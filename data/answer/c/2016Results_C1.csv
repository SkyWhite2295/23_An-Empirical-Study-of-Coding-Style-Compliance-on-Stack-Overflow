36759258,36759201,4,"<p>A forward declaration wouldn't allow you to do</p>

<pre><code>class A;

class B
{
    A a;
};
</code></pre>

<p>unless <code>A</code> is a reference or pointer type, since a forward declaration doesn't give any additional information on the size of the object (unless for <code>enum class</code> in C++11). So are you using pointers/references? Otherwise it means you are including the definition of <code>A</code> for sure.</p>

<p>Regarding your problem there is no way to forward declare and use a type since we're talking about two different things. A variable declaration doesn't define a type, it defines a variable.</p>

<p>A simple solution to your problem would be to gather all forward declaration in a single header file and include it in the project (or in your eventual precompiled header). This wouldn't create too much problems, since forward declarations don't expose anything nor they are heavyweight.</p>
",1
36759318,36759201,3,"<p>No, you can't do what you want. <a href=""https://stackoverflow.com/a/4757718/2589844"">This answer</a> about forward declarations should give you all the gory details, but in summary you need the full definition of a type if you want to use it (as including more or less does); not just the fact that it exists (as forward declaring more or less does).</p>
",1
36759363,36759201,5,"<p>What you're asking isn't completely clear but, if I understand you right, you can forward declare <em>at the same time</em> as declaring your variables:</p>

<pre><code>class B
{
    class A* a; // declaring A as class is an in-place forward declaration
};
</code></pre>

<p>Is that what you mean?</p>
",2
40752152,40751798,-1,"<p>The problem was with define in the top. I couldn't find it but now it is solved.</p>

<p>define directive should always be written so it can never be used by accident in code. The best way to do this is to use uppercase letters as it is reserved for preprocessor language. </p>

<p><a href=""https://stackoverflow.com/questions/15985542/error-declaration-does-not-declare-anything"">Error: declaration does not declare anything</a></p>
",2
42659368,42658513,0,"<p>To check ram usage as title asks; I can across this not long ago:</p>

<p><a href=""https://stackoverflow.com/q/26552223/7641490"">Get-Process with total memory usage</a></p>

<p>Unfortunately that's the only way I can help.</p>
",0
42661434,42658513,0,"<p>Regarding your question, if you are using Windows, there is no ""memory usage"" general counter for a process, but  the <em>""set of pages in the virtual address space of the process that are currently resident in physical memory"".</em></p>

<p>That is what is called the <em>Working set</em>.</p>

<p>The minimum and maximum working set of your process can be adjusted accordingly. Also, the current working set size can be obtained.</p>

<p>See the following Windows APIs:</p>

<p>GetProcessMemoryInfo: <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms683219(v=vs.85).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/ms683219(v=vs.85).aspx</a></p>

<p>To query and adjust working set limits:</p>

<p>GetProcessWorkingSetEx
<a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms683227(v=vs.85).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/ms683227(v=vs.85).aspx</a></p>

<p>SetProcessWorkingSetEx
<a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms686237(v=vs.85).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/ms686237(v=vs.85).aspx</a></p>

<p>For Linux systems, reading /proc/self/status will give you the same kind of information (which is called RSS: Resident Set Size). The RSS in the returned status is the 24th field.</p>
",0
42661454,42658513,0,"<p>You can split a file in two passes provided that the number of pieces is (somewhat) less than the maximum number of open files (which is usually configurable, by the way, so you probably can do better than 500).</p>

<p>You need a reasonably good hash function. Now suppose you want to split it into <em>N</em> pieces using at most <em>n</em> simultaneously open files, and suppose that <em>N</em> is less than <em>n</em>2. On the first pass, you open <em>n</em> temporary files, each of which is a hash bucket. You use the hash function to assign each symbol to one of these <em>n</em> buckets.</p>

<p>If your hash function is good, you will end up with very close to <em>N</em>/<em>n</em> symbols in each bucket. If <em>N</em> is a somewhat less than <em>n</em>2, then you shouldn't have more than <em>n</em> different symbols in each bucket and you can process each bucket individually in the second pass to split it into separate symbol files.</p>

<p>In your case <em>N</em> is about 10,000, which is a lot less than 5002. </p>

<p>Since the total size of the bucket files is the same as the size of the original file, you will end up reading all the data twice, which should be a good bit faster than reading it 20 times.</p>
",0
42658903,42658513,1,"<p>An HDD is <em>much</em> more effective in writing 1 large file instead of 100 small ones because it can dump data right after each other in 1 single swipe of the needle. I'm assuming you're using a HDD because of the amount of data you're talking about is kind of costly when talking about an SSD which would probably prolong the issue you're having.</p>

<p>The reason it is becoming slower is because your operating system is having difficulty iterating over many files. A database is much more effective as it is 1 big file (actually a couple, but less than 10). The end result is that your ""10gb"" or ""100gb"" files is a <em>lot</em> smaller because it doesn't have to write headers and treat files seperatly as it will be 1 huge blob of data.</p>

<p>If you can alter your application, then store data in a database instead. If not than you can create a simple script that would iterate over each file, store the data in the proper columns and the delete the file.</p>

<p>Keep in mind that when the file is currently being written in, it will have an <a href=""https://en.wikipedia.org/wiki/File_locking"" rel=""nofollow noreferrer""><code>file lock</code></a> in place. Check on that before you dump data into the database.</p>

<p>Storing the data in a database has advantages, all its data is accessible effortlessly.</p>
",0
38202730,37935990,0,"<p>Well, I used link from <a href=""https://stackoverflow.com/a/37936113/1237747"">this answer</a> and created such code. <a href=""https://gcc.godbolt.org/#compilers:!((compiler:g530,options:&#39;-std%3Dc%2B%2B14+-O2&#39;,source:&#39;int+main(int+i,+char**g)%0A%7B%0A+int+x+%3D+*g%5B0%5D%3B%0A++++++int+z+%3D+*g%5B1%5D%3B%0A++++++int+tmp+%3D+z+%3F+1+:+z%3B%0A++++++return+(x%3D%3D0%3Ftmp:x*tmp)%3B%0A%7D&#39;)),filterAsm:(commentOnly:!t,directives:!t,intel:!t,labels:!t),version:3"" rel=""nofollow noreferrer"">assembly here</a>, assembly is shorter, so might be faster, but needs profiling, because shorter assembly might not be faster.</p>

<pre><code>int main(int i, char**g)
{
  int x = *g[0];
  int z = *g[1];
  int tmp = z ? 1 : z;
  return (x==0?tmp:x*tmp);
}
</code></pre>
",0
47997244,47997195,1,"<p>The trailing const means that the ""this"" parameter in the function is also const. The implication of this is that no class state can be mutated in this function, and that the function cannot call other non-const member functions.</p>

<p>The function signature itself is overloading the [] operator. The return type for the function is ""const variable_value &amp;"". Overloading the [] operator allows you to index your class by whatever kind of indicies you'd like. Normally, [] is used by arrays to access elements (arr[1] == second element of array). With this overload, the class can be indexed with a string parameter (thatClass[""SomeString""]).</p>
",0
44738214,44738100,0,"<p>You can create global unordered_map and associate integer with function pointer. Something like this:</p>

<pre><code>std::unordered_map&lt;void(*)(void), int&gt; tmp;
</code></pre>

<p>As far as i remember standard guarantees, that function pointers for all types have the same size and since you just use function pointer to index into map, you can cast any function pointer (not pointer to member tho) to void (*)(void) and set / retrieve from unordered_map.</p>
",3
44738516,44738100,0,"<p>Based on Rados?aw Cybulski's answer, I have expanded this to a full working version:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;unordered_map&gt;

template &lt;typename Annotation&gt;
class FunctionAnnotation {
  public:
    template &lt;typename R, typename... Args&gt;
    Annotation get(R (*func)(Args...)) {
        return map_.at(strip(func));
    }

    template &lt;typename R, typename... Args&gt;
    void set(R (*func)(Args...), Annotation annotation) {
        map_[strip(func)] = annotation;
    }

  private:
    // Basic function pointer type.
    typedef void (*VoidFunc)();

    // Type stripping function that will take a function pointer and return a
    // function with the wrong but unified type.
    template &lt;typename R, typename... Args&gt;
    VoidFunc strip(R (*func)(Args...)) {
        return reinterpret_cast&lt;VoidFunc&gt;(func);
    }

    // The map with annotation values.
    std::unordered_map&lt;VoidFunc, Annotation&gt; map_;
};

FunctionAnnotation&lt;int&gt; flop_map;

// Some example functions.
void blas_routine(double *const dest, double const *const src) {}
void other(int a, int b) {}

int main() {
    // Populate that map.
    flop_map.set(blas_routine, 0);
    flop_map.set(other, 4);

    // Later on use that.
    std::cout &lt;&lt; flop_map.get(blas_routine) &lt;&lt; std::endl;
    std::cout &lt;&lt; flop_map.get(other) &lt;&lt; std::endl;
}
</code></pre>

<p>This compiles cleanly with GCC in C++11 and C++14 modes. The output is, as expected:</p>

<pre><code>0
4
</code></pre>
",0
44740395,44738100,1,"<p>I'd probably do something more like:</p>

<pre><code>#include &lt;type_traits&gt;
#include &lt;iostream&gt;

struct dummy { };

template &lt;class T&gt;
struct flop_map {
    static int value;
};

template &lt;class T&gt;
int flop_map&lt;T&gt;::value;

#define FOO_ID(foo) std::integral_constant&lt;decltype(&amp;foo), &amp;foo&gt;

void blas_routine(double *const, double const *const) {}
void other(int, int) {}

int main() {
    flop_map&lt;FOO_ID(blas_routine)&gt;::value = 0;
    flop_map&lt;FOO_ID(other)&gt;::value        = 4;

    std::cout &lt;&lt; flop_map&lt;FOO_ID(blas_routine)&gt;::value &lt;&lt; std::endl;
    std::cout &lt;&lt; flop_map&lt;FOO_ID(other)&gt;::value &lt;&lt; std::endl;
}
</code></pre>

<p><a href=""https://wandbox.org/permlink/uq6Wz207uw7aMu2R"" rel=""nofollow noreferrer"">[live demo]</a></p>
",2
42484287,42481977,0,"<p>Just write <code>static_assert(sizeof(Qwertyuiop)&gt;0, ""Qwertyuiop is defined"")</code>.</p>

<p>Obviously you can't check in one Translation Unit whether it's defined in another TU; that's incompatible with separate translation. TU's may be compiled in any order.</p>
",0
47970376,47970224,2,"<blockquote>
  <ol>
  <li>Is there an implicit cast <strong>from</strong> temporary values (values of built-in type, and temporary objects) <strong>to</strong> objects of type <code>rvalue reference</code>?</li>
  </ol>
</blockquote>

<p>First a nitpick, casts are explicit conversions by definition, so there cannot be an implicit cast. Beyond that, a reference is distinctly not an object type. It may even not require any storage. References are <em>bound</em> to objects. It'd be more appropriate to think about them as alternative <em>names</em> of objects. Rvalue references in particular can only bind to objects of a particular sort. Which are roughly all ""nameless"" and ""temporary"" values. We may also cast to an rvalue reference to force an object being designated as ""about to expire"".</p>

<p>There's however an intricate point here, once an rvalue reference binds to an object, it's no longer ""nameless"". In particular, this means that by using that reference we call an object ""by name"" and thus obtain an lvalue. Furthermore, and to coincide with that, binding a reference in block scope to a temporary, prolongs the lifetime of the temporary until the end of the scope. And that brings us to the next point.</p>

<blockquote>
  <ol start=""2"">
  <li>Does <code>a</code> has an address?</li>
  </ol>
</blockquote>

<p>Yes and no. The refernece itself may or may not require storage, as I said previously. But that's moot, since it's just the name of an object. Taking the address of a reference will yield the address of the object that was bound to it. In this case, it will be the address of the temporary bound to it.</p>
",5
38298113,38297626,1,"<p>This code maps a function over just the value part of a map's key/value pair:</p>

<pre><code>class Wrapper
{
public:
    void Apply(const std::function &lt;void (const std::string)&gt;&amp; functor)
    {
        for (auto i : _Map)
        {
            functor(i.second);
        }
    }
private:
    std::unordered_map&lt;int, std::string&gt;    _Map;
};
</code></pre>
",0
38297773,38297626,1,"<p>For the technical problem: pass a functor (e.g. a lambda) that invokes the client code's functor.</p>

<p>But do note that with a vector, if removing an object at a given index shifts the indices (id's) of the following objects, then the behavior with a map is different. So this change can break your existing client code. I.e. the problem can be more than just the technical one of adapting a lambda.</p>
",0
36238036,36238009,1,"<p>In your case, you can't, because <code>Child</code> and <code>Parent</code> have nothing in common except that they both inherit <code>Component</code>. <code>Child</code> has to have a <code>Parent</code> object in order to call <code>MethodToBeCalled()</code>.</p>
",3
36238193,36238009,3,"<p>Here's a example. I had to modify your code a bit to get it compile:</p>

<pre><code>class Component {};

class Parent;

class Child   : public Component
{
private:
    inline void myVoid();
    Parent &amp;parent_ref;

public:
    Child(Parent &amp;pr) : parent_ref{pr} {}
};

class Parent   : public Component {
private:
    Child child;

public:
    Parent() : child{*this}
    {
        // addChildComponent(child);
    }

    void MethodToBeCalled(int someArgument)
    {

    }
};

inline void Child::myVoid()
{
    parent_ref.MethodToBeCalled(1);
}
</code></pre>
",0
36238249,36238009,2,"<p>If you are sure that your <code>Child</code> object is a member subobject of <code>Parent</code> class (as in your example), you can use the <code>container_of</code> trick (see <a href=""https://stackoverflow.com/questions/15832301/understanding-container-of-macro-in-linux-kernel"">Understanding container_of macro in the Linux kernel</a>)</p>

<pre><code>class Child
{
private:
    void myVoid();
};

class Parent
{
public:
    Child child;

    void MethodToBeCalled(int someArgument)
    {
    }
};

void Child::myVoid()
{
    container_of(this, Parent, child)-&gt;MethodToBeCalled(42);
}
</code></pre>

<p>Obviously, tricks like this immediately restrict the usability of your <code>Child</code> class to always being a member of <code>Parent</code> class (at least when you intend to call <code>myVoid()</code> method on it). </p>

<p>A much better idea would be to just pass a reference to parent object to child object.</p>
",0
45784914,45784790,4,"<p>You could do:</p>

<pre><code>void pack_in_vector(std::vector&lt;std::uint8_t&gt;&amp; v, char c)
{
    v.push_back(c);
}

void pack_in_vector(std::vector&lt;std::uint8_t&gt;&amp; v, int n)
{
    v.push_back(n &amp; 0xFF);
    v.push_back((n &gt;&gt; 8) &amp; 0xFF);
    v.push_back((n &gt;&gt; 16) &amp; 0xFF);
    v.push_back((n &gt;&gt; 24) &amp; 0xFF);
}

void pack_in_vector(std::vector&lt;std::uint8_t&gt;&amp; v, const std::string&amp; s)
{
    for (c : s) {
        v.push_back(c);    
    }
}

template &lt;typename ... Ts&gt;
std::vector&lt;std::uint8_t&gt; pack(const Ts&amp;... args)
{
    std::vector&lt;std::uint8_t&gt; bytes;
    (pack_in_vector(bytes, args), ...); // Folding expression requires C++17
    return bytes;
}
</code></pre>

<p>For C++11, you have to modify last function to:</p>

<pre><code>template &lt;typename ... Ts&gt;
std::vector&lt;std::uint8_t&gt; pack(const Ts&amp;... args)
{
    std::vector&lt;std::uint8_t&gt; bytes;

    int dummy[] = {0, (pack_in_vector(bytes, args), 0)...};
    static_cast&lt;void&gt;(dummy); // avoid warning for unused variable
    return bytes;
}
</code></pre>
",4
45788387,45784790,1,"<pre><code>template&lt;class F&gt;
void range_to_bytes( F&amp;&amp; f, char const* begin, char const* end ){
  for(auto*it=begin; it != end; ++it)
    f(*it);
}
template&lt;class F&gt;
void to_bytes( F&amp;&amp; f, char c ){
  range_to_bytes(f, &amp;c, &amp;c+1);
}
template&lt;class F&gt;
void to_bytes( F&amp;&amp; f, int i ){
  range_to_bytes(f, (const char*)(&amp;i), (const char*)(&amp;i+1));
}
template&lt;class F&gt;
void to_bytes( F&amp;&amp; f, char const* str ){
  range_to_bytes(f, str, str+strlen(str));
}
template&lt;class F, class...Ts&gt;
void to_bytes( F&amp;&amp; f, Ts const&amp;... ts ){
  using discard=int[];
  (void)discard{0,(void(
    to_bytes(f, ts)
  ),0)...}
}
template&lt;class...Ts&gt;
std::vector&lt;char&gt; to_vector_bytes( Ts const&amp;... ts ){
  std::size_t count = 0;
  to_bytes([&amp;](char){++count;}, ts...);
  std::vector&lt;char&gt; r;
  r.reserve(count);
  to_bytes([&amp;](char c){r.push_back(c);}, ts...);
  return r;
}
</code></pre>
",0
36268122,36268066,2,"<p>It doesn't matter where they're allocated. Somewhere in memory on your computer, or perhaps not at all if they're optimised out. Don't worry about it.</p>

<p><a href=""https://stackoverflow.com/q/6466253/560648"">They're <em>not</em> immutable</a> &mdash; you could modify them if you like (try <code>std::string().append('!')</code>); it's just that you're only allowed to bind a temporary to a <em>reference</em> if it's a reference-to-<code>const</code>. And if you don't bind it to a reference, you can't actually name it later to do anything with it.</p>

<p><a href=""https://stackoverflow.com/q/13826897/560648"">This limitation was intended to prevent programmer mistakes</a>, because modifying a temporary is usually pointless, though Visual Studio relaxes that restriction. However, <a href=""https://stackoverflow.com/a/20982301/560648"">you can still make use of this lifetime-extension without <code>const</code> by using an rvalue reference</a>:</p>

<pre><code>std::string&amp;&amp; ref = std::string();
ref.append('!');
std::cout &lt;&lt; ref &lt;&lt; '\n';
</code></pre>

<p><em>Why</em> would you do it? Who knows.</p>

<p>As for your final question (one question per question please next time), no, those two references refer to two, unrelated, temporary <code>std::string</code> objects.</p>
",4
42605708,42605642,1,"<p>When classes are constructed, the order of construction is firstly, to initialise any base classes, then to initialise the data members in the order they appear in the class definition. The order they appear in the constructors' initialisation lists is not considered.</p>

<p>This rigid rule makes sense because syntactically, there's nothing wrong with initialising data members and then calling the base class' constructor, yet could lead to havoc.</p>

<p>Seeing as your public <code>albumService</code> member requires a fully constructed <code>mDatabase</code>, you unfortunately will have to arrange them in the less-sightly way you have in the second class definition.</p>
",1
45749102,45748592,0,"<p>As suggested in comments by Retired Ninja. the variable dwRecv needs to initialize, after initializing the variable the program works. thanks.</p>
",0
42640029,42639995,2,"<p>You can check that <code>size == 0</code>. So, there are no any iterations in both <code>for</code>-loops.</p>

<p>To fix it you need to move the line <code>vec_sz size = words.size();</code> few lines lower.</p>

<p>Try this order:</p>

<pre><code>cout &lt;&lt; ""Sentence: "";
while(cin &gt;&gt; input) {
    words.push_back(input);
}

vec_sz size = words.size();
</code></pre>

<p>Also there is a mistake it logic in your <code>for</code>-loops. You need to reset <code>count</code> each time (just add <code>count = 0;</code> right before internal loop to have correct results).</p>

<p>You can check how it works here: <a href=""http://ideone.com/T2cPcH"" rel=""nofollow noreferrer"">http://ideone.com/T2cPcH</a> (with the mistake with initialization of <code>count</code>)</p>
",3
42660161,42639995,1,"<p>The size variable is read <strong>before</strong> you insert anything into it. Therefore it's value is 0 at the point you read it. If it were to make it to the for loop at the bottom that loop will run no iterations <code>0 &lt; (0 - 1)</code> is false.</p>

<p>You can do away with your <code>size</code> variable. <code>vector::size</code> is a constant time operation. There is no overhead from calling it.</p>

<p>Also I changed how you read lines from the <code>cin</code>. Now it will read the line using <code>std::getline</code>. The line could have multiple words on one line, so it uses a <code>stringstream</code> to read each word out of the line and insert that into the vector.</p>

<p>There is another container called <code>multiset</code>, which may suit your needs better in terms of counting words. </p>

<p>An even better way would be to use an <code>unordered_dict</code> which can be used to hold a count for each string. It works because when you insert a new entry int the <code>unordered_map</code> it's int value will default to 0, so you can safely always apply an increment operation to it. </p>

<p>Examples below.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;unordered_map&gt;

// don't do this in a header file!!
using namespace std;

void basic()
{
    string input;
    vector&lt;string&gt; words;

    cout &lt;&lt; ""Sentence: "";

    if(std::getline(std::cin, input))
    {
        istringstream ss(input);
        string word;

        while(ss &gt;&gt; word){
            words.push_back(word);
        }
    }

    for(const auto&amp; word: words) {
        int count = 0;
        for(const auto&amp; word2: words) {
            if(word == word2) {
                ++count;
            }
        }
        cout &lt;&lt; ""The word "" &lt;&lt; word &lt;&lt; "" appears "" &lt;&lt; count &lt;&lt; "" times.\n"";
    }
}

void better()
{
    multiset&lt;string&gt; ms;
    string input;

    cout &lt;&lt; ""Sentence: "";

    if(std::getline(std::cin, input))
    {
        istringstream ss(input);
        string word;

        while(ss &gt;&gt; word){
            ms.insert(word);
        }
    }

    for(auto it = ms.begin(), end = ms.end(); 
        it != end; 
        it = ms.upper_bound(*it))
    {
        cout &lt;&lt; *it &lt;&lt; ""'count="" &lt;&lt; ms.count(*it) &lt;&lt; '\n';
    }
}

void best()
{
    unordered_map&lt;string, int&gt; counter;
    string input;

    cout &lt;&lt; ""Sentence: "";

    if(std::getline(std::cin, input))
    {
        istringstream ss(input);
        string word;

        while(ss &gt;&gt; word){
            counter[word]++;
        }
    }

    for(const auto&amp; it: counter)
    {
        cout &lt;&lt; it.first &lt;&lt; ""'count="" &lt;&lt; it.second &lt;&lt; '\n';
    }
}

int main() 
{
    //basic();
    //better(); 
    best();   
}
</code></pre>
",0
36313786,36313446,5,"<p>[update 1 - boost 'semi' solution]</p>

<p>I realized that example from my first answer does not work if your class has conversion operator (to type which allows for != comparision), to fix it you can use boost <a href=""http://www.boost.org/doc/libs/1_53_0/libs/type_traits/doc/html/boost_typetraits/reference/has_not_equal_to.html"" rel=""nofollow"">has_not_equal_to</a> type trait. Still its not perfect, as in some cases it generates compilation error instead of giving a value. Those cases are listed in provided link.</p>

<p>[update 2 - concepts solution]</p>

<p>Example with use of concepts:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

template&lt;typename T&gt;
concept bool OperatorNotEqual_comparable()
{
    return requires (T a, T b) {
        { a.operator!=(b) } -&gt; bool;
    };   
}

template &lt;OperatorNotEqual_comparable T&gt;
static bool equals(const std::vector&lt;T&gt; &amp;a, const std::vector&lt;T&gt; &amp;b) {
  if (a.size() != b.size())
    return false;

  for (size_t i = 0; i &lt; a.size(); ++i)
    if (a[i] != b[i]) // Requires that the != operator is supported by the template type.
      return false;

  return true;
}

struct sample1{
    bool operator!=(const sample1&amp;) const { return true; }
};

struct sample2{
};

struct sample3{
    operator void*() { return 0; }
};

int main() {
    // Compiles ok!
    std::vector&lt;sample1&gt; vec1;
    equals(vec1, vec1);

    // Fails, which is OK!
    //std::vector&lt;sample2&gt; vec2;
    //equals(vec2, vec2);    

    // Fails, which is OK!
    //std::vector&lt;sample2*&gt; vec2;
    //equals(vec2, vec2);

    // Fails, which is OK!
    //std::vector&lt;int&gt; vec4;
    //equals(vec4, vec4);        

    // Fails, which is OK!
    //std::vector&lt;sample3&gt; vec5;
    //equals(vec5, vec5);            
}
</code></pre>

<p><a href=""http://melpon.org/wandbox/permlink/txliKPeMcStc6FhK"" rel=""nofollow"">http://melpon.org/wandbox/permlink/txliKPeMcStc6FhK</a></p>

<p>[old answer - SFINAE solution, does not check for conversion operator]</p>

<p>You can use SFINAE, and in the near future concepts (they are in gcc 6.0),</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;type_traits&gt;

template&lt;typename T&gt;
class has_not_equal{
    template&lt;typename U&gt;
    struct null_value{
        static U&amp; value;
    };

    template&lt;typename U&gt;
    static std::true_type test(U*,decltype(null_value&lt;U&gt;::value!=null_value&lt;U&gt;::value)* = 0);
    static std::false_type test(void*);

public:
    typedef decltype(test(static_cast&lt;T*&gt;(0))) type;
    static const bool value = type::value;
};

struct sample1{
    bool operator!=(const sample1&amp;) { return true; }
};

struct sample2{
};

int main(){
    std::cout&lt;&lt;std::boolalpha;
    std::cout&lt;&lt;has_not_equal&lt;int&gt;::value&lt;&lt;std::endl;
    std::cout&lt;&lt;has_not_equal&lt;std::string&gt;::value&lt;&lt;std::endl;

    std::cout&lt;&lt;has_not_equal&lt;sample1&gt;::value&lt;&lt;std::endl;
    std::cout&lt;&lt;has_not_equal&lt;sample2&gt;::value&lt;&lt;std::endl;
}
</code></pre>

<p>output:</p>

<pre><code>g++ -std=c++14 -O2 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out
true
true
true
false
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/c9064ce77ea61e10"" rel=""nofollow"">live</a></p>

<p>above code is a modified version from this <a href=""http://dixq.net/forum/blog.php?u=673&amp;b=2137"" rel=""nofollow"">site</a>, it was for <code>operator==</code>, I changed it to <code>operator!=</code></p>
",4
36314139,36313446,1,"<p>If <code>T</code> has no <code>operator !=</code>, then the template wont get instantiated for that type, but you will get a (possibly horribly long and unreadable) error message from your compiler. On the other hand, it <code>T</code> has a <code>operator !=</code>, then it should be just fine to use it. There wont be silent wrong result, unless <code>T</code>s <code>operator !=</code> is anyhow broken.</p>
",0
36318096,36313446,1,"<p>If you are interested in check whether there is an operator != defined in a class (and it has precisely given signature) you may want this approach (tests taken from marcinj's code):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;type_traits&gt;

template &lt;class T, class = void&gt;
struct has_not_equal: std::false_type { };

template &lt;class T&gt;
struct has_not_equal&lt;T, typename std::enable_if&lt;std::is_same&lt;decltype(static_cast&lt;bool (T::*)(const T&amp;)const&gt;(&amp;T::operator!=)), bool (T::*)(const T&amp;)const&gt;::value&gt;::type &gt;: std::true_type { };

struct sample1{
    bool operator!=(const sample1&amp;) const { return true; }
};
struct sample2{
};
struct sample3:sample2 {
  bool operator!=(const sample2&amp; b) const { return true; }
};

struct sample4:sample2 {
  bool operator!=(const sample2&amp; b) const { return true; }
  bool operator!=(const sample4&amp; b) const { return true; }
};

int main(){

    std::cout&lt;&lt;std::boolalpha;
    std::cout&lt;&lt;has_not_equal&lt;int&gt;::value&lt;&lt;std::endl;
    std::cout&lt;&lt;has_not_equal&lt;std::string&gt;::value&lt;&lt;std::endl;

    std::cout&lt;&lt;has_not_equal&lt;sample1&gt;::value&lt;&lt;std::endl;
    std::cout&lt;&lt;has_not_equal&lt;sample2&gt;::value&lt;&lt;std::endl;
    std::cout&lt;&lt;has_not_equal&lt;sample3&gt;::value&lt;&lt;std::endl;
    std::cout&lt;&lt;has_not_equal&lt;sample4&gt;::value&lt;&lt;std::endl;
}
</code></pre>

<p>Output of the program:</p>

<pre><code>false
false
true
false
false
true
</code></pre>

<p>You may easily add allowed operator != overloads by adding specialization of the has_not_equal struct...</p>
",0
36314359,36313446,0,"<blockquote>
  <p>If someone uses a type without overloading it might end up using a simple binary comparison which might silently lead to wrong results. </p>
</blockquote>

<p>There's not such thing as ""binary comparison"" in C++. Either your class/struct has <code>operator!=</code> or the template won't be instantiated (and if there are no other candidates then it will be an error). </p>
",0
36314827,36313446,1,"<p>The only other (besides the conversion) case (I can think of) where a binary comparison can happen (has <code>operator!=</code> defined) and lead to silently wrong results is when <code>T</code> is actually a pointer and you expect a ""deep comparison"".</p>

<p>One could add an overload for vectors containg pointers but that wouldn't cover pointer to array storage.</p>

<pre><code>template &lt;typename T&gt;
static bool equals(const std::vector&lt;T&gt; &amp;a, const std::vector&lt;T&gt; &amp;b) 
{
  return std::equal(a.begin(), a.end(), b.begin());
}

template &lt;typename T&gt;
static bool equals(const std::vector&lt;T *&gt; &amp;a, const std::vector&lt;T *&gt; &amp;b) 
{
  return std::equal(a.begin(), a.end(), b.begin() 
    [](T* ap, T* bp) -&gt; bool { return *ap == *bp; });
}
</code></pre>
",0
36329603,36313446,1,"<p>Even though the title of my question here says I'm looking for a way to determine if the != operator is defined, the real question (as you can read from the description and my comment) was how to ensure that I don't silently get wrong results for a type T which has no != operator defined. The existing answers brought up good points, but the real answer is this:</p>

<p>1) You will get a compiler error on the <code>if (a[i] != b[i])</code> line if you instantiate the template with a value type array using a type that's missing the <code>!=</code> operator override (e.g. <code>std::vector&lt;sample2&gt;</code> from marcinj's answer) or you get hard to understand compiler error if you use <code>std::equal</code> instead. In this case the explicit comparison is much more helpful when looking for a solution.</p>

<p>2) If you have a reference type in the vectors to compare you will at first get no problem at all (since there are comparison operators defined for references, even though they only do a flat comparison via the address values). If you want to ensure that the comparison works as if you had used value types (including deep comparison) then add a specialization for vectors with pointer types, as pointed out by Pixelchemist. However, I cannot get the std::equals variants to compile at the moment.</p>

<p>At the end the solution that works for me is this:</p>

<pre><code>template &lt;typename T&gt;
static bool equals(const std::vector&lt;T&gt; &amp;a, const std::vector&lt;T&gt; &amp;b) {
  if (a.size() != b.size())
    return false;

  for (size_t i = 0; i &lt; a.size(); ++i)
    if (a[i] != b[i])
      return false;

  return true;
}

template &lt;typename T&gt;
static bool equals(const std::vector&lt;T*&gt; &amp;a, const std::vector&lt;T*&gt; &amp;b) {
  if (a.size() != b.size())
    return false;

  for (size_t i = 0; i &lt; a.size(); ++i)
    if (*a[i] != *b[i])
      return false;

  return true;
}
</code></pre>

<p>Tested with the sample1/2/3/4 structs from marcinj's answer. It's important to note that the operator overloading must use a value type (<code>operator == (const sample1&amp;)</code>) instead of a reference type.</p>

<p>I have still upvoted all answers that gave me useful information to get the final answer.</p>
",0
37450636,37450576,2,"<p>That is the standard incantation for ""access an array element and advance to the next one"". It's directly analogous to doing something like <code>foo[i++]</code> for iterating through an array.</p>

<p>The expression itself parses as</p>

<pre><code>*(foo++) = '\0';
</code></pre>

<p><code>foo++</code> means ""increment foo, but use its current value in this expression"". Thus, this expression assigns <code>'\0'</code> to the <code>char</code> object that <code>foo</code> is <em>currently</em> pointing to, and advances <code>foo</code> to point to the next element.</p>
",0
37450614,37450576,5,"<p>This line:</p>

<pre><code>*foo++ = '\0';
</code></pre>

<p>sets the character that <code>foo</code> points to to the value <code>'\0'</code> (the null character), and then moves the pointer so that it points to the next character. It is equivalent to:</p>

<pre><code>*foo = '\0';
foo = foo + 1;
</code></pre>
",0
37450878,37450576,0,"<p>The previous answers are correct: <code>foo</code> is pointing to a tab in <code>sStr</code>, so the line <code>*foo++ = '\0';</code> replaces the tab with a NUL and advances <code>foo</code> to point to the next character.</p>

<p>The reason you might do this is to parse a line of text into tab-separated fields.  I would be surprised if the <code>/* more code */</code> wasn't doing that (<em>i.e.</em>, recording pointers to the beginnings of fields, and separating them by replacing the tabs with NULs.)</p>
",0
48026296,48026143,1,"<p><code>reinterpret_cast</code> here should be safe. The latest Standard draft says:</p>

<blockquote>
  <p><a href=""http://eel.is/c++draft/expr.reinterpret.cast"" rel=""nofollow noreferrer"">[expr.reinterpret.cast]</a></p>
  
  <p>An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue <code>v</code> of object pointer type is converted to the object pointer type ¡°pointer to cv <code>T</code>¡±, the result is <code>static_-cast&lt;cv T*&gt;(static_-cast&lt;cv void*&gt;(v))</code>. [?Note: Converting a prvalue of type ¡°pointer to <code>T1</code>¡± to the type ¡°pointer to <code>T2</code>¡± (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value. ¡ª?end note?]</p>
</blockquote>

<p>Related questions:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/13466556/aligned-storage-and-strict-aliasing"">aligned_storage and strict aliasing</a></li>
</ul>
",1
48026940,48026143,1,"<p>Unfortunately this is forbidden by the standard. In the C++ standard <code>reinterpret_cast</code> from one pointer to an object <em>a</em> to another object <em>b</em> of different type is stated to be valid only when the two object are <em>pointer interconvertible</em>, <a href=""http://eel.is/c++draft/basic.compound#4"" rel=""nofollow noreferrer"">[basic.compound]/4</a>:</p>
<blockquote>
<p>Two objects a and b are <em>pointer-interconvertible</em> if:</p>
<ul>
<li><p>they are the same object, or</p>
</li>
<li><p>one is a union object and the other is a non-static data member of that object ([class.union]), or</p>
</li>
<li><p>one is a standard-layout class object and the other is the first non-static data member of that object, or, if the object has no non-static data members, the first base class subobject of that object ([class.mem]), or</p>
</li>
<li><p>there exists an object c such that a and c are pointer-interconvertible, and c and b are pointer-interconvertible.</p>
</li>
</ul>
<p>If two objects are pointer-interconvertible, then they have the same address, and it is possible to obtain a pointer to one from a pointer to the other via a <code>reinterpret_-cast</code>. [?Note: An array object and its first element are not pointer-interconvertible, even though they have the same address. ¡ª?end note?]</p>
</blockquote>
<p>The fact that a pointer has the right type and right value (memory address) does not make it a valid pointer. The canonical example of such surprising behavior is this:</p>
<pre><code>alignas(int) unsigned char buff[2*sizeof(int)];
auto p1 = new(buff) int{};
auto p2 = new(buff+sizeof(int)) int{};
*(p1+1) = 10;//Undefined behavior
//p1+1 does not point to *p2 even if p1 and p2 have same type and value.
</code></pre>
<p>So, to be standard compliant, you must store the value of the pointer returned by <code>new</code>.</p>
<hr />
<p>I found a good solution that consists to cast the pointer to an integer type and that to an other pointer type, that will cause an <em>implementation defined behavior</em> (<a href=""http://eel.is/c++draft/expr.reinterpret.cast#5"" rel=""nofollow noreferrer"">[expr.reinterpret_cast]/5</a>):</p>
<pre><code>reinterpret_cast&lt;MyStruct*&gt;(reinterpret_cast&lt;std::uintptr_t&gt;(addressof(g_storage));
</code></pre>
",3
43942120,43942067,-1,"<p>Store them in the way that makes the most semantic sense and let the optimizing compiler do what it's good at. If you need fixed-width 16-bit types you should also consider using the <code>&lt;cstdint&gt;</code> types like <code>uint16_t</code>; <code>unsigned short</code> is not guaranteed to always be 16 bits.</p>

<p>Related:
<a href=""https://softwareengineering.stackexchange.com/questions/80084/is-premature-optimization-really-the-root-of-all-evil"">https://softwareengineering.stackexchange.com/questions/80084/is-premature-optimization-really-the-root-of-all-evil</a></p>
",1
34922972,34922923,1,"<p>This is because of name hiding.</p>

<p>Declaring a function in a derived class with the same name as those in the base class <em>hides</em> the ones in the base class.</p>

<p>If you also want to be able to call <code>void foo(int)</code> on <code>Derived</code>, put in a using-declaration:</p>

<pre><code>class Derived: public Base {
public:
  using Base::foo; //here
  virtual void foo(int a, int b) {}
};
</code></pre>
",0
35268503,35268230,5,"<p>The preprocessor directives are evaluated at compile time, you cannot change the code in runtime.
If you compile the library and DEFINE_FIVE is not defined, the preprocessor will in first pass replace your code to the following:</p>

<pre><code>// head.cpp
int MyClass::obtain_value()
{
     return 6;    
}
</code></pre>

<p>As you can see, it will parse and remove all preprocessor directives. Then, the real compiling stage starts with machine code generation.</p>

<p>If you want dynamic values in your library, you have to change your interface, for example:</p>

<pre><code>// head.h
class __declspec(dllexport) MyClass
{

    public:
          int obtain_value(bool give_me_five=false);

};

// head.cpp
 int MyClass::obtain_value(bool give_me_five)
{
     if (!give_me_five)
        return 6;
     else return 5;
}
</code></pre>
",0
35268961,35268230,1,"<p>you can use <code>/D</code> switch in visual studio to define <code>DEFINE_FIVE</code> and you will get your desired result.</p>

<pre><code>goto properties --&gt; C/C++ --&gt; preprocessor --&gt; preprocessor definations --&gt; DEFINE_FIVE
</code></pre>

<p>the during compile time <code>DEFINE_FIVE</code> will be defined and you will get <code>return 5</code>. </p>
",0
35270869,35268230,0,"<p>The other answers are perhaps a bit pessimistic. You can create a replacement DLL, which <a href=""https://blogs.msdn.microsoft.com/oldnewthing/20060719-24/?p=30473/"" rel=""nofollow"">forwards</a> every function to the original DLL <em>except</em> <code>int MyClass::obtain_value()</code>, for which you provide a new implementation.</p>

<p>Downside: direct calls to <code>obtain_value</code> from inside the class won't go through the replacement DLL, which can lead to hard-to-debug errors. This is because you will have two copies of <code>int MyClass::obtain_value()</code> from two DLLs in one process.</p>
",0
45666958,45666863,0,"<p>Ah, I think I <a href=""https://stackoverflow.com/questions/30479383/uniform-initialization-in-return-statement-and-explicit-conversion-operator-to-b#comment49038727_30479383"">found the reason in the comments to another question</a>. It's because I'm using an initializer list.</p>

<p>If I switch the code to:</p>

<pre><code>size_t actual_size = vec.size(); // this should be a compiler error
</code></pre>

<p>Then I get the much clearer error:</p>

<pre><code>$  g++ --stdlib=libc++ -std=c++1y -Wall -Wextra -Werror keyed_vector_example.cpp
keyed_vector.cpp:28:10: error: no viable conversion from 'size_type' (aka 'my_size_type') to 'size_t' (aka 'unsigned long')
  size_t actual_size = vec.size(); // this should be a compiler error
         ^             ~~~~~~~~~~
1 error generated.
</code></pre>

<p>It looks like other compilers give a better error message for braced initializer lists, so if this really bothers me I should file an issue with clang.</p>
",0
46094272,46094125,4,"<p>Unfortunately you've wandered into one of the areas of the standard that's a little archaic and seemingly without any overarching design goals.</p>
<p>This is undoubtedly historic as the iostreams library AFAIAA, was not originally part of the STL which is what became the standard library.</p>
<p>It's worth reading the notes on all <code>std::ios_base</code> members and the associated manipulators.</p>
<p>For example:</p>
<p><a href=""http://en.cppreference.com/w/cpp/io/ios_base/width"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/io/ios_base/width</a></p>
<blockquote>
<p>Some I/O functions call width(0) before returning, see std::setw (this results in this field having effect on the next I/O function only, and not on any subsequent I/O)</p>
<p>The exact effects this modifier has on the input and output vary between the individual I/O functions and are described at each operator&lt;&lt; and operator&gt;&gt; overload page individually.</p>
</blockquote>
<p>Anticipating:</p>
<blockquote>
<p>But that's just &lt;insert expletive&gt;!!!</p>
</blockquote>
<p>A: yup.</p>
",3
47658088,47657442,1,"<pre><code>void GetFirstChar(const WCHAR* my_string)
{
    wchar_t newstr[2];
    newstr[0] = *my_string;
    newstr[1] = 0;
}
</code></pre>
",0
40537032,40536742,3,"<p>You have to pass all the <code>.cpp</code> files to the compiler command. It's strongly discouraged to include <code>.cpp</code> files in other <code>.cpp</code> files.</p>

<p>The command line that is likely to work for you is:</p>

<pre><code>g++ -ISeqLib -o my_executable rcpp_hello_world.cpp SeqLib/src/FermiAssembler.cpp
</code></pre>

<p>If you have a lot of files, it is advised to create a makefile script to avoid recompiling all the code every time.</p>

<p>if your <code>FermiAssembler</code> product contains <code>Makefile.am/in</code> files, it can build itself using a <code>configure</code> script which is probably here. The general idea is the:</p>

<pre><code>cd SeqLib
./configure
make
</code></pre>

<p>If it's a library product, it builds as a <code>.a</code> or <code>.so</code> file. In that case, the command line becomes:</p>

<pre><code>g++ -ISeqLib -o my_executable rcpp_hello_world.cpp SeqLib/bin/FermiAssembler.a
</code></pre>

<p>(I'm just gessing the path &amp; name of the output library file)</p>

<p>To include .a files from there, just add their path. Not sure that <code>SeqLib/bin/*.a</code> would do it because lib dependencies don't follow alphabetical order. A very bruteforce thing that would work would be specifying <em>all</em> <code>.a</code> files twice (so inter-lib dependencies would work):</p>

<pre><code>g++ -ISeqLib -o my_executable rcpp_hello_world.cpp SeqLib/bin/*.a SeqLib/bin/*.a
</code></pre>

<p>it would be better, though, to include only the required <code>.a</code> files, respecting the following order: first the ones depending on the following ones. The last library mustn't depend of any of the previous ones.</p>
",3
45784526,45783600,1,"<p>If you are ok with preprocessor definitions you could do this:</p>

<pre><code>// header.h
#ifndef CLASSID
#define CLASSID 0
#endif
static int id=CLASSID;

// class.cpp
#define CLASSID 1
#include ""header.h""
</code></pre>

<p>This way a source file may override the default, but may also omit it, which is the sort of <em>weak</em> approach you mentioned.</p>
",1
41935713,41935630,5,"<p>No there isn't. An explicit <code>=</code> operator invokes <code>operator=()</code> on a class that declares a suitable <code>operator=</code> method, exactly as if the <code>operator=</code> method was invoked directly.</p>

<p>This is true for all operators, not just <code>=</code>. That's the very definition of what an <code>operator</code> class method means: it specifies what gets executed when the corresponding operator is applied to an instance of the class.</p>
",1
41935981,41935630,4,"<p>Other than in <em>copy-initialization contexts</em>, the short operator expression is equivalent to the functional expression.
<a href=""http://eel.is/c++draft/over#tab:over.rel.op.func"" rel=""nofollow noreferrer"">Table 12</a> of the C++ standard draft describes the operator expressions:</p>

<p>Reproduced:</p>

<pre><code>Subclause       Expression      As member function         As non-member function

[over.unary]  |     @a    |     (a).operator@ (?)      |    operator@(a)
[over.binary] |     a@b   |     (a).operator@ (b)      |    operator@(a, b)
[over.ass]    |     a=b   |     (a).operator= (b)      |
[over.sub]    |     a[b]  |     (a).operator[](b)      |
[over.ref]    |     a-&gt;   |     (a).operator-&gt;(?)      |
[over.inc]    |     a@    |     (a).operator@ (0)      |    operator@(a, 0)
</code></pre>

<p>Where <code>@</code> is a placeholder for the operator.</p>

<hr>

<p>Of cause, there are other <em>contextual</em> use of the <code>=</code> operator; in function declarations, such as <em>defaulted</em> member functions, <em>deleted</em> functions and <code>= 0; // pure virtual</code></p>
",0
41936210,41935630,1,"<p>There are tiny differences, because <code>a = b</code> does not always invoke an <em>explicit</em> operator on object <code>a</code>:</p>

<ul>
<li><code>T a = b;</code>. It is not an assignment but an initialization: it invokes a copy (or move) construction</li>
<li><code>a = b;</code> when a is an intrinsic object (integer, pointer, floating point, ...): the <code>=</code> operator is a <em>builtin</em> one.</li>
<li>if <code>T</code> is trivially copyable, the assignement is allowed even when no <code>operator =</code> has been declared on the class, because the compiler use the default builtin assignement operator.</li>
</ul>

<p>But if an <code>operator =</code> method exists and is selected by the overload resolution rules, the assignment operator will invoke it.</p>
",0
38393880,38393792,1,"<p><strong><a href=""http://coliru.stacked-crooked.com/a/72fee651d09349ea"" rel=""nofollow"">It's invalid</a></strong>, because the variable and the type are in different scopes.</p>

<p><a href=""http://coliru.stacked-crooked.com/a/bfb1d0c11b9e18f1"" rel=""nofollow"">Hiding kicks in only when they're in the same scope</a>:</p>

<blockquote>
  <p><code>[C++14: 3.3.10/2]:</code> A class name (9.1) or enumeration name (7.2) can be hidden by the name of a variable, data member, function, or enumerator declared in the same scope. If a class or enumeration name and a variable, data member, function, or enumerator are declared in the same scope (in any order) with the same name, the class or enumeration name is hidden wherever the variable, data member, function, or enumerator name is visible.</p>
</blockquote>

<p>Clang and Visual Studio are wrong.</p>
",5
41650963,41650945,4,"<p>A reference allows you to alter the value referred to. This follows the behaviour of other containers in the Standard Library.</p>

<p>Then the question becomes: why not return a reference?</p>
",0
41651198,41650945,3,"<p>Because the <code>back()</code> function on standard containers gives you a reference to the last element, so that you can do things with that element.</p>

<p><code>std::string</code> provides you with the same interface.</p>

<p>Why shouldn't it?</p>
",0
38398376,38398264,1,"<p>The first is OK, temporary's lifetime is extended when assigned to a reference. Second is UB AFAIK, because <code>{ { 1, 2 } }</code> is a <code>std::initializer_list&lt;&gt;</code>, not a <code>std::vector&lt;&gt;</code> directly. Prolonging lifetime temporary objects is not transitive (i.e., it lasts till the end of <em>current</em> function, in this case, the constructor), only local ones get prolonged.</p>
",0
38398378,38398264,1,"<p>It works on gcc by accident, because this is definitely undefined behavior.</p>

<p>In order to satisfy <code>B</code>'s initialization, the compiler needs to construct a temporary <code>vector&lt;int&gt;</code>. Since the reference to that vector is <code>const</code>, the compiler does not see a problem with using it to initialize <code>B</code>. However, the temporary object becomes invalid as soon as the initialization is over, so accessing it by reference outside of initialization is undefined behavior.</p>
",0
45094630,45094556,4,"<p>Functions defined in an anonymous namespace in a .cpp file are like private functions. They are not meant to be reused in another .cpp file.</p>

<p>If you find that they can be reused by another .cpp file, those functions need to be declared in a .h file and defined in the appropriate .cpp file.</p>

<p>Whether you declare the functions in Common.h, A.h, or B.h, depends entirely up to you. The names of the functions in your posted code don't give much clue as to which .h file will be best to contain those declarations.</p>

<p>If you declare them in Common.h, I suggest that you implement them in Common.cpp.</p>

<p>If you declare them in A.h, I suggest that you implement them in A.cpp.</p>

<p>If you declare them in B.h, I suggest that you implement them in B.cpp.</p>
",0
41919668,41727129,1,"<p>Assuming that you're calling save() on a temporary file for each edit of the  diagram (even if user doesn't explicitly call the <strong>save</strong> action) and that you undo only the latest action, you can do as follows:</p>

<pre><code>LastDiagram load(const std::string &amp;path)
{
  /* Check for valid path (e.g. boost::filesystem here) */
  if(!found)
  {
    throw std::runtime_exception{""No diagram found""};
  } 
  //read LastDiagram
  return LastDiagram;
}
LastDiagram undoLastAction()
{
    return loadLastDiagram(""/tmp/tmp_diagram_file"");
}
</code></pre>

<p>and in your main app you handle the exception if thrown. In case you want to allow more undos, then you should think to a solution like sqlite or a tmp file with more entries. </p>

<p>If performance in time and space are issues due large diagrams, think to implement some strategy like keeping an incremental difference for each element of a diagram in a std::vector (limit it to 3/5 if objects are big) and call the renderer with the current statuses. I'm not an OpenGL expert, but I think it's the way it's done there. Actually you could 'steal' this strategy from game development best practices, or generally graphics related ones.</p>

<p>One of those strategies could be something like this:</p>

<p><a href=""http://www.academia.edu/1070596/A_structure_for_efficient_update_incremental_redisplay_and_undo_in_graphical_editors"" rel=""nofollow noreferrer"">A structure for efficient update, incremental redisplay and undo in graphical editors</a></p>
",3
41927362,41727129,7,"<p>Two reasonable approaches to this problem are implemented in the frameworks <a href=""https://irisate.com/flip-overview/"" rel=""nofollow noreferrer"">Flip</a> and <a href=""http://www.codesynthesis.com/products/odb/"" rel=""nofollow noreferrer"">ODB</a>.</p>

<h3>Code-generation / ODB</h3>

<p>With ODB you need to add <code>#pragma</code> declarations to your code, and have it's tool generate methods that you use for save/load and for editing the model, like so:</p>

<pre><code>#pragma db object
class person
{
public:
    void setName (string);
    string getName();
    ...
private:
    friend class odb::access;
    person () {}

    #pragma db id
    string email_;

    string name_;
 };
</code></pre>

<p>Where the accessors declared in the class are auto-generated by ODB so that all changes to the model can get captured and undo-transactions may be made for them.</p>

<h3>Reflection with minimal boilerplate / Flip</h3>

<p>Unlike ODB, Flip doesn't generate C++ code for you, but rather it requires your program to call <code>Model::declare</code> to re-declare your structures like so:</p>

<pre><code>class Song : public flip::Object
{
public:
    static void declare ();
    flip::Float tempo;
    flip::Array &lt;Track&gt; tracks;
};

void Song::declare ()
{
    Model::declare &lt;Song&gt; ()
    .name (""acme.product.Song"")
    .member &lt;flip::Float, &amp;Song::tempo&gt; (""tempo"");
    .member &lt;flip::Array &lt;Track&gt;, &amp;Song::tracks&gt; (""tracks"");
}

int main()
{
    Song::declare();
    ...
}
</code></pre>

<p>With the structured declared like so, <code>flip::Object</code>'s constructor can initialize all the fields so that they can point to the undo stack, and all the edits on them are recorded. It also has a list of all the members so that <code>flip::Object</code> can implement the serialization for you.</p>
",5
41665934,41665904,4,"<p>With:</p>

<pre><code>class Two
{
public:
    One x(1);
};
</code></pre>

<p>and based on language rules, the compiler attempts to parse <code>x</code> as a member function returning an object of type <code>One</code>, but rather than seeing valid <em>parameter-declarations</em> which requires at least a list of 0 or more <em>type-specifier</em>s, it sees a <em>non-type</em>.</p>

<blockquote>
<pre><code>class Three
{
public:
    One *x = new One(1);
};
</code></pre>
  
  <p>Can I initialize the class without using a pointer?</p>
</blockquote>

<p>Yes, use the <em>uniform-brace-initialization</em> syntax for <a href=""http://en.cppreference.com/w/cpp/language/value_initialization"" rel=""nofollow noreferrer"">value-initialization</a>:</p>

<pre><code>class Three
{
public:
    One x{1};
};
</code></pre>

<p>Or <a href=""http://en.cppreference.com/w/cpp/language/copy_initialization"" rel=""nofollow noreferrer""><em>copy-initialization</em></a>:</p>

<pre><code>class Three
{
public:
    One x = 1;  //Uses converting constructor, 
    //see http://en.cppreference.com/w/cpp/language/converting_constructor

    //or
    One x = One(your, multiple, arguments, here);
};
</code></pre>

<p>Or <a href=""http://en.cppreference.com/w/cpp/language/initializer_list#content"" rel=""nofollow noreferrer""><em>member-initializer-lists</em></a> in the Constructor:</p>

<pre><code>class Three
{
public:
    Three(...) : x(1) { ... }
    One x;
    ...
};
</code></pre>
",2
41665969,41665904,4,"<pre><code>One x(1);
</code></pre>

<p>is parsed as a function declaration, that is why it expects a type in parentheses. You can use</p>

<pre><code>One x = 1;
</code></pre>

<p>or</p>

<pre><code>One x{1};
</code></pre>

<p>instead.</p>
",0
34990826,34990660,-1,"<p>You cannot bind a reference to a temporany: only const reference can do that.</p>

<p>I suggesto you to look this link <a href=""https://stackoverflow.com/questions/27760290/c11-binding-rules-for-const"">C++11 binding rules for const &amp;&amp;</a></p>
",1
34991051,34990660,1,"<p>The way that you're currently doing, i.e. storing the object in a variable, is a proper way to extend the lifetime of the returned object and allow non-const references to bind to it. If <code>GetT</code> is implemented so that (N)RVO is possible, then no useless copy need to be made because it can be <a href=""http://en.cppreference.com/w/cpp/language/copy_elision"" rel=""nofollow"">elided</a>.</p>
",0
34991088,34990660,2,"<p>How about using <a href=""https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers"" rel=""nofollow"">universal references</a>.</p>

<p>Not sure if you would consider it elegant but it would look something like this:</p>

<pre><code>struct MyStruct
{
    int i;
};

template&lt;class T&gt;
void foo(T&amp;&amp; t)
{
    static_assert(std::is_base_of&lt;MyStruct, 
                  typename std::remove_reference&lt;T&gt;::type&gt;::value, ""ERROR"");
    t.i = 1024;
}

MyStruct GetMyStruct()
{
    return MyStruct();
}

int main() 
{
    foo(GetMyStruct());

    MyStruct ms;
    foo(ms);

    return 0;
}
</code></pre>
",1
34991618,34990660,0,"<p>I came up with a solution to my problem with simple overload:</p>

<p>f(T&amp; t) { ... }<br>
f(T&amp;&amp; t) { f(t); }  </p>

<p>But there still has to be a better way.</p>
",0
38984885,38977138,2,"<p>No, such a class cannot be considered abstract because (as mentioned in the comments, <a href=""http://eel.is/c++draft/class.abstract#2"" rel=""nofollow"">excerpt from the working draft</a>):</p>

<blockquote>
  <p>A class is abstract if it has at least one?pure virtual function.</p>
</blockquote>

<p>Unfortunately, there are cases when one cannot add a pure virtual method to a class to turn it in an abstract one and still he doesn't want users to be able to instantiate that class.</p>

<p>For the sake of curiosity, I'm adding this answer to mention an often unknown technique to work around the <em>issue</em>.<br>
Actually, you can easily turn such a class in an abstract one, even if you don't have any virtual method to be added to it.<br>
The basic idea is to exploit the destructor declaration to do that.<br>
A minimal, (not) working example follows:</p>

<pre><code>struct B { virtual ~B() = 0; };
// keep in mind the ODR
B::~B() { }

int main() { B b{}; }
</code></pre>

<p>The code above won't compile with the error:</p>

<blockquote>
  <p>cannot declare variable 'b' to be of abstract type 'B'</p>
</blockquote>

<p>Please, note that the definition of the destructor should be placed in a <em>.cpp</em> file, so as not to violate the ODR.</p>

<hr>

<p>To be honest, I haven't found any case in which this technique can be used till now. Anyway, it's worth mentioning it for future readers.</p>
",0
37759429,37759411,4,"<p>The first example which comes to mind is implementations analogous to the NULL value for SQL.  In that, comparing two objects&mdash;either of which are NULL&mdash;does not mean they are equal.  Only if both are not NULL does it makes sense to return equality.</p>
",1
37759704,37759411,0,"<p>In very simple situations, the ""implement equality in terms of inequality"" (or vice versa) idiom will suffice. On x86, the <a href=""https://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Comparison%5FInstructions"" rel=""nofollow""><code>cmp</code> instruction</a> is used for both equality and inequality. Take the following example:</p>

<pre><code>struct Foo
{
  bool operator==(const Foo&amp; rhs)
  {
    return val == rhs.val;
  }

  bool operator!=(const Foo&amp; rhs)
  {
    return val != rhs.val;
  }

  int val;
};

Foo a{20};
Foo b{40};
Foo c{20};

int main()
{
  (void)(a == b);
  (void)(a == c);
  (void)(a != b);
  (void)(a != c);
}
</code></pre>

<p>This is going to compile to identical assembly, sans <code>sete</code> versus <code>setne</code>. People may split hairs and make vague assertions about branch prediction, pipelines, CPU cache, etc. But they're really just vacuous statements.</p>

<p>In complex situations, it may be tempting to give different semantics for <code>operator==</code> and <code>operator!=</code>, but I don't agree with this principle:</p>

<ul>
<li><p>You're violating the user's expectation that these two operators are the inverse of each other. For example is there any difference between <code>!(a == b)</code> or <code>a != b</code>? You easily fall into the trap of other languages like PHP and Javascript where equality is a special type of Hell.</p></li>
<li><p>Hiding complex objects behind operator overloading and iterators can hurt performance badly. People use these features on the assumption that they're cheap (and in most cases they are.) An expensive ""iterator"" or ""equality"" makes it very difficult to use properly.</p></li>
</ul>

<p>""When does it makes sense"" is more of a question answered by business requirements than proper design, unfortunately.</p>
",0
37759809,37759411,3,"<p><em>If</em> you want to have the rule that <code>a == b</code> returns true exactly when <code>a != b</code> returns false, then indeed, there is little reason to have two implementations, unless you are hoping to optimize out a single <code>!</code> somehow. (Which would very rarely make a difference, and is better done by the optimizer.)</p>

<p>However, C++ does not generally assume that the operator overloads obey rules like this.</p>

<p>For instance, you might think also that, you should only need to overload <code>operator &lt;</code>, and then get <code>operator &gt;</code>, operator <code>&lt;=</code>, operator <code>&gt;=</code> and operator <code>==</code> for free. Since all these can be defined in terms of <code>operator &lt;</code> if you assume that it returns a bool and the relation is supposed to be a partial order.</p>

<p>But, operators are also used to give more complex syntax and semantics in some cases. If these kinds of ""identities"" were imposed it would make some things like expression templates impossible, for instance.</p>

<p>C++ doesn't impose any ""identities"" on you. You can give the operators whatever meaning you feel like, for better or worse.</p>

<p>So, I think what you heard may be a misconception. The reason you have this freedom is not to give more opportunities for ""efficiency"", it's to allow you to give the operators the meaning that you want when they are used with your custom classes.</p>

<hr>

<p>For completeness, here's an example of what I'm talking about.</p>

<pre><code>namespace expression_builder {

   struct arg {
     bool operator()(bool input) const {
       return input;
     }
   };

   template &lt;typename E&gt;
   struct negate {
     E e;

     bool operator()(bool input) const {
       return !e(input);
     }
   };

   template &lt;typename E1, typename E2&gt;
   struct equals {
     E1 e1;
     E2 e2;

     bool operator()(bool input) const {
       return e1(input) == e2(input);
     }
   };

   template &lt;typename E1, typename E2&gt;
   struct not_equals {
     E1 e1;
     E2 e2;

     bool operator()(bool input) const {
       return e1(input) != e2(input);
     }
   };

   // Operator overloads

   template &lt;typename T&gt;
   auto operator!(T t) -&gt; negate&lt;T&gt; {
     return {t};
   }

   template &lt;typename T1, T2&gt;
   auto operator==(T1 t1, T2 t2) -&gt; equals&lt;T1, T2&gt; {
     return {t1, t2};
   }

   template &lt;typename T1, T2&gt;
   auto operator!=(T1 t1, T2 t2) -&gt; not_equals&lt;T1, T2&gt; {
     return {t1, t2};
   }

} // end namespace expression_builder

int main() {
  using expression_builder::arg;

  auto my_functor = (arg == (arg != (!arg)));
  bool test1 = my_functor(true);
  bool test2 = my_functor(false);
}
</code></pre>

<p>In this code, operator overloading is being used to allow you construct function objects to implement simple boolean functions. The function construction process happens entirely at compile time, so the resulting code is very efficient. People use this with much more complex examples to do certain kinds of functional programming very efficiently in C++. And it's crucial that <code>operator ==</code> has a very different implementation from <code>operator !=</code> here.</p>
",0
40750541,40750245,4,"<p>There's a number of typos and small errors/warnings in your code (steps for fixing explained in the comments):</p>

<pre><code>class WireUser {
public:
  static bool wireInitialized;
  WireUser(); // Don't use scope specifiers in declarations:  WireUser::WireUser();
};

bool WireUser::wireInitialized = false; // Typo fixed here 'wireInitialized' isn't the 
                                        // same as         'wireIntialized'

WireUser::WireUser() {
  if (!wireInitialized) {
    // Wire.begin(); Commented out because it's not in context of your question
    wireInitialized = true;
  }
} //; &lt;&lt;&lt;&lt; Omit the semicolon to get rid of the warning

int main (){
    WireUser wu;
    return 0;
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/53b32bf554a1d802"" rel=""nofollow noreferrer"">Live Demo</a>.</p>

<hr>

<p>Also you should consider to make that thread safe for initialization.<br>
A <code>std::atomic&lt;bool&gt;</code> might be the right choice:</p>

<pre><code>#include &lt;atomic&gt;

class WireUser {
public:
  static std::atomic&lt;bool&gt; wireInitialized;
  WireUser();
};

std::atomic&lt;bool&gt; WireUser::wireInitialized = {false};

WireUser::WireUser() {
  if (!wireInitialized.exchange(true)) {
    // Wire.begin();
    // wireInitialized = true;
  }
}

int main (){
    WireUser wu;
    return 0;
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/eca4bec6be009d54"" rel=""nofollow noreferrer"">Live Demo</a></p>
",3
36781027,36780827,3,"<p>Once C++17 is released (or if your compiler supports prerelease versions),</p>

<p><code>return m_messageList.try_emplace(name, name).first;</code> should do the trick.</p>
",2
35242860,35242826,1,"<p>Just copy getopt.h to the directory where .c files are, so the compiler can find it.</p>
",2
35242863,35242826,0,"<p>Based on the linked source code and it's contents, the project you're trying to build appears to be written for Linux. It might be possible to sufficiently rewrite it to be able to compile under Microsoft Windows, and Microsoft's compiler; or perhaps install something like MinGW.</p>

<p>However, given your stated lack of development experience, this does not appear to be something that you could easily handle on your own.</p>
",1
35259706,35242826,5,"<p>Already emailed the OP about this, but here's the steps I followed in order to build lci successfully. The missing step seemed to be that Justin Meza neglected to mention that you need to install CMake as well in order for the install script to work. CMake will allow you to build C code against the glibc headers.</p>

<ol>
<li>Install <a href=""http://sourceforge.net/projects/mingw-w64/"" rel=""nofollow"">MinGW</a></li>
<li>Install <a href=""https://www.python.org/downloads/"" rel=""nofollow"">Python 3.5.1</a> (or latest Windows version) </li>
<li>Install Git for <a href=""https://git-scm.com/download/win"" rel=""nofollow"">Windows</a> (if you haven't already) 

<ul>
<li>Make sure to enable Git for the Windows command prompt</li>
</ul></li>
<li>Install <a href=""https://cmake.org/download/"" rel=""nofollow"">CMake</a> </li>
<li>Add MinGW and Python to your PATH environment variable. I'd double check that your paths to the executables are correct, mine looked like this:

<ul>
<li>C:\Program Files\mingw-w64\mingw64\bin</li>
<li>C:\Users{username}\AppData\Local\Programs\Python\Python35-32</li>
</ul></li>
<li>Run a command prompt as administrator, and go to your Documents folder and clone the lci repository (if you haven't already):

<ul>
<li>git clone <a href=""https://github.com/justinmeza/lci.git"" rel=""nofollow"">https://github.com/justinmeza/lci.git</a></li>
</ul></li>
<li>Go into the lci directory, and run:

<ul>
<li>install.py --prefix=""C:/Program Files/lci""</li>
</ul></li>
<li>Add lci to you PATH, if using the default location add this to the end of your PATH:

<ul>
<li>C:\Program Files\lci\bin</li>
</ul></li>
</ol>

<p>I would have included some links to the various programs above in steps 1-4 but apparently I don't have enough reputation on StackOverflow for that...you should be able to find them easily enough in a quick Google search.</p>

<p>You should now be able to run lci from any command prompt. A good test would be to run the ""HAI WORLD"" code at lolcode.org.</p>
",4
46615622,30073287,3,"<p>If you're just looking for a way to print a vector with its elements properly delimited (and without an extra delimiter at the end), try this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
  std::vector&lt;int&gt; v{1, 2, 3};

  auto it = v.begin();
  if (it != v.end())
  {
    std::cout &lt;&lt; *it;
    ++it;
  }

  for (; it != v.end(); ++it)
  {
    std::cout &lt;&lt; "", "" &lt;&lt; *it;
  }
}
</code></pre>
",0
40965655,40965614,3,"<p>The <code>##</code> is not used to ""stringify"" a macro parameter, its used to concatenate strings. The proper define would be:</p>

<pre><code>#define NULLWrapper(n) class IG##n##WrapperNULL : public I##n 
</code></pre>
",0
41402752,41397680,0,"<p>First, we need ways to check the field's type and to fetch its value based on its C++ type.</p>

<pre><code>template &lt;typename T&gt;
bool Is(const Field &amp;field) { return false; }

template &lt;&gt; bool Is&lt;bool&gt;(const Field &amp;field)   { return field.IsBool(); }
template &lt;&gt; bool Is&lt;double&gt;(const Field &amp;field) { return field.IsDouble(); }
template &lt;&gt; bool Is&lt;int&gt;(const Field &amp;field)    { return field.IsInt(); }

template &lt;typename T&gt;
T Get(const Field &amp;field) { throw 0; }

template &lt;&gt; T Get&lt;bool&gt;(const Field &amp;field)     { return field.GetBool(); }
template &lt;&gt; T Get&lt;double&gt;(const Field &amp;field)   { return field.GetDouble(); }
template &lt;&gt; T Get&lt;int&gt;(const Field &amp;field)      { return field.GetInt(); }
</code></pre>

<p>In the above, I'm assuming you have a limited number of types and specializing these function templates for each of them isn't a big deal.  Note the Field is whatever type your JSON parser returns when you request a specific field.</p>

<p>Now we can build a generic extractor.  I noticed your example also does the validation at this step, but I'm going to separate that out.  Note the JSONThing is whatever the type of your JSON object is (the same as the type of <code>item_[i]</code> in the original post).</p>

<pre><code>template &lt;typename T&gt;
T Extract(const JSONThing &amp;json, const char * field_name) {
    if (!json.HasMember(field_name)) throw CustomException(""missing field"")
    const Field &amp;field = json[field_name];
    if (!Is&lt;T&gt;(field)) throw CustomException(""wrong type"");
    return Get&lt;T&gt;(field);
}
</code></pre>

<p>For validation, you can use functions (or function templates) that return the input value if its valid.  Admittedly, this is a little contrived, but it makes populating the objects quite straightforward.</p>

<pre><code>template &lt;typename T&gt;
const T &amp;Nonnegative(const T &amp;value) {
  if (value &lt; static_cast&lt;T&gt;(0)) throw CustomException(""invalid value"");
  return value;
}
</code></pre>

<p>Now you can populate your object like this:</p>

<pre><code>const auto &amp;json = item_[i];
obj.setField1(Nonnegative(Extract&lt;double&gt;(json, ""Field1"")));
obj.setField2(Extract&lt;bool&gt;(json, ""Field2""));
obj.setField3(Nonnegative(Extract&lt;int&gt;(json, ""Field3"")));
// ...
</code></pre>

<p>I find this pretty readable, and it eliminates virtually all of the duplication, so there's little chance to make a mistake.  You'd have to do a little more work if you want more detail in the custom exceptions.</p>
",0
37204497,37203859,16,"<p>The C++ rule for the return type and value of <code>new T</code> is:</p>

<ul>
<li>If <code>T</code> is not an array type, the return type is <code>T *</code>, and the returned value is a pointer to the dynamically allocated object of type <code>T</code>.</li>
<li>If <code>T</code> is an array of type <code>U</code>, the return type is <code>U *</code>, and the returned value is a pointer to the first element (whose type is <code>U</code>) of the dynamically allocated array of type <code>T</code>.</li>
</ul>

<p>Therefore, since your <code>H</code> is an array of <code>int</code>, the return type of <code>new H</code> is <code>int *</code>, not <code>H *</code>.</p>

<p>By the same rule, <code>new H[1]</code> returns <code>H *</code>, but note that you have technicaly allocated a two-dimensional array of <code>int</code>s, sized 1 x 4.</p>

<p>The best way to get get around this in generic code is indeed to use <code>auto</code>:</p>

<pre><code>auto h = new H;
</code></pre>

<p>Or, if you prefer to highlight the pointer fact:</p>

<pre><code>auto *h = new H;
</code></pre>

<hr>

<p>As for the rationale of this seeming inconsistency in the rules: pointers to arrays are quite ""dangerous"" in C++ since they behave rather unexpectedly (i.e. you have to be very careful with them not to produce unwanted effects). Let's look at this code:</p>

<pre><code>typedef int H[4];
H *h = obtain_pointer_to_H_somehow();
h[2] = h[1] + 6;
</code></pre>

<p>At first (and maybe even second) glance, the code above seems to add 6 to the second <code>int</code> in the array and store it in the third <code>int</code>. But that's <em>not</em> what it does.</p>

<p>Just like for <code>int *p</code>, <code>p[1]</code> is an <code>int</code> (at the address <code>sizeof(int)</code> bytes offset from <code>p</code>), so for <code>H *h</code>, <code>h[1]</code> is a <code>H</code>, at the address <code>4 * sizeof(int)</code> bytes offset from <code>h</code>. So the code is interpreted as: take the address in <code>h</code>, add <code>4 * sizeof(int)</code> bytes to it, then add 6, and then store the resulting address at offset <code>8 * sizeof(int)</code> from <code>h</code>. Of course, that will fail, since <code>h[2]</code> decays to an rvalue.</p>

<p>OK then, you fix it like this:</p>

<pre><code>*h[2] = *h[1] + 6;
</code></pre>

<p>Even worse now. <code>[]</code> binds tighter than <code>*</code>, so this will reach into the 5th <code>int</code> object after <code>h</code> (note there are only 4 of them there!), add 6, and write that into the 9th <code>int</code> after <code>h</code>. Writing into random memory FTW.</p>

<p>To actually do what the code was probably intended to, it would have to be spelled like this:</p>

<pre><code>(*h)[2] = (*h)[1] + 6;
</code></pre>

<p>In light of the above, and since what you usually do with a dynamically allocated array is access its elements, it makes more sense for <code>new T[]</code> to return <code>T *</code>.</p>
",9
37204617,37203859,0,"<p>You can see why if you basically do the typedef substitution manually:</p>

<pre><code>H * h = new H;
</code></pre>

<p>Reduces to:</p>

<pre><code>int[4]* h = new int[4];
</code></pre>

<p>while</p>

<pre><code>H * h = new H[1];
</code></pre>

<p>reduces to:</p>

<pre><code>(int*)[4] h = new int[1][4];
</code></pre>

<p>Because of the array to pointer decay rules, this is legal.</p>

<p>If you want an actual workaround, and you know the type of H, you can do something like:</p>

<pre><code>typedef int* J;
typedef int H[4];

J j = new H; // This will work
</code></pre>
",3
37204663,37203859,2,"<p>In the C++ standard <code>new</code> and <code>new[]</code> are specifically separated because they can be be different allocators for performance and efficiency reasons; allocating an array vs. a single object has different usage patterns that allocator implementations optimise for.</p>

<p>The syntax is probably different because the compile-time type introspection techniques available when it was standardised wasn't nearly as reliable as it is today.</p>

<p>To make sensible code, the preferred way IMO would be:</p>

<pre><code>struct H { int values[4]; }

H * h = new H;
</code></pre>

<p>That way, your <code>H</code> type logically ""contains"" your array of four <code>int</code> values - but the in-memory structure should still be compatible (<code>assert(sizeof(H) == 4 * sizeof(int))</code>); and you get to use object-style allocation of your fixed-size arrays.  More... C++-ey.</p>
",1
42475273,42475242,5,"<p>When an object is <code>const</code>, it doesn't cause the reference members to also become <code>const</code> since the referent is not a part of the object itself. The reference member is just a piece of information representing the address of some other object. Whether or not the <code>B</code> object itself is immutable shouldn't affect whether it should be possible to mutate the objects it references.</p>

<p>If you make the <code>B::a</code> member a non-reference, as in <code>A a;</code>, then the <code>B</code> object will actually contain within itself an <code>A</code> object, so when the former is <code>const</code>, the latter will be too.</p>
",0
42475298,42475242,1,"<blockquote>
  <p>Inside f2() b is const, so my understanding was that b.a should also be const.</p>
</blockquote>

<p>It is. If the instance is <code>const</code> then it's members will be, too. But look at the type of the member:</p>

<pre><code>A &amp; a;
</code></pre>

<p>That's a reference to <code>A</code>. Making that <code>const</code> yields a constant reference to <code>A</code>:</p>

<pre><code>A &amp; const a;
</code></pre>

<p><em>Not</em> a reference to a constant <code>A</code>.</p>
",2
42475336,42475242,0,"<p>Strictly speaking there are no constant references. There are references to constant objects. </p>

<p>In the class B the data member <code>a</code>  is declared like a reference to non-constant object of the type A.</p>

<pre><code>A   &amp;a;
</code></pre>

<p>and this reference is passed as an argument to a function that accepts a reference to a non-constant object</p>

<pre><code>void f1(A&amp;) {}
void f2(const B &amp;b) { f1(b.a); }
</code></pre>

<p>Thus the code compiles successfully.</p>
",0
41700360,41699809,2,"<p>The rules are quite complicated, and I myself don't fully grasp them, but let's see if we can make head or tails of them (I think we can):</p>

<pre><code>namespace nx {
struct X {};
}

namespace ns {    
auto foo(nx::X x1, nx::X x2) { return x1 == x2; }
// error: no match for 'operator==' (operand types are 'nx::X' and 'nx::X')
}

auto operator==(nx::X, nx::X) { return true; }

auto global_foo()
{
  return ns::foo(nx::X{}, nx::X{}); 
}
</code></pre>

<p>This isn't found for a simple reason: <code>operator==</code> is not declared before its use. Nothing to to with ADL yet. So far so good. We understand that. Let's fix it:</p>

<pre><code>namespace nx {
struct X {};
}

auto operator==(nx::X, nx::X) { return true; }

namespace ns {
auto foo(nx::X x1, nx::X x2) { return x1 == x2; }
}

auto global_foo()
{
  return ns::foo(nx::X{}, nx::X{}); 
}
</code></pre>

<p>Does this work? Yes, it does, it compiles and calls our <code>operator==</code>. Is this the correct solution? <strong>No!</strong>. Because if we add this:</p>

<pre><code>namespace nx {
struct X {};
}

auto operator==(nx::X, nx::X) { return true; } // (1)

namespace ns {

template &lt;class T&gt; auto operator==(T, int) { return false; } // (2)

auto foo(nx::X x1, nx::X x2) { return x1 == x2; }
// error: no match for 'operator==' (operand types are 'nx::X' and 'nx::X')
}

auto global_foo()
{
  return ns::foo(nx::X{}, nx::X{});
}
</code></pre>

<p>Then (2) in ns hides (1) in global namespace, even if (1) would be a better fit. This is called <strong>name hiding</strong> and - again - doesn't involve ADL in any way.</p>

<p>Even worse:</p>

<pre><code>namespace nx {
struct X {};
}

auto operator==(nx::X, nx::X) { return true; } // (1)

namespace ns {

template &lt;class T&gt; auto operator==(T, T) { return false; } // (2)

auto foo(nx::X x1, nx::X x2) { return x1 == x2; } // calls (2)
}

auto global_foo()
{
  return ns::foo(nx::X{}, nx::X{}); 
}
</code></pre>

<p>Would compile and silently calls <code>(2)</code> instead of our operator <code>(1)</code>.</p>

<p>For a real world context think of <code>namespace ns</code> as namespace <code>std</code> and
any operator declared inside <code>std</code>. And you've got the situation in your post.</p>

<p>The correct solution is:</p>

<pre><code>namespace nx {
struct X {};
auto operator==(nx::X, nx::X) { return true; } // (1)
}

namespace ns {

template &lt;class T&gt; auto operator==(T, T) { return false; } // (2)

auto foo(nx::X x1, nx::X x2) { return x1 == x2; } // calls (1)
}

auto global_foo()
{
  return ns::foo(nx::X{}, nx::X{}); 
}
</code></pre>

<p>What happens here is that ADL kicks in and brings <code>(1)</code> from <code>nx</code> and now <code>(1)</code> is considered alongside <code>(2)</code>. But <code>(1)</code> is more specialized than <code>(2)</code> and so <code>(1)</code> is correctly selected.</p>

<p>If you don't have control of <code>namespace nx</code> and can't add the operator there, then what I can advise is to use callables instead of relying on operators. E.g instead of <code>std::find</code> use <code>std::find_if</code> with your own predicate (lambda) where you control exactly which method/operator to call. And when I say ""exactly"" I mean <strong>exactly</strong>: i.e. <code>::operator==(x1, x2)</code> (or whatever namespace you declared them) instead of <code>x1 == x2</code>.</p>

<hr>

<p>You can read more on this great article by Herb Sutter <a href=""http://www.gotw.ca/publications/mill08.htm"" rel=""nofollow noreferrer"">Namespaces &amp; Interface Principle</a></p>
",0
41700736,41699809,1,"<p>Just declare <code>operator==</code> inside the namespace <code>otherns</code> (The lookup will find it at namespace scope)</p>

<pre><code>namespace otherns {
bool operator==(const otherns::Property &amp;a, const otherns::Property &amp;b) {
  return a.getName() == b.getName();
}
}
</code></pre>

<p><a href=""http://ideone.com/ZsDmi3"" rel=""nofollow noreferrer"">Working code</a></p>

<p>You can do it in a separate header of the 3rd party library.</p>
",0
41700949,41699809,0,"<p>You defined <code>operator==</code> in the <em>global</em> namespace (perhaps misled by the misindentation).  It won't be found there by argument-dependent lookup.</p>

<p>The operator should be declared in the same namespace as (one of) its arguments:</p>

<pre><code>namespace otherns {

    class Property {
    public:
        const std::string &amp;getName() const { return m_name; }

    private:
        std::string m_name;
    };

    bool operator==(const otherns::Property &amp;a, const otherns::Property &amp;b) {
        return a.getName() == b.getName();
    }
}
</code></pre>

<p>That little change enables your example to compile cleanly.</p>
",0
44693292,44692931,1,"<p>It is just the way it is in C++. Redeclaring a class member is not allowed (unless you consider an out-of-class <em>definition</em> as another <em>declaration</em>). Redeclaring a namespace member is OK as long as you obey ODR.</p>
",1
44693145,44692931,5,"<p>It's explicitly prohibited by the C++ standard. Right there at <a href=""http://eel.is/c++draft/class#mfct-1"" rel=""noreferrer"">[class.mfct/1]</a></p>

<blockquote>
  <p>A member function may be defined in its class definition, in which
  case it is an inline member function, or it may be defined outside of
  its class definition if it has already been declared but not defined
  in its class definition. A member function definition that appears
  outside of the class definition shall appear in a namespace scope
  enclosing the class definition. <strong>Except for member function definitions
  that appear outside of a class definition</strong>, and except for explicit
  specializations of member functions of class templates and member
  function templates ([temp.spec]) appearing outside of the class
  definition, <strong>a member function shall not be redeclared.</strong></p>
</blockquote>
",2
44693469,44692931,1,"<blockquote>
<p>Why doesn't this compile?</p>
</blockquote>
<pre><code>class Test {
  void foo();
  void foo() { }; // wrong
};
</code></pre>
<p>Because, as <a href=""https://stackoverflow.com/a/44693145/841108"">StoryTeller</a> and others answered, you are declaring and defining the <em>same</em> member function <code>void Test::foo(void)</code> twice (and the inside-class definition of <code>foo</code> is implicitly <code>inline</code>).</p>
<p>If you want to define a member function in your header file <em>after</em> the class, you'll better declare it explicitly as <code>inline</code> like this:</p>
<pre><code>class Test {
   inline void foo();
};
</code></pre>
<p>and <em>later</em> define that member function (e.g. below in the same header file):</p>
<pre><code>void Test::foo() {
  // body of Test::foo
}
</code></pre>
<p>BTW, if you declare a member function with outside definition like above, and that member function is not <code>inline</code> but is <em>defined</em> in some header file which is included in several translation units, that function would be multiply defined and the linker would complain.</p>
",3
44693242,44692931,0,"<pre><code>void foo();
</code></pre>

<p>and </p>

<pre><code>void foo() {}
</code></pre>

<p>are two ways of declaring functions in a class definition. The first only declares the function and the second declares the function and also  implements it. Therefore the compiler assumes that you are going to re-declare the same function and is not a correct overload as the function signature is the same in both.</p>
",1
43180052,43179796,0,"<p>Ok, managed to fix it by just throwing expressions here and there, but it would still be great to read an answer that explains what is actually going on... here are my changes - only in <code>mystuff.h</code>:</p>

<p><code>mystuff.h</code>:</p>

<pre><code>#include &lt;iostream&gt;

class MyStuff
{
public:
  MyStuff();
  ~MyStuff();

  static const unsigned char temp_binary_data_7[];
  static constexpr const char* teapot_obj = (const char*) temp_binary_data_7;

  // from OpenGLDemo.cpp:
  struct Shape
  {
    Shape()
    {
      std::cout &lt;&lt; ""initializing "" &lt;&lt; static_cast&lt;const void*&gt;(teapot_obj) &lt;&lt; std::endl ;
    }
  };
  Shape tmptest;
};
</code></pre>

<p>So, basically:</p>

<pre><code>const char* teapot_obj = (const char*) temp_binary_data_7;
</code></pre>

<p>had to change into:</p>

<pre><code>static constexpr const char* teapot_obj = (const char*) temp_binary_data_7;
</code></pre>

<p>... which then means I have to make a <code>static_cast&lt;const void*&gt;</code> (instead of just <code>static_cast&lt;void*&gt;</code>) to print out the object address; and finally, have to add a <code>Shape tmptest;</code> so that the constructor of <code>Shape</code> runs at least once, so we can have something printed.</p>

<p>And now, the program runs without problems:</p>

<pre class=""lang-none prettyprint-override""><code>$ g++ -std=c++11 main.cpp mystuff.cpp -o main
$ ./main 
initializing 0x400c60
hello world#
</code></pre>
",0
38016050,38016016,8,"<p>The compiler sees <code>http:</code> as a label, and <code>//www.google.com</code> as a comment.</p>
",0
46662823,46662434,0,"<p>You can use gdb but that means you have to navigate to that part of the code. If I have a little program:</p>

<pre><code>struct AAA {
    int iii;
    int aonly;
    void foo () {
    }
};

struct BBB: public AAA {
    int iii;
    int bonly;
    void fooB () {
    }
};

int main (int argc, const char* argv[]) {
    BBB b;
    b.iii = 1;
    return 0;
}
</code></pre>

<p>I can compile with debugging symbols (-g in g++), set a break point and print the object:</p>

<pre><code>eric@mouni2:/tmp/ttt$ g++ -g a.cpp
eric@mouni2:/tmp/ttt$ gdb a.out
*** output flushed ***
(gdb) b 18
Breakpoint 1 at 0x4004e8: file a.cpp, line 18.
(gdb) R
Starting program: /tmp/ttt/a.out 

Breakpoint 1, main (argc=1, argv=0x7fffffffe278) at a.cpp:18
18      return 0;
(gdb) ptype b
type = struct BBB : public AAA {
    int iii;
    int bonly;
  public:
    void fooB(void);
}
(gdb) p b
$1 = {&lt;AAA&gt; = {iii = -7568, aonly = 32767}, iii = 1, bonly = 0}
(gdb) p b.iii
$2 = 1
(gdb) p b.AAA::iii
$3 = -7568
</code></pre>

<p>There you see what BBB inherited from AAA. It's not great, but it's better than nothing.</p>
",1
39127237,39127171,6,"<p>IMHO since C++11/14, lambdas make this sort of predicates superfluous?</p>

<pre><code>find_if(begin(v), end(v), [](auto x){ return x &lt;= 42; });
</code></pre>
",3
39127401,39127171,4,"<p>I think there is no technical reason why your second approach should be disallowed. Prior to deprecation, <code>std::bind2nd</code> helper function would come very close to your desired approach:</p>

<pre><code>std::find_if(std::begin(v), std::end(v), std::bind2nd(std::less_equal&lt;int&gt;(), 42));
</code></pre>

<p>Of course you can always make your own helper - it is very short:</p>

<pre><code>template &lt;typename T&gt; auto cmp_less_equal(const T&amp; x) {
  return std::bind(std::less_equal&lt;T&gt;(), std::placeholders::_1, x);
}
</code></pre>

<p>Now you can write</p>

<pre><code>std::find_if(std::begin(v), std::end(v), cmp_less_equal(42));
</code></pre>

<p>using your own wrapper (<a href=""http://ideone.com/CKCau7"" rel=""nofollow"">demo</a>).</p>
",0
39127906,39127171,3,"<p>How about you just give a lambda a name?</p>

<pre><code>const auto cmp_less_eq = [](auto x){ return x &lt;= 42; };
const auto result = find_if(begin(v), end(v), cmp_less_eq);
</code></pre>
",3
39134547,39134491,2,"<p>You can't have two definitions of the same class.</p>

<pre><code>struct S {};
template&lt;typename T&gt; struct S{};
</code></pre>

<p>reproduces your compiler error: <a href=""http://ideone.com/7KpAPl"" rel=""nofollow"">http://ideone.com/7KpAPl</a></p>

<p>In this case, you only need the template definition.</p>
",0
46934706,46934619,0,"<blockquote>
  <p>So, I'm trying to guard against accidental multiple includes of the file.</p>
</blockquote>

<p>At least your linker will serve to throw an error message about ODR rule violations, don't worry.</p>

<blockquote>
  <p>But if other files #included that .cpp file, it could be processed multiple times</p>
</blockquote>

<p>Yes, it will be processed multiple times and provide multiple definitions spread over translation units that cannot be linked together anymore.</p>
",4
46939486,46934619,0,"<p>what about using the <strong>COUNTER</strong> macro ? Not sure of the behaviour across projects</p>

<pre><code>#if __COUNTER__ &gt; 0
#error I was there already
#endif
</code></pre>
",0
38020291,38020185,9,"<p>Enums in C++ are more than just applying a name to an integer; we have <code>const int</code> variables for that. Enums conceptually represent an integer which is only supposed to store one of a set of specific values.</p>

<p>Typedefs are aliases; they are identical in every way to the given type. Enums are <em>distinct</em> types. They use their underlying types, and they can be <em>converted</em> to it, but they are not the <em>same</em> type as their underlying types.</p>

<p>As such, a reference to a <code>uint8_t</code> is not the same thing as a reference to an enum, even if that enum uses <code>uint8_t</code> as its underlying type. Converting from a reference-to-enum to a reference-to-underlying-type is therefore an illegal conversion, as well as breaking strict aliasing.</p>

<p>You could pass it by value, since non-class enums are implicitly convertible to their underlying types. And you can pass by <code>const&amp;</code>, since implicit conversion can create a temporary to fill that reference. But you cannot pass an enumeration to a function that takes a non-<code>const</code> reference to an integer.</p>
",0
39130975,39130701,-2,"<p>It has to be distinguished between the internal representation and the format. </p>

<p>In the internal representation Floating-point numbers are typically packed as sign bit, the exponent field, and the significand or mantissa, from left to right. This representation is defined for the range you mentioned (mathematical limit)</p>

<p>The format defines the ""external"" representation and is limited to the available space and thereby to the precision of the data type e.g. float about 7 digits (technical limit).</p>
",1
34964316,34964152,3,"<p>Under the C++ standard, what you are doing is undefined behavior.  The memory layout of unsigned and signed ints is not guaranteed to be compatible, as far as I know.</p>

<p>On most platforms (which use 2s complement integers), this will not be a problem.</p>

<p>The remaining issue is strict aliasing, where the compiler is free to presume that pointers to one type and pointers to another type are not pointers to the same thing.</p>

<pre><code>typedef int(__stdcall *Tfnc)(
  unsigned int *alen
);

int test() {
  int x = 3;
  Tfnc pf = [](unsigned int* bob) { *bob = 2; };
  pf((unsigned int*)&amp;x);
  return x;
}
</code></pre>

<p>the above code <em>might</em> be allowed to ignore the modification to the <code>x</code> while it is modified through the <code>unsigned int*</code>, even on 2s complement hardware.</p>

<p>That is the price of undefined behavior.</p>
",0
34964482,34964152,0,"<p>No it won't be of any problem, until and unless the int value you pass is not negative.
But if the given value is negative then the resulting value is the least unsigned integer congruent to the source integer (modulo 2^n where n is the number of bits used to represent the unsigned type).</p>
",0
47490940,37868097,2,"<p>I'd thought calling reset or assigning nullptr would've been pointless, but it turns out this causes smaller footprint in the assembler. The compiler explorer at <a href=""https://godbolt.org/"" rel=""nofollow noreferrer"">https://godbolt.org/</a> with gcc 7.2 and with -O3 the code:</p>

<pre><code>void test1()
{
    auto test1 = std::make_unique&lt;int&gt;(5);
    test1 = std::make_unique&lt;int&gt;(6);
}
</code></pre>

<p>Surprisingly causes more instructions than the uglier version:</p>

<pre><code>void test2()
{
    auto test1 = std::make_unique&lt;int&gt;(5);
    test1 = nullptr;
    test1 = std::make_unique&lt;int&gt;(6);
}
</code></pre>
",0
37691231,37690618,1,"<p>As noted in the answer from @bipll, the first statement you ask about:</p>

<pre><code>Foo&lt;decltype(foobar)&gt; foo1();
</code></pre>

<p>is simply a declaration of a function returning a <code>Foo</code>, not an initialization.</p>

<p>As to the second question, how can we make the following work?</p>

<pre><code>Foo&lt;decltype(foobar)&gt; foo1(foobar);
</code></pre>

<p>We could simply change the template to <a href=""http://en.cppreference.com/w/cpp/types/decay"" rel=""nofollow""><strong>decay the captured type</strong></a>:</p>

<pre><code>template &lt;typename F&gt; struct Foo{
    typename std::decay&lt;F&gt;::type workFunction;
    Foo(F f) :  workFunction(f) { }
};
</code></pre>

<p>Now, using an example:</p>

<pre><code>#include &lt;type_traits&gt;

int foobar() {
    return 1;
}

template &lt;typename F&gt; struct Foo{
    typename std::decay&lt;F&gt;::type workFunction;
    Foo(F f) :  workFunction(f) { }
};

int main(){
    Foo&lt;decltype(foobar)&gt; foo1(foobar);
    std::cout &lt;&lt; foo1.workFunction();
}
</code></pre>

<p>will return the expected output of <code>1</code>.</p>
",0
41191321,41191293,-2,"<p>Well, by putting it in the header you'd run into the one-definition rule if you include it in more than one cpp file.</p>

<p>But, on the other hand, you can create it as a constexpr in the header I believe.</p>
",2
41191498,41191293,5,"<p>The single advantage I know of is that you only have to recompile a single cpp-file when you change the constant¡¯s value and not every file that directly or indirectly includes the header file.</p>

<p>That can be particularly useful when you provide a dynamically linked library and want to patch it without recompiling the actual application.</p>

<p>Some drawbacks are that  </p>

<ul>
<li>(as latedeveloper wrote) you can't use them at places where a constant expression is required (e.g. array bounds or template parameters) outside of the cppfile, in which you defined it.</li>
<li>you make the optimizer's life harder.   </li>
<li>from a tooling perspective e.g. intellisense won't show you it's value.</li>
</ul>
",1
43962226,43961045,0,"<p>I would prefer to change and simplify the problem and write the code as follows:</p>

<pre><code>#include &lt;iostream&gt;

short int fold(short int a, short int b){return a+b;}  
int fold(int a, int b){return a+b;}

int main(int argc, char **argv){    
  std::cout&lt;&lt;fold((short)32767,(short)1)&lt;&lt;std::endl;
  std::cout&lt;&lt;fold(32767,(short)1)&lt;&lt;std::endl;   return 0; 
}
</code></pre>

<p>But as you may notice if you change the short to int and the int to long the code will not work any more due to lack of continuity in the promotion rules of C++.</p>
",1
43972513,43961045,1,"<p>Use the <code>switch{}</code> construction:</p>

<pre><code>switch(typeConst1){
case INT:
    switch(typeConst2){
    case INT:
        return stoi(constant1) + stoi(constant2);
    case LONG_INT:
        return stoi(constant1) + stol(constant2);
    case LONG_LONG_INT:
        return stoi(constant1) + stoll(constant2);
    case UNSIGNED_INT:
        return stoi(constant1) + stol(constant2);
    case UNSIGNED_LONG_INT:
        return stoi(constant1) + stoul(constant2);
    case UNSIGNED_LONG_LONG_INT:
        return stoi(constant1) + stoull(constant2);
case LONG_INT:
    //...
</code></pre>
",1
40781464,40781417,9,"<p>The standard has got you covered. Just declare <code>std::tuple&lt;Types...&gt; items</code>. </p>
",0
40781466,40781417,12,"<p>That is the purpose of <code>std::tuple</code>:</p>

<pre><code>template &lt;typename... Types&gt; class Data
{
    std::tuple&lt;Types...&gt; items;
};
</code></pre>
",1
40781481,40781417,24,"<p>You could use a <code>std::tuple</code></p>

<pre><code>#include &lt;tuple&gt;

template &lt;typename... Types&gt; class Data
{
    std::tuple&lt;Types...&gt; items;
};

struct Item1
{
    int a;
};

struct Item2
{
    float x, y, z;
};

struct Item3
{
    std::string name;
};

int main()
{
    Data&lt;Item1, Item2&gt; data1;
    Data&lt;Item3&gt; data2;
}
</code></pre>

<p>Try it <a href=""http://ideone.com/w8c9h0"" rel=""noreferrer"">here</a></p>
",3
35204414,35120763,1,"<p>The topic of ""undefined behavior"" is quite the nuisance on the site. For quite a while, there were many questions asking ""Is this undefined behavior?"" and answerers rushing to say ""yes"" when it actually wasn't the case. I believe what you're thinking of are cases like this:</p>

<blockquote>
  <p>The value computations of the operands of an operator are sequenced
  before the value computation of the result of the operator. If a side
  effect on a scalar object is unsequenced relative to either another
  side effect on the same scalar object or a value computation using the
  value of the same scalar object, and they are not potentially
  concurrent (1.10), the behavior is undefined.</p>
  
  <p>[ <em>Example:</em></p>

<pre><code>void f(int, int);
void g(int i, int* v) {
  i = v[i++];        // the behavior is undefined
  i = 7, i++, i++;   // i becomes 9

  i = i++ + 1;       // the behavior is undefined
  i = i + 1;         // the value of i is incremented

  f(i = -1, i = -1); // the behavior is undefined
}
</code></pre>
  
  <p>¡ª <em>end example</em> ]</p>
</blockquote>

<p>Both modifying an object and calling a library I/O function are side effects. Other than that, there is no relation whatsoever that implies your example has undefined behavior.</p>

<p>The other problem I have are answerers who would rather dump a bunch of nice-sounding standardese that is more difficult to parse than the human-friendly version. As a result, people tend to miss the bigger picture. Here is an example:</p>

<blockquote>
  <p>¡ì1.9/15 For each function invocation <em>F</em> , for every evaluation <em>A</em>
  that occurs within <em>F</em> and every evaluation <em>B</em> that does not occur
  within <em>F</em> but is evaluated on the same thread and as part of the same
  signal handler (if any), either <em>A</em> is sequenced before <em>B</em> or <em>B</em> is
  sequenced before <em>A</em>.</p>
</blockquote>

<p>Translation: If <em>A</em> and <em>B</em> would not otherwise be sequenced, then they are indeterminately sequenced. By definition, <em>indeterminately sequenced</em> means they can occur in <strong>any order</strong> but may not overlap.</p>

<p>Furthermore, in inexact terms, the operands of the <code>+</code> operator are unsequenced. So <code>+</code> does not represent a ""sequence point"". Therefore, <code>f1()</code> and <code>f2()</code> are indeterminately sequenced and you can infer that it's unspecified behavior.</p>

<p>TL;DR: Forget the standard, focus on learning the language. You get too bogged down into details and you lose sight of the bigger picture and confuse things. <a href=""http://en.cppreference.com/w/cpp/language/eval_order"" rel=""nofollow"">Here's a human-friendly treatise on the subject</a></p>
",1
35204933,35120763,2,"<blockquote>
<h2><a href=""http://en.cppreference.com/w/cpp/language/ub"" rel=""nofollow noreferrer"">Unspecified Behavior</a></h2>
<p>The behavior of the program varies between implementations and the conforming implementation is not required to document the effects of each behavior. For example, <strong>order of evaluation</strong>, whether identical string literals are distinct, the amount of array allocation overhead, etc. Each unspecified behavior results in one of a set of valid results.</p>
<h2><a href=""http://en.cppreference.com/w/cpp/language/eval_order"" rel=""nofollow noreferrer"">Order of Evaluation</a></h2>
<p>[T]here is no concept of left-to-right or right-to-left evaluation in C++. This is not to be confused with left-to-right and right-to-left associativity of operators: the expression f1() + f2() + f3() is parsed as (f1() + f2()) + f3() due to left-to-right associativity of operator+, but <strong>the function call to f3 may be evaluated first, last, or between f1() or f2() at run time.</strong></p>
</blockquote>
<p>If order is important, you do</p>
<pre><code>int a = f1();
int b = f2();
int i = a + b;
</code></pre>
<p>If order isn't important, then the code is perfectly fine.</p>
",0
43960077,43959859,1,"<p>As you have pointed out, a Card's data (its identity plus some rules about it) are constant.  Moreover, they are known at compile time.  So:</p>

<pre><code>#include &lt;array&gt;

enum class Rank {
    None, Ace, Two, Three, Four // ...
};

struct Card
{
    Rank rank = Rank::None;
    std::array&lt;Rank, 2&gt; from = {};
    std::array&lt;Rank, 2&gt; to = {};
};

constexpr Card cards[] = {
    {},
    {Rank::Ace, {Rank::Two, Rank::Three}, {}},
    {Rank::Two, {}, {Rank::Ace}},
    {Rank::Three, {Rank::Four}, {Rank::Ace, Rank::Four}},
    {Rank::Four, {Rank::Three}},
};
</code></pre>

<p>You can make the arrays as large as you need.  Now you have a full set of data which is all known at compile time, and which is compact in storage.</p>
",3
43978240,43959859,0,"<p>You cannot construct <code>const</code> objects referring to each other without breaking the rules of constructing them properly.  But.... </p>

<p>You can statically construct them read-write, as <code>private</code>, <code>static</code> class members, and then publish <code>const</code> references to them.  This will make the access to those members read-only.</p>

<h1>sample.h</h1>

<pre><code>class Sample {
    const int priv_ro;  /* this is true const field */
    int       priv_rw;  /* this is read-write */
public:
    const int&amp; pub_ro_ro; /* read only alias */
    const int&amp; pub_rw_ro; /* idem */
    //int&amp; pub_ro_rw; /* error, cannot alias a const as read write */
    int&amp; pub_rw_rw; /* correct, public read write alias to private field */
    static Sample global_rw; /* static global variable (read-write) */
    static const Sample global_ro; /* static global variable (read-only) */
private:
    Sample(int ro, int rw):
        priv_ro(ro),
        priv_rw(rw),
        pub_ro_ro(this-&gt;priv_ro),
        pub_rw_ro(this-&gt;priv_rw),
        pub_rw_rw(this-&gt;priv_rw)
    {
        //priv_ro = ro; /* error, priv_ro is const */
        priv_rw = rw; /* ok */
    }
};
</code></pre>

<h1>sample.cc</h1>

<pre><code>#include ""sample.h""

Sample Sample::global_rw(8,3);
const Sample Sample::global_ro(5,2);
</code></pre>

<h1>main.cc</h1>

<pre><code>#include &lt;iostream&gt;
#include ""sample.h""

#define P(x) do{ std::cout &lt;&lt; #x "" = "" &lt;&lt; x &lt;&lt; std::endl; } while(0)

int main()
{
    P(Sample::global_rw.pub_ro_ro);
    P(Sample::global_rw.pub_rw_ro);
    P(Sample::global_rw.pub_rw_rw);
    P(Sample::global_ro.pub_ro_ro);
    P(Sample::global_ro.pub_rw_ro);
    P(Sample::global_ro.pub_rw_rw);
    // Sample::global_ro.pub_ro_ro = 0; /* cannot assign. */
    // Sample::global_ro.pub_rw_ro = 0; /* cannot assign. */
    // Sample::global_ro.pub_rw_rw = 0; /* cannot assign. */
    // Sample::global_rw.pub_ro_ro = 0; /* cannot assign. */
    // Sample::global_rw.pub_rw_ro = 0; /* cannot assign. */
    Sample::global_rw.pub_rw_rw = 0;
    P(Sample::global_rw.pub_ro_ro);
    P(Sample::global_rw.pub_rw_ro);
    P(Sample::global_rw.pub_rw_rw);
    P(Sample::global_ro.pub_ro_ro);
    P(Sample::global_ro.pub_rw_ro);
    P(Sample::global_ro.pub_rw_rw);
}
</code></pre>

<h1>Makefile</h1>

<pre><code>targets=sample

sample_objs=sample.o main.o
sample: $(sample_objs)
    $(CXX) $(LDFLAGS) -o $@ $(sample_objs)
</code></pre>

<p>If you uncomment the commented lines, you'll see the non-accessible field or <code>const</code> definition error.</p>
",0
40759650,40741984,0,"<p>I solved it rewriting everything to:</p>

<pre><code>//split names
                std::vector&lt;std::wstring&gt; split_names;
                std::stringstream ss;
                ss.str(names);
                std::string name;
                while (std::getline(ss, name, ',')) {
                    split_names.push_back(std::wstring(name.begin(), name.end()));
                }

                std::vector&lt;const WCHAR*&gt; pszTags;
                pszTags.resize(split_names.size());
                for (int i = 0; i &lt; pszTags.size(); i++)
                    pszTags[i] = split_names[i].c_str();
</code></pre>

<p>Sorry for the inconvenience.</p>
",0
46946665,46937653,0,"<p>So thanks to Rusty, this is what I made:</p>

<p>In main.cpp:</p>

<pre><code>struct PFUNC
{
    void (*func)(void* classvar, void* arg0);
    void* classvar;
}
vector &lt;PFUNC&gt; onFrameMove;

void FrameMove(int frame,POINT pt)
{
    #some jobs here

    for(int i=0;i&lt;onFrameMove.size();i++)
         onFrameMove[i].func(onFrameMove[i].classvar, onFrameMove[i].arg0);
}
</code></pre>

<p>in SPRITE.cpp:</p>

<pre><code>SPRITE::SPRITE(MAINCLASS* main)
{
    PFUNC fc;
    fc.classvar = this;
    fc.func = &amp;FrameMoveCB;
    main-&gt;onFrameMove.push_back(fc);        //add to the main job
}

void FrameMoveCB(void* classobject, void* arg0)   //callback to translate the void*s
{
    SPRITE* Sprite= (SPRITE*)classobject;

    Sprite-&gt;FrameMove(*(POINT*)arg0);     //call the true method
}

void SPRITE::FrameMove(POINT pt)
{
    //more job here
}
</code></pre>

<p>So my main loop handle all the job and I don't have to modify it while adding new classes.</p>

<p>If someone have simpler I'll be happy, but that's good I think (and it work)</p>
",0
34981025,34980921,0,"<p>Avoiding the possible dynamic memory allocation will be more efficient for strings over a few chars long.</p>

<p>A good way to avoid when possible, is to let the caller pass a buffer to place the result in, and to provide a default wrapper using dynamic allocation of a suitable buffer (e.g. a <code>std::string</code>, as in your code).</p>

<p>However, unless measurements show this function to be absolutely critical performance-wise, that's most probably just wasted work: it's not something to do as a matter of course.</p>
",0
35226893,35226862,8,"<p><code>SomeEnum</code> is scoped to the class name it is declared in.  To use it you need <code>SomeClass::SomeEnum</code>.  This assumes that <code>SomeClass</code> is accessible in the scope you have it.  If not then you need <code>somespace::internal::SomeClass::SomeEnum</code></p>
",0
35289975,35289695,2,"<p>Your problem is that <code>std::atexit</code> can only register a true (unbound) function or a static method from a class but not a non static method.</p>

<p>If you do not need a pointer to the object, the simplest way would be to make the handler static:</p>

<pre><code>static void atexit_handler ()
{
    // Will cleanup some temp files and malloc things.
    cout &lt;&lt; ""Call atexit"" &lt;&lt;endl;
}
</code></pre>

<p>But anyway, if you create more than one object, you will register many times the same handler which is at least useless. If you really want (or need) to go that way you should:</p>

<ul>
<li>ensure you register the handler only once by using a static guard variable (and a mutex or other critical section if you want to be thread-safe)</li>
<li>register the objects that need processing in a standard container that would be a static member of the class</li>
<li>make the static handler process the registered objects</li>
</ul>

<p>But the idiomatic way of cleanup is simply to use a destructor and to ensure that all dynamic objects are correctly deleted before the program exits.</p>
",0
44377483,44377440,6,"<p>Your constructor initialization list <strong>copies</strong> the integer argument to the member variable.  The lifetime of your member variable is the lifetime of your object.</p>
",0
44377496,44377440,3,"<p>Yes, <code>temp</code> is destroyed, but before that it was copied during <code>d_member(in)</code> initialization. So nothing is wrong here</p>
",0
44377615,44377440,6,"<p>As others already mentioned with a non reference member variable your constructor call simply copies the value from the <code>const</code> reference parameter (and it even doesn't matter if you pass it by reference or value).</p>

<p>You would have a different situation, if your member variable is a reference like</p>

<pre><code>struct foo
{
    const int&amp; d_member; // &lt;&lt;&lt;&lt; reference member variable

    foo(const int &amp; in): d_member(in){};
};
</code></pre>

<p>In that case, accessing <code>d_member</code> after your scope block would raise <em>undefined behavior</em>:</p>

<pre><code>{
    int temp = 5;
    p = new foo(temp);
}

std::cout &lt;&lt; p-&gt;d_member &lt;&lt; std::endl; // &lt;&lt;&lt;&lt;  Undefined behavior
</code></pre>
",0
40557459,40497537,1,"<p><em>This is the closest thing to ""automatic"" that I could come up with:</em></p>

<p>For all structures that are going to be used within this persistent binary data, add an attribute with the expected instance size.</p>

<pre><code>struct MyPersistentBinaryStructure {
  // Expected size for 32/64-bit check.
  static constexpr size_t kExpectedInstanceSize = 80;

  ... 80 bytes of fixed size fields and appropriate padding ...
};
</code></pre>

<p>Then, in the code that looks up the address of structures within that binary data, check that value:</p>

<pre><code>template &lt;typename T&gt;
T* GetAsObject(Reference ref) {
  static_assert(std::is_pod&lt;T&gt;::value, ""only simple objects"");
  static_assert(T::kExpectedInstanceSize == sizeof(T), ""inconsistent size"");
  return reinterpret_cast&lt;T*&gt;(GetPointerFromRef(ref));
}
</code></pre>

<p>Any build that compiles the structure to a different size will give a compile-time error.  This doesn't future-proof the build because a definition that would be different for width X won't get caught until it is actually built on an architecture of width X, but at least you'll know and maybe be able to adapt the structure without breaking the format (e.g. 32-bit <code>int</code> -> <code>int32_t</code>).</p>

<p>Doing this turned out to be worth the effort as it immediately found three 32/64 incompatibilities within code that I'd manually checked with significant care.  Two of those errors would have caused data corruption; the other was just some extra tail padding.</p>
",0
39135082,39134436,3,"<p>The idea behind <code>std::logic_error</code> and derived classes is to be a bit like a glorified assert - and in the standard library they are used somewhat like that (think <code>vector::at</code> - what kind of recovery do you want to have from an invalid vector index? It just means that the logic is botched, it's just a friendly alternative to UB); also <code>invalid_argument</code> is used for something like that, IIRC in <code>std::bitset</code>.</p>

<p>But I agree that in general an ""invalid argument"" kind of exception can derive both from a ""logical"" or ""runtime"" error; my main point here is: don't seek much logic where there isn't any. </p>

<p>The whole <code>&lt;stdexcept&gt;</code> thing looks like it was jotted down as an afterthought before going to dinner, and then completely forgot. Extremely wide classes of errors are squarely divided into this logic/runtime dichotomy (of disputable value), essentially based on how they are used in the standard library for those that are used; those that aren't used (which should be a convenience for the programmer) are random both in choice (<code>overflow</code>/<code>underflow</code>/<code>domain_error</code> - maybe they were thinking just about mathematical functions?) and characterization (an <code>out_of_range</code> is ""logic"" but an <code>overflow</code> is ""runtime""? debatable at best).</p>

<p>In short: don't overthink the <code>stdexcept</code> ideas - they are vague, disputable and then hammered to fit some needs of the standard library. Derive the exception hierarchy that makes sense for your application from <code>std::exception</code> or <code>std::runtime_error</code> and be happy with it. </p>
",5
42654076,42653974,6,"<p>It's nothing to do with auto - this won't compile either:</p>

<pre><code>int main()
{
    int a[5];
    for(( int n : a )) {
    }
}
</code></pre>

<p>The extra brackets attempt to turn whats inside them into an expression.</p>
",0
40557732,40557699,3,"<p>Your code has unsequenced modifications of the variable <code>s</code>. This behaviour is undefined. You can fix it by using indexes instead of advancing the pointer (I'm assuming you're reading a little-endian variable. This is non-obvious from your code):</p>

<pre><code>uint64_t output =
     (((uint64_t)s[0]) &lt;&lt; 56) +
     (((uint64_t)s[1]) &lt;&lt; 48) +
     (((uint64_t)s[2]) &lt;&lt; 40) +
     (((uint64_t)s[3]) &lt;&lt; 32) +
     (((uint64_t)s[4]) &lt;&lt; 24) +
     (((uint64_t)s[5]) &lt;&lt; 16) +
     (((uint64_t)s[6]) &lt;&lt;  8) +
     (((uint64_t)s[7])        );
</code></pre>
",0
40557749,40557699,1,"<p>Your code modifies the value of <code>s</code> seven times within an instruction, and then uses it an eighth time.  Neither the C Standard or the C++ Standard imposes <em>any</em> requirements upon what an implementation would do if it receives input that could cause such code to be executed or make its execution inevitable.  Note, though, that the existence of such code in an application would not affect the correctness of the application <em>if the program never receives input that would make the execution of the code inevitable</em>, so it isn't a compilation error.  Adjusting the code using s[0], s[1], s[2], etc. would make the code clearer and avoid such problems.</p>
",1
36783135,36783106,4,"<p>It's because nothing happened to it. It's still empty.</p>

<p>You made a copy of the vector in <code>temp</code>, and you modified the copy, and not the original class member. You should use a reference:</p>

<pre><code> vector&lt;int&gt; &amp;temp = ob.get();
</code></pre>

<p>Since you are returning a reference from <code>get()</code>, you have to assign it to a reference. If you don't, you're just making a copy of the object.</p>

<p>EDIT: Also, change <code>get()</code> to return a mutable reference, rather than a <code>const</code> reference.</p>
",1
36783159,36783106,3,"<p>You are not modifying the <code>vector</code> that is inside of the <code>A</code> class.  <code>get()</code> returns a (<strong>const!</strong>) reference, which you are then assigning to a <em>non-reference</em> variable, so a <em>copy</em> of the <code>vector</code> is being created.  You are then modifying the copy but printing out the original.</p>

<p>You need to do this instead:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class A
{
    public:
        vector&lt;int&gt; T;

        vector&lt;int&gt;&amp; get(){
            return T;
        }

        void print(){
            cout &lt;&lt; "" size is "" &lt;&lt; T.size();
           // cout &lt;&lt; "" \nelements are %d "" &lt;&lt; T[0];
        }
};

int main()
{
   cout &lt;&lt; ""Hello World"" &lt;&lt; endl; 

   A ob;
   vector&lt;int&gt; &amp;temp = ob.get();
   temp.clear();
   temp.push_back(3);
   temp.push_back(5);

   ob.print();
   return 0;
}
</code></pre>
",0
36783186,36783106,2,"<p>Two problems.</p>

<p>First, your <code>A::get()</code> method returns a const reference to its member. You cannot modify the vector through a const reference.</p>

<p>Second, you're modifying the <code>temp</code> vector that is just a copy of the returned value.</p>
",0
43770842,43769773,0,"<p>That really depends on what you mean by ""large enough"". <code>char16_t</code> is not ""a type large enough to hold any Unicode character including those which I'm not allowed to use"". <em>You</em> chose to try to cram <a href=""http://www.unicode.org/versions/corrigendum9.html"" rel=""nofollow noreferrer""><code>\uFFFF</code>, which is ""reserved for internal use""</a>, into a <code>char16_t</code>, and thus you are the one at fault. The program is simply doing as you instructed.</p>
",11
43771344,43769773,5,"<p>The standard is quite explicit, <code>std::char_traits&lt;char16_t&gt;::int_type</code> is a typedef for <code>std::uint_least16_t</code>, see  [char.traits.specializations.char16_t], which also says:</p>

<blockquote>
  <p>The member <code>eof()</code> shall return an implementation-defined constant that cannot appear as a valid UTF-16 code unit.</p>
</blockquote>

<p>I'm not sure precisely how that interacts with <a href=""http://www.unicode.org/versions/corrigendum9.html"" rel=""nofollow noreferrer"">http://www.unicode.org/versions/corrigendum9.html</a> but existing practice in the major C++ implementations is to use the all-ones bit pattern for <code>char_traits&lt;char16_t&gt;::eof()</code>, even when <code>uint_least16_t</code> has exactly 16 bits.</p>

<p>After a bit more thought, I think it's possible for implementations to meet the Character traits requirements by making <code>std::char_traits&lt;char16_t&gt;::to_int_type(char_type)</code> return U+FFFD when given U+FFFF. This satisfies the requirement for <code>eof()</code> to return:</p>

<blockquote>
  <p>a value <code>e</code> such that <code>X::eq_int_type(e,X::to_int_type(c))</code> is <code>false</code> for all values <code>c</code>.</p>
</blockquote>

<p>This would also ensure that it's possible to distinguish success and failure when checking the result of <code>basic_streambuf&lt;char16_t&gt;::sputc(u'\uFFFF')</code>, so that it only returns <code>eof()</code> on failure, and returns <code>u'\ufffd'</code> otherwise.</p>

<p>I'll try that. I've created <a href=""https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80624"" rel=""nofollow noreferrer"">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80624</a> to track this in GCC.</p>

<p>I've also reported an <a href=""http://wg21.link/lwg2959"" rel=""nofollow noreferrer"">issue</a> against the standard, so we can fix the ""cannot appear as a valid UTF-16 code unit"" wording, and maybe fix it some other way too.</p>
",10
37295714,37295656,7,"<blockquote>
  <p>This makes each member of it also const thus <code>parent_</code> becomes <code>const Base *</code>.</p>
</blockquote>

<p>No, the pointer will become const itself, not the object it points to. So <code>parent_</code> becomes <code>Base * const</code>, not <code>const Base *</code>, and your code is valid.</p>
",0
37295765,37295656,5,"<pre><code>Base* parent() const { return parent_; }
</code></pre>

<p>Unfortunately, this is problem with C++. Method is <code>const</code>, but it is returning a non-const pointer, which would allow following operation to succeed:</p>

<pre><code>p-&gt;a = 10; // &lt;- is this correct?
</code></pre>

<p>It is programmer's responsibility not to return non-const pointer or references from functions (method being const or not). </p>
",2
37295999,37295656,0,"<p>As <strong>tobi303</strong> points out below, this answer is <strong>wrong</strong>. Keeping it here for the sake of the discussion below.</p>

<hr>

<p>I could be wrong, but this line:</p>

<pre><code>    Base* parent() const { return parent_; }
</code></pre>

<p>does not mention anything about returning const objects. It is equivalent to</p>

<pre><code>    Base* parent() const { return this-&gt;parent_; }
</code></pre>

<p>where <code>this</code> is <code>const Derived*</code>, but <code>parent_</code> is still <code>Base*</code>.</p>
",5
37297380,37295656,0,"<p>A const method only prevents the method from modifying any non-mutable data members of the class. </p>

<p>If you want to not allow the modification of <code>a</code> and don't want to update the class, you need to write:</p>

<pre><code>const Base *p = derived-&gt;parent();
</code></pre>

<p>However, I would recommend you to not return non-const data members from a class as ref or pointer because this breaks the data encapsulation concept of C++. This is the same, of course, with the public <code>a</code>.</p>
",0
41198139,41198075,21,"<p>Long story short, it was easier to disallow this than to allow.</p>

<p>Here is an example that shows what could be difficult about it: C++ lets you combine nested class definition with a member declaration, like this:</p>

<pre><code>class Foo {
    class Bar {
        Foo member;
    } bar; // &lt;&lt;== Here
};
</code></pre>

<p>It is clear why this definition must be disallowed: unlike a class definition which could have been OK, member definition makes size computation impossible.</p>

<p>Of course the writers of the standard could have allowed class definitions to pass, at the expense of giving compiler writers additional work. However, it looks like they decided that allowing this feature is not worth the trouble, so they didn't make it an exception from the requirement of the class to be complete at the point of declaring an instance.</p>
",2
41198277,41198075,19,"<p>There is nothing wrong with what you what to do, and you can do so with different syntax.</p>

<p>Since the compiler wants to determine the size of class Bar, it needs to know the size of class Foo, But Foo's definition is not yet complete (The source code has not been entirely parsed by the compiler).  The definition of Foo must be completed before using it in Bar.</p>

<p>Instead try forward declaring Bar inside Foo, then completing the definition of Bar after Foo, This way the size of Foo can be determined for use in Bar.</p>

<pre><code>class Foo {
    class Bar;
};
class Foo::Bar {
  Foo member;
};
</code></pre>
",2
41198296,41198075,6,"<p>It's not allowed because you can't define a class with a member with an incomplete type, period.  At the end of the class definition the class becomes complete and that is only possible if the sizes of all of its members are known.</p>

<p>For example, you get the same error, for the same reason, without nesting classes like this:</p>

<pre><code>class Foo;
class Bar {
    Foo member;
};
</code></pre>

<p>Sure, in your example the language could defer completing the definition of <code>Foo::Bar</code> until <code>Foo</code> is defined, but this would be inconsistent with how classes are defined generally. You'd have the weird behaviour of <code>Foo::Bar</code> being incomplete at a point in the source code after it was fully defined.</p>
",0
41002961,41002649,3,"<p>You can lift the <code>static</code> property to a single instance and use a template:</p>

<pre><code> template&lt;typename Derived&gt;
 class StaticInterface {
 protected:
      StaticInterface() {}
 public:
      virtual ~StaticInterface() {}
      static Derived&amp; instance() {
           Derived theInstance;
           return theInstance;
      }

      // The interface:
      virtual void foo() = 0;
      virtual void bar() = 0;
 };
</code></pre>

<p>And use that like</p>

<pre><code> class DervivedA : public StaticInterface&lt;DerivedA&gt; {
      template&lt;typename Derived&gt;
      friend class StaticInterface&lt;Derived&gt;;
      DerivedA() {}
 public:
      virtual void foo() {};
      virtual void bar() {};
 };

 class DervivedB : public StaticInterface&lt;DerivedB&gt; {
      template&lt;typename Derived&gt;
      friend class StaticInterface&lt;Derived&gt;;
      DerivedB() {}
 public:
      virtual void foo() {};
      virtual void bar() {};
 };
</code></pre>

<hr>

<p>Or omit the <code>virtual</code> part (and creation of a <em>""costly""</em> vtable) completely:</p>

<pre><code> template&lt;typename Derived&gt;
 class StaticInterface {
 protected:
      StaticInterface() {}
 public:
      ~StaticInterface() {}
      static Derived&amp; instance() {
           Derived theInstance;
           return theInstance;
      }

      // The interface:
      void foo() {
          Derived::foo_impl();
      }
      void bar() {
          Derived::bar_impl();
      }
 };

 class DervivedA : public StaticInterface&lt;DerivedA&gt; {
      template&lt;typename Derived&gt;
      friend class StaticInterface&lt;Derived&gt;;
      DerivedA() {}
 public:
      void foo_impl() {};
      void bar_impl() {};
 };
</code></pre>
",7
37300091,37299780,1,"<p>The errors are pretty clear</p>

<blockquote>
  <p>object of type 'MyClass' cannot be assigned because its copy assignment operator is implicitly deleted</p>
</blockquote>

<p>So, the copy assignment is implicitly deleted, you have to specify/create one yourself.</p>

<p>The reason why it is deleted is because of <code>dep_1</code>, as you can see from the second error</p>

<blockquote>
  <p>copy assignment operator of 'MyClass' is implicitly deleted because field 'dep_1' has a deleted copy assignment operator</p>
</blockquote>

<p>Now, if you want to know why <code>dep_1</code> doesn't have a copy assignment operator, look at the third error:</p>

<blockquote>
  <p>copy assignment operator of 'Dependancy' is implicitly deleted because field '_bar' has no copy assignment operator</p>
</blockquote>

<p>It all boils down to <code>_bar</code> of type <code>Bar</code> not having a copy assignment operator, because it has been defined as <code>const</code>.</p>

<p>As you said, you can't change the class <code>Dependancy</code>, so the only solution is to make a copy assignment operator in <code>MyClass</code> yourself.</p>
",2
37345751,37218024,2,"<p>I would suggest to use:</p>

<pre><code>std::cout &lt;&lt; '\n';  /* Use std::ios_base::sync_with_stdio(false) if applicable */
</code></pre>

<p>or</p>

<pre><code>fputc('\n', stdout);
</code></pre>

<p>And turn the optimization on and let the compiler decide what is best way to do this trivial job.</p>
",0
46088553,46088369,1,"<p>You did not consider the case when <code>b</code> is 3. Use this as your compare function.</p>

<pre><code>auto plarger = [](int a, int b)
{
  if ((a == 3) &amp;&amp; (b != 3))
  {
    return true;
  }
  else if ((b == 3) &amp;&amp; (a != 3))
  {
    return false;
  }
  else return a&gt;b;
};
</code></pre>
",3
46088673,46088369,0,"<p>i don't know why ,but i see the first time the a ==4 b==3,so your return true never run.
<a href=""https://i.stack.imgur.com/ThKH5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/ThKH5.png"" alt=""enter image description here""></a></p>
",1
45749833,37927205,1,"<p>This is something I've been trying to figure out myself. I had a hypothesis, but no real evidence for it. However, the document the rule originated in (<a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2079.pdf"" rel=""nofollow noreferrer"">N2079</a> as linked by @T.C.) confirmed part of my theory.</p>

<p>Note that the function that the rule comes from takes in a <code>std::seed_seq</code> object in the document, and not a templated class. This means that when the rule was written, it was made specifically for <code>std::seed_seq</code>, and not the concept of a SeedSequence in general. This means that we can look at the <code>std::seed_seq</code> class for information about this, specifically with how <code>std::seed_seq::generate</code> is defined.</p>

<p>The method that <code>std::seed_seq::generate</code> uses is well explained <a href=""http://en.cppreference.com/w/cpp/numeric/random/seed_seq/generate"" rel=""nofollow noreferrer"">on cppreference.com</a>. It's a bit complicated, but it can be summarized in 4 stages.</p>

<ol>
<li><p>Initialize the output range with some initial data (I'm including <code>k=0</code> here)</p></li>
<li><p>Move the original seed data into the output range (<code>k=1..s</code>)</p></li>
<li><p>Extend the seed data into the rest of the output range (<code>k=s+1..m-1</code> where <code>m=max(s+1, n)</code>)</p></li>
<li><p>Shuffle the data in the output range (<code>k=m..m+n-1</code>)</p></li>
</ol>

<p>When seeding a <code>std::linear_congruential_engine</code> with the modulo &lt;= 2<sup>32</sup> (which includes <code>std::minstd_rand</code> and <code>std::minstd_rand0</code>), it should only need to generate 1 value from <code>std::seed_seq</code>, but with this rule, it generates 4. So what changes in this algorithm when changing <code>n</code> from 1 to 4?</p>

<p>One part that changes is that the shuffling stage goes from 1 iteration to 4. Since one of the goals of <code>std::seed_seq</code> is to produce high quality seeding values ""given a small seed or a poorly distributed initial seed sequence.`, these extra shuffling iterations likely improve the resulting seed value. The reason why it drops the first 3 values instead of the last is because the later values are (usually) the ones that get shuffled more.</p>

<p>It's also worth noting that a key equation of all 4 stages is the value <code>begin[k]^begin[k+p]^begin[k?1]</code> (with XOR replaced with addition in the last stage). When <code>n=1</code>, this simply becomes <code>begin[k]</code> (or <code>3*begin[k]</code> for the last stage) (note that ""the indexing of the output range <code>begin[x]</code> is taken modulo n"" and <code>x % 1 == 0</code>). When <code>n=4</code>, this equation works more like it was intended to, which helps shuffle the data around more effectively.</p>

<p>So the short answer is that <code>std::linear_congruential_engine</code> discards 3 numbers generated by the seed sequence because having <code>std::seed_seq</code> generate those numbers improves the quality of the values it actually uses. Now, the decision to discard these numbers in the generator was decided before the <em>generic concept</em> of SeedSequence was defined, so it made more sense to solve the issue in the generator, instead of overcomplicating the seed sequence class. However, this now means that the first 3 values generated by <strong>any</strong> seed sequence are discarded. Whether or not that's worth it is probably debatable, but it is the way it is now.</p>
",0
41677628,28765811,0,"<p>the answer comes late, but I had the same problem right now :D <br>
I've got a <code>std::vector&lt; std::pair&lt; int, std::vector&lt; MyClass &gt; &gt; &gt; complexVector</code>.
If I call <code>complexVector.clear()</code>, the content is not cleared, I explicitly must iterate over <code>complexVector</code> and call <code>complexVector[i].second.clear()</code> to delete the content of the inner vector. Additionally clear <code>first</code><br>
I am happy about suggestions for 'better' solutions :)</p>
",0
45081551,45081391,4,"<p>Every member function has an implicit <code>this</code> parameter. The static type of <code>this</code> inside <code>f1</code> is always <code>A * const</code>. This is true for any member function. The static type of the implicit object parameter is the enclosing class where the function is <strong>defined</strong>. </p>

<p>The call inside <code>f1</code> is resolved as <code>this-&gt;f2()</code>. Since this is a call via pointer, the function <code>f2</code> is dispatched dynamically. This is despite the fact the <code>f1</code> is not virtual, and will always be called by static dispatch.</p>

<p>By whatever mechanism the compiler uses (a VTable is an <em>implementation detail</em>, not mandated by the C++ standard itself), we get a call to <code>C::f2</code>.</p>

<p>So your assumptions need some revision, I'd say.</p>

<hr>

<p>To answer your question as you specified in the comments. <code>C::f2</code> is virtual. You may have omitted the virtual specifier when overriding it, but there is no ""unvirtualising"" it.</p>
",6
38867432,38867348,3,"<p>You defined a function!</p>

<pre><code>ProcessingThread processingThread(
    std::shared_ptr&lt;circular_buffer&lt;bitset&lt;32&gt;&gt;&gt;(circularBuffer) );
</code></pre>

<p>is a function which has one argument of type <code>std::shared_ptr&lt;circular_buffer&lt;bitset&lt;32&gt;&gt;&gt;</code>. Easy solution:</p>

<pre><code>ProcessingThread processingThread(
    std::shared_ptr&lt;circular_buffer&lt;bitset&lt;32&gt;&gt;&gt; { circularBuffer } );
</code></pre>
",4
44697747,44697699,2,"<p><code>'0'</code> is <em>not</em> the same as <code>'\0'</code> which is probably what you wanted. (No <em>encoding</em> system supported by C++ is allowed to set the character literal <code>'0'</code> to have the value 0.)</p>

<p>The behaviour on using <code>strlen</code> on this memory block will be undefined.</p>

<p>If you want to populate with the character 0, then remember to add a NUL-terminator to the memory block, in order for the C-type string functions (and <code>&lt;&lt;</code> for that matter) to be usable.</p>
",5
44697870,44697699,1,"<p>Because both strlen and cout rely on a null terminator to indicate the end of the string</p>
",0
44698152,44697699,2,"<p>Both <code>strlen</code> and <code>operator&lt;&lt;(basic_ostream&amp;, char*)</code> have the precondition that the pointer arguments point to a null terminated string of characters. Your array is not null terminated and therefore you violate those preconditions. As a result, the behaviour of your program is undefined.</p>

<hr>

<blockquote>
  <p><strong>UPDATE:</strong> I don't with to use a null terminator. Is there a better alternative?</p>
</blockquote>

<p>There is no need for an alternative for <code>strlen</code> since you already know the length: <code>l</code>.</p>

<p>For streaming a non-null-terminated character array, you can use an iterator:</p>

<pre><code>std::ostream_iterator&lt;char&gt; it(std::cout);
std::copy(leading, std::end(leading), it);
</code></pre>

<hr>

<p>PS.</p>

<blockquote>
<pre><code>std::cin &gt;&gt; l;
char leading[l];
</code></pre>
</blockquote>

<p>This is ill-formed in C++. The size of an array must be a compile-time constant.</p>
",2
45789427,45789385,2,"<p>g++ compiler flag: -fsyntax-only
or <a href=""https://github.com/flycheck/flycheck"" rel=""nofollow noreferrer"">Flycheck</a></p>
",2
47978123,47978058,2,"<p>It means you declare an illegal member. Plainly put at <a href=""https://timsong-cpp.github.io/cppwp/n4659/class.bit#3"" rel=""nofollow noreferrer"">[class.bit/]3</a>:</p>

<blockquote>
  <p>A bit-field shall not be a static member. A bit-field shall have
  integral or enumeration type ([basic.fundamental]).</p>
</blockquote>

<p>Which refers you to the fundamental types section to clarify what an integral or enumeration type is. An array is not one of those. And the <code>[x]</code> in the member declarator tries to make it into one.</p>

<p>The error message text itself could be better phrased however.</p>
",0
44233529,30639048,1,"<p>The question is asking: Write one line of code to prototype a template function using type: RapidDog. In this case, ""T"" is just the unknown type T that the professor must be referring to. So here the type is RapidDog, leading to:</p>

<pre><code>void enemyAdjust(RapidDog  objparm);
</code></pre>

<p>Another template example would be this:</p>

<pre><code>template&lt;class  T&gt;   T  func1(T  a, T  b) 
</code></pre>

<p>and just use the type that you wish. It's just plain substitution.</p>

<pre><code>int func1(int a, int b);
double func1(double a, double b);
</code></pre>
",0
43930899,43930828,4,"<p>In the following line:</p>

<pre><code>Point p1 = c.getLocation();
</code></pre>

<p><code>p1</code> is not a reference, so basically you're copying the referenced object returned by <code>getLocation()</code>, thus calling copy constructor.</p>

<p>A solution would be to declare <code>p1</code> as a reference like this:</p>

<pre><code>Point&amp; p1 = c.getLocation();
</code></pre>
",1
34970715,34970614,1,"<p>Some static variables like <code>S_APP_EXIT</code> depend on other static variables (e.g. <code>nextState</code>) for their initialization.</p>

<p>Read about the <a href=""https://isocpp.org/wiki/faq/ctors#static-init-order"" rel=""nofollow"">static initialization order fiasco</a> and fix your code accordingly (making <code>nextState</code> a private variable?). You might even think of using the <em>Construct On First Use Idiom</em> (explained in the other FAQ <a href=""https://isocpp.org/wiki/faq/ctors#static-init-order-on-first-use"" rel=""nofollow"">here</a>).</p>

<p>Anyway I wouldn't generally advise keeping all those variables static, but it's quite hard to tell from just the excerpt you posted (where is <code>CS_SUCCESS</code> defined?).</p>
",0
43211780,43209685,0,"<p>You seem to have to rely on static allocation:</p>

<pre class=""lang-cpp prettyprint-override""><code>Transcaction Transcactions[10000];
</code></pre>

<p>Well, do so the same with your accounts:</p>

<pre class=""lang-cpp prettyprint-override""><code>Account accounts[1000];
</code></pre>

<p>You will have to create an appropriate account class, though, it might look similar to your transaction class with a member for id and balance. You might want to provide appropriate constructors to facilitate further work with it:</p>

<pre class=""lang-cpp prettyprint-override""><code>struct Account
{
    char id[128];
    int balance;

    Account(char const* theId = nullptr, int balance = 0)
        : balance(balance)
    {
        if(theId)
        {
            strncpy(id, theId, sizeof(id));
            // just for the case of theId begin too long:
            id[sizeof(id) - 1] = 0;
        }
    }
    Account(Account const&amp; other) = default;
};
</code></pre>

<p>Further details ommitted... Be aware that you get a default assignment operator, too.</p>

<p>Your transaction class, though, appears inappropriate to me. A transaction essentially requires a source account, a destination account and the amount to be transferred. Id is optional, but can be useful. Depending on your needs, you <em>could</em> use a pointer to the corresponding account instance or the index wihtin your companies account array:</p>

<pre class=""lang-cpp prettyprint-override""><code>struct Transaction
{
    unsigned int id;
    unsigned int sourceAccountIndex; // alternative: pointer or id string
    unsigned int destinationAccountIndex;  // alternative: pointer or id string
    int amount;
};
</code></pre>

<p>Using indices or pointers, you get quicker access to the related accounts, however, you have to consider pointers/indices getting invalid if you're ever going to delete accounts again. This is not too difficult to cope with, if you don't want to, you still can keep the account id as you have now (but you need two of them!).</p>

<p>With the array class members, you get your copy constructor for free! Just declare it:</p>

<pre class=""lang-cpp prettyprint-override""><code>Company(Company const&amp; other) = default;
</code></pre>

<p>If you want or have to write the copy constructor explicitly, simply iterate over the arrays and copy the entries (normally, you'd prefer std::copy, but as STL is explicitly excluded...):</p>

<pre class=""lang-cpp prettyprint-override""><code>Company::Company(Company const&amp; other)
{
    for(unsigned int i = 0; i &lt; sizeof(accounts)/sizeof(*accounts); ++i)
    {
        accounts[i] = other.accounts[i];
    }
    // transactions analogously
}
</code></pre>

<p>Finally: Your account function would iterate over the entries and return the first account the id matches:</p>

<pre class=""lang-cpp prettyprint-override""><code>Company::Account* Company::account(char const* id)
{
    for(unsigned int i = 0; i &lt; sizeof(accounts)/sizeof(*accounts); ++i)
    {
        if(strcmp(id, accounts[i].id) == 0)
        {
            return accounts + i;
        }
    }
    return nullptr;
}
</code></pre>

<p>Variant of using pointers (the one I personally would prefer):</p>

<pre class=""lang-cpp prettyprint-override""><code>Company::Account* Company::account(char const* id)
{
    Account* end = accounts + sizeof(accounts)/sizeof(*accounts);
    for(Account* a = accounts; a != end; ++a)
    {
        if(strcmp(id, a-&gt;id) == 0)
        {
            return a;
        }
    }
    return nullptr;
}
</code></pre>

<p>A last hint: with every new Transaction being created, do not forget to adjust the balances of the involved accounts!</p>
",1
36332983,36331171,0,"<p>A recent version of boost::variant, std::regex and c++14 gives us:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;boost/variant.hpp&gt;
#include &lt;iomanip&gt;
#include &lt;regex&gt;
#include &lt;stdexcept&gt;
#include &lt;exception&gt;
#include &lt;sstream&gt;

struct variant_value
{
    static auto evaluate(const std::string&amp; s)
    {
        static const std::regex syntax(R""regex((.*)\((.*)\))regex"");
        std::smatch result;
        if (std::regex_match(s, result, syntax))
        {

            if (result[1].str() == ""int"")
            {
                return variant_type(int(std::stoi(result[2].str())));
            }
            if (result[1].str() == ""string"")
            {
                std::stringstream ss(result[2].str());
                std::string rs;
                ss &gt;&gt; std::quoted(rs, '\'');
                return variant_type(rs);
            }
            if (result[1].str() == ""float"" || result[1].str() == ""double"")
            {
                return variant_type(std::stod(result[2].str()));
            }
        }
        throw std::invalid_argument(s);
    }

    variant_value(const std::string&amp; s)
    : _vnt(evaluate(s))
    {}

    template&lt;class F&gt;
    decltype(auto) visit(F&amp;&amp; f) {
        return boost::apply_visitor(std::forward&lt;F&gt;(f), _vnt);
    }

    using variant_type = boost::variant&lt;std::string, int, double&gt;;



    variant_type _vnt;
};

// now test
int main()
{
    auto a = variant_value(""string('hello world')"");
    auto b = variant_value(""int(10)"");
    auto c = variant_value(""float(6.43)"");

    auto print = [](const auto&amp; x) { std::cout &lt;&lt; x &lt;&lt; std::endl; };

    a.visit(print);
    b.visit(print);
    c.visit(print);

    return 0;
}
</code></pre>

<p>expected output:</p>

<pre><code>hello world
10
6.43
</code></pre>
",0
34895252,34895237,2,"<p>Put <code>break point</code> in the <code>copy constructor</code> for the objects that are copied and debug.</p>
",5
34895335,34895237,1,"<p>Maybe not a smart way, you can make the copy ctor of the class <code>deleted</code>, and confirm all the compile errors.</p>
",3
45749711,45749445,5,"<p>You can use an alias inside an unnamed namespace.</p>

<pre><code>namespace a_long_namespace_name {
    void someFunc() {};
}

namespace b {
    namespace { // an unnamed namespace
        namespace a = a_long_namespace_name; // create a short alias
    }

    void someOtherFunc() {
        a::someFunc();
    }
}

b::a::someFunc(); // compiler error
</code></pre>

<p>You would still need to be writing the namespace to call a function, but it makes calls way shorter.</p>
",0
47984831,47984796,3,"<p><code>friend</code> means, that the specific function or <code>class</code>/<code>struct</code> has <code>private</code> visibility. This means, it has full access to all your members. That doesn't do much in your case, but should never be done without a good reason.</p>

<p>I think, what you are looking for, is the <code>static</code> keyword.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

class A {
    public:
      A() { }
      static void print(std::string str);
};

class B {
    public:
       B() { }
       void set(std::string str);
};

void A::print(std::string str) 
{ 
    std::cout &lt;&lt; str &lt;&lt; std::endl; 
}

void B::set(std::string str) 
{ 
    A::print(str); // &lt;--  error: ¡®print¡¯ was not declared in this scope
}

int main(int argc, char *argv[])
{
    B b;
    b.set(""hello"");
    return 0;
}
</code></pre>

<p>EDIT: Didn't saw, that the question was without usage of static. I don't know, whats wrong with static in that case, but you can either declare print as a free function, or create an instance of A and call print this way.</p>

<pre><code>void B::set(std::string str) 
{
    A a;
    a.print(str);
}
</code></pre>

<p>There is no other solution for you. You have to specify your need exactly.</p>
",0
40759116,40758828,3,"<p>The <a href=""https://msdn.microsoft.com/en-us/library/96ayss4b.aspx"" rel=""nofollow noreferrer"">MSDN documentation</a> for <code>_popen</code> states:</p>

<blockquote>
  <p>If used in a Windows program, the <code>_popen</code> function returns an invalid
  file pointer that causes the program to stop responding indefinitely.
  <code>_popen</code> works properly in a console application.</p>
</blockquote>

<p>I'm assuming that C++ Builder is creating a Windows application and not a Console application.</p>
",3
40538439,40537816,1,"<p>Do <code>reinterpret_cast&lt;void *&gt;(const_cast&lt; __CFDictionary * &gt;(dictionary))</code></p>

<p><code>const_cast</code> is only designed to cast between <code>const</code> pointers or references and their non-<code>const</code> equivalents. To convert to a different type (<code>void*</code> in your case), you need to use <code>reinterpret_cast</code>. <code>reinterpret_cast</code> basically ""reinterprets"" the same sequence of bits as a different type. However, it is not allowed to cast away constness, so you need to use both casts together.</p>

<p>EDIT: As @AnT points out, since the target is <code>void *</code>, you can use <code>static_cast</code> instead of <code>reinterpret_cast</code>. In fact, it is considered safer, because the standard guarantees that you get the same address as a result. <code>reinterpret_cast</code>, on the other hand, only guarantees that the original value will be obtained by <code>reinterpret_cast</code> ing the result of the first cast back. However, this applies only for a restricted set of conversions (<code>void *</code>, Base-derived class pairs). <code>reinterpret_cast</code> is more general, although you are relying on the compiler to do the reasonable thing.</p>
",3
39665381,39665319,4,"<p>The reason you have nothing is your copy constructor is incorrect.  You make a copy of <code>temp</code> when you add it into the list and it is this copy that you are accessing.</p>

<p>You have</p>

<pre><code>Animal::Animal(const Animal&amp; orig) {
}
</code></pre>

<p>Which means when you make a copy, all the members of the class are default initialized and nothing else happens.</p>

<p>The simplest solution is to just get rid of it and let the compiler provided default copy constructor do the copy for you.</p>
",0
39665398,39665319,3,"<pre><code>Animal::Animal(const Animal&amp; orig) {
}
</code></pre>

<p>This is a (empty) copy constructor. Thus when copying an object of your class, e.g. when you ...</p>

<pre><code>animal_list.push_back(temp);
</code></pre>

<p>... add it to the list, the copy won't set it members appropriately.</p>

<p>Solution: Just remove that copy constructor (as well as the destructor). See the <a href=""http://en.cppreference.com/w/cpp/language/rule_of_three"" rel=""nofollow"">rule of zero</a>.</p>
",1
36267193,36267134,1,"<p>It's valid.</p>

<p>Access restrictions are emplaced on the <em>names</em> of the members, not the members themselves. (Otherwise many getters would not work!)</p>

<p>A function that has been permitted (by being a member function) to access that member by name, has decided to pass along a pointer to that object. If you don't want that to happen, don't do it.</p>

<p>It would not actually be possible, in the general case, for the compiler to detect and block this code even if it were supposed to.</p>
",0
36267214,36267134,2,"<p>The <code>private</code> and <code>public</code> sections control visibility of the <em>names</em> declared in those sections. They don't control visibility of the <em>data</em>. Outside code cannot refer to the <code>MyClass::dummy_data</code> name because it's private. If the class chooses to expose the <em>value</em> of that variable somehow, or even the <em>address</em>, then that's the class's choice, and any code with access to that other avenue (a pointer, in this case) is free to read it. There is no language error present, so the compiler doesn't complain.</p>
",0
44707304,44707245,-1,"<blockquote>
  <p>Is a new object constructed at (2)?</p>
</blockquote>

<p>Yes, the temporary object <code>X(7)</code>. But it gets destroyed right at the end of the statement.</p>

<blockquote>
  <p>If it is, what happens to the old object that was constructed at (1)?</p>
</blockquote>

<p>Its default <code>operator=</code> that was generated by the compiler is called, passing in the temporary object <code>X(7)</code>.</p>

<blockquote>
  <p>Is it automatically destructed or deallocated (which is it)?</p>
</blockquote>

<p>Not in the assignment. Its deallocated when the function exits though.</p>

<blockquote>
  <p>Is it overwritten?</p>
</blockquote>

<p>Only the value of its member <code>n</code> changes, but that can be thought of as being overwritten.</p>

<blockquote>
  <p>And what happens farther down the code at (3)?</p>
</blockquote>

<p>The same as in (2).</p>

<blockquote>
  <p>is there ever a chance of causing a memory leak by writing code like in the above?</p>
</blockquote>

<p>Yes, if you allocate dynamic memory or some other resource, which you're not doing here.</p>
",9
44707604,44707245,7,"<p>At point (2) three things happen:</p>

<ol>
<li>A temp object is constructed using the <code>X(int _n)</code> constructor.</li>
<li>The default assignment operator is used to copy the contents of the temporary to <code>a</code>.</li>
<li>The temporary goes out of scope and its default destructor is invoked.</li>
</ol>

<p>The same thing happens at point (3).</p>

<p>At the end of the function, the default destructor on <code>a</code> is invoked.</p>
",5
44708736,44707245,8,"<p>What you need to understand is that there's a lot of ""implicit"" code generated by the compiler that you, as a novice, don't know about. We'll use your code for <code>class X</code> as a direct example:</p>

<pre><code>class X {
    int n;
public: //You didn't include this, but this won't work at all unless your constructors are public
    X() {n = 0;}
    X(int _n) {n = _n;}
};
</code></pre>

<p>Before the code gets turned into Object Code, but after your compiler gets ahold of your class definition, it transforms your class into something that looks (roughly) like this:</p>

<pre><code>class X {
    int n;
public:
    X() {n = 0;} //Default-Constructor
    X(int _n) {n = _n;} //Other Constructor
    //GENERATED BY COMPILER
    X(X const&amp; x) {n = x.n;} //Copy-Constructor
    X(X &amp;&amp; x) {n = x.n;} //Move-Constructor
    X &amp; operator=(X const&amp; x) {n = x.n; return *this;} //Copy-Assignment
    X &amp; operator=(X &amp;&amp; x) {n = x.n; return *this;} //Move-Assignment
    ~X() noexcept {} //Destructor
};
</code></pre>

<p>The rules for when these members are automatically created are not super-obvious (<a href=""https://www.slideshare.net/ripplelabs/howard-hinnant-accu2014"" rel=""noreferrer"">A good starting reference here</a>), but for now, you can trust that in this case, that's exactly what happens.</p>

<p>So in your <code>main</code> function, let's go over what happens, with the specifics called attention to with comments:</p>

<pre><code>int main() {
    X a; //Default-Constructor called
    a = X(7);//Other Constructor called, then Move-Assignment operator called,
    //then Destructor called on temporary created by `X(7)`
    a = X(12); //Same as previous line

    return 0;
    //Destructor called on `a`
}
</code></pre>

<p>We'll add a few more lines to show most (if not all) of the various permutations of these calls:</p>

<pre><code>int main() {
    X a; //Default-Constructor
    X b = a; //Copy-Constructor (uses copy-elision to avoid calling Default + copy-assign)
    X c(5); //Other Constructor
    X d{7}; //Also Other Constructor
    X e(); //Declares a function! Probably not what you intended!
    X f{}; //Default-Constructor
    X g = X(8); //Other Constructor (uses copy-elision to avoid calling Other + move-assign + Destructor)
    X h = std::move(b); //Move-Constructor (uses copy-elision to avoid calling Default + move-assign)
    b = c; //Copy-assignment
    b = std::move(d); //Move-assignment
    d = X{15}; //Other Constructor, then Move-Assignment, then Destructor on `X{15}`.
    //e = f; //Will not compile because `e` is a function declaration!
    return 0;
    //Destructor on `h`
    //Destructor on `g`
    //Destructor on `f`
    //Destructor will NOT be called on `e` because `e` was a function declaration, 
    //not an object, and thus has nothing to clean up!
    //Destructor on `d`
    //Destructor on `c`
    //Destructor on `b`
    //Destructor on `a`
}
</code></pre>

<p>That should cover the basics.</p>

<blockquote>
  <p>And most importantly, <strong>is there ever a chance of causing a memory leak by writing code like in the above?</strong></p>
</blockquote>

<p>As written, no. However, suppose your class did something like this instead:</p>

<pre><code>class X {
    int * ptr;
public:
    X() {
        ptr = new int{0};
    }
};
</code></pre>

<p>Now, your code would leak, because every time an <code>X</code> was created, you'd have a pointer that never gets deleted.</p>

<p>To solve this, you need to make sure that A) The destructor properly cleans up the pointer, and B) that your copy/move constructors/operators are correct.</p>

<pre><code>class X {
    int * ptr;
public:
    X() {
        ptr = new int{0};
    }
    X(int val) {
        ptr = new int{val};
    }
    X(X const&amp; x) : X() {
        *ptr = *(x.ptr);
    }
    X(X &amp;&amp; x) : X() {
        std::swap(ptr, x.ptr);
    }
    X &amp; operator=(X const&amp; x) {
        *ptr = *(x.ptr);
        return *this;
    }
    X &amp; operator=(X &amp;&amp; x) {
        std::swap(ptr, x.ptr);
        return *this;
    }
    ~X() noexcept {
        delete ptr;
    }
};
</code></pre>

<p>This code will not leak memory if used as-is in either your <code>main</code> function or mine. But of course, it doesn't stop the leaks if you do something like this:</p>

<pre><code>int main() {
    X * ptr = new X{};
    return 0;
    //Whelp.
}
</code></pre>

<p>In general, if you never need to use pointers at all, it's recommended you use something like <code>std::unique_ptr</code> instead, as it gives most of this stuff for free.</p>

<pre><code>int main() {
    std::unique_ptr&lt;X&gt; ptr{new X{}};
    return 0;
    //Destructor called on *ptr
    //`delete` called on ptr
}
</code></pre>

<p>And it's a good idea in your original class, with a caveat that, unless you explicitly change it, your class won't by copyable anymore (though it'll still be movable):</p>

<pre><code>class X {
    std::unique_ptr&lt;int&gt; ptr;
public:
    X() {
        ptr.reset(new int{0});
    }
    X(int val) {
        ptr.reset(new int{val});
    }
    //X(X &amp;&amp; x); //auto generated by compiler
    //X &amp; operator=(X &amp;&amp; x); //auto generated by compiler
    //~X() noexcept; //auto generated by compiler

    //X(X const&amp; x); //Deleted by compiler
    //X &amp; operator=(X const&amp; x); //Deleted by compiler
};
</code></pre>

<p>We can see the changes in my previous version of <code>main</code>:</p>

<pre><code>int main() {
    X a; //Default-Constructor
    //X b = a; //Was Copy-Constructor, no longer compiles
    X c(5); //Other Constructor
    X d{7}; //Also Other Constructor
    X f{}; //Default-Constructor
    X g = X(8); //Other Constructor (uses copy-elision to avoid calling Other + move-assign + Destructor)
    X h = std::move(c); //Move-Constructor (uses copy-elision to avoid calling Default + move-assign)
    //b = c; //Was Copy-assignment, no longer compiles
    c = std::move(d); //Move-assignment
    d = X{15}; //Other Constructor, then Move-Assignment, then Destructor on `X{15}`.
    return 0;
    //Destructor on `h`
    //Destructor on `g`
    //Destructor on `f`
    //Destructor on `d`
    //Destructor on `c`
    //Destructor on `a`
}
</code></pre>

<p>If you want to use <code>std::unique_ptr</code>, but also want the resulting class to be copyable, you'll need to implement the copy constructor yourself using the techniques I discussed.</p>

<p>And that should be about it! Let me know if I missed anything.</p>
",4
36379927,35118319,0,"<p>I recently learned that <code>std::less</code> is specialized for pointers in a way that provides a total order, presumably to allow one to store pointers in <code>std::set</code>s and related <code>class</code>es.  Assuming that this must agree with the standard ordering whenever the latter is defined, I think the following will work:</p>

<pre><code>#include &lt;functional&gt;

template&lt;class T&gt;
T * copy_either_direction(const T * inputBegin, const T * inputEnd, T * outputBegin) {
    if (std::less&lt;const T *&gt;()(inputBegin, outputBegin)) {
        outputBegin += (inputEnd - inputBegin);
        std::copy_backward(inputBegin, inputEnd, outputBegin);
        return outputBegin;
    } else {
        return std::copy(inputBegin, inputEnd, outputBegin);
    }
}
</code></pre>
",0
36249029,36248918,5,"<p>For gcc you can specify:</p>

<pre><code>-Wdelete-non-virtual-dtor -Wsystem-headers
</code></pre>

<p>to see <code>delete-non-virtual-dtor</code> warning generated <code>by std::default_delete</code>, it will look as follows:</p>

<blockquote>
  <p>/usr/local/include/c++/5.3.0/bits/unique_ptr.h:76:2: warning: deleting object of polymorphic class type 'B' which has non-virtual destructor might cause undefined behaviour [-Wdelete-non-virtual-dtor]
    delete __ptr;</p>
</blockquote>

<p><a href=""http://coliru.stacked-crooked.com/a/ccc60cb14f09c6d9"">live</a></p>

<p>btw. your sample classes lack at least one virtual function in base class.</p>

<p>[edit]</p>

<p>to turn it into error use:</p>

<pre><code> -Werror=delete-non-virtual-dtor -Wsystem-headers 
</code></pre>
",5
36251833,36248918,1,"<p>It is my strong opinion that one should strictly separate ""value-based"" classes and ""OO-based"" classes (for lack of better term).</p>

<p>Value-based classes should have no public bases, and should normally support copy semantics (unless specially designed to disable copying). Objects of such classes have no identities apart from their values. They are interchangeable with their copies.</p>

<p>OO-based classes should have virtual destructors, and should never have copying members publicly accessible. Objects of such classes should only be copied via a virtual <code>clone</code> method. Such objects have identities separate from their values.</p>

<p>There should be no class with a public base that has a non-virtual destructor or a public copy/move ctor or a public copy/move assignment operator (in the base).</p>

<p>If you maintain this separation, you will have no accidents with object slicing or deletion through a non-polymorphic base pointer.</p>

<p>Unfortunately there are no tools (that I know of) that help maintain this separation. So you need to exercise due diligence while inheriting. It's really simple. Does it have a virtual dtor <em>and</em> inaccessible/deleted copy ctor and copy assignment? You can inherit publicly. No? Avoid potential mess, use composition or private inheritance.</p>

<p>A good class designed for inheritance would have its copying members protected in order to facilitate cloning in descendant classes. </p>

<p>Unfortunately, with third-party classes you don't have a choice, as authors usually leave copying members public, so there's still risk of object slicing. But you will have no risk of improper deletion through a base pointer.</p>

<p>TL;DR no tools, only programmer's due diligence.</p>
",0
34920460,34920386,4,"<p>It should be like this:</p>

<pre><code>template &lt;typename T&gt;
class MyFunction;

template&lt;typename R, class... Ts&gt;
class MyFunction&lt;R(Ts...)&gt;
{
public:
    using func_type = R(*)(Ts...);

    MyFunction(func_type f)
      : m_func(f) 
    {
    }

    R operator()(Ts ... args) 
    {
        return m_func(args...);
    }

private:
    func_type m_func;
};
</code></pre>

<p><code>MyFunction</code> should be specialized for function signature type.
Note: <code>std::function</code> is really more complicated.</p>
",2
38097904,38097687,5,"<p>I would avoid default parameter for virtual method (see <a href=""https://stackoverflow.com/questions/12139786/good-pratice-default-arguments-for-pure-virtual-method"">good-practice-default-arguments-for-pure-virtual-method</a>), so just add an extra overload</p>

<pre><code>virtual void func(double x, const std::string&amp; s, uint64_t&amp; i) = 0;
void func(double x, const std::string&amp; s) { int i; func(x, s, i) };
</code></pre>

<p>If you really want to keep default argument, you may use <code>boost::optional</code>:</p>

<pre><code>virtual void func(double x,
                  const std::string&amp; s,
                  boost::optional&lt;uint64_t&amp;&gt; i = boost::none) = 0;
</code></pre>
",0
38097846,38097687,3,"<p>You can use pointer instead of reference and within your function implementation only modify (dereferenced) value if pointer passed is not <code>nullptr</code></p>

<pre><code>void func(double x, const std::string&amp; s, uint64_t* pi = nullptr) = 0;
</code></pre>
",0
38097757,38097687,5,"<p><code>uint64_t&amp;</code> is an L-Value reference, and can therefore not bind to an R-Value, like the literal you provide as default argument. You must provide an L-Value as default.</p>

<p>One option is to define a dummy object that you pass as default, e.g.:</p>

<pre><code>static uint64_t dummy_default_value = 0;
void func(double x, const std::string&amp; s, uint64_t&amp; i = dummy_default_value ) = 0;
</code></pre>
",0
48009152,48009051,3,"<p>This is where a template specialization comes in handy.</p>

<pre><code>#include &lt;type_traits&gt;

template &lt;class Class_, bool = std::is_class&lt;Class_&gt;::value&gt;
struct EndianGuard_ : public Class_ 
{
    // inherit if class
};

template &lt;class Class_&gt;
struct EndianGuard_&lt;Class_, false&gt; 
{
    // don't inherit if not a class
};

struct foo {};

int main() 
{
    EndianGuard_&lt;int&gt; f; //ok
    EndianGuard_&lt;foo&gt; f2; // ok
}
</code></pre>

<p>If <code>std::is_class&lt;Class_&gt;::value</code> evaluates to <code>false</code>, the specialization kicks in and you can handle the non-class type. Other conditions can be added for more restriction.<br/>
As a side note, it's probably best to handle the <code>std::is_final</code> case, since you can't inherit from a <code>final</code> class.</p>
",0
48016557,48016464,3,"<p>Put each chip in its own .cpp file, and declare all those private, internal things within that file (and not in the header).  You can wrap them in anonymous namespace to keep them from being exposed to the linker.</p>
",1
42620270,42619050,0,"<p>R Sahu gave you  answer that is slightly modified version of your function . That is legal code, but that is basicly a C code, except use of nullptr. Returning nullptr is non-canon and if nupllptr will be returned, what &lt;&lt; operator would do? That's undefined behavior.
it is often agreed pattern to leave iterator (pointer) pointing at end of line (at the terminating zero) to avoid crash you may cause by returning nullptr.</p>

<pre><code>char* str_char(char* c_ptr, char c)
{
   char* cp = c_ptr; 

   for (; *cp != '\0'; ++cp )
   {
      if (*cp == c)
      {
         return cp;
      }
   }
   return cp; 
   // if cp was declared inside scope , we can't retirn it's value
}
</code></pre>

<p>Normally you do not need to write own string functions.. bth C library and C++ got  them already covered. C++ got set of abstract algorithmic functions, in your case a strchr, find  or find_if is prudent:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;

using std::cout;

int main()
{
    char *c = ""Hello"";


    cout &lt;&lt; std::strchr(c, 'l') &lt;&lt; '\n';

    // with pointer to null-terminated string, strlen searches 
    // for zero char and returns the count of characters before it
    cout &lt;&lt; std::find(c, c + strlen(c), 'l') &lt;&lt; '\n';


    // with  declared array we can use std:begin and std::end
    char carr[] = ""Hello""; 

    cout &lt;&lt; std::find(std::begin(carr),std::end(carr) , 'l') &lt;&lt; '\n';


    // with pointer to null-terminated string a lambda expression 
    // can be used to stop at 0 as well as at first key
    const char key = 'l';
    cout &lt;&lt; std::find_if(c, c + strlen(c),[=](const char&amp; item)
    {
        return (item ==  key) || (item ==  '\0');
    }) &lt;&lt; '\n';


    return 0;

}
</code></pre>

<p>An std::vector or ::array or other containers can be used with those templates as well.
The <code>&lt;algorithms&gt;</code> header would save tons of time you need to debug your custom-tailored functions for search, iteration, etc.</p>

<p>P.S. cout and cin deal with char and char* in special way.. char* is always pointer at string, char is always a character, not a number, so casts are required if you mean otherwise.</p>
",0
42619265,42619050,1,"<p>You are on the right track. However, there are a few things that are not right.</p>
<ol>
<li><p>Use of <code>sizeof(c_ptr)</code> is not right. It works for your case due to happy coincidence.</p>
<p><code>sizeof(c_ptr)</code> is equal to <code>sizeof(char*)</code>. It is not equal to the size of the array from the calling function.</p>
</li>
<li><p>There is a missing <code>return</code> statement at end of the function -- the case where <code>c</code> is not found in <code>c_ptr</code>.</p>
</li>
<li><p>There is no need of the <code>break;</code> after the <code>return;</code>.</p>
</li>
</ol>
<p>Also, you can simplify the function a little bit.</p>
<p>Here's an updated version:</p>
<pre><code>char* str_char(char* c_ptr, char c)
{
   for (char* cp = c_ptr; *cp != '\0'; ++cp )
   {
      if (*cp == c)
      {
         return cp;
      }
   }
   return nullptr;
}
</code></pre>
",5
42619890,42619050,0,"<p>The earlier answer has covered the bugs, so I'll just answer the actual question...</p>

<p>The function <em>does</em> return the location of an array element.  </p>

<p>The <code>&lt;&lt;</code> operator treats every <code>char*</code> as a pointer to a zero-terminated string, and outputting the result of <code>str_char</code> works exactly like outputting <code>c</code>; it prints every character after that location until it encounters a zero.  </p>

<p>If you want to output the value of the location itself, you need to cast it to a different type:</p>

<pre><code>cout &lt;&lt; static_cast&lt;void*&gt;(str_char(c, 'l')) &lt;&lt; endl;
</code></pre>

<p>as <code>&lt;&lt;</code> has an overload for <code>void*</code> that outputs the address itself.</p>
",3
37696010,37695367,2,"<p>You <em>can</em> wrap logging inside a RAII object. Just check whether an exception is currently in flight before printing in the destructor, which can be done with <a href=""http://en.cppreference.com/w/cpp/error/uncaught_exception"" rel=""nofollow""><code>std::uncaught_exception</code></a> (which will become <code>std::uncaught_exceptions</code> in C++17).</p>

<hr>

<p>If something more flexible is needed, you can use a wrapper for your return value, specializing it for <code>void</code>:</p>

<pre><code>template &lt;class T&gt;
struct RetWrapper {
    template &lt;class Tfunc, class... Targs&gt;
    RetWrapper(Tfunc &amp;&amp;func, Targs &amp;&amp;... args)
    : val(std::forward&lt;Tfunc&gt;(func)(std::forward&lt;Targs&gt;(args)...)) {}

    T &amp;&amp;value() { return std::move(val); }

private:
    T val;
};

template &lt;&gt;
struct RetWrapper&lt;void&gt; {
    template &lt;class Tfunc, class... Targs&gt;
    RetWrapper(Tfunc &amp;&amp;func, Targs &amp;&amp;... args) {
        std::forward&lt;Tfunc&gt;(func)(std::forward&lt;Targs&gt;(args)...);
    }

    void value() {}
};
</code></pre>

<p><code>RetWrapper</code> performs the function call and stores the result, which can later be moved out via <code>value()</code>. This ties in with the possibility of returning a <code>void</code>-type expression from a <code>void</code> function:</p>

<pre><code>template&lt;typename Method&gt;
typename Method::Result operator()(const Method &amp;method)
{
    journal(""-&gt;"", Method::Name());
    RetWrapper&lt;typename Method::Result&gt; retVal{transport, method};
    journal(""&lt;-"", Method::Name());
    return retVal.value();
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/2ce9b4617f3aa116"" rel=""nofollow"">Live on Coliru</a></p>
",1
36220802,36220150,2,"<h1>Main idea</h1>

<p>You can happily employ multiple inheritance here.</p>

<p>The main idea is: create a base class tagging your sets and make it a base class for all your sets. Then explicitly instantiate the set class for each template arguments you need, creating an empty class inherited publicly from both the set container and your tagging interface. Then you'll have nothing to add, no code duplication seems to be needed.</p>

<p>Anyway, you'll need to create some (maybe virtual) functions that will work for all template specializations. We'll need to be able to use a single variable in the same context regardless of what it holds. But you can try reduce some code with more <code>using</code> declarations due to inheritance and use implicit type conversion (e.g. if your sets contain numbers only).</p>

<pre><code>#include &lt;set&gt;

class setInterface {
    /* Code common for all set template specializations
       (you have to have some common interface anyway) */
};

template &lt;typename T&gt; class TSet: public setInterface, std::set&lt;T&gt; {
    using std::set&lt;T&gt;::set;
    /* more using-declarations or templated versions of some functions
       You can use SFINAE here to achieve more magical results,
       or use template specializations for specific types. */
};

using intSet = TSet&lt;int&gt;;
using doubleSet = TSet&lt;double&gt;;

class B {
public:
  setInterface values;
};

int main () {
    B b;
    b.values = intSet {1, 2, 3} ;
    b.values = doubleSet {1., 2., 3.};
}
</code></pre>

<p>PS: thanks go to @Jarod42 for the template using syntax.</p>

<h1>A working implementation</h1>

<p>The following assumptions have been made:</p>

<ul>
<li>We will use only the sets with items convertible to <code>long long</code>. We can use <code>void*</code> in general case and add some additional methods for convenience/safety.</li>
<li>We are sane and will never compare iterators of differently typed sets. The results will be unpredictable.</li>
<li>We don't need to check pointers for <code>nullptr</code>s (well, it will bring no more value in my code sample, sure in real world you always need).</li>
</ul>

<p>The solution is able to iterate over the map using non-const begin/ends and using the new shiny range-based for. See the <code>main</code>; compile and run it (<code>-std=c++14</code>) to see the result.</p>

<pre><code>#include &lt;set&gt;
#include &lt;memory&gt;
#include &lt;iostream&gt;

using common_denominator_type = long long;

class setInterface {
protected:
    class iterator_impl;
public:
    class iterator {
    public:
        iterator (iterator_impl* impl) : impl (impl) {}

        iterator&amp; operator++ () { ++*impl; return *this; };
        bool operator != (const iterator&amp; rhs) const { return *impl != *rhs.impl; };
        common_denominator_type operator* () const { return **impl; };
    private:
        std::shared_ptr &lt;iterator_impl&gt; impl;
    };
    virtual iterator begin() = 0;
    virtual iterator end() = 0;
    virtual size_t size() const = 0;
protected:
    class iterator_impl {
    public:
        virtual iterator_impl&amp; operator++ () = 0;
        virtual bool operator != (const iterator_impl&amp;) const = 0;
        virtual common_denominator_type operator* () const = 0;
        virtual void* as_std_set_iterator () = 0;
        virtual const void* as_std_set_iterator () const = 0;
    };
};

template &lt;typename T&gt; class TSet: public setInterface, std::set&lt;T&gt; {
public:
    using std::set&lt;T&gt;::set;
    size_t size () const override { return std::set&lt;T&gt;::size(); }
    iterator begin () override { return iterator (new TSet&lt;T&gt;::iterator_impl (std::set&lt;T&gt;::begin())); }
    iterator end   () override { return iterator (new TSet&lt;T&gt;::iterator_impl (std::set&lt;T&gt;::end  ())); }
protected:
    class iterator_impl: public setInterface::iterator_impl {
    public:
        using std_it = typename std::set&lt;T&gt;::iterator;
        iterator_impl (std_it&amp;&amp; _) : m_real_iterator(std::move (_)) {}
        iterator_impl&amp; operator++ () override { ++m_real_iterator; return *this; }
        bool operator != (const setInterface::iterator_impl&amp; rhs) const override {
            return *reinterpret_cast &lt;const std_it*&gt;(as_std_set_iterator())
                    !=
                   *reinterpret_cast &lt;const std_it*&gt;(rhs.as_std_set_iterator());
        }
        common_denominator_type operator* () const override { return *m_real_iterator; }
        void* as_std_set_iterator () override { return &amp;m_real_iterator; }
        const void* as_std_set_iterator () const override { return &amp;m_real_iterator; }
    private:
        std_it m_real_iterator;
    };
};

using intSet = TSet&lt;int&gt;;
using longSet = TSet&lt;long&gt;;

class B {
public:
    std::shared_ptr &lt;setInterface&gt; values;
};

std::ostream&amp; operator&lt;&lt; (std::ostream&amp; str, B&amp; b) {
    str &lt;&lt; ""["" &lt;&lt; b.values-&gt;size() &lt;&lt; ""] ["";
    for (auto i = b.values-&gt;begin(); i != b.values-&gt;end(); ++i)
        str &lt;&lt; *i &lt;&lt; "" "";
    str &lt;&lt; ""]["";
    for (auto i : *b.values)
        str &lt;&lt; i &lt;&lt; "" "";
    return str &lt;&lt; ""]"";
}

int main () {
    B b;
    b.values.reset (new intSet {1, 2, 3});
    std::cout &lt;&lt; b &lt;&lt; std::endl;
    b.values.reset (new longSet {10l, 20l, 30l});
    std::cout &lt;&lt; b &lt;&lt; std::endl;
}
</code></pre>
",4
47975565,47975314,1,"<p>Took a bit of a look in <a href=""https://nlohmann.github.io/json/classnlohmann_1_1basic__json.html"" rel=""nofollow noreferrer"">the documentation</a>. Here's the picture it paints:</p>

<pre><code>using   initializer_list_t = std::initializer_list&lt; detail::json_ref&lt; basic_json &gt; &gt;
// helper type for initializer lists of basic_json values
</code></pre>

<p>Which is of course used to define a constructor:</p>

<pre><code>basic_json (initializer_list_t init, bool type_deduction=true, value_t manual_type=value_t::array)
// create a container (array or object) from an initializer list
</code></pre>

<p>Since the  list initialization causes overload resolution to consider only <code>std::initializer_list</code> c'tors first, the above c'tor is matched and called. The source object seems to violate some sort of internal constraint of the <code>json</code> class when doing list initialization.</p>

<p>In your other snippet, the copy c'tor is chosen and called. </p>
",0
36665940,36665651,0,"<p>I assume your source data is a <code>uint8_t*</code>, since it's not specified otherwise. Therefore:</p>

<pre><code>uint8_t *src = /* your source */;
</code></pre>

<p>You want to extract one <code>uint16_t</code> at a given offset; this means:</p>

<pre><code>uint8_t high = src[offset], low = src[offset + 1];
uint16_t v = high &lt;&lt; 8 | low;

/* offset and offset+1 must be in a valid range */
</code></pre>

<p>Or, more compactly:</p>

<pre><code>uint16_t v = (src[offset] &lt;&lt; 8) | src[offset+1];
</code></pre>

<p>Then convert <code>v</code> to little endian accordingly, but notice plain <code>bswap</code> is not enough. This is because <code>__builtin_bswapX</code> (where X is the number of bytes) simply swaps bytes, which is <em>not</em> equivalent to <code>htonX</code>/<code>ntohX</code>: these also check your machine's endianness and, if needed, go ahead and swap; otherwise they're a no-op.
Indeed, if you're on a BE architecture the <code>htonX</code> has to be a no-op (data is already BE) and vice-versa.</p>
",3
36666086,36665651,4,"<p>To extract an <code>uint16_t</code> from an array of <code>uint8_t</code> without fear of alignment or aliasing issues and without re-implementing what's already provided to you by the system, use <code>memcpy</code>.</p>

<pre><code>uint16_t val;
memcpy(&amp;val, ptr, sizeof val);
</code></pre>

<p>If it's in network (big endian) order and you want to convert it to host order (possibly little endian but not limited to that), use <code>ntohs</code> as answered by Sam Varshavchik.</p>

<pre><code>val = ntohs(val);
</code></pre>

<p>You <em>can</em> do it by shifting bytes, but if standard library functions already do what you want, then I'd say stick with the standard library functions<sup>*</sup> at least until you have a compelling reason not to.</p>

<p><sub>* POSIX standard in this case, not C++ standard.</sub></p>
",1
36665884,36665651,0,"<p>Case A:</p>

<pre><code> value = ((uint16_t)(array[X]) &lt;&lt; 8) | (uint16_t)array[X + 1];
</code></pre>

<p>Case B:</p>

<pre><code> value = ntohs(*(unit16_t*)(char*)(array + X));
</code></pre>

<p>If the type of array is already char the char * cast isn't necessary. Most of the time the compiler will figure it out anyway; but technically it's undefined behavior without it.</p>
",2
36665781,36665651,0,"<p>You're probably looking for <a href=""http://manpages.courier-mta.org/htmlman3/byteorder.3.html"" rel=""nofollow"">ntohs(3)</a>.</p>
",5
45041182,45041014,0,"<p>You are passing in 'foo()' a const pointer, this means that you are telling compiler that you don't want anyone to change the data ponted by the pointer. Therefore, converting a const pointer to a non-const pointer makes no-sense. However, if you really want to do so 'just for fun' then you can workaround this by 'memcpy'.</p>
",1
45041225,45041014,1,"<p>Okay, you have clarified that you did not <em>intend</em> to add constness to the pointee, but instead to the pointer (and this can of course be safely dropped when copying the pointer). The error message is a good indication that you failed in that goal.</p>

<p>The type to do that is:</p>

<pre><code>int* const
</code></pre>

<p>Remember, <code>const</code> applies directly to the left (unless there's nothing there, in which case it applies directly to the right).</p>
",0
40767909,40767864,3,"<p>Yes, this will work as expected. <code>val</code> will have a valid location the moment you set <code>ref</code> to it. From then on, <code>ref</code> will just hold whatever is in <code>val</code>.</p>
",0
39633417,39633346,6,"<p>That is most likely the wrong way to call the function. The <code>getElementById</code> function takes a pointer to a pointer because it emulates <em>pass by reference</em>, and will write to the dereferenced pointer inside the function. Since you pass an uninitialized pointer you will get <em>undefined behavior</em> and probably a crash.</p>

<p>What you should do instead is to declare a single pointer variable, and pass a pointer to that variable. Like</p>

<pre><code>CComBSTR v = ""myid"";
IHTMLElement* element;
HRESULT hr = pDocument-&gt;getElementById(v, &amp;element);
</code></pre>

<p>As for how to get attributes etc., I recommend that you <a href=""https://msdn.microsoft.com/en-us/library/aa752279(v=vs.85).aspx"" rel=""noreferrer"">read a reference for <code>IHTMLElement</code></a>. Perhaps search for tutorials or examples as well?</p>
",0
39622509,39622508,5,"<p>It was a simple and clever use of the good old macros.</p>

<pre><code>#define KByte *1024
#define MByte *1024*1024
#define GByte *1024*1024*1024
</code></pre>

<p>So <code>size_t poolSize = 16 MByte;</code> gets translated into </p>

<pre><code>size_t poolSize = 16 *1024*1024;
</code></pre>
",7
39622579,39622508,89,"<p>In modern C++ you should <a href=""http://en.cppreference.com/w/cpp/language/user_literal"">define a literal notation</a>, e.g.</p>

<pre><code>auto operator""""_MB( unsigned long long const x )
    -&gt; long
{ return 1024L*1024L*x; }
</code></pre>

<p>Then write</p>

<pre><code>long const poolSize = 16_MB;
</code></pre>

<p>Don't use macros, they're <strong>Evil&trade;</strong>. In so many ways.</p>

<hr>

<p>Disclaimer: code not touched by compiler's hands.</p>
",13
39625300,39622508,13,"<p>Of course you should use template metaprogramming for this problem:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;type_traits&gt;

template&lt;long long N, long long M&gt;
struct is_power_of
{ 
    static constexpr bool value = (N%M != 0)? false : is_power_of&lt;N/M, M&gt;::value;
};

template&lt;long long M&gt;
struct is_power_of&lt;0, M&gt; : public std::false_type { };
template&lt;long long M&gt;
struct is_power_of&lt;1, M&gt; : public std::true_type { };

template&lt;long long N, typename = typename std::enable_if&lt;is_power_of&lt;N, 1024&gt;::value&gt;::type&gt;
struct bytes
{
    enum {value = N, next = value * 1024};   
    template&lt;long long M&gt;
    struct compile_time_get
    {
        enum {value = N*M};
    };
    static long long run_time_get(long long x) {return N*x;}
};

typedef bytes&lt;1&gt; byte;
typedef bytes&lt;byte::next&gt; kilo_byte;
typedef bytes&lt;kilo_byte::next&gt; mega_byte;
typedef bytes&lt;mega_byte::next&gt; giga_byte;
typedef bytes&lt;giga_byte::next&gt; tera_byte;
typedef bytes&lt;tera_byte::next&gt; peta_byte;
typedef bytes&lt;peta_byte::next&gt; eksa_byte;

int main()
{
    std::cout &lt;&lt; kilo_byte::compile_time_get&lt;3&gt;::value &lt;&lt; std::endl;
    int input = 5;
    std::cout &lt;&lt; mega_byte::run_time_get(input) &lt;&lt; std::endl;
}
</code></pre>

<p>Output:</p>

<pre><code>3072
5242880
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/f4874e9e4d14ef23"">LIVE</a></p>
",3
39635810,39622508,6,"<p>If you are going to be doing it a lot, then a user defined literal is the way to go.  OTOH, for one-offs (and to support older compilers and other languages), I'd go with the direct:</p>

<pre><code>size_t poolSize = 16ul*1024*1024;
</code></pre>
",0
39640477,39622508,2,"<p>All the examples I saw were more like </p>

<pre><code>#define KB 1024
#define MB (1024*1024)

size_t poolSize = 16*MB;
</code></pre>

<p>No magic, no questions, just works.</p>
",6
38295637,38295395,0,"<p>The only mistake i see is that in the cpp file you need to include the return type as well. It should be</p>

<pre><code>void EnableOpenTest()
{
    //Enter Code Here
}
</code></pre>
",0
38295641,38295395,0,"<p>Inside of <code>FILE_DOES_NOT_WORK_CORRECTLY.CPP</code>:</p>

<pre><code>EnableOpenTest(){ /* do work here */ }
</code></pre>

<p>must be</p>

<pre><code>void EnableOpenTest(){ /* do work here */ }
</code></pre>

<p>Looks like your compiler sets the missing return type to <code>int</code> instead of yelling at you with a error message.</p>

<p>You should turn on compiler warnings, it would allow you to notice such errors very quickly.</p>

<hr>

<p>Also, inside of <code>FILE_WORKS_CORRECTLY.H</code> you have another error:</p>

<pre><code>void EnableOpenTest() { }
</code></pre>

<p>must be</p>

<pre><code>inline void EnableOpenTest() { }
</code></pre>

<p>Otherwise it will trigger a error message if this header is included twice (i.e. in more that one <code>.cpp</code> file).</p>
",1
38296282,38295395,0,"<p>Solved it!</p>

<ol>
<li>Additional projects needed to be static library (main project .exe)</li>
<li>Added References of library projects to main project</li>
</ol>

<p>Obviously the file structure caused a lot of these issues.</p>
",0
43209425,43208329,1,"<p>You could use an <code>std::pair</code> to have essentially a 2 column table of vectors; </p>

<pre><code>std::vector&lt;CvPoint&gt; pa, pb;

...

std::pair&lt;std::vector&lt;CvPoint&gt;, std::vector&lt;CvPoint&gt;&gt; myPair(std::make_pair(pa, pb));

myPair.first == pa /* true */
myPair.second == pb /* true */
</code></pre>
",0
40552125,40551928,2,"<p>Change <code>iter &lt;= v.end();</code> to <code>iter != v.end();</code>, 
and</p>

<pre><code>for(int i = (*iter).size(); i &gt;= 0; i--){
</code></pre>

<p>to </p>

<pre><code>for(int i = (*iter).size() - 1; i &gt;= 0; i--){
</code></pre>

<p>Read this : <a href=""https://stackoverflow.com/questions/6673762/why-is-used-with-iterators"">Why is &quot;!=&quot; used with iterators?</a></p>
",0
40552135,40551928,1,"<p>I believe you are adding an empty character in your first loop, when trying to get <code>(*iter)[(*iter).size()]</code>.</p>

<blockquote>
  <p>If pos is equal to the string length and the string is
  const-qualified, the function returns a reference to a null character
  ('\0').</p>
</blockquote>

<p>Can you try:</p>

<pre><code>for(int i = (*iter).size()-1; i &gt;= 0; i--){
      reversed_word = reversed_word + (*iter)[i];
    }
</code></pre>

<p><code>std::cout</code> would not show this difference, even though the 2 strings are different.</p>
",0
40552049,40551928,3,"<p>How many times does this loop iterate?</p>

<pre><code>for(int i = (*iter).size(); i &gt;= 0; i--)
</code></pre>

<p>You probably want <code>size()-1</code> so it won't look past the end of the word.</p>

<p>Likewise, <code>iter &lt;= v.end()</code> is seldom right. <code>end</code> never points to anything; it is always invalid. The idiom is <code>!= v.end()</code>.</p>

<p>Also, if the function does not return a value, its return type should be <code>void</code>.</p>
",0
40552862,40551928,3,"<p>Code like this makes me sad! Even when corrected, it's still (pardon my being frank) ugly and hard to read.</p>

<p>The point of C++ and its standard library is to allow you to work at a relatively abstract level--but most of what you've written is at pretty close to the level of assembly language. Instead of using a <code>vector</code> or a string as an abstraction, you're dealing with individual characters, building up your reversed string one character at a time, and so on.</p>

<p>In terms of abstraction, this is barely baby step above assembly language (and with much uglier syntax than most assemblers use).</p>

<p>So let's sit back and consider what you're really doing.</p>

<p>Your taking a vector of inputs. You're processing each one, and producing a result. That's what <code>std::transform</code> does, so that's what you should probably use here.</p>

<pre><code>std::vector&lt;bool&gt; results(v.size());

std::transform(v.begin(), v.end(), results.begin(), is_palindrome);
</code></pre>

<p>So that leaves us with the task of defining <code>is_palindrome</code>.</p>

<p>Here again, I'd advise trying to think at a higher level of abstraction. <code>std::string</code> has a constructor that takes a pair of iterators. <code>std::string</code> also supports reverse iterators--you can use <code>rbegin()</code> and <code>rend()</code> to get reverse iterators into a string.</p>

<p>Between those two things, we can create a reversed string in one fairly simple step:</p>

<pre><code>std::string reversed(s.rbegin(), s.rend());
</code></pre>

<p><code>std::string</code> also overloads most of the relevant operators, so code to compare two strings can be more readable: <code>return s == reversed;</code></p>

<p>After that, I think it's worth mentioning one or two things that weren't possible when <em>Accelerated C++</em> was written, but should be on any compiler that's even sort of close to current. The first is initialization lists. Instead of:</p>

<pre><code>  vector&lt;string&gt; dictionnary;
  dictionnary.push_back(""coloc"");
  dictionnary.push_back(""elle"");
  dictionnary.push_back(""php"");
  dictionnary.push_back(""shahs"");
  dictionnary.push_back(""bonjour"");
  dictionnary.push_back(""random"");
</code></pre>

<p>...you can now write this like:</p>

<pre><code>vector&lt;string&gt; dictionary{ ""coloc"", ""elle"", ""php"", ""shahs"", ""bonjour"", ""random"" };
</code></pre>

<p>Another is lambda expressions. Instead of defining <code>is_palindrome</code> as a function (or functor) we can specify an expression in-place:</p>

<pre><code>std::transform(v.begin(), v.end(),
               results.begin(),
               [](std::string const &amp;s) {
                   return s == std::string(s.rbegin(), s.rend());
               });
</code></pre>

<p>There's most of the program in only 5 lines of code--and no <code>(*iter)[i]</code> in sight anywhere.</p>
",7
38285446,38285339,3,"<p>You can</p>

<ul>
<li><p>put the array constants in a namespace along with the function (an anonymous namespace is probably good enough),</p></li>
<li><p>put them in the global namespace as <code>static</code> constants, along with the function (note: this use of <code>static</code>, for data, is deprecated)</p></li>
<li><p>put them in separate accessor functions, which can be <code>static</code>.</p></li>
</ul>

<p>By the way, do add <code>const</code>.</p>

<p>That informs also the compiler that they're constant.</p>
",0
38285365,38285339,4,"<p>You can put your constants in their own file and <code>#include</code> them where you need them - that's not a problem.</p>

<p>Btw, you <em>say</em> constants, but in your example your array is not <code>const</code> - but it could be if you don't intend to change it.</p>
",0
38285698,38285339,0,"<p>One more thing, apart from the above answers: put it in a config file. You can only do this if you don't need it in compile time, but then you can update the constants without recompiling/redisting the code. It can still be a const, given you can read and parse the config file during static initialization.</p>
",1
38286162,38285339,0,"<p>You should have used <code>const</code> type qualifier for your double variable <code>coefficients</code>.</p>

<blockquote>
  <p>Looking at my code I'm not very happy with the ""look"" of the code</p>
</blockquote>

<p>Yes, you were right. It doesn't look good and there are better ways to do it.</p>

<p>You could achieve better readability if you have used <code>static</code> modifier with your variable and place it outside the function definition. Or you can just make it global in <code>.cpp</code> file just above the function definition that is going to access it. </p>

<p>And yes, <code>separate accessor functions</code> (make it <code>static</code>) is also a good idea as mentioned in one of the answer.</p>

<p>You can also try <a href=""https://en.wikipedia.org/wiki/X_Macro"" rel=""nofollow"">X Macro</a> if it helps in code readability issues.</p>
",0
38204742,38204671,1,"<p>Why use a pointer if you can use a reference?</p>

<pre><code>class Abc
{
public:
    Abc(Def &amp;def) : pDef(def)
    {
    }

    void do1();
private:
    Def&amp; pDef;
}
</code></pre>

<p>You aren't passing ownership, so there's no need for pointers.</p>

<p>Think of a reference like a pointer that can never be null.</p>
",7
38204844,38204671,0,"<p>This is what <code>std::shared_ptr</code> is for. If you use <code>std::shared_ptr</code>, the pointer will always be valid (as long as you follow all the very simple rules).</p>
",0
38205216,38204671,3,"<blockquote>
  <p>Assume Def is a large class with many class members</p>
</blockquote>

<p>I assume this means that it is expensive to copy the <code>Def</code> class. However, with C++11 you could implement move semantics for <code>Def</code> and keep the <code>Abc</code> implementation simple and efficient.</p>

<p><strong>Note:</strong> This answer is based on the assumption that the only reason the question uses any pointers (smart or otherwise) is as a way to avoid expensive copies.</p>

<h3>Example Code</h3>

<pre><code>class Def
{
public:
    Def() {}
    Def(const Def&amp; other) { /* ... */ } // Copy constructor even though it's expensive
    Def(Def&amp;&amp; other) { /* ... */ } // Move constructor for efficiency

    Def&amp; operator=(const Def&amp; other) { /* ... */ } // Copy assignment
    Def&amp; operator=(Def&amp;&amp; other) { /* ... */ } // Move assignment
};
</code></pre>

<p>Now the <code>Def</code> class supports copy semantics, even though copy the class may be expensive. However, it also supports move semantics to allow efficient usage when a copy isn't required.</p>

<pre><code>class Abc
{
public:
    Abc() {}

    Abc(const Def&amp; def) : mDef(def) {} // Perform an expensive copy

    Abc(Def&amp;&amp; def) : mDef(std::move(def)) {} // Perform a move

    // Implement any other member functions which could accept Def
    // via copy or move

private:
    Def mDef;
};
</code></pre>

<hr>

<p>I would only advocate using <code>std::shared_ptr</code> if the use case is actually to support shared ownership semantics.</p>
",4
41192363,41192267,0,"<p>I think something like this should work.</p>

<pre><code>void &lt;template T&gt; obtain_select_list(AbcArray&amp; objArray, std::vector&lt;int&gt; &amp;listSel, T (*fun)(const Abc&amp;))
{
    std::vector&lt;T&gt; areaArray;
       for(int i=0; i&lt;objArray.size(); i++)
                areaArray.push_back(fun(objArray[i]));

       function_select_list(areaArray,listIndexArray);

}
</code></pre>

<p>Just to be more general i used a template one, so that if you need the function to return things different from an int you can still use it.</p>

<p>I wasn't able to test it, it compiles but i don't know it if works, but it should.</p>
",2
41192427,41192267,2,"<p>Not exactly function pointers, but rather class method pointers.</p>

<p>Additionally, using C++11 range iteration makes the resulting syntax much simpler, and easier to read:</p>

<pre><code>void obtain_selected_list_based_on(AbcArray&amp; objArray, 
    std::vector&lt;int&gt; &amp;listIndexArray,
    int (Abc::*get_something)())
)
{
   std::vector&lt;int&gt; areaArray;

   for (const auto &amp;v:objArray)
            areaArray.push_back((v.*get_something)());

   function_select_list(areaArray,listIndexArray);
}
</code></pre>

<p>This can be invoked as:</p>

<pre><code>obtain_selected_list_based_on(objArray,
                              listIndexArray,
                              &amp;Abc::height);

// or

obtain_selected_list_based_on(objArray,
                              listIndexArray,
                              &amp;Abc::width);

// or

obtain_selected_list_based_on(objArray,
                              listIndexArray,
                              &amp;Abc::area);
</code></pre>

<p>Your class methods should probably be <code>const</code> themselves, which would change the parameter type to <code>int (Abc::*get_something)() const</code>.</p>
",0
42640462,42640432,0,"<p>No. The code you posted so far does not involve <code>string</code>'s copy assignment operator in any shape, way or form.</p>
",0
42640506,42640432,1,"<pre><code>string mystr=func();
</code></pre>

<p>does not invoke the copy assignment operator. It initializes <code>mystr</code> using the copy constructor.</p>

<p>To invoke the copy assignment operator, the initialization and assignment need to be two separate statements.</p>

<pre><code>string mystr;
mystr = func();
</code></pre>
",0
39623288,39623245,5,"<p>Yes, accessing <code>d</code> <em>is</em> illegal, and your code has undefined behaviour.</p>

<p>There is no concept of ""crash"" in C++, so it does not make sense to ask for a portable way to create a ""crash"". If the behaviour of a program is undefined, it is not portable, and the language rules do not tell you what the program is doing.</p>
",5
39623559,39623245,0,"<p>What you are doing usually won't cause a crash because of the way that memory allocation is typically handled behind the scenes.</p>

<p>And there are third party products that can check for errors of this kind (a buffer overrun in this case). Just search for ""memory debuggers c++"". Most tools for Windows are commercial, but there may be free ones available.</p>
",1
39623314,39623245,0,"<p>It is illegal, but you are casting which tells the compiler you know what you are doing (don't do this without knowing the consequences) and cthat converts your pointer from B* to a D* while still actually being a B obhect at the location pointed to. So the results here are <strong>UNDEFINED</strong> since you are accessing out of bounds.</p>

<p>Also it would be good to prefer C++ style casts, vs C style casts (you are using a C-style cast) as they are generally a bit safer.</p>
",4
38756959,38754683,1,"<p>Use the move constructor:</p>

<pre><code>class Abc
{
public: 
    Abc(std::vector&lt;LargeClass&gt; objTemp) : obj(std::move(objTemp)) {}

private:
    std::vector&lt;LargeClass&gt; obj;
};
</code></pre>

<p>or</p>

<pre><code>class Abc
{
public: 
    Abc(std::vector&lt;LargeClass&gt;&amp;&amp; objTemp) : obj(std::move(objTemp)) {}

private:
    std::vector&lt;LargeClass&gt; obj;
};
</code></pre>

<p>If <code>LargeClass</code> is movable-only (not copyable), both solution are mainly equivalent.</p>

<p>if <code>LargeClass</code> is copyable, I suggest the second one which force a correct usage.</p>

<p>I suggest to delete the copy constructor of <code>LargeClass</code> if you want to avoid copy (and implement a cheap move constrctor).</p>
",0
44375308,44375243,1,"<p><code>friend class MyClass;</code> in the context of <code>::namespace1::MyInterface</code> refers to the class <code>::namespace1::MyClass</code>, which is a different class from <code>::namespace2::MyClass</code>.  (That's the whole point of namespaces, right?)</p>

<p>Change the friend declaration to read like this:</p>

<pre><code>friend class ::namespace2::MyClass;
</code></pre>

<p>Note that this requires that the type <code>::namespace2::MyClass</code> has already been declared, so you either need to forward-declare it (<code>namespace namespace2 { class MyClass; }</code>) or you need to make sure that the definition is included prior to the definition of <code>::namespace1::MyInterface</code>.</p>

<p>(See <a href=""http://coliru.stacked-crooked.com/a/f2dffc3d8feb5185"" rel=""nofollow noreferrer"">this demo</a>.)</p>
",0
44375490,44375243,1,"<p>MyClass is in <code>namespace2</code>. So you need to use:</p>

<pre><code>friend class namespace2::MyClass;
</code></pre>

<p>You may also need to use forward decleration of <code>MyClass</code> before you define <code>MyInterface</code>.</p>

<p>Here's an example that compiles:</p>

<pre><code>// forward decleration
namespace namespace2
{
    class MyClass;
}

namespace namespace1
{
    class MyInterface
    {
        friend class namespace2::MyClass; // added missing namespace
    public:
        virtual void some_method(void) = 0;

    private:
        int some_attribute;
    };
}


namespace namespace2
{
    class MyClass
    {
        void MyMethod(namespace1::MyInterface* MyConcrete)
        {
            if(MyConcrete-&gt;some_attribute == 1)
            {
            }
        }
    };
}

int main()
{
}
</code></pre>

<p>You can run it <a href=""https://wandbox.org/permlink/nD6A6MnQB3Yrlv58"" rel=""nofollow noreferrer"">here</a>.</p>
",0
38394329,38394164,-1,"<p>Use scope resolution operator to use the process function in main function like this </p>

<p>first declare the object the 
A::object_name.processs();</p>
",1
38396661,38394164,2,"<p>Number of arguments not fixed, different types:</p>

<pre><code>#include&lt;iostream&gt;

template&lt;typename... T&gt;
void func(T... t) {
    int arr[] = { (std::cout &lt;&lt; t &lt;&lt; std::endl, 0)... };
}

int main() { func(1, .42, ""foo""); }
</code></pre>
",0
37767290,37766910,1,"<p>Maxim Sabyanin's comment might be a possible solution. If you are only interested in integers, then either do a floor or ceil of the result of pow. I have faced a similar issue before. You can write a simple implementation of pow as shown below</p>
<pre><code>int exponent(int base_number, int power)
{
    if(power==0)
        return 1;
    int i;//multiplication counter
    int current_product=1;
    for(i=0; i&lt;power; i=i+1)
    {
        current_product=current_product*base_number;
    }
    return current_product;
}
</code></pre>
",0
37767317,37766910,0,"<blockquote>
  <p>I used <code>ceil()</code> around the <code>pow()</code> and passed the test case. </p>
</blockquote>

<p>That's a good reason to avoid <code>pow</code> in such cases. It's not too hard to implement a function that works with integral types and doesn't suffer from the floating point precision issues.</p>

<pre><code>int int_pow(int x, unsigned int n)
{
   int ret = 1;
   while (n--)
   {
      ret *= x;
   }
   return ret;
}
</code></pre>

<p>Note that if this becomes a performance bottleneck, you can use a slightly modified version.</p>

<pre><code>int int_pow(int x, unsigned int n)
{
   if ( n == 0 )
   {
      return 1;
   }

   return (int_pow(x, n/2) * (n%2 == 0 ? 1 : x));
}
</code></pre>
",0
43230618,43230195,0,"<p>You may forward declaration of enum first:</p>

<pre><code>enum class MyEnum : int;

struct MyStruct
{
    TSomeClass&lt;MyEnum&gt; someClassInstance;
};
</code></pre>
",1
39687853,39687763,4,"<p>When you read the input you have:</p>

<pre><code>for (auto u : *univercities) {
    if (u.name == uni_name) {
        applications.push_back(&amp;u);
        break;
    }
}
</code></pre>

<p>In the ranged based for loop <code>u</code> is a copy of the element in the vector. Thus the adresses you push into the vector are invalid once you leave the loop. Use</p>

<pre><code>for (auto&amp; u : *univercities) { //...
</code></pre>

<p>to use references and avoid making copies.</p>
",1
39687904,39687763,0,"<p><code>applications.push_back(&amp;u);</code></p>

<p>You are pushing to <code>applications</code> a pointer to <code>univercities</code>'s element. But <code>univercities</code> cease to exist at the end of the <code>input</code> function (and so all its content). So after that pointers in <code>application</code> vector doesn't point to existing objects.</p>

<p>Btw.: ""universities"", not ""univercities"".</p>

<p><strong>Edit: I was wrong. Vector is passed by pointer so it still exist. Didn't notice the asterisk, sorry.</strong></p>
",5
39645114,39644599,4,"<blockquote>
  <p>Multiple people have told me it's not a violation and that there is no UB</p>
</blockquote>

<p>Those people are wrong. This code:</p>

<pre><code>uint16_t* data16 = reinterpret_cast&lt;uint16_t*&gt;(data);
</code></pre>

<p>is defined behavior if, <em>and only if</em>, there is an object of type <code>uint16_t</code> at <code>data</code>. That is, if I called your foo like:</p>

<pre><code>uint16_t p = 42;
foo(reinterpret_cast&lt;char*&gt;(&amp;p), 2); // now, we're ok
</code></pre>

<p>or:</p>

<pre><code>char data[64];
new (data) uint16_t{42};
foo(data, 2); // also ok, though with C++17 you'll have to use std::launder
</code></pre>

<p>But otherwise, it's UB. The non-UB way to do this would be:</p>

<pre><code>uint16_t data16;
memcpy(&amp;data16, data, sizeof(data16));
</code></pre>

<p>which many compilers will treat as a <code>reinterpret_cast</code>. </p>

<hr />

<p>That said, an enormous amount of networking code does what you are doing, and there would be <strike>riots in the streets</strike> many angry messages posted on forums if compilers optimized this code in a way that caused it to not do what you want it to. </p>
",1
39644759,39644599,2,"<blockquote>
  <p>doing <em>anything</em> that dereferences a type-casted pointer (unless it was just cv-casted or casted to a compatible type or char) is UB.</p>
</blockquote>

<p>That is not correct.</p>

<p>Any pointer can be cast to <code>char*</code> and <code>void*</code> and back. It is UB only when the original pointer is of a different type than the pointer type used when dereferencing the pointer. There are exceptions to even that. See <a href=""https://stackoverflow.com/questions/39599219/struct-alignment-and-type-reinterpretation"">Struct alignment and type reinterpretation</a> for an example.</p>
",4
47458361,47458252,11,"<p>In C++ the objects are constructed in order of occurrence and destructed in the reverse order. First comes <code>foo</code> construction, then <code>bar</code> construction then <code>main</code> is executed then <code>bar</code> is destructed and then <code>foo</code>. This is the behavior you are seeing. The switch appears because the constructor of <code>foo</code> doesn't construct a <code>Foo</code>, it constructs an empty <code>unique_ptr</code>, so you don't get to see <code>Foo()</code> in the output. Then <code>bar</code> is constructed with the output and in <code>main</code> you create the actual <code>Foo</code> after <code>foo</code> has long been constructed.</p>
",5
47458373,47458252,3,"<blockquote>
  <p>I would expect Bar's destructor to run only after the last instance of Foo's destructor runs. </p>
</blockquote>

<p>No, as a <code>static</code> data member, <code>Foo::bar</code> is independent of any instances of <code>Foo</code>. </p>

<p>And for the code you showed,</p>

<pre><code>static std::unique_ptr&lt;Foo&gt; foo; // no Foo created here

Bar Foo::bar; // Foo::bar is initialized before main(), =&gt; ""Bar()""

int main(int argc, char **argv) {
    foo = std::make_unique&lt;Foo&gt;(); // an instance of Foo is created, =&gt; ""Foo()""
} 

// objects are destroyed in the reverse order how they're declared
// Foo::bar is defined after foo, so it's destroyed at first =&gt; ""~Bar()""
// foo is destroyed; the instance of Foo managed by it is destroyed too =&gt; ""~Foo()""
</code></pre>
",6
47458645,47458252,2,"<p>The complication here is that the code doesn¡¯t instrument the constructor of <code>foo</code>. What happens is that <code>foo</code> gets constructed first, than <code>Foo::bar</code> gets constructed. The call to <code>make¡­unique</code> constructs a <code>Foo</code> object. Then <code>main</code> exits, and the two static objects get destroyed in reverse order of their construction: <code>Foo::bar</code> gets destroyed, then <code>foo</code>. The destructor for <code>foo</code> destroys the <code>Foo</code> object that it points to, which is the one created in<code>main</code>.</p>
",5
47460286,47458252,1,"<p>Static objects' lifetimes are based solely on the order of their definition. The compiler doesn't ""know enough"" when to call <code>Bar::Bar()</code> as much as calling <code>Bar::~Bar()</code>.</p>

<p>To illustrate the problem better, consider this</p>

<pre><code>class Foo;

struct Bar {
    Bar() {
        std::cout &lt;&lt; ""Bar()"" &lt;&lt; std::endl;
    }

    ~Bar() {
        std::cout &lt;&lt; ""~Bar()"" &lt;&lt; std::endl;
    }

    void baz() {}
};

struct Foo {
    Foo() {
        bar.baz();
        std::cout &lt;&lt; ""Foo()"" &lt;&lt; std::endl;
    }

    ~Foo() {
        std::cout &lt;&lt; ""~Foo()"" &lt;&lt; std::endl;
    }

    static Bar bar;
};

Foo foo;
Bar Foo::bar;

int main() {}
</code></pre>

<p>Prints</p>

<pre><code>Foo()
Bar()
~Bar()
~Foo()
</code></pre>

<p>The addition of <code>std::unique_ptr</code> postpones <code>Foo::Foo()</code> after its construction in main, giving the illusion of the compiler ""knowing"" when to call <code>Bar::Bar()</code>.</p>

<p>TLDR Static objects should be defined later than its dependencies. Before defining <code>bar</code>, it is just as much a bug to define a <code>std::unique_ptr&lt;Foo&gt;</code> and to define a <code>Foo</code></p>
",0
47462179,47458252,0,"<p>In general, you should not write code which depends on the order of construction or destruction of static (or global) data. This makes unreadable and unmaintainable code (you might prefer static smart pointers, or 
<em>explicit</em> initialization or startup routines called from <code>main</code>). And AFAIK that order is not specified when you link several translation units.</p>

<p>Notice that <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a> provides the <a href=""http://ttps://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Attributes.html"" rel=""nofollow noreferrer""><code>init_priority</code></a> and <a href=""https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html"" rel=""nofollow noreferrer""><code>constructor</code></a> (with priority) attributes. I believe you should rather avoid using them. However, the <code>__attribute__(constructor)</code> <a href=""https://stackoverflow.com/a/28652346/841108"">is</a> useful <a href=""https://stackoverflow.com/a/26672678/841108"">inside</a> plugins, for plugin initialization.</p>

<p>In some cases, you might also use <a href=""http://man7.org/linux/man-pages/man3/atexit.3.html"" rel=""nofollow noreferrer"">atexit(3)</a> (at least on POSIX systems). I don't know if such registered functions are called before or after destructors (and I think you should not care about that order).</p>
",0
35234881,35234791,2,"<p>Your problems seems to be more due to overlapping definitions than files that happen to have the same name. But either way, I'd suggest the following fix:</p>

<p>Don't use files from both of these libraries in the same file in your application. Have some files that use the first library and some that use the second. Files that use the first library are compiled with its include path. Files that use the second library are compiled with its include path.</p>

<p>If you really need to integrate calls to both libraries in the same code, just wrap one or both libraries with a sanitized interface whose file and identifier names don't conflict with your project's names.</p>
",1
36263093,36262871,1,"<p>The whole point of pure virtual functions is to actually decouple the concrete implementation from the abstract base class interface.</p>

<p>If you are calling the <code>pureFunc()</code> through a <code>Base*</code> pointer or reference, the calling code should be agnostic about the implementations in <code>D1</code> and <code>D2</code>, and thus shouldn't need to know which one is actually called.</p>
",0
36262992,36262871,1,"<p>The declaration should be <strong><code>virtual</code></strong><code>void pureFunc()=0</code> for the <code>=0</code> to make sense.</p>

<p>Then it depends on which class you instantiate. If you create a <code>D2</code>:</p>

<pre><code>D2 d2{};
</code></pre>

<p>then a <code>Base</code> pointer will call <code>D2::pureFunc()</code>, for example:</p>

<pre><code>Base* bptr = &amp;d2;
bptr-&gt;pureFunc(); // calls D2::pureFunc()
</code></pre>

<p>But if you had created the same pointer to a <code>D1</code> then the same call would resolve to <code>D1::pureFunc()</code></p>

<pre><code>D1 d1{};
bptr = &amp;d1; // same pointer now points to a D1
bptr-&gt;pureFunc(); // now calls D1:pureFunc()
</code></pre>
",0
36411073,36410130,2,"<p><code>duration_cast</code> is for casting a duration to a type which would make it lose precision. milliseconds to seconds, for example. While seconds to milliseconds is implicitly allowed. There's no reason for the #2 method, what were you hoping that to achieve? #1 is what you're after.</p>
",2
46986948,46986855,1,"<p>You declared <code>Shape::area</code> and <code>Shape::rotate</code> but you did not define them</p>

<p>One solution would be to change shapes.h like this:</p>

<pre><code>class Shape {
public:
    double h;
    double w;

    virtual double area(void) { return 0; }
    virtual void rotate(void) {}
};
</code></pre>

<p>Another solution is to instead add the definitions to shapes.cpp:</p>

<pre><code>double Shape::area() { return 0; }
void Shape::rotate() {}
</code></pre>

<p>As juanchopanza pointed out, another solution is to make the methods pure virtual (which is probably best):</p>

<pre><code>class Shape {
public:
    double h;
    double w;

    virtual double area(void) = 0;
    virtual void rotate(void) = 0;
};
</code></pre>
",5
41202994,41202948,0,"<p>No, there's nothing that marks the end of an array in memory. There is ""no equivalent of a null character"". It is your responsibility to keep track of this.</p>

<p>One of the many reasons for using a <code>std::vector</code> is that the vector keeps track of this. But since, as you stated, you ""have access to an array and not a vector"", then it's up to you to handle the vector's responsibilities.</p>
",2
41203134,41202948,3,"<p>There are several possible approaches.</p>

<p>You can use a sentinel value, and put that value at the end of the array, much like <code>'\0'</code> marks the end of a C-style string. The problem with that is that you have to be sure that your sentinel value will never occur in the data that you need to store.</p>

<p>You can carry around a count of the number of values in the array, and pass that value to functions that deal with your array.</p>

<p>You can create a pointer that points one past the last element in the array, and deal with the array as a pair of pointers: one that points at the first element, and one that points one past the end. That's compatible with STL algorithms, so it's probably your best overall approach.</p>
",0
34951319,34951199,1,"<p>You class does not overload <code>operator &lt;&lt;</code> and <code>operator &gt;&gt;</code> so you are not able to use it with <code>cout &lt;&lt;</code> and <code>cin &gt;&gt;</code>.  Your class does have</p>

<pre><code>std::istream &amp;read_item(std::istream &amp;in);
std::ostream &amp;write_item(std::ostream &amp;out) const;
</code></pre>

<p>Which you can use like</p>

<pre><code>Sales_item book;
int gne;
// read ISBN, number of copies sold, and sales price
book.read_item(std::cin);
// write ISBN, number of copies sold, total revenue, and average price
book.write_item(std::cout);
</code></pre>
",0
34951330,34951199,1,"<p>There is no operator&lt;&lt; and no operator>> defined for your type Sales_item, so the compiler doesn't know what to do with the statement ""cin >> book"" and ""cout &lt;&lt; book"".
You have to write operator overload functions for basic_istream and basic_ostream and Sales_item.</p>

<p>For your case:</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Sales_item&amp; item)
{
   return item.write_item(os);
}

std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Sales_item&amp; item)
{
   return item.read_item(is);
}
</code></pre>
",1
47464729,47464403,2,"<p>When you encode the username into stream, you take the length of the word but pass <code>.c_str()</code></p>

<pre><code>existingstream_.write(reinterpret_cast&lt;const char *&gt;(&amp;userlen), sizeof(int));
existingstream_.write(existinguser_.c_str(), userlen);
</code></pre>

<p><code>.c_str()</code> adds terminating <code>'\0'</code>, which you cut off by passing pure word length. And that is fine as long as you know how long is the word and pass that data along.</p>

<p>When you assemble it on the other end, you need to use string constructor that takes length param and pass your word length to it. Default constructor will look for terminating '\0' and sometimes there might even be one, which explains why it worked for you sometimes. So to make sure the string is constructed correctly, you need to tell the constructor how long is the username, like this:</p>

<pre><code> pair&lt;string, SaltDigest&gt; user_details(std::string(username, (int)*userlen), sd);
</code></pre>
",0
37837589,37837363,3,"<p>Without seeing all your code, you have probably not defined a template class called <code>LNA_FUNCTION</code>. Have you <code>#include</code>'d all of your dependencies?</p>

<p>As a sidenote, I would strongly advise against writing a class and then defining a preprocessor macro with the same name. It will probably not do what you want it to do.</p>
",0
43180345,43180263,5,"<p>They are not the same, and it would be a pain in the neck if someone forced them to be.</p>

<p>Copy construction is a way of <em>creating</em> an object. Amongst other things, <em>base member initialisers</em> can be used. In multi-threaded code, you don't need to worry so much about mutual exclusion units in a constructor since you cannot create the same object simultaneously!</p>

<p>An assignment operator does a rather different thing. It operates on an object that already exists <em>and should return a reference to self</em>. An implementation can do subtly different things here cf. copy construction. For example, a string class might <em>not</em> release resources if the new assigned string is smaller.</p>

<p>In simple cases they may well do the same thing and the return value of an assignment discarded. But in such cases you can rely on the ones that the compiler generates automatically.</p>
",2
43180616,43180263,3,"<p>They are <em>so</em> not the same. They might be the same in special cases, but generally, no.</p>

<p>when you have something like this:</p>

<pre><code>std::vector myVec = myOtherVec;
</code></pre>

<p>It looks like assignment, but actually the copy constructor is being called.</p>

<p><strong>The copy constructor starts an object from nothing</strong>.</p>

<p>This falls back to the basic question of what's the difference between <code>malloc</code> (the old C way to reserve memory) and <code>new</code>. The difference is: <code>new</code> calls the constructor of your object, which is very important in C++, otherwise we'd be talking about garbage memory that can't be initialzed unless it explicitly is.</p>

<p>For example, in the internal implementation of <code>std::vector</code>, there is a <code>size</code> variable that tracks the number of elements actively acknowledged by the user with <code>push_back()</code> or <code>resize</code> (we're not talking about reserve).</p>

<p>Now imagine how it's implemented:</p>

<pre><code>template &lt;typename T&gt;
class vector
{
    int size;
    T* theArray;
    void reserveMyMemory(); //ignoring allocators for simplicity
}
</code></pre>

<p>What's the difference between the copy constructor and assignment operator?</p>

<ul>
<li><strong>Assignment operator:</strong> Just copies size and the array content.</li>
<li><strong>Copy-cosntructor:</strong> Must reserve memory and initialize variables, then copy. </li>
</ul>

<p>Now imageine that memory reserving requires checking the <code>size</code> and whether <code>theArray</code> is <code>nullptr</code>. What's going to happen if internally it uses assignment operator? A catastrophe. Because the values are not initialized. So, you need a constructor to start.</p>

<p>In this case, the copy constructor is more general, because <em>it should initialize variables</em>, then copy the elements it has to copy. Of course, this whole example is just a demonstration. Don't take it literally for <code>std::vector</code>, the STL doesn't work that way.</p>
",0
37905300,37905125,9,"<p>There are a few differences between <code>cout&lt;&lt;</code> and <code>cout.put</code>, or should we say the overloaded <code>&lt;&lt;</code> operator and the <code>put</code> method from <code>std::basic_ostream</code> because this is not really limited to the global instance: <code>cout</code>.</p>

<p>The <code>&lt;&lt;</code> operator writes formatted output, the <code>put</code> method does not.</p>

<p>The <code>&lt;&lt;</code> operator sets the failbit if the output fails, the <code>put</code> method does not.</p>

<p>Personally I would go with the <code>&lt;&lt;</code> operator in almost all cases, unless I had specific needs to bypass the formatted output or not setting the failbit on error.</p>

<p>Using them can result in the following differences of output:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

int main() {
    cout &lt;&lt; ""Character: '"" &lt;&lt; setw(10) &lt;&lt; 'A' &lt;&lt; setw(0) &lt;&lt; ""'"" &lt;&lt; endl;
    cout &lt;&lt; ""Character: '"" &lt;&lt; setw(10);
    cout.put('A');
    cout &lt;&lt; setw(0) &lt;&lt; ""'"" &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>Outputs:</p>

<pre><code>Character: '         A'
Character: 'A'
</code></pre>

<p>See the above in action: <a href=""http://ideone.com/9N0VYn"" rel=""noreferrer"">http://ideone.com/9N0VYn</a></p>

<p>Since the <code>put</code> method is unformatted it does not respect the manipulator set, there might be situations where that is indeed what you intend. But since it sounds like you only want to print out the character, I would prefer the <code>&lt;&lt;</code> operator, which respects the formatting.</p>

<p>And then there is the case of the <code>failbit</code> which is not being set, and that might even be more crucial.</p>
",1
40539799,40539674,4,"<p>It is a question of what is meant by ""any function that is called during stack unwinding"" in the standard text. </p>

<p>I believe the intent was to prevent ""any function that is called <strong>directly</strong> by the stack unwinding mechanism"" to terminate with an exception, i.e. to throw another (new) exception into the active stack unwinding session. This requirement is not supposed to apply to any subsequent (nested) functions calls made <em>internally</em> by any function that is called by the original stack unwinding session.</p>

<p>As long as new exceptions are thrown and caught internally, without being allowed to escape into the active stack unwinding session, they are allowed. Herb's explanation is in full agreement with the standard: it is possible to throw new exceptions during stack unwinding as long as they are intercepted and suppressed internally.</p>

<p>Your example calls <code>terminate()</code> for a different reason. You are probably compiling with post-C++11 compiler. In C++11 destructors are <code>noexpect</code> by default, which is why your <code>YYY::~YYY()</code> simply calls <code>terminate()</code> regardless of whether stack unwinding is in progress, or of any other external conditions (GCC will even warn you about exactly that).</p>

<p>Declare it as </p>

<pre><code>~YYY() throw(std::exception) // or `noexcept(false)`
{
  ...
</code></pre>

<p>to test the intended behavior of the code. And no, it does not call <code>terminate()</code>: <a href=""http://coliru.stacked-crooked.com/a/296ffb43b774409e"" rel=""nofollow noreferrer"">http://coliru.stacked-crooked.com/a/296ffb43b774409e</a></p>

<p>Herb's outdated code, obviously, suffers from the same problem.</p>
",1
43766301,43766249,1,"<p>I would guess that they are so low-level (it's just a memory access for the compiler) that Exception-Handling would be an overkill for this very performance-cheap methods.</p>
",0
43766360,43766249,0,"<p>Performance basically. No check for an invalid value needed and no exceptions needed. If you want exceptions there's the <code>value</code> method.</p>
",0
43766382,43766249,2,"<p>Runtime performance.</p>

<p>See the <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html"" rel=""nofollow noreferrer"">proposal, revision 4</a>, which said:</p>

<blockquote>
  <p>Using the indirection operator for a disengaged object is an undefined
  behavior. This behavior offers maximum runtime performance.</p>
</blockquote>
",0
43766301,43766249,1,"<p>I would guess that they are so low-level (it's just a memory access for the compiler) that Exception-Handling would be an overkill for this very performance-cheap methods.</p>
",0
43766360,43766249,0,"<p>Performance basically. No check for an invalid value needed and no exceptions needed. If you want exceptions there's the <code>value</code> method.</p>
",0
43766382,43766249,2,"<p>Runtime performance.</p>

<p>See the <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3672.html"" rel=""nofollow noreferrer"">proposal, revision 4</a>, which said:</p>

<blockquote>
  <p>Using the indirection operator for a disengaged object is an undefined
  behavior. This behavior offers maximum runtime performance.</p>
</blockquote>
",0
41925030,41924944,1,"<p>As per the doc,
The value of the elements in a set cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container.</p>

<p>So you need to erase and re-insert in the set.</p>

<p><a href=""https://stackoverflow.com/questions/7340434/how-to-update-an-existing-element-of-stdset"">How to update an existing element of std::set?</a></p>
",0
41925196,41924944,0,"<p>As others have mentioned you could cast away the const but that wouldn't be the best solution and if you did that you would have to ensure that the cost isn't used in the sort. You could replace set with map and store the cost outside of your class. </p>

<p>You could then do something like the following...</p>

<pre><code>void Board::shortestPath32 (Position start, Position end){
  map&lt;Position, int&gt; validMoves; //getValidPositions(parent);    
  for(auto child=validMoves.begin(); child!=validMoves.end(); ++child ){  
    child-&gt;second=1; // NYI - replace 1 with the cost    
  }  
}
</code></pre>
",0
41925059,41924944,2,"<p>That's a limitation of <code>std::set</code> - its iterators always return <code>const</code> references. The rationale is - modifying an element in a set can change its position, so it's not allowed.</p>

<p>To modify an element in a set, the official process is to take it out of the set, modify it, and insert it back in.</p>

<p>Now if you <em>know</em> that modifying certain element properties won't affect its position, as a dirty workaround you can declare those <code>mutable</code> and the setter <code>const</code>:</p>

<pre><code>class Position {
public:
    Position();
    Position(int x, int y);
    int getCost() const;
    void setCost (int c) const { cost = c; }
private:
    int x;
    int y;
    mutable int cost;
};
</code></pre>

<p>An even dirtier solution is to cast away <code>const</code>, then you can modify anything (I feel dirty even bringing this up).</p>

<p>P.S. This issue can usually be avoided in the first place by choosing a structure that fits your needs better - for example <code>std::map</code>; you could refactor the code into <code>Position</code> and <code>Cost</code>:</p>

<pre><code>class Position {
    int x;
    int y;
    . . .
};
class Cost {
    int cost;
    . . .
};

std::map&lt;Position,Cost&gt; validMoves;
</code></pre>

<p>Then you will be able to modify <code>Cost</code> legally, while <code>Position</code> can remain <code>const</code>:</p>

<pre><code>  for(auto it =validMoves.begin(); it!=validMoves.end(); ++it){
      it-&gt;second.setCost(c);
  }
</code></pre>

<p>But that's a design choice that may depend on other factors not mentioned in the question...</p>
",4
41897942,41891482,2,"<p>The issue is that the linker will use all object files for linking a binary given to it directly, but for static libraries it will only pull those object files which define a symbol that is currently undefined.</p>

<p>That means that if all the object files in a static library contain only such self-registering code (or other code that is not referenced from the binary being linked) - nothing from the entire static library shall be used!</p>

<p>This is true for all modern compilers. There is no platform-independent solution.</p>

<p>A non-intrusive to the source code way to circumvent this using CMake can be found <a href=""https://github.com/onqtam/doctest/blob/master/examples/exe_with_static_libs/doctest_force_link_static_lib_in_target.cmake#L35"" rel=""nofollow noreferrer"">here</a> - read more about it <a href=""https://github.com/onqtam/doctest/blob/master/doc/markdown/faq.md#why-are-my-tests-in-a-static-library-not-getting-registered"" rel=""nofollow noreferrer"">here</a> - it will work if no precompiled headers are used. Example usage:</p>

<pre><code>doctest_force_link_static_lib_in_target(exe_name lib_name)
</code></pre>

<p>There are some compiler-specific ways to do this as grek40 has already <a href=""https://stackoverflow.com/questions/9459980/c-global-variable-not-initialized-when-linked-through-static-libraries-but-ok/11336506#11336506"">pointed out</a> in a comment.</p>
",0
36667815,36666368,1,"<h2>Approach</h2>

<ul>
<li>All the declarations must go in the headers and </li>
<li>all the definitions go into the .cpp files.</li>
<li>None of the headers include each other.</li>
</ul>

<p>In this specific instance the error regarding the missing definition (for the <code>std::pair</code>, as part of the <code>std::map</code>) goes away if all the .cpp files include all the declarations. (A needs C, but C needs B)</p>

<p>So even though the error was for a missing definition, it could be solved by including a declaration. I'm not sure why and will post a <a href=""https://stackoverflow.com/q/36667957/1460794"">separate question</a>.</p>

<h2>Solution</h2>

<p>A.h</p>

<pre><code>#ifndef A_h
#define A_h

#include &lt;map&gt;

class C;

class A {
public:
    C&amp; add();
    std::map&lt;int,C&gt; Cmap;
    void dosomethingwithC();
};

#endif
</code></pre>

<p>B.h</p>

<pre><code>#ifndef B_h
#define B_h

#include &lt;map&gt;

class A;

class B {
public:
    A&amp; add();
    std::map&lt;int,A&gt; Amap;
};

#endif
</code></pre>

<p>C.h</p>

<pre><code>#ifndef C_h
#define C_h

#include &lt;map&gt;

class B;

class C {
public:
    B&amp; add();
    std::map&lt;int,B&gt; Bmap;
};

#endif
</code></pre>

<p>A.cpp</p>

<pre><code>#include ""A.h""
#include ""B.h"" // also required here
#include ""C.h""

C&amp; A::add()
{
    auto emplace_results = Cmap.emplace(std::piecewise_construct,
        std::forward_as_tuple(3),
        std::forward_as_tuple());
    auto pair_iterator = emplace_results.first;
    auto&amp; emplaced_pair = *pair_iterator;
    auto&amp; map_value = emplaced_pair.second;
    return map_value;
}


void A::dosomethingwithC()
{
    Cmap[3].add();
}
</code></pre>

<p>B.cpp</p>

<pre><code>#include ""A.h""
#include ""B.h""
#include ""C.h"" // also required here

A&amp; B::add()
{
    auto emplace_results = Amap.emplace(std::piecewise_construct,
        std::forward_as_tuple(3),
        std::forward_as_tuple());
    auto pair_iterator = emplace_results.first;
    auto&amp; emplaced_pair = *pair_iterator;
    auto&amp; map_value = emplaced_pair.second;
    return map_value;;
}
</code></pre>

<p>C.cpp</p>

<pre><code>#include ""A.h"" // also required here
#include ""B.h""
#include ""C.h""

B&amp; C::add()
{
    auto emplace_results = Bmap.emplace(std::piecewise_construct,
        std::forward_as_tuple(3),
        std::forward_as_tuple());
    auto pair_iterator = emplace_results.first;
    //auto&amp; emplaced_pair = *pair_iterator;
    std::pair&lt;const int,B&gt;&amp; emplaced_pair = *pair_iterator;
    auto&amp; map_value = emplaced_pair.second;
    return map_value;
}
</code></pre>

<p>Main.cpp</p>

<pre><code>#include ""A.h""
#include ""B.h""
#include ""C.h""

int main()
{
    C c;
    auto&amp; emplacedB = c.add();
    auto&amp; emplacedA = emplacedB.add();
    auto&amp; emplacedC = emplacedA.add();
    emplacedC.add();
    return 0;
}
</code></pre>
",0
37705809,37705243,4,"<p>In both cases you are casting your lvalue <code>myclass</code> to an rvalue reference. </p>

<p>The return type of <code>std::move</code> is an rvalue reference, so by definition, the <code>std::move</code> expression is an rvalue - and as such, can bind to the rvalue reference parameter of the move constructor of <code>MyClass</code>.</p>

<p>The <code>std::move</code> instruction can be interpreted as 'I'm done with this variable, it can now be moved'. Note that this is the case irrespective of what the type of the variable being passed to <code>std::move</code> is - it works just as well with normal variables, lvalue reference and rvalue references.</p>
",0
37705901,37705243,2,"<blockquote>
  <p>how is it possible for the move to complete if the parameter was passed by value?</p>
</blockquote>

<p>Regular value (argument) variables can be copy-initialized by move.</p>

<p>So, with the value constructor, the argument is copy-initialized by moving from the passed value, and then the member is copy-initialized by moving from the argument.</p>

<p>With the rvalue reference constructor, the argument reference is bound to the passed value, and the member is copy-initialized by moving from the referenced value.</p>

<blockquote>
  <p>how does the compiler 'remember' that it was moved if the parameter was <code>Myclass</code> and not <code>Myclass&amp;&amp;</code>?</p>
</blockquote>

<p>The compiler does not need to 'remember' whether an object has been moved from or not (or whether it was constructed by move or otherwise).</p>
",0
37706035,37705243,3,"<p>When you write <code>MyContainer mycontainer{std::move(myclass)};</code>, we have to enumerate all the viable constructors of <code>MyContainer</code> that can be called with an xvalue of type <code>Myclass</code>. <code>MyContainer</code> has a single relevant constructor which takes an argument of type <code>Myclass</code>. To see if that constructor is viable, we effectively perform overload resolution again on constructing a <code>Myclass</code> with an xvalue of type <code>Myclass</code>. That gives us three constructors:</p>

<pre><code>Myclass(int );                     // not viable: no conversion from `Myclass` to `int`
Myclass(Myclass&amp;&amp; );               // viable
Myclass(const Myclass&amp; ) = delete; // viable
</code></pre>

<p>The move constructor is viable because you can bind an rvalue reference to an xvalue. The copy constructor is viable because you can bind a const lvalue reference to anything. One of the tiebreakers in overload resolution is picking the <em>least</em> <em>cv</em>-qualified reference. The move constructor is an rvalue reference to <code>Myclass</code>. The copy constructor is an lvalue reference to <code>Myclass const</code> - that is more cv-qualified, hence it is less prefered. Thus, we select the move constructor. This constructor is not deleted, so that call is well-formed.</p>

<p>The important part here is that we're constructing with an <em>xvalue</em> of type <code>Myclass</code> (that's what <code>std::move()</code> does - it's a cast to xvalue). If we were constructing with an lvalue (i.e. simply <code>MyContainer mycontainer(myclass)</code>) then only the copy constructor would be viable, but it's explicitly deleted so the entire expression is ill-formed.</p>

<blockquote>
  <p>how does the compiler 'remember' that it was moved if the parameter was <code>Myclass</code> and not <code>Myclass&amp;&amp;</code>?</p>
</blockquote>

<p>There's no remembering. In both cases, we're trying to initialize the argument in the constructor from an xvalue of type <code>Myclass</code>. In the former case, that involves invoking the move constructor of <code>Myclass</code>. In the latter case, that's a direct reference binding. </p>
",0
46634222,25610676,0,"<p>instead of using <code>sort(a[i][0],a[i][n]);</code><br>
use <code>sort(a[i],a[i]+n);</code><br>
it will work.</p>
",0
41188399,41188336,2,"<p>The reason your code isnt working is because you dont initialise your pointer.</p>

<p>Try this instead:</p>

<pre><code>vector&lt;string&gt;* v = new vector&lt;string&gt;();
</code></pre>

<p>Also, make sure to call</p>

<pre><code>delete v;
</code></pre>

<p>When you don't need your vector anymore.</p>
",3
37159092,37158879,1,"<p><code>size_t</code> is a typedef, you cant use it with extern - extern is used with variables or functions.</p>

<p>It would suffice if you make sure that before every:</p>

<pre><code>#include ""my_string.h""
</code></pre>

<p>there is </p>

<pre><code>#include &lt;cstddef&gt;
</code></pre>

<p>its good practice to always include first compiler headers (the onces with &lt; >), and then local headers (the includes with "" ""). </p>

<p>If you need a type definition as std::size_t then include it, even in header file. All headers should have proper include guards to prevent multiple definitions. Keeping to a habit of only including headers in your .cpp files is really hard. Compilers are good at optimizing multiple header includes, Visual Studio offers precompiled headers, also <code>#pragma once</code>.</p>
",4
37159081,37158879,4,"<p><code>extern</code> is for functions and variables, not for type aliases. Type aliases are defined with <code>typedef</code>s.</p>

<p>If you wanted to do this for one of your own types, you could copy its typedef from the header, and avoid header inclusion, but even then you would get duplicate code that is a maintenance liability.</p>

<p>Matters are even worse with <code>size_t</code>: since the built-in type behind it is system-dependent, you would have to reproduce the same logic or risk incompatibility. Both options are pretty bad, compared to simply including the header.</p>
",3
37159357,37158879,4,"<p>You should avoid include header file in a header file if you are developing a library, but you always need to include required header in cpp files.
thus it is a good practice to include specific headers only in cpp file and use forward declaration in header file.
but if you have a dependency in system header like your case then you should include that system header in your header file.</p>

<p><strong>The tip</strong> is that by including the header in 
source files
(*.cpp , *.c) we are preventing the end user to resolve the linker dependency of the library that we have developed.</p>
",1
34993709,34993429,20,"<p>Virtual inheritance is a funny beast, in that copy construction isn't ""inherited"" in the same way that it would be normally. Your <code>A</code> base is being default-constructed because you are not explicitly copy-constructing it:</p>

<pre><code>class C : public B {
public:
    C() {}
    C(const C &amp;from) : A(from), B(from) {}
};
</code></pre>
",6
43725381,43725030,0,"<p><code>std::string</code> doesn't recognize encodings; its <code>operator[]</code> returns its individual bytes, not individual characters.</p>

<p>On Unicode, <code>¨¦</code> is actually composed of two bytes, and with <code>letra[i]</code> you get each one of those individually. However, <code>operator&lt;&lt;</code> for <code>std::string</code>s does the right job by ""composing"" those two bytes and actually printing the character <code>¨¦</code>.</p>

<p>To access each character individually (not random access however), you can use <a href=""http://en.cppreference.com/w/cpp/string/multibyte/mbtowc"" rel=""nofollow noreferrer""><code>mbtowc</code></a> defined in <code>&lt;cstdlib&gt;</code>:</p>

<pre><code>int mbtowc(wchar_t* pwc, const char* s, size_t n);
</code></pre>

<p>It examines at most <code>n</code> bytes of <code>s</code> to find a character and place it at <code>pwc</code>, returning the number of bytes read. Your printing routine becomes something like this:</p>

<pre><code>mbtowc(nullptr, 0, 0);
for (int i = 0; i &lt; letra.size();)
{
    wchar_t wc;
    int r = mbtowc(&amp;wc, &amp;letra[i], letra.size()-i);
    cout &lt;&lt; wc &lt;&lt; endl;
    if (r &lt;= 0) break;
    i += r;
}
</code></pre>
",3
39129234,39129171,5,"<blockquote>
  <p><strong>Option 3: declare within class</strong></p>
  
  <p>Maybe the best option to limit scope</p>
</blockquote>

<p>Of course, that's the best way to limit scope and doesn't pollute the namespace. Go for option 3.</p>

<blockquote>
  <p><s>but potentially messy?</s></p>
</blockquote>

<p>I didn't get your concerns (you may wanted to elaborate that in your question), there's nothing <em>messy</em> with that at all. </p>

<p><strong>Note:</strong> Whenever needed to make a roundtrip from clients with it, they can use the <code>auto</code> keyword to refer to <code>Bar</code> variables.</p>

<hr>

<p>Another option as <a href=""https://stackoverflow.com/questions/39129171/where-to-define-struct-only-to-be-used-as-private-member-variable#comment65603917_39129171"">mentioned by R.Sahu</a>, is to use the <a href=""https://stackoverflow.com/questions/8972588/is-the-pimpl-idiom-really-used-in-practice""><em>Pimpl Idiom</em></a>:</p>

<pre><code>struct FooData;
class Foo {
    ...
private:

    std::unique_ptr&lt;FooData&gt; data_; // Note I not prefer to use leading underscores

public:
    Foo();
};
</code></pre>

<p>And in <code>Foo</code>'s translation unit:</p>

<pre><code>namespace {
    struct FooData;
    {
        int a;
        int b;
        ...
    };
}

Foo::Foo() : data_(std::make_unique&lt;FooData&lt;()) {}
</code></pre>
",11
39129357,39129171,4,"<blockquote>
<p><strong>Option 1: define in header?</strong></p>
<p>I'd like to avoid this, as I don't want Bar to be usable outside the Foo class scope.</p>
</blockquote>
<p>With option one, you just answered your own question.</p>
<blockquote>
<p><strong>Option 2: forward declare in header, define in cpp</strong></p>
</blockquote>
<p>Same problem here as option 1(scope visibility ), but only advantage is Bar's implementation won't be visible to other <code>.cpp</code> files.</p>
<blockquote>
<p><strong>Option 3: declare within class</strong></p>
</blockquote>
<p><strong>Option 3</strong> is the best, since it fulfills the purpose you ask for, and only that. In addition, with that <code>Bar</code> is available to the whole class. Also, nesting the class prevents unnecessary clutter in your code, as nothing except <code>Foo</code> can access <code>Bar</code>. And it definitely does NOT seem messy, and plus, you could declare just the struct like this:</p>
<pre><code>class Foo
{
private:
    struct Bar {int a, int b};
    //.....
};
</code></pre>
<p>For a small class, and that seems ok since it is a 1-liner. A disadvantage would be forward-declaring the class, not possible, as seen in this answer: <a href=""https://stackoverflow.com/a/951245/6525260"">https://stackoverflow.com/a/951245/6525260</a>.</p>
",2
39129208,39129171,10,"<p>For the option 2 to compile, <code>_bar</code> should be a pointer. Option 3 is best, since it doesn't pollute namespace.</p>
",0
44643778,44643727,2,"<p>Are you sure you are really compiling all the cpp files?
Looks like your CMake / compiler isn't including <code>cmf-algo-exacto.cpp</code> and <code>cmf-heuristica-constructiva.cpp</code>.</p>

<p>Also, with those files, you may get errors since you define the <code>main</code> function multiple times. Best approach would probably be to create a separate <code>main.cpp</code> file and put the (only) <code>main</code> function there.</p>

<p>EDIT: Igor Tandetnik is right, the parameters don't match</p>
",1
42530495,42530422,6,"<p>The assignment does not change the old object's identity, all pointers and references to it remain valid.</p>
",2
45093847,45093313,1,"<p>Please try the following:</p>

<pre><code>static std::string getFromNodeDefault(MiniNode* node, std::string&amp; def,std::string&amp; key) {
    try {
        return node-&gt;getAttributeString(key);
    }
    catch (...) {
        return def;
    }
}
template&lt;typename... T&gt;
static std::string getFromNodeDefault(MiniNode* node, std::string&amp; def, 
std::string&amp; key, T&amp;... args) {
    try {
        return getFromNodeDefault(node-&gt;getChildByKey(key), def, args...);
    }
    catch (...) {
        return def;
    }
}
</code></pre>
",0
35261419,35261389,6,"<p>During the call to <code>std::cout&lt;&lt;data.rdbuf()</code>, <code>std::cout</code> is unable to read any characters from <code>data</code>'s <code>filebuf</code> because the read position is already at the end of the file after the previous output; <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt"" rel=""nofollow"">accordingly</a>, this sets <code>failbit</code> on <code>std::cout</code>, and until this state is cleared any further output will fail too (i.e. your final line is essentially ignored).</p>

<p><code>std::cout&lt;&lt;data.str()&lt;&lt;std::endl;</code> will not cause <code>cout</code> to enter a failed state because <code>data.str()</code> returns a copy of the underlying string regardless of where the read position is (for mixed-mode stringstreams anyway).</p>
",2
47476167,47476129,2,"<p>Macros are a preprocessing concept. The preprocessor does not have a notion of namespace.</p>

<p>You could define your macro inside namespaces, but you'll use it with an unqualified name:</p>

<pre><code>namespace n {
#define MACRO(x)
}

int main()
{
    MACRO(""something"");
}
</code></pre>
",2
39330368,39330251,4,"<p>In the current C++ standard (C++14, as well as in the previous versions C++11 and C++03), it is unspecified whether memory is allocated before or after <code>f()</code> is evaluated, but in any case memory will be freed if it has been allocated; <strong>[expr.new]</strong>:</p>

<blockquote>
  <p>20 - If any part of the object initialization described above<sup>79</sup> terminates by throwing an exception, storage has
  been obtained for the object, and a suitable deallocation function can be found, the deallocation function is
  called to free the memory [...]</p>
  
  <p>79) This may include evaluating a <em>new-initializer</em> and/or calling a constructor.</p>
</blockquote>

<p>Here the <em>new-initializer</em> is <code>f()</code>, so if the evaluation of <code>f()</code> throws an exception, the deallocation function will be called (if found).</p>

<p>Since C++17, the allocation of memory is sequenced <em>before</em> the evaluation of <code>f()</code>, so the memory will always be deallocated:</p>

<blockquote>
  <p>21 - If any part of the object initialization described above<sup>79</sup> terminates by throwing an exception and a suitable
  deallocation function can be found, the deallocation function is called [...]</p>
</blockquote>

<p>Note though that since memory allocation is elidable, the implementation is in practice free to omit the allocation if it can predict that an exception will be thrown.</p>
",10
38873801,38873563,0,"<p>As explained <a href=""http://www.cplusplus.com/doc/tutorial/typecasting/"" rel=""nofollow noreferrer"">here</a>:</p>

<blockquote>
  <p>Single-argument constructors: allow implicit conversion from a
  particular type to initialize an object.</p>
</blockquote>

<p>Hence, there is an implicit conversion option from  <code>PA</code> to <code>B</code> due to the constructor:</p>

<pre><code>    B(PA pa)
</code></pre>

<p>So when you called:</p>

<pre><code>    func(pA)
</code></pre>

<p>the <code>pA</code> pointer converted to <code>B</code> object and then used by <code>func</code></p>

<p>(similar <a href=""https://stackoverflow.com/questions/38699814/c11-genrated-constructor/38699910#38699910"">SO post</a>)</p>
",0
46637125,46636826,1,"<p>The <a href=""http://en.cppreference.com/w/cpp/string/basic_string/to_string"" rel=""nofollow noreferrer""><code>to_string</code> function</a> only has overloads for converting numerical values to strings, which is why you're getting the string ""43"".  You could just change your code to this:</p>

<pre><code>s1.push(""+"");
</code></pre>

<p>in which string's <a href=""http://www.cplusplus.com/reference/string/string/string/"" rel=""nofollow noreferrer"">from c-string</a> constructor is used to implicitly convert from the <code>const char*</code> to a <code>string</code>.  Alternately, to convert from a single <code>char</code> to a <code>string</code>, the easiest way is to use the <a href=""http://www.cplusplus.com/reference/string/string/string/"" rel=""nofollow noreferrer"">fill constructor</a>, in which case you would write this:</p>

<pre><code>s1.push(string(1, exp[0]));
</code></pre>
",3
36668445,36667957,2,"<ol>
<li><p>B <em>is</em> used in C.cpp.  It is used in the definition of the member variable of C.</p></li>
<li><p>B.hpp doesn't contains a <em>declaration</em> of class B (which would be <code>class B;</code>).  It contains the <em>definition</em> of it (but not of its members).</p></li>
</ol>
",0
36430933,36417966,0,"<p>Sorry for my post last night. I've worked on it and got a little help from my professor so I wanted to share my answer with you guys.</p>

<p>I am asking for a little constructive criticism, especially on things that could have been done in a better/more efficient way.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

void gradesInput(int&amp; s1, int&amp; s2, int&amp; s3) {
    cout &lt;&lt; ""Please enter your test scores, in order from the first to last.\n"";
    cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3;
    if (s1 &lt; 0 || s1 &gt; 100) {
        cout &lt;&lt; ""Your first test score is not a valid number, please re-enter: "";
        cin &gt;&gt; s1;
    }
    else if (s2 &lt; 0 || s2 &gt; 100) {
        cout &lt;&lt; ""Your second test score is not a valid number, please re-enter: "";
        cin &gt;&gt; s2;
    }
    else if (s3 &lt; 0 || s3 &gt; 100) {
        cout &lt;&lt; ""Your third test score is not a valid number, please re-enter: "";
        cin &gt;&gt; s3;
    }
}


double average3Scores(int s1, int s2, int s3) {
    double avg = (int)(((s1 + s2 + s3) / 3.0) + 0.5); //rounded average
    return avg;
}

double average2Scores(int s2, int s3) {
    double avg = (int)(((s2 + s3) / 2.0) + 0.5);
    return avg;
}

char toLetterGrade(double avg, double avg2, int s3){
    if (avg &gt;= 90)
        return 'A';
    else if (avg &gt;= 70) {
        if (s3 &gt;= 90)
            return 'A';
        else
            return 'B';
    }
    else if (avg &gt;= 50) {
        if (avg2 &gt;= 70)
            return 'C';
        else
            return 'D';
    }
    else
        return 'F';
}

void displayGrade(double avg, char lGrade) {
    cout &lt;&lt; ""Average of 3 test scores is : "" &lt;&lt; avg;
    cout &lt;&lt; endl &lt;&lt; ""Your grade is : "" &lt;&lt; lGrade &lt;&lt; endl;
}


int main() {
    int s1, s2, s3;

    gradesInput(s1, s2, s3); //works
    double avg1 = average3Scores(s1, s2, s3); //works
    double avg2 = average2Scores(s2, s3); //works
    displayGrade(avg1, toLetterGrade(avg1, avg2, s3));

    system(""pause"");
    return 0;
</code></pre>

<p>}</p>

<p>I think I got the hang of reference parameters, but still not sure If I used them correctly. Feel free to point me in the right direction!</p>
",0
47651091,47651014,4,"<p>The language grammar interprets commas in initializers as comma-delimited declarator clauses, i.e. of the form:</p>

<pre><code>int i = 2, j = 3;
</code></pre>

<p>To avoid that ambiguity, you need to wrap comma-expressions in parentheses.</p>

<p>From <strong>[dcl.decl]</strong>:</p>

<pre><code>[...]
init-declarator-list:
    init-declarator
    init-declarator-list , init-declarator
[...]
</code></pre>
",6
39379584,39373556,0,"<p>C++98 Standard 12.6.2.5.4 (I don't expect new versions to have relaxed this).</p>

<blockquote>
  <p>¡ª Then, nonstatic data members shall be initialized in the order they
  were declared in the class definition (again regardless of the order
  of the mem-initializers).</p>
</blockquote>

<p>So the order of initialization is defined according to this.</p>

<p>If you want an example of how to crash it simply make <code>sizeof(Type)*n</code> > total memory in your system.</p>
",0
39009510,39009414,5,"<p>Your code will work without modifications, as long as <code>log</code> accepts an <code>ostream&amp;</code> reference:</p>

<pre><code>void log(ostream&amp; o) {
    stringstream* s = dynamic_cast&lt;stringstream*&gt;(&amp;o);
    if (s) {
        cout &lt;&lt; s-&gt;str() &lt;&lt; endl;
    }
}

int main() {
    int x = 5, y = 6;
    log(stringstream() &lt;&lt; ""x="" &lt;&lt; x &lt;&lt; "", y="" &lt;&lt; y);
    return 0;
}
</code></pre>

<p><a href=""http://ideone.com/wQW0ib"">Demo.</a></p>
",4
39009692,39009414,2,"<p>To solve this problem I have often simply done something like this:</p>

<pre><code>#define LOG(m) do{std::ostringstream oss;oss&lt;&lt;m;std::cout&lt;&lt;oss.str()&lt;&lt;'\n';}while(0)

// ...

LOG(""some text: "" &lt;&lt; value1 &lt;&lt; ' ' &lt;&lt; value2); // no need for '\n'
</code></pre>

<p>Now I tend to use a more sophisticated class based solution that has an even nicer interface and doesn't use a horrible macro.</p>
",0
46098918,46098262,3,"<p>You can NOT round <code>float</code> to particular precision as amount of decimal digits, as internally the float value is &sum; (b<sub>i</sub>/2<sup>i</sup>) values with <em>i</em> being 1..24 for <code>float</code> (when the platform does use IEEE 754 standard floating point implementation). So for example 1/1024 = 0.0009765625 => you may need this one to adjust the fourth decimal digit by cca. +-9, but it will also add few more decimal digits after the fourth.</p>

<p>That's why the OUTPUT is formatted (rounded) to particular amount of decimal digits, but value is kept intact.</p>

<p>In unit testing there's usually special assert dedicated to floating values comparison, which has further argument <em>epsilon</em>, specifying the maximal value difference to be tolerated (in your case 1e-4 would do).</p>

<p>If you don't use some unit testing framework with extensive asserts, you may use Steve's suggestion (which is implementation of such floating assert):</p>

<pre><code>// assert that the difference is smaller than 0.0001
assert(std::abs(mean - mean_x) &lt; 1e-4);  // (abs from cmath) 
</code></pre>

<hr>

<p>related docs about how <code>float</code> works (on most of the platforms):
<a href=""http://floating-point-gui.de/"" rel=""nofollow noreferrer"">What Every Programmer Should Know About Floating-Point Arithmetic</a></p>
",1
43728846,43728712,1,"<p>C++11 introduced the ability to initialize array members in the initializer list. This feature is needed to initialize array elements to a specific value other than zero. Since arrays can't be copied, providing an initialized arrays to copy from also doesn't work.</p>

<p>However, what <em>does</em> work is to wrap the array with a <code>struct</code> and to initialize a <code>const</code> member by copying such a <code>struct</code>. For example:</p>

<pre><code>template &lt;int Size&gt;
struct array {
    unsigned char value[Size];
};
typedef array&lt;100&gt; Key;
class A {
    Key const key1;
    Key const key2;
    static Key make_key() {
        Key rc = Key();
        rc.value[0] = 0x1;
        // whatever else
        return rc;
    }
public:
    A(): key1(make_key()), key2(make_key()) {}
};
</code></pre>

<p>The initialization in <code>make_key()</code> merely resembles the initialization in the example (the first element initialized to <code>0x1</code>, all others to zero). Clearly, it can do do whatever else is needed, probably based on arguments forwarded from the constructor.</p>
",1
37631749,32110748,1,"<p>You can consider the member initialization part of the constructor for functional effects and the member destruction part of the destructor. But what is inlined and what is invoked is not guaranteed. This part is depends totally on the compiler you are using.</p>
",0
36229105,36228717,1,"<p>At least, I can give you a solution for the first part of your problem, i.e. the if-statement. I think the following could work:</p>

<pre><code>std::string operators = ""+-*/"";
std::string tmp = tokens[i];
if(operators.find(tmp) != std::string::npos)
{
    a = S.top(); S.pop();
    b = S.top(); S.pop();
    S.push(compute(a, b, tmp)); // &lt;== [2]
}
else
{
    S.push(stoi(tmp));
}
</code></pre>

<p>What I do here is simple: I have a string that contains all operators and I just search for <code>tmp</code> inside that string. If its position inside that string is not <code>npos</code>, tmp has to be an operator.</p>

<p>For the second part, I have 2 ideas:</p>

<p>It's still a bit clumsy, but you wrote a <code>switch</code> statement would be acceptable, so how about this:</p>

<pre><code>int compute(int a, int b, std::string op)
{
    switch (op[0]) {
        case '+':
            return b+a;
        case '-':
            return b-a;
        case '*':
            return b*a;
        case '/':
            return b/a;
    }
}
</code></pre>

<p>The other idea: Initially, I thought you could use <code>operator+</code> and co to avoid writing your won functions for something that's already implemented, but as it turns out that's impossible. However there are other functions that you can use:</p>

<pre><code>int compute(int a, int b, std::string op)
{
    static std::map&lt;std::string,std::function&lt;int(int,int)&gt; &gt;  operations;
    operations[""+""] = std::plus&lt;int&gt;();
    operations[""-""] = std::minus&lt;int&gt;();
    operations[""*""] = std::multiplies&lt;int&gt;();
    operations[""/""] = std::divides&lt;int&gt;();

    return operations[op](b,a);
}
</code></pre>

<p>Take a look at <a href=""http://ideone.com/wSl5zQ"" rel=""nofollow"">http://ideone.com/wSl5zQ</a> for a full implementation that reads one line of RPN form stdin and calculates the result.</p>
",3
36229466,36228717,2,"<p>This should work with C++11 or greater. (if using g++ compile with <code>-std=c++11</code> flag).    </p>

<pre><code>#include &lt;map&gt;
#include &lt;functional&gt;
// ...

int evalRPN(vector&lt;string&gt;&amp; tokens) 
{
    // map of string -&gt; lambda
    std::map&lt;std::string, std::function&lt;int(int,int)&gt;&gt; ops;

    // fill the map 
    ops[""+""] = [](int a,int b) { return b+a; };
    ops[""-""] = [](int a,int b) { return b-a; };
    ops[""*""] = [](int a,int b) { return b*a; };
    ops[""/""] = [](int a,int b) { return b/a; };    

    int n = tokens.size();
    if (n == 0)
        return 0;

    stack&lt;int&gt; S;
    int a, b;
    for (int i = 0; i &lt; n; i++)
    {
        string tmp = tokens[i];
        // find the operator in map
        auto opit = ops.find(tmp);
        if ( opit != ops.end() ) {
            // if token is in map (ie. if it is operator)
            a = S.top(); S.pop();
            b = S.top(); S.pop();
            // get the function
            auto fn = opit-&gt;second;
            // and push it's result to stack
            S.push( fn(a,b) );
        } else {
            // if not operator push to stack
            S.push(stoi(tmp));
        }

    }
    return S.top();
}
</code></pre>
",0
39124823,39124737,1,"<p>When a C++ program crashes, it exits. The operating system cleans up any OS resources it may have asked for, which includes memory, but also other resources (file handles for example).</p>

<p>Thus, C++ does not clean up - the operating system does. What once was the C++ heap is returned to the operating system as free memory. </p>
",0
39124829,39124737,8,"<p>If the program crashes ""gracefully"" due to a handled exception, the stack unwinding will call the destructors on any smart pointers and free the memory. </p>

<p>For complete crashes (e.g. segmentation fault, call to <code>std::terminate()</code>), it is the operating system that will free any memory and resources held by the program.</p>
",0
40967834,40967797,0,"<p>You could use <a href=""http://en.cppreference.com/w/cpp/io/c/fprintf"" rel=""nofollow noreferrer"">std::sprintf</a> to format the string, e.g.</p>

<pre><code>for (int filenum=1; filenum&lt;=counter; filenum++) {
  char nambuf[64];
  std::snprintf(nambuf, sizeof(nambuf), ""./input/abc%02d.txt"", filenum);
  std::ifstream infile;
  infile.open(nambuf);
</code></pre>

<p>I recommend spending more time reading the <a href=""http://en.cppreference.com/w/cpp"" rel=""nofollow noreferrer"">documentation of C++</a> standard library.</p>
",0
40967941,40967797,0,"<p>You can use the <a href=""http://en.cppreference.com/w/cpp/io/manip/setw"" rel=""nofollow noreferrer""><code>std::setw</code></a> and <a href=""http://en.cppreference.com/w/cpp/io/manip/setfill"" rel=""nofollow noreferrer""><code>std::setfill</code></a> io manipulators to make sure your number is formatted to be at least two digits long:</p>

<pre><code>for(int file = 1; file &lt;= counter; file++) {
    std::ostringstream filename;
    filename &lt;&lt; ""./input/abc"" &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') &lt;&lt; file &lt;&lt; "".txt"";
    std::ifstream input(filename.str());
}
</code></pre>

<p>Here inserting <code>std::setw(2)</code> ensures that numbers are formatted to be at least two characters long, and <code>std::setfill('0')</code> fills out any missing characters with <code>'0'</code> when formatting the number.</p>
",0
40967991,40967797,1,"<p>This could be a dirty fix but you could add an additional condition to handle text files abc01 to abc09</p>

<pre><code> for(files=1;files&lt;=counter;files++)
  {   stringstream out;
      out&lt;&lt;files;
       if(files&lt;10){
       infile=""./input/abc0""+out.str()+"".txt"";
       }
       else
       infile=""./input/abc""+out.str()+"".txt"";
              input.open(infile.c_str());
  } 
</code></pre>
",1
41214943,41214902,4,"<p>No, it's not safe.</p>

<p>It's only work because you put a <code>int &gt;= 0</code>. <code>size_t</code> is <code>unsigned</code> so if you try to put negative value you will have <code>negative_value % 2**n</code> where n is the number of bits used to represent the unsigned type.</p>

<hr>

<p>The element in your vector are <code>size_t</code>. When you fill it with <code>i</code>, you ask to the compiler to cast a <code>int</code> into a <code>size_t</code>. This is not ""safe"".</p>

<hr>

<pre><code>vec[0] = 18446744073709551613;
</code></pre>

<p>And here this is safe because vec[0] is a <code>size_t</code>.</p>

<hr>

<p>Beware that <a href=""http://en.cppreference.com/w/cpp/types/size_t"" rel=""nofollow noreferrer""><code>size_t</code></a> is designed to handle... size. So the max value that can handle a <code>size_t</code> is not fixed. If you want stock integer. Use <a href=""http://en.cppreference.com/w/cpp/header/cstdint"" rel=""nofollow noreferrer""><code>&lt;cstdint&gt;</code></a>.</p>
",2
41214962,41214902,4,"<p>additionally to the answer by @Stargateur, the best portable bet is <code>intmax_t</code> and <code>uintmax_t</code>. They are guaranteed to be the biggest integer types available on the platform.</p>

<p>There might also be compiler specific extensions, such as <code>__int128_t</code>. <a href=""https://stackoverflow.com/a/34588884/4593721"">This answer</a> gives some information about 128 bit builtins in the gcc. Do note that <code>std::intmax_t</code> will stll be 64 bit.</p>
",2
41215016,41214902,4,"<p><code>vector&lt;size_t&gt;</code> means a vector whose entries are all <code>size_t</code>.  If you try to store a value that is not a <code>size_t</code>, it will be implicitly converted to <code>size_t</code> before being stored.  This could involve data loss if the original value was an integer outside the range of [<code>0</code>, <code>SIZE_MAX</code>].</p>

<p>Your question suggests that you imagine the vector is storing objects of various different types, but that does not happen.</p>

<p>Note: <code>size_t</code> typically represents the size of the largest possible allocatable unit. Perhaps it would be better to use a type that more reflects the source of values you are storing, e.g. <code>uint64_t</code>.</p>
",3
43924636,43924585,3,"<p>The difference here is that, for a <code>std::string</code>, those NULL characters don't affect its length; it can hold them just fine.</p>

<p>However, for a c-style string, <code>strlen</code> with stop counting when it encounters the first NULL character, which for you is the second character, hence a size of 1.</p>
",1
43924746,43924585,2,"<p>You told it you wanted 20 bytes, so that's exactly what you got.</p>

<p>It sounds like you want to copy <em>up to 20 bytes or until a null byte is encountered</em>:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;

int main()
{
    char a[20]{};

    a[0] = 'a';
    std::string b(a, a + strnlen(a, sizeof(a)));
    std::cout &lt;&lt; b.length() &lt;&lt; '\n';
    std::cout &lt;&lt; strlen(b.c_str()) &lt;&lt; '\n';
}
</code></pre>

<p>You'll notice I've gone back to having the computer detect the number of input bytes for us, but with <code>strnlen</code> you can tell it to stop at 20, taking care of the problem that the array <em>may</em> not be null-terminated. </p>

<p>I've also changed <code>{0}</code> to <code>{}</code>, for <a href=""https://stackoverflow.com/q/14797810/560648"">style/sanity reasons</a>.</p>

<h3>(<a href=""http://coliru.stacked-crooked.com/a/f3edbc1d12f955bd"" rel=""nofollow noreferrer"">live demo</a>)</h3>
",10
37345546,37335383,11,"<p>You cannot do things like that because the standard does not allow it. However since default arguments effectively just define new function overloads, you can get the desired effect by explicitly defining such an overload:</p>

<pre><code>void RateLimiter(unsigned int rateInPermitsPerSecond, 
                 unsigned int maxAccumulatedPermits);

inline void RateLimiter(unsigned int rateInPermitsPerSecond)
{ return RateLimiter(rateInPermitsPerSecond,rateInPermitsPerSecond); }
</code></pre>

<p>This shows that the standard forbidding this is half-hearted, as suggested by the language (""Consequently... shall not...""). They just did not want to go through the hassle of making this well defined with the same effect as what the explicit overload declaration would do: if desired, they could have specified that defaulted arguments are evaluated after explicitly provided ones, and from left to right. This would not have any influence on the rule that the evaluation order of argument expressions in a function call is unspecified (because default arguments do not correspond to such expressions; they are entirely separate and not even in the same lexical scope). On the other hand if (as they did) they preferred to disallow this, they could have just said ""shall not"" without need to justify themselves from some other rule (but maybe with explanatory footnote).</p>
",0
47984451,47984367,1,"<p>You could have an array of pointers that gets assembled at compile time:</p>

<p>file1.cpp:</p>

<pre><code>char const * str_f1 = ""hello"";
</code></pre>

<p>file2.cpp:</p>

<pre><code>char const * str_file2 = ""world"";
</code></pre>

<p>file3.cpp""</p>

<pre><code>extern char const * str_file1, * str_file2;
char const * strs[] { str_file1, str_file2 };
</code></pre>
",3
38017911,38017886,6,"<p><code>sizeof(arr)</code> will give the size of a pointer, not the allocated memory.</p>

<p>Try this to calculate the size to zero-clear:</p>

<pre><code>ll size = 2;
ll *arr = new ll[size];
memset(arr,0,sizeof(*arr) * size);
</code></pre>
",0
38017924,38017886,9,"<p>The problem is you use wrong size in memset call:</p>

<pre><code> memset(arr,0,sizeof(arr));
              ^^^^^^^^^^^ 
</code></pre>

<p><code>arr</code> is a pointer so <code>sizeof(arr)</code> is equal to 8 on 64-bit machine and 4 on 32-bit, what you want is:</p>

<pre><code>memset(arr,0,sizeof(ll) * size);
</code></pre>
",0
36228473,36228231,0,"<p>Instead of the <code>for</code> loop you could use <code>std::for_each</code>. Maybe something like:</p>

<pre><code>int maxvalue = std::numeric_limits&lt;int&gt;::min();
std::for_each(std::begin(B), std::end(B), [&amp;maxvalue](const auto&amp; v)
{
    maxvalue = std::max(maxvalue, *std::max_element(std::begin(v), std::end(b)));
});
</code></pre>
",0
36228587,36228231,0,"<p>If the thing you want to avoid using loops are long structures in your program, using <strong>C++11</strong> you can find the maximum in a single line <strong>with loops</strong>:</p>
<pre><code>std::vector&lt; std::vector&lt;int&gt; &gt; w;


int max = 0;
for (auto i : w) for (auto j : i) max = j &gt; max ? j : max;
</code></pre>
<p>Or</p>
<pre><code>int max = 0;
for (auto i : w) for (auto j : i) if (j &gt; max) max = j;
</code></pre>
<p>Anyway, I don't think this is a good practice. This option would be better:</p>
<pre><code>int max = 0;
for (auto i : w)
    for (auto j : i)
        max = j &gt; max ? j : max;
</code></pre>
",4
36228417,36228231,5,"<pre><code>auto max_value = std::accumulate(std::begin(B), std::end(B),
      std::numeric_limits&lt;int&gt;::min(), 
      [] (int cur_max, auto &amp;&amp; vec) 
      { 
        return std::max(cur_max, *std::max_element(std::begin(v), std::end(v));
      });
</code></pre>
",0
36228714,36228231,0,"<p>I used a custom comparison operator in <code>max_element()</code> to get the desired effect. No loops whatsoever, except the implied accumulation that <code>max_element()</code> runs.</p>

<pre><code>bool mycomp(vector&lt;int&gt; a, vector&lt;int&gt; b) {
  return *max_element(a.begin(), a.end()) &lt; *max_element(b.begin(), b.end());
}

vector&lt;vector&lt;int&gt;&gt; vv; // our vector of vectors

auto itv = max_element(vv.begin(), vv.end(), mycomp); // find the vector 
                                                     // with the max element

int answer = *max_element((*itv).begin(), (*itv).end()); // finds the max element 
                                                        // in the desired vector
</code></pre>

<p>This is by no means <em>clean</em>. But it does what it says it does.</p>
",6
43976953,43976324,-1,"<p>I think you should convert the values to be integers so the input will be supported. <code>(int)foo</code> is the simplest conversion, but it might be less than adequate for you. If it does not fulfill your needs, then you will need to write your own custom conversion. If this approach does not solve your problem, then you will need to modify the source-code of the library (by reverse-engineering if legal and necessary), or, if that's not an option, ask the author to use <code>fmod</code> in the library. Your idea is clever, but unfortunately that's not how things work.</p>
",0
39623215,39623137,1,"<p>From <a href=""https://stackoverflow.com/questions/7870648/multiple-postfix-increment-operator-in-an-expressionc"">this</a>:</p>
<p>Writing to the same variable twice without an intervening sequence point is undefined behaviour.  From the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf"" rel=""nofollow noreferrer"">spec</a>, <strong>J.2 Undefined behaviour</strong>:</p>
<blockquote>
<p>Between two sequence points, an object is modified more than once, or is modified and the prior value is read other than to determine the value to be stored (6.5).</p>
</blockquote>
<p>The reference is to <strong>6.5 Expressions</strong>, paragraph 5:</p>
<blockquote>
<p>Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, the prior value shall be read only to determine the value to be stored.</p>
</blockquote>
<p>Annex C of the C spec has a handy list of all of the sequence points:</p>
<blockquote>
<p>The following are the sequence points described in 5.1.2.3:</p>
<ul>
<li>The call to a function, after the arguments have been evaluated (6.5.2.2).</li>
<li>The end of the first operand of the following operators: logical AND <strong><code>&amp;&amp;</code></strong> (6.5.13); logical OR <strong><code>||</code></strong> (6.5.14); conditional <strong><code>?</code></strong> (6.5.15); comma <strong><code>,</code></strong> (6.5.17).</li>
<li>The end of a full declarator: declarators (6.7.5);</li>
<li>The end of a full expression: an initializer (6.7.8); the expression in an expression statement (6.8.3); the controlling expression of a selection statement (<strong><code>if</code></strong> or <strong><code>switch</code></strong>) (6.8.4); the controlling expression of a <strong><code>while</code></strong> or <strong><code>do</code></strong> statement (6.8.5); each of the expressions of a <strong><code>for</code></strong> statement (6.8.5.3); the expression in a <strong><code>return</code></strong> statement (6.8.6.4).</li>
<li>Immediately before a library function returns (7.1.4).</li>
<li>After the actions associated with each formatted input/output function conversion specifier (7.19.6, 7.24.2).</li>
<li>Immediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any movement of the objects passed as arguments to that call (7.20.5).</li>
</ul>
</blockquote>
",0
41214675,41214641,1,"<p>The last character of a string is at index <code>len - 1</code>, not <code>len</code>. As per the standard (C++11):</p>

<blockquote>
  <p>Returns <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>. Otherwise, returns a reference to an object of type charT with value charT(), where modifying the object leads to undefined behavior.</p>
</blockquote>

<p>What that standardese actually means is that, if <code>pos</code> is not less than the string length, the function returns a reference to a null character. Hence the first character you're putting <em>into</em> your reversed string is the null.</p>

<p>However, you don't really need to reverse the string to find if it's a palindrome, it might be easier to simply use the following (pseudo-code) algorithm:</p>

<pre><code>def isPalindrome(string):
    set left to zero
    set right to one less than string length
    while left is less than right:
        if string[left] is not equal to string[right]:
            return false
        add one to left
        subtract one from right
    return true
</code></pre>

<p>Given you have to process every character to form the reversed string anyway, you may as well use that processing power to just check the characters in the original string. That way, you can exit early if it's not a palindrome.</p>

<p>This will, of course, consider an empty string to be a palindrome, which is arguably correct. If you <em>don't</em> think that's correct, simply put a check in up front:</p>

<pre><code>def isPalindrome(string):
    if string length is zero:
        return false
    set left to zero
    ... and so on
</code></pre>
",5
43748389,43748077,1,"<p>Loki has a pimpl helper:</p>

<p><a href=""http://loki-lib.sourceforge.net/index.php?n=Idioms.Pimpl"" rel=""nofollow noreferrer"">http://loki-lib.sourceforge.net/index.php?n=Idioms.Pimpl</a></p>

<p>But it mostly helps with the pointer management, copy-construction etc. pp. if I remember correctly.
The tedious part is still up to you.</p>
",1
35231891,35231805,6,"<blockquote>
  <p>As I understand it, we are allocating memory from the heap to store
  <code>*p</code>.</p>
</blockquote>

<p>More correctly worded, the object created by <code>new</code> has <strong>dynamic storage duration</strong>.</p>

<blockquote>
  <p>If not from the heap, where does the memory for <code>C</code> come from?</p>
</blockquote>

<p>It has <strong>automatic storage duration</strong>.</p>

<p>See C++ standard ¡ì3.7/1.</p>

<p>Talking about ""stack"" or ""heap"" takes you on the compiler-implementation level. You are generally not interested in how the C++ compiler makes the different kinds of storage duration work but are only interested in their semantics.</p>
",3
35231824,35231805,4,"<blockquote>
  <p>Question: If not from the heap, where does the memory for C come from?</p>
</blockquote>

<p>From the stack (or in the case of a global variable or function 'static' variable, from a statically allocated region that exists independently of both the heap and the stack).</p>

<p>Strictly speaking, C++ has no concept of heap or stack (other than as data structures in the standard library, which are fundamentally different to ""the"" heap and stack that are the prevalent mechanisms used for allocation of memory by running programs); the exact mechanism for allocation and management of memory is not specified. In practice, there are two ways for a program to allocate memory at run time on most systems: from the heap (which is itself built on memory chunks obtained from the operating system), or from the stack (the same stack that is used to store the return address and save temporary values when functions are called).</p>

<p>Memory for the stack is usually allocated when (or just before) the program begins execution, and it usually needs to be contiguous. Memory for the heap is usually obtained dynamically and does not normally need to be contiguous (though in practice heap memory is often allocated in contiguous chunks).</p>

<p>Note that your first example:</p>

<pre><code>ClassName* p;
p = new ClassName;
</code></pre>

<p>... actually embodies two allocations: one for the <code>ClassName</code> object (dynamic storage, allocated on the heap) and one for the pointer variable <code>p</code> (automatic storage, allocated on the heap).</p>

<p>In practice, local variables will not always require stack allocation - their values can sometimes be kept in registers (or in some cases, the storage can be optimised away altogether, especially if the value is unused or is a compile-time constant). And theoretically, heap allocations can also potentially be optimised away.</p>
",8
41905574,41905539,2,"<p>The two subtractions are calculating the offset of the elements found at the positions <code>low</code> and <code>up</code> in the vector by calculating the delta between the iterator <code>v.begin()</code> and the iterators <code>low</code> and <code>up</code>, respectively. To make this code clearer, it probably would have been better to use <a href=""http://en.cppreference.com/w/cpp/iterator/distance"" rel=""nofollow noreferrer"">std::distance</a>.</p>

<p>When you tried to use <code>cout &lt;&lt; low &lt;&lt; endl;</code> you were trying to print out the value of the iterator. That's very different. Oh, and you're missing the std:: namespace reference around <code>cout</code> and <code>endl</code>.</p>
",1
41905926,41905539,3,"<p>*low *is an iterator as you declared. It holds the memory address that generates by your PC and you don't need any memory address to return . By writing </p>

<pre><code>low- v.begin()
</code></pre>

<p>You make a command to your program to return the actual position of your searching query as an answer. </p>

<p>That's why it returns a value the </p>

<pre><code>Address Position - Beginning of the Vector Position 
</code></pre>

<p>Suppose your vector starting memory address is FFF1 and your searching value is at FFF8 ... Then it return FFF8 - FFF1 = 7 .. ( Example is just to illustrate )</p>

<p>That's how I understand .</p>
",1
41223484,41222105,2,"<p>The object you would need to pass in this scenario is a <em>pointer to member function</em>:</p>

<pre><code>class Obj {
  // ...

  double getA() {
    return a;
  }

  double getB() {
    return b;
  }

private:
  double a;
  double b;
};

class Container {
  // ...
  get(int i, double (Obj::*what)()) { return (m_objs[i].*what)(); }
};

class User {
  Container m_cont;
  // ...
  get(int i, double (Obj::*what)()) { return m_cont.get(i, what); }
};

// ...
double myA = user.get(1, &amp;Obj::getA);
</code></pre>

<p>You can also add this to <code>Obj</code>:</p>

<pre><code>double get(double (Obj::*what)()) {
  return (this-&gt;*what)();
}
</code></pre>

<p>to make <code>Container</code> more consistent with <code>User</code>:</p>

<pre><code>class Container {
  // ...
  get(int i, double (Obj::*what)()) { return m_objs[i].get(what); }
};
</code></pre>
",0
43197215,43197078,3,"<p>==new update==</p>

<p>Use a (max) heap of std::pairs of value and timestamp. In c++11 the heap I'm discussing is a std::priority_queue. if you make the value type (and not the timestamp type) the first element of your pair (i.e. </p>

<pre><code>std::pair&lt;val_t,time_t&gt; 
</code></pre>

<p>and not </p>

<pre><code>std::pair&lt;time_t,val_t&gt;
</code></pre>

<p>), then you don't even need a custom comparator because std::pair comparison will give you the behavior you want by default (prioritizes comparing pair.first and only looks at pair.second when equal, uses std::less by default -> gives you max heap of pairs w.r.t. first value type).</p>

<p>Insert/push all the new values into the (max) heap. The largest value will always be on top. when polling, check the top sample's timestamp (sample.second) against now() minus the recency window age. if its too old, throw it out. certain value sequences can cause the heap to hide stale values underneath the max. when the heap exceeds a certain size threshold, empty it into a new one whilst filtering out the expired values. this should happen very infrequently proportional to the arrival rate of new samples as related to recency window size.</p>

<p>thanks to @chrise for suggesting an amendment to a good idea that I prematurely threw out</p>

<p>==previous update==</p>

<p>My original response answered only part of the question. I suggested using a max_heap (std::priority_queue, uses std::less by default -> max heap) to maintain the max value. this does not account for the recency maintenance. you have two separate concerns, searching for max and conditional membership. changing the rules for membership (the expiry criterion) on an existing heap will invalidate the heap and give you runtime errors that are hard to root cause.</p>

<p>instead you could use a list of pairs (or deque, probably better but I did examples with std::list) along with remove_if and a predicate that keeps track of the max value. this can be done two ways, by using lambdas, or by creating a functor class. using lambdas looks like this:</p>

<pre><code>using sample = std::pair&lt;unsigned,double&gt;;
sample a{ 1,12.2 };
sample b{ 2,11.778 };
sample c{ 3,9.2 };
sample d{ 4,-2.6 };
sample e{ 5,10.1 };

std::list&lt;sample&gt; samples{ d,c,b,a };
cout &lt;&lt; ""list is: "" &lt;&lt; samples &lt;&lt; endl &lt;&lt; endl;
double maxval = -std::numeric_limits&lt;double&gt;::infinity();
unsigned cutoff = now() - timerange;
samples.remove_if([&amp;maxval,cutoff](sample s) 
{
    //if older than cutoff, remove
    if (s.first &lt; cutoff) return true;
    //otherwise, keep and update max
    maxval = std::max(maxval, s.second);
    return false;
});
cout &lt;&lt; ""max is: "" &lt;&lt; maxval &lt;&lt; "", list is: "" &lt;&lt; samples &lt;&lt; endl &lt;&lt; endl;
</code></pre>

<p>see <a href=""http://ideone.com/O6UJPW"" rel=""nofollow noreferrer"">http://ideone.com/O6UJPW</a> for full example.</p>

<p>and using a functor class looks like this:</p>

<pre><code>using sample = std::pair&lt;unsigned,double&gt;;
sample a{ 1,12.2 };
sample b{ 2,11.778 };
sample c{ 3,9.2 };
sample d{ 4,-2.6 };
sample e{ 5,10.1 };

std::list&lt;sample&gt; samples{ d,c,b,a };
cout &lt;&lt; ""original list is: "" &lt;&lt; samples &lt;&lt; endl;

double maxval(-std::numeric_limits&lt;double&gt;::infinity());
//eliminate samples older than 2
using pred = PredRetainMax&lt;sample&gt;;
samples.remove_if(pred(now() - timerange, maxval));
cout &lt;&lt; ""max is: "" &lt;&lt; maxval &lt;&lt; "", list is: "" &lt;&lt; samples &lt;&lt; endl &lt;&lt; endl;
</code></pre>

<p>where predicate looks like this</p>

<pre><code>template&lt;class T&gt;
struct PredRetainMax;

template&lt;class Time, class Val&gt;
struct PredRetainMax&lt;std::pair&lt;Time, Val&gt;&gt;
{
    PredRetainMax(Time cutoff, Val&amp; m) :_cutoff(cutoff), _max(m) {}
    bool operator()(const std::pair&lt;Time, Val&gt;&amp; s)
    {
        //if older than cutoff, remove
        if (s.first &lt; _cutoff) return true;
        //otherwise, keep and update max
        _max = std::max(_max, s.second);
        return false;
    }
    Val get() { return _max; }
private:
    Time _cutoff;
    Val&amp; _max;
};
</code></pre>

<p>see <a href=""http://ideone.com/qs153j"" rel=""nofollow noreferrer"">http://ideone.com/qs153j</a> for full example</p>

<p>the functor is instantiated with a reference to the external maxval because the stl takes the remove_if predicate as a copy, so this is kind of a hack to keep track of the maxval.</p>

<p>==original response below==</p>

<p>Use a heap. In c++11 it is called a std::priority_queue. Insert/push all the new values into the (max) heap. The largest value will always be on top. </p>

<p>See <a href=""http://en.cppreference.com/w/cpp/container/priority_queue"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/container/priority_queue</a>
For some helpful usage examples</p>
",11
43198226,43197078,0,"<p>Just keep two copies of the data:</p>

<ul>
<li><code>std::deque&lt; std::pair&lt;timestamp, double&gt; &gt;</code></li>
<li><code>std::multiset&lt;double&gt;</code></li>
</ul>

<p>When a new value arrives:</p>

<ol>
<li><p>Add it to <strong>both</strong> containers</p></li>
<li><p>Purge out-of-date values, by examining the front of the deque.</p>

<p>a. If the first value of the deque is too old (expired), remove it from <strong>both</strong> containers.</p>

<p>b. Repeat until the first value in the deque is not an expired value.</p></li>
<li><p>The max value is at the end (a.k.a. <code>rbegin()</code>) of the multiset.</p></li>
</ol>

<p><strong>Performance notes:</strong></p>

<p>Multiset insertions and deletions are O(log(N)) and <code>rbegin()</code> is O(1).  If performance is really a concern and you don't mind using boost, consider using <code>boost::container::flat_multiset</code>, which is a drop-in replacement for <code>std::multiset</code>, but much faster (unless your data is huge).</p>
",4
43198693,43197078,3,"<p>If the data is small enough that it will easily fit in your CPU cache (say, 1 million <code>float</code> values), then we're all over-thinking this.</p>

<p>Just store a <code>std::deque&lt; std::pair&lt;float, timestamp&gt; &gt;</code>.</p>

<ul>
<li>When a new value comes in, use <code>push_back()</code>.</li>
<li>When you need to query the max element, call <code>pop_front()</code> until all expired values have been purged. Then just call <code>std::max_element()</code> on the whole deque.</li>
</ul>

<p>If there are no cache misses, it will have the same (or better) performance as more elaborate solutions involving <code>priority_queue</code> and <code>multiset</code>, etc.</p>
",1
47698592,47698476,29,"<p>Regarding conversions of integers, C 2011 [draft N1570] 6.3.1.3 2 says</p>

<blockquote>
  <p>Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.</p>
</blockquote>

<p>Thus, converting -1 to an unsigned integer type necessarily produces the maximum value of that type.</p>

<p>There may be issues with using <code>-1</code> in various contexts where it is not immediately converted to the desired type. If it is immediately converted to the desired unsigned integer type, as by assignment or explicit conversion, then the result is clear. However, if it is a part of an expression, its type is <code>int</code>, and it behaves like an <code>int</code> until converted. In contrast, <code>UINT_MAX</code> has the type <code>unsigned int</code>, so it behaves like an <code>unsigned int</code>.</p>

<p>As <a href=""https://stackoverflow.com/users/2410359/chux"">chux</a> points out in a comment, <code>USHRT_MAX</code> effectively has a type of <code>int</code>, so even the named limits are not fully safe from type issues.</p>
",4
47699111,47698476,8,"<p>The C++ standard says this about <code>signed</code> to <code>unsigned</code> conversions (<a href=""http://eel.is/c++draft/conv.integral#2"" rel=""nofollow noreferrer"">[conv.integral]/2</a>):</p>

<blockquote>
  <p>If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 
  2<sup>n</sup> where <em>n</em> is the number of bits used to represent the unsigned type). [?<em>Note:</em> In a two's complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). ¡ª?<em>end note</em>?]</p>
</blockquote>

<p>So yes, converting <strong>-1</strong> to an <em>n</em>-bit unsigned integer will always give you <strong>2<sup><em>n</em></sup>-1</strong>, regardless of which signed integer type the -1 started as.</p>

<p>Whether or not <code>unsigned x = -1;</code> is more or less readable than <code>unsigned x = UINT_MAX;</code> though is another discussion (there's definitely the chance that it'll raise <em>some</em> eyebrows, maybe even your own when you look at your own code later;).</p>
",1
47699866,47698476,9,"<p>The technical side has been covered by other answers; and while you focus on technical correctness in your question, pointing out the cleanness aspect again is important, because imo that¡¯s the much more important point.</p>

<p>The <strong>major reason</strong> why it is a <strong>bad idea</strong> to use that particular trickery is: <strong>The code is ambiguous.</strong> It is unclear whether someone used the unsigned trickery intentionally or made a mistake and actually wanted to initialize a signed variable to -1. Should your colleague mention a comment after you present this argument, tell him to stop being silly. :)</p>

<p>I¡¯m actually slightly baffled that someone would even consider this trick in earnest. There¡¯s an unambigous, intuitive and idiomatic way to set a value to its max in C: the _MAX macros. And there¡¯s an additional, equally unambigous, intuitive and idiomatic way in C++ that provides some more type safety: numeric_limits. That -1 trick is a classic case of being clever.</p>
",5
47700594,47698476,16,"<blockquote>
  <p>Is <code>-1</code> correct for using as maximum value of an unsigned integer?</p>
</blockquote>

<p>Yes, it is functionally correct when used as a direct assignment/initialization.  Yet often looks questionable <a href=""https://stackoverflow.com/questions/47698476/is-1-correct-for-using-as-maximum-value-of-an-unsigned-integer/47699866?noredirect=1#comment82356829_47698476"">@Ron</a>.</p>

<p>Constants from <code>limits.h</code> or <code>std::numeric_limits</code> convey more code understanding, yet need maintenance should the type of <code>i</code> change.</p>

<hr>

<p>[Note] OP later drop the <kbd>C</kbd> tag.</p>

<p>To add an alternative to assigning a maximum value (available in C11) that helps reduce code maintenance:</p>

<p>Use the loved/hated <code>_Generic</code></p>

<pre><code>#define info_max(X) _Generic((X), \
  long double: LDBL_MAX, \
  double: DBL_MAX, \
  float: FLT_MAX, \
  unsigned long long: ULLONG_MAX, \
  long long: LLONG_MAX, \
  unsigned long: ULONG_MAX, \
  long: LONG_MAX, \
  unsigned: UINT_MAX, \
  int: INT_MAX, \
  unsigned short: USHRT_MAX, \
  short: SHRT_MAX, \
  unsigned char: UCHAR_MAX, \
  signed char: SCHAR_MAX, \
  char: CHAR_MAX, \
  _Bool: 1, \
  default: 1/0 \
  )

int main() {
  ...
  some_basic_type i = info_max(i);
  ...
}
</code></pre>

<p>The above macro <code>info_max()</code> have limitations concerning types like <code>size_t</code>, <code>intmax_t</code>, etc. that may not be enumerated in the above list.  There are more complex macros that can cope with that.   The idea here is illustrative.</p>
",10
47701114,47698476,18,"<p>Not using the standard way or not clearly showing the intent <strong>is often a bad idea that we pay later</strong></p>

<p>I would suggest:</p>

<pre><code>auto i = std::numeric_limits&lt;unsigned int&gt;::max(); 
</code></pre>

<blockquote>
  <p>or @jamesdin suggested a certainly better one, closer to the C
  habits: </p>

<pre><code>unsigned int i = std::numeric_limits&lt;decltype(i)&gt;::max(); 
</code></pre>
</blockquote>

<p>Your colleague argument is not admissible. Changing <code>int</code> -> <code>long int</code>, as bellow:</p>

<pre><code>auto i = std::numeric_limits&lt;unsigned long int&gt;::max(); 
</code></pre>

<ul>
<li>does not require extra work compared to the <code>-1</code> solution (thanks to the use of <code>auto</code>).</li>
<li>the '-1' solution does not directly reflect our intent, hence it possibly has harmful consequences. Consider this code snippet:</li>
</ul>

<p>.</p>

<pre><code>using index_t = unsigned int;

... now in another file (or far away from the previous line) ...

const index_t max_index = -1;
</code></pre>

<p>First, we do not understand why <code>max_index</code> is <code>-1</code>.
Worst, if someone wants to improve the code and define </p>

<pre><code> using index_t = ptrdiff_t;
</code></pre>

<p><em>=> then the statement <code>max_index=-1</code> is not the <code>max</code> anymore</em> and you get <em>a buggy code</em>. Again this can not happen with something like:</p>

<pre><code>const index_t max_index = std::numeric_limits&lt;index_t&gt;::max();
</code></pre>

<hr>

<p><strong>CAVEAT:</strong> nevertheless there is a caveat when using <code>std::numeric_limits</code>. It has nothing to do with integers, but is related to <strong>floating point numbers</strong>.</p>

<pre><code>std::cout &lt;&lt; ""\ndouble lowest: ""
          &lt;&lt; std::numeric_limits&lt;double&gt;::lowest()
          &lt;&lt; ""\ndouble min   : ""
          &lt;&lt; std::numeric_limits&lt;double&gt;::min() &lt;&lt; '\n';
</code></pre>

<p>prints:</p>

<pre><code>double lowest: -1.79769e+308    
double min   :  2.22507e-308  &lt;-- maybe you expected -1.79769e+308 here!
</code></pre>

<ul>
<li><code>min</code> returns the smallest finite value of the given type</li>
<li><code>lowest</code> returns the lowest finite value of the given type </li>
</ul>

<p>Always interesting to remember that, as it can be a source of bug if we do not pay attention to (using <code>min</code> instead of <code>lowest</code>). </p>
",5
45282400,45282334,5,"<p>What you usually do in that case is expose a public static method that returns a new object:</p>

<pre><code>struct zippy
{
    static zippy mathematics(int b);
    const int a;
    const int b;
    zippy(int z, int q) : a(z), b(q) {};
};

zippy zippy::mathematics(int b)
{
    int r = b + 5;
    //imagine a bunch of complicated math here
    return zippy(b, r);
}
</code></pre>

<p>The naming is off here but you get the idea.</p>

<p>Which can be called without needing an instance of <code>zippy</code> and create a new <code>zippy</code> object:</p>

<pre><code>zippy newZippy = zippy::mathematics(42);
</code></pre>
",1
35191282,35191252,0,"<p>Well, you misquoted it. It's <code>*(new int)</code> and it means the same as any other <code>*&lt;some pointer here&gt;</code> &mdash; it dereferences the pointer.</p>

<p>It's the same as this:</p>

<pre><code>int* x = new int;
int&amp; ref = *x;
</code></pre>

<p>with <code>*x</code> of course being the expression that refers to the dynamically-allocated <code>int</code> object. Thing is, your way you don't have a variable name <code>x</code> to play with and now must write <code>delete &amp;ref</code> at some point, which is just kinda weird.</p>

<p>Avoid.</p>
",0
35191311,35191252,0,"<p>I mean, technically it's not a bright idea, but of course you can later fix the mess like</p>

<pre><code>int &amp;val = *(new int);
val = 5;
delete &amp;val;
</code></pre>

<p>If it was a class... and you dont want to use the -> operator, you could of course use this trick, as long as you remember to delete &val;, because after all, you have allocated something and needs proper clean up.</p>
",5
38859871,38859750,5,"<p>If you want to be sure that your class constructor takes only valid pointer, change signature to use the reference:</p>

<pre><code>class defice_123 {
public:
  defice_123(data_struct_t&amp; initData) : foo(initData.foo), boo(initData.boo) {
  }
...
};
</code></pre>
",0
38860195,38859750,2,"<p>As answered above you can enforce a signature in your constructor.</p>

<p>There are also alternatives:</p>

<ol>
<li>when something goes wrong in constructor, throw exception</li>
<li>do bare minimum things in constructor (zero variables) and move complex stuff to an initialization function, which you have flexibility to return more details upon failure.</li>
</ol>
",0
38861492,38859750,0,"<p>We're talking best practice here so I'm taking a hard line. There are always exceptions, but exceptions are exceptions, not best practice. </p>

<p>Best practices says don't allocate an object until you have the information you need to initialize an object. This is bundled in as part of <a href=""https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"" rel=""nofollow"">Resource Allocation Is Initialization</a> or RAII. </p>

<p>With RAII, when you construct an object it must come out of the constructor complete, valid and ready to use. If an object cannot be fully and properly initialized, it should be junked, discarded, obliterated, or otherwise disposed of so that there is absolutely no confusion about the state of the object. The object is either good and ready to use or does not exist.</p>

<p>If you do not have enough information to make the object valid, you are instantiating the object too early. If while constructing the object the input is such that the object cannot be valid, you clean up, throw an exception and the object is returned to whence it came. The creator does not get an invalid object. Ever.</p>

<p>RAII saves you from continually having to check something like <code>object.isvalid()</code> before using an object. You have an object, it's a good object. If the object wraps a resource, then that resource is available and accessible the instant you need it. You don't have to worry about trivial errors like opening a file that's not there. If you have an object, that file is open and ready for access. </p>

<p>As an added bonus, when properly observed RAII guarantees the resource is freed when the object goes out of scope. Static allocation (often the stack) and <a href=""http://en.cppreference.com/w/cpp/memory"" rel=""nofollow"">Smart pointers are your friend</a>. </p>

<p>This requires fairly mature exception use as you won't be getting a returned error code, so the exception thrown needs to make sense for the type of error  or contain an informative <code>what</code> string and be handled efficiently. Failure due to routine events may need to be trapped before constructing to avoid wasting time in the exception handler if performance is critical.</p>
",0
47988646,47988193,37,"<p>The issue is the C++ object model, which differs from Python's. To contrast, first let's answer: what does Python store in the exception object to print the key? It's a reference that keeps that object alive.</p>

<p>This cannot be done simply in C++.</p>

<ol>
<li><p><code>std::out_of_range</code> can't store a pointer or reference to the key as is. The handler for the exception may be in far away block. And that means that the key most probably went out of scope before the handler is entered. We get undefined behavior if the key is referred to.</p></li>
<li><p><code>std::out_of_range</code> is a concrete class. Not a template like <code>std::map</code>. It can't easily copy the key into itself. There are many different <code>Key</code> types, and it obviously can't account for all of them. Even if it could, what if the key is extremely expensive to copy? Or even non-copyable at all? Even in cases where that's not true, what if the key isn't convertible to a string, or printable?</p></li>
</ol>

<p>The above points don't mean it's impossible. <code>std::map::at</code> can throw a sub-class of <code>std::out_of_range</code> that does type erasure and so forth. But I hope you see it has non-trivial overhead. C++ is all about not paying in performance for features you don't need or use. Making everyone bear that overhead unconditionally isn't in line with this design.</p>
",0
47996661,47988193,3,"<p>C++ standard specifies that <code>map::at(const key_type&amp; k)</code> will launch a <code>std::out_of_range</code> exception (if value is not inside it); nothing more... but nothing less; a particular implementation of <code>map::at()</code> but the problem would be that the k's key_type have to be converted to char*.
So there are several options:</p>

<ol>
<li>Do not show this information</li>
<li><code>std::map</code> does not store types without (at least implicit) conversion to char*: but there would be a requirement applied to the key_store type that is not strict necessary</li>
<li>To provide different messages in <code>std::out_of_range</code> exception depending on the key_type: but this solution does not always show the expected information</li>
</ol>

<p>In other point of view, <code>std::out_of_range</code> inherits from <code>std::logic_error</code>; C++ standard distinguishes between two main types of exceptions:</p>

<ul>
<li>logic_error: they are due to errors in the internal logic of the
program. In theory, they are preventable.</li>
<li>runtime_error: they are due to events beyond the scope of the program. They cannot be easily predicted in advance.</li>
</ul>

<p>In our case, we can check the existence of an element easily (so our case fixes with this case)</p>
",0
48012376,47988193,0,"<p>With C++,  it is possible to create a  personalized exception inheriting from std::exception with extra info, like filename. Here is an example :</p>

<pre><code>#include &lt;sstream&gt;

class MyException : public std::exception {
  public :
  MyException (std::exception e, std::string filename = """") : std::exception (e), str_ (filename) {}
  MyException (const MyException&amp; e) : std::exception (e), str_ (e.str_) {}
  const char* what () const throw () {
    std::ostringstream oss;
    oss &lt;&lt; ""exception occured in "" &lt;&lt; str_ &lt;&lt; "" : "";
    oss &lt;&lt; std::exception::what ();
    return oss.str ().c_str ();
  }
  std::string str_;
};

int main(int argc, char** argv) {
    try {
      try {
          std::map&lt;std::string, int&gt; m{{""a"", 1}, {""b"", 2}};
          std::cout &lt;&lt; m.at(""c"") &lt;&lt; std::endl;
      }
      catch (const std::exception&amp; e) {
          MyException f (e, ""main"");
          throw (f);
      }
    }
    catch (const MyException&amp; e) {
      std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>

<p>will display :</p>

<pre><code>exception occured in main : std::exception
</code></pre>
",0
34937318,34937267,3,"<p>Because your char array isn't null-terminated and is therefore not a string. If you omit the size altogether and specify the value as a string, not individual chars, the compiler will null-terminate it for you.</p>
",0
34937346,34937267,0,"<p>Read <a href=""http://www.cplusplus.com/reference/string/basic_string/operator+/"" rel=""nofollow"">the standard library</a> which requires the C string when used with operator+ to be null terminated: ""If of type charT*, it shall point to a null-terminated character sequence.""  Yours is not null terminated.  Try adding an extra element at the end of the char array that is 0.</p>
",0
34937347,34937267,0,"<p>Your char array is not 0 terminated, but plain c-strings must be 0 terminated:</p>

<pre><code>    char someCharArray[7] = {'H', 'e', 'l', 'l', 'o', ' ', 0};
</code></pre>

<p>This should work.</p>
",3
39630970,39630754,1,"<p>In your main.cpp,</p>

<p>Notice how you have include book.h
Compiler will not look for book.h in local directory and couldn't find definition of book in standard lib location.</p>

<p>Instead of 
<code>#include &lt;book.h&gt;</code> use <code>#include""book.h""</code></p>

<p><strong>Adding further.</strong></p>

<p>You haven't defined below method in book.cpp and from main function you are trying to access them. Reason for all your pain.</p>

<pre><code>Order getBest( double, bool );
double getBestPrice( bool );
</code></pre>
",1
39631071,39630754,0,"<p>You should do the following (provided you run compiler and linker manually):</p>

<ol>
<li>Compile <code>main.cpp</code></li>
<li>Compile <code>book.cpp</code></li>
<li>Link <strong>both files</strong> into a single executable</li>
</ol>

<p>All of above can be done in one command if your compiler allows it. </p>

<p>Since I'm not familiar with MSVC compiler, I'll show how I would do this with gcc:</p>

<pre><code>gcc -c -o main.o main.cpp # Compiles main.cpp into main.o
gcc -c -o book.o book.cpp # Compiles book.cpp into book.o
gcc -o my_app main.o book.o # Creates the my_app executable from main.o and book.o
</code></pre>

<p>or</p>

<pre><code>gcc -o my_app main.cpp book.cpp # Does all of above in one command
</code></pre>
",0
37633889,37633840,1,"<p>Basically, getter and setters are used to hide complexity, or better saying, to abstract details from out of a class. So they are not mandatory for using inside a class.</p>

<p>Simply I can say, if you don't have a getter, you don't need to make that, for using inside of the class.
But if you have a getter, you should always use that, whether inside or outside of the class, as you might have applied some logic to the raw value inside getter.</p>
",2
37633945,37633840,1,"<p>Inside the class always use the attribute itself. The reason you have a getter is to make a certain value available to other classes. Be careful with automatically making getters for every attribute you use. It is considered bad design to expose the inner workings of a class. Sometimes it makes sense to make an attribute available, sometimes it is just for internal use and other classes have no business inspecting them.</p>

<p>If you like to know more about this google ""getters setters evil"" Some of the articles you may find are quite extreme but they will explain why they feel that way.</p>
",6
37634107,37633840,1,"<p>I disagree with @user3535256. Getters and setters should also be used inside private class functions. The idea behind getters and setters is to make code changes nice and easy. @StanE think of a situation where you're using your class member variable without getter functions and after some time you'd like to change the name to be more meaningful. This example forces you to change the member name in each place it's used. In case of using getter method for your variable only class getter function will be affected by this code change. </p>
",5
37634330,37633840,0,"<p>This depends on the internals of your class. Suppose you have a simple class that holds a value and you want to count how often that value was accessed but there are different getter methods (I have to admit it is a quite contrived example). Instead of doing the bookkeeping in each of the methods it is easier to do it only once and use the getter also inside the class:</p>

<pre><code>class CountedValue{
    private:
        int value;
        int counter;
    public:
        CountedValue() : value(0),counter(0) {}
        int getValue() const {
            counter++; 
            return value; 
        }
        int getMinusValue() const { 
            return - getValue(); 
        }
        // ... possibly more methods to retrieve the value
        int getCounter() const { return counter;}
}
</code></pre>

<p>Actually with setters the benefit of using them also inside the class becomes more evident. You usually want to do bookkeeping and define the invariants of a member only once and not each time it can change. 
For example:</p>

<pre><code>class Rational {
    private:
        int numerator;
        int denominator;
    public:
        void setNumerator(int n) { numerator = n; }
        void setDenominator(int d) {
            assert(d != 0 &amp;&amp; ""division by zero"");
            denominator = d;
        }
        void set(int n, int d) {
            setNumerator(n);
            setDenominator(n);  // no need to check for 0 again
        }
  }
</code></pre>
",4
37634335,37633840,2,"<p>It depends. Getters may have synchronization and if called from a method that is already holding the lock may deadlock the application. Or, on the contrary, getters may count/log access to the resource. Or even, the class may be an interface on the byte buffer and getters/setters dynamically unmarshal/marshal the wire data, in which case calling getters and setters is unavoidable.</p>

<p>The only universal rule - be consistent across the code base and try to not overcomplicate the design.</p>
",0
36558287,22542311,0,"<p>Vector is just like an array except that it can grow dynamically. </p>

<p>push_back is a method that adds at the end of the container. If you create a vector like vector a(10) and then do a push_back you are inserting at the 11th place since all the first 10 places are initialized with 0. So, to be helpful it is ideal to create a vector like vector a, without any size, and then using push_back to insert at the end. </p>

<p>vector a;<br>
a.push_back(5);</p>
",0
40577266,40577177,4,"<p>You are doing integer divisions in the line:</p>

<pre><code>p1.x = sqrt(1 / 8);
</code></pre>

<p>1/8 is 0 in C++</p>

<p>This is true in all other initialization.</p>

<p>Try writing </p>

<pre><code>p1.x = sqrt(1.0 / 8.0);
</code></pre>
",0
40577396,40577177,0,"<p>at first you must declare in main p1 and p2 and p3 and initialize them then pass them to plane's constructor:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
#include &lt;cmath&gt;

struct Vector3
{
    double x;
    double y;
    double z;
};


class Plane 
{
    Vector3 point, normal, p_p1, p_p2, p_p3;
public:
    Plane(Vector3 p1,
        Vector3 p2, Vector3 p3) : p_p1(p1), p_p2(p2), p_p3(p3){}
    double distance_to(const Vector3&amp; p)const;
};

double Plane:: distance_to(const Vector3&amp; p)const
{
    return get_hnf_d() + dot_product(p, get_normal()) ;
}

int main()
{
    Vector3 p1 = {sqrt(1.0 / 8.0), sqrt(1.0 / 8.0), sqrt(3.0 / 4.0)};
    // do the same thing as above
    Vector3 p2, p3;

    Plane _plane(p1, p2, p3);
    cout &lt;&lt; ""Distance to p1 is : "" &lt;&lt; _plane.distance_to(p1) &lt;&lt; endl;



    return 0;
}
</code></pre>

<p>this is just a sample not full code</p>
",0
42518312,42517963,5,"<p>Because the standard says so. From the N3936:</p>

<blockquote>
  <p>5.3.1 Unary operators</p>
  
  <ol start=""4"">
  <li><strong>A pointer to member is only formed when an explicit &amp; is used and its  operand is a qualified-id not enclosed in parentheses</strong>. [ Note:
  that is, the expression &amp;(qualified-id), where the qualified-id is
  enclosed in parentheses, does not form an expression of type ¡°pointer
  to member.¡± Neither does qualified-id, because there is no implicit
  conversion from a qualified-id for a non-static member function to the
  type ¡°pointer to member function¡± as there is from an lvalue of
  function type to the type ¡°pointer to function¡± (4.3). Nor is
  &amp;unqualified-id a pointer to member, even within the scope of the
  unqualified-id¡¯s class. ¡ª end note ]</li>
  </ol>
</blockquote>
",0
42518324,42517963,2,"<p>The C++ Standard's definition of the built-in <code>operator &amp;</code> states that only when the parameter to <code>&amp;</code> is a <em>qualified-id</em>, meaning something like <code>Class::Member</code>, does <code>&amp;</code> result in a pointer-to-member.  The parentheses make it no longer a <em>qualified-id</em>, so it attempts to parse <code>X::f</code> directly, which is illegal in this context: you're assigning an <code>int (*)(long)</code> to an <code>int (X::*)(int)</code>.</p>

<p>The distinction between the two cases resolves an ambiguity.  Let's say that you have:</p>

<pre><code>struct X {
    int m;
};
struct Y {
    int m;
};
struct Z : X, Y {
    void F();
};

void Z::F() {
    int X::*p1 = &amp;X::m;
    int *p2 = &amp;(X::m);
}
</code></pre>

<p>Here, <code>&amp;X::m</code> is a pointer-to-member, whereas <code>&amp;(X::m)</code> is an ordinary pointer to <code>int</code>, using the <code>X::</code> qualification to resolve the ambiguity between <code>X</code>'s <code>m</code> and <code>Y</code>'s <code>m</code>.</p>
",0
40978329,40978097,1,"<p>If you need really big precision, then give <code>gmp</code> chance. I am sure it works on Windows too.</p>

<p>If you just need bigger precision than <code>double</code>, try <code>long double</code>. It may or may not give you more, depends on your compiler and target platform.</p>

<p>In my case it does give more (gcc 6, x86_64 linux):</p>

<p>Test program:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;limits&gt;

int main() {
    std::cout &lt;&lt; ""float:""
        &lt;&lt; "" bytes="" &lt;&lt; sizeof(float)
        &lt;&lt; "" min="" &lt;&lt; std::numeric_limits&lt;float&gt;::min()
        &lt;&lt; std::endl;

    std::cout &lt;&lt; ""double:""
        &lt;&lt; "" bytes="" &lt;&lt; sizeof(double)
        &lt;&lt; "" min="" &lt;&lt; std::numeric_limits&lt;double&gt;::min()
        &lt;&lt; std::endl;

    std::cout &lt;&lt; ""long double:""
        &lt;&lt; "" bytes="" &lt;&lt; sizeof(long double)
        &lt;&lt; "" min="" &lt;&lt; std::numeric_limits&lt;long double&gt;::min()
        &lt;&lt; std::endl;
}
</code></pre>

<p>Output:</p>

<pre><code>float: bytes=4 min=1.17549e-38
double: bytes=8 min=2.22507e-308
long double: bytes=16 min=3.3621e-4932
</code></pre>
",0
40978365,40978097,1,"<p>If your compiler/architecture allows it, you could use something like <code>long double</code>, which compiles to an 80-bit float (though I think it aligns to 128 bits, so there's a bit of wasted space) and has more range and precision than a typical <code>double</code> value. Not all compilers will do that though, and on many compilers, <code>long double</code> is equivalent to a <code>double</code>, at 64-bits.</p>

<p>""gmp"" is one library you could use for extended precision floats. I generally recommend <a href=""http://www.boost.org/doc/libs/1_62_0/libs/multiprecision/doc/html/index.html"" rel=""nofollow noreferrer"">boost.multiprecision</a>, which includes gmp, though personally, I'd use <code>cpp_bin_float</code> or <code>cpp_dec_float</code> for my multiprecision needs (the former is IEEE756 compliant, the latter isn't)</p>

<p>As for how to use them: I haven't used gmp, so I can't comment on its syntax, but <code>cpp_bin_float</code> is pretty easy to use:</p>

<pre><code>typedef boost::multiprecision::cpp_bin_float_quad quad;
quad a = 34;
quad b = 17.95467;
b += a;
for(int i = 0; i &lt; 10; i++) {
    b *= b;
}
std::cout &lt;&lt; ""This might be rather big: "" &lt;&lt; b &lt;&lt; std::endl;
</code></pre>
",0
40978368,40978097,1,"<p>If you change your compiler to <code>gcc</code> or <code>Intel</code> type <code>long double</code> will be supported with bigger precission (80-bit). With default visual studio compiler, I have no advice for you what to do. </p>
",0
42515564,42515494,3,"<pre><code> short size = sizeof(exceptions[1]) / sizeof(exceptions[1][0]);
</code></pre>

<p>effectively does the same as </p>

<pre><code> short size = sizeof(int*) / sizeof(int);
</code></pre>

<p>On a 64 bit platform, that yields most probably <code>2</code>.</p>

<hr>

<blockquote>
  <p>How can I solve this problem?</p>
</blockquote>

<p>Use some c++ standard container like <code>std::vector&lt;std::vector&lt;int&gt;&gt;</code> instead:</p>

<pre><code>std::vector&lt;std::vector&lt;int&gt;&gt; exceptions {
    {1, 4, 11, 13},
    {5, 6, 11, 12, 14, 15},
    {2, 12, 14, 15},
    {1, 4, 7, 9, 10, 15},
    {1, 3, 4, 5, 7, 9},
    {1, 2, 3, 7, 13},
    {0, 1, 7, 12},
}
</code></pre>

<p>Your statement will become:</p>

<pre><code> short size = exceptions[0].size();
 size = exceptions[1].size();
</code></pre>

<p>(for whatever that's needed)</p>
",4
42515648,42515494,0,"<p>The best remedy would be to use vector provided in standard template library. They have a size() function which you can use and they are much more versatile than array.</p>
",0
39246217,39245756,1,"<p>Assuming that <code>BYTE</code> is some type or typedef such that <code>sizeof(int) &gt; sizeof(BYTE)</code>, and your real code had some <code>#include</code> and <code>using</code> directives that you forgot to paste, then your program causes undefined behaviour in several ways:</p>

<ol>
<li>An expression of type <code>int</code> is used to write to storage of type <code>BYTE</code>, this violates the strict aliasing rule. </li>
<li>Even if we ignore (1) for a moment, it attempts to write past the end of the storage for the vector.</li>
<li>The program violates the rule that <code>main</code> must have a return type of <code>int</code>. Violating a diagnosable rule means that any executable generated has completely undefined behaviour.</li>
</ol>

<p>When <a href=""https://stackoverflow.com/a/4105123/1505939"">undefined behaviour</a> occurs, anything can happen. This includes, but is not limited to, crashing and not crashing. You should not expect any particular events or lack thereof.</p>
",3
39246372,39245756,3,"<p>On a formal point of view, you are just invoking Undefined Behaviour because you are trying to access a <code>BYTE *</code> as a <code>A *</code>. Per the strict aliasing rule, it is enough for the compiler to to anything it wants.</p>

<p>In the real world, it will depend on the implementation, and it is likely to give correct results. Under the hood, common implementations for <code>vector</code> use allocated memory for their <code>data</code> member. That means that:</p>

<ul>
<li>it will be correctly aligned for any type</li>
<li>the actual allocated memory is likely to be at least enough for an int (because of the alignment, it is at least 4 bytes on a 32 bits system and 8 on a 64 one)</li>
<li>you can safely change the type of the allocated memory</li>
</ul>

<p>That means that it is not surprising that this code does not crash, even if it is plain Undefined Behaviour.</p>

<p>Note: except in <strong>very special cases</strong>, and with notices in red flashing font, you should never rely on implementation detail for your code, because it can crash with next version of your compiler, or simply if you change build options.</p>

<p>The heap corruption is only a warning, because your implementation has put a mark after the last byte that it has given to you, and has found that mark overwritten. But on a low level point of view you have not erased anything of major importance - assuming your implementation is like mine :-)</p>
",0
39246289,39245756,0,"<p>Welcome in Undefined Behavior land.</p>

<p><code>a-&gt;i = 70000;</code> is totally undefined => you write an <code>int</code> inside something that have only one byte. So you can't know what will happen:</p>

<ul>
<li>Works fine</li>
<li>Segmentation fault</li>
<li>Works fine but break something in background (seams to be your case)</li>
<li>another unpredictable behavior</li>
</ul>

<p>Just by guessing, I suspect that the line <code>a-&gt;i = 70000;</code> will produce a buffer overflow which will overwrite some internal variables from <code>vector</code>. So during assignment, no <em>visible</em> trouble because enough memory has been allocated. But when <code>vector</code> is destroyed, internal variables produce incorrect behavior which produce a ""crash"".</p>

<p>Once again, it's just guessing, because it's <em>undefined behavior</em>. Only with a debugger you can observe what's happen just before crashing.</p>
",0
39246295,39245756,0,"<p>Your program does not crash. The heap corruption is an extra warning added by the compiler.</p>

<p>Now when the object gets destroyed it checks whether the memory is still ""OK"". Because you put a bigger object into the memory than intended, the memory past the object was overwritten. The implicit runtime checks by the compiler trigger and give you this error to tell you ""something is wrong with the memory"".</p>

<p>When this happens is compiler dependent and of the kind of memory checks. You can turn of the memory checks, then you wont get the error there but you have still corrupt memory and maybe have some strange (undefined) behavior later on.</p>

<p>There are several methods for this checks. Usually by adding extra special bytes at the end (sometimes also front) of allocated memory an on ""delete"" check if they are still there.</p>
",0
39246782,39245756,1,"<p>The vector you're using allocates its internal buffer on heap.</p>

<p>You make a buffer overflow writing 4 bytes on the 1 byte buffer, thus corrupting the heap.</p>

<p>When the scope is closed, the vector's destructor deallocate its internal buffer, the heap corruption is detected.</p>
",0
41904645,41904526,1,"<pre><code>template &lt;typename ... A&gt; void executeFunction(int(*func_ptr)(A...), A...) {
   if (func_ptr(A...) &gt; 0)
     throw std::runtime_error(""Method failed""); 
}

int func(int A, int B) {
}

int main() {
    int a, b;
    a = 0;
    b = 4;
    executeFunction(func, a, b)
}
</code></pre>

<p>Not tested but something like this should work.</p>

<p>Hope it helps!</p>
",0
41904655,41904526,6,"<p>Do you mean something like this?</p>

<pre><code>template&lt;typename F, typename... Args&gt;
auto my_invoke(F &amp;&amp;f, Args&amp;&amp;... args) {
    if(std::forward&lt;F&gt;(f)(std::forward&lt;Args&gt;(args)...)) {
        throw std::runtime_error(""Method failed"");
    }
}
</code></pre>

<p>You can call it as;</p>

<pre><code>my_invoke(functionA, 0, 'c');
</code></pre>
",7
41904667,41904526,1,"<p>Here¡¯s one approach that doesn¡¯t require changing call sites. Assuming these C functions all have the same convention for return codes, you can write a wrapper that converts the return code to an exception.</p>

<pre><code>inline void checked(const char *name, int result) {
    if (result &gt; 0)
        throw std::runtime_error(name);
}
</code></pre>

<p>Then introduce a preprocessor definition for each function.</p>

<pre><code>#define functionA(...) checked(""functionA"", functionA(__VA_ARGS__))
</code></pre>

<p>This works because <code>functionA</code> will not be expanded within the definition of the <code>functionA</code> macro. And variadic macros are standard since C++11.</p>
",2
41904705,41904526,2,"<p>Here is a template-based solution using C++17's new <code>auto</code> template parameters:</p>

<pre><code>template &lt;auto &amp;&gt; struct CallerImpl;

template &lt;typename ...Args, int (&amp;F)(Args ...)&gt;
struct CallerImpl&lt;F&gt;
{
    static int CallOrThrow(Args ... args)
    {
        if (int n = F(args...); n &gt; 0)
            throw std::runtime_error(""Method failed"");
        else
            return n;
    }
};

template &lt;auto &amp; F, typename ... Brgs&gt;
int CallOrThrow(Brgs ... brgs)
{
    return CallerImpl&lt;F&gt;::CallOrThrow(brgs...);
}
</code></pre>

<p>Usage example:</p>

<pre><code>int foo(double, char)
{
    std::cout &lt;&lt; ""Foo called\n"";
    return 8;
}

CallOrThrow&lt;foo&gt;(1.5, 'x');
</code></pre>
",2
41904814,41904526,2,"<p>I know I'll get downvoted for this, but I honestly think this is one case where the preprocessor can usefully be used:</p>

<pre><code>#define CHECK( fn ) \
    { \
        if( fn &gt; 0 ) { \
            throw ""problem""; \
        } \
    } 


int f(int x) {
    return x - 1;
}


int main() {
    CHECK( f(42) );
}
</code></pre>

<p>It's clear, it's short, it's simple, and it could be made to make use of the <code>__LINE__</code>, <code>__FILE__</code> and other pre-defined macros, which you can't do with templates. </p>
",0
42582738,42582637,6,"<p>You can either specify the fully qualified name by using the scope-operator:</p>

<pre><code>A::stuff xxx = a.get_stuff(index);
</code></pre>

<p>Or if your compiler supports C++11 or later you can use the <code>auto</code> keyword and let the compiler figure out the type:</p>

<pre><code>auto xxx = a.get_stuff(index);
</code></pre>

<hr>

<p>As a side note:</p>

<p>Your <code>get_stuff</code> method shouldn't even compile since it's trying to return a <code>stuff</code> object, <code>nullptr</code> is not a <code>stuff</code> object.</p>

<pre><code>stuff get_stuff(int index){
   if(index &lt; vec_stuff.size() &amp;&amp; index &gt;= 0) return vec_stuff[index];
   else return nullptr;
}
</code></pre>

<p>If it's expected to have a value and thus it's an exceptional case, then you should throw an exception. Otherwise you can let it return a <code>stuff*</code> and just do return <code>&amp;vec_stuff[index]</code>.</p>
",4
37247773,37247695,5,"<p>Trying to modify a constant value leads to <em>undefined behavior</em>, just don't do it.</p>

<p>As for why it doesn't change, the compiler sees that it is a compile-time constant and may store it in a read-only segment.</p>

<hr>

<p>For the second program, the variable <code>i</code> can't be stored in a read-only segment, it's stored on the stack like any other local variable. However, since you marked <code>i</code> as constant attempting to modify it is <em>still</em> undefined behavior.</p>

<p>The reason the <code>main</code> program prints the old value, is because you pass the variable <em>by value</em> meaning it gets copied into the local variable <code>i</code> in the <code>ChangeValue</code> function. If the variable wasn't a constant in the <code>main</code> or the <code>ChangeValue</code> function, the value of <code>i</code> in the <code>main</code> function would <em>still</em> not change.</p>

<p>If you change the <code>ChangeValue</code> function to take its argument by reference, you might get the same behavior as the first program.</p>
",1
37639006,37638870,2,"<p>Yes, there is a difference. If a member function is defined inside class definition then the compiler tries to make it an inline function. For your example, the function is simple enough to make it inline. So the compiler has made <code>bar</code> inline and you only see symbol of <code>baz</code>.</p>

<p>Whether it will be good or bad depends largely on the specific functions and your use case. Inline function do not need an actual function call, the there is a performance improvement there. But the downside is if you include the class header in many places then that will increase the binary size.</p>

<p>Also note that inline is a request to the compiler. The compiler is free to ignore the request and treat it a normal method.</p>
",1
37640146,37638870,1,"<p>As from <a href=""http://eel.is/c++draft/class.mfct#1"" rel=""nofollow"">9.2.1/1</a>:</p>

<blockquote>
  <p>A member function may be defined in its class definition, in which case it is an?<em>inline</em> member function</p>
</blockquote>

<p>On the other side, from <a href=""http://eel.is/c++draft/class.mfct#2"" rel=""nofollow"">9.2.1/2</a>:</p>

<blockquote>
  <p>An inline member function (whether static or non-static) may also be defined outside of its class definition provided either its declaration in the class definition or its definition outside of the class definition declares the function as?inline?orconstexpr.</p>
</blockquote>

<p>The question was: <em>Are member functions defined in a class definition compiled differently than member functions defined elsewhere in C++?</em></p>

<p>It mostly depends on how you define them, as you can deduce from the citations above.<br>
In your example, they are actually different.</p>
",0
37833716,37833450,2,"<p>""variables"" and ""strings"" exist in a later phase of compilation; the preprocessor runs at the stage where you have mere tokens. Your idea cannot be made to work in C++.</p>

<p>Not a C++98 problem, either: the same phases of compilation still apply to C++17, and I would be highly surprised if they ever change. More fundamentally, you assume an interpreted language when you write <code>std::string paramList = ""int, int""</code>. At the time where you have an actual <code>std::string variable</code>, the compiler must have run in the past, but that <code>int,int</code> is <em>input</em> to the compiler. An interpreter can interpret new code while existing code is running, but a compiler does not.</p>
",0
37833724,37833450,1,"<p>You can't. Macros are no more than text substation, with limited capabilities. They do not see values in objects (like <code>std::string</code>) or even the type system.</p>

<p>A macro does nothing more than tell the preprocessor to transform a sequence of characters in the <strong>source code</strong> to another sequence of characters in the source code, before the compiler even starts parsing it.</p>
",7
44229614,44229532,2,"<p>The mod operator is fundamental to C++ and other languages. This is definitely the best operator to use. There aren't any built-in types in C++ that I can think of that support this type of operation, simply because of how easy the mod operator is to use,</p>

<pre><code>++count %= n;
</code></pre>

<p>For example, This simple piece of code increments and mods a number in one line. </p>

<p>As the comment above says, if you really need a type in C++ you can just make it yourself. </p>
",2
35261458,35261421,1,"<ul>
<li><p>Can it cause undefined behaviour?</p>

<p>No.</p>

<p>When using a member initialization list, the order is fully defined: First base-classes in their order, then members in their order. So at the time you create any member, all base classes and all previous declared members are instantiated. If you switch the order in your constructor, your compiler should output a warning.</p></li>
<li><p>Is it a good way of accomplishing what you want?  </p>

<p>Since you don't tell us what you are going to do with those classes, i can't tell you if its a good way, but you can do it this way if it fits your needs.</p></li>
</ul>
",0
45742175,45742015,3,"<pre><code>if(f == NULL || ferror(f)) // Check that f isn't NULL nor has an Error
    std::cerr &lt;&lt; ""Can't open the file "" &lt;&lt; ferror(f)  &lt;&lt; '\n';
</code></pre>

<p>In other words, if <code>f== NULL</code> then <code>cerr &lt;&lt; ferror(f)</code>.</p>

<p>No wonder it blows up.</p>
",1
47505876,47504831,1,"<p>I may be over simplifying it, and please comment if I am wrong but I think the error is simply in your if statements.</p>

<p>It appears as though <code>if (failShot == true)</code> never gets called since <code>failShot</code> was initialised as false, and only gets updated as false again whenever you check  <code>if (cin.fail())</code>. If I am understanding this correctly, you want <code>if (failShot == true)</code> to get called if your <code>cin</code> does not fail. In this case, initialising failShot as True would fix your error.</p>

<p>Try changing: </p>

<pre><code>    failShot = false;
</code></pre>

<p>To:</p>

<pre><code>    failShot = true;
</code></pre>
",3
47518908,47504831,0,"<p>ok, your problem is the understanding of the <code>std::cin</code> object.</p>

<p>this is how it works</p>

<p><code>std::cin</code> starts at position <code>pos_type p = -1</code> then increment this position as it fetches chars from the keyboard buffer, when it encounter an error in parsing the entered chars, it sets the position to <code>eof</code>, so when next time it runs, it will return <code>eof</code> then do nothing.</p>

<p>to illustrate this in your code, insert this snippet under: <code>cin&lt;&lt;row&lt;&lt;column;</code></p>

<pre><code>cin &lt;&lt; row &lt;&lt; column ;
cout &lt;&lt; ""p ="" &lt;&lt; cin.tellg();
</code></pre>

<p>it will output the following (only interesting part is printed here)</p>

<pre><code>// when you enter for expel: c1 - which is correct input, it prints
p = 2; // advanced two position in the buffer until EOF
// when you enter wrong input: cc1 - it prints
p =-1;
// next run just after the error message, it will print
p = 3;//this number is the number of character read last time and it coincide with EOF
// right after, it will prompt you for another input
</code></pre>

<p>which means <code>std::cin</code> needs to consume all the character in the buffer then sets the position indicator to -1, then start extracting character again.</p>

<p>and that's exactly why you have a duplicated message. So how to fix it?</p>

<p>this is an ugly hack:</p>

<pre><code>//inside the loop under
cin.clear()
cin.seekg(0); // rewind...uuurrrgg, ugly!! but it works
</code></pre>

<p>what I suggest is to restructure your code. Use Boolean logic to design a beautiful code flow chart. Error like this in a code base, means that the code is more a spaghetti code rather than a well written code.</p>

<p>Do your best, Good luck!</p>
",0
36784087,36783909,0,"<p>You need to compile all the .cpp files into one program.  You're not using <code>BinomialTree.cpp</code> anywhere right now.  If your project requires that you simply type <code>g++ Asg5.cpp</code> then you need to <code>#include</code> your .cpp files or move their contents to your .h files.  But the normal solution would be to build all the .cpp files together, not just the one containing <code>main()</code>.</p>
",0
36784106,36783909,0,"<p>You cpp files shouldn't have Class in them. They should look more like:</p>

<p>BinomialNode.cpp</p>

<pre><code>#include ""BinomialNode.h""

BinomialNode::BinomialNode(int n) :
  k(0)
{
  data = n;
}
</code></pre>

<p>And of course the corollary for the much longer BinomialTree.cpp. Also, you should compile it with something like:</p>

<pre><code>g++ BinomialTree.cpp BinomialNode.cpp Asg5.cpp -o asg5
</code></pre>

<p>Also you're going to run into a lot of other problems with you code. For instance:</p>

<pre><code>BinomialNode * BQ[20];
</code></pre>

<p>I don't see BQ being initialized anywhere, which means you're pretty much guaranteed a seg fault if you were to run this. You need to initialize this or allocate it. Seeing lines like:</p>

<pre><code>if(BQ[0] == NULL)
</code></pre>

<p>Makes me think you really wanted:</p>

<pre><code>BinomialNode BQ[20];
</code></pre>

<p>Though you would still need to initialize it to all NULLs since you aren't guaranteed that will be full of NULLs when you run the program. Also, this is recursive and infinite and can't possibly work (in BinomialNode.h):</p>

<pre><code>BinomialNode *children[20];
</code></pre>

<p>There are likely more issues with this code, but that wasn't your question, so I'll stop now!</p>
",3
47560044,47558823,1,"<p>A base class is an abstraction of the more more specialized classes that follow. As a result a base knows nothing, and has no need to know, about those that derive from it. All any class knows is itself and what the classes on which it is based make available to it.</p>
<p>In addition, the C++ build process makes it impossible to know all possible permutations of future child classes. It would have to know about code that may not have been written yet or be in other modules that may or may not be linked in later or at runtime.</p>
<p>To manipulate a base class's members through a subclass most of the time you don't have to do anything. For <code>public</code> and <code>protected</code> variables what's in the base class is accessible in the subclass. <code>private</code> data is off limits, as usual (but look up <code>friend</code>ship).</p>
<p>If the base class has an <code>int x</code></p>
<pre><code>x = 24;
</code></pre>
<p>will do the job for most cases.</p>
<p>This only becomes a problem if both the base and the subclass have a variable of the same name.</p>
<p>Time for some code:</p>
<pre><code>#include &lt;iostream&gt;
struct object // using struct because it defaults to public access. 
              // This makes for a simpler example
{
    int x;
    int y;
};

struct robot:public object
{
    int x; // variable hides the x in object
    int y;

    void print()
    {
        std::cout &lt;&lt; &quot;robot: &quot; &lt;&lt; x &lt;&lt; ',' &lt;&lt; object::x &lt;&lt; '\n'; 
        // to access object's x we must ask for it explicitly
    }
};

struct betterrobot:public object
{
    void print()
    {
        std::cout &lt;&lt; &quot;better robot: &quot; &lt;&lt; x &lt;&lt; ',' &lt;&lt; object::x &lt;&lt; '\n';
    }
};
int main() {

    robot rob;
    rob.x = 24; // set robot's x
    rob.object::x = 42; // set object's x
    rob.print();

    betterrobot rob2;
    rob2.x = 24;
    rob2.print();

    return 0;
}
</code></pre>
<p>Output:</p>
<blockquote>
<p>robot: 24,42</p>
<p>better robot: 24,24</p>
</blockquote>
<p><code>Object</code> and <code>robot</code> have their own <code>x</code> and <code>y</code>. <code>object</code>'s <code>x</code> can be reached through <code>robot</code> by explicitly requesting it</p>
<pre><code>rob.object::x = 42;
</code></pre>
<p>In the output, printing <code>x</code> and <code>object::x</code> gave different answers. If you only</p>
<pre><code>rob.x = 24;
</code></pre>
<p>a smart compiler will scream at you for not initializing <code>object::x</code> as soon as it sees the <code>robot::print</code> method. If it doesn't, happy debugging!</p>
<p>This is something you rarely want to do because it wreaks havoc on the brain. You have two <code>x</code>s, and when you are working on polymprphic objects (Note: no polymorphic objects in example to keep things simple) it's really easy to screw up and set the wrong <code>x</code>. Don't do this unless there is no way to avoid it.</p>
<p>It is almost always better to inherit and use the base class's variable to avoid confusion. This is what <code>betterrobot</code> does. <code>betterrobot</code> only has <code>object</code>'s <code>x</code> and <code>y</code>. There is no possibility for confusion.</p>
<pre><code>rob2.x = 24;
</code></pre>
<p>is all there is. In the output, printing <code>x</code> and <code>object::x</code> gave the same answer.</p>
<p>You can move <code>betterrobot</code> around like you can any other <code>object</code>. Functions in <code>object</code>, <code>move</code> for example can be used to move <code>betterrobot</code> around on the map. No special magic is required.</p>
",1
34969731,34969517,0,"<p>This can be done is some steps: </p>

<p>Take all 2nd elements to a 1D array of structures. Let it is <code>node temp[];</code> </p>

<p>where <code>node</code> is like this: </p>

<pre><code>struct node{
    int value;
    int position;
};
</code></pre>

<p>Sort them using any technique on basis of <code>temp[i].value</code>. </p>

<p>Then copy the array to a resultant array according to the <code>temp[i].position</code> from the sorted array.</p>
",1
47494396,47494371,3,"<p>This line </p>

<pre><code>global = nlohmann::json::parse(js_string);
</code></pre>

<p>Reassigns the global to have a new value. The only way this could leak anything is if the assignment operator for <code>nlohmann::json</code> is faulty.</p>

<p>I suspect that's not the case. You don't need to worry about leaks.</p>
",0
47494427,47494371,1,"<p>If either <code>test(s1);</code>, <code>test(s2);</code> or <code>work_loop</code> throw an exception then process may get terminated without calling destructor for <code>global</code> (and for both strings as well) because there is no exception handling. This won't really cause a memory leak since the process memory will be reclaimed by the system anyway, however if cleanup involves other actions (e.g. removing temp files or closing net connections) it may cause real problems.</p>
",1
42613928,42613866,7,"<p>From [expr.log.or]:</p>

<blockquote>
  <p>The operands are both contextually converted to <code>bool</code></p>
</blockquote>

<p>Contextual conversion to bool is allowed to use explicit conversions. That's the point of the concept of ""contextuality"": The explicit conversion is allowed precisely when it makes sense, and not otherwise, so you don't accidentally form arbitrary integral or pointer values from the bool conversion, but when you actually ask for a bool, you get it.</p>

<p>See [conv]/4 for details:</p>

<blockquote>
  <p>Certain language constructs require that an expression be converted to a Boolean value. An expression <code>e</code>
  appearing in such a context is said to be <em>contextually converted to <code>bool</code></em> and is well-formed if and only if the
  declaration <code>bool t(e);</code> is well-formed, for some invented temporary variable <code>t</code></p>
</blockquote>
",0
42614016,42613866,1,"<p>From the C++ Standard (4 Standard conversions )</p>

<blockquote>
  <p>4 Certain language constructs require that an expression be converted
  to a Boolean value. An expression e appearing in such a context is
  said to be <strong>contextually converted to bool</strong> and is well-formed if
  and only if the declaration bool t(e); is well-formed, for some
  invented temporary variable t (8.5).</p>
</blockquote>

<p>and (5.15 Logical OR operator)</p>

<blockquote>
  <p>1 The || operator groups left-to-right. The operands are both
  <strong>contextually converted to bool</strong> (Clause 4). It returns true if either of its operands is true, and false otherwise. Unlike |, ||
  guarantees left-to-right evaluation; moreover, the second operand is
  not evaluated if the ?rst operand evaluates to true.</p>
</blockquote>

<p>and at last (12.3.2 Conversion functions)</p>

<blockquote>
  <p>2 A conversion function may be explicit(7.1.2), in which case it is
  only considered as a user-de?ned conversion for
  <strong>direct-initialization</strong> (8.5). Otherwise, user-de?ned conversions are not restricted to use in assignments and initializations.</p>
</blockquote>

<p>Relative to your example the invented declaration of the variable <code>t</code></p>

<pre><code>C c( true );

bool t( c ); 
</code></pre>

<p>is well-formed because there is used the direct initialization.</p>
",0
37399257,37399185,2,"<p>From your reasoning it is unclear why you still cannot use <code>unordered_map&lt;node, node&gt;</code>.</p>

<p>But since you are determined to store pointers yet perform value comparisons, your only option is container-wide linear search, <code>std::find_if</code> for instance.</p>
",4
37399373,37399185,2,"<p>If you control the construction of this map, you can give it an equality function and hash function that is consistent with that definition of equals:</p>

<pre><code>auto hash_fun = [] (node* obj) { return /* some hash value computed from x and y */; };
auto key_equal = [] (node* a, node* b) { return a-&gt;x == b-&gt;x &amp;&amp; a-&gt;y == b-&gt;y; };
typedef std::unordered_map&lt;node*,node*,decltype(hash_fun),decltype(key_equal)&gt; node_map;
node_map map(0, hash_fun, key_equal);
</code></pre>
",5
37399523,37399185,3,"<p>If you do not have control of the map construction as the other answer suggests then the following is a potential solution (untested, may require small tweaks):</p>

<pre><code>std::unordered_map&lt;node*,node*&gt; map;
//...
// node object to find
node n;
n.x = 0;
n.y = 0;
std::find_if(map.begin(), map.end(), 
    [n](const std::pair&lt;node*,node*&gt;&amp; _node) 
    -&gt; bool { return _node.first-&gt;x == n.x &amp;&amp; _node.second-&gt;y == n.y; });
</code></pre>

<p>Note, however, that <code>std::unordered_map&lt;node*,node*&gt;</code> is a strange construct and I would strongly advise you to reconsider this data structure based on what your requirements actually are.</p>
",1
39668489,39668148,1,"<p><strong>Reason -</strong> You are directly using the class <code>Bracket</code> instead of an object. </p>

<p><strong>Solution -</strong> </p>

<p>To create an object, you need to include the following code in your program.</p>

<p>i.e..</p>

<p>In your <code>main</code>, include the following statement to create an object of Bracket.</p>

<pre><code>Bracket brackObj(next, 0);
</code></pre>

<p>Now, include this particular object in the <code>stack</code></p>

<pre><code>if (next == '(' || next == '[' || next == '{') {
    opening_brackets_stack.push(brackObj);
}
</code></pre>

<p>And now, you can call your method <code>Matchc</code> on the same object.</p>

<pre><code>if(brackObj.Matchc(next) == false ......
</code></pre>
",1
47996691,47996550,0,"<p>This is pretty awkward and not extendable solution but very short and simple and it supports <a href=""https://en.wikipedia.org/wiki/Copy_elision"" rel=""nofollow noreferrer"">RVO</a> which could be significant for some return types:</p>

<pre><code>template &lt;typename F&gt;
auto wrapAndRun(F fn) -&gt; decltype(F()) {
    // foo();
    char c;
    auto runner = std::unique_ptr&lt;char, decltype(bar)&gt;( &amp;c, bar );
    try {
        return fn();
    }
    catch( ... ) {
        runner.release();
        throw;
    }
}
</code></pre>
",3
47996782,47996550,22,"<p>You can write a simple wrapper class that handles this part of it:</p>

<pre><code>template &lt;class T&gt;
struct CallAndStore {
    template &lt;class F&gt;
    CallAndStore(F f) : t(f()) {}
    T t;
    T get() { return std::forward&lt;T&gt;(t); }
};
</code></pre>

<p>And specialize:</p>

<pre><code>template &lt;&gt;
struct CallAndStore&lt;void&gt; {
    template &lt;class F&gt;
    CallAndStore(F f) { f(); }
    void get() {}
};
</code></pre>

<p>You can improve usability with a small factory function:</p>

<pre><code>template &lt;typename F&gt;
auto makeCallAndStore(F&amp;&amp; f) -&gt; CallAndStore&lt;decltype(std::declval&lt;F&gt;()())&gt; {
    return {std::forward&lt;F&gt;(f)};
}
</code></pre>

<p>Then use it.</p>

<pre><code>template &lt;typename F&gt;
auto wrapAndRun(F fn) {
    // foo();
    auto&amp;&amp; result = makeCallAndStore(std::move(fn));
    // bar();
    return result.get();
}
</code></pre>

<p>Edit: with the <code>std::forward</code> cast inside <code>get</code>, this also seems to handle returning a reference from a function correctly.</p>
",9
47996823,47996550,4,"<p>Solution with SFINAE, the idea is to make internally a void function actually return int - hopefully the compiler will optimize this away. On outside <code>wrapAndRun</code> will return the same type as a wrapped function.</p>

<p><a href=""http://coliru.stacked-crooked.com/a/e84ff8f74b3b6051"" rel=""nofollow noreferrer"">http://coliru.stacked-crooked.com/a/e84ff8f74b3b6051</a></p>

<pre><code>#include &lt;iostream&gt;

template &lt;typename F&gt;
auto wrapAndRun1(F fn) -&gt; std::enable_if_t&lt;!std::is_same_v&lt;std::result_of_t&lt;F()&gt;, void&gt;, std::result_of_t&lt;F()&gt;&gt; {
    return fn();
}


template &lt;typename F&gt;
auto wrapAndRun1(F fn) -&gt; std::enable_if_t&lt;std::is_same_v&lt;std::result_of_t&lt;F()&gt;, void&gt;, int&gt; {
    fn();
    return 0;
}

template &lt;typename F&gt;
auto wrapAndRun(F fn) -&gt; std::result_of_t&lt;F()&gt; {
    // foo();
    [[maybe_unused]] auto result = wrapAndRun1(fn);    
    // bar();        
    if constexpr (std::is_void_v&lt;std::result_of_t&lt;F()&gt;&gt;)
        return;
    else
        return result;
}

int main()
{
    wrapAndRun([] { std::cout &lt;&lt; ""with return \n""; return 0; });
    wrapAndRun([] { std::cout &lt;&lt; ""no return \n""; });
}
</code></pre>
",7
47997149,47996550,14,"<p>The new C++17 <code>if constexpr</code> addition may be helpful here. You can choose whether to return <code>fn()</code>'s result at compile-time:</p>

<pre><code>#include &lt;type_traits&gt;

template &lt;typename F&gt;
auto wrapAndRun(F fn) -&gt; decltype(fn())
{
    if constexpr (std::is_same_v&lt;decltype(fn()), void&gt;)
    {
        foo();
        fn();
        bar();
    }
    else
    {
        foo();
        auto result = fn();
        bar();
        return result;
    }
}
</code></pre>

<p>As you said C++2a is an option as well, you could also make use of concepts, putting a constraint on the function:</p>

<pre><code>template &lt;typename F&gt;
  requires requires (F fn) { { fn() } -&gt; void }
void wrapAndRun(F fn)
{
    foo();
    fn();
    bar();
}

template &lt;typename F&gt;
decltype(auto) wrapAndRun(F fn)
{
    foo();
    auto result = fn();
    bar();
    return result;
}
</code></pre>
",7
47998530,47996550,5,"<p>Another trick might be to exploit the comma operator, something like:</p>

<pre><code>struct or_void {};

template&lt;typename T&gt;
T&amp;&amp; operator,( T&amp;&amp; x, or_void ){ return std::forward&lt;T&gt;(x); }

template &lt;typename F&gt;
auto wrapAndRun(F fn) -&gt; decltype(fn()) {
    // foo();
    auto result = ( fn(), or_void() );
    // bar();
    return decltype(fn())(result);
}
</code></pre>
",8
47999656,47996550,5,"<p>You can have a look at the ScopeGuard by Alexandrescu: <a href=""https://github.com/facebook/folly/blob/master/folly/ScopeGuard.h"" rel=""noreferrer"">ScopeGuard.h</a> It executes code only when there was no exception.</p>

<pre><code>template&lt;class Fn&gt;
decltype(auto) wrapAndRun(Fn&amp;&amp; f) {
  foo();
  SCOPE_SUCCESS{ bar(); }; //Only executed at scope exit when there are no exceptions.
  return std::forward&lt;Fn&gt;(f)();
}
</code></pre>

<p>So in case of no errors, the execution order is: 1. foo(), 2. f(), 3. bar(). And in case of an exception the order is: 1. foo(), 2. f()</p>
",1
44728189,44727957,-1,"<h1>How I'd deal with this</h1>

<p>Okay, so you have this:</p>

<pre class=""lang-cpp prettyprint-override""><code>std::stringstream ss; ss &lt;&lt; ""lives:"" &lt;&lt; this-&gt;Lives;
Text-&gt;RenderText(ss.str(), font, x, y, scale,color);
</code></pre>

<p>Now if you really want to do it in a single line, why not put the string generation into a single function call, something specific like</p>

<pre><code>std::string life_text(int lifecount){
   std::stringstream ss;
   ss&lt;&lt;""lives:""&lt;&lt;lifecount;
   return ss.str();
}
</code></pre>

<p>So you can call render like this:</p>

<pre><code>Text-&gt;render(life_text(lives), x, y, scale,color);
</code></pre>

<h1>What you're looking for</h1>

<p>First, before I answer the question that you asked, the <code>&lt;&lt;</code> operator does not imply method chaining. At least not in vanilla C++, in fact, I don't think it's used anywhere like that in c++.</p>

<p>The stream objects aren't really chaining a method, but calling something like </p>

<pre><code>template&lt;typename T&gt; std::stringstream&amp; operator&lt;&lt;(std::stringstream&amp; rightside,T leftside){
    rightside.append(leftside);
    return rightside;
}
</code></pre>

<p>So what happens at each step of that is something like:</p>

<pre><code>stringstream r;
r&lt;&lt;""lives:"";
r&lt;&lt;this-&gt;lives;
</code></pre>

<p>What you are asking for isn't really all that simple. You would need to change the rendertext function to return a new sort of object that you can pass arguments to. That's hard.</p>

<p>Second of all, that would mean that your evaluation order would make this somewhat more challenging. There are ways around that, but I don't know if this is a situation where a simple convenience function like above wouldn't be better.</p>

<p>If you're dead set on doing this that way, then you might have to do something that is really potentially very problematic. You'd have to make the object call the actual render function(which I assume you probably have from some framework) at its disposal.</p>

<p>Fine, but now you've required adding some scope that might matter if you need this done in a specific order. It would look, potentially, like this:</p>

<pre><code>{
    Text-&gt;render(x,y,scale,color)&lt;&lt;""lives:""&lt;&lt;this-&gt;Lives;
}
</code></pre>

<p>To my eyes, that looks frustrating.</p>

<p>I'll answer any questions you might have relating to my answer, if you'd like, but, at least to my eyes, your original goal seems like you're barking up the wrong tree with how you'd like to do this.</p>

<h1>Something approaching a solution in the manner you wanted</h1>

<pre><code>template&lt;std::function&lt;typename ReturnType(std::string&amp;,typename Ts...)&gt; Func&gt;
class caller{
std::stringstream r;
Ts... arguments;
Func storedFunction;
public:

caller(Func x,typename Ts...):storedFunction(x){
arguments=Ts;

}
~caller(){
Func(r.str(),...Ts);
}
friend template&lt;typename S,typename P&gt; caller&lt;S&gt;&amp; operator&lt;&lt;(caller&lt;S&gt;&amp;,T value);
};
template&lt;typename S,typename P&gt; caller&lt;S&gt;&amp; operator&lt;&lt;(caller&lt;S&gt;&amp; c, T value){
    c.r&lt;&lt;value;
}
</code></pre>

<p>caller a_suitable_name(std::bind(&amp;Text::Render,&amp;Text),_those_other_arguments);
   caller&lt;&lt;""lives:""&lt;

<p>This isn't likely to work in its present form, but I don't have time to finish the definition.</p>
",5
44728059,44727957,3,"<p>Return a temporary object that accumulates all the parts of your string, then when it is automatically destroyed at the end of the statement, have it render the content in its destructor.</p>

<pre><code>#include &lt;utility&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;
using namespace std;

class Renderer {
    stringstream sstream;
    float x;
    float y;
public:
    Renderer(float x, float y) : x(x), y(y){}
    template&lt;class T&gt;
    Renderer &amp;&amp; operator&lt;&lt;(T&amp;&amp; t) {
        sstream &lt;&lt; std::forward&lt;T&gt;(t);
        return std::move(*this);
    };
    ~Renderer() {
        // your real code replaces the line below..
        cout &lt;&lt; sstream.str() &lt;&lt; endl;
    }
};

Renderer render(float x, float y) {
    return Renderer(x, y);
}

int main() {
    int i = 5;
    render() &lt;&lt; ""foo"" &lt;&lt; i;
}
</code></pre>

<p>live: <a href=""https://wandbox.org/permlink/UToweQELJ4jt0QYl"" rel=""nofollow noreferrer"">https://wandbox.org/permlink/UToweQELJ4jt0QYl</a></p>
",8
40954838,40954819,0,"<ol>
<li><p>The function pointer parameter <code>select</code>'s type is incorrect. You declare its return type as <code>void</code>, which can't be <code>cout</code>ed. The return value should be of type <code>int</code>.</p>

<pre><code>void powerN(int x[], const int sizex, int(*select)(int))
//                                    ~~~
</code></pre></li>
<li><p>The for loop in <code>main()</code>, <code>a++</code> should be <code>aSize++</code>.</p></li>
</ol>

<p><a href=""http://rextester.com/REV37328"" rel=""nofollow noreferrer"">LIVE</a></p>
",0
37698183,37697832,7,"<p>You may use <code>std::mem_fn</code></p>

<pre><code>auto iter = std::find_if(v.begin(), v.end(), std::mem_fn(&amp;A::value));
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/1f0b970471145e48"">Demo</a></p>

<p>Note that <a href=""https://github.com/ericniebler/range-v3"">range library</a> should allow directly:</p>

<pre><code>auto iter = range::find_if(v, &amp;A::value);
</code></pre>
",0
37698242,37697832,0,"<p>A solution could be the following</p>

<ol>
<li>(Optional) Don't mark your constructor <code>A(bool)</code> as explicit to allow implicit conversion from <code>bool</code> to <code>A</code> (<a href=""http://coliru.stacked-crooked.com/a/c90e10aba6cc0996"" rel=""nofollow"">live demo on coliru</a>)</li>
<li>Overload <code>operator==()</code> so that it only uses <code>value</code> to establish equality.</li>
</ol>

<p>You can also supply an <code>operator==(bool v) { return value == v;}</code> (see this <a href=""http://coliru.stacked-crooked.com/a/d916357e79784b58"" rel=""nofollow"">demo</a>)</p>

<p>Of course I would advise you not to use that solution as it is quite dirty. Just supply a predicate using <code>std::find_if</code> to do the job. Note that the said predicate must have an <code>operator()</code> so of course you cannot supply a value such as a <code>bool</code> as the predicate to <code>std::find_if</code></p>
",2
37698349,37697832,3,"<p>If you cannot use C++11 lambdas, you can do that with <code>std::bind</code>:</p>

<pre><code>auto iter = std::find_if(v.begin(), v.end(), std::bind(&amp;A::value, std::placeholders::_1));
</code></pre>
",0
38202316,38202200,0,"<p>If you run it in the background, you check the value of ret before the script is over, and ret default value is probably 0.</p>
",2
41676439,41675656,1,"<p>Since you have a class template with a non-template <code>enqueue()</code> method, you can only partially specialize the whole class, not the individual method:</p>

<pre><code>template &lt;typename T, int N&gt;
class Queue
{
    void enqueue(T x) { /* default implementation */ }
};

template&lt;int N&gt;
class Queue&lt;Heap&lt;InfoNode&gt;, N&gt;
{
   void enqueue(Heap&lt;InfoNode&gt; x) { /* specialized implementation */ }
};
</code></pre>

<p>Another alternative is not to specialize the whole <code>Queue</code> class but to make <code>enqueue()</code> delegate to a small helper class that will be specialized.</p>
",2
41677411,41675656,0,"<p>I have solved by extending the Queue class:</p>

<pre><code>class QueueSpec: public Queue&lt;Heap&lt;struct infoNode&gt;, SIZE &gt;
{
    public:
        void enqueue(Heap&lt;struct infoNode&gt; x);
};

---
void QueueSpec::enqueue(Heap&lt;struct infoNode&gt; x) {}
</code></pre>
",0
47502050,47501928,4,"<p>No.</p>

<p>Since the software will not allow me to stop at that, I will elaborate. The ""No"" applies to the question only. I have not checked the code for errors. So, no, it is not wrong to return the result as written. There is no cost involved. Any modern compiler will use <a href=""https://stackoverflow.com/questions/19454068/c-return-value-optimization#19454278"">return-value optimization</a> to return the result.</p>

<p>It would be very bad form to use operator new. Doing so would put the burden of deleting the object upon the calling function. Search for ""C++ RAII"".</p>
",3
46123780,46122932,0,"<p>There is no easy way to do what you described, however, if you can standardize certain components you can make it easier for yourself.  Also if these are being fed into a database, you need to have some structure built out to map everything correctly.</p>

<p><strong>An example project I have worked on :</strong> </p>

<ol>
<li><p>Reports come in from different source systems, of varying file types</p></li>
<li><p>These reports need to be fed directly into the database</p></li>
</ol>

<p>In this case, I used both a Flat-File to XML converter and an XML to XLSX converter.  The source system would provide an ""XML"" looking file and I already had an XLSX converter in place from a previous project.  There are plenty of resources online that can help you achieve this, but I'd advise you avoid some headaches by restricting the inputs.</p>

<p><strong>Further elaboration:</strong></p>

<p>I converted various file types into an XML file.  Once I had the XML file I would map various fields to another XML file which would be my template (JDOM/JNI), the component that standardizes what actually will go in the database.  You can then use regex based on important fields that may need to be formatted in a specific way such as a date format or monetary values. This way we standardize the various fields.  Then I posted the finalized component through a web service, SOAP UI.</p>

<p><strong>Possible issues:</strong></p>

<ol>
<li>Special characters - You can handle this with either a script or directly within your program</li>
<li>File Type Limitations - The more file types you accept, the more conversions you'll have to make especially if there are various delimiters separating the data.</li>
</ol>
",0
42568698,42568557,6,"<p>There are many tools to count cycles and instructions retired.  One widely accessible tool is Linux perf, which is described in detail on <a href=""https://perf.wiki.kernel.org/index.php/Tutorial"" rel=""nofollow noreferrer"">https://perf.wiki.kernel.org/index.php/Tutorial</a>.</p>

<p>From the aforementioned tutorial, you will find an answer that addresses your need directly:</p>

<pre><code>LC_NUMERIC=en_US.UTF8 perf stat -B -e cycles:u,instructions:u dd if=/dev/zero of=/dev/null count=10000000

100000+0 records in
100000+0 records out
51200000 bytes (51 MB) copied, 0.0971547 s, 527 MB/s

 Performance counter stats for 'dd if=/dev/zero of=/dev/null count=100000':

       96,551,461 cycles
       38,176,009 instructions             #      0.395 IPC

       0.098556460  seconds time elapsed
</code></pre>

<p>This answer could be more complete.  You may also consider Intel Vtune, which provides similar hardware-aware profiling as Linux perf.  As you might imagine, Intel Vtune supports Intel processors, although it should support Linux, Mac and Windows (I have only used it on Linux).</p>

<p>Disclaimer: I work for Intel, but not in any capacity related to Vtune.</p>
",1
42568698,42568557,6,"<p>There are many tools to count cycles and instructions retired.  One widely accessible tool is Linux perf, which is described in detail on <a href=""https://perf.wiki.kernel.org/index.php/Tutorial"" rel=""nofollow noreferrer"">https://perf.wiki.kernel.org/index.php/Tutorial</a>.</p>

<p>From the aforementioned tutorial, you will find an answer that addresses your need directly:</p>

<pre><code>LC_NUMERIC=en_US.UTF8 perf stat -B -e cycles:u,instructions:u dd if=/dev/zero of=/dev/null count=10000000

100000+0 records in
100000+0 records out
51200000 bytes (51 MB) copied, 0.0971547 s, 527 MB/s

 Performance counter stats for 'dd if=/dev/zero of=/dev/null count=100000':

       96,551,461 cycles
       38,176,009 instructions             #      0.395 IPC

       0.098556460  seconds time elapsed
</code></pre>

<p>This answer could be more complete.  You may also consider Intel Vtune, which provides similar hardware-aware profiling as Linux perf.  As you might imagine, Intel Vtune supports Intel processors, although it should support Linux, Mac and Windows (I have only used it on Linux).</p>

<p>Disclaimer: I work for Intel, but not in any capacity related to Vtune.</p>
",1
43767809,43767790,5,"<p>Your compiler ""wants"" to make your <code>&lt;</code> request work.</p>

<p>There is no <code>operator&lt;</code> for <code>Foo</code>, but it sees that there is a way to convert <code>Foo</code> to <code>double</code>. With that, via <em>implicit conversions</em>, your comparison will be able to succeed.</p>

<p>If the operator were marked <a href=""http://en.cppreference.com/w/cpp/language/explicit"" rel=""noreferrer""><code>explicit</code></a> (C++11 or newer), this implicit conversion would be impossible and the compiler would have to give up with your <code>&lt;</code> request.</p>

<p>The rules for selecting a function during a call are extremely complicated, so if I were you I would just trust that it works rather than attempting to parse the standard wording. :)</p>
",2PostsId
43767809,43767790,5,"<p>Your compiler ""wants"" to make your <code>&lt;</code> request work.</p>

<p>There is no <code>operator&lt;</code> for <code>Foo</code>, but it sees that there is a way to convert <code>Foo</code> to <code>double</code>. With that, via <em>implicit conversions</em>, your comparison will be able to succeed.</p>

<p>If the operator were marked <a href=""http://en.cppreference.com/w/cpp/language/explicit"" rel=""noreferrer""><code>explicit</code></a> (C++11 or newer), this implicit conversion would be impossible and the compiler would have to give up with your <code>&lt;</code> request.</p>

<p>The rules for selecting a function during a call are extremely complicated, so if I were you I would just trust that it works rather than attempting to parse the standard wording. :)</p>
",2
43767961,43767790,10,"<p>As mentioned in the comments, the compiler is allowed to make 1 user-defined conversion as it's doing here. It sees that it can convert both objects to <code>double</code> and <code>double</code> does have  <code>operator &lt;</code>, so it does that. If you only want to use your conversion operator when you (the programmer) ask for it you can add <code>explicit</code>:</p>

<pre><code>explicit operator double() const {
    return 3.14;
}
</code></pre>

<p>Now, the compiler may only call it when you explicitly cast it to such a type:</p>

<pre><code>Foo f1;
double d = (double)f1; // conversion operator
</code></pre>
",0
47492234,22662728,0,"<p>I think that ostream.write (myVector[0], ...) will not work, as it does not work in reading into vector (that I had.)
What works is ostream.write(MyVector.data(), ...)
Note: for reading use ifstream.read(const_cast(MyVector.data()), ...)</p>
",0
44737746,44736712,0,"<p>Well, usually if you provide multiple implicit conversion operator, then you should be explicit about the conversion if the target function have multiple overloads. In some cases, you might want to make some conversions <code>explicit</code>. </p>

<p>In most cases, I would say that the best solution would be do use a temporary variable in such cases. For example:</p>

<pre><code>char c = test; // or even better  char c { test };
cout &lt;&lt; c;
</code></pre>

<p>The main advantage of this over casts is that you ensure that the desired conversion is available.</p>

<p>I have done a few tests with conversion operators and I think that VC would sometime use a conversion operator that should not be allowed. For example, </p>

<pre><code>char c { test }; 
</code></pre>

<p>would compile with VC even if I remove the conversion to char operator. I think it should give a narrowing conversion error instead. It does works in trivial cases like </p>

<pre><code>int x = 345;
char c { x }; // An error as expected
</code></pre>

<p>You could also use <code>static_cast</code> for your conversion if you prefer.  </p>
",1
39620906,39620085,2,"<p>Consider code something like this:</p>

<pre><code>class A {
    int x;
public:
    virtual void foo() { std::cout &lt;&lt; ""base::foo()\n""; }
    virtual void bar() = 0;
    virtual ~A() {}
};

class B : public A {
    int y;
public: 
    virtual void bar() { std::cout &lt;&lt; ""Derived::bar()""; }
    virtual void baz() { std::cout &lt;&lt; ""Added function""; }
};

int main() { 
    A a;
    B b;
}
</code></pre>

<p>This is going to result in a layout something on this general order:</p>

<p><a href=""https://i.stack.imgur.com/awACu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/awACu.png"" alt=""enter image description here""></a></p>

<p>So, each object contains its own copy of the object's data, which is an amalgamation of all the data defined in that class and all its base classes. When it contains at least one virtual function, it has a vtable pointer. That points to a table somewhere in the generated code. That table, in turn, contains pointers to the virtual functions for the class. The key to this working is that (for virtual functions that are common between them) the base class and derived class store those pointers at the same offsets in the vtable. When you invoke a virtual function, the compiler generates code to ""chase"" the vtable pointer, then invoke the function at the right offset in the vtable.</p>

<p>Although it's not shown directly here, when each member function (virtual or otherwise) is called, the address of the variable is typically passed as a hidden parameter that's named <code>this</code> inside the function. References to members can use <code>this</code> implicitly (so an assignment like <code>somember=a;</code> is really equivalent to <code>this-&gt;somemember = a;</code>).</p>

<p>Note: this is depicting how things are <em>typically</em> done--at least in theory, an implementation is free to do things entirely differently, as long as what it does meets the requirements in the standard. That said, every implementation of which I'm aware works <em>fairly</em> similarly.</p>
",0
45108092,45107804,1,"<p>Let me take a wild guess.</p>

<p>It is because maybe you have incremental linking on.</p>

<p>Check out this: <a href=""https://stackoverflow.com/questions/45003759/c-function-addresses-coming-out-different-in-attached-profiler-library-than-in/"">c++ function addresses coming out different in attached profiler library than in the subject code base</a></p>
",7
45108222,45107804,1,"<p>At the address you are getting is a jump to the address the debugger is showing. This allows the function to be redirected.</p>

<p>For example:</p>

<pre><code>add1:
00B211EF  jmp         add1 (0B21730h) 
</code></pre>

<p>The value of <code>add1Address</code> will be <code>0x00B211EF</code>, but Visual Studio will show <code>0x00B21730</code> as the address of <code>add()</code>.</p>
",0
42506149,42506046,6,"<p>Assuming IEEE754 double precision floating point, the closest <code>double</code> to 2.11 is the slightly smaller</p>

<p><code>2.109999999999999875655021241982467472553253173828125</code></p>

<p><code>std::cout</code> is clever enough to round appropriately by default, but gdb appears to be truncating to 2 decimal places.</p>
",6
42506686,42506046,2,"<p>Given the fact that real numbers behave as they did in your case, I fear there isn't much to do about it. You could have planned for it to avoid it, and  created space to perform equality checks over your double values.</p>

<p>Here are two plausible hacks for you:</p>

<p>1: [Tried this in a college project] To deal with numbers in the order 10^-4, use an integer and a factor value. Example: to store 1.2345, store like integer 12345 and factor as 10000. Now you can print correctly and this also give feasibility to do equality checks also.</p>

<p>2: If accuracy of double values is already known you can use an offset. Example: if 2.109999 has accuracy of 2 decimal places, use something like this:
(int)((2.109999 + .005)*100). And then print accordingly.</p>

<p>But both these hacks assume following:</p>

<p>1: You have control on accuracy of values.
2: you really need printing accurate values.</p>
",0
37901757,37901569,0,"<p>I assume that <code>no</code> is a class with a member named <code>nom</code>, whose type is some instantiation of <code>std::basic_string</code>, such as <code>std::string</code> (it would have to be in order for that call to <code>std::getline</code> to compile). That being the case, <code>no</code> is not a POD type, and in order to use it, you need to construct it. <code>aux1</code> does not point to a constructed <code>no</code> object. It just points to raw memory allocated by malloc. So you are calling <code>std::getline</code> with something which is not a valid constructed string object. You need to either construct an object after you call <code>malloc</code>.</p>

<pre><code>aux1 = (struct no *) malloc(sizeof(struct no)+1);
new (aux1) no(/* constructor arguments here */);
...
// later, when you're done with the object
aux1-&gt;~no();
free(aux1);
</code></pre>

<p>Or allocate your object with a <code>new</code> expression, which will handle both the allocation and construction.</p>

<pre><code>aux1 = new no(/* constructor arguments here */);
...
// later, when you're done with the object
delete aux1;
</code></pre>
",0
38997653,38997596,1,"<p>Adding <code>const</code> solves your problem:</p>

<pre><code>void GetHMACCode(unsigned char* buffer,
                 long bufferLength,
                 unsigned char** pResult,
                 unsigned int &amp;nResultLen,
                 const char *extra_arg = ""11111111111111111111"") // const added here
{}
</code></pre>
",0
38997673,38997596,2,"<p>The warning is about converting the string literal to a non-const char* (<code>char* extra_arg = ""...""</code>).</p>

<p>Changing the definition of your function to the following should make the warning go away:</p>

<pre><code>void GetHMACCode(unsigned char* buffer,long bufferLength,unsigned char** pResult,unsigned int &amp;nResultLen, const char *extra_arg = ""11111111111111111111""){}
</code></pre>
",5
42584859,42584804,1,"<p>Making <code>hello</code> a <code>friend</code> of <code>foo</code> means that it's <em>not</em> actually a member of <code>foo</code> (despite its definition being inside of <code>foo</code>'s definition). Its name is ""injected"" into the global namespace, which is how it's found inside of <code>main</code>.</p>
",0
39325121,18760080,0,"<p>I did that using <strong>two loops</strong></p>

<p>here is my code</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
    int rows, star, spaces;
    int number_of_stars = 5;
    int number_of_rows = number_of_stars;
    string str1 = ""*""; 

    for (rows=1; rows &lt;= number_of_rows; rows++) {
            for (spaces=1; spaces &lt;= number_of_stars; spaces++) {
                    if (spaces==number_of_stars)
                    {
                         cout&lt;&lt;str1;
                         str1+=""**"";
                    }
                    else
                        cout&lt;&lt;("" "");
            }
            cout&lt;&lt;(""\n"");
            number_of_stars = number_of_stars - 1;
    }
    return 0;
}
</code></pre>

<p>and the result is</p>

<pre><code>    *
   ***
  *****
 *******
*********
</code></pre>

<p><a href=""http://cpp.sh/3qvmw"" rel=""nofollow"">Url of code on Online compiler</a></p>

<p>and you can solve it using <strong>only  one loop</strong>, its simple and easy</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main()
{
    int numberOfLines=4;
    string spaces=string( numberOfLines , ' ' );//this is 4 spaces 
    string stars=""*"";
    while(spaces!="""") 
    {
        cout&lt;&lt;spaces&lt;&lt;stars&lt;&lt;endl;
        spaces = spaces.substr(0, spaces.size()-1);
        stars+=""**"";
    }
}
</code></pre>

<p><a href=""http://cpp.sh/3pnnl"" rel=""nofollow"">Url of code on Online compiler</a></p>
",0
36420611,22515592,7,"<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
</code></pre>

<p>You can enter the line <code>using namespace std;</code> for your convenience. Otherwise, you'll have to explicitly add <code>std::</code> every time you wish to use <code>cout</code>, <code>fixed</code>,  <code>showpoint</code>, <code>setprecision(2)</code> and <code>endl</code></p>

<pre><code>int main()
{
    double num1 = 3.12345678;
    cout &lt;&lt; fixed &lt;&lt; showpoint;
    cout &lt;&lt; setprecision(2);
    cout &lt;&lt; num1 &lt;&lt; endl;
return 0;
}
</code></pre>
",0
40988013,40987939,2,"<p>You can use reference parameters to obtain more than one result from a function:</p>

<pre><code>void findFraction(string problem, int &amp;n1, int&amp;d1, int&amp; n2, int&amp; d2)
{
    char op, slash;
    istringstream iss(problem);
    iss &gt;&gt; n1 &gt;&gt; slash &gt;&gt; d1 &gt;&gt; op &gt;&gt; n2 &gt;&gt; slash &gt;&gt; d2;
}
</code></pre>
",1
47565100,47565050,5,"<p>Operator <code>&lt;&lt;</code> inherited by <code>std::basic_stringstream</code> from <code>std::basic_ostream</code> returns a <code>std::basic_ostream &amp;</code> reference as result. Operator <code>&gt;&gt;</code> is not aplicable to a <code>std::basic_ostream</code>. For this reason the expression</p>

<pre><code>(std::stringstream() &lt;&lt; t) &gt;&gt; i
</code></pre>

<p>is not supposed to compile. </p>

<p>It is not immediately clear to me why it compiles on your Mac.</p>

<hr>

<p>As an additional note, in pre-C++11 version of the language the</p>

<pre><code>std::stringstream() &lt;&lt; t
</code></pre>

<p>would already be ill-formed for those <code>t</code> that rely on non-member implementation of <code>operator &lt;&lt;</code>. Freestanding implementations of <code>operator &lt;&lt;</code> take a non-const reference as their LHS parameter.</p>
",1
36257499,36257415,0,"<p>pls change your integer datatype to float so u got </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main()
{
  float x=4,y=2,z=11;
  float p;
  p=7+z/y-x*2;
  cout&lt;&lt;p;
  return 0;
}
</code></pre>
",1
36257476,36257415,1,"<p>If a and b are integers then result of a/b will always be integer, not float. Dividing result is just truncated to integer value and float part is thrown away.</p>

<p>In expression <code>7+z/y-x*2</code> only integer variables are used, that is why result is also integer.</p>

<p>As an option you can cast one of the operands on right side to float, then whole expression will be threated as float:</p>

<pre><code>7+z/(float)y-x*2
</code></pre>
",5
43188173,43188050,2,"<p>Give them back an object (that they can store if they want) that always looks up the real one via private (friend) interfaces.</p>

<p>For example, an <code>IFooCaller</code> that implements <code>IFoo</code> by getting the current <code>IFoo</code> and forwarding all calls to it.</p>
",0
43188316,43188050,2,"<p>Your title says:</p>

<blockquote>
  <p>Is there a way to prevent assignment of pointers?</p>
</blockquote>

<p>No, you can't prevent that if your function returns a pointer.</p>

<p>However, if you return a handle, which can be a pointer to a type that is only forward declared or an integral value that can be used to come up the real object, and make sure that all the real functionality works with the handle, then you can have more freedom over when you can delete the real object without the risk of leaving the client code with a dangling pointer.</p>

<p>Here's a simple program that demonstrates the concept.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;set&gt;

// Foo.h

struct Foo;
using FooHandle = Foo*;

FooHandle createFoo();

void fooFunction1(FooHandle h);

void fooFunction2(FooHandle h);

// Test Program

int main()
{
   FooHandle h = createFoo();
   fooFunction1(h);
   fooFunction2(h);
   fooFunction1(h);
   return 0;
}

// Foo implementation.

namespace FooImpl
{
   std::set&lt;Foo*&gt;&amp; getLiveFooObjects()
   {
      static std::set&lt;Foo*&gt; liveObjects;
      return liveObjects;
   }

   bool isValid(Foo* h)
   {
      return (getLiveFooObjects().find(h) != getLiveFooObjects().end());
   }
}

using namespace FooImpl;

struct Foo {};

FooHandle createFoo()
{
   FooHandle h = new Foo{};
   getLiveFooObjects().insert(h);
   return h;
}

void fooFunction1(FooHandle h)
{
   if ( isValid(h) )
   {
      std::cout &lt;&lt; ""In fooFunction1.\n"";
   }
   else
   {
      std::cout &lt;&lt; ""Ooops. The handle is no longer valid.\n"";
   }
}

void fooFunction2(FooHandle h)
{
   std::cout &lt;&lt; ""In fooFunction2.\n"";
   delete h;
   getLiveFooObjects().erase(h);
}
</code></pre>

<p>Output:</p>

<pre class=""lang-none prettyprint-override""><code>In fooFunction1.
In fooFunction2.
Ooops. The handle is no longer valid.
</code></pre>
",1
43188334,43188050,1,"<p>A middle ground answer that would prevent <em>accidentally</em> storing a pointer to a particular implementation, but wouldn't prevent someone from doing it on purpose:</p>

<pre><code>template &lt;typename T&gt; class service_wrapper;

class service_manager
{
    template &lt;typename T&gt; friend class service_wrapper;

public:
    template &lt;typename T&gt;
    service_wrapper&lt;T&gt; get() const;

private:
    template &lt;typename T&gt;
    T* get_instance() const;
};

template &lt;typename T&gt;
class service_wrapper
{
    friend class service_manager;

public:
    T* operator-&gt;() const;

private:
    service_wrapper(service_manager const &amp; p_sm) : sm(p_sm) { }
    service_manager const &amp; sm;
};

template &lt;typename T&gt;
T* service_wrapper&lt;T&gt;::operator-&gt;() const
{
    return sm.get_instance&lt;T&gt;();
}
</code></pre>

<p>Your manager only dispenses instances of <code>service_wrapper&lt;T&gt;</code>.  The <code>operator-&gt;</code> implementation allows invoking on the service using <code>wrapper-&gt;method(...);</code>, and always fetches the implementation pointer from the service manager.</p>

<p>This can be circumvented like:</p>

<pre><code>T *ptr = sm.get&lt;T&gt;().operator-&gt;();
</code></pre>

<p>But that's not something you can accidentally do.</p>
",0
40545662,40545513,2,"<p>In the code you show, <code>a</code> should not be a pointer but simply declared as <code>A a;</code>.</p>

<p>From your code <code>B</code> has the ownership of <code>A</code>. The reason is twofolds:</p>

<ul>
<li><p>you explicitly create <code>A</code> objects in <code>B</code> and not derived types of <code>A</code></p></li>
<li><p><code>B</code> has the ownership of <code>a</code>: constructors, destructor and assignment.</p></li>
</ul>

<p>If you need some kind of polymorphism on <code>A</code> (use derived types of <code>A</code>), you can use smart pointers with <code>std::unique_ptr</code>.</p>

<p>Your first scenario reasons as if the class <code>B</code> contains <code>A a</code>.
Your second scenario reasons as if the class <code>B</code> contains <code>std::unique_ptr&lt;A&gt; a</code>. Both scenarios are correct. But I think the first one is more consistent (and more efficient) w.r.t. the current whole code.</p>

<p>If you need polymorphism, you should use the second with <a href=""http://en.cppreference.com/w/cpp/memory/unique_ptr"" rel=""nofollow noreferrer"">std::unique_ptr</a>.
Note that in this second scenario, you could replace</p>

<pre><code>a = new A();
*a = *src.a;
</code></pre>

<p>by </p>

<pre><code>a = new A(*src.a);
</code></pre>

<p>if the copy constructor is consistent w.r.t. the assignment operator.</p>

<p>With <code>A a</code> the code would be</p>

<pre><code>class B
{
    A a;
    public:
       B() {} // calls A()
       B&amp; operator = (const B &amp; src) // or = default;
         { a = src.a; // this != &amp;src is managed inside a
           return *this;
         }
      ~B() {} // no more usefull
      void display()
      {
        cout&lt;&lt;""inside B's display""&lt;&lt;endl;
        a.display();   
      }
};
</code></pre>

<p>With <code>unique_ptr</code> the code would be</p>

<pre><code>class B
{
    std::unique_ptr&lt;A&gt; a;
    public:
       B() : a(new A()) {}
       B&amp; operator = (const B &amp; src)
         { if (this != &amp;src)
              a.reset(src.a.get() ? new A(*src.a) : nullptr);
           return *this;
         }
      ~B() {} // no more usefull
      void display()
      {
        cout&lt;&lt;""inside B's display""&lt;&lt;endl;
        a-&gt;display();   
      }
};
</code></pre>
",1
38287986,38287965,1,"<p>Your immediate source of compilation error is wrong syntax. When you are calling the function, you need to call it with parenthesis: <code>wh.getpos()</code>. However, this is a lesser of a problem. A much bigger problem is that you are returning an array which is local to your function. This won't do, this array will be destroyed once you exit the function, and you will end up with a pointer to deleted object. Say 'Hi' to undefined behavior.</p>

<p>To fix the problem, you need to return either <code>std::vector</code> or <code>std::array</code>.</p>
",3
38287987,38287965,2,"<p>A plain array cannot be returned directly from a function.</p>

<p>Use <code>std::array</code>, instead.</p>
",0
38290614,38287965,0,"<p>The best solution is to use <code>std::array</code> (or <code>std::vector</code>) because it's the most flexible. Otherwise, you could create the array outside the method, then use a reference parameter to operate on it inside <code>wh.getpos()</code>.</p>
",0
45752327,45752103,1,"<p>You need to overload = operator to be able to do this.</p>

<ul>
<li><p>See, when you type x = y in any code and if both are of the same type and compiler(provided you are not using interpreted language) knows how to assign them then this will work fine.</p></li>
<li><p>Now Account is your custom type, so you have to tell c++ compiler how to assign them. </p></li>
</ul>

<p>Device class/structure will have overloaded it.
This is a quite simple example for the same check this out</p>

<p><a href=""https://www.tutorialspoint.com/cplusplus/assignment_operators_overloading.htm"" rel=""nofollow noreferrer"">Link to tutorialpoint = operator overloading</a></p>
",0
45752364,45752103,0,"<p>Figured it out. a stray const variable hiding</p>
",0
46648975,46648555,3,"<p>Vokay, I've solved it and here is how I did it:</p>

<pre><code>    vector&lt;int&gt;::iterator start = array.begin();
    vector&lt;int&gt;::reverse_iterator end = array.rbegin();
    while (true)
    {
        if (*start == *end &amp;&amp; start &lt;= end.base())
        {
            start++;
            end++;
        }
        else
            break;
    }
</code></pre>

<p>I replaced rend with rbegin, because that is where things were going wrong</p>
",3
46649024,46648555,2,"<p>A contiguous iterator is not much over a pointer wrapper, and finding the pointed object is just a matter of taking the address of the object <em>pointed at</em> by the iterator. So you can just do:</p>

<pre><code>if (*start == *end &amp;&amp; &amp;(*start) &lt;= &amp;(*end)) { ...
</code></pre>

<p>Provided you are iterating over a contiguous container like a <code>std::array</code> or a <code>std::vector</code>, the pointers actually point to elements of the same underlying raw array, so comparing the pointers is valid. And if you were iterating over a non contiguous container, comparing iterators would not make sense at all...</p>
",3
39643486,39643156,0,"<blockquote>
<p>Cannot do the following to make the name shorter:</p>
<pre><code>typedef Class_A::Class_B td_classB;
</code></pre>
</blockquote>
<p>It makes sense that you can't do that any old place. After all, <code>Class_B</code> is a <code>private</code> nested class of <code>Class_A</code>.</p>
<p>You can use that in any class or function that has access to the <code>private</code> section of the class.</p>
",0
38999029,38943243,1,"<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() {
    int i;
    int j;
    int count = 1;
    for(i= 0;i&lt;10;i++) {
        if(i &lt; 5) {
           for(j=0;j&lt;=i;j++) {
               cout&lt;&lt;""*"";
           }
        } else {
           for(j=i-count;j&gt;0;j--) {
              cout&lt;&lt;""*"";
           } 
           count +=2;
    }
       cout&lt;&lt; ""\n"";
   }
   return 0;
}
</code></pre>
",0
48020223,38879475,7,"<p>Note: despite the below, I admit to liking the idea of making constexpr the default.  But you asked why it wasn't already done, so to answer that I will simply elaborate on mattnewport's last comment:</p>

<p>Consider the situation today.  You're trying to use some function from the standard library in a context that requires a constant expression.  It's not marked as constexpr, so you get a compiler error.  This seems dumb, since ""clearly"" the ONLY thing that needs to change for this to work is to add the word constexpr to the definition.</p>

<p>Now consider life in the alternate universe where we adopt your proposal.  Your code now compiles, yay!  Next year you decide you to add Windows support to whatever project you're working on.  How hard can it be?  You'll compile using Visual Studio for your Windows users and keep using gcc for everyone else, right?</p>

<p>But the first time you try to compile on Windows, you get a bunch of compiler errors: this function can't be used in a constant expression context.  You look at the code of the function in question, and compare it to the version that ships with gcc.  It turns out that they are slightly different, and that the version that ships with gcc meets the technical requirements for constexpr by sheer accident, and likewise the one that ships with Visual Studio does not meet those requirements, again by sheer accident.  Now what?</p>

<p>No problem you say, I'll submit a bug report to Microsoft: this function should be fixed.  They close your bug report: the standard never says this function must be usable in a constant expression, so we can implement however we want.  So you submit a bug report to the gcc maintainers: why didn't you warn me I was using non-portable code?  And they close it too: how were we supposed to know it's not portable?  We can't keep track of how everyone else implements the standard library.</p>

<p>Now what?  No one did anything really wrong.  Not you, not the gcc folks, nor the Visual Studio folks.  Yet you still end up with un-portable code and are not a happy camper at this point.  All else being equal, a good language standard will try to make this situation as unlikely as possible.</p>

<p>And even though I used an example of different compilers, it could just as well happen when you try to upgrade to a newer version of the same compiler, or even try to compile with different settings.  For example: the function contains an assert statement to ensure it's being called with valid arguments.  If you compile with assertions disabled, the assertion ""disappears"" and the function meets the rules for constexpr; if you enable assertions, then it doesn't meet them.  (This is less likely these days now that the rules for constexpr are very generous, but was a bigger issue under the C++11 rules.  But in principle the point remains even today.)</p>

<p>Lastly we get to the admittedly minor issue of error messages.  In today's world, if I try to do something like stick in a <code>cout</code> statement in constexpr function, I get a nice simple error right away.  In your world, we would have the same situation that we have with templates, deep stack-traces all the way to the very bottom of the implementation of output streams.  Not fatal, but surely annoying.</p>

<p>This is a year and a half late, but I still hope it helps.</p>
",7
38879548,38879475,17,"<p>It already is permitted to evaluate side-effect-free computations at compile time, under the as-if rule.</p>

<p>What <code>constexpr</code> does is provide guarantees on what data-flow analysis a compliant compiler is <em>required</em> to do to detect<sup>1</sup> compile-time-computable expressions, and also allow the programmer to express that intent so that they get a diagnostic if they accidentally do something that cannot be precomputed.</p>

<p>Making <code>constexpr</code> the default would eliminate that very useful diagnostic ability.</p>

<hr>

<p><sup>1</sup> In general, requiring ""evaluate all expressions at compile time if possible"" is a non-starter, because detecting the ""if possible"" requires solving the Halting Problem, and computer scientists know that this is not possible in the general case.  So instead a relaxation is used where the outputs are { ""Computable at compile-time"", ""Not computable at compile-time <em>or couldn't decide</em>"" }.  And the ability of different compilers to decide would depend on how smart their test was, which would make this feature non-portable.  <code>constexpr</code> defines the exact test to use.  A smarter compiler can still pre-compute even more expressions than the Standard test dictates, but if they fail the test, they can't be marked <code>constexpr</code>.</p>
",10
36780103,36780051,1,"<p>For value parameters, <code>const</code> actually makes no difference. If a parameter is passed as value, it cannot be modified by the function anyway.</p>
",0
36780116,36780051,1,"<p>If an argument is passed by value but marked as const, what would happen if the variable did get modified? The copy local to the function would change, but the copy that got passed in would not.</p>

<p>However, on the other hand if passed by reference, if you could somehow modify the variable it would manipulate the original and not just a copy.</p>
",0
36780156,36780051,3,"<p>When you pass by value, the argument is effectively a local variable of the function. Whatever you pass is copied. If the argument is a <code>const T</code>, it just means the function itself cannot modify its own variable. The caller shouldn't know or care about that.</p>

<p>Passing by <code>const T&amp;</code> actually refers to access of a variable which does not belong to the function. Same with <code>const T*</code>. But not the same with <code>T* const</code>, that one would just mean the function itself cannot modify its own pointer. The pointer belongs to the function, if the function wants to reassign it to point to something else that's its own business. What it points to does not belong to the function, so whether the function gets <code>const</code> access or not is very relevant to the caller.</p>
",0
47543302,47543278,3,"<p>You are storing a reference to an object and then destroying the object. Once you <code>pop</code> it off the queue, it's no longer on the queue. Either make a copy of the object or don't <code>pop</code> it until you're done with it.</p>

<p>Again, never ever try to access an object that no longer exists. The results will be unpredictable.</p>
",5
44700815,44700469,2,"<p>You want to erase the type of the objects and treat them uniformly, so naturally type erasure is the solution.</p>

<pre><code>class with_method_t {
   struct model_t {
     virtual ~model_t() = default;
     virtual void call_method() = 0;
   };

   template&lt;class C&gt;
   class concept_t final : public model_t {
     C obj;
   public:
     concept_t(C const&amp; c) : obj{c} {}
     concept_t(C&amp;&amp; c) : obj{std::move(c)} {}
     void call_method() override { obj.method(); }
   };

   std::unique_ptr&lt;model_t&gt; instance;
public:
   template&lt;class C&gt;
   with_method_t(C&amp;&amp; arg)
     : instance{std::make_unique&lt;concept_t&lt;C&gt;&gt;(std::forward&lt;C&gt;(arg))}
   {}

   void method() { instance-&gt;call_method(); }
};
</code></pre>

<p>Then have yourself a vector of <code>with_method_t</code> which is a value type. No raw dynamic allocation or de-allocation. The instance is build by forwarding the argument it receives into a small polymorphic container:</p>

<pre><code>std::vector&lt;with_method_t&gt; vec;
vec.emplace_back(A{});
vec.emplace_back(B{});

for ( auto &amp;i: vec )
  i.method();
</code></pre>
",2
44700724,44700469,4,"<p>This is more of a pseudocode, trivial details are omitted.</p>

<pre><code>struct HolderBase
{
   virtual void foo() = 0;
};

template &lt;class T&gt;
struct Holder : HolderBase
{
  Holder(T* t) : t(t) {}
  T* t;
  void foo() { t-&gt;foo(); }
};

std::vector&lt;HolderBase*&gt; v { new Holder&lt;A&gt;(new A), new Holder&lt;B&gt;(new B) };
</code></pre>

<p>You can also have a variant of <code>Holder</code> that holds an object by value (and mix both variants in the same vector freely).</p>

<p>If you have a <em>single</em> method to call, there is a much simpler solution:</p>

<pre><code>A a;
B b;
std::vector&lt;std::function&lt;void()&gt; v { [](){a.foo();}, [](){b.foo();} };
</code></pre>
",0
44700927,44700469,5,"<p>A possible solution based on type erasure, static member functions and pointers to <code>void</code> that doesn't make use of <code>virtual</code> at all (example code, far from being production-ready):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

struct Erased
{
    using fn_type = void(*)(void *);

    template&lt;typename T&gt;
    static void proto(void *ptr) {
        static_cast&lt;T*&gt;(ptr)-&gt;method();
    }

    fn_type method;
    void *ptr;
};

struct A
{
  void method(){ std::cout &lt;&lt; ""A"" &lt;&lt; std::endl; };
};

struct B
{
  void method(){ std::cout &lt;&lt; ""B"" &lt;&lt; std::endl; };
};

int main()
{
  std::vector&lt;Erased&gt; vec;

  vec.push_back(Erased{ &amp;Erased::proto&lt;A&gt;, new A });
  vec.push_back(Erased{ &amp;Erased::proto&lt;B&gt;, new B });

  for ( auto &amp;erased: vec ) {
      erased.method(erased.ptr);
  }

  return 0;
}
</code></pre>

<p>This can help to avoid using a common base class. See it on <a href=""https://wandbox.org/permlink/JUNljQo8ZAiZ3zXf"" rel=""nofollow noreferrer"">wandbox</a>.</p>

<hr>

<p>As mentioned in the comments, <a href=""http://coliru.stacked-crooked.com/a/239cdd32e5a38e63"" rel=""nofollow noreferrer"">here</a> is a slightly modified version that adds <code>create</code> and <code>invoke</code> methods to reduce the boilerplate for the users.</p>
",4
36257284,36256919,0,"<p>I think Private and Protected, both work as a access specifier only. Only thing we can achieve that providing access permissions of data to others. And these access permissions decide on the compile time.</p>

<p>Most use of Private and Protected to achieve Inheritance and Data Encapsulation. just see the below example:</p>

<pre><code>class Base {

private: 
  int MyPrivateInt;
protected: 
  int MyProtectedInt;
public:
  int MyPublicInt;
}

class Derived : Base
{
public:
  int foo1()  { return MyPrivateInt;} // Won't compile!
  int foo2()  { return MyProtectedInt;} // OK  
  int foo3()  { return MyPublicInt;} // OK
};

class Unrelated 
{
private:
  Base B;
public:
  int foo1()  { return B.MyPrivateInt;} // Won't compile!
  int foo2()  { return B.MyProtectedInt;} // Won't compile
  int foo3()  { return B.MyPublicInt;} // OK
}; 
</code></pre>
",0
36257114,36256919,2,"<p>For the memory layout of a class object, from a given access specifier until the next the compiler has to place the data members at increasing addresses. More generally it has to place the members with the same access level, at increasing addresses. And this is not so for members of different access levels.</p>

<b>C++11 ¡ì9.2/14:</b>

<blockquote>
  <p><strong>&rdquo;</strong> Nonstatic data members of a (non-union) class with the same access control (Clause 11) are allocated so
  that later members have higher addresses within a class object. The order of allocation of non-static data
  members with different access control is unspecified.</p>
</blockquote>

<p>That's about the only (influence on) run-time effect, something that can fit the wording &ldquo;internal mechanism&rdquo;, that I know of.</p>

<p>All the rest, the checking, is at compile time.</p>
",0
36256950,36256919,0,"<p>I don't believe there is any runtime differences between methods/variables with different access levels. It's all enforced at compile time. </p>
",0
39681260,39681252,1,"<p>Your <code>k</code> is probably not constant. C++ doesn't allow variable length arrays like C does.</p>

<p>Use 
<code>std::vector&lt;std::vector&lt;int&gt;&gt; s1(k)</code> instead, if it is supposed to be dynamic array.</p>
",3
37352084,37352003,2,"<p>Your constructor expects references, not pointers.</p>

<p>As a sidenote, it's not clear why you use references or pointers.</p>
",0
37352093,37352003,3,"<pre><code>Field(const Position &amp;posG, const Position &amp;posC);
                     ^^^^^                 ^^^^^^
</code></pre>

<p>Those are references. So when you try to pass pointers</p>

<pre><code>Field field (pPosG, pPosC);
             ^^^^^   ^^^^
             pointer   pointer
</code></pre>

<p>It can't compile. </p>

<p>Either make the constructor accept reference pointers (<code>const Position *&amp;posG)</code> or pass the value of the pointers (<code>*pPosG</code>), or just pass the values directly (<code>posG</code>).</p>
",2
37352182,37352003,0,"<p>you must define a <code>constructor</code>, then use of <code>const Position *pPosC(&amp;posC);</code> expression.</p>

<p>you must define <code>constructor-copy</code> like this :</p>

<pre><code>struct Posicion {
public :
    Position(const Position &amp;pos)         // constructor copy
    {
        // some code here
        x = pos.x;
        y = pos.y;
    }

    int x;
    int y;
};
</code></pre>
",0
37352114,37352003,3,"<p>When you have a constructor defined as</p>

<pre><code>Field(const Position &amp;posG, const Posicion &amp;posC);
</code></pre>

<p>You can use objects of type <code>Position</code> as arguments to it, not pointers to <code>Position</code>.</p>

<p>You can use:</p>

<pre><code>Field field(posG, posC);
</code></pre>

<p>or</p>

<pre><code>Field field(*pPosG, *pPosC);
</code></pre>
",0
36246004,36245980,6,"<p><code>""MyKey""</code> is not <code>std::string</code>. It's <code>const char[6]</code>. And for <code>""MyKey"" + ((long long) timev)</code>, your overloading operator won't be called. Instead, <code>""MyKey""</code> will decay to <code>const char*</code>, then <code>""MyKey"" + ((long long) timev)</code> might get out of the bound of the array, which is  <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">UB</a>. </p>

<p>The code is equivalent as:</p>

<pre><code>const char* key = ""MyKey"";
string cname = key + ((long long) timev); // or key[((long long) timev)]
</code></pre>

<p>You could</p>

<pre><code>string cname = string(""MyKey"") + ((long long) timev);
</code></pre>
",12
46951819,46951718,1,"<p>There is nothing wrong with using forward declarations. They only help the compiler, most programmers just ignore them when reading code. In your second option, if you B class ever uses A, you will still need to use declarations. I would go with the first option if I were you.</p>
",1
46112997,46112945,4,"<p>You don't need to delete basic types.</p>

<p>But not just for basic types. For anything that you didn't allocate with <code>new</code> you don't have to call <code>delete</code> on. Even for pointers.</p>
",0
46113324,46112945,0,"<p>You may allocate primitives types on the heap (new ...) but usually this useless.</p>

<p>The general rule is that you <strong>may</strong> use new with any type (int, double, or your own types), and you <strong>must</strong> issue a delete for each variable allocated on the heap with new.</p>

<hr>

<p>However as you are asking for best practices you should read articles or tutorials on smart pointers (<a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr"" rel=""nofollow noreferrer"">std::shared_ptr</a>, <a href=""http://en.cppreference.com/w/cpp/memory/unique_ptr"" rel=""nofollow noreferrer"">std::unique_ptr</a>) which help you avoid mistakes when using heap-allocated objects. You may also search for articles talking about <a href=""http://en.cppreference.com/w/cpp/language/lifetime"" rel=""nofollow noreferrer"">lifetime</a> and borrowing.</p>

<p>Finally if you want to know what are the recommend practices to write good and safe C++ you definitely should read the isocpp Guidelines : <a href=""http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines"" rel=""nofollow noreferrer"">http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines</a>. They describe in simple words what you should do or shouldn't do, why and how.</p>
",0
46115095,46112945,0,"<p>In <code>c++</code> for every <code>new</code> there should be a <code>delete</code>.</p>

<p>When <code>new</code> is called you are allocating on the heap and you are responsible for deallocating it. If no <code>new</code> is used, the memory is allocated on the stack and will be deallocated upon going our of scope.</p>

<p>Please read <a href=""https://stackoverflow.com/questions/5836309/stack-memory-vs-heap-memory"">this</a> and <a href=""https://stackoverflow.com/questions/6713637/heap-vs-stack-allocation"">this</a>. There are plenty of information on this topic.</p>
",0
46115137,46112945,0,"<p>I assume that B is another class. You just declared the pointer. But not instantiated yet. You have not allocated any memory to that pointer.So initialize it to null.</p>

<pre><code> B* b = NULL;
</code></pre>

<p>Now before deleting it in the deconstructor check whether you have allocated any memory or not.</p>

<pre><code>if(b){delete b; b = NULL;}
</code></pre>

<p>In the above code if you allocate any memory then only it will deallocate.
for eg: if you did </p>

<pre><code>*b = new b
</code></pre>

<p>now some memory is allocated for this particular pointer. So it will deallocate properly.
You don't need to deallocate  unless until you allocate some memory to pointer.
Hope this will help you. </p>
",1
39684585,39684530,3,"<p>Typically, you don't assign subobjects. It's conceptually wrong and violates how inheritance is supposed to work. If you need this, perhaps you have the wrong abstraction and really want composition:</p>

<pre><code>struct B {
    A a;
};

std::unique_ptr&lt;B&gt; bp{new B{}};
A a{12, 13};
bp-&gt;a = a;
</code></pre>
",1
39684603,39684530,3,"<p>This may be slightly more idiomatic:</p>

<pre><code>bp-&gt;A::operator=(a);
</code></pre>

<p>This kind of thing is pretty rare though, so it is hard to say.  In general, the more you can avoid casts the better, but having an explicit cast may be useful in this case to make it clear you are doing something unusual.</p>
",4
37293347,37293059,9,"<p>Let's see it on any modern compiler:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;limits&gt;

enum MySmallSmall {
  SmallValue = 0,
};

enum MyLongLong {
  LongValue = std::numeric_limits&lt;long long&gt;::max()
};

int main() {
  std::cout &lt;&lt; ""sizeof MySmallSmall is "" &lt;&lt; sizeof(MySmallSmall) &lt;&lt; std::endl;
  std::cout &lt;&lt; ""sizeof MyLongLong is "" &lt;&lt; sizeof(MyLongLong) &lt;&lt; std::endl;
  return 0;
}
</code></pre>

<p>clang and g++ output:</p>

<blockquote>
  <p>sizeof MySmallSmall is 4</p>
  
  <p>sizeof MyLongLong is 8</p>
</blockquote>

<p>But for MS Visual Studio both results are 4 (I've checked it using this site <a href=""http://rextester.com/l/cpp_online_compiler_visual"" rel=""noreferrer"">http://rextester.com/l/cpp_online_compiler_visual</a> not sure what compiler version is here)</p>

<p>So you can't rely on sizeof of any enum.</p>
",6
37293146,37293059,7,"<p>If an <code>enum</code> was always an <code>int</code>, then the following would be unsafe:</p>

<pre><code>enum oops {
    foo = 32767,
    bar, /*what am I?*/
};
</code></pre>

<p>This is because an <code>int</code> can be as small as 16 bits (and that is still surprisingly common). On a system with a 32 bit <code>int</code>, you could set <code>foo = 2147483647</code> and your compiler most certainly <em>wouldn't</em> pick an <code>int</code> as the underlying type.</p>

<p>So the clever C++ bods specify that the underlying <code>enum</code> integral type must be capable of representing the values given, and a compiler is free to pick one that's appropriate. Given that <code>int</code> is often considered as the machine's native type, it's often a sensible choice.</p>

<p>If you want to know the underlying type of an <code>enum</code>, then <a href=""http://en.cppreference.com/w/cpp/types/underlying_type"" rel=""nofollow"">std::underlying_type</a> provides this.</p>
",1
45677803,45677534,2,"<p>It's awkward, but:</p>

<pre><code>const float (&amp;mat() const)[2][2]
{
    return U;
}
</code></pre>

<p>Using a typedef or <code>decltype</code> might be better, eg:</p>

<pre><code>const decltype(U) &amp;mat() const { return U; }
</code></pre>

<p>or:</p>

<pre><code>using mat22 = float[2][2];
const mat22 &amp;mat() const { return U; }
</code></pre>

<p>(this latter one as suggested by Daniel H. in comments).</p>

<p>or, in C++14, even just:</p>

<pre><code>const auto &amp;mat() const { return U; }
</code></pre>
",1
42472871,42472795,5,"<p>In c++, a constructor with only one parameter is known as a <em>converting constructor</em>. The reason the function doesn't complain is because the copy operation needed to pass the value into <code>a1</code> is making use of <code>A(int n = 0)</code> implicitly.</p>

<p>Stop this from happening by marking it <code>explicit</code></p>

<pre><code>explicit A(int n = 0)
</code></pre>

<p>As a side note; it is generally considered good practise to always mark single parameter constructors explicit unless you really want that behaviour (why?!)</p>
",1
42472974,42472795,3,"<p>There exists a constructor for class A that takes an int so this constructor can be used to convert the parameter to the correct type. The compiler is allowed to do this once for each parameter.
Prefixing the <strong>explicit</strong> keyword to the constructor prevents the compiler from using that constructor for implicit conversions
Solution:
define</p>

<pre><code>explicit A(int n = 0)
</code></pre>
",0
42472844,42472795,4,"<p>The object of <code>A</code> gets created implicitly. To avoid such confusing cases, declare constructor <a href=""http://en.cppreference.com/w/cpp/language/explicit"" rel=""nofollow noreferrer""><code>explicit</code></a>. It is also considered as a good practice in general.</p>

<pre><code>explicit A(int n = 0)
</code></pre>

<p>The standard (<code>N4140 12.3.1/1</code>) says:</p>

<blockquote>
  <p>A constructor declared without the <em>function-specifier</em> <code>explicit</code> specifies a conversion from the types of its
  parameters to the type of its class. Such a constructor is called a <em>converting constructor</em>. [ <em>Example:</em></p>

<pre><code>struct X {
    X(int);
    X(const char*, int =0);
    X(int, int);
};

void f(X arg) {
    X a = 1; // a = X(1)
    X b = ""Jessie""; // b = X(""Jessie"",0)
    a = 2; // a = X(2)
    f(3); // f(X(3))
    f({1, 2}); // f(X(1,2))
}
</code></pre>
  
  <p>¡ª <em>end example</em> ]</p>
</blockquote>
",3
37904572,37904456,1,"<p>The whole offset has to be multiplied by <code>bpp</code>, not only <code>y</code>:</p>

<pre><code>    imageArray [bpp*(x*height + y)] = 255;
    imageArray [bpp*(x*height + y) + 1] = 0;
    ....
</code></pre>
",0
37904579,37904456,0,"<p>I think I understand your problem now, but it relies on some assumptions about how you are bringing in your data and what <code>bpp</code> means.</p>

<p>You are trying to loop over every pixel here and update the 3 values.
You set <code>size = width*height*bpp</code> where I can only assume <code>bpp</code> means bits-per-pixel and is the 3 showing up in your loop. Try stepping through this with <code>x=1</code> and <code>y=0</code>. If the data is being layed out contiguously like:
<code>RGB @ x=0,y=0; RGB @ x=1,y=0; ...</code> then you can see you end up writing over your data from the first iteration of the loop. Everytime you nest the loop, the index should get multiplied entirely by the next levels dimension. Just replace <code>x*height + 3*y</code> with <code>(x*height + y)*bpp</code> assuming <code>bpp = 3</code>.</p>
",0
37904702,37904456,0,"<p>It all depends on the order that bytes a stored in the image array.</p>

<p>Your formulation suggest a by-column/by-row/by-color. But it can also be by-row/by-column/by-color or even by-color/by-row/by-column.</p>

<p>The index formulation should be</p>

<ul>
<li><code>x*(b*h)+y*b+c</code></li>
<li><code>y*(b*w)+x*b+c</code></li>
<li><code>c*(w*h)+y*h+x</code></li>
</ul>

<p>(b, w ,and h are color bytes, width and height)</p>

<p>Note how indexes cumulate in the sums. You have at least forgotten one multiplication, assuming the order is correct.</p>
",0
41909138,41908940,-1,"<p>Qouted from <a href=""https://msdn.microsoft.com/en-us/library/3600tzxa.aspx"" rel=""nofollow noreferrer"">this</a> link.</p>

<blockquote>
  <p>You can set compiler options for each project in its <strong>Property Pages</strong> dialog box. In the left pane, select <strong>Configuration Properties, C/C++</strong> and then choose the compiler option category.</p>
</blockquote>

<p><strong>Update:</strong>
To add language specification use <a href=""https://msdn.microsoft.com/en-us/library/mt490614.aspx"" rel=""nofollow noreferrer"">/std</a> flag. Append it at the end of existing flags in <strong>Command Line</strong> option page.</p>
",6
42514912,42514726,0,"<p>In both C and C++, when inputting an integer, the <s>driver</s> input function will read numeric characters until a character that is not a number is read.  </p>

<p>For example, the sequence <code>""123GHI""</code> should return the value <code>123</code>.  </p>
",3
42515127,42514726,1,"<blockquote>
  <p>Please explain why is this happening?</p>
</blockquote>

<p>In the <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt"" rel=""nofollow noreferrer"">documentation</a> of the <code>std::istream&amp; operator&gt;&gt;(std::istream&amp;, int)</code> it's stated (emphasis mine):</p>

<blockquote>
  <blockquote>
    <p>If extraction fails (e.g. if a letter was entered where a digit is expected), <strong>value is left unmodified</strong> and failbit is set.</p>
  </blockquote>
</blockquote>

<p>For c++11 code it seems initialization is guaranteed:</p>

<blockquote>
  <blockquote>
    <p>If extraction fails, zero is written to value and failbit is set. If extraction results in the value too large or too small to fit in value, <code>std::numeric_limits&lt;T&gt;::max()</code> or <code>std::numeric_limits&lt;T&gt;::min()</code> is written and failbit flag is set.</p>
  </blockquote>
</blockquote>

<p>Assumed you run a debug build of your code, <code>n</code> is probably initialized with <code>0</code> automatically, but technically accessing it is <em>undefined behavior</em>, since it wasn't initalized in that case you describe.</p>

<p>You have to check <code>cin</code>'s state after input to detect if a failure occured during the number extraction, or if you can safely use the now-initialized value:</p>

<pre><code> int n;
 std::cin &gt;&gt; n;
 if(std::cin) {
     std::cout &lt;&lt; n &lt;&lt; std::endl;
 }
 else {
     std::cin.clear(); // Clear the streams fail state
     std::string dummy;
     std::cin &gt;&gt; dummy; // Consume the non numeric input
     std::cout &lt;&lt; ""Wrong input, '"" &lt;&lt; dummy &lt;&lt; ""' is not a number.""
 }
</code></pre>
",3
36498553,36496943,3,"<p>The problem occurs because you are trying to call method ""marr()"" of class ""bar"" before class definition. You only have declared class ""bar"" when you call ""bar_->mar();"" compiler knows that there is a class ""bar"" but does not know what methods it has.
The solution is to call constructor of ""foo"", after definition of ""bar"". you can declare it ""inline"" if your library is header only.</p>

<p>This code compiles ok:</p>

<pre><code>#pragma once
#include &lt;memory&gt;

class bar;
class foo {
public:
    foo(std::shared_ptr&lt;bar&gt; bar_);
    void moo() {};
};


class bar {
public:
    bar(std::shared_ptr&lt;foo&gt; foo_) {
        foo_-&gt;moo();
    }
    void mar() {  };
};

inline foo::foo(std::shared_ptr&lt;bar&gt; bar_){
    bar_-&gt;mar();
}
</code></pre>
",0
43934171,22057800,0,"<p>this is using string</p>

<pre><code>enter code here  #include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main()
{
string a = ""*"";
string c;
int x;
for (x=0; x&lt;5; x++)
{
  c+=a;
  cout&lt;&lt;c&lt;&lt;endl;
}
 return 0;
}
</code></pre>
",0
45767790,45767354,4,"<p>As mentioned in the comments, you're out of luck with your current code as both constructors are viable candidates. A solution is to use inheritance instead of aggregation and have <code>Node</code> derive from <code>Point</code>. You must also explicitly inherit <code>Point</code>'s constructor:</p>

<pre><code>class Node: public Point
{
public:
    using Point::Point; // constructor inheritance
    Node(std::string str) {}
};
</code></pre>

<p>Now you can use</p>

<pre><code>Node{0, 1}; // note that Node{{0, 1}} will invoke the string ctor
</code></pre>

<p>and </p>

<pre><code>Node{""test""};
</code></pre>

<p>just fine. </p>

<p>Full example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

class Point
{
public:
    Point() {};
    Point(int x, int y) : x(x), y(y) {std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; '\n';}
private:
    int x{};
    int y{};
};

class Node: public Point
{
public:
    using Point::Point;
    Node(const std::string&amp;) {std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; '\n';}
};

int main()
{
    Node{0, 1};
    Node{""test""};
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/55cf2b46ea3069e6"" rel=""nofollow noreferrer""><kbd>Live on Coliru</kbd></a></p>

<p>If you wonder why now <code>Node{{0, 1}}</code> will invoke the <code>Node::Node(const std::string&amp;)</code> constructor instead of an ambiguity, that's because the only viable constructor candidate is <code>Node::Node(const std::string&amp;)</code> (the other inherited constructor has the signature <code>Point::Point(int, int)</code>, so it won't accept an initializer list). Whereas in your original code <code>Node::Node(const Point&amp;)</code> would also be a viable constructor due to the implicit conversion from an initializer list to a <code>Point</code> (this kind of constructor is called a <em>conversion constructor</em>).</p>
",0
42525936,18939896,0,"<pre><code>//This is edit mode program

#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;string.h&gt;
#include&lt;iostream.h&gt;
int main()
{
FILE*fp1, *fp2;
char fname[100],lname[100];
char fncomp[100],lncomp[100];
int age; 
fp1 = fopen(""OriginalTextFile.txt"",""r""){
}
fp2 = fopen(""TemporaryTextFile.txt"",""w""){
}
printf(""Enter First name of a person that you want to edit: "");
scanf(""%s"", &amp;fncomp);

while(!feof(fp1)){
fscanf(fp1,""%s %s %d"", fname,lname,age);
if(strcmpi(fncomp,fname)==0)
printf(""%s %s %d\n\n"", fname,lname,age);

printf(""Replace name with: "");
scanf(""%s %s"",&amp;repfname, &amp;replname);

fname = repfname;
lname = replname;

fprintf(fp2,""%s %s %d"", fname,lname,age);
}
fclose(fp1);
fclose(fp2);

fp2 = fopen(""TemporaryTextFile.txt"",""r""){
}
fp1 = fopen(""OriginalTextFile.txt"",""w""){
}
while(!feof(fp2))
{
fscanf(fp2,""%s %s %d"", fname,lname,age);
fprintf(fp1,""%s %s %d"", fname,lname,age);
}
fclose(fp1);
fclose(fp2);

getch();
}
</code></pre>
",0
45788443,45788391,2,"<p>There is too little information here to be sure, but it looks like you have</p>

<pre><code>using namespace std;
</code></pre>

<p>Somewhere in your code. <a href=""https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice"">Don't do this</a>! In this case, the standard library has a <a href=""http://www.cplusplus.com/reference/algorithm/reverse/"" rel=""nofollow noreferrer"">function <code>reverse()</code> in std</a> that takes two parameters.</p>

<p>Furthermore, you have <code>void App::reverse(char *str)</code>, but that cannot be seen from <code>void myArray::reverse(char* str)</code>, so your own <code>reverse()</code> cannot be called as-is -  you would need to do <code>App::reverse()</code> if the function is a class static.</p>
",3
38393604,38393303,2,"<p>First of all, you're not streaming a <code>std::string</code>, but a <code>const char*</code>. You can fix that by writing <code>cout &lt;&lt; std::string(""string123"")</code> instead (<a href=""http://coliru.stacked-crooked.com/a/de0c7cd096c90ac0"" rel=""nofollow"">demo</a>; although, ew).</p>

<p>Note that there is already such an overload in <code>&lt;string&gt;</code>, and your implementation apparently just go happens to include <code>&lt;string&gt;</code> through <code>&lt;iostream&gt;</code> (<a href=""http://coliru.stacked-crooked.com/a/350805809b04bf7a"" rel=""nofollow"">as does mine</a>, and as is its prerogative). However, your version (after making the fix above) is a better match since ADL doesn't need to be invoked to find it.</p>
",0
38393624,38393303,1,"<p>You should send a string type to <code>&lt;&lt;</code>:</p>

<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; out,const string&amp; str)
{
    out&lt;&lt;""overloading"";
    return out;
}

int main()
{
    string s = ""string123"";
    cout &lt;&lt; s;
}
</code></pre>

<p>Note that sending again the string itself in the <code>&lt;&lt;</code> definition will make infinite recursion for </p>

<pre><code>out &lt;&lt; ""overloading"" &lt;&lt; str &lt;&lt;""done""
</code></pre>
",4
38393844,38393303,4,"<p>You're basically shooting yourself in the footin your example. You overload <code>operator&lt;&lt;</code> for <code>std::string</code> type, so you should expect it gets called every time you try to send an ""std::string"" to <code>out</code>, thus causing runtime stack overlow. To make it work, you:</p>

<ul>
<li>need to output a <code>char *</code> type to <code>out</code> in <code>operator&lt;&lt;</code> overload, so it doesn't cause infinite recursion</li>
<li>send an actual <code>std::string</code> in <code>main</code>. </li>
</ul>

<p>Here's a working example without runtime stack overflow problem:</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
ostream&amp; operator&lt;&lt;(ostream&amp; out, const string&amp; str)
{
    out &lt;&lt; ""overloading"" &lt;&lt; str.c_str() &lt;&lt; ""done"";
    return out;
}

int main()
{
    cout &lt;&lt; std::string(""string123"");
}
</code></pre>

<p>The output is</p>

<pre><code>overloadingstring123done
</code></pre>
",1
36365387,36365325,1,"<p>You forgot to use keyword <code>virtual</code>. Also translate to pointers (credit goes to Captain Giraffe).</p>

<p>See code below:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

class BaseClass {

public:

    BaseClass() {}

    virtual std::string getString() { // BINGO _!_!_!_!
        return ""base"";
    }

};

class SubOne : public BaseClass {

public:

    SubOne() : BaseClass() {}

    std::string getString() {
        return ""sub1"";
    }

};

class SubTwo : public BaseClass {

public:

    SubTwo() : BaseClass() {}

    std::string getString() {
        return ""sub2"";
    }

};

class MyCollection {

private:

    std::vector&lt;BaseClass*&gt; instances;

public:

    MyCollection() {}


    void add(BaseClass* ins) {
        instances.push_back(ins);
    }

    std::string printString() {

        for(std::vector&lt;BaseClass*&gt;::iterator it = instances.begin() ; it != instances.end(); ++it) {
            std::cout &lt;&lt; (*it)-&gt;getString() &lt;&lt; std::endl;
        }

    }

};

int main() {

MyCollection *coll = new MyCollection();

SubOne* s1 = new SubOne();
SubTwo* s2 = new SubTwo();

coll-&gt;add(s1);
coll-&gt;add(s2);

coll-&gt;printString();

return 0;

}
</code></pre>
",7
46667727,46667693,2,"<p>You said:</p>

<p><em>On the other hand, j goes from 0 to groupSize</em></p>

<p>But the code says:</p>

<pre><code>for (int j = i; j &lt;= groupSize; j++)
</code></pre>

<p>This means j is going from i to <code>groupSize</code>, not 0 to <code>groupSize</code></p>
",5
41667967,41667855,3,"<p>You can use a <code>std::istream_iterator&lt;&gt;</code>.  Here is an example which constructs a <code>std::vector</code> from the contents of stdin:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main(int argc, char **argv) {
    std::vector&lt;int&gt; vec{
        std::istream_iterator&lt;int&gt;(std::cin),
        std::istream_iterator&lt;int&gt;()};
    for (int i : vec) {
        std::cout &lt;&lt; i &lt;&lt; '\n';
    }
    return 0;
}
</code></pre>

<p>If you would rather, you can use <code>push_back</code> in a loop.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main(int argc, char **argv) {
    std::vector&lt;int&gt; vec;
    for (std::istream_iterator&lt;int&gt; p{std::cin}, e; p != e; ++p) {
        vec.push_back(*p);
    }
    for (int i : vec) {
        std::cout &lt;&lt; i &lt;&lt; '\n';
    }
    return 0;
}
</code></pre>
",2
41668025,41667855,1,"<p>In addition to the iterator solution shown in the other answer, you could add five elements to the end of the vector and then read new vales into them from the stream:</p>

<pre><code>auto n = vtr.size();
vtr.resize(n + 5);
if (std::cin &gt;&gt; vtr[n] &gt;&gt; vtr[n+1] &gt;&gt; vtr[n+2] &gt;&gt; vtr[n+3] &gt;&gt; vtr[n+4])
{ }
else
{ /* report error */ }
</code></pre>
",0
41669021,41667855,2,"<blockquote>
  <p>Can I do this in one line?</p>
</blockquote>

<p>Not directly, but you can wrap it:</p>

<pre><code>template&lt;typename ContainerType&gt;
void readValue(std::istream &amp;in, ContainerType &amp;container)
{
    ContainerType::value_type temp;
    if (in &gt;&gt; temp)
        container.push_back(temp);
}
</code></pre>

<p>Then it is a one-line call:</p>

<pre><code>readValue(cin, vtr);
</code></pre>

<blockquote>
  <p>For bonus points is there a way to also incorporate a for-loop alternative</p>
</blockquote>

<p>If you use C++11 or later, you can use <a href=""http://en.cppreference.com/w/cpp/algorithm/copy_n"" rel=""nofollow noreferrer""><code>std::copy_n()</code></a> with a <a href=""http://en.cppreference.com/w/cpp/iterator/istream_iterator"" rel=""nofollow noreferrer""><code>std::istream_iterator</code></a> and <a href=""http://en.cppreference.com/w/cpp/iterator/back_inserter"" rel=""nofollow noreferrer""><code>std::back_inserter</code></a>:</p>

<pre><code>std::copy_n(std::istream_iterator&lt;int&gt;(std::cin), 5, std::back_inserter(vtr));
</code></pre>

<p>Otherwise, just use a manual loop:</p>

<pre><code>for (int i = 0; i &lt; 5; ++i) readValue(cin, vtr);
</code></pre>
",0
36835197,36834838,0,"<p>As you've discovered, <code>CHECKLEAKDCL</code> is a macro that expands to the three tokens <code>: private CheckLeak</code>. Presumably <code>CheckLeak</code> is a class that adds some leak checking diagnostic behaviour to classes which inherit from it.</p>

<p>In general, this sort of obfuscation is not very helpful. Depending on the properties of <code>CheckLeak</code>, this macro might have unintended side effects, such as turning what appears to be a standard layout class into a non-standard layout class.</p>

<p>It would also be hard to add <code>CHECKLEAKDCL</code> to a class that wanted to inherit from another class for any other reason. (Are you supposed to <code>class Foo CHECKLEAKDCL, public OtherBase</code> ?)</p>

<p>Personally, if given the chance to improve this project I'd favour replacing this macro with its actual expansion in this case.</p>
",0
36835091,36834838,1,"<p>We cannot tell exactly what it is, as we have even less information than you do.</p>

<p>Normally, I have seen such macros resolve to export macro, for the library.</p>

<p>That is, the value of it should be defined as <code>dllexport</code>, <code>dllimport</code> or <code>extern</code> (depending on platform). <strong>When that is the case though, the macro appears before the class name.</strong></p>

<p>Considering the macro appears after the class name, <strong>it can only resolve to a base class</strong>, or <strong>list of base classes</strong>, or an empty macro.</p>

<p>If you have the documentation, search for a base class that tracks or reports it's address to a memory tracker on construction and destruction.</p>

<p>Then, the code base should be compiled using a macrodefinition similar to this:</p>

<pre><code>#define CHECKLEAKDCL() : private MemoryTrackingBaseClass
</code></pre>

<p>(where <code>MemoryTrackingBaseClass</code> is the class I mentioned above - according to your edit, <code>CheckLeak</code>).</p>

<p>If you want to simply compile, try using:</p>

<pre><code>#define CHECKLEAKDCL()
</code></pre>

<p><strong>Edit</strong> (addressing your update)</p>

<blockquote>
  <p>So Foo is extending CheckLeak, right? </p>
</blockquote>

<p>Only when you want to check your application for leaks, using whatever <code>CheckLeak</code> implements.</p>

<p>In a production environment (after you use the definition inheriting from <code>CheckLeak</code>), you should probably define <code>CHECKLEAKDCL</code> as an empty macro (for speed).</p>
",0
36834951,36834838,2,"<p>If you compile for windows (using Visual Studio), highly possible it will be evaluated to one of the Microsoft specific linkage identifiers, <code>dllexport</code> or <code>dllimport</code> :</p>

<p><a href=""https://msdn.microsoft.com/en-us/library/81h27t8c.aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/81h27t8c.aspx</a></p>

<p>It is used when you create a class which will be exported from a DLL or used from a DLL in an application, and dependig of this it's either evaluated to <code>dllexport</code> (DLL exporting the class) or <code>dllimport</code> (Application importing the class).</p>

<p>If you compile with GCC possibly it will evaluate to one of the gcc <code>_-attribute__</code>s. Such as <code>__attribute__ ((visibility (""default"")))</code> (<a href=""https://gcc.gnu.org/wiki/Visibility"" rel=""nofollow"">https://gcc.gnu.org/wiki/Visibility</a>)</p>

<p>These extensions to the core C++ are provided by compilers to make certain tasks more easily achievable (<a href=""https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Extensions.html"" rel=""nofollow"">https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Extensions.html</a>)</p>

<p><strong>EDIT</strong></p>

<p>After you updated the answer ... well, obviously you have a private inheritance from a class. But please note, this is a terrible macro you have there because</p>

<pre><code>#define CHECKLEAKDCL  : private CheckLeak
</code></pre>

<p>adds an <code>:</code> in your class declaration so you cannot use that symbol anymore to inherit  from base classes.</p>

<p>I'd recommend that you get rid of that macro altogether, if you cannot, do  not use it, it will confuse your code.</p>
",1
41645509,19434535,0,"<p>Copying information from the comments on an answer that's been deleted, apparently in the C4droid environment you can use the Volume-Down key as a Control key. Typing <code>d</code> while holding the Volume-Down key should send a <kbd>Ctrl-D</kbd> character to your application, which should trigger an end-of-file condition.</p>

<p>As an alternative consider installing the <a href=""https://play.google.com/store/apps/details?id=org.pocketworkstation.pckeyboard&amp;hl=en"" rel=""nofollow noreferrer"">Hacker's Keyboard</a> Android app; it gives you a desktop-style keyboard including an actual Control key.</p>
",0
34913638,34913502,4,"<p>This might help you get started.  See <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms682073(v=vs.85).aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/windows/desktop/ms682073(v=vs.85).aspx</a> for more info.</p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

void main()
{
    HANDLE screenBuffer = CreateConsoleScreenBuffer(
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        CONSOLE_TEXTMODE_BUFFER,
        NULL);

    if (screenBuffer == INVALID_HANDLE_VALUE)
    {
        printf(""CreateConsoleScreenBuffer failed - (%d)\n"", GetLastError());
        return;
    }

    if (!SetConsoleActiveScreenBuffer(screenBuffer))
    {
        printf(""SetConsoleActiveScreenBuffer failed - (%d)\n"", GetLastError());
        CloseHandle(screenBuffer);
        return;
    }

    for (int x = 0; x &lt; 10; ++x)
    {
        DWORD numCharsWritten;
        WriteConsoleOutputCharacter(screenBuffer, ""X"", 1, COORD{(short)x, 1}, &amp;numCharsWritten);

        Sleep(1000);
    }

    CloseHandle(screenBuffer);
}
</code></pre>
",3
36411107,36410532,3,"<p>Good:</p>

<pre><code>using namespace std::placeholders;
auto g = std::bind(f, 2, _1);
</code></pre>

<p>Better:</p>

<pre><code>auto h = std::bind(f, 2, std::placeholders::_1);
</code></pre>

<p>Best:    </p>

<pre><code>auto i = [](auto&amp;&amp; x) { f(2, x); };
</code></pre>

<p>For extra bonus points:</p>

<pre><code>auto j = [](auto&amp;&amp; x) {
    using type = std::decay_t&lt;decltype(x)&gt;;
    f(2, std::forward&lt;type&gt;(x));
};
</code></pre>
",2
38292053,38292040,10,"<blockquote>
  <p>My question is can a function return a string like an integer does?</p>
</blockquote>

<p>Sure, you want to write</p>

<pre><code>string aString()
{
    return ""Car"";
 // ^^^^^^
}
</code></pre>

<hr>

<p>If the function declares a return type, you actually need to return something, otherwise you have undefined behavior.</p>

<p>The compiler should have issued a warning about that.</p>

<p><code>std::cout</code> is used to print out values at the terminal, not to return them from functions.</p>
",2
41902646,41902344,1,"<p>This:</p>

<pre><code> *(m.begin())
</code></pre>

<p>evaluates to a nameless temporary object. To bind this to a reference, the reference must be const, so:</p>

<pre><code> void fun(const std::pair&lt;int, B&gt;&amp; p) {
</code></pre>

<p>and for that function to call getVal(), that must be const too:</p>

<pre><code> int getVal() const {return val2;}
</code></pre>
",0
36333732,36333595,3,"<p>Input from terminal is line buffered.</p>

<p>The first <code>std::cin &gt;&gt; currVal</code> blocks until input is available at standard input.</p>

<p>That doesn't happen until you press <code>&lt;Enter&gt;</code>. (Up to that <code>&lt;Enter&gt;</code>, the characters you entered are still residing in the line buffer of your terminal / CMD box. You can backspace, edit etc.; only when you press <code>&lt;Enter&gt;</code> does the terminal / CMD box actually send those characters to the program's standard input.)</p>

<p>For your expected behaviour to happen, try pressing <code>&lt;Enter&gt;</code> after each number.</p>
",2
36333923,36333595,0,"<p>Both <code>std::cin &gt;&gt; currVal</code> in your sample will block the standard input, <code>std::cin</code> means a value that comes from standard input, in that case your keyboard is your standard input. </p>

<p>To confirm the input from keyboard you need to push <code>Enter</code> key, then values are removed from the <code>buffer</code> of the keyboard and processed by your code.</p>

<p>If you want to get the values for each press of key you need to use something like <code>std::getchar</code>, that function reads the buffer immediately like you expect.</p>
",0
38094228,37253834,1,"<p>If you really don't want to allow a ""default"" instance, I would use a pointer to indicates the presence of the singleton instance:</p>

<pre><code>struct Foo {
    Foo(int i){...};

    static Foo&amp; initDefault (int i) {
        static Foo foo(i);
        if (pFoo) {
            throw ""Foo's instance is already initialized."";
            // or: foo = Foo(i); if you want to allow re-initialization
        }
        else {
            pFoo = &amp;foo;
        }
        return foo;
    }

    static Foo&amp; getDefault() {
         if (!pFoo) {
             throw ""Cannot get Foo's instance before initializing it."";
         }
         return *pFoo;
    }  

    void doSomething(){...}

private:
    static Foo *pFoo;
};

Foo* Foo::pFoo{nullptr};
</code></pre>

<p>With the above, you have a simple way to test if the instance is initialized without having to dynamically allocate your singleton instance.</p>
",0
35200563,35200488,7,"<p>Member functions in derived classes with the same names as those in base classes <em>hide</em> the functions in the base class.</p>

<p>If you want <code>MyTmp&lt;T&gt;::foo</code> to be available from <code>MyClass</code>, you could as a using-directive:</p>

<pre><code>class MyClass: public MyTmp&lt;Other&gt; {
public:
   using MyTmp::foo;
   void foo(const B&amp; b);
}
</code></pre>
",0
40558372,40558346,0,"<p>You are printing the pointer of the array for x and z which gives you a hex address if you want to print the values you need to loop through it and use the index operator [] like this </p>

<pre><code>for (int i = 0; i &lt; some number; i++) { cout &lt;&lt; x[i];}
</code></pre>

<p>Also it would appear that z is empty in this example. </p>
",0
47522404,47522344,0,"<p>Lets say you have this binary sequence:</p>

<pre><code>11110
</code></pre>

<p>Your code will compare starting from the first and second:</p>

<pre><code>|11|110 1 &amp;&amp; 1 -&gt; max = 1
1|11|10 1 &amp;&amp; 1 -&gt; max = 2
11|11|0 1 &amp;&amp; 1 -&gt; max = 3
111|10| 1 &amp;&amp; 0 -&gt; max = 3
</code></pre>

<p>you can see, that although there are 4 1's you only do 3 comparisons, so your max will always be -1 of the actual max. You can fix this by adding <code>mmax += 1</code> after your for loop.</p>
",1
47522430,47522344,0,"<p>Just a little bit of trace using small example will show why.</p>

<p>First, lets say there is only 1 '1' in your array.</p>

<p>Since you require both the current position and your next position to be '1', you will always get 0 for this case.</p>

<p>Let's say I have ""11111"". At the first '1', since next position is also '1', you increment count once. This repeats until 4th '1' and you increment your count 4 times in total so far. When you reach 5th '1', your next position is not '1', thus your count stops at 4.</p>

<p>In general, your method is like counting gaps between fingers, given 5 fingers, you get 4 gaps.</p>

<p>Side note: your code will fail for the case when there is no '1' in your array.</p>
",0
42599820,42599740,2,"<p>The extraction operator does not change the variables when the stream cannot be interpreted as a valid value of the appropriate type. Therefore you see uninitialized values for <code>input1</code> and <code>input2</code>. You can check the <code>failbit</code> on <code>cin</code> to see whether the extraction operator was successful.</p>

<p>For example:</p>

<pre><code>    int input1;
    cout &lt;&lt; ""Enter a real number :"";
    cin &gt;&gt; input1;
    if(cin.good())
    {
        cout &lt;&lt; ""The int number is "" &lt;&lt; input1 &lt;&lt; endl;
    }
    else
    {
       cout &lt;&lt; ""The input was not a number."" &lt;&lt; endl;

       // skip to the end of the input
       cin.clear();
       cin.ignore(INT_MAX, '\n');
    }
</code></pre>
",1
42599829,42599740,4,"<pre><code>int input1;
float input2;
</code></pre>

<p>At this point, both <code>input1</code> and <code>input2</code> have undefined values since you didn't initialize them.</p>

<p><code>std::cin</code> was expecting an integer to be entered but you entered <code>'a'</code>, which made <code>std::cin</code> to <code>fail</code>. That failure persists such that no extraction operation can be performed with <code>std::cin</code> until the <code>failbit</code> is cleared.</p>

<p>After your failed input operations, <code>input1</code> and <code>input2</code> are still ""undefined"". Printing them lead to Undefined Behavior.</p>
",8
47542355,47542218,4,"<p>If you don't specify an initial value for max, then it's value is whatever happens to be at that memory address at that time. Using unitialized memory is undefined behavior, the value could be anything. </p>
",1
36394232,36394190,1,"<p>I think this is what you want:</p>

<pre><code>bool isMUString ( char* sequence, int size )
{

    int numberOfChars = 0;
    while ( sequence[numberOfChars] != '\0' )
    {
        numberOfChars++;
    }

    if ( numberOfChars != size )
    {
        return false;
    }

    for ( int i = 0; i &lt; size; i++ )
    {
        if ( sequence[i] != 'M' &amp;&amp; sequence[i] != 'U' &amp;&amp; sequence[i] != 'I' )
        {
            return false;
        }
    }

    return true;
}
</code></pre>
",5
36394253,36394190,2,"<p>This should work:</p>

<pre><code>bool isMUString(const char* sequence, int size) {
    int numberOfChars = strlen(sequence);
    if(numberOfChars != size) {
        return false;
    }

    for(int i=0;i&lt;size;i++){
        if (sequence[i]!='M' &amp;&amp; sequence[i]!='U' &amp;&amp; sequence[i]!='I'){
            return false;
        }
    }
    return true;
}
</code></pre>

<p>Here's what I changed:</p>

<ul>
<li>Use strlen to determine the length of the string</li>
<li>Take <code>if(numberOfChars != size)</code> out of the for loop body because it only needs to be checked once.</li>
</ul>

<p>Here's an example, if you don't want to use <code>strlen()</code> (altough you should). I make a copy of the <code>sequence</code> pointer, so that you still have a pointer to the beginning of the string when you're done with the counting while loop:</p>

<pre><code>bool isMUString(const char* sequence, int size) {
    int numberOfChars = 0;
    const char* ptr = sequence;
    while (*ptr != '\0')  {
        numberOfChars++; ptr++;
    }

    if(numberOfChars != size) {
        return false;
    }

    for(int i=0;i&lt;size;i++){
        if (sequence[i]!='M' &amp;&amp; sequence[i]!='U' &amp;&amp; sequence[i]!='I'){
            return false;
        }
    }
    return true;
}
</code></pre>
",5
36228258,36228168,1,"<p>You should enter the two numbers with a space between them. The <code>std::in</code> does not know how to handle other types of separators (besides white spaces).</p>
",1
37640523,37640493,3,"<p>The problem you have is that you override the member names with function parameters. You can use <code>this-&gt;</code> to make it explicit or name the member differently.</p>

<p>For example:</p>

<pre><code>void Car::setBrand(string name) {
    this-&gt;name = name;
}
</code></pre>

<p>Or:</p>

<pre><code>void Car::setBrand(string new_name) {
    name = new_name;
}
</code></pre>
",1
37640525,37640493,3,"<p>In your constructor and setters, you make no differentiation between the local parameter and the class member.</p>

<pre><code>name = name;
</code></pre>

<p>Both the function parameter and the class member are called <code>name</code>. Currently the compiler is assigning the parameter value to itself, and not affecting the class member at all. This is because the function parameter is in a more immediate scope.</p>

<p>Possible solutions:</p>

<ol>
<li>Specify <code>this</code> when referring to the class member: <code>this-&gt;name = name;</code>.</li>
<li>Rename the function parameter: <code>name = _name;</code>.</li>
<li><p>For the constructor, use initializer lists:</p>

<pre><code>Car::Car(string name, double price)
: name(name)
, price(price)
{ }
</code></pre></li>
</ol>
",3
37640555,37640493,3,"<p>There's too much wrong with your code to describe it in prose, so let me present a fixed implementation, and I leave it to you to spot the difference:</p>

<pre><code>#include &lt;string&gt;

class Car
{
private:
    static constexpr double kNoPrice = -1.0;
    static constexpr const char* kNoName = ""[no name]"";

public:
    // Main constructor: constructs a car with the given name and price.
    Car(std::string name, double price)
    : name_(std::move(name))
    , price_(price)
    {}

    // Convenience constructors:
    Car() : Car(kNoName, kNoPrice) {}
    Car(std::string name) : Car(std::move(name), kNoPrice) {}

    // Accessors:
    const std::string&amp; getBrand() const { return name_; }
    void setBrand(std::string name) { name_ = std::move(name); }

    double getPrice() const { return price_; }
    void setPrice(double price) { price_ = price; }

private:
    std::string name;
    double price;
};
</code></pre>

<p>Some random notes, in no particular order:</p>

<ul>
<li>Use correct names. It's <code>std::string</code>, not <code>string</code>, <code>mate</code> or <code>buddy</code>. Never ever be abusing namespace std.</li>
<li>Include headers for external names that you need.</li>
<li>Reading uninitialized values is undefined behaviour, so none of your constructors should leave fields uninitialized (like <code>price_</code>).</li>
<li>Give private members consistent names (e.g. <code>foo_</code> in my example).</li>
<li>Accessors should be const-correct.</li>
<li>Convenience constructors should delegate to one single work-horse constructor.</li>
<li>Pick sensible defaults for initial values of defaulted fields and make them discoverable.</li>
<li>Use move semantics when taking ownership of dynamically managed data (strings, dynamic containers, etc.).</li>
</ul>
",0
45286921,21691771,0,"<pre><code>#include&lt;iostream&gt;
#include&lt;cmath&gt;

using namespace std;

int main()
{

     double  YearlyInt, LoanAmount, Payment, AmountPaid, MonthlyInt, NumPayments;




     cout &lt;&lt; ""Enter the loan amount (LoanAmount) --&gt; "";
     cin &gt;&gt; LoanAmount;

     cout &lt;&lt; ""Enter the YEARLY interest rate as a percentage --&gt; "";
     cin &gt;&gt; YearlyInt;

     cout &lt;&lt; ""Enter number of payments --&gt; "";
     cin &gt;&gt; NumPayments;



     cout &lt;&lt; ""Loan amount: "" &lt;&lt; LoanAmount &lt;&lt; endl;
     cout &lt;&lt; ""Yearly Interest Rate: "" &lt;&lt; YearlyInt &lt;&lt; ""%"" &lt;&lt; endl;
     cout &lt;&lt; ""Number of Payments: "" &lt;&lt; NumPayments &lt;&lt; endl;

     MonthlyInt = (YearlyInt/100.0) / 12;

     Payment = MonthlyInt * pow (( 1 + MonthlyInt ), NumPayments) /  (pow(( 1   + MonthlyInt), NumPayments) -1)  * LoanAmount;
     cout &lt;&lt; ""Monthly Payment:  "" &lt;&lt; Payment &lt;&lt; endl;


     //correction to Amount paid Value
     AmountPaid = Payment * NumPayments;
     cout &lt;&lt; ""Amount Paid Back: "" &lt;&lt; AmountPaid &lt;&lt; endl;
     cout &lt;&lt; ""Interest Paid:  "" &lt;&lt; (AmountPaid - LoanAmount) &lt;&lt; endl;


     cout &lt;&lt; ""Program Over"" &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;

     cout &lt;&lt; ""Press Enter to end --&gt;"" &lt;&lt; endl;



     return 0;
}
</code></pre>
",1
40784990,40784322,0,"<blockquote>
  <p>Is this true that {object} always produces temporary object?</p>
</blockquote>

<p>No (read on).</p>

<p>Both snippets are valid (you should use an up-to-date compiler) and will compile successfully.</p>

<p>The <code>{p}</code> case falls into <code>[over.match.list]/p1</code></p>

<blockquote>
  <p>When objects of non-aggregate class type T are list-initialized such that [dcl.init.list] specifies that overload resolution is performed according to the rules in this section, overload resolution selects the constructor in two phases:</p>
  
  <p>(1.1)
  Initially, the candidate functions are the initializer-list constructors ([dcl.init.list]) of the class T and the argument list consists of the initializer list as a single argument.</p>
  
  <p><strong>(1.2)</strong>
  If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class T and the argument list consists of the elements of the initializer list.</p>
</blockquote>

<p>Specifically in (1.2), while <code>{m}</code> is a list initialization for the other case.</p>
",0
40785248,40784322,2,"<blockquote>
  <p>What is the type of <code>{object}</code>?</p>
</blockquote>

<p>That depends on the context. In some situations, such as when constructing a type with a <code>std::initializer_list</code> parameter, it'll be of type <code>std::initializer_list&lt;decltype(object)&gt;</code>. In others, it'll be used to initialize members of an aggregate or some other type, in which case the syntactic form <code>{object}</code> doesn't <em>have</em> a type <em>per se</em>.</p>

<blockquote>
  <p>Is this true that <code>{object}</code> always produces temporary object?</p>
</blockquote>

<p>No, and in your case it shouldn't. This was <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1288"" rel=""nofollow noreferrer"">a bug in the C++11 spec</a> relating to the ordering of clauses specifying list initialization. The old wording meant that your call resulted in the construction of a temporary (which is ill-formed due to the non-const reference parameter), but under the new rules, the reference binds to the single initializer list element. Your old compiler implements the old wording, whereas <a href=""http://coliru.stacked-crooked.com/a/39564c68854632dd"" rel=""nofollow noreferrer"">newer compilers</a> implement the fixed behaviour.</p>

<blockquote>
  <p>Here there is no problem at all, so what is the difference between {m} from the first example and {p} from the second?</p>
</blockquote>

<p>The difference is that <code>{m}</code> is used to initialize the <code>M</code> parameter of <code>foo</code> (invalid under the old wording), but <code>{p}</code> initializes the <code>I</code> member. As such, <code>p</code> is taken as the argument to the <code>I</code> constructor, binds to the <code>M&amp;</code> parameter, and since <code>p</code> is an lvalue, everything is fine and dandy.</p>
",0
37450630,37450566,0,"<blockquote>
  <p>Is there an efficient technique to implement CallerA counting result
  from CalleeB?</p>
</blockquote>

<p>Sure, CallerA just needs to keep track of which results he has received back, so that when he receives all 5 results in a set he can act on them.</p>

<p>The way I would do it would be to have CallerA maintain an <code>unordered_map&lt;int, Result&gt;</code>, and whenever a result is received from a CalleeB, place it into the unordered_map and then check to see if the other 4 results for that set are also present in the unordered_map; if so, remove them from the unordered_map and process them.</p>

<p>Alternatively, you could keep an 10-item array of 5-item sub-arrays of results, and place each result into the appropriate slot (slotIdx=i%5) in the appropriate sub-array (arrayIdx=i/5) as it comes in.  After placing a result in the appropriate sub-array, you could either check the slots of the sub-array to see if they are all populated, or alternatively you could increment a counter specific to that sub-array, and when the counter gets to 5, the array must be full.</p>
",2
35247486,35247364,3,"<p>Unfortunately, there is no ""nice solution"". C++ does not have a reputation for being ""nice"".</p>

<p>The best thing you could do here is to use a nested constructor, so at least you won't have to do any additional work the constructor has to do:</p>

<pre><code>A(const std::string &amp;name, const char *s)
    : A(name, std::string(s))
{
}
</code></pre>

<p>Then, if your actual constructor here needs to do any work didn't show (although you didn't quite show a <a href=""https://stackoverflow.com/help/mcve"">Minimal, Complete, and Verifiable Example</a>, your effort was good enough), there won't be any additional code duplication.</p>

<p>On second thought, this might be the ""nice"" solution you're looking for. It can be argued that this is exactly what nested constructors are for.</p>
",1
36339798,36339670,1,"<p><code>std::string</code> is an object in C++, then implicit constructors get char pointers as string to support C's string literals.
If you care about memory a <code>std::ostringstream</code> can be more useful that the + operator:</p>

<pre><code>std::ostringstream result(""hello"");
result &lt;&lt; "" world!"";
std::cout &lt;&lt; result.str();
//prints ""hello world!""
</code></pre>
",0
35296427,35296262,3,"<p>You cannot change the return type based on the value of an argument. One option is to use two overloaded functions using tag types to differentiate them.</p>

<pre><code> const std::vector&lt;int&gt;&amp; getMember(std::true_type tag) { return _member; }
 std::vector&lt;int&gt; getMember(std::false_type tag) { return _member; }
</code></pre>

<p>You need to add</p>

<pre><code>#include &lt;type_traits&gt;
</code></pre>

<p>to use <code>std::true_type</code> and <code>std::false_type</code>.</p>

<p>Of course, you have to call them using a <code>std::true_type</code> or <code>std::false_type</code> as arguments.</p>

<pre><code>Class c;
auto ret1 = c.getNumber(std:::true_type{});
auto ret2 = c.getNumber(std:::false_type{});
</code></pre>
",3
35296459,35296262,9,"<p>A function can only have one return type, so no, it can't be done.<br>
It's also not clear what purpose it coud possibly serve.</p>

<p>Normally, you would provide the function that returns a const reference:</p>

<pre><code>const std::vector&lt;int&gt;&amp; getMember() const { return _member; }
</code></pre>

<p>and then your users can choose if they want a reference:</p>

<pre><code>const std::vector&lt;int&gt;&amp; aReference = anObject.getMember();
</code></pre>

<p>or a copy:</p>

<pre><code>std::vector&lt;int&gt; aCopy = anObject.getMember();
</code></pre>
",0
39109570,27198584,2,"<p>I was looking for this <code>erand48</code> method as well (with Visual Studio 2015) because </p>

<ol>
<li>it is thread safe, </li>
<li>caller must keep and pass the state, </li>
<li>it is pure C (don't ask me which version, it is old enough for me). </li>
</ol>

<p>So instead of providing a (C++) alternative, I will answer the question by providing a possible implementation itself.</p>

<pre><code>#pragma once

#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

#define RAND48_SEED_0   (0x330e)
#define RAND48_SEED_1   (0xabcd)
#define RAND48_SEED_2   (0x1234)
#define RAND48_MULT_0   (0xe66d)
#define RAND48_MULT_1   (0xdeec)
#define RAND48_MULT_2   (0x0005)
#define RAND48_ADD      (0x000b)

unsigned short _rand48_seed[3] = {
    RAND48_SEED_0,
    RAND48_SEED_1,
    RAND48_SEED_2
};
unsigned short _rand48_mult[3] = {
    RAND48_MULT_0,
    RAND48_MULT_1,
    RAND48_MULT_2
};
unsigned short _rand48_add = RAND48_ADD;

void _dorand48(unsigned short xseed[3]) 
{
    unsigned long accu;
    unsigned short temp[2];

    accu = (unsigned long)_rand48_mult[0] * (unsigned long)xseed[0] +
        (unsigned long)_rand48_add;
    temp[0] = (unsigned short)accu;        /* lower 16 bits */
    accu &gt;&gt;= sizeof(unsigned short) * 8;
    accu += (unsigned long)_rand48_mult[0] * (unsigned long)xseed[1] +
        (unsigned long)_rand48_mult[1] * (unsigned long)xseed[0];
    temp[1] = (unsigned short)accu;        /* middle 16 bits */
    accu &gt;&gt;= sizeof(unsigned short) * 8;
    accu += _rand48_mult[0] * xseed[2] + _rand48_mult[1] * xseed[1] + _rand48_mult[2] * xseed[0];
    xseed[0] = temp[0];
    xseed[1] = temp[1];
    xseed[2] = (unsigned short)accu;
}

double erand48(unsigned short xseed[3])
{
    _dorand48(xseed);
    return ldexp((double)xseed[0], -48) +
        ldexp((double)xseed[1], -32) +
        ldexp((double)xseed[2], -16);
}

double drand48(void)
{
    return erand48(_rand48_seed);
}

long lrand48(void) 
{
    _dorand48(_rand48_seed);
    return ((long)_rand48_seed[2] &lt;&lt; 15) + ((long)_rand48_seed[1] &gt;&gt; 1);
}

long nrand48(unsigned short xseed[3]) 
{
    _dorand48(xseed);
    return ((long)xseed[2] &lt;&lt; 15) + ((long)xseed[1] &gt;&gt; 1);
}

long mrand48(void) 
{
    _dorand48(_rand48_seed);
    return ((long)_rand48_seed[2] &lt;&lt; 16) + (long)_rand48_seed[1];
}

long jrand48(unsigned short xseed[3]) 
{
    _dorand48(xseed);
    return ((long)xseed[2] &lt;&lt; 16) + (long)xseed[1];
}

void srand48(long seed) 
{
    _rand48_seed[0] = RAND48_SEED_0;
    _rand48_seed[1] = (unsigned short)seed;
    _rand48_seed[2] = (unsigned short)(seed &gt;&gt; 16);
    _rand48_mult[0] = RAND48_MULT_0;
    _rand48_mult[1] = RAND48_MULT_1;
    _rand48_mult[2] = RAND48_MULT_2;
    _rand48_add = RAND48_ADD;
}

unsigned short *seed48(unsigned short xseed[3]) 
{
    static unsigned short sseed[3];

    sseed[0] = _rand48_seed[0];
    sseed[1] = _rand48_seed[1];
    sseed[2] = _rand48_seed[2];
    _rand48_seed[0] = xseed[0];
    _rand48_seed[1] = xseed[1];
    _rand48_seed[2] = xseed[2];
    _rand48_mult[0] = RAND48_MULT_0;
    _rand48_mult[1] = RAND48_MULT_1;
    _rand48_mult[2] = RAND48_MULT_2;
    _rand48_add = RAND48_ADD;
    return sseed;
}

void lcong48(unsigned short p[7]) 
{
    _rand48_seed[0] = p[0];
    _rand48_seed[1] = p[1];
    _rand48_seed[2] = p[2];
    _rand48_mult[0] = p[3];
    _rand48_mult[1] = p[4];
    _rand48_mult[2] = p[5];
    _rand48_add = p[6];
}
</code></pre>
",0
39674585,39674553,7,"<p>Your string size is zero from start so you are not allowed to access index zero. Instead do</p>

<pre><code>s = ""a"";
</code></pre>

<p>Now the string has size 1 and It is allowed to access s[0]</p>

<p>In general you may index from zero to size-1 but only when size >= 1</p>
",0
39675145,39674553,1,"<pre><code>std::string s; // s is default constructed (s.length() returns 0)
//s[0] = 'a'; // modifying elements that are out of bounds causes undefined behavior
s.resize(1);
s[0] = 'a'; // OK, s.length() is 1
std::cout &lt;&lt; s &lt;&lt; std::endl;
</code></pre>
",0
45067631,20024690,1,"<p>There's also <a href=""https://github.com/martinmoene/byte-lite"" rel=""nofollow noreferrer"">byte_lite</a>, compatible with C++98, C++11 and later.</p>
",0
35278474,35278448,0,"<p>In <code>SetB</code> your <code>A</code> variable is a temporary that is destroyed when the function returns.</p>
",2
35278671,35278448,0,"<p>The way it is written in your snippet, your code won't compile, because <code>B</code> has no method <code>GetA()</code>.  From your use case (the code in <code>main()</code>), I suspect you <em>either</em> want <code>B</code> to inherit from <code>A</code>:</p>

<pre><code>class B : public A
{
public:
  B() {];
  void SetB()
  {
    SetA();
  }
};
</code></pre>

<p>although that doesn't make too much sense, because in this case you could just call <code>b.SetA()</code> directly.  <em>Or</em>, you want an object of type <code>A</code> as a <em>member</em> of <code>B</code>:</p>

<pre><code>class B
{
public:
  void SetB()
  {
    a.SetA();
  }
  int GetA()
  {
    return a.GetA();
  }
private:
  A a;
};
</code></pre>

<p>But it's a bit hard to tell from your snippet what you're actually trying to achieve.</p>

<p>Also, you probably want your <code>Get¡­()</code> methods to be <code>const</code>.</p>
",0
35280068,35278448,0,"<p>If you;re trying to achieve what I think you're trying to achieve then you're nearly there, it is just that you are creating two versions of A, one on the main stack, and one that is a temporary inside B::SetA()</p>

<p>try passing A as a reference parameter to B, so that there is only one version of A.</p>

<pre><code>void SetB(A&amp; a)
{
     a.SetA();
} 
</code></pre>

<p>then your calling code would be:</p>

<pre><code>A a;
B b;
b.SetB(a);
cout &lt;&lt; a.GetA();
</code></pre>

<p>Alternatively, pass a in the constructor of B and store A as a reference member in B;</p>
",0
35214463,35214146,2,"<ol>
<li><code>Node</code>'a default constructor is called to construct an anonymous <code>Node</code> object.</li>
<li><code>Node</code>'s copy constructor is called to copy-initialize <code>myNode</code>.</li>
<li>You leak one <code>Node</code> worth of memory, because the pointer returned by <code>new</code> goes out of scope as soon as the statement ends.  You can therefore never <code>delete</code> the <code>Node</code> you <code>new</code>ed.</li>
</ol>

<p><code>Node::operator=</code> is not invoked, because you are performing copy-initialization, which uses the copy constructor.  Something like:</p>

<pre><code>Node myNode;
myNode = Node();
</code></pre>

<p>Would call <code>Node::operator=</code> instead of the copy constructor, since you're assigning to <code>myNode</code> after it has been constructed.</p>
",0
35214478,35214146,4,"<p><code>new Node()</code> - creates a new dynamically-allocated <code>Node</code> object. Yields a pointer to the new <code>Node</code>.</p>

<p><code>*</code> - given a pointer, yields the thing it points to (as an lvalue).</p>

<p><code>Node myNode =</code> - creates a new <code>Node</code> which is a local variable, and passes whatever's on the right side of the <code>=</code> to its constructor.</p>

<p>The overall effect: create a new local variable <code>Node</code>, create a dynamically-allocated <code>Node</code>, and copy the dynamic one to the local one. Additionally, you have no way to ever destroy the dynamic one, so this will cause a memory leak.</p>
",0
46057618,46057484,1,"<p>Your <code>operator&lt;&lt;</code> is a free function. As such it is neither inherited nor otherwise treated different than every other free function (regardless of the friendship). </p>

<p>Now, when the compiler processes the statement <code>cout &lt;&lt; obj3</code> the usual overload resolution takes place. In order to do so, the types of the arguments are inspected, which in this case are <code>std::ostream</code> and <code>Derived</code>. Next, all available functions are considered and the compiler checks whether they can accept arguments of these types. Since <code>Derived</code> inherits <code>Base</code> and an up-cast is implicit (may be performed by the compiler without you explicitly stating that), every function that takes a <code>Base</code> (or <code>const</code>/non-<code>const</code> pointer/reference to <code>Base</code>) may also take a <code>Derived</code> and is thus a valid match. This exactly is the case here for your <code>operator&lt;&lt;</code>.</p>

<p>Next, all matching overloads are ordered from best match to worst (but still valid) match. The quality of a match is hereby specified by the programming language. If there is a single best match, that one is chosen. In cases where two or more overloads are equally good, overload resolution is ambiguous and the compiler cannot decide which one to chose. In your particular case, there is only a single function, that one is chosen.</p>

<p>Would you add an additional function <code>ostream&amp; operator&lt;&lt;(ostream&amp;, const Derived&amp;)</code>, that one would be chosen by the compiler, as it is a better match for arguments of type <code>std::ostream</code> and <code>Derived</code>. </p>
",5
46057646,46057484,2,"<p>There's nothing strange going on here.</p>

<p>Indeed, <code>operator&lt;&lt;</code> is a free function that is not part of <code>Base</code>, <code>Base</code> only specifies that that function is a friend of said class. </p>

<p>Then you proceed to call this function and supply it with a <code>Derived</code> object. A <code>Derived</code> object <em>is</em> a <code>Base</code> object too and thus the specified overload for <code>operator&lt;&lt;</code> is valid. This has nothing to do with inheriting the function or not and has nothing to do with <code>friend</code>.</p>

<p>Try this with any other free function taking a <code>Base</code> and it'd be equally valid.</p>
",0
38501179,38500374,1,"<p><code>delete</code> doesn't have to change the memory your pointer points to. What it actually does is implementation specific.</p>

<p>What <code>delete</code> needs to do is to deconstruct any object at the given address and return the associated memory to the allocation pool. Some debugger might overwrite the value of a variable when freed, but for trivial types no special deconstruction needs to take place - the memory can be returned to the pool as-is. The pointer isn't changed either: after <code>delete p</code> we call <code>p</code> a <em>dangling pointer</em> that holds an address to freed memory. All access through that pointer is undefined behaviour.</p>

<p>Since handling raw pointers and especially dangling pointers is error prone, it's good to know the C++ <a href=""https://stackoverflow.com/q/106508/3426025"">smartpointers</a>, e.g. <code>unique_ptr</code>:</p>

<pre><code>std::unique_ptr&lt;int&gt; p;        // initialised to nullptr
p = std::make_unique&lt;int&gt;(13); // new int with value 13
p = std::make_unique&lt;int&gt;(37); // deleted previous int, assigned new int with value 37
// optional (when p goes out of scope its pointee is deleted automatically)
p.reset();                     // deleted the int and reset p to nullptr
</code></pre>
",0
37640836,37640809,3,"<p>Because of <a href=""http://en.cppreference.com/w/cpp/language/operator_precedence"" rel=""nofollow""><em>operator precedence</em></a> the expression</p>

<pre><code>*m[index].push_back(root)
</code></pre>

<p>is the same as</p>

<pre><code>*(m[index].push_back(root))
</code></pre>

<p>In other words, you try to dereference what the <code>push_back</code> function returns, and since it doesn't returns anything that can be referenced (it doesn't return anything at all) you get a compiler error.</p>

<p>What you want is</p>

<pre><code>(*m)[index].push_back(root)
</code></pre>
",0
37640838,37640809,1,"<p>It's about operator precedence. You would have to deference the pointer first, to get at the map</p>

<pre><code>(*m)[index].push_back(root);
</code></pre>
",0
46618187,46617535,2,"<p>It is probably better to avoid the C++ IO system and use the C memory mapped IO system.  You will have to add in error handling code but this should give you a start.</p>

<pre><code>/// Access a file using the mmap/munmap functions
///
class mmap_file
{
private:
  char * data_;
  std::size_t size_;
  int fd_;

public:  
  ~mmap_file()
  {
     ::munmap( this-&gt;data_, this-&gt;size_ );
     ::close( this-&gt;fd_ );
  }
  mmap_file( std::string fname ): data_( 0 )
    , size_( 0 )
    , fd_( -1 )
  {
     this-&gt;fd_ = ::open( fname.c_str(), O_RDWR );
     ::off_t tmp = ::lseek( this-&gt;fd_, 0, SEEK_END );
     this-&gt;size_ = ( size_t )tmp;
     tmp = ::lseek( this-&gt;fd_, 0, SEEK_SET );
     this-&gt;data_ = ::mmap( NULL, this-&gt;size_, PROT_WRITE
                         , MAP_PRIVATE, this-&gt;fd_, 0 );
  }

  // Is object valid?
  bool is_valid() const
  {
    return (char*)(0) != this-&gt;data_;
  }

  // Access the data of the object.
  char* const data()
  {
    return this-&gt;data_;
  }

  // What is the size of the object (in bytes)
  std::size_t size() const
  {
    return this-&gt;size_;
  }
};
</code></pre>

<p>Then</p>

<pre><code>mmap_file mmfile( ""some_filename"" );
if (mmfile.is_valid())
{
  for( char* p = mmfile.data(); p != mmfile.data() + mmfile.size(); ++p )
  {
    if( *p == 'Q' ) *p = 'X';
  }
}
</code></pre>

<p>This allows you to read and write the file from the same object. The C++ iostream is more designed to read from one object and write to another which is not so useful for editing in place.  In addition the memory mapped IO uses the computer's memory paging system to handle reading and writing to disk making this efficient on very large files.</p>

<p>You could improve the shown class by adding <code>begin</code> and <code>end</code> methods, then the shown for loop can be replaced with <code>std::replace</code>.</p>

<p><strong>NOTE</strong> Because this uses the OS memory paging system it will recognise which pages have had alterations and which not and automatically only save altered pages to disk (with generally a 4096 byte granularity).  You can do this manually with the other manual buffering answers but it requires more work from you.</p>
",0
46617570,46617535,1,"<p><strong>Your code is good enough.</strong> Don't forget to compile it with optimizations enabled (e.g. <code>g++ -O2 -march=native</code> with <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a>).</p>

<p>Some implementations of C++ standard libraries are done above C standard library. Then perhaps coding your thing in C (with <a href=""http://man7.org/linux/man-pages/man3/getline.3.html"" rel=""nofollow noreferrer"">getline(3)</a>) might be very slightly faster.</p>

<p>Perhaps using <a href=""http://en.cppreference.com/w/cpp/algorithm/replace"" rel=""nofollow noreferrer"">std::replace</a> might be slightly faster.</p>

<p><strong>The bottleneck remains the disk IO</strong> itself (and the hardware!) and you won't change that. Check with <a href=""http://man7.org/linux/man-pages/man1/time.1.html"" rel=""nofollow noreferrer"">time(1)</a> that your program is I/O bound (or spend a lot of time in system CPU time, e.g. doing system calls). If you can afford it, get some better hardware (e.g. SSD disks if you have spinning hard disks).</p>

<p>On Linux, you might use low level system calls like <a href=""http://man7.org/linux/man-pages/man2/posix_fadvise.2.html"" rel=""nofollow noreferrer"">posix_fadvise(2)</a>. You could avoid standard library functions and use directly system calls like <a href=""http://man7.org/linux/man-pages/man2/read.2.html"" rel=""nofollow noreferrer"">read(2)</a> (with a large enough buffer of e.g. 64Kbytes or one megabyte) and <a href=""http://man7.org/linux/man-pages/man2/write.2.html"" rel=""nofollow noreferrer"">write(2)</a>. If you just need to replace characters in place (without changing the file size) e.g. replace <code>Q</code>by <code>A</code>, that could be (very slightly) faster.</p>

<p>On most computers (except costly servers having a terabyte of RAM), a 66 Gbyte file don't stay in  the <a href=""https://en.wikipedia.org/wiki/Page_cache"" rel=""nofollow noreferrer"">page cache</a>. So the problem is IO bound.</p>

<p>But if, as I suspect, your code is I/O bound and spend most of its time doing I/O (e.g. waiting for the disk or running system calls), improvement of your code won't really matter. You'll win at most a few percent of elapsed real time (which is what actually matters to you). You could perhaps even use existing commands like <a href=""http://man7.org/linux/man-pages/man1/sed.1.html"" rel=""nofollow noreferrer"">sed(1)</a> to get the work done.</p>

<p>Remember that IO on spinning disk takes a dozen of milliseconds (per sectors of few kilobytes); with an SSD it could be a hundred microseconds. CPU can process a word of 8 bytes in a nanosecond.</p>
",1
46617581,46617535,3,"<p>If you want to replace the characters <em>in the file</em> and not only in the data you read, then it's not as simple as one would think.</p>

<p>The simplest and probably also quickest way is to read the data in chunks into memory, replace the data in the memory chunk, and write it out to a temporary file. Then when done, you rename the temporary file as the original file.</p>
",1
46617666,46617535,4,"<p>You could use something like this which I would think would be faster.</p>

<pre><code>std::ifstream ifs(""input_file_name"", std::ios::binary);
std::ofstream ofs(""output_file_name"", std::ios::binary);

char buf[4096]; // larger = faster (within limits)

while(ifs.read(buf, sizeof(buf)) || ifs.gcount())
{
    // replace the characters
    std::replace(buf, buf + ifs.gcount(), 'Q', 'X');

    // write to a new file
    ofs.write(buf, ifs.gcount());
}
</code></pre>

<p>If you don't want to produce a separate file (more dangerous) then you could modify the original file something a bit like this <strong>(untested code)</strong>:</p>

<pre><code>std::fstream fs(""input_file_name"", std::ios::in|std::ios::out|std::ios::binary);

char buf[4096]; // larger = faster (within limits)

auto beg = fs.tellg();

while(fs.read(buf, sizeof(buf)) || fs.gcount())
{
    auto end = fs.tellg();

    // replace the characters
    std::replace(buf, buf + fs.gcount(), 'Q', 'X');

    // return to start of block
    fs.seekp(beg);

    // overwrite this block
    fs.write(buf, fs.gcount());

    // shift old beginning to the end
    beg = end;

    // go to new beginning to start reading the next block
    fs.seekg(beg);
}
</code></pre>
",4
37638617,37638207,3,"<p>Nope, the pointer to both the in-built and as well as class type have indeterminate value and will lead to undefined behavior. In C or C++, if you write</p>

<pre><code>int a;
</code></pre>

<p>or</p>

<pre><code>int *b;
MyClass *c;
</code></pre>

<p>then a, b, c will have indeterminate value (or garbage value). If you want to initialize them as <code>nullptr</code> then you can declare them <code>static</code> (not a good approach) or initialize them explicitly as <code>int a = 10</code> or <code>int *b = nullptr</code>.</p>

<p>You should always initialize pointers to <code>NULL</code> or <code>nullptr</code> (if your compiler supports C++11, assigning NULL to pointers is <a href=""https://stackoverflow.com/q/1282295/5006740"">deprecated</a>).</p>
",1
36430168,36429837,0,"<p>Use the vector::emplace_back(Args...) method, which avoids any unnecessary copy's. 
If a constructor for a vertex exists that accepts some type of string argument for a name, that would be ideal. If it does not exist, i would highly recommend adding one just for this, as adding a new vertex with a specific name seems like a common operation. </p>

<pre><code>vector.emplace_back(...,""My Name"",...);
</code></pre>

<p>If no such constructor exists i would use the second method you listed. When using new like this <code>MyVector.push_back(new element)</code>, you will have to remember to delete it. On top of that, their is a possibility of a memory leak if an exception is thrown when the object is being constructed. If you really need to use the ""new"" method consider using an appropriate smart pointer. </p>
",0
36429911,36429837,0,"<p>Option one will allocate the vertex on the heap while option two will allocate it locally on the stack. </p>

<p>This really depends on your use case, we need more context.</p>
",0
36429918,36429837,0,"<p>The two aren't exactly comparable. In (1) you are creating an object on the heap while the other is creating on the stack and copying to the vector (so yes you are making 2 copies). Really depends on your requirements and the context.</p>

<p>(1) would definitely take slightly more time due to heap allocation but it's a more persistent object.</p>
",0
36429998,36429837,2,"<p>Both a bad (and <code>.push_back(new vertex)</code>) is especially bad (and it won't work with <code>std::vector&lt;vertex&gt;</code> because it returns pointer).</p>

<p>Here what you get:</p>

<pre><code>vertices.push_back(vertex());             // construct temporary object
                                          // copy it to vector
                                          // destroy temporary object
vertices[vertices.size()-1].name = name;
</code></pre>

<p>vs.</p>

<pre><code>vertex v;                                 // construct temporary
v.name = name;                               
vertices.push_back(v);                    // copy temporary object with a string
</code></pre>

<p>Assuming that copying string is not cheap, 2nd option is worse. However, if your compiler decides to apply <a href=""http://en.cppreference.com/w/cpp/language/copy_elision"" rel=""nofollow"">Copy elision</a> optimizations for the first case (which it is eligible to do since <code>vertex()</code> is a nameless temporary), then no temporary object would be introduced.</p>

<p>Cleaner solution came with C++11 which allow to construct objects directly in vector's memory without using temporary objects</p>

<pre><code>vectices.emplace_back(/* vertex ctor parameters */);  // no temp objects here
vertices.last().name = name;
</code></pre>
",3
36291419,36290508,0,"<p>Consider how this can be achieved with <a href=""https://github.com/haptork/easyLambda"" rel=""nofollow"">easyLambda</a> library.</p>

<pre><code>ezl::rise(
  ezl::readFile&lt;string, array&lt;int, 3&gt;, array&lt;string, 2&gt;&gt;(fileName)
    .colSeparator(""|""))
.map&lt;2&gt;([](array&lt;int,3&gt; cardPinBal) { // 2nd column selected for lambda
  if (cardPinBal[0] == 9322) cardPinBal[2] = newBal;
  return cardPinBal;
}).colsTransform().dump(""updatedInfo.txt"")
.run();
</code></pre>

<p>Here, readFile reads the data file, the types are for columns on every row. It is implemented using <code>readLine</code> for reading rows and string splitting on colSeparators for each row. The strings are converted to types using boost <code>lexical cast</code> however <code>stoi</code> and family can work equally well.
The function in the map is applied to every row (for selected cols, here 2nd col). ColsTransform makes sure that the columns update with returned value without reordering.</p>

<p>You may consider using the library for general data processing tasks.</p>
",0
43747864,43747839,4,"<p>Wrapping declarations in <code>extern ""C""</code> doesn't transform them into C code. It just affects name mangling, allowing for linking between the two languages.</p>

<p>The feature you're using doesn't exist in C++, so you can't use it here. C++ simply sees no matching function.</p>

<p>Instead of wrapping entire <code>#include</code> statements in <code>extern ""C""</code> and hoping for the best, a C header should be <em>designed</em> to be compatible with C++ callers; such code will typically have <code>extern ""C""</code> at appropriate locations in the header itself, and will avoid C-only features like this.</p>

<p>In short, unless you can ""fix"" the header, you're out of luck.</p>
",6
44736012,20883098,0,"<p>because there also have a Polygon defined in wingdi.h</p>

<p><a href=""https://i.stack.imgur.com/NyXMH.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/NyXMH.jpg"" alt=""enter image description here""></a></p>

<p>THE SOLUTION IS Put NOGDI in preprocessor. In Visual Studio Project Properties -> Configuration Properties -> C/C++ -> Preprocessor -> Preprocessor Definitions -> add NOGDI.
<a href=""https://i.stack.imgur.com/790pk.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/790pk.jpg"" alt=""enter image description here""></a></p>
",1
35283829,35283773,1,"<p>You have not included <code>foo.cpp</code> in your compile command, So this is why you cant link the functions. You need to use the command line argument:</p>

<pre><code>g++ main.cpp foo.cpp -o main
</code></pre>

<p>This allows the compiler to find the functions in <code>foo.cpp</code>.</p>
",0
35283898,35283773,2,"<blockquote>
  <p>Also, another question: in Foo.cpp, why do I need Foo::Foo() etc? I
  used namespace std, so why can't I just say Foo()?</p>
</blockquote>

<p>You need to write <code>Foo::Foo()</code> in <code>foo.cpp</code> because you are defining the constructor outside the body of the <code>Foo</code> class which is present in <code>foo.h</code>.
<code>std</code> is the standard namespace and using that in no way absolves you from referring to the <code>Foo</code> class you have created since its not a part of the standard namespace</p>
",3
35284129,35283773,4,"<p>Looking at the way you compile, you are only providing only one source file (main.cpp) whereas the correct way is to specify all the source files. In your case, it would be:</p>

<pre><code>g++ main.cpp foo.cpp -o executable
</code></pre>

<p>The ""undefined reference"" error is a error thrown at the linking stage when the linker can't resolve the names correctly because, you didn't link the source files properly like above.</p>

<p>Additionally, make sure that when you declare a function prototype, the implementation of the function should also have the same signature. In your example, you provided the function prototypes as:</p>

<pre><code>void transmitMsg(char *);
void addCity(std::string, std::string);
</code></pre>

<p>But your implementation of those functions don't have the correct signature. They should have been:</p>

<pre><code>void Foo::transmitMsg(char *){}

void Foo::addCity(std::string, std::string){}
</code></pre>

<blockquote>
  <p>why do I need Foo::Foo() etc?</p>
</blockquote>

<p>Because Foo() is a function of the class Foo.</p>

<blockquote>
  <p>I used namespace std, so why can't I just say Foo()?</p>
</blockquote>

<p>When you make a call to using namespace ; all symbols in that namespace will become visible without adding the namespace prefix. A symbol may be for instance a function, class or a variable.</p>

<p>Foo is not a namespace like ""std"". It is a user-defined class. </p>
",0
46980972,46980769,3,"<pre><code>myclass&lt;int&gt; obj = myclass&lt;int&gt;(2, 3);
</code></pre>

<p>On this line, <code>myclass&lt;int&gt;</code> is move-constructed from a temporary <code>myclass&lt;int&gt;</code>, using the automatically-generated move constructor.</p>

<p>You can see that this is happening by deliberately preventing the compiler from generating the move constructor, by putting a line such as</p>

<pre><code>myclass(myclass&amp;&amp;) = delete;
</code></pre>

<p>in the <code>myclass</code> definition, and observing the resulting error.</p>

<p>But at no point does this require <code>myclass</code> to be default constructed -- the temporary on the right-hand side is constructed using the two-argument constructor, and the move construction happens in one step after that -- using the move (or copy) constructor like this is not the same as default constructing <code>obj</code> followed by copy/move assignment.</p>

<p>EDIT: The above applies to C++11 and 14. If you're using an earlier version of C++, <code>obj</code> will be copy constructed rather than move constructed, but the same applies -- at no point does the default constructor need to be called.</p>

<p>In C++17, <a href=""http://en.cppreference.com/w/cpp/language/copy_elision"" rel=""nofollow noreferrer"">guaranteed copy elision</a> means that <code>obj</code> will be constructed as if you had said <code>myclass&lt;int&gt; obj(2, 3)</code> directly, i.e. <code>-fno-elide-constructors</code> will have no effect. (Thanks to Guillaume Racicot for the reminder.)</p>
",2
46614371,46614303,1,"<p>Very simply, you need an array. This is what your <code>main()</code> function might look like using one:    </p>

<pre><code>int num[5];

for (int i = 0; i &lt; 5; i++) {
    printCount(i+1, num[i]);
}
</code></pre>
",6
46614375,46614303,2,"<p>Use an array:</p>

<pre><code>int nums[5];

// initialize array elements

for (int i = 0; i &lt; 5; i++)
{
    printCount(i + 1, nums[i]);
}
</code></pre>

<p>But also you need to pass words.</p>

<p><strong>And what if sentence contains words with more than 5 letters? So using fixed-size array is not the flexible way.</strong></p>

<p>I suggest you to create a function with the following prototype. Function takes <a href=""http://en.cppreference.com/w/cpp/string/basic_string"" rel=""nofollow noreferrer"">std::string</a> and returns extracted words:</p>

<pre><code>vector&lt;vector&lt;string&gt;&gt; extractWords(const string&amp; sentence);
</code></pre>

<p>Function would return vector of vectors. Every inner vector would contain the words with the same length. Read about <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow noreferrer"">std::vector</a>.</p>
",2
46614470,46614303,0,"<p>Just modify main function by adding loop.   </p>

<pre><code>    int main()
        {
            int num1, num2, num3, num4, num5;
           int arr1[5] = {1,2,3,4,5};
           int arr2[5] = {num1,num2,num3,num4,num5};
           for(int i = 0 ; i &lt;=sizeof(arr1)-1 li++){
                printCount(arr1[i], arr2[i]);
         }      

}
</code></pre>
",0
36645926,36645510,1,"<p>Functions in C++ cannot return multiple values of their return type via a <code>return</code> statement.</p>

<hr>

<pre><code>int a, b = r(""input_a.txt"");
...
return rows, cols;
</code></pre>

<p>These 2 lines don't do what you think they do.</p>

<p>The line <code>int a, b = r(""input_a.txt"");</code> is equivalent to:</p>

<pre><code>int a;
int b = r(""input_a.txt"");
</code></pre>

<p>That is, you declare variables <code>a</code> and <code>b</code> and initialize <code>b</code> to the return value of <code>r(""input_a.txt"")</code>, while <code>a</code> remains uninitialized.</p>

<p>The line <code>return rows, cols;</code> is equivalent to:</p>

<pre><code>rows;
return cols;
</code></pre>

<p>...and is an example of <a href=""https://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow noreferrer"">comma operator</a>, which evaluates its left operand (in your case, <code>rows</code>), discards the result, then evaluates its right operand (in your case, <code>cols</code>) and returns the result of this evaluation. So, in effect, your function <code>r()</code>, as it is now, always returns a single value, <code>cols</code>.</p>

<hr>

<p>If you need to return more than one value from a function, you should consider accepting additional arguments as non-const references for you to store resulting values to, or changing the return type of your function to some <code>struct</code>, which would contain all of the values you want to return. You can find an example of both these approaches in @tobi303's <a href=""https://stackoverflow.com/a/36645711/1051764"">answer</a>.</p>
",0
36645711,36645510,8,"<p>You cannot return two values from a function that is declared to have a single <code>int</code> as return type:</p>

<pre><code>int r(string fn){
    /*...*/
    return rows,cols;  // &lt;-- this is not correct
}
</code></pre>

<p>Also the way you call this function is not behaving as you might expect:</p>

<pre><code>int a, b = r(""input_a.txt"");
</code></pre>

<p>this declares two integers and initializes the second one with the return value of the function, but the first one stays uninitialized (see <a href=""https://stackoverflow.com/a/36645926/4117728"">TerraPass answer</a> for more explanation on the comma operator).</p>

<p>You basically have two options. First option is to pass references to the function and the function assigns the results to those references:</p>

<pre><code>void r(string fn, int&amp; rows,int&amp; cols) {
    /*...*/
    rows = x;
    cols = y;
}
</code></pre>

<p>and you call it like this:</p>

<pre><code>int a,b;
r(""someString"",a,b);
</code></pre>

<p>However, in this way the caller has to ""prepare"" those return values. Imho it is more convenient to use the return value to return results from a function (sounds logical, no?). To do this you just have to define a type that encapsulates the two integers:</p>

<pre><code>struct RowAndCol { int row;int col; };

RowAndCol r(string fn) {
    /*...*/
    RowAndCol result;
    result.row = x;
    result.col = y;
    return result;
}
</code></pre>

<p>and call it like this:</p>

<pre><code>RowAndCol rc = r(""someString"");
</code></pre>

<p>Note that you could also use a <code>std::pair&lt;int,int&gt;</code> instead of defining your custom struct (see e.g. <a href=""https://stackoverflow.com/a/36647101/4117728"">molbdnilos answer</a>). However, IMHO whenever you know exactly what is contained in the pair, it is better to give it a reasonable name (e.g. <code>RowAndCol</code>) instead of using a naked <code>std::pair&lt;int,int&gt;</code>. This will also help you in case you need to add more methods to the struct later (e.g you might want to overload the <code>std::ostream&amp; operator&lt;&lt;</code> for your struct to print it on the screen).</p>

<p>PS: Actually your output does not look like it was produced by the code you are showing. Theses are some memory addresses, but in your code there is neither a pointer nor an address-of operator.</p>
",0
36647101,36645510,3,"<p>I guess you're used to Python (I peeked at your profile), but the comma does not create a pair in C++.</p>

<p>(You may not have thought about it that way, but you can only return one value from a Python function, too. If you ""return two values"", you're returning <em>one</em> pair.)</p>

<p>Fortunately, there are tuples in the standard library.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;utility&gt;


std::pair&lt;int,int&gt; r(std::string fn);

int main()
{
    std::pair&lt;int, int&gt; result = r(""input_a.txt"");
    cout &lt;&lt; ""a --- "" &lt;&lt; result.first &lt;&lt; endl;
    cout &lt;&lt; ""b --- "" &lt;&lt; result.second &lt;&lt; endl;

// Or,
    int a = 0;
    int b = 0;
    std::tie(a, b) = r(""input_a.txt"");
    cout &lt;&lt; ""a --- "" &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; ""b --- "" &lt;&lt; b &lt;&lt; endl;


}

std::pair&lt;int, int&gt; r(std::string fn)
{
    std::ifstream fin01(fn);

    // ...

    return std::make_pair(rows, cols);
}
</code></pre>
",1
43946045,43943764,0,"<p>This will be your File.h</p>

<pre><code>#ifndef FILE_H
#define FILE_H

class A
{
public:
void display();
};
#endif
</code></pre>

<hr>

<p>This will be your File.cpp</p>

<pre><code>#include &lt;iostream&gt;
#include ""File.h""

void A::display() {
std::cout&lt;&lt;""This is from first program"";
}
</code></pre>

<hr>

<p>This will be you main.cpp</p>

<pre><code>#include &lt;iostream&gt;
#include ""File.h""

int main()
{
A a1;
a1.display();
return 0;
}
</code></pre>

<p>You compile this with <code>g++ File.cpp main.cpp</code></p>
",0
36513660,36513634,2,"<p>Because the contained <code>advString</code> object (the <code>buffer</code> member) doesn't have a default constructor, you need to explicitly provide a <code>advString_stream</code> constructor to properly construct the <code>buffer</code> object.</p>

<p>Something like</p>

<pre><code>class advString_stream
{
public:
    advString_stream()
        : buffer(someArgumentHere)  // Using constructor initializer list
    {}

    ...
};
</code></pre>
",2
36513675,36513634,2,"<p>You have to declare and implement a default constructor, If you declare and implement a other contructor.</p>
",1
46971646,43333582,2,"<p>According to comments made by Barman and answer given by HairyDuck, in accordance with stringstream reference </p>

<p><a href=""http://www.cplusplus.com/reference/sstream/stringstream/stringstream/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/sstream/stringstream/stringstream/</a></p>

<p>which states that copy operator is deleted
copy (3)<br>
stringstream (const stringstream&amp;) = delete;</p>

<p>and assuming stack is std::stack which specifies that push </p>

<p>""Inserts a new element at the top of the stack, above its current top element. The content of this new element is initialized to a copy of val.""
<a href=""http://www.cplusplus.com/reference/stack/stack/push/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/stack/stack/push/</a></p>

<p>=> Do not use a stack::push with a non copyable type.</p>
",0
35216573,35216538,0,"<p>If the file is 237 GB, then iterating over it is more feasible than copying it to a memory array.</p>

<p>If you iterate, you still want to do the actual disk I/O in page sized chunks (not go to the device for every byte). But streams usually provide that kind of buffering.</p>

<p>So what you want is a mix of both.</p>
",0
45769225,45768669,0,"<p><code>p[i]*x/100)</code> is calculated multiple times and stored as <code>double</code>. Probably you want to calculate <code>p[i]*x/100.0</code> as <code>double</code>.</p>

<p>In <code>main</code> the <code>vector&lt;int&gt; p</code> you can push the values to append them. So you don't need to access the container with the indexer.
Also you might avoid the <code>for (int i</code> loop in <code>feeOrUpfront</code> with an iterator and <code>std::for_each</code>.</p>

<p>IMHO Your question would match better at <a href=""https://codereview.stackexchange.com/"">https://codereview.stackexchange.com/</a></p>
",0
44714527,44714358,0,"<p>You really need to get a hold of <code>const</code> correctness. All of your functions tell the compiler that that they can modify the passed in parameters.</p>

<p>In particular this means that this:</p>

<pre><code>Fraction f6 = Fraction(1, 2) * Fraction(2, 3) * Fraction(3, 4);
</code></pre>

<p>which the compiler has to generate code something like this:</p>

<pre><code>Fraction const tmp1 = Fraction(1, 2);
Fraction const tmp2 = Fraction(2, 3);
Fraction const tmp3 = operator*(tmp1, tmp2);
Fraction const tmp4 = Fraction(3, 4);
Fraction f6 = operator*(tmp3, tmp4);
</code></pre>

<p>Note that compiler produced temporaries are not actually <code>const</code>, but you cannot bind to them using a non-const reference (i.e. you should use <code>const &amp;</code> rather than just <code>&amp;</code> in the function prototype, or not use a reference at all), partly because if you write code that alters a temporary that subsequently disappears, it's pretty meaningless, and almost undoubtedly not what you meant to do. (Historical note: In at least one version of a fortran IV compiler - where everything is passed by non const reference - it was possible to alter the value of the numerical constant 1 because the language had no concept of constness or temporary variables, leading to much confusion).</p>

<p>But none of your arithmetic operators take <code>const</code> references (despite not actually altering their parameters), the compiler can't find an appropriate method to use and hence errors that statement.</p>

<p>Incidentally, you don't have an operator&lt;&lt; overload, and nowhere in that code sample would you actually be using it if you had one.</p>

<p>Note also your <code>print</code> method isn't <code>const</code> and it should be or you wont' be able to use it on a <code>const</code> Fraction object.</p>
",3
44714402,44714358,0,"<p>The line that fails is this one:</p>

<pre><code>Fraction f6 = Fraction(1, 2) * Fraction(2, 3) * Fraction(3, 4);
</code></pre>

<p>The reason is that anonymous temporaries cannot be modified.  This is a language feature meant to protect you from yourself, because usually if you want to modify something you want to use the result.  So your non-modifying operators need to take their arguments either by const-ref or by value.</p>
",1
42584156,42584046,2,"<p>First you need an instance of the class <code>Schema</code>, then use <code>.*</code> or <code>-&gt;*</code>, something like:</p>

<pre><code>Schema schema;

(schema.*th.fpObjHandler)(md, evd, tokenIdx);
</code></pre>

<p>Or, as you are already in a method of <code>Schema</code>:</p>

<pre><code>(this-&gt;*th.fpObjHandler)(md, evd, tokenIdx);
</code></pre>
",7
38398861,38398739,1,"<p>You seem a bit confused. None of your examples pass by value. First example passes by reference, the second passes by pointer.</p>

<p>The main differences are:</p>

<p>Pass by value <code>foo(Object object)</code>: the function gets a copy of the argument and cannot change the original.</p>

<p>Pass by reference <code>foo(Object&amp; object)</code>: the function gets a reference (not copy) to the original object and can modify it. References cannot be ""un-bound"", they always refer to a valid object (with certain exceptions which are usually bugs).</p>

<p>Pass by pointer <code>foo(Object* object)</code>: as passing by reference, except it is valid for the pointer to not refer to anything (it can be <code>nullptr</code> which is useful if you need to signal that).</p>
",7
38398871,38398739,0,"<p>When you take by reference <em>and</em> the function can be inlined, the compiler is - theoretically - not required to generate the address of the instance. Depending on your type, unary prefix <code>operator&amp;()</code> might do more than just returning <code>this</code>. Also, it's valid for a pointer to be nullptr, you should check for that (or use gsl's <code>not_null</code>).</p>
",0
46653803,46604382,1,"<p>Use <code>namespace</code>s. In your case this would translate into something like this:</p>

<pre><code>MyString/String.h
namespace my_namespace {
  class string {
    ...
  }
}
</code></pre>

<p>Now to make sure your <code>std::string</code> or any other class named <code>string</code> is not <em>accidentally</em> used instead of <code>my_namespace::string</code> (by any means, including but not limited to setting up your include paths incorrectly) you need to refer to your type using its fully qualified name, namely <code>my_namespace::string</code>. By doing this you avoid any naming clashes and are guaranteed to get a compile error if you don't include the correct header file (unless there's actually exists another class called <code>my_namespace::string</code> that is not yours). There are other ways to avoid these clashes (such as <code>using my_namespace::string</code>) but I'd rather be explicit about the types I'm using. This solution is costly however because it probably needs change all over your code base (changing all <code>strings</code> to <code>my_namespace::string</code>).</p>

<p>A somewhat less cumbersome alternative would be to change the name of the header <code>String.h</code> to something like <code>MyString.h</code>. This would quickly introduce compile errors but requires changing all your includes from <code>#include ""String.h"" into</code>#include ""MyString.h""` (Should be much less effort compared to the first option).</p>

<p>I cannot think of any other way that requires less effort as of now. Since you were looking for a solution that would work in all similar scenarios I'd go with the <code>namespace</code>s if I were you and solve the problem once and for all. This would prevent any other existing/future naming clashes that may be in you code.</p>
",4
36246512,36246483,2,"<p>You want to do this:</p>

<pre><code>srand(time(NULL));
int card = rand() % deck.size();
</code></pre>

<p><a href=""http://www.cplusplus.com/reference/cstdlib/srand/"" rel=""nofollow"">srand</a>: Initialize random number generator</p>

<p><a href=""http://www.cplusplus.com/reference/cstdlib/rand/"" rel=""nofollow"">rand</a>: Generate random number</p>
",0
34974393,34974345,0,"<p>In general, no:  you can't define or redefine <code>#pragma</code>s or their parameters.</p>

<p>However, if you are willing to modify the compiler and preprocessor's source code, you can add all kinds of features.  If you have the source code, this is a medium-complexity task.</p>

<p>Note that many <code>#pragma</code>s correspond to a command line compiler option:  If one exists that is much easier to realize.</p>
",0
34974494,34974345,1,"<p>Since this is NOT a standard <code>#pragma</code>, it is actually consumed by the preprocessor for ODB, which spits out processed C++-code for the ""real compiler"".</p>

<p>You could do something similar, by writing a program that parses the source code and modifies it. It's not something you'd hack up in five minutes, but with some libraries (such as the libclang), you could feasibly read, process and output modified source-code, and send that to the compiler proper.</p>

<p>To produce real <code>#pragma</code> for the compiler itself, you would have to modify the source code of the compiler.</p>

<p>Edit: a relatively light-weight way to produce your own full compiler that supports custom pragmas would be to start with clang, and either build your own compiler-driver, or modify the cc1_main.cpp. </p>

<p>Then use the <code>Preprocessor::addPragmaHandler()</code> to introduce your own pragmas. This would be modifying the compiler, but really without having to change the actual compiler source code - maintaining a change to the actual compiler is much harder than having a ""plugin"" that you apply to the public interfaces of the compiler source code. Even if these do change, it's not at all as ""busy"" as the list of pragmas in the compiler source itself.</p>
",3
36402226,36402154,1,"<p>You could use <a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""nofollow"">member initialize list</a> to initialize non-static member variable with specified constructor, just like what you do in class <code>derived</code>'s constructor for base subobject.</p>

<pre><code>class test
{
   public:
    test(int data ) : d(data)
                    ~~~~~~~~~
    {
    cout&lt;&lt;""test: parameter's constructor ""&lt;&lt;endl;
    }
    derived return_data()
     {
     return d;
    }

   private:
     derived d;
};
</code></pre>
",0
34975405,34975239,3,"<p>You could try this code to obtain the machine epsilon for <code>float</code> values:</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;limits&gt;
int main(){
  std::cout &lt;&lt; ""machine epsilon (float): ""
            &lt;&lt; std::numeric_limits&lt;float&gt;::epsilon() &lt;&lt; std::endl;
}
</code></pre>
",4
34976011,34975239,4,"<blockquote>
<pre><code>while(one+x != one)
</code></pre>
</blockquote>

<p>The computation of <code>one+x</code> might well be an extended precision double. The compiler is quite free to do so. In such an implementation, you will indeed see the same value for <code>iter</code> regardless of the type of <code>one</code> and <code>x</code>.</p>

<p>The following works quite nicely <strong>on my computer</strong>.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;limits&gt;

template &lt;typename T&gt; void machine_epsilon()
{   
    T one = 1.0;
    T eps = 1.0;
    T fac = 0.5;
    int iter = 0;
    T one_plus_eps = one + eps;
    while (one_plus_eps != one)
    {   
        ++iter;
        eps *= fac;
        one_plus_eps = one + eps;
    }   
    --iter;
    eps /= fac;
    std::cout &lt;&lt; iter &lt;&lt; ' ' 
              &lt;&lt; eps &lt;&lt; ' ' 
              &lt;&lt; std::numeric_limits&lt;T&gt;::epsilon() &lt;&lt; '\n';
}   

int main ()
{   
    machine_epsilon&lt;float&gt;();
    machine_epsilon&lt;double&gt;();
    machine_epsilon&lt;long double&gt;();
}   
</code></pre>
",0
43205305,43203869,3,"<blockquote>
  <p>What is best practice in this case?</p>
</blockquote>

<p>The best practice is to delete the move constructor and move assignment operator to prevent this from happening.  Your object requires that <code>this</code> never changes, and you're getting undefined behavior because in this case the object was whipped out from beneath your thread and subsequently destroyed.</p>

<p>If, for whatever reason preventing moves goes against your design requirements, then there are a some common approaches that would make the most sense to anybody fortunate enough to be reading and maintaining your code.</p>

<ol>
<li><p>Use the <em>pimpl idiom</em> to create an internal object dynamically which can move with the outer object.  The outer object is movable, but the inner object is not.  The thread is bound to that object, and anything the thread needs access to is also within that object.  In your case, you would basically take your structure as it is and wrap it.  The basic idea is something like:</p>

<pre><code>class MovableA
{
public:
    MovableA() : a_(std::make_unique&lt;A&gt;()) {}
    void start() { a_-&gt;start(); }
    A &amp; a() const { return *a_; }
private:
    std::unique_ptr&lt;A&gt; a_;
};
</code></pre>

<p>The benefit of this approach is that you can move <code>MoveableA</code> without needing to synchronize with the running thread.</p></li>
<li><p>Abandon the notion of using stack allocation, and just allocate <code>A</code> dynamically.  This has the same benefit as option 1, and is simpler because you're not having to wrap your class in anything or provide accessors.</p>

<pre><code>std::unique_ptr&lt;A&gt; m;
{
    auto a = std::make_unique&lt;A&gt;();
    a-&gt;v_ = ""bar"";
    a-&gt;start();
    m = std::move(a);
}
std::cout &lt;&lt; ""v_ = "" &lt;&lt; m-&gt;v_ &lt;&lt; '\n';
m-&gt;t_.join();
</code></pre></li>
</ol>

<p>I started writing an option 3 that avoids dynamic allocation and instead binds a 'floating' version of <code>this</code> to a <code>std::reference_wrapper</code> but I felt I'd get it wrong without thinking about it a lot, and it seemed hacky and horrible anyway.</p>

<p>The bottom line is if you want to keep the object outside your thread <em>and</em> use it in the thread, the best practice is to use dynamic allocation.</p>
",1
43204672,43203869,6,"<p>As written, it's not going to work. After moving, the thread <code>m.t_</code> refers to a thread which is still running <code>a.threadProc()</code>. That will be attempting to print <code>a.v_</code>. </p>

<p>There are even two problems with the snippet: not only is <code>a.v_</code> moved from (so its value is unspecified), but it's also about to be destroyed in another thread, and that destruction is not sequenced-after its use.</p>

<p>Since the object needs to stay alive long enough, with a non-trivial lifetime due to the thread, you'll need to get it off the stack and out of the vector. Instead, use <code>std::shared_ptr</code> to manage the lifetime. You will probably need to pass that <code>shared_ptr</code> to the thread, to avoid a race condition where the object might expire before the thread starts running. You can't rely on <code>std:shared_from_this</code>.</p>
",1
43204924,43203869,2,"<p>(Alternative answer, using C++17) </p>

<p>Using lambda's, you can capture a copy of <code>A</code>. Since the thread owns the lambda and the lambda owns the copy, you don't have lifetime issues:</p>

<pre><code>t_ = std::thread([*this](){threadProc();});
</code></pre>
",6
37030575,37030463,0,"<p>You can't do it from the value itself, but you <em>can</em> use <code>std::map::find</code> to get an iterator to the interesting item in the map and delete the iterator's key/value pair directly.</p>
",0
37030609,37030463,2,"<p><code>unordered_map</code> supports two <code>erase</code> overloads:</p>

<ul>
<li>by key</li>
<li>by iterator</li>
</ul>

<p>There is no such <em>""erase through address of mapped value""</em>. Basically you have two ways of doing it:</p>

<pre><code>int main() {
    unordered_map&lt;string, int&gt; data;

    data[""UK""] = 10;
    data[""UK""]++;
    data[""US""] = 8;

    cout &lt;&lt; data.size() &lt;&lt; endl;
    auto it = data.find(""UK"");
    data.erase(it);
    cout &lt;&lt; data.size() &lt;&lt; endl;
    data.erase(""US"");
    cout &lt;&lt; data.size() &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>Using the iterator is more efficent because you can obtain the value (through <code>second</code> member) and together erase it without the need to do two lookups.</p>

<p>By your comment you can't take the address of an iterator which is obtained by value on a local variable. That would yield a local address in any case, but the standard guarantees you that iterators in an <code>unordered_map</code> are not invalidated upon insertion and on delete only the affected one is invalidated, so storing them somewhere is allowed, something like:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;

using namespace std;
using map_type = unordered_map&lt;string, int&gt;;

map_type data;
vector&lt;map_type::iterator&gt; timer_queue;

void timeTick()
{
  for_each(begin(timer_queue), end(timer_queue), [](map_type::iterator&amp; it) {
    --it-&gt;second;

    if (it-&gt;second == 0)
    {
      cout &lt;&lt; ""pair "" &lt;&lt; it-&gt;first &lt;&lt; "" has expired"" &lt;&lt; endl;
      data.erase(it);
      cout &lt;&lt; ""map size: "" &lt;&lt; data.size() &lt;&lt; endl;
    }
  });
}

template&lt;typename... Args&gt; void addElement(Args... args)
{
  auto it = get&lt;0&gt;(data.emplace(args...));
  timer_queue.push_back(it);
}

int main() {

  addElement(""IT"", 5);
  addElement(""US"", 10);
  addElement(""UK"", 8);

  while (!data.empty())
  {
    cout &lt;&lt; ""time tick"" &lt;&lt; endl;
    timeTick();
  }

    return 0;
}
</code></pre>
",1
37031470,37030463,0,"<p>I wouldn't recommend this for production code, but if you are okay with making the assumption that your STL's implementation of unordered_map is storing keys and values together in a struct, and that therefore the memory locations of the key and value in a given key/value pair will always be at a fixed offset from each other, you could use the GetKeyFromValue() function below to retrieve the key associated with your reference-to-a-value.  Then you could use that pass that key in to erase() or whatever, as usual.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

using namespace std;

/** Given a reference to a value in (map), returns a reference to the associated key.
  * @param map Reference to the unordered_map object.
  * @param value Reference to a value in (map).  If this reference is to some object that is
  *              not actually stored in (map), then this function's behavior is undefined, so be careful!
  * @returns A reference to the key associated with (value).
  */
template&lt;typename KeyType, typename ValueType&gt; const KeyType &amp; GetKeyFromValue(const unordered_map&lt;KeyType, ValueType&gt; &amp; map, const ValueType &amp; value)
{
   if (map.size() == 0) throw invalid_argument(""Called GetKeyFromValue() on an empty map!?"");

   auto it = map.begin();
   const KeyType   * firstKey = &amp;it-&gt;first;
   const ValueType * firstVal = &amp;it-&gt;second;

   const char * cFirstKey = reinterpret_cast&lt;const char *&gt;(firstKey);
   const char * cFirstVal = reinterpret_cast&lt;const char *&gt;(firstVal);
   ptrdiff_t diff = cFirstVal-cFirstKey;

   const char * cUserVal = reinterpret_cast&lt;const char *&gt;(&amp;value);
   cUserVal -= diff;
   return *(reinterpret_cast&lt;const KeyType *&gt;(cUserVal));
}

// Quick unit test for the above
int main(int, char **)
{
   unordered_map&lt;string, int&gt; mymap;
   mymap[""US""] = 10;
   mymap[""UK""] = 9;
   mymap[""US""]++;
   mymap[""France""]=8;

   int &amp; x = mymap[""UK""];
   const string &amp; uk = GetKeyFromValue(mymap, x);
   cout &lt;&lt; ""keyForX=["" &lt;&lt; uk &lt;&lt; ""]"" &lt;&lt; endl;

   int &amp; y = mymap[""France""];
   const string &amp; france = GetKeyFromValue(mymap, y);
   cout &lt;&lt; ""keyForY=["" &lt;&lt; france &lt;&lt; ""]"" &lt;&lt; endl;

   return 0;
}
</code></pre>
",5
39320001,39319862,7,"<blockquote>
  <p>I need to convert ""void*"" to int</p>
</blockquote>

<p>no you don't.</p>

<blockquote>
  <p>I really do...</p>
</blockquote>

<p>no, you need to represent a pointer as some kind of integer type which is guaranteed not to lose information.</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;cstdint&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;utility&gt;
#include &lt;cinttypes&gt;

void dummy(void *p) {
    std::intptr_t x = reinterpret_cast&lt;std::intptr_t&gt;(p);
    printf(""x = %"" PRIiPTR ""\n"", x);
// ^^ see here: http://en.cppreference.com/w/cpp/types/integer
}

int main(int argc, char *argv[]) {
    void *p = (void*)5;
    dummy(p);
    return 0;
}
</code></pre>

<blockquote>
  <p>ok, what I really want to do is work with 32-bit values in a standards-compliant way.</p>
</blockquote>

<p>This is what <code>std::uint32_t</code> is for:</p>

<pre><code>#include &lt;cstdint&gt;
#include &lt;iostream&gt;

void dummy(std::uint32_t x) {
  std::cout &lt;&lt; x &lt;&lt; '\n';
}

int main(int argc, char *argv[]) {
    auto x = std::uint32_t(5);
    dummy(x);
    return 0;
}
</code></pre>

<p><code>std::uint32_t</code> - guaranteed to be unsigned 32 bits</p>

<p><code>std::int32_t</code> - guaranteed to be signed 32 bits</p>
",2
39332627,39319862,6,"<p>You are probably looking for something along the lines of</p>

<pre><code>int x = static_cast&lt;int&gt;(reinterpret_cast&lt;std::uintptr_t&gt;(p));
</code></pre>

<p>This is not strictly guaranteed to work: perhaps surprisingly, the standard guarantees that a pointer converted to a large enough integer and back to a pointer results in the same value; but doesn't provide a similar guarantee for when an integer is converted to a pointer and back to the integer. All it says about the latter case is</p>

<blockquote>
  <p><strong>[expr.reinterpret.cast]/4</strong> A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is implementation-defined. [ <em>Note:</em> It is intended to be unsurprising to those who know the addressing structure of the underlying machine. <em>¡ªend note</em> ]</p>
</blockquote>

<p>Hopefully, you know the addressing structure of your machine, and won't be surprised.</p>
",0
36783301,36783196,3,"<p>This is undefined behavior.</p>

<pre><code> return ret.c_str();
</code></pre>

<p>The object <code>ret</code> has a local function scope. This object gets destroyed when this function returns, and all of its internal memory gets deallocated.</p>

<p>It's <code>c_str()</code> method returns a pointer that's no longer valid, after the object gets destroyed. As soon as this function returns, the <code>c_str()</code> pointer is no longer valid.</p>

<p>The pointer that's returned by <code>c_str()</code> is only valid until the <code>std::string</code> object is modified, or it gets destroyed.</p>
",1
39686262,39686189,3,"<p><code>double x1[dim];</code> is a VLA (variable length array). It is not standard C++.</p>

<p>The reason why it works on <code>gcc</code> is that <code>gcc</code> has an extension which allows VLAs. VS2015 doesn't, so that's why it doesn't compile (it has its own set extensions though, just not that one).</p>

<p>The best alternative is a <code>std::vector</code>:</p>

<pre><code>std::vector&lt;double&gt; x1(dim); //array of size dim
</code></pre>

<p>If you can't use that, you can still use a manual dynamic array (although that is not recommended):</p>

<pre><code>double* x1 = new double[dim];
delete[] x1; //Don't forget to delete it when you are done
//Alternatively, create a class which wraps the dynamic array, so you can use RAII
</code></pre>
",5
39686369,39686189,1,"<p>In the past, when I wanted to use VLA on MSVC, a workaround was to use <code>alloca()</code> whenever I wanted or needed VLA feature on a compiler that does not support VLA.</p>
",1
41660388,41660364,5,"<p>You can use <a href=""http://en.cppreference.com/w/cpp/algorithm/find"" rel=""nofollow noreferrer""><code>std::find</code></a>:</p>

<pre><code>arr = new int[capacity];
const auto end_arr = arr + capacity;
int* found = std::find(arr, end_arr, 42);
if (found == end_arr)
    std::cout &lt;&lt; ""Not found"";
else
    std::cout &lt;&lt; ""Found at index "" &lt;&lt; (found - arr);
</code></pre>

<p>This library function looks for the number between the specified <em>iterators</em>, ""begin"" and ""end"". In your array, the pointer to the first element is the ""begin"", while the pointer past the last element (<code>end_arr</code>) is the ""end"".</p>

<p>If the number is not found, the library function returns the end iterator (not <code>nullptr</code>, as you might expect), so you have to compare its return value with the end iterator to discover whether the number was found.</p>

<hr>

<p>You can also use <code>std::vector</code> to represent an array, instead of ""pointer + capacity"". This usually leads to easier-to-read code, which is also more robust (i.e. less bugs). <code>std::vector</code> holds its capacity internally, and also has dedicated methods <code>begin</code> and <code>end</code>:</p>

<pre><code>std::vector&lt;int&gt; arr;
...
arr.resize(capacity);
...
auto found = std::find(arr.begin(), arr.end(), 42);
if (found == arr.end())
    std::cout &lt;&lt; ""Not found"";
else
    std::cout &lt;&lt; ""Found at index "" &lt;&lt; (found - arr.begin());
</code></pre>
",1
39339873,39338875,3,"<p>If your compiler supports it, you could use C++17 <a href=""http://en.cppreference.com/w/cpp/utility/variant"" rel=""nofollow""><code>std::variant</code></a> (based on <a href=""http://www.boost.org/doc/libs/1_61_0/doc/html/variant.html"" rel=""nofollow""><code>boost::variant</code></a>).</p>

<hr>

<p>Edit: For maximally space-efficient, opt-in type safety, you could do something along the lines of</p>

<pre class=""lang-cpp prettyprint-override""><code>union Word { int32_t i; float f; Instruction inst; };

namespace MemAccess
{
        static std::bitset&lt;MEM_SIZE&gt; int32_whitelist,
                                     float_whitelist,
                                     inst_whitelist;
        static std::array&lt;Word, MEM_SIZE&gt; memory;
        // set or reinterpret as int32
        int32_t &amp;
        int32_at(const size_t at)
        {
                int32_whitelist[at] = 1;
                float_whitelist[at] = inst_whitelist[at] = 0;

                return memory[at].i;
        }
        // interpret as int32 only if whitelisted
        int32_t &amp;
        int32_checked(const size_t at)
        {
                if (int32_whitelist[at])
                {
                        return memory[at].i;
                }
                else
                {
                        throw;
                }
        }
        // equivalent functions for floats and instructions
}
</code></pre>

<p>Edit 2: Occurred to me this could also be done with one bitset.
</p>

<pre><code>static std::array&lt;Word, MEM_SIZE&gt; memory;
static std::bitset&lt;MEM_SIZE * 2&gt; whitelist;

float &amp;
float_at(const size_t at)
{       // None = 00, Inst = 10, Int32 = 11
        whitelist[at * 2]     = 0;
        whitelist[at * 2 + 1] = 1;

        return memory[at].f;
}

float &amp;
float_checked(const size_t at)
{
        if (!whitelist[at * 2] &amp;&amp; whitelist[at * 2 + 1])
        {
                return memory[at].f;
        }

        throw;
}
</code></pre>
",5
40754220,40754161,8,"<p>Your design suffers from it being easy to be in a bad state (e.g. what if both <code>stop_</code> and <code>play_</code> are both <code>true</code>?</p>

<p>You should use an <code>enum</code> to define a <a href=""https://en.wikipedia.org/wiki/Finite-state_machine"" rel=""noreferrer"">set of finite-states</a> of which only 1 can be active at any given point in time.</p>

<p>C++'s <code>enum</code> types are somewhat different from Swift, Java and C#'s <code>enum</code>: they're unscoped and are more permissive with implicit conversions - behaving somewhat similarly to <code>#define</code>.</p>

<p>C++11 adds <code>enum class</code> which is very similar to C#'s <code>enum</code>. There is no built-in functionality similar to the flexibility of Java or Swift's <code>enum</code>s, however.</p>

<p>You will want something like this:</p>

<pre><code>enum class PlayerState {
    Stopped,
    Playing,
    Paused
}
</code></pre>

<p>If <code>Reset</code> is not a state, but a verb, then it should not be in the <code>enum</code> definition.</p>

<pre><code>class VideoPlayer {
private:
    PlayerState state;
public:
    VideoPlayer() :
        state( PlayerState::Stopped )
    {

    }

    void play() {

        switch( this-&gt;state ) {
            case PlayerState::Stopped:
                 // start video here, only change `state` when complete.
                // you might want to add a ""BeginPlaying"" (e.g. `LoadingFileFromDisk`) state value too.
                this-&gt;state = PlayerState.Playing;
                break;
            case PlayerState::Playing:
                throw VideoPlayerStateExeception(""Already playing"");
            case PlayerState::Paused:
                this-&gt;resume();
                break;
        }
    }


}
</code></pre>
",3
40755463,40754161,0,"<p>I would use C++17's <code>std::variant</code>. States will become types with data.</p>

<pre><code>struct Playing {
    float time_from_start;
};

struct Paused {
    float time_from_start;
};

struct Stopped {};

struct MediaPlayer {
    std::variant&lt;
        Playing,
        Paused,
        Stopped
    &gt; state;

    void play() {
        state = Playing{};
    }

    void pause() {
        state.visit([&amp;](auto&amp;&amp; s){
            using S = std::decay_t&lt;decltype(s)&gt;;

            float time = 0;

            if constexpr (std::is_same_v&lt;S, Playing&gt;) {
                time = s.time_from_start;
            }

            state = Paused{time};
        });
    }
};
</code></pre>

<p>One could even add some other useful states:</p>

<pre><code>struct ABLoop {
    float a, b, time_from_a;
};
</code></pre>
",0
35238656,28631812,0,"<p>Maybe you are trying to store 1 in a char array as </p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
int main()
{
    char n=1;
    cout &lt;&lt; n;
    return 0;
 }
</code></pre>

<p>The output will be a smiley </p>
",3
41189224,41189047,3,"<ol>
<li><p>Change <code>measure</code> to a function template to allow you to use any callable, not just a function.</p></li>
<li><p>Use a lambda function in <code>run</code>.</p></li>
</ol>

<hr>

<pre><code>#include &lt;iostream&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;

template &lt;typename F&gt;
void measure(F f) {
    time_t tBegin = time(NULL);
    f();
    time_t tEnd = time(NULL);
    std::cout &lt;&lt; ""Duration: "" &lt;&lt; (tEnd - tBegin) &lt;&lt; "" sec"" &lt;&lt; std::endl;
}

class Myclass {
private:
    double _d;

public:
    Myclass(double d) : _d(d) {}

    void run() {
        measure([=](){m();});
    }

    void m() const {
        usleep(1000000 * _d);
    }
};

int main() {
    Myclass obj(2.0);
    obj.run();
    return 0;
}
</code></pre>

<hr>

<p>Since,  you are not allowed to modify <code>measure</code>, you can use a helper class template and a function template to make it possible for you to use any callable.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;

void measure(void (*f)()) {
    time_t tBegin = time(NULL);
    f();
    time_t tEnd = time(NULL);
    std::cout &lt;&lt; ""Duration: "" &lt;&lt; (tEnd - tBegin) &lt;&lt; "" sec"" &lt;&lt; std::endl;
}

template &lt;typename F&gt;
struct MeasureFunctor
{
   static F* f_;
   static void run(){(*f_)();}
};

template &lt;typename F&gt; F* MeasureFunctor&lt;F&gt;::f_ = nullptr;

template &lt;typename F&gt;
void measure(F f) {
   MeasureFunctor&lt;F&gt;::f_ = &amp;f;
   measure(MeasureFunctor&lt;F&gt;::run);
}

class Myclass {
private:
    double _d;

public:
    Myclass(double d) : _d(d) {}

    void run() {
        measure([=](){m();});
    }

    void m() const {
        usleep(1000000 * _d);
    }
};

int main() {
    Myclass obj(2.0);
    obj.run();
    return 0;
}
</code></pre>
",2
41189425,41189047,0,"<p>I also would prefer a lambda (and a std::function as parameter for measure), but since you cannot change that, what about this idea:</p>

<ol>
<li>Make <code>m()</code> static.</li>
<li>Add a static member to MyClass that takes a reference to the current MyClass instance that is running <code>measure</code>. You must set this everytime before you call <code>m()</code>. Also, think about thread safetiness.</li>
<li>In <code>m()</code> you can then use this reference to get to <code>_d</code>. Alternatively, you could even store the value of <code>_d</code> in a static member var to have it available in <code>m()</code>. Depends on what you actually need from <code>MyClass</code>.</li>
</ol>

<p>This approach would allow to measure only one invocation at a time. For parallel execution of multiple <code>measure()</code> calls you could use thread-local-storage for the reference you set in step 2.</p>
",0
46978676,27318112,0,"<p>if you have a pointer <code>p</code> point to the array<br>
and you want to get the array size.<br>
try <code>size_t array_size = *(size_t*)p;</code><br>
Dangerous. But it works.</p>
",0
41673242,41672889,1,"<p>To solve a problem like this, start by breaking the problem into smaller parts.  A possible decomposition is:</p>

<ol>
<li>Are there characters still to read from the input?  No: Great, we are done!</li>
<li>Read in a character</li>
<li>Is the character a vowel? Yes: Goto 1.</li>
<li>Output the character</li>
<li>Goto 1.</li>
</ol>

<p>Then in code, you can translate this into:</p>

<pre><code>// 1) Are there characters still to read?
while (std::cin.good())
{
    // 2) Read in a character
    char ch;
    std::cin.get(ch);

    // 3) Is the character a vowel?
    //     For the test for a vowel, you can use something similar to
    //     what you have at the moment, or better still: consider
    //     writing a function like isVowel in @Shreevardhan answer.
    if ( /* TODO: Test if the character is a vowel... */)
    {
        // Skip the rest of the loop and go back to 1
        continue;
    }

    // 4) Output the good character
    std::cout &lt;&lt; ch;

    // 5) Reached the end of the loop, so goto 1
}
</code></pre>

<p>It's a good habit to break your problem down into smaller parts.  I often start a new project by first writing out a list/comments (or even drawing a flow diagram) to break up the problem into more manageable pieces.</p>
",1
41673517,41672889,0,"<p>Other answers show how to solve this problem in a more intuitive manner.
Anyway, when looking at your code consider the following:</p>

<pre><code>while( a==65 || a==69 || a==73 || a==79 || a==85 || a==97 || a==101 || a==105 || a==111 || a==117)
            cin.ignore(1 , a);
</code></pre>

<p>As you do a while loop with conditions around the value of <code>a</code>, and as <code>cin.ignore(1 , a)</code> does not change the value of <code>a</code>, you wont ever leave this loop unless an exception is thrown, right?</p>
",0
41673331,41672889,0,"<p>Something like this</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

bool isVowel(char c) {
    c = tolower(c);
    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
}

int main() {
    char c;
    while (cin.get(c))
        if (!isVowel(c))
            cout &lt;&lt; c;
    return 0;
}
</code></pre>

<p>Add your storing logic inside.</p>

<p>A more C++-ish code</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;

int main() {
    string s;
    getline(cin, s);
    s.erase(remove_if(s.begin(), s.end(), [](char c) {
        c = tolower(c);
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
    }), s.end());
    cout &lt;&lt; s;
    return 0;
}
</code></pre>

<p>See a <a href=""http://ideone.com/iVrzSu"" rel=""nofollow noreferrer"">demo</a>.</p>
",0
41673585,41672889,0,"<p>Maybe you can try to use the boost library.</p>

<pre><code>#include &lt;boost/algorithm/string.hpp&gt;
boost::erase_all(str, ""a"");
</code></pre>
",0
36377677,36373129,0,"<p>You only need specify the scoped name, <code>Arrayc&lt;T&gt;::Arrayc</code>, when <em>defining</em> the constructor.</p>

<p>To call the constructor, simply use <code>Arrayc&lt;T&gt;(/*args*/)</code>.</p>

<p>Of course, you really don't even need <code>new</code> at all, but that's unrelated to the error.</p>
",0
36373208,36373129,-1,"<p>You are not passing any clues to your constructors of what you want T to be at the time that you use them. I'd suggest adding a parameter T to your constructor, even if you only use it as a phony initializer value, so that the compiler can deduce what type Arrayc() will be, e.g., <code>new Arrayc(10, 0)</code> or <code>new Arrayc (10, 0.0f)</code></p>
",1
46088131,46087593,1,"<p>Static member variables are not associated with each object of the class. It is shared by all objects. </p>

<p>If you declare a static variable inside the class then you should define it in the cpp file, otherwise, you can get error <code>undefined reference</code>. </p>

<p>Note that if the static member variable is of const int type (e.g. <code>int</code>, <code>bool</code>, <code>char</code>), you can then declare and initialize the member variable directly inside the class declaration in the header file.</p>
",0
46087904,46087593,3,"<p>When you declare a member as <code>static</code> it will belong to the <code>class</code> with only one instance and not to the objects of the <code>class</code>, therefore you cannot initialize it inside the constructor. The constructor is a special member function which mainly exists to initialize the non <code>static</code> members of a new object.</p>

<p>Note that a <code>static</code> member is shared by all objects of the <code>class</code> and when an object changes it, the change can be seen from all other objects of the same <code>class</code>. If this is what do you want to achieve, then the method you shown is good.</p>
",1
42496950,42496875,7,"<p>There's no <code>_Generic</code> in C++ and you cannot use it in C++ code. If you want to design cross-compilable code (e.g. header files), either avoid <code>_Generic</code> entirely, or use <code>#ifdef __cplusplus</code> to provide two independent (or semi-independent) versions of the same code for C and C++ separately, e.g. use function overloading on C++ side instead of <code>_Generic</code>.</p>
",1
39678925,39678813,1,"<p>Here</p>

<pre><code>line = (struct Line *) malloc(sizeof(Line));
</code></pre>

<p>the code allocates exactly <em>one</em> line-object.</p>

<p>Here its seems to address more then just <code>line[0]</code>:</p>

<pre><code>line[pImage-&gt;numGraphicElements]....
</code></pre>

<p>Doing so the code invokes undefined behaviour, anything can happen from this moment on. This includes overwriting other memory belonging to the same process.</p>
",6
46079206,46078578,0,"<p>Most probably this is name collision with preprocessor problem. This is why old habbit of having all constant in uppercase creates problems this days instead of fixing them. To fix this issue remove macro definition before include:</p>

<pre><code>#ifdef STATIC
#undef STATIC
#endif
#include &lt;header_with_problem&gt;
</code></pre>

<p>on another side undefining this macro may create problems somewhere else, you then need to find what value it has and restore it after include. (or put this include as last one if possible)</p>
",0
46079387,46078578,0,"<p>The solution was as stupid as I expected it to be:</p>

<p>I used clang-format to format my code according to the guideline. The clang-format tool changed the include file order (alphabetical, whoever set this property). That ""minor"" change broke my code.</p>

<p>Hint: I used the preprocessor to solve the problem:</p>

<pre><code>#if 0
// excluded code
#endif
</code></pre>

<p>and</p>

<pre><code>#if 1
// included code
#endif
</code></pre>

<p>This allowed me to exclude codeparts. If the compilation still fails it will be a problem of the rest of the code. So I found out, that the problem was hidden in some include file.</p>

<p>Afterwards I used SVN Diff to compare the includes.</p>
",2
41221594,22683437,0,"<p><a href=""http://www.akkadia.org/drepper/dsohowto.pdf"" rel=""nofollow noreferrer"">Ulrich Drepper's paper on shared ELF libraries</a> is relevant for you if you produce dynamically shared objects, usually shared libraries. I assume that some considerations also apply to applications which just are dynamically linked. The paper discusses the GNU tools but similar concerns will likely apply to other tool chains.</p>

<p>In short there may be build-time, load-time and run-time penalties for global objects and functions. </p>

<p>Build- and load-time penalties are rooted in the number of (string) comparisons needed to resolve dependencies which are not necessary for locally-defined symbols like file static functions and variables. Drepper discusses this at page 8 using the example of OpenOffice.</p>

<p>The reason for run-time penalties is ELF specifying that even locally-defined but global symbols could be replaced at run time with definitions in other objects. Therefore function code cannot be inlined and further optimized, even though it is visible at compile time; and the function call proper is more complicated than necessary, involving more indirections. See Drepper's paper, pp. 17 and 18.</p>
",0
43754561,43754462,5,"<p>First of all this line <code>list.begin();</code> and that line <code>list.front().Orders.begin();</code> don't do anything. Remove them.</p>

<p>Now the main problem. Elements in lists don't appear automagically. Lists are empty when created. Have a look at this line:</p>

<pre><code>list.front().price = 13000;
</code></pre>

<p>At that point your list is empty, there is no <code>.front()</code>. So its an undefined behaviour, probably the cause of the segfault.</p>

<p>This will do:</p>

<pre><code>Bid bid;
list.push_back(bid);
list.front().price = 13000;
// or if C++11
list.emplace_back();
list.front().price = 13000;
</code></pre>

<p>The same goes for <code>list.front().Orders.front()</code> and every other line using <code>.front()</code>.</p>

<p><em>Side note:</em> You may want to use <a href=""http://en.cppreference.com/w/cpp/container/list/emplace_back"" rel=""nofollow noreferrer""><code>list.emplace_back</code></a> instead of <code>push_back</code>. Also you may want to use <code>std::vector</code> instead of <code>std::list</code>. There are several performance advantages over a list and it should be used by default unless you really know that you need lists.</p>
",5
43754563,43754462,1,"<p>Calling <a href=""http://en.cppreference.com/w/cpp/container/list/front"" rel=""nofollow noreferrer""><code>front()</code></a> on an empty list has undefined behavior. An empty list doesn't have a first item, so you shouldn't be trying to access it.</p>

<p>You can use <a href=""http://en.cppreference.com/w/cpp/container/list/push_back"" rel=""nofollow noreferrer""><code>push_back()</code></a> eg. to add an item into the list, which you can then access and modify.</p>

<pre><code>list.push_back(Bid());
</code></pre>
",0
43754600,43754462,1,"<p>You do not insert elements into your list. <code>std::list::front</code> will return the first element of the list if it is non-empty, but behaviour is undefined if the list is empty.</p>

<p><code>std::list::begin</code> returns an iterator to the first element, if the list is non-empty or the past-the-end iterator if the list is empty.</p>

<p>Use <code>std::list::push_back</code> to insert new elements into your list.</p>
",0
43755268,43754462,0,"<p>Thanks guys for clear explanations and advises.
I ended with the following working code :</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;list&gt;
using namespace std

typedef struct Order {
  int userid;
  int qty;
} Order;

typedef struct Bid {
  int price;
  list&lt;Order&gt; Orders;
} Bid;

typedef list&lt;Bid&gt; bids;

int main(void)
{
  Bid bid;
  bids bidList;
  Order order_to_insert;

  bidList.push_back(bid);
  bidList.front().price =13000;

  order_to_insert.userid = 3;
  order_to_insert.qty = 20;

  bidList.front().Orders.push_back(order_to_insert);
  bidList.front().Orders.front() = order_to_insert;

  cout &lt;&lt; ""Liste : "" &lt;&lt; bidList.front().price &lt;&lt; endl;
  cout &lt;&lt;  bidList.front().Orders.front().move  &lt;&lt; endl;

  return 0;
}
</code></pre>
",5
43754561,43754462,5,"<p>First of all this line <code>list.begin();</code> and that line <code>list.front().Orders.begin();</code> don't do anything. Remove them.</p>

<p>Now the main problem. Elements in lists don't appear automagically. Lists are empty when created. Have a look at this line:</p>

<pre><code>list.front().price = 13000;
</code></pre>

<p>At that point your list is empty, there is no <code>.front()</code>. So its an undefined behaviour, probably the cause of the segfault.</p>

<p>This will do:</p>

<pre><code>Bid bid;
list.push_back(bid);
list.front().price = 13000;
// or if C++11
list.emplace_back();
list.front().price = 13000;
</code></pre>

<p>The same goes for <code>list.front().Orders.front()</code> and every other line using <code>.front()</code>.</p>

<p><em>Side note:</em> You may want to use <a href=""http://en.cppreference.com/w/cpp/container/list/emplace_back"" rel=""nofollow noreferrer""><code>list.emplace_back</code></a> instead of <code>push_back</code>. Also you may want to use <code>std::vector</code> instead of <code>std::list</code>. There are several performance advantages over a list and it should be used by default unless you really know that you need lists.</p>
",5
43754563,43754462,1,"<p>Calling <a href=""http://en.cppreference.com/w/cpp/container/list/front"" rel=""nofollow noreferrer""><code>front()</code></a> on an empty list has undefined behavior. An empty list doesn't have a first item, so you shouldn't be trying to access it.</p>

<p>You can use <a href=""http://en.cppreference.com/w/cpp/container/list/push_back"" rel=""nofollow noreferrer""><code>push_back()</code></a> eg. to add an item into the list, which you can then access and modify.</p>

<pre><code>list.push_back(Bid());
</code></pre>
",0
43754600,43754462,1,"<p>You do not insert elements into your list. <code>std::list::front</code> will return the first element of the list if it is non-empty, but behaviour is undefined if the list is empty.</p>

<p><code>std::list::begin</code> returns an iterator to the first element, if the list is non-empty or the past-the-end iterator if the list is empty.</p>

<p>Use <code>std::list::push_back</code> to insert new elements into your list.</p>
",0
43755268,43754462,0,"<p>Thanks guys for clear explanations and advises.
I ended with the following working code :</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;list&gt;
using namespace std

typedef struct Order {
  int userid;
  int qty;
} Order;

typedef struct Bid {
  int price;
  list&lt;Order&gt; Orders;
} Bid;

typedef list&lt;Bid&gt; bids;

int main(void)
{
  Bid bid;
  bids bidList;
  Order order_to_insert;

  bidList.push_back(bid);
  bidList.front().price =13000;

  order_to_insert.userid = 3;
  order_to_insert.qty = 20;

  bidList.front().Orders.push_back(order_to_insert);
  bidList.front().Orders.front() = order_to_insert;

  cout &lt;&lt; ""Liste : "" &lt;&lt; bidList.front().price &lt;&lt; endl;
  cout &lt;&lt;  bidList.front().Orders.front().move  &lt;&lt; endl;

  return 0;
}
</code></pre>
",5
38988494,38988370,2,"<p><code>collection</code> is defined as an <code>ifstream</code>, i. e. ""input file stream"". It only supports reading input <em>from</em> a file, thus only <code>operator&gt;&gt;</code>.</p>

<p>You need an <code>ofstream</code> to output data <em>to</em> a file. Or you use an fstream, which supports both input and output.</p>

<p>And WhozCraig pointed to it already: Your code is lacking calls to <code>operator&lt;&lt;</code> between several output data.</p>
",0
38988496,38988370,2,"<p>You defined <code>collection</code> in two places, and where you are using it it is an <code>istream</code>. You can't output to an ifstream.</p>

<p>You also forgot a bunch of <code>&lt;&lt;</code>
This should solve it. You can also open the file directly in the constructor, which would be better.</p>

<pre><code>            fstream collection_out;
            collection_out.open(filename, std::fstream::in | std::fstream::out | std::fstream::app);
            collection_out &lt;&lt; ctr &lt;&lt; ""\t"" &lt;&lt; student[ctr].studentID&lt;&lt;""\t"" &lt;&lt; student[ctr].surname&lt;&lt;""\t""&lt;&lt;student[ctr].firstname&lt;&lt;""\t"" &lt;&lt; student[ctr].birthdate&lt;&lt;""\t""&lt;&lt; student[ctr].sex&lt;&lt;endl;
</code></pre>
",0
41921311,41921216,0,"<p>Try</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;

int main()
{
  int c, e = 100;
  ofstream outputFile;
  outputFile.open(""num_gen.txt"");
  while (true)
    {
      cout &lt;&lt; ""Enter starting value from 1 to 100: "" &lt;&lt; endl;
      cin &gt;&gt; c;
      if (c &lt;= 0)
        cout &lt;&lt; ""Value is too small"" &lt;&lt; endl;
      else if (c &gt;= 100)
        cout &lt;&lt; ""Value is too big"" &lt;&lt; endl;
      else
        {
          while (c &gt; 0 &amp;&amp; c &lt; 100)
            {
              outputFile &lt;&lt; ""&lt;"" &lt;&lt; c &lt;&lt; c &lt;&lt; c &lt;&lt; c &lt;&lt; endl;
              c++;
            }
          break;
        }
    }

  cout &lt;&lt; ""Press enter to exit..."" &lt;&lt; endl;
  cin.get();
  cin.get();
  return 0;
}
</code></pre>
",11
41903775,31571402,3,"<p>You're facing an unsigned integer overflow. No matter what you do to an <code>unsigned int</code>, it's always going to be less than or equal to its maximum value (255). You can instead use a larger integer data type for the loop index. If you'd <em>still</em> rather use an <code>unsigned char</code>, a <code>while</code> loop will work:</p>

<pre><code>unsigned char uc = 0;
do {
  // stuff it in here
} while (uc++ &lt; std::numeric_limits&lt;unsigned char&gt;::max());
</code></pre>
",0
40952468,40952323,2,"<pre><code>#define CALL(fn, x, y) fn(x, y)
#define CALL(fn, x, y, z) fn(x, y, z)
</code></pre>

<p>allows you to do:</p>

<pre><code>CALL(foo, 13, 6);
CALL(bar, 1, 2, 3);
</code></pre>

<p>Would that be good enough?</p>
",0
40952468,40952323,2,"<pre><code>#define CALL(fn, x, y) fn(x, y)
#define CALL(fn, x, y, z) fn(x, y, z)
</code></pre>

<p>allows you to do:</p>

<pre><code>CALL(foo, 13, 6);
CALL(bar, 1, 2, 3);
</code></pre>

<p>Would that be good enough?</p>
",0
38286197,38286111,0,"<p>You can usually trust Valgrind to report facts. But how you interpret those is important. Not all leaks are equal.</p>

<p>Not all memory leaks are a problem. A program may legitimately neglect to free some objects during shutdown if their destructors are known to not have relevant work to do and thus ""leak"" them - leaving it up to the operating system to clear up the memory when the process exits.</p>

<p>So, there <em>may</em> be a real issue, sure. But it may also be that the library is intentionally leaking some objects for performance or convenience reasons.</p>

<p>A memory leak is only really a problem if it causes memory use to continuously increase during runtime.</p>

<p>A leak as in - a resource is allocated once and persists until the end of the program and is never freed - is only <em>really</em> a problem if that resource is of a significant size and could be released early so the memory could be used for something better, and/or if the resource has a destructor that it is important to run.</p>

<p>Remember that once the program terminates, <em>all</em> memory it allocated is returned to the system (rare exceptions like ""sysv shared memory"" and such excepted). A memory leak cannot impact the system beyond program termination.</p>
",0
38287360,38286111,0,"<p>You can usually trust Valgrind in that the memory is allocated there and not freed. Whether it is a problem or not, is another question.</p>

<p>This actually seems to be buffer allocated for stdout/stderr for performance reasons, which is indeed not freed by the C library on purpose.</p>

<p>You can try calling:</p>

<pre><code>setbuf(stdout, NULL);
setbuf(stderr, NULL);
</code></pre>

<p>as the very first thing of the program and see if the Valgrind errors will go away. However it isn't a good thing to do, because the buffers are there for better performance. So it might be better to ignore this error (i.e. add it to the Valgrind suppression file).</p>

<p>(as you are using an unit-test framework, it might be actually kind of difficult to do this as the very first thing, because the framework will probably step in the way - one possibility might be to create a static global instance of an object which will call these in its constructor)</p>
",0
38290201,38290159,3,"<p>You need to sum up all subtotals. However, each subtotal is only accessible in its iteration, afterwards, it's lost since you reassign subtotal.</p>

<p>Hence, declare a variable <code>total</code> outside of your while loop, then add the subtotal to the total in each iteration. Thus, add the following line</p>

<pre><code>subtotal = units*price;
total += subtotal;
</code></pre>

<p>Now you can print <code>total</code> later on.</p>
",0
36393088,36392600,0,"<p>The code bellow works in the same manner for both == and &amp;&amp;. 
The class equality is triggered only when are of the same type.</p>

<pre><code>#include &lt;stdio.h&gt;

class my_bool {
private:
  bool v{false};
  public:
    my_bool() : v(v) {};
    operator bool (){return v;}

    friend bool operator==(const my_bool a, my_bool b){
            printf(""operator==\n"");return a.v==b;
        }
        friend bool operator&amp;&amp;(const my_bool a, my_bool b){
            printf(""operator&amp;&amp;\n"");return a.v&amp;&amp;b;
        }
};

int main(int argc, char **argv)
{ printf(""Starting\n"");
  bool a=true,b=true;
  my_bool A{},B{},R{};

  a==b;a&amp;&amp;b;
  a==A;a&amp;&amp;A;
  A==b;A&amp;&amp;b;
  A==B;A&amp;&amp;B;
}
</code></pre>
",1
36265012,26518300,5,"<p>It's impossible to do it in O(log n) time with std::set, but you can do it using <code>tree</code> from extended STL. Here is how to use it:</p>

<pre><code>#include &lt;ext/pb_ds/assoc_container.hpp&gt;
using namespace __gnu_pbds;
tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; s;
s.insert(x);
s.erase(x);
s.count(x);
s.find_by_order(k);
// k-th biggest element in set
s.order_of_key(x);
// how many elements in set are less than x
</code></pre>
",0
41201537,41201486,4,"<p>No it shouldn't! <code>increment</code> has <code>void</code> as return type, that means that an expression call to this function has no value. If you want that call to be able to be used on the left part of an assignment, it must return a left-value.</p>

<p>Basically, when you write <code>a=b</code> <code>a</code> denotes a container but <code>b</code> a value.</p>

<p>You can try:</p>

<pre><code>int &amp;increment(int &amp;p){
    p = p +10;
    return p; // return the reference passed as argument...
}
int main()
{
    int i = 10;
    increment(i) += 15;
    cout&lt;&lt;""i = "" &lt;&lt;i&lt;&lt;endl;
    return 0;
}
</code></pre>
",0
39660482,39660450,8,"<p><code>##</code> is for pasting tokens together. You don't need that, so just:</p>

<pre><code>#define APPLY_FUNCTION(PIXELTYPE) apply&lt;PIXELTYPE&gt;(input);
</code></pre>

<p>That said, two guidelines:</p>

<ol>
<li>Don't end your macro with a <code>;</code> Requiring the user to add it will save you from some bugs.</li>
<li>Please don't write this macro. </li>
</ol>
",0
39660499,39660450,0,"<p>In a macro expansion, <code>##</code> tells the compiler to combine the token that precedes it with the token that follows it and treat the result as a single token. As the error message says, <code>&lt;uint8_t</code> is not a valid token. Just get rid of the <code>##</code>.</p>
",0
39660654,39660450,0,"<p>Why do you need to specify the type of the template parameter anyway?  If you don't specifically want a macro then just using your apply function directly will work just fine:</p>

<pre><code>    template &lt;class T&gt;
    void apply(const T &amp; input)
    {
        //...
    }

    apply(1.0f); // Will instantiate apply&lt;float&gt; to match the input's type
</code></pre>

<p>If you want the type <code>T</code> to be different from what is passed in, then I would suggest the following template instead:</p>

<pre><code>    template &lt;class T, class Input&gt;
    void apply(const Input &amp; input)
    {
        T t(input);
        //...
    }
</code></pre>

<p>Which can then be called with:</p>

<pre><code>    apply&lt;uint8_t&gt;(1.0f);
</code></pre>

<p>And there's no need for this macro at all.</p>
",0
35253327,35253181,0,"<p>You could add a constructor or destructor that runs an assertion test on the size, then rely on the programmer to pad it correctly. (Which seems the C++ way IMO)</p>

<p>That would ""make sure"" that it was being used properly.</p>

<p>You might be able to check it with <code>static_assert</code> which would give you a compile time error if it's used wrong.</p>

<p>... or ... </p>

<p>... or do something convoluted with recursive-templates and partial-specialization to find a matching definition that's a power of 2</p>
",0
36272183,36272132,3,"<p>If you try to print a <code>char *</code>, C++ assumes that it is a C-style null-terminated string.</p>

<p>It appears that you are allocating (and passing a pointer into) a <code>char</code> array without a terminating null -- so, the I/O library will follow that character with all the junk data that happens to be in memory, until it happens to encounter a null byte.</p>

<p>A simple solution is to pass either a <code>char</code> or a <code>char &amp;</code>, instead of a <code>char *</code>, so that the I/O will correctly interpret it as a single character.</p>

<p>However, that will not fix your memory leaks, which are a separate problem.  If you want to use C++ for anything beyond toy programs, you should make a habit of <code>delete</code>-ing anything allocated by <code>new</code> when you no longer need it.</p>

<p>Finally, as mentioned in comments, your code is very non-idiomatic for C++.  It is actually terribly educational to play around with low-level code like this, but the standard library has <code>std::string</code>'s and all sorts of containers that make it easier to manage your memory correctly, so make sure you learn how to use them, as well as understanding the lower-level features they are built on...</p>
",0
36272247,36272132,1,"<p>Change your ""Generate"" functions parameter from a pointer to a pointer reference:</p>

<pre><code>int Generator::Generate(char *&amp; ar)
</code></pre>

<p>And change the line:</p>

<pre><code>*ar = *arr;
</code></pre>

<p>that is in your ""Generate"" function to:</p>

<pre><code>ar = arr;
</code></pre>

<p>Also remember to clear any dynamic memory that ""ar"" may point to, when ""Generate"" is called.</p>

<p>I tested this code and it worked for me...</p>

<p><strong>EDIT</strong> In the ""for"" loop that displays your array, change the line:</p>

<pre><code>std::cout &lt;&lt; &amp;arr[generateChars] &lt;&lt; "" "";
</code></pre>

<p>to:</p>

<pre><code>std::cout &lt;&lt; arr[generateChars] &lt;&lt; "" "";
</code></pre>
",3
38881788,38881707,6,"<blockquote>
<pre><code>const std::pair&lt;guid, RadioTransmitterInformation&gt; &amp;t
</code></pre>
</blockquote>

<p>The value_type of a <code>map</code> always stores the key as <code>const</code>. But your <code>pair</code> here doesn't store the key as <code>const</code>. So to call your function, it has to copy the internal <code>pair</code> value into a temporary, which gets bound to a <code>const&amp;</code> parameter. And thus, gets deleted after calling your lambda.</p>

<p>Instead, use:</p>

<pre><code>const std::pair&lt;const guid, RadioTransmitterInformation&gt; &amp;t
</code></pre>

<p>Or even better:</p>

<pre><code>const decltype(mRTMap)::value_type &amp;t
</code></pre>

<p>Or even better-er if you have C++14:</p>

<pre><code>const auto &amp;t
</code></pre>
",2
38881799,38881707,2,"<p>If a map has type <code>std::map&lt;guid, RadioTransmitterInformation&gt;</code>, then it stores values of type <code>std::pair&lt;const guid, RadioTransmitterInformation&gt;</code> - note the <code>const</code>.</p>

<p>Since <code>std::pair&lt;guid, RadioTransmitterInformation&gt;</code> is a different type, the compiler has to generate a temporary <code>pair</code> to call your functors (in either version).</p>

<p>So try using <code>const std::pair&lt;const guid, RadioTransmitterInformation&gt;&amp;</code> arguments, or maybe <code>const decltype(mRTMap)::value_type&amp;</code>.</p>
",0
42550159,42550050,2,"<p>A couple of things to note:</p>

<ul>
<li>When you have UB the program can behave in any way, including the possibility of it working ""correctly"" (i.e. giving expected results)</li>
<li>There is no such thing as ""empty reference""</li>
</ul>

<p>Your code itself is fine, it's ok to have a reference to an object go out of scope. It is not ok to have the object that is being referenced to to go out of scope before the reference does (but note that there are cases when a const reference prolongs the lifetime of the object) and then to try use it via the reference.</p>
",4
42550395,42550050,1,"<p>Your code is fine.</p>

<pre><code>for(typename vector&lt;T&gt;::size_type index = 0; index &lt; v.size(); ++index)
{
    T&amp; local = v[index];
    ++local;
}
</code></pre>

<p>is analogous to</p>

<pre><code>int i = 0;
{
   int&amp; ref = i;
   ++ref;  // Changes the value of i
}
</code></pre>

<p>At the end of that, you would expect to see the value of <code>i</code> to be 1.</p>

<ol>
<li><code>ref</code> lives only in the nested scope. It can't be used outside the nested scope. It does not change the life of <code>i</code>.</li>
<li>Value of <code>i</code> is changed inside the nested scope through <code>ref</code>. <code>i</code> continues to be alive after the nested scope ends.</li>
</ol>
",0
34937156,34937071,5,"<p>While this is technically not ""wrong"", it definitely goes against the C++ paradigm.</p>

<p>The biggest problem you'll end up with is the confusion you'll cause yourself and anyone else who has to maintain the code.</p>

<p>As a general rule, use <code>new</code>/<code>delete</code> instead of <code>malloc</code>/<code>free</code> in C++. And for bonus points, use smart pointers and never deal directly with object allocation or de-allocation at all.</p>
",0
34937127,34937071,0,"<p>Technically it is legal, but why would you want to do that? Use <code>new</code> for everything.</p>

<blockquote>
  <p>what potential problems it may cause?</p>
</blockquote>

<p>Accidently using wrong deallocation. It is not easy to <em>just</em> get dynamic memory handling done properly. If you would increase complexiti with that...</p>
",2
34960248,34960125,1,"<p>If you have a pointer or smart pointer to the object, that means the object will be allocated from the heap.</p>

<p>If App has a direct Console member, then it is allocated from the same pool as the App object.</p>

<p>If Console stores the strings as std::strings or especially std::strings in a standard library container, then the storage does not matter very much because the string data would be dynamically allocated from the heap anyway.</p>

<p>So I'd recommend just having Console as a member because that is the most hassle free way, unless you have e.g. a need to change to a different Console while the App is running.</p>
",0
36310070,36309816,3,"<p><a href=""https://stackoverflow.com/questions/36309816/broken-string-in-exception/36310070#comment60243039_36309816"">As noted in the comments</a>, you can't return the <code>c_str</code> of a local <code>string</code> without creating undefined behavior. It might make sense to store a <code>string</code> cache of the <code>what</code> value on the exception itself; <a href=""http://www.cplusplus.com/reference/exception/exception/what/"" rel=""nofollow"">the <code>char*</code> returned by <code>what</code> needs to live as long as the exception object</a>, so caching on the exception is reasonable.</p>

<pre><code>class ParseException : public exception {
public:
    //Constructor
    //Arguments:
    //  Str: Message
    //  Pos: Position
    ParseException(string Str, int Pos) : msg(std::move(Str)), pos(Pos) {}

    //Get what happened(From exception)
    //Returns:
    //  Message with position
    virtual const char* what() const throw() {
        // Lazily populate what so it's not populated until called
        if (_what.empty()) {
            _what = msg + "" at "" + to_string(pos);
        }
        return _what.c_str();
    }
private:
    string msg; //Message
    int pos;    //Position
    string _what;
};
</code></pre>

<p>Alternatively, you compute the value in the constructor so <code>what</code> remains <code>nothrow</code> compatible (matching the C++ standard library exceptions).</p>
",0
42385698,42381790,1,"<p>As <a href=""https://stackoverflow.com/users/3943312/sam-varshavchik"">Sam Varshavchik</a> mentioned in the comment, you declared</p>

<pre><code>Element::Element()
</code></pre>

<p>on your Element header file but did not define it. Adding</p>

<pre><code>Element::Element() {
}
</code></pre>

<p>to your Element class file should allow the linker to find the missing symbol.</p>
",0
42385861,42381790,1,"<p>You have declared <code>Element();</code> constructor in Element header file but you have not defined it in any file.</p>

<p>You may want to add this in your Element implementation file:</p>

<pre><code>Element::Element() {
}
</code></pre>
",0
41214819,41214793,2,"<p>Can't you pass the vector by-reference?</p>

<pre><code>class Foo {
    void someMethod(std::vector&lt;lex&gt;&amp; words);
}

void Foo::someMethod(vector&lt;lex&gt;&amp; words) {

    words.push_back( (lex()) ); 
}
</code></pre>

<p>Usage:</p>

<pre><code>vector&lt;lex&gt; words;

Foo foo;
foo.someMethod( words );
</code></pre>

<p>Or by-pointer (if <code>nullptr</code> has meaning in your application, as references shouldn't be null):</p>

<pre><code>class Foo {
    void someMethod(std::vector&lt;lex&gt;* words);
}

void Foo::someMethod(vector&lt;lex&gt;* words) {

    if( words != nullptr ) {
        words.push_back( (lex()) ); 
    }
}
</code></pre>

<p>Usage:</p>

<pre><code>vector&lt;lex&gt; words;

Foo foo;
foo.someMethod( &amp;words );
</code></pre>
",1
36557332,36557076,0,"<p>Use <code>sprintf()</code> with <code>%d</code> as the format string , e.g.</p>

<pre><code>char logMessage[1000];
SYSTEMTIME st;
GetSystemTime(&amp;st);
sprintf(logMessage, ""Year: %d"", st.wYear);
</code></pre>

<p><code>logMessage</code> not contains <code>Year: 2016</code></p>
",0
36557344,36557076,3,"<p>You need to format the numeric <code>WORD</code> value to your character buffer, eg:</p>

<pre><code>SYSTEMTIME st;
GetSystemTime(&amp;st);

char logMessage [1000];
sprintf(logMessage, ""%hu"", st.wYear);
...
FILE *fp = fopen(""file.log"", ""a"");
fputs(logMessage, fp);
fclose(fp);
</code></pre>

<p>Or:</p>

<pre><code>SYSTEMTIME st;
GetSystemTime(&amp;st);

FILE *fp = fopen(""file.log"", ""a"");
fprintf(fp, ""%hu"", st.wYear);
...
fclose(fp);
</code></pre>

<p>Or, using C++ instead of C:</p>

<pre><code>#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;

SYSTEMTIME st;
GetSystemTime(&amp;st);

std::ostringstream logMessage;
logMessage &lt;&lt; st.wYear;
...
std::ofstream ofs(""file.log"", std::ios_base::app);
ofs &lt;&lt; logMessage.str();
ofs.close();
</code></pre>
",0
36557267,36557076,0,"<p>Addressing the title question directly, the <code>C++</code> way to it would be to simply do <code>year_str = std::to_string(st.wYear)</code> and work from that. </p>

<p>If you really need it as a <code>char*</code> then you can get it by doing <code>year_str.c_str()</code></p>
",1
47479962,47479372,1,"<p>You haven't given us much information about what <code>data_</code> is. Poking around in binary data is something to be avoided unless you absolutely have to. The better way to do it is to use structs or classes. The general cases of having raw binary data are (1) your data is completely defined in which case you can easily map the data onto a structure or (2) it is data with a header and variable length binary data. In the second case a trick is to make a
struct with the header data and have the last element of the structure a char array of length 1 where the variable length data starts.</p>

<pre><code>struct data_type
{
   // real definition
   char a[123];
   ...
   int entity_id;
   ...
   // end of header/fixed elements
   char blob[1]; // beginning of some variable length data.
};
</code></pre>

<p>Then</p>

<pre><code>sometype get_entity_id() {
  return ntohl(static_cast&lt; data_type&amp; &gt;(data_).entity_id);
}
</code></pre>

<p>*Note: This doesn't help if alignment is a problem as pointed out by @Fran?ois Andrieux (ie you are openning binary files written on machines or codes with different alignment rules). </p>
",5
45750443,45750416,3,"<p>The return type of the method is declared <code>R</code> and in your case this means <code>int</code>, not <code>string</code>.</p>
",0
45750521,45750416,2,"<p>In this line:</p>

<pre><code>class ToStringVisitor : public Visitor&lt;string, int&gt; {
                     parameter type (P) --^     ^-- return type (R)
</code></pre>

<p>you have to swap <code>string</code> with <code>int</code> because it mismatches the parameter that should be passed (<code>P = int</code>) and the return type (<code>R = string</code>):</p>

<pre><code>class ToStringVisitor : public Visitor&lt;int, string&gt; {
                   parameter type (P) --^      ^-- return type (R)
</code></pre>

<p>then it will be conform with the template class declaration.</p>
",0
36230072,36230038,0,"<p>I think you are trying to check if an entry exists. This is possible with <code>std::map</code>. Here is how to do it:</p>

<pre><code>store.find(name) != store.end()
</code></pre>
",0
42652844,42652689,0,"<pre><code>    int rows;
    cout &lt;&lt; ""Enter a number: "";
    cin &gt;&gt; rows;
    for (int y = rows; y &gt; 0; --y)
    {
        for (int x = rows; x &gt; 0; x--)
        {
            if (x &lt;= y) cout &lt;&lt; x &lt;&lt; "" "";
            else cout &lt;&lt; ""* "";
        }
        cout &lt;&lt; endl;
    }
</code></pre>
",1
42653041,42652689,0,"<p>This is how you could do it:</p>

<pre><code>cout &lt;&lt; ""Enter a number: "";
cin &gt;&gt; rows;
for (int y = rows; y &gt; 0; --y)
{
    for(int h = rows-y; h&gt;0; --h){
        cout&lt;&lt;""*"";

    }
    for (int x = y; x &gt;= 1; --x)
    {

        cout &lt;&lt; x &lt;&lt; "" "";
    }
    cout &lt;&lt; endl;
}
</code></pre>
",0
45680388,45680260,3,"<p>You have two options depending on whether they are used in a single file or in multiple files.</p>

<p><strong>Put them in an unnamed namespace.</strong></p>

<p>If the functions are used only within a single source code file, you can put them in an unnamed namespace within that file.</p>

<pre><code>namespace
{
    int iAlignUp( int a, int b ){return (a%b != 0) ? (a + b - a%b) : a;}
    int iDivUp( int a, int b ){return (a%b != 0) ? (a/b + 1) : (a/b);}
}
</code></pre>

<p><strong>Put them in a header file and an internal namespace.</strong></p>

<p>If the functions are used in multiple source code files, but not outside your project, you can put them in a header file included only within your project, and put them in an internal namespace.</p>

<pre><code>namespace project
{
namespace impl
{
    inline int iAlignUp( int a, int b ){return (a%b != 0) ? (a + b - a%b) : a;}
    inline int iDivUp( int a, int b ){return (a%b != 0) ? (a/b + 1) : (a/b);}
}
}
</code></pre>

<p>In this example, the <code>project::impl</code> namespace is not visible outside the project. It is not mentioned in any externally accessible header files.</p>
",1
41405651,41405630,2,"<p>You are trying to use one of overloads of <a href=""http://www.cplusplus.com/reference/string/string/insert/"" rel=""nofollow noreferrer"">std::string::insert</a> but none of them accept int and char:</p>

<p>One of the matching your needs is accepting position, count and symbol, so call <code>hexNum.insert(0, 1, hexConverstion[remainder]);</code></p>
",0
41405672,41405630,1,"<p>If you were thinking of using the following function:</p>

<pre><code>iterator insert( iterator pos, CharT ch );
</code></pre>

<p>you need to use:</p>

<pre><code>hexNum.insert(hexNum.begin(), hexConverstion[remainder]); 
</code></pre>
",0
41405673,41405630,0,"<p>That error is coming because there is no such <em>overloaded</em> version of <code>string::insert</code> which takes <code>int</code> and <code>char</code> as arguments. </p>

<p>You can use this overloaded version:</p>

<pre><code> string&amp; insert (size_t pos, size_t n, char c);                                 
</code></pre>

<p>where <code>n = 1</code> in your case, as you want to add a character once only.</p>

<p>, or    </p>

<pre><code>iterator insert (iterator p, char c);
</code></pre>

<p>where <code>p = hexNum.begin()</code></p>

<p>Checkout <a href=""http://www.cplusplus.com/reference/string/string/insert/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/string/string/insert/</a></p>
",0
34896412,34896296,6,"<p><strong>TL;DR:</strong> Don't try to do this.</p>

<p><strong>Full story:</strong></p>

<p>You ask:
""how can I make use of pointers or references such that the x-value doesn't get copied?""</p>

<p>If you are compiling your program with optimization turned on, the variables probably do not get copied anyway. Using pointers and/or references might just make things slower.</p>

<p>This leads me to a more important point: How do you even know that copying the values is taking a long time? Why would you expect that using pointers would take less time?</p>

<p>The way to optimize your code is to <em>measure</em> where the time is spent, then try to optimize that.</p>
",5
34896617,34896296,7,"<blockquote>
  <p>how can I make use of pointers or references such that the x-value doesn't get copied?</p>
</blockquote>

<p>By declaring the arguments as either pointers or references. But don't do that. Then you need to copy the address of the variable, which is just as slow, because the size of a double is same (or nearly same) as the size of a memory address. Not only that, but you need to dereference the pointer whenever you use it in the function. Or dereference it once and copy the value anyway.</p>

<blockquote>
  <p>Ideally the computation time and memory use should be the same as if I had never written rhobiweight, but implemented this function directly in tauscale.</p>
</blockquote>

<p>That would happen if the function is expanded inline by the optimizer. There is no standard way to force the compiler expand a function inline, but if the optimizer thinks it's advantageous, and you've enabled optimization, it will do that as long as the function is inlinable. To make the function inlinable, make sure that the definition is visible at the call site. A trivial way to do that is to declare the function <code>inline</code>.</p>

<p>Note that the peak memory use may actually be higher if many function calls are inlined.</p>
",0
39602221,39602114,1,"<pre><code>#include &lt;iostream&gt;
using namespace std;
class Two
{
public:
    int toReturn;
    Two()
    {
        toReturn=0;
    }

    int returnValue() 
    {
         return toReturn;
    } 
};

class One
{
 public:
     Two foo;
};

int main() 
{
    One bar;
    int toPrint=bar.foo.returnValue();
    cout &lt;&lt; toPrint &lt;&lt; endl;
} 
</code></pre>
",2
39602260,39602114,0,"<p>Yes, it can be done.  Let's dissect or rebuild.
First to get <code>Class1.Class2</code>, we need to have a class <em>member</em> called <code>Class2</code>.   And <code>Class2</code> needs to have a member called <code>Fct</code>.  </p>

<p>Here is one implementation:  </p>

<pre><code>struct Class2_Object
{
  void Fct(void);
};

struct Class1_Object
{
  Class2_Object Class2;
};

Class1_Object Class1;
Class1.Class2.Fct();
</code></pre>
",4
34922909,34922795,8,"<p>I don't see two more <code>return</code> in the code</p>

<p>I have added in the commented lines below:</p>

<pre class=""lang-cpp prettyprint-override""><code>int check_for_chef(string str1,string str2,int M,int N)
{
    if ( N == -1 )
    {
        cout &lt;&lt; ""I am returning 1."" &lt;&lt;endl;
        return 1;
    }
    else if ( N &gt; M )
    {
        cout &lt;&lt; "" I am returning 0."" &lt;&lt;endl;
        return 0;
    }
    else
    {
        if ( str1[M] == str2[N])
        {
            location[N] = M;
            cout &lt;&lt; ""location is: ""&lt;&lt;location[N]&lt;&lt;endl;

            return check_for_chef(str1,str2,M - 1, N - 1); // here 1st RETURN
        }
        else
        {
            return check_for_chef(str1,str2,M - 1, N); // here 2nd RETURN
        }
    }

}
</code></pre>
",2
34922912,34922795,3,"<p>Your code does not return anything expicitly in the <code>else</code> branch.
Values in x84 usually are returned via <code>EAX</code> register, so if you do not return anything - it behaves like an uninitialized variable.</p>
",0
42614475,26355998,0,"<p>So instead of:</p>

<pre><code>if (operation = 1)
</code></pre>

<p>do:</p>

<pre><code>if (operation == 1)
</code></pre>

<p>Also change your output to:
<code>cout &lt;&lt; ""Your answer is "" &lt;&lt; answer &lt;&lt; endl;</code></p>

<p>Another mistake:</p>

<pre><code>input - input2 == answer;
</code></pre>

<p>This is wrong. You have to make answer equal to <code>input - input2</code>. Also there should only be one <code>=</code>, because it is not a condition.</p>

<p>So:</p>

<pre><code>answer = input - input2;
</code></pre>

<p>Apply that to all your arithmetic inside the if statements. That should fix it.
But try to not use <code>system (""PAUSE"");</code> because it has its problems if you transfer your code. Just a suggestion.</p>
",0
47982750,47982722,4,"<ul>
<li><p><code>a++</code> returns what <code>a</code> was before, and then increments it, so originally your function would just return the argument and then add one. </p></li>
<li><p><code>++a</code> increments the variable and then returns, which is what you want here. </p></li>
</ul>
",0
45073204,45073029,1,"<p>There is no replacement for <code>freeze</code> in <code>ostringsteam</code> since it is no longer needed. In <code>ostrstream</code> <code>freeze()</code> is used to work around the deficiency that <code>str()</code> returns a c-style (<code>char *</code>) string.</p>
",0
45073301,45073029,6,"<p>You don't need <code>freeze()</code> in case of <code>std::ostringstream</code> - the necessity of calling this function was actually one of the reasons why <code>strstream</code> got deprecated in the first place. Because of its design (returning <code>char*</code> from <code>str()</code>) it wasn't clear who should clean the buffer that <code>strstream</code> holds and <code>freeze()</code> had to be used to signal that you want <code>strstream</code> itself to do it after every call to <code>str()</code> - in case of <code>std::ostringstream</code> you don't need to worry about this as <code>str()</code> returns a copy of the <code>std::string</code>.</p>
",0
36254231,36254202,1,"<p>Because it doesn't know it. Add the prototype above the class:</p>

<pre><code>   void *producer(void);
</code></pre>
",0
36254222,36254202,1,"<p>You need to declare the method before its usage.</p>

<pre><code>void * producent ( void );
class A
{
    public:
    void method()
    {
        pthread_t p;
        pthread_create(&amp;p, NULL, producent, NULL);
    }
};

void * producent ( void )
{
   return ( NULL );
}
</code></pre>
",0
36352213,36352044,0,"<p>You will probably need 2 for loops:</p>

<pre><code>for(int a=0; a&lt;MAX; a++) {
  for(std::vector&lt;int&gt;::const_iterator i = edges.begin(); i != edges.end(); ++i) {
    std::cout &lt;&lt; *i &lt;&lt; ' ';
  }
  std::cout &lt;&lt; endl;
}
</code></pre>

<p>and do same for cost. Note you will probably have empty lines, but you could modify your code to exclude empty vectors.</p>
",0
41225267,41225188,7,"<p>The factorials are typically very large, so you just have an integer overflow here. To fix this issue, you could implement any other algorithm of calculation <code>C(n, k)</code> not using factorials, for example:</p>

<pre><code>unsigned long long C(unsigned n, unsigned k) {
    if (n == k || k == 0) {
        return 1; // There's exactly one way to select n or 0 objects out of n
    }
    return C(n - 1, k - 1) * n / k;
}
</code></pre>

<p>Here the following recurrent rule is used: <code>C(n, k) = C(n - 1, k - 1) * n / k</code>. It's very easy to prove since <code>C(n, k) = n! / (k! (n-k)!) = (n/k) * (n-1)! / ((k-1)!(n-1-k+1)!)</code>.</p>
",9
42657248,42657060,3,"<p>Your class has a const member, while you are asking std::sort to basically swap instances of your class around. Unlike a Java ArrayList, which contains handles (garbage-collected pointers) to the objects, C++ STL containers <em>directly</em> contain the objects themselves. Thus, you cannot swap the instances around because that would mean overwriting a const object. Your solution will have to be one of the following:</p>

<ul>
<li>Sort a vector of pointers or references to the objects: you can use <code>vector&lt;MyClass*&gt;</code> or <code>vector&lt;reference_wrapper&lt;MyClass&gt;&gt;</code> if you have the instances elsewhere, or <code>vector&lt;unique_ptr&lt;MyClass&gt;&gt;</code> if the vector <em>owns</em> the instances.</li>
<li>Make the field non-const. Then your class will have a copy assignment operator (and a move ctor/op=, but with only that member it would be identical)</li>
<li>Provide a custom move/copy op= that uses <code>const_cast</code> to cast away the const-ness of the field. This is a <em>bad</em> idea, since the standard says it is undefined behaviour (i.e. the compiler and program may set your computer aflame if they want to) under certain cases. I don't remember the exact standardese, but you would have to be <em>very</em> careful not to fall in one of the jolly C++ undefined behaviour traps.</li>
</ul>
",1
42657254,42657060,3,"<p><a href=""http://en.cppreference.com/w/cpp/algorithm/sort"" rel=""nofollow noreferrer""><code>std::sort</code></a> requires that the elements the iterators point to are <a href=""http://en.cppreference.com/w/cpp/concept/MoveAssignable"" rel=""nofollow noreferrer"">MoveAssignable</a> and <a href=""http://en.cppreference.com/w/cpp/concept/MoveConstructible"" rel=""nofollow noreferrer"">MoveConstructible</a>.  You class is MoveConstructible but it is not MoveAssignable.  The reason for that is you have a <code>const</code> member.  You cannot assign to or move from a <code>const</code> member as that is a mutating operation.  You can provide you own copy or move assignment operator to get around this or just make the member non const.</p>
",0
46625735,23319346,0,"<p>Just call main(); again..
in your code will be like this:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

float add(float a, float b){
              return a+b;  
      }

int main(){

    float num1;
    float num2;    

    cout&lt;&lt;""add...enter digits \n"";
    cout&lt;&lt;""first digit: "";
    cin&gt;&gt;num1;
    cout&lt;&lt;""\n Second number: "";
    cin&gt;&gt;num2;

    cout&lt;&lt; ""your sum is: ""&lt;&lt;add(num1, num2)&lt;&lt;endl; 

    main();
}
</code></pre>
",0
39251092,39250909,9,"<p>If you declare your map with <code>std::map&lt;int, char *&gt;</code> the second member is just a pointer to a <code>char</code>.</p>

<p>In your code, this pointer points to the first <code>char</code> of your <code>buffer</code> and you add it several times in your <code>map</code> hence you get the same result at the end.</p>

<p>If you want to keep your map with the <code>char*</code> you have to allocate some memory to each entry you will add, and at the end free it.</p>

<p>I advise you to replace your <code>char *</code> by <code>std::string</code> and the manipulations will be way much simpler, as an example :</p>

<pre><code>#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

std::map&lt;int, std::string&gt; messages;
messages[0] = ""hello"";
messages[1] = ""how"";
messages[2] = ""are"";
messages[3] = ""you"";

std::cout &lt;&lt; messages[0] &lt;&lt; std::endl;
std::cout &lt;&lt; messages[1] &lt;&lt; std::endl;
std::cout &lt;&lt; messages[2] &lt;&lt; std::endl;
std::cout &lt;&lt; messages[3] &lt;&lt; std::endl;
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/a8af4fe9df2f951e"" rel=""noreferrer"">See on Coliru</a></p>
",0
39251025,39250909,0,"<p>What's happening there is that you change the value of the  memory your variable <code>buffer</code> points to. If you want to use <code>char*</code> then you have to allocate new memory for every message. But as some people in the comment mentioned, you can just use the <code>std</code> type <code>std::string</code> to do what you want to do. Then the memory management is done behind the scenes  </p>

<p>edit: changed the phrase at the beginning, because it was ambiguous!</p>
",4
38415282,38415161,2,"<p>Just casting the pointer to another type does not change the value to which the original pointer is pointing. You can only safe cast the values but not the pointers.</p>

<p>As you see your cast forces to read the other <code>int</code> value from index <code>x[1]</code> and displays it as <code>int64_t</code>.</p>

<p>Do not cast the pointer in your function - cast the value and then it works.</p>
",0
42625251,42624940,3,"<p>This boils down to <code>vector&lt;T&gt;</code> not needing to know the size a value of type <code>T</code> occupies, which allows <code>T</code> to be an incomplete type. Essentially, the mechanism in play here is the same as in this declaration:</p>

<pre><code>struct test {
    test* start;
    test* end;
};
</code></pre>

<p>The compiler has no problem declaring pointers to any type, as long as you promise to define it at some later point.</p>

<p>This behavior changes based on the template: you have no problem defining <code>test</code> with a <code>vector&lt;T&gt;</code>, but an <code>array&lt;T,Size&gt;</code> or even a <code>pair&lt;T,K&gt;</code> would be problematic:</p>

<pre><code>struct broken1 {
    array&lt;broken1,3&gt; a; // Does not compile
};
struct broken2 {
    pair&lt;broken2,broken2&gt; p; // Does not compile
};
</code></pre>
",0
38093231,38093010,2,"<p>Your problem is in these two lines.</p>

<pre><code>char g[10],j[10];
sprintf(j,""L_%dLprime_%dM_%dMprime_%d"",L,Lprime,M,Mprime);
</code></pre>

<p>You allocate a 10 character buffer for <code>j</code>, and then proceed to write more than 20 characters into that buffer, overrunning it, and invoking <a href=""https://stackoverflow.com/q/2397984"">Undefined Behavior</a>.</p>

<p>Once you're into UB, a segfault is just one of many things that will go wrong.</p>
",2
36234141,36234046,0,"<p>The compiler should give you a warning, that <code>value</code> will be truncated if you use <code>-Wconversion</code>.</p>

<pre><code>warning: conversion to 'uint16_t {aka short unsigned int}' from 'uint32_t {aka unsigned int}' may alter its value [-Wconversion]
uint16_t low1 = value;
                  ^
</code></pre>

<p>With bitmask g++ do not produce a warning...</p>
",1
36234166,36234046,2,"<p>The C++ standard guarantees that assignment to and initialization of unsigned types gives you the value modulo 2<sup><em>n</em></sup>, where <em>n</em> is the number of bits in the value representation of the unsigned type.</p>

<p>In Windows all bits participate in the value representation.</p>

<p>Hence using a bitmask serves no purpose other than to put a little stumbling block in the way for the future, when one might change the types.</p>

<hr>

<p>If you absolutely want to use a mask, e.g. to avoid a compilation warning from an over-zealous compiler, then you can do it in a type-independent way like this, assuming that the type is unsigned:</p>

<pre><code>uint16_t low2 = value &amp; uint16_t(-1);
</code></pre>

<p>Which relies on the aforementioned modulo-2<sup><em>n</em></sup> guarantee.</p>
",4
42467876,42467807,2,"<p>The answer depends on your required accuracy, the platform and a lot more. Here are a few suggestions:</p>

<h3>chrono</h3>

<p>Put this at some place in your code that is executed often enough. However, this only works if you use C++11 (or later). And you should!</p>

<pre><code>using namespace std::chrono;

/* Put this outside of your function or loop */
auto lastOutputTime = steady_clock::now();

/* Put this inside of your function or loop */
auto now = steady_clock::now();
if (now - lastOutputTime &gt;= 60s) {
  auto throughput = getCurrentThroughput();
  std::cout &lt;&lt; ""Throughput: "" &lt;&lt; throughput &lt;&lt; std::endl;
  lastOutputTime = now;          
}
</code></pre>

<h3>clock()</h3>

<p>Another option that would even work in C (apart from the output itself). However, as @Some programmer dude pointed out this method depends on the platform. Usually you measure CPU time with this and not wall-clock time. So it might or might not be sufficiently accurate for you.</p>

<pre><code>/* Put this outside of your function or loop */
clock_t lastOutputTime = 0;
clock_t now = clock();

/* Put this inside of your function or loop */
if(now - lastOutputTime &gt; CLOCKS_PER_SEC*60) {
  double throughput = getCurrentThroughput();
  std::cout &lt;&lt; ""Throughput: "" &lt;&lt; throughput &lt;&lt; std::endl;
  lastOutputTime = now;
}
</code></pre>

<p>For using <code>clock()</code> you have to add the following to your header</p>

<pre><code>#include &lt;ctime&gt;
</code></pre>

<h3>time()</h3>

<p>If you need wall-clock time and C++11 is not available, you can use <code>time()</code>. However, it only provides an accuracy of one second, which might or might not enough for you.</p>

<pre><code>/* Put this outside of your function or loop */
time_t lastOutputTime;
time(&amp;lastOutputTime);

/* Put this inside of your function or loop */
time_t now;
time(&amp;now);
if(difftime(now,lastOutputTime) &gt;= 60) {
  double throughput = getCurrentThoughput();
  std::cout &lt;&lt; ""Throughput: "" &lt;&lt; throughput &lt;&lt; std::endl;
  lastOutputTime = now;
}
</code></pre>
",9
42468067,42467807,0,"<h3>Your question is really unclear.</h3>

<p>Here are some thoughts.</p>

<p>If you are coding your program and can modify its source code, you could just add some server abilities into it for instrumentation purposes. For example, you might add some HTTP server abilities: you'll use some HTTP server library like <a href=""http://coralbits.com/libonion/"" rel=""nofollow noreferrer"">libonion</a> and you could e.g. improve your code so that it serves on the <code>http://localhost:4567/status</code> URL and gives, as an HTTP response to every <code>GET http://localhost:4567/status</code> HTTP request, some JSON content with the appropriate status variable. BTW, this is <strong>what I recommend</strong> to do.</p>

<p>You could also have your program compiled with all debug options (e.g. compile it with <code>g++ -g -O</code>) and use some clever script which would: stop the process with SIGSTOP signal, start some <code>gdb -p</code> command, use <code>backtrace</code> and <code>print</code> gdb commands, and continue the process with SIGCONT</p>

<p>You might also consider <a href=""http://man7.org/linux/man-pages/man5/proc.5.html"" rel=""nofollow noreferrer"">proc(5)</a>. Maybe a clever use of <a href=""http://man7.org/linux/man-pages/man1/strace.1.html"" rel=""nofollow noreferrer"">strace(1)</a> might be enough.</p>

<p>You could put important variables into a shared memory segment (use a pointer and some public <code>struct</code>, code an utility to read from that shared memory segment). Read <a href=""http://man7.org/linux/man-pages/man7/shm_overview.7.html"" rel=""nofollow noreferrer"">shm_overview(7)</a> (and <a href=""http://man7.org/linux/man-pages/man7/sem_overview.7.html"" rel=""nofollow noreferrer"">sem_overview(7)</a> for synchronization purposes).</p>

<p>You may think of other <a href=""https://en.wikipedia.org/wiki/Inter-process_communication"" rel=""nofollow noreferrer"">inter-process communications</a>. See <a href=""http://man7.org/linux/man-pages/man7/socket.7.html"" rel=""nofollow noreferrer"">socket(7)</a>, <a href=""http://man7.org/linux/man-pages/man7/pipe.7.html"" rel=""nofollow noreferrer"">pipe(7)</a>, <a href=""http://man7.org/linux/man-pages/man7/fifo.7.html"" rel=""nofollow noreferrer"">fifo(7)</a> and read <a href=""http://advancedlinuxprogramming.com/"" rel=""nofollow noreferrer"">Advanced Linux Programming</a>.</p>

<p>You could start an extra (instrumenting) thread which would log into some file, etc...</p>

<p>See also <a href=""http://man7.org/linux/man-pages/man7/time.7.html"" rel=""nofollow noreferrer"">time(7)</a> &amp; <a href=""http://man7.org/linux/man-pages/man7/signal.7.html"" rel=""nofollow noreferrer"">signal(7)</a></p>

<p>Perhaps your program should have a proper <a href=""https://en.wikipedia.org/wiki/Event_loop"" rel=""nofollow noreferrer"">event loop</a> (see <a href=""http://man7.org/linux/man-pages/man2/poll.2.html"" rel=""nofollow noreferrer"">poll(2)</a>...).</p>

<p>Otherwise, your quest is impossible: at runtime, C++ variables don't exist anymore (they are in registers, or in memory locations).</p>

<p>So depending on what you really want to do, it can be easy or impossible.</p>
",0
38092362,38091585,2,"<p>As stated in the comment, it is not possible with standard C++.</p>

<p>But as your goal is to reduce the number of reallocate and copy operations, you can achieve it by allocating memory in advance:</p>

<p>If your container is full and you want to add another element, don't just increase the capacity by one, instead increase it by say, 25% or 50%. This will reduce the number of reallocate and copy operations from O(n) to O(log(n)) when adding single elements to your container. Of course this advantage comes at the cost of additional memory being allocated. However your original suggestion also relies on free memory being available, so there is not really a difference.</p>

<p>A similar strategy seems to be used by common implementations of <code>std::vector</code>.</p>
",0
38094766,38091585,0,"<p>The function <code>std::realloc</code> may help you.</p>
<blockquote>
<p>The reallocation is done by either:</p>
<p>a) expanding or contracting the existing area pointed to by ptr, if possible. The contents of the area remain unchanged up to the lesser of the new and old sizes. If the area is expanded, the contents of the new part of the array are undefined.</p>
<p>b) allocating a new memory block of size new_size bytes, copying memory area with size equal the lesser of the new and the old sizes, and freeing the old block.</p>
</blockquote>
<p>See also <a href=""http://en.cppreference.com/w/cpp/memory/c/realloc"" rel=""nofollow noreferrer"">cppreference</a></p>
",3
37901177,37901066,3,"<p>You can't. The standard says one can write <code>using namespace myns;</code> to get all the names, and there is nothing you can do about that.</p>

<p>If the user gets collisions after <code>using namespace XXX;</code>, that's their own fault. Generally, it is not possible to stop people from shooting themselves in the foot if they try to.</p>

<p>In the end, pulling in all names from some third party namespace is not something that happens on accident, but has been discouraged since about the dawn of time. If the user decides to do it anyways, they better know what they are doing. Really not the problem of the library maintainer.</p>
",2
37901387,37901066,1,"<p>One (questionable) workaround I can think of is replacing your namespace with a class or a struct of the same name and turning everything in your namespace into a (static) member of this class.</p>

<pre><code>struct myns final
{
    class MyClass
    {

    }

    class string
    {

    }

private:
    // private constructor, copy constructor and assignment operator
    // ...
};
</code></pre>

<p>This would preclude programmers, using your library from writing <code>using namespace myns</code> but... well, like I said, I consider such a workaround to be quite questionable.</p>

<p>Note that users will still be able to use type aliases, such as:</p>

<pre><code>using string = myns::string;
</code></pre>
",0
34925398,34924799,2,"<p>not sure if you are talking about generic headers of a library, for example vec.h and mat.h, and for some reason you want to express rules to avoid to have:</p>

<pre><code>#include &lt;vec.h&gt;
#include &lt;mat.h&gt;
</code></pre>

<p>If that is the case I don't think that is possible, on the other hand if you are talking about same header from different library version, like vec_2_0.h , vec_2_1.h I would talke the problem differently (well first of all if I could name the headers I would not write the version on the header itself).</p>

<p>The way I would tackle is by separating the includes in the folder structure example:</p>

<pre><code>mathlib:

-----&gt; mathlib_2_0
---------&gt; includes
----&gt; mathlib_2_1
--------&gt;  includes
</code></pre>

<p>Then you can enforce at project settings to avoid picking one over the other, rather then trying to fix that in the file itself.</p>

<p>Maybe what you can do (but I think is ugly) is to wrap all the possible header include in a macro and use a define version to have the processor leaving only the correct one.
Example:</p>

<pre><code>Compiler flag -DMathVersion 2_0
</code></pre>

<p>The macro:</p>

<pre><code>INCLUDE_VECTOR_HEADER()
{
#if MathVersion == 2_0
#include &lt;vec_2_0.h&gt;
#elif MathVersion == 2_1
#include &lt;vec_2_1.h&gt;
#endif
}
</code></pre>

<p>But I think is way overkill and a bit ugly, maybe can be generalized in having the version as parameter of the macro. I would not go down that road personally.
PS: All is pseudo code just to give an idea</p>
",2
34926666,34924799,2,"<p>A run time check is doable language-only. (In another post I'll suggest a number of build-time checks.)</p>

<p>This is not elegant. I have a nagging feeling that somebody will come up with a 2-liner for this. But for what it's worth.</p>

<p>Each header defines a class which will be instantiated once for each translation unit when the program starts. (We need a class because we need to run ctor code in order to check a value.) The ctor of each class reads a global <code>sentinel</code> and checks whether it has the wrong magic value (it will be 0 initially as a global). If not, it assigns its own. It does not rely on the initialization order of the static objects. I am not sure whether we need to protect sentinel from concurrent access here; I hope not.</p>

<p>lib.cpp (your library):</p>

<pre><code>int sentinel;
// other lib stuff
// ...
</code></pre>

<p>f1.h (one of the two headers):</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
using namespace std;

extern int sentinel;

struct f1duplGuard
{
    enum { f1=0xf1, f2= 0xf2 };

    f1duplGuard() 
    { 
        cout &lt;&lt; ""f1 duplGuard() "" &lt;&lt; endl;
        if( ::sentinel == f2 ) 
        {
            cerr &lt;&lt; ""f1: include violation -- must be a f2 somewhere"" &lt;&lt; endl;
            exit(1); 
        }
        sentinel = f1;
    }
};

static f1duplGuard dg;
</code></pre>

<p>f2.h (the other header -- the moirror image with a different constant):</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;cstdlib&gt;
using namespace std;

extern int sentinel;

struct f2duplGuard
{
    enum { f1=0xf1, f2= 0xf2 };

    f2duplGuard() 
    { 
        cout &lt;&lt; ""f2 duplGuard() "" &lt;&lt; endl;

        if( ::sentinel == f1 ) 
        {
            cerr &lt;&lt; ""f2: include violation -- must be a f1 somewhere"" &lt;&lt; endl;
            exit(1); 
        }
        sentinel = f2;
    }
};

static f2duplGuard dg;
</code></pre>

<p>One TU using the lib, including one of the two f headers</p>

<pre><code>#include &lt;iostream&gt;
#include ""f2.h""      // changing this to f1.h fails at run time

using namespace std;


void f(void)
{
    cout &lt;&lt; ""second.cpp, f()"" &lt;&lt; endl;
}
</code></pre>

<p>The second TU using the lib, including an f header, too (with main):</p>

<pre><code>#include &lt;iostream&gt;
#include ""f2.h""

extern void f();

using namespace std;

int main(void)
{
    f();
    return 0;
}
</code></pre>

<p>Phew. If you change one of the two includes to the other header, you trigger an error message and exit.</p>

<p>Sample session (without the error):</p>

<pre><code>$ g++ -O0 -std=c++14  -o dupl-static -Wall second.cpp dupl-static.cpp lib.cpp &amp;&amp; ./dupl-static
f2 duplGuard()
f2 duplGuard()
second.cpp, f()
</code></pre>

<p>Sample session with error:</p>

<pre><code> cat dupl-static.cpp &amp;&amp; g++ -std=c++14  -o dupl-static -Wall second.cpp dupl-static.cpp lib.cpp &amp;&amp; ./dupl-static
#include &lt;iostream&gt;
#include ""f1.h""

extern void f();

using namespace std;

int main(void)
{
        f();
}
f1 duplGuard()
f2 duplGuard()
f2: include violation -- must be a f1 somewhere
</code></pre>
",2
34927571,34924799,2,"<p>You're working with Visual C++ then <strong>it can be done</strong> (but be warned that it's not portable and you will get warnings instead of errors unless you use <code>/WX</code>). With GCC (maybe, I didn't try) you may use somehow <code>#pragma weak</code>.</p>

<p>Because each compilation unit is compiled separately then you have to find <em>something</em> at linker level (exporting a function, changing a setting). Easiest way I found is to declare a section and allocate a dummy variable on it. If this section is declared with different attributes on your headers then linker will complain.</p>

<p>You have to add this to <strong>Header1.h</strong>:</p>

<pre><code>#pragma section(""mylib_priv_impl_section"",read)
__declspec(allocate(""mylib_priv_impl_section"")) static int mylib_priv_impl_var = 0;
</code></pre>

<p>And then in <strong>Header2.h</strong>:</p>

<pre><code>#pragma section(""mylib_priv_impl_section"",read,write)
__declspec(allocate(""mylib_priv_impl_section"")) static int mylib_priv_impl_var = 0;
</code></pre>

<p>Now when you compile and link you will get this warning:</p>

<blockquote>
  <p>multiple 'mylib_priv_impl_section' sections found with different attributes (C0300040)</p>
</blockquote>

<p>Because we declared same section with different attributes (<code>read</code> in Header1 and <code>read+write</code> in Header2). Unfortunately it's just a warning (you may use section name to give some useful diagnostic message) and to stop compilation you must specify <code>/WX</code> (unfortunately ignored by <code>#pragma comment(linker, ""/WX"")</code>).</p>

<p>Note that we need that <em>dummy</em> variable otherwise  our declared section (if unused) will be simply ignored. Nothing else but our dummy variable will be placed in that section (see also <a href=""https://stackoverflow.com/q/23416861/1207195"">Scope of __declspec allocations</a>).</p>

<hr/>

<p>Note that if a preprocessor macro is viable then also a solution similar to what <a href=""https://stackoverflow.com/a/34925398/1207195"">Marco Giordano</a> suggested will work smoothly. I'd just change the way it work to throw an error if you're including Header1 but you set you want to use Version2 (and vice-versa) instead of having a macro for inclusion. Something like this (in Header1 and specular in Header2):</p>

<pre><code>#if MyLibVersion != 1
#error You are including version 1 headers, please set MyLibVersion accordingly.
#endif
</code></pre>
",7
34945058,34924799,0,"<p>I see several ways to do that at build time (but with the help of mechanisms beyond just the compiler/linker).</p>

<h3>Pre-compile: <a href=""https://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html#index-M-1043"" rel=""nofollow"">Use gcc's dependency generator.</a></h3>

<p>gcc has an option to walk the include tree for each file on the command line and list its dependencies, among them the directly or indirectly included header files. Obviously this needs gcc, but it won't actually compile anything, so it could be a pre-build command in VS with a cygwin gcc. Probably only minimal configuration is necessary because the option <code>-MG</code> lets gcc handle ""missing"" headers gracefully. (In order to follow nested includes it will be necessary to use <code>-I</code> in order to define include paths.) </p>

<p>As an example let's assume we have three files.<br>
1.c:</p>

<pre><code>#include ""header1.h""
</code></pre>

<p>2.c :</p>

<pre><code>#include &lt;stdio.h&gt;
#include ""2.h""
</code></pre>

<p>and 2.h:</p>

<pre><code>#include ""header2.h""
</code></pre>

<p>Sample session:</p>

<pre><code>$ ls &amp;&amp; echo ""-------"" &amp;&amp; gcc -MM -MG *.c
1.c  2.c  2.h
-------
1.o: 1.c header1.h
2.o: 2.c 2.h header2.h
</code></pre>

<p>This can be simply grepped for the header names.</p>

<h3>Compile time:</h3>

<h3>Define a C preprocessor token during the build and check it in the headers</h3>

<p>Agree on two well-known tokens, of which exactly one will be defined by the build environment for any build; the headers check against them with an <code>#ifdef</code>. For example, <code>header1.h</code> could contain the line</p>

<pre><code>#ifdef USE_HEADER2
#   error ""Using header1.h although USE_HEADER2 is defined""
#endif
</code></pre>

<p>In a make environment one could define <code>USE_HEADER2</code> by passing a <code>-D</code> option, like <code>make -DUSE_HEADER_1</code> ...` or the like. In Visual Studio one would define the symbol in the Build properties of the project.</p>

<p>This will not work for incremental builds, because between builds the setting might change. That is surely a source of errors; only doing complete rebuilds as a remedy is prohibitive for large projects.</p>

<h3>Post-Compile: Define a static string in each header and grep the binaries for it</h3>

<p>This is inspired by @MSalters' suggestion in the comments, but possibly a bit simpler. Define a distinct static string in each header. For <code>header1.h</code>, that could be </p>

<pre><code>volatile static char str[] = ""HEADER_1_INCLUDED"";
</code></pre>

<p>(Without the <code>volatile</code> the compiler would dismiss the never-used string when built with optimization. This could be implementation specific. I used gcc 4.9.3.) </p>

<p>After a build you just check all library and object files for both strings and fail if both are there:</p>

<pre><code> if grep -q  ""HEADER_1_INCLUDED"" *.o *.a *.lib *.dll &amp;&amp;  grep -q  ""HEADER_2_INCLUDED"" *.o *.a *.lib *.dll; 
 then handle_error; 
 fi
</code></pre>
",0
41908450,41906413,0,"<p>if i got your question right, you're simply looking to sort your list
in two ways (alphabetically and birthdate) 
note: i will use bubble sort to simplify the algorithm but you can use better one as you know</p>

<pre><code>#include &lt;iostream&gt;


struct node{
    const char* name;
    int birthdate;
    node*next;
};

struct sort_data{
private:
    node *name_root = nullptr; // alphabetically head/root pointer
    node *date_root = nullptr; // birthdate head/root pointer
public:
    void push(const char*name,int birthdate); // push data;
    void sort_by_birth(); // sort the birth linked list
    void sort_by_alphabet(); // sort the alphabet linked list
    void print_birth(); // print the data of the birth linked list
    void print_alph(); // print of the data of the alphabet linked list
};


void sort_data::push(const char*name,int birthdata) {
    node*Name = new node; // allocate a node for the alphabet list
    node*Date = new node; // allocate a node for the date list

    Name-&gt;name = Date-&gt;name = name; 
    Name-&gt;birthdate = Date-&gt;birthdate = birthdata;
    Name-&gt;next = name_root;
    Date-&gt;next = date_root;

    name_root = Name;
    date_root = Date;

}

void sort_data::sort_by_birth() {
    node*i = date_root;
    node*j;

    if(!i) // if i == nullptr 
        return;

    while(i){ // while(i!=nullptr)
        j = i-&gt;next;
        while(j){
            if(i-&gt;birthdate &gt; j-&gt;birthdate){
                std::swap(i-&gt;birthdate,j-&gt;birthdate);
                std::swap(i-&gt;name,j-&gt;name);
            }
            j = j-&gt;next;
        }
        i = i-&gt;next;
    }
}

void sort_data::sort_by_alphabet() {

    node*i = name_root;
    node*j;

    if(!i)
        return;

    while(i){
        j = i-&gt;next;
        while(j){
            if(i-&gt;name[0] &gt; j-&gt;name[0]){
                std::swap(i-&gt;birthdate,j-&gt;birthdate);
                std::swap(i-&gt;name,j-&gt;name);
            }
            j = j-&gt;next;
        }
        i = i-&gt;next;
    }
}

void sort_data:: print_birth(){
    node*temp = date_root;

    while(temp){
        std::cout &lt;&lt; temp-&gt;name &lt;&lt; "" "" &lt;&lt; temp-&gt;birthdate &lt;&lt; std::endl;
        temp = temp-&gt;next;
    }

}

void sort_data::print_alph() {

    node*temp = name_root;

    while(temp){
        std::cout &lt;&lt; temp-&gt;name &lt;&lt; "" "" &lt;&lt; temp-&gt;birthdate &lt;&lt; std::endl;
        temp = temp-&gt;next;
    }

}




int main(){


    sort_data obj;
    obj.push(""jack"",1997);
    obj.push(""daniel"",1981);
    obj.push(""maria"",1995);
    obj.push(""john"",2008);
    obj.sort_by_alphabet();
    obj.sort_by_birth();
    std::cout &lt;&lt; ""alphabetically : \n"" ;
    obj.print_alph();

    std::cout &lt;&lt; ""by birthdate : \n"";
    obj.print_birth();



}
</code></pre>

<p>note: because you're using C++ don't use char* to store string literals
use std::string or const char *. as the chars in string literals are const char so you don't want to point on const char with char
if you're using a C++ compiler that support C++11 your compiler should generate a warning about such thing </p>
",0
43211214,43211102,2,"<p>Read <a href=""http://en.cppreference.com/w/cpp/container/map/emplace"" rel=""nofollow noreferrer""><code>std::map::emplace</code>'s documentation</a>:</p>

<blockquote>
  <p>The constructor of the new element (i.e. <code>std::pair&lt;const Key, T&gt;</code>) is called with exactly the same arguments as supplied to emplace, forwarded via <code>std::forward&lt;Args&gt;(args)...</code>.</p>
</blockquote>

<pre><code>struct Vertex 
{
    Vertex(unsigned identifier, int type, unsigned attributes) {}
};

int main()
{
    std::map&lt;unsigned, Vertex&gt; vertexes;

//                       Vertex
//                       vvvvvvvvvvvvvvvvv
    vertexes.emplace(0u, Vertex{0u, 1, 0u});
//                   ^^
//       const unsigned
}
</code></pre>

<p><a href=""https://wandbox.org/permlink/8lJACrQeTXFguOgu"" rel=""nofollow noreferrer""><strong>live wandbox example</strong></a></p>
",0
39668452,39666177,0,"<p>First of all, finding the length of a number is very simple. In c++, it is just <code>ceil(log10(number))</code> when using math.h.  On to your code, you can use a very simple function to turn the input of numbers into a vector.  For example:</p>

<pre><code>//input number of racers (int racerNum)
//input number of races (int raceNum)
vector&lt;vector&lt;int&gt;&gt; result(raceNum, vector&lt;int&gt;(racerNum));
for (int race=0; race&lt;raceNum; race++){
    //input race results as one string of integers without spaces (int rResult)
    int curVal = rResult;
    for (int place = racerNum-1, input=0; place &gt;= 0; place--, input++){
        curVal = floor(rResult/pow(10,place));
        result.at(race).at(place) = curVal;
        rResult -= curVal*pow(10, place);
    }
}
</code></pre>

<p>Or, you may want to use the example you had before, where you input the results with spaces.  This will allow you to have more than 9 racers, and it is probably simpler.  It utilizes the fact that cin will separate a string with spaces into smaller strings. For example:</p>

<pre><code>//get number of racers (int racerNum)
//get number of races (int raceNum)
vector&lt;vector&lt;int&gt;&gt; raceResults;
for (int race=0; race&lt;raceNum; race++){
    vector&lt;int&gt; singleResult;
    cout &lt;&lt; ""Results of race "" &lt;&lt; race+1 &lt;&lt; "":"";
    //get input with spaces
    for (int counter=0; counter&lt;racerNum; counter++){
        int result;
        cin &gt;&gt; result;
        singleResult.push_back(result);
    }
    raceResult.push_back(singleResult);
}
</code></pre>

<p>I would recommend the second example, but the first will also work just as well.  The first is just the purely mathematical approach, and the second utilizes the way cin gets input.  Either way, you will be left with a vector or races, each of which is a vector of the results, in the proper order.  I think that this should be enough to get you started, but if you need any help with the rest of the code or with this code, I can help.</p>
",2
35209148,35208901,0,"<p>As far as I understood, you just need number of divisors. Find all the prime divisors and write the <code>x1^a1 * x2^a2 ... * xn^an</code>. The number of divisors equal to <code>(a1+1)*(a2+1)*...*(an+1)</code></p>

<p>For example, <code>12=2^2*3^1</code>, therefore, it has <code>(2+1)*(1+1) = 6</code> divisors, i.e. <code>1,2,3,4,6,12</code>. I didn't test the code but it should work.</p>

<pre><code>int main()
{
     int n,i=2,d=0;
     int num_div = 1;
     while(i &lt;= sqrt(n))
     {
         int cnt = 0;
         while(n % i == 0){
             cnt++;
             n /= i;
         }                 
         if (cnt != 0)
             num_div *= (cnt+1);
         i++; 
     }
     cout&lt;&lt;num_div;
}
</code></pre>

<p>Check this <a href=""https://stackoverflow.com/a/110365/2021883"">answer</a>  </p>
",0
46652150,46652046,5,"<p>The reaons is to allow <code>EOF</code> as input. And <code>EOF</code> is (from <a href=""http://en.cppreference.com/w/cpp/io/c"" rel=""noreferrer"">here</a>):</p>

<blockquote>
  <p>EOF   integer constant expression of type int and negative value</p>
</blockquote>
",0
41218811,41218740,5,"<p>I'd be inclined to read a <code>std::string</code>:</p>

<pre><code>std::string foo;
cin &gt;&gt; foo;
</code></pre>

<p>Then use </p>

<p><code>bool is_only_digits = std::all_of(foo.begin(), foo.end(), ::isdigit);</code></p>

<p>to check if the input contains only numbers. (You can also use <code>foo.size()</code> to check the string length).</p>

<p>This will be <em>much</em> easier to fashion into a loop.</p>
",0
41218835,41218740,2,"<p>Try by modifying your code as below.</p>

<pre><code>while(true)
{
    i=0;

    while(i&lt;codeLength &amp;&amp; code[i] &gt;= '0' &amp;&amp; code[i] &lt;= '9')
        i++;

    if(i != codeLength)
    {
        cout &lt;&lt; ""The code is not valid: "" &lt;&lt; codDat &lt;&lt; endl;
        cout &lt;&lt; ""Enter the code again: "";
        cin &gt;&gt; code;
    }
    else
        break;
}
</code></pre>
",0
36227949,36227785,0,"<p>Here you push back <code>n-1</code> elements</p>

<pre><code>vector&lt;string&gt;A;
for(int i = 2; i &lt;= n; ++i) // fills the whole table with ""true"" from 0 to n-2
    A.push_back(""true"");
</code></pre>

<p>but here you access your vector from <code>A[2]</code> to <code>A[n]</code>.</p>

<pre><code>//print the prime numbers
for(int i = 2; i &lt;= n; ++i)
{
    if(A[i] == ""true"")
        cout &lt;&lt; i &lt;&lt; '\n';
}
</code></pre>

<p><code>A</code> has elements at positions <code>A[0]</code> to <code>A[n-2]</code>. You might correct this defect by initializing your vector differently. For example as</p>

<pre><code>vector&lt;string&gt; A(n+1, ""true"");
</code></pre>

<p>This creates a vector <code>A</code> with <code>n+1</code> strings with default values ""true"" which can be accessed through <code>A[0]</code> to <code>A[n]</code>. With this your code should run, even if it has more deficits. But I think you learn most if you just try to successfully implement the sieve and then look for (good) alternatives in the internet.</p>
",0
36227962,36227785,-3,"<p>This is painful. Why are you using a string array to store boolean values, and not, let's say, an array of boolean values? Why are you leaving out the first two array elements, forcing you to do some adjustment of all indices? Which you then forget half the time, totally breaking your code? At least you should change this line:</p>

<pre><code>i -= 2; // because I built the vector from 0 to n-2, i need to reflect that here.
</code></pre>

<p>to:</p>

<pre><code>i -= 2; // because I left the first two elements out, I that here.
// But only here, doing it everywhere is too annoying. 
</code></pre>

<p>As a result of that design decision, when you execute this line: </p>

<pre><code>    for(int j = pow(i, 2); j &lt;= n; j += i)
</code></pre>

<p>i is actually <em>zero</em> which means j will stay zero forever. </p>
",1
43236628,43236477,6,"<blockquote>
  <p>but implements the usual functions ...</p>
</blockquote>

<p>You mean like the array overloads of <a href=""http://en.cppreference.com/w/cpp/iterator/begin"" rel=""nofollow noreferrer""><code>std::begin</code></a> and <a href=""http://en.cppreference.com/w/cpp/iterator/end"" rel=""nofollow noreferrer""><code>std::end</code></a>, which enable new-style <code>for</code> loops to work automatically?</p>

<blockquote>
  <p>...and iterators</p>
</blockquote>

<p>And the fact that raw pointers are automatically RandomAccessIterators, because that's how iterators were designed?</p>

<hr>

<p>That is, the modern idioms</p>

<pre><code>int a[] = {1, 2, 3, 4, 5, 6};
// demonstrate that the overloads exist ...
auto b = std::begin(a);
auto e = std::end(a);
// and that b,e work correctly as InputIterators ...
std::cout &lt;&lt; ""distance="" &lt;&lt; (std::distance(b, e)) &lt;&lt; '\n';
std::cout &lt;&lt; ""elements="" &lt;&lt; (sizeof(a)/sizeof(a[0])) &lt;&lt; '\n';
// and further that they're explicitly described as RandomAccessIterators ...
std::cout &lt;&lt; ""random access=""
    &lt;&lt; std::is_same&lt;std::iterator_traits&lt;decltype(b)&gt;::iterator_category,
                    std::random_access_iterator_tag&gt;::value &lt;&lt; '\n';
// and finally that new-style for just works ...
std::cout &lt;&lt; ""{"";
for (auto i : a) {
    std::cout &lt;&lt; i &lt;&lt; ',';
}
std::cout &lt;&lt; ""}\n"";
</code></pre>

<p>will give the expected output:</p>

<pre><code>distance=6
elements=6
random access=1
{1,2,3,4,5,6,}
</code></pre>

<p>You're out of luck if you wanted to write</p>

<pre><code>for (auto i = a.begin(); i != a.end(); ++i)
</code></pre>

<p>instead, but why would you?</p>
",6
43236853,43236477,2,"<p>Visual Studio has an <a href=""https://msdn.microsoft.com/en-us/library/hh305260.aspx"" rel=""nofollow noreferrer""><code>array_view</code> class</a> for this very purpose:</p>

<blockquote>
  <p>Represents an N-dimensional view over the data held in another container.</p>
</blockquote>
",0
43236611,43236477,3,"<p>No, there's not anything in the standard library for that particular task (though <code>std::array</code> sort of reverses the situation: it doesn't let you wrap around an existing array, but does basically guarantee that its storage will be a simple array).</p>

<p>The <a href=""https://github.com/Microsoft/GSL/tree/master/include/gsl"" rel=""nofollow noreferrer"">Guideline Support Library</a> does include a <code>span</code> class for pretty much this purpose though.</p>
",0
46033576,46033106,0,"<p>When you call <em>new</em> (overloaded or not), you are constructing an object, so there is no object yet, and you can not answer the question ""which object invokes the call?"". </p>

<p>When you create an object of a specified class (on heap or stack) one of the constructors of that class is called. 
When the <em>new</em> operator is overloaded, the overloaded <em>new</em> will be used to allocate required memory for that object.</p>

<p>The caller is not an object of that class!</p>
",0
46033844,46033106,2,"<p>Let's separate things into proper terms:</p>

<p>When you write <code>new Test</code>, it is a ""new expression"". The semantics of the new expression is to call the appropriate allocation function (an overload of <code>operator new</code>) and initialize an object in the memory it allocates.</p>

<p>So the <strong>expression</strong> you wrote, is what calls the overloaded <strong>operator</strong> function.</p>
",0
46035020,46033106,1,"<p>The short answer:  the compiler does.</p>

<p>In more detail, given</p>

<pre><code>Test *ptr = new Test;
</code></pre>

<p>the compiler needs visibility of the complete definition of <code>Test</code> in order to instantiate it using the new expression (<code>new Test</code>).  The compiler will give a diagnostic (in this case, a compilation error in practice) when it doesn't have that visibility.</p>

<p>The definition of a <code>class</code> or <code>struct</code> type includes, among other things, any declarations of any <code>operator new()</code> functions it provides.   Since the compiler has complete visibility of that, it can decide what version of <code>operator new()</code> needs to be called.</p>

<p>Given that information, the compiler emits the appropriate code to call the appropriate overload of <code>operator new()</code> to obtain memory, and then to initialise that memory using a constructor.    It also emits code to handle error conditions (for example, giving required behaviour if the <code>operator new()</code> or the constructor throws an exception).</p>

<p>No object (instance of <code>Test</code>) is required to call <code>operator new()</code>, since <code>operator new()</code> is called before the object is even constructed.   This is different from operators like <code>operator+()</code> which operate on two existing objects.</p>
",0
34911157,34911062,2,"<p>Move int z=0, r=0; inside for loop.</p>
",0
34911193,34911062,0,"<p>Why not using this code to know if the number is symmetry?</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    int x;
    for (;;) {
        cout &lt;&lt; ""Enter number: "";
        cin &gt;&gt; x;
        m = x;

        std::stringstream str;
        str &lt;&lt; x;

        std::string number = str.str();
        if ( number == std::string( number.rbegin(), number.rend() )
            break;
        else
            n++;
    }
    cout &lt;&lt; n;
    return 0;
}
</code></pre>

<p>Simpler, leads to the same result and is definitely more error prone ;-)</p>
",2
34915097,34911062,0,"<p>It would have been much easier to reason if you have written like this:<br></p>

<pre><code>#include &lt;iostream&gt;

bool isPalindrome(int x)
{
    int y = x;
    int z;
    while (x) {
        z = z * 10 + x % 10;
        x /= 10;
    }
    return y == z;
}

int main()
{
    int n = 0;
    int x;
    for (;;) {
        std::cout &lt;&lt; ""Enter number: "";
        std::cin &gt;&gt; x;
        if (isPalindrome(x))
            break;
        else
            ++n;
    }
    std::out &lt;&lt; ""Number of non-palindromes: "" &lt;&lt; n &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>functions with meaningful names always helpful!</p>
",0
35251498,35251461,3,"<p>You have a syntax error.<br>
Instead of</p>

<pre><code>SysInfoClass SysInfo();
</code></pre>

<p>You need to write</p>

<pre><code>SysInfoClass SysInfo;
</code></pre>

<p>The way you wrote it, the compiler thinks it's a function declaration.</p>
",0
35251503,35251461,-1,"<p>Turn the global variable into a <code>static</code> local variable in a free-standing function which returns a reference to the variable.</p>

<pre><code>SysInfoClass&amp; SysInfo()
{
    static SysInfoClass sys_info;
    return sys_info;
}
</code></pre>
",2
47463291,47463085,2,"<blockquote>
  <p>Can you return in c++ a two dimensional array without using vectors or
  pointers?</p>
</blockquote>

<p>Only if the size is known at compile time and only if you wrap the array in a class type. Just like one-dimensional arrays. You cannot return arrays directly.</p>

<pre><code>struct Array
{
    int array[2][3];
};

Array f()
{
    return Array { 1, 1, 1, 2, 2, 2 };
}

int main()
{
    auto const array = f();
}
</code></pre>

<p>If you consider using a class like <code>Array</code>, think twice and mind that the standard library already offers <code>std::array</code> for that.</p>

<p>If you don't know the size at compile time, drop the ""without using vectors"" requirement and use <code>std::vector</code>.</p>
",0
36806682,36806660,1,"<p>You can make an instance of the struct and access the members:</p>

<pre><code> A a;
 cout &lt;&lt; a.v.v2.B1 &lt;&lt; a.v.v2.B2 &lt;&lt; a.v.v2.B3 &lt;&lt; '\n';
</code></pre>
",1
35248872,35248845,5,"<p>First of all, <code>char * args[];</code> is incorrect. In standard C++ an array has to have a specified size when defined. The (apparent) exception is when you write something like <code>int arr[] = {1,2,3,4,5};</code>, however in this case the compiler automatically sets the size to 5 in this case, as it determines the size at compile time.</p>

<p>Secondly, you cannot copy an array. In your function</p>

<pre><code>Command(char * a[]){args = a}
</code></pre>

<p><code>a</code> decays to a <code>char**</code>. Then you are trying to assign to <code>args</code>, which is an array, a pointer of type <code>char**</code>. This won't work. You cannot assign to an array.</p>

<p>In case you assign/copy arrays, your best bet is to use standard containers such as <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow""><code>std::vector</code></a>.</p>
",4
35248874,35248845,2,"<p>The declaration <code>char * args[]</code> denotes an array of pointers to non-<code>const</code> <code>char</code>. It's invalid code. Standard C++ does not permit an array of unknown bound as a data member.</p>

<p>Raw arrays are not assignable so also the assignment in the constructor body is invalid code.</p>
",0
39332009,39331858,0,"<p>Your error:</p>

<blockquote>
  <p>Error C2664: 'Strategy::Interphase' : cannot convert parameter 2 from 'char *' to 'char *[]'</p>
</blockquote>

<p>means that you're giving a <code>char*</code> to the function which expects a <code>char*[]</code>.</p>

<pre><code>bool Interphase(int argc, char * args[]);
</code></pre>

<p>Note the 2nd argument, it's a pointer to an array (or array of arrays, or pointer to pointer).</p>

<p>Your code can be modified to give it the address of the pointer:</p>

<pre><code>while (Interphase(1, &amp;Hcopy) == true || Interphase(1, &amp;Gcopy) == true)
    // ...
</code></pre>

<p>but I doubt that's how the API is meant to be used.</p>

<p>I'm not familiar with that function, but I'm guessing it's used more like:</p>

<pre><code>const char** args = {""arg1"", ""arg2""};
Interphase(2, args);
</code></pre>

<hr>

<p>Your warning:</p>

<blockquote>
  <p>Warning C4566: character represented by universal-character-name '\u05E9' cannot be represented in the current code page (1252)</p>
</blockquote>

<p>means that <code>char</code> can't hold non-ASCII characters.</p>

<p>If you're doing Unicode, you must use wide characters and strings (<a href=""http://www.cplusplus.com/reference/cwchar/wchar_t/"" rel=""nofollow noreferrer""><code>wchar_t</code></a> and <a href=""http://www.cplusplus.com/reference/string/wstring/"" rel=""nofollow noreferrer""><code>wstring</code></a>) to allow bigger numbers. Otherwise, you'll have an <a href=""https://en.m.wikipedia.org/wiki/Integer_overflow"" rel=""nofollow noreferrer"">overflow</a> and likely a wrap.</p>

<p>Link to <a href=""https://stackoverflow.com/questions/402283/stdwstring-vs-stdstring"">comparison between <code>string</code> and <code>wstring</code></a>.</p>

<hr>

<p>As a side note, you really shouldn't use C-style strings (<code>char*</code>).
Use <code>std::string</code> instead.
The reason:</p>

<ul>
<li>Need to deallocate them yourself (your code leaks memory as-is)</li>
<li>Unsafe api (needing to pass the size along with the data)</li>
</ul>
",13
46059127,46059026,0,"<p>Your question is <em>very</em> unclear.</p>

<p>You should be aware of <a href=""https://en.wikipedia.org/wiki/Calling_convention"" rel=""nofollow noreferrer"">calling conventions</a>. They might define in which <a href=""https://en.wikipedia.org/wiki/Processor_register"" rel=""nofollow noreferrer"">processor registers</a> some arguments are passed (and how is the result returned). Understand the <a href=""https://en.wikipedia.org/wiki/Application_binary_interface"" rel=""nofollow noreferrer"">ABI</a> relevant to your compiler, system, and processor. (See e.g. <a href=""https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI"" rel=""nofollow noreferrer"">this</a> for Linux/x86-64)</p>

<p>You need at least to know the signature of the called function at runtime.</p>

<p>In that case, you might use <a href=""https://sourceware.org/libffi/"" rel=""nofollow noreferrer"">libffi</a>. You'll better declare <code>extern ""C""</code>  the called (C++) function (because the ABI is generally for C code).</p>
",0
36755855,36755658,3,"<p><code>*Cola->getDrinkName</code> is not correct.<br><br>
Use either <code>Cola->getDrinkName()</code> or <code>(*Cola).getDrinkName()</code> instead; same for all other calls of the same kind in your code.</p>
",0
36645957,36645928,1,"<p>The code is not in a method of the <code>Characters</code> class. Thus it can't reference members of that class.</p>

<p>The code also makes almost no sense, but that's another matter of course.</p>
",0
36645961,36645928,2,"<p>The reason is you didn't mention that, this is an implementation of a class method so you need to specify it like below:</p>

<p>Change:</p>

<pre><code>string characters(int x)
</code></pre>

<p>to:</p>

<pre><code>string Characters::characters(int x)
</code></pre>
",0
36645976,36645928,1,"<p>should be</p>

<pre><code>string Characters::characters(int x){

   ofstream characters;
   characters.open(""characters.txt"");
   while (characters &gt;&gt; name){
      return name;
   }
}
</code></pre>
",1
40984973,40984937,1,"<p>Run-time type information.  Any polymorphic class creates extra meta-data in the program to make things like <code>typeof</code> and <code>dynamic_cast</code> work.  This is in addition to the virtual function table.</p>
",0
40985004,40984937,6,"<p>The vpointer is needed because the compiler cannot guarantee an external (e.g. shared) library does not use a derived type. The existence-of-derived-class resolution happens at runtime.</p>
",3
37693843,37693748,3,"<p>You can use <code>std::find_if</code> to do that</p>

<pre><code>auto it = std::find_if(map.begin(), map.end(), 
   [x](const auto &amp; l) -&gt; bool { 
      return l.second.size() &gt;= x;    // &gt;= or &gt;, depending upon requirement
   }
);
</code></pre>

<p>Then use this iterator in your <code>std::minmax_element</code></p>

<pre><code>auto minMaxElements = std::minmax_element(it, map.end(), 
    [](const auto &amp; lhs, const auto &amp; rhs) {
        return lhs.second.size() &lt; rhs.second.size();
    }
);
</code></pre>
",2
47563284,47563155,1,"<p>Is f3 a const reference, if so DevidedBy must be declared as const. </p>
",0
47563351,47563155,2,"<p>It means you have declared f3 as type <code>const fraction</code>, meaning you cannot change it. Even though the method <code>DividedBy</code> does not change it, there is no guarantee about it so compiler assumes the method can change it somehow.</p>

<p>The solution here is either not to have f3 constant or better make the method <code>DividedBy</code> constant by changing the declaration and definition to</p>

<pre><code>fraction fraction::DividedBy(fraction operand) const   

fraction fraction::DividedBy(fraction operand) const {
...
}
</code></pre>

<p>By the rule of thumb it is better to make constant anything that can be constant. You can for example make the operand of type <code>const fraction &amp;</code> which would prevent unnecessary copying of your classes around while still not preventing the code from compiling when you pass it constant fractions.</p>

<p>The last part <code>[-fpermissive]</code> is just the compiler telling you how to suppress this warning and make it compile anyways (you would just pass this flag to the compiler). It's nice to know there is this option but you should never use it unless you are really sure what you're doing and why it can't be done the proper way.</p>
",0
36256175,36256111,3,"<p>At the line <code>A::method</code> is defined, <code>B</code> is known only by name, not by its full definition.</p>

<p>You have to make sure that the full definition of <code>B</code> is known before you can use <code>B::meth()</code>.</p>

<p><strong>Option 1</strong></p>

<p>Move the definition of <code>B</code> before the definition of <code>A</code>.</p>

<pre><code>class B
{
    public:
    void static meth()
    {
    }
};

class A
{
    public:
    void method()
    {
        B::meth();
    }
};
</code></pre>

<p><strong>Option 2</strong></p>

<p>Move the definition of <code>A::method</code> after the definition of <code>B</code>.</p>

<pre><code>class A
{
    public:
    void method();
};

class B
{
    public:
    void static meth()
    {
    }
};

void A::method()
{
   B::meth();
}
</code></pre>
",0
36256182,36256111,0,"<p>The issue is that class A is trying to access a member of class B before class B is defined. You should define class B first. Furthermore, consider renaming the classes so that they will be in alphabetical order.</p>
",0
36463387,36463120,0,"<p>Try this instead:</p>

<pre><code>template&lt;typename Element&gt;
movieArray&lt;Element&gt;&amp; movieArray&lt;Element&gt;::operator-=(int position)
{
    // some code here...
    return *this;
}

template&lt;typename Element&gt;
void movieArray&lt;Element&gt;::deleteElem(int position)
{
    *this -= position;
}

template&lt;typename Element&gt;
movieArray&lt;Element&gt;&amp; movieArray&lt;Element&gt;::operator+=(const Element &amp;elem)
{
    resizeArray();
    elements[lenght++] = elem;
    return *this;
}

template&lt;typename Element&gt;
void movieArray&lt;Element&gt;::addElem(const Element &amp;elem)
{
    *this += elem;
}
</code></pre>

<p>Or this:</p>

<pre><code>template&lt;typename Element&gt;
movieArray&lt;Element&gt;&amp; movieArray&lt;Element&gt;::operator-=(int position)
{
    deleteElem(position);
}

template&lt;typename Element&gt;
void movieArray&lt;Element&gt;::deleteElem(int position)
{
    // some code here...
}

template&lt;typename Element&gt;
movieArray&lt;Element&gt;&amp; movieArray&lt;Element&gt;::operator+=(const Element &amp;elem)
{
    addElem(elem);
    return *this;
}

template&lt;typename Element&gt;
void movieArray&lt;Element&gt;::addElem(const Element &amp;elem)
{
    resizeArray();
    elements[lenght++] = elem;
}
</code></pre>
",1
36463753,36463120,0,"<p>We are guessing a lot since you only posted a little fraction of your code. But perhaps you meant:</p>

<pre><code>*this += elem;
</code></pre>

<p>which would call your class's overloaded <code>operator+=</code> function that you showed, instead of:</p>

<pre><code>this-&gt;elements += elem;
</code></pre>

<p>which would call <code>+=</code> on the member variable <code>elements</code>.   You haven't told us what <code>elements</code> is , but (based on your symptoms) perhaps it has some type which has <code>+=</code> defined for <code>int</code> but not for <code>Element</code>.</p>

<hr>

<p>NB. Not related to your compilation error, but <code>resizeArray();</code> should be inside <code>operator+=</code> , otherwise (assuming that this function is necessary to make space in the array) you will overflow your space when someone calls <code>operator+=</code> instead of <code>addElem</code>.</p>
",1
41183738,31147958,2,"<pre><code>CSocket r;
wchar_t ku[5100];

AfxSocketInit();

 wchar_t b[]=L""GET /currency-converter/#from=USD;to=EUR;amt=1 H
TTP/1.1\r\nhost:finance.yahoo.com\r\n\r\n"";

;
    r.Create()
    r.Connect(L""finance.yahoo.com"",80);
    r.Send(b,sizeof(b));
    r.Receive(ku,sizeof(ku));  //header stuff
    r.Receive(ku,sizeof(ku));  //rate
    CString t(ku); 
    //grabbed data is ready 
</code></pre>

<p>Pros: CString + WSA error stuff</p>

<p>And linux sample:</p>

<pre><code>#include&lt;stdio.h&gt; //printf
#include&lt;string.h&gt;    //strlen
#include&lt;sys/socket.h&gt;    //socket
#include&lt;arpa/inet.h&gt; //inet_addr
 #include &lt;unistd.h&gt; 
       #include &lt;netdb.h&gt;
int main(int argc , char *argv[])
{
    int sock;
    struct sockaddr_in server;
    char  server_reply[5000];

     struct hostent *host;

    //Create socket
    sock = socket(AF_INET , SOCK_STREAM , 0);
    if (sock == -1)
    {
        printf(""Could not create socket"");
    }
    puts(""Socket created"");
     host = gethostbyname(""finance.yahoo.com"");


    server.sin_addr.s_addr=*((unsigned long*)host-&gt;h_addr);
    server.sin_family = AF_INET;
    server.sin_port = htons( 80 );

    //Connect to remote server
    if (connect(sock , (struct sockaddr *)&amp;server , sizeof(server)) &lt; 0)
    {
        perror(""connect failed. Error"");
        return 1;
    }

    puts(""Connected\n"");


char        message[]=""GET /currency-converter/#from=USD;to=EUR;amt=1 HTTP/1.1\r\nhost:finance.yahoo.com\r\n\r\n"";

        //Send some data
        if( send(sock , message , strlen(message) , 0) &lt; 0)
        {
            puts(""Send failed"");
            return 1;
        }


        //Receive a reply from the server
        if( recv(sock , server_reply , 3000 , 0) &lt; 0)
        {
            puts(""recv failed"");

        }

        puts(""Server reply :"");

        puts(server_reply);



        //Receive a reply from the server
        if( recv(sock , server_reply , 3000 , 0) &lt; 0)
        {
            puts(""recv failed"");

        }
         puts(server_reply);


    close(sock);
    return 0;
}
</code></pre>
",0
35249914,35249292,1,"<p>Your 3 arrays in <code>ADC</code> have 7 elements in them but the functions you pass them to expect 8.  This results in undefined behavior, which is showing here as overwriting the first byte of the next array.</p>
",4
35277875,35277850,5,"<p>You can do:</p>

<pre><code>typedef MyClass::mytype mytype;
</code></pre>
",3
35277902,35277850,4,"<p>Use a typedef or an alias declaration, ideally in the narrowest possible scope.</p>

<pre><code>void some_function() {
    typedef MyClass::mytype mytype;
    // or: using mytype = MyClass::mytype;
}
// namespace not polluted
</code></pre>
",0
39340872,39340836,2,"<p>In your source code file structure, while <code>blackjack_stand.h</code> contains the implementation, it indeed was not compiled at all, since compilers normally don't compile header files directly.</p>

<p>You should rename <code>blackjack_stand.h</code> to <code>blackhack_stand.cpp</code> and compile that file along with <code>main.cpp</code>.</p>
",4
35242361,35242266,5,"<p>I can think of at least three ways, off the top of my head.</p>

<p>First:</p>

<pre><code>namespace internal {
template&lt; typename T &gt;
void foo_impl( std::string &amp;&amp;name, T value ) {
    // actual implementation here
}
}

void foo(std::string &amp;&amp;name, SpecialType1 value ) {
    internal::foo_impl(std::forward&lt;std::string&gt;(name), value);
}
void foo(std::string &amp;&amp;name, SpecialType2 value ) {
    internal::foo_impl(std::forward&lt;std::string&gt;(name), value);
}
</code></pre>

<p>Second:</p>

<pre><code>template&lt; typename T &gt;
typename std::enable_if&lt;std::is_same&lt;T, SpecialType1&gt;::value ||
                        std::is_same&lt;T, SpecialType2&gt;::value &gt;::type
foo( std::string &amp;&amp;name, T value ){
    //implementation here
}
</code></pre>

<p>Third:</p>

<pre><code>template&lt; typename T &gt;
void foo(std::string &amp;&amp;name, T value){
    static_assert(std::is_same&lt;T, SpecialType1&gt;::value ||
                  std::is_same&lt;T, SpecialType2&gt;::value,
    ""wrong template argument"");
    //implementation here
}
</code></pre>

<p><a href=""http://rextester.com/MXYVZ89644"" rel=""noreferrer"">Demo</a></p>
",6
35242373,35242266,1,"<p>One thing I have seen people done is using <a href=""http://en.cppreference.com/w/cpp/types/enable_if"" rel=""nofollow""><code>std::enable_if</code></a>. I don't know exactly what your 4 types are, so this is an example with two types <code>int</code> and <code>float</code>.</p>

<pre><code>using myType = std::enable_if&lt;
std::is_same&lt;int, T&gt;::value ||
std::is_same&lt;float, T&gt;::value, T &gt;::type;
</code></pre>

<p><code>myType</code> exists only if <code>T</code> is exactly <code>int</code> or <code>float</code>. Hope that helps!</p>
",0
35243426,35242266,2,"<p><code>&lt;type_traits&gt;</code> let you generalize your logic into class template. How this works is we take template parameter <code>T</code> and parameter pack of <code>Ts</code> and we start checking if <code>T</code> is same to <code>Head</code> of the list of types. If match is found, we inherit from <code>std::true_type</code> and we are done. If no match is found, we pop the head and recursively instantiate same template with tail of <code>Ts</code>. Eventually, if no match is found at all, parameter pack size will drop to zero and the compiler will instantiate base template class that inherit from <code>std::false_type</code>. Please check this <a href=""https://www.youtube.com/watch?v=Am2is2QCvxY"" rel=""nofollow"">video</a> for much better and in dept explanation by Mr. Walter E. Brown.</p>

<pre><code>template&lt;class T, class...&gt; struct is_any_of: std::false_type{};
template&lt;class T, class Head, class... Tail&gt; 
struct is_any_of&lt;T, Head, Tail...&gt;: std::conditional_t&lt;
  std::is_same&lt;T, Head&gt;::value, 
  std::true_type,
  is_any_of&lt;T, Tail...&gt;&gt;
{};
</code></pre>

<p>Now we can SFINAE over, using <a href=""http://en.cppreference.com/w/cpp/types/enable_if"" rel=""nofollow"">enable_if</a> in almost English wording.</p>

<pre><code>#include &lt;type_traits&gt;
#include &lt;string&gt;

template&lt;
  class T,
  class = std::enable_if_t&lt;is_any_of&lt;T, int, float, unsigned, double&gt;::value&gt;
&gt;
void foo(std::string &amp;&amp;str, T value) {}


int main()
{
  foo(std::string{""hello""}, 3);
  foo(std::string{""world""}, '0'); //compile-time error
}
</code></pre>

<p>SFANIE is a language feature, a tool, that's used or <em>abused</em> some say to achieve what you ask for,</p>

<blockquote>
  <p>The standard library component std::enable_if allows for creating a substitution failure in order to enable or disable particular overloads based on a condition evaluated at compile time.
  FYI <a href=""http://en.cppreference.com/w/cpp/language/sfinae"" rel=""nofollow"">http://en.cppreference.com/w/cpp/language/sfinae</a>.</p>
</blockquote>

<p>Note that <code>std::conditional_t&lt;&gt;</code> and <code>std::enable_if_t&lt;&gt;</code> are shorthanded from <code>std::conditional&lt;&gt;::type</code> and <code>std::enable_if&lt;&gt;::type</code> respectively. You could simple replace these in code, but should put <code>typename</code> keyword before <code>enable_if</code> then. </p>
",2
36323027,36322599,0,"<p>Rather than got stuck on the ideal function, I implemented in a different way:</p>

<pre><code>class TreeItem
{
public:
    string name;
    string value;
    TreeItem* parent;
    std::vector&lt;TreeItem*&gt; children;
};
</code></pre>

<p>Then do a tokenize on the flat keys to create chained TreeItems; the result is a tree whose root is a, with two childrens, b and e, and b further have two children c and d. </p>

<p>Then a Depth First Search on the tree printed my expected result.</p>
",0
47465379,47465342,2,"<p>It is copying a cat object to an animal object. Ditto with dog.</p>

<p>You can verify this by implementing a copy constructor.</p>

<p>I think you need:</p>

<pre><code>Animal* ani[]={&amp;cat,&amp;dog};
ani[0]-&gt;Speak();
</code></pre>
",0
47465402,47465342,3,"<p>In the line <code>Animal ani[]={cat,dog};</code>, <code>cat</code> and <code>dog</code> are copied by value into 2 <code>Animal</code> objects. <a href=""https://stackoverflow.com/questions/274626/what-is-object-slicing"">Object slicing</a> occurs during the copying. So, <code>ani[0].Speak()</code> actually uses an object of type <code>Animal</code>, not <code>Cat</code> or <code>Dog</code>.</p>

<p>The member function call is also not virtual because the object is used by value. Virtual call is performed only through pointer or reference.</p>

<pre><code>Animal* dog_as_animal = &amp;dog;
dog_as_animal-&gt;Speak();
Animal&amp; cat_as_animal = cat;
cat_as_animal.Speak();
</code></pre>
",0
39683302,39682818,1,"<blockquote>
  <p>but my confusion is, even though I don't inherit Mother class, the function still works, so how am I inheriting/overriding it? I am very confused as if I'm really inheriting/overriding anything.</p>
</blockquote>

<ul>
<li><p>you don't really override sayName() of your Mother class because (as you said) Daughter class doesn't inherit it in the first place. That is, you need to inherit a class first in order to be able to <strong>override</strong> its <strong>virtual</strong> functions.</p></li>
<li><p>your second call to sayName() works because it's a call to a member function of Daughter class, which is totally independent from Mother class. Note that, just having multiple independent classes whose member functions share the same signature is not <strong>overriding</strong></p></li>
<li><p>side note:  you shouldn't include Daughter.hpp in Mother.cpp, whether you plan to inherit Mother in Daughter, or not.  </p></li>
</ul>
",0
35233059,35233022,2,"<p>Note that <code>&gt;&gt;</code> is an operator. C++ provides the ability to define functions that give functionality for any built-in operator. (Note, you cannot create new operators that don't already exist in the language.) In this particular case, the <code>&gt;&gt;</code> operator has been overloaded for use with <code>cin</code> and either an <code>int</code> or a <code>string</code>. These functions then carry out the conversion. In the case of the <code>int</code> version, it will set an error flag in <code>cin</code> if the input cannot be converted to an <code>int</code>.</p>
",0
35233074,35233022,1,"<p><code>std::cin</code> reads from <code>stdin</code>.</p>

<p>This:</p>

<pre><code>string word;
cin &gt;&gt; word;
</code></pre>

<p>will return a <code>string</code>, not a <code>char*</code>. Try avoid char arrays in C++.</p>

<p>Read about <code>std::cin</code> <a href=""http://www.cplusplus.com/reference/iostream/cin/"" rel=""nofollow"">here</a>. Also learning about <a href=""http://www.cplusplus.com/reference/sstream/stringstream/"" rel=""nofollow"">stringstreams</a> is very useful when dealing with C++ IO.</p>
",1
35233088,35233022,1,"<p>You may want to read a book about C++ iostreams. <a href=""https://rads.stackoverflow.com/amzn/click/com/0321958322"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Like the C++ book by Stroustrup who invented C++.</a></p>

<p>But in summary, a iostream object, like cin, has goodbit, badbit, failbit and eofbit. <a href=""http://en.cppreference.com/w/cpp/io/ios_base"" rel=""nofollow noreferrer"">Look at iostate.</a></p>

<p>The cin object will return false when it is anything but good. So you can read integers like this:</p>

<pre><code>int my_int;
while(cin &gt;&gt; my_int) {
    cout &lt;&lt; ""Received "" &lt;&lt; my_int &lt;&lt; ""\n"";
}
</code></pre>

<p>The loop will exit when it reads anything that isn't a number or when it reaches the end of file.</p>
",1
42601466,42600462,0,"<p>CSV files are a bit trickier to read than that.</p>

<p>Your specific file may have simple records, but Excel will create CSVs wth escapes, missing values, and so on.</p>

<p>If you take my CSV parser, you can then query it both for CSV file structure (what columns are in there and what is their type) and for the values. The parser doesn't do anything terribly complicated, but it handles the messiness of allocating memory and breaking the fields out  and assigning them to columns.</p>

<p>If you are filling in a simple C structure, you then throw out any CSV objects that don't match. If an object does match, it's a simple loop through with calls to getfield. You then destroy the CSV object.</p>

<p><a href=""http://www.malcolmmclean.site11.com/www/CSVtoC/csvtoc.html"" rel=""nofollow noreferrer"">http://www.malcolmmclean.site11.com/www/CSVtoC/csvtoc.html</a></p>
",0
42476335,42378028,1,"<blockquote>
  <p>I'd like to know how some of them work behind the scenes. Like what is
  the actual code behind std::stoi ?</p>
</blockquote>

<p>I think you can find the 'actual' code by doing a search similar to:</p>

<ul>
<li><p>On Ubuntu, my makefile creates a .depends file with:</p>

<p>g++-5 -m64  -O3 -ggdb -std=c++14 -Wall -Wextra -Wshadow -Wnon-
virtual-dtor -pedantic -Wcast-align -Wcast-qual -Wconversion 
-Wpointer-arith -Wunused -Woverloaded-virtual   -O0  -M  *.cc  > .depends</p>

<p>(I try to keep the compiler options for this command matching my normal compile.)</p></li>
<li><p>In a browser, I look at </p>

<p><a href=""http://en.cppreference.com/w/cpp/string/basic_string/stol"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/string/basic_string/stol</a></p>

<p>to identify that </p>

<p>std::stoi is included from std::basic_string (at top of page)</p></li>
<li><p>In my editor, (or) using grep, I search through the .depends file for ""basic_string""</p>

<p>grep --color -nH -e ""basic_string"" .depends  </p>

<p>grep reports the string 214 times in my current depends file, which
changes size when I change code.</p>

<p>Example of one report:</p>

<p>.depends:14105: /usr/include/c++/5/bits/basic_string.h \</p></li>
<li><p>In my editor, I open the indicated file </p>

<p>""/usr/include/c++/5/bits/basic_string.h"", </p>

<p>then search for ""stoi"", which appears to exist only twice.</p>

<p>This indicates v5 of the compiler.</p></li>
</ul>

<p>I think you should be able to do a similar search on your system.</p>

<p>Good luck.</p>
",0
37839757,37839585,4,"<p>Since you're in a specific situation where you need a <code>double x double -&gt; double</code> function, you can wrap <code>foo</code> as follows:</p>

<pre><code>double foo_w(double a, double) { return foo(a); }
</code></pre>

<p>If you are interested in a more general solution, you can look into variadic template for the number of arguments (and their respective type) as Mohammadreza Panahi shows in his answer. But try not to over engineer your problem. ;-)</p>
",0
37839925,37839585,4,"<p>Instead of a function pointer, if you use C++11, you can use <code>std::function</code> to store the functions:</p>

<pre><code>double foo(double, double) {}
double Foo(double, ...) {} //You could also use a template for this one

//Note that the number of parameters of 'func' should be the maximum possible
//arguments of the functions you want to store (here: 1 vs 2)
std::function&lt;double(double, double)&gt; func;

func = foo; //Ok
func = Foo; //Ok

//Now you can call 'func'
func(1, 2); //if 'func' == 'Foo', ignores the 2
</code></pre>
",2
37839779,37839585,4,"<p>Here are two general solutions.</p>

<h2>Compile time</h2>

<p>This can be accomplished using variadic templates:</p>

<pre><code>double func(double x)
{
    return x + 1;
}

template&lt;typename... Ts&gt;
double wrappedFunc(double x, const Ts&amp;...)
{
    return f(x);
}
</code></pre>

<p><code>wrappedFunc()</code> can be invoked with any number of arguments of any types, only the first one will actually be used and passed to <code>f()</code>:</p>

<pre><code>wrappedFunc(5.0, ""Hello!"", false, -23);    // returns 6.0
</code></pre>

<h2>Run time</h2>

<p>As far as I understand the edit you made, you are looking for a way to do this at run time. Here's one way to do so in C++14, using a function template, returning a lambda with variable number of parameters, which calls the original function, passing its first parameter and ignoring the rest:</p>

<pre><code>template&lt;typename Func&gt;
auto getVariadicWrapper(Func func)
{   
    return [func](auto argument, auto...) {return func(argument);};
}
</code></pre>

<p>This function template can be used to construct a wrapper function in the following manner:</p>

<pre><code>// Assuming func() is the same as before

// Create a wrapper function, which passes its first param to func and ignores the rest.
auto wrappedFunc = getVariadicWrapper(func);

// Use it
wrappedFunc(5.0, false, ""bananas"", 72233);    // returns 6.0
</code></pre>
",2
37840275,37839585,0,"<p>Another nice and easy way is with a lambda</p>

<p>If you have</p>

<pre><code>double func (double a)
{
    return a;
}

struct st
{
    double(*foo)(double,double);
};
</code></pre>

<p>You can do </p>

<pre><code>st a;
a.foo = [](double a,double b){return func(a);};
</code></pre>
",2
37963119,37962981,0,"<p>As stated in the error, the compiler can't find a correct comparison operator because it should be defined as </p>

<pre><code>bool const operator &lt; (point b)
</code></pre>

<p>and not </p>

<pre><code>bool const operator &lt; (point&amp; b)
</code></pre>

<p>EDIT : as cited in the commentary, </p>

<pre><code>bool const operator &lt; ( point const &amp; b)
</code></pre>

<p>may be the better way</p>
",1
37963717,37962981,-1,"<p>Move overloading operator outside of struct:</p>

<pre><code>struct point
{
    int xx;
    int yy;
    int zz;
};

bool const operator &lt; (const point &amp;a, const point &amp;b) const
{
    return xx &lt; b.xx;
}
</code></pre>
",0
34943301,34943170,0,"<p>You are right, the enum is basically a 'const int'.</p>

<p>Second guessing why some developer chose a certain style is futile.</p>

<p>Unless you call the function in a very close loop it doesn't matter anyhow.</p>
",1
34943323,34943170,-1,"<p>There is one big difference: If you pass options as a value, then it becomes a local variable in your function, and only your function can change it. If you pass options as a const&amp;, then there is a variable somewhere, which might be a static or global variable, and if your function modifies any other variable of type FileOptions, then it might be the one that was passed to you as a const&amp;, so the value of options might change. </p>

<p>And if your function calls another function, then that function <em>might</em> change the variable behind options. So as a developer, after any function call you could suspect that options might have changed (although if that happens, that would be about the worst possible programming style imaginable), but also the compiler would have to assume that it has changed unless it can prove otherwise. </p>

<p>Modifying a const&amp; in that way would be awful, so we can safely assume that unless the caller absolutely hates you a const&amp; won't be changed. You use const&amp; when you actually want to pass a value, but passing it by reference seems to be more efficient. For an int that is pointless, for an array containing ten megabytes worth of int's it's not at all pointless. </p>

<p>Another use for const&amp; instead of value is for objects that cannot easily be copied. For example a mutex cannot easily be copied. Or an object giving exclusive access to a file can by definition not be copied in a meaningful way. </p>
",7
34943346,34943170,0,"<p>In modern C++ there is also enum class which is strongly typed enums.
I think const reference is used only for similarity and easy to modificate in future.</p>

<p>For example you have a class with a lot of methods, all parameters in this methods usually complex objects and of course passed by const reference. So you declare the enum parameter in the same way. And you will know for sure that it's should not be changed and so on</p>

<p>Later you may deside to convert enum in more complex object, and you will no need to update function declaration at all. It's already suitable for such refactoring</p>
",3
34943426,34943170,1,"<p>The only advantage I can see is, that if you later decide to create a class with extended funcitonality, you can pass it still efficiently without changing the code everwhere.</p>

<p>Any decent optimizer doesn't care for the reference if it is a const reference for a base type anyway, and creates the same code in both cases.</p>

<p>Another consequence could be if the reference is to some other variable and it is changed by another thread, it can even change it's value during the course of your function (even though it says it's const) which, I would think, is not really desireably. In this case it would heavily depend on the optimization what value is used in a given branch of that method.</p>
",0
35201020,35200964,1,"<p>You should change the signature of your function to</p>

<pre><code>OwnedArray&lt;fftconvolver::FFTConvolver&gt; const&amp; getConvolver() const;
</code></pre>

<p>so you are returning a <em>reference</em> to the array. As written, it will return a copy of the array, which the compiler seems to be telling you that the copy constructor is deleted.</p>

<p>If you need to be able to modify the contents of the array you could also return a non-const reference</p>

<pre><code>OwnedArray&lt;fftconvolver::FFTConvolver&gt;&amp; getConvolver();
</code></pre>
",0
35201024,35200964,1,"<p>You're returning by copy, try returning by reference:</p>

<pre><code>OwnedArray&lt;fftconvolver::FFTConvolver&gt;&amp; 
ImpulseCreator::getConvolver() {
    return convolvers;
}


OwnedArray&lt;fftconvolver::FFTConvolver&gt; const&amp; 
ImpulseCreator::getConvolver() const {
    return convolvers;
}
</code></pre>

<p>The compiler is telling you that the <code>OwnedArray</code> destructor is declared deleted. Guessing from the name the <code>OwnedArray</code> is owned by someone else, thus you're not allowed to destruct its objects in a non friendly context.</p>
",0
36487871,36487805,0,"<p>You have:</p>

<pre><code>D = new double[n + 1];

for (int i = 0; i &lt;= dD; i++)
    D[i] = div[i];
</code></pre>

<p>It's not clear what the relationship between <code>n</code> and <code>dD</code> is. </p>

<p>You need to either change the first line to:</p>

<pre><code>D = new double[dD + 1];    // Use dD, not n
</code></pre>

<p>or the change the loop to:</p>

<pre><code>for (int i = 0; i &lt;= n; i++)  // Use n, not dD.
    D[i] = div[i];
</code></pre>

<p>It's not clear to me which one should be changed.</p>
",2
36665227,36665164,1,"<p>You basically only have one option: Rewrite the configuration file, write out all configuration options from the start.</p>

<p>Trying to move around contents of a text file if one line changes length (bigger <em>or</em> smaller) is possible, but it's much more work than just rewriting it.</p>

<p>It's either that or the working solution using <code>sed</code>, which can be called from inside the program using the <code>system</code> function.</p>
",0
35296886,29545469,1,"<p>use <code>==</code> instead of <code>=</code><br>
<code>==</code> is for comparison<br>
<code>=</code> is for assingment</p>
",0
37761279,37761243,6,"<p>The default argument must have static linkage (e.g. be a global).
Here's an example:</p>

<pre><code>#include &lt;iostream&gt;

int array[] = {100, 1, 2, 3};

void myFunction(int myArray[] = array)
{
    std::cout &lt;&lt; ""First value of array is: "" &lt;&lt; myArray[0] &lt;&lt; std::endl;
    // Note that you cannot determine the length of myArray!
}

int main()
{
    myFunction();
    return 0;
}
</code></pre>
",0
37761286,37761243,13,"<p>You can use a <code>nullptr</code> or a pointer to a global const array to denote the default value:</p>

<pre><code>void myFunction(int myArray[] = nullptr ) {
                             // ^^^^^^^
}
</code></pre>

<p>This is because <code>int myArray[]</code> is type adjusted to a <code>int*</code> pointer when used as function parameter.</p>
",0
35230025,35229924,2,"<p>It seems like you are looking to read a c++ tutorial, but this code creates an empty array with room for 5 elements of type uint8_t. You then set v to the value of DHT_data[2], which is the third element of the array. On the next line, you invoke the constructor for the float data type with the value of v (which as said by NathanOliver is undefined). The new value of v as a float is returned. As for printing v, there are many methods on how to do that. The most common one is ostream::operator&lt;&lt;.</p>
",0
35230029,35229924,0,"<p><code>float</code> is different from <code>int</code> in the way that it can print decimals. For example for the number <code>4.23</code>, int would just print <code>4</code> and float would print <code>4.23</code>.
The <code>return float(int)</code> is casting the variable <code>v</code>, which was an int, to a float and is then returned.</p>
",2
45667809,45667393,24,"<p>A simplified version of your problem:</p>

<p>buggy.hpp</p>

<pre><code>int function() { return 0; }
</code></pre>

<p>main.cpp</p>

<pre><code> #include ""buggy.hpp""
 int main() { return 0; }
</code></pre>

<p>other.cpp</p>

<pre><code> #include ""buggy.hpp""
</code></pre>

<p>The problem is that <code>buggy.hpp</code> is <em>defining</em> <code>function</code>, not just <em>declaring</em>.  Once the header inclusion is expanded, that means <code>function</code> is declared in both <code>main.cpp</code> and <code>other.cpp</code> - and that is not allowed.</p>

<p>The fix is to declare <code>function</code> as <code>inline</code> which allows the function to be declared in multiple translation units. </p>

<pre><code>inline int function() { return 0; }
</code></pre>

<p>In fact, allowing multiple definitions is the <em>only</em> meaning of <code>inline</code> to the C++ <em>standard</em>.  Compilers may treat it as a hint that the function body may be expanded inline.  Good ones won't; they are better at making that sort of decision that programmers).</p>
",4
46626539,46626464,4,"<p>An in-class member initializer must either use an equal sign or <code>{</code>curly braces<code>}</code>.</p>

<p>So:</p>

<pre><code>OtherClass Instance2 = ""Foobar"";
</code></pre>

<p>or:</p>

<pre><code>OtherClass Instance2{ ""Foobar"" };
</code></pre>
",1
43760960,43759003,0,"<p>So it seems, if you use template for a function parameter this needs to be in the header file, rather than the source file.</p>
",0
43760960,43759003,0,"<p>So it seems, if you use template for a function parameter this needs to be in the header file, rather than the source file.</p>
",0
42499051,42499012,3,"<p>Your <code>Stage</code> constructor must default-initialize <code>display</code> before executing the body of the constructor. All class members must be constructed before executing the body of the class's constructor. No exceptions. The shown code, therefore, attempts to default-construct <code>display</code> before using the assignment operator on it.</p>

<p>Since <code>Display</code> does not have a default constructor, this fails, hence the complaint from your compiler that there is no defualt constructor.</p>

<p>In this situation you must explicitly construct <code>display</code> in the initialization section of the constructor:</p>

<pre><code>Stage::Stage (Display &amp;display_) : display{display_}
{
}
</code></pre>

<p>or, pre-C++11:</p>

<pre><code>Stage::Stage (Display &amp;display_) : display(display_)
{
}
</code></pre>

<p>This explicitly constructs the <code>display</code> member right from the beginning, presumably using its copy-constructor.</p>
",0
47489833,47489087,-1,"<p>As others already mentioned, this method of yours is not reliable, because the compiler may choose to pad your <code>struct</code>. For example, if you are on a 64 bit platform, the compiler may choose to pad the <code>struct</code> to 8-byte align.</p>

<p>But the idea of using a pointer to access members of class still can work. You can use <code>sizeof</code> to get the actual size of the <code>struct</code> (in bytes).</p>

<p>With your first example, it would look like this:</p>

<pre><code>float *ptr = (float*) &amp;myData[0].x;
</code></pre>

<p>and access the next <code>x</code> value like this:</p>

<pre><code>ptr = (float*)(((char*)ptr) + sizeof(VertexData));
</code></pre>

<p>or, alternatively, if you are sure that <code>sizeof(VertextData)</code> is a multiple of <code>sizeof(float)</code>, it could be:</p>

<pre><code>ptr += sizeof(VertexData) / sizeof(float);
</code></pre>

<p>This is a bit complicated, but is reliable. Also, you can wrap things into macros, if you wish.</p>

<p>Whether this method is practical depends on your particular situation. I'd say in certain situations it could be useful.</p>

<hr>

<p>EDIT:</p>

<p>There is, nevertheless, some danger in using this method.</p>

<p>The most important thing to remember is that, if you insert some elements into your vector, the whole storage could be reallocated, hence your previous pointer will no longer be valid.</p>

<hr>

<p>EDIT:</p>

<p>There is also another way, avoiding the use of <code>sizeof</code>. To access the next <code>x</code> value, you can use:</p>

<pre><code>ptr = (float*) (((VertexData*) ptr) + 1);
</code></pre>

<p>This should compile to the same result.</p>
",34
47489691,47489087,-1,"<p>According to the C++ Standard, this technique has <strong>undefined behavior</strong>. The compiler is free to add padding between members. So, according to the principles of the standard, this is a bad idea.</p>

<p><em>However.</em></p>

<p>All compilers I know (I've worked with 8 different C++ compilers in the past 15 years), don't add padding in this case. Why would they? So, if you <em>dare to enter undefined-behavior land</em>, you can use this technique. Even in complex cases. Inheritance, virtual functions, etc. All the compilers I know, do the logical thing, and put float members next to each other in memory in your case, and their optimizers don't fail for this case. Note: the standard allows compilers reorder members between access specifiers, so if you want to be on the safe side (which you've already left), put all members under the same access specifier (still, I've yet to see a compiler, which actually reorders members between access specifiers.).</p>

<p>So. <strong>Is it reliable?</strong> According to the standard: <strong>No</strong>. According to the current practice: in my experience, yes. I've yet to see a compiler, for which such a code fail. I encourage anyone who knows such a compiler, to not be silent, and add it as an answer.</p>

<p>Note: this is the current status. It may break any time. I'd only recommend using this technique if you know what you're doing, and you're aware of the possible consequences. And don't forget to comment this fact in your code.</p>
",14
37288968,37288918,0,"<p>The templated operator+ is superfluous; just remove it.</p>

<hr>

<p>In other news:</p>

<ul>
<li><p>Consider also changing <code>bigInt operator+ (bigInt num)</code> to <code>bigInt operator+ (bigInt const&amp; num)</code> to avoid needless inefficiency.</p></li>
<li><p>Also, consider making it a <code>friend</code> function so that order of arguments doesn't matter.</p></li>
</ul>
",5
34981326,34977728,0,"<p>I made the random seed determinstic with:</p>

<pre><code>//std::random_device rd;
std::default_random_engine generator(-246744094);
</code></pre>

<p>and can consistently reproduce this error at 832million iterations. I got it with different compilers (VS2013 32/64bit and also Intel C++ 2016 64-bit), and different machines (My desktop i7, and a cluster node Xeon E5) with identical result. My rgamma.max() agreed with Bob's too.</p>

<p>I then compiled it with MinGW (g++ main.cpp -o main.exe -std=c++0x -O3) - and it ran without generating any infinites.</p>

<p>SO - I hypothesise: it's some sort of bug in libraries that get linked through Visual Studio, regardless of whether you use the MS or Intel compiler. Not sure whether that can be reported/fixed - or whether it might just be quicker to find some reliable source code for gammas.</p>
",0
39671164,39671101,2,"<p>function age doesn't assign value a to the member ag but instead it returns the value a which it takes as parameter it's such a bad thing.
to get what I want to say in main write:</p>

<pre><code>cout &lt;&lt; mom.age(40) &lt;&lt; endl; // 40
</code></pre>

<p>to make it correct change you function age to:</p>

<pre><code>double Mother::age(double a)
{
    ag = a;
    return a; // it's redundant to do so. change this function to return void as long as we don't need the return value
}
</code></pre>

<p>*** another thing you should do:</p>

<p>make ""getters"" const to prevent changing member data and only let ""setters"" not constant. eg in your code: class mother: </p>

<pre><code>double getH()const; // instead of double getH() const prevents changing member data ""ag"" 
</code></pre>
",2
39671179,39671101,3,"<p>Your mom.print() does this:</p>

<pre><code>cout&lt;&lt;""I am "" &lt;&lt;ag &lt;&lt;endl;
</code></pre>

<p>So the problem here is: ag = 0</p>

<p>Your mom.age(40) does this:</p>

<pre><code>return a;
</code></pre>

<p>See, it doesn't save your mom's age to your <code>mom</code> variable, it only return what you pass ( here is 40 ), so how could it print ?</p>

<p>Therefore, there are many ways to solve this, if you want to return your mom's age, do cout &lt;&lt; mom.age(40) in main()
Or, just:</p>

<pre><code>void Mother::age(double a)
{
    ag = a;
}
</code></pre>
",0
39671234,39671101,2,"<p>You have to use correctly setter and getter. Use the setter to change the age like this :</p>

<pre><code>void setAge(const double &amp;_age) {
    ag = _age;
}
</code></pre>

<p>If you want to retrieve the value use the getter.</p>

<pre><code>double getAge() const {
    return ag;
 }
</code></pre>
",0
36575236,36574978,1,"<p>Char has only 1 byte. In this case 1200 is 0100 1011 0000 (binary).
For one byte you can only assign 8 bit, in your case: 1011 0000 (first 4 bits will be deleted). Now you have -80 (first bit shows if negative (1) or positive (0)).
Try with your calculator (programmer) and type 1200 decimal and switch from Qword to Byte and you can see what happens with your number. </p>
",0
36575257,36574978,7,"<p>The trick here is how numbers are represented. Look into <a href=""http://www.exploringbinary.com/twos-complement-converter/"" rel=""nofollow"">2's complement</a>. 30 * 40 in binary is 1200 or 10010110000 base 2. But our char is only 8 bits so we chop off the leading 100 (and all the implied 0s before that). This leaves us with <code>1011000</code>. </p>

<p>Note the leading 1. In 2s complement, how your computer probably stores the values, this indicates a negative number. <code>11111111</code> is -1, <code>11111110</code> is -2 and so on. If go down to 1011000 we get to -80. </p>

<p>That is, if we convert 1011000 to 2s complement we're left with -80.</p>

<p>You can do 2s complement by hand. Take the value, drop the leading sign bit and swap the other values. In this case <code>10110000</code> turns into <code>01001111</code> in binary this would be 79. Turn it negative and remove one more because we don't start at zero and we're at -80.</p>
",4
36269523,36269484,6,"<p>First of all, you'd have better luck researching this topic if you used proper terminology. An empty string is not ""<code>NULL</code>""; a zero-equivalent integer is also not ""<code>NULL</code>"". The only thing that can be ""<code>NULL</code>"" is a pointer (though we use <code>nullptr</code> for those nowadays). So right away we can stop using that term.</p>

<p>There is no general ""not set"" value for arbitrary types, and therefore no common way to detect such a case. However, you can use a wrapper type that explicitly adds this possibility, such as <code>boost::optional&lt;T&gt;</code>:</p>

<pre><code>#include &lt;boost/optional.hpp&gt;
#include &lt;iostream&gt;

template &lt;typename T&gt;
void foo(boost::optional&lt;T&gt; arg)
{
   if (arg)
      std::cout &lt;&lt; arg.get() &lt;&lt; '\n';
}

int main()
{
    boost::optional&lt;int&gt;   a{123};
    boost::optional&lt;int&gt;   b{boost::none};
    boost::optional&lt;float&gt; c{boost::none};
    boost::optional&lt;float&gt; d{123.456};

    foo(a);
    foo(b);
    foo(c);
    foo(d);

    // Or, pass it directly:
    foo(boost::optional&lt;std::string&gt;{""abc""});
    foo(boost::optional&lt;std::string&gt;{boost::none});
    foo(boost::optional&lt;std::string&gt;{});  // as if boost::none were given
}

// $ g++ -std=c++14 -O2 -Wall -Wextra -pedantic -pthread main.cpp &amp;&amp; ./a.out
// 123
// 123.456
// abc
</code></pre>

<h3>(<a href=""http://coliru.stacked-crooked.com/a/9c9ba047dcec0d54"" rel=""nofollow"">live demo</a>)</h3>

<p>Your only other option would be to accept pointers-to-objects and check for <code>NULL</code>ity on the pointer. But that is an abstraction leak, because accepting a pointer indicates an intent other than that of this function; it also creates a bit of a mess with respect to clear ownership semantics.</p>
",1
36269835,36269484,0,"<p>You could have generic code without repeating yourself by using a template that compares to a default constructed version of the object:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

template &lt;typename T&gt;
void doSomething(T t)
{
    std::cout &lt;&lt; ""Doing something with "" &lt;&lt; t &lt;&lt; "" \n"";
}

void doSomethingElse()
{
    std::cout &lt;&lt; ""Doing something else\n"";
}

template &lt;typename T&gt;
void f(T t)
{
    if (t!=T{}) doSomething(t); // compare with default constructed object
    else doSomethingElse();
}

int main()
{
    int var1{};
    std::string var2{};

    int var3{3};
    std::string var4{""var4's text""};

    f(var1);
    f(var2);
    f(var3);
    f(var4);
}
</code></pre>

<p>Produces:</p>

<pre><code>Doing something else
Doing something else
Doing something with 3
Doing something with var4's text
</code></pre>
",0
34900396,34900194,0,"<p>It is not the proper way. <code>++pOther</code> will take you to nowhere. This code will produce undefined behavior. </p>
",2
34900714,34900194,1,"<pre><code>*pOther = getAddr(i);
</code></pre>

<p>You assign here to the value of <code>pOther</code> not the address. <code>*</code> is dereferencing(accessing the pointer content). And <code>&amp;</code> is the opposite, getting pointer or referencing.</p>

<pre><code>OtherType** pOther = &amp;inst.m_pfirst;
</code></pre>

<p>Here <code>&amp;inst.m_pfirst</code> first <code>.</code>(prio. 2) and then <code>&amp;</code>(prio. 3), so you get the struct field and then its address. <code>OtherType** pOther</code> is pointer on pointer. In short, you change the inner pointer to point to <code>inst.m_pfirst</code>. Now you can say for yourself whether that makes sense.</p>

<p><strong>Ussually I do</strong>:</p>

<pre><code>struct mystruct {
int data;
char *arr;
};

struct mystruct *s = malloc(sizeof *s);
s-&gt;data = 5;  //same as (*s).data
int n = 3;
*(s-&gt;data) = &amp;n; //now its 3
int capacity = s-&gt;data;
s-&gt;arr = malloc(capacity * sizeof(*(s-&gt;arr)))
</code></pre>

<p>And then you can plug in your address-functions at the appropriate places.</p>

<p>Hopefully that clears it up a little bit.</p>
",1
34900519,34900194,1,"<p>If your fields are named this way, then you have no choice:</p>

<pre><code>inst.m_pFirst = getaddr(0);
inst.m_pSecond = getaddr(1);
...
</code></pre>

<p>A better struct could be:</p>

<pre><code>struct MyType {
    OtherType *m_pFields[10];
}

...
for (int i=0; i&lt;10; i++) {
    inst.m_pFields[i] = getaddr(i);
}
</code></pre>

<p>As you tagged C++, you can use a ctor:</p>

<pre><code>struct MyType {
    OtherType *m_pFirst;
    OtherType *m_pSecond;
    MyType(OtherType *p1,OtherType *p2): m_pFirst(p1), m_pSecond(p2) {};
};
...
MyType inst(getaddr(0),getaddr(1));
</code></pre>
",3
36836837,36836643,2,"<p>You don't initialise the <code>ptr</code> in <code>main</code>;</p>

<pre><code>int main()
{
    book* ptr = new book(); // initialize it here
    ptr-&gt;add_book();
    return 0;
}
</code></pre>

<p>This will fix the segfault, however, I'm not sure of the logic associated with the sample code, and possible memory leaks.</p>

<hr>

<p>I would look to separate the <code>library</code> from the <code>book</code> type for better composition and avoid the heap allocation;</p>

<pre><code>#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;

class book
{
public:
    std::string Author, Title;
    int Year;
    book(){}
    book(std::string author, std::string title, int year) : Author(author), Title(title), Year(year) {} 
    ~book(){}
};  

struct library {
    std::vector&lt;book&gt; books_;
    void add_book(const book&amp; value) { books_.push_back(value); }
};

int main()
{
    library lib;
    int y;
    std::string a, t;
    std::cin&gt;&gt;a;
    std::cin&gt;&gt;t;
    std::cin&gt;&gt;y;
    lib.add_book(book(a, t, y));
    return 0;
}
</code></pre>
",0
36836838,36836643,1,"<p>Well, here:</p>

<pre><code>book* ptr;
ptr-&gt;add_book();
</code></pre>

<p><code>ptr</code> is unassigned, so its use causes seg fault. You should assign it before use:</p>

<p>ptr = new book();</p>

<p>this will cause memory leak so I suggest (if you like dynamic allocation):</p>

<pre><code>auto ptr = std::make_unique&lt;book&gt;();
ptr-&gt;add_book();
</code></pre>

<p>but, why you need pointer anyway, this:</p>

<pre><code>book bk;
bk.add_book();
</code></pre>

<p>will work the same way.</p>

<hr>

<p>On the other hand, why your <code>book</code>class keeps a vector of <code>book</code> instances? You need a <code>library</code> class which will keep a vector of book-s.</p>
",1
36836842,36836643,1,"<p>You will have to make an object of class Book before using its methods.</p>

<pre><code>Book *ptr = new Book();
</code></pre>
",0
35264370,35263968,0,"<p>Most probably you are accessing the string using subscript which is out of index. It will be easy to answer if you point at which line you are getting the error.</p>
",0
35264081,35263968,0,"<p>There's no need to use a <code>char[]</code> array, use <code>std::string</code> instead, especially given that you already are using it.</p>

<p>Note to OP: <code>cin.getline()</code> is this one:</p>

<p><a href=""http://www.cplusplus.com/reference/istream/istream/getline/"" rel=""nofollow""><code>std::istream::getline(char*, int)</code></a></p>

<p>The one you ned to use for <code>std::string</code>'s is this one:</p>

<p><a href=""http://www.cplusplus.com/reference/string/string/getline/"" rel=""nofollow""><code>std::getline(istream&amp;, string&amp;)</code></a></p>

<pre><code>struct Case{
public:
    int Size;
    vector&lt;string&gt; Names;
    vector&lt;string&gt; Results;
    void Set_Data(){
        std::string temp;
        cin &gt;&gt; Size; cin.ignore();
        for (int i = 0; i &lt; Size; i++){
            std::getline(cin, temp);
            Names.push_back(temp);
        }
    }
}
</code></pre>

<p>As far as compile errors go, always:</p>

<ul>
<li>quote the exact error messgae</li>
<li>tell the line it happened at</li>
<li>show the code that contains the line and the relevant classes/methods</li>
</ul>
",2
35264789,35263968,1,"<p>Personally I would define a class to represent a line. Then you can use stream iterators to load the vector.</p>

<pre><code>class Line
{
    std::string   line;
    public:
        // Operator to convert a line back to a std::string
        operator std::string const&amp;() const {return line;}

        // Friend function to read a line from a stream.
        friend std::istream&amp; operator&gt;&gt;(std::istream&amp; in, Line&amp; data)
        {
            return std::getline(in, data.line);
        }
 };

 int main()
 {
     int countOfPeople;
     std::cin &gt;&gt; countOfPeople;

     std::vector&lt;std::string&gt;  lines;
     std::copy_n((std::istream_iterator&lt;Line&gt;(std::cin)), countOfPeople,
                 std::back_insert_iterator(lines));
 }
</code></pre>
",0
44352221,44351991,2,"<p>No, there isn't any way to do what you're asking.</p>

<blockquote>
  <p>Right now, either casting every multiplication or putting it inside a function returning the same type are the only options I can think of.</p>
</blockquote>

<p>Another option is avoiding using multiple operations in a single expression, implicitly forcing a conversion back to <code>uint16_t</code>:</p>

<pre><code>uint16_t test() {
    uint16_t a = 1000;
    uint16_t b = 1000;
    uint16_t c = 100;
    a *= b;
    a /= c;
    return a;
}
</code></pre>

<p>Or, using a function, that function could be an overloaded operator to keep the code readable:</p>

<pre><code>#include &lt;stdint.h&gt;

template &lt;typename T&gt;
struct unpromoted
{
   T value;

   unpromoted() = default;
   unpromoted(T value) : value(value) { }
   explicit operator T() { return value; }

   friend unpromoted operator*(unpromoted a, unpromoted b)
   { return a.value * b.value; }

   friend unpromoted operator/(unpromoted a, unpromoted b)
   { return a.value / b.value; }

   // add other operators as well
};

using uuint16_t = unpromoted&lt;uint16_t&gt;;

uuint16_t test() {
    uuint16_t a = 1000;
    uuint16_t b = 1000;
    uuint16_t c = 100;
    return (a * b) / c; // returns 169
}
</code></pre>

<p>Note that this does require a cast when e.g. adding an <code>uuint16_t</code> and an <code>uuint8_t</code>. It's possible to let that return an <code>uuint16_t</code>, but I probably wouldn't bother with it.</p>
",1
44352089,44351991,3,"<p>This could be an <a href=""https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem"">XY problem</a>. Depends on your specific work.</p>

<p>While unit testing on a desktop machine for a different architecture could help, I doubt this is the way. Even if you found some switches in the compiler to simulate on x86 some rules for other architecture, you can never be sure that the simulated behavior will be the same as in the real environment. Furthermore there certainly will be other differences (some you can predict, some you cannot) on behavior between the target architecture and the testing architecture.</p>

<p>So in conclusion, testing on an architecture and expecting it to work on another is not reliable, not in a real way anyway. So the solution should be to test on the target architecture. Get an emulator, or a VM, or a remote device on which you can unit test on the real environment.</p>

<p>If that is not a viable option, instead of trying to make unit testing match the real environment from a pc environment, you could just live with these differences, take into account that unit tests are not very reliable and use them just for limited testing, and rely more on integration testing, which should be on the target architecture.</p>
",2
38984161,38984066,2,"<p>Reading data via a <code>delete</code>d pointer is ""Undefined Behaviour"" - meaning that the compiler can do what it pleases and your program has no meaning.</p>

<p>You <em>may</em> get the results you expect, you <em>may</em> get a crash, you <em>may</em> get demons flying out your nose. There is no way to tell. The program is simply invalid and <em>any</em> behaviour is OK. As per the rules of the C++ standard it is the programmers responsibility to <strong>not</strong> invoke undefined behaviour - it <em>may</em> compile and run, but you've broken the rules so the compiler has no obligation to do anything sane (or even anything at all).</p>
",3
36756705,36756462,2,"<p>It seems likely that you are not compiling with C++11 or higher, since your compiler is complaining about the following line:</p>

<pre><code>const auto infinity = std::numeric_limits&lt;int&gt;::infinity();
</code></pre>

<p>Assuming you have indeed included <a href=""http://en.cppreference.com/w/cpp/header/limits"" rel=""nofollow""><code>#include &lt;limits&gt;</code></a>, there is nothing wrong with that line except the use of <code>auto</code>. Without C++11, the compiler doesn't know what <code>auto</code> is. Compile with C++11 or higher, or change <code>auto</code> to <code>int</code>.</p>

<p>Unrelated, and this was pointed out in the comments, but using <a href=""http://en.cppreference.com/w/cpp/types/numeric_limits/infinity"" rel=""nofollow""><code>numeric_limits&lt;int&gt;::infinity</code></a> is an awful, awful way of checking things. It doesn't make any sense to make an <code>int</code> comparison in regards to infinity. Prefer to use <a href=""http://en.cppreference.com/w/cpp/types/numeric_limits/max"" rel=""nofollow""><code>numeric_limits&lt;int&gt;::max</code></a> instead (or whatever else suits your purposes).</p>
",1
42607204,27746642,0,"<p>I faced the same problem.
Run Visual Studio as Administrator solved my problem.</p>
",0
44710643,44710572,2,"<p>You are using the assignment operator <code>=</code> where you should be using the equality operator <code>==</code></p>

<blockquote>
  <p>if (x = 1)</p>
</blockquote>

<p>That is where your x becomes 1</p>
",3
34985459,34985048,10,"<p>Maybe a little clarification is in order -- getters and setters aren't meant to be avoided at all costs; they have their place.  The reason people say they should be avoided is because one goal of good object-oriented program design is <em>encapsulation</em> -- that is to say, each class should keep the details of its own implementation as private as possible, so that users of that class don't need to know (or care) about how the class was implemented.  This becomes increasingly important as the program gets larger and more complicated, because a human programmer can only keep so many details in his/her head at once, and if the programmer has to remember everything about how class C works while simultaneously writing/debugging class A, that's an additional/unecessary cognitive burden that at some point will cause the programmer's brain to explode.</p>

<p>So, getting back to the main question -- how to avoid getters and setters -- the way to do it is to define your classes' interfaces at a higher level of abstraction than as simple repositories for state variables.  (After all, if you wanted a simple collection of state variables, there's no reason to use a C++ class at all, you could simply declare a C-style struct instead)</p>

<p>For example, if your class C was intended to represent, say, a slot machine, a poor interface to class C might include lots of getters and setters, like this:</p>

<pre><code>int getNumCoins() const {return numCoins;}
void setNumCoins(int newCoinCount) {numCounts = newCoinCount;}
void setDisplayedResult(const string &amp; displayStr) {result = displayStr;}
int getDisplayedResult() const {return result;}
</code></pre>

<p>... and the poor programmer who was forced to use class C would have to write code like this:</p>

<pre><code>playersWallet--;  // take a coin out of the player's wallet
c.setNumCoins(c.getNumCoins()+1);  // insert the coin into the machine
string newResult = ""10 J A"";   // somehow figure out what the machine should display
c.setDisplayedResult(newResult);  // and make the machine display it
if (c.getDisplayedResult() == ""7 7 7"")
{
   cout &lt;&lt; ""YOU ARE WINNER!"" &lt;&lt; endl;
   int numCoinsWon = 5000;  // jackpot!
   c.setNumCoins(c.getNumCoins()-numCoinsWon);  // deduct from machine's balance
   playersWallet += numCoinsWon;  // add to player's balance
}
[... and so on...]
</code></pre>

<p>Note that in the above code, the programmer had to think about all of the internal mechanisms of the slot machine, and write his own code to handle each step of its operation.  With good encapsulation, on the other hand, the slot machine's public interface would be much simpler and more opaque, like this:</p>

<pre><code>// returns the number of coins the player won on this round
int pullTheBigLever();
</code></pre>

<p>... and the programmer who was using this API might write code like this:</p>

<pre><code>playersWallet += (c.pullTheBigLever() - 1);  // -1 for the coin the player put in
</code></pre>

<p>Note that there is only one line of code, and that the programmer didn't have to think at all about how the internals of the slot machine worked.  This avoids exploding-programmer-brain-syndrome, and just as importantly it means you (or someone else) can go back later and change the private implementation of how the slot machine works without breaking the code that interacts with the slot machine.</p>

<p>So when are getters and setters acceptable?  Answer:  when there really isn't any higher level of abstraction to be had.  If you are writing a class that represents a light switch, then just being able to examine the switch's current position, or specify a new position for it, may be all the functionality you need.  But in many (most?) cases you are implementing the functionality of something more complex than that, and the more of that complexity you can hide behind your public interface, the happier users of that class (including you) will be.</p>
",0
34985081,34985048,1,"<blockquote>
  <p>How avoid using getters/setters in C++.</p>
</blockquote>

<p>To avoid setter/getter, all code that accesses a data attribute of class C, must be part of a class C method.</p>

<p>Alternate wording: bring the code that uses the data attribute inside the class.</p>

<hr>

<p>update 2016/01/25</p>

<p>Would an example help?  I find it trivial to avoid getters and setters (and public data and friends, etc.)  I suppose I'm just used to it.</p>

<p>I recently completed yet another implementation of the game-of-life.  The whole game is the entertainment value of watching the cells change patterns.  Impressively complex behaviour from a small set of rules.  </p>

<p>My class Cell_t has ONLY private data, No getters, no setters, and no friends.  No other class has access to any cells data.  </p>

<p>Here is a snippet of that part of my game illustrating how easy it is to live without getters, setters and friends creating the undesirable coupling and cohesion:</p>

<pre><code>// somewhere in GameOfLife exists 
std::vector&lt;Cell_t&gt; m_ptCellVec;  // a vector of cell ptrs


GameOfLife::exec(...)
{
   // ... preliminary stuff

   do {

      // ... some preliminary stuff

      // NOTE 1
      for ( auto it : m_ptCellVec ) it-&gt;countNeighbor();

      // NOTE 2
      for ( auto it : m_ptCellVec ) { it-&gt;updateDisplay();}

      // .... more stuff

      if(timeElapsed &gt; timeLimit)  break;
      if(m_generation &gt; genLimit)  break;
   }while(1);
}
</code></pre>

<p>NOTE 1 -- The class GameOfLife does not count neigbors ... each cell does its own counting.  The next state is computed from these counts.</p>

<p>NOTE 2 -- The class GameOfLife does not update the display ... each cell updates it's own little piece of the screen. </p>

<p>THUS, there is no getter of Cell_t state, or next state, or living-neighbour count, or dead-neighbour count, etc.  </p>

<p>With respect to this aspect of these two classes</p>

<pre><code>The cohesion (of Cell_t) is functional, the most desirable.

The coupling (of GameOfLife_t to Cell_t) is 'none', also the most 
desirable.

Changing the name or type of a Cell_t private data attribute has no 
impact on any other code.  
</code></pre>

<hr>

<p>Oh, and a debug routine I often add (for another example):</p>

<pre><code>std::string Cell_t dump() {
   std::stringstream ss;
   ss &lt;&lt; // .... anything you want to 'dump' from this instance 
   return (ss.str());
}
</code></pre>

<p>I use the method name dump() to indicate an intent for a 'deeper' investigation of the activity of a specific Cell_t ... I have sometimes generated tabular data of state changes, with time stamps.</p>

<p>I often have a very similar method called show(), which typically provides a string for the user ... </p>

<p>These two examples, perhaps, illustrate the idea that a getter is simply bypassing an important aspect of the design process - naming what you are doing. </p>
",5
34985749,34985048,2,"<p>Short answers, in OOP, classes should have ""properties"" as part of their public API. Properties can have have things like getters, setters and change notifications, as appropriate. Wether a  getter directly returns a private member variable, that is an implementation detail,  and could change as needed. Distinguish the concept of property from the concept of member variable.</p>

<p>When thinking about it like this, the direct answer to your question is, that there's nothing you should try to ""avoid"", other than having unnecessary readable properties.</p>

<p>Note that often there is no explicit syntax or support for properties in an object oriented language (popular counter-example: <a href=""https://msdn.microsoft.com/en-us/library/x9fsa0sw.aspx"" rel=""nofollow"">C#</a>), so it's easy to think they are same thing as a member variable with a setter and a getter. But the overlap is sort of a coincident, and not something you should care about when using a class. In a way, there is no getter for a member variable, there is only a getter for the property, even if it happens to map 1:1 with a member variable.</p>
",0
37701496,37700976,7,"<p>Inheriting from <code>true_type</code>/<code>false_type</code> will already provide you with corresponding <code>value</code> member, function call operator and implicit conversion to bool. In addition, if you will use inheritance, your type would be eligible for tag dispatch, which is often clearer and easier than SFINAE:</p>

<pre><code>namespace detail 
{
template &lt;typename T&gt;
void do_work(T&amp; foo, std::true_type);

template &lt;typename T&gt;
void do_work(T&amp; foo, std::false_type);
}

template &lt;typename T&gt;
void do_something(T&amp; foo) 
{
    //Selects overload depending on type of IsSharedPtr&lt;T&gt;
    detail::do_work(foo, IsSharedPtr&lt;T&gt;{})
}
</code></pre>
",1
37160115,37158445,1,"<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

void printSpace(int n)
{
    for(int i=0; i&lt;n; i++)
    {
        cout &lt;&lt; ""  "";
    }
}

int main()
{
    char word[100];
    int len, temp;
    cout &lt;&lt; ""Input word with odd letters: \n"";
    cin &gt;&gt; word;
    len = strlen(word);
    cout &lt;&lt; ""Entered word was : ""&lt;&lt; word &lt;&lt; "" and of size: "" &lt;&lt; strlen(word) &lt;&lt; ""\n"";
    if(len % 2==0)
    {
        cout &lt;&lt; ""Please enter a word with odd number of letters!"";
    }
    else
    {
        int mid;
        mid = (len - 1)/2;
        cout &lt;&lt; ""The middle number is : "" &lt;&lt; mid+1 &lt;&lt; "" and character is "" &lt;&lt; word[mid] &lt;&lt; ""\n"";
        temp = len - 1;

        int up=len-2, side=0, down=1;
        char a,b;
        for(int i=0; i&lt;len; i++)
        {
            if(i &lt; mid)
            {
                a = word[i];
                b = word[len-i-1];
            }
            else
            {
                a = word[len-i-1];
                b = word[i];
            }

            printSpace(side);

            cout &lt;&lt; a;

            if(i &lt; mid)
            {
                printSpace(up);
                up -= 2;
            }
            else if(i &gt; mid)
            {
                printSpace(down);
                down += 2;
            }

            if(i != mid) cout &lt;&lt; b;

            printSpace(side);
            cout &lt;&lt; endl;

            if(i &lt; mid) side++;
            else side--;
        }
        cout &lt;&lt; ""done"" &lt;&lt; endl;
    }
}
</code></pre>
",3
41201711,41201696,10,"<p>You need to allocate some space to hold the concatenated strings. Fortunately, C++ has the <code>std::string</code> class to do this for you.</p>

<pre><code>std::string fullPath = path;
fullPath += archivo;
fullPath += extension;
const char *foo = fullPath.c_str();
</code></pre>

<p>Be aware that the space containing the concatenated strings is owned by <code>fullPath</code> and the pointer <code>foo</code> will only remain valid so long as <code>fullPath</code> is in scope and unmodified after the call to <code>c_str</code>.</p>
",1
41201759,41201696,0,"<p>When you use a <code>const char*</code> you can't change the chars to which are pointing. 
So append <code>const char*</code> to a <code>const char*</code> is not possible!</p>
",0
41201768,41201696,2,"<p>If you want to construct <em>at compile-time</em> a bunch of string literals, some of which are concatenations of other string literals, the most basic idiomatic low-maintenance technique is based on the good-old preprocessor</p>

<pre><code>#define PATH ""C:\\Users\\xxx\\Desktop\\""
#define NAME ""vectors""
#define EXT  "".txt""

const char *path = PATH;
const char *archivo = NAME;
const char *extension = EXT;

const char *fullPath = PATH NAME EXT;
</code></pre>

<p>However, the same thing can be achieved in more moden way by using some <code>constexpr</code> and template meta-programming magic (see <a href=""https://stackoverflow.com/questions/13292237/c-concat-two-const-char-string-literals"">C++ concat two `const char` string literals</a>).</p>

<p>Otherwise, you will have to resort to run-time concatenation (like <code>std::string</code> and such). But again, if the input is known at compile time, then a run-time solution is a ""loser's way out"" :)</p>
",0
40778144,40778086,3,"<p>Yes, the linker will generally fold duplicate identical template instantiations away. Doing so is pretty much required to avoid an explosion in binary size when templates are involved, and to maintain some standard required invariants such as equivalence of function pointers. This behavior is sometimes called <em>fold by name</em>.</p>

<p>Beyond that, <a href=""https://stackoverflow.com/q/15168924/149138"">some linkers</a> will even fold away all symbols that <em>happen</em> to be identical in content (i.e., compile the same code), even if they don't originate from the same definition. This is sometimes called <em>fold by value</em>, but unless done carefully may break the letter of the standard (i.e., because function pointers to different functions now compare equal).</p>
",0
42475385,42475301,2,"<p>You need to specify the type:</p>

<pre><code>std::mt19937 Foo::genId = std::mt19937(Foo::rdId());
std::uniform_real_distribution&lt;&gt; Foo::randId = std::uniform_real_distribution&lt;&gt;(0, 100);
</code></pre>
",1
36557143,36555296,1,"<p>One way to do this is to just keep the list of found indices in a static local.  But then, how do you know you haven't already seen this one before? So better to make it a class.  Then you can also do some optimization: sort the array once, then just pop the next highest index from the result whenever it's called:</p>

<pre><code>struct mysort{
    const std::vector&lt;int&gt;&amp; _tosort;
    mysort(const std::vector&lt;int&gt; tosort) : _tosort(tosort) {}
    bool operator()(int a, int b){ return _tosort[a] &lt; _tosort[b]; }
}


class IndexFinder{
private:
    std::vector&lt;int&gt; sorted_indices;
    int invoked;
public:
    IndexFinder(const std::vector&lt;int&gt;&amp; tosort) :
      sorted_indices(tosort.size()) {
        invoked = 0;
        for(size_t i=0; i&lt;tosort.size(); ++i)
            sorted_indices[i] = i;
        std::stable_sort(sorted_indices.begin(), sorted_indices.end(),
                          mysort(tosort));
    }

    int IndexFinder::operator()(){
        return sorted_indices[invoked++];
    }
}; 
</code></pre>

<p>You should put in protections to IndexFinder::operator()() to handle what happens if the user calls it more times than there are indices in the vector.  As a bonus you should be pretty easily able to change it into a template class to sort things other than ints. </p>
",0
36557790,36555296,0,"<p>This is a little different than the previous answer @bloer gave, but shows somewhat of a shorter method (it still uses a class) by using C++ 11 (<code>std::iota</code> and usage if lambda in <code>std::sort</code>).</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

class MaxIndex
{
    private:
        std::vector&lt;int&gt; index;

    public:
        MaxIndex(const std::vector&lt;int&gt;&amp; tosort) : index(tosort.size()) 
        {
           // initialize the indices
           std::iota(index.begin(), index.end(), 0);

           // sort the indices based on passed-in vector
           std::sort(index.begin(), index.end(), [&amp;](int n1, int n2)
                     { return tosort[n1] &gt; tosort[n2];});
        }

        // return the nth highest index 
        int getNthMaxIndex(int n) const { return index[n]; }
};

using namespace std;

int main()
{
   std::vector&lt;int&gt; a = {2,6,4,12,5,7,12,8};
   MaxIndex mi(a);
   for (size_t i = 0; i &lt; a.size(); ++i)
      cout &lt;&lt; mi.getNthMaxIndex(i) &lt;&lt; endl;
}
</code></pre>

<p><a href=""http://ideone.com/GwyM77"" rel=""nofollow"">Live Example</a></p>

<hr>

<p>Second, is there a reason to consistently use <code>n</code> if you're going to use <code>std::vector</code>?  A <code>std::vector</code> knows its own size, so passing (and using) extraneous variables denoting the number of elements in a vector is inviting a bug to be introduced somewhere.  Just use the <code>std::vector::size()</code> function if you want to get the number of elements, or just pass the vector by itself.</p>

<p>In addition, you should be passing things like <code>std::vector</code> by either reference or const reference, depending on whether the passed-in vector will be changed or not.  Passing <code>std::vector</code> by value (as you're doing now) incurs an (unnecessary) copy.</p>
",0
35236303,35236112,0,"<p>this if is fine. 
for example if you type mars, code will get value 3. 
But then in next step of loop you will set it again to -1 ;)
Break the loop when result is found. </p>

<p>Advice:
Split this part of code to new function. </p>
",0
35236145,35236112,4,"<p>You need to <code>break</code> the loop after you have found the matching planet name, otherwise the loop keeps searching, and the next name won't match so <code>code</code> is set to  -1.</p>

<p>Also: for efficiency and clarity: set <code>code = -1</code> before the loop and only set to <code>x</code> on a match:</p>

<pre><code>code = -1;
for (int x = 0; x &lt; 8; x++)
{
    if (planet == planetNames[x])
    {
        code = x; //THIS IS WHERE THE PROBLEM IS!!!!!!!!!
        break; // And now it's gone ;-)
    }
}
</code></pre>
",0
42545862,42545836,4,"<pre><code>for (auto it : digits){
</code></pre>

<p>The range variable gets essentially copied by value, from the sequence, so</p>

<pre><code>   swap(tmpInt, it);
</code></pre>

<p>all this is doing is swapping between <code>tmpInt</code> and a temporary range variable.</p>

<p>You need to use a reference, in order to get equivalent results with the first example:</p>

<pre><code>for (auto &amp;it : digits){
   swap(tmpInt, it);
</code></pre>
",0
39107210,39107183,1,"<p>The copy of <code>std::string</code> will do an allocation (unless small string optimization), whereas passing <code>char</code> as parameter would probably be done by register.</p>

<p>Pass <code>std::string</code> by const reference</p>

<pre><code>void func(const std::string&amp;);
</code></pre>
",3
39107245,39107183,1,"<p>Passing every character of a string by value to a function is just as not-okay as passing the entire string by value. That is, in both cases you should prefer some alternative, where the entire string doesn't have to be copied or traversed, if you can.</p>
",0
39107461,39107183,1,"<p>Passing a single character by value is OK because the size of a character is less than the size of a pointer you need to pass by reference. Plus, no copy constructors are invoked for a character.</p>

<p>(That does not mean calling a function for each character in a string is always OK)</p>
",0
36429759,36428550,1,"<p>It's generally not possible to have two functions with the same name which only differ by return type. In a narrow sense I see the following main possibilities to work around that limitation:</p>

<ul>
<li>A general solution for this kind of problem is to have references as arguments which are changed as a side effect of the function. The actual return value is a simple bool or integer indicating success. Here you would pass a reference to an initially empty vector; whether the string was parsed and split or not would be indicated by a boolean return value, and the results of the parsing -- if it happened -- would be put in the referenced vector.</li>
<li>Return a vector as before; an empty vector would indicate that no parsing happened. This solution implies that the raw string is accessible by the caller, for example because obtaining the string and parsing it were separated in two functions.</li>
</ul>

<p>In a wider sense this is just a design problem, as you just detected. You can obtain, inspect, and -- only if the inspection indicates that it's necessary --  parse the data in separate steps so that you know which function to call and what to do with the data at every point. Divide et impera, the Tao of programming.</p>
",5
45712103,45711854,3,"<p>For example, it would be</p>

<pre><code>template &lt;typename T, std::size_t S1, std::size_t S2, S3&gt;
struct Matrix3D
{
    // ...

     const T&amp; operator()(std::size_t i, std::size_t j, std::size_t k) const {
          return data[i][j][k];
     }
     T&amp; operator()(std::size_t i, std::size_t j, std::size_t k) {
          return data[i][j][k];
     }
private:
    T data[S1][S2][S3];
};
</code></pre>
",0
45712184,45711854,0,"<p>Thanks to your help I have a solution:</p>

<pre><code>T&amp; operator()(unsigned width, unsigned height) {
    return my_data[width + height * data_width];
}
</code></pre>

<p>works both ways:</p>

<pre><code>my_class(1,2) = value;
value = my_class(1,2);
</code></pre>
",0
39676931,39676527,1,"<p>Both versions of your code are problematic.</p>

<p>The first version, </p>

<pre><code>make_shared&lt;short&gt;(dimX*dimY)
</code></pre>

<p>creates a <em>single</em> heap-allocated short with the value <code>dimX*dimY</code>. It is apparent from the rest of your question, that your code later treats this logically as an <em>array</em> of dimension <code>dimX*dimY</code>, which is exactly what's causing the heap corruption (you only allocated a single <code>short</code>, but you're treating it like many).</p>

<p>The second version has the opposite problem. You're allocating <code>dimX*dimY</code> shorts, but, as far as your <code>shared_ptr</code>, it doesn't know that. So it doesn't have your heap corruption, but the <code>shared_ptr</code> destructor calls <code>delete</code>, not <code>delete[]</code> (even though you allocated with <code>new[]</code>, not <code>new</code>).</p>

<hr>

<p>For this case, its' unclear why you need a <code>shared_ptr</code> to begin with. Why not use <code>std::vector&lt;short&gt;</code>, or <code>std::vector&lt;std::vector&lt;short&gt;&gt;</code>?</p>
",0
36248296,36248285,4,"<p>No.</p>

<p><code>&amp;&amp;</code> and <code>||</code> have short-circuit evaluation, that is, once the result is definitely known (<code>false</code> for <code>&amp;&amp;</code> and <code>true</code> for <code>||</code>) evaluation stops. And it's always strictly left-to-right.</p>

<p>In this case the compiler might even choose to elide the <code>if</code> statement completely, since the condition at compile-time is known to be <code>false</code> and thus the code afterwards is unreachable.</p>
",2
36248299,36248285,8,"<p>Because C++ have <a href=""https://en.wikipedia.org/wiki/Short-circuit_evaluation"" rel=""noreferrer""><em>short-circuit evaluation</em></a> of conditions, no the function will not be called since the first<code>false</code> makes the whole expression false anyway.</p>

<p>If you change the order, so you put the function call first (i.e. <code>myfunc() &amp;&amp; false &amp;&amp; true</code>) then the function will be called. The result of the expression will still be <code>false</code> though, no matter what <code>myfunc</code> returns.</p>
",2
36248300,36248285,1,"<p>No, <code>myfunc()</code> will not be called, because of the first <code>false</code>, compiler will stop there. It's called short circuit evaluation.</p>
",0
38097436,26458422,0,"<p>You are creating a new Account object every time you need it. Of course it will be 0 when you print it as the default constructor initializes the balance to 0.</p>

<p>Rather when the App starts, as the user to identify his account or something and create a corresponding account instance. The instance need to be there throughout the whole time user operates on it. </p>

<p>So instantiate not in the methods but in the main function. And pass the instance to the methods as a way of modifying the instance as required.</p>
",0
41219717,41219650,2,"<p>You have a reference cycle between header files.
To resolve problem don't use </p>

<pre><code>#include ""...""
</code></pre>

<p>but use</p>

<pre><code>class XXX;
</code></pre>
",0
35229268,35229198,1,"<p>Declare second function before first, so it can see it's existence.</p>

<pre><code>int function2();

int function1() {
    if (somethingtrue) {
        function2();
    }
}

int function2() {
    //do stuff
    function1(); //beware of double recursion.
}
</code></pre>
",0
35229277,35229198,1,"<pre><code>int function2();

int function1() {
    if (somethingtrue) {
        function2();
    }
}

int function2() {
    //do stuff
    function1();
}
</code></pre>

<p>This is called forward declaration. You let the compiler know there is a function called <code>function2()</code>, without defining it. This is enough for the compiler to insert a call to that function when it's called inside <code>function1()</code>, which is then resolved at link-time.</p>
",9
35229278,35229198,1,"<p>Forward declare function2().</p>

<pre><code>int function2(); //forward declaration

int function1() {
    if (somethingtrue) {
        function2();
    }
}

int function2() {
    //do stuff
    function1();
}
</code></pre>
",0
35229282,35229198,3,"<p>Use <a href=""https://en.wikipedia.org/wiki/Forward_declaration"" rel=""nofollow"">forward declaration</a>. You can declare a function before using it by just writing its signature, followed by a semicolon. With that, you promise the compiler that there will be a function definition with the same signature somewhere else.</p>

<pre><code>int function2();

int function1() {
    if (somethingtrue) {
        function2();
    }
}

int function2() {
    //do stuff
    function1();
}
</code></pre>
",0
35229284,35229198,2,"<p>Just put this above your functions:</p>

<pre><code>int function1();
int function2();
</code></pre>

<p>But don't create an endless loop!
With that two lines you tell the compiler that <code>function1</code> and <code>function2</code> will be <strong>defined</strong> in the future. In bigger projects you would use header files. There you do the same but can use the functions in multiple files.</p>

<p>And also don't forget the return statement. I think your code example was only demonstration but I only want to mention it. </p>

<p>In C++ you must seperate <strong>declaration and definition</strong>.
Read more about it here: <a href=""https://stackoverflow.com/a/1410632/4175009"">https://stackoverflow.com/a/1410632/4175009</a></p>
",2
35229302,35229198,8,"<p>This is a case for a forward declaration.  A forward declaration tells the compiler that the name is going to exist, what it's type is and allows you to use it in a limited context before you define it.</p>

<pre><code>int function2();  // this lets the compiler know that that function is going to exist

int function1() {
    if (somethingtrue) {
        function2(); // now the compiler know what this is
    }
}

int function2() { // this tells the compiler what it has to do now when it runs function2()
    //do stuff
    function1();
}
</code></pre>
",0
35229336,35229198,1,"<p>This will solve your problem: </p>

<pre><code>int function2();

int function1() {
    if (true) {
        function2();
    }
}

int function2() {
    //do stuff
    function1();
}
</code></pre>
",1
41173085,41170571,2,"<p>I have tested the following setup in XCode with apple compiler and GNU++ language dialect; the setup has to be used - if to be used at all - with care. See remarks at the end of the answer.</p>

<p>Suppose a header file defining class A as follows:</p>



<pre class=""lang-cpp prettyprint-override""><code>// testprivateA.h:
#ifndef memberpublic
#define memberpublic private:
#endif

class A {

memberpublic

    int x;
};

#undef memberpublic
</code></pre>

<p>... and a separate headerfile defining class B:</p>

<pre class=""lang-cpp prettyprint-override""><code>// testprivateB.h:
#include ""testprivateA.h""

class B {

public:
    void test();

    A a;
};
</code></pre>

<p>At the place where member function <code>B::test()</code> is implemented, define <code>memberpublic</code> as <code>public:</code>:</p>

<pre class=""lang-cpp prettyprint-override""><code>// testprivateB.cpp:
#define memberpublic public:
#include ""testprivateB.h""

void B::test()
{
    a.x = 5;  // OK
}
</code></pre>

<p>Whereas at any other place, where class <code>A</code> is used, let <code>memberpublic</code> remain undefined; accessing member variable <code>A.x</code> then yields a compiler error:</p>

<pre class=""lang-cpp prettyprint-override""><code>// anyOtherFile.cpp:
#include ""testprivateB.h""
void testfail()
{
    A a;
    a.x = 5; // Error: 'x' is a private member of 'A'
}
</code></pre>

<p>One now may ask if this behaviour is according to c++ standard or not. And the answer to this question is - actually not (though it took me a while to find out why).</p>

<p>Though there may be more than one definition of a class in a program, above setting contradicts the <a href=""http://en.cppreference.com/w/cpp/language/definition"" rel=""nofollow noreferrer"">One Definition Rule</a>, because different access specifiers lead to different sequences of tokens:</p>

<blockquote>
  <p>There can be more than one definition in a program, as long as each definition appears in a different translation unit, of each of the following: class type, enumeration type, inline function with external linkage inline variable with external linkage (since C++17), class template, non-static function template, static data member of a class template, member function of a class template, partial template specialization, as long as all of the following is true:
  <strong>- each definition consists of the same sequence of tokens (typically, appears in the same header file)</strong></p>
</blockquote>

<p>Still it could work, but the main issue is the connection of memory layout and access specifiers as defined in <a href=""http://en.cppreference.com/w/cpp/language/access"" rel=""nofollow noreferrer"">access specifiers - cppreference.com</a>:</p>

<blockquote>
  <p>Any number of access specifiers may appear within a class, in any order. Member <strong>access specifiers may affect class layout</strong>: the addresses of non-static data members are only guaranteed to increase in order of declaration for the members with the same access. For StandardLayoutType, all non-static data members must have the same access. ...</p>
</blockquote>

<p>Still it can work, if all non-static data members in the respective class have the same access specifier. If it is a good solution, one may decide... </p>
",2
35193260,35192905,1,"<p>Adapt your code like this:</p>

<pre><code>void addition (int a[], int b[], int sizea, int sizeb, int result[]){

    int maxSize = sizea &gt; sizeb ? sizea : sizeb;  // number of bits is maximum of siza and sizeb

    int carry = 0;
    for( int i = 0; i &lt; maxSize; i++ )
    {
        int bitA = i &lt; sizea &amp;&amp; a[i] ? 1 : 0;     // test if bit in array a is set
        int bitB = i &lt; sizeb &amp;&amp; b[i] ? 1 : 0;     // test if bit in array b is set
        int sum = bitA + bitB + carry;            // calculate sum of all bits
        result[i] = sum == 1 || sum == 3 ? 1 : 0; // result bit is set if sum is equal 1 or 3
        carry = sum &gt; 1 ? 1 : 0;                  // carry bit is set if sum is eaul 2 or 3
    }
    result[ maxSize ] = carry;                    // highest bit of result is carry bit

    for (int i = 0; i &lt;= maxSize; i++){
        cout &lt;&lt; result[maxSize-i];
    }
    cout &lt;&lt; endl;
}
</code></pre>
",2
36609863,36609828,3,"<p>The address <em>of</em> the pointer will not change, but the pointer may point to something else if you start to increment it:</p>

<pre><code>char* x = ""test"";
// *x is now 't'

x++;
// *x is now 'e'
</code></pre>

<p>There's no meaningful way to manipulate the address of the pointer itself unless you're using a pointer to a pointer, like <code>char** x</code>.</p>

<p>Your remark about ""when the user requests some memory"" and implying you must manipulate the pointer seems to be based on flawed assumptions. If you're doing this C-style you'd use <code>realloc()</code> where you get a pointer to the new allocation back. If you're doing C++ properly you'd <code>new</code> some new memory, copy the contents over, and <code>delete</code> the old allocation.</p>
",3
36610242,36609828,3,"<p>In your comments you indicate that your code is along the liens of:</p>

<pre><code>char mem_arr[] = ""hello world"";
char* memPointer = &amp;mem_arr[0];
memPointer += actualSize;
printf(""memPointer = %p\n"", &amp;memPointer);
</code></pre>

<p>This line </p>

<pre><code>char* memPointer = &amp;mem_arr[0];
</code></pre>

<p>says: Let there be a variable of type <code>char*</code> called <code>memPointer</code> and let it contain <em>the address of the 1st element of mem_arr</em>. After this line, the variable <code>memPointer</code> <em>contains</em> the address of <code>mem_arr[0]</code>.</p>

<p><code>&amp;memPointer</code> expands to the <em>address-<strong>of</em></strong> memPointer rather than the address that memPointer contains. memPointer is a named variable, and saying <code>&amp;memPointer</code> evaluates to the address - location in memory - of that variable, not its value.</p>

<pre><code>memPointer += actualSize;
printf(""&amp;mem_arr[0] = %p, memPointer = %p\n"", &amp;mem_arr[0], memPointer);
</code></pre>

<p>will set memPointer to point to the <em>actualSize</em>th element of mem_arr, as your code appears to be trying to do.</p>
",0
36610256,36609828,1,"<p>Maybe you're confused getting the address of <em>mempointer</em> instead of the address that <em>mempointer is pointing to</em></p>

<p>This code shows how the address that my_pointer is pointing to changes whenever i increase the pointer or i give him a new memory address, take a look:</p>

<pre><code>int mem_arr[256];
int * my_pointer = &amp;mem_arr[0];

// let's give some values to the array just
// for fun
for(int i = 0; i &lt; 256; i++)
{
    mem_arr[i] = 10 + (i * 10);
}

// print original value &amp; address
std::cout &lt;&lt; ""Value 1: "" &lt;&lt; *my_pointer &lt;&lt; "" Address 1: "" &lt;&lt; my_pointer &lt;&lt; std::endl;

// increase pointer (+4 bytes)
my_pointer++;

// print current value &amp; address
std::cout &lt;&lt; ""Value 2: "" &lt;&lt; *my_pointer &lt;&lt; "" Address 2: "" &lt;&lt; my_pointer &lt;&lt; std::endl;

// let's seek into the 8th element
// of the array
my_pointer = &amp;mem_arr[8];

// and print current value &amp; address once again
std::cout &lt;&lt; ""Value 3: "" &lt;&lt; *my_pointer &lt;&lt; "" Address 3: "" &lt;&lt; my_pointer &lt;&lt; std::endl;

getchar();
</code></pre>

<p><code>my_pointer</code> </p>

<p>by itself returns the address that my_pointer is pointing to, while </p>

<p><code>&amp;my_pointer</code> </p>

<p>returns the address where the pointer <code>my_pointer</code> is stored</p>
",0
37842029,37841637,2,"<p>I suspect that the problem is from the combination of this couple of methods</p>

<pre><code>list&lt;Product&gt; Supermarket::GetProduct_list()
 {return Product_list;}

void Supermarket::Add_new_product_in_productlist(Product P)
{
   //Need to Implement
   list&lt;Product&gt;&amp; Product_list = GetProduct_list();
   Product_list.push_back(P);
   cout &lt;&lt;""GetProduct Count in ADD_new""&lt;&lt;GetTotalProductsCount()&lt;&lt;endl;
}
</code></pre>

<p><code>GetProduct_list()</code> return a <strong>copy</strong> of the member <code>Product_list</code>, so when you define</p>

<pre><code>   list&lt;Product&gt;&amp; Product_list = GetProduct_list();
</code></pre>

<p>you obtain a reference to a <strong>copy</strong> of the member; when you add a product</p>

<pre><code>   Product_list.push_back(P);
</code></pre>

<p>you add a product in a copy of the member, not in the member. Copy that is destroyer exiting from <code>Add_new_product_in_productlist()</code></p>

<p>I suppose you could simply avoid the use of <code>GetProduct_list()</code></p>

<pre><code>void Supermarket::Add_new_product_in_productlist(Product P)
{
   Product_list.push_back(P);
   cout &lt;&lt;""GetProduct Count in ADD_new""&lt;&lt;GetTotalProductsCount()&lt;&lt;endl;
}
</code></pre>

<p>but, if you want use <code>GetProduct_list()</code> in this way, you should return a reference to <code>Product_list</code>, so</p>

<pre><code>list&lt;Product&gt; &amp; Supermarket::GetProduct_list()
 { return Product_list; }
</code></pre>

<p>p.s.: sorry for my bad English</p>
",1
35216399,35216307,0,"<p>To start a different software than your own program (with or without arguments) you can use <a href=""http://www.cplusplus.com/reference/cstdlib/system/"" rel=""nofollow"">system()</a> from <code>&lt;cstdlib&gt;</code> header.</p>

<pre><code>#include &lt;cstdlib&gt;
int main(int argc, char* argv[]) {
  system(""start putty -ssh user@server -pw password"");
  return 0;
}
</code></pre>

<p>If you want to evaluate the arguments to your own program, you can use <code>argv[]</code>. <code>argv[0]</code> holds the name/path of your program, and <code>argv[1] ... argv[argc-1]</code> the actual arguments i.e. </p>

<pre><code>#include &lt;cstring&gt;
#include &lt;iostream&gt;

int main(int argc, char* argv[]) {
  if ((argc &gt; 1) &amp;&amp; (!strcmp(argv[1], ""-help""))) {
    std::cout &lt;&lt; ""Showing help"" &lt;&lt; std::endl;
  }
  return 0;
}
</code></pre>
",2
38017526,38017510,0,"<p>Simply use a newline character <code>'\n'</code>.</p>

<pre><code>ofstream data_ip_list;
data_ip_list.open(""data_ip_list.txt"", std::ios_base::app);

ifstream fileinput(""ip_a.txt"");
if(fileinput.is_open()){
    for(i = 0; i &lt; count; ++i)
    {
        fileinput &gt;&gt; str1[i];
        data_ip_list &lt;&lt; str1[i] &lt;&lt; '\n';
</code></pre>
",0
38017610,38017510,0,"<p>You can use either <code>std::endl</code> or <code>'\n'</code> to add the newline</p>

<pre><code>data_ip_list &lt;&lt; std::endl;
// or
data_ip_list &lt;&lt; '\n';
</code></pre>

<p>But <code>std::endl</code> flush the output buffer, which may be a little slower than <code>'\n'</code>.</p>
",0
36303640,36302006,1,"<p>Since all the example formats are different (e.g. the occurrence of commas, spaces, or slashes), you could try to identify the input format by checking for the format-specific characters:</p>

<pre><code>std::string inputDate = ""Wed, 31 Mar, 2016 10:28:00"";
if (inputDate.find("","") &lt; std::string::npos) handleFormat1();
else if (inputData.find(""/"") &lt; std::string::npos) handleFormat3();
else handleFormat2();
</code></pre>

<p>where the functions <code>handleFormat</code> would do the conversion from the input format to your desired output format.</p>

<p>Of course, if you have to deal with a larger number of input formats it will be more complicated to identify the correct format or the days, months, years, and times. But since you can do it manually it should also be possible to figure it out for all possible formats.</p>
",2
34952238,34952207,4,"<p>Here is the line where <code>n</code> is declared</p>

<pre><code>int n, count;
</code></pre>

<p>In this case the value of <code>n</code> is <a href=""https://stackoverflow.com/questions/1597405/what-happens-to-a-declared-uninitialized-variable-in-c-does-it-have-a-value"">unspecified as it is left uninitialized</a>. You should initialize it</p>

<pre><code>int n = 1;
</code></pre>
",1
34952251,34952207,2,"<p>If you always want a loop to run at least once then you want a <code>do...while();</code> loop.  It will always enter the loop on the first iteration and execute the loop body then it will check the while condition to determine if it loops again or exits.  A <code>do...while();</code> has the form of</p>

<pre><code>do
{
    statements
} while (condition);
</code></pre>

<p>In this case it would save you from having to initialize <code>n</code> before you get the input from the user.</p>

<p>In this case though that doesn't seem like exactly what you want as you want nothing to happen if the user enters a number less than 1.  One way you can solve that is to put your output and input into the while loop along with the check for <code>n</code>.  This will stop anything from happening if the user enters less than 1 but still allowing you to prompt the usr and get the input on each iteration.</p>

<pre><code>while (cout &lt;&lt; ""Enter a positive integer N (&lt;1 to stop): "" &amp;&amp; cin &gt;&gt; n &amp;&amp; n &gt;= 1)
{
    sum = 0;
    for (count = 1; count &lt;= n; count++)
        sum = sum + (1.0 / count);
    cout &lt;&lt; ""Sum = "" &lt;&lt; sum &lt;&lt; endl;
}
</code></pre>
",0
34952255,34952207,0,"<p>Set n to a value greater than or equal to 1 so the loop is guaranteed to enter. Since you aren't setting it yourself, the default value can be something less than 1 meaning that the look has a chance, but isn't guaranteed to fire. </p>

<pre><code>int n = 1
</code></pre>

<p>Also, you should set count = 0 in your for loop, because if n and count is equal to each other, the for loop automatically breaks and doesn't execute at all, leaving sum at 0. </p>

<p>To make sure your dividing by 0, set count to count + 1.</p>

<pre><code>for (count = 0; count &lt;= n; count++)
    sum = sum + (1.0 / (count + 1) );
</code></pre>
",4
34952272,34952207,1,"<p>The problem is that <code>n</code> has not been initialized. Unlike in other languages like Java or C#, primitive variables do not have any pre-defined ""default"" value. The simply occupy whatever stack space was there previously; for all intents and purposes, the default value of uninitialized variables can be considered ""random"".</p>

<p>To fix this, simply initialize the variable before entering the loop.</p>

<pre><code>n = 1;
</code></pre>
",3
34952311,34952207,0,"<p>You need simply to use another kind of loop that is the do-while loop. For example</p>

<pre><code>do 
{
    cout &lt;&lt; ""Enter a positive integer N (&lt;1 to stop): "";
    cin &gt;&gt; n;
    sum = 0;
    for (count = 1; count &lt;= n; count++)
    sum = sum + (1.0/count);
    if ( n &gt; 0 ) cout &lt;&lt; ""Sum = "" &lt;&lt; sum &lt;&lt; endl;
} while ( n &gt; 0 );
cout &lt;&lt; ""Bye! "";
</code></pre>

<p>And instead of the declaration</p>

<pre><code>int n, count;
</code></pre>

<p>you should use declaration</p>

<pre><code>unsigned int n, count;
</code></pre>

<p>You could else check whether the input is valid. For example</p>

<pre><code>if ( !( cin &gt;&gt; n ) || n == 0 ) break;
</code></pre>

<p>Taking this into account you could use also the following kind of loop</p>

<pre><code>while ( true ) 
{
    cout &lt;&lt; ""Enter a positive integer N (&lt;1 to stop): "";

    unsigned int n;

    cin &gt;&gt; n;

    if ( !( cin &gt;&gt; n ) || n == 0 ) break;

    sum = 0;
    for (unsigned int count = 1; count &lt;= n; count++)
        sum = sum + (1.0/count);
    if ( n &gt; 0 ) cout &lt;&lt; ""Sum = "" &lt;&lt; sum &lt;&lt; endl;
}
cout &lt;&lt; ""Bye! "";
</code></pre>
",4
46114788,46113685,3,"<p>You can make a new <code>operator new</code> overload:</p>

<pre><code>void * operator new(std::size_t count, const char* file, int line)
{
    // Do stuff
    // ...
    return ::operator new(count);
}

void * operator delete(void* p, const char* file, int line)
{
    // Do stuff
    // ...
    return ::operator delete(p);
}

// ... and [] versions ..
</code></pre>

<p>Then you can use placement syntax:</p>

<pre><code>auto x = new (__FILE__, __LINE__) Foo;
</code></pre>

<p>And then you can add a macro:</p>

<pre><code>#define TRACE_NEW new (__FILE__, __LINE__)

auto x = TRACE_NEW Foo;
</code></pre>
",2
46114861,46113685,0,"<p>In general there is no way to do what you want (except of course by using macros like <a href=""https://stackoverflow.com/a/46114788/841108"">moldbnilo answered</a>, or some future <a href=""http://en.cppreference.com/w/cpp/experimental/source_location"" rel=""nofollow noreferrer"">std::source_location</a>)</p>

<p>However, if you are on a recent Linux system, and if all your code (and most of the libraries it is using, including <code>libstdc++</code>) is compiled with debug options, you might also consider Ian Taylor's <a href=""https://github.com/ianlancetaylor/libbacktrace"" rel=""nofollow noreferrer"">libbacktrace</a> (it is also used inside <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a>) and use it inside your <code>operator new</code> implementation.  That <code>libbacktrace</code> enables you to inspect call frames in your <a href=""https://en.wikipedia.org/wiki/Call_stack"" rel=""nofollow noreferrer"">call stack</a> using <a href=""https://en.wikipedia.org/wiki/DWARF"" rel=""nofollow noreferrer"">DWARF</a> debug info.</p>

<p>You could then even have the source location of most functions in your <a href=""https://en.wikipedia.org/wiki/Call_stack"" rel=""nofollow noreferrer"">call stack</a> (notably the source location in the caller of your <code>operator new</code>).</p>

<p>Remember that you can compile some C++ code (using <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a> or <a href=""http://clang.llvm.org/"" rel=""nofollow noreferrer"">Clang</a>) with both debug info (e.g. <code>-g</code>) and some optimization flags (e.g. <code>-O1</code> or perhaps <code>-O2</code>); of course the debug info (in <a href=""https://en.wikipedia.org/wiki/DWARF"" rel=""nofollow noreferrer"">DWARF</a>) would then be ""fuzzy"" but still mostly usable in practice.</p>

<p>BTW, perhaps you just need <a href=""http://valgrind.org/"" rel=""nofollow noreferrer"">valgrind</a> or some address sanitizing by compiling with <code>-fsanitize=address</code> <a href=""https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html"" rel=""nofollow noreferrer"">instrumentation option</a> (we don't know because your question is not motivated).</p>
",0
34945098,34944424,1,"<p>Your array declaration reads like this:</p>

<pre><code>int SuccessiveTestArrayInt[50][1];
</code></pre>

<p>And in lines 39, 68 and 86, you are accessing it like this:</p>

<pre><code>SuccessiveTestArrayInt[RowCount][1] = { i }; //Position line 39
cout &lt;&lt; ""["" &lt;&lt; SuccessiveTestArrayInt[i][0] &lt;&lt; ""]"" &lt;&lt;""["" &lt;&lt; SuccessiveTestArrayInt[i][1] &lt;&lt; ""]"" &lt;&lt; endl; // line 68
SuccessiveTestArrayInt[i][1] = SortArrayPosition[d]; // line 86
</code></pre>

<p>In all the above cases, you are accessing your array out-of-bounds. Since the second dimension is only 1 while declaration, you can access it via 0 only. Anything greater is out-of-bounds.</p>

<p>Maybe you meant to declare it as:</p>

<pre><code>int SuccessiveTestArrayInt[50][2]; // note the second dimension size
</code></pre>
",0
39320056,39320039,6,"<blockquote>
  <p>is it allowed to compare a pointer to a custom class to <code>nullptr</code>?</p>
</blockquote>

<p>Yes, a pointer of any type can be compared to <code>nullptr</code> for (in)equality.</p>
",1
42575768,42575587,0,"<p>1) You're using <code>&amp;&amp;</code> which is a <a href=""http://en.cppreference.com/w/cpp/language/operator_logical"" rel=""nofollow noreferrer"">logical AND</a> but you should use <code>&amp;</code> which is a <a href=""http://en.cppreference.com/w/cpp/language/operator_arithmetic"" rel=""nofollow noreferrer"">bitwise AND</a>.</p>

<pre><code>// It would be better to use hex values when you're working with bits
if ( value_in_mem &amp; 0x80 == 0x80 )
{
    // it's negative
}
else
{
    // it's positive
}
</code></pre>

<p>2) You can simply compare your value to <code>0</code> (if <code>value_in_mem</code> is declared as <code>char</code>)</p>

<pre><code>if ( value_in_mem &lt; 0 )
{
    // it's negative
}
else
{
    // it's positive
}
</code></pre>
",2
42579450,42575587,0,"<p>Make sure you are using correct types for your values (or cast them where it matters, if you prefer for example to have memory values as unsigned bytes most of the time (I certainly would), then cast it to signed 8 bit integer only for the particular calculation/comparison by <code>static_cast&lt;int8_t&gt;(value_in_mem)</code> ).</p>

<p>To demonstrate the importance of correct typing, and how C++ compiler will then do all the dirty work for you, so you don't have to bother with bits and can use also <code>if (x &lt; 0)</code>:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    {
        uint16_t pc = 65530;     int8_t b = 0xFF;     pc += b;
        std::cout &lt;&lt; pc &lt;&lt; ""\n""; // unsigned 16 + signed 8
        // 65529 (b works as -1, 65530 - 1 = 65529)
    }
    {
        int16_t pc = 65530;      int8_t b = 0xFF;     pc += b;
        std::cout &lt;&lt; pc &lt;&lt; ""\n""; // signed 16 + signed 8
        // -7 (b works as -1, 65530 as int16_t is -6, -6 + -1 = -7)
    }
    {
        int16_t pc = 65530;      uint8_t b = 0xFF;    pc += b;
        std::cout &lt;&lt; pc &lt;&lt; ""\n""; // signed 16 + unsigned 8
        // 249 (b works as +255, 65530 as int16_t is -6, -6 + 255 = 249)
    }
    {
        uint16_t pc = 65530;     uint8_t b = 0xFF;    pc += b;
        std::cout &lt;&lt; pc &lt;&lt; ""\n""; // unsigned 16 + unsigned 8
        // 249 (b = +255, 65530 + 255 = 65785 (0x100F9), truncated to 16 bits = 249)
    }
}
</code></pre>
",0
40982757,40982566,2,"<p>By default, function parameters are passed ""by value"" to c/c++ functions. This means that the function has its own local copy of the gamestate variable that is initialized to the value given by the caller.</p>

<p>You have 2 possibilities: to change the function to take a reference to the variable or to take a pointer to the variable instead.</p>

<p>A function taking a reference would look like this:</p>

<pre><code>void ChangeState (bool &amp;gameState){
   gameState=false;
}
</code></pre>

<p>Using a pointer would look like this:</p>

<pre><code>void ChangeState (bool *gameState){
   *gameState=false;
}
</code></pre>

<p>....
   <code>ChangeState (&amp;gameState);</code></p>

<p>Using a reference can be seen as more convenient as the syntax and the use of the local variable is not changed. On the other hand, using a pointer forces the caller to use the &amp; to take the address of the variable, so everybody looking at the function call is made aware that the value may be changed inside the function.</p>
",0
40982720,40982566,1,"<p>In c++ when you pass an argument to a function it generally is passed a copy of that value, that means it is just a copy of what that variable contains, and isn't that variable.  In order to create an output parameter a simple solution is to pass by reference or pointer.</p>

<p>I will show the reference version:</p>

<pre><code>void changeState(bool&amp; gameState){
  string answer;
  cout &lt;&lt; ""End game? Y/N"" &lt;&lt; endl;
  cin &gt;&gt; answer;

  if(answer == ""Y""){
    gameState = false;
  } else if (answer == ""N""){
    gameState = true;
  }
}
</code></pre>

<p>The code is the exact same the only difference is the &amp; after the bool inside the parameter list.</p>

<p>This tutorial will go into more detail:
<a href=""http://www.cplusplus.com/doc/tutorial/functions/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/doc/tutorial/functions/</a></p>

<p>Also just a fyi, a reference or pointer depending on the OS, could be 4 bytes, where your bool is typically 1 byte, just returning a bool value would take less memory then passing by reference.</p>
",0
40982999,40982566,1,"<p>Return the <code>gameState</code> varible passed by value, there is no need to pass by reference or pointer in your code, this could lead to hide behavior,</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
using namespace std;

bool changeState(bool gameState){
  string answer;
  cout &lt;&lt; ""End game? Y/N"" &lt;&lt; endl;
  cin &gt;&gt; answer;

  if(answer == ""Y""){
    gameState = false;
  } else if (answer == ""N""){
    gameState = true;
  }  
  return gameState; 
}

void gameLoop(){
  bool gameState = true;
  while(gameState == true){
    cout &lt;&lt; ""Game is being played"" &lt;&lt; endl;
    gameState = changeState(gameState);
  }    
}

int main(){    
  gameLoop();  
  return 0;
}
</code></pre>
",0
36305791,36305477,3,"<p>You need to change:</p>

<pre><code>cout &lt;&lt; bisi[row] &lt;&lt; bisi[col] &lt;&lt; "" "";
</code></pre>

<p>to:</p>

<pre><code> cout &lt;&lt; bisi[row][col] &lt;&lt; "" "";
</code></pre>

<p><code>bisi</code> is a 2d array, <code>bisi[row]</code> or <code>bisi[col]</code> will just print you an address</p>
",3
36306009,36305477,1,"<p>From an object oriented view point, this is bad style. Wrap the information in a class. e.g. </p>

<pre><code>struct Appointment
{
  std::string patient;
  std::string doctor;
  std::string room;
}
</code></pre>

<p>and store that information in some kind of collection:</p>

<pre><code>std::vector&lt;Appointment&gt; appointments;
appointments.emplace_back({""henk"", ""doctor bob"", ""room 213""});
appointments.emplace_back({""jan"", ""doctor bert"", ""room 200""});
</code></pre>

<p>printing could then be done by:</p>

<pre><code>for (const auto &amp;appointment: appointments)
{
  std::cout &lt;&lt; appointment.patient
            &lt;&lt; appointment.doctor
            &lt;&lt; appointment.room
            &lt;&lt; std::endl;
}
</code></pre>
",0
36314947,36305477,0,"<p>I just added the preprocessor directive #include &lt;""string""> without the quotes and it worked fine.
Thank You guys for helping out.</p>
",0
48045593,26576714,0,"<p>I'd like to clarify something. Although the answer provided by gmas80 could work, for me, it didn't. I had to modify it somewhat, and here's what I ended up with:</p>

<pre><code>position = line.find(deleteLine);

if (position != string::npos) {
    line.replace(line.find(deleteLine), deleteLine.length(), """");
}
</code></pre>

<p>Another thing that didn't satisfy me was that it left blank lines in the code. So I wrote another thing to delete the blank lines:</p>

<pre><code>if (!line.empty()) {
    temp &lt;&lt; line &lt;&lt; endl;
}
</code></pre>
",0
45710771,45710305,4,"<p><code>std::map</code> can only have one predicate for associating key with a value.</p>

<p>You can use different predicates with the standard algorithm <code>std::find_if</code> to achieve this, but it does a linear search, rather than an efficient map lookup.</p>

<p>If you need multiple predicates to look up an element efficiently, then you need a multi-index container. The standard library does not have such a thing, but you can implement one by using multiple maps internally, or you can use a generic solution from <a href=""http://www.boost.org/doc/libs/1_64_0/libs/multi_index/doc/index.html"" rel=""nofollow noreferrer"">Boost</a>.</p>
",0
45712520,45710305,0,"<p>If your research is still in same order, you might use something like:</p>

<pre><code>struct A {
    std::string Id;
    std::string Name;
    Std::string Year;
};

bool operator &lt; (const A&amp; lhs, const A&amp; rhs) {
    return std::tie(lhs.Id, lhs.Name, lhs.Year) &lt; std::tie(rhs.Id, rhs.Name, rhs.Year);
}


auto findById(const std::map&lt;A, int&gt;&amp;m, const std::string&amp; id)
{
    auto it = m.lower_bound(A{id, """", """"});

    if (it != m.end() &amp;&amp; it-&gt;first.Id == id) {
        return it;
    }
    return m.end();
}

auto findByIdName(const std::map&lt;A, int&gt;&amp;m, const std::string&amp; id, const std::string&amp; name)
{
    auto it = m.lower_bound(A{id, name, """"});

    if (it != m.end() &amp;&amp; it-&gt;first.Id == id &amp;&amp; it-&gt;first.Name == name) {
        return it;
    }
    return m.end();

}

auto findByIdNameYear(const std::map&lt;A, int&gt;&amp;m,
                      const std::string&amp; id,
                      const std::string&amp; name,
                      const std::string&amp; year)
{
    return m.find(A{id, name, year});
}
</code></pre>

<p>If you prefer to use <code>std::vector</code>, you may use <code>std::find_if</code> like that:</p>

<pre><code>std::vector&lt;A&gt; as = /*...*/;
auto it = std::find_if(as.begin(), as.end(),
                       [&amp;](const A&amp; a){ return a.Id = id &amp;&amp; a.Name = name;} );
if (it == as.end()) {
    // Not found
} else {
    // use *it as matching A.
}
</code></pre>
",2
36254506,36254484,-1,"<p>try (it) instead of (*it)
the iterator should be a pointer to the object allready so you need to omit the * as this would result in the actual data not the reference</p>
",1
36254521,36254484,3,"<p>You have a <code>vector</code> of <code>Command</code>s.  You cannot cast a <code>Command</code> to an <code>A_COMMAND*</code>.  It's important to note that a <code>vector&lt;Command&gt;</code> cannot possibly contain a <code>A_COMMAND</code>.  If you want to do runtime polymorphism in C++, you <em>have to</em> use pointers or references.  In this case your <code>Parser::commands</code> would need to be a <code>std::vector&lt;Command*&gt;</code> (or some type of smart pointer like <code>std::vector&lt;std::shared_ptr&lt;Command&gt;&gt;</code>).</p>

<p>Take for example this code:</p>

<pre><code>std::vector&lt;Command&gt; commands;
A_COMMAND a_command;
commands.push_back(a_command);
</code></pre>

<p><code>commands</code> does not contain an <code>A_COMMAND</code> object.  It contains a <code>Command</code> object that is a copy of <code>a_command</code>.  It more-or-less equivilant of this:</p>

<pre><code>std::vector&lt;Command&gt; commands;
A_COMMAND a_command;
Command temp(a_command);
commands.push_back(temp);
</code></pre>

<p>Remember, in C++ a variable is an object, not a reference to an object like in some other languages (Java or C# for instance).  Objects will never change type, but you can have a reference or pointer of one type that points to an object of a derived type:</p>

<pre><code>std::vector&lt;Command*&gt; commands;
A_COMMAND a_command;
commands.push_back(&amp;a_command);
</code></pre>

<p>In this case <code>commands[0]</code> is a <code>Command*</code>, but it points to an <code>A_COMMAND</code> object.</p>

<p>RE your edit:<br>
You are adding a pointer.  <code>&amp;some_variable</code> returns a pointer to <code>some_variable</code>, BUT you should absolutely never, ever do something like that.  As soon as <code>command</code> goes out of scope, it will be destroyed and any access to it will result in undefined behavior.  You will need to use dynamic memory allocation with <code>new</code>.  It would probably be best to use a smart pointer class like <code>std::shared_ptr&lt;Command&gt;</code> to hold your dynamically allocated objects so you don't have to worry about <code>delete</code>ing them later.</p>

<p>If you use raw pointers then something like this will work:</p>

<pre><code>A_COMMAND* command = new A_COMMAND;
commands.push_back(command);
</code></pre>

<p>If you go with that approach, you'll need to <code>delete</code> all of your commands when you're done with them (probably <code>Parser</code>'s destructor):</p>

<pre><code>for(Command* command : commands) {
    delete command;
}
</code></pre>

<p>It would be better to use <code>std::shared_ptr</code>s though.  Declare <code>commands</code> as <code>std::vector&lt;std::shared_ptr&lt;Command&gt;&gt; commands;</code>, then:</p>

<pre><code>std::shared_ptr&lt;A_COMMAND&gt; command = std::make_shared&lt;A_COMMAND&gt;();
commands.push_back(command);
</code></pre>

<p>Then your objects will all get automatically <code>delete</code>ed when the last <code>shared_ptr</code> to them goes out of scope.  If you use smart pointers you'll need to cast them slightly differently though.  Look into <a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast"" rel=""nofollow""><code>std::dynamic_pointer_cast</code></a>.</p>
",12
36254749,36254484,0,"<p>The real question is why use dynamic_cast at all.
This is a job for virtual methods.
If another class is derived, then your dynamic_cast will also need updating, with a virtual method you do not need to be concerned what the derived class is, only that it overrides the virtual method, which can be forced by using an interface class for the base (pure virtual methods, no state). This sounds like an application for the strategy pattern. <a href=""https://en.wikipedia.org/wiki/Strategy_pattern"" rel=""nofollow"">https://en.wikipedia.org/wiki/Strategy_pattern</a>.</p>
",0
41206834,41206504,0,"<p>Yes, you can do something to make the code usable for different struct types.</p>

<p>However, all struct types <strong>must</strong> have the fields used inside the function.</p>

<p>It could look something like this:</p>

<pre><code>template&lt;typename T&gt;
void readData(vector&lt;T&gt;&amp; v, istream&amp; infile)
{
    T temp;
    while(getline(infile, temp.whatever) &amp;&amp; getline(infile, temp.whatever2))
    {
        v.push_back(temp);
    }
}

int main() {
    // Add code for infileA and infileB

    vector&lt;myStructA&gt; va;
    readData(va, infileA);  // or readData&lt;myStructA&gt;(va, infileA); if you prefer

    vector&lt;myStructB&gt; vb;
    readData(vb, infileB);  // or readData&lt;myStructB&gt;(vb, infileB); if you prefer

    ....
    ....

    return 0;
}
</code></pre>

<p>So here both <code>myStructA</code> and <code>myStructB</code> must have the member <code>whatever</code> and <code>whatever2</code>. This could be implemented by using a common base class for <code>myStructA</code> and <code>myStructB</code>.</p>
",0
42522977,42522925,0,"<p>Member functions in C++ can access member variables without having to explicitly specify <code>this.</code> before them. You take advantage of this in your code. However, friend functions cannot. In friend functions, you need to specify <code>f1.num</code> or <code>f2.num</code> (or whatever instance of fraction you want to change), not just <code>num</code>.</p>
",0
42523241,42522925,0,"<p>You can design your <code>add</code> function this way:</p>

<pre><code>fraction add( const fraction &amp;f1,  const fraction &amp;f2)
{
  long num = (f1.getnum ( ) * f2.getDen ( )) + ( f1.getDen ( ) * f2.getnum ( ) );
  long den = (f1.getDen ( ) * f2.getDen ( ));
  return fraction(num, den);
}
</code></pre>

<p><code>add</code> no longer needs to be a <code>friend</code> function if used this way.</p>

<p>You will have to make a couple more edits to your getter functions:</p>

<pre><code>long fraction::getDen (void) const 
{
  return den ;
}
long fraction::getnum (void) const 
{
  return num ;
}
</code></pre>

<p>Note that you are using <code>add</code> this way:</p>

<pre><code>f1 = add(f2,f3);
</code></pre>

<p>Therefore, returning a void from <code>add</code> would not help you.</p>

<p>Having said this, there are other errors in your code that you should look into</p>
",2
42588222,42588189,1,"<p>Simplest way:</p>

<pre><code>char video[MAX_ROW][MAX_COLUMN] = {{0}};//initialize all elements to NULL
</code></pre>
",3
42588285,42588189,1,"<p>If you want to initialize all elements to 0 in your array you have to use initializer syntax:</p>

<pre><code>VideoSim::VideoSim()
    : video{}
{
    currentRow = 0;
    currentColumn = 0;
}
</code></pre>

<p>In the line <code>video[MAX_ROW][MAX_COLUMN] = { 0 };</code> you write a zero to <code>video[MAX_ROW][MAX_COLUMN]</code> which is an out of bounds error.</p>

<p>You can also put the zero initialization in the class definition as:</p>

<pre><code>    char video[MAX_ROW][MAX_COLUMN]{};
</code></pre>

<p>If you eventually add custom constructors you can then just overwrite this default initialization by providing a different initialization like the one in the constructor above.</p>
",3
42588351,42588189,0,"<pre><code>VideoSim::VideoSim(void)
{

    currentRow = 0;
    currentColumn = 0;
    memset(video,0, sizeof(video));

}
</code></pre>
",0
36266399,36266370,10,"<p>In the expression <code>1 / 6</code>, both numbers are integers. This means that this division will perform integer division, which results in <code>0</code>. To do a <code>double</code> division, one number has to be a double: <code>1.0 / 6</code> for example.</p>
",0
36266438,36266370,4,"<p>Integer literals <code>1</code> and <code>6</code> have type <code>int</code>. Thus in the expression</p>

<pre><code>1/6
</code></pre>

<p>there is used the integer arithmetic and the result is equal to 0.</p>

<p>Use at least one of the operands as a floating literal. For example</p>

<pre><code>a = 1.0/6;
</code></pre>

<p>or</p>

<pre><code>a = 1/6.0;
</code></pre>

<p>or</p>

<pre><code>a = 1.0/6.0;
</code></pre>
",2
36410390,36410146,0,"<p>I think templated functions could be helpful.  Check out <a href=""https://stackoverflow.com/a/16085135/3613250"">this</a> answer from 2 years ago.  I used this solution to implement a basic logging feature for my needs.</p>

<p>Hope this helps!</p>
",0
38303900,38303843,2,"<p>The only solution I see is to not have the <code>operator&lt;</code> function as a virtual member function, but as a set of overloaded non-member functions: One ""default"" function which takes two references to <code>A</code> as arguments, and then one overload each for the special cases.</p>
",0
38304809,38303843,2,"<pre><code>///
/// goal:       provide partial ordering of objects derived from A on the basis
///             only of class type.
/// constraint: ordering specified by us
///

#include &lt;vector&gt;
#include &lt;typeindex&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;


class A
{
public:
    virtual bool operator&lt; (const A &amp;rhs) const = 0;

    static const std::vector&lt;std::type_index&gt;&amp; ordering();
};

template&lt;class T&gt; struct impl_A : public A
{
    bool operator&lt; (const A &amp;rhs) const override
    {
        auto&amp; o = ordering();
        auto first = std::begin(o);
        auto last = std::end(o);

        auto il = std::find(first, last, typeid(T));
        auto ir = std::find(first, last, typeid(rhs));
        return il &lt; ir;
    }
};

class B: public impl_A&lt;B&gt; {};

class C: public impl_A&lt;C&gt; {};

const std::vector&lt;std::type_index&gt;&amp; A::ordering()
{
    // specify fording of types explicitly
    static const std::vector&lt;std::type_index&gt; _ordering { typeid(B), typeid(C) };
    return _ordering;
}



void test(const A&amp; l, const A&amp; r)
{
    if (l &lt; r) {
        std::cout &lt;&lt; typeid(l).name() &lt;&lt; "" is less than "" &lt;&lt; typeid(r).name() &lt;&lt; std::endl;
    }
    else {
        std::cout &lt;&lt; typeid(l).name() &lt;&lt; "" is not less than "" &lt;&lt; typeid(r).name() &lt;&lt; std::endl;
    }
}

int main()
{
    test(B(), C());
    test(B(), B());
    test(C(), B());
    test(C(), C());

}
</code></pre>

<p>example output (clang):</p>

<pre><code>1B is less than 1C
1B is not less than 1B
1C is not less than 1B
1C is not less than 1C
</code></pre>

<blockquote>
  <p>Fine! But (I was not precise enough in my question), when x and y share the same type (for example B), the result of x &lt; y is given by a specific function const operator&lt; (B &amp;rhs) const in class ?B. It is not necessarily false`.</p>
</blockquote>

<p>OK, so we are revising requirements. This is a normal dialogue between users (who rarely realise the level of detail required in specifications) and the developers (who do!)</p>

<p>So this time we will say that any two dissimilar derived classes will have a consistent partial ordering (i.e. they will never compare equal and one will always compare less than the other) but we'll let the standard library decide which one comes first.</p>

<p>However, when the two classes being compared are of the same type, we would like to actually compare their values to determine ordering (and equivalence).</p>

<p>It would go something like this:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;typeinfo&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;tuple&gt;
#include &lt;iomanip&gt;


class A
{
public:
    virtual bool operator&lt; (const A &amp;rhs) const = 0;

    std::ostream&amp; print(std::ostream&amp; os) const {
        handle_print(os);
        return os;
    }

private:
    virtual void handle_print(std::ostream&amp;) const = 0;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const A&amp; a) {
    return a.print(os);
}

template&lt;class T&gt; struct impl_A : public A
{
    bool operator&lt; (const A &amp;rhs) const override
    {
        auto&amp; rhs_info = typeid(rhs);
        auto&amp; lhs_info = typeid(T);
        if (rhs_info == lhs_info) {
            // same type, so do comparison
            return static_cast&lt;const T&amp;&gt;(*this).ordering_tuple() &lt; static_cast&lt;const T&amp;&gt;(rhs).ordering_tuple();
        }
        else {
            return lhs_info.before(rhs_info);
        }
    }
};

class B: public impl_A&lt;B&gt; {
public:
    B(int v) : _value(v) {}

    auto ordering_tuple() const {
        return std::tie(_value);
    }

private:

    void handle_print(std::ostream&amp; os) const override {
        os &lt;&lt; _value;
    }

    int _value;
};



class C: public impl_A&lt;C&gt; {
public:
    C(std::string v) : _value(std::move(v)) {}

    auto ordering_tuple() const {
        return std::tie(_value);
    }

private:

    void handle_print(std::ostream&amp; os) const override {
        os &lt;&lt; std::quoted(_value);
    }

    std::string _value;
};

// now we need to write some compare functions


void test(const A&amp; l, const A&amp; r)
{
    if (l &lt; r) {
        std::cout &lt;&lt; l &lt;&lt; "" is less than "" &lt;&lt; r &lt;&lt; std::endl;
    }
    else {
        std::cout &lt;&lt; l &lt;&lt; "" is not less than "" &lt;&lt; r &lt;&lt; std::endl;
    }
}

int main()
{
    test(B(1), C(""hello""));
    test(B(0), B(1));
    test(B(1), B(0));
    test(B(0), B(0));
    test(C(""hello""), B(1));
    test(C(""goodbye""), C(""hello""));
    test(C(""goodbye""), C(""goodbye""));
    test(C(""hello""), C(""goodbye""));

}
</code></pre>

<p>example results:</p>

<pre><code>1 is less than ""hello""
0 is less than 1
1 is not less than 0
0 is not less than 0
""hello"" is not less than 1
""goodbye"" is less than ""hello""
""goodbye"" is not less than ""goodbye""
""hello"" is not less than ""goodbye""
</code></pre>
",3
36235101,36234984,0,"<p>Do you mean to convert all uppercase characters to lowercase characters and lowercase letters to uppercase letters, in a string?</p>

<pre><code>void swapuplo(char *s)
{
    size_t i;

    for (i = 0; s[i]; ++i)
        if (isupper(s[i]))
            s[i] = tolower(s[i]);
        else if (islower(s[i]))
            s[i] = toupper(s[i]);
}
</code></pre>

<p>This is the calling routine</p>

<pre><code>int main()
{
    char buf[] = ""HeLLo WORLD"";
    swapuplo(buf);
    printf(""%s\n"", buf);

    getchar();
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>hEllO world
</code></pre>

<p>Be sure to include <code>&lt;ctype.h&gt;</code>, which contains the declarations for the character testing functions.</p>
",4
34952246,31708567,0,"<p>The c++ compiler will pass your complete set code to a binary tree which will rearrange your code according to the precedence of the operator = + - etc in left node or right node</p>
",0
42488282,42488111,0,"<p>Really cin and the extraction operators are no good for parsing user input. They're OK for inputting automatically formatted records, but not input that is likely to have free form errors in it.</p>

<p>If you use line-based input, then call the function strtol(), you can find digits. strtol() also handles minus signs and numbers which are too large to fit into an integer. It's essentially the safe integer parser. Also, on error, you can easily discard the whole line and ask the user to re-enter, which is usually the desired behaviour.</p>
",0
46079851,46079687,2,"<p>Most of this is a simple matter of optimization: as long as you don't produce any output from the loops, the compiler determines that the loops are basically dead code, and simply doesn't execute them at all. It has to do a little bit of pre-computation to determine the value that <code>vector[5].y</code> would have following the loops, but it can do that entirely at compile time, so at run-time, it's basically just printing out a fixed number.</p>

<p>When you produce visible output inside the loops, the compiler can't just eliminate executing them, so the code runs dramatically slower.</p>
",5
40972854,40972813,0,"<p>You have to convert <code>i</code> to <code>std::string</code> first:</p>

<pre><code>int co = 3;
for (int i = 1; i &lt;= co; i++){   
    ofstream file;
    file.open (std::to_string(i) + "".txt""); //Here
    file.close();
}
</code></pre>
",0
40972884,40972813,1,"<p>You need to convert <code>i</code> to a string in order to concatenate it using <code>operator+</code>, otherwise you will inadvertently execute <a href=""http://en.cppreference.com/w/c/language/operator_arithmetic#Pointer_arithmetic"" rel=""nofollow noreferrer"">pointer arithmetic</a>:</p>

<pre><code>// C++11
#include &lt;fstream&gt;
#include &lt;string&gt;     // to use std::string, std::to_string() and ""+"" operator acting on strings 

int co = 3;
for (int i = 1; i &lt;= co; i++)
{   
    ofstream file;
    file.open (std::to_string(i) + "".txt"");
    file.close();
}
</code></pre>

<p>If you do not have access to C++11 <em>(or if you want to avoid explicitly ""converting <code>i</code> and then concatenating"")</em>, you can use <code>std::ostringstream</code>:</p>

<pre><code>// C++03
#include &lt;fstream&gt;
#include &lt;sstream&gt;

std::ostringstream oss;
int co = 3;
for (int i = 1; i &lt;= co; i++)
{   
    ofstream file;

    oss &lt;&lt; i &lt;&lt; "".txt""; // `i` is automatically converted
    file.open (oss.str()); 
    oss.str(""""); // clear `oss`

    file.close();
}
</code></pre>

<hr>

<p><em>Note:</em> <strong>clang++</strong> catches this mistake with the <code>-Wstring-plus-int</code> warning flag <em>(<a href=""http://melpon.org/wandbox/permlink/E0V5EfaOFKY2YN57"" rel=""nofollow noreferrer""><strong>wandbox example</strong></a>)</em>.</p>
",4
40972906,40972813,1,"<p>In C++ you can't simply ""concatenate"" a string literal with an integer. A string literal will decompose into a pointer to constant char (<code>char const *</code>) and pointer arithmetic rules apply.</p>

<p>When adding or subtracting an integer value from a pointer, the result is a pointer to an object that's the number of elements further in memory - and of course this only holds if the boundaries of that memory are not crossed.</p>
",0
42648596,42647883,0,"<p>The STL comes with a header called iomanip, which can modify in the way you want and even more.</p>

<p>A short example would be:</p>

<pre><code>#include &lt;iomanip&gt;
#include &lt;iostream&gt;

int main() {
    std::cout &lt;&lt; std::setfill ('x');
    std::cout &lt;&lt; ""PC"" &lt;&lt; std::setw(3) &lt;&lt; 4 &lt;&lt; std::endl;
}
</code></pre>

<p>An additional example can be found here:
<a href=""http://www.cplusplus.com/reference/iomanip/setfill/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/iomanip/setfill/</a></p>

<p>An overview over all options here:
<a href=""http://www.cplusplus.com/reference/iomanip/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/iomanip/</a></p>
",2
42610633,42604405,0,"<p>I cannot find any place in your code where pointers are added to <code>list</code>. However, you cannot instantiate a class with pure virtual functions as the full type, such s <code>Converter::ConversionImpl</code>. Hence the elements in your <code>list</code> cannot point to objects of polymorphic type <code>Converter::ConversionImpl</code>. You must inherit from this class before you can use it.</p>

<p>Either add an implementation to the pure virtual functions or derive from the class and make the destructor virtual as well. In that case you will need to override the virtual functions in the base class.</p>
",1
43197288,43197062,2,"<p><code>struct tm</code> is a type. </p>

<p><code>struct tm &amp; timeinfo</code> means that timeinfo is referencing a variable of that type.</p>

<p><code>struct tm * timeinfo</code> means that timeinfo is a pointer to  a variable (that may or may not exist) of that type.</p>

<p><code>struct tm * &amp; timeinfo</code> means that timeinfo is a reference to a variable (which exists) that happens to be a pointer to a variables (that may or may not exist) of type <code>struct tm</code>.</p>

<p><code>struct tm &amp; *</code> means nothing. You can't have a pointer to a reference, because the reference itself is not a variable, and pointers point to variables.</p>

<p>Note: when I say that ""may or may not exist"" I mean that the variable may or may not be allocated in memory.</p>
",0
35258386,35258108,8,"<p>Well, since I've refined my question more, a question with the answer I was looking for showed up in a list pf possible answers. And low and behold, I found what I wanted.</p>

<p>Using the '\r' modifier, instead of endl; on my <code>cout &lt;&lt; (temp) &lt;&lt; ""%"" &lt;&lt; endl;</code> deletes the current line as soon as it writes to it, and overwrites it with the next number.</p>
",0
40995284,40995261,4,"<p>That is a mark for the GOTO statement.</p>

<p>It allows the program to jump to this mark from (almost) any point in the code. This is usually used in hardware-programming or embedded programming when you cannot return from deeply nested structures without using lots of <code>break</code> statements or similiar situations for example.</p>
",0
40995288,40995261,3,"<pre><code>exit:
</code></pre>

<p>It's label that is used together with <code>goto</code>. This <code>goto</code> <code>lable</code> is usually used to jump out of a block of code when some error condition happens.</p>
",3
40995399,40995261,3,"<p>The other answers are correct, but are not making it clear that the label can be any word that is not a reserved keyword. <code>exit</code> is just one such name.</p>

<p>And another thing, in your example where there is no corresponding <code>goto exit;</code> normal program execution simply bypasses the label, it has no bearing on the functionality. </p>
",1
48008620,48008309,6,"<p>If you want to be able to set user defined functions for a class object then you can give it a  <em>member variable</em> of type <a href=""http://en.cppreference.com/w/cpp/utility/functional/function"" rel=""nofollow noreferrer"">std::function</a>. Using slightly different syntax from your example it could look like this:</p>

<pre><code>class MyClass
{
public:

    std::function&lt;void()&gt; genericFunction = []{};
};

int main()
{
    MyClass instance;

    instance.genericFunction(); // does nothing

    // assign a lambda function to our
    // function member
    instance.genericFunction = []
    {
        std::cout
            &lt;&lt; ""This new code exists only for this instance, and has been created outside the class!"";
    };

    instance.genericFunction(); // executes our lambda function
}
</code></pre>

<p><strong>EDIT</strong></p>

<p>If you want to be able to pass parameters or receive a return value, then change the template signature to <code>std::function</code> like this:</p>

<pre><code>class MyClass
{
public:
    // take a string parameter and return an integer    
    std::function&lt;int(std::string const&amp;)&gt; genericFunction = [](std::string const&amp;){ return 0; };
};

int main()
{
    MyClass instance;

    int return_value;

    return_value = instance.genericFunction(""This will do nothing and return 0""); // does nothing

    std::cout &lt;&lt; ""The first function returned: "" &lt;&lt; return_value &lt;&lt; '\n';

    // assign a lambda function to our
    // function member
    instance.genericFunction = [](std::string const&amp; msg)
    {
        std::cout &lt;&lt; msg &lt;&lt; '\n';
        return 5;
    };

    return_value = instance.genericFunction(""This will pint a message and return 5""); // executes our lambda function

    std::cout &lt;&lt; ""The second function returned: "" &lt;&lt; return_value &lt;&lt; '\n';
}
</code></pre>
",4
34955349,34955303,2,"<p>Problem:</p>

<pre><code>else if(cont == ""Y"" || ""y"") 
</code></pre>

<p>should be</p>

<pre><code>else if(cont == ""Y"" ||  cont == ""y"") 
</code></pre>

<p>Explanation: OR operator returns true if one of its operands if true, clearly simply using literal ""y"" returns true - because it is address in memory and not 0.</p>
",3
34955379,34955303,3,"<p>This test is always true:</p>

<pre><code>else if(cont == ""Y"" || ""y"")
</code></pre>

<p>because <code>""y""</code> always evaluates to non-zero, therefore <code>(cont == ""Y"" || ""y"")
</code> always evaluates to non zero.</p>

<p>You wanted:</p>

<pre><code>else if(cont == ""Y"" || cont ==  ""y"")
</code></pre>
",0
34955433,34955303,0,"<p>If you convert or <em>transform</em> the input string to all lower case or all upper case, you would only need one compare:</p>

<pre><code>cont[0] = toupper(cont[0]);
if (cont[0] == 'Y')
</code></pre>

<p>Search the internet for ""c++ string transform lower case"" for examples.</p>
",0
34906044,34905981,3,"<p><code>using namespace std;</code> means you can write <code>cout</code> later on rather than <code>std::cout</code>. It saves typing at the expense of gross <em>namespace pollution</em>.</p>

<p>Your compile error can be fixed by writing <code>cout &lt;&lt; z;</code></p>

<p>Also, do return a value from <code>main</code>.</p>
",4
34906330,34905981,0,"<blockquote>
  <p>What does using namespace <code>std;</code> do?</p>
</blockquote>

<p><strong>It tells the compiler which class/namespace to look in for an identifier.</strong> You either use <code>using namespace std;</code> in the beginning of the file or have to place it in front of each function that belongs to it.  </p>

<blockquote>
  <p>What is the matter with this C++ code?</p>
</blockquote>

<p>The syntax to use <code>std::cout</code> is:</p>

<pre><code>std::cout &lt;&lt; source; 
</code></pre>

<p>variable <code>source</code> is inserted with the help of <code>operator &lt;&lt;</code> in the <code>std::cout</code> stream which prints it to the standard output, i.e. computer monitor.</p>

<hr>

<p><sup><code>std</code> <em>""labels""</em> a function member of the Standard Library. This is a technique used (among other reasons) to resolve (using the resolution operator <code>::</code>) members that belong to the Standard Library from (possible) name conflicts with functions with similar(same) names and to reduce a scope of a search. <code>std</code> is called a namespace, so <code>using namespace std;</code> is a bit self explanatory.</sup></p>
",0
34906498,34905981,2,"<p>To begin to explain what this does, it is important for you to understand what namespaces do. Namespaces are logical units of code divided up, you are able to create your own namespace or use other namespaces. The benefit of using namespaces is to have your program logically divide up your code with like functions. This is very similar to classes, but you do not need initiation of the namespaces like classes do. IN Java this would be similar to packages. To use a function within a namespace you need to use the namespace identifier followed by the function you are calling. This will call the correct function in the namespace scope you are wanting to use. An example of creating a namespace is the following: </p>

<pre><code>namespace connection 
{
 int create_connection();
 int close_connection();
 //ect.......
}   
</code></pre>

<p>Then later in the code when you want to call create_connection you need to do it the following way:</p>

<pre><code>connection::create_connection();
</code></pre>

<p>As for your answer you are able to prevent from having to type the namespace identifier in this case connection, or in your case std. You are able to introduce an entire namespace into a section of code by using a using-directive. This will allow you to call the functions that are in that namespace without needing to use the namespace followed with the scope indicator"" :: "". </p>

<p>The following syntax to do this is as follows:</p>

<pre><code>using namespace connection:
</code></pre>

<p>or in your case</p>

<pre><code>using namespace std;
</code></pre>

<p>So by doing this with std you will be granting that access to std namespace which includes C++ I/O objects cout and cin to use freely without having to use the namespace and scope operator first. Though a better practice is to limit the scope to the namespace members you want to actually use. On large programs this will be cleaner why of coding as well as avoid several problems. To introduce only specific members of a namespace, such as only introducing the std::cin and std::cout, you do the following:</p>

<pre><code>using std::cin;
using std::cout;
</code></pre>
",1
43214143,43213758,1,"<p>In case you do not know template and looking for an other answer to this question, use STL algorithms.</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;algorithm&gt;

bool findInArray(int number, int array[], int size_array){
  int* p   = std::find(array, array+size_array, number);
  if (p != array+size_array) {
    return 1;
  } else {
   return 0;
}
</code></pre>

<p>And from main, you can call :</p>

<pre><code>findInArray(5, a, sizeof(a)/sizeof(a[0]));
</code></pre>
",0
43213778,43213758,8,"<p>You need a template:</p>

<pre><code>template &lt;std::size_t N&gt;
bool findInArray(int number, const int (&amp;array)[N]) {
  // Finds if the number is in the array
  return std::find(std::begin(array), std::end(array), number) != std::end(array);
}
</code></pre>

<p>You also need to pass the array by lvalue, since you cannot pass arrays by prvalue in C++, and instead the array would decay to a pointer to its first element, thereby losing the size information.</p>
",1
35227839,35227530,1,"<p>It appears - from the error message - that the compiler knows your function as </p>

<pre><code>void addBlobToExistingBlobs(Blob&amp;, Blob&amp;, int&amp;);
</code></pre>

<p>whereas, in your implementation of </p>

<pre><code>void matchBlobs(std::vector&lt;Blob&gt;&amp;, std::vector&lt;Blob&gt;&amp;);
</code></pre>

<p>a function with the name of <code>addBlobToExistingBlobs</code> is used, but with a different prototype, namely</p>

<pre><code>void addBlobToExistingBlobs(Blob&amp; ,std::vector&lt;Blob&gt;&amp;, int&amp;);
</code></pre>

<p>Have you checked that, somewhere in your code, you haven't a prototype for another <code>addBlobToExistingBlobs</code> function that gets the compiler confused ?</p>
",2
36294500,36294167,0,"<p>Why are you using a for loop? is better to use a while loop like so:</p>

<pre><code>void getNames(vector&lt;string&gt; &amp;n, int &amp;b)
{
 string temp;
 cout &lt;&lt; ""Enter Names. Press \'quit\' to stop."" &lt;&lt; endl;
 getline(cin, temp);
 while(temp != ""quit"")
 {
  int space = temp.find(' ', 0);
  string inPut = temp.substr((space+1), temp.length());
  inPut += "", "";
  inPut += temp.substr(0, space);
  n.push_back(inPut);
  getline(cin, temp);
 }
 ...//the rest of your code...
}
</code></pre>

<p>I didn't answer the question, sorry... the first input is the termination character of your last cin... <a href=""http://www.cplusplus.com/reference/string/string/getline/"" rel=""nofollow"">std::getline (string)</a></p>
",2
36294953,36294167,0,"<p>By fixing your curly braces your getNames() function works for me as expected. Maybe this is an oversight from posting your code, but you are missing a curly brace to end your for loop and function call for GetNames(). Compiling and using this code produces the expected output:</p>

<pre><code>void getNames(vector&lt;string&gt; &amp;n, int &amp;b){

    string temp;

    cout &lt;&lt; ""Enter Names. Press \'quit\' to stop."" &lt;&lt; endl;

    for(b; temp != ""quit""; b++){

        getline(cin, temp);
        if(temp == ""quit""){
            break;
        }else{

            int space = temp.find(' ', 0);

            string inPut = temp.substr((space+1), temp.length());
            inPut += "", "";
            inPut += temp.substr(0, space);

            cout &lt;&lt; inPut &lt;&lt; endl; //Testing string transformation before insertion.

            n.push_back(inPut);
        }
    }
}
</code></pre>

<p>Passing the names: ""Bob Dylan"", ""Jerry McQuire"", and ""Some Guy"" resulted in the output</p>

<pre><code>Dylan, Bob
McQuire, Jerry
Guy, Some
</code></pre>

<p>It is possible that there is an error somewhere else in the code if your first element in the Vector is always blank. The error is possibly in the saveNames() or readNames() functions. But the strings are input and transformed correctly here. It's beneficial to post all the code relevant to your question ahead of time. </p>

<p><strong>Please include this at the top of getNames():</strong></p>

<pre><code>cin.clear();
cin.ignore(10000, '\n');
</code></pre>

<p>This will clear the cin buffer to a new line so the initial choice from main() doesn't get put in to the vector unexpectedly.</p>
",4
37349203,37348913,5,"<p>You are missing the <code>const</code> qualifier on the call operator of <code>comp</code>:</p>

<pre><code>bool operator()(const CartesianLocation&amp; loc1, 
                const CartesianLocation&amp; loc2) const { }
                                               ^^^^^
</code></pre>
",0
41205288,41205192,10,"<p>In your executable you have two main functions (print out <code>Carm_SOURCES</code> by <code>MESSAGE(${Carm_SOURCES}))</code>. One is in <code>test.cpp</code> and one in <code>CMakeCXXCompilerId.cpp</code> (which is a file that CMake generates to test if your CXX compiler works correctly). The <code>GLOB_RECURSE</code> finds and adds both of these files to <code>Carm_SOURCES</code></p>

<p>It is not recommended to use <code>GLOB</code> to collect a list of source files. From the file(GLOB documentation:</p>

<blockquote>
  <p>We do not recommend using GLOB to collect a list of source files from your 
  source tree. If no CMakeLists.txt file changes when a source is added or removed 
  then the generated build system cannot know when to ask CMake to regenerate.</p>
</blockquote>

<p>The recommended way to list project files is to add them by hand to <code>CMakeLists.txt</code>.</p>
",1
37289140,37289103,2,"<p>You obviously meant to write</p>

<pre><code>dummyString=buffer;
</code></pre>

<p>instead of the last line in your shown code.</p>
",3
37289281,37289103,0,"<p>Perhaps the issue is that the syntax:</p>

<p>dummyString(Char*) is a constructor -- but it looks like you've already declared dummyString somewhere?</p>

<p>Try declarying dummyString as...
string dummyString(buffer);</p>

<p>or if it must already be declared, try...</p>

<p>dummyString = buffer;</p>
",0
37289390,37289103,0,"<p>Did you intend to do</p>

<pre><code>dummyString = std::string(buffer);
</code></pre>

<p>or</p>

<pre><code>dummyString = buffer;
</code></pre>

<p>because the syntax that you used is only allowed at time of declaration</p>

<pre><code>std::string dummyString(buffer);
</code></pre>
",0
37289528,37289103,2,"<p>After looking at your question again there's something else I should mention as it's likely relevant here. Constructors are special unnamed member functions and cannot be invoked directly like other functions. They are only invoked when an object is first constructed and cannot be invoked again. If that was your intention now you have a better idea of why it won't work.
<hr>
The error you get is because your code is trying to invoke <code>dummyString</code> as if it were a function. Although C++ <em>does</em> support the ability to do this the definition of <code>string</code> does not (there's no reason to - it's not a function type object). Based on your post it looks like you are attempting to construct <code>dummyString</code> well after it has been defined. It's definitely considered good practice to define a variable as close as possible to it's first use but this isn't how to do it.</p>

<p>When you define a variable it is initialized in some way. In this case the following statement causes the default constructor of <code>std::string</code> to be invoked on <code>dummyString</code>. </p>

<pre><code>std::string dummyString;
</code></pre>

<p>What you are trying to do is construct <code>dummyString</code> using the contents of a character buffer. To do this you need to pass the string as an argument at the time of instantiation which in this case is when the variable is defined.</p>

<pre><code>std::string dummyString(buffer);
</code></pre>

<p>This will construct the string using the contents of buffer.</p>
",0
42526521,42526429,1,"<p>You need to do it yourself by manually parsing a string. The overloads of <code>operator&gt;&gt;</code> for particular types (like <code>int</code>) are there for your convenience and for the cases when you are absolutely sure that the input will be of that type. Of course you can check it for failure, but once again, for failure to read a single particular type which you expect.</p>

<p>In general, however, <code>cin</code> works with characters (""character input"") so on the basic level you operate with character sequences (aka strings).</p>

<p>TL;DR: <code>cin</code> into a <code>string</code>, and then parse the string's contents yourself to determine the actual type of entered data.</p>
",0
40770256,40770144,1,"<p>line</p>

<pre><code>bvec.push_back(new Derived(66));
</code></pre>

<p>does not compiler because Derived class constructor is private and is defined to take two int arguments.</p>

<p>Fix that and it will compile and run:</p>

<p><a href=""http://cpp.sh/9nrkc"" rel=""nofollow noreferrer"">http://cpp.sh/9nrkc</a></p>
",2
37917533,37917028,-1,"<p>To instantiate std::pair, you can use that:</p>

<pre><code>std::pair&lt;int, double&gt; p2(42, 0.123);
std::cout &lt;&lt; ""Initialized with two values: ""
          &lt;&lt; p2.first &lt;&lt; "", "" &lt;&lt; p2.second &lt;&lt; '\n';
</code></pre>

<p>And for vectors :</p>

<pre><code>std::vector&lt;int&gt; second (4,100);
</code></pre>

<p>(This line creates a Vector of 4 int, with value 100. I let you guess what you can do ?)</p>

<pre><code>  std::vector&lt;int&gt; third (second.begin(),second.end());
</code></pre>

<p>This one iterates on another vector. Be creative and don't hesitate to look on docs !
(And also, check the doc for the <code>operator new</code>. If you want to create it dynamically you'll need it :) )</p>
",0
37918835,37917028,0,"<p>you can use this:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
#include &lt;vector&gt;

void doSomething(){
    int x = 1, y= 3;
    // vector of the graph's points
    vector&lt;pair&lt;int, int&gt;&gt; graph;
    // add point to the vector
    graph.push_back(make_pair(x, y));
    // accessing a point // here accessing first point at index 0
    // you can loop through the vector when having many points
    cout&lt;&lt;""x = ""&lt;&lt; graph.at(0).first &lt;&lt;endl;
    cout&lt;&lt;""y = ""&lt;&lt; graph.at(0).second &lt;&lt;endl;
}
</code></pre>
",0
43763642,43763432,1,"<p>No. The language feature that you describe is called <em>reflection</em>. C++ has no support for reflection.</p>

<p>It is of course possible to maintain the information about classes and members and such in an external structure. Using a preprocessor, it is possible to build a system that allows defining a class and its reflection metadata without repetition.</p>

<hr>

<p>There are proposals to add (static) reflection to the language: <a href=""http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4428.pdf"" rel=""nofollow noreferrer"">N4428</a>, <a href=""http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4447.pdf"" rel=""nofollow noreferrer"">4447</a>, <a href=""http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4451.pdf"" rel=""nofollow noreferrer"">N4451</a>, <a href=""https://groups.google.com/a/isocpp.org/forum/#!forum/reflection"" rel=""nofollow noreferrer"">SG 7</a> Hopefully reflection will become part of C++ in the future.</p>
",0
43763642,43763432,1,"<p>No. The language feature that you describe is called <em>reflection</em>. C++ has no support for reflection.</p>

<p>It is of course possible to maintain the information about classes and members and such in an external structure. Using a preprocessor, it is possible to build a system that allows defining a class and its reflection metadata without repetition.</p>

<hr>

<p>There are proposals to add (static) reflection to the language: <a href=""http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4428.pdf"" rel=""nofollow noreferrer"">N4428</a>, <a href=""http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4447.pdf"" rel=""nofollow noreferrer"">4447</a>, <a href=""http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4451.pdf"" rel=""nofollow noreferrer"">N4451</a>, <a href=""https://groups.google.com/a/isocpp.org/forum/#!forum/reflection"" rel=""nofollow noreferrer"">SG 7</a> Hopefully reflection will become part of C++ in the future.</p>
",0
44730457,44730054,2,"<ul>
<li><p><code>new (&amp;p) std::string(""New word"");</code> is using <strong>placement new</strong>.  <code>&amp;p</code> must point at a pre-existing block of memory that is at least <code>sizeof(std::string)</code> bytes in size.  The <code>std::string</code> object will be constructed inside that memory, instead of in a newly allocated block of memory.  The object must be destroyed by calling its destructor directly when you are done using it, eg:</p>

<pre><code>char buffer[sizeof(std::string)];
std::string *p = new (buffer) std::string(""New word"");
...
p-&gt;~std::string();
</code></pre></li>
<li><p><code>p = std::string(""New word"");</code> could be doing different things, depending on the context in which it is used:</p>

<ul>
<li><p>if used in a variable declaration statement, <code>p</code> is allocated on stack (automatic) or heap (dynamic) memory (depending on context) and is copy-constructed using the <code>std::string</code> value:</p>

<pre><code>some_type p = std::string(""New word"");
//
// same as:
// some_type p(std::string(""New word""));
//
// if some_type=std::string, same as:
// std::string p(""New word"");
...
</code></pre></li>
<li><p>if used in an assignment statement on a pre-existing object, it is allocating a block of temporary stack (automatic) memory, constructing a new temporary <code>std::string</code> object in that memory, assigning that temp object to <code>p</code>, and then destroying the temp object and freeing the temp memory.</p></li>
</ul></li>
<li><p><code>p = new std::string(""New word"");</code> is allocating a new block of heap (dynamic) memory, constructing the <code>std::string</code> object in that memory, and then assigning the memory address to the <code>p</code> pointer.  The object must be destroyed manually using <code>delete</code>:</p>

<pre><code>std::string *p = new std::string(""New word"");
...
delete p;
</code></pre></li>
</ul>

<p>In all three cases, the <code>std::string</code> object contains an internal pointer to its character data, which may point to memory on the stack (automatic) or heap (dynamic), depending on where the <code>std::string</code> is allocated, what optimizations it employs, etc.</p>
",7
35257165,35257125,1,"<p><code>&amp;fishpointer</code> Is the address of the pointer.</p>

<p>Look pointer to pointers:</p>

<pre><code>http://www.tutorialspoint.com/cprogramming/c_pointer_to_pointer.htm
</code></pre>
",0
35257166,35257125,1,"<p>The second value is the address of the variable <code>fishpointer</code>.</p>

<p>The compiler has decided to put the two variables next to each other in memory, which is why their addresses are so similar. The language doesn't guarantee this will happen - and you may even see different behaviour if you turn on optimisation.</p>
",0
35257184,35257125,1,"<p>A pointer is a value (the address in memory at which an object resides). But <code>fishpointer</code> is a variable (whose type happens to be one that contains a pointer value).</p>

<p>So you can take the address of <code>fishpointer</code> with <code>&amp;</code>, and it gives you the address of the variable that contains the address of <code>fish</code>.</p>

<p>Since <code>fish</code> and <code>fishpointer</code> are two local variables, the compiler puts them both on the stack, and in this case they end up next to each other (the exact layout of variables in memory is implementation-dependent). On your platform, it seems that pointers are 4-bytes each -- hence the four byte difference in the addresses of the variables.</p>
",1
34964269,34964200,1,"<p>Short answer - No.  </p>

<p>The terms 32-bit and 64-bit refer to the way a computer's processor, handles information. The 64-bit version of Windows handles large amounts of random access memory (RAM) more effectively than a 32-bit system.<br>
If you have a long long int, it simply means that it takes up 64 bits in the memory.  </p>

<p>Refer to <a href=""https://stackoverflow.com/questions/4552905/what-is-the-difference-between-a-32-bit-and-64-bit-processor"">What is the difference between a 32-bit and 64-bit processor?</a> , for a complete understanding of the differences between 32 bit and 64 bit processors.</p>

<p>Also take a look at - <a href=""https://en.wikipedia.org/wiki/64-bit_computing"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/64-bit_computing</a></p>
",0
34964289,34964200,0,"<p>The integer size in memmory is independent of the amount of bits a CPU uses.
hoewever the length of an int can vary because that processor always tries to run at it's most efficient way so for an 32 bit processor an int will have a default size of 32-bits.
using types like long long int or uint64 (unsigned integer of 64 bit) will guarantee the length of 64 bits across all processors. so it's good to keep that in mind.</p>
",0
34964334,34964200,1,"<p>In short, no.</p>

<p>Using <code>long long</code> types does not limit your choice of operating system.    If your compiler supports <code>long long</code> and targets a 32-bit operating system (or even a 16-bit operating system), then the compiler or library sorts out the details of how to support longer types.</p>

<p>Using <code>long long</code> types does limit you to compilers (and libraries) that support such a type, no matter what operating system you use.   In C++, the 2011 standard introduced them, but some older compilers support <code>long long</code> types as an extension (e.g. because C did since 1999).    So, compilers predating the 2011 standard may not support <code>long long</code> types.</p>
",0
34964557,34964200,0,"<p>No, instead it completely depend on the data models used by the OS and the compiler being used. In C++ since C99 the size of long long int is 64 bits. Infact, most of the Linux/Unix implementations define long as a 64 bit type but it is only 32 bit in Windows because they use different data models. Have a look at given <a href=""https://en.wikipedia.org/wiki/64-bit_computing#64-bit_data_models"" rel=""nofollow"">64 bit computing</a> related to models. </p>
",0
34964436,34964200,0,"<p>You are worried if your program will run the same when you run it on a 32-bit machine. You shouldn't. </p>

<p>If it's compiled as a 32-bit application it will always run the same, it just won't use the features of 64-bit processors. So you might have guessed <code>long long</code> was fine with 32-bit compilers because otherwise you wouldn't be able to build your program. </p>

<p>If it's compiled as a 64-bit application, it will not run on 32-bit machines at all.</p>
",4
34964604,34964200,0,"<p>Edit: <code>long long int</code> always exists in a C++11 implementation, and it has at least 64 bits because the <em>C standard</em> in 5.2.4.2.1 (not the C++ standard) demands it (by defining a minimum value of LLONG_MAX). That means you should be fine. On 32 bit systems the library may be slow or not available though.</p>
",0
34964461,34964200,-1,"<p><code>long long int</code> is not guaranteed to be a 64 bit integer. At least not by the C++ standard:</p>

<blockquote>
  <p>3.9.1 Fundamental types [basic.fundamental]</p>

<pre><code> ...
</code></pre>
  
  <p>2 There are five standard signed integer types : ¡°signed char¡±, ¡°short int¡±, ¡°int¡±, ¡°long int¡±, and ¡°long long int¡±. In this list,
  each type provides at least as much storage as those preceding it in
  the list. There may also be implementation-defined extended signed
  integer types. The standard and extended signed integer types are
  collectively called signed integer types. Plain ints have the natural
  size suggested by the architecture of the execution environment;
  the other signed integer types are provided to meet special needs.</p>
</blockquote>

<p>In other words, the only guarantee you have is that a <code>long long int</code> will be at least as big as a <code>long int</code>. That's it.</p>

<p>Now, on most modern execution environments, a <code>long long int</code> is a 64 bit value, and this is true even on native 32-bit hardware platforms.</p>

<p>But, as far as the C++ standard goes, you have no guarantees whatsoever. So, you might find that on a particular 32-bit platform, a <code>long int</code> and a <code>long long int</code> are both 32 bit integer values. And this will be perfectly compliant with the C++ standard.</p>
",5
46125846,46125800,2,"<p>One method is to use <code>std::istream</code>:  </p>

<pre><code>BigInteger(std::istream&amp; input);
</code></pre>

<p>This constructor allows you to create a <code>BigInteger</code> from a file as well.  </p>

<p>To use:  </p>

<pre><code>BigInteger bi(std::cin);
</code></pre>

<p>You may want to resolve your issue with <code>std::string</code> first.  </p>
",2
35258743,35258696,5,"<p>You should notice that <code>std::endl</code> includes flushing the output stream. As from the <a href=""http://en.cppreference.com/w/cpp/io/manip/endl"" rel=""noreferrer"">reference documentation</a>:</p>

<blockquote>
  <p>Inserts a newline character into the output sequence <code>os</code> and flushes it as if by calling <code>os.put(os.widen('\n'))</code> followed by <code>os.flush()</code>.</p>
</blockquote>

<p>So if you flush <code>cout</code> after printing in your example</p>

<pre><code>cout &lt;&lt; multiply(""0"", ""0"");
cout.put(cout.widen('\n'));
cout.flush();
</code></pre>

<p>you would see the result printed <kbd><a href=""http://ideone.com/PTwXEA"" rel=""noreferrer"">Live Demo</a></kbd>.</p>

<p>For more information about flushing and what it actually means for buffered output read here please <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream/flush"" rel=""noreferrer""><code>std::ostream::flush()</code></a>.</p>
",2
42475003,42474855,0,"<p>Additional to @tuple_cat answer you could place all your string constants in one place:</p>

<p><code>common_const.h</code>:</p>

<pre><code>extern const char LOOT_CONTAINERS[];
extern const char SOMETHING_ELSE[];
</code></pre>

<p><code>common_const.cc</code>:</p>

<pre><code>const char LOOT_CONTAINERS[] = ""Loot Containers"";
const char SOMETHING_ELSE[] = ""Something Else"";
</code></pre>

<p>And then use this constants instead across code. Similar approach used in Chromium sources. But this will not work if you will try to somehow get the key from user input or any other source. Alternatively you could use <code>std::unordered_map&lt;std::string, GUISetting&gt;</code>.</p>
",0
42474878,42474855,3,"<p><code>std::unordered_map</code> compares the keys using <code>==</code>, so it's checking whether your char pointers point to the same memory location, <em>not</em> that they point to equal strings.</p>

<p>If you want <code>std::unordered_map</code> to compare the strings that the char pointers point to, you need to pass the map a custom comparator as a template parameter. Or do it the easy way and use <code>std::string</code> as the key type.</p>
",2
48008708,48008477,2,"<blockquote>
  <p>What seems to be the problem here?</p>
</blockquote>

<p>Not really sure why you have expected this code to work.</p>

<p>To start with, you need to check <a href=""http://en.cppreference.com/w/cpp/algorithm/find"" rel=""nofollow noreferrer""><code>std::find_if</code></a> overloads. There are no overloads which accept both value to find and custom predicate, only predicate is accepted.</p>

<p>Then, if you use <code>my_functor</code>, the code should look like this:</p>

<pre><code>std::find_if(std::cbegin(container), std::cend(container),
    MyClass&lt;T, Comp&gt;::my_functor(v));
</code></pre>

<p>Where <code>T</code> and <code>Comp</code>are some types.</p>
",2
48032945,48032893,3,"<p>You cannot wrap a polymorphic object that you pass by value because of <a href=""https://stackoverflow.com/q/274626/335858""><em>object slicing</em></a>. Your <code>Wrapper</code> needs to have a pointer or a reference to the object that it wraps.</p>

<p>Here is an implementation that uses a reference:</p>

<pre><code>class Wrap
{
private:
    Situation&amp; _sit;
public:
    Wrap(Situation&amp; sit) : _sit(sit)
    {
    }
    void call()
    {
        _sit.handler();
    }
};
</code></pre>

<p>Note that this implementation is nearly identical to your original one, with <code>&amp;</code> added in two places, and initializer list used to set <code>_sit</code> reference. However, it is fragile, because you must ensure that the lifetime of the object referenced by <code>_sit</code> stretches beyond the last point where its <code>Wrapper</code> is used.</p>

<p>A more robust implementation of the wrapper would use smart pointers to dynamically allocated objects.</p>
",0
48032959,48032893,1,"<p>Since your wrapper takes (and stores) its Situation object by copy the derived type information is lost, all that will remain is the base class, this is called slicing.</p>

<p>If you want to keep the derived parts pass a pointer or reference to the wrapper constructor and change the member type to some pointer type (possible unique_ptr if the wrapper is to take wonership of the derived type instance).</p>
",0
48032974,48032893,0,"<p>You pass <code>first</code> via the <code>sit</code> parameter by value. It means that <code>sit</code> is a copy of <code>first</code> of the type <code>Situation</code> as you declared, not the originated <code>one</code> of the type <code>One</code>. By the way you copied only small part of the class <code>One</code>.</p>

<p>To call a virtual method you should pass your object <code>one</code> by reference or pointer.</p>
",0
48032982,48032893,0,"<p>Your problem is passing an object of the base class by value rather than a reference or pointer ¨C you basically cast your <code>One</code> back to a <code>Situation</code> (also stripping extra data) and therefore get your result.</p>

<p>In fact, since you're using polymorphism (virtual members and inheritance), you don't even need your wrapper to begin with:</p>

<pre><code>class Situation {
public:
    virtual void handle() {
        std::cout &lt;&lt; ""Base Situation"" &lt;&lt; std::endl;
    }
}

class One : public Situation {
public:
    virtual void handle() {
        std::cout &lt;&lt; ""One Situation"" &lt;&lt; std::endl;
    }
}

int main(int argc, char **argv) {
    // These pointers point to any base class object or derived object
    Situation *first = new Situation();
    Situation *second = new One();

    // Calling a virtual member will automatically call the most derived class's member
    first-&gt;handle(); // prints ""Base Situation""
    second-&gt;handle(); // prints ""One Situation""

    delete first;
    delete second;
}
</code></pre>
",2
46095643,46095397,4,"<p>It is implicitly guaranteed, since it is true for all the allowed forms of signedness:</p>

<p>(examples with 16 bit <code>int</code>)</p>

<ul>
<li>One's complement, <code>INT_MIN = -32767, INT_MAX = 32767</code></li>
<li>Two's complement, <code>INT_MIN = -32768, INT_MAX = 32767</code></li>
<li>Sign &amp; magnitude, <code>INT_MIN = -32767, INT_MAX = 32767</code></li>
</ul>

<p>No other forms are allowed. As we can see, <code>abs(INT_MIN) &gt;= abs(INT_MAX)</code> for all the allowed forms.</p>

<p>As a side note, <code>INT_MAX</code> is not allowed to be smaller than <code>32767</code> and <code>INT_MIN</code> is not allowed to be smaller than <code>-32767</code>. This is guaranteed by the requirements for limits.h.</p>
",10
34911073,34911053,2,"<p>Thete's no need to escape with <code>\</code>. You could use raw string literals. Like this. </p>

<pre><code>system(R""(start ""C:\Program Files (x86)\Steam\Steam.exe"")"");
</code></pre>

<p>or</p>

<pre><code>system(R""(start C:\Program Files (x86)\Steam\Steam.exe)"");
</code></pre>
",0
34911149,34911053,3,"<p>(Migrating answer from comment)</p>

<p>Place the path into a string internally:</p>

<pre><code>system(""start \""C:\\Program Files (x86)\\Steam\\Steam.exe\"""");
</code></pre>

<p>Note: use <code>\""</code> to create a quotation mark within a string.</p>
",0
39684384,39684289,0,"<p>Both <code>*</code> and <code>/</code> associate to the left, so the expressions are evaluated left-to-right.</p>

<p><code>C * (line - i)</code> (i.e. <code>C * 16</code>) overflows.<br>
<code>(line - i) / i</code> is <code>1</code>, and <code>1 * C</code> doesn't overflow.</p>
",0
39684486,39684289,0,"<pre><code>cout&lt;&lt; 3/2 *2; // Prints 2
cout&lt;&lt; 2*3/2;  // Prints 3
</code></pre>

<p>In the first line, 3/2 evaluates to 1.5, which is integer 1. Which then multiplied by 2 gives 2.</p>

<p>In the second line, the multiplication is done first, 2*3 evaluates to 6, which divided by 2 gives 3.</p>

<p>So when mixing integer and double arithmetic, the order of evaluation matters.</p>
",0
34960227,34959703,1,"<p>You can change the definition to </p>

<pre><code>Something(int data):data(data)
{
}
</code></pre>

<p>and it will work, too.  The parameter <code>data</code> hides the field <code>data</code> in the scope of the function.  <code>this-&gt;data</code> explicitly specifies the scope to be that of the class.  I can't tell you why the above declaration works other than to say that the elements in the initialization list of the constructor must be fields of the class instance.  So this may imply the scope.  While the values with which they are initialized come from the function scope.</p>
",0
34985234,34985177,0,"<p><a href=""https://stackoverflow.com/questions/6438086/iterator-invalidation-rules"">This question</a> lists iterator invalidation rules.  Modifying the data structure by <strong>resizing</strong> (""as per insert/erase [23.2.4.2/6]"") invalidates the iterator, even the <code>end()</code> as you've noticed.</p>
",1
34985265,34985177,0,"<p>From <a href=""http://en.cppreference.com/w/cpp/container/vector/insert"" rel=""nofollow"">http://en.cppreference.com/w/cpp/container/vector/insert</a></p>

<blockquote>
  <p>Causes reallocation if the new <code>size()</code> is greater than the old <code>capacity()</code>. If the new <code>size()</code> is greater than <code>capacity()</code>, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated. </p>
</blockquote>

<p>In your case, the call <code>v.insert(begin, 4)</code> invalidates all iterators since the vector is empty to start with.</p>

<p>As a defensive coding strategy, it is better not to rely on any iterators after a call to <code>insert()</code>.</p>
",1
34985266,34985177,0,"<p>First of all. STL iterators are the same insecure as pointers. Good or bad, this is so. We cannot change this. This means that you need to be careful when you are working with iterators.</p>

<p>Now what happens behind the scenes. Both iterators are essentially pointers. First one points to the current beginning of the vector body, the second one to the current end of the vector body. During insertion vector is allowed to move body of the vector to some other place. If vector will move the body, your iterator <code>end</code> will continue pointing to the same place. Even if vector will not move the beginning of the vector (sometimes this happens), your iterator will point to the last valid element (not after that last one as it should in normal case). Again, this will not be what you are expecting.</p>

<p>What is written above is just for understanding. You should never use this knowledge. You should check what actions invalidate what types of iterators and base your code only on what is explicitly allowed in the documentation.</p>
",1
38288741,38288048,-1,"<p>Try the system command like this </p>

<pre><code>system("".\\Data\\Common\\PPI.exe"")
</code></pre>

<p>and you need to include this:</p>

<pre><code>#include &lt;windows.h&gt;
</code></pre>
",11
43949957,43948931,0,"<p><code>npos</code> indicates the end of the string (you can think of it as being the index version of end ()). <code>pos</code> is the position of the search string found in the searched string. It gets incremented in every iteration so that it searches for a new occurrence each time. <code>size_t</code> is an unsigned integer type suitable for expressing the sizes of objects in memory.</p>

<p>In this implementation overlapping occurrences get counted, e.g. </p>

<p>Counting  ""aaa"" in ""xaaaay"" will count 2 occurrences.</p>
",0
37246552,37246392,1,"<p>so basically you have several levels that you can tackle this at... </p>

<ol>
<li>Ignore it, when in rome do as romans do, use <code>virtual</code> methods and c++ paradigms</li>
<li>Use Objective-C++, this is useful as a shim between Mac OSX gui and a c++ library</li>
<li>Use strings as something like selectors... and sort of mock out NSInvocation, use a variadic method like <code>MyObject::performMethodWithArguments(std::string methodName, ...)</code> ... this would be logic heavy and sort of painful</li>
</ol>

<p>probably just learn about virtual methods and function pointers.</p>
",1
37250976,37246392,1,"<p>Here is something that works that may be close enough for you:</p>

<pre><code>#include &lt;map&gt;
#include &lt;iostream&gt;

template&lt;typename C&gt;
struct MessageExpression
{
    std::map&lt;std::string,void(C::*)(void)&gt; functions;
    void registerFunc(std::string name,void(C::*function)(void))
        { functions[name]=function; }
    void sendMesg(std::string name)
        { (static_cast&lt;C*&gt;(this)-&gt;*functions[name])(); }
};

struct SomeClass : public MessageExpression&lt;SomeClass&gt;
{
    void method1() { std::cout &lt;&lt; ""method1"" &lt;&lt; std::endl; };
    void method2() { std::cout &lt;&lt; ""method2"" &lt;&lt; std::endl; };
};

int main()
{
    SomeClass s;
    s.registerFunc(""method1"",&amp;SomeClass::method1);
    s.registerFunc(""method2"",&amp;SomeClass::method2);
    s.sendMesg(""method1"");
    s.sendMesg(""method2"");
}
</code></pre>

<p>You can store a void pointer in an array of void pointers but at some point you need to convert it back to the correct member function pointer.  And since that is done in MessageExpression anyway you may as well store the correct kind of pointer in a proper map.</p>

<p>You need to pass &amp;SomeClass::method1 to registerFunc because the compiler won't know about method1 unless you say what namespace it is in.  I am also passing the string - you could use a preprocessor macro to stringify the function name if you want.</p>

<p>The other thing you could do is store std::function in the map.  But then you need to bind the this pointer just before calling it.  I don't see the advantage here - it may make more sense if you bound the this pointer before storing it in the map..</p>
",1
37640670,37640541,11,"<p>C++ implement copy by value, which means it basically does <code>x = y;</code>. In many cases this is enough. </p>

<p>However, in the case of pointers the compiler knows nothing about what is pointed to. It will copy the value of the pointer, but will not duplicate the underlying item because of this. For example, if you've got a class like this:</p>

<pre><code>class Foo
{
  char *data;
};
</code></pre>

<p>Then what should the compiler do with <code>data</code>? It doesn't know if it points to a single <code>char</code> or an array of <code>char</code>. It doesn't know anything about how the memory was allocated or how it should be freed. It doesn't know if it should make a copy, or if all instances of <code>Foo</code> should point to the same instance.</p>

<p>Because of this the language takes a perfectly reasonable default stance, which is that only the value of the pointer will be copied. If you want anything more then you have to do it yourself as only you fully understand the use-case of the variable.</p>
",1
35197422,35196721,-1,"<p>This is the explanation of what is happening here:
1.) if at least one virtual function is present in a class then a vtable is created for the class and a vptr for the calling object by the constructor. This vtable contains only the virtual functions. Every polymorphic call then is resolved by the compiler during run-time (dynamic binding) from the type of object the pointer refers to rather than the type of the pointer itself.
So, here:
2.) class 1 would have a vtable , let's call vtable(class 1). Then vtable(class 2) and vtable(class 3). There would be 4 vptrs, vptr(object 1), vptr(p), vptr(object 2) and vptr(object 3).
3.) So, when the calls; p = (class 1*)&amp;object 2; p->f(); and p->g() are resolved at runtime, the compiler would look for the object vptr of object referred by p, i.e object 2; though it is casted but still the referred object is object 2 hence vptr(object 2) would be invoked which would search for virtual function f in vtable (class 2) and call it. While searching for g() it vptr won't find it in vtable and hence go for the type of pointer itself which is class 1 and call class 1's g.
4.) Note that: virtual function has got to do with polymorphism and not inheritance.</p>
",0
35196791,35196721,4,"<p><strong>Undefined behaviour.</strong></p>

<p>Casting between completely unrelated types and accessing their contents is undefined behaviour, so anything could happen, including appearing like things worked.</p>

<p>Don't do this.</p>

<p>Additionally, using a C-style cast in that context is analogous to a <code>reinterpret_cast</code>. You should avoid using this as much as possible. If you use <code>static_cast</code>, for example, you'll get a compiler error.</p>
",1
41929418,41929037,3,"<p>There are some things that structs and arrays have in common, but generally they are thought of as conceptually separate. One situation in which you might be able to use either of them is if you want to store a known number of variables that are all of the same type.</p>

<p>I would recommend using an array if the data you are storing is a series where each value has the same meaning in some different context, and a struct if each value has a different meaning.</p>

<p>E.g.</p>

<p>You want to store a series of maximum temperature values for a single week. The meaning of each value is the same, all are maximum temperatures, so you use an array: </p>

<pre><code>std::array&lt;int, 7&gt; week_max_temperatures;
</code></pre>

<p>You want to store the maximum and minimum temperatures and total rainfall for a day. The type of each value is the same, <code>int</code>, but the meanings are different, so you use a struct to avoid confusing minimum temperature, maximum temprature, and rainfall:</p>

<pre><code>struct DailyWeatherData
{
    int max_temperature_deg_c;
    int min_temperature_deg_c;
    int total_rainfall_mm;
};
</code></pre>

<p>Here is a list of their similarities and differences:</p>

<p>Structs:</p>

<ul>
<li>Data members can be a combination of different types, but the types and number of members are fixed at compile time.</li>
<li>Can have static and instance methods.</li>
<li>Are copyable using <code>operator=()</code> (unless prohibited through copy constructor deletion or including a non-copyable member).</li>
<li>Are copied when passed as a function parameter (unless passed as a reference or pointer).</li>
<li>Data is stored in the object. Where they are stored in memory depends on whether they are defined as local variables or allocated using <code>new</code>. If the latter then you are responsible for memory management.</li>
</ul>

<p>C-style arrays:</p>

<ul>
<li>May contain any number of elements, all of which are of the same type. The type is set at compile time and the number of elements is set when the array is created at run time.</li>
<li>Cannot have user-defined methods associated with them.</li>
<li>Are copyable, but only through <code>std::copy</code> or <code>memcpy</code>, not <code>operator=()</code>.</li>
<li>Decay to pointers when passed as a function parameter.</li>
<li>Where data is stored in memory depends on whether the array is created as a local variable or allocated using <code>new[]</code>. If the latter then you are responsible for memory management. In either case, the array variable acts like a pointer to the actual data.</li>
</ul>

<p><a href=""http://en.cppreference.com/w/cpp/container/array"" rel=""nofollow noreferrer"">std::array</a>:</p>

<ul>
<li>May contain any number of elements, all of which are of the same type. The type and number of elements are set at compile time.</li>
<li>Cannot have user-defined methods associated with them (ignoring subclassing).</li>
<li>Are copyable using <code>operator=()</code>.</li>
<li>Are copied when passed as a function parameter (unless passed as a reference or pointer).</li>
<li>Data is stored in the object. They are not typically allocated using <code>new</code>, so memory management is not a concern.</li>
</ul>

<p><a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow noreferrer"">std::vector</a>:</p>

<ul>
<li>May contain any number of elements, all of which are of the same type. The type is set at compile time and the number of elements can change during run time.</li>
<li>Cannot have user-defined methods associated with them (ignoring subclassing).</li>
<li>Are copyable using <code>operator=()</code>.</li>
<li>Are copied when passed as a function parameter (unless passed as a reference or pointer).</li>
<li>Data is stored outside the object, and memory management is handled automatically.</li>
</ul>
",0
34967968,34967756,32,"<p>The official C++ ""documentation"" is the C++ standard, ISO/IEC 14882:2014(E). There is information at <a href=""https://isocpp.org/std/the-standard"" rel=""noreferrer"">ISOCPP</a> how to obtain the document.</p>

<p>I wouldn't necessarily consider the standard good documentation but it does specify the behavior of the standard language and library constructs.</p>

<p>There isn't any other <em>official</em> document on C++ describing the entire language. There are good derivative works making things more accessible like Bjarne Stroustrup's ""Programming: Principles as Practices Using C++"" and Nicolai Josuttis's ""The C++ Standard Library"".</p>
",0
45042181,45042069,3,"<blockquote>
  <p>Do you think this is at all feasible?</p>
</blockquote>

<p>Yes.</p>

<blockquote>
  <p>Should I approach this differently?</p>
</blockquote>

<p>Most certainly. Look up the factory pattern using your favorite search engine.</p>

<blockquote>
  <p>Should I have all possible fields already appear in the <code>BaseClass</code> and only use them in the derived classes that would have them (which doesn't seem too elegant to me)?</p>
</blockquote>

<p>Your hunch is correct. That's not a good idea. A base class should not make any assumptions about classes derived from it. It should have exactly what it needs -- nothing less, nothing more.</p>
",2
35255857,35119952,0,"<p>Thanks to anyone that tried to help!
I really appreciate it!</p>

<p><strong>I figured out the problem myself</strong>: Turns out that vectors do not use the same logic when pulling in strings from a file as arrays do. The setup I had in my original code outputs this error because I was trying to get vectors to this way. </p>

<p>As an example: </p>

<p>Original input from file to vector: </p>

<pre><code>for(count=0; count&lt;teams; count++)
    getline(inputFile, names[count]);
</code></pre>

<p>Updated input from file to vector: </p>

<pre><code>while(getline(inputFile, name))
    Teams.push_back(name);
</code></pre>

<p>Also another noted feature is that arrays by default are set as reference when being passed as parameters in a function. Vectors don't have this default feature and so required and ampersand-&amp;-sign in either the prototype or function statement. </p>

<p>-Francisco</p>
",0
35211430,35211202,0,"<p>Do this:</p>

<pre><code>int main() {
    char name[2][2] = {{'E', 'f'}, {'g', 'r'}};
    char pname[2][2];
    memcpy(pname, name, sizeof (char)*2*2);

    for (int x = 0; x&lt;2; x++) {
        for (int y = 0; y&lt;2; y++) {
            cout &lt;&lt; pname[x][y] &lt;&lt; endl;  
        }  
    }
}
</code></pre>

<p>It would output: 
<code>E</code>
<code>f</code>
<code>g</code>
<code>r</code> with newlines inbetween</p>

<p>look up memcopy <a href=""https://stackoverflow.com/questions/2225850/c-c-how-to-copy-a-multidimensional-char-array-without-nested-loops"">here</a></p>
",1
35211543,35211202,1,"<p>I would use something like:</p>

<pre><code>  #define x_size 2
  [...]
  char (*pname)[x_size] = &amp;name[0];

  for (int x = 0; x&lt;2; x++)
  {
    for (int y = 0; y&lt;2; y++)
      {
        cout &lt;&lt; pname[x][y] &lt;&lt; endl;  
      }  
  }
</code></pre>

<p>or:</p>

<pre><code>  int x_size = 2;
  char* pname = &amp;name[0][0];

  for (int x = 0; x&lt;2; x++)
  {
    for (int y = 0; y&lt;2; y++)
      {
        cout &lt;&lt; pname[x*x_size + y] &lt;&lt; endl;  
      }  
  }
</code></pre>
",0
35211366,35211202,2,"<p>What's happening here is, the <code>char*</code> type drops the array size information from the C-style 2-D array <code>name</code>.  Because <code>pname</code> is just a <code>char*</code>, its users have no way of knowing the size and shape of the thing it's pointing to.</p>
",0
35211387,35211202,5,"<p><code>pname</code> is a pointer to <code>char</code>. So <code>pname[x]</code> is a <code>char</code>. Therefore <code>pname[x][y]</code> is an attempt to take the yth item from a char, just as if you'd typed <code>char t; t[10];</code>.</p>

<p>Assuming you want to pass a pointer because you want to pass by reference, you want to take an argument of <code>char pname[][10]</code>.</p>

<p>If you just want to output the items linearly, use your current <code>pname</code> and step along <code>for(int c = 0; c &lt; 4; c++) cout &lt;&lt; pname[c] &lt;&lt; endl;</code>.</p>
",1
35197283,35197166,0,"<ul>
<li><p>Just call your function like this:</p>

<pre><code>int a = f(x, y);
cout &lt;&lt; a &lt;&lt; "" "" &lt;&lt; x &lt;&lt; "" "" &lt;&lt; y;
</code></pre></li>
</ul>
",4
43213186,43212150,1,"<p>The <strong>onceFlag</strong>, which is an object of <code>std::once_flag</code> <strong>class</strong> is key here.</p>

<p>The internal state of <code>std::once_flag</code> object is set, so that there is no second execution of <code>std::call_once</code> function.</p>

<p>Here if you notice, the standards exposed only <strong>one constructor with out arguments</strong> for <code>std::once_flag</code> class ,And no overloaded assignment operator. Standards might have declared a private assignment operator or used ""Explicitly delete special member functions. (C++11)"".</p>

<p><strong>As far as I know, there is no way you can change/modify  the set internal sate.</strong></p>

<p>Try this odd way, if you seriously require....</p>

<p>Declare different <code>std::once_flag</code> flags</p>

<pre><code>std::once_flag flag1,flag2,flag3; //Three different flags.

    {
        ....
        std::call_once ( flag1, [ ]{ /* my code body here runs only once */ } ); //track first thread call
        std::call_once ( flag2, [ ]{ /* my code body here runs only once */ } ); //track second thread call
        std::call_once ( flag3, [ ]{ /* my code body here runs only once */ } ); //third third thread call

    }
</code></pre>
",0
40572193,40572155,1,"<p><code>"""" + K</code> is an operation between a <code>const char*</code> and an <code>int</code>. It's equivalent conceptually to <code>&amp;(""""[K])</code></p>

<p>You create a <code>std::string</code> from a pointer you obtained mistakenly. It points to an unspecified location, and using it to construct your <code>std::string</code> is relying on undefined behavior.</p>

<p>A funny thing is that if you were to use a <code>std::string</code> literal, you'd get a compiler error:</p>

<pre><code>string C = """"s + K;
</code></pre>
",0
40572196,40572155,2,"<pre><code>string C = """" + K;
</code></pre>

<p>doesn't do what you think it does. You probably think it is equivalent to <code>std::to_string(K)</code>, well no. What it <em>actually</em> does is increment the pointer of the string literal <code>""""</code> by <code>K</code>.</p>

<p>That's undefined behavior (as <code>K</code> is not <code>0</code> - that wouldn't change the pointer), and you can get any result. You have to use <code>std::to_string</code> or <code>std::atoi</code> or similar functions.</p>
",1
35254961,35254854,1,"<p>If you don't need to generate arrays, then check uniqueness and remove elements - store only unique numbers.</p>

<p>Try to use <code>hashed_unique</code> <a href=""http://www.boost.org/doc/libs/1_46_1/libs/multi_index/doc/tutorial/indices.html"" rel=""nofollow noreferrer"">boost::multiindex</a>.
If you want to preserve order, make use of <code>ordered_unique</code>.</p>

<p>See also: <a href=""https://stackoverflow.com/a/769161/1566267"">this</a></p>
",0
35255022,35254854,1,"<p>First of all eliminate check by cycling through array. If you only have 30E6 variants you can try put them in one array of boolean flags if you have enough space. That would cost about 30Mb. Another optimization by memory may be packing flags to bitmask. That would cost 8 times less. And it will improve speed. So having 30Mb/8 (~4Mb) sized array of flags you can check existence of already generated number in constant time. That wiil improve speed drastically. But there is another problem: having many generations you will stuck in repeated collisions.</p>
",1
35255748,35254854,2,"<p>You can first generate the unique numbers in order and then shuffle them to obtain the final result (if you need that at all).</p>

<p>Using <a href=""http://en.cppreference.com/w/cpp/utility/bitset"" rel=""nofollow""><code>std::bitset</code></a> would be an efficient way to store if the value has already been generated. Alternatively, if you don't actually know the number of values at compile time, you could use <a href=""http://en.cppreference.com/w/cpp/container/vector_bool"" rel=""nofollow""><code>std::vector&lt;bool&gt;</code></a> which is a specialization using bit operations will also save you some space.</p>

<pre><code>#include &lt;iostream&gt;

#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;random&gt;
#include &lt;bitset&gt;


int main()
{
    static constexpr int max_value = 30'000'000;
    static constexpr int n_values = 800'000;

    std::bitset&lt;max_value + 1&gt; have_num;

    int cur_n_values = 0;

    std::mt19937_64 mt{std::random_device{}()};
    std::uniform_int_distribution&lt;int&gt; distribution{0, max_value};


    while (cur_n_values != n_values) {
        auto newVal = distribution(mt);

        if (!have_num[newVal]) {
            have_num[newVal] = true;
            ++cur_n_values;
        }
    }

    std::vector&lt;int&gt; nums;
    nums.reserve(n_values);

    for (int i = 0; i &lt; have_num.size(); ++i) {
        if (have_num[i]) {
            nums.push_back(i);
        }
    }

    std::shuffle(nums.begin(), nums.end(), mt);

    for (auto i : nums) {
        std::cout &lt;&lt; i &lt;&lt; "" "";
    }
}
</code></pre>

<p><a href=""http://rextester.com/ENXJ66435"" rel=""nofollow"">LIVE</a></p>
",1
35254932,35254893,0,"<p>You calculate values first suing uninitialized values, then read amount of coins <strong>and</strong> not use them after you read them.</p>
",0
35254938,35254893,4,"<p>You are using the variables before they are read. You can't declare a <em>variable</em> to be some calculation like you have done. You have to calculate the values <em>after</em> you have put values into the variables. </p>

<p>When you say</p>

<pre><code>float valueofDollars = numberofDollars * dollar;
</code></pre>

<p>it means ""calculate the multiplication of the variable values <em>at this moment</em> and store it."" It doesn't mean ""calculate this every time the variables change."" So move all these after the variables have been read. </p>
",0
45777853,45777850,1,"<p>Note that <code>0110</code> is an <a href=""http://en.cppreference.com/w/cpp/language/integer_literal"" rel=""nofollow noreferrer"">octal-literal</a>:</p>

<blockquote>
  <p>octal-literal is the digit zero (0) followed by zero or more octal digits (0, 1, 2, 3, 4, 5, 6, 7)</p>
</blockquote>

<p>That's why you're getting <code>72</code> when printing out it, it's not same as <code>110</code>.</p>
",4
45777897,45777850,1,"<p>The compiler's right.</p>

<p>With ONE leading zero, your number will be treated as 8-based, so <code>0110</code> means (110)<sub>8</sub>, which equals to (72)<sub>10</sub>.</p>

<p>If you try to write <code>08</code>, your compiler will complain it's not a valid octal number.</p>
",0
36230518,36230448,4,"<p>Change this:</p>

<pre><code>std::ofstream fileOutStream(""filepath.txt"");
</code></pre>

<p>to this:</p>

<pre><code>std::ofstream fileOutStream(""filepath.txt"", std::ios::in | std::ios::binary);
</code></pre>

<p>You open the input file in binary, so it would make sense to do the same for the output file too.</p>

<hr>

<p><sub>As M.M said:</sub></p>

<p>Another option is to open both files as text (in which case the memory buffer will contain <code>\n</code> instead of <code>\r\n</code>). </p>
",0
41212192,41212130,9,"<p>That is a <a href=""http://en.cppreference.com/w/cpp/language/list_initialization"" rel=""noreferrer"">list initialization</a> aka brace initializer list. More specifically, in this case it's a direct-list initialization.</p>

<p>Basically the <code>m_font</code> variable is initialized with the value that's given in the curly braces, in this case it's initialized to a <code>shared_ptr</code> for the <code>font</code> object that's given to the constructor.</p>
",0
41212196,41212130,7,"<p>The class <code>Font</code> has a member called <code>m_font</code> of type <code>std::shared_ptr&lt;sf::Font&gt;</code>, so in the constructor of the class <code>Font</code> that member is being initialized with a shared pointer to <code>font</code>.</p>
",0
41212253,41212130,25,"<p>This is described on <a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""noreferrer"">cppreference</a>, but in a somewhat hard to read format:</p>

<blockquote>
  <p>The body of a function definition of any constructor, before the opening brace of the compound statement, may include the <em>member initializer list</em>, whose syntax is the colon character <code>:</code>, followed by the comma-separated list of one or more <em>member-initializers</em>, each of which has the following syntax</p>
  
  <p>...</p>
  
  <p><em>class-or-identifier brace-init-list</em> (2) <sub>(since C++11)</sub></p>
  
  <p>...</p>
  
  <p>2) Initializes the base or member named by <em>class-or-identifier</em> using list-initialization (which becomes value-initialization if the list is empty and aggregate-initialization when initializing an aggregate)</p>
</blockquote>

<p>What this is trying to say is that <code>X::X(...) : some_member{some_expressions} { ... }</code> causes the <code>some_member</code> class member to be initialised from <code>some_expressions</code>. Given</p>

<pre><code>struct X {
    Y y;
    X() : y{3} {}
};
</code></pre>

<p>the data member <code>y</code> will be initialised the exact same way a local variable <code>Y y{3};</code> would be initialised.</p>

<p>In your case, <code>std::make_shared&lt;sf::Font&gt;(font)</code> produces the value that will be used to initialise the <code>m_font</code> class member.</p>
",3
34894221,34893986,0,"<p>In this case you need to have a short understanding how the heap memory management works. in particular implementation of it, when you allocate an object you receive a pointer to the start of the memory available to you to work with. However, the 'really' allocated memory starts a bit 'earlier'. This means the allocated block is a bit more than you have requested to allocate. The start of the block is the address you have received minus some offset. Thus, when you pass the incremented pointer to the <code>delete</code> it tries to find the internal information at the left side of it. And because your address is now incremented this search fails what results in a crash. That's in short.</p>
",1
34894236,34893986,3,"<p>What your program shows is several cases of undefined behaviour:</p>

<ol>
<li>You write to memory that hasn't been allocated (<code>*i = 1</code>)</li>
<li>You free something that you didn't allocate, effectively <code>delete i + 1</code>.</li>
</ol>

<p>You MUST call <code>delete</code> on exactly the same pointer-value that you got back from <code>new</code> - nothing else. Assuming the rest of your code was valid, it would be fine to do <code>int *j = i;</code> after <code>int *i = new int(1);</code>, and then <code>delete j;</code>. [For example <code>int *i = new int[2];</code> would then make your <code>i++; *i=1;</code> valid code]</p>
",1
34894082,34893986,1,"<p>Who allocates is who deallocates. So you should not be able to delete something you did not new by yourself. Furthermore, <code>i++;*i=1;</code> is UB since you may access a restricted memory area or read-only memory...</p>

<p>The code made no sense . I think You have XY problem. If you could post your original problem there will be more chance to help you.</p>
",0
34894443,34893986,0,"<p>The problem lies here:</p>

<pre><code>    i++;
</code></pre>

<p>This line doesn't increment the value <code>i</code> points to, but the pointer itself by the number of bytes an <code>int</code> has (4 on 32-bit platform).
You meant to do this:</p>

<pre><code>    (*i)++;
</code></pre>
",1
34894315,34893986,0,"<p>Let's take it step by step:</p>

<pre><code>int* i = new int(1);  // 1. Allocate a memory.
i++;                  // 2. Increment a pointer. The pointer now points to
                      //    another location.
*i=1;                 // 3. Dereference a pointer which points to unknown
                      //    memory. This could cause segmentation fault.
delete i;             // 4. Delete the unknown memory which is undefined 
                      //    behavior.
</code></pre>

<p><s>In short: If you don't own a piece of memory you can't do arithmetic with it neither delete it!</s></p>
",7
45115230,45115188,1,"<blockquote>
  <p>I understand the compiler, but I don't know how to manage this situation. How should I redesign the class to solve this problem?</p>
</blockquote>

<p><code>LeafNode::getNodeList</code> can only return an empty list. Implement it as:</p>

<pre><code>vector&lt;Node *&gt;&amp; getNodeList() const
{
   static vector&lt;Node *&gt; empty;
   return empty;
}
</code></pre>

<p>Also,</p>

<pre><code>virtual void isLeaf() const = 0;
</code></pre>

<p>is not right. It makes more sense to use:</p>

<pre><code>virtual bool isLeaf() const = 0;
</code></pre>
",4
41211847,41211793,1,"<p>Use <code>std::vector</code> and <code>std::string</code>.  Use a correct form of reading a file:  </p>

<pre><code>std::string word;
std::vector&lt;std::string&gt; word_database;
while (text_file &gt;&gt; word)
{
  word_database.push_back(word);
}
std::cout &lt;&lt; ""Words read: "" &lt;&lt; word_database.size() &lt;&lt; ""\n"";
</code></pre>
",3
41211852,41211793,1,"<p>Check out <a href=""https://stackoverflow.com/questions/24607385/read-data-from-fstream"">this link</a> here. </p>

<p>Also, std:: is a reference to the namespace of code you are calling. When you include a file that is in the standard libraries, such as string, vector, fstream, iostream, you need to either declare that your file will use the namespace std with using namespace std; OR you append std:: to the method or variable.</p>
",2
36261218,36261096,1,"<p>I suspect the thing you're missing is that when you <code>insert</code> a range, it inserts each item in that range. It doesn't try to insert them as a single item but it inserts each item in the range individually.</p>

<pre><code>      set&lt;char *&gt;m;
      m.insert(a,a+8);
</code></pre>

<p>Okay, so <code>m</code> is a <code>set</code> of <code>char*</code>. You've said that you want to insert everything in the range from <code>a</code> to <code>a+8</code>. That's a range of characters. So you're trying to insert characters into a set of pointers to characters. That can't work.</p>

<p>Perhaps you just want <code>m.insert(a);</code>? Since <code>m</code> is a <code>set</code> of <code>char*</code> and <code>a</code> is a <code>char*</code>, I can't imagine what you might want to do other than insert it.</p>
",3
36261634,36261096,0,"<pre><code>m.insert(a,a+8);
</code></pre>

<p>You tried to use a wrong overload of <code>set::insert()</code>. It is mostly useful when you want to do something like this:</p>

<pre><code>int a[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
std::set&lt;int&gt; m;
m.insert(a[0]);
m.insert(a[1]);
...
m.insert(a[6]);
m.insert(a[7]);
</code></pre>

<p>This is lengthy and we want to avoid repetitions. Equivalently, you can write</p>

<pre><code>int a[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
std::set&lt;int&gt; m;
m.insert(a, a+8);
</code></pre>

<p>Now let's go back to your code...</p>

<pre><code>while(getline(cin,info)){
      char *a = new char[info.size()+1];
      ...
      set&lt;char *&gt;m;
      m.insert(a,a+8);
</code></pre>

<p>Conversely, you can ""expand"" it into</p>

<pre><code>while(getline(cin,info)){
      char *a = new char[info.size()+1];
      ...
      set&lt;char *&gt;m;
      m.insert(a[0]);
      m.insert(a[1]);
      ...
      m.insert(a[6]);
      m.insert(a[7]);
</code></pre>

<p>Now you see you ended up in <code>insert</code>-ing a <code>char</code> object to <code>std::set&lt;char *&gt;</code>. This is the reason why you got the error message.</p>

<h2>Proposed fix</h2>

<p>You defined <code>set&lt;char *&gt; m</code> <em>inside</em> the <code>while</code> loop.  That means you are dealing with a freshly constructed <code>m</code> in each iteration of the <code>while</code> loop, which doesn't makes sense.  You need to move the definition of <code>m</code> to before <code>while</code>.</p>

<p>It is not recommended to use <code>new char[...]</code> until you spend 5--6 years in C++.   C++ already prepared <code>std::string</code> and/or <code>std::vector</code> for you to replace 99% of the use cases of raw <code>new char[...]</code>.  So your <code>set</code> should be <code>set&lt;string&gt; m</code>.</p>

<p><code>std::string</code> has an assignment operator (and a copy constructor) which takes a <code>std::string</code> or NUL-terminated <code>const char *</code> and does <code>memcpy()</code> for you, and you can think <code>set::insert()</code> internally invokes it.</p>

<p><code>std::string</code> also supports a substring operation returning a fresh <code>std::string</code> such that <code>string(""abcde"").substr(3) == ""abc""</code>.  </p>

<ul>
<li><a href=""http://en.cppreference.com/w/cpp/string/basic_string/substr"" rel=""nofollow"">http://en.cppreference.com/w/cpp/string/basic_string/substr</a></li>
</ul>

<p>That means you don't need an intermediate variable <code>a</code> at all.</p>

<p>After these corrections, you'll get</p>

<pre><code>set&lt;string&gt; m;
while(getline(cin,info)){
      m.insert(info.substr(8));
}
</code></pre>
",2
45056923,45054931,0,"<p>You should implement also other methods for derived classes you declare, namely <code>Derived::~Derived(void)</code>, <code>Derived::someMethod(void)</code>, <code>Derived::someMethod2(void)</code>, <code>DerivedB::~DerivedB(void)</code> and <code>DerivedB::someMethod(void)</code>.</p>

<p>See this post: <a href=""https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration"">What is the difference between a definition and a declaration?</a> and <a href=""https://stackoverflow.com/questions/12573816/what-is-an-undefined-reference-unresolved-external-symbol-error-and-how-do-i-fix"">What is an undefined reference/unresolved external symbol error and how do I fix it?</a></p>
",1
36324325,36324254,7,"<p>You are using the addressof(<code>&amp;</code>) operator, meaning <code>&amp;flag</code> is converted to <code>bool*</code></p>

<p>Remove it, and it should work:</p>

<pre><code>test_irater = search_tree(test_irater, p_test, flag); 
</code></pre>
",3
47983478,30064637,1,"<p>I was doing that exercise right now. I took your initial suggestion and expanded on it to get the following (to be inserted in place of your for loop):</p>

<pre><code>for (int i=0; i&lt;=n; i++){
        int j = i;
        while(j &gt; 1) {
            if((j % 10 == 4 || j % 10 == 7)) {
                count++;
                break;
            }
            j = j / 10;
        }
    }
</code></pre>

<p>This seems to get the intended answer. However, when trying to check the solution, the site claims that the result is wrong for n = 74 (it claims the correct answer is 15, but counting by hand I'm pretty sure it's 27, which is also what this code returns). I didn't figure out what I did wrong so I've tried to log a ticket with the site.</p>
",1
41210734,41210408,0,"<p>To do this in <a href=""/questions/tagged/c"" class=""post-tag"" title=""show questions tagged &#39;c&#39;"" rel=""tag"">c</a>, you must first allocate an array. For a 32 bit int, this could be a fixed array with 10 digits (+ NUL char), e.g.</p>

<pre class=""lang-c++ prettyprint-override""><code>int main()
{
    int n;
    std::cin &gt;&gt; n;
    char a[11];
    int i = 0;
    while (n &gt; 0) {
        int digit = n % 10;
        a[i] = digit;
        ++i;
        n /= 10;
        std::cout &lt;&lt; digit &lt;&lt; "" "";
    }

    a[i] = '\0'; // final NUL byte
    // the digits are now stored in reverse order in `a`
    return 0;
}
</code></pre>
",0
41210463,41210408,5,"<p>The best approach is proably to use a vector since they can be easily resized at runtime, something like:</p>

<pre><code>int main()
{
    int n;
    std::cin&gt;&gt;n;
    std::vector&lt;int&gt; digitArray;
    while (n &gt; 0)
    {
        int digit = n%10;
        n /= 10;
        std::cout&lt;&lt;digit&lt;&lt;"" "";
        digitArray.push_back(digit);
    }
    std::reverse(digitArray.begin(), digitArray.end()); // reverse the order of digits

    return 0;
}
</code></pre>

<p>Vectors can be accessed just like C-style arrays: <code>digitArray[0]</code> = the first digit. </p>

<p>Another approach to take might be to use a fixed size array since we know that a 32-bit integer can only be up to 10 digits long, something like:</p>

<pre><code>int main()
{
    int n;
    std::cin&gt;&gt;n;
    int digitArray[10] = {0}; //initialize all elements to 0
    int size = 0;
    while (n &gt; 0)
    {
        int digit = n%10;
        n /= 10;
        std::cout&lt;&lt;digit&lt;&lt;"" "";
        digitArray[size] = digit;
        ++size;
    }
    std::reverse(std::begin(digitArray), std::begin(digitArray)+(size-1)); // reverse the order of digits

    return 0;
}
</code></pre>

<p>This will leave you with useless elements most of the time, though that probably won't matter here.</p>
",5
41210576,41210408,0,"<p>First count the number of digits, then create a dynamic array and push the digits from highest to lowest index <code>0</code> as you move from lsb to msb: </p>

<pre><code>int main()
{
    int n, count = 0;
    std::cin&gt;&gt;n;
    int m = n;
    while(n &gt; 0)
    {
       n /= 10;
       ++count;
    }
    int *a = new int[count];
    while(m &gt; 0)
    {
       a[--count] = m % 10;
       m /= 10;
    }
    delete[] a;  //don't forget to release the memory.
    return 0;   
}
</code></pre>
",0
39340269,39340163,0,"<p><code>int** m = new int*[input];</code> should inside a function definition. </p>

<p>You can dynamically create multidimensional array using </p>

<pre><code>int** m = new int*[input];
for(int i = 0; i &lt; row; i++)
    m[i] = new int[col];
</code></pre>

<p>A better approach to use <code>std::vector</code> for 2-d array.</p>

<p>You can create 2-D array using <code>std::vector</code> like <code>std::vector&lt;std::vector&lt;int&gt;&gt; m;</code></p>
",0
37196279,37196063,0,"<p>In <code>room.h</code>, replace <code>#include ""User.h""</code> with a forward declaration instead.  Use forward declarations in the <code>.h</code> files, and move the corresponding <code>#include</code> statements to the <code>.cpp</code> files:</p>

<p>user.h</p>

<pre><code>#ifndef USER_H
#define USER_H

class Room;

using namespace std;

class User
{
private:
    Room* _currRoom;
public:
    //some functions...
};

#endif
</code></pre>

<p>user.cpp</p>

<pre><code>#include ""user.h""
#include ""room.h""
...
</code></pre>

<p>room.h</p>

<pre><code>#ifndef ROOM_H
#define ROOM_H

#include &lt;vector&gt;
#include &lt;string&gt;

class User;

class Room
{
private:
    vector&lt;User*&gt; _users;
    User* _admin;
    int _maxUsers;
    int _questionTime;
    int _questionsNo;
    string _name;
    int _id;

public:
    Room(int id, User* admin, string name, int maxUsers, int questionsNo, int questionTime);
    //more functions...
};

#endif
</code></pre>

<p>room.cpp</p>

<pre><code>#include ""room.h""
#include ""user.h""
...
</code></pre>

<p>If you don't do the forward declarations in this manner, you can end up in a circular situation where a header indirectly includes itself via another header (A includes B, which includes A) and thus its header guard has already been defined preventing its declarations from being processed, thus causing errors.</p>
",1
39643477,39643438,3,"<p>You are actually calling the <strong>constructors</strong> when you say you're passing arguments to objects. <strong>Constructors</strong> with matching signatures are called.</p>

<p>When you write <code>Person person1;</code>, default constructor which is </p>

<pre><code>Person(){
    name = ""undefined"";
    age = 0;
};
</code></pre>

<p>is called.<br>
When you write <code>Person person2(""David"");</code>, </p>

<pre><code>Person(string newname){
    name = newname;
    age = 0;
};
</code></pre>

<p>is called. <br>
And finally, when you do <code>Person person3(""Mia"", 35);</code>,</p>

<pre><code>Person(string newname, int newage){
    name = newname;
    age = newage;
};
</code></pre>

<p>is called.</p>
",0
39643524,39643438,1,"<p>When you define a new C++ class, with its members as your choice, each one of these functions as a regular variable (or pointers, or instances of other classes, etc.) which is a concept you are already familiar with.</p>

<p>So when you instantiate a new instance of the class, the compiler knows exactly how much memory it should allocate, and what is the inner structure of it - how to divide that memory into smaller pieces corresponding to the class members.
And that is how, when you call a constructor, it knows how to ""add the arguments"" to your instance.</p>
",4
39643545,39643438,1,"<p>This statement: <code>Person person1;</code> is calling this constructor:</p>

<pre><code>Person();
</code></pre>

<p>This <code>Person person2(""David"");</code> is calling this constructor:</p>

<pre><code>Person(string newname);
</code></pre>

<p>And this <code>Person person3(""Mia"", 35);</code>  is calling this constructor:</p>

<pre><code>Person(string newname, int newage);
</code></pre>

<p>Since constructors are <strong>functions</strong> that initialize the object of class Person, they can receive arguments, like any function.</p>
",0
36255499,36255429,0,"<p>This...</p>

<pre><code>while (!in.eof()) {
</code></pre>

<p>...is broken.  You should attempt to read and parse data into your variables, <em>then</em> check for failure/eof.  Do not assume that you'll necessarily be at the end of file after reading the last <code>MYCLASS</code>.  Instead:</p>

<pre><code>string name;
int age;
while (in &gt;&gt; name &gt;&gt; age)
    ...do stuff...
</code></pre>

<p>If you've really got some kind of leading dot on each line, add a <code>char</code> and read into it too:</p>

<pre><code>char dot;
string name;
int age;
while (in &gt;&gt; dot &amp;&amp; dot == '.' &amp;&amp; in &gt;&gt; name &gt;&gt; age)
    ...do stuff...
</code></pre>

<p>More generally, it's not a very scalable model to assume the rest of the input stream will contain one <code>MYCLASS</code> object.  You could instead have a delimiter (e.g. when the first word on a line is not a name, but <code>&lt;END&gt;</code>), that terminates the loop.</p>
",1
36257812,36257495,4,"<p>The easier way would be to create a base class for all your structures and store pointers to that in the map.</p>

<pre><code>struct BaseStruct
{
    virtual ~BaseStruct()
    {}
};
struct My_Struct1 : BaseStruct { int x; }
struct My_Struct2 : BaseStruct { float y; }

std::map&lt;unsigned int, BaseStruct *&gt; MyMap;
</code></pre>

<p>Or you may prefer using a smart pointer to handle the lifetime of the objects.</p>

<pre><code>std::map&lt;unsigned int, std::shared_ptr&lt;BaseStruct&gt; &gt; MyMap2;
std::map&lt;unsigned int, std::unique_ptr&lt;BaseStruct&gt; &gt; MyMap3;
</code></pre>

<p>Note the virtual destructor. That is important so that when you delete the objects from the map the memory of the subclasses is properly freed.</p>

<p>PS: Take a look at <a href=""http://www.boost.org/doc/libs/1_60_0/doc/html/any.html"" rel=""nofollow""><code>boost::any</code></a>. It may be useful if you don't want or can't use the base struct.</p>
",8
36258389,36257495,3,"<p>You can achieve that via inheritance, create a base struct and inherit both of your structs from that base struct (place some constructor to initialize the data member if you want).</p>

<pre><code>//Your base struct
struct My_Base
{
    virtual void foo() {};
};

struct My_Struct1: virtual My_Base
{
public:
    int x;
    My_Struct1(int _x) { x = _x; }
};

struct My_Struct2 : virtual My_Base
{
public:
    float y;
    My_Struct2(float _y) { y = _y; }
};

map&lt;unsigned int, My_Base*&gt; _map;
</code></pre>

<p>To make it easily understandable, providing the driver or invocation code below.</p>

<pre><code>My_Base* obj1 = new My_Struct1(2);
My_Base* obj2 = new My_Struct2(3.2f);

//Adding some random test data to map
_map[1] = obj1;
_map[2] = obj2;

My_Base* mapObjBase = _map.find(2)-&gt;second;
//Downcast the object you retrieved from the map, this downcasting could fail so please note the if here.
if (My_Struct2* mapObj2 = dynamic_cast&lt;My_Struct2*&gt;(mapObjBase))
{
    cout &lt;&lt; ""My_Struct2.y = "" &lt;&lt; mapObj2-&gt;y &lt;&lt; endl;
}
else
{
    cout &lt;&lt; ""Error..."" &lt;&lt; endl;
}
//Some memory cleaning before leaving the code block.
delete obj1;
delete obj2;
</code></pre>

<p>Something about <a href=""http://en.cppreference.com/w/cpp/language/dynamic_cast"" rel=""nofollow"">dynamic_cast</a> (if you are interested in further reading...)</p>
",0
36257548,36257495,2,"<p>You should declare struct type in following way:</p>

<pre><code>struct My_Struct
{
    union
    {
        int x;
        float y;
    };
};
</code></pre>

<p>Then you can use it in following way:</p>

<pre><code>map&lt;unsigned int, My_Struct&gt; MyMap;
</code></pre>
",4
34946627,32636021,1,"<p><code>auto</code> removes references and top-level cv-qualifiers (<code>const</code> and <code>volatile</code>).</p>

<p>The type of <code>c</code> is <code>something const&amp;</code> and it would be the same even if you wrote <code>auto&amp; c = f_x()</code> (the same situation as <code>v5</code> on slide 15 of Scott Meyers' <a href=""http://www.aristeia.com/TalkNotes/C++TypeDeductionandWhyYouCareCppCon2014.pdf"" rel=""nofollow"">""Type Deduction and Why You Care""</a>) so you don't need a <code>const</code> there.</p>

<p>The type of <code>c_copy</code> is <code>something</code> (note: no <code>const</code> even though the RHS is a const reference; same as <code>v3</code> on the same slide) , that's why <code>c_copy = c</code> invokes the copy constructor.</p>
",0
38877658,38874200,0,"<p>It was a simple lack of understanding. The solution to my particular issue was:</p>

<pre><code>std::stringstream ss(line.substr(2)); 
char throwaway; 
for (int i = 0; i &lt; 3; i++){ 
     ss &gt;&gt; vertexIndex[i] &gt;&gt; throwaway &gt;&gt; uvIndex[i] &gt;&gt; throwaway &gt;&gt; normalIndex[i]; 
}
</code></pre>

<p>My next question is why the following does not work?</p>

<pre><code>ss.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '/');
ss &gt;&gt; vertexIndex[i] &gt;&gt;  uvIndex[i] &gt;&gt;  normalIndex[i];
</code></pre>
",0
42590890,42590875,0,"<p>You did <code>in.readAll()</code>, after that call <code>in.atEnd()</code> will return <code>true</code>. Either remove <code>in.readlAll()</code> or <code>while</code> loop, why do you need both?</p>
",2
35282220,35281953,1,"<pre><code>    struct node
{
    int info;
    struct node *next;

};
</code></pre>

<p>Think of the above as just a template for something you will be using in future.</p>

<p>So when you want to structure your data using the above struct you will need to define a variable or instantiate the struct in memory as shown below</p>

<p>Something like</p>

<pre><code>struct node mynode;
or 
struct node* mynodeptr = new node;
</code></pre>

<p>To answer your subsequent question the above can be done wheresoever you need a <code>node</code> variable instantiated. So yes it doesn't have to be always done the way it was done in your original question.</p>

<p>As for <code>typedef</code>ing a <code>struct</code> there's a good discussion on why you would use it. Take a look <a href=""https://stackoverflow.com/questions/1675351/typedef-struct-vs-struct-definitions"">here</a></p>
",2
35281980,35281953,6,"<p><code>start</code> is a variable of type <code>struct node*</code> - my guess is it is the head of the list.</p>

<p>If you find it easier to split the type and the variable:</p>

<pre><code>struct node
{
    int info;
    struct node *next;

};

struct node* start;
</code></pre>

<p>Since this is C++ you can also simplify to <code>node* start;</code></p>
",2
36267986,36267291,0,"<p>Ideone problem. Visual Studio works ok. Also, <code>counting_sort(a, size)</code>, not <code>size-1</code></p>
",2
34928505,34928428,1,"<p>The problem is that with the <code>double arr[n]</code> syntax you are allocating the array on the stack.</p>

<p>Now, the stack is a limited resource, and <code>n</code> can grow up to almost 5 megabytes, which is way beyond the <a href=""https://stackoverflow.com/questions/1825964/c-c-maximum-stack-size-of-program"">normal size of the stack</a></p>

<p>You should allocate the array on the heap with</p>

<pre><code>double * arr = new double[n];
</code></pre>

<p>and then free it at the end of the function with</p>

<pre><code>delete[] arr;
</code></pre>
",6
34928562,34928428,2,"<p>1) <code>rand</code> usually cannot generate numbers that large. It is commongly capped around 32k</p>

<p>2) <code>double arr[n];</code> is not legal if n is not a compile-time constant. You are probably using  unportable compiler extention.</p>

<p>3) Stack space (where arr resides) is usually very limited. I doubt it can accomodate so much data which is the reason to crash.</p>
",4
34929509,34928428,0,"<p>Sorry this is a very partial answer but I can't add comments (low reputation...)
Still, there should be a RAND_MAX value defined in stdlib (0x7FFF in my case)
So to my understanding rand() returns a value between 0 and 32767.
If you want a value between 0 and 5000000 you can try </p>

<pre><code>unsigned int n = ((double)rand()/RAND_MAX) * 5000000;
double * arr = new double[n];
...
delete[] arr;
</code></pre>

<p>Also, check that your compare structure is a strict comparator.</p>

<p>Hope it helps</p>
",0
46084254,46083966,0,"<p>There is no reason to use <code>const char *</code>, since its more error-prone and harder to implement you should use <code>std::string</code> instead.</p>

<p><code>std::string</code> also allows you to get <code>const char *</code> to string using <code>c_str()</code> method.</p>

<p>But if you have to implement name as C-style string, here is what you have to do:</p>

<ul>
<li>Allocate enough space on heap using <code>new</code>.</li>
<li>Cast to non-const</li>
<li>Copy strings using <code>strcpy</code></li>
<li>Free memory in destructor</li>
</ul>

<p>Constructor:</p>

<pre><code>test(const std::string&amp; str) : name(new char[str.length() + 1])
{
    strcpy((char*)name, str.c_str()); }
};
</code></pre>

<p><strong><a href=""https://ideone.com/ICsxL9"" rel=""nofollow noreferrer"">[Live demo]</a></strong></p>

<hr>

<p>Also as @Pixelchemist <em>correctly</em> noted, there are important <a href=""http://en.cppreference.com/w/cpp/language/rule_of_three"" rel=""nofollow noreferrer"">rules of zero/three/five</a>. If your class contains resources which arent copied/destructed correctly them self, like pure pointers <strong>aren't</strong> (if you would use smart pointers, it would be different story), you have to implement these as well:</p>

<ul>
<li>copy constructor</li>
<li>copy assignment operator</li>
<li>destructor</li>
</ul>

<hr>

<ul>
<li>move constuctor</li>
<li>move assignment operator</li>
</ul>

<p>For extended informations read <a href=""https://stackoverflow.com/a/4172724/8254699"">this excellent answer about rule of three</a>.</p>
",0
46084224,46083966,0,"<blockquote>
  <p>But this will store the address of the variable str in t1.name</p>
</blockquote>

<p>Not exactly. <code>str.c_str()</code> does not return the address of variable <code>str</code>. It returns the address of the character array owned by <code>str</code>.</p>

<blockquote>
  <p>Instead I want the values of str to put in a char array member of the structure</p>
</blockquote>

<p>To do that, the structure must have a <code>char</code> array member. Your structure does not; it has a pointer member.</p>

<blockquote>
  <p>char array member of the structure which should be of exact same size as variable str.</p>
</blockquote>

<p>This is not possible. The size of the string is dynamic i.e. it may change at run time. The size of a member array must be known at compile time.</p>

<p>You can instead allocate an array dynamically. As the name implies, the size of dynamic allocation may be determined at run time. However, dynamic allocations must be manually deallocated, or else your program will leak memory.</p>

<blockquote>
  <p>or a better design</p>
</blockquote>

<p>A popular design pattern for dynamic allocation is <a href=""http://en.cppreference.com/w/cpp/language/raii"" rel=""nofollow noreferrer"">RAII</a>. The standard library already has a RAII container for character strings: <code>std::string</code>. So, to copy a string into a member of a struct, a good design is to have a string as the member:</p>

<pre><code>struct test {
    std::string name;
};

test t1;
t1.name = str;
</code></pre>
",0
35267632,35267581,4,"<p>It depends on the platform, but almost surely reading values from memory is more expensive than the operations on the CPU. But, on the topic of big o notation - it's not about which operation is more expensive. It's about the fact that the algorithm scales with the number of inputs (i.e. n).</p>
",4
37772967,37772830,0,"<p>You cannot access <code>std::list</code> elements with an index and square brackets. I recommend using a <code>std::vector</code> instead of a <code>std::list</code>. Then you can write:</p>

<pre><code>for (int i = 0; i &lt; BCD.size(); i++) {
    if (BCD[i].GetBankCustomerName() == name) {
       return true;
    }
}
</code></pre>

<p>Of course you could also do the same thing with a <code>list</code> but then you have to rewrite the loop using an iterator.</p>

<pre><code>std::list&lt;BankCustomerDetails&gt;::iterator iterator;
for (iterator = intList.begin(); iterator != intList.end(); ++iterator)
    if (iterator-&gt;GetBankCustomerName() == name) {
       return true;
    }
}
</code></pre>

<p>Still I recommend using the <code>vector</code> because it almost always has better performance.</p>

<p>Two more notes:</p>

<ul>
<li>List <code>itemBCD[i].Name</code> does not work because <code>Name</code>is private.</li>
<li>The comparison operator is <code>==</code> and not <code>=</code>.</li>
</ul>
",5
36557788,36557720,3,"<p>If <code>BYTE</code> is defined as:</p>

<pre><code>typedef unsigned char BYTE;
</code></pre>

<p>Then they are the same type. <code>BYTE</code> is just an alias (another name) for <code>unsigned char</code> and there's no need for any further conversions, as both <code>unsigned char</code> and <code>BYTE</code> refer to the exact same type.</p>

<p>In case an API provides an alias such as <code>BYTE</code> it is recommended to use the alias, because future versions of the API might change the meaning of this alias. If you use the <code>typedef</code> provided by the API rather explicitly using the type it refers to, it usually leads to less changes in your code.</p>
",0
35254268,35254127,0,"<p>Usually, you would allocate objects on the stack, because it is faster, and you do not need to delete it.</p>

<p>However, if you want to return a pointer you must allocate it on the heap. For example</p>

<pre><code>int *foo(int n)
{
    int *pn = new int(n);
    return pn;
}
</code></pre>

<p>Now the caller is responsible for freeing the memory.</p>

<pre><code>int main()
{
    try {
        int *ptr = foo(6);

        // use ptr

       delete ptr;
   } catch (std::bad_alloc &amp;ba) {
       std::cerr &lt;&lt; ba.what() &lt;&lt; '\n';
   }
}
</code></pre>

<p>Your mistake is to not store the return value of <code>new</code>. Without storing the return value, how will you use the memory? How will you free it? It's like paying for a ticket to the movies, but then throwing it out.</p>

<p>Your program has other mistakes. <code>main</code> must return <code>int</code>, not <code>void</code>. It is also a better idea to use the standard <code>getchar</code> function instead of <code>getch</code>.</p>

<p>I also added exception handling to the code, because <code>new</code> throws an exception when it can't allocate. Wrapping the entire <code>main</code> function code in a <code>try</code> block is a common idiom in C++ code.</p>
",1
35254284,35254127,4,"<p>&ldquo;Anonymous object&rdquo; is not a standard term, it's a descriptive term. I would interpret it as an object without a name. Objects with names are called variables or data members.</p>

<ol>
<li><p>In the expression <code>MyClass().disp()</code> you're calling the member function <code>disp</code> on a <strong>temporary object</strong> of class <code>MyClass</code>. The lifetime of the temporary object extends <sup>[1]</sup>to the end of the full expression. Which in C++ standardese, if I recall correctly, is called the <em>full-expression</em>.</p></li>
<li><p>The <code>new</code>-expression <code>new MyClass</code> allocates memory for a new <code>MyClass</code> object, and creates a new <code>MyClass</code> object in that chunk of memory. The expression produces a pointer to the new object. You can store that pointer in a variable and use it in a later <code>delete</code> expression to destroy the object and deallocate its memory.</p></li>
<li><p>The expression <code>new MyClass(300)</code> is the same except an argument is provided for the <code>MyClass</code> constructor. The <code>new</code>-expression syntax also provides a notation to specify arguments to the allocation operation. But that's more advanced, very seldom needed, and anyway, as a beginner you should preferentially never use raw <code>new</code> or <code>delete</code>, but instead standard library containers and strings.</p></li>
</ol>

<p>If there is no corresponding <code>delete</code> for a <code>new</code> then the object lives till the end of the program execution. If this is a machine with an operating system then the OS will reclaim the memory. However, the OS knows nothing about C++ objects so the object destructor is then not called, and hence cleanup specified in the destructor will not be performed.</p>

<p>You ask where <code>new</code> is useful. Generally when the desired lifetime for an object does not fit a scope (the nested lifetimes of local automatic variables), and/or where one needs a dynamic size object. Using <code>new</code> to control lifetime is less of an issue with efficiently movable objects as in C++11 and later, and for dynamic size preferentially use containers such as <code>std::vector</code> and strings like <code>std::string</code>.</p>

<p><sup>
<sup>[1]</sup> More generally a temporary object can be bound directly to a local reference, in which case its lifetime is extended to the lifetime of the reference, i.e. out the enclosing block.
</sup></p>
",3
35255843,35254127,0,"<p>In addition to <a href=""https://stackoverflow.com/a/35254284/1621391"">Cheers and hth. - Alf</a>'s answer, I will however add this...</p>

<p>If you <strong>really want</strong> <em>and</em> <strong>have</strong> to create a temporary object of class <code>Bar</code> on the heap, just use <a href=""http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared"" rel=""nofollow noreferrer"">std::make_shared</a> (C++11) or <a href=""http://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique"" rel=""nofollow noreferrer"">std::make_unique</a> (C++14)....</p>

<p>Example:</p>

<pre><code>std::make_unique&lt;Bar&gt;()-&gt;foo()
std::make_shared&lt;Bar&gt;()-&gt;foo()
</code></pre>

<p>The above creates <code>Bar</code> and calls it's method <code>foo()</code>. <code>Bar</code>'s destructor is called after <code>foo()</code> completes, and invariably its associated memory deleted....</p>

<p>Its possible to code a simple class and function like that in older C++ but, it can't be generic because of <a href=""http://en.cppreference.com/w/cpp/language/variadic_arguments"" rel=""nofollow noreferrer"">variadic templates</a> and <a href=""http://en.cppreference.com/w/cpp/utility/forward"" rel=""nofollow noreferrer"">perfect forwarding</a></p>

<p>Free advice: Avoid any circumstances that ever requires the above... even the code below (supposedly more efficient than heap) is usually frowned at in code reviews</p>

<pre><code>Bar().foo()
</code></pre>
",0
46614656,46614639,6,"<p>A smart pointer like <code>std::unique_ptr</code> only encapsulates the resource management. It doesn't change the semantics of pointers or polymorhpic use of types.</p>

<p>So you'll be deleting a <code>B</code> via a pointer to an <code>A</code> without a virtual d'tor, and that would still be undefined behavior. Just like with a raw pointer.</p>
",0
36780203,36779335,0,"<p>Vector &amp; list are worst to use if you don't sort them, you don't want loop through all.
I suggest you use map, even tho building the entire map might take longer (nlogn). I still recommend it, since the runtime for searching is log(n) which is pretty fast! </p>

<blockquote>
  <p>""speed of searching is important""</p>
</blockquote>
",0
36780568,36779335,0,"<p>I'd suggest something like a class which contains a vector of your id/string pairs, an unordered_map which maps id to an iterator or reference into that vector, and an unordered_map which maps a string to an iterator or reference into that vector. Then, two search functions in the class which look up the id/string pair based on the id or a string.</p>
",2
42615017,30775992,-1,"<p>15 8 means if the sum is odd diff is even or vice </p>
",1
36811421,36811388,6,"<p><strong>No.</strong></p>

<p>Your second snippet of code is the proper/correct/best/clearest/easiest way to do it.</p>

<p>Don't try to be too clever.</p>
",0
36811519,36811388,6,"<p>You can do it like this:</p>

<pre><code>if(int e = MyFunction())
{
    MessageBox(e);
}
</code></pre>

<p>This works because <code>int</code> naturally converts to <code>bool</code> so the <code>if()</code> succeeds when <code>e</code> is any <em>non-zero</em> value (or if it converts to <code>true</code> bool value).</p>

<p>The benefit of this is that you don't litter the surrounding scope with error return values. Though it may not be as immediately obvious to some coders as separating the function call from the test.</p>
",2
36812043,36811388,0,"<p>Not exactly what you wanted, but if the cause is only in record appearance you can use <code>for</code> instead <code>if</code>:<br></p>

<pre><code>for(int e = MyFunction(); e!=0; e=0) MessageBox(e);
</code></pre>

<p>BUT I'm not sure there are any reasons to replace normal clear code to statements like this. Nobody will recommend you such solutions.</p>
",0
38298447,38298371,0,"<p>From what I understand, the following function is what you are looking for. It will count the number of occurrences of <code>\n</code> and return back the count. You can refactor it to output the number of the lines every time it finds a new line (See the comment below)</p>

<pre><code>int count_new_lines(string s) {
    int count = 0;

    for (int i = 0; i &lt; s.size(); i++)
       if (s[i] == '\n') 
       {
          count++;
          //Output to file the number of the line
       }

    return count;
}
</code></pre>

<p><i>EDIT</i>:
Since you need to go through a whole vector of strings, and assuming that you need to count line numbers in all of the string objects inside that vector, this is what you've got to do: </p>

<pre><code>int count_new_lines(vector&lt;string&gt; stringVector) {
    int count = 0;
    for (int strings = 0; strings &lt; stringVector.size(); strings++)
    {
       string s = stringVector[strings];
       for (int i = 0; i &lt; s.size(); i++)
          if (s[i] == '\n') 
          {
            count++;
            //Output to file the number of the line
          }
    }
    return count;
}
</code></pre>

<p>This will return the total number of lines in all string objects within that vector of yours. For better performance and other benefits consider passing vector as a reference or a pointer, but these are a bit more advanced topics.</p>

<p>For future reference - this function would greatly benefit from using references and pointers instead of copying objects like in the following line:</p>

<pre><code>string s = stringVector[strings];
</code></pre>
",12
38300667,38298371,0,"<p>To find the number of occurrences of a character in a string, we can use</p>

<pre><code>    size_t count = std::count(str.begin(), str.end(), '\n');
</code></pre>

<p>e.g.</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

int main() {
    std::string str(""hello\nworld\n"");
    std::cout &lt;&lt; std::count(str.begin(), str.end(), '\n');
}
</code></pre>

<p><a href=""http://ideone.com/mxRpKd"" rel=""nofollow"">http://ideone.com/mxRpKd</a></p>

<p>According to your comments in another answer you want to get the total count across a vector of strings:</p>

<pre><code>size_t vec_char_count(const std::vector&lt;std::string&gt;&amp; vec, char c) {
    size_t count = 0;
    for (const auto&amp; str : vec) {
        count += std::count(str.begin(), str.end(), c);
    }
    return count;
}
</code></pre>

<p>Demo: <a href=""http://ideone.com/DAkWRj"" rel=""nofollow"">http://ideone.com/DAkWRj</a></p>
",1
35274769,35274703,8,"<p><code>s.find_first_of(""p"")</code> returns a <code>size_t</code> which is an <code>unsigned</code> type.</p>

<p>The <code>&gt;</code> operator will convert <code>-1</code> to an unsigned type before <code>s.find_first_of(""p"")&gt;-1;</code> is evaluated. That's how C++ works: if an operator that takes two arguments encounters a <code>signed</code> and an <code>unsigned</code> type as those arguments, then the <code>signed</code> one gets converted to an <code>unsigned</code> one.</p>

<p><code>-1</code> when converted to an unsigned type will be a large positive number. (In fact, it will <em>wrap around</em> to the largest value of <code>size_t</code>.)</p>

<p>So your comparison evaluates to <code>false</code>.</p>

<p>To check if a character is not in a string, use <code>b = s.find_first_of(""p"") != string::npos;</code></p>
",2
35275165,35274703,3,"<p><code>std::string::find_first_of()</code> return value is of type <code>size_t</code>, and that's typedef for some unsigned type. In order to compare to integer{-1}, compiler should yield a common type. According to the standard <em>usual arithmetic conversions</em>:</p>

<blockquote>
  <p>If the operand that has unsigned integer type has rank greater than or equal to the
  rank of the type of the other operand, the operand with signed integer type shall be converted to
  the type of the operand with unsigned integer type.</p>
</blockquote>

<p>That means, something like that happens:</p>

<pre><code>bool b = s.find_first_of(""p"")&gt;static_cast&lt;unsigned&gt;(-1);
</code></pre>

<p>You could compile following simple program to observe the behavior.</p>

<pre><code>#include &lt;iostream&gt;

int
main()
{
  int i = -1;
  std::cout &lt;&lt; static_cast&lt;unsigned&gt;(i);
}
</code></pre>
",0
36340207,36339969,1,"<p>You may specialize the function instead:</p>

<pre><code>#include &lt;iostream&gt;

class AbstractBase
{
    public:
    // You should have a virtual destructor:
    virtual ~AbstractBase() {}
    virtual void func() = 0;
};

enum class Opts
{
    FOO, BAR
};

template&lt;Opts opt&gt;
class Derived: public AbstractBase
{
    public:
    void func() override;
};

template&lt;&gt;
void Derived&lt;Opts::FOO&gt;::func()
{
    std::cout &lt;&lt; ""Foo"" &lt;&lt; ""\n"";
}

template&lt;&gt;
void Derived&lt;Opts::BAR&gt;::func()
{
    std::cout &lt;&lt; ""BAR"" &lt;&lt; ""\n"";
}

int main()
{
    Derived&lt;Opts::FOO&gt; foo;
    AbstractBase&amp; bfoo = foo;
    bfoo.func();
    Derived&lt;Opts::BAR&gt; bar;
    AbstractBase&amp; bbar = bar;
    bbar.func();
}
</code></pre>

<p>However, I consider mixing dynamic polymorphism (virtual) and static polymorphism (templates) a bad design (there might be exemptions).</p>
",1
36340091,36339969,1,"<p>Just specialize the class template for each to-be-treated-specially enum value, e.g.,</p>

<pre><code>enum class Opts{foo, bar};

template&lt;Opts opt&gt;
class Derived;

template&lt;&gt;
class Derived&lt;Opts::foo&gt;
    : public AbstractBase
{
public:
    void func() override
    {
        std::cout &lt;&lt; ""Foo"" &lt;&lt; ""\n"";
    }
};

template&lt;&gt;
class Derived&lt;Opts::bar&gt;
    : public AbstractBase
{
public:
    void func() override
    {
        std::cout &lt;&lt; ""bar"" &lt;&lt; ""\n"";
    }
};
</code></pre>

<p>Where you want some general common stuff that's not in <code>AbstractBase</code>, you can either inherit it in, or add it in via CRTP in a most derived class.</p>

<p>Disclaimer: off the cuff code, not compiled.</p>
",0
35206192,35206128,3,"<p>Since <code>vipList</code> is a <code>const list&lt;member&gt;&amp;</code> you need to use <code>list&lt;member&gt;::const_iterator</code> as that is what <code>begin()</code> will return.  You could also use <code>auto</code> and let the compiler pick the right type.</p>

<p>Instead of doing all of this we could just use <a href=""http://en.cppreference.com/w/cpp/algorithm/minmax_element"" rel=""nofollow""><code>std::minmax_element</code></a> which will return a pair of iterators the min and max values.  We can do that with the list using a lambda like</p>

<pre><code>return std::minmax_element(vipList.begin(), vipList.end(), [](const member &amp; lhs, const member&amp; rhs) { return lhs.level &lt; rhs.level; });
</code></pre>

<p>This will return a <code>std::pair&lt;std::list&lt;member&gt;::const_iterator, std::list&lt;member&gt;::const_iterator&gt;</code>.  If you want it to return a <code>std::pair&lt;float, float&gt;</code> then we need to capture the return of <code>std::minmax_element</code> and dereference the iterators to get the underlying floats.</p>

<pre><code>auto ip = std::minmax_element(vipList.begin(), vipList.end(), [](const member &amp; lhs, const member&amp; rhs) { return lhs.level &lt; rhs.level; });
return std::make_pair(ip.first-&gt;level, ip.second-&gt;level);
</code></pre>
",10
39657674,39657583,0,"<p>The third parameter is number of bytes. Which is 4*4=16 for your case.</p>

<p><a href=""http://www.cplusplus.com/reference/cstring/memset/"" rel=""nofollow"">memset</a></p>
",0
39657724,39657583,1,"<p><code>memset</code> sets 16 bytes (not bits) to 0. This is correct because the size of your array is 16 bytes, as you correctly stated (4 integers x 4 bytes per integer). <code>sizeof</code> knows the number of elements in your array and it knows the size of each element. As you can see in the docs, the third argument of <code>memset</code> takes the number of bytes, not the number of elements. <a href=""http://www.cplusplus.com/reference/cstring/memset/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstring/memset/</a></p>

<p>But be careful with using <code>sizeof()</code> where you pass array as <code>int x[]</code> or <code>int* x</code>. For example the following piece of code will not do what you expect:</p>

<pre><code>void foo(int arr[]) {
  auto s = sizeof(arr); // be careful! this won't do what you expect! it will return the size of pointer to array, not the size of the array itself
  ...
}

int a[10];
foo(a);
</code></pre>
",0
39657746,39657583,0,"<p>Actually the first solution is the correct one.</p>

<p>The function <a href=""http://www.cplusplus.com/reference/cstring/memset/"" rel=""nofollow""><code>memset</code></a> takes as third parameter the <em>number of bytes</em> to set to zero.</p>

<blockquote>
  <p><em>num</em>:
  Number of bytes to be set to the value.</p>
</blockquote>

<p><a href=""http://en.cppreference.com/w/cpp/language/sizeof"" rel=""nofollow""><code>sizeof</code></a> returns the number of bytes occupied by the expression. </p>

<p>In your case <code>sizeof(arr) = 16</code> which is exactly yhe number of bytes requested by <code>memset</code> function.</p>

<hr>

<p>Your second solution:</p>

<pre><code>memset(arr, 0, sizeof(arr)/sizeof(*arr));  // Note that: sizeof(arr)/sizeof(*arr) == 16 / 4 (generally) == 4 bytes
</code></pre>

<p>will set only the first 4 bytes to zero, that is the first integer of the array. So that solution is wrong if your intent is to set each element of the array to zero.</p>
",0
36352669,36352517,1,"<p>In an <code>ifstream</code> you should use <a href=""http://www.cplusplus.com/reference/istream/istream/seekg/"" rel=""nofollow""><code>seekg()</code></a> instead of <a href=""http://www.cplusplus.com/reference/ostream/ostream/seekp/"" rel=""nofollow""><code>seekp()</code></a>, because you want to set the position for reading and not the position for writing. </p>

<p><a href=""http://www.cplusplus.com/reference/fstream/ifstream/"" rel=""nofollow""><code>ifstream</code></a> and <a href=""http://www.cplusplus.com/reference/fstream/ofstream/"" rel=""nofollow""><code>ofstream</code></a> have only the one of the two function.  An <a href=""http://www.cplusplus.com/reference/fstream/fstream/"" rel=""nofollow""><code>fstream</code></a> can do both, but beware if it's for reading or writing.  <a href=""https://www.daniweb.com/programming/software-development/threads/6542/fstream-tutorial"" rel=""nofollow"">This tutorial</a> (especially the section about random access) could be of interest for you. </p>
",2
36352677,36352517,1,"<p>There is no <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream/seekp"" rel=""nofollow""><code>seekp</code></a> for <a href=""http://en.cppreference.com/w/cpp/io/basic_istream"" rel=""nofollow""><code>istream</code></a>.
You probably meant either <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/seekg"" rel=""nofollow""><code>seekg</code></a>, or you wanted to use an <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream"" rel=""nofollow""><code>ostream</code></a> instead (which does have <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream/seekp"" rel=""nofollow""><code>seekp</code></a>).</p>

<p>Judging by your code, you seem to want input from the file, so <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/seekg"" rel=""nofollow""><code>seekg</code></a> with your <a href=""http://en.cppreference.com/w/cpp/io/basic_istream"" rel=""nofollow""><code>istream</code></a> is appropriate here.</p>

<p>Bear in mind that <a href=""http://en.cppreference.com/w/cpp/io/basic_ifstream"" rel=""nofollow""><code>ifstream</code></a> and <a href=""http://en.cppreference.com/w/cpp/io/basic_ofstream"" rel=""nofollow""><code>ofstream</code></a> are subtypes of <a href=""http://en.cppreference.com/w/cpp/io/basic_istream"" rel=""nofollow""><code>istream</code></a> and <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream"" rel=""nofollow""><code>ostream</code></a> respectively.</p>

<hr>
",0
36240380,36240166,2,"<p>As you mention, it looks like the long double difference is equal to the <em>float</em> precision (it is the double precision, though).</p>

<p>Literal floating points, like literal integers, can be <a href=""http://en.cppreference.com/w/cpp/language/floating_literal"" rel=""nofollow"">followed by a suffix</a> so the conversion makes use of a specific type. By default, the type is double.</p>

<p>There is what you should have to get the wanted precision:</p>

<pre><code>float a = 145.5678f;
double b = 145.5678;
long double c = 145.5678l;
</code></pre>

<p>The 'f' (or 'F') for <code>floats</code> and 'l' (or 'L') for <code>long double</code>.</p>
",1
36512461,36512073,1,"<p>The code you pasted is printing the contents of the file <code>datos.txt</code> into <code>stdout</code>. Just make sure the file is placed in the directory the program is ran in.</p>

<p>also this <em>specific method</em> is not related to <strong>Qt</strong>, this is using the <strong>Standard C++ library</strong>.</p>
",1
36754967,36752872,1,"<blockquote>
  <p>The calculator class has a const member function called calculateStart() which sets (i.e. modifies) the reference returned from calling the Parms() function in the Calculator class.</p>
</blockquote>

<p>Yes, <code>calculateStart()</code> does modify the Calculator object, which is unexpected considering the final const qualifier in its definition.<br><br>
Why ? Look at definition of <code>inline const ParmsPtr&amp; Layout::parms() const</code>; the final <code>const</code> tells the compiler that the function will not modify the <code>Layout</code> object, though it actually does. How ? By mischeviously <code>const_cast</code>'ing the object to a non-const object; that's where the constness is broken and that's why <code>setParms()</code> can be called.<br><br>
This is a bad practice, though there may be some reasons to do it. In such cases, <code>const_cast</code> serves this purpose.</p>
",0
41205460,41205394,3,"<p><code>nodes.begin()</code> returns an iterator, therefore you need to dereference the iterator to get to the object.</p>

<pre><code>for (auto n = nodes.begin(); n != nodes.end(); ++n)
    (*n)-&gt;save(outfile);
</code></pre>

<p><a href=""http://ideone.com/HcClHr"" rel=""nofollow noreferrer"">Live Example</a></p>

<p>Also just a tip:  Make the parameter to <code>save</code> a <code>std::ostream&amp;</code>.  This gives the <code>save</code> function more flexibility if the output stream is not a file.</p>
",0
41205474,41205394,-1,"<p>You can use:</p>

<pre><code>TYPE&amp; dynamic_cast&lt;TYPE&amp;&gt; (object);
</code></pre>

<p>To try to figure out the class that you are calling in your loop, then call the method for the class that you expect to have it.</p>
",0
41205491,41205394,1,"<p>You should dereference the iterator.</p>

<p>There are two ways to solve your problem: the easiest is:</p>

<pre><code>for (auto n: nodes) 
      n-&gt;save(outfile);
</code></pre>

<p>The other is to convert the iterator into a reference to the element of the vector (a pointer to the object):</p>

<pre><code>for (auto n = nodes.begin(); n != nodes.end(); ++n) {
   auto &amp;el = *n;
   el-&gt;save(outfile);
}
</code></pre>

<p>But, why do you store pointers? why don't you simply store the objects themselves in the vector?</p>

<pre><code>std::vector&lt;BaseNode&gt; nodes;
nodes.push_back(BiasNode());
nodes.push_back(InputNode());

for (auto n: nodes) 
   n.save();
</code></pre>
",4
41205516,41205394,0,"<pre><code>for (auto n = nodes.begin(); n != nodes.end(); ++n) 
    n-&gt;save(outfile); //here's the issue
</code></pre>

<p>Here, n is the iterator. Dereference it to use like this :</p>

<pre><code>(*n)-&gt;save(outfile);
</code></pre>

<p>Or simply (after C++11)</p>

<pre><code>for (auto n : nodes) 
    n-&gt;save(outfile);
</code></pre>
",0
38498056,38497960,1,"<p>It's hard to answer since you did not post any of the source code. But it seems that you tried to use a char array as key to a map. That will not work. Use <code>std::string</code> instead.</p>

<p><code>std::map&lt;std::string,journey_plan::contact_details&gt;</code></p>

<p>Edit: You <em>can</em> use char arrays as keys, following this question: <a href=""https://stackoverflow.com/questions/4157687/using-char-as-a-key-in-stdmap"">Using char* as a key in std::map</a></p>
",0
35248062,35248009,1,"<p>Wish I could just comment this:</p>

<p>All instances of the line <code>Node *tmp = new Node;</code> should read <code>Node *tmp = new Node();</code></p>
",1
35248146,35248009,0,"<p>Creating a Node wont create the structure that Reservation *data; tries to point to, and so you try to access non initialized memory.
You need to initialize data:
tmp->data = new Reservation();</p>
",0
35248640,35248009,0,"<p>Don't use pointers if you don't have to. In this example <code>Node</code> has to be a pointer, because the list may have zero nodes, or 1000 nodes, so we need pointers to dynamically allocate memory on demand.</p>

<p>But <code>(Reservation)data</code> does not have to be a pointer. Each node always has one <code>Reservation</code> member.</p>

<p>If you do declare it as pointer then you must allocate it, and free it when it is no longer needed.</p>

<p><code>head</code> should be initialized to <code>NULL</code>, because the single linked-list has no nodes when it is initialized. The first node inserted becomes the head. </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class Reservation 
{
private:
    int ID;
    string reservedNumber;
public:

    int getID() { return ID; }
    string getResevNum() { return reservedNumber; }

    void setId(int x) { ID = x; }
    void setReseNum(string y) { reservedNumber = y; }
};

class ReservationCollection
{
public:
    struct Node
    {
        Reservation data;
        Node *next;
    };

    ReservationCollection();
    ~ReservationCollection();

    void addBook(int id, string book);

    Node* getHead() { return head; }

private:
    Node *head;
};

ReservationCollection::ReservationCollection()
{
    head = NULL;
}

ReservationCollection::~ReservationCollection()
{
    Node *p = head;
    while (p)
    {
        Node *next = p-&gt;next;
        cout &lt;&lt; ""delete: "" &lt;&lt; p-&gt;data.getID() &lt;&lt; "", "" &lt;&lt; p-&gt;data.getResevNum() &lt;&lt; endl;
        delete p;
        p = next;
    }
}

void ReservationCollection::addBook(int id, string book)
{
    Node *node = new Node;
    node-&gt;data.setId(id);
    node-&gt;data.setReseNum(book);

    //this element is the last element
    node-&gt;next = NULL;

    if (!head)
    {
        //first element inserted
        head = node;
        head-&gt;next = NULL;
    }
    else
    {
        //find the previous node in the list
        Node *prev = head;
        while (prev-&gt;next)
            prev = prev-&gt;next;

        //this node is after previous node
        prev-&gt;next = node;
    }

    cout &lt;&lt; ""Good\n"";
}

int main()
{
    ReservationCollection list;
    list.addBook(0, ""Book0"");
    list.addBook(1, ""Book1"");
    list.addBook(2, ""Book2"");
    list.addBook(3, ""Book3"");

    ReservationCollection::Node *p = list.getHead();

    while (p)
    {
        ReservationCollection::Node *next = p-&gt;next;
        cout &lt;&lt; p-&gt;data.getID() &lt;&lt; "", "" &lt;&lt; p-&gt;data.getResevNum() &lt;&lt; endl;
        p = next;
    }
}
</code></pre>
",0
42506849,42506605,2,"<p>It's actually quite simple.</p>

<p>Initialize the array with 50 1s on the first positions and the rest with 0s. Then use  <a href=""http://en.cppreference.com/w/cpp/algorithm/random_shuffle"" rel=""nofollow noreferrer""><del>std::random_shuffle</del> std::shuffle</a> on the whole array.</p>
",0
38393649,38378852,1,"<p>The problem has nothing to do with opening files. The program hangs in an infinite loop at lines 28-34 while(!successful).</p>
",1
36333428,36310399,0,"<p>My apologies for a very poorly worded question that was to long and bulky to make much sense of. Luckily I have found my own answer to be much easier then initially anticipated. </p>

<pre><code>double Particle::timeToCollision(const Particle particle){

    Vector r2=particle.getPosition();
    Vector r1=p;
    Vector v2=particle.getVelocity();
    Vector v1=v;
    Vector r0=r2-r1;
    Vector v=v2-v1;

    double modv;
    double tca = ((--r0).dot(v)) / v.modulusSqr();
    double bsqr;

    double result=0;

    double rColTestx=r0.GetX()+v.GetX()*tca;
    double rColTesty=r0.GetY()+v.GetY()*tca;
    double rColTestz=r0.GetZ()+v.GetZ()*tca;

    Vector rtColTest(rColTestx, rColTesty, rColTestz);


    modv=getVelocity().modulus();

    cout &lt;&lt; ""start "" &lt;&lt; endl;

    if(modv&lt;0.0000001){
        cout &lt;&lt; ""a"" &lt;&lt; endl;
        result=FLT_MAX;
    }else{
        cout &lt;&lt; ""b"" &lt;&lt; endl;

        if (tca &lt; 0) {
            cout &lt;&lt; ""c"" &lt;&lt; endl;
            result=FLT_MAX;
        }else{
            cout &lt;&lt; ""d"" &lt;&lt; endl;
            Vector s(v.GetX(), v.GetY(), v.GetZ());
            s.Scale(tca);

            cout &lt;&lt; getVelocity().GetX() &lt;&lt; endl;
            cout &lt;&lt; getVelocity().GetY() &lt;&lt; endl;
            cout &lt;&lt; getVelocity().GetZ() &lt;&lt; endl;


           double radsqr= radius*radius;

            bsqr=rtColTest.modulusSqr();

            if (bsqr &lt; 4*radsqr) {
                cout &lt;&lt; ""e"" &lt;&lt; endl;
                cout &lt;&lt; ""collision occurs"" &lt;&lt; endl;
                result = FLT_MAX;
            } else {
                cout &lt;&lt; ""collision does not occurs"" &lt;&lt; endl;
            }

        }

    }
    cout &lt;&lt; ""fin"" &lt;&lt; endl;
    return result;

}
</code></pre>

<p>Sorry its a large section of code. Also FLT_MAX is from the cfloat lib. I didn't stat this in my question. I found this to work for several examples I calculated on paper to check.</p>

<p>To be Clear, the <code>return result</code>and <code>result=0</code> were arbitrary. I later edit to return time but for this part didn't need or want that.  </p>
",0
36485187,36485120,1,"<p>You need to reset <code>correct</code> to 0 at the beginning of the <code>grade()</code> method.</p>
",1
38016690,38015784,1,"<p>Just try to use long long unsigned int x,i hope it helps</p>
",0
47697555,47697461,4,"<p>The fix to your problem is: </p>

<pre><code>while(i &lt;= 17){
    if(num%5 != 0){
        cout &lt;&lt; num &lt;&lt;endl;
        i++;
    }

    num++;
}
</code></pre>
",0
46023695,46022071,1,"<p>A functor is very easy to make.  And that's the only way of currying functions in pre 2011 c++.</p>

<p>Example:</p>

<pre><code>struct my_func_functor  // choose a name
{
    int curry_;
    my_func_functor(int curry) : curry_(curry) {}
    int operator()(int a) { return my_func(a, curry_); }
};


// to use...
vector&lt;int&gt; v;

//...

// build the functor with the curry and let transform do the cooking...
std::transform(v.begin(), v.end(), v.begin(), my_func_functor(555));
</code></pre>

<p>You can of course store anything you want in the functor.  including references.  This is the same model used behind the scene by C++11's lambdas.  Instead of a capture clause, you have a constructor, and a structure to hold the data to pass along when the actual call is made through the <code>operator()</code>.</p>
",2
39600515,39600038,0,"<p><strong>Why does the program output <code>24</code>?</strong></p>

<p>You are right, <code>12</code> is <code>0b1100</code> in its binary representation. That being said, it also is <code>0b001100</code> if you want. In this case, bitshifting to the left gives you <code>0b011000</code>, which is <code>24</code>. The program produces the excepted result.</p>

<p><strong>Where does this stop?</strong></p>

<p>You are using an <code>int</code> variable. Its size is typically 4 bytes (32 bits) when targeting 32-bit. However, it is a bad idea to rely on <code>int</code>'s size. Use <a href=""http://en.cppreference.com/w/cpp/types/integer"" rel=""nofollow"">stdint.h</a> when you need specific sizes variables. </p>

<p><strong>A word of warning for bitshifting over signed types</strong></p>

<p>Using the <code>&lt;&lt;</code> bitshift operator over negative values is undefined behavior. <code>&gt;&gt;</code>'s behaviour over negative values is implementation-defined. In your case, I would recommend you to use an <code>unsigned int</code> (or just <code>unsigned</code> which is the same), because <code>int</code> is signed.</p>

<p><strong>How to get the result you except?</strong></p>

<p>If you know the size (in bits) of the number the user inputs, you can use a bitmask using the <code>&amp;</code> (bitwise AND) operator. e.g.</p>

<pre><code>result = (number &lt;&lt; 1) &amp; 0b1111; // 0xF would also do the same
</code></pre>
",0
47462534,47110820,0,"<p>I eventually figured this one out. Here's the code I came up with:</p>

<pre><code>/***********************************************************************
* Program:
*    Assignment 31, Array Design
*    Sister Unsicker, CS124
* Author:
*    Lanie Molinar
* Summary:
*    This program gets 10 grades from the user, averages them, and displays 
*    the result. It doesn't count -1 as a completed assignment, so it won't 
*    count it when it computes the average.
*
*    Estimated:  2.0 hrs
*    Actual:     4.0 hrs
*      I had a lot of trouble making my code pass all 3 tests in testbed. I 
*      kept failing at least one every time. After working on it for a while,
*      though, I finally got it working.
************************************************************************/

#include &lt;iostream&gt;
using namespace std;

#define NUMGRADES 10

/***********************************************************************
* The function getGrades gets 10 grades from the user, passing them to main().
***********************************************************************/
void getGrades(int grades[], int num)
{
   for (int i = 0; i &lt; num; i++)
   {
      cout &lt;&lt; ""Grade "" &lt;&lt; i + 1 &lt;&lt; "": "";
      cin &gt;&gt; grades[i];
   }
   return;
}

/***********************************************************************
* The function averageGradesGrades averages the grades inputted by the user
* and returns that value to main(). It doesn't count -1's as completed 
* assignments, and if the user enters -1 for all grades, it outputs dashes 
* instead of the average.
***********************************************************************/
void averageGrades(int grades[], int num)
{
   int sum = 0;
   int notCompleted = 0;
   int average;
   for (int i = 0; i &lt; num; i++)
   {
      if (grades[i] != -1)
         sum += grades[i];
      else
         notCompleted++;
   }
   if (sum != 0)
      average = sum / (num - notCompleted);
   if (notCompleted != num)
      cout &lt;&lt; average;
   else
      cout &lt;&lt; ""---"";
}

/**********************************************************************
*    The main function calls getGrades and averageGrades and displays the
*   result returned by averageGrades.
***********************************************************************/
int main()
{
   int grades[NUMGRADES];
   getGrades(grades, NUMGRADES);
   cout &lt;&lt; ""Average Grade: "";
   averageGrades(grades, NUMGRADES);
   cout &lt;&lt; ""%\n"";
   return 0;
}
</code></pre>
",0
36607755,36607128,3,"<p>Using the first snippet you posted, I called the Update method as below, and no  ""Unable to Read Memory"" issue arose.</p>

<pre><code>int main()
{
  shared_ptr&lt;ModelCommand&gt; fc(new FolderCommand(""somestring\\""));
  CModel mod;

  mod.Update(fc);
  mod.print_folder();

  return 0;
}
</code></pre>

<p>I think that would  be interesting to see how the Update method is being used.</p>

<p>Obs.: I added a public member function, print_folder, to print ou the _folder private member. Also, I'd make just a comment, however I still don't have this privilege.</p>
",5
43943035,43942913,5,"<blockquote>
  <p>I am askign the reason of using <code>static</code> pointer instead of just returning pointer</p>
</blockquote>

<p>The member function is static, but the pointer it returns is not. The object the function creates is allocated dynamically, and should be deleted in the same way that you delete other objects.</p>

<p>The reason the member function is marked <code>static</code> is to let you run it without creating an instance of the object, i.e.</p>

<pre><code>A* myObj = A::create();
</code></pre>

<p>as opposed to</p>

<pre><code>A obj;
A* objPtr = obj.create();
</code></pre>

<p>which defeats the purpose of defining a factory function in the first place.</p>

<p>Keyword <code>static</code> is not repeated at the point the member function is defined in accordance with C++ syntax: the compiler already knows from the declaration that <code>A::create</code> is <code>static</code>, so there is no need to repeat this information.</p>
",1
37035109,37034999,3,"<p>The problem is you are at the end of the file when you go to actually store the data.</p>

<pre><code>while(getline(openFile, line)){
    ++counter;
}
</code></pre>

<p>Reads the file all the way to the end and then sets the EOF flag on the string.  Then you get to</p>

<pre><code>while(! openFile.eof()){
     for(int i = 0; i &lt; counter; i++){
        getline( openFile, a[i], '/');
        getline( openFile, b[i], '/');
        getline( openFile, c[i], '/');
        getline( openFile, d[i]);
    }
}
</code></pre>

<p>And since the EOF flag is set the while loop is never executed.  Since all you really need counter for is the the display loop at the end we can combine the counter loop and the reading loop into one loop like</p>

<pre><code>while(getline( openFile, a[counter], '/') &amp;&amp; getline( openFile, b[counter], '/') &amp;&amp;
      getline( openFile, c[counter], '/') &amp;&amp; getline( openFile, d[counter])){
    counter++;
}
</code></pre>

<p>And now we read in the full file and get a count of the number of lines read.</p>
",5
39253375,39253332,0,"<p>Typo here. You can not do modulo operation on an array. <code>a%2==0</code> should be <code>a[i]%2==0</code>. Also change <code>&amp;&amp;</code> to <code>||</code> as you are trying to find ""either a negative number <code>or</code> a even number"".</p>
",1
39253423,39253332,0,"<p>Two things:</p>

<ol>
<li>You are modulo-ing an array <code>a</code> with an integer <code>2</code>. You should dereference it to get the value: <code>a[i] % 2 == 0</code>.</li>
<li>You do a boolean AND, where you want a boolean OR (according to your question): <code>||</code> instead of <code>&amp;&amp;</code>.</li>
</ol>
",0
37631819,37631740,0,"<p><code>value</code> is a double. When you type |, it won't be read as a number, and <code>value</code> won't be set. Instead, a failure bit should be set in cin.</p>

<p>Comparing <code>value == '|'</code> checks to see if <code>value</code> equals the numeric value of the ASCII character |, which happens to be 124¡ªthat's not what you want.</p>
",0
37631845,37631740,0,"<p>Your program expects two inputs, everytime, in your loop.</p>

<p>If you want to stop at the first input, then you need to read the input in two steps.</p>

<p>Also, your <code>value</code> is a number, not a string, you can't read numbers and strings the same way.</p>

<pre><code>while (1) {
    string tmp;
    if (!(cin &gt;&gt; tmp)) {
        break;
    }

    if (tmp == ""|"") {
        break;
    }

    //convert string into double
    value = stod(tmp); //todo, check conversion was well done

    if (! (cin &gt;&gt; unit) ) {
        break;
    }

    // rest of code
}
</code></pre>
",0
37631848,37631740,0,"<p><code>""|""</code> is not what can be interpreted as <code>double</code>, so you should use <code>std::string</code> to read the input.</p>

<p>Your code should be like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using std::cin;
using std::cout;
using std::stod;
using std::string;

int main()
{ 
  double value;
  double realvalue;
  double lowest = 0;
  double highest = 0;
  string value_str;
  string unit;
  string highest_unit;
  string lowest_unit;
  cout &lt;&lt; ""Please enter a number follow by a unit: "";

  //convert units to cm for all
  while (cin &gt;&gt;value_str&gt;&gt;unit)
  {
    if (value_str == ""|"") // use string literal, not character constant
    {
       cout &lt;&lt; lowest &lt;&lt; lowest_unit &lt;&lt; "" is the lowest number.\n"";
       cout &lt;&lt; highest &lt;&lt; highest_unit &lt;&lt; "" is the highest number. \n"";
       break;
    }
    value = stod(value_str);

    // do works with value and unit
    cout &lt;&lt; value &lt;&lt; ""\t"" &lt;&lt; unit &lt;&lt; ""\n"";
  }
}
</code></pre>
",1
40761478,40457296,1,"<p>I have succeed on running examples with haptic feedback using sensable plugin. The sofa developers are still updating the sources of the framework. So I checked the master branch of their repository and build that sources. After that the examples with haptic feedback worked as it suppose to do. ¨C Ruslan Rakhmatov just now </p>
",0
36365280,36364888,1,"<p>The error occurs because
a) <code>operator*</code> is declared as non-template (you should use <code>&lt;&gt;</code>)
b) if you use <code>&lt;&gt;</code> syntax, you must provide the declaration of the template.</p>

<p>Fix
(Add before Matrix class):</p>

<pre><code>template&lt;class T, int m, int n&gt;
class Matrix;

template&lt;class T, int m, int n&gt;
Matrix&lt;T, m, n&gt; operator*(T&amp;, const Matrix&lt;T, m, n&gt;&amp;);

//class matrix definition here
</code></pre>

<p>Add <code>&lt;&gt;</code> to <code>operator*</code> <code>friend</code> declaration:</p>

<pre><code>friend Matrix&lt;T, m, n&gt; operator*&lt;&gt;(T&amp;, const Matrix&lt;T, m, n&gt;&amp;);
</code></pre>
",4
36733801,36733677,1,"<p>You are not updating the values of <code>townA</code> and <code>townB</code> in the loop. Hence, you never get out of the loop.</p>

<p>Also, you need to increment <code>years</code> in the loop. Use:</p>

<pre><code>while (townA &lt;= townB)
{
   finalA = ((growthA / 100) * (townA)) + townA;
   finalB = ((growthB / 100) * (townB)) + townB;
   cout &lt;&lt; ""Town A "" &lt;&lt; finalA &lt;&lt; endl;
   cout &lt;&lt; ""Town B "" &lt;&lt; finalB &lt;&lt; endl;

   // Update the values of the key variables.
   ++years;
   townA = finalA;
   townB = finalB;
}

// This needs to be moved from the loop.
cout &lt;&lt; ""It took Town A "" &lt;&lt; years &lt;&lt; "" years to exceed the population of Town B."" &lt;&lt; endl;
</code></pre>
",0
36484987,36484422,2,"<p>You can use <a href=""http://en.cppreference.com/w/cpp/thread/sleep_for"" rel=""nofollow"">sleep_for</a> or <a href=""http://en.cppreference.com/w/cpp/thread/sleep_until"" rel=""nofollow"">sleep_until</a> (<code>C++11</code>) to accomplish your task (in <code>&lt;thread&gt;</code>).<br>
And including <code>&lt;chrono&gt;</code> for time.</p>

<pre><code>int main()
{
    using namespace std::this_thread;
    using namespace std::chrono;

    vector&lt;int&gt; v { 1,2,3,4,5 };

    for (const auto&amp; i : v) {
        cout &lt;&lt; i &lt;&lt; '\n';
        sleep_for(seconds(1));
        // or sleep_until(system_clock::now() + seconds(1));
    }
}
</code></pre>

<p>And in <code>C++14</code> with chrono literals:</p>

<pre><code>sleep_for(1s);
</code></pre>
",1
40967477,40967311,3,"<p>You cannot store polymorphic types by value in a container.  What is actually happening when you call <code>push_back</code> is your values are being converted to a <code>DessertItem</code> before being added.</p>

<p>To make use of polymorphism in your container, it must store either a reference or a pointer.  You could define your storage as:</p>

<pre><code>std::list&lt;std::unique_ptr&lt;DessertItem&gt;&gt; dessertList;
</code></pre>

<p>And then:</p>

<pre><code>dessertList.emplace_back( std::make_unique&lt;Cookie&gt;( quantity, price ) );
dessertList.emplace_back( std::make_unique&lt;Candy&gt;( quantity, price ) );
</code></pre>

<p>Your loop is also not great.  Don't test for <code>eof</code>.  A naive fix for the loop is to convert it as follows:</p>

<pre><code>while( desserts &gt;&gt; type &gt;&gt; quantity &gt;&gt; price )
{
    // ...
}
</code></pre>
",5
36811170,36811104,12,"<p><strong>You're already doing it.</strong></p>

<p>When you write <code>cmap[2]</code>, and that element doesn't exist, it is created and default-constructed.</p>

<p>So, <code>cmap[2]</code> will be an empty list. Then you can <code>.push_back</code> to it whenever you like.</p>

<p>Since this process is also triggered by the <code>cmap[2]</code> in <code>cmap[2].push_back(..)</code>, you don't actually need the initial ""empty"" initialisation unless there's some requirement in your project for the key to exist in the map from the start (in which case, fair enough).</p>

<p>If you don't want an empty list to be the value but for there to be no value, I think that this is silly but you have some options:</p>

<ul>
<li>Don't add the key, either<br>
<em>(let the lack of the key <strong>mean</strong> lack of the value)</em>;</li>
<li>Store <code>std::unique_ptr&lt;std::list&lt;char&gt;&gt;</code> and start off with <code>nullptr</code><br>
<em>(yuk; dynamic allocation for no good reason; no thanks!)</em>;</li>
<li>Store <code>std::optional&lt;std::list&lt;char&gt;&gt;</code> and start off with <code>cmap[2] = std::none</code><br>
<em>(when <code>Boost.Optional</code> makes it into C++, which is happening but slowly)</em>.</li>
</ul>

<p>And&hellip; that's it.</p>
",5
36500470,36500392,1,"<pre><code>vector&lt;string&gt; vec;
vec.reserve(5);
vec[0].assign(""blabla"");
</code></pre>

<p>This causes undefined behavior. <code>vec[0]</code> has been reserved but not allocated. You should use push or emplace instead.</p>

<hr>

<pre><code>vector&lt;string&gt; vec;
vec.reserve(5);
vec[0].push_back('a');
</code></pre>

<p>Same error. You are pushing to <code>vec[0]</code> which is not exist in memory yet.</p>

<hr>

<p><strong>Solution:</strong></p>

<pre><code>vector&lt;string&gt; vec;
vec.reserve(5);
vec.emplace_back(""blabla""); //or push_back
</code></pre>

<p>Or:</p>

<pre><code>vector&lt;string&gt; vec;
vec.resize(5);// Notice resize not reserve
vec[0].assign(""blabla"");//this works now since vec[0] is exist
</code></pre>

<p>Or:</p>

<pre><code>vector&lt;string&gt; vec;
vec.resize(5);// Notice resize not reserve
vec[0].push_back('b'); //this works now since vec[0] is exist
</code></pre>

<p>I do <strong>NOT</strong> prefer the second option since it causes construction N times then assignment N times</p>
",0
43223693,43223348,0,"<p>""When a class has virtual bases it's common for a constructor to result in two different function bodies being emitted - one for use when this class is the most derived type, and one for use when this class is itself a base class. The reason is that virtual base classes are constructed by the most-derived class, to ensure that when they're shared they're only constructed once. So the first version of the constructor will call all base class constructors, whereas the second version will only call constructors for non-virtual bases.""</p>

<p>in this the answerer  actually wants to say about a situation common in C++ known as dreaded diamond in multiple inheritance.
to understand just see the most upvoted answer to this link
<a href=""https://stackoverflow.com/questions/21558/in-c-what-is-a-virtual-base-class"">In C++, what is a virtual base class?</a></p>
",0
43225375,43223348,1,"<p>In your example it is the default constructor of <code>derived1</code> that is responsible for calling the default constructor of <code>base</code>. However, this is only necessary when <code>derived1</code> is the actual (most derived) object, as in your example</p>

<pre><code>int main()
{
  derived1 d1obj; // Most derived object of type `derived1`
  // It contains a direct `base` subobject
  // Constructor of `derived1` must construct `base` subobject as well
} 
</code></pre>

<p>But when <code>derived1</code> is used a base subobject of a larger object</p>

<pre><code>class derived2 : public derived1
{
public:
  derived2()
  {
     cout &lt;&lt;""ctor in derived 2 class\n"";
  }    
};

int main()
{
  derived2 d2obj; // Most derived object of type `derived2`
  // It contains a direct `derived1` subobject and an indirect `base` subobject 
  // (through `derived1`)
  // Constructor of `derived2` must directly construct both `derived1` subobject and 
  // `base` subobject 
  // Which means that constructor of `derived1` subobject should not attempt
  // to construct `base` subobject
}
</code></pre>

<p>then it is the constructor of <code>derived2</code> that is responsible for calling both the default constructor of <code>derived1</code> and the default constructor <code>base</code>. In this case the default constructor of <code>derived1</code> shall <em>not</em> call the constructor of <code>base</code>, since it will lead to double-construction of <code>base</code>.</p>

<p>To satisfy all of these requirements <code>derived1</code> will typically have two versions of its default constructor: full version called in your original example and ""reduced"" version called from <code>derived2</code> in my example above.</p>

<p>Alternatively, <code>derived1</code>'s default constructor can be implemented with a hidden boolean parameter, which will tell it whether to call <code>base</code>'s default construictor or not.</p>
",0
40978274,40978251,4,"<p>In C++ (and many other languages) there is no difference as any non zero value is ""truey"" and zero itself is ""falsey"".</p>
",0
40978340,40978251,7,"<p>The type of the expression required in the <code>if</code> condition is boolean. The expression <code>intVar!=0</code> is already boolean, the expression <code>intVar</code> has type <code>int</code> and requires an implicit conversion to boolean. As it happens the conversion rules for <code>int</code> to <code>bool</code> are precisely that anything non-zero maps to <code>true</code> and zero maps to <code>false</code>, so the resultant expression evaluation is exactly the same.</p>
<p>Sometimes writing the full <code>intVar!=0</code> can add clarity (for example, to make it clear you're not evaluating a pointer type for <code>nullptr</code> but rather an integral type for zero), whereas other times it doesn't - it really depends on the context.</p>
<p>Regarding requested references, I will use the <a href=""http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4606.pdf"" rel=""nofollow noreferrer"">standard</a>. The section relating to conversions [conv.bool]:</p>
<blockquote>
<p><strong>4.14 Boolean conversions</strong></p>
<p>A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a
prvalue of type bool. A zero value, null pointer value, or null member
pointer value is converted to false; any other value is converted to
true</p>
</blockquote>
",2
40978649,40978251,5,"<p>Additionally to other's answers (and for fun), I'd like to say that for an <code>intVar</code> of a user-defined type defining an implicit conversion operator to <code>int</code> and another to <code>bool</code>, the two expression could have a different behaviour:</p>

<pre><code>#include &lt;iostream&gt;

class Celcius
{
    int _value;
public:
    Celcius(int value) : _value(value) {}
    operator int() { return _value; }
    operator bool() { return _value &gt; -273; }
};

int main()
{
    Celcius waterBoilingPoint(0);

    if (waterBoilingPoint != 0) { // false
        std::cout &lt;&lt; ""This is not Standard Conditions for Temperature and Pressure!\n"";
    }

    if (waterBoilingPoint) { // true
        std::cout &lt;&lt; ""This is not 0K (pun intended).\n"";
    }
}
</code></pre>

<p>But this is an edge case I wouldn't jump into.</p>
",1
47462582,47216227,0,"<p>I eventually figured this out with help from a tutor. Unfortunately, it's not as easy as I would like to get tutors at my school since most are busy students as well, so it's hard to find times when they can help. Here's my code:</p>

<pre><code>/***********************************************************************
* Program:
*    Assignment 33, Pointers
*    Sister Unsicker, CS124
* Author:
*    Lanie Molinar
* Summary: 
*    This program asks two people for their bank account balances and the cost
*    of dinner, a movie, and ice cream on a date. It then deducts the cost 
*    from the bank account with the most money.
*
*    Estimated:  2.0 hrs   
*    Actual:     6.0 hrs
*      I had a lot of trouble getting the account balances to show up right 
*      at the end of running the program. It took me a long time to figure out
*      what I was doing wrong. I was finally able to fix it by using 
*      pass-by-reference in some locations and pass-by-pointer in others.
************************************************************************/

#include &lt;iostream&gt;
using namespace std;

/***********************************************************************
* This function asks two people for their account balances and stores the 
* information.
***********************************************************************/
void getBalances(float &amp;account1, float &amp;account2)
{
   cout &lt;&lt; ""What is Sam's balance? "";
   cin &gt;&gt; account1;
   cout &lt;&lt; ""What is Sue's balance? "";
   cin &gt;&gt; account2;
   return;
}

/***********************************************************************
* This function compares the balances in both accounts to determine which is 
* larger.
***********************************************************************/
void compareBalances(float &amp;account1, float &amp;account2,  float ** pAccount)
{
   if (account1 &gt; account2)
      *pAccount = &amp;account1;
   else
      *pAccount = &amp;account2;
   return;
}

/***********************************************************************
* This function prompts the user for the cost of the date and then deducts it 
* from the account with the most money.
***********************************************************************/
void date(float * pAccount)
{
   float priceDinner;
   float priceMovie;
   float priceIceCream;
   cout &lt;&lt; ""Cost of the date:\n""
      &lt;&lt; ""\tDinner:    "";
   cin &gt;&gt; priceDinner;
   cout &lt;&lt; ""\tMovie:     "";
   cin &gt;&gt; priceMovie;
   cout &lt;&lt; ""\tIce cream: "";
   cin &gt;&gt; priceIceCream;
   *pAccount -= priceDinner;
   *pAccount -= priceMovie;
   *pAccount -= priceIceCream;
   return;
}

/***********************************************************************
* This function reports the new account balances.
***********************************************************************/
void report(float &amp;account1, float &amp;account2)
{
   cout.setf(ios::fixed);
   cout.setf(ios::showpoint);
   cout.precision(2);
   cout &lt;&lt; ""Sam's balance: $"" &lt;&lt; account1 &lt;&lt; endl;
   cout &lt;&lt; ""Sue's balance: $"" &lt;&lt; account2 &lt;&lt; endl;
   return;
}

/**********************************************************************
*    The main function calls the other functions in the program.
***********************************************************************/
int main()
{
   float account1;
   float account2;
   float * pAccount;
   getBalances(account1, account2);
   compareBalances(account1, account2, &amp;pAccount);
   date(pAccount);
   report(account1, account2);
   return 0;
}
</code></pre>
",0
36607984,36607237,1,"<p>Create comparison operators for <code>struct state</code> using <a href=""http://en.cppreference.com/w/cpp/algorithm/lexicographical_compare"" rel=""nofollow""><code>lexicographical_compare</code></a></p>

<pre><code>bool operator&lt; (const state&amp; rhs) {
    return lexicographical_compare(name.cbegin(), name.cend(), rhs.name.cbegin(), rhs.name.cend());
}

bool operator== (const state&amp; rhs) {
    return name == rhs.name;
}
</code></pre>

<p>You can then use <a href=""http://en.cppreference.com/w/cpp/algorithm/sort"" rel=""nofollow""><code>sort</code></a> directly on <code>array</code>:</p>

<pre><code>sort(begin(array), end(array));
</code></pre>

<p>I've trimmed your class a bit, but this is how it would work: <a href=""http://ideone.com/SwaivI"" rel=""nofollow"">http://ideone.com/SwaivI</a></p>
",2
43767168,43766395,6,"<p>From <a href=""http://en.cppreference.com/w/cpp/language/qualified_lookup"" rel=""nofollow noreferrer"">qualified_lookup</a></p>

<p><code>pervaneli::plane</code> is the injected-class-name <code>plane</code> (the type).</p>

<p>so <code>pervaneli::plane::engine</code> is in fact <code>plane::engine</code>, which is ambiguous as you have two base class <code>plane</code>.</p>

<p>You cannot give full path to the member you want.</p>
",1
43767457,43766395,1,"<p>Public inheritance means <code>is a</code> relationship.<br> <em>Reference: Effective C++: Item 32: Make sure public inheritance models ¡°is-a.¡±</em></p>

<p>So <code>pervaneli</code> is a <code>plane</code> because of public inheritance. The class <code>pervaneli</code> already has the member variable <code>engine</code> in it because of <code>is a</code> relationship with <code>plane</code>.</p>

<p>By adding the scope of <code>plane</code> you are making it ambiguous for the compiler hence the error.</p>
",0
43767457,43766395,1,"<p>Public inheritance means <code>is a</code> relationship.<br> <em>Reference: Effective C++: Item 32: Make sure public inheritance models ¡°is-a.¡±</em></p>

<p>So <code>pervaneli</code> is a <code>plane</code> because of public inheritance. The class <code>pervaneli</code> already has the member variable <code>engine</code> in it because of <code>is a</code> relationship with <code>plane</code>.</p>

<p>By adding the scope of <code>plane</code> you are making it ambiguous for the compiler hence the error.</p>
",0
43767168,43766395,6,"<p>From <a href=""http://en.cppreference.com/w/cpp/language/qualified_lookup"" rel=""nofollow noreferrer"">qualified_lookup</a></p>

<p><code>pervaneli::plane</code> is the injected-class-name <code>plane</code> (the type).</p>

<p>so <code>pervaneli::plane::engine</code> is in fact <code>plane::engine</code>, which is ambiguous as you have two base class <code>plane</code>.</p>

<p>You cannot give full path to the member you want.</p>
",1
42465032,42464950,2,"<p>Okay, so I didn't plan on writing the answer, but I just saw too many logical mistakes in the code for me to write in the comments section!</p>

<ul>
<li><blockquote>
  <p>First of all, your use of the variable name <code>iterator</code> is very
  wrong. It's not used for iteration over the list. Why create confusion. Best to use something like <code>max_index</code> or something like that.</p>
</blockquote></li>
<li><blockquote>
  <p>Why start from <code>i=0</code>? Your temp value is <code>arr[0]</code>, so there is no use. of checking with first element again. Start from i=1!</p>
</blockquote></li>
<li><blockquote>
  <p><code>temp</code> is pointless in that function. The maximum index should initially be <code>0</code>, and set to <code>i</code> if ever there is some <code>arr[i]</code> that is greater than <code>arr[max_index]</code>.</p>
</blockquote></li>
<li><blockquote>
  <p>Passing the length separately to the function is better coding as it makes the code more clearer.</p>
</blockquote></li>
<li><blockquote>
  <p>The content in <code>arr</code> is not modified, and as such better safe than sorry: make the pointer <code>const</code>.</p>
</blockquote></li>
</ul>

<hr>

<p>Re-writing the code, it should be:</p>

<pre><code>int TravellingSalesMan::getMaximum(const double *arr,int len)
{
    int max_index = 0;
    for(int i = 1; i &lt; len; i++)
    {
        if(arr[i] &gt; arr[max_index])
            max_index = i;
    }
    return max_index;
}
</code></pre>

<p>Worth noting, but unchanged in the code above, <code>len</code>, <code>i</code>, and the function result should <em>all</em> be an unsigned integer type. There is no reason, to allow signed integer indexing, so make it a warning-condition from the caller if they do so by hard-specifying <code>unsigned</code> or just <code>size_t</code> as the indexing variable types.</p>
",2
42465005,42464950,2,"<p>You should be assigning a new value to <code>temp</code> when you find a new maximum.</p>

<pre><code>int TravellingSalesMan::getMaximum(double *arr){
    double temp = arr[0];
    int iterator = 0;
    for(int i = 0; i &lt; 30; i++){
        if(arr[i] &gt; temp){
            iterator = i;
            temp = arr[i];  // this was missing
        }
    }
    return iterator;
}
</code></pre>

<p>Without this you are finding the largest index of a value greater than the value at index zero.</p>

<p>A much better solution is to simply use <a href=""http://en.cppreference.com/w/cpp/algorithm/max_element"" rel=""nofollow noreferrer"">std::max_element</a> instead.  Pointers can be used as iterators in most (if not all) algorithms requiring iterators.</p>

<pre><code>#include &lt;algorithm&gt;

static unsigned int chromosomes = 30;
double value[chromosomes];
for (int i=0; i&lt;chromosomes; ++i) {
    value[I] = estimate_fitness(current_population[i]);
}

double *max_elm = std::max_element(&amp;value[0], &amp;value[chromosomes]);
int best = int(max_elm - &amp;value[0]);
std::cout &lt;&lt; best &lt;&lt; std::endl;
</code></pre>
",0
38408572,38408151,0,"<p>If the value of the variables to be added is not <strong>fixed</strong> (e.g. <code>const int a = 5;</code>) at compile time, then the expression <em>cannot</em> be evaluated at compile time. In this case, because the values are coming from the command line, the expression must be evaluated at compile time.</p>
",2
38408715,38408151,1,"<p>It depends on the compiler. Many modern compilers perform constant folding - that is, expressions such as <code>2 + 3</code> are already resolved at compile time. However, the degree to which constant folding is applied varies per compiler; it may be really smart, or there may be none at all. </p>

<p>Note that expressions defined as being <code>constexpr</code> are always computed at compile time. <code>constexpr</code> expressions have certain limitations that guarantee it will be possible for the compiler to already fully evaluate the expression. At this time, the limitations appear to be pushed back in each successive update to the standard.</p>
",0
36666648,36666129,1,"<p>You can't assign a <strong>variable</strong> to define the size of an array.May Be you could use a <strong>macro</strong>.</p>

<pre><code>#define SIZE 50
</code></pre>

<p>Or you could use <strong>dynamic variable</strong>. 
<strong>Ex:</strong></p>

<pre><code>#include&lt;iostream&gt;

using namespace std;

int main()
{
    int n ,*a;
    cout&lt;&lt;""Enter size of array= "";
    cin&gt;&gt;n;
    a=new int[n];       //allocate memory 
    for(int i=0;i&lt;n;i++)    
        *(a+i)=i;
    for(int i=0;i&lt;n;i++)
        cout&lt;&lt;*(a+i)&lt;&lt;endl;
    return 0;
} 
</code></pre>

<p>And</p>

<pre><code>void abst_diff(int arr[][**n**], int n)
</code></pre>

<p>You can't give the size here too.</p>

<pre><code>#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;


void abst_diff(int arr[50][50], int n){
int sum_1=0;
int sum_2=0;

for(int a_i = 0; a_i &lt; n; a_i++)
    sum_1 = sum_1 + arr[a_i][a_i];

for(int a_i = 0, a_j = n-1; a_i &lt; n; a_i++, a_j--)
    sum_2 = sum_2 + arr[a_i][a_j];

sum_2=abs(sum_2-sum_1);
cout &lt;&lt; sum_2;

}

int main(){
int n;
cin &gt;&gt; n;
int arr[50][50];
for(int a_i = 0;a_i &lt; n;a_i++){
   for(int a_j = 0;a_j &lt; n;a_j++){
      cin &gt;&gt; arr[a_i][a_j];
   }
}
abst_diff(arr,n);
return 0;
}
</code></pre>

<p><strong>Please comment using '/' not '\'.</strong></p>
",0
42463834,42463818,2,"<p>The difference of two pointers has type <code>std::ptrdiff_t</code>, which is signed and may be a wider type than <code>int</code>. You should change the type of <code>best1</code> to <code>std::ptrdiff_t</code>.</p>

<p>You can also use <code>std::distance</code> to compute the distance, from <code>&lt;iterator&gt;</code>:</p>

<pre><code>std::ptrdiff_t best1 = std::distance(
                           bestFitness,
                           std::max_element(bestFitness, bestFitness + N));
</code></pre>

<p>Chances are of course that you could rewrite your code in terms of iterators and give up on indexes altogether.</p>

<p>Note also that in general the returned iterator could be past-the-end if the input range is empty. This doesn't happen in your case (since arrays always have non-zero size), but in more general settings that's something you need to account for.</p>

<p>Also note that you don't need to remember the array size; it's part of the type and can be obtained via <code>begin</code>/<code>end</code>, also from <code>&lt;iterator&gt;</code>:</p>

<pre><code>std::max_element(std::begin(bestFitness), std::end(bestFitness));
</code></pre>
",2
41211795,41211719,0,"<p>Lets take a closer look at how your <code>arr1D</code> would look like in memory:</p>

<pre>
+---+---+---+---+---+---+---+---+---+----+
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
+---+---+---+---+---+---+---+---+---+----+
</pre>

<p>It's a simple and contiguous chunk of memory.</p>

<p>Now how would that <code>arr2D</code> look like in memory? Actually <em>just the same!</em></p>

<p>So the simplest way is just to use e.g. <a href=""http://en.cppreference.com/w/cpp/algorithm/copy_n"" rel=""nofollow noreferrer""><code>std::copy_n</code></a> to copy from one array to the other:</p>

<pre><code>double arr1D[10] = {1,2,3,4,5,6,7,8,9,10};
double arr2D[2][5];

std::copy_n(&amp;arr1D[0], 10, &amp;arr2D[0][0]);
</code></pre>

<hr>

<p>For the last code snippet, you don't have a ""2D array"". Instead the pointer variable <code>ptr</code> will point to the first element of <code>arr1D</code>. You can then use <code>ptr</code> almost as you use <code>arr1D</code> (the biggest difference is that <code>sizeof arr1D != sizeof ptr</code>).</p>
",0
43968349,43968292,0,"<p>You are declaring a variable of type <code>DWORD</code> without initializing it:</p>

<pre><code>DWORD safemode;
</code></pre>

<p>Then you are passing it to a function:</p>

<pre><code>str_to_number(safemode, arg2);
</code></pre>

<p>The compiler does not know that the initial value of the first argument is probably not used by the function, and therefore it is not a real issue here.</p>

<p>To resolve the warning, just initialize the variable with a default value:</p>

<pre><code>DWORD safemode = 0;
</code></pre>
",2
36783968,36783939,3,"<p><code>get()</code> returns every character. <code>getline()</code> throws away the line terminator.</p>
",0
36784199,36783939,0,"<p>Because your <code>while(!fin.eof())</code> was broken (see my comment under the question), when you're actually at the end of file you attempt another input operation, and the EOF is <em>then</em> set on the stream but not checked until <em>after</em> the variable you tried to input to has been used.</p>

<p>That's why you print <code>st</code> twice for the last line:</p>

<pre><code>1234 hijabcd  efg1234  hij
</code></pre>

<p><code>getline()</code> does remove the (newline) delimiter from the values set in <code>st</code>, which is why all your output will appear on the same line.</p>

<p>For the <code>get</code> version the attempted read at EOF returns <code>Traits::eof()</code> which you print... that may or may not visibly display something, depending on the <code>eof()</code> value your implementation chooses and your terminal/console program.</p>
",0
39628917,39628799,2,"<p>As far as what happens, it's absolutely nothing, and that's the point. Just a reference to the variable, but do absolutely nothing with it. The compiler dutifully processes it, notes that the parameter was used, then throws everything away and does not generate any actual code.</p>

<p>As far as parenthesis go:</p>

<p>It is a good practice to use parenthesis for macros that can potentially be used in an expression, even when it is not needed.</p>

<p>Consider, for example, a simple macro in hypothetical code that draws a window on the screen. The library that does it adds a border around the window that, say, is 6 pixels long. This macro computes the total width of the window. A naive implementation of this macro would read:</p>

<pre><code>#define ACTUAL_WIDTH(w)  w+6
</code></pre>

<p>Now, let's say your code wants to compute the actual width of two windows. Both windows are 100 pixels wide:</p>

<pre><code>int total_width=ACTUAL_WIDTH(100)*2;
</code></pre>

<p>What do you think happens? Recall that a macro substitution is basically just a straightforward text substitution, so this is what actually gets compiled:</p>

<pre><code>int total_width=100+6*2;
</code></pre>

<p>Which is utterly wrong. You want to have an extra set of parenthesis in your macro, so that the correct code gets compiled:</p>

<pre><code>int total_width=(100+6)*2;
</code></pre>

<p>And that's why you will often see an extra set of parenthesis in macros that can be used in expressions. Not only that, a macro like that will also have parenthesis around its argument, so it will probably be:</p>

<pre><code>#define ACTUAL_WIDTH(w)  ((w)+6)
</code></pre>

<p>And that's why you see an extra set of parenthesis in macros. It's easier to acquire a habit of always sticking them into every macro you write and be safe; rather than waste time figuring out, every time, if they are really needed or not.</p>

<p>Using good programming habits will avoid many common bugs.</p>
",0
39628954,39628799,1,"<p>As you said , your code will not display a unused variable warning because you are using your variable 'x' , but you are just doing nothing to it , you are passing it to a function that do nothing important (NOOP(x) --do nothing important but , compiler see you are trying to use the x variable) so it do not tell you you are not using your variable </p>
",0
39629142,39628799,2,"<p>From Section 5.2.9 paragraph 6 of the <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf"" rel=""nofollow"">C++14 standard working draft from November 2014</a>:</p>

<blockquote>
  <p>Any expression can be explicitly converted to type cv void, in which case it becomes a discarded-value expression.</p>
</blockquote>

<p>As stated by others, the extra parentheses prohibits any undesired effects by effectively quarantining the expression from code that might be around it.  Although in this case, I believe it would be unlikely that any ill effects would be felt in practical applications by not including the outer parentheses, especially if you were just using this to avoid the unused variable warning in a function.  It is just not worth any risk though by leaving them out.</p>

<p>To demonstrate this, I have come up with a very contrived example that leads to unintentional execution of code, because there are operators with higher precedence than C-style casting.</p>

<pre><code>#include &lt;iostream&gt;

#define NOOP(x) ((void)(x))
#define MYNOOP(x) (void) (x)

struct A
{
  bool operator()(void) {
    std::cout &lt;&lt; ""Called function unintentionally"" &lt;&lt; std::endl;
    return true;
  }
};

int main() {
  A i;
  MYNOOP(i)();
  //NOOP(i)(); // error: called object type 'void' is not a function or function pointer
  return 0;
}
</code></pre>
",0
48044061,40568007,0,"<p>There was an error of data structure is not correct, or the table does not exist.</p>
",0
40568313,40568007,0,"<p>The solution is: There was an error of sql statement on driver data view's query.</p>
",0
34982171,34982052,0,"<p>If I got you right, you can use that (map) :</p>

<pre><code>     #include&lt;map&gt;
      using namesapce std;
        map&lt;double, string&gt; myMap;
        myMap.insert(name of the pair you want to insert)
</code></pre>

<p>std::map sorts it self automaticaly</p>
",3
34983574,34982052,0,"<p>Lazy approach => use std::stable_sort. See: <a href=""http://en.cppreference.com/w/cpp/algorithm/stable_sort"" rel=""nofollow"">http://en.cppreference.com/w/cpp/algorithm/stable_sort</a></p>

<p>Not so lazy approach => Rewrite your design. Have an array of structure that contain name and point information. (Merge this info) Sort this array of structures based on a comparison function using the point member.</p>

<p>If you insist on using this design, I'd write my own little sort function that would also swap the name array position while swapping the point position... But that's not very nice is it?</p>
",0
44738401,44738380,2,"<p>This was happening because your loop condition was wrong,  you should be terminating when <code>offset</code> is equal to 0 and not when its smaller than 10, that way you skip one digit</p>

<pre><code>#include &lt;iostream&gt;

using std::cout;
using std::endl;

int reverse_num(unsigned long int offset) {
    int revnum = 0;
    while (offset){
        int remainder = offset % 10;
        revnum = (revnum * 10) + remainder;
        offset = (offset - remainder) /10.0;
    }
    return revnum ;
}

int main() {
    cout &lt;&lt; reverse_num(8963) &lt;&lt; endl;
}
</code></pre>

<hr>

<p>Also keep in mind that there is a danger for overflows here when the <code>unsigned long int</code> is too large to fit in an <code>int</code></p>
",3
36731804,36731625,9,"<p>Use <a href=""http://en.cppreference.com/w/cpp/algorithm/all_any_none_of"">std::all_of</a>, <a href=""http://en.cppreference.com/w/cpp/string/byte/isdigit"">isdigit</a> and <code>string::size()</code> to determine if the zip code is valid:</p>

<pre><code>#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
//...
bool isValidZipCode(const std::string&amp; s)
{
   return s.size() == 5 &amp;&amp; std::all_of(s.begin(), s.end(), ::isdigit);
}
</code></pre>

<p><a href=""http://ideone.com/yyMUss"">Live Example</a></p>

<p><a href=""https://en.wikipedia.org/wiki/Declarative_programming""><strong>Declarative Programming</a> plug:</strong></p>

<p>Note that if you say out loud the line in the <code>isValidZipCode</code> function, it fits your description (the string must have a size equal to 5 and ""all of"" the characters must be a digit).  </p>
",1
36731835,36731625,4,"<p>Since you are receiving input as a <code>std::string</code>, you can use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/size"" rel=""nofollow noreferrer""><code>std::string::length</code></a> (or <code>std::string::size</code>) to ensure you have the right amount of characters:</p>

<pre><code>if (userInput.length() != 5)
{
    // Input is invalid
}
</code></pre>

<p>To ensure they're only numbers, as @user4581301 points out you can use <a href=""http://en.cppreference.com/w/cpp/algorithm/all_any_none_of"" rel=""nofollow noreferrer""><code>std::all_of</code></a> and <a href=""http://en.cppreference.com/w/cpp/string/byte/isdigit"" rel=""nofollow noreferrer""><code>isdigit</code></a> (or check out answers in <a href=""https://stackoverflow.com/questions/8888748/how-to-check-if-given-c-string-or-char-contains-only-digits"">this question</a>)</p>

<pre><code>if (userInput.length() == 5 &amp;&amp; std::all_of(s.begin(), s.end(), ::isdigit))
{
    // Input is valid
}
</code></pre>

<p>It's also worth noting that the following line</p>

<pre><code>PropertyRec.setZipCode(stoi(userInput));
</code></pre>

<p>Will remove any leading <code>0</code> you have, so you may need to store your zip code as a <code>std::string</code> (unless you implement handling that will assume any zip code that's &lt; 5 has leading 0's, but it's likely far easier to store it exactly as-is)</p>
",0
36732519,36731625,0,"<p>You can use string size function for getting the size of the string. Save the string size in other variable and validate it whether it less than five or not.</p>
",0
43959651,43959410,1,"<p>The debugger should show what the template parameter <code>Element</code> was deduced to:</p>

<ul>
<li><code>T &amp;</code> means the argument was an lvalue.</li>
<li><code>T</code> means the argument was a prvalue.</li>
<li><code>T &amp;&amp;</code> means the argument was an xvalue.</li>
</ul>
",0
41921554,41921429,0,"<p><strong>correct code</strong>  </p>

<pre><code>std::vector&lt;int&gt;::iterator GetIterator(std::vector&lt;int&gt;&amp; vec) {
    return vec.begin();  // compiler said that here is an error.
}
</code></pre>

<p>your <code>&amp;</code> is extra.</p>

<p>The iterator is like <code>int*</code> and gets a <strong>address</strong>.<br>
And <code>std::vector&lt; type &gt;::iterator</code> is like that.<br>
So the <code>vector.begin()</code> is like <code>&amp;int</code> so you can not bind it to <code>iterator&amp;</code> </p>
",0
41921569,41921429,2,"<p>You can sometimes use a reference to avoid a copy - but here you need a copy. The result of <code>vec.begin()</code> is a temporary which ceases to exist when your function returns. If you want the value outside the function - and you do - then a copy is needed. (If you succeeded in forming a reference here it would be a ""dangling reference"", which is not a good thing.)</p>

<p>And in any case a lot of types are designed to be copied efficiently, and iterators are amongst those. And in fact the compiler can often avoid the copy for you, without you having to do any work at all - and this is one of those cases. </p>

<p>So the code without the reference is easier, correct, and already optimal.</p>
",0
41921499,41921429,1,"<p><code>vec.begin();</code> return a temporary object and is r-value. You can't bind a l-value reference to a r-value. After returning from <code>GetIterator</code> function, that temporary object will be destroyed and your reference will be dangled.</p>

<p>Return by value (<code>std::vector&lt;int&gt;::iterator</code>) instead of reference. <code>Iterator</code>s are designed to be copyable and cheap to copy. Also compilers use <em>Return value optimization</em> to avoid cost of coping objects.</p>
",2
35259363,35259315,5,"<p>The <code>return 0</code> line is going to end the program before <code>cin.get()</code> gets executed.</p>

<p>Flip the order of <code>return 0</code> and <code>cin.get()</code>.</p>
",0
36573955,36573896,6,"<p>When you do</p>

<pre><code>A a = B();
</code></pre>

<p>you are <a href=""https://stackoverflow.com/questions/274626/what-is-object-slicing""><em>slicing</em> the object</a>. What you have is only an instance of an <code>A</code> object.</p>

<p>To make polymorphism work you need to either use references:</p>

<pre><code>B b;
A&amp; a = b;
</code></pre>

<p>or use pointers</p>

<pre><code>A* a = new B;
</code></pre>
",3
36277845,36277594,0,"<p>My 5 cents </p>

<p>Actually first one who thought about <strong>char to int conversion</strong> was <code>Ada Lovelace</code> (<a href=""https://en.wikipedia.org/wiki/Ada_Lovelace"" rel=""nofollow"">https://en.wikipedia.org/wiki/Ada_Lovelace</a>).</p>

<p>When she discuss <code>Analytical Engine</code> (<a href=""https://en.wikipedia.org/wiki/Analytical_Engine"" rel=""nofollow"">https://en.wikipedia.org/wiki/Analytical_Engine</a>), she theorize that <code>numbers</code> could express <code>letters</code> and <code>symbols</code> and in this way, the <code>Analytical Engine</code> could theoretically process <code>text</code> information.</p>

<p>She even made some example ""program"" that works with text.</p>
",0
36277707,36277594,1,"<p>The author is saying that you can safely convert from a char to an int for two reasons. The first is a char is single character represented by its ASCII value. </p>

<p>Here is the link to one such table <a href=""http://www.asciitable.com/"" rel=""nofollow"">http://www.asciitable.com/</a></p>

<p>As shown in the example, converting a 'x' to an int will result in 120, which is the decimal ASCII value for lowercase x.</p>

<p>The second reason this is safe to do, is because no variables are having their data changed or overwritten, since you are creating new variables for each conversion.</p>

<p>To sum it up, a char is a data type that represents an integer ASCII value as a character that corresponds with the given table, which is why you can easily convert from a char to an int, because they're essentially both integers.</p>
",3
36781762,36781727,7,"<p>The following would be the typical sequence of tasks:</p>

<ul>
<li>Load the old VS2005 project file in VS2008</li>
<li>VS2008 will prompt to convert the project file to VS2008 format, do that</li>
<li>Build the project</li>
<li>Fix anything that is flagged as an error by the newer compiler</li>
<li>Test the resulting compiled code</li>
</ul>

<p>Of course the C++ language itself did not change between those years. Other things about VS might have.</p>
",2
37157820,37157704,11,"<h3><code>int i1 = 1;</code></h3>

<p>This is good old C style.  Still works fine and is conventional in C++.</p>

<h3><code>int i2(1);</code></h3>

<p>This is C++ style.  It came about because some types need more than one argument to their constructor.</p>

<h3><code>int i3{};</code></h3>

<p>C++11 style.</p>

<h3><code>int i4 = {1};</code></h3>

<p>This is not conventional.</p>

<h3><code>int i5 = int{1};</code></h3>

<p>This is not conventional.  But it's supported due to the new ""uniform initialization syntax"" of C++11.</p>

<h3><code>int i6 = {};</code></h3>

<p>You didn't ask about this one, but it's also valid in C++11.</p>

<h3><code>int i7{1};</code></h3>

<p>Another bonus, this is probably the most conventional use of uniform initialization syntax in C++11.</p>

<h3><code>auto i8 = int{1};</code></h3>

<p>Thanks to KerrekSB for this abomination, which he credits to none other than Herb Sutter.  This will probably win you friends from the ""No True Modern C++"" camp, and alienate your coworkers who were perfectly happy with the first syntax.</p>
",12
37158079,37157704,4,"<p><strong>TL;DR</strong> - Use <code>X a1 {v};</code> for initialization.</p>

<p>To take cue from <a href=""https://en.wikipedia.org/wiki/Bjarne_Stroustrup"" rel=""nofollow"">Bjarne Stroustrup</a> himself, below is directly quoted from TCPL, fourth edition -</p>

<blockquote>
  <p>If an initializer is specified for an object, that initializer determines the initial value of an object.
  An initializer can use one of four syntactic styles:</p>
</blockquote>

<pre><code>X a1 {v};
X a2 = {v};
X a3 = v;
X a4(v);
</code></pre>

<blockquote>
  <p><strong>Of these, only the first can be used in every context, and I strongly recommend its use</strong>. It is clearer
  and less error-prone than the alternatives. However, the first form (used for a1) is new in C++11, so
  the other three forms are what you find in older code. The two forms using = are what you use in
  C.</p>
</blockquote>
",2
34905052,34904811,0,"<pre><code>Kind=stod(kind);
</code></pre>

<p>does not seem right. The value of <code>kind</code> is going to be <code>""$GPRMC""</code>. You cannot extract a <code>double</code> from it.</p>

<p><strong>PS</strong> Fixing it may not fix any other problems you might have.</p>
",0
34905119,34904811,1,"<p>In a review, let us consider how you parse the first datum.  </p>

<pre><code>   com_1=gps.find("","");
</code></pre>

<p>The above line finds the position of the first comma, good.  </p>

<p>Next, you extract the substring of the first item:  </p>

<pre><code>kind=gps.substr(0,com_1);
</code></pre>

<p>The variable <code>kind</code> should be ""$GPRMC"", according to your input.</p>

<p>Finally, you convert this text to a double:  </p>

<pre><code>Kind=stod(kind);
// In other words, this is equivalent to  
// Kind = stod(""$GPRMC"");  
</code></pre>

<p>The <code>stod</code> function fails because there are no digits in the string.  </p>

<p>BTW, differing variable names by case, such as <code>kind</code> vs. <code>Kind</code>, is considered as poor coding practices.  Most coding guidelines forbid this and require variable names to differ by more than case.  </p>
",0
43206310,43205874,0,"<p>Your program will not behave as you expect if you enter in more numbers than your <code>count</code> because of how it is parsing the inputs.  </p>

<pre><code>for (i = 1; i &lt;= count; i++) {

    cin &gt;&gt; teikums[i];
}
</code></pre>

<p>Let's say your <code>count</code> is 1, and you enter in <code>1 2</code>.
This will loop once and say <code>teikum[1]</code> to be 1, and <code>2</code> is still leftover waiting to be grabbed by an input stream.  Below that you have,</p>

<pre><code> cin &gt;&gt; yesno;
</code></pre>

<p>which will now set <code>yesno</code> to be <code>2</code> and your program will terminate because <code>2 != 'n'</code>.  You will need to either input the data correctly as your format expects or clear <code>cin</code> using something like <code>cin.ignore('\n')</code> which will ignore the current line of input.</p>

<p>Further, you start your <code>i</code> at 1 and go up to count but your array is only size 100.  If count is 100, it will try to access <code>teikum[100]</code> which will be out of bounds as your array goes from 0 - 99</p>
",0
37069170,37069070,2,"<p>You're not deleting the <code>Facebook</code> object.</p>

<p>Try this:</p>

<pre><code>void Quit(void** DS)
{
   delete (*DS);
   *DS = NULL;
}
</code></pre>
",2
37069211,37069070,1,"<p>Try this</p>

<pre><code>void Quit(void** DS){
   Facebook* pDS = (Facebook*)(*DS);
   delete pDS;
   *DS = NULL;
   return;
}
</code></pre>
",0
40774460,40774301,1,"<p>It can do it because reference can't be rebound to another one.</p>

<p>If the compiler would generate a function like you provided, I would do this:</p>

<pre><code>struct Ref {
    int&amp; num;
    // hypotetical operator= generated
};

// ...

int a = 2;
int b = 5;

Ref ra{a};
Ref rb{b};

ra = rb; // now a = 5. Quite confusing.

a = 3; // still changes what value `ra.num` yeild. rb is not affected.

// will print ""false"".
std::cout &lt;&lt; std::boolalpha &lt;&lt; (ra.num == rb.num) &lt;&lt; std::endl;
</code></pre>

<p>That would lead to some nasty errors.</p>

<p>My preferred solution to this problem is to not care. I think that the <code>operator=</code> is not absolutly required for most use cases.</p>

<p>However, if you really want to provide an <code>operator=</code> to the users of your class, you can hold a pointer or a <code>std::reference_wrapper</code> instead of a reference. Both will allow your class to be assignable, making your reference rebindable. Between those two, I usually prefer pointers as they are more straightforward to use in my opinion.</p>

<pre><code>struct Ref {
    std::reference_wrapper&lt;int&gt; num;
};

// -- or --

struct Ref {
    Ref(int&amp; ref) : num{&amp;ref} {}

    int* num;
};

// ...

int a = 2;
int b = 5;

Ref ra{a};
Ref rb{b};

ra = rb; // now ra.num and rb.num are bound to the same reference.
</code></pre>
",0
38290791,38290741,5,"<p>This function:</p>

<pre><code>vector&lt;N&gt;&amp; operator[](int &amp;index)
</code></pre>

<p>Cannot be called like this:</p>

<pre><code>Array2D&lt;int&gt; L(10, 10);
L[3][3] = 10;
</code></pre>

<p>Because a non-const reference to a literal cannot be taken.  References allow modification, and what would it mean to modify <code>3</code>?</p>

<p>You should use this instead:</p>

<pre><code>vector&lt;N&gt;&amp; operator[](size_t index)
</code></pre>
",0
37912005,37911882,2,"<p>The problem appears here:</p>

<pre><code>sum += coeff[k] * pow(term[k], length - 1 - k);
</code></pre>

<p>but the actual problem may be in the header of the function where you are sending references (cplx &amp;coeff, cplx &amp;term), but you expect to use them as arrays, or pointers. The solve could be this way:</p>

<p>// f(x)</p>

<pre><code>cplx f(cplx *coeff, cplx *term, int length)
{
    cplx sum {0., 0.};
    for (int k=0; k&lt;length; ++k)
    {
        sum += coeff[k] * pow(term[k], length - 1 - k);
    }
    return sum;
}
</code></pre>

<p>As you can see, I have changed from &amp; sign to *.</p>
",2
37195240,37189528,0,"<p>I don't know what's the rationale behind OP choices, so I can't properly comment the design of code provided, but for what I can understand there are some mistakes with the example input too.</p>

<p>Given A and B matrices as presented, the inner product of the lower rows of A with the corresponding in B is always 0:</p>

<pre><code>                                     B[1]   { 2,     1, 0, 0, 0 },
row ""2"" or A[1] is { 0, 1, 0, 1 } &lt;- B[4]   { 2,     0, 0, 1, 0 },
                                     B[5]   { 2,     1, 0, 1, 0 },
</code></pre>

<p>The same for the succesive row. Only if swapped, the expected output can be obtained and so I did in my code.</p>

<p><code>vectorA</code> and <code>vectorB</code> and the corresponding copy loops aren't really neccessary and probably are the cause of the wrong output:</p>

<pre><code>for( int x = 1; x &lt; 4; x++)
{ //            ^^^^^  this should be  &lt;=  to reach the last element
    vectorB[x -1] = B[y][x];
}
</code></pre>

<p>My code, with the updated input and the direct use of A and B is:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt;

using vec_t = std::vector&lt;int&gt;;   // I assume a C++11 compliant compiler
using mat_t = std::vector&lt;vec_t&gt;;
using std::cout;

int main() {

    mat_t A{
        { 0, 0, 0, 0 },
        { 1, 0, 1, 0 }, // &lt;-- those lines are swapped
        { 0, 1, 0, 1 }, // &lt;--
        { 1, 1, 1, 1 }
    };
    mat_t B{
        { 1, 0, 0, 0, 0 },
        { 2, 1, 0, 0, 0 },
        { 3, 0, 1, 0, 0 },
        { 4, 1, 1, 0, 0 },
        { 2, 0, 0, 1, 0 },
        { 2, 1, 0, 1, 0 },
        { 4, 0, 1, 1, 0 },
        { 4, 1, 1, 1, 0 },
        { 3, 0, 0, 0, 1 },
        { 4, 1, 0, 0, 1 },
        { 3, 0, 1, 0, 1 },
        { 4, 1, 1, 0, 1 },
        { 4, 0, 0, 1, 1 },
        { 4, 1, 0, 1, 1 },
        { 4, 0, 1, 1, 1 },
        { 4, 1, 1, 1, 1 }
    };

    mat_t C(4, vec_t(16));
    vec_t pos(4);

    for ( int i = 0; i &lt; 16; ++i )
    {
        int row = B[i][0] - 1;
        int col = pos[row];
        int prod = std::inner_product( A[row].begin(), A[row].end(),
                                      ++(B[i].begin()), 0 );
        //                            ^^^ skip the first element
        C[row][col] = prod;
        if ( prod )
            ++pos[row];
    }

    for ( auto &amp; r : C )
    {
        for ( int x : r ) {
            cout &lt;&lt; ' ' &lt;&lt; x;
        }
        cout &lt;&lt; '\n';
    }

    return 0;
}
</code></pre>

<p>The output is:</p>

<pre><code> 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 1 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0
 1 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0
 2 2 3 2 3 2 3 3 4 0 0 0 0 0 0 0
</code></pre>

<p>I don't know if the ordering of the last row is as expected, but it mimics the logic of OP's code.</p>
",0
36273459,36273422,3,"<p>I think this is a typo problem. Your binary heap class is <code>binaryHeap</code>, while in your <code>main</code> function, you are saying <code>struct BinaryHeap heap(10);</code>, which in the compiler's POV is a completely different type.</p>
",1
40964408,40964287,0,"<blockquote>
  <p>T2 is a non-templated type, but T1 is a templated type</p>
</blockquote>

<p>In this case, <code>T1</code> should be a template template parameter.<br>
It follows a minimal, working example:</p>

<pre><code>template&lt;template&lt;typename&gt; class T1, typename T2&gt;
struct S {
    void f(T1&lt;T2&gt;) {}
    void g(T2) {}
};

template&lt;typename&gt;
struct T {};

int main() {
    S&lt;T, int&gt; s;
    s.f(T&lt;int&gt;{});
    s.g(42);
}
</code></pre>

<p>See <a href=""http://en.cppreference.com/w/cpp/language/template_parameters"" rel=""nofollow"">here</a> for further details.</p>

<hr>

<blockquote>
  <p>But still, I would like to define?T2?depending on?T1?(to make the dependencies clear)</p>
</blockquote>

<p>If you want to be clear about the dependency, you can also enforce it by using a partial specialization similar to the one in the following example:</p>

<pre><code>template&lt;typename&gt;
struct S;

template&lt;template&lt;typename&gt; class T1, typename T2&gt;
struct S&lt;T1&lt;T2&gt;&gt; {
    void f(T1&lt;T2&gt;) {}
    void g(T2) {}
};

template&lt;typename&gt;
struct T {};

int main() {
    S&lt;T&lt;int&gt;&gt; s;
    s.f(T&lt;int&gt;{});
    s.g(42);
}
</code></pre>
",0
35212842,35212421,0,"<p>BTW, a correction on syntax:</p>

<pre><code>if ((username == ""test"") or (username == ""username) or (username == ""whitelist""))
</code></pre>

<p>With that out of the way...  </p>

<p>Essentially you are searching a container of strings for a given string.  The container selection is yours, but a few include: <code>std::vector</code>, <code>std::list</code> and <code>std::set</code>.  </p>

<p>I suggest you initialize your ""whitelist"" container and then search the container.  With a sorted container, you may be able to use more efficient search functions such as <code>binary_search</code> or <code>lower_bound</code>.  </p>

<p>You may want to consider using a database.  </p>
",1
36262568,36262491,0,"<p>The two functions have not bee called in this example. See this: <a href=""http://cpp.sh/8te7"" rel=""nofollow"">http://cpp.sh/8te7</a></p>

<p>However, the constructors(<code>Humidity(int)</code>, <code>Temperature(int)</code> of the two classes have been called and they are doing something and they are doing something similar to the two functions you mentioned(<code>seHumidity</code>,<code>seTemperature</code>).</p>
",0
34944008,34943835,5,"<p>In the expression <code>buffer[0] &lt;&lt; 24</code> the value 24 is an <code>int</code>, so <code>buffer[0]</code> will also be converted to an <code>int</code> before the shift is performed.</p>

<p>On your system a <code>char</code> is apparently signed, and will then be sign extended when converted to <code>int</code>.</p>
",0
34944089,34943835,29,"<p>Your <code>buffer</code> contains <em>signed</em> characters. So, actually, <code>buffer[0] == -29</code>, which upon conversion to <code>int</code> gets sign-extended to <code>0xffffffe3</code>, and in turn <code>(0x3e &lt;&lt; 8) | 0xffffffe3 == 0xffffffe3</code>.</p>

<p>You need ensure your individual <code>buffer</code> bytes are interpreted <code>unsigned</code>, either by declaring <code>buffer</code> as <code>unsigned char *</code>, or by explicitly casting:</p>

<pre><code>int a = int((unsigned char)(buffer[0]) &lt;&lt; 24 |
            (unsigned char)(buffer[1]) &lt;&lt; 16 |
            (unsigned char)(buffer[2]) &lt;&lt; 8 |
            (unsigned char)(buffer[3]));
</code></pre>
",3
34945247,34943835,2,"<p>There's a implict promotion to a signed int in your shifts.
That's because char is (apparently) signed on your platform (the common thing) and &lt;&lt; promotes to integers implicitly. In fact none of this would work otherwise because &lt;&lt; 8 (and higher) would scrub all your bits!</p>

<p>If you're stuck with using a buffer of signed chars this will give you what you want:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int buffToInteger(char * buffer)
{
    int a = static_cast&lt;int&gt;(static_cast&lt;unsigned char&gt;(buffer[0]) &lt;&lt; 24 |
        static_cast&lt;unsigned char&gt;(buffer[1]) &lt;&lt; 16 | 
        static_cast&lt;unsigned char&gt;(buffer[2]) &lt;&lt; 8 | 
        static_cast&lt;unsigned char&gt;(buffer[3]));
    return a;
}

int main(void) {
    char buff[4]={0x0,0x0,0x3e,static_cast&lt;char&gt;(0xe3)};
    int a=buffToInteger(buff);

    std::cout&lt;&lt;std::hex&lt;&lt;a&lt;&lt;std::endl;

    // your code goes here
    return 0;
}
</code></pre>

<p>Be careful about bit shifting on signed values. Promotions don't just add bytes but may convert values. </p>

<p>For example a gotcha here is that you can't use <code>static_cast&lt;unsigned int&gt;(buffer[1])</code> (etc.) directly because that converts the signed char value to a signed int and then reinterprets that value as an unsigned.</p>

<p>If anyone asks me all implicit numeric conversions are bad. No program should have so many that they would become a chore. It's a softness in the C++ inherited from C that causes all sorts of problems that far exceed their value.
It's even worse in C++ because they make the already confusing overloading rules even more confusing.</p>
",2
35282611,35282550,0,"<p>As long as you dont want to modify the string inside your UserInput-Function, just use </p>

<pre><code>cout &lt;&lt; ""You entered: "" &lt;&lt; input &lt;&lt; endl;
</code></pre>

<p>If you want to modify it, write your function like this: </p>

<pre><code>string UserInput(string s)
{
s = ""whatever""; //modify s as you like
return s;
}
</code></pre>

<p>In C++ function parameters need a type (<code>string</code> here) and a name (<code>s</code> here) in order to use/modify them.</p>
",1
35282629,35282550,0,"<p>Your intent is confusing, this function:</p>

<pre><code>string UserInput(string)
{
    //string Input = 
    return 0;
}
</code></pre>

<p>Doesn't do anything. You are performing a bad cast from the <code>int</code> to <code>string</code> which causes runtime errors: <a href=""http://ideone.com/vzoQcw"" rel=""nofollow"">http://ideone.com/vzoQcw</a>.</p>

<p>Play around this:</p>

<pre><code>int main(void)
{

    string input;

    // Enter user input
    cout &lt;&lt; ""Enter your input: "";
    cin &gt;&gt; input;

    // Display user input
    cout &lt;&lt; ""You entered: "" &lt;&lt; input &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>If you want to do some consistent modifications of the string with your function user input, then you need to modify the string and return. eg.</p>

<pre><code>// Example function to uppercase the string. 
string UserInput(string input) {
    for (int i = 0; i &lt; input.length(); ++i) {
         input[i] = toupper(input[i]);
    }
    return input;
}
</code></pre>

<p><a href=""http://ideone.com/ecoszM"" rel=""nofollow"">Here is a live example for you to play with.</a> </p>
",1
46631583,46631557,2,"<p>Using <code>std::cin</code> is considered writing to member data. But you can not change the data members using a <code>const</code> qualified member function. Remove the <code>const</code> specifier from the function declaration and definition if you want to achieve that functionality:</p>

<pre><code>void Course::EnterCourse();
</code></pre>

<p>More info on the subject in these SO posts:<br>
<a href=""https://stackoverflow.com/questions/751681/meaning-of-const-last-in-a-c-method-declaration"">Meaning of ¡°const¡± last in a C++ method declaration?</a><br>
<a href=""https://stackoverflow.com/questions/3141087/what-is-meant-with-const-at-end-of-function-declaration"">What is meant with ¡°const¡± at end of function declaration?</a></p>
",1
46131084,46130729,0,"<p>Since you are using C++, you should avoid to include <code>.h</code> header. There's the <code>&lt;string&gt;</code> header in C++ to manipulate string, so use it.</p>

<p>Then, you have commented the <code>using namespace std</code> which is a good practice. See <a href=""https://stackoverflow.com/a/1452738/7943474"">here</a> why. But now you need to specify which namespace string objects belong to, so it's necessary to explicity write <code>std::string</code> istead of <code>string</code>.</p>

<p>Finally, I quote @Bathsheba answer. You should create a class student.</p>
",0
46130774,46130729,1,"<p>Replace <code>string</code> with <code>std::string</code>.</p>

<p>You've done the good thing and got rid of the intrusive <code>using namespace std;</code>.</p>

<p>Finally, why not make the ""global functions"" members of the <code>student</code> class itself? Then you wouldn't need that <code>student*</code> pointer.  C++ ain't C you know.</p>
",0
41901780,41901692,6,"<p>The order of initialization of global variables is only well-defined for a single <a href=""https://en.wikipedia.org/wiki/Translation_unit_(programming)"" rel=""nofollow noreferrer""><em>translation unit</em></a>. The order between translation units is <em>undefined</em>. That's what's happening here.</p>

<p>You can't know if <code>K</code> from <code>Card.cpp</code> will be initialized first, or <code>Stab</code> from <code>test.cpp</code>.</p>
",3
38523282,38523180,6,"<p>You append the <strong>local</strong> object <code>Node end(d);</code> to the end of the linked list. This object is destroyed upon exist from <code>append</code> and the last list element points to a non-existent object.</p>
",0
38523467,38523180,2,"<p>For the edited Question:
You are <strong>copying</strong> the <code>head</code> to <code>n</code>, then modify <code>n</code>. At the end of your <code>append</code> function, <code>n</code> is destroyed, but <code>head</code> was never touched.</p>
",0
38523492,38523180,4,"<p>A few issues with this.</p>

<p>You make a copies in your <code>append</code> function here <code>Node n = head;</code> and here <code>n = *n.next</code>. You then then finally make a change to the copy rather than the original. </p>

<p>You are assigning <code>Node end(d)</code> on the stack. When <code>append</code> returns it goes out of scope and is deleted.</p>

<p>You can fix both with,</p>

<pre><code>#include&lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;

struct Node{
    int val;
    std::shared_ptr&lt;Node&gt; next;
    Node(int v) : val(v), next(nullptr) {}
};

void append(Node &amp;head, int d){
    Node* n = &amp;head;    
    while(n-&gt;next != nullptr){
            n = n-&gt;next.get();
    }
    n-&gt;next = std::make_shared&lt;Node&gt;(d);
}

int main(){
    Node head(0);
    for(int i=1;i&lt;5;i++){
            append(head, i);
    }    
    Node n = head;
    while(n.next != nullptr){
            cout &lt;&lt; n.val&lt;&lt;"" "";
            n = *n.next;
    }
    cout&lt;&lt;n.val&lt;&lt;endl;
    return 0;
}
</code></pre>
",0
36223590,36223447,-1,"<p>You just check each character in your input string is a number, I have a simple example for your problem:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

bool is_number(const char * s)
{
    int length = strlen(s);
    for (int i = 0; i &lt; length; i++)
    {
        if (s[i] &lt; '0' || s[i] &gt; '9')
            return false;
    }
    return true;
}

int main()
{
    printf(""Enter a string: "");
    char myString[10];
    gets(myString);
    if (is_number(myString))
        printf(""%s is a number"", myString);
    else
        printf(""%s is not a number"", myString);
}
</code></pre>
",1
36223592,36223447,-1,"<p>I don't think you even need to check.  According to the C++ API:</p>

<blockquote>
  <p>If the first sequence of non-whitespace characters in str is not a
  valid integral number, or if no such sequence exists because either
  str is empty or it contains only whitespace characters, no conversion
  is performed and zero is returned.</p>
</blockquote>

<p>SEE: 
<a href=""http://www.cplusplus.com/reference/cstdlib/atoi/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdlib/atoi/</a></p>

<p>-</p>

<p>So, you should just be able to do:</p>

<pre><code>// Convert the string
int value = atoi( myString.c_str() );

if ( value == 0 )
{
    // The string was not a valid integer
}
else
{
    // The string was a valid integer
}
</code></pre>
",0
36223599,36223447,0,"<ol>
<li>Construct a <code>std::istringstream</code> from the <code>std::string</code>.</li>
<li>Extract a number from it. If extraction is successful, use the number. If not, move on to the next thing.</li>
</ol>



<pre><code>std::string s = ""123"";
std::istringstream str(s);
int n;
if ( str &gt;&gt; n )
{
   // Extraction is successful.
   // Use n.
}
</code></pre>

<p><strong>Further Enahncements</strong></p>

<p>To make your program more robust, you can add a further check to make sure that:</p>

<p>""123FAST"" is not treated as an integer.<br>
""123.56"" is not treated as an integer.<br>
""123.56xyz"" is not treated as an integer.  </p>

<pre><code>std::string s = ""123"";
std::istringstream str(s);
int n;
if ( str &gt;&gt; n )
{
   // Extraction is successful.
   // Add another check.

   // Get the next character.
   // It has to be a whitespace character or EOF for the input
   // to be an integer.
   // If it is neither, don't accept the input as an integer.
   std::istream::int_type c = str.get();
   if ( std::isspace(c) || str.eof() )
   {
      // Use n.
   }
}
</code></pre>
",11
36223755,36223447,-1,"<p>You can check if there is any non-digit character in the string:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;cctype&gt;
int main()
{
    std::string test;

    std::cin &gt;&gt; test;
    if(std::find_if(test.begin(), test.end(), [](auto x){return !isdigit(x);}) == test.end())
        std::cout &lt;&lt; ""its a number"" &lt;&lt; std::endl;
    else
        std::cout &lt;&lt; ""not a number"" &lt;&lt; std::endl;
}
</code></pre>
",3
36223697,36223447,-1,"<p>'isnum()' function below checks if given string is comprised of numbers only. However it might not work if number is very large.</p>

<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
bool isnum(string str){
    for(int i=0;i&lt;str.length();i++){
        if((str[i]&lt;'0') || (str[i]&gt;'9'))return false;
    }
    return true;
    }
int main() {
    // your code goes here
    int n=0,r=1;
    string num;
    cin&gt;&gt;num;
    if(isnum(num)){
        for(int i=num.length()-1;i&gt;=0;i--){
            n+=(r)*(int)(num[i]-'0');
            r*=10;
        }
    cout&lt;&lt;n;
    }
    return 0;
}
</code></pre>
",1
36288005,36287902,10,"<p>The compiler does not know when to stop.  </p>

<pre><code>for(i = 0; p[i]; i++)
</code></pre>

<p>will only stop when <code>p[i]</code> is <code>0</code>.  You just got lucky and <code>p[5]</code> happened to be <code>0</code>.  There is nothing saying that it has to be so and it could keep going like <a href=""http://coliru.stacked-crooked.com/a/eea9c0984e275be3"" rel=""nofollow"">this example</a>.  As soon as <code>i &gt;= array size</code> you are accessing memory the array does not own and you enter the world of <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a>.</p>

<p>Also if you had a <code>0</code> in the array like</p>

<pre><code>int inumbers[] = {1 ,2 , 0, 4, 5};
</code></pre>

<p>then the program will only print </p>

<pre><code>1
2
</code></pre>

<p>And it will not visit the rest of the array.</p>

<p>When dealing with an array or a standard container you can use a <a href=""http://en.cppreference.com/w/cpp/language/range-for"" rel=""nofollow"">ranged based for loop</a> like</p>

<pre><code>for (const auto &amp; e : inumbers)
    std::cout &lt;&lt; e &lt;&lt; '\n';
</code></pre>

<p>To iterate through it's contents. Then <code>const &amp;</code> is not really needed in this case as we are dealing with an int but it is a good habit to get into as passing by reference avoids copying and making it <code>const</code> prevents you from accidentally modifying the element when doing a read only operation.</p>

<p>When dealing with a pointer you need to provide a size like</p>

<pre><code>for (int i = 0; i &lt; size_of_pointed_to_array, i++)
    std::cout &lt;&lt; p[i] &lt;&lt; '\n';
</code></pre>
",4
36288022,36287902,3,"<p>You got lucky. By random chance, it appears that there was a zero in memory after the last element in your <code>inumbers</code> array.</p>

<p>Your program is not actually correct. Instead, you might want to limit your loop by counting array members:</p>

<pre><code>for(i = 0; i &lt; sizeof(inumbers)/sizeof(int); i++) cout &lt;&lt; p[i] &lt;&lt; '\n';
</code></pre>
",7
36288055,36287902,2,"<h2>The Issue</h2>

<p>The behaviour of your program is undefined. According to the way you have written the program, the loop should terminate when <code>p[i]</code> evaluates to false, which in this case should mean that <code>p[i] == 0</code>.</p>

<h2>What C++ is actually doing</h2>

<p>Clearly there is no <code>0</code> in your array hence the program will take the pointer out of bounds of the array and will dereference 4 consecutive bytes of memory and interpret those 4 bytes as an integer until it finds a <code>0</code>. In your case you got lucky that there was such a <code>0</code> present in memory.</p>

<p>In case there was no <code>0</code>, the program will eventually encounter a segmentation fault.</p>

<p>An interesting experiment would be printing the value of <code>i</code> after it exits the loop.</p>
",1
36288103,36287902,2,"<p>The above code relies upon undefined behavior.</p>

<p>In particular, it reads past the end of the array.  As it happens that int sized quad byte is zero (in your particular build and hardware).  This causes the loop to end (the middle clause of the <code>for</code> loop reads <code>while p[i] is non-zero</code>).</p>

<p>When there is undefined behavior, the C++ language does not constrain the behavior of the runtime.  ""Working"" is a valid behavior, as is formatting your hard drive.</p>
",0
35216274,35216173,2,"<p>The <code>hex</code> iomanipulator will stay in effect until it is changed with something like <code>dec</code>.  To output your decimal value, use</p>

<pre><code>if (decimal) cout&lt;&lt;dec&lt;&lt;""    ""&lt;&lt;seq.GetNum()&lt;&lt;endl;
</code></pre>
",1
42640673,42640560,2,"<blockquote>
  <p>But i'm wondering. Every time I loop through the outer for loop and increment i, does the data get stored in memory, making the computer less efficient, as I keep looping?</p>
</blockquote>

<p>Looking at your posted code, <code>vectorInts</code> seems to have been defined outside the outer for loop. If that is indeed true, <code>vectorInts</code> will keep on getting bigger as you iterate over the loops.</p>

<p>Whether that makes the computer slow depends on how much memory is available on your computer and how big <code>vectorInts</code> gets.</p>

<p>Based on:</p>

<blockquote>
  <p>Basically what I want to do is populate a vector, vectorInts, with random integers, then sort the Vector, then print it.</p>
</blockquote>

<p>you probably want <code>vectorInts</code> to be defined inside the outer <code>for</code> loop and outside the inner <code>for</code> loop.</p>

<pre><code>for(int i = 0; i &lt; MAXVALUE; i++){
   std::vector&lt;int&gt; vectorInts;
   for(int k = 0; k &lt; vecMaxSize;k++){
      int randNum = rand()%MAXVALUE;
      vectorInts.push_back(randNum);
   }
   ...
   sortVector(vectorInts);
   //Print vector here...
}
</code></pre>

<p>That will make sure that <code>vectorInts</code> will be created at the start and deleted at the end of every iteration of the outer <code>for</code> loop.</p>

<hr>

<p>As @paddy pointed out in a comment, it will more efficient if you create the vector with the required size outside the <code>for</code> loop and just use its elements using the array indexing operator rather than using <code>push_back</code>.</p>

<pre><code>// Create the vector with the known size.
std::vector&lt;int&gt; vectorInts(vecMaxSize);
for(int i = 0; i &lt; MAXVALUE; i++){
   for(int k = 0; k &lt; vecMaxSize;k++){
      int randNum = rand()%MAXVALUE;

      // Set the element of vectorInts.
      vectorInts[i] = randNum;
   }
   ...
   sortVector(vectorInts);
   //Print vector here...
}
</code></pre>
",7
42644494,42640560,0,"<p>I just wanted to point your attention on the fact that</p>

<pre><code>int randNum = rand()%MAXVALUE;
</code></pre>

<p>will not produce real random number, it is incorrect way, the numbers will not be generated uniformly</p>

<p>rand() returns a pseudo-random integral number in the range between 0 and RAND_MAX. RAND_MAX depends on library implementation. 
To understand the issue, imagine that on your system RAND_MAX is 15, and your MAXVALUE is 10. Then number 3 can come from 3 and 13, while number 6 can come only from 6. Thus numbers 0,1,2,3,4 has double chances to outcome from rand()%MAXVALUE, comparing to chances of numbers 6,7,8,9...</p>

<p>If MAXVALUE > RAND_MAX, then some numbers will never be achieved in rand() call.</p>

<p>There are other ways to generate uniformly generated random numbers. </p>
",1
39127489,39127389,2,"<p>C++ doesn't include any graphical library in it. So you need to use any existing third-party library or API of operating system.</p>
<p>For example, there exists next graphical libraries, which supports C++:</p>
<ol>
<li>MFC</li>
<li>Qt</li>
<li>wxWidgets</li>
<li>TCL/Tk</li>
<li>GTK+</li>
</ol>
<p>Some of them are object oriented and some - not. Some of them are portable, some - not. Some of them are proprietary, some - not.</p>
<p>Also you always can use low-level API's such as Win32 API</p>
",2
36233874,36233787,0,"<p>using cin will skip white space by default. you can try other ways:</p>

<p><a href=""http://www.cplusplus.com/reference/istream/istream/get/"" rel=""nofollow"">cin.get();</a></p>

<p>exactly this code overload of function would help you:</p>

<pre><code>istream&amp; get (char* s, streamsize n, char delim);
</code></pre>

<p>put '\n' in delim to end input line on pushing enter</p>
",3
35210268,35210142,2,"<p>You're looking for an array.</p>

<pre><code>int a[10];

// Loop that assigns all elements in array a to 0
for (int i = 0; i &lt; 10; i++)
{
    a[i] = 0;
}

// Array b will have all of it's members initialized to 0
int b[10]{};

// You can also assign different values to different elements of the array
b[0] = 6;
b[8] = 2;

// You can then use the array elements in operations
int c = b[0] * b[8];
</code></pre>

<p>If you want array like structure without compile time defined size, then use std::vector.</p>

<pre><code>// An empty vector of ints
std::vector&lt;int&gt; d;

// A simple int
int e = 5;

// Push 2 values to the end of the vector
d.push_back(2);
d.push_back(e);

// Use the members for operations
int f = d.at(0) * d.at(1);
</code></pre>
",8
35211351,35210142,1,"<p>Since you've now described the problem you're trying to solve instead of just the problem with the solution you came up with:</p>

<p>You don't need to invent variable names or use arrays to compute averages and maximums.</p>

<p>Here's an example of how you can compute an average of the numbers a user inputs:</p>

<pre><code>float sum = 0;
int elements = 0;
float input = 0;
while (cin &gt;&gt; input)
{
    sum += input;
    elements += 1;
}
std::cout &lt;&lt; ""Average: "" &lt;&lt; sum / elements &lt;&lt; std::endl;
</code></pre>

<p>It's easy to expand this to also keep track of the maximum value so far.</p>

<p>To expand to the average and maximum of a number of series, add another loop ""around"" it.</p>
",2
37629078,37615096,3,"<p>I can confirm that this is a bug in the VS2005 CRT 64 bit implementation of fmod. It's easy to repeat: Make sure the DivByZero flag in the FPU is raised just before calling z=fmod(x,y) where x=0.0 and y=1.0, then z will be NaN which is wrong of course.</p>

<p>So this has nothing to do with multi-threading, nor memory corruption. It's just a bug in that CRT lib.</p>

<p>I made a little test app using VirtualAlloc to have some executable memory in which i put the code bytes to do a divide by zero in the FPU so that the FPU DivByZero flag is raised. (VS2005 can't inline 64 bit assembly code therefore the exe ram trick) Then i do the above mentioned fmod function call and indeed z is displayed as -1.#IND00 = NaN. All steps double-checked in the debugger. QED.</p>

<p>I'm amazed i could not find anything about this CRT bug on the www. Am i the first one to discover this CRT bug?</p>

<p>Anyway, the question has been answered. Conclusion: I'll use an alternative implementation for fmod.</p>

<p>PS: In case someone wants to repeat the test, here are the x86 code bytes i used to force a raised DivByZero flag in the FPU:</p>

<pre><code>0xD9,0xEE = fldz
0xD9,0xE8 = fld1
0xD8,0xF1 = fdiv ST(0),ST(1)
0xDD,0xD8 = fstp ST(0) = pop stack
0xDD,0xD8 = fstp ST(0) = pop stack
0xC3 = ret
</code></pre>
",1
37627136,37626999,1,"<p><code>cout &lt;&lt; unit (o) &lt;&lt; "" "";</code></p>

<p>Look! You are output the return value of <code>unit</code>.</p>

<p>But what does it return, let's see :)</p>

<pre><code>bool unit(int unit);
</code></pre>

<p>So it's a <code>bool</code>, either <code>true</code> or <code>false</code> (those will get outputted as <code>1</code> and <code>0</code>)</p>

<p>When does the function return?</p>

<pre><code>bool unit(int unit)
{
    if (unit == 1)
        cout &lt;&lt; ""one"";
    else if (unit == 2)
        cout &lt;&lt; ""two"";
    else if (unit == 3)
        cout &lt;&lt; ""three"";
    else if (unit == 4)
        cout &lt;&lt; ""four"";
    else if (unit == 5)
        cout &lt;&lt; ""five"";
    else if (unit == 6)
        cout &lt;&lt; ""six"";
    else if (unit == 7)
        cout &lt;&lt; ""seven"";
    else if (unit == 8)
        cout &lt;&lt; ""eight"";
    else if (unit == 9)
        cout &lt;&lt; ""nine"";
    //else if (unit == 0)
      //  cout &lt;&lt; ""zero"";
    //else
        //cout &lt;&lt; ""not a unit digit number."" &lt;&lt; endl;
}
</code></pre>

<p>What, it doesn't even return... So, the return value will be garbage (your compiler should warn you about this though (mine does)).</p>

<p>Those random numbers you see are those garbage values that <code>unit</code> returns. The logic is weird because <code>unit</code> outputs the numbers already, so you don't even need to return anything from <code>unit</code>, less print it.</p>

<p>Just call <code>unit</code> (this goes the same for the other 2 functions):</p>

<pre><code>if (t == 0 &amp;&amp; o != 0)
    unit(o);
</code></pre>
",7
35232388,35232337,8,"<p>Drop the single quotes used in the <code>case</code> statements.</p>

<p>Change</p>

<pre><code> case '1':
</code></pre>

<p>to</p>

<pre><code>case 1: 
</code></pre>

<p>Similarly for others.</p>

<p><code>'1'</code> is a character constant while <code>1</code> is the integer constant. When ASCII encoding is used, <code>'1'</code> evaluates to the number <code>49</code>, which clearly is not equal to the number <code>1</code>. Hence, that <code>case:</code> branch is not executed when you enter <code>1</code> as your input.</p>
",3
35232867,35232337,1,"<p>'break' statement is missing for Case 2 and change case '1': to case 1.</p>
",1
35232443,35232337,3,"<p><code>'1'</code> is a character.  When you input <code>1</code> into an integer it is stored as <code>1</code> not <code>'1'</code>.  You need to change all the cases of <code>'x'</code> to <code>x</code>.</p>

<p>The reason you do not get any errors about this is that <code>'1'</code> can be implicitly converted to an <code>int</code> and it has a value of the implementations character encoding.  If it was ASCII the it would be <code>49</code></p>
",0
35232488,35232337,2,"<p>Two solutions:</p>

<p>Change <code>int choice</code> to <code>char choice</code></p>

<p>Or</p>

<p>Change <code>case '1':</code> to <code>case 1:</code>.</p>
",0
35291935,35291874,0,"<pre><code>g++ h.cpp
./h r.txt
./h.exe r.txt # for windows
</code></pre>

<p>work's for me, output:</p>

<pre><code>Connection status
file opened
0
</code></pre>
",2
35291973,35291874,2,"<p>You need to remove the quotes.
Try this</p>

<pre><code>h r.txt
</code></pre>

<p>else it will find the file <code>""r.txt""</code> which doesn't exist.</p>
",0
37910219,37910195,4,"<blockquote>
  <p>Why is <code>~CItemPriceListTableCache</code> funtion body empty ? </p>
</blockquote>

<p>Because no special action needs to be taken on destruction, but the destructor still should be callable for this class.</p>

<blockquote>
  <p>If i delete from class.cpp the ~CItemPriceListTableCache should be ok ? Will affect this my codes ? </p>
</blockquote>

<p>Yes, you will be left with an undefined reference error.</p>

<blockquote>
  <p>With what should i replace  ~CItemPriceListTableCache function body ? I just don't like to see empty functions. Even if i have one line in function is ok for me , i just don't like function to be empty. </p>
</blockquote>

<p>You can write </p>

<pre><code>virtual ~CItemPriceListTableCache() {}
</code></pre>

<p>or </p>

<pre><code>virtual ~CItemPriceListTableCache() = default;
</code></pre>

<p>in your class declaration.</p>

<blockquote>
  <p>If i complete delete virtual decalaration of destructor from class should be ok ?</p>
</blockquote>

<p>Yes, the default destructor generated by the compiler, will be just fine.</p>
",2
46103640,46103267,1,"<p>Let's break this code down.</p>

<pre><code>for (i = 0; i &lt; MAX_NUMBERS; i++)
</code></pre>

<p>We're doing a for-loop with 6 iterations.</p>

<pre><code>number = numberGen();
</code></pre>

<p>We're generating a new number, and storing it into the variable <code>number</code>. This variable isn't used anywhere else.</p>

<pre><code>for (int j = 0; j &lt; MAX_NUMBERS; j++)
</code></pre>

<p>We're looping through the array again...</p>

<pre><code>    if (picked[i] == picked[j])
</code></pre>

<p>Checking to see if the two values match (fyi, <code>picked[n] == picked[n]</code> will <strong>always</strong> match)</p>

<pre><code>        picked[j] = numberGen();
</code></pre>

<p>And assigning a new random number to the <em>existing</em> value if they do match.</p>

<p>A better approach here would be to eliminate a duplicate value if one exists, <em>then</em> assign it to your array. For example:</p>

<pre><code>for (i = 0; i &lt; MAX_NUMBERS; i++)
{
    bool isDuplicate = false;

    do
    {
        number = numberGen(); // Generate the number

        // Check for duplicates
        for (int j = 0; j &lt; MAX_NUMBERS; j++)
        {
            if (number == picked[j])
            {
                isDuplicate = true;
                break; // Duplicate detected
            }
        }
    }
    while (isDuplicate); // equivalent to while(isDuplicate == true)

    picked[j] = number;
}
</code></pre>

<p>Here, we run a do-while loop. The first iteration of the loop will generate a random number, and checks to see if it's a duplicate already in the array. If it is, it re-runs the loop until a non-duplicate is found. Once the loop breaks, we have a valid, non-duplicate number available, and then we assign it to the array.</p>

<p>There are going to be better solutions available as you progress through your course.</p>
",0
46105101,46103267,1,"<h1>C++17 sample</h1>

<p>C++17 provides an algorithm for exactly this (go figure):</p>

<p><a href=""http://en.cppreference.com/w/cpp/algorithm/sample"" rel=""nofollow noreferrer"">std::sample</a></p>

<blockquote>
<pre><code>template&lt; class PopulationIterator, class SampleIterator,
          class Distance, class UniformRandomBitGenerator &gt;
SampleIterator sample( PopulationIterator first, PopulationIterator last,
                       SampleIterator out, Distance n, 
                       UniformRandomBitGenerator&amp;&amp; g);
</code></pre>
  
  <p>(since C++17)</p>
  
  <p>Selects n elements from the sequence [first; last) such that each
  possible sample has equal probability of appearance, and writes those
  selected elements into the output iterator out. Random numbers are
  generated using the random number generator g. [...]</p>
</blockquote>

<pre><code>constexpr int min_value = 1;
constexpr int max_value = 49;
constexpr int picked_size = 6;

constexpr int size = max_value - min_value + 1;

// fill array with [min value, max_value] sequence
std::array&lt;int, size&gt; numbers{};
std::iota(numbers.begin(), numbers.end(), min_value);

// select 6 radom
std::array&lt;int, picked_size&gt; picked{};
std::sample(numbers.begin(), numbers.end(), picked.begin(), picked_size,
            std::mt19937{std::random_device{}()});
</code></pre>

<h1>C++11 shuffle</h1>

<p>If you can't use C++17 yet then the way to do this is to generate all the numbers in an array, shuffle the array and then pick the first 6 numbers in the array:</p>

<pre><code>// fill array with [min value, max_value] sequence
std::array&lt;int, size&gt; numbers{};
std::iota(numbers.begin(), numbers.end(), min_value);

// shuffle the array
std::random_device rd;
std::mt19937 e{rd()};

std::shuffle(numbers.begin(), numbers.end(), e);

// (optional) copy the picked ones:

std::array&lt;int, picked_size&gt; picked{};
std::copy(numbers.begin(), numbers.begin() + picked_size, picked.begin());
</code></pre>

<p>A side note: please use the new C++11 random library. And prefer <code>std::array</code> to bare C arrays. They don't decay to pointers and provide <code>begin</code>, <code>end</code>, <code>size</code> etc. methods.</p>

<hr>
",0
46104799,46103267,0,"<h3>Efficient approach: Limited Fisher¨CYates shuffle</h3>
<p>For drawing n numbers from a pool of m you need n calls to random for this approach (6 in your case) instead of m-1 (49 in your case) used when simply shuffling the whole array or vector. So <strong>the approach shown below is much more efficient than simply shuffling the whole array</strong> and <strong>does not require any duplicate checking</strong>.</p>
<ol>
<li>random numbers can get really expensive, so I thought it might be a good idea never to generate more random numbers than necessary. Simply running rand() multiple times until a fitting number comes out seems no good idea.</li>
<li>repetitive double check drawing gets especially expensive in the case that nearly all of the available numbers need to be drawn</li>
<li>I wanted to do it stateful, so it doesn¡ät matter how many numbers of the 49 you actually request</li>
</ol>
<p>The solution below does not do any duplicate checking and calls rand() exactly n times for n random numbers. A slight modification of your numberGen was necessary therefore. Albeit you really should use the random library functions instead of rand().</p>
<p>The code below draws all numbers, just to verify that everything works fine, but its easy to see how you would draw only 6 numbers :-)</p>
<p>If you need repetitive draws you can simply add a reset() member function that sets <code>drawn = 0</code> again. The vector is in shuffled state then, but that doesn¡ät do any harm.</p>
<p>If you can¡ät afford the range checking in <code>std::vector.at()</code> you can of course easily replace it by the index access operator[]. But I thought for experimenting with the code at() is a better choice and in this way you get error checking for the case that too many numbers are drawn.</p>
<p><strong>Usage:</strong>
Create a class instance of n_out_of_m using the constructor which takes as an argument the amount of available numbers.</p>
<p>Call draw() repetitively to draw numbers.</p>
<p>If you call draw() more often then numbers are available the std::vector.at() will throw an out_of_range exception, if you don¡ät like that you need to add a check for that case.</p>
<p>I hope someone likes this approach.</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;

size_t numberGen(size_t limit)
{
    size_t number = rand();
    size_t target = (number % limit) + 1;
    
    return target;
}

class n_out_of_m {
public:
           n_out_of_m(int m) {numbers.reserve(m); for(int i=1; i&lt;=m; ++i) numbers.push_back(i);}
    int    draw();
private:
    std::vector&lt;int&gt; numbers;
    size_t drawn = 0;
};

int n_out_of_m::draw()
{
    size_t index = numberGen(numbers.size()-drawn) - 1;
    std::swap(numbers.at(index), numbers.at(numbers.size()-drawn-1));
    drawn++;
    return numbers.at(numbers.size()-drawn);
};

int main(int argc, const char * argv[]) {
    n_out_of_m my_gen(49);
    for(int n=0; n&lt;49; ++n)
       std::cout &lt;&lt; n &lt;&lt; &quot;\t&quot; &lt;&lt; my_gen.draw() &lt;&lt; &quot;\n&quot;;
        
    return 0;
}
</code></pre>
",0
43237570,43236904,0,"<p>Correct, what you're doing with your vector doesn't exactly make sense.  When you call push_back() and the vector's size changes; there's an automatic reallocation of the storage for the entire vector.  So potentially, the previously added elements may no longer exist at their original address.</p>

<p>A quick fix for this is to pre-allocate all of the indexes you'd wish to use using v.resize(). So the following code should work:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;

class Test{
    public :
        int wiek;
};

int main(int argc, char **argv)
{
    std::vector&lt;Test&gt; v;
    std::vector&lt;Test*&gt; vv;

    v.resize(36);

    for (int i = 0; i &lt; 12; i++) {
        Test t;
        t.wiek = 10;
        v.push_back(t);
        vv.push_back(&amp;v.back());
    }

    Test&amp; m = v.back();

    for (int i = 0; i &lt; 24; i++) {
        Test t;
        t.wiek = 123;
        v.push_back(t);
        vv.push_back(&amp;v.back());
    }

    for (int i = 0; i &lt; 36; i++) {

        std::cout&lt;&lt;""vv.at(i)-&gt;wiek : ""&lt;&lt;vv.at(i)-&gt;wiek&lt;&lt;""\n"";
    }

//    vv.at(i)-&gt;wiek : 10
//    vv.at(i)-&gt;wiek : 10
//    vv.at(i)-&gt;wiek : 10
//    vv.at(i)-&gt;wiek : 10
//    vv.at(i)-&gt;wiek : 10
//    vv.at(i)-&gt;wiek : 10
//    vv.at(i)-&gt;wiek : 10
//    vv.at(i)-&gt;wiek : 10
//    vv.at(i)-&gt;wiek : 10
//    vv.at(i)-&gt;wiek : 10
//    vv.at(i)-&gt;wiek : 10
//    vv.at(i)-&gt;wiek : 10
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123
//    vv.at(i)-&gt;wiek : 123

    return 0;
}
</code></pre>

<p>However, If you don't know what the final size would be.  You'd have to create the entirety of the ""v"" vector prior to assigning all of its element's addresses to ""vv"".  </p>
",2
43237688,43236904,1,"<p>If you need a container which permits random access and which guarantees that item references are not invalidated when the container grows, use <code>std::deque</code>.</p>
",0
37700057,37697542,1,"<p>You can use <code>std::fixed</code>.  This will, like <code>printf</code> do, force to print all the precision decimals.  This means that <code>5</code> is now printed <code>5.000000</code>, if you don't mind more than one unneeded 0.</p>

<p>If you do mind, I don't see many solutions, but to write the string in memory with an <code>ostringstream</code> or with <code>sprintf</code>, then to append <code>"".0""</code> if you cannot find a point in it, and to print that string.</p>
",0
40775880,40775667,1,"<p>Solution:</p>

<pre><code>i=0;
</code></pre>

<p>Delete below code on top of the while loop</p>

<pre><code>len++;
</code></pre>

<p>You are actually getting an exception there. Because on the last run, you are having indexoutofbound exception.</p>

<p>If your string is ""hello"" the length is 5 which mean your index is 0,1,2,3,4.</p>

<pre><code>h e l l o
0 1 2 3 4
</code></pre>

<p>With your len++ it raised the length to 6. And on the last round of while(5&lt; 6) you are tring to access index of 5 which does not exist</p>

<p>Hope it helps</p>
",1
42477937,42477841,0,"<pre><code>new uint8_t(w*h);
</code></pre>

<p>This allocates exactly one <code>uint8_t</code>, whose initial value is <code>w*h</code>.</p>

<p>You probably intended:</p>

<pre><code>new uint8_t[w*h];
</code></pre>

<p>Otherwise, this:</p>

<pre><code>file_stream.read((char *)M.m_input_image-&gt;m_data ,m_a * m_b);
</code></pre>

<p>will immediately overrun this buffer. The same bug occurs several times in the shown code.</p>

<pre><code>delete  m_data;
</code></pre>

<p>Stuff allocated with <code>new[]</code> should be deallocated with <code>delete[]</code>.</p>

<p>In general, your overall approach is very error-prone. Instead of manually handling memory, in this fashion, you should be using <code>std::vector</code>, and iterators. Correct usage of C++'s containers greatly reduces the possibility of making these kinds of bugs.</p>
",1
43978082,43976991,3,"<p>When you call:</p>

<pre><code>container.add&lt;DataClassA&gt;(data_a);
//            ^^^^^^^^^^^
</code></pre>

<p>explicitly providing the template parameter means that the compiler does not deduce the template parameter (i.e. you do not get forwarding reference behaviour).</p>

<p>Instantiating <code>add</code> with <code>DataClassA</code> as template parameter means its signature is:</p>

<pre><code>void add(DataClassA&amp;&amp; tag) 
</code></pre>

<p>which is an rvalue reference, not a forwarding reference, therefore an lvalue argument cannot bind to it.</p>

<p>To use perfect forwarding you must let the compiler deduce the template parameter from the argument.  There are three possible deductions (<code>T</code>, <code>T&amp;</code>, <code>T&amp;&amp;</code>) based on the value category of the argument and this is how <code>std::forward</code> reproduces the value category of the argument:</p>

<pre><code>container.add(data_a);
</code></pre>
",0
42629703,42623767,0,"<p>The problem you have is in your <code>minion</code> class:</p>

<pre><code>class minion::Enemy{
public:
    int specialAttack(int x)
    {
        int attackPower = x;
        cout &lt;&lt; ""Take this you chump! "" &lt;&lt; attackPower + 6; 
    }
};
</code></pre>

<p>In order to declare a child class, it needs to have to following syntax:</p>

<pre><code>class ChildClass : public ParentClass
{
    // Declare variable and/or functions
};
</code></pre>

<p>You are confusing the syntax for implementing a function outside of its class with declaring a new class. You can implement functions outside of their class like:</p>

<pre><code>void AnyClassFunction::AnyClass {
</code></pre>

<p>However, you cannot use the same syntax to declare a child class. You should change the header line of your <code>minion</code> class to:</p>

<pre><code>class minion : public Enemy{ // This tells the compiler that the minion class is inherited from the Enemy class
public:
    int specialAttack(int x)
    {
        int attackPower = x;
        cout &lt;&lt; ""Take this you chump! "" &lt;&lt; attackPower + 6; 
    }
};
</code></pre>
",0
36668283,36667994,1,"<p>There are several possibilities,  but if <code>cout&lt;&lt;name()</code> causes a segmentation fault, the most probable cases are:  </p>

<ul>
<li><code>name_</code> is still nullptr</li>
<li><code>name_</code> is an invalid pointer (for example if you copied your structure, which doesn't respect the <a href=""https://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29"" rel=""nofollow"">rule of 3</a>)  </li>
</ul>

<p>To make your code more reliable, you could change all <code>char*</code>, their  tedious memory allocations and the c-style string operations with <code>string</code>.  </p>

<p>If you don't, make sure to respect the rule of 3 to avoid shallow copy and pointer issues when copying or copy constructing your struct, and make sure that when you use a fixed size char array, you're sure not to overflow the buffer  </p>

<p>Note also that doing this, might overflow the buffer:    </p>

<pre><code>    file.getline(n, ',');
    name(n);
</code></pre>

<p>because <a href=""http://www.cplusplus.com/reference/istream/istream/getline/"" rel=""nofollow""><code>istream::getline()</code></a>, when it has two arguments, takes as second argument the size (here 44, the ascii value of the comma). <code>file.getline(n, 7, ',')</code> would be the correct form. </p>
",1
45715647,45715219,2,"<p>You cannot store functions with different signatures in a container like <code>map</code>, no matter if you store them as a function pointer or <code>std ::function&lt;WHATEVER&gt;</code>. The information about the signature of the function is one and only one in both cases.</p>

<p>The types for the <code>value</code> in <code>map</code> is one, meaning that the object stored in it are <strong>all of the same type</strong>.</p>

<p>So if your functions have all the same signature, then it's easy, otherwise, you have to abandon type safety and start walking in a very dangerous realm.
The one in which you <strong>erase the type information</strong> about the functions stored inside the map.
This translates to something like <code>map&lt;string, void*&gt;</code>.</p>
",2
45716315,45715219,6,"<p>The most (I cannot say best here) you can do is to use a signature erasure. That mean to convert the pointer to functions to a common signature type, and then convert them back to the correct signature before using them.</p>

<p>That can only be done in very special use cases (I cannot imagine a real world one) and will be highly unsecure: nothing prevent you to pass the wrong parameters to a function. In short: <strong>NEVER DO THIS IN REAL WORLD CODE</strong>.</p>

<p>That being said, here is a working example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;

typedef void (*voidfunc)();

void foo(int x, int y)
{
    std::cout &lt;&lt; ""foo "" &lt;&lt; x &lt;&lt; "" "" &lt;&lt; y &lt;&lt; std::endl;
}

void bar(std::string x, int y, int z)
{
    std::cout &lt;&lt; ""bar "" &lt;&lt; x &lt;&lt; "" "" &lt;&lt; y &lt;&lt; "" "" &lt;&lt; z &lt;&lt; std::endl;
}

int main()
{
    std::map&lt;std::string, voidfunc&gt; m;
    m[""foo""] = (voidfunc) &amp;foo;
    m[""bar""] = (voidfunc)&amp; bar;
    ((void(*)(int, int)) m[""foo""])(1, 2);
    ((void(*)(std::string, int, int)) m[""bar""])(""baz"", 1, 2);
    return 0;
}
</code></pre>

<p>It gives as expected:</p>

<pre><code>foo 1 2
bar baz 1 2
</code></pre>

<p>I could not find in standard whether this invokes or not Undefined Behaviour because little is said about function pointer conversions, but I am pretty sure that all common compilers accept that, because it only involve <em>function pointers</em> casting.</p>
",1
45718187,45715219,25,"<p>You can type-erase the function types into a container, then provide a template <code>operator()</code>. This will throw <code>std::bad_any_cast</code> if you get it wrong.</p>
<p>N.B. because of the type erasure, you will have to specify exactly matching arguments at the call site, as e.g. <code>std::function&lt;void(std::string)&gt;</code> is distinct from <code>std::function&lt;void(const char *)&gt;</code>, even though both can be called with a value like <code>&quot;Hello&quot;</code>.</p>
<pre><code>#include &lt;any&gt;
#include &lt;functional&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

template&lt;typename Ret&gt;
struct AnyCallable
{
    AnyCallable() {}
    template&lt;typename F&gt;
    AnyCallable(F&amp;&amp; fun) : AnyCallable(std::function(std::forward&lt;F&gt;(fun))) {}
    template&lt;typename ... Args&gt;
    AnyCallable(std::function&lt;Ret(Args...)&gt; fun) : m_any(fun) {}
    template&lt;typename ... Args&gt;
    Ret operator()(Args&amp;&amp; ... args) 
    { 
        return std::invoke(std::any_cast&lt;std::function&lt;Ret(Args...)&gt;&gt;(m_any), std::forward&lt;Args&gt;(args)...); 
    }
    std::any m_any;
};

void foo(int x, int y)
{
    std::cout &lt;&lt; &quot;foo&quot; &lt;&lt; x &lt;&lt; y &lt;&lt; std::endl;
}

void bar(std::string x, int y, int z)
{
    std::cout &lt;&lt; &quot;bar&quot; &lt;&lt; x &lt;&lt; y &lt;&lt; z &lt;&lt; std::endl;
} 

using namespace std::literals;

int main()
{
    std::map&lt;std::string, AnyCallable&lt;void&gt;&gt; map;
    
    map[&quot;foo&quot;] = &amp;foo;      //store the methods in the map
    map[&quot;bar&quot;] = &amp;bar;
    
    map[&quot;foo&quot;](1, 2);       //call them with parameters I get at runtime
    map[&quot;bar&quot;](&quot;Hello, std::string literal&quot;s, 1, 2);
    try {
        map[&quot;bar&quot;](&quot;Hello, const char *literal&quot;, 1, 2); // bad_any_cast
    } catch (std::bad_any_cast&amp;) {
        std::cout &lt;&lt; &quot;mismatched argument types&quot; &lt;&lt; std::endl;
    }
    map[&quot;bar&quot;].operator()&lt;std::string, int, int&gt;(&quot;Hello, const char *literal&quot;, 1, 2); // explicit template parameters
    
    return 0;
}
</code></pre>
",8
40998392,40998351,2,"<p>You just need to pass object B a reference to the object you are trying to use, such as...</p>

<p>Note: When you pass objects as function arguments that are not just POD, it is best practice to pass them by constant reference if you aren't modifying them (that way you aren't making a copy of the whole object, which could be large, you just pass a pointer). However in this case, as it is now a const reference, you can only call const functions which is why I made your printX const. Presumably printX isn't modifying A, so it should be const.</p>

<p><code>A.h</code></p>

<pre><code>class A
{
   int x;
   A() 
   { 
      //x is being read from a file 
   }
   void printX() const;
};
</code></pre>

<p><code>B.h</code></p>

<pre><code>class B
{
   void somefunction(const A&amp; objectA) 
   {
      objectA.printX();
   }
}
</code></pre>

<p><code>main.cpp</code></p>

<pre><code>main()
{
   A objectA;
   ...
   B objB;
   objB.somefunction(objectA);
}
</code></pre>
",0
34965089,34965067,5,"<p>Your constructor did not initialize any of the members: <code>MyClass::x</code>, <code>MyClass::y</code> nor <code>MyClass::z</code>.</p>

<p>You must do:</p>

<pre><code>MyClass::MyClass(float x, float y, float z)
{
    this-&gt;x = x;
    this-&gt;y = y;
    this-&gt;z = z;
};
</code></pre>

<p>or better yet (more idiomatic, and possibly faster):</p>

<pre><code>MyClass::MyClass(float x, float y, float z) : 
    x( x ), y( y ), z( z )
{
};
</code></pre>

<p>Without that, you're printing the values of uninitialized members of the <code>MyClass</code> object <code>One</code>. In general, you must <a href=""https://stackoverflow.com/questions/2614809/what-is-the-default-value-for-c-class-members"">always initialize members of a class</a> before you can use them.</p>
",9
34965130,34965067,2,"<p>Your current constructor does nothing.</p>

<p>You have to initialize your objects variable. For this you can use</p>

<pre><code>MyClass::MyClass(float x, float y, float z) : x(x), y(y), z(z) 
{
}
</code></pre>

<p>This type of initialization in constructors is called <em>initializer list</em>, you can read it up <a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""nofollow"">here</a>.</p>

<p>This has the same effect as the constructor pointed out by @jpo38.</p>
",5
34945059,34835425,3,"<p>As IgorTandetnik pointed out, you ran into C++'s Most vexing parse. The solution (if your compiler understands C++11) is to use uniform initialization syntax.</p>

<p>clang has a suggestion that will work even in C++98:</p>

<pre><code>cin-vec.cc:7:21: warning: parentheses were disambiguated as a function declaration [-Wvexing-parse]
std::vector&lt; int &gt; v(std::istream_iterator&lt; int &gt;(std::cin),
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cin-vec.cc:7:22: note: add a pair of parentheses to declare a variable
std::vector&lt; int &gt; v(std::istream_iterator&lt; int &gt;(std::cin),
                     ^
                     (                                     )
cin-vec.cc:12:19: error: member reference base type 'std::vector&lt;int&gt; (std::istream_iterator&lt;int&gt;, std::istream_iterator&lt;int&gt; (*)())' is not a structure or union
    std::cout &lt;&lt; v.size();
                 ~^~~~~
</code></pre>

<p>i.e. change your code to:</p>

<pre><code>std::vector&lt; int &gt; v((std::istream_iterator&lt; int &gt;(std::cin)),
                std::istream_iterator&lt; int &gt;() );
</code></pre>
",0
40974768,40974639,1,"<p>In the simplest case you're just looking for the number of <code>'\n'</code> characters in the file.</p>

<p>So let's say that you've successfully opened the file to: <code>ifstream pFile</code> then you can use an <a href=""http://en.cppreference.com/w/cpp/iterator/istreambuf_iterator"" rel=""nofollow noreferrer""><code>istreambuf_iterator</code></a> to count those:</p>

<pre><code>const auto numLines = count(istreambuf_iterator&lt;char&gt;(pFile), istreambuf_iterator&lt;char&gt;(), '\n')
</code></pre>

<p>A couple comments here:</p>

<ol>
<li>The this <code>count</code> operation will consume everything in <code>pFile</code>'s buffer, meaning you'll need to call <code>pFile.seekg(0, ios_base::beg)</code></li>
<li>Picking and choosing values to read from an <code>ifstream</code> indicates a bad smell in code. It's likely that the file format was improperly conceived, or that the program will subsequently need to re-stream the remainder of file contents. The 2<sup>nd</sup> option seems to be true in your case, as you seek to illegally set the size of an array with a value found at runtime:</li>
</ol>

<blockquote>
  <p>The reason I need a constant <code>int</code> is so I can set array to that size</p>
</blockquote>

<p><strong>EDIT:</strong></p>

<p>When you say you want to use <code>numLines</code> to ""right an array""<sub>[sic]</sub>, my assumption is that the only reason that you would have needed your array to be that size is that you're going to stream each line from a file into your container, that is you're going to stream the entire file once to calculate the size then stream the entire file again to populate your container. Here's what you should do instead:</p>

<pre><code>vector&lt;string&gt; lines;

for(string line; getline(pFiles, line);) {
    lines.push_back(line);
}
</code></pre>

<p>Now <code>lines</code> will contain your entire file, with each element being a line. If <code>numLines</code> would have been important to you, instead you can use <code>size(lines)</code>.</p>
",4
40974771,40974639,1,"<p>You can initialize a <code>const int</code> just the same as you would initialize a regular <code>int</code>. The difference with a <code>const int</code> is that you cannot re-assign after initialization.</p>

<pre><code>const int numLines = sizeOfFile(inputFile);
for(int i = 0, i &lt; numLines; i++){
  //code here
}
</code></pre>
",11
41929456,41929434,3,"<p>Call the functions using the function pointer <code>array</code> like following:</p>

<pre><code> (*array[i]) ( 0 );
</code></pre>

<p>Update you <code>callFunctions</code> as:</p>

<pre><code>/* void */ callFunctions( void (*fptr[ ])(int), int size )
{
   // (*fptr[ i ])( 0 );
}
</code></pre>
",3
46085227,33400777,138,"<p>Check project configuration. <strong>Linker</strong>-><strong>System</strong>-><strong>SubSystem</strong> should be <strong>Windows</strong>.</p>
",1
41649426,41649319,5,"<p>It is not a ""three elements typedef"", it is a pointer to member variable typedef. You can find more information about pointer to member variable <a href=""https://stackoverflow.com/a/670744/4745527"">here</a>.</p>

<p>In your precise case, it allows you to instantiate variables of type ""rt"" that will point to a precise member of type <code>int</code> of <code>A</code> class, and then use it to access this member on <code>A</code> instances.</p>

<pre><code>#include &lt;iostream&gt;

class A{
public:
    int c;
};
typedef int A::* rt;

int main() {
  A instance;
  rt member; // This is a pointer to A member.
  member = &amp;A::c; // This pointer will point on c member of A class

  instance.c = 0;
  instance.*member += 2; // As member point on c, this code access to the c member.
  std::cout &lt;&lt; instance.c &lt;&lt; std::endl; // This will now output ""2"".
}
</code></pre>
",0
41649447,41649319,2,"<p>It's pointer to member variable.
You define it with this syntax: <code>int A::* pointer;</code>, and initialize it <code>$A::c</code> and read it's value <code>instance.*pointer</code>.</p>

<p><code>A instance;
int A::* pointer = &amp;A::c;
instance.*pointer = 10;
</code></p>

<p>Actually it's an offset from beginning of the class that allow you to hold a pointer to <code>int</code> that is a member variable of class <code>A</code>.</p>
",0
43196121,43196106,4,"<p>Numeric literals with leading zeros are assumed to be octal numbers. Don't use leading zeros.</p>
",0
43196122,43196106,0,"<blockquote>
  <p><em>integer array element with leading 0 showing garbage output</em></p>
</blockquote>

<p>You do not get ""<strong>garbage</strong>"" values; the compiler mainly interprets the values in your array that have leading zeros, like <em>012</em>, as octal values. The compiler then converts it into a decimal value (for <em>012</em>, it is <em>10</em>) and outputs that.</p>

<p>Don't use leading zeroes if you are working with the decimal system.</p>
",3
45115938,45115890,5,"<ol>
<li><p>The C++ language specification defines the <code>int main(int argc, char* argv[])</code> <a href=""http://en.cppreference.com/w/cpp/language/main_function"" rel=""nofollow noreferrer"">entrypoint function</a> - it has nothing to do with OpenCV at all - similarly OpenCV is not concerned with your program's entrypoint either: OpenCV is a library, not an application framework (like MFC or Qt).</p></li>
<li><p>OpenCV's <code>cv::String</code> type <a href=""http://docs.opencv.org/trunk/d1/d8f/classcv_1_1String.html#a3fcfff8db840709e39cd770100f2d886"" rel=""nofollow noreferrer"">defines a constructor from <code>const char* s</code></a> which will be used to provide <a href=""http://en.cppreference.com/w/cpp/language/implicit_conversion"" rel=""nofollow noreferrer"">an implicit conversion</a> to <code>cv::String</code>.</p></li>
<li><p>All command-line arguments are passed-in through <code>argv</code>, you cannot pass in non-<code>char</code>-type arguments with the standard C/C++ <code>main</code> entrypoint (this is because C and C++ do not define a convention for passing non-string arguments unlike, for example, PowerShell where Cmdlet arguments are defined in terms of .NET types). You will need to use <code>atof</code> or <code>sscanf</code> to convert arguments back into typed data.</p></li>
</ol>
",0
45115953,45115890,1,"<p><code>const char*</code> can be implicitly converted to <code>cv::String</code> according to <a href=""http://docs.opencv.org/trunk/d1/d8f/classcv_1_1String.html"" rel=""nofollow noreferrer"">the official cv::String Class Reference</a>.<br>
<em>A double type input</em> is technically impossible in command line. You can use <code>atof(const char*)</code> function to convert <code>char*</code> type to <code>float</code>/<code>double</code> type in your function.</p>
",0
45747470,45747404,0,"<p>each <code>index</code> is being destroyed at the end of their scope, rendering the pointers to them invalid</p>

<pre><code>std::vector&lt;std::ifstream *&gt; indexes;
for (int i = 0; i &lt; 254; i++) {
    std::ifstream index(root + ""main_file_cache.idx"" + std::to_string(i));
    if (!index.good())
        break;

    indexes.push_back(&amp;index);
} // index is destroyed here
</code></pre>

<p>you should change it to create them with <code>new</code> (just make sure you delete them when you're done)</p>

<pre><code>std::vector&lt;std::ifstream *&gt; indexes;
for (int i = 0; i &lt; 254; i++) {
    std::ifstream* index = new std::ifstream(root + ""main_file_cache.idx"" + std::to_string(i));
    if (!index-&gt;good())
        break;

    indexes.push_back(index);
}
</code></pre>

<p>or better yet, use <code>std::vector&lt;std::unique_ptr&lt;std::ifstream&gt;&gt;</code> and <code>std::make_unique</code> instead.</p>

<p>You'll likely have the same problem with <code>meta</code> and <code>data</code> when you return from <code>open</code>. </p>
",1
45747486,45747404,2,"<pre><code>    std::ifstream index(root + ""main_file_cache.idx"" + std::to_string(i));
</code></pre>

<p>This constructs a <code>std::ifstream</code> object. It gets declared with automatic scope.</p>

<pre><code>    indexes.push_back(&amp;index);
}
</code></pre>

<p>This pushes a pointer to the <code>std::ifstream</code> into the <code>indexes</code> vector, however because <code>index</code>'s automatic scope ends immediately afterwards, the <code>index</code> object gets immediately destroyed, with its corresponding file being closed. You declared this <code>std::ifstream</code> object in automatic scope, inside the inner loop. As such, the object gets destroyed at the end of the loop.</p>

<p>The subsequent code then attempts to dereference these pointers, that were stored in the <code>indexes</code> vector, which are now all dangling pointers. This results in undefined behavior.</p>

<p>Additionally, the <code>indexes</code> vector gets passed by value, which results in the vector getting copied, which adds to confusion.</p>

<p>You need to re-read the following chapters in your C++ book:</p>

<ul>
<li><p>The chapter that explains how automatic scope, and how dynamic scope works in C++.</p></li>
<li><p>The chapter that explains the difference between passing function arguments by reference and passing them by value, and what that means.</p></li>
</ul>
",0
38195232,38195064,0,"<pre><code>validFatGrams(fatGrams);
fatGrams = validFatGrams(fatGrams);
</code></pre>

<p>Get rid of the first line. As written, the code looks for valid input twice.</p>
",1
38195357,38195064,0,"<p>Credit to Xeren Narcy. Passing by reference worked. Also credit to Pete Becker and immibis. Removing the redundant call was the best way to fix the problem. Here's the result if anyone is interested. Thanks for the help. Also, is this the wrong place for me? As a beginner I don't want to waste your time...</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

const int VALID_CALORIES = 9;

double validFatGrams(double fatGrams);
double validCalories(double fatGrams, double calories);

int main()
{
    double fatGrams = 0, calories = 0, percentCalFromFat = 0;

    cout &lt;&lt; ""Enter the number of fat grams:"" &lt;&lt; endl;
    cin &gt;&gt; fatGrams;

    fatGrams = validFatGrams(fatGrams);

    cout &lt;&lt; ""Enter the number of calories:"" &lt;&lt; endl;
    cin &gt;&gt; calories;

    calories = validCalories(fatGrams, calories);

    cout &lt;&lt; fatGrams &lt;&lt; "" "" &lt;&lt; calories &lt;&lt; endl;
}

double validFatGrams(double fatGrams)
{
    while(fatGrams &lt; 0)
    {
        cout &lt;&lt; ""fat"" &lt;&lt; ""  "" &lt;&lt; fatGrams &lt;&lt; endl;
        cout &lt;&lt; ""Invalid input. The number of fat grams must be greater than 0"" &lt;&lt; endl;
        cout &lt;&lt; ""Enter the number of fat grams (greater than 0):"" &lt;&lt; endl;
        cin &gt;&gt; fatGrams;
    }
    return fatGrams;
}

double validCalories(double fatGrams, double calories)
{
    double passableCalories = 0;

    passableCalories = fatGrams * VALID_CALORIES;

    while(calories &lt; passableCalories)
    {
        cout &lt;&lt; ""cal"" &lt;&lt; ""  "" &lt;&lt; calories &lt;&lt; endl;
        cout &lt;&lt; ""Invalid input. The number of calories must be greater than 0"" &lt;&lt; endl;
        cout &lt;&lt; ""and must be greater than fat grams x 9."" &lt;&lt; endl;
        cout &lt;&lt; ""Enter a number of calories greater than "" &lt;&lt; passableCalories &lt;&lt; "":"" &lt;&lt;endl;
        cin &gt;&gt; calories;
    }
    return calories;
}
</code></pre>

<p>And a sample of fixed output ...</p>

<pre><code>Enter the number of fat grams:
-1
fat  -1
Invalid input. The number of fat grams must be greater than 0
Enter the number of fat grams (greater than 0):
1
Enter the number of calories:
2
cal  2
Invalid input. The number of calories must be greater than 0
and must be greater than fat grams x 9.
Enter a number of calories greater than 9:
3
cal  3
Invalid input. The number of calories must be greater than 0
and must be greater than fat grams x 9.
Enter a number of calories greater than 9:
20
1 20
</code></pre>

<p>Thanks again</p>
",0
45047405,45047356,2,"<p>It's a bit tricky to say, because link-time optimizers have become crazy smart over the years, but on paper, you are paying a bit of a cost.</p>

<p>That's because, when you get down to it, references are essentially pointers in disguise.</p>

<p>Case in point:
<a href=""https://godbolt.org/g/RZuYFj"" rel=""nofollow noreferrer"">https://godbolt.org/g/RZuYFj</a></p>

<p>Notice how the code with the <code>const&amp;</code> has an extra instruction? That's caused by the extra dereferenciation, which is ""somewhat"" costly, but not as bad as it looks, because a cache hit is almost guaranteed in that case.</p>

<p>However, as I mentionned, compile-time optimizers are crazy good, and link-time optimizers are getting there. So I'd use the following rule of thumb:</p>

<ol>
<li>For inline code, it almost certainly will never make a difference.</li>
<li>For linked code, you should assume you are paying a small cost if the type in question fits inside a single register.</li>
</ol>
",0
45047802,45047356,2,"<p>In leaf functions, passing by reference isn't likely to cause problems.</p>

<p>However, in non-leaf functions, passing by const reference can cause all kinds of grief, because you have to ensure that the reference stays live for the entire function call.  For parameters which are semantically pass by value, and the reference is introduced for efficiency (saving a copy), it's likely that the caller is not thinking about lifetime.</p>

<p>Consider the following code, which contains a bug:</p>

<pre><code>std::vector&lt;X&gt; v = some_func();
assert(v.size() &gt; 0);
v.push_back(v.front());
</code></pre>

<p><code>std::vector&lt;T&gt;::push_back(const T&amp;)</code> saves a copy by accepting its parameter by reference.  It also results in a constraint violation on perfectly reasonable-looking code like the above.  To wit, if <code>push_back</code> causes growth of the vector, it invalidates all existing iterators and pointers and references to elements.  The parameter is invalidated, breaking the requirement that arguments to library functions must be valid for the entire duration of the call.  The new location will be copy-constructed from an item that's either moved-from or even freed.  Inlining is no protection.</p>

<p>If <code>push_back</code> had accepted its argument by value, there would be no problem.</p>
",1
45048247,45047356,2,"<p>For built-in types (<code>int</code>, <code>bool</code>, <code>char</code>, <code>size_t</code>, <code>double</code>, etc.) and pointer types (<code>int*</code>, <code>char*</code>, etc.):</p>

<ul>
<li><strong>Pass by value.</strong> There is no performance benefit to passing these by const reference, it just adds extra work for the compiler to optimize. Some people like to add <code>const</code> to pass-by-value 
like <code>void f(const int x)</code>. This prevents accidentally modifying the value inside the function, at the cost of cluttering up the interface.</li>
<li>Except, <strong>pass by non-const reference</strong> if the callee will modify it, and this is clear to the caller. This is basically only used to simulate a function returning multiple values.</li>
</ul>

<p>For objects of class type (<code>class</code> and <code>struct</code>):</p>

<ul>
<li><strong>Pass by const reference</strong> (<code>const std::string&amp;, const std::vector&lt;T&gt;&amp;</code>, <code>const MyClassOrStruct&amp;</code>), if (1) the callee does not need to modify it, and (2) the callee will not hold on to the reference after the caller has destroyed it. This is probably the most common case for non-builtins.</li>
<li><strong>Pass by non-const reference</strong> if (1) the callee <em>does</em> need to modify it, (2) the callee will not hold on to the reference after the caller has destroyed it, and (3) it is clear to the caller that the passed object will be modified.</li>
<li><strong>Pass by value</strong> if need to make a copy of the object, and know that you are paying the price for a copy. For small struct-like types (such as <code>std::pair&lt;int, int&gt;</code> for example), it is okay to pass by value in general. For larger classes, you will need to look at your specific use-case.</li>
<li><strong>Pass by move</strong> if you will no longer need the original object and wish to transfer ownership to the function you are calling. This is often cheaper than a copy, but still has a cost. Generally pass lambdas and <code>std::function</code>s by move if possible.</li>
<li><strong>Pass a <code>std::shared_ptr&lt;T&gt;</code> by value</strong> if you would like to pass by reference, except the callee <em>does</em> need to hold on to the reference after the caller has destroyed it.</li>
<li><strong>Pass a <code>std::unique_ptr&lt;T&gt;</code> by move</strong> if you would like to pass by move, except that the move constructor is expensive, or you need the object to stay in place for some reason.</li>
</ul>
",3
41205517,41204957,0,"<p>Your list class needs to have suitable <code>begin()</code> and <code>end()</code> member functions, or else there must be suitable free functions with these names. See <a href=""http://en.cppreference.com/w/cpp/language/range-for"" rel=""nofollow noreferrer"">here</a> for example.</p>

<p>There is nothing special about <code>this</code>. If your list class is <code>L</code> and <code>l</code> has type <code>L</code> then you can do:</p>

<pre><code>for (auto i : l)
</code></pre>
",0
41205541,41204957,0,"<p>Example </p>

<pre><code>list&lt;T&gt; l{....};
</code></pre>

<p>Post C++11</p>

<pre><code>for(auto &amp; elem : l)
    cout&lt;&lt;elem;
</code></pre>

<p>Usual Way</p>

<pre><code>for(list&lt;T&gt;::iterator it = l.begin();it!=l.end();++it)
    cout&lt;&lt;*it;
</code></pre>
",0
41205612,41204957,0,"<p>As per the documentation, the range-for loop is defined as it follows (until C++17):</p>

<pre><code>{
    auto &amp;&amp; __range =?range_expression?;?
    for (auto __begin =?begin_expr,?__end =?end_expr;?__begin?!= __end; ++__begin) {?
        range_declaration?= *__begin;?
        loop_statement?
    }
}
</code></pre>

<p>Therefore you have just to define a couple of functions, that are <code>begin</code> and <code>end</code>. They can be either member functions or accessible via ADL.<br>
This way you'll be able to use your type in a range-for loop, either from within the class itself (using <code>*this</code>) or from anywhere else (by using a named variable).</p>

<hr>

<p>It follows a minimal, working example:</p>

<pre><code>#include&lt;list&gt;
#include&lt;iostream&gt;

struct my_list {
    using iterator = std::list&lt;int&gt;::iterator;

    friend iterator begin(my_list &amp;);
    friend iterator end(my_list &amp;);

    void f() {
        for(auto v: *this) {
            std::cout &lt;&lt; v &lt;&lt; std::endl;
        }
    }

private:
    std::list&lt;int&gt; data{ 0, 1, 2 };
};

my_list::iterator begin(my_list &amp;l) {
    return l.data.begin();
}

my_list::iterator end(my_list &amp;l) {
    return l.data.end();
}

int main() {
    my_list l{};
    l.f();

    for(auto v: l) {
        std::cout &lt;&lt; v &lt;&lt; std::endl;
    }
}
</code></pre>
",0
39654859,39654345,2,"<p>First of all in this while loop:</p>

<pre><code>while(i++&lt;5)
 {
   res[i] = x[i]-y[i]; 
 }
</code></pre>

<p><code>i</code> will start from 1, since the condition has a side-effect of post-increment. So you are never changing <code>res[0]</code> which is why you see a <code>0</code> when you print <code>res[0]</code>. And regarding the value of <code>y[0]</code>, the while loop will run till <code>i</code> is 5. So finally you have something like:</p>

<pre><code>res[5] = x[5] - y[5];
</code></pre>

<p>Writing into <code>res[5]</code> is corrupting the location <code>y[0]</code>.</p>
",0
35190787,35190652,0,"<p>For future references, it was because of the equal sign on the following code:</p>

<pre><code>[Point top = (jumpman.get_x(), jumpman.get_y());
 Circle c = (top, 10);]
</code></pre>

<p>I guess since we are creating the point and the circle we aren't supposed to use an equal sign.</p>
",1
35191901,35190652,1,"<p>The error occurs in the lines</p>

<pre><code> Point top = (jumpman.get_x(), jumpman.get_y());
 Circle c = (top, 10);
</code></pre>

<p>where you intend to create instances of <code>Point</code> and <code>Circle</code>. Which we don't have the corresponding headers, by common sense it's safe to assume that those classes have ctor's that take obvious parameters <code>(int, int)</code> and <code>(Point, int)</code>. So, the correct way to create an object of a class is either this</p>

<pre><code>Point top(jumpman.get_x(), jumpman.get_y());
Circle c(top, 10);
</code></pre>

<p>or</p>

<pre><code>Point top = Point(jumpman.get_x(), jumpman.get_y());
Circle c = Circle(top, 10);
</code></pre>

<p>which would results in calls to the appropriate constructors.</p>

<p>Your code results in the following. The  expression <code>(jumpman.get_x(), jumpman.get_y())</code> evaluates to the rightmost <code>jumpman.get_t_y()</code>, that's how the comma operator works. Thus, the compiler concludes that you want to construct a <code>Point</code> from a single <code>int</code>, which is impossible, since there (obviously) is no such constructor or conversion operator. Same for the second line, with different constructor parameters.</p>
",7
37289450,37289406,1,"<p><code>root</code> is never updated in your <code>Insert</code> method. The passed <code>root</code> to method is not same as the member variable.</p>

<p>Do like following :</p>

<pre><code>Tree-&gt;root = Tree-&gt;Insert(Tree-&gt;root, 10) ;
</code></pre>

<p>or pass address of root or use <code>this-&gt;root =</code> everywhere inside the method.</p>

<p>Overall the design need to be revisited, I assume you want to <em>play and learn</em></p>

<p>Also make sure you release the memory once you're done. Currently you have memory leaks, everywhere.</p>
",0
35238787,35238724,2,"<p>You want to use a loop for multiple lines.</p>

<pre><code>while(getline(cin,line))
{
  cout &lt;&lt; line &lt;&lt; endl;
  //do something
}
</code></pre>
",3
38509458,38509090,1,"<p>You should be using <code>std::find_if</code>, not <code>std::find</code>.  </p>

<p>You're supposed to return <code>true</code> or <code>false</code> depending on whether the data has been found or not.  Then the returned iterator from <code>std::find_if</code> can be checked:</p>

<pre><code>auto iter = std::find_if(my_vector.begin(), my_vector.end(),
                      [] (student const&amp; scores){ return scores.score ==l; });

if ( iter != my_vector.end())
      cout&lt;&lt;""it is available""&lt;&lt;(*iter).name&lt;&lt;(*iter).stno;
else
      cout&lt;&lt;""not available;
</code></pre>
",6
38509983,38509058,0,"<p>My guess is that at one point, you either had a class named <code>map</code> in the global namespace, which provided an interface similar to <code>std::map</code>, or more likely, you were relying on a <code>using namespace std;</code> directive that has since been removed (whether unintentionally or not; perhaps someone else had one in a header you were using, but removed it when they realised that was a bad idea).  Either put a using-directive for <code>std</code> or a using-declaration for <code>std::map</code> in the code block containing that line, or explicitly use <code>std::map</code> whenever you want to use the C++ standard library <code>map</code> class; the latter is recommended, because it makes code clearer and cleaner.</p>

<p>If you were using a custom <code>map</code> class before, check that its header is still <code>#include</code>d, and that it doesn't run into the same namespace issue.</p>
",1
39337920,39337843,1,"<p>Add checks like this:</p>

<pre><code>if(inputfile&gt;&gt; n)
{
     //Code
} else
{
    cout &lt;&lt; ""Failed!"";
}
</code></pre>

<p>Also, check the file was opened:</p>

<pre><code>ifstream inputfile(""input.txt"");
if (!inputfile)
{
    cout &lt;&lt; ""Failed opening file!"";
    return -1;
}
</code></pre>
",3
40959653,40959344,0,"<p>In codeblocks, when creating a new class, it should automatically header file. Programming with header files is the best practice out there. Here's the code I tried and it worked, with io.h.</p>

<p><strong>main.cpp</strong></p>

<pre><code>#include &lt;iostream&gt;
#include ""io.h""

using namespace std;

io inOut;


int main()
{

    int x = inOut.readNumber();
    int y = inOut.readNumber();
    inOut.writeResult(x + y);
    return 0;

}
</code></pre>

<p><strong>io.h</strong></p>

<pre><code>#ifndef IO_H
#define IO_H


class io
{
    public:
        int readNumber();
        void writeResult(int);
};

#endif
</code></pre>

<p><strong>io.cpp</strong></p>

<pre><code>#include &lt;iostream&gt;
#include ""io.h""

using namespace std;

int io::readNumber()
{
    cout &lt;&lt; ""Enter a number: "";
    int x;
    cin &gt;&gt; x;
    return x;
}

void io::writeResult(int x)
{
    cout &lt;&lt; ""Sum of your numbers is "" &lt;&lt; x &lt;&lt; endl;
}
</code></pre>

<p>I used codeblocks to compile the code written above, and it worked perfectly.</p>
",1
40960017,40959344,0,"<p>Well as turns out when adding more cpps they're not supposed to be #included on the top. That's what makes compiler say that function is being defined multiple times. All I had to do was just get rid off that one line.</p>

<p>Here's my source:</p>

<p><a href=""http://www.cplusplus.com/forum/beginner/44651/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/forum/beginner/44651/</a></p>
",0
41003264,41003181,1,"<p>I think the line <code>if (op = 'y') {</code> is the culprit.</p>

<p>It should be a double equals <code>if (op == 'y') {</code></p>
",4
36625500,36624496,0,"<p>Yet another way of doing it, almost equivalent to using a break statement inside the for loop. </p>

<p>Just loop through the vector, and then print the result outside it.</p>

<pre><code>unsigned int i = 0;
for(; i &lt; temp.size() &amp;&amp; userinput != temp[i].eventID; ++i);

if(i &lt; temp.size() &amp;&amp; userinput == temp[i].eventID)
{
    cout &lt;&lt; ""Location: "" &lt;&lt; temp[i].location &lt;&lt; endl;
    cout &lt;&lt; ""Begin Date: "" &lt;&lt; temp[i].begindate &lt;&lt; endl;
    ....
}
else
{
    cout &lt;&lt; ""it doesnt match"" &lt;&lt; endl;
}    
</code></pre>
",0
36781215,36778994,0,"<p>Using the <code>this</code> pointer is not necessary if the member- and parameter names are different. <br>
It's an explicit way of saying <em>member of this object</em>, whose value is the address of the object.</p>

<p>But, if you don't use the <code>this</code> pointer when the names are <em>equal</em>, you will be assigning the value of the local variable to itself:</p>

<pre><code>void setlength(double length) 
{ // assigning value to itself
    length = length;
} // this-&gt;length is unchanged
</code></pre>

<p>If the names are the same and you use the <code>this</code> pointer explicitly, you will get the expected result:</p>

<pre><code>void setlength(double length) 
{
    this-&gt;length = length;
}
</code></pre>

<p>Here we are saying <em>I mean length that belongs to <strong>this</strong> object</em></p>
",0
39680289,39680126,1,"<p>Let's take it one requirement at a time.</p>

<blockquote>
  <p>Your DeptstoreMember class  </p>
</blockquote>

<pre><code>class DeptstoreMember
{
};
</code></pre>

<blockquote>
  <p>A constructor that takes parameters for the ID number and name. If the ID number presented is greater than 0, it should accepted; otherwise the ID number should be set to -1.  </p>
</blockquote>

<pre><code>class DeptstoreMember
{
  public:  
    DeptstoreMember(int id, const std::string&amp; name)
      : m_id(id), m_name(name)
    {
      if (m_id &lt;= 0) m_id = -1;
    }
  private:
    int m_id;
    std::string m_name;
};
</code></pre>

<blockquote>
  <p>Getters and setters for the ID, first name, and last name.  </p>
</blockquote>

<pre><code>class DeptstoreMember
{
  public:  
    DeptstoreMember(int id, const std::string&amp; name)
      : m_id(id), m_name(name)
    {
      if (m_id &lt;= 0) m_id = -1;
    }
    int get_id() const
    {
       return m_id;
    }
    int get_name() const
    {
       return m_name;
    }
    void set_id(int id)
    {
       if (id &lt;= 0)
          m_id = -1;
       else
          m_id = id;
    }
    void set_name(const std::string&amp; new_name)
    {
       m_name = new_name;
    }
  private:
    int m_id;
    std::string m_name;
};
</code></pre>

<p>You should next, try implementing one requirement at a time.  </p>

<p>I recommend creating a <code>main</code> program and getting it to compile.<br>
Next, add the above code and get it to compile.
Next, implement another requirement, get it to compile.</p>

<p>You may want to make copies of the files before you add a new requirement.  This will give you a snapshot to fall back to if there are any new issues.  </p>

<p><strong>Edit 1: The <code>main()</code> function</strong><br>
I usually like to start with a small stencil for <em>console application</em>:  </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

using std::cout;
using std::cin;

int main(void)
{
  cout &lt;&lt; ""Paused.  Press Enter to continue.\n"";
  cin.ignore(1000000, '\n');
  return EXIT_SUCCESS;
}
</code></pre>

<p>I get the above <code>main</code> function to work, then add little chunks of code and test them out.  </p>

<p>If I make a new class, and it works in <code>main</code>, I <em>factor</em> it out into separate header and source files, then rebuild.  </p>

<p>This process is repeated until all the requirements are satisfied.  </p>
",0
36324506,36324488,1,"<p><code>array[0][i]= x;</code> looks wrong. It should be:</p>

<pre><code>array[i][0]= x;
</code></pre>

<p>First index is for row and second for col.</p>

<p>Later <code>cout &lt;&lt; array[row][col];</code> is also wring as <code>row</code> is out of range.</p>

<p>The way you delete the array is also wrong, it should be:</p>

<pre><code>for(i=row - 1; i &gt;= 0; --i){
  delete [] array[i];
}
delete [] array;
</code></pre>
",1
36324577,36324488,0,"<pre><code>cout &lt;&lt; array[row][col];
</code></pre>

<p>Out of range in each of the two dimensions, as others have said.</p>

<pre><code>for(i=0; i&lt;row; i++){

delete [] array[i];
delete [] array;
}
</code></pre>

<p>You're deleting array's elements three times, once for each element.  This is good.  You're also deleting array itself three times.  This is dangerous and wrong.</p>
",0
38287282,38286967,1,"<p>The <code>fstream</code> object you have is a representation of the bytes on disk. If 'insert' writes were allowed, the program would have to move every byte in the file after the insert point up by one position, essentially rewriting the file.</p>

<p>The only way to get an implemention of an 'insert' ability is to do it yourself, generally using a new file (you <em>could</em> do it in the same file by reading the rest of the file into memory, going back to the insert position, overwriting the character, and then writing your buffered copy of the file from before).</p>

<p>The reason that the <em>next</em> two characters are being overwritten is as follows:</p>

<pre><code>// file buffer = [i][;][a][m][;][t]...
// position       ^
distances &gt;&gt; c;
// c = [i]
// file buffer = [i][;][a][m][;][t]...
// position          ^
distances &gt;&gt; c;
// c = [;]
// file buffer = [i][;][a][m][;][t]...
// position             ^
distances &lt;&lt; endl;
</code></pre>

<p><code>std::endl</code> writes the local line ending sequence and issues a <code>std::flush</code> to force writing. Under Windows, <code>endl</code> produces the sequence <code>file &lt;&lt; '\r' &lt;&lt; '\n' &lt;&lt; std::flush;</code></p>

<p>The stream position is where the <code>'a'</code> is, not where the ';' is - by reading that character you advanced the stream position past it, so it writes the <code>'\r'</code> over the <code>'a'</code> and the <code>'\n'</code> over the <code>'m'</code>.</p>

<pre><code>// file buffer = [i][;][a][m][;][t]...
// position             ^
  distances &lt;&lt; '\r'
// file buffer = [i][;][\r][m][;][t]...
// position                 ^
   distances &lt;&lt; '\n'
// file buffer = [i][;][\r][\n][;][t]...
// position                     ^
distances &gt;&gt; c;
// c = ';'
// file buffer = [i][;][\r][\n][;][t]...
// position                        ^
</code></pre>
",0
38287008,38286967,1,"<p>The most likely explanation is that you're using Microsoft Windows, where the newline sequence is two characters: a carriage return and a line feed: <code>\r\n</code>.</p>

<p>On Microsoft Windows a <code>std::endl</code> will write two characters: an <code>\r</code> and an <code>\n</code>.</p>
",3
38287073,38286967,3,"<p>Despite the illusion presented by text editing software, you can't ""insert"" into a file. You can only read its contents, modify them in memory, then write them back out again.</p>

<p>Your two characters are being <em>replaced</em> by your newline which, on Windows, actually consists of a Carriage Return followed by a Line Feed.</p>
",0
46949809,46949570,1,"<p><code>getline</code> reads a line from the input
and then <code>ifs &gt;&gt; info[i].name &gt;&gt; ..</code> reads additional info thus skipping what you have read using <code>getline</code>.</p>

<p>Simply change:</p>

<pre><code>string line;
while (getline(ifs, line))
{
    ifs &gt;&gt; info[i].name &gt;&gt; info[i].pos &gt;&gt; info[i].numTouchDowns &gt;&gt; info[i].numCatches &gt;&gt; info[i].numPassingYards 
        &gt;&gt; info[i].numReceivingYards &gt;&gt; info[i].numRushingYards;
    [..]
}
</code></pre>

<p>Into:</p>

<pre><code>while (true)
{
    ifs &gt;&gt; info[i].name &gt;&gt; info[i].pos &gt;&gt; info[i].numTouchDowns &gt;&gt; info[i].numCatches &gt;&gt; info[i].numPassingYards 
        &gt;&gt; info[i].numReceivingYards &gt;&gt; info[i].numRushingYards;
    if (!ifs) break;
    [..]
}
</code></pre>

<p>An <strong>better implementation</strong> (splitted to avoid littering the actual issue), is using a temp object and moving it once we realized the read was successful:</p>

<pre><code>while (true)
{
    FPlayerInfo temp;
    ifs &gt;&gt; temp.name &gt;&gt; temp.pos &gt;&gt; temp.numTouchDowns &gt;&gt; temp.numCatches &gt;&gt; temp.numPassingYards 
        &gt;&gt; temp.numReceivingYards &gt;&gt; temp.numRushingYards;
    if (!ifs) break;

    info[i] = std::move(temp);
    [..]
}
</code></pre>
",2
39001198,38988029,1,"<p>The problem is quite simple. You initialize your member variables in a Java-esque manner. But C++ doesn't work that way. A constructor always calls the constrcutors of all base classes and members <strong>before</strong> its own body is even reached. You can specify parameters to the various c'tors using <a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""nofollow"">member initializer lists</a>.  </p>

<p>However your constructor doesn't, so the compiler attempts to call the default constructor first (a no parameter one). So a fix would be:</p>

<pre><code>ice_token::ice_token(ice_lexer *const lexer, ice_type_enum t):
  type(t), line(lexer-&gt;line), pos(lexer-&gt;pos), num(0)
{}
</code></pre>
",0
35254099,35254012,0,"<p>You may use jQuery like library for parsing HTML - <a href=""https://github.com/lazytiger/gumbo-query"" rel=""nofollow"">https://github.com/lazytiger/gumbo-query</a> . Accessing browser' Window is tedious and will require more details about the actual OS and browser, since their inner details are vastly different - as a result it won't be as easy as figuring out how to use GetWindowHandle and GetWindowText </p>
",0
43966280,43963072,2,"<p>You're going to have trouble finding faster code than this:</p>

<pre><code>#include &lt;chrono&gt;
#include &lt;string&gt;

void
stamp(char* s, int i)
{
    do
    {
        *s-- = char(i % 10) + '0';
        i /= 10;
    } while (i &gt; 0);
}

void GenerateUTCTimestamp(std::string&amp; out)
{
    using namespace std;
    using namespace std::chrono;
    using days = duration&lt;int, ratio&lt;86400&gt;&gt;;
    auto now = time_point_cast&lt;seconds&gt;(system_clock::now());
    auto today = time_point_cast&lt;days&gt;(now);
    auto s = now - today;

    // y-m-d
    auto z = today.time_since_epoch().count() + 719468;
    const auto era = 5;
    const auto doe = z - era * 146097;
    const auto yoe = (doe - doe/1460 + doe/36524 - doe/146096) / 365;
    const auto y = yoe + era * 400;
    const auto doy = doe - (365*yoe + yoe/4 - yoe/100);
    auto m = (5*doy + 2)/153;
    const auto d = doy - (153*m+2)/5 + 1;
    m = m + (m &lt; 10 ? 3 : -9);

    // h:M:s
    const auto h = duration_cast&lt;hours&gt;(s);
    s -= h;
    const auto M = duration_cast&lt;minutes&gt;(s);
    s -= M;

    // format yyyymmdd-hh:MM:ss
    out = ""00000000-00:00:00"";
    stamp(&amp;out[3], y);
    stamp(&amp;out[5], m);
    stamp(&amp;out[7], d);
    stamp(&amp;out[10], h.count());
    stamp(&amp;out[13], M.count());
    stamp(&amp;out[16], s.count());
}
</code></pre>

<ul>
<li><p>This code uses the public domain algorithm <code>civil_from_days</code> from here:</p>

<p><a href=""http://howardhinnant.github.io/date_algorithms.html#civil_from_days"" rel=""nofollow noreferrer"">http://howardhinnant.github.io/date_algorithms.html#civil_from_days</a></p>

<p>where you can find an in-depth explanation of that algorithm.</p></li>
<li><p>The number of branches in the code is minimized, and the code size itself is minimized.</p></li>
<li><p>The use of general purpose (and convenient) streams are entirely avoided, opting instead for a bare-bones integer-to-char algorithm that doesn't  deal with localization, traits, wide characters, custom widths or alignments or even negative values.</p></li>
<li><p>Except for the first call, memory allocation is completely avoided by reusing and formatting directly into <code>out</code>.</p></li>
<li><p>This code <em>does</em> <em>have</em> a limited range of validity:  2000-03-01 to 2400-02-29.  If you need to make this code valid for points in time outside this range, change the computation of <code>era</code> to:</p>

<p><code>const auto era = (z &gt;= 0 ? z : z - 146096) / 146097;</code></p></li>
</ul>

<p>I put this code in a loop of 1000 calls (with the same <code>string</code>), timed it, and averaged the time over all the calls.</p>

<p>On my machine (macOS, clang, libc++, -O3), the original code takes about 3.9&micro;s and the optimized code takes about 150ns (about 25X faster).</p>

<p>Then for grins, I implemented <code>GenerateUTCTimestamp</code> using <a href=""https://howardhinnant.github.io/date/date.html"" rel=""nofollow noreferrer"">Howard Hinnant's date library</a> to see how it fared in the timing test.  It clearly wins the ease of use test (imho):</p>

<pre><code>#include ""date.h""

void GenerateUTCTimestamp(std::string&amp; out)
{
    using namespace date;
    using namespace std::chrono;
    out = format(""%Y%m%d-%T"", time_point_cast&lt;seconds&gt;(system_clock::now()));
}
</code></pre>

<p>It clocked in at 2.5&micro;s, 50% faster than the thread-unsafe C API, but plenty slower than the optimized code.  There's a performance penalty for the flexibility of a general purpose tool.</p>

<p>The date library uses the same calendrical algorithm as the optimized tool (except for using the generalized <code>era</code>), but formats into a <code>stringstream</code> like the original code.  It also of course has to parse the formatting string.</p>
",2
48002402,48002213,1,"<p>Yes, the compiler can optimize to remove the initialization. This technique is called <a href=""https://en.wikipedia.org/wiki/Dead_store"" rel=""nofollow noreferrer"">dead store</a> optimization. Determining whether a dead store occurs is part of <a href=""https://en.wikipedia.org/wiki/Data-flow_analysis"" rel=""nofollow noreferrer"">data-flow analysis</a>.</p>
",0
48002618,48002213,-2,"<p>It will first assign the three values to a,b and c and then after that change them to the later assigned values.</p>

<p>This is because in c++, execution is line by line. So first the object gets declared and it gets values assigned by the constructor as soon as declared. After that a,b and c values are changed.</p>

<p>To <em>optimize</em> it, you can use the constructor with default arguments like this</p>

<pre><code>class Foo{
public:
int a, b, c;
Foo(x = 10, y = 11, z = 12){
   a = x;
   b = y;
   c = z;
}
};

int main(){
Foo f; //a gets 10, b gets 11, c gets 12
Foo fi(51, 52, 53); //a gets 51, b gets 52, c gets 53
}
</code></pre>
",1
48002846,48002213,2,"<p>This obviously depends on the compiler--but there are certainly at least some compilers that can and will eliminate the dead stores. In fact, depending on how you use the results, the compiler may eliminate <em>all</em> stores, dead or otherwise. </p>

<p>For example, if we compile your code exactly as it is right now, we end up with assembly language like this:</p>

<pre><code>xor eax, eax
ret
</code></pre>

<p>That's it--since you never use any of the values you store, it eliminates all the code dealing with those values entirely. All that's left is the fact that <code>main</code> returns <code>0</code>, so it just generates code for <code>main</code> to return zero.</p>

<p>That's probably not a case you care a whole lot about though, so let's expand the code a bit, to show something closer to what you probably care about.</p>

<pre><code>#include &lt;iostream&gt;

class Foo {
public:
  Foo() : a(10), b(11), c(12) {};
  int a;
  int b;
  int c;

  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, Foo const &amp;f) {
      return os &lt;&lt; ""("" &lt;&lt; f.a &lt;&lt; "", "" &lt;&lt; f.b &lt;&lt; "", "" &lt;&lt; f.c &lt;&lt; "")"";
  }
};

int main() {
  Foo f;
  f.a = 50;
  f.b = 51;
  f.c = 52;

  std::cout &lt;&lt; f &lt;&lt; ""\n"";
}
</code></pre>

<p>In this case, the compiler still eliminates all the storage involved, and produces code to just directly write out the values we gave as literals in the source:</p>

<pre><code>mov esi, 50
mov edi, OFFSET FLAT:std::cout
call std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;::operator&lt;&lt;(int)
</code></pre>

<p>[and the same sequence repeated for 51 and 52].</p>

<p>Reference:</p>

<p><a href=""https://godbolt.org/g/CRUFdz"" rel=""nofollow noreferrer"">Godbolt</a></p>
",0
34981260,34981129,0,"<p>Generally, <code>contents[i]</code> means the ith element of a container (such as an array), but it can mean whatever the designer wanted it to mean. If you write a class of your own, you can write <code>operator[]</code> for that class to do whatever you want-- and if you make it do anything other than return a reference to the ith element of a container, the people who have to deal with your code will curse your name.</p>

<p>So <code>contents[i][j]</code> means the jth element of the ith element of <code>contents. For example,</code>contents<code>might be an array of arrays of</code>int<code>(often called a 2-dimensional array), or a</code>vector<code>of arrays of</code>mYClass<code>, or a</code>vector<code>of</code>myContainer<code>, or a</code>myContainer<code>of</code>myOtherContainer`... </p>
",0
34981361,34981129,0,"<p>A ""double subscript"" is actually two <em>single</em> subscripts. The second subscript is applied to whatever object is returned by the first.</p>

<p>So with <code>contents[i][j]</code> we have:</p>

<pre><code>contents; // object taking subscript (array, vector etc...)
</code></pre>

<p>If we subscript that object to access its contents we get another object that <em>also</em> takes a subscript:</p>

<pre><code>contents[i]; // another object taking subscript
</code></pre>

<p>So you might typically find the ""double subscript"" applied to a <em>vector</em> that contains <em>vectors</em> as is elements.</p>

<pre><code>// a vector that contains vectors that each contain doubles
std::vector&lt;std::vector&lt;double&gt;&gt; contents;
</code></pre>

<p>Then:</p>

<pre><code>contents; // returns a vector of vectors to doubles
contents[i]; // returns a vector of doubles
contents[i][j]; // returns a double
</code></pre>

<p>Useful for modelling 2 dimensional data.</p>
",0
34981148,34981129,0,"<p>When you have a 1d array, you access the i-th element with <code>[i]</code>.</p>

<p>When you have a 2d array, thus a <strong>matrix</strong>, you access the element in i-th row and j-th column with <code>[i][j]</code>.</p>
",1
34981156,34981129,2,"<p><code>content</code> most likely stores an 2D array: an array of array (probably <code>std::vector&lt; std::vector&lt;double&gt; &gt;</code>, thank you @owacoder for the comment).</p>

<p><code>contents[i]</code> accesses the <code>i</code>'s array of <code>contents</code>, which itself is a <code>std::vector&lt;double&gt;</code>, and then <code>contents[i][j]</code> acesses the <code>j</code>'s elements of the <code>i</code>'s array stored in <code>contents</code>.</p>
",1
34981163,34981129,1,"<p>You have a 2 dimensional array, so you need an (width, hight) coordinates to access every element in it?</p>

<p><a href=""https://i.stack.imgur.com/eWb17.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/eWb17.png"" alt=""enter image description here""></a></p>
",1
42481725,42480128,0,"<p>So i limited the code down into a do while loop with a counter for the gold, in the buyItems() function.
Here it is, if anyone is interested.</p>

<pre><code>do {
    inv.gold -= inv.itemPrice[inp - 1];
    ++(inv.pInv[inp - 1]);
} while (inv.gold &gt; 0);

if (inv.gold &lt; 0) {
    inv.gold = 0;
    inv.pInv[inp - 1]--;
}

printItems();
</code></pre>
",0
46622939,46622876,5,"<p>The problem is that you use <code>#define</code> with a semicolon, while you shouldn't. In C, preprocessor statements don't use semicolons.  </p>

<p>It gets into the <code>#define</code> definition.  </p>

<p>So <code>ai[i] = f + i;</code> becomes <code>ai[i] = 5; + i;</code>.  </p>

<p>As <code>+i;</code> is a valid statement that does nothing, the compiler doesn't even warn you.  </p>

<p>Use <code>#define f 5</code> to fix this.</p>
",0
44747221,44747161,0,"<blockquote>
  <p>... from the fact that it's no longer a POD type after I added the constructor.</p>
</blockquote>

<p>That's no <em>fact</em> (merely fake news ;-) ). Adding a constructor doesn't change a <code>struct</code>s POD type status.</p>

<p>You can also easily check this with a <code>static_assert</code>:</p>

<pre><code>static_assert( ""Something must be a POD type!"",std::is_pod(Something)::value);
</code></pre>

<blockquote>
  <p>Is this legal?</p>
</blockquote>

<p>I'm not so sure. Depends on the context. In your's it would work and compile without errors or warnings like intended </p>

<blockquote>
  <p>safe?</p>
</blockquote>

<p>Certainly not.</p>

<p>It calls undefined behavior in various ways. </p>

<ol>
<li><code>this</code> may consist of more than just the data members. There maybe things like a vtable held.</li>
<li>The compiler is allowed to change the memory layout of the member variables. <a href=""https://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member"">So padding might occur</a>.</li>
<li>In cause the data is interchanged via a network, endianess comes into play, and has to be considered during de-/serialization</li>
</ol>

<p>You should note, that any kind of <code>reinterpret_cast</code> (i.e. c-style cast) is giving you <em>undefined behavior</em> to some degree. 
You need 100% to know what you're doing, and I recommend to check the emitted assembly output and memory layout every time when you use such constructs.</p>
",11
44747300,44747161,-8,"<p>It is guaranteed to be successfully compiled without error messages. So by definition, it is 100% legal.</p>

<p>In this particular case, it would work as intended. But, if a structure uses virtual functions, it would store vptr, and this thing would not work.  You may, for instance, later add a virtual function, and the constructor will stop working.  So no, it is not safe.</p>
",6
36232224,36232036,0,"<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void LCS(char *str, char *reverseStr);

int main(void) {
    char *str = NULL;
    char *reverseStr = NULL;

    // Allocate first string (any size will do)
    size_t number = 10;
    str = malloc( sizeof(char) * (number + 1 ));

    // Make sure it is allocated, or return error code    
    if( !str ) return -2;

    // zero the memory
    memset( &amp;str[0], 0, sizeof(char)*(number+1));


    // Using getline. It will return the actual buffer size to us.
    size_t bufferSize = getline( &amp;str, &amp;number, stdin );

    // How many characters were read?
    printf( ""Read in %lu characters (not including null terminator)\n"", bufferSize );

    //get rid of the 'enter' at the end. Replace it with a NULL.
    str[bufferSize-1] = 0;

    //Allocate the reversed buffer once we know the size for sure.
    reverseStr = malloc( sizeof(char) * (bufferSize + 1 ));

    //Zero the memory
    memset( &amp;reverseStr[0], 0, sizeof(char)*(bufferSize+1));


    //Copy string in reverse
    for (int i = 0; i &lt; strlen(str); i++) {
        reverseStr[i] = str[strlen(str) - 1 - i];
    }

    printf( ""\nCompare and check that whitespace is gone at both ends:\n"" );
    printf( ""Original string length: %lu\n"", strlen(str));
    printf( ""Reversed string length: %lu\n"", strlen(reverseStr));

    printf( ""Original string:   %s\n"", str);
    printf( ""Reversed string:   %s\n"", reverseStr);

    LCS( str, reverseStr);

    // Cleanup
    free(str);
    free(reverseStr);
    return 0;
}


void LCS(char *str, char *reverseStr) {
    int **matrix;
    int result = strlen(str);

    matrix = (int**)malloc( sizeof(int) * (strlen(str)+1));
    for (int i = 0; i &lt; strlen(str) + 1; i++) {
        matrix[i] = (int*)malloc( sizeof(int) * (strlen(str)+1));
    }


    for (int i = 1; i &lt;= strlen(str); i++) {
        for (int j = 1; j &lt;= strlen(reverseStr); j++) {
            if (str[i - 1] == reverseStr[j - 1])
                matrix[i][j] = matrix[i - 1][j - 1] + 1;
            else if (matrix[i - 1][j] &gt;= matrix[i][j - 1])
                matrix[i][j] = matrix[i - 1][j];
            else
                matrix[i][j] = matrix[i][j - 1];
        }
    }

    result -= matrix[strlen(str)][strlen(reverseStr)];
    printf( ""Result = %d\n"", result );

}
</code></pre>

<p>The output:</p>

<pre><code>~/myprograms john  &gt;&gt;./test
radar
Read in 6 characters (not including null terminator)

Compare and check that whitespace is gone at both ends:
Original string length: 5
Reversed string length: 5
Original string:   radar
Reversed string:   radar
Result = -18178288
</code></pre>
",6
36235079,36232036,1,"<p>Probably you are hitting some command line limit. I also was not able to pass a string of this size. But I was able to do so using file as an input stream.</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;fstream&gt;

using namespace std;

void LCS(const char *sourceStr, char *reverseStr);

int main()
{
    ifstream input_stream;
    const char* filenam = ""input_file.txt"";

    input_stream.open(filenam);
    if( !input_stream.good() )
    {
        cerr &lt;&lt; ""couldn't open file: "" &lt;&lt;  filenam &lt;&lt; ""\n"";
        return 1;
    }


    string buffer;
    size_t size;
    input_stream &gt;&gt; size;
    input_stream.get();
    std::getline(input_stream, buffer);

    if ( size != buffer.size() )
    {
        cerr &lt;&lt; ""ambiguous input: size != buffer.size()\n"";
        return 1;
    }

    //no need to allocate a new bufer for read only purpose
    const char* raw_str = buffer.c_str();

    //allocate space for reversed string
    char* reverse_str = new char[size];

    LCS(raw_str, reverse_str);

    delete [] reverse_str;

}


void LCS(const char *sourceStr, char *reverseStr){
    //implementation skipped
}
</code></pre>

<p>There is no need to deep copy of a source string(source Str), because function LCS are not going to modify it.
BTW. There is also an error in function LCS. You cannot use double square brackets here, because the matrix contains multiple chunks of memory(""new"" was used in a loop).</p>
",1
37198427,37197850,2,"<p>For compilers that support the <code>filesystem</code> <a href=""http://en.cppreference.com/w/cpp/filesystem"" rel=""nofollow noreferrer"">Technical Specification</a> which has now been accepted into <code>C++17</code> this can be done as follows:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;experimental/filesystem&gt; // Later (C++17) just &lt;filesystem&gt;

namespace fs = std::experimental::filesystem;

int main(int, char** argv)
{
    std::string dir = ""."";

    if(argv[1])
        dir = argv[1];

    for(auto&amp; item: fs::recursive_directory_iterator(dir))
    {
        if(!fs::is_regular_file(item.path())
        || item.path().extension() != "".txt"")
            continue;

        // open text file here
        std::cout &lt;&lt; ""Found text file: "" &lt;&lt; item.path().string() &lt;&lt; '\n';
    }
}
</code></pre>
",0
42654810,42654482,0,"<p>Just make the constructor accept an array of characters, or even better, use std::string:</p>

<pre><code>class BigInteger {
public:
    BigInteger(const std::string&amp; s) : m_s(s) {}
    //...

private:
    std::string m_s;
};


int main() {
    BigInteger n(""123456789"");
    //...
}
</code></pre>
",0
40964043,40963958,2,"<p>It's a lot easier to reverse a string than an integer.  It's also a lot easier to accumulate individual digits of a string containing a number than an integer.  Try this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
int main(int argc, char *argv[])
{
    std::string number;
    int accum = 0;
    std::cout &lt;&lt; ""Enter a five digit number: "";
    std::cin &gt;&gt; number;

    if (number.length() != 5)
    {

        std::cout &lt;&lt; std::endl &lt;&lt; ""I asked for five digits!"" &lt;&lt; std::endl;
        return 0;
    }

    for (int i = 0; i &lt; 5; i++)
    {
        if (number.at(i) &lt; '0' || number.at(i) &gt; '9')
        {
            std::cout &lt;&lt; std::endl &lt;&lt; ""Non-integer string entered"" &lt;&lt; std::endl;
            return 0;
        }

        accum += (number.at(i) - '0');

    }

    std::reverse(number.begin(), number.end());
    std::cout &lt;&lt; ""Reversed: "" &lt;&lt; number &lt;&lt; std::endl &lt;&lt; ""Sum of digits: "" &lt;&lt; accum &lt;&lt; std::endl;



    return 0;
}
</code></pre>
",3
40964089,40963958,1,"<p>A simple solution using the same logic and tools of your code..</p>

<pre><code>    int sum = 0;
    for(int i = 0; i &lt; 5; ++i)
    {
        int digit = number % 10;
        sum += digit;
        cout &lt;&lt; digit &lt;&lt; "" "";
        number /= 10;
    }

    cout &lt;&lt; ""\nSum of digits: "" &lt;&lt; sum &lt;&lt; ""\n"";
</code></pre>
",3
40964162,40963958,1,"<p>This is probably easiest solution for you to understand:</p>

<pre><code> #include &lt;iostream&gt;

using namespace std;
int main()
{
int number;
int number2;
int numberReverse;
int sum = 0;

cout &lt;&lt; ""Enter a five-digit number: "";
cin &gt;&gt; number;

numberReverse = number;

cout &lt;&lt; number / 10000 &lt;&lt; "" "";
sum = sum + number/10000;
number = number % 10000;
cout &lt;&lt; number / 1000 &lt;&lt; "" "";
sum = sum + number/1000;
number = number % 1000;
cout &lt;&lt; number / 100 &lt;&lt; "" "";
sum = sum + number/100;
number = number % 100;
cout &lt;&lt; number / 10 &lt;&lt; "" "";
sum = sum+number/10;
number = number % 10;
cout &lt;&lt; number &lt;&lt; endl;
sum = sum+number;

cout &lt;&lt; ""Reverse: "" &lt;&lt; endl;

number2 = numberReverse%10;
cout &lt;&lt; number2 &lt;&lt; "" "";
number2 = (numberReverse/10)%10;
cout &lt;&lt; number2 &lt;&lt; "" "";
number2 = (numberReverse/100)%10;
cout &lt;&lt; number2 &lt;&lt; "" "";
number2 = (numberReverse/1000)%10;
cout &lt;&lt; number2  &lt;&lt; "" "";
number2 = (numberReverse/10000)%10;
cout &lt;&lt; number2 &lt;&lt; endl;

cout &lt;&lt; ""Sum is "" &lt;&lt; sum;

return 0;
}
</code></pre>
",7
40964283,40963958,0,"<p>I think, you need to do something like this:</p>

<pre><code>int number;

... some IO operations ...

std::vector&lt;int&gt; digits;
do {
    digits.push_back(number % 10);
    number /= 10;
} while (number);
</code></pre>

<p>After this all you need to do is 2-3 loops through vector <code>digits</code></p>

<pre><code>for (std::size_t k = digits.size() - 1; k &gt;= 0; --k)
   std::cout &lt;&lt; digits[k] &lt;&lt; "" "";
std::cout &lt;&lt; std::endl;
for (std::size_t k = 0; k &lt; digits.size(); ++k)
    std::cout &lt;&lt; digits[k] &lt;&lt; "" "";
std::cout &lt;&lt; std::endl;
int sum = 0;
for (std::size_t k = 0; k &lt; digits.size(); ++k)
    sum += digits[k];
std::cout &lt;&lt; sum;
</code></pre>
",0
35239648,35239547,2,"<p>You have to incement your control varibales <code>i</code> ans <code>j</code> inside your loops. You did it outsid the loops directly after. Apart from this the varibale <code>stars</code> was incremented in the outer <code>for</code> loop. In the secend code snippet you did it in the inner <code>while</code> loop.  Adapt your code like this:</p>

<pre><code>#include&lt;iostream&gt;

int main()
{
    int n;
    std::cout&lt;&lt;""Enter the number of rows"";
    std::cin&gt;&gt;n;
    int stars=1;
    int i=1;
    while ( i&lt;=n )         // corresponds to for(i=1;i&lt;=n;i++) { .... }
    {
        int j=1;
        while ( j&lt;=stars ) // corresponds to for(j=1;j&lt;=stars;j++) cout&lt;&lt;""*"";
        {
            std::cout&lt;&lt;""*"";
            j++;           // increment control variable inside of the loop  
        }

        std::cout&lt;&lt;""\n"";
        stars++;
        i++;               // increment control variable inside of the loop    
    }
    return 0;
}
</code></pre>

<p>Note if you improve the formatting of the code, you'll find such mistakes easily.</p>
",0
34954564,34954543,5,"<p>You never allocated any memory for <code>p</code> so you have an uninitialized pointer pointing to garbage.  Once you dereference it is <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behavior</a>.</p>

<pre><code>int *p;
</code></pre>

<p>Should be</p>

<pre><code>int *p = new int;
</code></pre>

<p>And then you need a</p>

<pre><code>delete p;
</code></pre>

<p>before the end of main as every <code>new</code>/<code>new[]</code> should be matched with a <code>delete</code>/<code>delete[]</code>.</p>

<p>But in this case there is no reason to even do that.  Just use a regular int and you have</p>

<pre><code>int main()
{
    int p = 9;
    std::cout&lt;&lt; p &lt;&lt; '\n';
    return 0;
}
</code></pre>
",2
35214174,35213889,3,"<p>The program looped back to getline as you told it to with the for statement. Your exit condition is getline returns false. To do this you need to close the file, you do this by entering <kbd>Control-D</kbd> on Unix or <kbd>Control-Z</kbd> on Windows.</p>

<p>Another tactic would be to loop until somebody types 'q' or 'exit' or an empty line.</p>
",0
45094809,45094680,6,"<p>In C++17, inline variables will be introduced. A <code>static constexpr</code> data member of a class will be implicitly inline and will be a definition of that data member. Multiple definitions will be resolved at link time into a single address for that data member.</p>

<p>In your example, <code>A::j</code> is <code>const</code> but not <code>constexpr</code>, so that provision will not apply to it. Your example will work the same in all versions from C++98 to C++17.</p>

<p>In the case where <code>j</code> is <code>constexpr</code>, in C++17 and later, the out-of-line definition <code>const int A::j</code> will become a redundant declaration that the compiler will ignore. Yes, this is for backward compatibility reasons.</p>
",5
37299836,37299777,1,"<p>You have some syntax error</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;

using namespace std;

class Product
{
    string title;
    string sirName;
    string isbn;
    double wholesalePrice;
public:
    Product();
    Product(string, string, string, double);
    ~Product() {}
    void setInfo(string, string, string, double);
    string getTitle();
    string getSurName();
    string getIsbn();
    double getWholesalePrice();

};


//Derived Class----------------------------Stock----------------------------
class Stock:public Product{ // use ':' instead of '::'

    double retailPrice;
    char bookFormat;
    int stockLevel;

    Stock();
    ~Stock() {}
    void setRetail() {} // add function body or ';'
};
</code></pre>
",1
37036194,37035993,2,"<pre><code>  else
    {
        int tens = _amount1 / 10;
        int ones = _amount1 - (tens * 10);
        str_one = ten_ninety[tens] + upto20[ones];
    }
</code></pre>

<p>if amount = 100, then tens will equal 10, which you use as reference into an array of 10 elements, which steps outside the bounds of the array. You code might work &lt; 100, but once it hits a hundred it won't function anymore. </p>
",2
36573190,36572789,0,"<p>what you are trying to do is Object slicing:</p>

<p>It happens when a derived class object is assigned to a base class object, additional attributes of a derived class object are sliced off to form the base class object</p>
",2
36573290,36572789,0,"<p>If you don't mind casts you need to:</p>

<ul>
<li>Make parent function virtual for dynamic binding to work </li>
<li>if you need to use a generic container you will need to use pointers to base class as objects. </li>
</ul>

<p>Sample edits: </p>

<pre><code>   class Action:
   {
        virtual int updateOK() {
            std::cout &lt;&lt; """" &lt;&lt; std::endl;
            return 0;
        }
   };

--- the rest of classes --- 

    namespace actions
    {
        const Action* light = new Attack();
        const Action* meduim = new Attack();
        const Action* heavy = new Attack();
        const Action* block = new Block();
        const Action* cancelBlock = new Block();
        const std::vector&lt;Action*&gt; listAction { light , meduim, heavy , block, cancelBlock };
    }

    Main.cpp :
    for(Action* action : actions::listAction) {
                action-&gt;updateOK();
    }
</code></pre>
",1
37248721,37248428,0,"<p>The first code example does not determine if a number is odd. It uses pre-existing knowledge to print all off numbers in the 1-20 range. The pre-existing knowledge is that you already know that the numbers 1, 3, 5, ... are odd numbers, you just print that information. The second example goes over all numbers 1-20 and calculates/determines if any number in that range is an odd number. Meaning, if it's not divisible by 2 (hence the % 2 operation) then it's an odd number. That's what your teacher is saying.</p>
",3
37249157,37248428,2,"<p><b>TL;DR</b> Your version is clearly better in every possible way :). The version of your teacher loops 20 times, while your version only loops 10 times. It is 100% more efficient (even if it gets optimized away by the compiler, then there is no difference).</p>
<p><i>Note: you don't even need the <code>=</code> in the comparison, because it will never be <code>20</code>, only less.</i></p>
<hr>
<p>If you want to you can see the difference in the assembly generated (non-optimized):</p>
<p><b>Your version</b></p>
<pre><code>main:
                                   ; Initialization omitted
.LCFI1:
        subq    $16, %rsp
        movl    $1, -4(%rbp)       ; Initialize 'i' to 1
        jmp     .L2                ; Jump to compare statements
.L3:
        movl    -4(%rbp), %eax     ; Copy 'i' to register1 (for function call)
    
        ; Omitted call to std::cout to output 'i' and '\n'
        
        addl    $2, -4(%rbp)       ; Add 2 to 'i'
.L2:
        cmpl    $20, -4(%rbp)      ; Compare 'i' to 20
        jle     .L3                ; Jump only if 'i' &lt; 20
        movl    $0, %eax           ; Reset (cleanup)
        leave                      ; Leave
</code></pre>
<p><b>His version</b></p>
<pre><code>main:
.LCFI1:
        subq    $16, %rsp
        movl    $1, -4(%rbp)       ; Initialize 'i' to 1
        jmp     .L2                ; Jump to compare statements
.L4:
        movl    -4(%rbp), %eax     ; Copy 'i' to register1
        andl    $1, %eax           ; XOR 'i' with 1 (same as 'i' % 2)
        testl   %eax, %eax         ; Compares 'i' to 'i'
        je      .L3                ; Continue loop by jumping if 'i' == 0
                                   
        ; Omitted call to std::cout to output 'i' and '\n'
.L3:
        addl    $1, -4(%rbp)       ; Add 1 to 'i'
.L2:
        cmpl    $20, -4(%rbp)      ; Compare 'i' to 20
        jle     .L4                ; Jump only if 'i' &lt; 20
        movl    $0, %eax           ; Reset (cleanup)
        leave                      ; Leave
</code></pre>
<p>As you can see your version has far less instructions than his version, so yours runs faster, in the non-optimized code.</p>
<p>Here are the benchmarks for the non-optimized version</p>
<pre><code>Version | Time
You     | 0s
His     | 0.015625s
</code></pre>
<p>And here for the optimized (compiled using <code>-O3</code>)</p>
<pre><code>Version | Time
You     | 0s
His     | 0s
</code></pre>
<p>In the end, there is no difference, because the compiler is quite good at optimizing such loops.</p>
<h1><em>Disclaimer</em></h1>
<p>The above assembly was generated by g++ 4.8.4 on Ubuntu 14, using the following command: <code>g++ -S -fno-asynchronous-unwind-tables -fno-dwarf2-cfi-asm foo.cpp</code></p>
",1
47487846,47487731,4,"<p>Yes, it is possible, but I wouldn't recommend it <em>at all</em>. Because <code>std::get</code> has multiple overloads, you need to <code>static_cast</code> to the right one.</p>

<pre><code>static_cast&lt;int&amp;(*)(std::tuple&lt;int, int&gt;&amp;)&gt;(&amp;std::get&lt;0, int, int&gt;)
</code></pre>

<p>Really, that's not nice to look at, with repetition of template arguments two times. And if you want the cast to be generic, it will be pretty long.</p>

<p>Instead, to shorten your lambda, you can drop the <code>-&gt; int</code>, as the return type will get automatically deduced:</p>

<pre><code>std::transform( vt.begin(), vt.end(), vi.begin(), [](auto &amp;v) {
    return std::get&lt;0&gt;(v);
} );
</code></pre>

<hr>

<p>Someday, we might be able to write this:</p>

<pre><code>std::transform(vt.begin(), vt.end(), vi.begin(), [](auto &amp;v) =&gt; std::get&lt;0&gt;(v));
</code></pre>
",4
36251487,36251336,1,"<p>Your member functions take <code>int</code> as argument, but you make array of pointers to member functions as if arguments were pointer of type <code>int*</code>.
Pointer to function arguments and return type must be exactly same as function's that is pointed to. Change:</p>

<pre><code>void (Menu::*fptr[3])( int*);
</code></pre>

<p>to:</p>

<pre><code>void (Menu::*fptr[3])(int);
</code></pre>
",1
36255879,36255844,0,"<p>Open the command prompt and type <code>g++ 'yourprogram.c'</code> and it should compile and leave you with an executable called a.exe or something like that. Run the executable by typing <code>./a.exe</code>.</p>
",1
38873817,38873684,1,"<p>You need to call <code>srand(time(NULL));</code> only once for the whole execution. So move it outside your function and you could put it in <code>main()</code> like this:</p>

<pre><code>// ..

int main(void){
    srand(time(NULL));
    //..

    return 0;
}

// ..

int GenerateRandom(int a){
    int b;
    b = rand() % a;
    return b;
}
</code></pre>
",1
38874091,38873684,0,"<p>The loop condition</p>

<pre><code>while(StepCount != MaxStepCount)
</code></pre>

<p>is not a good idea if StepCount is incremented more than one at each loop iteration.</p>

<p>If you replace it by </p>

<pre><code>while(StepCount &lt; MaxStepCount)
</code></pre>

<p>It should terminate.</p>

<p>Consider using a debugger like gdb instead of having breakpoints with cin.get(). It is more efficient for the debug and you can ask for the value of your counter for each loop.</p>
",1
36709913,36709546,-1,"<p>Have a bool flag for the loop. If you find a match, set it to true. Then, you can place a check where your comment is.</p>

<pre><code>if(flag)
{
//code if found
}
else
{
//code if not found
}
</code></pre>
",0
36710590,36709546,0,"<p>You can use <code>std::find</code> to locate the raw string within the array. To get the index for the digits array just subtract the begin of the array from the iterator returned by std::find. </p>

<p>std::find requires two iterators (begin and end) for the search range. Plain pointers can be used as iterators (because they support incrementing (++) and dereferencing (*)). The return value is either an interator pointing to the first element found or an end-iterator pointing to the end (one past the last element).</p>

<p>The std::function parameter allows you to specify a callback for lines not found in the raw string array. You can use any function or lambda that matches the signature (<code>const std::string&amp;</code> parameter and <code>std::string</code> return value). </p>

<p><strong>WARNING</strong>: The following code is not correct. It uses 82 for the number of dictionary entries (like the code from the original post) but it defines only 6 dictionary entries. This will result in undefined behaviour if using unknown raw strings. You should add 76 dictionary entries or reduce the entry-count from 82 to 6.</p>

<pre><code>#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;

using namespace std;

const string dictionary_array_strings_raw[] = { // x
    ""25643663"",
    // Y
    ""2346442"", ""2446442"",
    // Z
    ""3676764"",
    // :
    ""4"",
    // -
    ""111""
};

const string dictionary_array_strings_digits[] = { // x
    ""X"",
    // Y
    ""Y"", ""Y"",
    // Z
    ""Z"",
    // :
    "":"",
    // -
    ""-"",
    // 1  
};

string string_look_up(string data, std::function&lt;std::string(const std::string&amp;)&gt; callback)
{
    assert(callback != nullptr);

    const auto dictionary_array_strings_raw_end = dictionary_array_strings_raw + 82;

    std::string loc_string = """";

    std::stringstream ss(data);

    std::string line;
    while (std::getline(ss, line, '0'))
    {
        if (line.empty())
        {
            continue;
        }

        cout &lt;&lt; line &lt;&lt; endl;
        const auto it = std::find(dictionary_array_strings_raw, dictionary_array_strings_raw_end, line);

        if (it == dictionary_array_strings_raw_end)
            loc_string += callback(line);
        else
            loc_string += dictionary_array_strings_digits[it - dictionary_array_strings_raw];

        cout &lt;&lt; loc_string &lt;&lt; endl;
        cout &lt;&lt; ""######"" &lt;&lt; endl;
    }

    return loc_string;
}
</code></pre>

<p>The following example shows the use of a lambda for unknown raw strings ('99' in the example).</p>

<pre><code>int main(int argc, char **argv)
{
    const auto result = string_look_up(""25643663023464420990"", [](const std::string&amp; line) { return '&lt;' + line + '&gt;'; });
    std::cout &lt;&lt; ""Result:\n"" &lt;&lt; result;

    return 0;
}
</code></pre>

<p>When string_look_up encounters the line containing '99' it tries to find a matching raw-string. When it does not find a matching raw string it calls the callback-function with ""99"" as its only parameter. The lambda defined in main adds '&lt;' before and '&gt;' after the line value and returns the result to string_look_up() which adds the return value to the result.</p>

<p>The input <code>25643663023464420990</code> results in the output <code>XY&lt;99&gt;</code> (and a lot of debug output)</p>

<p>I would recommend using a std::map for the translation table (raw strings as keys, digits as values). With a map you could use the find() member function to get the iterator (let's call it 'it') and it->second to get the digits string.</p>

<p>Here is an example for the static initialization of a map:</p>

<pre><code>const std::map&lt;std::string, std::string&gt; translationTable = {
    {""25643663"", ""X""},
    {""2346442"", ""Y""},
    {""2446442"", ""Y"" }
    // ...
};
</code></pre>

<p>You can search for a value with <code>const auto it = translationTable.find(line);</code> and compare it to <code>translationTable.end()</code> to check if the search was successfull. <code>it-&gt;first</code> contains the raw string (i.e. ""25643663"") while <code>it-&gt;second</code> contains the digits string (i.e. ""X"")</p>
",0
38502373,38502039,2,"<p>Your condition is not an interval (diapason). It is functionally equivalent to</p>

<pre><code>X &lt; std::min(A, B)
</code></pre>

<p>You only have an upper bound, no lower bound at all.</p>

<hr>

<p>Exactly how NaN and +Inf behave, depends on the floating point representation, which is not specified by the C++ standard, but is cpu specific.</p>

<p>If we assume the commonly used IEEE-754, then neither X=+Inf, nor X=NaN can satisfy the condition for any values of A and B.</p>

<hr>

<p>This is how you check that a floating point number is between a lower and an upper bound (but equal to neither):</p>

<pre><code>X &gt; low &amp;&amp; X &lt; high
</code></pre>

<p>or</p>

<pre><code>low &lt; X &amp;&amp; X &lt; high
</code></pre>

<p>Again, if we assume IEEE-754, then neither X=+Inf, nor X=NaN can satisfy this condition for any values of low and high. But, since IEEE-754 might not be guaranteed, the behaviour of such numbers is not specified. You might need to be explicit to support exotic hardware:</p>

<pre><code>low &lt; X &amp;&amp; X &lt; high &amp;&amp; std::isfinite(X)
</code></pre>
",2
40757790,40749749,1,"<p>Here it is written with a function instead</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt; // for exit()

using namespace std;

void readfile(string file)
{

   ifstream inf (file.c_str());

    if (!inf)
    {
        // Print an error and exit
        cerr &lt;&lt; ""Uh oh, file could not be opened for reading!"" &lt;&lt; endl;
        exit(1);
    }

    while (inf)
    {
        std::string strInput;
        getline(inf, strInput);
        cout &lt;&lt; strInput &lt;&lt; endl;
    }
}

int main()
{
    cout &lt;&lt; ""-------------------obtaining Totaltime and Idletime----------------"" &lt;&lt; endl;
    readfile(""/proc/uptime"");

    return 0;
}
</code></pre>
",1
36526718,36517403,0,"<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int found(int array[], int size, int key);
void throwOut(int array[], int &amp;size, int key);

int main()
{
  int array[] = {8, 4, 2, 8, 0, 3};
  int size = 6;
  int key = 8;
  throwOut(array, size, key);
  for(int i = 0; i &lt; size; i++) {
      std::cout&lt;&lt;array[i]&lt;&lt; "" "";
  }
}
// This function found key in array.
// return first index where key was found.
// return -1 if key was not found.
int found(int array[], int size, int key) {
    for (int i = 0; i &lt; size; i++) {
        if (array[i] == key) {
            return i;
        }
    }
    return -1;
}

// This function removes all key from array and then fix the size of array.
void throwOut(int array[], int &amp;size, int key) {
    int f = found(array, size, key);
    if (f &gt;= 0) {
        int count = 1;
        for (int i = f + 1; i &lt; size; i++) {
            if (array[i] != key) {
                array[f] = array[i];
                f++;
            } else {
                count++;
            }
        }
        size -= count;
    }
}
</code></pre>

<p>When I run this code, it prints <code>4 2 0 3</code>. You can also run it here: <a href=""http://cpp.sh/5gqd"" rel=""nofollow"">http://cpp.sh/5gqd</a></p>
",0
42596465,42596209,0,"<p>I rather applied a simple method. 
Say I have to get <code>jth</code> element from the begging.</p>

<pre><code>map&lt;int, int&gt;::iterator it = mpp.begin();
while(j--)
          it++;
cout &lt;&lt; it-&gt;first &lt;&lt; "" "" &lt;&lt; it -&gt; second &lt;&lt; endl;
</code></pre>
",0
42596498,42596209,1,"<p>Only random access iterators have overloads for <code>operator+</code> and <code>operator-</code>. Bidirectional iterators such as <code>std::map::iterator</code> do not. They can however be advanced linearly by using <code>std::next</code> (since C++11) which will</p>
<blockquote>
<p>Return the nth successor of iterator it.</p>
</blockquote>
<p>or <code>std::advance</code> which</p>
<blockquote>
<p>Increments given iterator it by n elements.</p>
</blockquote>
<hr />
<p>PS. Note that the complexity for finding n'th element of a <code>std::map</code> has linear complexity. There are other similar data structures provide the features that <code>std::map</code> has, but also allow for faster n'th member lookup. So, and alternative data structure might more appropriate for your use case.</p>
<p>For example, a binary search tree can be augmented with the size of each subtree. Such structure is named order statistic tree. For the small linear increase in memory overhead, it gives O(log n) complexity for finding n'th element.</p>
",0
40773681,40773652,0,"<p>You're not initialising the <code>produse</code> field.</p>

<p>If you want to use C++ idiomatically you should use <code>vector</code> instead of raw arrays and <code>string</code> instead of <code>char*</code>.</p>
",1
40773700,40773652,0,"<p>Since you allocate memory with <code>new[]</code>, you need to deallocate it with <code>delete[]</code>:</p>

<pre><code>int *p = new int[10];
...
delete[] p;

int* p[1] = {new int[10]};
...
delete[] p[0];
</code></pre>

<p>And since <code>produse</code> is <code>char **</code>, you should allocate memory for <code>produse</code> before trying to dereference it:</p>

<pre><code>char **produse = new char *[10];
produse[0] = new char [10];
...
delete[] produse[0];
delete[] produse;
</code></pre>
",0
40773758,40773652,1,"<p>You are not allocating any memory for <code>this-&gt;produse</code> before trying to populate it.  Also, because you are manually managing dynamically allocated memory, you need to implement the <a href=""https://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming)"" rel=""nofollow noreferrer"">Rule of Three</a> manually as well.</p>

<p>Try this instead:</p>

<pre><code>#include &lt;algorithm&gt;

class Ferma
{
private:
    int m_id_ferma;
    int m_suprafata
    int m_nr_produse;
    char** m_produse; // &lt;-- change this to char**!

public:
    Ferma(int id_ferma, int suprafata, int nr_produse, char* produse[])
        : m_id_ferma(id_ferma), m_suprafata(suprafata), m_nr_produse(nr_produse)
    {
        m_produse = new char*[nr_produse]; // &lt;-- add this!

        for (int i = 0; i &lt; nr_produse; ++i)
        {
            m_produse[i] = new char[strlen(produse[i]) + 1];
            strcpy(m_produse[i], produse[i]);
        }
    }

    Ferma(const Ferma &amp;src) // &lt;-- add this!
        : m_id_ferma(src.m_id_ferma), m_suprafata(src.m_suprafata), m_nr_produse(src.m_nr_produse)
    {
        m_produse = new char*[m_nr_produse];

        for (int i = 0; i &lt; m_nr_produse; ++i)
        {
            m_produse[i] = new char[strlen(src.m_produse[i]) + 1];
            strcpy(m_produse[i], src.m_produse[i]);
        }
    }

    ~Ferma()
    {
        for (int i = 0; i &lt; m_nr_produse; ++i)
            delete[] m_produse[i]; // &lt;-- change this to delete[]!

        delete[] m_produse; // &lt;-- add this!
    }

    Ferma&amp; operator=(const Ferma &amp;rhs) // &lt;-- add this!
    {
        Ferma tmp(rhs);
        std::swap(m_id_ferma, tmp.m_id_ferma);
        std::swap(m_suprafata, tmp.m_suprafata);
        std::swap(m_nr_produse, tmp.m_nr_produse);
        std::swap(m_produse, tmp.m_produse);
        return *this;
    }
};
</code></pre>

<p>That being said, you should stop using manual memory management.  Use <code>std::vector</code> and <code>std::string</code> instead, let the STL handle all of the memory management for you:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;

class Ferma
{
private:
    int m_id_ferma;
    int m_suprafata;
    std::vector&lt;std::string&gt; m_produse;

public:
    Ferma(int id_ferma, int suprafata, int nr_produse, char* produse[])
        : id_ferma(id_ferma), m_suprafata(suprafata)
    {
        m_produse.reserve(nr_produse);

        for (int i = 0; i &lt; nr_produse; ++i)
            m_produse.push_back(produse[i]);

        // alternatively:
        // std::copy(produse, produse+nr_produse, std::back_inserter(m_produse));
    }

    // no destructor, copy constructor, or copy assignment operator needed!
};
</code></pre>
",0
40527626,40527576,7,"<p>This:</p>

<pre><code>int getTransID()        { return transID;  }
</code></pre>

<p>has nothing to do with your class, it's a global function.</p>

<p>You meant:</p>

<pre><code>int Transaction::getTransID() { return transID;  }
</code></pre>

<p>Also, that function (and the other getters) should be made <code>const</code> to signal that they don't modify the object.</p>
",1
39596595,39596272,3,"<p>Absolutely. <code>std::shared_ptr</code> comes with <a href=""http://en.cppreference.com/w/cpp/memory/weak_ptr"" rel=""nofollow""><code>std::weak_ptr</code></a>, a pointer that can point to an object managed by a set of <code>std::shared_ptr</code>s and check whether it is still alive, but does not extends the object's lifetime.</p>

<p>You just have to keep the original <code>std::shared_ptr</code> to your object, and lend <code>std::weak_ptr</code>s to other users of that object. When the object must be destroyed, reset the <code>std::shared_ptr</code>, and all remaining <code>std::weak_ptr</code>s will be able to tell (they'll return null <code>std::shared_ptr</code>s when the users try to lock them).</p>
",5
43749864,43749860,-2,"<p>I think you meant to put this: <code>if(num == 5 || num == 6)</code> as your condition <code>|| 6</code> is a non zero value and so evaluates to true everytime. </p>
",1
43749872,43749860,0,"<p>Your if statement isn't doing what you think it does. Try this:</p>

<pre><code>if(num == 5 || num == 6)
</code></pre>

<p>""Or"" in C++ is || not a single bar.</p>
",1
43750068,43749860,1,"<p>All right. You're encountering a bit of misunderstanding on your part, aggravated by a wart in the C language.</p>

<p>The <code>==</code> operator only compares values, it won't look in a list. It returns 1 or 0, which represents true or false respectively.</p>

<p>The <code>|</code> operator is the ""binary-or"" operator. It performs an operation comparing the values of two numbers bit by bit ( this is known as a bit-wise operation ). The <code>|</code> sets the bit in the final number to 1 if the same bit is 1 in either of the given numbers.</p>

<pre><code>0b00 | 0b00 -&gt; 0b0000
0b10 | 0b00 -&gt; 0b0010
0b00 | 0b10 -&gt; 0b0010
0b10 | 0b11 -&gt; 0b0011
</code></pre>

<p>The <code>||</code> operator is the ""logical-or"" operator, and returns 1, meaning true, if either of its given expressions yield 1. If the left expression yields 1, it doesn't bother to execute the right one ( this is known as short circuiting ).</p>

<p>HOWEVER, when they were initially creating C, they did something that has plagued the language since. They made <code>==</code> bind tighter than <code>|</code> in the order of operations ( also known as operator precedence ). This means <code>( 1 == 2 | 3 )</code> does not mean ""the result of comparing 1 to the result of taking the binary or of 2 and 3"", but instead means ""the result of taking the binary or of ( the result of comparing 1 and 2 ) and 3"".</p>

<p>It means <code>( ( 1 == 2 ) | 3 )</code>, where <code>( 1 == ( 2 | 3 ) )</code> is what most would expect before being made aware of this oddity.</p>

<p>All this taken together, your if statement means:</p>

<pre><code>if ( num == 5 ) | 6:
  quit()
</code></pre>

<p>Which is very likely to quit for numbers other than 5 or 6! :)</p>
",0
43749864,43749860,-2,"<p>I think you meant to put this: <code>if(num == 5 || num == 6)</code> as your condition <code>|| 6</code> is a non zero value and so evaluates to true everytime. </p>
",1
43749872,43749860,0,"<p>Your if statement isn't doing what you think it does. Try this:</p>

<pre><code>if(num == 5 || num == 6)
</code></pre>

<p>""Or"" in C++ is || not a single bar.</p>
",1
43750068,43749860,1,"<p>All right. You're encountering a bit of misunderstanding on your part, aggravated by a wart in the C language.</p>

<p>The <code>==</code> operator only compares values, it won't look in a list. It returns 1 or 0, which represents true or false respectively.</p>

<p>The <code>|</code> operator is the ""binary-or"" operator. It performs an operation comparing the values of two numbers bit by bit ( this is known as a bit-wise operation ). The <code>|</code> sets the bit in the final number to 1 if the same bit is 1 in either of the given numbers.</p>

<pre><code>0b00 | 0b00 -&gt; 0b0000
0b10 | 0b00 -&gt; 0b0010
0b00 | 0b10 -&gt; 0b0010
0b10 | 0b11 -&gt; 0b0011
</code></pre>

<p>The <code>||</code> operator is the ""logical-or"" operator, and returns 1, meaning true, if either of its given expressions yield 1. If the left expression yields 1, it doesn't bother to execute the right one ( this is known as short circuiting ).</p>

<p>HOWEVER, when they were initially creating C, they did something that has plagued the language since. They made <code>==</code> bind tighter than <code>|</code> in the order of operations ( also known as operator precedence ). This means <code>( 1 == 2 | 3 )</code> does not mean ""the result of comparing 1 to the result of taking the binary or of 2 and 3"", but instead means ""the result of taking the binary or of ( the result of comparing 1 and 2 ) and 3"".</p>

<p>It means <code>( ( 1 == 2 ) | 3 )</code>, where <code>( 1 == ( 2 | 3 ) )</code> is what most would expect before being made aware of this oddity.</p>

<p>All this taken together, your if statement means:</p>

<pre><code>if ( num == 5 ) | 6:
  quit()
</code></pre>

<p>Which is very likely to quit for numbers other than 5 or 6! :)</p>
",0
34974231,34974166,1,"<p>Have a look at the <a href=""http://en.cppreference.com/w/cpp/language/operator_precedence"" rel=""nofollow"">C++ operator precedence</a>.</p>

<p>(++) post-increment has the highest precedence, sou you end up with <code>(a++) + b</code>. </p>
",0
34974278,34974166,2,"<p>A key part of why <code>a+++b</code> ""works"", and <code>a++b</code> doesn't is the way the C and C++ language parsing is defined. It is what is called a 'greedy' parser. It will combine as many elements as possible to produce a valid token. </p>

<p>So, given that it's a greedy parser, <code>a++b</code> becomes <code>a++ b</code>, which is not valid. <code>a+++b</code> becomes <code>a++ + b</code>, which is syntactically valid - whether that is what you WANT is another matter. If you want to write <code>a + +b</code>, then you need spaces to separate the tokens. </p>
",0
34974190,34974166,1,"<p>Looks like <em>a</em> is post increment then added to <em>b</em> with bad spacing. For example a++ + b. The variable <em>a</em> is evaluated then incremented. That being said a++b is invalid syntax. </p>
",0
36607364,36606966,7,"<p>Your professor is trying to demonstrate that the area of memory around your program contains ""stuff"" - specifically that the memory around your program isn't zero'd or set to any other default value. </p>

<p>Presumably, this is part of a further point that accessing memory out-of-bounds doesn't guarantee that you'll have any particular value, and as such need to initialise your variables accordingly.</p>

<p><strong>However;</strong> the problem is that we consider ""accessing out-of-bounds of an array"" to be undefined behaviour. Undefined behaviour in the C++ standard means ""the compiler can handle this situation in whatever way it considers appropriate"". Most compilers will serve you values from nearby memory locations (this being simple to do), but they're not required to do so. </p>

<p>Likewise, some compilers can aggressively optimise-out undefined behaviour (like concluding that <code>i</code> can never be greater than 1 when used to index into <code>a</code>, and adjusting the loop appropriately): compilers are free to assume (for optimisation purposes) that undefined behaviour is never invoked by the programmer. See <a href=""http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html"">this page from the LLVM project</a> for more details on undefined behaviour (noting that under ""Dereferences of Wild Pointers and Out of Bounds Array Accesses"", both the Clang team and g++ have made the same decision with regards to handling out-of-bounds errors: they access nearby memory locations; because it's the simplest thing to do in that case).</p>
",0
36709041,36708754,1,"<pre><code>string content[10000];
string encryptedContent[10000];
</code></pre>

<p>This is wrong because it is creating 20000 strings (you probably think it is creating a large enough character array to read the data). </p>

<p><code>string content;</code> is enough. It can be resized to handle any length of strings.</p>

<p>You just need to read/write the file in binary:</p>

<pre><code>int main() 
{
    string input = ""input.txt"";
    ifstream file(input, ios::binary);
    if (!file.is_open())
    {
        cout &lt;&lt; ""\tUnable to open the file: "" &lt;&lt; input &lt;&lt; ""!\n"";
        return 0;
    }

    string plaintext;

    //read the file    
    file.seekg(0, std::ios::end);
    size_t size = (size_t)file.tellg();
    file.seekg(0);
    plaintext.resize(size, 0);
    file.read(&amp;plaintext[0], size);

    cout &lt;&lt; ""reading:\n"" &lt;&lt; plaintext &lt;&lt; ""\n"";

    //encrypt the content
    string encrypted = encrypt(plaintext);

    //encrypt again so it goes back to original (for testing)
    string decrypted = encrypt(encrypted);

    cout &lt;&lt; ""testing:\n"" &lt;&lt; decrypted &lt;&lt; ""\n"";

    /* Write encryption to file */
    ofstream outputFile(""output.txt"", ios::binary);
    outputFile.write(encrypted.data(), encrypted.size());

    return 0;
}
</code></pre>
",1
36644768,36644662,1,"<p>This looks and compiles OK for me. Are you sure you've turned on C++11 support in your compilers? It's often off by default (e.g. Clang has <code>-std=c++11</code>).</p>

<p>For Visual Studio, check C++11 feature support at <a href=""https://msdn.microsoft.com/en-us/library/hh567368.aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/hh567368.aspx</a>.</p>

<p>Edit: I checked for you, curious (as I've not used VC++ for years). Apparently:</p>

<blockquote>
  <p>These are now supported, but with this exception: For defaulted functions, the use of <code>=default</code> to request member-wise move constructors and move assignment operators is not supported</p>
</blockquote>
",0
41688374,41688346,4,"<p>Your code has two problems:</p>

<ol>
<li>It skips an element when you erase an element.</li>
<li>It runs in to a problem (leading to undefined behavior) if you call <code>erase</code> on the last element of the vector.</li>
</ol>

<p>Here's what you should use:</p>

<pre><code>for (vector&lt;vector&lt;Point&gt;&gt;::iterator it = contours.begin(); it != contours.end(); ) {
    if (contourArea(*it) &lt; 50) {
        it = contours.erase(it);
    }
    else {
        ++it;
    }
}
</code></pre>
",0
36462391,36450828,0,"<p>@interjay already answered your question pointing out the error in the condition:</p>

<pre><code>if ( column = 0 ... // should be ==
</code></pre>

<p>As many others said, remember to always enable all the warnings your compiler can rise. You could also try to  write the literals first:</p>

<pre><code>if ( 0 = column ... // that's an error every compiler can catch
</code></pre>

<p>The main reason I wrote this answer is that I'd like to show you a different (maybe more readable and less error prone) algorithm to achive your task, if I may.</p>

<p>Think about the ship and its sorrounding water as a rectangle in the sea (board). To check all the cells inside a rectangle is easy, it can be done in a nested loop. To correctly define the vertices of the rectangle of search may be trickier, but not too much.</p>

<p>I guess I've figured out how you store the data about the ships (the needed ones at least), so this snippet of code should work:</p>

<pre><code>const int rows = 10;
const int cols = 10;

bool CheckPlace(int row, int column, DIRECTION direct, Battleship ship) {

    // check if the top left corner of the ship is inside the board
    if ( row &lt; 0  ||  row &gt;= rows  ||  column &lt; 0  || column &gt;= cols )
        return false;

    int r_min = row,            // temporary top side of the rectangle
        c_min = column,         // temporary left side
        r_max = row + 2,        // temporary bottom side
        c_max = column + 2;     // temporary right side

    // update top and left size if there is enough space
    if ( r_min &gt; 0 ) --r_min;
    if ( c_min &gt; 0 ) --c_min;

    // use ship length and direction to update values for right and bottom side
    // max values are one past the border of the rectangle
    if ( horizontal == direct ) 
        c_max += ship.GetLength() - 1;
    else 
        r_max += ship.GetLength() - 1;

    // check if the bottom rigth corner of the ship is outside the board
    if ( r_max &gt; rows + 1 ||  c_max &gt; cols + 1 )
        return false;

    // clip the rectangle if the ship is near the border
    if ( r_max &gt; rows )
        --r_max;
    if ( c_max &gt; cols )
        --c_max;

    // check inside the rectangle
    for ( int i = r_min; i &lt; r_max; ++i ) {
        for ( int j = c_min; j &lt; c_max; ++j ) {
            if ( '_' != board[i][j] )
                return false;
        }   
    }   

    // open water
    return true;
}
</code></pre>
",0
48006915,48006360,3,"<p>Thank you <a href=""https://stackoverflow.com/users/597607/bo-persson"">Bo Persson</a> for your contribution.  The suggested solution is readable and functional:</p>

<pre><code>void MainLoop::RunLoop(){
    while(programState != MainLoop::Shutdown){
        switch(programState){
            case MainLoop::Uninitialized:{
                break;
            }
            case MainLoop::RunningGame:{
                MainLoop::RunGame();
                break;
            }
            case MainLoop::Exiting:{
                MainLoop::ExitSafely();
                programState = MainLoop::Shutdown;
                break;
            }
        }
    }
}
</code></pre>
",0
45221221,45221056,3,"<p>First, your book is wrong, or at least very simplifying. For example, you could compile and run valid and standard C++ code on a Linux server (that you have rented from some VPS provider) or a supercomputer and such a server has no screens and no windows. And the C++ code (compiled) that you use on servers running in datacenters at Google or Facebook (probably the most common computations you do) has no ""windows"".</p>

<p>Or you could cross-compile some C++ code for a small microcontroller like an <a href=""https://www.arduino.cc/"" rel=""nofollow noreferrer"">arduino</a> which has no screens and no windows.</p>

<p>Then, even if you assume to compile then run some C++ code on a laptop (running an ordinary operating system like Linux, Window, MacOSX, Android....) there are <em>many layers</em> of software involved (cumulating many millions of lines of code).</p>

<p>If you want to understand more, read about <a href=""https://en.wikipedia.org/wiki/Display_server"" rel=""nofollow noreferrer"">display servers</a>, <a href=""https://en.wikipedia.org/wiki/Terminal_emulator"" rel=""nofollow noreferrer"">terminal emulators</a>, <a href=""https://en.wikipedia.org/wiki/Process_(computing)"" rel=""nofollow noreferrer"">processes</a> and about <a href=""https://en.wikipedia.org/wiki/Operating_system"" rel=""nofollow noreferrer"">operating systems</a>.</p>

<p>You C++ implementation gives you (thru its C++ standard library and many other layers of software) the abstraction of console streams. How these are really implemented is a complex topic. Windows are unknown to the C++14 standard (but consider using a complex GUI framework library like <a href=""http://qt.io/"" rel=""nofollow noreferrer"">Qt</a> if you need some).</p>

<p>If you have access to some Linux system, try to <a href=""http://man7.org/linux/man-pages/man1/strace.1.html"" rel=""nofollow noreferrer"">strace(1)</a> a hello-world program in C++ and read the <a href=""http://www.linusakesson.net/programming/tty/"" rel=""nofollow noreferrer"">tty demystified</a> page; you'll be surprised by the amounts of system calls involved (and your <em>terminal emulator</em> is much more complex than hello-world, and so is the display server).</p>

<p><sup>PS. At Paris 6 university, an full-year course (of several hours per week) is required to explain only the <em>basics</em> of the answer to your question</sup></p>
",7
45221703,45221056,3,"<p>Magic.</p>

<p>No, I'm serious.  The C++ standard dictates that the compiler needs to provide a certian environment to the C++ program.  This environment is rather abstract -- it is called the abstract machine.</p>

<p>Specific compilers decide to attach that abstract machine to particular behaviors on the actual machine they run on.  How this happens is <em>outside</em> the C++ language.</p>

<p>In practice, what happens is that a given C++ executable is compiled to run in a given operating system (and usually on given kinds of compatible hardware).</p>

<p>The operating system knows how to <em>load</em> your executable into memory, and ""wires up"" the parts of the executable to its own services (or directly to hardware services) that provide features, like console output/input, memory allocation, threading, etc etc etc.</p>

<p>The compiler was written with the ability to write that executable in mind.  The operating system was written with the ability to load that executable in mind.</p>

<p>In some cases, the ""operating system"" is firmware on a chip or motherboard, and ""loading the executable"" consists of initializing a ROM with the bits that come out of the compiler.</p>

<p>In more common cases, the ""operating system"" is a modern desktop operating system.  It specifies an executable layout, and provides ways for such an executable to talk to the OS/kernel/screen/etc.</p>

<p>The compiler could have libraries (dynamic or not) that are written to help the program interact with the operating system of your computer, which it links to your program implicitly.</p>

<p>The operating system itself is going to be written, usually, in a mixture of machine code, assembly and higher level languages (like C, C++ or even Java).  It will often be running in a ""different mode"" than client code is running in, and have access to a very different environment.</p>

<p>In short, Magic.</p>

<p>C++ does not specify how this happens, it just demands the compiler do it.  These things are usually not fully implemented in C++.</p>
",1
45667299,45667218,2,"<p>The crash is coming from trying to dereference <code>it</code> in the line <code>while(*it){</code>. If a vector <code>v</code> is empty, then the iterator <code>v.begin()</code> won't point to valid memory, and dereferencing it will cause a Segmentation Fault.</p>
",8
45667344,45667218,0,"<pre><code>list&lt;vector&lt;int&gt;::iterator&gt; l;
l.push_back(it1);
</code></pre>

<p>If suppose <code>v1</code> is empty, then <code>it1</code> would be <code>v1::end()</code> which is one past the last element of vector and is not part of the vector.So later when you do</p>

<pre><code>while(*it){
</code></pre>

<p>you are trying to dereference <code>v::end()</code> which is the reason for the crash.To avoid this you should insert into <code>l</code> only if the iterators are not pointing to <code>end</code>.</p>

<pre><code>if(it1!= v1.end())
   l.push_back(it1);
</code></pre>
",0
45667520,45667218,0,"<p>It will fail as you cannot dereference an iterator until you know its valid to dereference. If the vector is empty <code>begin == end</code> and end is not a valid thing to dereference, as it's one off the end of the container.  </p>

<p>You wont be able to iterate your container without knowing the <code>end</code> and you don't capture it, you only capture <code>begin</code>. Simply dereferencing the iterator to test for validity is not correct. It could hold any value.</p>

<p>What about an alternative where you capture a pair of iterators for each vector?</p>

<pre><code>#include &lt;vector&gt;
#include &lt;list&gt;

#include &lt;iostream&gt;
#include &lt;utility&gt;
using namespace std;

int main() 
{
    const vector&lt;int&gt; v1 ={1,2,3};
    const vector&lt;int&gt; v2 ={4,5,6,7};

    list&lt;pair&lt;vector&lt;int&gt;::const_iterator, 
              vector&lt;int&gt;::const_iterator&gt;&gt; L;

    L.push_back(make_pair(begin(v1), end(v1)));
    L.push_back(make_pair(begin(v2), end(v2)));

    for(const auto&amp; a : L){

        for(auto it = a.first; it != a.second; ++it)
        {
            cout &lt;&lt; *it &lt;&lt; '\n';
        }
    }
}
</code></pre>

<p>Now you have the capability to stop as you know the end iterator too.</p>
",0
41909738,41909680,3,"<p>You need to make the class hierarchy polymorphic. A good way of doing this is by adding a <code>virtual ~Attribute() { }</code> destructor:</p>

<pre><code>struct Attribute 
{
    virtual ~Attribute() { }
};
</code></pre>

<p>Your code then <a href=""http://melpon.org/wandbox/permlink/FLTo8aQ4RRk5Y6pp"" rel=""nofollow noreferrer""><strong>works as expected</strong></a>:</p>

<pre><code>{
    auto baseList = std::vector&lt;Attribute*&gt;({ place0, time0 });

    updateBaseList(baseList, {place2, time2, way0});
    assert(baseList[0] == place2);
    assert(baseList[1] == time2);
    assert(baseList[2] == way0);
    assert(baseList.size() == 3);

    updateBaseList(baseList, {place0});
    assert(baseList[0] == place0);
    assert(baseList[1] == time2);
    assert(baseList[2] == way0);
    assert(baseList.size() == 3);
}
</code></pre>

<hr>

<p>Unrelated, but you can make your implementation of <code>baseList</code> easier to read using C++11 range-for loops:</p>

<pre><code>void updateBaseList(std::vector&lt;Attribute*&gt;&amp; v, std::initializer_list&lt;Attribute*&gt; l) 
{
    for (auto&amp; litem : l) 
    {
        bool found = false;
        for (auto&amp; attr : baseList) 
        {
            if (typeid(*litem) != typeid(*attr)) continue;

            attr = litem;
            found = true;
            break;
        }

        if (!found) 
        {
            v.push_back(litem);
        }
    }
}
</code></pre>

<p>You can also take advantage of standard algorithms to avoid the stateful <code>found</code> variable:</p>

<pre><code>void updateBaseList(std::vector&lt;Attribute*&gt;&amp; v, std::initializer_list&lt;Attribute*&gt; l) 
{
    for (auto&amp; litem : l) 
    {
        const auto found = std::find_if(std::begin(v), std::end(v), [&amp;](Attribute* p)
                                       {
                                           return typeid(*litem) == typeid(*p);
                                       });

        if (found == std::end(v)) 
        {
            v.push_back(litem);
        }
        else 
        {
            *found = litem;
        }
    }
}
</code></pre>
",0
44737543,44737528,0,"<p>Integers are ussually at least 32bit on most architectures you are likely to use.
So can hold  around +/-2 billion</p>
",0
44737561,44737528,2,"<p>According to <a href=""https://stackoverflow.com/a/1819236/6525260"">this answer</a>, the <em>minimum</em> (emphasis mine) ranges of an integer is -32,767 to 32,767. The actual limits are implementation defined, and are most likely from -2 billion to positive 2 billion.</p>

<p>To check the integer limits on your device, you could use the header <a href=""http://en.cppreference.com/w/cpp/types/numeric_limits"" rel=""nofollow noreferrer""><code>&lt;limits&gt;</code></a> as follows:</p>

<pre><code>int imin = std::numeric_limits&lt;int&gt;::min(); // minimum value
int imax = std::numeric_limits&lt;int&gt;::max(); //or INT_MAX
</code></pre>
",0
44737563,44737528,0,"<p>Integer size is usually 4 bytes on most operating systems (platforms). Therefore, at the lowest, which is 32-bit architectures, it can hold values from (-2147483648) to (+2147483648).
If you're working with a 64-bit architecutre, which is the common one today, you can hold values from (-2^64 / 2) to (+2^64 / 2).</p>

<p>Take a look at this link that shows the size of integer on different platforms: <a href=""http://ivbel.blogspot.co.il/2012/02/size-of-primitive-types-in-c-language.html"" rel=""nofollow noreferrer"">http://ivbel.blogspot.co.il/2012/02/size-of-primitive-types-in-c-language.html</a></p>
",1
44737567,44737528,1,"<blockquote>
  <p>Normally C++ integers are ¡À32676</p>
</blockquote>

<p>This is false on most systems (except embedded things like <a href=""http://arduino.cc"" rel=""nofollow noreferrer"">Arduino</a>). On most current C++ systems, <code>int</code> uses 32 bits. IIRC the standard mandates <em>at least</em> 16 bits.</p>

<p>You should use the <a href=""http://en.cppreference.com/w/cpp/header/limits"" rel=""nofollow noreferrer""><code>&lt;limits&gt;</code></a> standard <a href=""https://en.wikipedia.org/wiki/C%2B%2B11"" rel=""nofollow noreferrer"">C++11</a> (or better) header.</p>

<p>BTW your program is a typical example of <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><strong>undefined behaviour</strong></a> so you need to be <a href=""https://stackoverflow.com/a/25636788/841108""><em>very scared</em></a> (and you should not <em>expect</em> any particular concrete behavior).</p>
",0
36712674,36712169,2,"<p>Avoid using macros if you have trouble understanding what the compiler complains about. This is what your code looks like when the macro is expanded, when you put the extra {}</p>

<pre><code>result={a+2*b}
</code></pre>

<p>And this is what it looks like with the declaration on the same line</p>

<pre><code>int result={a+2*b}
</code></pre>

<p>Before the C++11 standard, the former is a syntax error. Since C++11, it is <a href=""http://en.cppreference.com/w/cpp/language/list_initialization"" rel=""nofollow"">copy-list-initialization</a> of a temporary (see the syntax labeled (10) ).</p>

<p>The latter is <a href=""http://en.cppreference.com/w/cpp/language/aggregate_initialization"" rel=""nofollow"">aggregate initialization</a>.</p>
",2
36755578,36755387,0,"<p>Your loop indexing is not correct. As @tadman pointed out, you will walk off the string. </p>

<p>The first loop would have to terminate 2 indices shorter than the size, so that when you add 2, it would be 1 less than content.size(). Remember C/C++ is 0 indexed, therefore if size is 10, element 9 is the last index of the string.</p>

<pre><code>for (i = 0; i &lt; content.size()-2; i+=2) {
            doSwap(content[i], content[i+2]);
    }
</code></pre>

<p>Similarly the second loop should start 1 short of the size and terminate at 2, so when you index into <code>i-2</code>, you are indexing no less than 0.</p>

<pre><code> for (i = after.size()-1; i &gt;= 2; i -=2) {
        doSwap(after[i], after[i-2]);
    }
</code></pre>
",0
37244706,37244670,4,"<p>You're not null-terminating the character array in the second constructor. Add this line at the end of the method:</p>

<pre><code>linePtr[1] = '\0';
</code></pre>
",6
40577074,40565724,0,"<p>You can read the input file word by word while keeping track of what shape is being currently processed. Let's say your input file contains the following shapes with a different number of corresponding dimensions:</p>

<pre><code>$cat testShapes.txt
Rectangle 2.44 3.6
Sphere 1.82
Square 1.11
Parallelepiped 3.33 4.44 5.55
</code></pre>

<p>Once you read the shape you know how many dimensions to read next.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    string word;
    double d1, d2, d3;

    while (cin &gt;&gt; word)
    {
        cout &lt;&lt; ""shape: \""""  &lt;&lt; word &lt;&lt; ""\"""" &lt;&lt; endl;

        if (word == ""Rectangle"") {
           cin &gt;&gt; d1 &gt;&gt; d2;
           cout &lt;&lt; ""\tdimensions: ""  &lt;&lt; d1 &lt;&lt; "", "" &lt;&lt; d2 &lt;&lt; endl;
        }
        else if (word == ""Sphere"") {
           cin &gt;&gt; d1;
           cout &lt;&lt; ""\tdimension: ""  &lt;&lt; d1 &lt;&lt; endl;
        }
        else if (word == ""Square"") {
           cin &gt;&gt; d1;
           cout &lt;&lt; ""\tdimension: ""  &lt;&lt; d1 &lt;&lt; endl;
        }
        else if (word == ""Parallelepiped"") {
           cin &gt;&gt; d1 &gt;&gt; d2 &gt;&gt; d3;
           cout &lt;&lt; ""\tdimensions: ""  &lt;&lt; d1 &lt;&lt; "", "" &lt;&lt; d2 &lt;&lt; "", "" &lt;&lt; d3 &lt;&lt; endl;
        }
        else {
           cout &lt;&lt; ""Unknow shape"" &lt;&lt; endl;
        }
    }

    return 0;
}
</code></pre>

<p>Instead of reading from a file in this example the data is read from standard input <code>cin</code>. For example, on linux after compiling it you would run it as:</p>

<pre><code>$a.out &lt; testShapes.txt
</code></pre>

<p>It should be trivial to modify this example to calculate whatever you need from the values read for each shape.</p>
",0
37772863,37772809,3,"<p>You could provide a dummy type and a constructor that takes that type and does the equivalent of default constructing an instance. For example,</p>

<pre><code>struct None_t {};

constexpr None_t None{}; // const None_t None = {}; in C++03

template&lt;class T&gt;
class A {
public:
    A() : _val() {};
    A(None_t) : A() {} // A(None_t) : _val() {} in C++03
    A(T val) : _val(val) {}
private:
    T _val;
};

int main()
{
   A&lt;int&gt; x = None;
}
</code></pre>

<p>Note I changed <code>_val</code> to from <code>int</code> to <code>T</code>, since otherwise the template doesn't make much sense.</p>
",0
37772870,37772809,2,"<p>The usual way would be to create a tag class, in this case <code>none_type</code> and have a constexpr (or static const) model of it available.</p>

<pre><code>struct none_type {};
constexpr auto none = none_type {};

template&lt;class T&gt;
class A {
public:

    A():_val(0) {};

    A(none_type) : A() {};

    A(int val):_val(val) {};
private:
    int _val;
};

int main()
{
    A&lt;int&gt; a = none;
}
</code></pre>
",2
37449898,37449872,0,"<p><code>getline</code> is what you're looking for:
<a href=""http://www.cplusplus.com/reference/string/string/getline/"" rel=""nofollow"">http://www.cplusplus.com/reference/string/string/getline/</a></p>

<p>For more complex pattern matching, regex might be useful:
<a href=""http://www.cplusplus.com/reference/regex/"" rel=""nofollow"">http://www.cplusplus.com/reference/regex/</a></p>

<p>A similar question was posted here with lots of replies:
<a href=""http://www.cplusplus.com/forum/general/94419/"" rel=""nofollow"">http://www.cplusplus.com/forum/general/94419/</a></p>
",0
37450152,37449872,0,"<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

int main()
{
    string word; // You have to give word an actual string for this to work xd
    ofstream writer(""file.txt"");//Creating the text document // Creating the variable that writes to it
    ifstream fin(""file.txt"");//The variable that reads it`

    if(!writer){//Checking to make sure it nothing bad occurred when opening file
        cout &lt;&lt; ""An error occurred opening "" &lt;&lt; writer;
        return 1; //Return an error occurred
    }else{
        cout &lt;&lt; word; // Print the string word whatever it is on file.txt
    }

    char letter;//To get every letter that get iterated over
    vector &lt;string&gt; textInFile(999999);//Saves letter into an array

    if(!fin){
        cout&lt;&lt;""Problem opening""&lt;&lt;fin; // Check if file opened safely
    }else{
        for(int x = 0; ! fin.eof(); x++){//eof = End of file // It basically iterates over the entire .txt;
            fin.get(letter); // Gets every letter
            textInFile[x] = letter; // vector stores the letters
        }

        for(int x = 0; x &lt; textInFile.size(); x++){ // For size of &lt;vector&gt; textInFile iterate over all indexes
            cout &lt;&lt; textInFile[x]; // Prints every letter in the vector
        }
    }
    cout&lt;&lt;endl;
    fin.close();

    return 0;
}
</code></pre>

<p>Sorry about the messy post, this is like my first post and I have no clue how this boxing things works xd</p>
",0
37450612,37449872,0,"<p>Use <code>getline</code></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;algorithm&gt;
#include &lt;cctype&gt;

using namespace std;

int main()
{
   string sentence;
   set &lt;string&gt; sentences;

  ifstream file(""thisfile.txt"");

  if(file.is_open())
  {
    while(getline(file, sentence, "".""))
    {
      sentence.erase(remove_if(sentence.begin(), sentence.end(), IsChars(""\n"")), sentence.end());
      sentences.insert(sentence);
    }
  }

  file.close(); //close file

  return 0;
} 
</code></pre>
",0
37450838,37449872,1,"<p>If you just want to split on '.' then Jason Caldwell answer is what you were looking for:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;

static std::string trim(const std::string&amp; str)
{
    size_t first = str.find_first_not_of("" \n\t\r\v"");
    size_t last = str.find_last_not_of("" \n\t\r\v"");
    return str.substr(first, (last-first+1));
}

int main()
{
    std::vector&lt;std::string&gt;    sentences;

    std::ifstream ifs(""sentences.txt"");
    if (ifs.is_open() == false)
    { std::cerr &lt;&lt; ""Couldn't open file..."" &lt;&lt; std::endl; return -1; }

    std::string line;
    while(getline(ifs,line, '.'))
    { sentences.emplace_back(trim(line) + "".""); }

    for (auto sentence : sentences)
    { std::cout &lt;&lt; ""sentence: "" &lt;&lt; sentence &lt;&lt; std::endl; }
    ifs.close();
}
</code></pre>

<p>Note that this code uses c++11 features (auto , emplace_back...)</p>

<p>But if you assume that a sentence is something a bit more complex, I would suggest the same as Jason once again, use regexes. But be sure that your compiler implement them correctly (ex: g++-4.9)</p>

<p>This <a href=""https://stackoverflow.com/a/16752826/6374665"">answer</a> show you how to do it. You will probably have to split your string with std::getline for simplicity.</p>

<p>Edit: added check on file and note about c++11 features.</p>
",0
37452479,37449872,1,"<blockquote>
  <p>The problem is, when I try to read in a sentence from the file, it only reads in a word and not the sentence.</p>
</blockquote>

<p>The <code>&gt;&gt;</code> extraction operator skips whitespace by default, hence, it only extracts one word.</p>

<p>To read a line at a time, you can use <code>std::getline</code>. The following code will read the first line in the text file. You can put <code>getline</code> inside a while loop to read line by line.</p>

<pre><code>int main()
{
    string line;
    ifstream fin(""file.txt"");

    // Read in the sentence from the file
    getline(fin, line);
    cout &lt;&lt; line &lt;&lt; '\n';

    return 0;
}
</code></pre>
",0
39603143,39603081,1,"<p>The problem is you dereference the pointer and assign it to a pointer.  To fix, simply change from </p>

<pre><code>*cp = _cp;
</code></pre>

<p>to</p>

<pre><code>cp = _cp;
</code></pre>
",2
39603243,39603081,0,"<p>Either the ControlPanel must supply you with a assignment operator (a built-in assignment operator may do bitwise-copy and thus give you segfuault) OR you should start using just the pointers to ControlPanel (instead of copying the ControlPanel objects).</p>

<p>Both approaches have their advantages and disadvantages. If I have access to the source code of Control Panel, I would write a valid assignment operator (if it is required! Writing the special class functions in C++ must be done carefully in order to avoid surprises and painful troubleshotting later).</p>
",0
43207266,43207226,1,"<p>I'm not sure the ternary conditional is of much help here. But you can save some typing (and perhaps even gain a bit of performance; profile it) by writing</p>

<p><code>(2 * isMax - 1) * (lower - higher) &lt;= distance</code></p>

<p>This assums that <code>isMax</code> is a <code>bool</code> type, or is either 1 or 0. A perfect equivalent is the obtuse</p>

<p><code>(2 * !!isMax - 1) * (lower - higher) &lt;= distance</code></p>

<p>On the grounds it took me 3 edits to get this correct, it might be encroaching on the borderline of readability.</p>

<p>Perhaps therefore leave it as it is, or bury the complexity in a function.</p>
",2
43207730,43207226,1,"<p>Apparently <a href=""http://coliru.stacked-crooked.com/a/058485f9b831ed82"" rel=""nofollow noreferrer"">this is possible</a><sup>1</sup>:</p>

<pre><code>(x ? [](int a, int b){ return a &gt;= b; } : [](int a, int b){ return a &lt;= b; })(a, b)
</code></pre>

<p>Should you do that, though? I'd personally just go with a <code>(bool, int, int)</code> function.</p>

<p><sup>1</sup> I was a bit surprised at first, but I guess it's triggering the lambda decay somehow. If they were closures (had something within <code>[]</code>) they would be different types and as such the type of the <code>?:</code> would depend on runtime state. </p>
",0
43207542,43207226,2,"<p>Short answer: No.</p>

<p>But something close would be to write your own inline function with this effect:</p>

<pre><code>template&lt;class T&gt;
inline bool compare(bool isLessThan, const T&amp; left, const T&amp; right)
{
    if (isLessThan) {
        return left &lt;= right;
    }
    else {
        return left &gt;= right;
    }
}

// ... later ...
if (compare(isMax, lower - higher, distance)) {
    // ...
}
</code></pre>

<p>My opinion (which you didn't ask for): just use an intermediate variable (or several if necessary)!</p>
",7
43208104,43207226,2,"<p>You can do this if you encapsulate the operators into functions with the same type:</p>

<pre><code>namespace detail{
template&lt;class T&gt;
bool less_equal(T lhs, T rhs)
{
    std::cout &lt;&lt; ""Using &lt;=\n"";
    return lhs &lt;= rhs;
}

template&lt;class T&gt;
bool greater_equal(T lhs, T rhs)
{
    std::cout &lt;&lt; ""Using &gt;=\n"";
    return lhs &gt;= rhs;
}
}
</code></pre>

<p>And then we can write your logic as:</p>

<pre><code>void DoTheThing(bool isMax, int lower, int higher, int distance)
{
    auto func = isMax ? &amp;detail::less_equal&lt;int&gt; : &amp;detail::greater_equal&lt;int&gt;;
    if (func(lower-higher, distance))
    {
        // your logic here
    }
}
</code></pre>

<p>And a test:</p>

<pre><code>int main()
{
    DoTheThing(true, 1, 1, 1); // &lt;=
    DoTheThing(false, 1, 1, 1); // &gt;=
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>Using &lt;=
Using &gt;=
</code></pre>

<h2><a href=""http://coliru.stacked-crooked.com/a/06ad848795189d3c"" rel=""nofollow noreferrer"">Demo</a></h2>
",0
39317668,39317615,2,"<p><em>Don't</em> use <code>srand</code> and <code>rand</code>. <code>rand</code> has a very low period, is usually based on a linear congruential generator (very bad random properties) and <em>don't</em> use modulo (<code>%</code>) to get a range of numbers - you are introducing bias. Use the facillities in <a href=""http://en.cppreference.com/w/cpp/header/random"" rel=""nofollow"">the random header</a> instead.
In this case you probably want <code>std::random_device</code> (for the seed), <code>std::mt19937</code> (for the generator) and <code>std::uniform_int_distribution</code> (for the distribution).</p>

<p>Btw, you are <em>always</em> seeding with a value of <code>0</code> (zero).</p>
",8
41661364,41661102,1,"<p>You can use <strong>#warning</strong> directive, most of the widespread compilers (GCC, VC, Intels and Mac), support #warning message.</p>

<pre><code>#warning ""this is deprecated, use the Init() method instead""
</code></pre>

<p>A good practive is to not only show a warning (which people can ignore), but make the compiling fail, using the #error directive (which is quite standard):</p>

<pre><code>#  error ""this method is forbidden and private""
</code></pre>

<p>As a Visual Studio specific <a href=""https://stackoverflow.com/a/2143358/2183287"">solution</a>, you can use <em>pragma</em>.</p>
",0
41661365,41661102,2,"<h2>Part 1 of your question:</h2>

<p>No, there is no good way of giving a custom message on using a private method. What I would do is to make sure that you only have a public API which forwards to the private implementation. This can be done via some pimple pattern or by creating a facade.</p>

<p>As you did not specify the way someone would get the Widget, I'm currently assuming a Singleton.</p>

<pre><code>class Widget {
public:
    Widget() : _impl(getHoldOfPrivateWidgetViaSingleton())
    {
         _impl.init();
    }
    // ...
private:
    PrivateWidget &amp;_impl;
};

// Note: rename of the Widget in your example
class PrivateWidget {
private:
    friend class Widget;
    PrivateWidget();
    // ...
};
</code></pre>

<p>The disadvantage of doing this is that you will have to write some/a lot of forwarding code. </p>

<h2>Part 2 of your question:</h2>

<pre><code>class Widget {
public:
  void Init();
  [[deprecated(""use paintWidget instead"")]] void Paint();
  void PaintWidget(); // A new implementation of paint
  ...
private:
  Widget();
  ...
}
</code></pre>

<p>Note that if you don't have access to a modern compiler with C++17 enabled, you might want to check out your compiler specific attributes.</p>
",4
38306228,38304334,0,"<p>in case someone is encoutering the same error, the below fixed it for me:</p>

<p>const char tmp1 = (const char *) tmp;
tmp1 = (const char) strstr(tmp, delim); </p>
",0
34917397,34917349,3,"<p>Use <code>\""</code>. Also known as <a href=""http://en.cppreference.com/w/cpp/language/escape"" rel=""nofollow"">escape sequences</a>.</p>
",0
34917464,34917349,4,"<p>Another solution is to use raw strings:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; R""_(A raw string with "" inside (and \ as well))_"" &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/cad51755a66ec1b9"" rel=""nofollow""><kbd>Live example</kbd></a></p>

<p>Output: </p>

<blockquote>
  <p>A raw string with "" inside (and \ as well)</p>
</blockquote>

<hr>

<h3>Quotes from the Standard:</h3>

<p>According to the Standard 2.14.5 [lex.string]:</p>

<pre>
<strong>string-literal</strong>:
    <strong>encoding-prefix<sub>opt</sub></strong> ""<strong>s-char-sequence<sub>opt</sub></strong>""
    <strong>encoding-prefix<sub>opt</sub></strong> R <strong>raw-string</strong>

<strong>encoding-prefix</strong>:
    u8
    u
    U
    L

<strong>s-char-sequence</strong>:
    <strong>s-char</strong>
    <strong>s-char-sequence</strong> <strong>s-char</strong>

<strong>s-char</strong>:
    any member of the source character set except
        the double-quote <strong>""</strong>, backslash <strong>\</strong>, or new-line character
    <strong>escape-sequence</strong>
    <strong>universal-character-name</strong>

<strong>raw-string</strong>:
    "" <strong>d-char-sequence<sub>opt</sub></strong> ( <strong>r-char-sequence<sub>opt</sub></strong>) <strong>d-char-sequence<sub>opt</sub></strong> ""

<strong>r-char-sequence</strong>:
    <strong>r-char</strong>
    <strong>r-char-sequence</strong> <strong>r-char</strong>

<strong>r-char</strong>:
    any member of the source character set, except
        a right parenthesis <strong>)</strong> followed by the initial <strong>d-char-sequence</strong>
        (which may be empty) followed by a double quote <strong>""</strong>.

<strong>d-char-sequence</strong>:
    <strong>d-char</strong>
    <strong>d-char-sequence</strong> <strong>d-char</strong>

<strong>d-char</strong>:
    any member of the basic source character set except:
        space, the left parenthesis <strong>(</strong>, the right parenthesis <strong>)</strong>, the backslash <strong>\</strong>,
        and the control characters representing horizontal tab,
        vertical tab, form feed, and newline.
</pre>

<blockquote>
  <ol>
  <li><p>A string literal is a sequence of characters (as defined in 2.14.3) surrounded by double quotes, optionally prefixed by <code>R</code>, <code>u8</code>, <code>u8R</code>,
  <code>u</code>, <code>uR</code>, <code>U</code>, <code>UR</code>, <code>L</code>, or <code>LR</code>, as in <code>""...""</code>, <code>R""(...)""</code>,
  <code>u8""...""</code>, <code>u8R""**(...)**""</code>, <code>u""...""</code>, <code>uR""*?(...)*?""</code>, <code>U""...""</code>,
  <code>UR""zzz(...)zzz""</code>, <code>L""...""</code>, or <code>LR""(...)""</code>, respectively.</p></li>
  <li><p>A string literal that has an <code>R</code> in the prefix is a <em>raw string literal</em>. The <code>d-char-sequence</code> serves as a delimiter. The terminating
  <code>d-char-sequence</code> of a raw-string is the same sequence of characters
  as the initial <code>d-char-sequence</code>. A <code>d-char-sequence</code> shall consist of
  at most 16 characters.</p></li>
  <li>[Note: The characters <code>(</code> and <code>)</code> are permitted in a raw-string. Thus, <code>R""delimiter((a|b))delimiter""</code> is equivalent to <code>""(a|b)""</code>. ¡ªend
  note ]</li>
  <li><p>[Note: A source-file new-line in a raw string literal results in a new-line in the resulting execution <code>string-literal</code>. Assuming no
  whitespace at the beginning of lines in the following example, the
  assert will succeed:</p>

<pre><code>const char *p = R""(a\
b
c)"";
assert(std::strcmp(p, ""a\\\nb\nc"") == 0);
</code></pre>
  
  <p>¡ª end note ]</p></li>
  <li><p>[Example: The raw string</p>

<pre><code>R""a(
)\
a""
)a""
</code></pre>
  
  <p>is equivalent to <code>""\n)\\\na\""\n""</code>. The raw string</p>

<pre><code>R""(??)""
</code></pre>
  
  <p>is equivalent to <code>""\?\?""</code>. The raw string</p>

<pre><code>R""#(
)??=""
)#""
</code></pre>
  
  <p>is equivalent to <code>""\n)\?\?=\""\n""</code>. ¡ªend example ]</p></li>
  </ol>
</blockquote>
",3
42581330,42580307,1,"<p>Prototype of <code>string hex_decode(string hex_input)</code> says a new string object is always returned by <code>hex_decode</code>.</p>

<p>Paragraph <code>12.2#3</code> of the standard says:</p>

<blockquote>
  <p>Temporary objects are destroyed as the last step in evaluating the full-expression that (lexically) contains the point where they were created.</p>
</blockquote>

<p>Additionally <code>c_str()</code> returns a pointer to something <em>inside</em> of the string object.</p>

<p>When reading documentation for <code>c_str()</code> and <code>data()</code> (which now perform the same function) you can deduce that from this line (see <a href=""http://en.cppreference.com/w/cpp/string/basic_string/c_str"" rel=""nofollow noreferrer"">here</a> or <code>21.4.7.1#1</code>):</p>

<blockquote>
  <p><code>c_str() + i == &amp;operator[](i)</code> for every <code>i in [0, size()]</code>.</p>
</blockquote>

<p>Therefore:</p>

<p>Once <code>c_str()</code> ended there's <code>;</code> and the temporary string returned by <code>hex_decode()</code> must be destroyed. During destruction it frees underlying character array.</p>

<p>However to preserve character array there's no need to copy the temporary string. <code>12.2#4,5</code>:</p>

<blockquote>
  <p>There are two contexts in which temporaries are destroyed at a different point than the end of the full-expression. ... The second context is when a reference is bound to a temporary.</p>
</blockquote>

<p>So you can just bind a const reference to the temporary object and save on the copy constructor call:</p>

<pre><code>const string &amp; hex_decoded_string = hex_decode(input);
const char* hex_decoded_c_str = hex_decoded_string.c_str();
</code></pre>
",0
42580384,42580307,-1,"<p>Pointer returned by <code>c_str()</code> method becomes invalid after <code>std::string</code> instance is destroyed.</p>
",0
42580392,42580307,0,"<p>with</p>

<pre><code>const char* hex_decoded_c_str = hex_decode(input).c_str();
</code></pre>

<p>you're taking a reference to the internal representation of a <code>string</code> temporary object (the return value), which is invalid when <code>hex_decode(input)</code> goes out of scope, immediately after the <code>c_str()</code> call.</p>

<p>With the other approach, you copy the <code>string</code> object, making that reference valid in your scope.</p>
",5
42580449,42580307,1,"<p><code>string hex_decode(string hex_input)</code> returns a temporary <code>string</code> object. <code>c_str()</code> returns a pointer into the private parts of that string object. Once the temporary dies (at the end of the full expression), that pointer points into inaccessible memory. That's called <em>undefined behavior</em>.</p>

<p>To solve this, copy the return value into a local <code>string</code> object, or extend the lifetime of the temporary, by binding it to a <code>const string&amp;</code> reference. The validity of the return value of <code>c_str()</code> is tied to the lifetime of the object it was called on. Abidance cannot be enforced by the compiler, library or runtime. This is something a developer needs to make sure.</p>

<p>For reference, see <a href=""http://en.cppreference.com/w/cpp/language/lifetime"" rel=""nofollow noreferrer"">Lifetime</a>.</p>
",0
46651255,46650773,1,"<p>Sure, just embed its binary data as an array of whatever fundamental type you want, perhaps in a header -- unsigned char, int, whatever -- write it to disk on execution of your parent application, then call it as a child process. </p>

<p>I'm not sure why you would want to do this, it seems a bit silly and like there are other approaches you can take. It might also trigger some antivirus heuristics, as this is a common way viruses propagate. </p>

<p>If you <em>do</em> do this, you'll also probably want to store it as a compressed byte/int array to save space, and then decompress it on the fly. Or at least Base-85 to keep your header file smaller.</p>
",0
38291132,38291113,9,"<p>Usually your compiler provides an option where you can add pathes where it looks up header files from <code>#include</code> statements.</p>

<p>E.g. for GCC add </p>

<pre><code>-I/Users/cooper/Desktop/MyLib
</code></pre>

<p>to your compiler command line.</p>

<hr>

<p>This option might also be available to be set in your IDE's project settings, or as a variable in your build system.</p>
",0
34966395,34965618,0,"<p>This works.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

using namespace std;

void pde_advect_IC(double* x, double* u, const int&amp; N)
{
  for (int i = 0; i &lt; N; i++)
    u[i] = x[i];
}

int main()
{
  double a = 0.0;
  double b = 1.0;
  int   nx = 4;
  double dx = (b - a) / double(nx);
  double xx[nx + 1]; //array xx with intervals

  // allocate memory for vectors of solutions u0
  double* u0 = new double [nx + 1];

  //fill in array x
  for (int i = 0; i &lt;= nx; i++)
    xx[i] = a + double(i) * dx;

  pde_advect_IC(xx, u0, nx + 1); // u0 = x (initial conditions)
  for (int i = 0; i &lt;= nx; i++)
    cout &lt;&lt; u0[i] &lt;&lt; endl;

  // de-allocate memory of u0
  delete [] u0;

  return 0;
}
</code></pre>

<p>Note that I added <code>const int&amp; N</code> to <code>pde_advect_IC()</code> in order to pass it the size of the array, by <code>const reference</code>, to be sure it does not get modified by mistake.
Note that your trick with <code>sizeof()</code> does <strong>not</strong> work with pointers.</p>
",2
34965650,34965618,3,"<p>You can't use <code>sizeof(x)</code> because that will return the size of the pointer, not the array you thought you passed to it. You have to specify the size with a third parameter or use something more convenient like an <code>std::vector</code> and use <code>size()</code>.</p>
",0
36371386,36371257,1,"<p>Please note, that <code>char*</code> is a pointer to a <code>char</code>, not a string object. A literal <code>""yes""</code> is actually a <code>const char*</code>, because the literals will be constant data in the programms data section. For compatibility with C C++ still allows to initialize a <code>char</code>* with a <code>const char*</code>.</p>

<p>Also note, that the unary <code>*</code> operator on a pointer dereferences the pointer.</p>

<p>Now that you do here is assigning the first character of <code>str2</code> (<code>'n'</code>) to the first character of <code>str1</code>. Since the first character of <code>str1</code> is a constant in the programs data section, that will of course fail.</p>

<p>If you really want to assign the first <code>char</code>, first produce a <code>char</code> array on the heap:</p>

<pre><code>char* str1 = (char*)malloc(4); // here str1 is non const
strncpy(str1, ""yes"", 4);

const char* str2 = ""no"";

*str1 = *str2; // now str1 contains ""nes"".
</code></pre>

<p>I assume you are trying to work with strings. Please prefer <code>std::string</code>:</p>

<pre><code>std::string str1 = std::string(""yes"");
std::string str2 = std::string(""no"");

str1 = str2 // now str1 is ""no"" as well.
</code></pre>

<p>With C++14 string literals you can make it even more elegant:</p>

<pre><code>auto str1 = ""yes""s;
auto str2 = ""no""s;

str1 = str2 // now str1 is ""no"" as well.
</code></pre>

<p>Whenever reasonable, use the standard library instead of C legacy constructs. You probably won't get it better.</p>
",2
36371399,36371257,0,"<p>As per the comments, the OP simply wants to make <code>str1</code> to <code>""no""</code></p>

<p>Instead of </p>

<pre><code>*str1 = *str2;
</code></pre>

<p>You should do</p>

<pre><code>str1 = str2;
</code></pre>

<p><code>str1</code> is a pointer that points to the first character of the given string.
<code>*str</code> dereferences the pointer giving you the first character of the string <code>str1</code>. So what your code was doing was trying to make the first character of <code>str1</code> to the first character of <code>str2</code></p>

<p>In my code, I am making <code>str1</code> point to the same location ass <code>str2</code> which in effect will give you two variables pointing to the same memory location.</p>

<p>If you want to copy the contents of str2 to str1 then use the <code>strcpy</code> function.</p>
",0
36371670,36371257,4,"<p>This original code,</p>

<pre><code>char* str1 = ""yes"" ;
char* str2 = ""no"" ;
*str1 = *str2;    //----crash

*str1 = *str2; //here program crashes.
</code></pre>

<p>&hellip; is <strong>invalid</strong>, not permitted, as of C++11 and later. We're now at C++14 and in a short while will presumably be at C++17.</p>

<p>What does a C++11 compiler say about it? E.g., what does MinGW g++ 5.1.0 with option <code>-std=c++14</code>, say about it?</p>

<pre>
C:\my\forums\so\121&gt; <b><i>g++ foo.cpp</i></b>
foo.cpp: In function 'int main()':
foo.cpp:3:18: error: ISO C++ forbids converting a string constant to 'char*' [-Wpedantic]
     char* str1 = ""yes"" ;
                  ^
foo.cpp:4:18: error: ISO C++ forbids converting a string constant to 'char*' [-Wpedantic]
     char* str2 = ""no"" ;
                  ^

C:\my\forums\so\121&gt; _
</pre>

<p>However, Visual C++ 2015 update 2 erroneously accepts the code.</p>

<p>The reason why the implicit conversion to <code>char*</code> was dropped from the language was precisely that it's unsafe. It allows the code to attempt modification of the literals, as this code does. But the literals can be stored in read-only memory, which then can cause a crash (as it did for the OP), or other undesirable behavior. It's just <strong>Undefined Behavior</strong>, where anything can happen, including that the code appears to &ldquo;work&rdquo;.</p>

<hr>

<p>How to fix it?</p>

<p>Use <strong><code>std::string</code></strong>.</p>

<p>Like this:</p>

<pre><code>#include &lt;string&gt;
using namespace std;

auto main() -&gt; int
{
    string str1 = ""yes"" ;
    string str2 = ""no"" ;
    str1 = str2;    // OK.
}
</code></pre>

<hr>

<p>If you absolutely want to use C level zero-terminated strings handled via pointers, perhaps in order to be compatible with some C code, then use <code>const</code> as appropriate for pointers, use local or dynamically allocated arrays for storage as appropriate, and use the C standard library's string functions, or roll your own, they're very simple functions:</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;string.h&gt;     // The "".h"" header is a C++ version of C's header.

auto main() -&gt; int
{
    char str1[] = ""yes"" ;
    char const* const str2 = ""no"" ;

    int const n2 = strlen( str2 );
    assert( sizeof( str1 ) &gt; n2 );
    strcpy( str1, str2 );
    assert( strcmp( str1, ""no"" ) == 0 );
}
</code></pre>
",0
41225719,41225676,-1,"<p>It doesn't, but the size of a pointer may be different than the size of a character. If you change your code from <code>sizeof(ch)</code> to <code>sizeof(*ch)</code>, then you'll get <code>1 1</code>.</p>
",0
41225771,41225676,0,"<p>Pointer to char is not a char, it is a pointer. Size of a pointer does not depend on the size of the object it points to. Because pointer is basically an address of the first byte of the object.</p>
",1
41226157,41225676,2,"<p>Pointers are not the data they're pointing to and <code>char *</code> is not the same type as <code>char</code>. </p>

<p>Most pointers have the same size and it's generally machine architecture dependent, in your case it happend to be 8 bytes, so you pretty much can expect something among the lines:</p>

<pre><code>int* pInt;
char* pChar;
std::cout &lt;&lt; (sizeof(pInt) == sizeof(pChar)); // prints 1 for true
</code></pre>

<p>On the other hand <code>sizeof(char)</code> is guaranteed to return <code>1</code>. But this still doesn't guarantee the ammount of actual memory used to store it, funny enough.</p>

<p>If you want to get the size of actual data pointed to by the pointer you, of course, can dereference it:</p>

<pre><code>std::cout &lt;&lt; sizeof(*ch); // prints 8
</code></pre>
",2
41225798,41225676,0,"<pre><code>sizeof *ch
</code></pre>

<p>The catch is that <code>ch</code> is a <code>pointer to char</code>, so <code>ch</code> is <strong>not</strong> a <code>char</code>. It just stores an address. For storing an address, it needs some space and in many systems, that happen to be <strong>8 bytes</strong></p>

<pre><code>sizeof(nch)
</code></pre>

<p>prints the size of <code>char</code> type in a system and it is <strong>1 byte</strong>.</p>
",3
34981330,34980804,0,"<p>The complexity of binary search is log2(N), it's about <code>23</code> for <code>N = 10000000</code>. 
I think its not enough to mesure in realtime scale and even <code>clock</code>.
In this case you should use <code>unsigned long long __rdtsc()</code>, that returns number of processor ticks from last reset. Put this before and after your binary search and place <code>cout &lt;&lt; start;</code> after obtaining end time. Overwise time of output would be included.</p>

<p>There is also memory corruption around <code>data</code> array. Index in C runs from <code>0</code> to <code>size - 1</code>, so thereis no <code>data[max]</code> element.</p>

<p>And <code>delete [] data;</code> before calling return.</p>
",0
34980881,34980804,0,"<p>Try to use the clock_t object from the time.h header:</p>

<pre><code>clock_t START, END;
        START = clock();
        **YOUR CODE GOES HERE**
        END = clock();
        float clocks = END - START;
        cout &lt;&lt;""running time : **"" &lt;&lt; clocks/CLOCKS_PER_SEC &lt;&lt; ""** seconds"" &lt;&lt; endl;
</code></pre>

<p>CLOCKS_PER_SEC is a defined var to convert from clock ticks to seconds.</p>
",2
34980883,34980804,0,"<p><a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms724408(v=vs.85).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/ms724408(v=vs.85).aspx</a>
This article says that result of <strong>GetTickCount</strong> will wrap to zero if you system runs for 49.7 days.</p>

<p>You can find here: <a href=""https://stackoverflow.com/questions/2808398/easily-measure-elapsed-time"">Easily measure elapsed time</a> how to measure time in C++.</p>
",0
34980890,34980804,0,"<p>You can use time.h header </p>

<p>and do something like this in your code : </p>

<pre><code>clock_t Start, Stop;
double sec;

Start = clock();
//call your BS function
Stop = clock();

Sec = ((double) (Stop - Start) / CLOCKS_PER_SEC);
</code></pre>

<p>and print the sec! </p>

<p>I hope this helps you! </p>
",1
34980975,34980804,1,"<p>Your code looks like this:</p>

<pre><code>int main()
{
    // Some code...

    while (some_condition)
    {
        // Some more code...
        // Print timing result
        return 0;
    }
}
</code></pre>

<p><em>That's</em> why your code prints zero time, you only do one iteration of the loop then you exit the program.</p>
",0
47537056,47536914,0,"<p>try using <code>getch()</code> between line or trace code 
this would help you to find when it exits.also use exception handling techinics </p>

<p>replace </p>

<pre><code>det=""**""
</code></pre>

<hr>

<p>with <code>det[]={""**""};</code></p>
",3
39663832,39663628,3,"<p>Note:</p>

<pre><code>   for(int i=0; i&lt;N; ++i) {
        for(int j=0; j&lt;N-1; ++i)  // &lt;&lt;&lt;&lt;&lt;&lt; some little mouse got here
</code></pre>

<p>EDIT:</p>

<p>Explanation:
You have created infinite loop, where <code>j&lt;N-1</code> is always <code>true</code>. This means, you push new elements into vector until no more memory is available, hence the run-time error.</p>
",3
39663983,39663628,0,"<p>This function may be a cause of an error:  </p>

<pre><code>int findIndex(x, lastAns, N) {
    return ((x == !lastAns) % N);
}
</code></pre>

<p>First off, the parameters are missing their types.  </p>

<p>Next, the expression  </p>

<pre><code>!lastAns
</code></pre>

<p>will evalute to zero or non-zero.
Which means that you are comparing an integer, <code>x</code>, to zero or nonzero:
<code>(x == 0) or (x == 1)</code><br>
The result of the above expressions is either zero or non-zero.  Let's assume 1 for nonzero.  You get the final expression</p>

<pre><code>`return 0 % N;` or `return 1 % N`;
</code></pre>

<p>The final return value is 0 or 1.  The <code>N</code> variable doesn't matter, because the only significant values are 0 or 1.  You can't have N as zero (which you don't check for), and when N is 1, you still get 0 or 1.</p>

<p>So your expression:</p>

<pre><code>v[findIndex(x, lastAns, N)]
</code></pre>

<p>will be <code>v[0]</code> or `v[1].</p>
",1
47564133,47563566,0,"<p>When you call <code>store_payments</code>, <code>read</code> is already open and at the end of the file (assuming those are the only things in the file, I will assume they are). Your next read is invalid, because you're at the end of the file and there's nothing else to read. You should endeavour to check the state of the read afterwards, and you would see this:</p>

<pre><code>read.ignore(7, '\n');
if (read.good())
{
    read &gt;&gt; payments[i][j];
}
</code></pre>

<p>You could also see this behaviour by checking <code>eof()</code>:</p>

<pre><code>void store_payments(double payment[10][3])
{
    read.open(""Data.txt"");
    if (read.eof())
    {
        read.clear(); // clear the eof flag
        read.seekg(0, ios::beg); // return to top of the file
    }
}
</code></pre>

<p>Or you could just close the file at the end of <code>store_names</code>.</p>

<p>When you call <code>read.ignore(7, '\n')</code>, 7 characters will be ignored. This will work fine for the first two names, which are 7 characters long, but if you encounter a name that isn't, you'll attempt to read something that isn't a <code>double</code>. Again, you would've seen this if you were checking the state of <code>read</code> after each read:</p>

<pre><code>read.ignore(7, '\n');
if (read.good())
{
}
</code></pre>

<p>Since your names can be variable length, you should read the entire line first, then sift through it. You can use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/getline"" rel=""nofollow noreferrer""><code>std::getline</code></a> to do this:</p>

<pre><code>std::string line;
std::getline(read, line);
</code></pre>

<p>Now <code>line</code> will contain something like</p>

<blockquote>
  <p>Johnson 60 12.50</p>
</blockquote>

<p>You can just use <a href=""http://en.cppreference.com/w/cpp/string/basic_string"" rel=""nofollow noreferrer""><code>std::string</code> functions</a> to remove the non-numeric parts, or look for whitespace. You could combine both functions together, and assume the name is everything to the first space, the <em>something</em> is everything to the next white space, and the <em>something else</em> is everything else.</p>

<p>The reason you are seeing memory addresses in your print, is because you're printing memory addresses.</p>

<pre><code>cout &lt;&lt; payment[j];
</code></pre>

<p><code>payment[j]</code> is essentially a pointer to the first element in <code>payment</code>. You likely meant to print <code>payment[i][j]</code> instead.</p>
",0
34961337,34960162,0,"<p>Your problem is that you never store a value in the global variable.  In the function that allocates the array, you declare a local variable with the same name. </p>
",0
34962317,34962304,0,"<p>Change</p>

<pre><code>void moveCharacter(const double dX, const double dY, const double dZ)
</code></pre>

<p>to</p>

<pre><code> void Character::moveCharacter(const double dX, const double dY, const double dZ)
</code></pre>

<p>So that is have the scope of the class member variables and not a stand alone function</p>
",3
34967299,34967249,0,"<p>You need to change</p>

<pre><code>string fit_int_2(int i0)
</code></pre>

<p>to</p>

<pre><code>string display_utils::fit_int_2(int i0)
</code></pre>

<p>(You need to define the member function - currently you're defining an unrelated global function.)</p>
",1
42648566,42648429,1,"<p>I'd do it this way:</p>

<pre><code>std::array&lt;midimhandle_t, 3&gt; dimensions;
std::vector&lt;midimhandle_t&gt; dimensions_new(3);
</code></pre>

<p>The first is a fixed-size, uninitialized array.  It stores its values directly inside, so if it's created on the stack the values will be too.</p>

<p>The second is an adjustable-size, default (value) initialized vector.  It stores its values on the heap.</p>
",0
42648731,42648429,0,"<p>Please replace this:</p>

<pre><code>midimhandle_t dimensions[3], *dimensions_new;
std::vector&lt;midimhandle_t&gt; dimensions_new(sizeof(midimhandle_t) * 3);
</code></pre>

<p>with simply:</p>

<pre><code>midimhandle_t dimensions[3];
std::vector&lt;midimhandle_t&gt; dimensions_new(3);
</code></pre>
",1
42648838,42648429,0,"<p>Yes, your means of creating the vector is wrong, and you need to take other things into account.</p>

<p>Assuming your original C code looks something like</p>

<pre><code>void some_function()
{
     midimhandle_t *dimensions_new;
     dimensions_new = (midimhandle_t *) malloc(sizeof(midimhandle_t) * 3);

      //  do something here

     free(dimensions_new);
 }
</code></pre>

<p>A rough equivalent using a <code>std::vector</code> would be</p>

<pre><code>void some_function()
{
     std::vector&lt;midimhandle_t&gt; dimensions_new(3);    //  create vector with 3 elements

      //  do something here

      // the vector will cease to exist as the function returns
 }
</code></pre>

<p>Another thing to account for is that a <code>std::vector</code> is actually a C++ (templated) class, so supports a different set of operations (e.g. to access elements) than a pointer to an array allocated using <code>malloc()</code> - which means, depending on what <code>//  do something here</code> represents, that you will still get compilation errors.   You'll need to read the documentation for <code>std::vector</code> to learn how to use it effectively.</p>
",0
37072665,37072463,1,"<p>In your second example, the new line character is still available to read - you've read a string, not a line.</p>

<p>See the missing extra newline in the output? That's the clue.</p>

<p>But more importantly, don't use <code>eof</code>. See <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">Why is ¡°while ( !feof (file) )¡± always wrong?</a></p>
",1
37073528,37072463,0,"<p>If <code>istream::eof()</code> returns <code>true</code> it means that <strong>the previous input operation failed</strong> because the stream was at the end of the file. That's why you can't use it to control an input loop: by the time it's true, the input has already failed. And that's why the input operations themselves can tell you whether they succeeded: that way you can loop as long as the input succeeds. This code</p>

<pre><code>while (cin.getline(whatever)) {
    do_something(whatever);
}
</code></pre>

<p>will execute the loop each time the <code>getline</code> call reads a line. When <code>cin</code> reaches the end of the input, the <code>getline</code> call will fail, and the loop won't be executed. This code:</p>

<pre><code>while (!cin.eof()) {
    cin.getline(whatever);
    do_something(whatever);
}
</code></pre>

<p>will call <code>do_something</code> even if the call to <code>getline</code> fails. <strong>After</strong> that call fails, on the next time through the loop, <code>cin.eof()</code> will return true and the loop will exit.</p>
",0
37195463,37195362,1,"<p>A string literal should be passed into a <code>const char*</code> not a <code>char*</code> (<a href=""https://stackoverflow.com/questions/2245664/what-is-the-type-of-string-literals-in-c-and-c"">the former is the correct type</a>) so change the constructor signature to</p>

<pre><code>Error(int c , const char* p);
</code></pre>

<p>and the member variable to</p>

<pre><code>const char *err_desc;
</code></pre>

<p>Or you can pass around <code>std::string</code>, which I would recommend.</p>
",1
37195483,37195362,1,"<p>In C++, the type of a string literal is array of <code>const char</code>, so normally you would use it to initialize a <code>const char*</code>, not a <code>char*</code>. The special rule that you can nonetheless initialize a <code>char*</code> with a string literal, which is not really const-correct, is for backward compatibility with C, in which string literals are arrays of plain <code>char</code>. It was deprecated as of C++03, and removed in C++11.</p>

<p>You should change <code>err_desc</code> and the argument of <code>Error</code>'s constructor from <code>char*</code> to <code>const char*</code>, which will make the warning go away, as well as make your code const-correct and prevent it from breaking in C++11.</p>
",0
43185486,43185374,0,"<p>Use dynamic array for initializing <code>sub</code>:</p>

<pre><code>char*  sub = new char[length];
</code></pre>
",1
34988488,34987861,1,"<p>In your case I would suggest to use the Singleton Pattern. Here is an example of how you could do it:</p>

<pre><code>class Logger
{
    std::ifstream logF;
    static Logger *s_instance;
    Logger(std::string &amp;path)
    {
        logF.open(path, std::ios_base::in);
    }
public:
    void log_data(int val)
    {
        logF &lt;&lt; val &lt;&lt; std::endl;
    }

    static void create_instance(std::string &amp;path)
    {
        s_instance = new Logger(path);
    }
    static Logger *instance()
    {                
        return s_instance;
    }
};
</code></pre>

<p>Now you can just include the header with the class def and call something like:</p>

<pre><code>Logger::instance()-&gt;log_data(&lt;value&gt;);
</code></pre>

<p>And do not forget to init the class before calling the static method (somewhere in main for instance):</p>

<pre><code>Logger::create_instance(&lt;path&gt;);
</code></pre>

<p>Of course, you can just make it easier by hard-coding a value for your path, but if the path changes you'll have to re-compile everything.</p>

<p>Or just use something already implemented like <a href=""http://log4cpp.sourceforge.net/"" rel=""nofollow"">log4cpp</a></p>
",4
34988554,34987861,0,"<p>Ah yes now that you mentioned the use of <code>datafile</code> in other function I see the error: The variable <code>datafile</code> is a <em>local</em> variable inside the <code>setup</code> function.</p>

<p>It should either be a member variable or possible a global variable.</p>
",5
34954648,34954603,4,"<p>You wrote a space instead of <code>::</code> between <code>std::fstream</code> and <code>out</code> in the <code>open</code> line.</p>
",0
41656446,41656373,-1,"<p>The modern way is like this</p>

<pre><code>  template&lt;Data&gt; struct node
  {
      struct node *next;
      struct node *previous;
      Data data;
  }
</code></pre>

<p>Now instantiate it with your struct UczzestnikList.</p>
",1
41656411,41656373,1,"<p>Very simply, create a class that has <code>Uczestnik</code> as a member variable.</p>

<pre><code>struct UczestnikList {
    UczestnikList *next;
    UczestnikList *prev;
    Uczestnik val; // or Uczestnik* val;
};
</code></pre>

<p>Now you can use the <code>UczestnikList</code> and traverse through it.</p>

<p>Also note that <code>val</code> could be an embedded member variable or a pointer (<code>Uczestnik* val</code>) depending on how you wish to implement the list.</p>

<p>When you get more familiar with C++, you could use STL libraries for this, such as the doubly-linked list in <a href=""http://www.cplusplus.com/reference/list/list/"" rel=""nofollow noreferrer"">std::list</a>.</p>
",1
36287297,36286646,-1,"<p>Did you try free() function?</p>

<pre><code>free(node);
</code></pre>
",3
37769892,37769104,0,"<p>The binary predicate <code>Comp</code> used for <code>std::map&lt;Key, Value, Comp&gt;</code> needs to implement a <a href=""https://en.m.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings"" rel=""nofollow""><em>strict weak order</em></a> on objects of type <code>Key</code>. the <em>strict</em> refers to the fact that <code>comp(x, x)</code> yields <code>false</code> for all objects of type <code>Key</code> used with <code>Comp</code>. For the predicate you defined that is <em>not</em> the case.</p>
",0
37759304,37759291,2,"<p>This declares a <code>std::unique_ptr</code> to an instance of a template class <code>Lucille</code>, with <code>Oscar</code> as its template parameter.</p>
",0
37759314,37759291,2,"<pre><code>std::unique_ptr&lt;Lucille&lt;Oscar&gt;&gt; mBuster;
</code></pre>

<p>It's creating a <code>unique_ptr</code> <code>Lucille</code> of type <code>Oscar</code>.</p>

<p>Much like: <code>std::vector&lt;queue&lt;stack&gt;&gt;</code>, which is a vector of queues containing stacks.</p>
",0
37759404,37759291,2,"<p>Your problem simply seems to be that you aren't familiar with the concept of templates in C++ yet.</p>

<p>It's somewhat similar to function parameters. The function</p>

<pre><code>foo(int value);
</code></pre>

<p>takes a value of type int as parameter, you can pass any int value. Templates make this a bit different, they aren't used to pass values, they are used to pass types as arguments.</p>

<p>To use a little bit of a simpler example let's look at <code>vector</code>:</p>

<pre><code>std::vector&lt;int&gt; ivector; // works on int values
ivector.push_back(5);

std::vector&lt;std::string&gt; strvector; // works on string values
strvector.push_back(""Hello"");
</code></pre>

<p>the part within the angular brackets <code>&lt;&gt;</code> are the template parameters. You can see that we can simply pass some type and all the functions will work for that specific type.</p>

<p>Now <code>unique_ptr&lt;type&gt;</code> takes the type to point to as a template argument. Your <code>std::unique_ptr&lt;Lucille&lt;Oscar&gt;&gt;</code> points to a value of type <code>Lucille&lt;Oscar&gt;</code>. Lucille is itself a template and works on values of type <code>Oscar</code>.</p>
",1
35224149,35224074,5,"<p>In order to analyse this, let's expand the macro, which becomes <code>++i * ++i</code>.</p>

<p>Formally, the behaviour of <code>++i * ++i</code> is <em>undefined</em> as <code>*</code> is not a sequencing point, and <code>++</code> mutates the <code>i</code>. So the compiler can do anything, and no further explanation is necessary.</p>

<p>If your compiler supports <code>typeof</code> (which is compile-time evaluable so will not do any incrementing), and <em>expression statements</em>, then the safe version of your macro is</p>

<pre><code>#define MUL(i) ({    \
    typeof(i) j = (i);  \
    j*j;                \
})
</code></pre>

<p>although it would be wise to avoid a macro altogether and use a function.</p>
",7
45050635,45050444,0,"<p>First of all I wouldn't suggest using pointers for singletons. This (<a href=""https://www.devarticles.com/c/a/Cplusplus/C-plus-plus-In-Theory-The-Singleton-Pattern-Part-I/4/"" rel=""nofollow noreferrer"">""Meyer Singleton""</a>) is a much better approach.</p>

<pre><code>static SingletonDatabase &amp;get() {
   static SingletonDatabase db;
   return db;
}
</code></pre>

<p>Also storing the singleton is kind of a bad idea, as with the storing you validate the initial idea / purpose behind the singleton: You are making copies, thus the singleton is not the ""sole"" instance of the class.</p>

<p>Anyway a great solution to your problem would be to use some kind of signal/slot system. (Qt / Boost library) Upon change you can emit the singal, which is then ""caught"" by all instances and the actualize the values.</p>

<p><a href=""http://www.boost.org/doc/libs/1_63_0/doc/html/signals.html"" rel=""nofollow noreferrer"">Boost Signals / Slots</a>
<a href=""http://doc.qt.io/qt-4.8/signalsandslots.html"" rel=""nofollow noreferrer"">Qt Signals Slots</a></p>

<p>I Hope this helps :)</p>
",2
45050747,45050444,2,"<p>You cannot. If your <code>getInstance()</code> returns a pointer or reference, there is no way to prevent the result from being copied into some variable, the same way as you cannot prevent a result of type <code>int</code> or <code>double</code> from being copied.</p>

<p>You could, however, make the functions the singleton provides static:</p>

<pre><code>class SomeSingleton
{
public:
    static void foo();
private:
    // deleting copy constructor and assignment operator...
    static SomeSingleton* getInstance();
};

void SomeSingleton::foo()
{
    SomeSingleton* instance = getInstance();
    // use instance as you need to get the appropriate result
}
</code></pre>

<p>So you enforce usage like this:</p>

<pre><code>SomeSingleton::foo();
</code></pre>

<p>Some might even consider it more comfortable to use than</p>

<pre><code>SomeSingleton::getInstance().foo();
</code></pre>

<p>By the way: This aproach makes it possible to protect you from race conditions, too, if multi-threading is or gets an issue:</p>

<pre><code>class SomeSingleton
{
public:
    static void foo();
private:
    static std::mutex mutex; // &lt;- add a mutex!

    static SomeSingleton* getInstance();

    static void exchange();
};

void SomeSingleton::foo()
{
    // this must be added whenever the singleton is used...
    std::lock_guard&lt;std::mutex&gt; guard(mutex);

    SomeSingleton* instance = getInstance();
    // use instance as you need to get the appropriate result
}

void SomeSingleton::exchange()
{
    // ... or the singleton instance is re-asigned
    std::lock_guard&lt;std::mutex&gt; guard(mutex);

    SomeSingleton* newInstance = new SomeSingleton();
    delete instance;
    instance = newInstance;
}
</code></pre>
",2
45050791,45050444,1,"<p>My solution is a wrapper with overloaded <code>-&gt;</code> operator like in smart pointers which calls <code>getInstance()</code> inside:</p>

<pre><code>class Singleton {
    friend SingletonWrapper;
    private:
        static Singleton * getInstance() {...}
    public:
        void foo() {}
};

class SingletonWrapper {
    public:
    Singleton * operator-&gt;() {
        return Singleton::getInstance();
    }
};

int main() {
    SingletonWrapper w;
    w-&gt;foo();
}
</code></pre>
",3
45073384,45050444,0,"<p>Use volatile to declare the singleton variable. This will force the compiler to always check for it</p>

<pre><code>class Singleton
{
    private:
        static volatile Singleton* instance;

    private:
        Singleton();

    public:
        static volatile Singleton* getInstance();
};
</code></pre>
",0
34900187,34899535,0,"<p>The function <a href=""http://fresh2refresh.com/c-programming/c-strings/c-strrev-function/"" rel=""nofollow"">strrev</a> needs a string, but you have a char vector. You have to insert the <strong>null-terminator '\0'</strong> at the end of the vector in order to use the function!</p>
",1
34899903,34899535,1,"<p>You need to null terminate your c-style strings, something like:</p>

<pre><code>char ch1[x + 1];  // need space for null
for(i=0; i&lt;x; i++){
    cin&gt;&gt;ch1[i];
}
ch1[x] = '\0';  // null terminate

char ch2[x + 1] = {0};  // need space for null here too

for(i=0; i&lt;x; i++){
ch2[i] = ch1[i];
}
ch2[x] = '\0';  // null terminate
</code></pre>
",6
38092280,38092010,1,"<p>I think you misread the question. It says that the <code>read()</code> method should read the data from the user. Usually it means read from the standard input. Afterwards, the method should set the values of the attributes for this specific athlete. Meaning, that the entered values relate to this specific object. Not for something new and temporary.</p>

<p>Pulling everything together is may look like the following:</p>

<pre><code> void Athlete::read()
 {
      string name;
      double salary;
      std::cout &lt;&lt; ""Please enter the athlete name:"";
      std::cin &gt;&gt; name;
      std::cout &lt;&lt; ""Please enter the athlete salary:"";
      std::cin &gt;&gt; salary;
      setName(name);
      setSalary(salary);
}
</code></pre>
",7
38092340,38092010,1,"<p>The thing you've missed is that <code>read</code> is supposed to be a <strong>pure virtual</strong> function. This means that you should not actually implement it, instead you should declare it as:</p>

<pre><code>virtual void read(string name, double salary) = 0;
</code></pre>

<p>This means that the <code>Athlete</code> class cannot actually be instantiated (it's called an absract class), instead it will be used as a base class and derived classes would be required to override the <code>read</code> method. If they don't override the method they will themselves be abstract and cannot be instantiated.</p>

<p>You are <strong>not</strong> required to implement the <code>read</code> method as a method of <code>Athlete</code> once you declared it as pure virtual. It only need to be implemented as a method in the derived class(es).</p>

<p>Also as the method in the derived class is supposed to modify the object the method cannot be <code>const</code> declared (as shown above). </p>
",4
46128627,46128582,0,"<p>Every flow of your fonction must return a <code>int</code>. So just display your text and then return.</p>

<pre><code>int bonAppetit(int n, int k, int b, vector &lt;int&gt; ar) {
    // Complete this function
    int sum = 0; 
    for(auto i : ar )
    {
        sum += i;
    }

    sum -= ar[k];

    if(sum/2 == b)
        cout&lt;&lt; ""Bon Appetit""&lt;&lt;endl;

    return b-(sum/2);
}
</code></pre>

<p>If you really need to ""return"" the string to main, it means your function returns both <code>int</code> and a ?<code>string</code>. In C++, a function has only one return type. Then, you have several options to have your function provide two outputes (<code>int</code> and <code>string</code>). Here are two simple options:</p>

<p>Return a <code>pair</code> (<code>int</code> and <code>string</code>):</p>

<pre><code>pair&lt;int,string&gt; bonAppetit(int n, int k, int b, vector &lt;int&gt; ar) {
    // Complete this function
    int sum = 0; 
    for(auto i : ar )
    {
        sum += i;
    }

    sum -= ar[k];

    return make_pair( b-(sum/2), ((sum/2 == b) ? ""Bon Appetit"" : """") );
}
</code></pre>

<p>Then your main will do:</p>

<pre><code>pair&lt;int,string&gt; result = bonAppetit(n, k, b, ar);
if ( !result.second.empty() )
    cout &lt;&lt; result.second &lt;&lt; endl;
cout &lt;&lt; result.first &lt;&lt; endl;
</code></pre>

<p>Or have a <code>string</code> be passed as reference to the function (if not a <code>const</code> reference, it will let your function modify it):</p>

<pre><code>int bonAppetit(int n, int k, int b, vector &lt;int&gt; ar, string&amp; message) 
{
    // Complete this function
    int sum = 0; 
    for(auto i : ar )
    {
        sum += i;
    }

    sum -= ar[k];

    if (sum/2 == b)
        message = ""Bon Appetit"";

    return b-(sum/2);
}
</code></pre>

<p>Then your main will do:</p>

<pre><code>string text;
int result = bonAppetit(n, k, b, ar, text);
if ( !text.empty() )
    cout &lt;&lt; text &lt;&lt; endl;
cout &lt;&lt; result.first &lt;&lt; endl;
</code></pre>
",1
46128657,46128582,2,"<pre><code>int bonAppetit(int n, int k, int b, vector &lt;int&gt; ar) {
    // Complete this function
    int sum = 0; 
    for(auto i : ar )
        sum += i;

    sum -= ar[k];

    if(sum/2 == b)
        return -1;
    else
        return b-(sum/2);
}
</code></pre>

<p>and in main:</p>

<pre><code>if (result != -1) std::cout &lt;&lt; result &lt;&lt; std::endl;
else std::cout &lt;&lt; ""Bon Appetit"" &lt;&lt; std::endl;
</code></pre>

<p>Please, do not use <code>using namespace std</code>. Read <a href=""https://stackoverflow.com/a/1452738/7943474"">here</a> why</p>
",2
46128674,46128582,1,"<p>you can return two value from one function by using byRef Arguments. this is a simple sample:</p>

<pre><code>char* isDividableOn(int num, int divider ,int &amp; remain){

   if ( num % divider == 0){
        remain = 0;
        return ""number is dividable"";
   }
   else {
        remain = num % divider;
        return ""number is not dividable"";
   }
}

int main (){
    int num = 11;
    int divider = 3;
    int res = -1;
    cout &lt;&lt; isDividableOn(num , divider, res);
    /// in this point  value of res now is set to 2;
}
</code></pre>
",0
46128872,46128582,0,"<p>it worked :</p>

<pre><code> #include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

string bonAppetit(int n, int k, int b, vector &lt;int&gt; ar) {
    // Complete this function
    int sum = 0; 
    for(auto i : ar )
    {
        sum += i;
    }

    sum -= ar[k];

    if(sum/2 == b)
        return ""Bon Appetit"";

       string str = to_string(b-(sum/2));
   return str;
}

int main() {
    int n;
    int k;
    cin &gt;&gt; n &gt;&gt; k;
    vector&lt;int&gt; ar(n);
    for(int ar_i = 0; ar_i &lt; n; ar_i++){
       cin &gt;&gt; ar[ar_i];
    }
    int b;
    cin &gt;&gt; b;
    string result = bonAppetit(n, k, b, ar);
    cout &lt;&lt; result &lt;&lt; endl;
    return 0;
}
</code></pre>
",2
34937202,34937192,3,"<p>Single quotes should work just fine inside double quotes:</p>

<pre><code>cout &lt;&lt; "" The lowercase equivalent of '"" &lt;&lt; mychar &lt;&lt; ""' is '"" &lt;&lt; input &lt;&lt; ""'"" &lt;&lt; endl;
</code></pre>
",5
34937210,34937192,0,"<pre><code>cout &lt;&lt; "" The lowercase equivalent of \'"" &lt;&lt; mychar &lt;&lt; ""\' is \'"" &lt;&lt; input &lt;&lt; ""\'"" &lt;&lt; endl;
</code></pre>

<p>Should work. Single quotes need to be escaped by the backslash.</p>
",2
43226873,43219545,0,"<p>y is non-const variable. So the non-const method is called.</p>

<p>If you defined y2 as const, it will called the const method.</p>

<pre><code>int main()
{
    Y y;
    const Y y2 = y;

    X i = y.GetX();
    const X&amp; j = y2.GetX();

    return 0;
}
</code></pre>
",0
34967977,34967583,0,"<p>You can not <code>cout</code> the result of a <code>void</code> function or cast the <code>void</code> to something to be used on the <code>cout</code>, since there is nothing being returned.</p>

<p>If all you needed is the side effect of your function <code>printLetterGrade</code> and that the side effect take place exactly at a certain point in the <code>cout</code> sequence, you can change its return to something trivial that does not print, </p>

<p>e.g., You can change the return type from <code>void</code> to <code>char *</code> or <code>string</code> and return an empty string <code>""""</code> wherever you had a <code>return;</code> statement (if any).</p>
",0
34968898,34967583,0,"<pre><code>float calculateClassStats(float marks[], int length)
{
    const int arrayCount = length;
    for (int x = 0; x &lt; arrayCount; x++)
    {

        cout &lt;&lt; marks[x] &lt;&lt; printLetterGrade(marks[x]) &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<p>Just change the return-type to <code>string</code>, and change <code>cout &lt;&lt;</code> to <code>return</code>.</p>

<pre><code>string printLetterGrade(float mark)
{
    float grade = mark;

    if (grade &gt;= 90)
        return "" Your Letter Grade is A+"";

    else if ((grade &gt;= 85) &amp;&amp; (grade &lt;= 89))
        return "" Your Letter Grade is A"";

    else 
        return "" Fail"";

}
</code></pre>

<p>Output</p>

<pre><code>95 Your Letter Grade is A+
88 Your Letter Grade is A
50 Fail
</code></pre>
",0
34967629,34967583,-1,"<p>modify your cout statement as </p>

<pre><code> cout&lt;&lt;printLetterGrade(marks[x])&lt;&lt;marks[x];
</code></pre>

<p>Also remove the <code>char letter = printLetterGrade(marks[x]);</code>line, it seems unnecessary.</p>

<p>Edit: the modified code will then be:</p>

<pre><code>void printLetterGrade(float mark)
{
float grade = mark;

if (grade &gt;= 90)
    cout &lt;&lt; ""Your Letter Grade is A+"" &lt;&lt; endl;

else if ((grade &gt;= 85) &amp;&amp; (grade &lt;= 89))
    cout &lt;&lt; ""Your Letter Grade is A"" &lt;&lt; endl;

else 
    cout &lt;&lt; ""fail"" &lt;&lt; endl;

}

float calculateClassStats(float marks[], int length)
{
const int arrayCount = length;
for (int x = 0; x &lt; arrayCount; x++){
    cout&lt;&lt;marks[x];
    printLetterGrade(marks[x]); 
}
return 0;
}
</code></pre>
",3
34967649,34967583,0,"<p>Print both in same function</p>

<pre><code>void printLetterGrade(float mark)
{
    float grade = mark;

    if (grade &gt;= 90)
        cout &lt;&lt;mark&lt;&lt; ""Your Letter Grade is A+"" &lt;&lt; endl;

    else if ((grade &gt;= 85) &amp;&amp; (grade &lt;= 89))
        cout &lt;&lt;mark&lt;&lt; ""Your Letter Grade is A"" &lt;&lt; endl;

    else 
        cout &lt;&lt; ""fail"" &lt;&lt; endl;

}

float calculateClassStats(float marks[], int length)
{
    const int arrayCount = length;
    for (int x = 0; x &lt; arrayCount; x++){
        printLetterGrade(marks[x]);            
    }
    return 0;
}
</code></pre>
",0
34967665,34967583,6,"<p>You need to change the <code>printLetterGrade</code> such that it <em>does</em> return something. E.g. </p>

<pre><code>const char *printLetterGrade(float mark)
{
   if ( ... )
      return ""A+"";
   if ( ... )
      return ""A"";
   ...
}
</code></pre>

<p>(Of course, at this point, you may want to call the function something else too)</p>
",4
34967882,34967583,0,"<p>If you want to print something on the same line, just don't print the <code>endl</code>:</p>

<pre><code>void printLetterGrade(float mark)
{
    float grade = mark;

    if (grade &gt;= 90)
        cout &lt;&lt; ""Your Letter Grade is A+"" &lt;&lt; endl;

    else if ((grade &gt;= 85) &amp;&amp; (grade &lt;= 89))
        cout &lt;&lt; ""Your Letter Grade is A"" &lt;&lt; endl;

    else 
        cout &lt;&lt; ""fail"" &lt;&lt; endl;

}

float calculateClassStats(float marks[], int length)
{
    const int arrayCount = length;
    for(int x = 0; x &lt; arrayCount; x++) {

        cout &lt;&lt; marks[x] &lt;&lt; "" ""; // don't print endl, just a space
        printLetterGrade(marks[x]); // goes on same line
    }
    return 0;
}
</code></pre>
",0
34971967,34971931,0,"<p><code>COMMUNICATIONOBJECT</code> is the name of the typedef and <code>PCOMMUNICATIONOBJECT</code> is a pointer to such a typedef. </p>
",0
34972042,34971931,0,"<p>By putting <code>typedef</code> before <code>struct</code>, you can define the struct and then list new aliases for it after the definition. <code>COMMUNICATIONOBJECT</code> is a new name for <code>_tagCOMMUNICATIONOBJECT</code> and <code>PCOMMUNICATIONOBJECT</code> is a new name for a pointer to the struct. It could be written like this instead:</p>

<pre><code>struct _tagCOMMUNICATIONOBJECT
{
    HWND  hWndClient;
    BOOL  bExitLoop;
    LONG  lSleepTimeout;
};
typedef _tagCOMMUNICATIONOBJECT COMMUNICATIONOBJECT;
typedef _tagCOMMUNICATIONOBJECT *PCOMMUNICATIONOBJECT;
</code></pre>
",0
34972047,34971931,4,"<p>This is the old way Microsoft defined most of their structures. It works in C and C++. In C++ just the name after the <code>struct</code> keyword would be enough as it auto-typedef's such a name.</p>

<p>But to make it clearer you could re-write such as follow:</p>

<pre><code>struct _tagCOMMUNICATIONOBJECT
{
  HWND  hWndClient;
  BOOL  bExitLoop;
  LONG  lSleepTimeout;
};

typedef struct _tagCOMMUNICATIONOBJECT COMMUNICATIONOBJECT;
typedef struct _tagCOMMUNICATIONOBJECT *PCOMMUNICATIONOBJECT;
</code></pre>

<p>So in C++ they define 3 names:</p>

<pre><code>_tagCOMMUNICATIONOBJECT
COMMUNICATIONOBJECT
PCOMMUNICATIONOBJECT
</code></pre>
",0
35246811,35245198,0,"<p>After <code>getline(std::cin,strg)</code>   strg=="""".<br/> 
In loop: 
     <pre><code>for(int i = 0; i &lt;= str.length()-1; i++)</code></pre>
comparison  &lt;= not work correct if str.length() ==0.<br/> 
After changing to</p>

<p><pre><code>for(int i = 0; i &lt;= (int)str.length()-1; i++)</code></pre>
program not fail.<br/> <br/>
Preferable also change 
    <code>cin >> codc;</code>
to
    <code>getline(cin,codc);</code></p>

<p>Now program not fail.</p>
",0
35245302,35245198,0,"<p>The exception is caused by:</p>

<pre><code>str.substr(i + 1, str.length());
</code></pre>

<p>as it tries to access <code>str</code>'s elements up to <code>i + str.length()</code>. This fails for <code>i &gt; 0</code>. See the original <a href=""https://stackoverflow.com/questions/32318770/stdstringsubstr-throws-stdout-of-range-but-the-arguments-are-in-limit/32318799#32318799"">Q&amp;A</a>.</p>

<p><sup><code>str.substr(i + 1, str.length() - i - 1);</code> would correct it.</sup></p>

<p>If you want to get the part of the string on the right of the index <code>i</code>, you can just <strong>leave out the second argument</strong>:</p>

<pre><code>str.substr(i + 1);
</code></pre>

<p>See the <a href=""http://en.cppreference.com/w/cpp/string/basic_string/substr"" rel=""nofollow noreferrer"">reference</a>.</p>

<p>And this is dangerous too:</p>

<pre><code>alphacap[loc + 1]
alphacap[loc - 1]
</code></pre>

<p>What if <code>loc</code> is the index of the first/last element in <code>alphacap</code>?</p>
",4
34893754,34893572,0,"<pre><code>#include&lt;iostream&gt;
template&lt;class T&gt;
void swap(T &amp;x, T &amp;y){
    T temp;
    temp = x;
    x = y;
    y = temp;
}

int main(){
   char ch1,ch2;
   std::cin&gt;&gt;ch1&gt;&gt;ch2;
   swap(ch1,ch2);
   std::cout&lt;&lt;ch1&lt;&lt;"" ""&lt;&lt;ch2&lt;&lt;""\n"";
   int a,b;
   std::cin&gt;&gt;a&gt;&gt;b;
   swap(a,b);
   std::cout&lt;&lt;a&lt;&lt;"" ""&lt;&lt;b&lt;&lt;""\n"";
   return 0; 
}
</code></pre>

<p>Since swap is already present in namespace, you would not be able to overload it when using namespace std.</p>
",3
38395556,38395376,1,"<p>The issue here is a non static member function is not the same as a regular or static function. It has a hidden parameter that it takes and that is pointer to the object the function is being called on.  </p>

<p>You have a couple ways to fix this.  First you can make it static and then it treats it just like a normal function whose name is scopeed to the class.  If you cannot do that then you can use <a href=""http://en.cppreference.com/w/cpp/utility/functional/bind"" rel=""nofollow""><code>std::bind</code></a> to create function like object that you can call the function operator on.  It would be used like</p>

<pre><code>timer(std::chrono::milliseconds(10), std::bind(&amp;class_name::my_functions(), &amp;class_instance));
</code></pre>

<p>Lastly you could use a lambda to wrap the call just like <code>bind</code> does.  For that the syntax would be</p>

<pre><code>timer(std::chrono::milliseconds(10), [&amp;class_instance](){
    return class_instance.my_functions(); 
});
</code></pre>
",0
38395583,38395376,1,"<p>You cannot call non-static methods/functions without an object instance (even if the object is not really needed inside the method/function).</p>

<p>To achieve a method call without the need for an object, declare that method <code>static</code> (can still be inside the class, but add <code>static</code> before its name).</p>
",2
38395611,38395376,2,"<p>To pass a non-static member function to another function you need to utilize <code>std::function</code> and <code>std::bind</code> from <a href=""http://en.cppreference.com/w/cpp/header/functional"" rel=""nofollow"">functional</a> header, as well as instantiate the object</p>

<pre><code>myclass mc;
timer(std::chrono::milliseconds(1), std::bind(&amp;myclass::my_functions, mc));
</code></pre>

<p>However, your code might not work as expected, because to see the message you must wait for the thread to make a call. Here's a simple example of a working one</p>

<pre><code>#include &lt;thread&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;chrono&gt;

template &lt;typename Duration, typename Function&gt;
void timer(Duration const &amp; d, Function const &amp; f)
{
    std::thread([d, f](){
        std::this_thread::sleep_for(d);
        f();//error here
    }).detach();
}

class myclass{
public:
    void my_functions() const {
        std::cout &lt;&lt; ""aaa"";
    }
};

int main(){
    myclass mc;
    timer(std::chrono::milliseconds(1), std::bind(&amp;myclass::my_functions, mc));
    std::this_thread::sleep_for(std::chrono::milliseconds(2000));
}
</code></pre>

<p>The proper way would be of course to wait for thread completion.</p>

<p>Also, if the sole purpose of your member function is to output a message, you can make it static and do without binding.</p>
",0
38396006,38395376,1,"<p>If you are okay to charge argument list of your <code>timer()</code> function then this will also works.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;

template &lt;typename Duration, typename Function, typename Class&gt;
void timer(Duration const &amp; d, Function const &amp; f,Class const&amp; o)
{
    std::thread([d,f,o](){
        std::this_thread::sleep_for(d);
        f(o);//error here
    }).detach();
}
class Foo{
public:
    Foo() {}
    void func() const {
        std::cout&lt;&lt;__func__&lt;&lt;"":""&lt;&lt;__LINE__&lt;&lt;std::endl;};
    }

int main(){
    std::function&lt;void(const Foo&amp;)&gt; foo_func = &amp;Foo::func;
    const Foo foo;
    timer(std::chrono::seconds(2),foo_func,foo);
    std::this_thread::sleep_for(std::chrono::seconds(5));
    return 0;
}
</code></pre>
",0
36284846,36284720,1,"<p>You have returned the space that was allocated to the free heap pool.   That does not mean something is going to write zeros to it.  That takes time, and you might not want to spend that time on that task.</p>

<p>I suppose some types could have destructors that could clear their storage during destruction, but an <code>int</code> doesn't.</p>

<p>If you do want data erased, clear it yourself before calling <code>delete</code></p>

<p>It's also a bad idea to continue to use the memory after you've told the system you are done with it.</p>

<p>So you have the option of setting your pointer to <code>NULL</code> after the <code>delete</code>, that will help cause an exception if you do screw up and try to use the old pointer.</p>
",0
36284849,36284720,0,"<p>You are not deleting the actual <code>value</code> of the pointer or the value its pointing at. You are just <strong>deallocating the memory</strong> so some other pointer ""later"" will be able to point at that same spot.</p>
",3
36284854,36284720,2,"<p>The delete operator frees the memory that was pointed to by the pointer. Once free it can be reallocated at any time so accessing that pointer will have unpredictable results.  In your program it is simply the case that the memory has not yet been reallocated for anything else.</p>

<p><a href=""https://msdn.microsoft.com/en-us/library/h6227113.aspx"" rel=""nofollow"">https://msdn.microsoft.com/en-us/library/h6227113.aspx</a></p>

<p>Specifically:</p>

<p>""Using the delete operator on an object deallocates its memory. A program that dereferences a pointer after the object is deleted can have unpredictable results or crash.
When delete is used to deallocate memory for a C++ class object, the object's destructor is called before the object's memory is deallocated (if the object has a destructor).""</p>
",0
46955100,46955053,8,"<p>It's not C++ depending. Tabulation <code>representation size</code> depends of the position on the line to the next <code>Tab stop</code></p>

<p><a href=""https://en.wikipedia.org/wiki/Tab_key"" rel=""nofollow noreferrer"">Tab_key</a></p>

<p><a href=""https://en.wikipedia.org/wiki/Tab_stop"" rel=""nofollow noreferrer"">Tab_stop</a></p>
",0
46955189,46955053,3,"<p>Because <code>\t</code> aligns to the next tab stop which is 8 characters long in your case. Your first line is 23 characters long, so the next tab stop is at 24 chars. Your second line is 26 characters long, so the next tab stop is at 32 chars.</p>
",0
46955203,46955053,5,"<p>Wikipedia Tab key:</p>

<blockquote>
  <p>The tab key Tab ? (abbreviation of tabulator key[1] or tabular key[2])
  on a keyboard is used to advance the cursor <strong>to the next tab stop.</strong></p>
</blockquote>

<p>Wikipedia Tab stop</p>

<blockquote>
  <p>A tab stop on a typewriter is a location where the carriage movement
  is halted by mechanical gears. Tab stops are set manually, and
  pressing the tab key causes the carriage to go to the next tab stop.
  In text editors on a computer, the same concept is implemented
  simplistically with automatic, <strong>fixed tab stops.</strong></p>
</blockquote>

<p><strong>tldr:</strong> the 'tab' jumps the cursor to the next tabstop, which for example is in a line per 4 characters. So doing a tab at position 3, will jump to 4. tab at position 4 jumps to 8.</p>
",0
39627067,39626903,1,"<p>If you want to avoid typing the ""<code>Point::</code>"" in front of the <code>getX</code>, <code>getY</code> etc., then the answer is <em>""no""</em>, unfortunately. In C++ and the name of any class (like ""<code>Point</code>"") is not a <em>namespace</em>, it's a <em>scope</em>.</p>

<p>What you can only do is <em>inlining</em> the method, defining into the class declaration.</p>

<pre><code>class Point {
  public:
    void a_method() {
      // all the code here!
    }
};
</code></pre>
",0
39626984,39626903,0,"<p>You can't avoid ""the <code>Point::Point</code> part,"" unless you declare the construction inline in the class declaration.  The first ""Point"" defines the scope of the function, and the second ""Point"" is the name of the constructor function.</p>

<p>However, you could define the constructor(s) inline, like so:</p>

<pre><code>class Point
{
  Point()
  {
    x = 0;
    y = 0;
  }
  Point(int newX, int newY);
  {
    x = newX;
    y = newY;
  }
  // ...
};
</code></pre>

<p>Or:</p>

<pre><code>class Point
{
  Point() : x(0), y(0) {}
  Point(int newX, int newY) : x(newX), y(newY) {}
  // ...
};
</code></pre>

<p>Or:</p>

<pre><code>class Point
{
  Point(int newX = 0, int newY = 0) : x(newX), y(newY) {}
  // ...
};
</code></pre>
",0
39626996,39626903,1,"<p>You aren't <em>required</em> to separate your declaration and definition, and these functions are incredibly trivial. So including them in the class definition may actually allow the compiler to perform numerous additional optimizations.</p>

<p>So you could discard the .cpp entirely and the header becomes:</p>

<pre><code>#ifndef POINT_H_
#define POINT_H_

class Point
{
    int x_ { 0 };
    int y_ { 0 };

public:
    Point() = default;
    Point(int x, int y) : x_(x), y_(y) {}

    int getX() const { return x_; }
    int getY() const { return y_; }
    void setX(int x) { x_ = x; }
    void setY(int y) { y_ = y; }
    void moveBy(int x, int y) { x_ += x, y_ += y; }
    Point reverse() const { return Point(y_, x_); }
};

#endif
</code></pre>

<p>But you can't avoid the ""Point::"" part when defining the members outside of the class declaration.</p>
",0
40973734,40973464,2,"<p>If the format can be variant (not always the fixed 3 arguments: <code>%5d</code>, <code>%8s</code> and <code>%8x</code>) and you want to be flexible in that manner, you should write your own implementation for that.</p>

<p>Assuming that count defined after <code>%</code> is a general digit (not only 5 or 8) you could try using the <a href=""http://www.cplusplus.com/reference/regex/regex_search/"" rel=""nofollow noreferrer"">std::regex_search</a> or <a href=""http://www.cplusplus.com/reference/regex/regex_match/"" rel=""nofollow noreferrer"">std::regex_match</a> to find the actual mnemonics you are looking for. For example your expression could look like <code>%\d+[dsx]</code></p>

<p>Then you should parse it to find the <code>COUNT</code> and <code>type</code> and substitute with a random number acquired with the desired <a href=""http://www.cplusplus.com/reference/random/"" rel=""nofollow noreferrer"">generator</a>.
To parse you could try updating the above expression to <code>%(\d+)([dsx])</code> and capturing groups.</p>

<p>A sample parse implementation for your case could look like this:</p>

<pre><code>std::string text = ""RndOrder%5d - RndCustomer%8s - RndHex%8x"";
auto reg = std::regex(""%(\\d+)([sdx])"");
std::smatch match;
while (std::regex_search(text, match, reg))
{
    const auto&amp; full = match.str(); // in 1st iter contains ""%5d""
    const auto&amp; count = match.str(1); // in 1st iter contains ""5""
    const auto&amp; type = match.str(2); // in 1st iter contains ""d""
    // further processing: type conversion, number generation, string replacement

    text = match.suffix().str();
}
</code></pre>

<p>For implementation example with search and group capturing you can also check out another question: <a href=""https://stackoverflow.com/questions/12908534/retrieving-a-regex-search-in-c"">Retrieving a regex search in C++</a></p>
",3
40974153,40973464,1,"<p>Ok, assuming that you're actually asking about string parsing here (and not random number/data generation)... have a look at this:</p>

<pre><code>int iRandom1 = 12345;       // 5-digit decimal
int iRandom3 = 0x12345678;  // 8-digit hexadecimal
char cRandom2[9] = ""RandomXY\0"";  // Don't forget to NULL-terminate!
std::string sFormat = ""RndOrder%5d - RndCustomer%8s - RndHex%8x"";

char cResultBuffer[500];  // Make sure this buffer is big enough!

std::sprintf( cResultBuffer, sFormat.c_str(), iRandom1, cRandom2, iRandom3 );
std::string MyString = cResultBuffer;  // MyString = ""RndOrder12345 - RndCustomerRandomXY - RndHex12345678"";
</code></pre>
",2
40975958,40973464,1,"<p>It's a candidate for <code>std::snprintf</code> (c++14), but take care to request the correct buffer size in one call, allocate a buffer and then format the string into the buffer:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;string&gt;

template&lt;class...Args&gt;
std::string replace(const char* format, Args const&amp;... args)
{
    // determine number of characters in output
    auto len = std::snprintf(nullptr, 0, format, args...);

    // allocate buffer space
    auto result = std::string(std::size_t(len), ' ');

    // write string into buffer. Note the +1 is allowing for the implicit trailing
    // zero in a std::string
    std::snprintf(&amp;result[0], len + 1, format, args...);

    return result;
};

int main() {
    auto s = replace(""RndOrder%5d - RndCustomer%8s - RndHex%8x"", 5, ""foo"", 257);
    std::cout &lt;&lt; s &lt;&lt; std::endl;
}
</code></pre>

<p>expected output:</p>

<pre><code>RndOrder    5 - RndCustomer     foo - RndHex     101
</code></pre>
",0
35237882,35237813,0,"<p>This line:</p>

<pre><code>put(input[word], words, counts, wordsSize);
</code></pre>

<p>You are trying to index into an <code>ifstream</code>. This is simply not allowed. The compiler (g++ 4.8.4) said:</p>

<pre><code>no match for ¡®operator[]¡¯ (operand types are ¡®std::ifstream {aka std::basic_ifstream&lt;char&gt;}¡¯ and ¡®int¡¯)
</code></pre>
",2
35287530,35273872,1,"<blockquote>
  <p>(Event.o): In function
  com::egi::services::mff::api::Event::setBeginTime(EGIBase::EGIXStringWrap)':
  Event.cpp:(.text+0xacd): undefined reference to
  EGIBase::EGIXStringWrap::getStringCopy[abi:cxx11] ()'</p>
</blockquote>

<p>Given what you have posted, it means that the function setBeginTime() of the Event Class, in the namespace <em>com::egi::services::mff::api</em>, has an argument of type <em>EGIXStringWrap</em> that belongs to the <em>EGIBase</em> namespace.</p>

<p>All is well till here, since the compiler keeps resolving after that line. We can deduce that the namespace <em>EGIBase</em> is visible to the library of the class <em>Event</em>.</p>

<p><strong>Assumption:</strong></p>

<p>Then, the compiler can't find a reference to <em>getStringCopy</em>, inside the <em>EGIBase::EGIXStringWrap</em> namespace, which is in a binary form (maybe a .o) expected to be built with a C++ 11 compatible compiler.</p>

<p><strong>Given that my assumption is correct:</strong></p>

<p>First of all, it is unlikely that you can do anything, given that those libraries are given to you already compiled, better contact their provider.</p>

<p>Secondly, <em>getStringCopy</em> is in the same namespace, <em>EGIBase</em>, so it must be visible.</p>

<p>Apart from that, I find it unlikely that the produced binary library is incompatible with a library of a previous C++ version (although not impossible).</p>
",2
37633084,37629979,0,"<p>Containers store the necessary entry points to the held data as members of the object. In your case, you'd store the pointer to the buckets (and any other administrative data you'll need):</p>

<pre><code>template &lt;typename E&gt;
class ExHashing {
    Bucket&lt;E&gt;* buckets;
public:
    ExHashing(): buckets(0) {}               // Make sure the pointer is initialized.
    ExHashing(ExHashing const&amp;);             // You'll likely need a copy ctor,
    ~ExHashing();                            // a destructor,
    ExHashing&amp; operator= (ExHashing const&amp;); // and copy assignment.
    // as well as other mmebers
};
</code></pre>

<p>When you create or access your buckets you'd use <code>this-&gt;buckets</code> instead of a local variable.</p>
",2
35246795,35246732,0,"<p>The hit and miss problem is cause by use of</p>

<pre><code>openFile &gt;&gt; tempInt;
</code></pre>

<p>followed by</p>

<pre><code>getline(openFile, temp);
</code></pre>

<p>After <code>tempInt</code> is read, the newline character is still left in the stream. The next call to <code>getline</code> just grabs an empty string.</p>

<p>You can add another call to <code>getline</code> right after the call to read <code>tempInt</code>.</p>

<pre><code>openFile &gt;&gt; tempInt;
std::string ignoreString;
getline(openFile, ignoreString);

...

getline(openFile, temp);
</code></pre>
",2
38503917,38503800,0,"<p>find two largest numbers and two smallest numbers, and also a third largest number, if third number is positive return it and the pair that has the largest product, if it is negative return it and the pair that has the smallest product.</p>
",2
38503966,38503800,1,"<p>This is a rather mathematical question.</p>

<p>Without trying to proof my idea would be to take the numbers with the greatest absolute value and at the same time look for an even amount of negative numbers to produce a positive number.</p>
",2
38504545,38503800,2,"<p>I assume that the input set contains at least 4 integers (the solution is trivial if we have 3 integers...).</p>

<p>A few cases are of notable interest:</p>

<ol>
<li>2 or more negative integers, 1 or 2 positive integers</li>
<li>2 or more negative integers, 3 or more positive integers</li>
<li>All positive integers</li>
<li>1 negative integer, 3 or more positive integers</li>
<li>All negative integers</li>
</ol>

<p>Let's think about the solution in each case. In the following discussion, <code>lowest</code> and <code>greatest</code> both refer to the common total order on integers: for instance, of -5 and -1, -1 is the greatest.</p>

<ol>
<li>The desired output will be obtained by multiplying the 2 negative numbers with highest absolute value (ie. their mins) with the highest positive number. In other words the result is <code>lowest_negative*2nd_lowest_negative*greatest_positive</code></li>
<li>Result is <code>max(3rd_greatest_positive*2nd_greatest_positive, lowest_negative*2nd_lowest_negative)*greatest_positive</code></li>
<li>Result is <code>3rd_greatest_positive*2nd_greatest_positive*greatest_positive</code></li>
<li>Same as 3.</li>
<li>Result is <code>3rd_greatest_negative*2nd_greatest_negative*greatest_negative</code></li>
</ol>

<p>From the cases above you can deduce a formula that solves the problem universally (which works for 3-elements sets as well as for any configuration of negative/positive integers):</p>

<blockquote>
<pre><code>result = max(max1*min1*min2, max1*max2*max3)
</code></pre>
  
  <p>Where <code>max1</code> is the max of the input, <code>max2</code> the second greatest element, <code>max3</code> the third greatest element and <code>min1</code> and <code>min2</code> are the two lowest elements.</p>
</blockquote>

<p>Now you could easily write a program to keep track of the 2 minimum elements and the 3 maximum elements (regardless of their sign!), then return <code>max(max1*min1*min2, max1*max2*max3)</code></p>

<p>Here is a <a href=""http://coliru.stacked-crooked.com/a/2e4f260ecd837d49"" rel=""nofollow"">C++ demo</a> (using vector) just to demonstrate the accuracy of the formula. I leave you the I/O handling as an exercise.</p>
",2
38504716,38503800,1,"<blockquote>
  <p>What's the easiest method to solve this?</p>
</blockquote>

<p>Brute force.</p>

<p>Compute all products of 3 numbers in N choose 3 time, and then take the maximum.</p>

<p>How big is your input? You could reuse products of 2 numbers with a memoizing (dynamic programming) approach.</p>
",1
38504548,38503800,1,"<p>There can be negative and positive numbers and it can also happen that all numbers are negative, thus you have to consider all possible cases: </p>

<p>The biggest product can be made of...</p>

<pre><code>+++   all numbers positive  -&gt; needs factors with large absolute value
++-   one negative          -&gt; needs factors with small absolute value
+--   only one positive     -&gt; needs factors with big ...
---   all negative          -&gt; needs factors with small ...
</code></pre>

<p>As you cannot use arrays or vectors, you can do it like this:</p>

<p>For each above case, you need either all factors with maximum absolute value or minimum absolute value. You can go trough all given numbers and for each case store the three numbers that would make the biggest product for this case. In the end you just have to compare the 4 results and take the biggest one. </p>
",0
35257001,35256146,0,"<p>Try this small illustrative program:  </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

int main(void)
{
  std::cout &lt;&lt; ""This is a prompt, enter some text:\n"";
  std::string  the_text;
  std::getline(std::cout, the_text); // Input the text.
  std::cout &lt;&lt; ""\n""
            &lt;&lt; ""The text you entered:\n"";
  std::cout &lt;&lt; the_text;
  std::cout &lt;&lt; ""\n"";

  // Pause the program, if necessary.
  std::cout &lt;&lt; ""\n\nPaused.  Press Enter to continue...\n"";
  std::cin.ignore(10000000, '\n');

  // Return status to the Operating System
  return EXIT_SUCCESS;
}
</code></pre>

<p>As you can see, outputting an instructional phrase before an input is known as <em>prompting the User</em>.  </p>

<p><strong>Edit 1:  Prompting in a <code>while</code> loop</strong><br>
In your case, you need to prompt the user before the input:</p>

<pre><code>while (input != ""quit"")
{
  // Do stuff

  std::cout &lt;&lt; ""Enter text or \""quit\"" to quit: "";
  std::cout.flush();  // Flush buffers to get the text on the screen.
  std::cin &gt;&gt; input;
}
</code></pre>
",0
35256220,35256161,2,"<p>You have </p>

<pre><code>newacceleration-&gt;y = a.y;
</code></pre>

<p>Twice. The 2nd one needs to be:</p>

<pre><code>newacceleration-&gt;z = a.z;
</code></pre>

<p>Update: What ere these 2 lines in sensor()?</p>

<pre><code>int f;
cin &gt;&gt; f;
</code></pre>
",2
34979907,34979879,0,"<p>If you means by lib the windows .lib output of static library built. The answer is no. You can not link to part of it without the other. However, if you have the whole source, yes you can do some trick and clean the unnecessary part then built it again and link to it.</p>

<p><strong>EDIT:</strong></p>

<p>I have just notice the sort word. If it is really the <code>std::sort</code>, then you have misunderstood something. Like <a href=""https://stackoverflow.com/users/1670129/igor-tandetnik"">Igor</a> said in the comments: </p>

<blockquote>
  <p>it's a template function implemented entirely in headers. You don't
  ""import"" any library for it.</p>
</blockquote>
",0
34979950,34979879,2,"<p>Assuming a function is in a library in the first place (and not just a header-file implementation), then linking to that library SHOULD only pull in the function(s) you are using [including, of course, ones that are used internally]. So there is really no reason to avoid linking with a library that provides something you need.</p>

<p>Of course, the implementation may be silly and use lots of functions that you don't ACTUALLY need for what you want to do, but this is a separate problem.</p>

<p>For template-functions (which, in almost every current compiler, <em>has</em> to be implemented in a header-file), the requirement is to include the appropriate header-file.</p>
",0
34979996,34979879,2,"<p>At the moment, you can't import individual functions from a header, you can only <code>#include</code> the entire header.  While you don't need to include the entire standard library to use <code>std::sort()</code>, you do need to <code>#include &lt;algorithm&gt;</code>, and by extension include all the algorithms.  However, the compiler is usually smart enough to only put the library members you use in your executable; it's not likely to compile <code>std::copy()</code> into your program if the only member of <code>&lt;algorithm&gt;</code> you use is <code>std::sort()</code>, for example.</p>

<p>C++ may be getting this functionality in the future, however.  One of the things they were looking at for the C++17 standard is modules, which would theoretically allow for functionality similar to what you want (I believe).  While it currently doesn't appear that they'll actually make it into C++17, they may still be released as a Technical Specification, which most major compilers would likely try to incorporate if it's feasible for them to do so.</p>
",0
42493780,42493659,1,"<p>Dont search the map yourself, use the find method. It is a Red-Black Tree so searching it the way you are doing will be costly. Use <a href=""http://en.cppreference.com/w/cpp/container/map/find"" rel=""nofollow noreferrer"">std::map::find</a>.</p>

<pre><code>for (list&lt;string&gt;::iterator it_address= address_list.begin(); it_address != address_list.end(); ++it_address) {

    auto myCommand = command_map.find(*it_address);

    if (myCommand != command_map.end()) {
        cout&lt;&lt;""Addr_""&lt;&lt;myCommand-&gt;first&lt;&lt;"":""&lt;&lt;endl;
        cout&lt;&lt;""         ""&lt;&lt;myCommand-&gt;second&lt;&lt;endl;
    } else {
        cout&lt;&lt;""         ""&lt;&lt; *it_address &lt;&lt;endl;
    }
}
</code></pre>
",2
42569196,42568045,0,"<pre><code>swap(x[i], x[problem5(&amp;x[i], tmpsize, m, n)]);
</code></pre>

<p>should be</p>

<pre><code>problem5(&amp;x[i], tmpsize, m, n);
swap(x[i], x[n]);
</code></pre>

<p>as currently you probably have out of bound access.</p>

<p>I suggest also to rename your variable <code>n</code>, <code>m</code> in <code>problem8</code> into something like <code>smallIndex</code>, <code>smallestValue</code>. to result to something like:</p>

<pre><code>int find_min(const int* arr, int size, int&amp; value, int&amp; index)
{
    int smallest = 101; 
    int smallestindex;
    for (int i = 0; i &lt; size; ++i) {
        if (arr[i] &lt; smallest) {
            smallest = arr[i];
            smallestindex = i;
        }
    }
    value = smallest;
    index = smallestindex;
    return n; 
}

int problem5(int* arr, int size, int&amp; m, int&amp; n)
{
    int res = find_min(arr, size, m, n)
    std::cout &lt;&lt; ""Smallest value is ""&lt;&lt; m &lt;&lt; std::endl;
    std::cout &lt;&lt; ""It's index is "" &lt;&lt; n &lt;&lt; std::endl;
    return res;
}

void selection_sort(int* x, int size)
{
    int value = 101;
    int index = 101;
    int tmpsize = size;

    for(int i = 0; i&lt;size; i++) {
        problem5(&amp;x[i], tmpsize, value, index);
        swap(x[i], x[index]);
        tmpsize = tmpsize - 1;
    }
}

void problem8(int* x, int size){
    problem4(x, 20); // better name ?
    selection_sort(x, size);
}
</code></pre>
",2
35293186,35293043,0,"<p>The problem with this sort of approach is that the rejection rate of random numbers will increase steadily as the algorithm progresses.</p>

<p>A better approach is to <em>shuffle</em> the input coordinates, and subsequent to that, read the shuffled set in order.</p>

<p>Use <code>std::random_shuffle</code> to do that.</p>
",2
40544400,40544188,1,"<p>First of all, add <code>_CRT_SECURE_NO_WARNINGS</code> to <code>Preprocessor</code> works for me, if not for you, try other solutions below:</p>

<p><strong>Solution 1:</strong>
Define <code>_CRT_SECURE_NO_WARNINGS</code> at the beginning of your file:</p>

<pre><code>#define _CRT_SECURE_NO_WARNINGS
#include &lt;time.h&gt;
</code></pre>

<p><strong>Solution 2:</strong></p>

<p>Add <code>4996</code> to : </p>

<pre><code>YourProject-&gt;Properties-&gt;Configuration Properties-&gt;C/C++-&gt;Advanced-&gt;Disable Specific Warnings
</code></pre>
",2
40553061,40552972,2,"<p>First off you need to set the iterator to point to an valid element of the map.  When you do </p>

<pre><code>std::map&lt;std::string, std::vector&lt;Object*&gt;&gt;::iterator Class::it;
int size = it-&gt;second.size();
</code></pre>

<p><code>it</code> doesn't point to anything so using it is undefined behavior.  What you can do though is use</p>

<pre><code>std::map&lt;std::string, std::vector&lt;Object*&gt;&gt;::iterator Class::it;
it = cntr.begin();
int size = it-&gt;second.size();
</code></pre>

<p>Which now gives you the size of the first vector in the map.</p>

<p>If you want to get all of the sizes then you will need to iterate through the map.  You can do this with a nice ranged based for loop like</p>

<pre><code>for (const auto &amp; elem : cntr) // get a const reference to each pair
    std::cout &lt;&lt; elem.second.size();
</code></pre>
",2
40553250,40552972,0,"<p>NathanOliver's answer should work if you have C++11. If you don't, you can try this, with a typedef to make the code clear:</p>

<pre><code>typedef std::vector&lt;Object*&gt; MypObjVec;
typedef std::map&lt;std::string, MypObjVec&gt; MyMap;

MyMap::iterator Class::it = cntr.begin();
const MyMap::iterator Class::it_end = cntr.end();

for(; it!=it_end ; ++it)
{
   std::cout&lt;&lt; it-&gt;second.size() &lt;&lt; std::endl;
}
</code></pre>
",0
35279832,35279781,1,"<p>It looks like you're expecting the function <code>makeColors</code> to modify the vectors, but you pass all the arguments by value.  You can change:</p>

<pre><code>void makeColors(std::vector&lt;int&gt; red, std::vector&lt;int&gt; blue, std::vector&lt;int&gt; green)
</code></pre>

<p>to</p>

<pre><code>void makeColors(std::vector&lt;int&gt;&amp; red, std::vector&lt;int&gt;&amp; blue, std::vector&lt;int&gt;&amp; green)
</code></pre>

<p>to pass by reference instead.</p>
",1
40558092,40558022,1,"<p>These statements </p>

<pre><code>IntList* obj1;
IntList* obj2 = obj1;
</code></pre>

<p>do not make any sense. Remove them.</p>

<p>Take into account that the copy assignment operator</p>

<pre><code>IntList&amp; IntList::operator=(const IntList&amp; rhs){
  head = 0;
  tail = 0;
  for(IntNode* i = rhs.head; i != 0; i = i -&gt; next){
    push_back(i-&gt;data);
  }
  IntList* obj1;
  IntList* obj2 = obj1;
  return *obj2;
}
</code></pre>

<p>is invalid. It does not free all previously allocated memory for the list. And it shall return reference to it self. So the last statement shall be</p>

<pre><code>return *this;
</code></pre>

<p>The operator can look the following way</p>

<pre><code>IntList &amp; IntList::operator =( const IntList &amp;rhs )
{
    while ( head )
    {
        IntNode *tmp = head;
        head = head-&gt;next;
        delete tmp;
    }

    tail = head;

    for ( IntNode* i = rhs.head; i != 0; i = i -&gt; next )
    {
        push_back( i-&gt;data );
    }

    return *this;
}
</code></pre>
",0
40558109,40558022,0,"<p>You should replace the two lines containing <code>obj1</code> and <code>obj2</code> in the assignment operator function with <code>return *this;</code>. The two lines containing <code>obj1</code> and <code>obj2</code> are not needed in the copy constructor. </p>
",0
40558126,40558022,0,"<p>The following has no use in the code. It is pointless. </p>

<pre><code>IntList* obj1; 
IntList* obj2 = obj1;
</code></pre>

<p>Also, it looks to be that you're copying the list but you're not actually assigning the head node to some pointer. So when the function is over, you lose the copied list. </p>
",6
34891003,34890965,2,"<p>max and min are <strong>uninitialized</strong>. In C++, this means the values can be anything at all, unless in say Java where primitives are auto-initialized to 0.</p>

<p>One way to fix is to set a first flag, and set max and min the the first value entered.</p>

<pre><code>bool first = true;
for (int x=0; x &lt; qty; x++)
{
    cin &gt;&gt; input;

    if( first )
    {
        max = input;
        min = input;
        first = false;
    }
    if (input &gt; max)
        max = input;

    if (input &lt; min)
        min = input;

}
</code></pre>

<p>Here's what I mean by <strong>uninitialized</strong>. When starting up, min and max can be anything. Anything at all. Try it by printing out the value of min and max before your loop. It should (could) be different every time you run the program. Basically the value depends on what data was in that memory location the last time it was used. </p>

<p>So the <code>if( input &gt; max)</code> is checking to see if input is greater than some random number between -2billion and 2 billion. (not useful). The <code>first</code> flag I put in there initializes <code>min</code>/<code>max</code> in the first iteration of the for loop, or the first value entered by the user, which is guaranteed to be both the min and the max of the entered value since it's the only entered value. </p>
",8
40567529,40567368,3,"<p>The <code>getchar()</code> is consument by the cin input and it does nothing.</p>

<p>Substitute getchar() for</p>

<pre><code>char t;
cin&gt;&gt;t;
</code></pre>
",0
40567546,40567368,1,"<p>The cout is executed, but the console is closed as the program ended.</p>

<p>To prevent this add</p>

<pre><code>system(""PAUSE"")
</code></pre>

<p>before the <code>return 0;</code>, this way, the console will be in pause, and you will be able to read the output.</p>
",0
40567686,40567368,0,"<p>You forget insert the variable with <em>number of people</em> and the <em>expression for compute the average age</em>. So you lines 22 and 23 should be</p>

<pre><code>cout &lt;&lt; ""the number of people entered is: "" &lt;&lt; numberOfPeopleEntered &lt;&lt; endl;
cout &lt;&lt; ""the average age is: "" &lt;&lt; (float) ageTotal / numberOfPeopleEntered &lt;&lt; endl;
</code></pre>
",1
34899309,34899104,2,"<pre><code>void get_choice()
{
    display_menu();
    do
    {

        cout &lt;&lt; ""\n\n\t\t\t\tEnter Number [1-5] : "";
        cin &gt;&gt; choice;
        menu_selection(choice);
    } while 
        (choice &lt; 1 || choice &gt; 5); // &lt;&lt; and &gt;&gt; aren't for comparison
        cin.ignore();

}
</code></pre>
",1
34899346,34899104,2,"<p>In your <code>get_choice</code> function, you have a <code>do-while</code> loop with the following condition:</p>

<pre><code>while (choice &lt;&lt; 1 || choice &gt;&gt; 5); // this is going to run for a bit
</code></pre>

<p><code>&lt;&lt;</code> and <code>&gt;&gt;</code> are not comparison operators; rather, they are <a href=""http://en.cppreference.com/w/cpp/language/operator_arithmetic#Bitwise_shift_operators"" rel=""nofollow"">bit shift operators</a>.</p>

<p>Because your choice can be shifted either left or right, it goes into an infinite loop. It's a simple fix, really - change them to comparison operators!</p>

<p>As for the customer name, if there are spaces or newlines, <code>std::cin</code> will stop reading at the first one. Be sure to use <code>std::getline</code> for reading strings from stdin.</p>

<p>In <code>open_account</code>, replace this:</p>

<pre><code>cin &gt;&gt; customer_name;
</code></pre>

<p>with this:</p>

<pre><code>std::getline(cin, customer_name);
</code></pre>

<p>Also, fix this line:</p>

<pre><code>int interest = 1.67; // This should be a double
</code></pre>

<p>You shouldn't be using globals really, but that's a whole different story.</p>
",3
34912240,34912185,3,"<p>In your main, it should be <code>main_savitch_2A::throttle throt1(5, 0);</code>.<br/>
The same for <code>throt2</code>.</p>

<p>See <a href=""http://en.cppreference.com/w/cpp/language/namespace"" rel=""nofollow"">namespaces</a> for further details.</p>
",1
48014251,48014146,11,"<p>A common pattern you find in bad code is the usage of explicit template arguments in function templates which would otherwise perform template argument deduction, e.g.</p>

<pre><code>std::make_pair&lt;int,std::string&gt;(1729, ""Hello World!"");
</code></pre>

<p>This is superfluous and in this case the explicit type for the second argument is even different from the type that would have been deduced.</p>

<p>To prevent people from doing so, you can just put a variadic bogus template argument in front of the argument which is to be deduced, so that nobody can ever explicitly name those arguments.</p>

<p>The developers apparently chose <code>int&amp;...</code> as the type for the bogus argument but it could have been any other thing (another type as well) and to improve readability of the code they also gave it a name, <code>ExplicitArgumentBarrier</code>, which should make sense now.</p>
",0
48014380,48014146,2,"<p>In a comment, you asked,</p>

<blockquote>
  <p>i dont quite understand - how, according to you, should <code>MakeSpan</code> be called?</p>
</blockquote>

<p>Here's a demonstrative program that does not use <code>MakeSpan</code>.</p>

<pre><code>template &lt;typename ... T, typename T2&gt; void foo(T2 arg) {}

template &lt;int ... N, typename T2&gt; void bar(T2 arg) {}

int main()
{
   foo&lt;int, int&gt;(0);    // T2 is deduced to be int
   foo(0);              // T2 is still deduced to be int
   foo&lt;int, int&gt;(10.5); // T2 is deduced to be double
   foo(10.5);           // T2 is still deduced to be double


   bar&lt;10, 20, 30&gt;(1);   // T2 is deduced to be int
   bar(1);               // T2 is still deduced to be int

   bar&lt;10, 20, 30&gt;(1.2); // T2 is deduced to be double
   bar(1.2);             // T2 is still deduced to be double
}
</code></pre>

<p>A function call that involves <code>MakeSpan</code> would look like:</p>

<pre><code>int a;
int b;
auto s1 = MakeSpan(20);        // T is deduced to be int
auto s1 = MakeSpan&lt;a, b&gt;(20);  // T is still deduced to be int
</code></pre>

<p>All the explicitly specified template parameters are ignored. The type of argument(s) is always deduced.</p>
",1
35203770,35203717,2,"<p>The line of code;</p>

<pre><code>A a = 3;
</code></pre>

<p>Is using <a href=""http://en.cppreference.com/w/cpp/language/copy_initialization"" rel=""nofollow"">copy initialisation</a> to work. For that to work, a copy of <code>A</code> is needed and is duly made. You have two constructors taking an <code>int</code> as an argument (and neither are <code>explicit</code>).</p>

<p>The copy cannot bind to <code>A(A&amp; val)</code> because normal references don't bind to temporary values.</p>

<p>Possible solutions, direct initialisation;</p>

<pre><code> A a { 3 };
</code></pre>

<p>Add or change the copy constructor to a move constructor;</p>

<pre><code>A(A&amp;&amp; val);
</code></pre>

<p>Add a <code>const</code> to the copy constructor (although this is not what you wanted, but it does work);</p>

<pre><code>A(A const&amp; val);
</code></pre>

<hr>

<p><strong>Note</strong> both clang and g++ reject the original code correctly, but <a href=""http://webcompiler.cloudapp.net"" rel=""nofollow"">VC++</a> accepts it.</p>
",4
35203945,35203717,7,"<p>The issue is your copy constructor: <code>A(A&amp; val) { n=val.n; }</code>.</p>

<p>Given this line <code>A a = 3;</code> one possibility is to use <code>A a = A(3)</code> which in turn will use the copy constructor. However, it is against the standard to bind a temporary to non-const. A proper copy constructor will solve the problem.</p>

<h3>Example Code</h3>

<pre><code>#include &lt;iostream&gt;

class A
{
    int n;

public:
    A(int&amp; val) : n(val) { std::cout &lt;&lt; ""A(int&amp;)\n""; }
    A(const int&amp; val=0) : n(val) { std::cout &lt;&lt; ""A(const int&amp;)\n""; }
    A(const A&amp; val) : n(val.n) { std::cout &lt;&lt; ""A(const A&amp;)\n""; }
};

int main()
{
    A a = 3;
    return 0;
}
</code></pre>

<h3>Example Output</h3>

<pre><code>A(const int&amp;)
</code></pre>

<p><a href=""https://ideone.com/Rnto1O"" rel=""nofollow"">Live Example</a></p>

<p><strong>Note:</strong></p>

<ul>
<li>The above code makes proper use of the initialization lists</li>
<li>The output shows the copy constructor is not actually invoked</li>
</ul>
",6
35204034,35203717,2,"<p>In this statement</p>

<pre><code>A a=3;//want to call A::A(const int&amp;)
</code></pre>

<p>there is created a temporary object of type <code>A</code> using constructor</p>

<pre><code>A(const int&amp; val=0){n=val;}
</code></pre>

<p>However a temporary object can be bound to a constant reference. So the compiler need that the copy constructor</p>

<pre><code>A( const A&amp; val){n=val.n;}//work without this constructor
   ^^^^^
</code></pre>

<p>would be at least accessible (even if it will not be called due to the copy constructor elision).
 But the class does not has this constructor and the compiler issues an error.</p>

<p>On the other hand when you comment this constructor then the compiler itself implicitly defines this constructor and the code is compiled.</p>

<p>Take into account that this constructor</p>

<pre><code>A(int&amp; val){val=n;}
            ^^^^^^
</code></pre>

<p>does not make sense.:)</p>
",1
39677091,39676538,0,"<p>Making my comment as an answer:</p>

<p>Do the following two things:</p>

<ol>
<li><p>No need to include <code>student.h</code> in <code>app.cpp</code>, it already gets it via the inclusion of <code>app.h</code></p></li>
<li><p>Do not include <code>app.h</code> in <code>student.h</code></p></li>
</ol>
",0
39676874,39676538,1,"<p><code>student.h</code> includes <code>app.h</code>, but <code>app.h</code> includes <code>student.h</code>.</p>

<p>In your case, you can just remove the <code>#include ""app.h""</code> from <code>student.h</code>, because it is not needed.</p>
",0
35232092,35232042,0,"<p>I am seeing a bug here:</p>

<pre><code>string getMin(int s1, int s2, int s3, int s4, int s5, string n1, string n2, string n3, string n4, string n5) 
{

    float min;
    string minName;
    // Compares each grade to find the min
    min = s1;
    minName = n1;
    if (min &lt;  s2)
    {
        min = s2;
        minName = n2;
    }
    if (min &lt; s3)
    {
        min = s3;
        minName = n3; 
    }
    if (min &lt;   s4);
    { 
        min = s4;
        minName = n4;
    }
    if (min &lt;  s5)
    {
        min = s5;
        minName = n5;
    }
    return minName;

}
</code></pre>

<p>You have to use: <code>&gt;</code> instead <code>&lt;</code></p>
",1
35232178,35232042,1,"<p><code>if (min &lt; s2)</code> and other instances of this is wrong. They should be <code>if (min &gt; s2)</code></p>

<p><code>avg = sum / 2</code> is wrong. Should be <code>avg = sum / 5</code></p>

<p>Also have <code>&lt;&lt; std::endl;</code> or <code>&lt;&lt; ""\n"";</code> at the end of your last <code>cout</code> statement to generate a new line.</p>
",0
35232200,35232042,1,"<p>You have 5 students, You have to calculate average on 5 students:</p>

<pre><code>float CalcAvgClassGrade(int s1, int s2, int s3, int s4, int s5)
{
    float avg, sum;
    // Sum grades, and get avg
    sum = s1 + s2 + s3 + s4 + s5;
    avg = sum / 5;    //math: average on 5 students
    return avg;
}
</code></pre>

<p>In <code>getMin</code> method you compare grades and <code>min</code> wrongly. </p>

<blockquote>
  <p>If any number is less than <code>min</code>, Take that number as new min</p>
</blockquote>

<p>So turn all <code>&lt;</code>s to <code>&gt;</code> in <code>getMin</code> method</p>
",0
35225036,35224621,3,"<p>Currently you're reading into the array, <em>then</em> creating/allocating it. That's backwards.</p>

<p>You'd be better off parsing each line as you read it, ideally. Rather than storing all five gigabytes.</p>
",0
35246867,35246805,0,"<p>Just trying to guess what you want to accomplish.
If you have a 2DArray object, say o, in order to call print, you write</p>

<pre><code>o.print();
</code></pre>

<p>If you have a pointer to a 2DArray object, then it is</p>

<pre><code>p-&gt;print();
</code></pre>

<p>If you are inside a function of the 2DArray class, then it is</p>

<pre><code>print();
</code></pre>
",2
34912797,34912688,-1,"<pre><code>void main() {
char *name[] = {
    ""./program"",
    ""-c"",
    ""foo -u adm -p 123"",
    NULL
};
execvp(name[0], name);
}
</code></pre>
",5
34912821,34912688,-2,"<p>There you go every executable needs a main function which is the entry point for execution.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

void SayHello(string Name)
{
    cout &lt;&lt; "" Hello "" &lt;&lt; Name;
}

int main(int argc, char* argv[])

{

   if (argc &gt; 1) 
      SayHello(argv[1]);

}
</code></pre>

<p>To compile this do </p>

<blockquote>
  <p>$g++ hello.cpp</p>
</blockquote>

<p>It should produce a.out on Linux.</p>

<p>To run it </p>

<blockquote>
  <p>./a.out ""World!""</p>
</blockquote>
",5
34912864,34912688,1,"<p>If you want to call a function of your program based on the arguments, you could do something like:</p>

<pre><code>int main(int argc, char* argv[]) { 
    if(argc &gt; 2){
        if(strcmp(argv[1], ""SayHello"") == 0){
            SayHello(argv[2]);
        }
    }
    return 0; 
}
</code></pre>

<p>Of course this is just a sketch and i can be improved if what you want to achieve is more complex.
You could also build a more dynamic solution if you want other functions than the ""SayHello"" one to be callable too.</p>
",3
34912872,34912688,0,"<p>int main( int argc, char** argv )</p>

<p>Here argc refers to the number of argument (arg count)
argv refers to the argument array (""char*"" array) (arg value)</p>

<p>Calling your program from command line will result in a main entry with these parameters ; it remains to parse them and launch the command accordingly.</p>
",1
34915151,34915112,3,"<p>Move the statement<br/></p>

<pre><code>a = new int[j];
</code></pre>

<p>after</p>

<pre><code>cin&gt;&gt;j;
</code></pre>

<p>You are allocating with ""junk"" as j takes the value whatever in the local stack memory location have!</p>
",1
37760295,37760196,1,"<p>It is not true that in C or C++ we cannot declare a function with two dimensional array parameter with both sizes specified.</p>

<p>See: <a href=""http://c-faq.com/aryptr/pass2dary.html"" rel=""nofollow"">http://c-faq.com/aryptr/pass2dary.html</a></p>

<p>The problem has been correctly explained by @AlanStokes in his comments! </p>
",3
41920802,41920681,0,"<p>What you probably meant to do instead of overloading the <code>new</code> and <code>delete</code> operators for class <code>Array</code>, is to write appropriate constructor and destructor functions:</p>

<pre><code>class Array {
    int *arr;
public:
    Array(size_t size) : arr(new int[size]) {
    }
    ~Array() {
        delete arr;
    }
    // ...
};
</code></pre>
",0
39253726,39243026,0,"<p>I can't post a comment, but this probably is not solution for your problem, but just a guess as I don't see full code. You mentioned that you defined str like:</p>

<pre><code>char* str;
</code></pre>

<p>Then you point the str to an empty memory for """" (i.e. buffer with just 1 byte: \0). Better would be to allocate space for str:</p>

<pre><code>char str[80];   // or whatever size you need
</code></pre>

<p>and instead of</p>

<pre><code>str = """";
</code></pre>

<p>you should just clear the space allocated:</p>

<pre><code>memset(str, 0, sizeof(str));
</code></pre>

<p>Or just use C++ and std::getline() to read from a file stream.</p>
",0
40756558,40755462,2,"<p>Your call to <code>CoCreateInstance()</code> is wrong.  You are passing the CLSID of the <code>SpVoice</code> CoClass where the IID of the <code>ISpVoice</code> interface is expected instead (so it should be failing with an <code>E_NOINTERFACE</code> error).</p>

<p>Try this instead:</p>

<pre><code>CoCreateInstance(CLSID_SpVoice, NULL, CLSCTX_ALL, IID_ISpVoice, (void **)&amp;pVoice);
</code></pre>

<p>Alternatively:</p>

<pre><code>CoCreateInstance(__uuidof(SpVoice), NULL, CLSCTX_ALL, IID_PPV_ARGS(&amp;pVoice));
</code></pre>
",2
37703534,35353469,1,"<p>Firstly u have to correct ur basics of mathematics.</p>

<ol>
<li><p>Calculating %age means
example
(Marks obtained)/(Total marks)*100
Not (Total marks/marks obt)*100</p></li>
<li><p>Dividing any no by 0 is not defined. So if    ur current code randomly assign toss or head =0, then obviously u will have errors.</p></li>
</ol>

<p>Secondly talking about codes, U should either initialize i from 0 , or u should use</p>

<pre><code>for (i=1; i&lt;=userInput; i++)
</code></pre>

<p>As otherwise the head+toss value will be userInput-1.</p>

<p>Also remember to initialise variables like</p>

<pre><code>Int headsCount=0; 
</code></pre>

<p>etc. As the variable will take any random value if not initialised to a fixed no. (Though it does not creates a problem here)</p>

<p>And just change the datatype</p>

<pre><code>int userInput,
    toss,
    headsCount,
    tailsCount;
</code></pre>

<p>To </p>

<pre><code>double userInput,
    toss,
    headsCount,
    tailsCount;
</code></pre>

<p>This will solve your problem.</p>

<p>Advice: Please use </p>

<pre><code>using namespace std; 
</code></pre>

<p>in the starting of ur programs as u have to type a lot of std::</p>
",0
34954904,34954741,1,"<p><code>const</code> of the function argument is part of that function's signature. Thus</p>

<pre><code>void show(const stringy &amp; r1);
</code></pre>

<p>is not the same as</p>

<pre><code>void show(stringy &amp; r1);
</code></pre>

<p>At the compilation of <code>main ()</code> the compiler is aware only of <code>void show(const stringy &amp; r1);</code> but then the linker doesn't find its implementation since you implemented </p>

<pre><code>void show(stringy &amp; r1);
</code></pre>

<p>and not</p>

<pre><code>void show(const stringy &amp; r1);
</code></pre>

<p>The solution is just to add <code>const</code> before <code>stringy &amp; r1</code> at the implementation of <code>show</code>.</p>
",0
34982764,34982056,1,"<p>You can try out something like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

static int counter = 1;    

void init_proc()
{
    pid_t pid;
    pid = fork();
    if(pid==0)
    {
        if(counter==10)
        {
            return;
        }
        else
        {
            counter++;
            init_proc();
        }
    }
    else if(pid &gt; 0)
    {
        int status;
        waitpid(pid, &amp;status, WNOHANG);
        printf(""Process %d with child %d\n"", getpid(), pid);
    }
    else
    {
        fprintf(stderr,""Error: Could not initialize process\n"");
    }
}    

int main ()
{
     init_proc();
     return 0;
}
</code></pre>

<p>Notice that <code>pid != 0</code> doesn't necessarily mean that you are in the parrent process. If <code>fork()</code> returns -1 it means there was an error. More info about this here: <a href=""http://linux.die.net/man/2/fork"" rel=""nofollow"">http://linux.die.net/man/2/fork</a> .</p>

<p>In my example i didn't use the printf's you wanted but you can play with it a little to get the results you want.</p>
",5
40780338,40779982,2,"<p>This is called copy constructor. When you want to initialize a class instance by copying an existing instance, you'd probably want to use it. </p>

<p>const - you don't want to change the object you are copying.</p>

<p>reference - you don't want to copy the existing instance into the constructor, just to copy it again in the initialization. </p>
",0
34993507,34993210,0,"<p>I solved it, add &amp; behind cl::Buffer, like this:</p>

<pre><code>m_kernel.setArg(10, (cl::Buffer&amp;)_img_src);
</code></pre>

<p>But I still don't know why it work well on visual studio.</p>
",0
34993668,34993210,0,"<p>Thanks to the information you provided in your answer, I think I know what the problem is.</p>

<p><code>m_kernel</code>'s <code>setArg</code> most probably takes its argument by reference (i.e a <code>cl::Buffer&amp;</code>).</p>

<p>A cast to a value type copy-constructs a temporary of that type. However, a temporary can't bind to a non-const reference, so you can't pass it to <code>setArg</code>.</p>

<p>Moreover, <code>setArgs</code> probably has two more overloads, both of which could be called by an implicit conversion of that temporary to their parameter's type. But as both functions are equally valid, overload resolution fails with an ""ambiguous call"" error.</p>

<p>Casting to a reference type yields a reference, and so the first overload is an exact match, no problem here.</p>

<p>The reason it works with MSVC is that it enables by default an extension that <em>does</em> allow non-<code>const</code> references to bind to temporaries. Thus the first overload, which wasn't compatible before, is now selected as an exact match, before the others.</p>
",2
40983922,40983787,0,"<p>The problem is that you are newing an array and you are newing all students in the array. you made a <code>new Student*[]</code> and some <code>new Student</code>, but you only <code>delete[] arr</code>, you forgot to <code>delete x</code></p>

<p>Before the fix, I want to suggest you to use vector and unique_ptr, which would have prevent all your error in the first place:</p>

<pre><code>std::vector&lt;std::unique_ptr&lt;Student&gt;&gt; roster;

int num;
cout &lt;&lt; ""how many?"";
cin &gt;&gt; num;
roster.reserve(num);

std::string l,f,c;

for (int i = 0; i &lt; num; i++){
  cout &lt;&lt; ""\nenter last, first, course: "";
  getline(cin, l);
  getline(cin, f);
  getline(cin, c);

  roster.emplace_back(std::make_unique&lt;Student&gt;(l, f, c));
  roster.back()-&gt;showInfo();
}
</code></pre>

<hr>

<p>Now, the solution for your code. You should put that at the end of your code:</p>

<pre><code>for (int i = 0; i &lt; num; i++){
    delete roster[i];
}
delete [] roster;
</code></pre>
",1
43978800,43978640,6,"<p>In general, one should avoid using <code>static</code> when the only goal is to save CPU cycles.</p>

<p>Making <code>coords</code> static renders your <code>map_coord_to_chunk_coord</code> function <a href=""https://en.wikipedia.org/wiki/Reentrancy_(computing)"" rel=""noreferrer""><em>non-reentrant</em></a>, meaning that it is no longer usable in concurrent environments without proper synchronization. This is a very high price to pay for saving a construction cost of a simple object.</p>

<p>For example, you should be able to optimize construction of <code>std::pair</code> by using <code>make_pair</code>:</p>

<pre><code>inline std::pair&lt;sf::Vector2i, sf::Vector2i&gt; 
Map::map_coord_to_chunk_coord(int x, int y) {
    int first_x = x / CHUNK_SIZE;
    int first_y = y / CHUNK_SIZE;
    return std::make_pair(
        sf::Vector2i(first_x, first_y)
    ,   sf::Vector2i(x - first_x * CHUNK_SIZE, y - first_y * CHUNK_SIZE)
    );
}
</code></pre>

<p>In certain cases the compiler <a href=""https://en.wikipedia.org/wiki/Return_value_optimization"" rel=""noreferrer"">can even optimize out the copying</a>, further improving performance.</p>
",2
43979463,43978640,1,"<p>No.</p>

<p>You have to copy it anyway (return by value!), so you gained nothing.</p>

<p>(You actually <em>added</em> precisely one construction.)</p>

<p>All you achieved was making your function non-reentrant, which is a step backwards.</p>
",0
43980599,43978640,2,"<p>As others have pointed out you should generally avoid using local static variables in this way as it makes the code non thread safe.</p>

<p>Generally, the most idiomatic C++ is to rely on return-value-optimization and other compiler optimizations. I'd be surprised (and a little envious) if construction of a <code>std::pair</code> of <code>sf::Vector2i</code> was the bottleneck in your code but if this really is the critical piece of your code you could be slightly less idiomatic and pass-by-reference instead of using a return value:</p>

<pre><code>void
map_coord_to_chunk_coord(int x, int y, std::pair&lt;Vector2i, Vector2i&gt;&amp; chunk_coord) {
    chunk_coord.first.x = x / CHUNK_SIZE;
    chunk_coord.first.y = y / CHUNK_SIZE;
    chunk_coord.second.x = x % CHUNK_SIZE;
    chunk_coord.second.y = y % CHUNK_SIZE;
}
</code></pre>

<p>Then the caller can re-use a <code>chunk_coord</code> variable within a tight loop and you have no constructions of <code>std::pair</code> or <code>sf::Vector2i</code>.</p>
",0
38190571,38190196,6,"<p>From what I'm seeing, the <code>toString</code> and <code>toString0</code> are both static methods of <code>TreeNode</code> and not <code>Parser</code>. Try calling them like so: <code>Parser::TreeNode::toString</code>.</p>
",0
36236409,36236268,1,"<p>I assume you want the third word from the given string.</p>

<p>You have find the second space, but your output is the sub-string from the second space to the end of the string.</p>

<p>Instead, you need to find the third space, and output the sub-string between the two spaces.</p>

<p>So here is the modification.</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    const std::string str = ""System-&gt;ONDRASHEK: Nick aaasssddd nen¨ª v ?¨¢dn¨¦        m¨ªstnosti"";

    size_t pos = str.find("" "");
    size_t start;
    size_t end;
    if (pos == std::string::npos)
        return -1;

    pos = str.find("" "", pos + 1);
    if (pos == std::string::npos)
        return -1;

    start = pos + 1;

    pos = str.find("" "", pos + 1);
    if (pos == std::string::npos)
        return -1;

    end = pos;

    std::cout &lt;&lt; str.substr(start, end - start) &lt;&lt; std::endl;
}
</code></pre>
",1
36236427,36236268,0,"<p>please elaborate you question? you need substring between 2 white spaces ? if I am true, find first whitespace and then print string until you find another whitespace. you can use characters for that</p>
",0
40959187,40861563,7,"<p>Suppose you have the following files in the directory in which you are running the program:</p>

<p><a href=""https://i.stack.imgur.com/2EACO.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/2EACO.png"" alt=""File List""></a></p>

<p>Then, the following code will serve your job:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

using namespace std;

int main() {
    cout &lt;&lt; ""Intro To C"" &lt;&lt; endl;
    cout &lt;&lt; ""Intro To C++"" &lt;&lt; endl;
    cout &lt;&lt; ""Intro To Java"" &lt;&lt; endl;

    string topicName;

    cout &lt;&lt; ""\t\tWhich Topic You Want to edit: "";
    getline(cin, topicName);

    topicName = ""notepad \"""" + topicName + ""\"""";

    system(topicName.c_str());
    return 0;
}
</code></pre>

<p>Then upon running, we get the following output:</p>

<pre><code>Intro To C
Intro To C++
Intro To Java
        Which Topic You Want to edit: Intro To Java
</code></pre>

<p>Upon typing this, the file will be opened in notepad if you are running it in a Windows system. Please change your program accordingly if you are using a different operating system.</p>

<p><a href=""https://i.stack.imgur.com/sB27P.png"" rel=""noreferrer""><img src=""https://i.stack.imgur.com/sB27P.png"" alt=""Output""></a></p>
",0
38194824,38194163,0,"<p>One mistake is this in your <code>calculateAmountEarnedByPlaying</code> function:</p>

<p><code>double won;</code></p>

<p>You did not initialize this variable, thus it contains an indeterminate value.  </p>

<p>It is only set if you've won something, but not set if you didn't win.  You then do this at the end of your function:</p>

<p><code>total = (total + won);</code>  </p>

<p>If <code>won</code> is not initialized, then <code>total</code> will also be set to an indeterminate value (or undefined behavior occurs).</p>

<p>The <code>won</code> variable should be initialized to <code>0</code>:</p>

<p><code>double won = 0;</code></p>

<p>Most compilers give a warning if you access an uninitialized variable like this.  Please check that you have your warnings on to detect these issues.</p>

<hr>

<p>The other issue is that you forgot a <code>break</code> in your switch statements:</p>

<pre><code>switch (slot1)
{    
    case 1:
        cout &lt;&lt; ""You got "" &lt;&lt; cherries &lt;&lt; endl;  // no break statement
    case 2:
        cout &lt;&lt; ""You got "" &lt;&lt; oranges &lt;&lt; endl;
    break;
</code></pre>

<p>If <code>slot1</code> is <code>1</code>, it will print both sets of output for case 1 and case 2.</p>

<p>None of this would be necessary if you used arrays instead of 6 separate variables and 6 separate lines of output:</p>

<pre><code>   std::string slot_items[] = {""cherries"", ""oranges"", ""plums"", ""bells"", ""melons"", ""bars""};
   //...
   int slots[3];
   //...
   for (int i = 0; i &lt; 3; ++i)
      slots[i] = rand()%6+1;
   //...
   // inside the function...
   //...
   for (int i = 0; i &lt; 3; ++i)
      cout &lt;&lt; ""You got "" &lt;&lt; slot_items[slots[i]] &lt;&lt; endl;
</code></pre>

<p>A two line <code>for</code> loop replaces 60 lines of <code>switch</code> and case statements.</p>
",3
35211303,35211030,0,"<p>Make a class out of it and implement the == operator:</p>

<pre><code>class Fraction{

  int num;
  int den;

  Fraction(int n, int d){
    //probably a good idea to find a better reduce-algorithm here
    //maybe with http://en.cppreference.com/w/cpp/experimental/gcd ?
  }

  bool operator==(Fraction&amp; other){
    //comparing fractions might be inexact for floats.
    //return (1.*num)/den == (1.*other.num)/other.den;

    //this one on the opposite relies on a working reduction in the constructor
    return (num==other.num) &amp;&amp; (den==other.den);
  }

}
</code></pre>

<p>you can then store instances of this inside a <code>std::unordered_set&lt;Fraction&gt;</code> and later check if an equal element is already present. Or just fill a set with the instances you want to use and then use them in a second loop after you filled the set.</p>

<p>Using a class also provides the benefit, that you can implement addition, multiplication and so on inside your class by just overloading the corresponding operators.</p>
",6
41649742,41649718,1,"<p>You're not updating the value of <code>temp</code> after every iteration</p>

<pre><code>int n, temp;
cout &lt;&lt; ""Please enter number: "";
cin &gt;&gt; n;
bool ascending = true;
temp = n%10;

while (n / 10 &gt; 0)
{
    n /= 10;
    if (temp &gt; n % 10)
    {
        ascending = false;
        break;
    }
    temp = n % 10;
}

if (ascending)
{
    cout &lt;&lt; ""Number is ascending"";
}
else {
    cout &lt;&lt; ""Number is not ascending"";
}
</code></pre>
",6
41650404,41649718,1,"<p>When I run the latest from Thirupathi, it does work.  Note OP said ascending order <strong>RIGHT to LEFT</strong>.</p>

<p>Ex output runs:</p>

<pre><code>./order
Please enter number: 5321
Number is ascending

./order
Please enter number: 2356
Number is not ascending
</code></pre>
",1
35301437,35301395,2,"<p>Your constructor is</p>

<pre><code>Student::Student (char *fname, char *lname, int age, double marks)
                                                     ^^^^^^^^^^^^
</code></pre>

<p>But you are trying to pass an array to it in</p>

<pre><code>double marks[3];
//...
Student st1(fname, lname, age, marks);
</code></pre>

<p>You either need to get rid of the array in the class and just take a double or change the constructor to take a double array and then copy it in the constructor like</p>

<pre><code>Student::Student (char *fname, char *lname, int age, const double (&amp;marks)[3]) {
//                                                   ^^^^^^^^^^^^^^^ use array of size 3 
//                                                   since that is what _marks is
    strcpy(_fname, fname);
    strcpy(_lname, lname);
    _age = age;

    for (int i =  0; i &lt; 3; i++)
    _marks[i] = marks[i];
}   
</code></pre>
",7
38854409,38854321,1,"<p>That's essentially because you're trying to add a <code>char[]</code> array literal to a <code>char*</code> type: the compiler will not like that since the types don't match.</p>

<p>Writing <code>(std::string(""c:\\adb install "") + argv[1]).c_str()</code> to concatenate your strings will fix it. This relies on <em>operator overloading</em> of <code>+</code> to a <code>std::string</code>, and <code>c_str()</code> extracts the character buffer. So, in full:</p>

<p><code>FILE* lsofFile_p = popen((std::string(""c:\\adb install "") + argv[1]).c_str(), ""r"");</code></p>

<p>Do check the value of <code>argc</code> though before reading that element of <code>argv</code>.</p>
",4
35199666,35199622,0,"<p>It means the compiler can't find the function, and that's because you didn't <code>#include &lt;cstring&gt;</code>.</p>
",3
36247736,36208982,0,"<p>Creating a whole copy of the board on each call would use a lot of memory. I think you can avoid it by having Knights_tour return a bool which is true when a solution is found. The return value can be used when you unwind the stack to decide on if you should unset board[x][y].</p>

<pre><code>if(!Knights_tour((valid_x[i]+x), (valid_y[i]+y), move_count))
{
    board[x][y] = 0;
}
</code></pre>
",0
46660212,46660127,2,"<p>You are never going back to zero.</p>

<pre><code>int count = 0;
//...  
while(cin &gt;&gt; x)
{
    homework.push_back(x);
    ++count;
    if(count == 0)  //count will never be zero
</code></pre>
",0
39645552,39645263,0,"<p>The following gives warnings about possible loss of data when converting between <code>int</code> and <code>float</code> but it demonstrates how you can pass the variable as one type and work with it in the function as another:</p>

<pre><code>float some_function(int some_argument) {
    // Do stuff
    return some_argument;
}

int main()
{
    float oldval = 3;
    float newval = some_function(oldval);
    return 0;
}
</code></pre>
",3
39645429,39645263,1,"<blockquote>
  <p>Is there some way to do this?</p>
</blockquote>

<p>You can create a new scope and define a new variable of the same name which shadows the name of the function argument.</p>

<pre><code>void some_function(int some_argument) {
   {
      float some_argument = 0;
      // Do stuff
   }
}
</code></pre>

<p>However, you cannot use:</p>

<pre><code>void some_function(int some_argument) {
   {
      float some_argument = (float)some_argument;
      // Do stuff
   }
}
</code></pre>

<p>In the second case, the initialization does not use the function argument to initialize the shadowing variable. It is as bad as</p>

<pre><code>int i = i;
</code></pre>

<p>Avoid all these hassles by:</p>

<ol>
<li><p>Using different names for the variable and the argument.</p>

<pre><code>void some_function(int some_argument_in) {
   float some_argument = (float)some_argument_in;
   // Do stuff
}
</code></pre></li>
<li><p>Using a function overload.</p>

<pre><code>void some_function(float some_argument) {
   // Do stuff
}

void some_function(int some_argument) {
   some_function((float)some_argument);
}
</code></pre></li>
</ol>
",1
38288825,38288739,1,"<p>the problem is you assigne 10 to x, so
<code> (x=10) == true </code></p>
",0
38288852,38288739,1,"<p><strong>I have tried to fix it, and I made it count to 10, atleast.</strong>
Here's my code:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() {
for (int x = 0; x &lt;= 10; x += 2) {
    cout &lt;&lt; x &lt;&lt; endl;
    if (x == 20) {
        cout &lt;&lt; ""hello world"" &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; ""hello darkness my old friend"" &lt;&lt; endl;
    }
}
return 0;
}
</code></pre>

<p>Here's the output:</p>

<pre><code>0
hello darkness my old friend
2
hello darkness my old friend
4
hello darkness my old friend
6
hello darkness my old friend
8
hello darkness my old friend
10
hello darkness my old friend
</code></pre>

<p>Is this the result you needed?</p>
",1
38288855,38288739,2,"<pre><code>#include &lt;iostream&gt; 
using namespace std;
int main() {
    for (int x = 0; x &lt;= 20; x += 2) 
    {
        cout &lt;&lt; x &lt;&lt; endl;
        if (x == 10) 
        {
            cout &lt;&lt; ""hello world"" &lt;&lt; endl;
        }
        else if(x &gt; 10)
        {
            cout &lt;&lt; ""hello darkness my old friend"" &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>

<p>I think this is what you want; I increased your loop limit to 20, fixed the comparison issue with <code>if(x ==10)</code> and I added and else <code>if(x &gt; 10)</code> to take care of numbers greater than 10. Hope that helps!</p>
",0
38288776,38288739,1,"<p>Besides the assignment/comparison issue, you loop will never reach any higher number than <code>10</code>, because that's when the loop condition says that the loop will end.</p>

<p>The statement <code>for (int x = 0; x &lt;= 10; x += 2)</code> says to define and initialize <code>i</code> to <code>0</code>, loop while <code>x &lt;= 10</code> is true, and after each iteration increase <code>x</code> by <code>2</code>. It is basically the same as this:</p>

<pre><code>{
    int x = 0;
    while (x &lt;= 10)
    {
        // Your code inside the loop
        x += 2;
    }
}
</code></pre>

<p>So you loop will have the following value for <code>x</code>: <code>0</code>, <code>2</code>, <code>4</code>, <code>6</code>, <code>8</code>, <code>10</code> and then after that <code>x &lt;= 10</code> is false and the loop will end.</p>

<hr>

<p>Coming back to the assignment/comparison issue, this is the reason some people like to write e.g. <code>20 == x</code> instead of <code>x == 20</code>. If by mistake assignment is used instead of comparison then the expression would be <code>20 = x</code> which is not a valid expression and the compiler would generate an error.</p>

<p>Most compilers today will be able to detect the assignment <code>x = 20</code> when used as a condition and can generate a warning for that. You might want to enable a higher warning level for the compiler to tell you about it.</p>
",0
38288806,38288739,0,"<p>Try this</p>

<pre><code>#include &lt;iostream&gt; 
using namespace std;
int main() 
{
    for (int x = 0; x &lt;= 10; x += 2) 
    {
        cout &lt;&lt; x &lt;&lt; endl;
        if (x == 10)
            cout &lt;&lt; ""hello world"" &lt;&lt; endl;
        else 
            cout &lt;&lt; ""hello darkness my old friend"" &lt;&lt; endl;

    }
    return 0;
}
</code></pre>
",5
38290064,38288739,2,"<p>I Guess that's what you're looking for:-  </p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() {
    int num;
    cin&gt;&gt;num;
    //num taken from user
    if(num%2==0) {
        for (int x = 0; x &lt;= num; x += 2) {
            cout &lt;&lt; x &lt;&lt; endl;
        }
        cout&lt;&lt;""Hello World"" &lt;&lt;endl;
    } else {
        cout &lt;&lt; ""hello darkness my old friend"" &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<blockquote>
  <p>Output will be like:-</p>
</blockquote>

<pre><code>let num=12;   //entered by USER 

0
2
4
6
8
10
12
Hello World

// In Case of False Condition

hello darkness my old friend  
</code></pre>
",2
35237493,35237435,1,"<p>You need to actually call function1, for example:</p>

<pre><code>while (true)
{
    cout &lt;&lt; ""Enter Integer "" &lt;&lt; endl;
    cin &gt;&gt; integer;
    function1();
    cout &lt;&lt; roman &lt;&lt; endl;
    cout &lt;&lt; ""convert another (y/n)? "" &lt;&lt; endl;
    cin &gt;&gt; answer;
    if (answer == 'n' || answer == 'N')
        break;
}
</code></pre>
",1
36238946,36238859,2,"<p>To get the length of an array in c++ you can use:</p>

<pre><code>int length = sizeof(a) / sizeof(a[0]);
</code></pre>

<p>Array is not an object in c++ thus it cannot have fields.</p>
",0
36238964,36238859,3,"<p>You are using an array. It is a primitive type. So there are not member functions on it like objects. You have to use a vector instead.  You also have to initialize the vector (or array) with chars not strings.</p>

<pre><code>int main()
{
    std::vector&lt;char&gt; a = {'H', 'e', 'l', 'l', 'o'};
    for (int i = 0; i &lt; a.size (); i++)
    {
        std::cout &lt;&lt; a[i];
    }
}
</code></pre>

<p>If you really want to use an array you have to define the size function as follow:</p>

<pre><code>template&lt;class T, size_t N&gt;
constexpr size_t size (T (&amp;)[N]) { return N; }

int main()
{
    char a[] = {'H', 'e', 'l', 'l', 'o'};
    for (int i = 0; i &lt; size (a); i++)
    {
        std::cout &lt;&lt; a[i];
        //I also tried printf with stdlib.h
    }
}
</code></pre>
",0
36238997,36238859,1,"<p>You can't do that. You can get the size of an array <code>a</code> using:</p>

<pre><code>   sizeof(a)/sizeof(a[0]);
</code></pre>

<p>But since you are in C++ you should use an <code>std::vector</code> like this:</p>

<pre><code>  std::vector&lt;char&gt; a;
</code></pre>

<p>And then get the size:</p>

<pre><code> a.size();
</code></pre>
",0
36239007,36238859,2,"<p>Plain arrays define no functions but you can use the library <code>begin</code> and <code>end</code> functions introduced with c++11:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    char a[] = { 'H', 'e', 'l', 'l', 'o' };  // use chars instead of strings
    for (auto it = std::begin(a); it != std::end(a); ++it)  // use iterators
    {
        std::cout &lt;&lt; *it;
    }
}
</code></pre>

<p><a href=""https://ideone.com/7Hf2vC"" rel=""nofollow"">Run on ideone.</a></p>

<p>Or even shorter using a range for as pointed out by BarryTheHatchet:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    char a[] = { 'H', 'e', 'l', 'l', 'o' };
    for (auto c : a)
    {
        std::cout &lt;&lt; c;
    }
}
</code></pre>

<p><a href=""https://ideone.com/3tUMVn"" rel=""nofollow"">Run on ideone.</a></p>

<p>Keep in mind that the list initialization as above doesn't include a NULL char. If you declare your array with a NULL char at the end you can use cout directly without for loop:</p>

<pre><code>char a[] = { 'H', 'e', 'l', 'l', 'o', '\0' };  // explicit NULL with list initialization
std::cout &lt;&lt; a;

char b[] = ""Hello"";  // implicit NULL when using a literal
std::cout &lt;&lt; b;
</code></pre>
",1
36239048,36238859,0,"<p>Here a is a character array.. It doesn't have any member called <code>""length""</code>..This member is found in Java not C++. For this problem you can use <code>""sizeof()"" function</code> function.</p>
",0
41197952,41197832,24,"<p>The correct terminology would be ""static nested class"".</p>

<p>Static nested classes in Java are like normal nested classes in C++, so just drop the <code>static</code> and it should work fine.</p>

<p><em>Non-static</em> ones like in Java would be a bit harder to emulate in C++, because there is no compiler magic to automatically provide the context of the outer class. You would have to work around the issue by storing a reference to the outer class in the inner class, initialising it in the constructor of the inner class, and accessing members of the outer class explicitly via the reference.</p>
",4
41698945,41698886,5,"<p><code>++a</code> increases the value of <code>a</code> by one and is an expression that equals that incremented value.</p>

<ol>
<li><p>When <code>a</code> is 5, <code>if (a)</code> is <code>if (true)</code> as <code>a</code> is non-zero. So <code>printf(""if %d\n"" , ++a);</code> runs, the <code>++a</code> in that statement increments <code>a</code> and evaluates to that incremented value, 6.</p></li>
<li><p>When <code>a</code> is 0, <code>if (a)</code> is <code>if (false)</code>. So <code>printf(""else %d\n"" , a);</code> runs. <code>a</code> is not changed in that case.</p></li>
</ol>
",10
41699524,41698886,1,"<p>I believe what is going on is confusion understanding whats happening with the if statement.</p>
<pre><code>int main() {
    int a =5;
    if(a)
    {
        printf(&quot;if %d\n&quot; , ++a);
    }
    else
        printf(&quot;else %d\n&quot; , a);
    return 0;
}
</code></pre>
<p>This code is essentially equivalent to:</p>
<pre><code>int main() {
    int a =5;
    printf(&quot;if %d\n&quot; , ++a);
    return 0;
}
</code></pre>
<blockquote>
<p>output: 6</p>
</blockquote>
<p>If a was 0 the code would be equivalent to:</p>
<pre><code>int main() {
    int a =0;
    printf(&quot;else %d\n&quot; , a);  // Notice no ++
    return 0;
}
</code></pre>
<blockquote>
<p>output: 0</p>
</blockquote>
<p>If you were to write the code as:</p>
<pre><code>int main() {
    int a =5;
    printf(&quot;if %d\n&quot; , a);  // Notice no ++
    return 0;
}
</code></pre>
<blockquote>
<p>output: 5</p>
</blockquote>
<p><code>if</code> Will evalute the value stored in the parenthesis so for example:</p>
<pre><code>int a = 0;
if(a)  // since a is 0, the value equates to false and the if is ignored
{

}
else // since the if evaluated to false it will do the else.
{
 
}
</code></pre>
<p>In the instance of:</p>
<pre><code>int a = 5;
if(a) // a is non-zero therefore it equates to true, and the if body is ran
{

}
else // since the if was true the else is ignored, and its body wont be run.
{
 
}
</code></pre>
<p>Now lets breakdown why in your case a = 5 was printing out 6.</p>
<p>In c++, there are operators called <code>postfix</code> and <code>prefix</code> operators, postfix operators will run after the statement whereas prefix operators will run before the statement.</p>
<p>These operators will directly affect the value.</p>
<blockquote>
<p>++a - prefix operator, gets resolved before your printf and retrieves the value.</p>
<p>a++ - postfix operator, retrieves the value and then gets resolved after your printf</p>
<p>a - no operator just retrieves the value.</p>
</blockquote>
<p>You can learn more about these operators here:
<a href=""http://en.cppreference.com/w/cpp/language/operator_incdec"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/language/operator_incdec</a></p>
<p>Bathsheba, answer is 100% correct.  Posted this answer to try and attempt to further your understanding, and anyone else who comes here with the same issues.</p>
",1
41699765,41698886,0,"<p>Here is your code modified slightly to show the two cases you are asking about.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
using namespace std;

int main() {
    int a;

    a = 5;
    if(a)   // check whether a is zero (false) or non-zero (true)
    {
        // variable a has a non-zero value (true)
        printf(""if %d\n"" , ++a);  // preincrement variable a then print value
    }
    else {
        // variable a has a value of zero (false)
        printf(""else %d\n"" , a);  // print value as it is
    }

    a = 0;
    if(a)   // check whether a is zero (false) or non-zero (true)
    {
        // variable a has a non-zero value (true)
        printf(""if %d\n"" , ++a);  // preincrement variable a then print value
    }
    else {
        // variable a has a value of zero (false)
        printf(""else %d\n"" , a);  // print value as it is
    }

    return 0;
}
</code></pre>

<p>There is a difference between preincrement of a variable, using ++a, and postincrement of a variable, using a++.</p>

<p>Preincrement, the ++a, increments the value of the variable and makes the new value available for the next operator or action.</p>

<p>Postincrement, the a++, makes the current value of the variable available for the next operator or action and then increments the variable.</p>

<p>So look at the following code.</p>

<pre><code>int  a;
int  b;

a = 5;
b = a;    // straight assignment, no increment, b now contains 5.
b = a++;  // postincrement a, do assignment, b now contains 5, a contains 6
b = ++a;  // preincrement a, do assignment, b now contains 7, a contains 7
</code></pre>

<p>Now in your code you first assign a value of 5 to the variable <code>a</code>. When you do the <code>if</code> you check to see if <code>a</code> is true (value is non-zero) or false (value is zero). Since <code>a</code> equals 5, value is non-zero, then it takes the <code>then</code> path.</p>

<p>When it does the <code>printf()</code> the value of <code>a</code> is modified using a preincrement. This means that the value of <code>a</code> is first incremented and then the new value of <code>a</code> is used in the <code>printf()</code>. So you print the value of the preincremented variable <code>a</code> which is 6 printing ""if 6"".</p>

<p>If you had used a postincrement then the old value of <code>a</code> would have been used in the printf()` printing ""if 5"".</p>

<p>Next you set the value of the variable <code>a</code> to zero. The if checks whether <code>a</code> is true, non-zero, or false, zero, and since <code>a</code> is now zero or false the path taken is the <code>else</code>. In this <code>printf()</code> you are just printing the value of the variable <code>a</code> so you see ""else 0"".</p>
",1
40983914,40983870,2,"<p>Yes, there is. <a href=""http://en.cppreference.com/w/cpp/numeric/math/fabs"" rel=""nofollow noreferrer""><code>abs</code> from <code>&lt;cmath&gt;</code></a></p>
",0
40984716,40983870,0,"<p>I recommend that you still use <code>fabs</code> if the argument is always <code>double</code> - it is more reliable. The risk is: sometimes only <code>abs(int)</code> will be visible, so your <code>double</code> argument will be truncated to <code>int</code> (you may get a compiler warning, though). </p>

<p>One of the reasons is that until C++17 it is not guaranteed that a single header includes both <code>abs(int)</code> and <code>abs(double)</code>: <code>&lt;cmath&gt;</code> <strong>must</strong> contain <code>abs(double)</code> and <code>&lt;cstdlib&gt;</code> <strong>must</strong> contain <code>abs(int)</code>, but of course they <strong>may</strong> contain both. So, changing the compiler may change which overload is chosen.</p>

<p>Another example: if you <code>#include</code> <code>""math.h""</code> instead of <code>&lt;cmath&gt;</code>, and use Visual C++, will <code>abs(double)</code> be visible? It will be - up to Visual Studio 2013, but when you upgrade to Visual Studio 2015 you lose it.</p>

<p>Of course, use should still use <code>abs</code> when its argument type is not known, e.g. it is a part of a template.</p>
",2
43756224,43755831,0,"<p>You're over indexing one of your arrays.</p>

<p>Change the code</p>

<pre><code>for(int j = 0; j &lt;= n; j++)
{
    A[j][n] = b[j];
}
</code></pre>

<p>To</p>

<pre><code>for(int j = 0; j &lt; n; j++)
{
    A[j][n] = b[j];
}
</code></pre>
",1
43756224,43755831,0,"<p>You're over indexing one of your arrays.</p>

<p>Change the code</p>

<pre><code>for(int j = 0; j &lt;= n; j++)
{
    A[j][n] = b[j];
}
</code></pre>

<p>To</p>

<pre><code>for(int j = 0; j &lt; n; j++)
{
    A[j][n] = b[j];
}
</code></pre>
",1
35279799,35279475,3,"<p>With respect to your second question:</p>

<p>I would have chosen to use a one-dimensional vector, and then index it by (row*ncols+col).</p>

<p>This will at least reduce memory consumption, but it may also have a significant impact on speed.</p>

<p>I don't remember whether a 'vector of vectors' is an endorsed idiom by the standard, but there is a risk that too much copying and memory reallocation is going on, if there is no special handling of the 'vector of vectors' case.</p>
",0
35283174,35279475,3,"<p>Not so much an answer as additional questions (these don't format well for a comment).</p>

<p>Observation: I think answering vector or something else better for memory storage is hard to say without knowing more about optimization potential... some of the data-related questions hit on that.</p>

<h2>Questions about timing:</h2>

<p>Can you modify your timing logic to read header values, then time the following scenarios:</p>

<pre><code>1) Read-only, just pull each line into memory.   Disable the the grid
      parsing &amp; assignment part.  Goal to benchmark raw reads on file.
      Also no ""resize"" operations on your ""data"" member.
2) Memory allocation (just read the headers and ""resize"" the ""data"" member;
   don't loop through remainder of file).
3) Everything (code as-posted).
</code></pre>

<p>Seems to me that reading a file under 1gb in size will be cached by the operating system.
<br>So... 
<br>I'd encourage you to run the above 5 times or something and see if subsequent runs are are consistent.  (If you don't check for that it might look like you get get a big speedup from a minor change to the code but actually it was just because the data file was cached by the os and your ""gains"" evaporate w/the next reboot).</p>

<h2>Questions about the data file...</h2>

<p>To paraphrase, the data file looks like a complete dump of every value in the grid.
<br>
<br>Example: In addition to the 6 ""header"" lines, a 100 x 200 ""grid"" will have 100 lines in the file with 200 lines on each row.  So 6 + 100*200 = 20,006 lines.
<br>
<br>You mentioned a 900 MB data file.
<br>
<br>I'll make some assumptions, just for the fun of it.
<br>If your values are consistently formatted (e.g. ""0.000000"" thru ""1.000000"") that means 8 chars per value.
<br>
<br>
<br>Assuming simple encoding (1 byte per character) then you'll fit something like a 10,000^2 grid in 900 MB.
<br>
<br>Ignoring the header ""lines"" and end-of-line delims (which will just be rounding errors):
<br>1kb has 1,024 chars
<br>1mb has 1,048,576 chars (1024^2)
<br>900mb has 943,718,400 chars (1024^2 * 900)
<br>8 char element values yields 117,964,800 elements (1024^2*900/8)
<br>Which is roughly a 10,000^2 grid (10,861 from sqrt(1024^2*900/8) ).
<br>
<br>Is that even half-way close, size-wise?
<br>
<br>What is the largest number grid elements you want to support? Millions? Billions? More?
<br>
<br>Seems like any such ""limit"" is going to be driven by whatever produces your data files.</p>

<h2>Questions about the data values</h2>

<p><br>What kind of distribution do you see in your values?
<br>
<br>What kind of range are you seeing in your values?
<br>
<br>Are values always from 0.0000 - 1.0000 ?  Or maybe any valid value for a C++ float?
<br>Can you generate a frequency distribution of values?
<br>e.g. count how many distinct values are in your Grid next time you build it?
<br>
<br>This might help to find any values you can try to optimize around?
<br>
<br>Perhaps many of the grid elements are zero, or 1, or...?
<br>
<br>If so you might consider a sparse matrix approach with an interface that gives callers the illusion
<br>of a fully instantiated grid (e.g. no need to allocate space).
<br>
<br>I don't know what the break even point is for a ""sparse matrix"" approach to begin to pay off.
<br>(Something I wouldn't consider unless I had a common value for at least 30% of my grid elements.)
<br>
<br>If you're manipulating ""raw"" style images, the values will probably be all over the place.
<br>If your values have a pattern, maybe you can exploit that.
<br>I suppose that would be a kind of data compression.
<br>
<br>Can you compute a mid-point value and just store offsets from that?
<br>Can the value be computed from their grid coordinates?  (I would guess No).
<br>
<br>Another comment (@MaruisBancila) mentioned binary format vs. character format.
<br>Makes good sense.
<br>
<br>Going from 8 characters to 4 byte floats would cut the file size in half.
<br></p>

<h2>Questions about what people will do with a Grid</h2>

<p>Once your Grid is populated, what will the ""user"" do with it?
<br>Are they operating the entire grid?
<br>Just a subset of it?
<br>Can you ""window"" on your data to make the consumer(s) happy and only load a subset of grid values into memory?
<br>(I would guess No, but never hurts to ask).</p>

<p>Ok, that's all I can think of for questions.</p>
",0
35292851,35279475,2,"<p>Great Answers.  Using binary format instead of plain text will give me a great performance boost I think.</p>

<p>I had someone send me this code as well.  I'll play around some more and come up with a V2.</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

#include &lt;deque&gt;
#include &lt;vector&gt;

using namespace std;

/* ////////////////////////////////////////////////////////////////////////////
  timer stuff
//////////////////////////////////////////////////////////////////////////// */

//----------------------------------------------------------------------------
typedef double epoch_time_t;

//----------------------------------------------------------------------------
#ifdef __WIN32__

  #include &lt;windows.h&gt;

  epoch_time_t get_epoch_time()  // Since 1601 Jan 1
    {
    FILETIME f;
    GetSystemTimeAsFileTime( &amp;f );
    LARGE_INTEGER t =
      { {
      f.dwLowDateTime,
      f.dwHighDateTime
      } };
    return t.QuadPart / 10000000.0;  // 100 nano-second intervals
    }

  void waitforkeypress()
    {
    WaitForSingleObject(
      GetStdHandle( STD_INPUT_HANDLE ),
      INFINITE
      );
    }

//----------------------------------------------------------------------------
#else // POSIX

  #include &lt;sys/time.h&gt;

  epoch_time_t get_epoch_time()  // Since 1970 Jan 1
    {
    struct timeval tv;
    if (gettimeofday( &amp;tv, NULL )) return 0.0;
    return tv.tv_sec + tv.tv_usec / 1000000.0;
    }

  #include &lt;unistd.h&gt;
  #include &lt;termios.h&gt;
  #include &lt;poll.h&gt;

  #define INFINITE (-1)

  void waitforkeypress()
    {
    struct termios initial_settings;
    tcgetattr( STDIN_FILENO, &amp;initial_settings );

    struct termios settings = initial_settings;
    settings.c_lflag &amp;= ~(ICANON);
    tcsetattr( STDIN_FILENO, TCSANOW, &amp;settings );

    struct pollfd pls[ 1 ];
    pls[ 0 ].fd     = STDIN_FILENO;
    pls[ 0 ].events = POLLIN | POLLPRI;
    poll( pls, 1, INFINITE );

    tcsetattr( STDIN_FILENO, TCSANOW, &amp;initial_settings );
    }

#endif

//----------------------------------------------------------------------------
ostream&amp; print_epoch_time( ostream&amp; outs, epoch_time_t elapsed_time )
  {
  unsigned minutes    = (unsigned) elapsed_time        / 60;
  unsigned seconds    = (unsigned) elapsed_time        % 60;
  unsigned hundredths = (unsigned)(elapsed_time * 100) % 100;

  outs &lt;&lt; ""It took you ""
       &lt;&lt; setfill( '0' ) &lt;&lt; minutes    &lt;&lt; "":""
       &lt;&lt; setw( 2 )      &lt;&lt; seconds    &lt;&lt; "".""
       &lt;&lt; setw( 2 )      &lt;&lt; hundredths &lt;&lt; endl;

  return outs;
  }

/* ////////////////////////////////////////////////////////////////////////////
  loading stuff
//////////////////////////////////////////////////////////////////////////// */

typedef vector &lt;float&gt;     container;
typedef deque  &lt;container&gt; container2;

//----------------------------------------------------------------------------
void load_at_once( const char* filename, string&amp; result )
  {
  ifstream f( filename, ios::binary );
  result.assign( istream_iterator &lt;char&gt; ( f ), istream_iterator &lt;char&gt; () );
  }

//----------------------------------------------------------------------------
struct data_t
  {
  unsigned nrows;
  unsigned ncols;
  double   xllcorner;
  double   yllcorner;
  int      cellsize;
  double   nodatavalue;

  container2 data;
  };

void load_in_pieces( istream&amp; f, data_t&amp; data )
  {
  string s;
  f &gt;&gt; s &gt;&gt; data.ncols
    &gt;&gt; s &gt;&gt; data.nrows
    &gt;&gt; s &gt;&gt; data.xllcorner
    &gt;&gt; s &gt;&gt; data.yllcorner
    &gt;&gt; s &gt;&gt; data.cellsize
    &gt;&gt; s &gt;&gt; data.nodatavalue;
  data.data.resize( data.nrows );
  for (container2::iterator row = data.data.begin(); row != data.data.end(); ++row)
    {
    row-&gt;resize( data.ncols );
    for (container::iterator col = row-&gt;begin(); col != row-&gt;end(); ++col)
      {
      f &gt;&gt; *col;
      }
    }
  }

//----------------------------------------------------------------------------
int main()
  {
  epoch_time_t start, stop;
  string       raw_data;
  data_t       data;

  cout &lt;&lt; ""Please wait while loading...\n"";
  start = get_epoch_time();
  load_at_once( ""data.txt"", raw_data );
  istringstream iss( raw_data );
  load_in_pieces( iss, data );
  stop = get_epoch_time();
  print_epoch_time( cout, stop - start );

  return 0;
  }
</code></pre>
",0
36663728,36663618,2,"<p>You need to provide them when you need different behaviour than what the default, compiler provided, functions implement.</p>

<p>The default copy constructor copies all members by value. The default assignment operator assigns all members by value.
In a lot of cases this is just what you want so there is no need to provide your own implementations. But that is not always the case.</p>

<p>Consider this contrived example:</p>

<pre><code>struct Broken {
  Broken() : i(42), p(new int) { }
  ~Broken() { delete p; }
  int i;
  Int* p;
};
</code></pre>

<p>It will get the default compiler generated copy ctor and operator= but in this case they don't do what you want - consider this:</p>

<pre><code>int main()
{
  Broken b1;
  Broken b2 = b1;
} // you'll probably crash here with a double free
</code></pre>

<p>What happens is that <code>b1</code> stores 42 in its <code>i</code> member, then allocates a new int on the heap and stores the address in its <code>p</code> member (let's say the address is 0x1234).
Then we construct <code>b2</code> from <code>b1</code> and the default copy constructor happily assigns <code>b2.i</code> to be 42 - this is fine. It also assigns <code>b2.p</code> to have the value 0x1234 - this is not what you want. Now both objects hold a pointer to the same memory and both their destructors will attempt to <code>delete</code> it.
Thus, when <code>b2</code> goes out of scope at the end of <code>main</code> it disposes of the memory - so far so good - but then <code>b1</code> also goes out of scope and tries to release the already freed memory and your program is now broken.</p>

<p>In this case you would want to provide your own operator= and copy ctor that don't naively copy the value of the pointer, but instead make a deep copy of whatever the pointer points to and stores that in a new chunk of memory that is distinct from the original, so that both objects have their own unique copy.</p>

<p>There are many other examples but this was the simplest I could come up with.</p>
",3
43724840,43724807,0,"<p>Do you want the vector to have a fixed size of 10? If so then you might prefer </p>

<pre><code>std::array&lt;int, 10&gt; fhd;
</code></pre>

<p>If you want it to be a vector, then you can give it a default value using syntax like</p>

<pre><code>vector&lt;int&gt; fhd = std::vector&lt;int&gt;(10);
</code></pre>
",1
36542923,36542818,2,"<p>Check first whether <code>==</code> or <code>!=</code> operator is overloaded for type <code>Time</code>. You must provide your own meaning to operators which you are gonna to use in your code for user-defined types else you will get compiler errors.</p>

<p>something like below,</p>

<pre><code>class Time
{
public:
      bool operator==(Time const &amp; t1) const
      {
         return this.hour == t1.hour &amp;&amp; this.min==t1.min;

      }
private:
     int min;
     int hour;
};
</code></pre>
",9
36543023,36542818,0,"<p>In order to be able to answer your question completely, it would be necessary to know the details of the type ""Time"". Since you talk about comparing two objects, let's assume it is class.</p>

<p>If it was simple class like this:</p>

<pre><code>class Time {
    public:
        int getValue();
        void setValue(int value);
    private:
        int value;
}
</code></pre>

<p>You would need to use getValue method:</p>

<pre><code>if( t1.getValue() == t2.getValue())
</code></pre>

<p>If you want to compare the objects directly, you need to overload the necessary operators:</p>

<pre><code>bool operator==(const Time&amp; anotherTime) const {
    return (anotherTime.getValue()==this-&gt;getValue());
}
</code></pre>
",1
40965508,40965482,0,"<pre><code>bool plus = false;
for (int i = 1; i &lt;= n; i++) {
    cout &lt;&lt; (plus ? "" + "" : """") &lt;&lt; i;
    plus = true;
}
</code></pre>
",0
40965510,40965482,0,"<pre><code>for (int i = 1; i &lt;= n; i++)
{
    cout &lt;&lt; i &lt;&lt; "" + "";
}
</code></pre>

<p>Should be rewritten as </p>

<pre><code>for (int i = 1; i &lt;= n; i++)
{
    cout &lt;&lt; i;
    if(i != n) cout &lt;&lt; "" + "";
}
</code></pre>
",1
40965636,40965482,0,"<p>Just need 2 small edits to your code:</p>

<pre><code>for (int i = 1; i &lt;= n; i++)
{
    cout &lt;&lt; i &lt;&lt; "" + "";
}
</code></pre>

<p>this becomes:</p>

<pre><code>for (int i = 1; i &lt; n; i++)
{
    cout &lt;&lt; i &lt;&lt; "" + "";
}
cout &lt;&lt; 10;
</code></pre>
",0
39654215,39653897,1,"<p>The syntax of memcmp is </p>

<pre><code> int memcmp ( const void * ptr1, const void * ptr2, size_t num );
</code></pre>

<p>It compares the first num bytes of the block of memory pointed by ptr1 to the first num bytes pointed by ptr2, returning zero if they all match or a value different from zero representing which is greater if they do not.</p>

<p><strong>condition 1</strong></p>

<p>the output of memcmp will be <strong>&lt;0</strong> if the first byte that does not match in both memory blocks has a lower value in ptr1 than in ptr2 </p>

<p><strong>condition 2</strong></p>

<p>the output of memcmp will be <strong>0</strong> if the contents of both memory blocks are equal and</p>

<p><strong>condition 3</strong></p>

<p>the output will be >0 if  the first byte that does not match in both memory blocks has a greater value in ptr1 than in ptr2</p>

<p>here is the simple program</p>

<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;string.h&gt;

     int main ()
     {
     char buffer1[] = ""NEpAL"";
     char buffer2[] = ""NEPAL"";

      int n;

     n=memcmp ( buffer1, buffer2, sizeof(buffer1) );

     if (n&gt;0) printf (""'%s' is greater than '%s'.\n"",buffer1,buffer2);
     else if (n&lt;0) printf (""'%s' is less than '%s'.\n"",buffer1,buffer2);
     else printf (""'%s' is the same as '%s'.\n"",buffer1,buffer2);

      return 0;
      }
</code></pre>

<p>the output will be</p>

<p>'NEpAL' is greater than 'NEPAL'.</p>

<p>as p = 112 and P=80 . Hope it helps</p>
",0
39654051,39653897,1,"<p><code>memcmp</code>'s 3rd parameter should be <code>4*sizeof(int)</code></p>

<p><code>memcmp</code> takes two <code>void*</code> and will not know the width of the type, it always compare as if the pointer is <code>unsigned char*</code>, so what you compare is the first 4 byte (not 4 <code>int</code>) point by the two pointer</p>

<p>Anyway, you will have some problem on endianness if you do this. I will suggest use some compare function that take the type into concern.</p>
",2
37117593,37116730,1,"<p>I think the problem is, that when you find the nth prime, and raise the count so it equals input, you also raise result. You have to either check if count '!=' / '&lt;' input before result++, or decrease result by one before the end of the else loop.</p>

<p>I would also remove the ""else continue;"" part, since if it's not there the exact same thing happens.</p>

<p>The main logic might be nicer like this (I don't have a compiler at hand, but it should work I think):</p>

<pre><code>result = 2;
while(count &lt; input){ //if input == 1 no increment
    result++;
    if(helperFunction(result)) count++; // after 2 every new prime increments count
}
cout&lt;&lt;""result = ""&lt;&lt; result;
</code></pre>
",1
41173930,41173750,1,"<p><strong>Edit</strong>: As @HolyBlackCat mentions, use private inheritance instead of a private member, then a <code>using</code> statement to bring the private base class' member function into public scope:</p>

<pre><code>class B : A {
public:
  B(int i) : A(i) {}

  using A::getSomeval; /*
  ^^^^^^^^^^^^^^^^^^^^ */
};


int main() {
  B b(42);
  std::cout &lt;&lt; b.getSomeval() &lt;&lt; std::endl;
}
</code></pre>

<hr>

<p>You could public-inherit the structs:</p>

<pre><code>class B : public A {
public:
  B(int i) : A(i) {}
};

B b(42);
b.getSomeval();
</code></pre>

<p>Or make <code>A</code> a public data member of <code>B</code>:</p>

<pre><code>class B {
public:
  B(int i) : a(i) {}
  A a;
};

B b(42);
b.a.getSomeval();
</code></pre>

<p>However this method breaks encapsulation.</p>

<p>Most IDEs will auto-construct getter and setter functions for you - you don't necessarily need to write them out by hand.</p>
",2
44744763,44744663,1,"<p>The second <code>cout</code> will be executed when the recursion unfolds, that is from last recursive call to first recursive call.</p>

<pre><code>  f(12345)          
     print 5
     f(123) ----------&gt; f(123)
     print 5                print 3
                            f(1)  --------&gt;  f(1)
                            print 3             print 1
                                                f(0)  -----&gt;   f(0)
                                                print 1           print 0
</code></pre>
",0
44744778,44744663,1,"<p>The answer lies in the if condition. Inside 'if', f(n/100) is called which creates a separate execution tree. This separate execution tree when completed, immediately calls the next instructions, which in this case be 1, 3 and 5 respectively. <a href=""https://i.stack.imgur.com/YneXf.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YneXf.png"" alt=""enter image description here""></a></p>
",0
38500726,38500198,2,"<p>You have two options here. You should either do the non-virtual call in a <em>lambda</em> or you go the trusty old way of <em>slicing the object</em> (which is a copy) you want to pass to <code>std::bind</code>.</p>

<pre><code>// Base method
B b_obj; b_obj.A::foo(); // prints ""Hello from A::foo()!""

// First method
auto k = [](auto b){ b.A::foo(); };
k(b_obj);

// Second method
auto f = std::bind(&amp;A::foo, *static_cast&lt;A*&gt;(&amp;b_obj));
f(); 
</code></pre>

<p>This all prints:</p>

<pre><code>Hello from A::foo()!
Hello from A::foo()!
Hello from A::foo()!
</code></pre>

<p>The <em>Second method</em> works (slices) since <code>std::bind</code> copies its arguments. You should <em>really prefer</em> a lambda.</p>
",4
38500733,38500198,1,"<p>You could wrap the call inside a lambda:</p>

<pre><code>B b_obj;
auto f = std::bind([&amp;b_obj]() { b_obj.A::foo(); } );
</code></pre>

<p>But this makes little sense unless you can only use <code>std::bind</code> somewhere (for example because of <code>std::is_bind_expression</code>), as you pass the object parameter to the lambda's capture, not to bind. </p>

<p>Otherwise just using a lambda or <code>std::function</code> without <code>bind</code> should be cleaner.</p>
",0
41183973,41183348,1,"<p>You have not escaped the <code>""\s""</code> sequence correctly.  Actually, your compiler should be showing you a warning like</p>

<pre><code>main.cpp: In function 'int main()':
main.cpp:9:16: warning: unknown escape sequence: '\s'
   std::regex e(""[a-zA-Z_][0-9a-zA-Z_]*\s*"");
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>

<p>To represent a regex pattern such as <code>\s</code> in a C++ string, you will need to escape the backslash in order to get a literal backslash in your string.  To elaborate a bit:</p>

<ul>
<li><code>""\n""</code> represents a linebreak.  You've probably seen that before.</li>
<li><code>""\\n""</code> represents a backslash, followed by the letter <code>n</code>.</li>
<li>In the same vein, <code>""\s""</code> is treated as an escape sequence by the compiler, except the sequence <code>""\s""</code> does not actually exist.</li>
<li>You want an <em>actual</em> backslash +<code>s</code> in your string, so you need to write <code>""\\s""</code>: a backslash, followed by the letter <code>s</code>.  This, in turn, is understood by <code>std::regex</code> to be a shorthand for whitespace.</li>
</ul>

<p>This program should do what you are looking for:</p>

<pre><code>#include &lt;regex&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
  std::string str(""example1   "");
  std::smatch sm;
  std::regex e(""[a-zA-Z_][0-9a-zA-Z_]*\\s*"");
  if (std::regex_match(str, sm, e))
  {
    std::cout &lt;&lt; ""ok_match"";
  }
}
</code></pre>

<p><kbd>Live on coliru</kbd></p>
",0
36313305,36312913,1,"<p>The best way would be to use <code>std::vector</code> and <code>std::map</code> as already mentioned by others. But since you can only use nested loops and arrays here's an example that works:</p>

<pre><code>const int num_elements = 12;
int numbers[num_elements] = { 2, 6, 7, 4, 5, 4, 1, 8, 9, 0, 7, 4 };
int counter = 0;

for ( int i = 0; i &lt; num_elements; i++ ) {
    for ( int j = i + 1; j &lt; num_elements; j++ ) {
        if ( numbers[j] == numbers[i] ) {
            counter++;
            for ( int k = 0; k &lt; i; k++ ) {
                if ( numbers[k] == numbers[j] ) {
                    counter--;
                    break;
                }
            }
            break;
        }
    }
}

cout &lt;&lt; counter &lt;&lt; endl;
</code></pre>

<p>It will print <code>2</code> and not <code>3</code>. Simply, when we find a duplicate, we go back and check if we already met this number.</p>
",0
36313326,36312913,3,"<p>You find 3 because you don't check if current number is already count as duplicate : the first 4, you find a duplicate, and the second one also. You have to check if the current number isn't in the begin of array. If it is, it's already count as duplicate, so no need to continue, you can pass to next number </p>

<pre><code>int main() {
    const int num_elements = 12;
    int numbers[num_elements] = { 2, 6, 7, 4, 5, 4, 1, 8, 9, 0, 7, 4 };


    for(int i = 0; i &lt; num_elements; ++i){
        int oneCounterMax = 0;  
        bool notAlreadyCheck = true;  

        for(int j = 0; j &lt; i-1; ++j) {
            if (numbers[i] == numbers[j]){
                notAlreadyCheck = false;
            }
        }
        if (notAlreadyCheck) {    
            for(int j = i + 1; j &lt; num_elements; ++j) {
                if((numbers[i] == numbers[j]) &amp;&amp; (oneCounterMax &lt; 1)) {
                    ++numduplicates;
                    ++oneCounterMax;
                }       
            }
        } 
    }       
    cout &lt;&lt; numduplicates &lt;&lt; endl;
}
</code></pre>
",3
36313492,36312913,0,"<p>First you have to sort the array,then skip the repeated elements  and increase the value of <strong><code>numduplicates</code></strong></p>

<pre><code>int main() {
    const int num_elements = 12;
    int numbers[num_elements] = { 2, 6, 7, 4, 5, 4, 1, 8, 9, 0, 7, 4 };

    sort(numbers,numbers+12);//sorting
    int  numduplicates = 0;
    for(int i = 0; i &lt; num_elements; ++i){
        if((i+1)&lt;num_elements &amp;&amp; numbers[i] == numbers[i+1]) {
            ++numduplicates;
            while((i+1)&lt;num_elements &amp;&amp; numbers[i] == numbers[i+1])
               i++;
       }       
    }       
    cout &lt;&lt; numduplicates &lt;&lt; endl;
}
</code></pre>
",0
36313504,36312913,0,"<p>If you are allowed to sort the array, you can write something like this:</p>

<pre><code>std::sort(numbers, numbers + num_elements);

int k = 0;
while (k &lt; num_elements - 1) {
   int i = 1;
   while ((k + i &lt; num_elements) &amp;&amp; (numbers[k + i] == numbers[k])) 
      i++;
   if (i &gt; 1)
      ... // numbers[k] is a duplicate with multiplicity i
   k += i;
}
</code></pre>
",2
36313534,36312913,0,"<p>First sort the array and then iterate over this sorted array. Use a bool flag to save the current state about whether this number has been counted as a duplicate number. </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int main()
{
    const int num_elements = 12;
    int numbers[num_elements] = { 2, 6, 7, 4, 5, 4, 1, 8, 9, 0, 7, 4 };

    std:sort(numbers, numbers+num_elements);
    int duplicate_count = 0;
    bool duplicate = false;
    for(int i = 1; i &lt; num_elements; i++)
    {
        if(numbers[i] != numbers[i-1])
            duplicate = false;
        else if(numbers[i] == numbers[i-1] &amp;&amp; !duplicate)
        {
            duplicate_count++;
            duplicate = true;
        }
    }
    cout &lt;&lt; ""duplicate count: "" &lt;&lt; duplicate_count &lt;&lt; endl;
    return 0;
}
</code></pre>
",1
36314080,36312913,1,"<p>Most of the answers are good enough, but not striving too far from your solution, there is also a clever trick to be had!:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    const int num_elements = 12;
    int numbers[num_elements] = { 2, 6, 7, 4, 5, 4, 1, 8, 9, 0, 7, 4 };

    unsigned int numduplicates = 0;
    for (int i = 0; i &lt; num_elements; ++i) {
        int counter = 0; // changed name
        for (int j = i + 1; j &lt; num_elements; ++j) {
            if (numbers[i] == numbers[j]) { // changed condition
                ++counter; // only increment counter
            }
        }

        if (counter == 1) { // added if statement
            ++numduplicates;
        }
    }
    cout &lt;&lt; numduplicates &lt;&lt; endl;
}
</code></pre>

<p>Instead of only counting 1 of the duplicates (with <code>oneCounterMax</code>), we count all of them. Then later we check if the number we counted is exactly 1.</p>

<p>This does 2 things:</p>

<ul>
<li>We counted at least 1 duplicate, so there is a duplicate of the current number. but...</li>
<li>If we counted more then 1 duplicate, we don't increment the duplicate counter, because it will already be done later on in our iteration, when we count again for the second to last duplicate.</li>
</ul>
",0
36315194,36312913,0,"<p>Simplest implementation for sorted array:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;

int main()
{
    int numbers[] = { 2, 6, 7, 4, 5, 4, 1, 8, 9, 0, 7, 4 };

    auto b = std::begin( numbers );
    auto e = std::end( numbers );
    std:sort( b, e );
    auto ne = std::unique( b, e );
    std::cout &lt;&lt; ""duplicates:"" &lt;&lt; std::distance( ne, e ) &lt;&lt; std::endl;
}
</code></pre>

<p>or by one loop:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;

int main()
{
    int numbers[] = { 2, 6, 7, 4, 5, 4, 1, 8, 9, 0, 7, 4 };

    auto b = std::begin( numbers );
    auto e = std::end( numbers );
    std:sort( b, e );

    int dups = 0;
    int v = *b++;
    for( auto it = b; it != e; ++it ) {
       if( v != *it ) v = *it;
       else ++dups;
    }
    std::cout &lt;&lt; ""duplicates:"" &lt;&lt; dups &lt;&lt; std::endl;
}
</code></pre>
",0
36315066,36312913,0,"<p>Sounds like homework in which case your teacher may be unhappy with this approach even though it doesn't use <code>vector</code>.</p>

<p>Given the input array:</p>

<pre><code>int numbers[num_elements] = { 2, 6, 7, 4, 5, 4, 1, 8, 9, 0, 7, 4 };
</code></pre>

<p>You can find the unique size of the array by using a <a href=""http://en.cppreference.com/w/cpp/container/set"" rel=""nofollow""><code>set</code></a>, because a <code>set</code>:</p>

<blockquote>
  <p>Is an associative container that contains a sorted set of <strong>unique</strong> objects of type <code>Key</code></p>
</blockquote>

<p>In C++14 you can build the <code>set</code> like this:</p>

<pre><code>const auto numduplicates = num_elements - set&lt;int&gt;(cbegin(numbers), cend(numbers)).size();
</code></pre>

<p><a href=""http://ideone.com/OpGbNl"" rel=""nofollow""><kbd>Live Example</kbd></a></p>

<p>In C++11 you can build the <code>set</code> like this:</p>

<pre><code>const auto numduplicates = num_elements - set&lt;int&gt;(numbers, next(numbers, num_elements)).size();
</code></pre>

<p>And before that you could build the <code>set</code> like this:</p>

<pre><code>const auto numduplicates = num_elements - set&lt;int&gt;(numbers, numbers + num_elements).size();
</code></pre>
",0
36647952,36647562,1,"<p>You have 2 problems:</p>

<pre><code>if(head-&gt;children[0]!=NULL){
</code></pre>

<p>You access <code>children[0]</code> but you don't check if children is empty. I'm fairly sure this causes your SegFault.</p>

<pre><code>return findNode(data, head-&gt;children.at(i));
</code></pre>

<p>You need to check if this is null before returning. In case it's null you want to check the other children.</p>

<p>Also pass <code>const std::string&amp; data</code> so that you don't copy the string at every call.</p>
",0
39325043,39324279,1,"<p>Error spring up becouse it fails cast type <code>string</code> to <code>char *</code>. But it must work reversed (therefore your <code>temp = argv[i];</code> does't fails).
Don't write to <code>argv</code>(you can, but I do not recommend).
Simple way: Copy <code>argv</code> to to some array of <code>string</code> before sorting:
`</p>

<pre><code>string *argv_strings = new string[argc - 1];
for(int i = 0; i &lt; argc - 1; ++i)
{
    argv_strings[i] = new string(argv[i + 1]);
}
</code></pre>

<p>`</p>

<p>and work with <code>argv_strings</code> instead <code>argv</code>
Do not forget <code>delete</code> pointer after.</p>
",0
39324942,39324279,3,"<p>There are two errors in the code:</p>

<ol>
<li>As @hyde pointed out, <code>temp</code> should be <code>char*</code> and not <code>string</code></li>
<li><code>argv[i] &gt; argv[j]</code> looks like pointer comparison i.e. it will compare the value of the address rather than comparing the string. I suggest using <code>strcmp</code> methods for comparing two <code>char*</code> (then you need to <code>#include &lt;string&gt;</code> to use this method)</li>
</ol>

<p>Suggested code (not sure if totally bug free or not, but hopefully it's the case):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main (int argc, char **argv)
{
    int i = 0, j = 0;
    char* temp;

    for (i = 1; i &lt; argc; ++i)
    {
         for (j = i+1; j &lt; argc; ++j)
         {
              if (strcmp(argv[i] , argv[j]) &gt; 0)
              {
                   temp = argv[i];
                   argv[i] = argv[j];
                   argv[j] = temp;
              }
          }
     }
    for(i = 0; i &lt; argc; i++){
        cout &lt;&lt; argv[i]&lt;&lt; endl;
    }
} 
</code></pre>

<p>Note the final for loop is to check if the output is sorted. I tried your comparison <code>argv[i] &gt; argv[j]</code> rather than <code>strcmp</code> and it does not seem to work on my machine.</p>
",3
37692112,37689877,0,"<p>How about defining some helper meta functions to get the type you want?</p>

<pre><code>#include &lt;type_traits&gt;

struct class1
{
    enum res
    {
        a = 9,
        b = 15
    };

    class1(res e) { }
};

struct class2
{
    enum res
    {
        he = 5,
        de = 2
    };

    class2(res e) {}
};

auto get_enclosing_type(class1::res) -&gt; class1;
auto get_enclosing_type(class2::res) -&gt; class2;

template &lt;typename T&gt;
using get_enclosing_type_t = decltype(get_enclosing_type(std::declval&lt;T&gt;()));

template&lt;typename E&gt;
void fn(E const e)
{
    using type = get_enclosing_type_t&lt;E&gt;;
    foo(type {e});
}
</code></pre>
",0
36323141,36322897,3,"<p>Here's the situation in pictorial form:</p>

<pre><code>+----------+       +----------+       +----------+
| before_p |  &lt;-&gt;  |     p    |  &lt;-&gt;  | after_p  |
+----------+       +----------+       +----------+

+----------+       +----------+       +----------+
| before_q |  &lt;-&gt;  |     q    |  &lt;-&gt;  | after_q  |
+----------+       +----------+       +----------+
</code></pre>

<p>The problem you have is that saving a <code>temp</code> pointer to <code>p</code> does not actually copy the pointers inside <code>p</code>.  So when you overwrite them, you're in trouble.</p>

<p>Now, those ""before"" and ""after"" items in the picture are what you really want.  It's much easier to just copy them out and then do the logic.  Look at how much clearer the following code is:</p>

<pre><code>Item * before_p = p-&gt;pre;
Item * before_q = q-&gt;pre;
Item * after_p = p-&gt;next;
Item * after_q = q-&gt;next;

// Relink before and after nodes
if( before_p ) before_p-&gt;next = q;
if( before_q ) before_q-&gt;next = p;
if( after_p ) after_p-&gt;pre = q;
if( after_q ) after_q-&gt;pre = p;

// Relink nodes themselves
p-&gt;pre = before_q;
q-&gt;pre = before_p;
p-&gt;next = after_q;
q-&gt;next = after_p;
</code></pre>

<p>You may also want a sanity test before you do <em>anything</em>:</p>

<pre><code>if( p == q || !p || !q ) return;
</code></pre>

<p>And finally, if you are maintaining a pointer to the head of your list somewhere, and that happens to be one of the items swapped, don't forget to update it after*.</p>

<pre><code>if( head == p ) head = q;
else if( head == q ) head = p;
</code></pre>

<p>(*) Same goes for other pointers like <code>tail</code>.</p>
",1
39623519,39623493,3,"<p>C++ arrays are 0 based.</p>

<p><code>players[1]</code> is accessing a location outside the range of the array.</p>

<p>You will want: <code>players[0]</code>.</p>
",2
39623612,39623493,0,"<p>Definitely it crashes for the below line:</p>

<pre><code>players[1]=players[1]+x+y;
</code></pre>

<p>Because size of <code>players</code> array is 1, so it has only index <strong>0</strong>. And in above line, it tries to access index <strong>1</strong>. Take a look at <a href=""https://en.wikipedia.org/wiki/Buffer_overflow"" rel=""nofollow"" title=""Buffer Overflow"">Buffer Overflow</a> and array index out of bounds.</p>

<ul>
<li>Try to define an array with constant size.</li>
<li>If you need a dynamic array, use linked list or vector.</li>
</ul>
",6
39623719,39623493,0,"<pre><code>cout &lt;&lt; (""Your score is"" + players[1]) &lt;&lt; endl;
</code></pre>

<p>Here you're trying to use direct string concatenation, but you can't concatenate a string literal with an integer like that. You end up doing pointer arithmetic, which is definitely not what you intended.</p>

<p>You should instead use <code>cout</code>'s built-in formatting:</p>

<pre><code>cout &lt;&lt; ""Your score is"" &lt;&lt; players[1] &lt;&lt; endl;
</code></pre>

<p>Your next problem is that <code>players</code> is not declared correctly; an array cannot have runtime bounds, and <code>numplayers</code> (despite having only the one initial value) is ultimately a ""runtime"" variable. You would be better off with a <code>std::vector</code> if the size of the array is going to change later; otherwise make <code>numplayers</code> a <code>constexpr</code>.</p>

<p>Your last problem is that, if the array declaration <em>were</em> valid, you'd be trying to access the second element of a one-element array! The first element is <code>players[0]</code>, not <code>players[1]</code>.</p>
",3
39624419,39623493,0,"<p>There are many things you're doing not good.</p>

<ul>
<li>I believe you're using C++, there is no known way to me about creating arrays of dynamic size i.e. <code>int players[numplayers]</code>. In C++ either we can create array of fixed size i.e. <code>int players[10]</code> or use <em>pointer</em> to an array for dynamically allocated memory e.g. <code>int* players = new int[numplayers]</code>. This allocates an array of size <code>numplayers</code> and an <em>int pointer</em> named players is pointing to it. We can use this pointer as normal array e.g. printing 1st index of array is written as <code>player[0]</code> or another syntax is <code>*(player + 0)</code>. Remember to delete this dynamically allocated memory at the end of program i.e. <code>delete[] player</code>.</li>
<li>Second thing is when you have allocated an array and are using its value for computation, always initialize it to 0 as newly allocated array contains garbage value and it will affect your computations. code for initializing it to zero may be like this:</li>
</ul>

<p>Here is the loop:</p>

<pre><code>for(int i = 0 ; i &lt; numplayers ; i++){
    player[i]=0;
    //another syntax is : *(player + i) = 0;
}
</code></pre>

<ul>
<li><em>C++</em> does not concat as you did in your <code>std::cout</code> statement. Make it like this:
<code>cout &lt;&lt; ""Your score is"" &lt;&lt; players[0] &lt;&lt; endl;</code></li>
<li><p>In C++, arrays always start with index zero, so 1st index will be 0 in this case. So your program will work well if it is like this:</p>

<pre><code>int numplayers = 1;
int* players = new int[numplayers];
int x = 0, y = 0;
srand(time(0));
x = (rand() % 6 + 1);
y = (rand() % 6 + 1);
players[0] = 0;
players[0] = players[0] + x + y;
cout &lt;&lt; ""Your score is"" &lt;&lt; players[0] &lt;&lt; endl;
delete[] players;

return 0;
</code></pre></li>
</ul>
",0
36756395,36756302,0,"<p>You need to write to <code>outFile</code> inside the <code>while(getline(inFile, line))</code> loop.</p>

<p>[edit] see user4581301's answer for a more thorough treatment.</p>
",1
36756502,36756302,1,"<p>Here we can see that <code>outFile</code> is only written to outside of the while loop:</p>

<pre><code>while (getline(inFile, line))
{
    cout &lt;&lt; ""The input number :"" &lt;&lt; line &lt;&lt; endl;
    for (i = 0; i &lt; 8; i++)
    {
        cout &lt;&lt; ""The number "" &lt;&lt; i + 1 &lt;&lt; "":"";
        cout &lt;&lt; line.at(i);
        cout &lt;&lt; endl;
    }
}
outFile &lt;&lt; line &lt;&lt; endl;
</code></pre>

<p>It has no chance of containing the same output as the console</p>

<p>Solution:  Write inside the loop the same stuff that was written to the console:</p>

<pre><code>while (getline(inFile, line))
{
    cout &lt;&lt; ""The input number :"" &lt;&lt; line &lt;&lt; endl;
    outFile &lt;&lt; ""The input number :"" &lt;&lt; line &lt;&lt; endl;
    blah blah blah
}
</code></pre>

<p>But this looks like crap and a function makes like a better solution by eliminating duplication and upping re-usability.</p>

<pre><code>void output(std::ostream &amp; out,
            const std::string &amp; line)
{
    out &lt;&lt; ""The input number :"" &lt;&lt; line &lt;&lt; endl;
    for (int i = 0; i &lt; 8; i++)
    {
        out &lt;&lt; ""The number "" &lt;&lt; i + 1 &lt;&lt; "":"";
        out &lt;&lt; line.at(i);
        out &lt;&lt; endl;
    }
}
</code></pre>

<p>and called:</p>

<pre><code>while (getline(inFile, line))
{
    output(cout, line);
    output(outFile, line);
}
</code></pre>
",0
41401636,41401464,3,"<p>Assuming the actual code isn't as simple as posted, it <em>may</em> be reasonable to customize the function template with an operation which is actually applied. For example:</p>

<pre><code>template &lt;typename T&gt;
bool load_aux(T&amp; t, std::string const&amp; s) { return t.load(s); }
bool load_aux(some_special_case&amp; t, std::string const&amp; s) { return t.open(s); }

template &lt;typename T&gt;
bool load(T&amp; t, std::string const&amp; s) {
    if (load_aux(t, s)) {
        // some code
        return true;
    }
    // some more code
    return false;
}
</code></pre>
",4
36266941,36266629,0,"<p>You need to put extern keyword. C/C++ does for every .c/.cpp file will combine the text of files and all definitions will be merged in the linking step. If you write 'extern' before the header variable, you can define it in just one C++ file, and all other files will reuse it. The linker will use just one instance of the variable you externed it to.</p>

<p>So in header.h</p>

<pre><code>#pragma once
extern char text[];
</code></pre>

<p>main.cpp remains the same, but""dosomething.cpp"" changes slightly</p>

<pre><code>#include ""Header.h""

(...)
char text[] = ""..."";

(...)
</code></pre>

<p><a href=""https://en.wikipedia.org/wiki/External_variable"" rel=""nofollow"">https://en.wikipedia.org/wiki/External_variable</a></p>
",0
47700283,47700133,0,"<p>It is done this way to make overloading more versatile, and because the interpreter decides which function to call based off what parameters you pass.  Say I have two functions</p>

<pre><code>void add(int* a, int* b){
    *a= *a+*b;
    *b = *a;
}
</code></pre>

<p>and</p>

<pre><code>int add(const&amp; int a, const&amp; int b){
    return a+b;
}
</code></pre>

<p>These are two very different ways of adding two numbers.  When I call these functions the interpreter knows which one to call based off what I pass it.</p>
",0
47700296,47700133,0,"<p>Call-by-reference vs. call-by-value isn't primarily about ""modification"" vs. ""read-only"". <code>const</code> is for indicating if a parameter is read-only or not. The choice of call-by-reference vs. call-by-value in function design is more often about the performance impacts.</p>

<p>For example, an <code>int</code> is usually passed-in-register while a <code>int *</code> would pass the pointer in-register but require a dereference to access. This is most obvious in structures/classes where passing-by-value will involve copying chunks of memory larger than a machine word and/or calling constructors/destructors on temporaries.</p>

<p>For example, this function requires temporary generation, a ctor/dotr cycle, possibly with heap allocation on every call invocation:</p>

<pre><code>void foo(const std::string s);
</code></pre>

<p>While this one avoids additional temporaries while still being read-only:</p>

<pre><code>void foo(const std::string&amp; s);
</code></pre>

<p>The design choices of how the function takes parameters is explicitly visible to the caller so that the developer can in turn make their own performance-related tradeoffs in how it's used. C/C++ code performance is in large part based on putting data in the right place, and passing references to it in the right way.</p>

<blockquote>
  <p>As for ""how is this justified in C++"" questions, see Stroustrup, ""The Design and Evolution of C++"", Addison-Wesley (1994)</p>
</blockquote>
",0
47701271,47700133,0,"<p>It's always caller who ""decide"" what callee to call based on types of arguments. There are strict resolution rules which are pretty reasonable. Search for C++ overload resolution. E.g.: <a href=""http://en.cppreference.com/w/cpp/language/overload_resolution"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/language/overload_resolution</a>.</p>

<p>Different overloads are different functions with same name in source code they have different mangled name but not in object files.</p>
",0
41698813,41698029,0,"<p>The constructor you implemented is not a copy constructor or a default constructor, so it has nothing to do with what (you think) your teacher said.</p>

<p>I believe either you or your teacher have mixed up two rules.</p>

<p>One rule is</p>

<ul>
<li>If you implement a non-default constructor but no default constructor, the ""compiler-generated"" default constructor is implicitly deleted.<br>
If you want one you need to define it yourself. (In C++11, you can use <code>= default;</code>.)</li>
</ul>

<p>(There are more situations that cause ""special member functions"" to be deleted, but this is the one most people stumble across first.)</p>

<p>The other rule (""the rule of three"", which is more a rule of thumb) is</p>

<ul>
<li>If you need to implement a copy constructor, destructor, or assignment operator, you <em>probably</em> need to implement all three, so do it immediately.</li>
</ul>
",0
37837625,37837133,1,"<p>The line does not actually delete the <code>Node</code> from the memory. It removes it from the linked list.</p>

<p>The code makes your current <code>Node</code> (<code>p</code>) points to the second <code>Node</code> on the right instead of the first on the right.  </p>

<p>Several issues with this code:</p>

<ul>
<li>Potential memory leak since the <code>Node</code> is not deleted from the memory </li>
<li>you need to do some check before <code>p-&gt;next=p-&gt;next-&gt;next;</code> or you might have some undefined behaviour when <code>p</code> or <code>p-&gt;next</code> end up being <code>NULL</code>. e.g. <code>L</code> is NULL, <code>S</code> > size of the linked list...</li>
</ul>
",0
37837603,37837133,1,"<p>Let's take a look at what the function does. It takes two arguments, the linked list, and the index of the item to be removed.</p>

<p>First, it searches the right node:
p is the first item of the linked list. It starts stepping through the list, untill either, the right index is found (<code>i=S-1</code>) or untill the end of the list is reached (<code>p=NULL</code>).</p>

<p>when it has found the right node, it sets the link to the next item: <code>p-&gt; next</code>, to the next item of the next item.</p>

<p>And now, you can also see the problems in the function:</p>

<ul>
<li>When an item is removed, the item itself is still in the list, there
is just no more pointer to it, this is a memory leak like molbdnilo said.</li>
<li>When the end of the list is reached (p=NULL), you try to set p->next to NULL, this will cause the program to throw a nullpointerexception.</li>
<li>If p itself is the last item in the list, p->Next will be null, and since you try to call 'Next' on this item, you will also get a nullpointerexception.</li>
</ul>
",0
38502529,38502470,1,"<p>2 problems:</p>

<ol>
<li><p><code>new_account(&amp;accountStore);</code> is wrong, use <code>new_account(*accountStore);</code> to match the argument type.</p></li>
<li><p><code>accountStore.push_back(account);</code> is wrong. <code>account</code> is type not object. Add some argument to the function.</p></li>
</ol>
",0
38502931,38502470,0,"<p>Several issues:</p>

<ol>
<li><p>You must specify the variable name here (and not only the type):</p>

<pre><code>template&lt;class account&gt;
inline void accountStream::pushToStore(account c)
{
    accountStore.push_back(c);
}
</code></pre></li>
<li><p>You must receive a pointer (not a reference to a pointer) here</p>

<pre><code>void new_account(accountStream *accountStorage)
{
    newAccount *account = new newAccount;
    accountStorage-&gt;pushToStore(account);
}
</code></pre></li>
<li><p>You must call the function with a pointer as a parameter:</p>

<pre><code>new_account(accountStore);
</code></pre>

<p>Alternatively, you can declare the variable (not a pointer to):</p>

<pre><code>accountStream accountStore;
</code></pre>

<p>call the function:</p>

<pre><code>new_account(accountStore);
</code></pre>

<p>and receive a reference:</p>

<pre><code>void new_account(accountStream &amp;accountStorage)
{
    newAccount *account = new newAccount;
    accountStorage.pushToStore(account);
}
</code></pre></li>
</ol>
",1
38502997,38502470,0,"<p>As answered here already, you need to use *accountStore and not &amp;accountStore because the function takes a reference and not a pointer to a pointer (which is what you get from using &amp; operator on a pointer).</p>

<p>the second problem is here:</p>

<pre><code>template&lt;class account&gt;
inline void accountStream::pushToStore(account)
{
    accountStore.push_back(account);
}
</code></pre>

<p>you are declaring the function templated on the 'account' therefore account is a type, and what you are trying to do in the next line is push_back a type and not an object. 
the correct code would be: </p>

<pre><code>template&lt;class account&gt;
inline void accountStream::pushToStore(account acct)
{
    accountStore.push_back(acct);
}
</code></pre>

<p>because account is the <em>type</em> while acct is an instance of the type account.</p>
",1
43953860,43953838,2,"<p>You can write </p>

<pre><code>std::cout &lt;&lt; '\n';
</code></pre>

<p>instead. That would have the advantage that the stream isn't flushed at the same time.</p>

<hr>

<p>Note:<br>
On Windows OS it might be required to write </p>

<pre><code>std::cout &lt;&lt; '\r' &lt;&lt; '\n';
</code></pre>

<p>or </p>

<pre><code>std::cout &lt;&lt; ""\r\n"";
</code></pre>

<p>to get correct line endings.</p>
",5
43953892,43953838,2,"<p>You can also use:</p>

<pre><code>std::cout &lt;&lt; '\n';
</code></pre>

<p>The only difference is that the stream won't be flushed.</p>
",12
36645007,36644502,0,"<p>You're not marking the matched characters from <code>arr</code>
Replace the matched characters from <code>arr[j]</code> with a distinct character so that you can determine where to replace later. you can use <code>null terminator</code> </p>

<pre><code>    for (int i = 0; i &lt; 3; i++) {
        for (int j = 0; j &lt; 5; j++) {
            if (subarr[i] == arr[j]) {
                if (!check) {
                    cout &lt;&lt; ""Found characters are: "";
                }
                count++;
                cout &lt;&lt; subarr[i] &lt;&lt; "","";
                check = true;
                arr[j]='\0'; //replacing the matched character with null terminator
            }
        }
    } 
</code></pre>

<p>Now traverse through your <code>arr</code> and replace null terminators with characters from <code>replace</code> array</p>

<pre><code>   int i=0;

   for (int j = 0; j &lt; 5; j++) {
      if (arr[j]=='\0') { //replace when it equals to null terminator
         arr[j] = replace[i++];
       }
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/7su5f.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/7su5f.png"" alt=""enter image description here""></a></p>
",5
36645015,36644502,0,"<p>You want to ask the user to replace a specific number of chars, counting how many chars appear in subarr.</p>

<p>arr is input, subarr is from:</p>

<pre><code>int replacecount[3] = { 0 };

for (int x=0; x&lt;6; x++)
    for (int i=0; i&lt;3; i++)
        if (input[x] == from[i]) {
            ++replacecount[i];
            break;
        }

int count = 0;
for (int i=0; i&lt;3; i++)
    if (replacecount[i] &gt; 0)
        ++count;

std::cout &lt;&lt; "" you can replace "" &lt;&lt; count &lt;&lt; "" characters..."" &lt;&lt; std::endl;
char to[3];
for (int i=0; i&lt;3; i++)
    if (replacecount[i] &gt; 0) {
        std::cout &lt;&lt; ""enter replace character for '"" &lt;&lt; from[i] &lt;&lt; ""'"" &lt;&lt; std::endl;
        std::cin &gt;&gt; to[i];
    }

for (int x=0; x&lt;6; x++)
    for (int i=0; i&lt;3; i++)
        if (input[x] == from[i]) {
            input[x] = to[i];
            break;
        }

 std::cout &lt;&lt; ""replaced string is: "" &lt;&lt; input &lt;&lt; std::endl;
</code></pre>
",0
38204274,38202978,0,"<h1>Alphabet  number/place in alphabet</h1>

<p>You can convert each letter of the alphabet, to the number that respectively the place of that letter.</p>

<ul>
<li>a = 1</li>
<li>b = 2</li>
<li>...</li>
<li>z = 26</li>
</ul>

<p>This program is a quick 'tool' do this type of encoding. Separate it from your actual project.<br>
<strong>Save as:</strong> MyStringEncoder.cpp <em>and compile</em></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

string encodeMyString(string s) {
    string encodedString;
    string alphabet = ""abcdefghijklmnopqrstuvwxyz"";
    for (int i = 0; i &lt; s.length(); i++) {
        char toEncode = s[i];
        for (int j = 0; j &lt; alphabet.length(); j++) {
            if (toEncode == alphabet[j]) {
                encodedString += to_string(j +1);
                encodedString += ""_"";
            }
        }
    }

    encodedString.erase(encodedString.length() -1, encodedString.length());
    return encodedString;
}

int main() {
    cout &lt;&lt; ""Give in string to encode: "";

    string stringToEncode;
    cin &gt;&gt; stringToEncode;

    cout &lt;&lt; encodeMyString(stringToEncode);
    cin.ignore().get();
}
</code></pre>

<p>When you enter a string, it will be reversed to numbers. So ""hello"" will become ""8_5_12_12_15"".</p>

<p>In your actual program; you have to have these two functions:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;

using namespace std;

//Needed in your actual program
char toAlpha(int n) {
     return ""abcdefghijklmnopqrstuvwxyz""[n-1];
}
string decodeMyString(string encodedString) {
     stringstream ss(encodedString);
     string part;
     vector&lt;int&gt; partList;

     while (getline(ss, part, '_')) {
          partList.push_back(stoi(part));
     }

    string decodedString;
    for (int i = 0; i &lt; partList.size(); i++) {
        decodedString += toAlpha(partList[i]);
    }

    return decodedString;
}
//----------------------------------

int main() {

     cout &lt;&lt; decodeMyString(""8_5_12_12_15"");
}
</code></pre>

<p>By putting the encoded number-string into the function <code>decodeMyString()</code> it'll get reversed back to ""hello"", because the eight character of the alphabet is ""h"", the fifth is ""e"",...</p>

<p>This way someone opening your file would only see numbers, but not actually words. </p>

<p>Of course, you still have to build in support for spaces and other special characters. But it's just a quick example.</p>

<h1>Caesar Cipher</h1>

<p>This cipher is one of the most basic and first versions of encryption, yes, this is actually encryption because you need a key to encrypt and decrypt it. However, it's a very weak form of encryption.</p>

<p>Anyway, it works like this.
You have the alphabet, and you shift it a specific times.
So,<br>
ABCDEFGHIJKLMNOPQRSTUVWXYZ<br>
BCDEFGHIJKLMNOPQRSTUVWXYZA<br>
Is shifted, one time.</p>

<p>So, 1 is your 'secret' key.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;

using namespace std;

//Function to encrypt
string toCaesar(string s, int key) {
    string alphabet = ""abcdefghijklmnopqrstuvwxyz"";

    for (int i = 0; i &lt; s.length(); i++) {
        for (int j = 0; j &lt; alphabet.length(); j++) {
            if (s[i] == alphabet[j]) {
                int index = j + key;
                if (index &gt;= 26) index = index - 26;
                s[i] = alphabet[index];
                break;
            }
        }
    }

    return s;
}

//Function to decrypt
string decryptCaesar(string s, int key) {
    string alphabet = ""abcdefghijklmnopqrstuvwxyz"";

    for (int i = 0; i &lt; s.length(); i++) {
        for (int j = 0; j &lt; alphabet.length(); j++) {
            if (s[i] == alphabet[j]) {
                int index = j - key; //Only difference is the MINUS here
                if (index &gt;= 26) index = index - 26;
                s[i] = alphabet[index];
                break;
            }
        }
    }

    return s;
}

int main() {
    int inputKey;
    string stringToEncrypt;

    cout &lt;&lt; ""Give your key: "";
    cin &gt;&gt; inputKey;
    cout &lt;&lt; ""String to encrypt: "";
    cin &gt;&gt; stringToEncrypt;

    cout &lt;&lt; toCaesar(stringToEncrypt, inputKey) &lt;&lt; endl;
    cout &lt;&lt; decryptCaesar(""fgh"", 5);
}
</code></pre>

<p>This is weak, not only because it can be easily brute-forced. But also because if you take the most for common letter in English ('e') and the most for common in your cipher, you already have one of the 26 letters.</p>

<h1>Note</h1>

<p>However, note that both of these methods are weak, and unsecure.
What you are trying to do is called security through obfuscation. And is dissadvised.</p>

<p>Another thing you're maybe interested in, is <a href=""https://en.wikipedia.org/wiki/Obfuscation_(software)"" rel=""nofollow"">source code obfuscation</a>.</p>
",3
38204838,38202978,-1,"<p>Replace each character with character to the right of it at the keyboard. Then ""hello"" becomes ""jr;;p"".  (The rightmost character becomes the leftmost, i.e. '/' becomes 'z'.)  Implement decode function, then use constants i.e. instead of </p>

<pre><code>print(""Hello world\n"");
</code></pre>

<p>you need</p>

<pre><code>static const char* sz_hello_world = decode(""Jr;;p ept;f\n"");
printf(sz_hello_world);
</code></pre>

<p>Special characters like '\n' or ' ' should not be touched.</p>

<p>Warning: since your decode function will allocate memory, you need to call each decode only once, to avoid memory leak.  Thats why you need <code>static const</code>.</p>
",0
41658724,41616758,0,"<p>Edited on Mike P's suggestion:</p>

<p>You not only have to implement <em>every</em> virtual method you declare in the header; you have to fix your destructor too. It would be something like this:</p>

<pre><code>SinglyCLL::~SinglyCLL()
{
    node *q, *next;

    if (head) {
        next= head-&gt;next;
        delete head;

        while ((q= next) != head) {
            next=  q-&gt;next;
            delete q;
        }
    }
    head= tail= NULL;
}
</code></pre>

<p>Note: actually, as it is a circular list, 'tail' pointer could be removed.</p>
",3
47615109,47615085,1,"<p><code>using namespace NormalClient;</code> is the cause of the error. NormalClient is a class, not a namespace. You don't have to use the <code>using namespace</code> to use the NormalClient header, you have to create an instance of the class and access stuff inside using the dot operator, eg: <code>NormalClient.something</code>. </p>
",1
47615587,47615085,3,"<p>Compiler need to know where's definition corresponding the class declaration.</p>

<p>You just declared the class at the file ""ClientType.h"".
On the other hand, you need to define the class and it would be located at cpp file normally.</p>

<p>(about declaration and definition, see <a href=""https://stackoverflow.com/a/1410632/9043064"">https://stackoverflow.com/a/1410632/9043064</a>)</p>

<p>If you want reduce to repeating source code, then you can just define class at your header file</p>

<pre><code>class NormalClient : public ClientType {
public:
    NormalClient() { // implementation }
    NormalClient(const NormalClient&amp; orig) { // implementation }
    double getDiscount() { // implementation }
    int getMaxRents() { // implementation }
    virtual ~NormalClient() { // implementation }
private:

};
</code></pre>

<p>But it is not recommended in that header file's getting bigger. it could increase building time. And also it's not a good practice.
 (<a href=""https://stackoverflow.com/a/333964/9043064"">https://stackoverflow.com/a/333964/9043064</a>)</p>

<p>About using namespace... I think it'll be helpful for you to read this  (even though it's not possible to use actually for implementing class definition) <a href=""https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice?rq=1"">Why is &quot;using namespace std&quot; considered bad practice?</a></p>
",0
47615109,47615085,1,"<p><code>using namespace NormalClient;</code> is the cause of the error. NormalClient is a class, not a namespace. You don't have to use the <code>using namespace</code> to use the NormalClient header, you have to create an instance of the class and access stuff inside using the dot operator, eg: <code>NormalClient.something</code>. </p>
",1
47615587,47615085,3,"<p>Compiler need to know where's definition corresponding the class declaration.</p>

<p>You just declared the class at the file ""ClientType.h"".
On the other hand, you need to define the class and it would be located at cpp file normally.</p>

<p>(about declaration and definition, see <a href=""https://stackoverflow.com/a/1410632/9043064"">https://stackoverflow.com/a/1410632/9043064</a>)</p>

<p>If you want reduce to repeating source code, then you can just define class at your header file</p>

<pre><code>class NormalClient : public ClientType {
public:
    NormalClient() { // implementation }
    NormalClient(const NormalClient&amp; orig) { // implementation }
    double getDiscount() { // implementation }
    int getMaxRents() { // implementation }
    virtual ~NormalClient() { // implementation }
private:

};
</code></pre>

<p>But it is not recommended in that header file's getting bigger. it could increase building time. And also it's not a good practice.
 (<a href=""https://stackoverflow.com/a/333964/9043064"">https://stackoverflow.com/a/333964/9043064</a>)</p>

<p>About using namespace... I think it'll be helpful for you to read this  (even though it's not possible to use actually for implementing class definition) <a href=""https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice?rq=1"">Why is &quot;using namespace std&quot; considered bad practice?</a></p>
",0
41691218,41690258,0,"<p>There are few problems with your code :<br>
1.<code>double smallestNum = ' '</code> should be replaced with double <code>smallestNum = DBL_MAX</code> (or a really large value).<br>
2.Just as you have used <code>largestNum</code> and <code>smallestNum</code> to keep track of largest and smallest values, you also need to use <code>unitOfLargestDistance</code> and <code>unitOfSmallestDistance</code> to keep track of their corresponding units.<br>
 3. </p>

<pre><code>if (testNum &lt; smallestNum) {
    smallestNum = doubNum;
    cout &lt;&lt; smallestNum &lt;&lt; "" "" &lt;&lt; unitOfDistance &lt;&lt; "" is the smallest distance entered so far.\n"";
}
</code></pre>

<p>Here you need to update <code>smallestNum</code> with <code>testNum</code> not <code>doubNum</code>. So it should be like:</p>

<pre><code>if (testNum &lt; smallestNum) {
    smallestNum = testNum;
    cout &lt;&lt; doubNum &lt;&lt; "" "" &lt;&lt; unitOfDistance &lt;&lt; "" is the smallest distance entered so far.\n"";
}
</code></pre>

<p>Similarly for the other 2 conditions.</p>
",1
41694345,41690258,1,"<p>Try this</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;limits&gt;
using namespace std;

int main() {
    double num, result, smallest, largest;
    smallest = numeric_limits&lt;double&gt;::max();
    largest = numeric_limits&lt;double&gt;::min();
    string unit;
    cout &lt;&lt; ""Enter a distance with a unit of measure (ft, in, cm, m): "";
    while (cin &gt;&gt; num &gt;&gt; unit) {
        if (unit == ""in"")       // in to cm
            result = num * 2.54;
        else if (unit == ""ft"")  // ft to cm
            result = (num * 12) * 2.54;
        else if (unit == ""cm"")  // cm
            result = num;
        else if (unit == ""m"")   // m to cm
            result = num * 100;
        else {
            cout &lt;&lt; ""I don't know that unit.\n"";
            break;
        }
        smallest = min(smallest, result);
        largest = max(largest, result);
        cout &lt;&lt; smallest &lt;&lt; "" cm is the smallest distance entered so far.\n"";
        cout &lt;&lt; largest &lt;&lt; "" cm is the largest distance entered so far.\n"";
    }
    return 0;
}
</code></pre>

<p>Input</p>

<pre><code>2 m
3 ft
6 in
</code></pre>

<p>Output</p>

<pre><code>Enter a distance with a unit of measure (ft, in, cm, m):
200 cm is the smallest distance entered so far.
200 cm is the largest distance entered so far.
91.44 cm is the smallest distance entered so far.
200 cm is the largest distance entered so far.
15.24 cm is the smallest distance entered so far.
200 cm is the largest distance entered so far.
</code></pre>
",0
36644647,36644508,1,"<pre><code> instanceA( x );
</code></pre>

<p>is not a function</p>
",0
36644609,36644508,4,"<p>For the 2nd case (<a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""nofollow"">member initializer list</a>), <code>instanceA</code> will be initialized by <code>A::A(int)</code> directly.</p>

<p>For the 1st case, <code>instanceA</code> will be initialized by <code>A::A()</code> (the default constructor) firstly, the body of the constructor will be executed later. Because <code>A</code> doesn't have a default constructor, it failed.</p>

<blockquote>
  <p>Initialization order  </p>
  
  <p>3) Then, non-static data members are initialized in order of
  declaration in the class definition.<br>
  4) Finally, the body of the constructor is executed</p>
</blockquote>

<p>And <code>instanceA(x);</code> won't do what you expected (i.e. call <code>A::A(int)</code> to initialize it), it will be parsed as <code>instanceA.operator()(x);</code> and won't compile since it's doesn't provide <code>operator()</code>.</p>
",4
38981341,38981297,0,"<p>Thanks for helping me now I know that I am supposed to use </p>

<pre><code>bubbleSort(num, terms);
</code></pre>
",1
38981400,38981297,1,"<p>Although a good question should be accompanied by a complete example of the compiler error, this answer should be fine.</p>

<pre><code>void bubbleSort(int arr[], int term) {
  // ...
}
</code></pre>

<p>It's a function which accepts an array of integers as first parameter and an integer as second one.</p>

<p>When you try to invoke it with:</p>

<pre><code>int num[5] = {2, 9, 5, 10, 6};
// ...
bubbleSort(num[5], terms);
</code></pre>

<p>You're passing <code>num[5]</code> which is not an array of integer, but it should be an <em>element</em> of the array <code>num</code>, then an integer itself.</p>

<p>In short you're calling the function passing</p>

<pre><code> bubbleSort(INT, INT);
</code></pre>

<p>and not, as requested by the function</p>

<pre><code> bubbleSort(ARRAY_INT, INT);
</code></pre>

<p>That' why the compiler doesn't find a function which names <code>bubbleSort</code> and accept two integers.</p>

<h1>Additional note</h1>

<p>It's a little be out of context, but I want to suggest you to improve your C++ base skills, because the expression:</p>

<pre><code>num[5]
</code></pre>

<p>It's perfectly wrong in your code, because it tries to access to the 6-th element in the array (which is composed by only 5 elements), that'll produce an out-of-bound behaviour.</p>
",0
36757610,36757440,1,"<ol>
<li>Define an <strong>int</strong> value for each combination according to their order. HighestCard - 0, OnePair - 1, ...</li>
<li>Find out what combination does each hand has. You already did it with your if statements. Just store the corresponding values somewhere.</li>
<li>Sort cards in each hand by their ranks. Suits are no longer needed as all combinations are already defined.</li>
<li>Sort hands. First compare hand combination values. In case they are equal then compare cards starting from the highest one by one.</li>
<li>The winning hand is the first (last) in the sorted container.</li>
</ol>

<p>Also it might be useful to check out <a href=""http://www.everfall.com/paste/id.php?92wpizwskbni"" rel=""nofollow"">this code</a> for optimized definition of combinations.</p>
",0
36327779,36327494,18,"<p>The cast in</p>

<pre><code>A* a1 = (A*)new B;
</code></pre>

<p>is a cast to inaccessible base class.</p>

<p>It can only be expressed as a C style cast. It is equivalent to what a <code>static_cast</code> would do if a <code>static_cast</code> could be used in this situation, and it is not equivalent to a <code>reinterpret_cast</code>. In particular the result address is not necessarily the same as the argument address.</p>

<b>C++11 ¡ì5.4/4:</b>

<blockquote>
  <p><strong>&rdquo;</strong>  The same semantic restrictions and behaviors [as for a <code>static_cast</code>] apply [for a C style cast], with the exception that in performing a <code>static_cast</code> in the following situations the conversion is valid even if the base class is inaccessible:</p>
  
  <p>¡ª a pointer to an object of derived class type or an lvalue or rvalue of derived class type may be explicitly converted to a pointer or reference to an unambiguous base class type, respectively;</p>
</blockquote>
",3
36327931,36327494,8,"<p>This is allowed by the rules of C-style casts:</p>

<blockquote>
  <p>(N3337) <code>[expr.cast]/4</code>: The conversions performed by</p>
  
  <ul>
  <li>a const_cast (5.2.11),</li>
  <li>a static_cast (5.2.9),</li>
  <li>a static_cast followed by a const_cast,</li>
  <li>a reinterpret_cast (5.2.10), or</li>
  <li>a reinterpret_cast followed by a const_cast,</li>
  </ul>
  
  <p>can be performed using the cast notation of explicit type conversion. The same semantic restrictions
  and behaviors apply, <strong>with the exception that in performing a static_cast in the following situations the conversion is valid even if the base class is inaccessible</strong>:</p>
  
  <ul>
  <li><p><strong>a pointer to an object of derived class type or an lvalue or rvalue of derived class type may be explicit
  converted to a pointer or reference to an unambiguous base class type, respectively;</strong></p></li>
  <li><p>[...]</p></li>
  </ul>
</blockquote>

<p>If you change to a <code>static_cast</code>, then this will fail to compile. GCC gives this error:</p>

<pre><code>error: 'A' is an inaccessible base of 'B'
    A* a1 = static_cast&lt;A*&gt;(new B);
</code></pre>
",0
36327613,36327494,5,"<p>Explicit casting allow you to do everything you want. You can, for example, to write so:</p>

<pre><code>int *p = (int*)new B; 
</code></pre>

<p>and the code will be compiled.
Explicit cast means that you know what you are doing.</p>
",4
36329784,36327494,1,"<p>The explicit typecasting is a programming feature of C language which doesn't have any object orientation features or rules. For C language everything is pointers (to memory or functions). Updcasting and downcasting are object orientation features provided by c++. The inheritance casting must behave on the object orientation rules of the language.  However, by typecasting the object like this: <code>A* a1 = (A*)new B;</code> you force 
the compiler to treat the object as <code>A</code> just as you would do in C by forcing a pointer of a struct to another. Therefore, when the compiler decides which function pointer to assign on the <code>f()</code> calling pointer of the casted object it assigns the pointer of the <code>A</code> class implementation.</p>
",1
47533116,47530113,1,"<blockquote>
  <p>why does the following code changes its output when I replace virtual void f() in class A with void f()? (it prints B when void, C when virtual void)</p>
</blockquote>

<p>When a class inherits from another (like in your case <code>B</code> and <code>C</code> from <code>A</code> and <code>B</code> respectively), the <code>virtual</code> keyword means that the method it is applied to (<code>f()</code>) in your case) can be re-defined for child classes. In your case, it allows classes <code>B</code> and <code>C</code> to have their own personal implementations for <code>f()</code>, through polymorphism. Notice how in your <code>main()</code> you create a <code>C</code> object, and not a <code>B</code>:</p>

<pre><code>B *p = new C;
</code></pre>

<p>it seems confusing because the address of that <code>C</code> object is stored in a <code>B</code> pointer, but is is legal in C++ because a <code>C</code> object is in fact <code>B</code> object, because it inherits (has a ""is a"" relationship) from <code>B</code>. When you call <code>f()</code>on that <code>B</code> pointer storing a <code>C</code> object, polymorphism is enabled because the method is <code>virtual</code>: it selects the <code>C</code>-version of the <code>f()</code> method, and that is why you see a <code>C</code> printed.</p>

<p>When you remove the <code>virtual</code> polymorphism is disabled the the <code>C</code> object is seen as a <code>B</code> object, and the <code>B</code>-version of <code>f()</code> is selected. Then you see ""<code>B</code>"" on your screen.</p>

<blockquote>
  <p>Why does the following code print more than ""CPP!""?</p>
</blockquote>

<p>From <a href=""http://www.cplusplus.com/doc/tutorial/control/"" rel=""nofollow noreferrer"">this</a>, it says that: </p>

<blockquote>
  <p>The switch statement has a somewhat peculiar syntax inherited from the
  early times of the first C compilers, because it uses labels instead
  of blocks. In the most typical use (shown above), this means that
  break statements are needed after each group of statements for a
  particular label. If break is not included, all statements following
  the case (including those under any other labels) are also executed,
  until the end of the switch block or a jump statement (such as break)
  is reached.</p>
</blockquote>

<p>So, try this instead:</p>

<pre><code>int main ()
{
    int x[10] = {1,2,3,4,5,6,7,8,9,10};
    for(int y:x)
    {
        switch(y)
        {
            case 1:cout&lt;&lt;""C"";break; // &lt;- notice the 'break'!
            case 3:cout&lt;&lt;""P"";break;
            case 7:cout&lt;&lt;""P"";break;
            case 8:cout&lt;&lt;""!"";break;
        }
    }
}
</code></pre>
",0
36688847,36688727,0,"<p>Allocating a 2D array as a one big chunk permits the compiler to generate a more efficient code than doing it in multiple chunks. At least, there would be one pointer dereferencing operation in one chunk approach. BTW, declaring the 2D array like this:</p>

<pre><code>Object obj[rows][cols];
obj[x][y]; 
</code></pre>

<p>is equivalent to:</p>

<pre><code>Object* obj = new Obj[rows * cols];
obj[x * cols + y]; 
</code></pre>

<p>in terms of speed. But the first one in not dynamic (you need to specify the values of ""rows"" and ""cols"" at compile time.</p>
",6
36689007,36688727,0,"<p>First and less important, when you allocate and free your object you only need to do a single allocation/deallocation.</p>

<p>More important: when you use the array you basically get to trade a multiplication against a memory access. On modern computers, memory access is much much much slower than arithmetic.</p>

<p>That's a bit of a lie, because much of the slowness of memory accesses gets hidden by caches -- regions of memory that are being accessed frequently get stored in fast memory inside, or very near to, the CPU and can be accessed faster. But these caches are of limited size, so (1) if your array isn't being used all the time then the row pointers may not be in the cache and (2) if it <em>is</em> being used all the time then they may be taking up space that could otherwise be used by something else.</p>

<p>Exactly how it works out will depend on the details of your code, though. In many cases it will make no discernible difference one way or the other to the speed of your program. You could try it both ways and benchmark.</p>

<p>[EDITED to add, after being reminded of it by Peter Schneider's comment:] Also, if you allocate each row separately they may end up all being in different parts of memory, which may make your caches a bit less effective -- data gets pulled into cache in chunks, and if you often go from the end of one row to the start of the next then you'll benefit from that. But this is a subtle one; in some cases having your rows equally spaced in memory may actually make the cache perform <em>worse</em>, and if you allocate several rows in succession they may well end up (almost) next to one another in memory anyway, and in any case it probably doesn't matter much unless your rows are quite short.</p>
",0
36689012,36688727,0,"<p>By having one large contiguous chunk of memory, you may get improved performance because there is more chance that memory accesses are already in the cache.  This idea is called <em>cache locality</em>.  We say the large array has better cache locality.  Modern processors have several levels of cache.  The lowest level is generally the smallest and the fastest.  </p>

<p>It still pays to access the array in meaningful ways.  For example, if data is stored in row-major order and you access it in column-major order, you are scattering your memory accesses.  At certain sizes, this access pattern will negate the advantages of caching.</p>

<p>Having good cache performance is far preferable to any concerns you may have about multiplying values for indexing.</p>
",0
37076480,37074348,2,"<p>your problem resides with understanding how to use polymorphism,
polymorphism works on reference and on pointers in your case it's neither.
let's explore it:</p>

<pre><code> class A {
  public: 
  virtual ~A() {};
  virtual void chase(char bd) { cout &lt;&lt; ""A chases : ""&lt;&lt; bd &lt;&lt; endl; }
</code></pre>

<p>};</p>

<pre><code>class B : public A {
 public:
 void chase(char bd) override { cout &lt;&lt; ""B chases : "" &lt;&lt; bd &lt;&lt; endl; } 
};
</code></pre>

<p>in main or w/e:</p>

<pre><code>A a, *aptr;
B b;
a.chase('s');
b.chase('s');
aptr = &amp;b;
aptr-&gt;chase('s');
a = b;
a.chase('s');
A &amp;ref = b;
ref.chase('s');
</code></pre>

<p>... will yeild:
A chases : s</p>

<p>B chases : s</p>

<p>B chases : s</p>

<p>A chases : s</p>

<p>B chases : s</p>

<p>why? in those two polymorphism was never used it's a ""regular objects""
a.chase('s'); 
b.chase('s');</p>

<p>aptr = &b;  &lt;-we gave aptr the address of a b object 
since chase is virtual now polymorphism kicks in
aptr->chase('s');</p>

<p>same goes with references:
aptr = &b;
aptr->chase('s');</p>

<p>but what you did was actually this: 
a = b; here b copies it's ""A"" part into a but since a can't hold the ""B"" part
it doesn't hold it as far as it concern it thinks of b as an A object
a.chase('s'); so that will yield the A chase and not the B chase</p>

<p>so tips: polymorphism can be used with: pointers(smart pointers or raw pointers like i used in my example) or reference. 
if you wanna use polymorphic powers it will do iff you used pointers/references</p>

<p>another tip is use override to notice the compiler that you're overriding a ""parent"" function it will help you when you have bad parameters and etc( will produce proper compiler error and etc. </p>

<p>and one of the most vital things is always make your destructor in the base class virtual to make sure no zombies will appear </p>
",0
37076763,37074348,2,"<p>Your <code>Board</code> class contains an array of <code>Ghost</code> objects, not <code>Chase</code> objects. So <code>G[0].chase(bD);</code> will always call <code>Ghost::chase()</code>, never <code>Chase::chase()</code>.  Just because you <em>define</em> an override in <code>Chase</code> does not mean it is used automatically everywhere a <code>Ghost</code> is used.  Polymorphism only works when you have a pointer/reference of a base class type pointing at an object of a derived type.  Your code does not have that.  To fix that, make your array hold <code>Ghost*</code> pointers that point at <code>Chase</code> objects.  For example:</p>

<pre><code>class Board
{
private:    
    Ghosts* G[4];

public:
    Board()
    {
        for (int i = 0; i &lt; 4; i++)
            G[i] = new Chase;
    }

    ~Board()
    {
        for (int i = 0; i &lt; 4; i++)
            delete G[i];
    }

    void Chase(char bD)
    {
        G[0]-&gt;chase(bD); 
    }
};
</code></pre>
",1
39679172,39678949,3,"<p>To count the number of 1's in the first 8 bits of x:</p>

<pre><code>int value(int x)
{
  return bitset&lt;8&gt;(x).count();
}
</code></pre>

<p>To count all the bits:</p>

<pre><code>int value(int x)
{
  return bitset&lt;sizeof(x) * CHAR_BIT&gt;(x).count();
}
</code></pre>

<p>If you have to use a loop solution: (Adaption to your solution with available functions)</p>

<pre><code>int value(int x)
{
    int counter=0;
    bitset&lt;8&gt; i(x);
    while (i != 0) {
       if(i[0] == 1) {
           counter++;
       }
       i &gt;&gt;= 1;
  }
  return counter;
}
</code></pre>
",8
37399864,37399374,1,"<p>This is all completely implementation dependant. A compiler doesn't have to use a vptr to implement virtual classes at all. </p>

<p>However, in your example, the C object and A subobject share a vptr, and the B subobject has its own vptr. Both are the size of a pointer, which in your implementation is 4.</p>
",0
37399920,37399374,2,"<p>While size of any custom type is compiler dependent and can change with new compiler, new OS or without any reason, it is useful to know where it is coming from and what usually affect sizes of your types.</p>

<p>Any analysis will be based on particular impmlementation, so I will take g++ on Linux. Giving 3 classess you have (I added another virtual function to C for more insight), compiled in 64bit mode, I see following sizes:</p>

<p><code>sizeof(A)</code> = <code>sizeof(B)</code> = 8, <code>sizeof(C)</code> = 16. Where those sizes come from?</p>

<p><code>A</code> and <code>B</code> are easiest to reason about. They are very similar, and they do not have any data members. However, they do have a <code>virtual</code> function. Implementation of virtual functions in g++ is done through virtual functions table, and every instance of the class has a pointer to it. In 64bit systems, pointers are 8 bytes, so both those classess have the size of 8.</p>

<p>Now, class <code>C</code>. What's with it's size? One might expect it to be 24, right? 8 bytes for vptr of A, 8 bytes for vptr of B, and 8 bytes for vptr of C. But if you think about it, we do not really need a separate vptr for C. Instead, we could create a virtual table with methods of A, add our virtual function to it, and use a pointer to this new table. Thus we do not need an extra pointer there! We still need a separate pointer to B's table, so that object would behave correctly when cast to B.</p>
",4
37399949,37399374,0,"<p>As has been remarked. Standard doesn't specify virtual pointer at all. And it is all implementation dependent.</p>

<p>Your compiler is 32 bit having 4 byte pointer size.
So A's size is 4. B's size is 4.</p>

<p>Now C has two vptr in it. One coming from class A and other from class B. It can use vpty from parent's class.  Now even if a new virtual method is define, it would reuse one of the parent's pointer. (In case of gcc4.8, it's A's vptr will be used as C's vptr)</p>
",0
41902131,41901789,0,"<p>In <code>void printGenre(vector&lt;Movie&gt; &amp;d)</code></p>

<pre><code>getline(cin, whatGenre); &lt;&lt; reads in genre from user
cin &gt;&gt; whatGenre; &lt;&lt; reads in the genre again, but this time only one word of it.
</code></pre>

<p>A second read of <code>whatGenre</code> overwrote the first. Why is this being done? Well... this is why we needed to see more code.</p>

<p>Way back in <code>main</code> </p>

<pre><code>cin &gt;&gt; choice;
</code></pre>

<p>read in the a single character. But to get that character, the user had to provide the character and press enter. The enter remained in the input stream, was parsed by </p>

<pre><code>getline(cin, whatGenre);
</code></pre>

<p>and placed the resulting empty string in <code>whatGenre</code>.</p>

<p>Be careful flipping back and forth between <code>&gt;&gt;</code> and <code>std::getline</code>. Preferably use only one.</p>

<p>Solution:</p>

<p>Remove </p>

<pre><code>cin &gt;&gt; whatGenre;
</code></pre>

<p>and replace </p>

<pre><code>cin &gt;&gt; choice;
</code></pre>

<p>with </p>

<pre><code>string choicestr;
getline(cin, choicestr);
choice = choicestr[0];
</code></pre>

<p>or something similar.</p>

<p>You will have to do the same for some of your other functions as well.</p>
",0
36393669,36393545,0,"<p>From what I can tell on what you shared is that you don't have an array setup to handle multiple people/numbers/info. It would look something like:</p>

<pre><code>gin.getline(name[I],50,'\n');
</code></pre>

<p>This will store each entry in a different spot in memory without needing to separately make new variables every time.</p>
",0
41902492,41901801,0,"<p>I'm not certain that this is a typo or an attempt at doing something crafty that went awry, but </p>

<pre><code>number2 = largest;
</code></pre>

<p>and its friends seem to be assigning in the wrong direction. The reason that I think it could be a logic mistake is</p>

<pre><code>largest = number1; // assume first integer is largest

if (number2 &gt; largest){ // formerly number2 &gt; number1 and largest == number1 
    largest = number2;
}

if (number3 &gt; largest) { // formerly number3 &gt; number2 and continuing from above 
                         // number2 may have been equal to largest. This is where 
                         // the logic breaks down
    largest = number3;
}
</code></pre>

<p>would be a reasonable way to solve this.</p>
",0
41904276,41901801,0,"<p>Besides to some logic errors, the problem lies in how you have used the equal sign, referred to in c++ as the copy assignment operator. I'll explain how it works:</p>
<h3>In simple terms, the assignment operator (=) serves the purpose of copying the value on the right-hand side of the equal sign to the variable on the left side of the equal sign.</h3>
<p>Simply, if we do this:</p>
<pre><code>    int a = 2;
    int b = 3;
    b = a;
</code></pre>
<p>This copies the value stored on the right side of the assignment operator (i.e from <code>a</code>) to the variable on the left side (i.e to <code>b</code>). In effect, the variable <code>b</code> stores the value 2 now, not 3. On the other hand, <code>a</code> retains the value 2.</p>
<p>However, if we did this:</p>
<pre><code>    int a = 2;
    int b = 3;
    a = b;
</code></pre>
<p>This would mean that <code>a</code> now stores the same value as <code>b</code> stores, which is 3, while <code>b</code> still stores 3.</p>
<p>The problem in your code is not the logic, but rather the improper use of the assignment operator, because in the following lines:</p>
<pre><code>    number2 = largest;
    number3 = largest;
</code></pre>
<p>Instead of setting the variable <code>largest</code> to <code>number2</code> or <code>number3</code>, depending on the input, you are unknowingly setting the value of <code>number2</code> or <code>number3</code> to the current largest value, which would be the value of number1. This is because in the line:</p>
<pre><code>    largest = number1; // assume first integer is largest
</code></pre>
<p>You set the variable largest to the value in number1. That's why you would notice that your max value is always the value in <code>number1</code>.</p>
<p>This same problem persists when you try to find the smallest value, because your smallest value is set to <code>number1</code> again, just like above, and you set this value to <code>number2</code> or <code>number3</code> instead of moving the smallest value <strong>from</strong> <code>number2</code> or <code>number3</code>.</p>
<hr />
<p>Another problem is your logic. Consider the following lines (I've fixed your equal signs):</p>
<pre><code>largest = number1; // assume first integer is largest

if (number2 &gt; number1){
largest = number2;
}

if (number3 &gt; number2) {
largest = number3;
}
</code></pre>
<p>Now let's use the number 3, 1, 2 for <code>number1</code>, <code>number2</code>, <code>number3</code> respectively. We begin by setting <code>number1</code> to 3. We then compare number1 to number2, which gives us 1 &gt; 3, and this is false, so the largest number remains number1. However, you then make the comparison to see if <code>number3 &gt; number2</code>, and this means 2 &gt; 1, which is true. So as a result, you allocate <code>largest</code> to number3, even though you make no comparison between <code>number3</code> and <code>number1</code>. The same problem persists in your logic for finding the smallest value.</p>
<p>Here's some logic that works (I've tried and tested it):</p>
<pre><code>if (number1 &gt; number2)
{
    if (number1 &gt; number3)
        largest = number1;
    else
        largest = number3;
}
else
{
    if (number2 &gt; number3)
        largest = number2;
    else
        largest = number3;
}

if (number1 &lt; number2)
{
    if (number1 &lt; number3)
        smallest = number1;
    else
        smallest = number3;
}
else
{
    if (number2 &lt; number3)
        smallest = number2;
    else
        smallest = number3;
}
</code></pre>
<p>Hope this answers your question.</p>
",0
40558029,40557848,0,"<p>Your function does not have a return type. C++ will therefore default to <code>int</code>.
to solve this, make sure the function returns an <code>Array&lt;int&gt;</code> (the type of tmp).</p>
",1
40558147,40557848,0,"<p>You need to template <code>Array&lt;int&gt; tmp;</code> as <code>Array&lt;T&gt; tmp;</code>, so that then you <code>memcpy(tmp.data, a.data, sizeof(int)*num);</code> the size of memory area would realy be same. Also, as @Thecocatrice mentioned, add retutn type to you overloaded operator. 
This will look like</p>

<pre><code>template&lt;typename T&gt;
Array&lt;T&gt; Array&lt;T&gt;::operator *(const Array&lt;T&gt; &amp;a) { ... };
</code></pre>

<p>And last. You dont actually need that <code>memcpy</code>. It doesnt make any sence, since you still have loop. Just write:</p>

<pre><code>for(int i = 0 ; i &lt; num ; i++)
{
    tmp.data[i] = data[i] * a.data[i];
} 
</code></pre>
",0
36229057,36228976,0,"<p>If you're dealing with single digit, positive integers, you can just change <code>int</code> to <code>char</code>, and it will work. For anything outside of [0-9], you will have to convert.</p>

<p><a href=""http://www.cplusplus.com/reference/string/stoi/"" rel=""nofollow"">stoi (string to int)</a> will get you the numbers. Then on the way back out, use <a href=""http://www.cplusplus.com/reference/string/to_string/"" rel=""nofollow"">to_string</a> to return a string back.</p>

<p>Also, if you're expecting a certain input, you should not use a template. Your code would allow the caller to use a <code>string</code>, an <code>int</code>, and a <code>vector</code> which would just make everything go haywire when it actually ran.</p>
",0
36229080,36228976,0,"<p>Unless really performance critical, don't write it yourself, use std::max instead. However as this is most likely for educational purposes, the importance is understanding it.</p>

<p>Whenever you have a template, try reading this code as if T was replaced by the wanted type. (Which is actually what the compiler does for you)</p>

<p>So, when called with std::string, you get the function:
<code>std::string findMax(std::string a, std::string b, std::string c)</code></p>

<p>In which case, you will get a compilation error: <code>int max = a</code> as you can't assign a string to an integer. So either you need a conversion from std::string to int, which can be done by passing an std::function. However in this case, I guess you want to write <code>T max = a</code> or even <code>auto max = a</code></p>
",0
41930033,41929895,3,"<p>You use an object on the stack if you don't have the need for the object outside of the scope where it is created.</p>

<p>Example:</p>

<pre><code>int foo(int in)
{
   int i = in + 2;
   return i;
}
</code></pre>

<p><code>i</code> is not needed outside <code>foo</code>. Hence, you create an object on the stack and return its value.</p>

<p>You use an object on the heap if you have a need for the object outside the scope where it is created.</p>

<pre><code>int* foo(int in)
{
   int* ip = new int(in + 2);
   return ip;
}
</code></pre>

<p>The pointer that <code>ip</code> points to is returned from <code>foo</code> and is expected to be used by the calling function. Hence, you need to create an object on the heap and return it.</p>

<p>That's the conceptual aspect of the difference. Normally, you won't need to use an object from the heap if you are talking about an <code>int</code>. The difference becomes important when you need to return an array.</p>

<pre><code>int* foo()
{
   int arr[] = {1, 2, 3, 4};
   return arr;
}
</code></pre>

<p>That function will be a problem since it returns a pointer that will be invalid as soon as the function returns. </p>

<pre><code>int* foo()
{
   int* arr = new int[4]{1, 2, 3, 4};
   return arr;
}
</code></pre>

<p>That will work since the returned pointer will point to valid objects even after the function returns. The calling function has to take responsibility to deallocate the memory though.</p>
",1
41930201,41929895,-1,"<p>Difference can be seen from performance point of view.</p>

<p>Consider the <strong>worst case</strong> scenario:</p>

<p><code>int ptr;</code>  In this case all the required memory will be on the same page.</p>

<p><code>int *ptr = new int;</code>  In this case the address of <code>ptr</code> can be on one page and the memory which it points to can be on different page which may result in a page-fault while accessing the memory indirectly i.e <code>*ptr</code>.</p>
",2
36498391,36498302,0,"<p>Have you considered not using a fixed array size if that is not what you want? You could just use a <code>char*</code> instead and assign it's size dynamically.</p>

<p>If you want a fixed size for some reason the only solution I can come up with is to track in a separate variable how long the word is and then only print the n first characters. There is no way to determine which chars are valid and which are not in the array as far as I know.</p>
",1
36498414,36498302,3,"<p>C strings are terminated by a NUL byte (<code>'\0'</code>). If you don't have this terminator then <code>printf</code> doesn't know that your string has ended. The solution is to put a <code>\0</code> after your word in the array.</p>

<p>Note: learn to use <a href=""http://en.cppreference.com/w/cpp/string/basic_string"" rel=""nofollow""><code>std::string</code></a> which manages this for you.</p>
",0
36498732,36498302,0,"<p>Other than that, if your buffer is supposed to be just a byte array and not a (null terminated) string, then you can use fwrite instead of fprintf to dump the contents.</p>

<p>But in general, I agree with others that it could be better to use std::string.</p>
",0
39684697,39683669,0,"<p>It is talking about <a href=""http://en.cppreference.com/w/cpp/language/using_declaration"" rel=""nofollow"">using declaration</a>.</p>

<p>By making use of ""using declaration"" you can bring names into current scope, so that they become visible to your current block of code, so that they become readily resolvable, so that you can reduce ambiguity during multiple inheritance, so that you don't have to type long specifiers in order to access them (like the short-cut of using <em>cout</em> instead of <em>std::cout</em>.) But, their access status still remains same (private remains private, public remains public, protected remains protected).</p>

<pre><code>class Base {
    public:
    int x;
    private:
    int y;
    protected:
    int z;
};

class Derived : public Base {

    // Bring x,y,z into scope
    // x is still public. y is still private. z is still protected.

    using Base::x;
    using Base::y; // This fails to compile. Why bring something into scope when you don't have access to it?
    using Base::z;
};
</code></pre>

<p>The above code isn't a convincing example of <em>using declaration</em> (because, inheritance already brings names into scope). It becomes more useful in other cases (like multiple inheritance or when you are trying bring a name that is very distance away from your current scope (like creating a short-cut name).</p>

<pre><code>namespace X {
    namespace Y {
       namespace Z {
          namexpace W {
              int deep_x;
              int deep_y;
          }
       }
    }
 }

int main()
{
     cout &lt;&lt; X::Y::Z::W::deep_x;
     // Bringing X::Y::Z::W::deep_y into scope
     using X::Y::Z::W::deep_y;
     cout &lt;&lt; deep_y;
}
</code></pre>
",0
39685200,39684835,0,"<p>If you want to use a map, then what you want to do is keep adding to the vector that's associated with the key.</p>

<p>The following example shows how to do this:</p>

<pre><code>#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

typedef std::map&lt;int, std::vector&lt;int&gt;&gt; MapV;

using namespace std;

int main()
{
    MapV mymap;
    string line;

    // get one line of data
    while (getline(cin, line))
    {
        // use a string stream to parse the data
        istringstream strm(line);
        int key, data;

        // first value is the key
        strm &gt;&gt; key;

        // all other values are the data
        while (strm &gt;&gt; data)
        {
            // the magic is here.
            auto pr = mv.insert(make_pair(key, std::vector&lt;int&gt;()));

            // add item to the vector
            pr.first-&gt;second.push_back(data);
        }
    }
}
</code></pre>

<p>The most important part of the code is this line:</p>

<pre><code>    auto pr = mv.insert(make_pair(key, std::vector&lt;int&gt;()));
</code></pre>

<p>The <a href=""http://en.cppreference.com/w/cpp/container/map/insert"" rel=""nofollow"">std::map::insert</a> function will return a <code>std::pair</code>, denoting the iterator to the inserted item as the <code>first</code> of the pair, or if the key exists, the existing iterator to the key that already exists.</p>

<p>Then all we need to do is to take that return value, access the <code>second</code> (which is the vector), and merely <code>push_back</code> onto that vector.</p>

<p>See this <a href=""http://ideone.com/kc4rXQ"" rel=""nofollow"">live example</a></p>
",0
41225112,41224826,-2,"<pre><code>  gets(s); //Helloworld   -- reads a string from keyboard to s
  gets(s+2);//dog         -- reads a string from keyboard to s started with char 2
  sort(s+1,s+7);          -- sorts s in interval [1, 7]
  puts(s+4);              -- writes to console s from char 4
</code></pre>

<p>gets(s); //Helloworld   --> s=<strong>Helloworld</strong></p>

<p>gets(s+2);//dog         --> s=He<strong>dog</strong></p>

<p>sort(s+1,s+7);          --> s=H<strong>dego</strong></p>

<p>puts(s+4);              --> console=Hdeg<strong>o</strong></p>
",2
41225198,41224826,0,"<p>The best thing to say about the code is that it is very bad.  Luckily, it is short but it is vulnerable, unmaintainable and error prone.</p>

<p>However, since the previous is not really an answer, let's go through the code, assuming the standard include files were used and ""using namespace std;"":</p>

<ul>
<li>char s[20];   </li>
</ul>

<p>This declares an array of 20 characters with the intent of filling it with a null-terminated string.  If somehow, the string becomes larger, you're in trouble</p>

<ul>
<li>gets(s); //Helloworld</li>
</ul>

<p>This reads in a string from stdin.  No checks can be done on the size.  The comment assumes it will read in Helloworld, which should fit in s.</p>

<ul>
<li>gets(s+2);//dog</li>
</ul>

<p>This reads in a second string from stdin, but it will overwrite the previous string starting from the third character.  So if the comment is write, s will contain the null-terminated string ""Hedog"".</p>

<ul>
<li>sort(s+1,s+7);</li>
</ul>

<p>This will sort the characters in asserting ascii value from the second up to the seventh character.  With the given input, we already have a problem that the null-character is on the sixth position so it will be part of the sorted characters and thus will be second, so the null-terminated string will be ""H"".</p>

<ul>
<li>puts(s+4);</li>
</ul>

<p>Writes out the string from the fifth position on, so until the null-charater that was read in for ""Helloworld"", but then overwritten and half-sorted.  Of course input can be anything, so expect surprises.</p>
",0
41225808,41224826,2,"<p>Draw it on paper, along these lines.</p>

<p>At first, twenty uninitialised elements:</p>

<pre><code>| | | | | | | | | | | | | | | | | | | | |
</code></pre>

<p><code>gets(s)</code>:</p>

<pre><code>|H|e|l|l|o|w|o|r|l|d|0| | | | | | | | | |
</code></pre>

<p><code>gets(s+2)</code>:</p>

<pre><code>|H|e|d|o|g|0|o|r|l|d|0| | | | | | | | | |
     ^
     |
    s+2
</code></pre>

<p><code>sort(s+1, s+7)</code>:</p>

<pre><code>|H|0|d|e|g|o|o|r|l|d|0| | | | | | | | | |
   ^           ^
   |           |
  s+1         s+7
</code></pre>

<p><code>puts(s+4)</code>:</p>

<pre><code>|H|0|d|e|g|o|o|r|l|d|0| | | | | | | | | |
         ^
         |
        s+4 
</code></pre>
",0
42658397,42657508,2,"<p>As @SomeProgrammerDude explained and you already knew, you specify <code>signed</code> or <code>unsigned</code> explicitly when you wish to use small integral values. On an AMD-64 architecture (which is the most widely-used architecture for 64-bit general-purpose CPUs, and it probably the one you have on your laptop), a <code>signed char</code> takes up 1 byte and ranges from -128 to 127, while an <code>unsigned char</code> also takes up 1 byte but ranges from 0 to 255.</p>

<p>I would like to push this a little further by showing how using <code>signed</code> or <code>unsigned</code> integral types (such as <code>char</code>, <code>short</code>, <code>int</code>, ...) impact the final program and are actually implemented. I'll use the example of  <code>char</code>, but the principle is identical with other integral types.</p>

<p>Assume we have this small program:</p>

<pre><code>// main.cpp

#include &lt;iostream&gt;

int main() {
    signed char   sc = (signed char)255; // equivalent to sc = -1
    unsigned char uc = 255;

    bool signedComp   = (sc &lt;= 5);
    bool unsignedComp = (uc &lt;= 5);

    return 0;
}
</code></pre>

<p>If we have a look at the assembler (the code that is very close to what your CPU actually does), we can observe the difference. Here is the most relevant part of the assembler code:</p>

<pre><code>movb    $-1, -4(%rbp) # sc = -1
movb    $-1, -3(%rbp) # uc = -1 (equivalent to uc = 255)

cmpb    $5, -4(%rbp)  # compare sc and 5, ...
setle   %al           # ... see whether sc was lower or equal (signed comparison), ...
movb    %al, -2(%rbp) # ... and set the boolean result into signedComp.

cmpb    $5, -3(%rbp)  # compare uc and 5, ...
setbe   %al           # ... see whether uc was below or equal (unsigned comparison), ...
movb    %al, -1(%rbp) # ... and set the boolean result into unsignedComp.
</code></pre>

<p>(If you are curious and want to generate the assembler yourself, run <code>g++ -S main.cpp -o main.s -O0</code> and have a look at part of the <code>main.s</code> file where you see the <code>main:</code> tag.)</p>

<p>On your memory (specifically, on the <em>stack</em>), both <code>sc</code> and <code>uc</code> will take up 1 byte. In fact, <code>sc</code> and <code>uc</code> actually contain the <em>same</em> value of <code>255</code>. However, it's the <em>way</em> the comparison is done that makes <code>sc</code> and <code>uc</code> different.</p>

<p>Thus, this :</p>

<blockquote>
  <p>there isn't much of a difference between an <code>unsigned char</code> and a <code>signed char</code></p>
</blockquote>

<p>... is ironically 100% true.</p>

<p>The lesson to learn from this is that the numbers programmers work with are just conceptual. In the end, it's all about <em>how</em> you work with the 1s and 0s.</p>
",6
40999488,40999268,1,"<pre><code>int na = 0;
int *a = (int*)malloc(na*sizeof(int));
read(a, na);
</code></pre>

<p>Here's the problem. You create a buffer of size 0, and then you write ""in"" it. Must create the buffer only when you figure out the size, which is after reading the size. Rearrange the code so that this line makes sense:</p>

<pre><code>int na = 0;
int *a = read(na);
</code></pre>

<p>Or better yet:</p>

<pre><code>std::vector&lt;int&gt; a = read();
</code></pre>
",0
47481421,31917916,0,"<p>I also encountered the same problem before. since velocity is double type.  velocity ^ 2 might be unscoped. Thus velocity * velocity  can solve the problem.</p>

<pre><code>int c;
int d;
int f = (c ^ 2 + d ^ 2);
</code></pre>
",0
36322803,36322714,1,"<p>Where did you get that idea about <code>7+4</code>?</p>

<p>Your code clearly says that <code>V[0][2]</code> is <code>V[0][1] + A[2][2]</code>. But on previous iteration of your cycle <code>V[0][1]</code> was set to <code>V[0][0] + A[0][1]</code>. And on yet previous iteration of your cycle <code>V[0][0]</code> was set to <code>A[0][0]</code>.</p>

<p>So, <code>V[0][0]</code> is <code>1</code>. Which makes <code>V[0][1] = 1 + 7 = 8</code>. Which makes <code>V[0][2] = 8 + 4 = 12</code>.</p>

<p>Everything is as you implemented it.</p>
",0
36664167,36663993,0,"<p>Your problem is circular dependencies.   That is reflected in your header files each including each other, so the definition of <code>World</code> depends on the definition of <code>Organism</code> which depends on the definition of <code>World</code>, ad infinitum.</p>

<p>The (non-standard) <code>#pragma once</code> might stop the header files from infinitely including each other, but does not change the fact that the types defined within them have that recursive dependence.</p>

<p>You need to break the dependency.   A common technique is to use forward declarations, and avoid having (at least) one of the headers relying on the other, and use declarations to break dependencies between the classes.</p>

<pre><code>#ifndef ORGANISM_H_INCLUDED     // include guard instead of #pragma once
#define ORGANISM_H_INCLUDED

class World;   // declaration of World

class Organism  
{  
     // as you have it
};
#endif
</code></pre>

<p>and </p>

<pre><code>#ifndef WORLD_H_INCLUDED
#define WORLD_H_INCLUDED

class Organism;
class World
{
     // as you have it
};
#endif
</code></pre>

<p>The important thing to realise is that, given a class declaration (not a definition) it is only possible to work with pointers or references.</p>

<p>To implement member functions of both classes that rely on knowledge of both full class definitions you will need to <code>#include</code> both headers.   Based on that, your code will be able to do things like create instances of either type.</p>
",0
36664071,36663993,8,"<p>It's because the <code>""Organism.h""</code> header file depends on the <code>""World.h""</code> header file which depends on the <code>""Organism.h""</code> and so on in infinity. It's a so-called <em>circular dependency</em>.</p>

<p>In your case it's very easy to break, since neither header file, as you show them, actually need the <em>definitions</em> of the other classes, only the <em>declarations</em>.</p>

<p>That means the <code>World.h</code> header file can look like this instead:</p>

<pre><code>#pragma once
// Note: No #include directive here
class Organism;  // Forward-declaration of the class
class World
{
    int height;
    int width;
    Organism*** organisms;
public:
    World();
    World(int, int);
    ~World();
    void DrawWorld();
    void NextRound();
};
</code></pre>

<p>The same can be done with the <code>Organism.h</code> header file.</p>

<p>The source file that <em>uses</em> the classes needs the full definitions of the classes, so they need to include both header files.</p>
",0
36485443,36485329,2,"<p><code>t</code> is not in the right scope for you to use. You declared it in the block after the <code>if</code> statement(s). Instead, you should declare it as a base class before the code blocks, and initialize it to child classes after each if statement (which you should really use <code>switch</code> instead, but this isn't codereview)</p>
",4
36485695,36485329,1,"<p>In C++ all the loops and <code>if</code> clauses have their own scope. So you should declare <code>t</code> outside of the <code>if</code> clauses, and you should declare <code>list</code> outside of the loop. Also C++ is the language with strict variable types, so you can't change the type of <code>t</code>, neither you can push values of different types to a list. To do so you should either use pointers <code>void*</code> with no type or create a parent class and derive all the different types you use for <code>t</code> from that class (then you cold use a pointer to a base class for <code>t</code> in that case). If you don't know how to do this, you would better read some books on object oriented programming in C++, it's too vast topic to explain in this answer.</p>

<p>The good book on this topic might be one of the books of Bjarne Stroustrup found, for example, <a href=""http://www.stroustrup.com/"" rel=""nofollow"">here</a>. </p>
",0
36241005,36240950,1,"<p>I suspect you're looking for <code>int test = true ? 5 : 1;</code></p>
",0
36241006,36240950,3,"<p>C++ isn't Lua.</p>

<p>In Lua, <code>true and 5</code> expression results in <code>5</code>. That's simply how Lua works with boolean expressions.</p>

<p>And that's not how C++ works with boolean expressions. In C++, a boolean expression results in a boolean <em>value</em>. That is, either <code>true</code> or <code>false</code>.</p>

<p>If you want to select between two values based on a condition, we have an operator for that:</p>

<pre><code>int i = true ? 5 : 3;
</code></pre>

<p>If the condition is true, you get the value before the <code>:</code>. If it's false, you get the value after the <code>:</code>.</p>
",0
36241008,36240950,1,"<p>What you need is a conditional expression:</p>

<pre><code>  int i = true ? 2 : 5;
</code></pre>

<p>In this case <code>i</code> will be 2.</p>
",0
36242115,36240950,0,"<p>If we really wanted to, as of c++11 (which gives us the <code>and</code> and <code>or</code> keywords as a synonyms for <code>&amp;&amp;</code> and <code>||</code>), we could almost strong-arm the c++ compiler into compliance, and get it to compile this:</p>

<pre><code>int x = when_true(b) and 5 or 6;
</code></pre>

<p>In order to do this we would need to provide some scaffolding:</p>

<pre><code>#include &lt;iostream&gt;

struct maybe_int {
    bool cond;
    int x;

    operator int() const { return x; }
};

int operator || (const maybe_int&amp; l, int r) {
    if (l.cond) return l.x;
    return r;
}

struct when_true {
    when_true(bool condition)
    : _cond(condition)
    {}

    auto operator&amp;&amp;(int x) const {
        return maybe_int { _cond, x };
    }

    bool _cond;

};


int main()
{
    using namespace std;

    auto b = false;
    int x = when_true(b) and 5 or 6;
    cout &lt;&lt; x &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>My suggestion would be that you don't try this kind of thing at work.</p>
",0
36242150,36242131,4,"<p>It¡¯s possible that operator[] for Container has been overloaded for rvalues and lvalues. </p>

<pre><code>auto Container::opeartor[](int i) &amp;&amp; -&gt; Container::value_type&amp;;
auto Container::opeartor[](int i) &amp; -&gt; Container::value_type&amp;;
</code></pre>

<p>If so, we want to make sure that if c was initialized with an rvalue, we call the rvalue version of operator[] on c. It¡¯s certainly not common to overload operator[] to behave differently for lvalues and rvalues, but it¡¯s possible, so in truly generic code, we need to apply std::forward to c before forwarding it to operator[].</p>
",2
48028277,48027264,1,"<p>""A class instance cannot contain an instance of itself"" - Oliver Charlesworth, The Comment Section.</p>

<p><a href=""https://stackoverflow.com/questions/26528633/create-an-instance-of-a-class-in-the-class-itself"">As mentioned elsewhere</a>, the class is not fully defined at the point of use (see the last line in the compiler error message), and would have problems with memory layout.</p>

<p>You therefore need to use pointers to manage the items in the array. One relatively straightforward adjustment to your code is to use <code>std::unique_ptr</code> instead (avoiding manual memory management with <code>new</code> and <code>delete</code>).</p>

<p><a href=""https://ideone.com/rWXRC8"" rel=""nofollow noreferrer"">IDEOne link w/ code</a></p>

<p>Note the ownership semantics where the stack owns the top node, which owns the node underneath, etc. You could emulate this with manually with raw pointers using <code>new</code> in the push function, and <code>delete</code> in the pop function.</p>
",0
42471770,42470703,0,"<p>I don't know if i correctly understood your question, but here we go:</p>

<p>The only node you 'KNOW' for fact is the root, then, if you want to go to the others, you just 'find your way' through the pointers (right and Left)</p>

<p>Also, Here's my recursive code on the Pre-Order:</p>

<pre><code>void pre_ordem(node *root)
{
    if(root!= NULL)
    {
        printf(""%d - "",root-&gt;num);
        pre_ordem(root-&gt;left);
        pre_ordem(root-&gt;right);
    }
}
</code></pre>
",0
36318195,36316989,0,"<p>First, the numeric format you are confused by is ""scientific notation"". That will be enough info to open up a world of google searches, or you can just force it not to print in scientific notation.</p>

<p>Second, you <em>really</em> want to use a time library for any calendar stuff.  It will handle all kinds of calendar weirdness for you, including leap years. Fortunately we have time.h</p>

<p>Third, I recommend using an integer type for seconds, partly to avoid rounding errors and ugly decimals, but mainly because that's what time.h uses. Just make sure it is big enough. My compiler uses a 64 bit integer for time_t, so I used that:</p>

<pre><code>#include &lt;time.h&gt;
#include &lt;memory&gt;

time_t get_age_in_seconds(int year, int month, int day)
{
    struct tm birthday;
    memset(&amp;birthday, 0, sizeof(birthday));
    birthday.tm_year = year - 1900;      // years since 1900
    birthday.tm_mon = month - 1;         // months since January (0,11)
    birthday.tm_mday = day;              // day of the month (1,31)

    time_t birthday_in_seconds = mktime(&amp;birthday);
    time_t now = time(NULL);
    return now - birthday_in_seconds;
}
</code></pre>
",0
36318717,36316989,0,"<p>Don't use doubles to do the calculation. You're not going to have any fractional values since you're not doing any division.</p>

<p>More importantly, look into <a href=""http://www.cplusplus.com/reference/ctime/mktime/"" rel=""nofollow""><code>mktime()</code></a>, <a href=""http://www.cplusplus.com/reference/ctime/time/"" rel=""nofollow""><code>time()</code></a>, and <a href=""http://www.cplusplus.com/reference/ctime/difftime/"" rel=""nofollow""><code>difftime()</code></a>. You should be using these to do your calculation.</p>
",0
40987705,40987645,5,"<p>This code is ill-formed. See C++14 [dcl.init]/4:</p>

<blockquote>
  <p>An empty initializer list <code>{}</code> shall not be used as the initializer-clause for an array of unknown bound.</p>
</blockquote>

<p>The compiler could reject the code, and if it doesn't then the behaviour of the program is completely undefined by the C++ standard.  Some compilers have a non-standard extension allowing zero-sized arrays.</p>
",1
40989041,40987645,0,"<p>Do you mean to use dynamic allocation?
This means you declare an array but don't give it a fixed size. </p>

<pre><code>int size = 10;
int * arr = new int[size];
</code></pre>

<p>Now you can add things to arr[] like normal. If you need more space, you have to make another array of the new size, copy the values over, set the new array equal to the old one (arr = newArr), then IMPORTANT: do delete [] newArr;</p>

<p>This is because arrays do not handle memory allocation by themselves like vectors do. You have to give it a number for the size, or declare it dynamically.</p>
",0
37110531,37109265,0,"<pre><code>std::mutex m;

auto my_lock = std::unique_lock&lt;std::mutex&gt;(m);
</code></pre>

<p>or...</p>

<pre><code>using mutex_type = std::mutex;
using lock_type = std::unique_lock&lt;mutex_type&gt;;

mutex_type m;

auto lock = lock_type(m);
</code></pre>
",0
37248145,37247824,1,"<p>Your program doesn't terminate with instance of bad alloc  when I tried to run. However, it does get warnings because of this line</p>

<p><code>Parcel parcel(parcel.getID(), parcel.getSenderName(), parcel.getSenderAddress(), parcel.getReceiverName(), parcel.getReceiverAddress(), parcel.getWeight(), parcel.getFee());</code></p>

<p>You should consider a default constructor <code>Parcel()</code> with default values assigned to different attributes and then <code>Parcel parcel</code> before assigning them in <code>main()</code></p>

<p>What arguments did you run your program with?</p>
",0
37247959,37247824,3,"<blockquote>
  <p><code>Parcel parcel(parcel.getID(), parcel.getSenderName(), parcel.getSenderAddress(), parcel.getReceiverName(), parcel.getReceiverAddress(), parcel.getWeight(), parcel.getFee());</code></p>
</blockquote>

<p>Don't do that. You are calling <code>parcel.getSenderName()</code> before the <code>parcel</code> object is fully initialized.</p>
",4
37248157,37247824,1,"<p>Your construction,</p>

<pre><code> Parcel parcel(parcel.getID(), parcel.getSenderName(), parcel.getSenderAddress(), parcel.getReceiverName(), parcel.getReceiverAddress(), parcel.getWeight(), parcel.getFee());
</code></pre>

<p>initialises <code>parcel</code> with itself, which is uninitialised.<br>
This is undefined, and anything can happen.</p>

<p>You've already read all parameters from the user, so use them:</p>

<pre><code>Parcel parcel(id, senderName, senderAddress, receiverName, receiverAddress, weight, fee);
</code></pre>

<p>You can remove the entire sequence of setters.</p>

<p>And you should not call the destructor; C++ handles destruction automatically.<br>
If you found that idea in a book, throw it away immediately and look for a better one <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">here</a>.<br>
If you don't have a book, look in the same place.</p>
",0
37242294,37242200,2,"<p>If you are trying to create a <code>Parsel2</code> object on the stack (as a local variable), you can just declare a variable with an integer argument.  (The integer argument is needed because your constructor requires an argument.)  For example:</p>

<pre><code>Parcel2 obj(2);
</code></pre>

<p>Here is an alternative C++ 11 syntax, which some (me) find easier to parse:</p>

<pre><code>auto obj = Parcel2(2);
</code></pre>

<p>If instead you want to dynamically allocate a <code>Parsel2</code>, you need to allocate it with <code>new</code>:</p>

<pre><code>Parcel2 * obj = new Parcel2(2);
</code></pre>

<p>And once again, an alternative syntax:</p>

<pre><code>auto obj = new Parcel2(2);
</code></pre>

<p>As a final note, please consider assigning class members using a <em>member initialization list</em>:</p>

<pre><code>Parcel2::Parcel2(int id) : id(id)
{}  
</code></pre>
",0
36429711,36429589,0,"<p>You should just leave <code>n</code> uninitialized instead, assigning it to NULL in C++11 can lead to undefined behavior. There should not be an instance in which you need to assign to NULL.</p>
",1
36429946,36429589,3,"<p>Your program is free to do whatever the implementation of <code>std::string</code> you have choses to. <code>std::string</code> has a constructor taking a <code>const char* s</code>.  However, this involves:</p>

<blockquote>
  <p>Constructs the string with the contents initialized with a copy of the null-terminated character string pointed to by <code>s</code>. The length of the string is determined by the first null character. The behavior is undefined if <code>s</code> does not point at an array of at least <code>Traits::length(s)+1</code> elements of <code>CharT</code>, <strong>including the case when s is a null pointer.</strong></p>
  
  <p>(emphasis mine)</p>
</blockquote>

<p><sub>Via <a href=""http://en.cppreference.com/w/cpp/string/basic_string/basic_string"" rel=""nofollow"">cppreference</a></sub></p>
",2
36440241,36439956,0,"<p>There are a lot of issues in your code so I will do my best:</p>

<p>In your <code>main()</code>, <code>choice</code> is an <code>int</code> but you are checking if it's a <code>character</code> 1 or 2 or 99. this takes the <code>ASCI CODE</code> value of those characters which are equal to (I think) 49, 50, .. etc. Just remove the brackets if you want to check the integer value.</p>

<p>Also, you need to declare all your variables in <code>main()</code>, but then pass needed variables on every function call.</p>

<p>Also try to find a better naming so things don't get confusing. (See below)</p>

<p>Try to do all the <code>std::cout</code> statements in <code>main()</code>, and the calculations in functions. Just for a better practice.</p>

<p>This code is your code but compiles, you need to figure the rest out yourself and I will help if needed. This code pass variables <em>by value</em> and <strong>NOT by reference</strong>. Make sure that the logic is correct by Step-Over/Step-Into the code using F-10 and F-11 in Visual Studio. Hoover your mouse on all variables on every statement to see if the flow is what you desire. And Good luck!</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
using namespace std;


// Function Prototypes
void getTime12(string, int,int, int);
void getTime24(string, int, int, int);
void convert12to24(string, int, int, int);
void convert24to12(string, int, int, int);
void print24(string, int, int, int);
void print12(string, int, int, int);
void menu();

int main()
{
    static string AMPM = ""AM"";
    int get12Hrs = 0, get12Mins = 0, get12Secs = 0;
    int get24Hrs = 0, get24Mins = 0, get24Secs = 0;

    int choice;

    do
    {
        // Display menu options
        menu();
        cin &gt;&gt; choice;

        if (choice == 1)
        {
            getTime12(AMPM, get12Hrs, get12Mins, get12Secs);
            convert12to24(AMPM, get12Hrs, get12Mins, get12Secs);
            print24(AMPM, get12Hrs, get12Mins, get12Secs);
        }

        else if (choice == 2)
        {
            getTime24(AMPM, get24Hrs, get24Mins, get24Secs);
            convert24to12(AMPM, get24Hrs, get24Mins, get24Secs);
            print12(AMPM, get24Hrs, get24Mins, get24Secs);
        }

    } while (choice != 99);

    system(""pause"");
    return 0;
}

void menu()
{
    //Declare variabls to return
    cout &lt;&lt; endl;
    cout &lt;&lt; ""1. To convert time from 12-hour notation to 24-hour notation."" &lt;&lt; endl;
    cout &lt;&lt; ""2. To convert time from 24-hour notation to 12-hour notation."" &lt;&lt; endl;
    cout &lt;&lt; ""99. To quit the program."" &lt;&lt; endl &lt;&lt; endl;
    cout &lt;&lt; ""Your choice (1, 2, 99): "";
    cout &lt;&lt; endl &lt;&lt; endl;
}

//function to get the hours
void getTime12(string AMPM, int get12Hrs, int get12Mins, int get12Secs)
{

    //ask for the hour using cin
    cout &lt;&lt; ""Enter the hours: "";
    cin &gt;&gt; get12Hrs;
    cout &lt;&lt; endl;

    cout &lt;&lt; ""Enter minutes: "";
    cin &gt;&gt; get12Mins;
    cout &lt;&lt; endl;

    cout &lt;&lt; ""Enter seconds: "";
    cin &gt;&gt; get12Secs;
    cout &lt;&lt; endl;

    //ask user for AM PM input
    cout &lt;&lt; ""Enter AM or PM: "";
    cin &gt;&gt; AMPM;

    //For PM
    if (AMPM == ""PM"" || AMPM == ""Pm"" || AMPM == ""pm"")
    {
        AMPM = ""PM"";
    }

}

void getTime24(string AMPM, int get24Hrs, int get24Mins, int get24Secs)
{

    //ask for the hour using cin
    cout &lt;&lt; ""Enter the hours: "";
    cin &gt;&gt; get24Hrs;
    cout &lt;&lt; endl;

    cout &lt;&lt; ""Enter minutes: "";
    cin &gt;&gt; get24Mins;
    cout &lt;&lt; endl;

    cout &lt;&lt; ""Enter seconds: "";
    cin &gt;&gt; get24Secs;
    cout &lt;&lt; endl;

    //ask user for AM PM input
    cout &lt;&lt; ""Enter AM or PM: "";
    cin &gt;&gt; AMPM;

    //For PM
    if (AMPM == ""PM"" || AMPM == ""Pm"" || AMPM == ""pm"")
    {
        AMPM = ""PM"";
    }

}

//Function to change to 24-hour notation
void convert24to12(string AMPM, int get24Hrs, int get24Mins, int get24Secs)
{
    if (get24Hrs &lt; 12)
    {
        get24Hrs = get24Hrs;
        get24Mins = get24Mins;
        get24Secs = get24Secs;
    }
    if (AMPM == ""PM"")
    {
        get24Hrs = get24Hrs - 12;
        get24Mins = get24Mins;
        get24Secs = get24Secs;
    }
}

//Function to change to 12-hour notation
void convert12to24(string AMPM, int get12Hrs, int get12Mins, int get12Secs)
{
    if (get12Hrs &gt; 12)
    {
        get12Hrs = get12Hrs;
        get12Mins = get12Mins;
        get12Secs = get12Secs;
    }
    if (AMPM == ""PM"")
    {
        get12Hrs = get12Hrs + 12;
        get12Mins = get12Mins;
        get12Secs = get12Secs;
    }
}

void print12(string AMPM, int get24Hrs, int get24Mins, int get24Secs)
{
    cout &lt;&lt; ""The 12-hour time is "" &lt;&lt; get24Hrs &lt;&lt; "":"";

    cout.width(2);
    cout.fill('0');

    cout &lt;&lt; get24Mins &lt;&lt; "" "" &lt;&lt; get24Secs;
    cout &lt;&lt; AMPM &lt;&lt; endl;
    cout &lt;&lt; endl &lt;&lt; endl;

}

void print24(string AMPM, int get12Hrs, int get12Mins, int get12Secs)
{
    cout &lt;&lt; ""The 24-hour time is "" &lt;&lt; get12Hrs &lt;&lt; "":"";

    cout.width(2);
    cout.fill('0');

    cout &lt;&lt; get12Mins &lt;&lt; "" "" &lt;&lt; get12Secs;
    cout &lt;&lt; AMPM &lt;&lt; endl;
    cout &lt;&lt; endl &lt;&lt; endl;

}
</code></pre>
",6
36780252,36780202,5,"<p>Your function prototype <code>void test(float, int);</code> does not match your function <code>void test(float a[], int size)</code>. Change the prototype at the top to <code>void test(float a[], int size);</code> (I like to leave the input variable names in the prototype for consistency, but this is not necessary).</p>
",2
36780306,36780202,2,"<p>You probably meant to write:</p>

<pre><code>void test(float*, int);
// ...
void test(float* a, int size)
{
    [....]
}
</code></pre>

<p>when test is called with array argument, array will decay to pointer to its first element - and its size will be lost.</p>
",0
36780364,36780202,0,"<p>Wrong parameter type for the test forward deceleration.</p>

<p>Try this.</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;
void test(float *, int);

int main()
{ 
    const int size=11;
    float a[size];

    test(a, size);

    return 0;
}

void test(float a[], int size)
{

}
</code></pre>
",0
36254265,36254109,2,"<p>Given your initialization, it is not possible.  A <code>const Derived&amp;</code> can only refer to an object of type <code>Derived</code>, or of a class derived from <code>Derived</code>.</p>

<p>But you have only created objects of type <code>Base</code>. You do not have any objects of type <code>Derived</code>.</p>

<p>You could attempt this by writing:</p>

<pre><code>virtual const Derived&amp; getDerived() const
{
    return dynamic_cast&lt;Derived const &amp;&gt;(*b[indexOfDerived]);
}
</code></pre>

<p>which will throw an exception if the pointer in question does not actually point to a <code>Derived</code>. (Which it won't, until you have a <code>new Derived</code> somewhere).</p>
",1
36254273,36254109,0,"<p>First, if you want to return <code>Derived</code>, then you should create <code>Derived</code> </p>

<pre><code>b[i] = new Base(); 
</code></pre>

<p>You must cast to convert a <code>Base*</code> to a <code>Derived*</code></p>

<pre><code>const Derived&amp; getDerived() const
{
    return *static_cast&lt;Derived const*&gt;( b[0] );
} 
</code></pre>

<p>Consider using a <code>vector&lt;Base*&gt;</code> or better <code>vector&lt;unique_ptr&lt;Base&gt;&gt;</code> to help with memory management and exception safety issues.</p>
",2
42663534,42663313,1,"<p>Change this one line:</p>

<pre><code>    for (int i = 1; i &lt; K.size(); i++)   // K.size() not K.size()-1
</code></pre>
",2
36421101,36419009,0,"<p>In addition to adding the library path to the project setting be sure you also add the required library files(.lib) as an additional dependency for the linker. you can find the additional dependency input field at project->properties->linker->Input and add the actual names(with extension) of the library files separated by a space.</p>
",0
42536038,42535935,0,"<p>The reason your behavior is happening is because of these 2 lines:</p>

<pre><code>cin &gt;&gt; player1;
cin.getline(player1);
</code></pre>

<p>In the first line, <code>cin</code> will ignore whitespace, and in the second one, it will not. So just remove the first line in the snippet above, and it should accept a name with spaces.</p>
",2
36512097,36511970,0,"<p>If you look at the line above the <code>==</code> line it says</p>

<pre><code>// must take 'address of' the argument to compare it to the
// this pointer.""
if (right == *this) {
</code></pre>

<p>What you are currently doing is trying to compare the value of <code>right</code> with the value of <code>*this</code>. What you really want to do is to compare the <strong>pointer</strong> to <code>right</code> (using the address of operator <code>&amp;</code>) with the <code>this</code> pointer.</p>

<pre><code>if (&amp;right == this) {
</code></pre>

<p>Then you don't need to implement the value comparison operator (if you don't need it anywhere else).</p>
",1
36512035,36511970,1,"<p>Read <a href=""http://en.cppreference.com/w/cpp/language/operators"" rel=""nofollow"">here</a> about operator overload.</p>

<p>Given your error:</p>

<blockquote>
  <p>IntelliSense: no operator ""=="" matches these  operand types are: const String1030 == String1030 </p>
</blockquote>

<p>And this line</p>

<pre><code>(right == *this)
</code></pre>

<p>There is no implementation of equality operator, so you need to implement one:</p>

<pre><code>bool operator==(const String1030 &amp; lhs, const String1030&amp; rhs){ 
     /* do actual comparison */ 
}
</code></pre>
",0
45734795,45734431,1,"<p>If <code>Base</code> is polymorphic, you may do:</p>

<pre><code>std::vector&lt;Base*&gt; bases;

auto it = std::find(bases.begin(), bases.end(),
                    [](const auto* base) {
                        return dynamic_cast&lt;const DerivedA*&gt;(base) != nullptr;
                    });
</code></pre>
",0
39664380,39663823,1,"<p>I understand the need is to be able to declare:</p>

<pre><code>SLVar var;
</code></pre>

<p>and later decide to assign integer, string, float, whatever without the need of fixing the type by a template (kind of dynamic typing)</p>

<p>I'm proposing a solution with a lot of compromises, without typeinfo at all and without templates (the template is useless here since you have to perform a type check within the function)</p>

<p>either, I kept only <code>const char *</code> and <code>int</code> types for simplicity's sake but that can be easily extended.</p>

<p>When assigning, the type is set in an enumerate, later used by the console write function.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;istream&gt;
#include &lt;ostream&gt;

class SLVar
{
    private:
        const char* str;
        int in;
        enum TheType { TYPE_INT, TYPE_CHARPTR, TYPE_UNKNOWN };
        TheType type;

    public:
        SLVar() : type(TYPE_UNKNOWN)
        {}

        friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const SLVar&amp; var);

        SLVar &amp; operator=(int var)
        {
            in = var;
            type=TYPE_INT;
            return *this;
        }
        SLVar &amp;operator=(const char *var)
        {
            str = var;
            type=TYPE_CHARPTR;
            return *this;
        }

};
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const SLVar&amp; var)
{
    switch (var.type)
    {
    case SLVar::TYPE_CHARPTR:
        return os &lt;&lt; var.str;            
    case SLVar::TYPE_INT:
        return os &lt;&lt; var.in;           
    default:
      return os;  // not printing anything
      }       
}
int main()
{
    SLVar var;
    var = ""Hello world"";
    std::cout &lt;&lt; var &lt;&lt; std::endl;    
    var = 35;    // kind of dynamic typing through assignment
    SLVar var2;
    var2 = 56;
    std::cout &lt;&lt; var &lt;&lt; "" "" &lt;&lt; var2 &lt;&lt; std::endl;

}
</code></pre>

<p>result:</p>

<pre><code>Hello world
35 56
</code></pre>

<p>It's still missing a lot of things, like default constructor, copy constructor... but the principle works.</p>
",5
39665526,39663823,0,"<p>Try something along the lines of:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;istream&gt;
#include &lt;ostream&gt;

template &lt;typename T&gt;
class SLVar {
public:
    SLVar&lt;T&gt;() {} ; // Defualt constructor
    SLVar&lt;T&gt;(T value) :
        var(value)
    {} ;

    T var ;
    T getvalue() {return var ;}

    // This lets you use the class as though it was the object
    inline operator T() {return var;}
    T operator=(T newvar)
    {
        var = newvar ;
    }
};

int main()
{
    SLVar&lt;double&gt; var_dbl(3.14);
    SLVar&lt;int&gt; var_int(5) ;
    SLVar&lt;const char*&gt; var_str(""hello"") ;
    SLVar&lt;char&gt; var_char('y') ;

    // And now to test...
    std::cout &lt;&lt; ""Dbl: "" &lt;&lt; var_dbl &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Int: "" &lt;&lt; var_int &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Str: "" &lt;&lt; var_str &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Char: "" &lt;&lt; var_char &lt;&lt; std::endl;

    // Lets try resetting the values
    var_dbl = 4.6 ;
    var_int = 7 ;
    var_str = ""goodbye"" ;
    var_char = 'n' ;

    std::cout &lt;&lt; ""Dbl: "" &lt;&lt; var_dbl &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Int: "" &lt;&lt; var_int &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Str: "" &lt;&lt; var_str &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Char: "" &lt;&lt; var_char &lt;&lt; std::endl;

    // Lets try some math on the double variable
    std::cout &lt;&lt; ""Dbl * 0.5: "" &lt;&lt; var_dbl*0.5 &lt;&lt; "" (this shoudl be 2.3)"" &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>The downside is that (I'm I'm sure you've realized) the streamer wont work if you try to do <code>SLVar&lt;std::string&gt;</code>. There you just need to use <code>SLVar&lt;const char*&gt;</code>. I've also added the line:</p>

<pre><code>inline operator T() {return var;}
</code></pre>

<p>So that the the class can act as an object of the type it is suppose to represent. So you can use the <code>SLVar&lt;double&gt;</code> as a double in a formula, for example.</p>
",2
42638947,42638855,0,"<p>Integer rounding. That seems to be a problem. Switch from using <code>int</code> to using <code>double</code>.</p>
",0
42640014,42638855,0,"<p>First note that I am using Visual Studio and pre-compiled headers so my header configuration is a bit different.</p>

<p>When I compiled your code the compiler sure warned me that using ""int"" would be a problem. I always remove warnings unless I am sure I don't need to and I don't ignore warnings unless I am sure I can safely.</p>

<p>For ""employee.h"" I have:</p>

<pre><code>#pragma once
using namespace std;

class employee
{
public:

    void readData(ifstream&amp; inf);
    //Precondition: File must exist, be accessible, and have the appropriate contents

    //Postcondition: The contents in the file are assigned to a variable. 

    void Compute(double basepay);
    //Precondition: basepay = $800
    //Postcondition: Salary is found using the basepay plus the three other basepays percentages. 

    void print(ofstream&amp; outf) const;
    //Precondition:  The new values (ID and salary) must be updated and accessible. 
    //Postcondition: The ID and salary must be displayed in an output file. The salary must be in the proper format.  

    employee();
    //Precondition:  The variables ID, Job_class, Years, Ed, and sal must have been created already. 
    //Postcondition: the variables ID, Job_class, Years, Ed, and sal are all set to zero. 

private:

    int ID;
    int Job_class;
    int Years;
    int Ed;
    double sal;

};
</code></pre>

<p>Note that ""sal"" is a double.</p>

<p>For ""employee.cpp"" I have:</p>

<pre><code>#include ""stdafx.h""
#include ""employee.h""
using namespace std;


void employee::readData(ifstream&amp; inf)
{
    inf &gt;&gt; ID &gt;&gt; Job_class &gt;&gt; Years &gt;&gt; Ed;
}

void employee::Compute(double basepay)
{
    //int extra = .01;
    //int bp1 = 0;
    //int bp2 = 0;
    //int bp3 = 0;
    double extra = .01;
    double bp1 = 0;
    double bp2 = 0;
    double bp3 = 0;

    if (Job_class == 1)
    {
        bp1 = basepay*.05;
    }
    if (Job_class == 2)
    {
        bp1 = basepay*.10;
    }
    if (Job_class == 3)
    {
        bp1 = basepay*.20;
    }

    if (Years &gt; 0 &amp;&amp; &lt;= 10)
    {
        bp2 = basepay*.05;
    }
    if (Years&gt; 10)
    {
        bp2 = basepay*(.05 + extra);
    }

    if (Ed == 1)
    {
        bp3 = 0;
    }
    if (Ed == 2)
    {
        bp3 = basepay * 05;
    }
    if (Ed == 3)
    {
        bp3 = basepay*.12;
    }
    if (Ed == 4)
    {
        bp3 = basepay*.20;
    }

    sal = basepay + bp1 + bp2 + bp3;
}


void employee::print(ofstream&amp; outf) const
{
    outf &lt;&lt; ID &lt;&lt; setw(15) &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; setprecision(2) &lt;&lt; ""$ "" &lt;&lt;
        sal &lt;&lt; endl;
}

employee::employee()  // default constructor
{
    ID = 0;
    Job_class = 0;
    Years = 0;
    Ed = 0;
    sal = 0.0;
}
</code></pre>

<p>For the main I have:</p>

<pre><code>#include ""stdafx.h""
using namespace std;
#include ""employee.h""

int main()
{
    double basepay = 800;
    employee emp;
    ifstream inf;
    inf.open(""G:\\Temporary\\employee.txt"");
    ofstream outf;
    outf.open(""G:\\Temporary\\employeeout.txt"");

    if (!inf)
    {
        cout &lt;&lt; "" *** Input file does not exist! *** "" &lt;&lt; endl;
        return 1;
    }

    outf &lt;&lt; ""ID #"" &lt;&lt; setw(20) &lt;&lt; ""Salary"" &lt;&lt; endl;
    outf &lt;&lt; ""****************************"" &lt;&lt; endl;

    while (!inf.eof())
    {
        emp.readData(inf);
        emp.Compute(basepay);
        emp.print(outf);
    }

    inf.close();
    outf.close();
    return 0;
}
</code></pre>

<p>For ""employee.txt"" I have:</p>

<pre><code>1078 2 12 3
1070 3 10 4
</code></pre>

<p>Note that there are no commas.</p>

<p>For ""employeeout.txt"" I have:</p>

<pre><code>ID #              Salary
****************************
1078             $ 1024.00
1070             $ 1160.00
1070             $ 1160.00
</code></pre>

<p>Note that the program is reading the last line twice. I did not fix that; I think it is a matter of personal preference how to handle that so you can do it your way.</p>
",2
45780375,45779976,0,"<p>Firstly, you never use 't', so I removed that.
What I found was that it isn't actually outputting garbage values, it is just outputting the values in the wrong order. If you swap k and i at the end, it should work:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    int test,n,arr[50],str[20][20],j,i,k;
    j = 0;
    cin&gt;&gt;test; //test cases
    while(test&gt;0){
        cin&gt;&gt;n; //number of elements in a test case 
        for(i=0;i&lt;n;i++){
            cin&gt;&gt;arr[i]; //array of elements
        }
        for(i=0;i&lt;n;i++){
            cout&lt;&lt;""arr = ""&lt;&lt;arr[i]&lt;&lt;""\n"";
            str[j][i] = arr[i]; // storing arr in str
        }
        cout&lt;&lt;""\n"";
        str[j+1][i] = 0;
        j++;
        test--;
    }
    for(i=0;i&lt;j;i++){
        for(k=0;str[k][i]!=0;k++){
            cout&lt;&lt;str[k][i]&lt;&lt; ' ';  // printing str
        }
        cout&lt;&lt;""\n"";
    }
    return 0;
}
</code></pre>
",2
45780454,45779976,1,"<p>There are a lot of mistakes but the main one is the indexing of a 2d array </p>

<p>A two dimensional array is like this <strong>arr [row] [column]</strong> and you have been using it like <strong>arr [column] [row]</strong>  </p>

<pre><code> str[i][j] = arr[i];
</code></pre>

<p>see what u are doing is storing a number at every row</p>

<p>maybe this image will clear things out </p>

<p><a href=""https://i.stack.imgur.com/e0zOz.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/e0zOz.jpg"" alt=""enter image description here""></a></p>

<pre><code>#include &lt;iostream&gt;
using std :: cin ;
using std :: cout ; 
using std :: endl ;

int main() {
    int test,n,arr[50],str[20][20],i,j,k;
    j = 0;
    cin&gt;&gt;test; //test cases
    int temp = test ;
    while(test&gt;0)
    {
        cin&gt;&gt;n; //number of elements in a test case 

        for(i=0;i&lt;n;i++)
            cin&gt;&gt;arr[i]; //array of elements

        for(i=0;i&lt;n;i++)
        {
            cout&lt;&lt;""arr = ""&lt;&lt;arr[i]&lt;&lt;""\n"";
            str[j][i] = arr[i]; // storing arr in str
        }

        str[j][i] = '\0';
        cout&lt;&lt;""\n"";

        j++;
        test--;
    }

    for ( int i = 0 ; i &lt; temp ; i++ )
    {
        j=0 ;
    while ( str[i][j] != '\0')
       {
           cout&lt;&lt;str[i][j];  // printing str
            j++ ;
        }
        cout&lt;&lt;""\n"";
    }
    cin.ignore(5) ;
    return 0;
}
</code></pre>
",0
36526247,36525992,0,"<p>To make the loop stop to take input for a single question first,and then proceed to further question(s), try taking the input for the variable <code>panswere1</code> inside the loop, like this:</p>

<pre><code> for( question = 1; question &lt;= nquestion; question = question + 1 ){
    num1 = rand()%20 +1;
    num2 = rand()%20 +1;
    coutnum1""+""num2endl;
    qanswere1 = num1 + num2;
    cin&gt;&gt;panswere1;
}
</code></pre>

<p>Note 1: Judging on what the first for loop is doing, it can very well be achieved by</p>

<pre><code>while(choice == 1){..
</code></pre>

<p>without compromising the readability of your code.</p>

<p>Cheers!</p>

<p><strong>Edit 1:</strong><br>
To make the code stop at 10 questions, you will have to replace the outer loop</p>

<pre><code>for ( choice ==1; choice==1; choice==1){..
</code></pre>

<p>with a simple if condition:</p>

<pre><code>if( choice == 1){..
</code></pre>

<p>The problem with the for-loop is that it will run infinite number of times, since you have not added any mechanism to limit the number of times it will execute. If you have to limit the number of questions to 10, I would recommend replacing the loop with this if-statement.</p>

<p><strong>Edit 2:</strong><br>
You will have to replace the inner while-loop with an if-condition too:<br>
replace</p>

<pre><code>while(choice == 1){..
</code></pre>

<p>with</p>

<pre><code>if(choice == 1){..
</code></pre>
",8
42541166,42541054,0,"<p>Some hints to help you along the way: If there was no even number in the range, you will not enter into the loop. What will <code>j</code> be then? How do you react on that value?</p>
",1
42542939,42541054,0,"<p>I tried to fix your code, I did the best I could from what I understood you were tring to do.
I cleaned it up, fixed spelling and grammer, I deleted unnecessary stuff, I also made it more compact and nice to look at.</p>

<pre><code>#include &lt;iostream&gt;

int main() {
    int max=0, min=1, sum=0; product = 1, amount = 0; // max, min - entered by user, product - product of all even numbers in interval, sum - sum of all even numbers in interval. amount - amount of even numbers in interval
    char x=Y; // Entered by user to know if to quit or continue to continue.

    while ((x == Y) || (x == y))
    {
        while (min &gt; max) { // System detects whether minimum is bigger than maximum
            cin.clear();  // Clears screen so if this part runs again it wouldn't get messy.
            cin.ignore();
            cout &lt;&lt; ""Max has to be larger than min!"";
            cout &lt;&lt; ""\n Enter the min number of interval!  "";
            cin &gt;&gt; min;
            cout &lt;&lt; ""\n Enter the max number of interval!  "";
            cin &gt;&gt; max;
        }

        for (; min &lt;= max; min++)
        {
            if (min % 2 == 0)
            {
                sum+=n;
                count++;
                product*=n;
            }
        }
        if (count == 0)
        {
            product=0;
            cout &lt;&lt; ""There are no even numbers in interval!"";
        }
        else
        {
            cout &lt;&lt; ""\n The amount of the even numbers in interval: "" &lt;&lt; amount &lt;&lt; "",the product of the even numbers: "" &lt;&lt; product &lt;&lt; "",the sum of the even numbers: "" sum &lt;&lt; ""\n\n"";
        }
        cout &lt;&lt; ""Repeat? (Y/N) "";
        x=getchar;
        system(""cls"");
    }
    return 0;
}
</code></pre>
",0
36441213,36440946,0,"<p>The problem is that you aren't resetting PreviousResult after you perform the calculations. So in calculation 2, you are setting PreviousResult to 2, setting result = PreviousResult, and then displaying the result.  The problem is that once you go into calculation 3, PreviousResult still equals 2.  That means calculation 3 is computing 2 divided by 2 instead of 0 divided by 2, giving you the incorrect answer.</p>

<p>So after you set Result = PreviousResult, you need the line </p>

<pre><code>PreviousResult = 0;
</code></pre>

<p>As for the 4th calculation, while(!myfile.eof()) can cause inconsistent results. There may be a newline character causing it to try and read the next empty line.  Add myfile.ignore() right after the opening brace of the while loop and that should fix the issue.</p>
",2
36441273,36440946,1,"<p>If I am interpreting your program correctly, you are right that one of your problems is from the PreviousResult not being reset.  You declared and initialized PreviousResult at the beginning with this line</p>

<pre><code>int PreviousResult = 0;
</code></pre>

<p>Resetting it is as simple as resassigning its value such as</p>

<pre><code>PreviousResult = 0;
</code></pre>

<p>As for why you are getting 4 calculations instead of 3, </p>

<pre><code>while(!myfile.eof())
</code></pre>

<p>will loop 1 more time than you intend it to because eof() only returns false after the input stream has read the end of file.  That does not occur until
<code>myfile &gt;&gt; numCommands;</code>.  An Alternative is to do</p>

<pre><code>while(myfile &gt;&gt; numCommands)
</code></pre>

<p>and the while loop will terminate when there are no more things to be read.</p>
",1
36411567,36410113,0,"<p>Assuming you wanted an output string like 'A7' or 'F2', one way to achieved this would be to convert everything to <code>string</code> (since you can't add and <code>int</code> and a <code>char</code>). For those who don't have access to C++11 and <code>std::to_string()</code> yet, you could use:</p>

<pre><code>char letters[]= {'A','B','C','D','E','F','G','H','I','L'};
int G = std::rand() % 10;
int nOut = std::rand() % 10;
char lOut = letters[G];
std::stringstream ss;
ss &lt;&lt; nOut;
std::string Guess = lOut + ss.str();
</code></pre>
",0
36611035,36610943,0,"<p>Derefence a pointer using the <code>*</code> operator as follows:</p>

<pre><code>std::cout &lt;&lt; *it;
</code></pre>
",0
36611091,36610943,0,"<p>See code below:</p>

<pre><code>Item *it;
it = new Screwdriver(""big"", 11);
cout &lt;&lt; *it;
</code></pre>

<p>C++ has dereference operator <code>*</code> to go from pointer to the value it points to.</p>
",0
36487384,36487271,1,"<p>You need to re-initialize validRange to false at the start of the do-while loop. Otherwise, once you have an input with a valid range, it will keep the range is valid until (fabs(exit - entry) > 0.0001) is false.</p>
",0
36487395,36487271,1,"<p>There is a path through your checks that does not set validRange one way or the other: i.e. when <code>(abs(exit - entry) &gt; 0.0001)</code> is true but <code>if (range &gt;= 0.75 &amp;&amp; range &lt;= 1.25)</code> is false.  So validRange will still have whatever value remained from the previous iteration.</p>
",0
37151458,37150367,0,"<p>The best I could come up with for you:</p>

<ol>
<li><p>remove the keyword <code>static</code> - it's not needed</p></li>
<li><p>shorten the definition of <code>MyCharArray</code> by using a typedef.</p></li>
</ol>

<p>-</p>

<pre><code>using chars = const char[];

constexpr chars MyCharArray = ""yolo"";

template&lt;const char* CharArray&gt;
struct MyStruct {
    //Do stuff
};

int main()
{
  MyStruct&lt;MyCharArray&gt; myStruct;
}
</code></pre>
",0
36358361,36357881,2,"<p><code>cout&lt;&lt;names;</code> appears to be trying to print the whole 2D array, but <code>cout</code> doesn't know how to, so treats it as an address and prints just that.  If instead you try and print individual names (i.e. <code>out&lt;&lt;names[row-1];</code>), these are character pointers, so it <em>does</em> know how to print them.</p>
",0
36346097,36346023,0,"<p>The proper way to do this is to remove the while loop and check if cloak is true in your methods. Here is a implementation that will not give you the errors(assuming cloak is a member variable, which it should be in this case):</p>

<pre><code>void ghost::AssaultR_hit()
{
    if(!cloak)
    {
       //assualtR_hit implementation goes here
    }
}
void ghost::FlameT_hit()
{
        if(!cloak)
    {
       //FlameT_hit implementation goes here
    }
}

void ghost::SniperR_hit()
{
    if(!cloak)
    {
       //SniperR_hit implementation goes here
    }

}

void ghost::RocketL_hit()
{
    if(!cloak)
    {
       //RocketL_hit implementation goes here
    }
}

void ghost::StickyG_hit()
{
    if(!cloak)
    {
       //StickyG_hit implementation goes here
    }
}
</code></pre>

<p>Note: Also note the comment that you can not have a while loop outside of a function in C++ like the commentator said.</p>
",0
36378248,36378217,2,"<p>A class without base classes is just that : a type on its own.<br>
As such, there is nothing to override from any base class, neither operators nor anything else.</p>
",2
43214799,43214644,0,"<pre><code>std::vector&lt;std::vector&lt;int&gt;&gt; array_2d(rows, std::vector&lt;int&gt;(cols, 0));
</code></pre>

<p>This creates a rows * cols 2D array where each element is 0. The default value is std::vector(cols, 0) which means each row has a vector which has cols number of element, each being 0.</p>
",0
43214997,43214644,0,"<blockquote>
  <p>Can you tell me what mean ""initializers as actual parameters of vector constructors""?</p>
</blockquote>

<p><strong>Construct a 1D vector</strong></p>

<pre><code>// Construct a 1D vector with the elements {10, 20, 30, 40}
std::vector&lt;int&gt; v1 = {10, 20, 30, 40};
</code></pre>

<p><strong>Construct a 2D vector</strong></p>

<pre><code>// Construct a 2D vector with 2 rows and 3 colomns.
// First row has the elements {10, 20, 30}
// Second row has the elements {40, 50, 50}
std::vector&lt;std::vector&lt;int&gt;&gt; v2 = {{10, 20, 30}, {40, 50, 60}};
</code></pre>

<p><a href=""http://ideone.com/E1v38P"" rel=""nofollow noreferrer""><strong>Live Demo</strong></a></p>
",0
38618372,38618262,0,"<p>There is a few ways you could do this... you could define priordistance outside of your for loop, and be sure to only redefine it 1 time (since you are looping twice).</p>

<p>However this is not what I would do, I would simply create an array of integers that hold n number of 'distances' for your reference by index i</p>

<pre><code>int[] or int *
</code></pre>
",0
38618376,38618262,0,"<p>You can do various things. You need the value to persist throughout your <code>for</code> loop. Note that there is no point in comparing until you have already got one prior value.</p>

<pre><code>int main(){
  int priordistance = 0; //lifetime outside for loop
  for(int i = 0; i &lt; 2; i++){
    int x = rand() % 180;
    int y = rand() % 180;
    int x2 = rand() % 180;
    int y2 = rand() % 180;

    int distance = distanceFormula(x, x2, y, y2);

    if(i &amp;&amp; priordistance != distance){
     //^---- have we got a prior value yet?  
      cout&lt;&lt;""Yes! It worked!""&lt;&lt;endl;
    }
    priordistance = distance;//remember for next time
  }
  return 0;
}
</code></pre>
",1
38618377,38618262,0,"<p>Simply redord the previous value in a variable.</p>

<pre><code>#include &lt;cmath&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
using std::cout;
using std::endl;

int distanceFormula(int x1, int x2, int y1, int y2){
  int distance;
  distance = sqrt(pow((x1-x2), 2) + pow((y1-y2), 2));
  return distance;
}

int main(){
  int priordistance = 0; // a variable used to record the value
  for(int i = 0; i &lt; 2; i++){
    int x = rand() % 180;
    int y = rand() % 180;
    int x2 = rand() % 180;
    int y2 = rand() % 180;

    int distance = distanceFormula(x, x2, y, y2);
    if(i &gt; 0 &amp;&amp; priordistance != distance){ // use i &gt; 0 to avoid compareing with meaningless value
      cout&lt;&lt;""Yes! It worked!""&lt;&lt;endl;
    }
    priordistance = distance; // record the value
  }
  return 0;
}
</code></pre>
",0
38618560,38618262,0,"<p>Do you mean something like the following?</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;cmath&gt;

int distanceFormula( int x1, int x2, int y1, int y2 )
{
    int distance;

    distance = std::sqrt( std::pow( x1 - x2, 2 ) + std::pow( y1 - y2, 2 ) );

    return distance;
}

int main() 
{
    const size_t N = 2;
    int distance[N];

    std::srand( ( unsigned int )std::time( nullptr ) );

    for ( size_t i = 0; i &lt; N; i++ )
    {
        int x  = rand() % 180;
        int y  = rand() % 180;
        int x2 = rand() % 180;
        int y2 = rand() % 180;

        distance[i] = distanceFormula( x, x2, y, y2 );
    }

    if ( distance[0] != distance[1] ) std::cout &lt;&lt; ""Yes! It worked!"" &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>The program output is</p>

<pre><code>Yes! It worked!
</code></pre>
",0
37112994,37112727,1,"<ol>
<li><p><code>static</code> at namespace scope means ""local to this translation unit"", so you'll get a new copy of the object in every unit that includes your header.</p></li>
<li><p>Same thing.</p></li>
<li><p>These have internal linkage by default.</p></li>
<li><p>These don't, but the language has a rule that says you can duplicate these in a program as long as each ""copy"" looks <em>exactly</em> the same. That's because, historically, compilers could only do inlining on functions visible in the same translation unit. Nowadays, link-time optimisation exists.</p></li>
</ol>
",1
37295772,37293742,0,"<p>You could add each word you read to a std::vector, then you could use a for loop to use them in the manner you described. The code below is an example of something you could do</p>

<pre><code>  vector&lt;string&gt; words;
  string word = """";
  ifstream infile(""words.txt"", ios::in);

  while (infile &gt;&gt; word)
  {
    /*
     you can process each word here like removing commas, periods 
     and such(if that is in fact what you want) before you add 
     them to the vector
    */
    words.push_back(word);
  }

  string phrase = """";

  for (int k = 0; k &lt; words.size(); k++)
  {
    phrase +=  "" "" + words[k];
    cout &lt;&lt; phrase &lt;&lt; endl;
  }
</code></pre>

<p>In the example, I assume you want the words in the phrases to be space separated</p>
",0
40759079,40758965,0,"<p>You need to set the name first. In your main method,</p>

<pre><code>PokemonWorld world;
int number;
char name[10];
cout &lt;&lt; ""What is the World Name ?"" ;
cin &gt;&gt; name;
world.setName(name);
//Then get the name
    world.getName(name);
</code></pre>
",0
40759153,40758965,0,"<p>With <code>cstring</code>, you have to use c string manipulator. You definitively can't assign an array to another one. For your issue, use <a href=""http://en.cppreference.com/w/c/string/byte/strncpy"" rel=""nofollow noreferrer""><code>strncpy_s</code></a>:</p>

<pre><code>void setName(char x[]) {
    strncpy_s(name, 10, x, 10);
};
</code></pre>

<p>Also, to avoid issue, your getter should be:</p>

<pre><code>const char * const getName() const {
    return name;
};
</code></pre>

<p>Also, to compare, use <code>strncmp</code>, to concatenate use <code>strncat</code>, ...</p>

<p>Or, because you use c++, use <code>std::string</code></p>
",4
40759504,40758965,0,"<p>You are not using a cstring (most people who hear ""cstring"" think of the <code>CString</code> class of the MFC library).</p>

<p>You are using a ""C"" string, or a raw char pointer. This is bad practice in general, as it involves performing memory management manually, and unless you solve the problems that come with using raw pointers, you will simply have those problems in your code.</p>

<p>setName should be:</p>

<pre><code>void setName(char const * const x)
{
    auto length = std::min(std::strlen(x), 9); // only copy up to 9 characters
    std::copy_n(x, length, name);
    name[length] = '\0';
}
</code></pre>

<p>... or (as already <a href=""https://stackoverflow.com/a/40759153/186997"">pointed out</a>):</p>

<pre><code>strncpy_s(name, 10, x, 10);
</code></pre>

<p>getName should be:</p>

<pre><code>char const * const getName() const
{
    return name;
}
</code></pre>

<p>This code is almost correct:</p>

<pre><code>char name[10];
cout &lt;&lt; ""What is the World Name ?"" ;
cin &gt;&gt; name;
world.setName(name);
</code></pre>

<p>... but you should initialize name where you declare it:</p>

<pre><code>char name[10] = { 0 };
</code></pre>

<p>Also, what will you do if the user inputs more than 10 characters? In that case the stack of your program will become corrupted.</p>

<p>You could avoid the problem by using a std::string.</p>
",0
46627525,46627485,0,"<p>The <code>showMaxReviews</code> function is marked as <code>const</code>, which means it can not modify any of the member variables of the <code>reviewData</code> class. That means it can not call functions, it <code>this</code> or on member objects, that at not <code>const</code>.</p>

<p>The <code>findMaxReview</code> function is <em>not</em> marked as <code>const</code>, therefore it can not be called. As you see if you read the error message, the compiler is attempting to call a <code>const</code> function.</p>
",1
37196865,37196498,0,"<p>If the line you want to write is <em>exactly</em> the same length (in bytes, not in characters, remember some encodings (like e.g. UTF-8) is variable length) then it's very easy: Just skip over the first seven lines and then write the line.</p>

<p>There is a caveat with this though: <a href=""http://en.cppreference.com/w/cpp/io/basic_istream"" rel=""nofollow"">input streams</a> and <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream"" rel=""nofollow"">output streams</a> have different stream positions. So if you read from a <a href=""http://en.cppreference.com/w/cpp/io/basic_fstream"" rel=""nofollow"">combined input/output file stream</a> then only the <em>read</em> position will change, so if you just try to write directly then you will not write at the same position. To solve this you need to get the read position, and set the write position to the same value.</p>

<hr>

<p>As an alternative, or if the data you want to write is not the same size as the existing data, then you have to use a temporary ""buffer"", be it another file or an actual in-memory buffer.</p>

<p>If the file is not big you can use an in-memory buffer, for example using a <code>std::vector</code> for the lines. Read each line into the vector, and then modify the lines (elements in the vector) that you want to modify. Finally reopen the file for writing, truncating it, and then just write each ""line"" to the file.</p>

<p>There is a slight problem with the above though when it comes to the rewriting of the data, and that is if the file is truncated and then there's an error when you write to the file, you can lose data. This can be dsolved by using a temporary file.</p>

<p>Using a temporary file it's easier to not bother with the in-memory buffer, and instead read from the original file and write directly to the temporary file. Knowing when you should write something else is done by keeping track of the current line numbers, which is easy if you read one line at a time. In your example you read the first seven lines from the original file and write them to the temporary file, after the seventh line you write your special eight line while skipping the original eight line from the original file, and then just continue reading/writing the remaining lines. When done close the files and then rename the temporary file as the original file.</p>
",2
42537341,42535980,0,"<p>You need Nested loop. Think about formula to get patten, and do in your nested loop, like this</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;conio.h&gt;
using namespace std;

int main(){
int j, i, n=3;
for(j=0;j&lt;=n;j++)
{ // YOU CAN ADD FORMULA
    for(i=1;i&lt;=j;i++)
        {
            // YOU CAN ADD FORMULA
        }
        cout&lt;&lt;""\n"";
}

for(j=0;j&lt;=n;j++)
{ // YOU CAN ADD FORMULA

    for(i=0;i&lt;=n-j;i++)
        {
           // YOU CAN ADD FORMULA
        }
        cout&lt;&lt;""\n"";
}

getch();
return 0;
}
</code></pre>

<p>Improve by your self</p>
",1
42564701,42535980,2,"<p><a href=""https://i.stack.imgur.com/LO3Ml.jpg"" rel=""nofollow noreferrer"">See image for the logic of the pattern</a></p>

<p>thats basically the logic behind this pattern. once you make this, you can easily invert and then use nested loop to print it twice.</p>
",0
42541950,42541908,2,"<p>The order of evaluation of function parameters is not defined in C or C++. If you need a specific order, assign the return values of those functions to named variables in the order you require, and then pass those variables to the function:</p>

<pre><code>int a = askCalculation();
int b = askNumber1();
int c = askNumber2();
cout &lt;&lt; calculate( a, b, c ) &lt;&lt; endl;
</code></pre>
",0
46091225,46091125,2,"<p>The inner cycle finds the number of <code>101</code> (possibly intersected) bit patterns among the least 22 bits of <code>g</code>. And the condition could be replaced with</p>

<pre><code>if (((g &gt;&gt; i) &amp; 0b111) == 0b101) counter[g]++; 
</code></pre>
",2
42664647,42664453,1,"<p>here is example to find word from string</p>

<pre><code>std::string str (""There are two needles in this haystack with needles."");
std::string str2 (""needle"");

 std::size_t found = str.find(str2);
 if (found!=std::string::npos)
 std::cout &lt;&lt; ""first 'needle' found at: "" &lt;&lt; found &lt;&lt; '\n';
</code></pre>
",0
36734070,36734008,1,"<p>Go through the line and skip non-digit symbols. And for digits use <code>-'0'</code> conversion and <code>*10</code> shift approach. E.G.:</p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
//or cctype to use isdigit()
#include &lt;string.h&gt;
//or cstring to use strlen()

int main()
{
    char str[] = ""3 word 12 with word""; // can be any string
    int result = 0; // to store resulting number
    // begin of solution
    for (int i = 0; i &lt; strlen(str); i++)
    {
        if (isdigit(str[i]))
        {
            result *= 10;
            result += str[i] - int('0');
        }
    }
    // end of solution
    printf(""%d\n"", result);
    return 0;
}
</code></pre>
",0
36734102,36734008,0,"<p>Assuming that <code>s</code> is your initial string.</p>

<pre><code>int toInt(string s) {
    string digits;
    for(size_t i = 0; i &lt; s.size(); i++)
        if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')
            digits.push_back(s[i]);

    int res = 0;
    for(size_t i = 0; i &lt; digits.size(); i++)
        res = res * 10 + digits[i] - '0';
    return res;
}
</code></pre>

<p>Leading zeros are not a problem.
Note however that it is possible to receive an overflow if the resulting <code>digits</code> string will contain a big number.</p>
",0
36734700,36734008,1,"<p>Same idea as in <a href=""https://stackoverflow.com/a/36734070/4833"">VolAnd's answer</a>. Just, because the question is tagged <code>c++</code>, using some STL stuff.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;string&gt;
using namespace std;

int main(){
    std::string input(""3 word 12 with word"");

    int num = std::accumulate(input.begin(), input.end(), 0,
            [](int val, const char elem) {
                if (isdigit(elem)) {
                    val = val*10 + (elem-'0');
                }
                return val;
        }
    );

    std::cout &lt;&lt; num &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>see <a href=""http://en.cppreference.com/w/cpp/algorithm/accumulate"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/algorithm/accumulate</a></p>

<p>note: It gets slightly more interesting if you want to allow a leading minus sign....  </p>

<p>And using <a href=""http://www.boost.org/doc/libs/master/libs/range/doc/html/range/reference/adaptors/reference/filtered.html"" rel=""nofollow noreferrer"">boost::adaptors::filter(rng, pred)</a> on this one would be fun but slightly overdoing it ;-)</p>
",0
42550473,42550362,0,"<p>You cannot.</p>

<p>Not until reflection has been introduced in C++, which should (I hope) be the case in C++20.</p>

<p><a href=""https://github.com/duckie/named_types"" rel=""nofollow noreferrer"">Some projects</a> introduce tuples enhanced with names, but it still not real structs.</p>
",0
42550477,42550362,2,"<blockquote>
  <p>How to access C++ struct property value using index?</p>
</blockquote>

<p>You can not. C++ language has no feature that would allow this. This could be possible in a language that supports (static) reflection.</p>

<p>You could choose to use a <code>std::tuple</code> instead, which does allow indexed member access, but that's a step down in readability since you don't get to name the members.</p>
",0
42551090,42550362,5,"<p>You can't. At least not in the direct manner you want to do it and without partially redefining what a structure is. I will split my answer into two parts the first one explaining possible ways to get at least close to what you want and the second one explaining what you actually should do:</p>
<p><strong>Getting down and dirty</strong></p>
<p>There are two ways (that I can currently come up with) that might give you something to think about:</p>
<ul>
<li><strong>Use a wrapper class</strong> - while C++ does increase the flexibility of structure it doesn't change their purpose of a simple heterogeneous data container. It does however allow operator overloading including the <code>[]</code> operator. So if you create a class that contains the structure as its member (that is it wraps around the structure), you can expose the structure's data using <code>[]</code>. This comes as close to what you want to do as possible. It does however defeat the whole purpose of using a struct since you can do that with just plain non-sturct class members but I have actually seen it not so long time ago when I was going through a C++ library that was wrapping a previous C-based version of itself in order to provide more modern features without the need of completely rewriting the C code.</li>
<li><strong>Use pointer with an offset</strong> - using indexing generally suggest that the underlying container has a consistency when it comes to the blocks of data it contains. The problem is that a structure doesn't necessarily obey this since it can contain (just like in your case) multiple types of data. If you can sacrifice the heterogeneity of your structure and stick with a single data type (for example one or more doubles), you can safely use (up to the point that you have to always remember the number of members the structure has) a pointer and an increasing/decreasing offset to access its members. Just like with any sort of data when you create a standard reference (aka pointer) to something, that reference points at the address of the beginning of the memory this data is using. It is a common practice to use pointers to iterate through arrays and it works exactly like that - create a reference to your structure and the add +1, +2, ... (as many members that struct has). This makes things overly complicated though and is prone to error. As mentioned it also requires using the same type of data inside your structure. However you can also create a set of functions that handle (internally) the offsets. But this idea is similar to the class wrapper I have proposed above.</li>
</ul>
<p><strong>The alternatives ...</strong></p>
<p>From what you have given as information I think you are looking for a completely different type of data - a dictionary, map or a list that contains some sort of custom generic data container that can hold any type of data but also stores that data's type in order to allow recasting it to its original state. Many libraries provide such containers for example Qt has the <code>QVariant</code> (part of the core module), <code>boost</code> has the <code>boost::variant</code>, <code>std::tuple</code> (or even better - named tuples) provided with your standard C++ (since C++11) and so on. I can speak about Qt in greater detail since I have more experience with it. It offers the <code>QVariantList</code> (a <code>typedef</code> for <code>QList&lt;QVariant&gt;</code>) which allows indexing. Of course all this requires you to 1)abandon your structure-thing and 2)use some more advanced containers that may or may not introduce huge drawbacks on whatever you are working on including licensing issues, memory overhead, larger binaries, handling a lot of extra library files etc.</p>
",2
36784033,36783861,0,"<p>If you want to keep a running count of the maximum and minimum and not make structural changes to your existing program,</p>

<p>You'll need to '#include &lt; algorithm >' unless you want to roll your own min and max functions.</p>

<p>Instead of:</p>

<pre><code>maximum = number1;
minimum = number2;
</code></pre>

<p>Use this:</p>

<pre><code>maximum = (maximum &lt; max(number1, number2)) ? max(number1, number2) : maximum;
minimum = (minimum &gt; min(number1, number2)) ? min(number1, number2) : minimum;
</code></pre>
",1
42614795,42614594,0,"<blockquote>
  <p>""get_word"". It takes two arguments. Every call to this function will
  fill one of the arguments with a word from the file.</p>
</blockquote>

<p>As you supposed, you will need two arguments, one file and one string.
But because you must fill the string passed as argument with a word from the file, you have to declare the string argument as reference.
What it means ? By default, arguments are passed as copy, for example</p>

<pre><code>void plusTwo(int a) { a += 2 }
</code></pre>

<p>The code inside the function declaration will modify the copy of the variable passed as parameter, so :</p>

<pre><code>int b = 0;
plusTwo(b);
//b still equals 0
</code></pre>

<p>So you have to mark the argument with an <code>&amp;</code> in the declaration which means that you passed the argument as reference (no copy). So for example :</p>

<pre><code>void plusTwo(int &amp;a) { a += 2 }
</code></pre>

<p>The code inside the function declaration will modify the copy of the variable passed as parameter, so :</p>

<pre><code>int b = 0;
plusTwo(b);
//b equals now 2
</code></pre>

<p>So the correct prototype is :</p>

<pre><code>void get_word(std::ifstream, std::string&amp;);
</code></pre>

<p>Then, the command line is the window where are displayed the text with ""cout"". So in order to get the file path, you have to do :</p>

<pre><code>std::string filePath;
cin &gt;&gt; filePath;
</code></pre>

<p>filePath will get what is entered by user.</p>
",4
38877570,38877440,18,"<p>It looks like you are using C++98 or C++03.  In those versions <code>cin</code> could be implicitly converted to a <code>void*</code> so what you are seeing is that conversion.</p>

<p>If you used C++11, which got rid of the implicit <code>void*</code> conversion and instead implemented a explicit conversion to bool this would produce a compiler error like</p>

<pre><code>clang++ -std=c++11 -O2 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out
main.cpp:4:15: error: invalid operands to binary expression ('ostream' (aka 'basic_ostream&lt;char&gt;') and 'istream' (aka 'basic_istream&lt;char&gt;'))
    std::cout &lt;&lt; std::cin;
    ~~~~~~~~~ ^  ~~~~~~~~
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:245:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'const void *' for 1st argument; take the address of the argument with &amp;
      operator&lt;&lt;(const void* __p)
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/system_error:209:5: note: candidate function [with _CharT = char, _Traits = std::char_traits&lt;char&gt;] not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'const std::error_code' for 2nd argument
    operator&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp; __os, const error_code&amp; __e)
    ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:108:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to '__ostream_type &amp;(*)(__ostream_type &amp;)' (aka 'basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt; &amp;(*)(basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt; &amp;)') for 1st argument
      operator&lt;&lt;(__ostream_type&amp; (*__pf)(__ostream_type&amp;))
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:117:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to '__ios_type &amp;(*)(__ios_type &amp;)' (aka 'basic_ios&lt;char, std::char_traits&lt;char&gt; &gt; &amp;(*)(basic_ios&lt;char, std::char_traits&lt;char&gt; &gt; &amp;)') for 1st argument
      operator&lt;&lt;(__ios_type&amp; (*__pf)(__ios_type&amp;))
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:127:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'std::ios_base &amp;(*)(std::ios_base &amp;)' for 1st argument
      operator&lt;&lt;(ios_base&amp; (*__pf) (ios_base&amp;))
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:166:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'long' for 1st argument
      operator&lt;&lt;(long __n)
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:170:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'unsigned long' for 1st argument
      operator&lt;&lt;(unsigned long __n)
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:174:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'bool' for 1st argument
      operator&lt;&lt;(bool __n)
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:178:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'short' for 1st argument
      operator&lt;&lt;(short __n);
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:181:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'unsigned short' for 1st argument
      operator&lt;&lt;(unsigned short __n)
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:189:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'int' for 1st argument
      operator&lt;&lt;(int __n);
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:192:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'unsigned int' for 1st argument
      operator&lt;&lt;(unsigned int __n)
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:201:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'long long' for 1st argument
      operator&lt;&lt;(long long __n)
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:205:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'unsigned long long' for 1st argument
      operator&lt;&lt;(unsigned long long __n)
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:220:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'double' for 1st argument
      operator&lt;&lt;(double __f)
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:224:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'float' for 1st argument
      operator&lt;&lt;(float __f)
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:232:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'long double' for 1st argument
      operator&lt;&lt;(long double __f)
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:270:7: note: candidate function not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to '__streambuf_type *' (aka 'basic_streambuf&lt;char, std::char_traits&lt;char&gt; &gt; *') for 1st argument
      operator&lt;&lt;(__streambuf_type* __sb);
      ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:502:5: note: candidate function [with _CharT = char, _Traits = std::char_traits&lt;char&gt;] not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'char' for 2nd argument
    operator&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp; __out, char __c)
    ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:508:5: note: candidate function [with _Traits = std::char_traits&lt;char&gt;] not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'char' for 2nd argument
    operator&lt;&lt;(basic_ostream&lt;char, _Traits&gt;&amp; __out, char __c)
    ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:514:5: note: candidate function [with _Traits = std::char_traits&lt;char&gt;] not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'signed char' for 2nd argument
    operator&lt;&lt;(basic_ostream&lt;char, _Traits&gt;&amp; __out, signed char __c)
    ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:519:5: note: candidate function [with _Traits = std::char_traits&lt;char&gt;] not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'unsigned char' for 2nd argument
    operator&lt;&lt;(basic_ostream&lt;char, _Traits&gt;&amp; __out, unsigned char __c)
    ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:556:5: note: candidate function [with _Traits = std::char_traits&lt;char&gt;] not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'const char *' for 2nd argument
    operator&lt;&lt;(basic_ostream&lt;char, _Traits&gt;&amp; __out, const char* __s)
    ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:569:5: note: candidate function [with _Traits = std::char_traits&lt;char&gt;] not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'const signed char *' for 2nd argument
    operator&lt;&lt;(basic_ostream&lt;char, _Traits&gt;&amp; __out, const signed char* __s)
    ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:574:5: note: candidate function [with _Traits = std::char_traits&lt;char&gt;] not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'const unsigned char *' for 2nd argument
    operator&lt;&lt;(basic_ostream&lt;char, _Traits&gt;&amp; __out, const unsigned char* __s)
    ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:628:5: note: candidate function [with _CharT = char, _Traits = std::char_traits&lt;char&gt;, _Tp = std::basic_istream&lt;char&gt;] not viable: no known conversion from 'ostream' (aka 'basic_ostream&lt;char&gt;') to 'basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt; &amp;&amp;' for 1st argument
    operator&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp;&amp; __os, const _Tp&amp; __x)
    ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/bits/ostream.tcc:321:5: note: candidate function [with _CharT = char, _Traits = std::char_traits&lt;char&gt;] not viable: no known conversion from 'istream' (aka 'basic_istream&lt;char&gt;') to 'const char *' for 2nd argument
    operator&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp; __out, const char* __s)
    ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:497:5: note: candidate template ignored: deduced conflicting types for parameter '_CharT' ('char' vs. 'std::basic_istream&lt;char&gt;')
    operator&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp; __out, _CharT __c)
    ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/bits/basic_string.h:5325:5: note: candidate template ignored: could not match 'basic_string' against 'basic_istream'
    operator&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp; __os,
    ^
/usr/local/bin/../lib/gcc/x86_64-pc-linux-gnu/6.1.0/../../../../include/c++/6.1.0/ostream:539:5: note: candidate template ignored: could not match 'const _CharT *' against 'istream' (aka 'basic_istream&lt;char&gt;')
    operator&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp; __out, const _CharT* __s)
    ^
1 error generated.
</code></pre>
",0
42620264,42620240,2,"<p>What version of gcc are you using?</p>

<p>You might need at -std=c++11 to your command line</p>
",0
42620271,42620240,2,"<p>The problem is that MSVC2013 does not support <code>constexpr</code>. It does not purport to implement the C++11 standard.</p>

<p>The first version that does is MSVC2015.</p>

<p>Your <code>constexpr</code> statement is grammatically correct C++11. Make sure you have a GCC version compliant with that standard.</p>
",0
42640157,42640030,1,"<p>This is likely caused by comparing a <code>double</code> value to 0. You should always compare <code>double</code> values to a tolerance, i.e., </p>

<pre><code>if (abs(x)  &lt; 0.0001) 
</code></pre>

<p>instead of </p>

<pre><code>if (x == 0)
</code></pre>

<p>You can use any minimum acceptable value instead of 0.0001. See <a href=""https://stackoverflow.com/q/17333/898810"">this answer</a> for more details.</p>
",5
41912821,41912719,2,"<p>As people have indicated in the comments, you shouldn't define a function inside of another function like this.</p>

<pre><code>int main(){
   // This is defined inside of main
   int sum_digits(int tiv) {
      int sum = 0;
      while (tiv &gt; 0) {
</code></pre>

<p>I'd always encourage proper code indentation as that would have made this problem much more obvious.</p>

<p>Also, this isn't the correct way to do a function call:</p>

<pre><code>int root = sum_digit(int num);
</code></pre>

<p>You don't need to include the <code>int</code> again here (in fact, it's not syntactically valid to do so) - it's already clear from the rest of your code that <code>num</code> is an <code>int</code>.</p>

<p>Same thing here:</p>

<pre><code>while(root &gt; 9) {
  sum_digits(int root);
};
</code></pre>

<p>Also, you don't actually do anything with the return value of <code>sum_digits</code>, so this will literally do nothing. It will either be an infinite loop (if <code>root</code> is greater than 9), since the value of <code>root</code> never changes, or the loop won't ever run (if <code>root</code> is less than 9).</p>

<p>One final point: in order to have this program actually do anything, you'll have to call the functions from your <code>main</code> method with some value. Right now even if you fix the compilation errors the program won't work because you don't actually determine what values you want the root of and you never actually call the functions you wrote.</p>
",4
41912824,41912719,0,"<p>defining functions within functions is nothing you should do in c/c++. I think gcc supports this, but afaik its not standard conforming.</p>

<p>just declare and define your functions not within other functions. use anonymous namespaces if you want to hide them from your public api</p>
",0
42640806,42640666,0,"<p>You have two alternatives to node creation:</p>

<ol>
<li><p>use of create method but you have to make it static. You don;t have to instantiate other object in order to call 'create' method. That way you use sort of factory method pattern.</p>

<p>class DLNode{
    ...
     static DLNode * create(int d);
    ...
    }</p>

<pre><code>void DoubleLinkedListImplementation::appendToBeginningOfList(int data)
{
      DLNode *node=DLNode::create(data);
      if(head==NULL){
          head=node;
      }
      else{
          node-&gt;setNextNode(head);
          head-&gt;setPreviousNode(node);
          head=node;
      }
}
</code></pre></li>
<li><p>use directly the new operator to create your node</p>

<pre><code>void DoubleLinkedListImplementation::appendToBeginningOfList(int data)
{
      DLNode *node= new DLNode(data);
      if(head==NULL){
          head=node;
      }
      else{
          node-&gt;setNextNode(head);
          head-&gt;setPreviousNode(node);
          head=node;
      }
}
</code></pre></li>
</ol>
",0
36541715,36541592,-1,"<p>This answer should be helpful:</p>

<p><a href=""https://stackoverflow.com/questions/120876/c-superclass-constructor-calling-rules"">C++ superclass constructor calling rules</a></p>

<p>Also, for the display method you should consider using a <em>virtual</em> function to achieve <em>polymorphism</em>, see the following links for detailed explanation:</p>

<p><a href=""http://www.cplusplus.com/doc/tutorial/polymorphism/"" rel=""nofollow noreferrer"">C++ referece: Polymorphism</a></p>
",0
36689448,36685511,0,"<p>I think you accidentally put the collision detection for ships inside the block containing the code for collision for planets.</p>

<p>Try change your code to this:</p>

<pre><code>        void Spacewar::collisions()
    {
        VECTOR2 collisionVector;
        for (int i = 0; i &lt; 10; i++)
        {
            if (ship[i].collidesWith(planet, collisionVector))
            {
                // bounce off planet
                ship[i].bounce(collisionVector, planet);
                ship[i].damage(PLANET);
            }

            // if collision between ships
            for (int j = i + 1; j &lt; 10; j++)
            {
                if (ship[i].collidesWith(ship[j], collisionVector))
                {
                    // Bounce off ship
                    ship[i].bounce(collisionVector, ship[j]);
                    ship[i].damage(SHIP);
                    // change the direction of the collisionVector for ship2
                    ship[j].bounce(collisionVector*-1, ship[i]);
                    ship[j].damage(SHIP);
            }
        }
    }
}
</code></pre>
",1
37759390,37759344,1,"<pre><code> if(population[i]&gt; max);
        max = population[i];
</code></pre>

<p>should be</p>

<pre><code> if(population[i]&gt; max)
        max = population[i];
</code></pre>

<p>Try that and see.  </p>

<p>OK, I think I see what's up now.  You are trying to print populations for the various years.  Each column is essentially 6 characters wide (<code>""\*\*""</code> set in a <code>setw(3)</code>, plus a <code>""   ""</code>).  Trouble is, you only print that column if it's going to get the <code>""**""</code>; otherwise you print nothing.  So all the columns with <code>""\*\*""</code> are jammed to the left.</p>

<p>Solution is to always print the column, for each row, whether it gets a <code>""**""</code> or not:</p>

<pre><code>        for (int year_counter = 0; year_counter &lt;= count - 1; year_counter++)
            if (num &lt;= population[year_counter])
                cout &lt;&lt; setw(3) &lt;&lt; ""**"" &lt;&lt; ""   "";
            else                                    //NEW
                cout &lt;&lt; setw(3) &lt;&lt; ""  "" &lt;&lt; ""   "";   //NEW
</code></pre>
",3
45043298,45041897,1,"<p>On a modern (non-embedded) CPU, the branch predictor will be smart enough to recognize that the same path is taken every time, so an <code>if</code> statement is a perfectly acceptable (and readable) way of handling your situation.</p>

<p>On an embedded processor, compiler optimizations should be smart enough to get rid of most of the overhead of the <code>if</code> statement.</p>

<p>If you're really picky, you can use the template method that you mentioned earlier, and have an <code>if</code> statement select which version of the function to execute.</p>
",0
45668698,45666879,0,"<p>I had some trouble to handle the term <strong>discrete statement</strong> (especially because it has been emphasized multiple times). I tried to find something like a clear definition (by google) but I couldn't. Thus, I decided to read this literally as <em>one statement</em> (with <em>discrete</em> in the sense of <em>separate</em>).</p>

<p>Denoting a function <code>inline</code> is just a hint to the compiler that the programmer would like to have the function body inserted directly at every ""call point"" (instead of simply calling the function). Actually, the compiler decides whether the function is really inlined. (It might be even inlined at one point of call but become a function call at another point.) If a macro is used instead of the inline function, the inline requirement would be granted (as macro expansion is actually nothing else than text replacement). Of course, macros have a lot of limitations which inline functions have not. One of them is that inline functions may have local variables.</p>

<p>I made a synthetic example. It's not code ""ready for production"" but it hopefully helps to illustrate the topic:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

inline int absValue(int a)
{
  int mB = -a;
  return a &lt; 0 ? mB : a;
}

int main()
{
  int value;
  // use input to prevent compile-time computation
  cout &lt;&lt; ""input: "" &lt;&lt; flush;
  cin &gt;&gt; value;
  // multiple usages of absValue()
  cout &lt;&lt; ""value: "" &lt;&lt; value &lt;&lt; endl
    &lt;&lt; ""absValue(value): ""
    &lt;&lt; absValue(value)
    &lt;&lt; endl
    &lt;&lt; ""absValue(-value): ""
    &lt;&lt; absValue(-value)
    &lt;&lt; endl;
  // done
  return 0;
}
</code></pre>

<p>The second output statement calls function <code>absValue()</code> multiple times where the call should be inlined. I imagine it like:</p>

<pre><code>  // multiple usages of absValue()
  cout &lt;&lt; ""value: "" &lt;&lt; value &lt;&lt; endl
    &lt;&lt; ""absValue(value): ""
    &lt;&lt; {
         int mB = -(value);
         return (value) &lt; 0 ? mB : (value);
       }
    &lt;&lt; endl
    &lt;&lt; ""absValue(-value): ""
    &lt;&lt; {
         int mB = -(-value);
         return (-value) &lt; 0 ? mB : (-value);
       }
    &lt;&lt; endl;
</code></pre>

<p>There are two occurrences of <code>mB</code> in this statement. On one hand, these are two separate local variables. On the other hand, they may share the same storage on stack as they are used consecutively. (They might not share the same storage if the compiler optimization introduces some kind of code re-ordering which results in interleaving of the first and second expansion of <code>absValue()</code>.)</p>

<p>This whole explanation is rather theoretically. Practically, the compiler will hopefully put <code>mB</code> into a register or even optimize most of the code away.</p>

<p>I fiddled a little bit with <a href=""https://godbolt.org/g/8rK8JF"" rel=""nofollow noreferrer""><strong>godbolt</strong></a> to illustrate it further. Finally, I must admit that it proofs essentially my last paragraph above.</p>
",0
39318983,39318892,3,"<pre><code>void TreasureSeeker::save(ofstream &amp; out)const
{
    out.write((const char*)this, sizeof(*this));
}
</code></pre>

<p>You may only do this if all the data members of the class are <a href=""https://stackoverflow.com/questions/146452/what-are-pod-types-in-c""><strong><code>POD types</code></strong></a> and do not own a <strong>resource</strong>, even with that, there comes the issue of <a href=""https://en.wikipedia.org/wiki/Data_structure_alignment"" rel=""nofollow noreferrer"">structure padding</a>.</p>

<p>Free advice, don't do this expressly, its usually not portable even for non-resource owning POD types.</p>

<p>NOTE: A pointer either owns or refers to a resource (memory).</p>

<p>Different compilers may <a href=""https://en.wikipedia.org/wiki/Data_structure_alignment"" rel=""nofollow noreferrer"">pad your structure</a> and lay it out in memory differently.</p>

<pre><code>TreasureSeeker::TreasureSeeker(ifstream&amp; in)
{
    in.read((char*)this, sizeof(*this));
}
</code></pre>

<p>In addition to what I said previously, this is also a pretty bad idea. You are in the context of <code>this</code>, and externally modifying the whole of <code>this</code>, while its alive....</p>

<hr>

<p>To solve your problem, read About <a href=""https://isocpp.org/wiki/faq/serialization"" rel=""nofollow noreferrer"">Serialization in C++</a></p>
",0
37451921,37451831,0,"<p>You can use substr or find functions to find spaces or other characters that you want. </p>

<p>For example:</p>

<pre><code>string str=""We think in generalities, but we live in details."";
string str2 = str.substr (3,5);  // output --&gt; ""think""
</code></pre>

<p>please read these pages it will help you:</p>

<p><a href=""http://www.cplusplus.com/reference/string/string/substr/"" rel=""nofollow"">http://www.cplusplus.com/reference/string/string/substr/</a></p>

<p><a href=""http://www.cplusplus.com/reference/string/string/find/"" rel=""nofollow"">http://www.cplusplus.com/reference/string/string/find/</a></p>
",0
37452335,37451831,0,"<p>Use strtok. In my opinion, there isn't a need to build a class around tokenizing unless strtok doesn't provide you with what you need. Here is an example</p>

<pre><code>char myString[] = ""Word1 Word2""; 
char *p = strtok(myString, "" "");

while (p) { 
    printf (""Token: %s\n"", p);
    p=strtok(NULL, "" "");
}
</code></pre>

<p>A few caveats (which might not suit your needs). The string is ""destroyed"" in the process, meaning that EOS characters are placed inline in the delimter spots. Correct usage might require you to make a non-const version of the string. You can also change the list of delimiters mid parse.</p>
",0
37452442,37451831,2,"<p>You can use the <code>operator&gt;&gt;</code> function on the input stream and disable skipping white space characters.</p>

<h3>Example Code</h3>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;

int main()
{
    std::stringstream ifs;
    ifs.unsetf(std::ios::skipws);
    ifs.str(""word by word\n this is test"");

    std::string word;
    char ws;
    bool isWord = false;

    // Keep reading words or if that fails clear the error state and read a white space character
    while ((isWord = static_cast&lt;bool&gt;(ifs &gt;&gt; word)) || (ifs.clear(), ifs &gt;&gt; ws))
    {
        std::cout &lt;&lt; ""word: '"";
        if (isWord)
            std::cout &lt;&lt; word;
        else
            std::cout &lt;&lt; ws;
        std::cout &lt;&lt; ""'\n"";
    }

    return 0;
}
</code></pre>

<h3>Example Output</h3>

<pre><code>word: 'word'
word: ' '
word: 'by'
word: ' '
word: 'word'
word: '
'
word: ' '
word: 'this'
word: ' '
word: 'is'
word: ' '
word: 'test'
</code></pre>

<p><a href=""http://ideone.com/Ob8ZXV"" rel=""nofollow"">Live Example</a></p>
",0
37452736,37451831,0,"<p>Full c++ solution based on orbitcowboy suggestion.</p>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;

int main()
{
    std::vector&lt;std::string&gt;    words;

    std::ifstream ifs(""words.txt"");
    if (ifs.is_open() == false)
    { std::cerr &lt;&lt; ""Couldn't open file..."" &lt;&lt; std::endl; return -1; }

    std::string string_to_split(
                 (std::istreambuf_iterator&lt;char&gt;(ifs))
                 , std::istreambuf_iterator&lt;char&gt;());

    char * cstr = new char [string_to_split.length()+1];
    std::strcpy (cstr, string_to_split.c_str());

    const char delimiters[]="" \t\r\n\v\f"";
    char *p = strtok(cstr, delimiters);
    while (p) {
        words.push_back(p);
        words.push_back("""");
        p = strtok(NULL, delimiters);
    }

    for (auto word : words)
    { std::cout &lt;&lt; ""word: "" &lt;&lt; word &lt;&lt; std::endl; }
}
</code></pre>

<p>Note that this is higlhy inneficient for huge files due to the way I create string_to_split.</p>

<p>This uses a c++11 feature at the end <code>for (auto sentence : sentences)</code>, remove it if you don't compile with c++11 flag.</p>
",0
36806776,36806132,1,"<p>I'd solve this by printing the space BEFORE the item. E.g.: </p>

<pre><code>cout &lt;&lt; "" "" &lt;&lt; item;
</code></pre>

<p>Problem is, you'll now have an extra space after ""Expanded: "". You could easily solve this by adding an 'if' statement, that prints the first thing without a space, before you kick off the while loop: </p>

<pre><code>      if(getline(ss, item, ' ')) {
        if(contains(item) == 1) {
          cout &lt;&lt; myMap[item];
        } 
        else {
          cout &lt;&lt; item;
        } 
      }
      while(getline....)
</code></pre>

<p>Or, you could just delete the trailing space from where you print ""Expanded: "" :)</p>
",1
36810996,36806132,1,"<p>An alternative is to use a <code>std::string</code> as a temporary buffer and remove the last char (the extra space) before printing it.</p>

<p>You may also avoid to declare the map as a global variable and pass it as a parameter to the <code>contains</code> function. It's a design choice, I don't know how much of your actual code depends on <code>myMap</code> to be a global.</p>

<p>That's how you can change your code:</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;sstream&gt;
#include&lt;map&gt;

using std::cout;
using std::endl;
using std::string;
using std::map;

bool contains( map&lt;string, string&gt; m, string str) {
    return  m.find(str) != m.end();
}

int main() {
    map&lt;string, string&gt; myMap{
        {""BFF"", ""best friend forever""},
        {""IDK"", ""I don't know""},
        {""JK"", ""just kidding""},
        {""TMI"", ""too much information""},
        {""TTYL"", ""talk to you later""},
        {""IDK."", ""I don't know.""},
        {""TTYL."", ""talk to you later.""},
        {""BFF,"", ""best friend forever,""},
        {""JK,"", ""just kidding,""},
        {""JK."", ""just kidding.""},
        {""TMI!"", ""too much information!""},
        {""TMI."", ""too much information.""},
    };

    string text;

    cout &lt;&lt; ""Enter text: "";
    getline(std::cin, text);
    cout &lt;&lt; ""You entered: "" &lt;&lt; text &lt;&lt; endl;
    cout &lt;&lt; ""Expanded: "";

    std::stringstream ss(text);
    string item;
    string outs;
    while ( ss &gt;&gt; item ) {             // spaces are delimiters for operator&gt;&gt;
        if( contains(myMap, item) ) {
            outs += myMap[item];
        } 
        else {
            outs += item;
        }
        // or, if you know the conditional operator:
        //                outs += contains(myMap, item) ? myMap[item] : item;

        outs += ' ';
    }
    outs.pop_back();                   // removes the last char
    cout &lt;&lt; outs &lt;&lt; endl;

    return 0;                          
}
</code></pre>

<p>Please note that you are searching for item in the map twice, you can avoid that by doing so:</p>

<pre><code>while ( ss &gt;&gt; item ) {
    map&lt;string, string&gt;::iterator it = myMap.find(item);
    outs += (it != myMap.end() ) ? it-&gt;second : item;
    ...
</code></pre>
",1
36811035,36806132,1,"<p>Just make it a prefix, rather than suffix, space:</p>

<pre><code>cout &lt;&lt; ""Expanded:"";               // Removed trailing space here

stringstream ss(text);
string item;
while (getline(ss, item, ' ')) {
    cout &lt;&lt; ' ';                   // now adding space FIRST
    if (contains(item) == 1)
       cout &lt;&lt; myMap[item];
    else
       cout &lt;&lt; item;
}
</code></pre>

<p>Now, there is no space at the end of the line (whether you had items or not), but each item (if you <em>do</em> have some) is still separated by a space.</p>
",0
36733146,36732932,1,"<p>To fix your problem try to return zero as the main function should return it, if your code is clear from errors.</p>

<p>Try to follow that convention to always return 0 in main. </p>

<p>Your code should look like this:</p>

<pre><code>#include &lt;iostream&gt; 
using namespace std;

int main()
{ 
    int Y; 
    cin &gt;&gt; Y; 
    cout &lt;&lt; 2*Y &lt;&lt; "" minutos "" &lt;&lt; endl;         

    return 0; 
}
</code></pre>

<p>To conclude simply use <em>cout</em> instead of <em>return</em>. </p>
",3
36733593,36732932,1,"<p>PE is a common error in OJ of ACM. you can check <strong>space</strong> , <strong>newline</strong> charactor or something you missed.  for example:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main(){
  int Y;

  cin &gt;&gt; Y;
  cout &lt;&lt; 2*Y &lt;&lt; "" minutos (minutes in portuguese)"" &lt;&lt; endl;

  return 0;
}
</code></pre>

<p>you can have a try, good luck for you.</p>
",0
37117320,37117232,2,"<p>One hint: Read to a temporary string variable, and store the values in <code>std::set&lt;std::string&gt;</code> - there you can check if the value has been already entered before.</p>
",0
36734513,36734413,0,"<p>Well, just run the loop <code>howMany</code> times and overwrite the value in <code>nums</code>.</p>

<pre><code>int j = 0;
for (int counter = 0; counter &lt; howMany; ++counter)
{
    nums[j++] = index;
}
</code></pre>

<p>Now sure why do you want to re-assign values to <code>counts</code>. <code>counts</code> already stores the frequency of each number in <code>nums</code>.</p>
",0
36734820,36734413,0,"<p><em>Possibly</em> this is what you need:</p>

<pre><code>void babySort(int nums[], int length){
    int counts[100]={0}; 
    for(int i=0;i&lt;length;i++)
        counts[nums[i]]++;

    int j=0;
    for(int index=0; index&lt;100; index++){
        for(; counts[index]&gt;0; counts[index]--)
            nums[j++]=index;
    }
}
</code></pre>

<p>The <code>for(index)</code> loop scans possible <code>index</code> values and when it finds one that has been encountered in the input <code>nums[]</code>, the <code>for(counts)</code> loop fills appropriate number of <code>nums[]</code> items with that value, just by counting from accumulated <code>count[index]</code> down to zero. Variable <code>j</code> counts filled items.</p>
",0
36734744,36734413,0,"<p>That isn¡¯t a very efficient algorithm to begin with. Partly because it assumes that none of the values will ever be greater than 99 or less than 0, and partly because it wastes a lot of processing time if there aren¡¯t that many numbers to sort. You¡¯d probably be better off using an algorithm like this one:</p>

<pre><code>void babySort(int nums[], int length) {
   int i,j;
   int Value;

   for(i = 1; i &lt; length; i++) {
      Value = nums[i];
      for(j = i - 1; j &gt;= 0 &amp;&amp; nums[j] &gt; Value; j--) {
         nums[j + 1] = nums[j];
      }
      nums[j + 1] = Value;
   }
}
</code></pre>
",0
36735651,36734413,0,"<pre><code>int findMinUnique(int* originArray, int* sortedArray, int lastInsertedValue)
{
  int tempInt = 0x7fffffff;//max possible int32

  for(int i = 0; i &lt; length; i++)
  {
    if(originArray[i] &lt; tempInt &amp;&amp; originArray &gt; lastInsertedValue)
    {
      tempInt = originArray[i];
    }
  }
  return tempInt;
}
void babySort(int nums[], int length)
{
  int insertedValues = 0, lastInserted = -1;
  int* anotherArray = new int[length];
  //you have to allocate memory for an array, it may be of any length
  while(insertedValues &lt; length)
  {
    int temp = findMinUnique(nums, anotherArray, lastInserted);
    for(int j = 0; j &lt; length j++)
    {
      if(nums[j] = tempValue)
        lastInserted = anotherArray[insertedValues++] = nums[j];
    }
  }
  //if you need nums to become sorted, copy anotherArray to nums
  for(int k = 0; k &lt; length; k++)
    nums[k] = anotherArray[k];
  delete[] anotherArray;
}
</code></pre>
",0
38299827,38299558,2,"<p>I'm sure others have better suggestions, but some very basic improvements are:</p>

<pre><code>#include&lt;iostream&gt;
// Don't import libraries you don't use.

class Convert //Classes typically have the leading character Capitalized.
{
public:
    /*Give meaningful function names.*/
    float celsius_To_Fahrenheit(const float &amp;y) /*Placing ""const"" in your parameters is good practice if you don't need/want to change the parameter inside the function.*/
    {
        //Try not to use local variables in classes, use member variables if you do need a variable.
        //I'm not sure either member function *needs* a local variable.
        //And I don't think this very simple classes needs local variables, yet.
        return y*9/5+32; /*Use ""return"" to return *something* otherwise, use ""void"" functions.*/
    }

    float fahrenheit_To_Celsius(const float &amp;x)/*And using ""&amp;"" to pass by reference is good in combination with ""const"", this makes your code more efficient so multiple copies don't exist of the same variable.*/
    {
        //Avoid putting std::cout statements inside classes as a habit.
        return (x-32)*5/9;
    }
};

int main()
{
    char choice = 'z'; //Give meaningful variable names.
    float temperature = 1; // Initialize local variables!
    Convert temp_converter;

    std::cout &lt;&lt; ""__________Temp Converter-----------"" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""What would like to convert? (c/f): "";
    std::cin &gt;&gt; choice;

    switch(choice)
    {
        case 'c' : std::cout &lt;&lt; ""Input Celsius: "";
            std::cin &gt;&gt; temperature;
            std::cout &lt;&lt; temperature &lt;&lt; "" converted to Fahrenheit is "" &lt;&lt; temp_converter. celsius_To_Fahrenheit(temperature) &lt;&lt; std::endl;
            break;
        case 'f' :std::cout &lt;&lt; ""Input Fahrenheit: "";
            std::cin &gt;&gt; temperature;
            std::cout &lt;&lt; temperature &lt;&lt; "" converted to Celcius is "" &lt;&lt; temp_converter. fahrenheit_To_Celsius(temperature) &lt;&lt; std::endl;
            break;
        default:
            std::cout &lt;&lt; ""Wrong input."";
    }
    return 0;
}
</code></pre>
",2
38301027,38299558,1,"<p>I won't post a wall of code as @NonCreature0714 has already done that.</p>

<p>I wouldn't have a class called <code>convert</code>. Will you stick <code>volt_amperes</code> and <code>watts</code> in there too?</p>

<p>Also what happens if you have a whole lot of functions that use Celsius and and another load that use Fahrenheit would they all live together in the same class?  Personally I would have a code unit called <code>celsius</code> and another code unit called <code>fahrenheit</code> and then have a third unit called <code>celsius_fahrenheit</code> which would handle conversions between the two.  This means you can have code that needs just Celsius without pulling in all the Fahrenheit.</p>
",0
37198896,37198819,0,"<p>You need to deference your string.  You also need to change <code>#include &lt;string.h&gt;</code> to <code>#include &lt;string&gt;</code> instead.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

void print_str( const std::string* str ) {
    std::cout &lt;&lt; *str &lt;&lt; std::endl;
}

int main() {
    std::string str = ""Hello world!"";
    print_str( &amp;str );
    return 0;
}
</code></pre>

<p>Execution example:
<a href=""https://ideone.com/AGSk1k"" rel=""nofollow"">https://ideone.com/AGSk1k</a></p>
",2
37199307,37198819,0,"<p>While dereferencing the string and using <code>#include &lt;string&gt;</code> was already <a href=""https://stackoverflow.com/questions/37198819/passing-the-address-of-string-objects-to-functions/37198896#37198896"">explained by Blake</a>, the exercise, if I understood correctly, is about using a single function, not two functions. I think, they meant something along these lines (<a href=""http://ideone.com/TcfsLQ"" rel=""nofollow noreferrer"">code on ideone.com</a>):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

void print_str(std::string const * _str, int _flag = 0){
 static int count_call = 0;
 ++count_call;
 int count_print = _flag ? count_call : 1;

 while(count_print--)
  std::cout &lt;&lt; *_str &lt;&lt; std::endl;
}

int main(){
 std::string str{""Hello, world!""};

 print_str(&amp;str);
 print_str(&amp;str);
 print_str(&amp;str);
 std::cout &lt;&lt; std::endl;

 print_str(&amp;str, 1);
 std::cout &lt;&lt; std::endl;

 print_str(&amp;str);

 return (0);
}
</code></pre>

<p>Program output:</p>

<pre><code>Hello, world!
Hello, world!
Hello, world!

Hello, world!
Hello, world!
Hello, world!
Hello, world!

Hello, world!
</code></pre>
",1
38020309,38020228,2,"<p>Make some <a href=""http://en.cppreference.com/w/cpp/container"" rel=""nofollow"">container</a> (probably a <code>std::list&lt;std::string&gt;</code>, perhaps a <code>std::set&lt;std::string&gt;</code> or a <code>std::vector&lt;std::string&gt;</code>) containing the collections of found (absolute) file paths, then delete all of them (using <a href=""http://en.cppreference.com/w/cpp/filesystem/remove"" rel=""nofollow"">std::filesystem::remove</a> or simply the C <a href=""http://en.cppreference.com/w/cpp/io/c/remove"" rel=""nofollow"">remove</a> ...)</p>

<p>So you have two steps: first, you iterate on your file system to find relevant files (on Linux, I would use <a href=""http://man7.org/linux/man-pages/man3/nftw.3.html"" rel=""nofollow"">nftw(3)</a> for that; perhaps your OS has something similar) without removing them (but collecting their <em>full</em> file path in the container). Second, you iterate on the container to remove every file path there.</p>
",2
38020491,38020228,1,"<p>You are looking for <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa363915.aspx"" rel=""nofollow""><code>DeleteFile()</code></a>, eg:</p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;Shlwapi.h&gt;

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#pragma comment(lib, ""shlwapi.lib"");    

void GetFolderListing(std::string directory, const std::string &amp;fileFilter, std::vector&lt;std::string&gt; *subfolders, std::vector&lt;std::string&gt; *files)
{    
    if (!directory.empty() &amp;&amp; (*directory.rbegin() != '\\'))
        directory += ""\\"";

    std::string filter = directory;
    if (subfolders)
        filter += ""*"";
    else
        filter += fileFilter;

    WIN32_FIND_DATAA FindFileData;
    HANDLE hFind;
    DWORD dwError;

    hFind = FindFirstFileA(filter.c_str(), &amp;FindFileData);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        if (dwError != ERROR_FILE_NOT_FOUND)
            std::cout &lt;&lt; ""FindFirstFile error "" &lt;&lt; dwError &lt;&lt; std::endl;
        return;
    }

    do
    {
        if (FindFileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)
        {
            if ((subfolders) &amp;&amp;
                (lstrcmpA(FindFileData.cFileName, ""."") != 0) &amp;&amp;
                (lstrcmpA(FindFileData.cFileName, "".."") != 0))
            {
                subfolders-&gt;push_back(directory + FindFileData.cFileName);
            }
        }
        else
        {
            if ((files) &amp;&amp;
                ((!subfolders) || PathMatchSpecA(FindFileData.cFileName, fileFilter.c_str())))
            {
                files-&gt;push_back(directory + FindFileData.cFileName);
            }
        }
    }
    while (FindNextFileA(hFind, &amp;FindFileData));

    dwError = GetLastError();
    FindClose(hFind);
    if (dwError != ERROR_NO_MORE_FILES)
        std::cout &lt;&lt; ""FindNextFile error "" &lt;&lt; dwError &lt;&lt; std::endl;
}

void DeleteFiles(const std::string &amp;directory, const std::string &amp;fileFilter, bool recursively = true)
{    
    std::vector&lt;std::string&gt; folders;
    std::vector&lt;std::string&gt; files;

    GetFolderListing(directory, fileFilter, (recursively) ? &amp;folders : NULL, &amp;files);

    for (std::vector&lt;std::string&gt;::iterator iter = files.begin(); iter != files.end(); ++iter)
        DeleteFileA(iter-&gt;c_str());

    if (recursively)
    {
        for (std::vector&lt;std::string&gt;::iterator iter = folders.begin(); iter != folders.end(); ++iter)
            DeleteFiles(*iter, fileFilter, true);
    }
}

int main(int argc, char* argv[])
{
    DeleteFiles(""c:\\"", ""*.do"");
}
</code></pre>

<p>Or, using Unicode (which you should be using instead of ANSI):</p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;Shlwapi.h&gt;

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#pragma comment(lib, ""shlwapi.lib"");    

void GetFolderListing(std::wstring directory, const std::wstring &amp;fileFilter, std::vector&lt;std::wstring&gt; *subfolders, std::vector&lt;std::wstring&gt; *files)
{    
    if (!directory.empty() &amp;&amp; (*directory.rbegin() != L'\\'))
        directory += L""\\"";

    std::wstring filter = directory;
    if (subfolders)
        filter += L""*"";
    else
        filter += fileFilter;

    WIN32_FIND_DATAW FindFileData;
    HANDLE hFind;
    DWORD dwError;

    hFind = FindFirstFileW(filter.c_str(), &amp;FindFileData);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        if (dwError != ERROR_FILE_NOT_FOUND)
            std::cout &lt;&lt; ""FindFirstFile error "" &lt;&lt; dwError &lt;&lt; std::endl;
        return;
    }

    do
    {
        if (FindFileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)
        {
            if ((subfolders) &amp;&amp;
                (lstrcmpW(FindFileData.cFileName, L""."") != 0) &amp;&amp;
                (lstrcmpW(FindFileData.cFileName, L"".."") != 0))
            {
                subfolders-&gt;push_back(directory + FindFileData.cFileName);
            }
        }
        else
        {
            if ((files) &amp;&amp;
                ((!subfolders) || PathMatchSpecW(FindFileData.cFileName, fileFilter.c_str())))
            {
                files-&gt;push_back(directory + FindFileData.cFileName);
            }
        }
    }
    while (FindNextFileW(hFind, &amp;FindFileData));

    dwError = GetLastError();
    FindClose(hFind);
    if (dwError != ERROR_NO_MORE_FILES)
        std::cout &lt;&lt; ""FindNextFile error "" &lt;&lt; dwError &lt;&lt; std::endl;
}

void DeleteFiles(const std::wstring &amp;directory, const std::wstring &amp;fileFilter, bool recursively = true)
{    
    std::vector&lt;std::wstring&gt; folders;
    std::vector&lt;std::wstring&gt; files;

    GetFolderListing(directory, fileFilter, (recursively) ? &amp;folders : NULL, &amp;files);

    for (std::vector&lt;std::wstring&gt;::iterator iter = files.begin(); iter != files.end(); ++iter)
        DeleteFileW(iter-&gt;c_str());

    if (recursively)
    {
        for (std::vector&lt;std::wstring&gt;::iterator iter = folders.begin(); iter != folders.end(); ++iter)
            DeleteFiles(*iter, fileFilter, true);
    }
}

int wmain(int argc, wchar_t* argv[])
{
    DeleteFiles(L""c:\\"", L""*.do"");
}
</code></pre>
",6
43744515,43744372,1,"<p>The reason why it does not show the grades as expected is because you are not adding up the values.While taking the average over all the grades variable
'pazymiai' stores just the last entered variable. In order to complete the job you can use an 'array' to stores sum of grades in each array element .</p>

<pre><code>cin&gt;&gt;pazymiai;
a[k]+=pazymiai;
</code></pre>

<p>where as while calculating grades use </p>

<pre><code> vidurkis = a[k] / isvisopazymiu;
</code></pre>
",0
44733292,44733258,1,"<p><code>printf(""%d\n"",b);</code> prints a signed number due to the <code>%d</code> flag. If you want an unsigned number use <code>%u</code>:</p>

<pre><code>printf(""%u\n"",b);
</code></pre>
",1
44733295,44733258,2,"<p>You're telling <code>printf</code> to print a <em>signed</em> int value with the <code>%d</code> format specifier.  Technically undefined behavior, but most implementations will convert the unsigned value back to the equivalent signed value to print.</p>

<p>You want <code>%u</code> to print an unsigned value.</p>
",1
43200683,43200673,0,"<p>You need to remove precompiled headers options with the file, you can do that using these instructions from Microsoft-><a href=""https://docs.microsoft.com/en-us/cpp/error-messages/compiler-errors-1/fatal-error-c1010"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/cpp/error-messages/compiler-errors-1/fatal-error-c1010</a></p>
",0
42532771,42532740,0,"<p>The pointer becomes a <em>stray</em> or <em>dangling</em> pointer, and dereferencing it will lead to <a href=""http://en.cppreference.com/w/cpp/language/ub"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>.</p>

<p>If your program have UB (Undefined Behavior) it is ill-formed and invalid.</p>
",1
37240398,37240340,10,"<p><code>operator+</code> is not a normal identifier, it is an <em>operator-function-id</em> as defined in 13.5/1 in N4140. By definition, it consists of the word <code>operator</code> followed by an operator, the <code>+</code> in your example. By this rule, you can also write</p>

<pre><code>operator +
</code></pre>

<p>or even</p>

<pre><code>user_data_type
operator


+
(const user_data_type &amp; t) const;
</code></pre>

<p>as again, <code>operator+</code> is not a normal identifier.</p>

<p>The rule you cite does not apply here. </p>
",0
37240482,37240340,0,"<p>Operator overload functions can only contain punctuation or symbols that are operators which can be overloaded. When using the keyword <code>operator</code> followed by a valid operator you are using a built-in feature of C rather than creating your own identifier.</p>
",0
37240483,37240340,7,"<p>From ¡ì3.1</p>
<blockquote>
<p>A name is a use of an <b>identifier</b> (2.11), <b>operator-function-id</b> (13.5), literal-operator-id (13.5.8), conversion-function-
id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1).</p>
</blockquote>
<p>So, as you can see, there are rules for the <i>identifiers</i> (which are the variable/function names). But there are some exceptions, and operator overloading (<i>operator-function-id</i>) is one of them, which means different rules apply to them.</p>
<p>From ¡ì13.5:</p>
<blockquote>
<p>operator-function-id: <b>operator</b> <i>operator</i></p>
<p><i>operator</i>: one of</p>
<ul>
<li><p>new delete new[] delete[]</p>
</li>
<li><p>+ - * / % ? &amp; | ~</p>
</li>
<li><p>! = &lt; &gt; += -= *= /= %=</p>
</li>
<li><p>?= &amp;= |= &lt;&lt; &gt;&gt; &gt;&gt;= &lt;&lt;= == !=</p>
</li>
<li><p>&lt;= &gt;= &amp;&amp; || ++ -- , -&gt;* -&gt;</p>
</li>
<li><p>( ) [ ]</p>
</li>
</ul>
</blockquote>
<p>So, <code>operator+</code> is allowed, <code>operator-</code> also, basically <code>operator</code> + <code>any of the operators listed above</code>.</p>
",2
37240429,37240340,0,"<p><a href=""http://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Lexical-Elements"" rel=""nofollow"">The GNU C reference manual</a> states that </p>

<blockquote>
  <p>there are five types of tokens: keywords, identifiers, constants,
  operators, and separators</p>
</blockquote>

<p>thus operator is not an identifier.</p>

<pre><code>user_data_type operator + (const user_data_type &amp; t) const;/*
^^^^^          ^^^^^    ^
identifier     keyword  operator
*/
</code></pre>
",2
38306583,38306495,1,"<p>That's because <a href=""http://en.cppreference.com/w/cpp/utility/variadic/va_start"" rel=""nofollow""><code>va_start</code></a> (and all other <a href=""http://en.cppreference.com/w/cpp/utility/variadic"" rel=""nofollow"">variadic helper ""functions""</a>) can only be used in functions where the argument list ends in an elipsis <code>...</code>.</p>

<p>If you can, then you could modify the function like</p>

<pre><code>static inline int sgx_wrapper_open64(const char *pathname, int flags, ...)
{
    va_list ap; 
    va_start(ap, flags); 
    mode_t mode;

    if (flags &amp; O_CREAT)
        mode = va_arg(ap, mode_t); 
    else
        mode = 0777;

    va_end(ap);     

    int retval;
    ocall_open2(&amp;retval, pathname, flags, mode);
    return retval;
}
</code></pre>

<p>Note especially the change of the function argument list, and the addition of the local variable <code>mode</code>.</p>
",0
38306604,38306495,1,"<p>The error message ""¡®va_start¡¯ used in function with fixed args"" is self-explanatory. Your function has a fixed list of arguments. <code>va_start</code> can only be used in a function with a variadic argument list, meaning it ends with ellipsis, such as:</p>

<pre><code>static inline int sgx_wrapper_open64(const char *pathname, int flags, ...)
</code></pre>
",2
37241188,37240834,0,"<p>You can use the <code>&lt;time.h&gt;</code> header file and use the internal clock to measure if 10 seconds have passed or not</p>

<pre><code>clock_t t;

while (1) {    // This loop runs exactly once every 10 seconds
    t = clock();    // Reset clock

    // Do something in this loop

    while ((double)(clock()-t)/CLOCKS_PER_SEC &lt; 10);    // Wait if 10 seconds havent passed

}
</code></pre>

<p>This would fail if your computation inside the while loop takes more than 10 seconds</p>
",0
37241412,37240834,5,"<p>I generally use something like this:</p>

<pre><code>// for an easier life
using clock = std::chrono::steady_clock;

// set the baseline time
auto timeout = clock::now();

for(;;)
{
    // (re)set timer
    timeout += std::chrono::seconds(10);

    // sleep until time has elapsed
    std::this_thread::sleep_until(timeout);

    // do something useful (like print the time)
    auto timer = std::time(0);
    std::cout &lt;&lt; ""loop: "" &lt;&lt; std::ctime(&amp;timer) &lt;&lt; '\n';
}
</code></pre>

<p>By using <code>std::this_thread::sleep_until()</code> the loop doesn't consume <code>CPU</code> time while it is waiting for the <code>10</code> seconds to elapse.</p>

<p>This can be wrapped up in a neat little class like this:</p>

<pre><code>class wait_timer
{
    using clock = std::chrono::steady_clock;

    clock::duration time_to_wait;
    clock::time_point timeout = clock::now();

public:
    wait_timer(std::chrono::milliseconds ms)
    : time_to_wait(ms), timeout(clock::now()) {}

    void wait()
    {
        timeout += time_to_wait; // (re)set timer
        std::this_thread::sleep_until(timeout);
    }
};

int main()
{
    // create it outside the loop so it doesn't
    // loose track of time every iteration
    wait_timer wt(std::chrono::seconds(2));

    for(;;)
    {
        wt.wait();

        // do something useful (like print the time)
        auto timer = std::time(0);
        std::cout &lt;&lt; ""loop: "" &lt;&lt; std::ctime(&amp;timer) &lt;&lt; '\n';
    }
}
</code></pre>
",0
37243194,37240834,0,"<p>You can use <code>std::this_thread::sleep_for</code>:</p>

<pre><code>#include &lt;thread&gt;
#include &lt;chrono&gt;
using namespace std;
using namespace std::chrono_literals;

int main()
{
    while (1) {
        // some code

        this_thread::sleep_for(10s);
    }
}
</code></pre>
",0
42660409,42660304,2,"<p>This doesn't do what you think it does:</p>

<pre><code>std::string *str = new std::string[this-&gt;m_digitCount];
</code></pre>

<p>That allocates an array of empty strings.  I don't know how your code even compiles.</p>

<p>Anyway, what you meant to do was this:</p>

<pre><code>std::string str;
str.reserve( m_digitCount );
for (int j = 0; j &lt; m_digitCount; j++) {
    str.push_back( getDigit(j) );
}
return std::stod(str);
</code></pre>

<p>Note that the digit should be a character type.  If it's just an integer from 0 to 9, you will have to do <code>str.push_back( '0' + getDigit(j) )</code></p>
",0
40570237,40570118,1,"<p>If you want to use declarations to implement/define the function, declarations that you don't want to make visible in the *.h file, then it would be necessary to move the definition of the function to a separate file.</p>
",0
40570245,40570118,0,"<p>From a technical perspective (in terms of what a compiler needs or will accept) it is almost never necessary - it is possible to copy/paste the content of every (non-standard) header file into the source files that include them, and compile that.   After all, that is effectively what the preprocessor does with <code>#include</code> directives - copy the included file in place, after which the resultant source is fed to later phases of the compiler.</p>

<p>It is possible for a compiler to run out of memory when compiling source - in which case breaking the program into smaller pieces, including header files, can help - but such circumstances (on machines with very limited hardware resources, such as memory) are very rare in modern development.</p>

<p>However, humans are less consistent and more error prone than compilers when dealing with source files, so humans benefit from use of header files.  For example, instead of typing (or copying in) needed declarations into every source file that needs them (an activity which people find boring, and tend to make mistakes when doing) simply place the declarations in a header file and <code>#include</code> it when needed.</p>

<p>So then it comes down to when placing declarations in a header file makes life easier for a human, allowing them to avoid making errors, and to focus their effort on the creative parts of software development (implementing new things) rather than the mechanical (copying function declarations into source files that need them).</p>

<p>In practice, it normally works out that a class which will be used within more than one compilation unit (aka source file) is better off being defined in a header file.   A class which is local to a single compilation unit (e.g. to contain implementation details for that compilation unit that do not need to be directly accessed by others) does not need to be in a header file, since it can be defined directly without use of a header.   The problems come in if such ""local"" classes later need to be used in other compilation units - in that case, it is usually advisable to migrate the necessary declarations to a header file, to aid reuse.</p>

<p>Header files also tend to become necessary for authors of libraries - who write a set of functions for use by other programmers, but don't wish to ship the source.   This is a non-technical constraint (i.e. policy based), rather than a technical one.  In that case, they can distribute the header files and the compiled object (or library) files, and keep their source code private.   Of course, technically, they could provide a set of text files with instructions of the form ""copy these declarations to your program when you need to use them"" instead of header files ..... but that would make the library unpopular with developers, since it forces them back into the mundane and error-prone activity of copying text around rather than doing useful development.</p>

<p>Considerations like reducing compile times are also non-technical reasons (a compiler doesn't care how long it takes to build a program, but people do).   Separating class definitions into header (class definition, any inline functions) and separate source (definition of non-inline member functions) does tend to reduce build times, and aid with incremental builds.</p>
",0
40570134,40570118,0,"<p>Usually that's a good separation between class definition (<code>.h</code>) and class implementation (<code>.cpp</code>) People can just read the <code>.h</code> files to know and <strong>use</strong> the class without bothering reading the implementation details.</p>

<p>It's, however, not mandatory to always separate <code>.h</code> and <code>.cpp</code>, you can have the class definition and implementation in a single file (eg., for some simple classes, or some quick prototypes).</p>
",2
40570154,40570118,1,"<p>It's done that way so that you only build the class' code one time.
If you put the class' code in the <code>.h</code> file, then every file that picks up the <code>.h</code> (to access the public functions of the class) will also duplicate the class' code.
The compiler will happily do this for you.
The linker, however, will complain mightily about duplicate lvalues in the namespace.</p>

<p>Along the same lines, yet conversely:  <strong><em>inline functions</em></strong> need to be in the <code>.h</code> so that their code <strong><em>will</em></strong> get picked up in the other code files, which is exactly the intent of inline functions.</p>
",0
40570163,40570118,2,"<p>It is not strictly necessary, as far as the C++ language is concerned. You can put all class methods inline in the <code>.h</code> file.</p>

<p>However, putting the implementations into a separate <code>.cpp</code> offers many benefits, such as:</p>

<ol>
<li><p>C++ is very complex. As the code grows, it will take longer and longer to compile it. Every <code>.cpp</code> file that includes the same header file will end up compiling the same code, over and over again.</p></li>
<li><p>Related to the first point: if any change is made to the class's methods, if all the class methods are in a separate <code>.cpp</code> file, only that <code>.cpp</code> needs recompilation. If all class methods are placed inline into the <code>.h</code> file, every <code>.cpp</code> that includes will must be recompiled.</p></li>
<li><p>Very often, the class's methods will use other classes as part of doing whatever they need to do. So, if they're all placed inline in the <code>.h</code> file, the <code>.h</code> file that defines those other classes will need to be included also, also slowing down the compilation of every <code>.cpp</code> file that includes the header file. If the class methods are in a separate <code>.cpp</code> file, only that <code>.cpp</code> file needs to include the other headers, and most of the time it's only necessary to add some forward declarations to the <code>.h</code>.</p></li>
</ol>
",1
37915967,37915654,1,"<p>You have to keep in mind that there are many different ways to represent numeric variables, especially floating point numbers. The input/output streams have some default options regarding precision and scientific/fixed formatting.</p>

<p>So, in your case, I guess you expected to get the numbers printed in the exact same format that you entered them. Instead, you probably got the first of your two doubles printed as <code>19857</code> and the second as <code>-5.27924e+06</code>. So you thought the numbers were not correctly parsed.</p>

<p>The reason that you got these values is that the default <a href=""http://en.cppreference.com/w/cpp/io/ios_base/precision"" rel=""nofollow"">precision</a> for floating point numbers is set to 6 and the default <a href=""http://en.cppreference.com/w/cpp/io/manip/fixed"" rel=""nofollow"">formatting</a> made your first number be printed in fixed and your second in scientific notation.</p>

<p>To change the default behavior, you can change these two options, e.g. by invoking a <a href=""http://en.cppreference.com/w/cpp/io/manip"" rel=""nofollow"">manipulator</a></p>

<pre><code>cout &lt;&lt; setprecision(3) &lt;&lt; fixed &lt;&lt; e;
cout &lt;&lt; setprecision(10) &lt;&lt; fixed &lt;&lt; f;
</code></pre>

<p>Note that you have to <code>#include &lt;iomanip&gt;</code> for the additional manipulator <code>setprecision</code>. Alternatively you could put <code>cout.precision(3)</code> before printing <code>e</code> and <code>cout.precision(10)</code> before printing <code>f</code>.</p>
",0
38192816,38192669,0,"<p>You can avoid the need for casting by declaring <code>virtual</code> functions on the <code>Shape</code> class for any functions which are applicable to all derived classes. In this case, you want to know what each derived type is so you could have a <code>getType()</code> function. You don't have to do it exactly this way but the following is an example of how you could do it.</p>

<h3>Example Code</h3>

<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

class Shape
{
public:
    virtual ~Shape() {}

    virtual Shape* clone() const = 0;

    virtual std::string getType() const = 0;
};

class Circle : public Shape
{
public:
    virtual Circle* clone() const override { return new Circle(*this); }

    virtual std::string getType() const override { return ""Circle""; }
};

class Rectangle : public Shape
{
public:
    virtual Rectangle* clone() const override { return new Rectangle(*this); }
    virtual std::string getType() const override { return ""Rectangle""; }
};

class Person
{
public:
    explicit Person(const std::string&amp; name, const Shape&amp; shape) :
        mName(name),
        mShape(shape.clone())
    {
    }

    std::string mName;
    std::unique_ptr&lt;Shape&gt; mShape;
};

int main()
{
    std::vector&lt;Person&gt; people;
    people.emplace_back(""Foo"", Circle());
    people.emplace_back(""Bar"", Rectangle());

    for (const auto&amp; person : people)
    {
        std::cout &lt;&lt; person.mName &lt;&lt; "" with "" &lt;&lt; person.mShape-&gt;getType() &lt;&lt; ""\n"";
    }

    return 0;
}
</code></pre>

<h3>Example Output</h3>

<pre><code>Foo with Circle
Bar with Rectangle
</code></pre>

<p><kbd><a href=""http://ideone.com/QMBTVS"" rel=""nofollow"">Live Example</a></kbd></p>
",0
38192755,38192669,0,"<p>If you have an <em>pointer</em> of type <code>Shape</code>, which holds objects of child types such as <code>Rectangle</code> or <code>Circle</code>, then you can use <code>dynamic_cast</code> to check the type of object at runtime. dynamic_cast will allow you to safely check the run-time type of object whose address is held by a pointer. </p>

<p>Please look <a href=""https://en.wikipedia.org/wiki/Run-time_type_information#dynamic_cast"" rel=""nofollow"">https://en.wikipedia.org/wiki/Run-time_type_information#dynamic_cast</a> for an example of how this is done.</p>
",0
38192756,38192669,0,"<p>With the <code>Shape</code> superclass having at least one virtual method you can certainly use <code>dynamic_cast</code>, to figure out which subclass each instance of the superclass is. That's certainly possible, and sometimes it's the right thing to do, but most of the time it's not.</p>

<p>Rather, the right thing to do is to design your classes in advance, in a manner that whatever operations can possibly be done with any <code>Shape</code> there's a <code>Shape</code> method for it, usually virtual. The lowest common denominator is to have a pure virtual method that's implemented by every subclass, which returns an identifier for which particular subclass this is.</p>

<p>But, generally, if you have a need to know what particular subclass an instance of a superclass is, then it's a clue that the class hierarchy is not designed correctly. It is true that life is not 100% perfect, all the time. Sometimes it might become necessary to resort to this kind of ugliness, in order to handle a tricky situation. But that shouldn't be the plan from the beginning. You should try to properly design your class hierarchy so this is not necessary.</p>

<p>Even the lowest common denominator of:</p>

<p>A) The aforementioned function that returns some enumerated identifier for which particular subclass the superclass is, and</p>

<p>B) The superclass defining all possible virtual methods that all superclasses could implement, with the default implementation that throws an exception</p>

<p>would make it possible to do this in a way that does not involve ugly casts.</p>
",2
37403291,37403093,0,"<p>One band-aid fix is to use the <code>nanosleep</code> function instead of <code>sleep</code>. If <code>nanosleep</code> wakes up prematurely, it stores the remaining time into the time structure, so you can re-try. You can wrap this in your own function that resembles <code>sleep</code>.  Since <code>nanosleep</code> isn't ever implemented with <code>SIGALRM</code>, there is no reason why it would wake up prematurely.  Be sure to use <code>sigaction</code> to set up your alarm signal handler, and specify <code>SA_RESTART</code> in the flags, all the same. This allows your signal not to disturb restartable system calls.</p>
",1
40683297,40682853,1,"<p>You need to make data consistnt, ie keep it together in struct, try:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include&lt;iomanip&gt;
using namespace std;

/*void selectionSort(double votes[], string name[], double len)
{

    for (int i = 0; i &lt; len-1; i++)

    {
        double max = (int)i;


        for (int j = i+1; j &lt; len; j++)
        {

            if (votes[j]&gt;votes[(int)max])
            {
                double temp = votes[i];
                votes[i] = votes[j];
                votes[j] = temp;

                string temp2 = name[i];
                name[i] = name[j];
                name[j] = temp2;
            }

        }
    }
}*/

struct candidate{
    string *name;
    double votes;
    double percentage;
};

void insertionSort( candidate candidates[], double len)
{
    for (int i = 0; i &lt; len - 1; i++)
    {
        int j = i + 1;
        candidate tmp = candidates[i];
        while (j &gt; 0 &amp;&amp; tmp.votes &gt; candidates[j-1].votes)
            {
                    candidates[j] = candidates[j - 1];
                    j--;
                    candidates[j] = tmp;
            }
    }

}
int main()
{
    //Declaring variables
candidate candidates[5];
    double total = 0;
    int max = 0;

    //for condition for user to input Canditate names and the votes received
    for (int i = 0; i &lt; 5; i++)
    {
        candidates[i].name = new string;
        cout &lt;&lt; ""Please input the canditate "" &lt;&lt; i + 1 &lt;&lt; "" "" &lt;&lt; ""name: "" &lt;&lt; endl;
        cin &gt;&gt; *(candidates[i].name);
        cout &lt;&lt; ""Please input the canditate "" &lt;&lt; i + 1 &lt;&lt; "" "" &lt;&lt; ""votes: "" &lt;&lt; endl;
        cin &gt;&gt; candidates[i].votes;
        total = total + candidates[i].votes;

    }
    //Q1 or Q2
    //selectionSort(candidates, 5);
    insertionSort(candidates, 5);

    //printing out the Canditate, voters received, and % of total votes
    cout &lt;&lt; ""Candidate"" &lt;&lt; ""\t\t"" &lt;&lt; ""Votes Received"" &lt;&lt; ""\t\t"" &lt;&lt; ""% of Total Votes"" &lt;&lt; endl;
    //for loop in order to find % of total votes, winner of election
    for (int i = 0; i &lt; 5; i++)
    {
        cout &lt;&lt; *(candidates[i].name) &lt;&lt; ""\t\t\t"" &lt;&lt; fixed &lt;&lt; setprecision(0) &lt;&lt; candidates[i].votes &lt;&lt; ""\t\t\t"" &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; (candidates[i].votes * 100 / total) &lt;&lt; endl;

    }
    //printing out the total and winner of the election
    cout &lt;&lt; ""Total"" &lt;&lt; ""\t\t\t"" &lt;&lt; fixed &lt;&lt; setprecision(0) &lt;&lt; total &lt;&lt; endl;
    cout &lt;&lt; ""The winner of the elections is "" &lt;&lt; *(candidates[0].name) &lt;&lt; ""."" &lt;&lt; endl;

    for(int i=0; i&lt;5; ++i)
     delete candidates[i].name;

    cout &lt;&lt; ""Program ended with exit code: 0"" &lt;&lt; endl;

    return 0;

}
</code></pre>
",2
43721793,43714200,0,"<p>This would be my approach:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {

    ifstream readFromFile(""test.txt"");
    vector&lt;string&gt; fileWords;

    string word;

    while (readFromFile &gt;&gt; word) {

        try {
            int number = stoi(word); // here is your number
            cout &lt;&lt; number &lt;&lt; endl;
        } catch (const invalid_argument&amp; exception) {
            cout &lt;&lt; exception.what() &lt;&lt; endl; // just for debug
        }

        fileWords.emplace_back(word);
    }

    for (const auto&amp; word: fileWords) {
        cout &lt;&lt; word &lt;&lt; ' ';
    }

    readFromFile.close();
}
</code></pre>

<p>It reads word by word, saves it on an array and it also checks if a word is an integer (using the std::stoi function).</p>
",1
37115844,37115503,4,"<p>You refer to <code>A</code>'s member function <code>foo</code>. This function is not known to exist yet, because you only forward declare <code>A</code>.</p>

<p>In other words, you'll have to declare <code>A&lt;T&gt;::foo</code> before <code>C</code>, as the GCC message tries to tell you (the other two are rather cryptic). This means you have to declare the complete interface of <code>A</code> before <code>C</code>, instead of only forward declaring it.</p>
",1
37115963,37115503,2,"<h2>Solution</h2>

<p>You can declare <code>f</code> as a friend of <code>C</code> in the following way:</p>

<pre><code>class C;

template &lt;class T&gt; struct A {
  void f(C const &amp;c);
};

class C {
  int i = 42;
public:
  static void foo();
  template &lt;class T&gt; friend void A&lt;T&gt;::f(C const &amp;c);
};

template &lt;class T&gt; void A&lt;T&gt;::f(C const &amp;c) { std::cout &lt;&lt; c.i &lt;&lt; std::endl; }
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/89da7e41aa2f9f71"" rel=""nofollow""><strong>Live Demo</strong></a></p>

<h2>Justification</h2>

<p>According to the standard <em>¡ì3.3.2/p6 Point of declaration [basic.scope.pdecl]</em>:</p>

<blockquote>
  <p>After the point of declaration of a class member, the member name can
  be looked up in the scope of its class. [ Note: this is true even if
  the class is an incomplete class. For example,</p>

<pre><code>struct X {
enum E { z = 16 };
int b[X::z]; // OK
};
</code></pre>
  
  <p>¡ª end note ]</p>
</blockquote>

<p>The diagnostic is rather misleading both for GCC and CLANG. The real problem with your code is not the fact that you're trying to access the definition of an incomplete type, but rather is that you can only refer to a class member name only after it has been declared.</p>
",3
37116466,37115503,0,"<p>Firstly, Forward declaration of a class is not sufficient if you need to use the actual class type, for example, if you need to use it as a base class, or if you need to use the methods of the class in a method.</p>

<p>Since here you try to use its details ""foo()"", there is no way compiler knows what is A::foo().. Compiler cannot distinguish if it is a typo (or) actual function.. it needs to know the declaration of A::foo() before you can use it. </p>

<p>If you still want to only to forward declare the class and make it a friend, see if friend classes fit your situation</p>

<pre><code>template &lt;class T&gt; struct A;

class C{
   template &lt;class T&gt; friend struct A;
};
</code></pre>
",0
37116610,37115503,1,"<p>The first problem is (I think) from <em>&sect;9.3/7 [class.mfct]</em> and probably some other places in the standard (see clang message below and 101010's answer):</p>

<blockquote>
  <p>Previously declared member functions may be mentioned in friend declarations.</p>
</blockquote>

<p>This problem is similar to the one from <a href=""https://stackoverflow.com/questions/36821049/member-function-of-incomplete-class-as-friend-formally-valid/36821822"">this question</a>.</p>

<p>Since you did not declare <code>A&lt;T&gt;::f</code> before <code>C</code>, you cannot declare it has a friend of <code>C</code>.</p>

<p>But <strong>there is an hidden problem behing clang's message</strong>, if you make <code>A</code> a non-templated class, the message is different:</p>

<blockquote>
  <p>Incomplete type <code>A</code> in nested name specifier.</p>
</blockquote>

<p>Which is closer to gcc message than the actual one, this is because clang's warning is about something else. Per <strong>&sect;14.5.4/5 [temp.friend]</strong>, the standard allows member of class template to be friend, so this must be valid:</p>

<pre><code>template &lt;typename T&gt;
struct A {
    void f ();
};

class C {
    template &lt;typename T&gt;
    friend void A&lt;T&gt;::f(); // Ok, A&lt;T&gt;::f is already declared

    void private_member (); // See below
};
</code></pre>

<p>But clang still complains:</p>

<blockquote>
  <p>warning: dependent nested name specifier 'A::' for friend class declaration 
  is not supported; turning off access control for 'C' [-Wunsupported-friend]</p>
</blockquote>

<p>clang does not support such <code>friend</code> declaration, so it simply <strong>turns off</strong> access control for <code>C</code>, meaning that:</p>

<pre><code>C c;
c.private_member();
</code></pre>

<p>Will be ""valid"" everywhere, which may not be what you want.</p>
",0
43200068,43199623,0,"<p>It seems that you have not initialized variable and directly using it:</p>

<pre><code>int i;
if (fullName[i] == ' ')        //checks if an element is equal to a space
</code></pre>
",0
37451342,37450999,0,"<p>Your inner loop is where you need to make changes. I'll break it down into separate function to help you understand better. You are iterating between the required range in the outer loop. Now you want to find out if the number in the current iteration is a prime number. Let's bring a function called <code>isPrime</code>  which checks if the number is prime.</p>

<pre><code>bool isPrime(int x)
{
    bool flag = 1;
    for (int i=2;i&lt;x;i++)
    {
        if (x%i == 0)
        {
            flag = 0;
            break;
        }
    }
    return flag;
}
</code></pre>

<p>This function checks if the number is prime. After adding this, your main function should look like this.</p>

<pre><code>int main()
{

    int n1,n2,i;
    cout&lt;&lt;""Enter the first number""&lt;&lt;endl;
    cin&gt;&gt;n1;
    cout&lt;&lt;""Enter the second number""&lt;&lt;endl;
    cin&gt;&gt;n2;
    int n3=(n1+1);
    for(i=n3; i&lt;n2;i++)
    {
        if (isPrime(i))
        {
            cout &lt;&lt;i;
        }
    }
}
</code></pre>

<p>Let me know if you have any questions about this.</p>
",1
37451303,37450999,0,"<p>Your code has a number of inconsistencies that will lead to bugs. Also, think about what makes a number prime (if it is divisible by ONLY 1 and itself). </p>

<p>To help you out </p>

<p>1) for a number n between n1 and n2 </p>

<p>2) check if n is divisible by any number between 2 to n-1 (unless the number is 2 then output 2)</p>

<p>3) if n is divisible by some other number between 2 to n-1 then it is not prime and it should not be listed. If it is not then output that number</p>

<p>This may minor optimizations you can run to not have to check every number's factors (such as if the number n is divisible by 2 and n != 2 then throw that number out)</p>

<p>ex) for the number 5 I would check if 5 is divisible by 2,3,4. if none of those are true then 5 is a prime number</p>
",0
34961075,34960946,0,"<p>There is an issue is in the function.</p>

<pre><code>void pop(LIST* pop_element)
</code></pre>

<p>The value being popped works find, but it doesn't modify the sent in parameter.</p>

<p>So the line</p>

<pre><code> pop(start_stack);
</code></pre>

<p>Removes the memory start_stack, but doesn't change the pointer start_stack.
Creating a reference would fix this issue.</p>

<p>i.e.</p>

<pre><code>void pop(LIST* &amp; pop_element)
{
    LIST *temp;
    temp=pop_element;
    pop_element=pop_element-&gt;next;
    delete temp;
}
</code></pre>

<h2>How to find these errors</h2>

<p>My debug environment used MSVC and a debug heap.  When the same memory was freed a second time, it broke in the debugger and was relatively easy to figure this problem.  For linux you could use valgrind, non MS compilers on windows Application Verifier would find this issue.</p>

<p>If you use a debugger single step through the code.  Look at the values of the variables, and check they are as you expect.</p>

<p>In this case (without a debug heap, I could have seen that the pointer <code>start_stack</code> was not changing value.</p>

<p>The code provided is an implementation of a list, a stack and using these together for the required infix to postfix conversion.</p>

<p>Try unit testing the list behavior separately from the larger problem.
Try unit testing the stack behavior separately from the larger problem.  The stack overflow requires the smallest verifiable code sample (<a href=""https://stackoverflow.com/help/mcve"">SO : MCVE</a>).  This is to encourage you to deconstruct your problem to find the smallest piece of code which doesn't work.  This should also help to focus you on how to fix it.</p>

<p>When you are implementing stacks and queues, try comparing against the std::stack and std::queue behavior, again helping you to identify the unit which is failing.</p>

<p>Finally for stack overflow, a program which eats stdin is difficult for people to see what is going on.  Ensure you specify what input is required to cause the behavior, or provide a program which takes input from itself....</p>

<pre><code> void Old()
 {  
     int myVar;
     cin &gt; myVar;
 }
 int main()
 {
      Old();
 }
</code></pre>

<p>should be </p>

<pre><code> void Old( std::istream &amp; stm )
 {  
     int myVar;
     stm &gt; myVar;
 }
 int main()
 {
      std::stringstream s( ""123"" ); // test value causes issue.
      Old(s );
 }
</code></pre>
",0
37037881,37037630,0,"<p>Your <code>outputVLI</code> function is <a href=""https://stackoverflow.com/a/1410632/22099"">declared, but not defined</a>. So, you should add the definition:</p>

<pre><code>void outputVLI(int vli[], int size) {
    // TODO: implementation here
}
</code></pre>

<p>Also, your <code>compVLI</code> functions needs to return a value...</p>
",2
37402962,37402593,1,"<p>You are taking char type input, and comparing it to int values. Try comparing to the char equivalent of the int values you use (i.e. '1' instead of 1). Also, your last if excludes the possibility of 8, which is weird in my opinion.</p>

<p>It would give something like this :</p>

<pre><code>if (x == '0')
    std::cout &lt;&lt; 0 &lt;&lt; y &lt;&lt; ""/100"";
if (y == '0')
        std::cout &lt;&lt; x &lt;&lt; ""/10"";

    if (y == '1' || y == '2' || y == '3' || y == '4' || y == '5' || y == '6' || y == '7' || y == '8' || y == '9')
        std::cout &lt;&lt; x &lt;&lt; y &lt;&lt; ""/100"";
</code></pre>
",0
37403301,37402593,0,"<p>In addition to Bettorun's answer, you also would need to do the same to your variables:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
        char n = '0';//for decimal point
        char x = '0';//for tenths place
        char y = '0';//for hundredths place

        cout &lt;&lt; ""Please enter the decimal to the hundredths place here: "";
        cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;

        if (x == '0')
            cout &lt;&lt; '0' &lt;&lt; y &lt;&lt; ""/100"" &lt;&lt; endl;

        if (y == '0')
            cout &lt;&lt; x &lt;&lt; ""/10"" &lt;&lt; endl;

        else if (y == '1' || y == '2' || y == '3' || y == '4' || y == '5' || y == '6' || y == '7' || y == '9')
        cout &lt;&lt; x &lt;&lt; y &lt;&lt; ""/100"" &lt;&lt; endl;

        return 0;
}
</code></pre>
",0
35298927,32637139,2,"<pre><code>#include&lt;bits/stdc++.h&gt;
void encode(int num_rails,char plain_text[],char cipher_text[])
{
    int i=0,j=0,k=0;
    for(i=1;i&lt;=num_rails;i++)
    {
        if(i==1||i==num_rails)
        {
            for(j=i-1;j&lt;strlen(plain_text);j+=2*(num_rails-1))
            {
                cipher_text[k++]=plain_text[j];             
            }                           
        }
        else
        {
            cipher_text[k++]=plain_text[i-1];
            for(j=i-1;j&lt;strlen(plain_text);)
            {
                int x=0;
                x++;
                if(x%2==1)
                {
                    j=j+2*(num_rails-i);
                }
                else
                {
                    j=j+2*(i-1);                        
                }
                cipher_text[k++]=plain_text[j];
            }       
        }
    }
    cipher_text[10]='\0';
}
void decode(int num_rails,char cipher_text[],char decrypt_text[],int length)
{
    int i=0,j=0,k=0;
    int y=strlen(cipher_text);
    //printf(""%d\n"",y);
    for(i=1;i&lt;=num_rails;i++)
    {
        if(i==1||i==num_rails)
        {

            for(j=i-1;j&lt;length;j+=2*(num_rails-1))
            {
                decrypt_text[j]=cipher_text[k++];   
                //printf(""%d\n"",j);         
            }
        }                           
        else
        {   
            decrypt_text[i-1]=cipher_text[k++];
            for(j=i-1;j&lt;length;)
            {
                int x=0;
                x++;
                if(x%2==1)
                {
                    j=j+2*(num_rails-i);
                }
                else
                {
                    j=j+2*(i-1);                        
                }
                decrypt_text[j]=cipher_text[k++];
            }   
        }
    }   
}
int main()
{
    char plain_text[100],cipher_text[100],decrypt_text[100];
    printf(""ENTER PLAIN TEXT\n"");
    scanf(""%s"",plain_text);
    int num_rails,i;
    printf(""ENTER NO OF RAILS\n"");
    scanf(""%d"",&amp;num_rails);
    int x=strlen(plain_text);
    encode(num_rails,plain_text,cipher_text);
    printf(""CIPHER TEXT IS:"");
    for(i=0;i&lt;=x;i++)
    printf(""%c"",cipher_text[i]);
    printf(""\n"");
    printf(""DECRYPTED TEXT IS:"");
    decode(num_rails,cipher_text,decrypt_text,x);
    for(i=0;i&lt;=x;i++)
    printf(""%c"",decrypt_text[i]);
}
</code></pre>
",0
43727033,43727005,7,"<p>This:</p>

<pre><code>  const char ch[5] = {'h','e','l','l','o'};
</code></pre>

<p>is not null-terminated. This:</p>

<pre><code>  const char ch[6] = {'h','e','l','l','o', 0 };
</code></pre>

<p>would be. What you are seeing is undefined behaviour.</p>
",8
37073383,37072352,0,"<pre><code>#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
using namespace std;

string Day[7] = {""Sun"",""Mon"", ""Tue"", ""Wed"", ""Thu"", ""Fri"", ""Sat""};

// define struct Date to collect information for Date
struct  Date {
    int day;                // variable to collect day
    int month;              // variable to collect month
    int year;               // variable to collect year
    int weekday;            // variable to store weekday value
    string event;           // string to hold events
    int last;

};
struct Event{
    int day;
    int month;
    int year;
    int weekday;
    string event;
};
vector&lt;Event&gt; myhappening;
vector&lt;string&gt; data;

void inputDate(Date &amp;);     // prototype of inputDate function
void checkYear(Date &amp;);     // prototype of checkYear function
void checkMonth(Date &amp;);    // prototype of checkMonth function
void checkDay(Date &amp;);      // prototype of checkDay function
void checkLast(Date &amp;);     // prototype of checkLast function
void increment(Date &amp;);     // prototype of increment function
void setWeekDay(Date &amp;);    // prototype of setWeekDay function
void setEvent(Date &amp;,Event []);      // prototype of setEvent function
void outputDate(Date &amp;);    // prototype of outputDate function
void setFirstWeekDay(Date &amp;); // set weekday to the first day of the week
void decrement(Date &amp;date); // Prototype of decrement function
void readFile(vector&lt;string&gt; &amp;);


// main function
int main()
{
    Date time;                          // intialiaze our struct
    inputDate(time);                    // Ask from user to input a date
    Event  MyHappenings[] =
    {
        { -1, 0, 0, 0, ""Payday"" },
        { 1, 3, 0, 0, ""Birthday Party"" },
        { 0, 0, 0, 5, ""Darts evening"" },
        {13, 0, 0, 5, ""Friday the 13th"" },
        //  {2,3,0,0,""Hooooraaa another event""}, // You can add other events too here,"" no limits ""
    };                                    // Initialize the events,
    setWeekDay(time);
    setFirstWeekDay(time);
    for (int i = 0; i &lt; 7; i++)
    {
        setWeekDay(time);               // Calculate the weekday of a date
        checkLast(time);                // check that if a date is the last date of the month or not
        setEvent(time,MyHappenings);    // compare the date and events, and set events related to that date
        outputDate(time);               // print date with weekdays and events
        increment(time);                // increment a date by one day
    }
    readFile(data);
       }// end of main function

//  inputDate function to get date from user and store it in Date struct
void inputDate(Date &amp;date)
{

    cout&lt;&lt;"" Enter Your Date (Year starts from 1754) and Follow this format by space DD MM YYYY :""&lt;&lt;endl;
    cin&gt;&gt;date.day&gt;&gt;date.month&gt;&gt;date.year;
    checkYear(date);
    checkMonth(date);
    checkDay(date);
    cout&lt;&lt; "" Your Given Date is : ""&lt;&lt;date.day&lt;&lt;"" ""&lt;&lt;date.month&lt;&lt;"" ""&lt;&lt;date.year&lt;&lt;endl;
}// end function inputDate

// checkYear Function to check year value to be correct and ask user for correct value if it is uncorrect
void checkYear(Date &amp;date)
{
    while (date.year&lt;1754 or date.year&gt;9999) {
        cout&lt;&lt; "" You pick wrong Year!(It should be between 1754 and 9999)Please Enter new Year Value : "";
        cin&gt;&gt;date.year;
    }
}// End checkYear function

// checkMonth Function to check month value to be correct and ask user for correct value if it is uncorrect
void checkMonth(Date &amp;date)
{
    while (date.month&gt;12 or date.month&lt;1) {
        cout&lt;&lt; "" You pick wrong Month!(You should pick months between 1-12) Please Enter new Month Value : "";
        cin&gt;&gt;date.month;
    }
}//End function checkMonth

//checkDay Function to check day value to be correct and ask user for correct value if it is uncorrect
void checkDay(Date &amp;date)
{
    switch (date.month) {
        case 1: case 3: case 5: case 7: case 8: case 10: case 12 :
            while (date.day&gt;31 or date.day&lt;1) {
                cout&lt;&lt; "" You pick wrong Day!(It should be in 1- 31 range) Please Enter new Day Value : "";
                cin&gt;&gt;date.day;
            }
            break;
        case 4: case 6: case 9: case 11:
            while (date.day&gt;30 or date.day&lt;1) {
                cout&lt;&lt; "" You pick wrong Day!(It should be in 1- 30 range) Please Enter new Day Value : "";
                cin&gt;&gt;date.day;
            }
            break;
        case 2 :
            if ((date.year % 4 ==0 and date.year%100 !=0) or date.year%400==0  ){
                if (date.day&gt;29 or date.day&lt;1) {
                    cout&lt;&lt; "" You pick wrong Day!(It should be in 1- 29 range) Please Enter new Day Value : "";
                    cin&gt;&gt;date.day;
                }
            }else{
                while (date.day&gt;28 or date.day&lt;1) {
                    cout&lt;&lt; "" You pick wrong Day!(It should be in 1- 28 range) Please Enter new Day Value : "";
                    cin&gt;&gt;date.day;
                }
            }
            break;

        default:
            cout&lt;&lt;"" The program should not get into this code""&lt;&lt;endl;
            break;
    }
}// End checkDay function

// checkLast funtion to find if a date is last day of the month or not
void checkLast(Date &amp;date)
{
    date.last = 0;
    switch (date.month) {
        case 1: case 3: case 5: case 7: case 8: case 10: case 12 :
            if (date.day ==31)
                date.last=-1;
            break;
        case 4: case 6: case 9: case 11:
            if (date.day ==30)
                date.last=-1;
            break;
        case 2 :
            if ((date.year % 4 ==0 and date.year%100 !=0) or date.year%400==0  ){
                if (date.day ==29)
                    date.last=-1;
            }else{
                if (date.day ==28)
                    date.last=-1;
            }
            break;

        default:
            cout&lt;&lt;"" The program should not get into this code""&lt;&lt;endl;
            break;
    }
}// End checkLast function

// increment Function to calculate increment days respect to the user input
void increment(Date &amp;date)
{
    date.day= date.day + 1;
    switch (date.month) {
        case 1: case 3: case 5: case 7: case 8: case 10:
            if (date.day &gt; 31)
            {
                date.month++;
                date.day= date.day- 31;
            }
            break;

        case 4: case 6: case 9: case 11:
            if (date.day &gt; 30)
            {
                date.month++;
                date.day= date.day- 30;
            }
            break;

        case 2:
            if ((date.year % 4 ==0 and date.year%100 !=0) or date.year%400==0  ){
                if (date.day &gt; 29){
                    date.month++;
                    date.day = date.day - 29;
                }
            }else {
                if (date.day &gt; 28){
                    date.month++;
                    date.day = date.day - 28;
                }
            }
            break;

        case 12 :
            if (date.day &gt; 31)
            {
                date.month = date.month - 11;;
                date.year++;
                date.day = date.day - 31;
            }
            break;

        default:
            cout&lt;&lt;""Program should not get into this error in increment Function!!!""&lt;&lt;endl;
            break;
    }
} // end increment Function

//setWeekDay function to calculate weekday
void setWeekDay(Date &amp;date){
    // find the algorithm here ""https://en.wikipedia.org/wiki/Determination_of_the_day_of_the_week""
    int a = (14-date.month)/12;
    int y = date.year-a;
    int m = date.month+12*a-2;
    date.weekday = (date.day + y + y/4 - y/100 + y/400 +(31 * m/12)) % 7;
}// end setWeekDay function

//setEvent function to set events related to their related events
void setEvent(Date &amp;date,Event event[]){
    date.event = ""-"";
    string a;
    for(int i=0 ; i&lt;sizeof(event); i++){
        if((date.day==event[i].day or event[i].day == 0 or event[i].day == date.last) and (date.month==event[i].month or event[i].month == 0) and (date.year==event[i].year or event[i].year == 0) and (date.weekday==event[i].weekday or event[i].weekday == 0)){
            if(a.empty()){
                date.event = event[i].event;
                a = date.event;
                continue;
            }else{
                date.event = event[i].event+"",""+ a;
                a = date.event;
                continue;
            }
        }
    }
} // end of setEvent function

// outputDate function which use increment function to increment a date and also set event related to input date
void outputDate(Date &amp;date)
{
    cout&lt;&lt;setfill('0');
    cout&lt;&lt;setw(2)&lt;&lt;date.day&lt;&lt;"".""&lt;&lt;setw(2)&lt;&lt;date.month&lt;&lt;"".""&lt;&lt;setw(4)&lt;&lt;date.year&lt;&lt;""      ""&lt;&lt;""[ ""&lt;&lt;Day[date.weekday]&lt;&lt;"" ]""&lt;&lt;""     ""&lt;&lt;date.event&lt;&lt;endl;
} // end of outputDate function

//setFirstWeekDay Function to find first day of the week related to given date
void setFirstWeekDay(Date &amp;date){
    switch (date.weekday) {
        case 0:
            for (int i = 1; i&lt;7; i++)
                decrement(date);

            //date.day = date.day - 6;
            break;
        case 2:
            decrement(date);
            break;
        case 3:
            for (int i = 1; i&lt;3; i++)
                decrement(date);
            break;
        case 4:
            for (int i = 1; i&lt;4; i++)
                decrement(date);
            break;
        case 5:
            for (int i = 1; i&lt;5; i++)
                decrement(date);
            break;
        case 6:
            for (int i = 1; i&lt;6; i++)
                decrement(date);
            break;

        default:
            break;
    }
}// end setFirstWeekDay Function
// Decrement Function to decrement days by one day
void decrement(Date &amp;date)
{
    date.day= date.day - 1;
    switch (date.month) {
        case 12: case 5: case 7: case 8: case 10:
            if (date.day == 0)
            {
                date.month--;
                date.day= 30;
            }
            break;

        case 2: case 4: case 6: case 9: case 11:
            if (date.day == 0 )
            {
                date.month--;
                date.day= 31;
            }
            break;

        case 3:
            if ((date.year % 4 ==0 and date.year%100 !=0) or date.year%400==0  ){
                if (date.day == 0){
                    date.month--;
                    date.day = 29;
                }
            }else {
                if (date.day == 0 ){
                    date.month--;
                    date.day = 28;
                }
            }
            break;

        case 1 :
            if (date.day == 0 )
            {
                date.month = date.month + 11;;
                date.year--;
                date.day = 31;
            }
            break;

        default:
            cout&lt;&lt;""Program should not get into this error in increment Function!!!""&lt;&lt;endl;
            break;
    }
} // end decrement Function
void readFile(vector&lt;string&gt; &amp;data){
    string line;
    ifstream readFile(""events.dat"", ios::in);
    if (!readFile) {
        cerr&lt;&lt;""File COuld not be opened""&lt;&lt;endl;
        exit(EXIT_FAILURE);
    }
    while (readFile &amp;&amp; !readFile.eof()) {
        getline(readFile,line);
       //if (line.length() == 0 or line[0] == '#' )
        data.push_back(line);
    }
    for(int i=0; i &lt; data.size(); i++){
        cout&lt;&lt;data[i];
    }

}
</code></pre>

<p>this is how i have done till now,after that i want put data to event vector myhappening. Before that u would see i use normal event struct to initialize an array, but now i want to use file processing.</p>
",0
37073088,37072352,0,"<p>You could do it with <code>std::istringstream</code> and <code>std::getline</code>, it has a third parameter which is a <code>char</code> at which it should stop consuming characters and return string. Other aproach is to use regexps, below is a way how you can parse it with regexps,I have tested it with only one string but it should give you a start how to do it.</p>

<p><a href=""http://coliru.stacked-crooked.com/a/d3aed577b2f72bd7"" rel=""nofollow"">http://coliru.stacked-crooked.com/a/d3aed577b2f72bd7</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;regex&gt;

struct Event{
    int day;
    int month;
    int year;
    int weekday;
    std::string event;
};

int main()
{
    std::regex pattern(""([0-9\\$\\*]+)\\.([0-9\\$\\*]+)\\.([0-9\\$\\*]+):(\\w+):([\\w ]+)"" );
    std::string line = ""13.*.*:Fri:Friday the 13th"";
    std::smatch sm;
    Event evt;
    if (std::regex_match(line, sm, pattern)) {
        std::string val1 = sm[1];
        if (val1 == ""*"")
            evt.day = -1; // wildcard
        else if (val1 == ""$"")
            evt.day = -2; // last
        else 
            evt.day = std::stoi(val1);

        val1 = sm[2];
        if (val1 == ""*"")
            evt.month = -1; // wildcard
        else if (val1 == ""$"")
            evt.month = -2; // last
        else 
            evt.month = std::stoi(val1);

        val1 = sm[3];
        if (val1 == ""*"")
            evt.year = -1; // wildcard
        else if (val1 == ""$"")
            evt.year = -2; // last
        else 
            evt.year = std::stoi(val1);


        std::string weekDay = sm[4];
        std::vector&lt;std::string&gt; weekdays = {""Mon"", ""Tue"", ""Wen"", ""Thr"", ""Fri"", ""Sat"", ""Sun""};
        auto it = std::find(weekdays.begin(), weekdays.end(), weekDay);
        evt.weekday = std::distance(weekdays.begin(), it);

        evt.event = sm[5];

        std::cout &lt;&lt; evt.day &lt;&lt; "", "" &lt;&lt; evt.month &lt;&lt; "", "" &lt;&lt; evt.year &lt;&lt; "", "" &lt;&lt; evt.weekday &lt;&lt; "", "" &lt;&lt; evt.event &lt;&lt; ""\n"";      
    }
}
</code></pre>

<p>on output :</p>

<pre><code> 13, -1, -1, 4, Friday the 13th
</code></pre>
",0
37073693,37072352,0,"<p>The difficulty is that your event structure uses <code>int</code>, and your format accepts special chars.  If you can accept that <code>*</code> to be translated into 0 and the <code>$</code> into -1, you could use the following function:  </p>

<pre><code>Event string_to_event (string s) {
    static vector&lt;string&gt; wd{""*"",""Sun"",""Mon"",""Tue"",""Wed"",""Thu"",""Fri"",""Sat""};
    stringstream sst(s); 
    Event e; 

    string sday,smonth,syear,sweekday; 
    getline(getline (getline (getline(getline(sst,sday,'.'), smonth,'.'), syear,':'), sweekday, ':'), e.event); 

    e.day = sday.compare(""*"")==0 ? 0: (sday.compare(""$"")==0 ? -1 : stoi(sday)); 
    e.month = smonth.compare(""*"")==0 ? 0: (smonth.compare(""$"")==0 ? -1 : stoi(smonth)); 
    e.year = syear.compare(""*"")==0 ? 0: (syear.compare(""$"")==0 ? -1 : stoi(syear)); 

    e.weekday = find(wd.begin(), wd.end(), sweekday)-wd.begin(); 

    return e; 
}
</code></pre>

<p>As you see it makes extensive use of <a href=""http://www.cplusplus.com/reference/sstream/stringstream/"" rel=""nofollow""><code>stringstreams</code></a> and <a href=""http://www.cplusplus.com/reference/string/string/getline/"" rel=""nofollow""><code>getline()</code></a>.  </p>

<p>If you can get rid of your intermediary data vector, you coud rewrite <code>readLine()</code> as follows: </p>

<pre><code>void readFile(vector&lt;Event&gt; &amp;data){
    string line;
    ifstream readFile(""events.dat"", ios::in);
    if (!readFile) {
        cerr&lt;&lt;""File COuld not be opened""&lt;&lt;endl;
        exit(EXIT_FAILURE);
    }
    while (getline(readFile,line)) {
        if (line.length() != 0 &amp;&amp; line[0] != '#' &amp;&amp; line[0] != '/') {
            data.push_back(string_to_event(line));
        }
    }
}
</code></pre>

<p>If you need to keep your intermediate structure, you should correct your original reading function, by looping on <code>getline()</code> and not on <code>eof()</code> and use <code>continue</code> instead of <code>break</code>. </p>

<p>You could then use <code>tranform()</code> to apply the converstion function on the vector of strings: </p>

<pre><code>vector&lt;string&gt; vs; 
vector&lt;Event&gt; evt; 
readFile(vs); 
transform (vs.begin(), vs.end(), back_inserter(evt), string_to_event ); 
copy (evt.begin(), evt.end(), ostream_iterator&lt;Event&gt;(cout,""\n""));
</code></pre>
",0
37457815,37457690,1,"<p><code>B</code>'s constructor takes object of type <code>A</code> by value -> creates new object (copy)</p>

<pre><code>B(...,A a) ...
       ^^^^ pass by value
</code></pre>

<p>Passing by reference won't create a new object (copy).</p>

<pre><code>B(...,A &amp;a)...
       ^^^^^ pass by reference -&gt; no copy
</code></pre>

<p>Also, this means that you <strong>can't</strong> store it in <code>B</code> as object <code>A a</code>, because that would, again, create new object (copy), you'll have to store it as reference.</p>

<p>This could cause some problems:</p>

<pre><code>B* createNewObject()
{
   A a(...); //local object is created
   B* ptr = new B(...,a); // reference in B now refers to local object
}// However, here is local object destroyed, so reference in B is now invalid (dangling reference)

int main()
{
   B *pb = createNewObject();
   //Any operation on B working with that invalid reference causes UNDEFINED BEHAVIOUR
}
</code></pre>

<p>Additionaly, bear in mind that any change in <code>a</code> will also change object you passed (because that reference refers to same object you passed).</p>
",0
37457868,37457690,2,"<p>Taking <code>A</code> by value in <code>B::B(int machin, A a)</code> is the main issue, do <code>B::B(int machin, A&amp; a)</code> or <code>B::B(int machin, const A&amp; a)</code>.
The same applies to the assignment to the field within the constructor body. The field declaration in class <code>B</code> should hence be <code>A&amp; a;</code> or <code>const A&amp; a;</code>, respectively.</p>

<p>However, you probably also want to delete the assignment operator: <code>A&amp; operator=( const A&amp; ) = delete;</code></p>

<p>Take a look at boost <a href=""http://www.boost.org/doc/libs/master/libs/core/doc/html/core/noncopyable.html"" rel=""nofollow"">non-copyable</a>.</p>

<p>Its implementation also depends on whether C++11 is available: <a href=""http://www.boost.org/doc/libs/1_60_0/boost/core/noncopyable.hpp"" rel=""nofollow"">http://www.boost.org/doc/libs/1_60_0/boost/core/noncopyable.hpp</a></p>
",4
46047534,46045421,1,"<p>In your case, since you define a typedef in the <code>Object</code> class, you can simply do this:</p>

<pre><code>template &lt;typename T&gt;
class Observable&lt;T, typename std::enable_if&lt;std::is_base_of&lt;Object&lt;typename T::T&gt;, T&gt;::value&gt;::type&gt;
</code></pre>

<p>If you were not using that typedef, you could do that:</p>

<pre><code>// returning a pointer protect us from abstract types.
template&lt;typename T&gt;
T* get_object_type(const Object&lt;T&gt;&amp;);

template&lt;typename T&gt;
using object_type_t = typename std::remove_pointer&lt;
    decltype(get_object_type(std::declval&lt;const T&amp;&gt;()))
&gt;::type;
</code></pre>

<p>And then, use the type trait:</p>

<pre><code>template &lt;typename T&gt;
class Observable&lt;T, typename std::enable_if&lt;std::is_base_of&lt;object_type_t&lt;T&gt;, T&gt;::value&gt;::type&gt;
</code></pre>

<p>Note that sfinae will occur first on <code>object_type_t</code>. If the function <code>get_object_type</code> is not callable using a <code>const T&amp;</code>, that specialization of <code>Observable</code> will be ruled out. If <code>T</code> don't extends <code>Object&lt;T&gt;</code>, but the function <code>get_object_type</code> is still callable, then your condition with <code>is_base_of</code> will rule out the specialization of <code>Observable</code>.</p>
",1
39661644,39661522,11,"<p>Your constructor has a <em>side effect</em> - namely the <code>cout</code> call. So the compiler <em>cannot</em> optimise out the copy taken in <code>obj = obj.f();</code>.</p>

<p>But the C++ standard <em>does</em> allow it to optimise out the deep copy taken in</p>

<pre><code>myclass myclass::f(){
    myclass temp;
    return temp;
};
</code></pre>

<p><em>despite</em> there being a side effect. That allowable strategy is called <em>Named Return Value Optimisation</em>.</p>

<p>Sadly your book is really rather outdated, or factually incorrect from the outset! You could use it for kindling when lighting those cosy fires this coming winter.</p>
",3
39666161,39661522,0,"<pre><code>#include &lt;iostream&gt;
using namespace std;
class myclass {
public:
 myclass();
myclass(const myclass &amp;o);
myclass f();
};
myclass:: myclass(){
cout&lt;&lt;""Constructing normally""&lt;&lt;endl;
};
myclass:: myclass(const myclass &amp;o){
cout&lt;&lt;""Constructing copy""&lt;&lt;endl;
};
myclass myclass::f(){
myclass *temp;
return *temp;
};
int main(){
myclass obj;
obj = obj.f();
 return 0;
}
</code></pre>
",1
43224710,43224657,3,"<p>A few problems:</p>

<ul>
<li><p>The first argument to <a href=""http://en.cppreference.com/w/c/memory/realloc"" rel=""nofollow noreferrer""><code>realloc</code></a> is the <em>original</em> pointer (or <code>NULL</code>).</p></li>
<li><p>Your <code>ProcessBit</code> doesn't really emulate pass-by-reference correctly.</p></li>
<li><p>You can use a negative index.</p></li>
<li><p><code>mas</code> is a pointer to a pointer to <code>int</code>, but you use it as a pointer to <code>int</code>.</p></li>
</ul>

<p>A ""fixed"" version <em>might</em> look something like this:</p>

<pre><code>void ProcessBit(int num, int *ind, int **mas)
{
    int *temp = realloc(*mas, (*ind + 1) * sizeof(int));
    if (temp == NULL)
    {
        // TODO: Handle error
        // TODO: return or exit(EXIT_FAILURE)
    }

    *mas = temp;

    (*mas)[*ind] = 0;  // Initial initialization

    if (num &gt; 0)
    {
        (*mas)[num - 1]++;
    }

    ++*ind;  // Increase the size
}
</code></pre>

<hr>

<p>Now, if this really was C++ (as you tagged your question) then you should be using <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow noreferrer""><code>std::vector</code></a> instead, which would solve almost all your problems with much simpler code.</p>
",0
43225030,43224657,0,"<p>The parameters are wrong. Since you are trying to realloc a NULL pointer it should behave like malloc; however, the header declared in cstdlib is</p>

<pre><code>void* realloc( void* ptr, std::size_t new_size );
</code></pre>

<p>The formal parameter <code>mas</code> is already the <strong>address</strong> of the pointer, so the call should be</p>

<pre><code>*mas=(int*)realloc(*mas,((*ind))*sizeof(int));
(*mas)[num-1]++;
</code></pre>

<p>Since realloc handles and returns pointers <strong>by copy</strong>, not by reference.</p>

<p>You are passing the address of the memory location where the address of a memory location (NULL) is stored to your <code>ProcessBit</code> function, and then the address of that location to the <code>realloc</code> function. The function tries to reallocate memory where the variable <code>mac</code> is stored, on the stack. No wonder it's an invalid pointer.</p>

<p>By passing <code>&amp;mac</code> you are simply taking a step in the wrong direction while dereferencing pointers.</p>
",0
40756022,40755411,0,"<p>if you really want to do it in your way, you have to declare a new array of characters and then count the element of the characters that you want to be left on the array by iterating on the array through your pointer, that count will be the size of the new array.</p>

<p>example:</p>

<pre><code>char b[] = ""acbbca"";
char* p = &amp;b[0];
int oldsize = 6;
int newsize = 0;
for ( int a = 0; a &lt; oldsize; a++ )
{
    if(*p!='b')
        newsize++; // increment the newsize when encountered non-b char
    p++;
}
</code></pre>

<p>in the snippet above, you count the number of non-b characters, so it will be the size of the new array.</p>

<pre><code>p = &amp;b[0]; // point again to the first element of the array.
char newone[size]; declare the new array that will hold the result
int ctr = 0;
for ( int a = 0; a &lt; oldsize; a++ )
{
    if(*p!='b')
    {
        newone[ctr] = *p; //store non-b characters
        ctr++;
    }
    p++;
}
</code></pre>

<p>in the snippet above, it stores all non-b characters to the new array.</p>

<p>another way is to use std::string.</p>

<pre><code>std::string b = ""aabbcc"";
b.erase(std::remove(b.begin(),b.end(),'b'),b.end());
</code></pre>
",1
40756932,40755411,0,"<p>Since arrays cannot be resized, there really is no such thing as ""removing elements"".  To actually remove elements, you would need to use a container such as <code>std::string</code> where elements can actually be removed.</p>

<p>Given this, let's assume you can only use an array, and that ""removal"" means to move the removed values to the end of the array, and then point to where the removed elements start.  The STL algorithm function <a href=""http://en.cppreference.com/w/cpp/algorithm/remove"" rel=""nofollow noreferrer"">std::remove</a> can be used to accomplish this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;

int main()
{
    char letters[] = ""aabbccbccd"";

    // this will point to the first character of the sequence that is to be
    // removed.
    char *ptrStart = std::remove(std::begin(letters), std::end(letters), 'b');

    *ptrStart = '\0';  // null terminate this position
    std::cout &lt;&lt; ""The characters after erasing are: "" &lt;&lt; letters;
}
</code></pre>

<p>Output:</p>

<pre><code>The characters after erasing are: aaccccd
</code></pre>

<p><a href=""http://ideone.com/65ULMm"" rel=""nofollow noreferrer"">Live Example</a></p>

<p>The <code>std::remove</code> just takes the character you want to remove and places it at the end of the array.  The return value of <code>std::remove</code> is the point in the array
where the removed elements were placed.  Basically the return value points to where the discarded elements start (even though the elements aren't actually discarded).</p>

<p>So if you now write a function to do this, it would probably look like this:</p>

<pre><code>void erase_element(char *ptr, char erasechar)
{
   char *ptrStart = std::remove(ptr, ptr + strlen(ptr), erasechar);
   *ptrStart = '\0';  // null terminate this position
}
</code></pre>

<p><a href=""http://ideone.com/M6ZBJK"" rel=""nofollow noreferrer"">Live Example 2</a></p>

<p>We pass a pointer to the first element, and use the <code>strlen()</code> function to determine how long the string is (the function assumes the string is null-terminated). </p>
",0
38405634,38405544,1,"<p>Your loop will never <code>break</code> unless you explicitly enter <code>110</code> which is the 'n' char in <a href=""http://www.asciitable.com/"" rel=""nofollow""><strong>ASCII Codes</strong></a> or 78 which is the 'N'. So change your <code>cont</code> declaration from <code>int cont;</code> to <code>char cont;</code> and then you won't get the infinite loop anymore, and its condition will be valid to <em>possibly</em> <code>break</code> by then unless you have another hidden logical error which will require you to debug it. </p>
",3
37396515,37396278,19,"<p>With c++11, using the standard <a href=""http://en.cppreference.com/w/cpp/numeric/random"">random library of c++11</a>, you can do this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;random&gt;

int main()
{
  /* Seed */
  std::random_device rd;

  /* Random number generator */
  std::default_random_engine generator(rd());

  /* Distribution on which to apply the generator */
  std::uniform_int_distribution&lt;long long unsigned&gt; distribution(0,0xFFFFFFFFFFFFFFFF);

  for (int i = 0; i &lt; 10; i++) {
      std::cout &lt;&lt; distribution(generator) &lt;&lt; std::endl;
  }

  return 0;
}
</code></pre>

<p><a href=""https://ideone.com/O0BtPY""><kbd><strong>Live Demo</strong></kbd></a></p>
",3
37396357,37396278,-2,"<p>If your <code>rand()</code> function only gives numbers in the range <code>[0, 2^15)</code>, then you can concatenate 5 numbers returned by <code>rand()</code> to get a number in the range <code>[0, 2^64)</code>.</p>

<p>Of course, there are other possible solutions (which may be even better). The <code>rand()</code> function in C++ library is usually a <a href=""https://en.wikipedia.org/wiki/Linear_congruential_generator"" rel=""nofollow"">linear congruential generator</a>. You may simply implement your own generator, using the same mathematical principles.</p>

<p>For example, the following code generates 64 bit random numbers:</p>

<pre><code>unsigned long long rand64()
{
    static unsigned long long seed;
    seed = seed * 6364136223846793005 + 1442695040888963407;
    return seed;
}
</code></pre>

<p>The parameters <code>6364136223846793005</code> and <code>1442695040888963407</code> are those used by Donald Knuth.</p>

<p>The advantages and disadvantages of this method is discussed in the above wiki page. If high quality randomness is not needed, it could be a good choice.</p>
",7
37397139,37396278,6,"<p>As a uniformly random number in the range <code>[0, 2^64)</code> is just 64 random bits, you can just use the return values of <code>std::mt19937_64</code> directly:</p>

<pre><code>#include &lt;random&gt;

int main () {
    std::mt19937_64 gen (std::random_device{}());

    std::uint64_t randomNumber = gen();
}
</code></pre>

<p>Note that seeding a Mersenne Twister engine with a single 32 bit seed is not optimal, for a better way, have a look at <a href=""https://codereview.stackexchange.com/questions/109260/seed-stdmt19937-from-stdrandom-device"">this</a>.</p>

<p>Also note that the use of <code>rand</code> is generally discouraged these days. <a href=""https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful"" rel=""nofollow"">Here</a> is a talk by Stephan T. Lavavej on that topic.</p>
",0
37397482,37396278,1,"<p>I would also consider using the OS facilities instead. All modern systems have cryptographic modules capable of generating very good random byte arrays of arbitrary length. Linux has <a href=""http://man7.org/linux/man-pages/man2/getrandom.2.html"" rel=""nofollow""><code>getrandom()</code></a>. Windows has <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa379942(v=vs.85).aspx"" rel=""nofollow""><code>CryptGenRandom</code></a>. OpenBSD has <a href=""http://man.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man3/arc4random.3?query=arc4random%26sec=3"" rel=""nofollow""><code>arc4random</code></a>. iOS has <a href=""https://developer.apple.com/library/ios/documentation/Security/Reference/RandomizationReference/index.html#//apple_ref/c/func/SecRandomCopyBytes"" rel=""nofollow""><code>SecRandomCopyBytes</code></a>. etc. etc.</p>
",0
37152502,37151787,1,"<p>There's actually nothing wrong with your code except this line</p>

<pre><code>string endL = ""\n\r"";
</code></pre>

<p>Which should really only be</p>

<pre><code>string endL = ""\n"";
</code></pre>

<p><code>\n</code> is automatically converted to the line endings used by the system, which traditionally is <code>\n (0x0a)</code> on unix systems and <code>\r\n (0x0d0a)</code> on Windows. </p>

<p>But, how did this affect the program so much? Well it only takes affect after the phonebook is written at the end of the program so that <code>phonebook.txt</code> contains these bogus line endings that have <code>\r\n\r</code> at the end (on Windows). So when the file is read, it reads up until the new line <code>\r\n</code> and sees <code>\rPerson Name</code> as line after! Which explains why searching was failing. </p>

<p>You also may see some additional bogus contacts generated because there may be some extra <code>\r</code>s at the end which read as a single line each. Without looking at your <code>phonebook.txt</code> I can't say for certain why you have an additional 4 though I'd guess extra <code>\r</code>s would be the cause. </p>

<p>All in all, use <code>\n</code> for new lines. </p>

<p>To answer the title, <code>vector::size()</code> is THE way to get the number of stored objects in a vector. It's not lying to you. </p>
",0
37152239,37151787,0,"<p>Using the range based for loop ensures that you won't hit any nonexistent contacts:</p>

<pre><code>for(auto&amp;&amp; contact: contacts)
{
    // Contact contact is now accessible.
}
</code></pre>

<p>Also, it is probably not a good idea to store <code>a</code> as a global variable. What happens if you execute <code>search</code> twice?</p>
",2
47547425,47547048,0,"<p>If you want to use the local date format you can try <a href=""http://en.cppreference.com/w/cpp/io/manip/get_time"" rel=""nofollow noreferrer""><code>std::get_time</code></a> (available since C++11) or the C function <a href=""http://en.cppreference.com/w/c/chrono/strftime"" rel=""nofollow noreferrer""><code>strftime</code></a> with <code>""x""</code> as format.</p>

<blockquote>
  <p>|   x |   parses the locale's standard date representation |  all |
  -- cppreference.com</p>
</blockquote>

<p>Both return calendar time <code>struct tm</code> that you can convert it to timestamp using either <code>localtime</code> or <code>gmtime</code> if you want.</p>

<p>Note that you have to set the C and C++ locale of your application before, in order to be able to use your OS regional settings and not the classic C locale. See <code>locale</code> and <code>std::locale</code>. And it's good to set both so that they are in sync and not get bad surprises. </p>

<pre><code>setlocale(LC_ALL, """");
std::locale::global(std::locale(setlocale(LC_ALL, NULL)));
</code></pre>
",2
40776811,40776786,6,"<p>Your input file most likely has lines ending with <code>CR LF</code>, i.e. Windows/DOS text files. Linux expects all lines ending with <code>LF</code> only, so on Linux, <code>std::getline()</code> ends up reading a line containing a single <code>CR</code> character.</p>

<p>Before the existing code that checks the contents of <code>nextLine</code>, check if the line is non-empty, and ends with the <code>CR</code> character, then remove it. Then continue on with your existing <code>if</code> statement.</p>
",0
38304609,38304552,3,"<p>ptr[1] is actually the integer next to the variable pointed to by ptr. Writing to such memory means overwriting about anything. You may overwrite other variables. Or return addresses. Or stack frames. Or about anything else. Heck, you may overwrite ptr itself, depending on how variables on the stack are arranged.</p>

<p>Undefined behavior. Compilers are allowed to assume it doesn't happen.</p>
",0
38304627,38304552,1,"<p>Let see what you are doing here (Lets assume <code>int</code> is 4 bytes):</p>

<pre><code>int x = 56;
int *ptr = &amp;x;
ptr[1]=8;
cout &lt;&lt; *ptr &lt;&lt; endl;
</code></pre>

<pre>
&lt;- 4 bytes->......(rest of the stack)
 ----------------
|   x     |      |
 ----------------
^         ^
ptr[0]   ptr[1]
</pre>

<p>So, <code>pre[1]</code> is writing to a memory location which does not yet exist. So, you are writing data <code>out-of-bound</code>.</p>
",1
38304673,38304552,1,"<p>Presumably you were expecting <code>ptr[1]</code> to mean the second <em>byte</em> in <code>x</code>. But that's not how pointer arithmetic works. The pointer is an <code>int*</code>, so arithmetic is performed in ""chunks"" of <code>int</code>-sizes. Therefore, <code>ptr[1]</code> is the non-existent integer ""next to"" <code>x</code>.</p>

<p>You could probably see this working by making <code>ptr</code> a <code>char*</code> instead, but be careful because this is real hackery and probably not a good idea unless you <em>really</em> know what you're doing.</p>

<p>A further misconception is your indication that the number of decimal digits in the human-readable representation of <code>x</code>'s value has anything to do with the number of bytes taking up by <code>x</code> in memory; it doesn't.</p>
",3
37290144,37290081,0,"<p>Write a helper function that traverses the nodes of the linked list and prints them in reverse order.</p>

<pre><code>void  reverse_nodes(Node* node) {
   if ( node != NULL )
   {
      reverse_nodes(node-&gt;next);
      cout &lt;&lt; node-&gt;value &lt;&lt; endl;
   }
}
</code></pre>

<p>and call it from the function that is called with the list.</p>

<pre><code>void  reverse(List* list) {
   reverse_nodes(list-&gt;first);
}
</code></pre>
",2
37244448,37244419,0,"<p>If you would like to skip empty lines in your file, at the end or in the middle, you could add a check to the body of the loop to skip them:</p>

<pre><code>while(getline(fin,line)) {
    if (line.empty()) {
        continue;
    }
    // the rest of your code goes ehre
}
</code></pre>
",0
37244485,37244419,1,"<p><code>std::string::empty</code> (<a href=""http://www.cplusplus.com/reference/string/string/empty/"" rel=""nofollow"">reference</a>) can be used to check if a <code>std::string</code> is empty.</p>

<p>So, check to see if <code>line</code> is empty, if it isn't, run your code, otherwise, do nothing.</p>

<p>Example:</p>

<pre><code>while (getline(fin, line))
{
    if (!line.empty())
    {
        // Your logic here...
    }
}
</code></pre>
",0
39131346,39131302,3,"<p>This line does not do what you expect it to do:</p>

<pre><code>cin &gt;&gt; number1, number2, number3;
</code></pre>

<p>You probably wanted to read 3 numbers from <code>cin</code>, this is done the following way:</p>

<pre><code>cin &gt;&gt; number1 &gt;&gt; number2 &gt;&gt; number3;
</code></pre>

<p>In the current form it's evaluated as </p>

<pre><code>(cin &gt;&gt; number1), number2, number3;
</code></pre>

<p>The result of this expression is <code>number3</code>, which is not initialized in your program. <code>number2</code> is part of the expression, also not initialized, so compiler warns about it too, though the value is discarded.</p>
",0
39131353,39131302,1,"<p>The comma operator separates expressions in C++ and joins them into a bigger expression, so the statement <code>cin &gt;&gt; number1, number2, number3</code> <strike>would read the expression <code>number1, number2, number3</code> from <code>cin</code></strike> is equivalent to <code>(cin &gt;&gt; number1), number2, number3</code> which does not make much sense, and is certainly not what you intended to do. </p>

<p>Try <code>cin &gt;&gt; number1 &gt;&gt; number2 &gt;&gt; number3</code> instead.</p>

<p>This is one of those weird ""features"" of C++ that the language would have been much better off without.</p>
",16
39131396,39131302,0,"<p>As mentioned, this should work:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
    // ...
    cin &gt;&gt; number1 &gt;&gt; number2 &gt;&gt; number3; // here is the fix

    // ...
    cout &lt;&lt; ""The average is"" &lt;&lt; average &lt;&lt; endl; // same as you did here

    return 0;
}
</code></pre>
",1
39673924,39673531,2,"<p>Firstly, heap and stack are not C++ concepts.   They refer to particular types of memory, as managed on some systems.</p>

<p>Second, what is often described as ""heap"" is, in C++, referred to as ""dynamically allocated memory"".</p>

<p>When dynamically allocated memory is released by the program (e.g. using operator <code>delete</code> on something obtained using operator <code>new</code>, using <code>free()</code> on a pointer returned by C's <code>malloc()</code>) that memory no longer exists as far as your program is concerned, but the pointer value does not change.  Using a pointer or reference to something that no longer exists gives, in the language of the C++ standard, undefined behaviour.</p>

<p>Practically, the memory might exist physically on your system, or even still be allocated by the host system to your program.   However, once it has been released by your program, there is nothing preventing the memory being reused.   Your program might use operator <code>new</code> to allocate more memory, so the memory that was previously released is now being used for something else - completey unrelated to the original usage - by your program.   That is inherently dangerous - the results can be anything (which is, loosely, the implication of undefined behaviour in the C++ standard).</p>

<p>The operating system might also have recovered the logical or physical memory (after all, your program has indicated no more use for that memory) and allocated it to another program.   That is dangerous for both your program and the other program that has been allocated memory.  Which is why most modern operating systems prevent that e.g. by forcably terminating your program if the operating system detects an access to memory it no longer owns.</p>

<p>A real danger is that you might access a released object for a while, and everything seems to work as required.   Only to crash later on.  There can often be a significant time interval between some memory being released by your program, and being reused for something else.</p>

<p>Such flaws in programs tend to infuriate users of that program (users, for some obscure reason, tend to be less than appreciative when programs crash in unpredictable and unrepeatable ways in the middle of their work).  Such flaws in your code also tend to be very difficult to track down, and therefore hard to correct.</p>
",0
39674219,39673531,1,"<blockquote>
  <p>I have problem with <strong>""an object has been returned back to the memory heap""</strong> part. Does <strong>returned back</strong> means that the object has been freed? If not, why it is a disaster to have a pointer/reference to that object?</p>
</blockquote>

<p>It might help to break down the terminology and clarify a few things:</p>

<p>Firstly, the term <em>Object</em> in C++ refers to <strong><em>something</strong> residing in memory</em>, but does not refer to the memory itself.</p>

<p>It's worth making a distinction between an object and the memory storing the object because the actions of allocating memory and initialising an object are distinct and separate.</p>

<p>The following line is doing two things:</p>

<pre><code>new int(123);
</code></pre>

<ul>
<li><p>It is allocating an area of memory on the heap to your program whose size in bytes is equal to <code>sizeof(int)</code>.   The effect of the allocation of memory is not to create an object, nor is it even to change anything about the content of that memory;  it is simply to ringfence that memory for your program to use.<br>
Any ""junk"" or garbage values which might have been pre-existing in that memory will not be changed.</p></li>
<li><p>After the memory is allocated, that chunk of memory is initialised with an <code>int</code> object containing <code>123</code>.  Objects may only be initialised within an area of memory which is already allocated to your program. </p></li>
</ul>

<p>Given that the <code>new</code> operator is doing two different things, it follows that the <code>delete</code> operator may also perform two different actions:</p>

<ul>
<li><p><code>delete</code> will destroy the object; this is usually limited to releasing resources owned by the object.   Destroying an object typically does not bother to change or reset any memory which is about to be deallocated because that's usually a waste of CPU cycles.<br>
After an object is destroyed, you might find the remains or partial remains of that object stuck around in memory for a while, but as far as your program is concerned, the object itself is dead/gone and the memory contents are junk.</p></li>
<li><p><code>delete</code> will de-allocate the memory.   The process of de-allocation is not to change the content of that memory, it is simply to release that memory for use by something else.   Trying to access that area of memory after it has been deallocated is undefined behaviour.</p></li>
</ul>

<hr>

<p>Remember that a pointer cannot ever point-to an <strong>object</strong> because an object is <em>""The thing in memory""</em> rather than the memory itself;  raw pointers in C++ are fairly simple/dumb - they don't track anything about the state of the objects in their pointed-to memory.  If an object is moved or copied or destroyed, the pointer will know nothing about it. </p>

<p>A <strong>pointer</strong> is an <strong>address</strong> for a location in memory.</p>

<p>It helps to think of <em>pointer-values</em> (addresses) and <em>pointer-variables</em> which contain those values/addresses.  Sadly the term <em>pointer</em> has historically had a bit of a double-meaning, to refer both to the pointer-value and the pointer-address, which can seem confusing.   </p>

<p>Typically the memory location pointed-by a pointer-variable <em>should</em> contain a valid object within an allocated area of memory, but it also might not.    </p>

<p>C++ does not protect you against dangling pointers, where a <em>dangling pointer</em> is a pointer-variable containing an address of an area of memory which has not been allocated to your program.    </p>

<p>Neither does C++ protect you against pointers-to un-initialised memory (e.g. if you have allocated memory using <code>malloc</code> but not initialised its contents).</p>

<p>Lastly, C++ does not protect you against memory leaks; you as the programmer are responsible for keeping track of all your allocated memory.</p>

<p>These last 3 points are among some of the many reasons why <code>new</code>/<code>delete</code> tend not to be used very often in modern C++, and why <code>&amp;</code> references, <code>std::vector</code>, <code>std::shared_ptr</code> and other alternatives are preferred; they take care of many nuances and gotchas surrounding new/delete.</p>
",0
45746310,45746192,1,"<p>Not sure if it makes a difference for data type <code>int</code> whether you view the replacement of it's value as ""put whatever is in x into y"" or as ""morphing"". Anyway, this <a href=""https://timsong-cpp.github.io/cppwp/n3337/expr.ass#2"" rel=""nofollow noreferrer"">online c++ standard draft concerning assignment operator</a> describes the process as follows:</p>

<blockquote>
  <p>5.17 (2) In simple assignment (=), the value of the expression replaces that of the object referred to by the left operand.</p>
</blockquote>

<p>Not sure if this answers your question, but taking this formulation one could say that ""the value of the object is replaced, but the object remains the same"". </p>
",1
37352184,37351842,0,"<p>--EDITED--</p>

<p>here's my suggestion with STACK based on my previous suggestion using vector</p>

<pre><code>findMaxValueOutOfNDigits(stackInput, M, N)
{
  // stackInput = [2, 9, 3, 6, 5, 8, 8, 8, 8, 7, 2, 2, 8, 1, 4]
  // *where 4 was the first element to be inserted and 2 was the last to be inserted
  // if the sequence is inverted, you can quickly fix it by doing a ""for x = 0; x &lt; stack.length; x++ { newStack.push(stack.pop()) }""

  currentMaxValue = 0

  for i = 0; i &lt; (M - N + 1); i++
  {
    tempValue = process(stackInput, M, N)
    stackInput.pop()
    if (tempValue &gt; currentMaxValue)
      currentMaxValue = tempValue
  }

  return currentMaxValue
}

process(stackInput, M, N)
{
  tempValue = stackInput.pop() * 10^(N - 1)
  *howManyItemsCanILook = (M - N + 1)

  for y = (N - 2); y == 0; y++
  {
    currentHowManyItemsCanILook = *howManyItemsCanILook

    tempValue = tempValue + getValue(stackInput, *howManyItemsCanILook) * 10^(y)

    *howManyItemsCanILook = *howManyItemsCanILook - 1

    for x = 0; x &lt; (currentHowManyItemsCanILook - *howManyItemsCanILook); x++
    {
      stackInput.pop()
    }
  }

  return tempValue
}

getValue(stackInput, *howManyItemsCanILook)
{
  currentMaxValue = stackInput.pop()
  if (currentMaxValue == 9)
    return 9
  else
  {
    goUntil = *howManyItemsCanILook

    for i = 0; i &lt; goUntil; i++
    {
      *howManyItemsCanILook = *howManyItemsCanILook - 1
      tempValue = stackInput.pop()
      if (currentMaxValue &lt; tempValue)
      {
        currentMaxValue = tempValue
           if (currentMaxValue == 9)
                return currentMaxValue
      }
    }
    return currentMaxValue
  }

}
</code></pre>

<p>note: where *howManyItemsCanILook is passed by reference</p>

<p>I hope this helps</p>
",10
37843502,37843412,1,"<p>You are returning objects by value, not by reference. That means, you get a <strong>copy</strong> of author but you're not modifying the one stored in Book class.</p>

<p>You should modify the signature in </p>

<pre><code>Author&amp; Book::getAuthor();
</code></pre>

<p>to make your changes to the object <strong>author</strong> effective</p>
",0
37843516,37843412,2,"<blockquote>
  <p>I want to modify the mail from the Author from the test program, but <code>cppbook.getAuthor().setEmail(""..."")</code> doesn't work.</p>
</blockquote>

<p><code>Author getAuthor();</code> should be <code>Author&amp; getAuthor();</code> if you want to change the internal object associated to <code>Book</code>.</p>

<p>Otherwise you're just changing a temporary copy of that <code>Author</code> instance.</p>
",0
37350887,37350770,1,"<p>You forgot to <strong>declare</strong> <code>Cat::Meow</code> in the class declaration.</p>

<pre><code>//some code
void PrintInformation();
void Meow();
</code></pre>

<p>Additionally, you have to specify what the return type of the function <code>Meow</code> is, in your case it would be <code>void</code>, because it returns nothing.</p>

<p>You also have some recursion going on, <code>Meow</code> calling <code>Meow</code> (forgetting about the fact that <code>fluffy</code> isn't a variable in this scope). Your <code>Cat</code> class knows nothing about the instance <code>fluffy</code>, so you can't access it.</p>

<p>I guess you meant <code>voice</code> instead.</p>
",0
38198755,38198670,0,"<p>You can do:</p>

<pre><code>std::unordered_map&lt;int, std::vector&lt;Type&gt;*&gt; mymap;
</code></pre>

<p>or better:</p>

<pre><code>std::unordered_map&lt;int, std::unique_ptr&lt;std::vector&lt;Type&gt;&gt;&gt; mymap;
</code></pre>

<p>Access it like:</p>

<pre><code>auto vptr = mymap[10];
</code></pre>
",2
38290008,38289992,2,"<p><code>myclass obj;</code> will already be deleted automatically after each iteration of the loop.</p>

<blockquote>
  <p>How can I free that memory?</p>
</blockquote>

<p>You don't need to.</p>
",0
38290014,38289992,8,"<p>You don't have to delete them explicitly, because as you have created them <code>myclass obj;</code> they are created on stack and deleted after each iteration.</p>

<p>When the program reaches the first curly brace after the instantiation on stack of an object it deletes it, in your case:</p>

<pre><code>myclass obj;
obj.do_function();
} // Here the obj is deleted
</code></pre>

<p><a href=""https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap"">Here</a> are some examples and explanations of how stack is working, versus heap, to let you understand better when you need to free memory yourself, and when you don't.</p>

<p>Note: I have used notions of <em>stack</em> and <em>heap</em> only to suggest how objects are handled relatively to their lifetime like when an object from stack should be freed after it leaves the scope, and an object of heap lives until it's explicitly freed. As mentioned in comments, these notions are not considered in standard C++ because the programs can run in an environment which does not support these type of memory. Although the compiler respects these rules for a C++ program.</p>
",2
38291527,38289992,2,"<p>Short answer is that you don't need to.</p>

<p>Here's a quick example:</p>

<pre><code>class myClass {
    public:
        myClass() { cout &lt;&lt; ""Hello!"" &lt;&lt; endl; }
        ~myClass() { cout &lt;&lt; ""Goodbye!"" &lt;&lt; endl; }
        void do_function() { cout &lt;&lt; ""Something"" &lt;&lt; endl; }
};

int main() {
    for (int i=0; i&lt;3; ++i) {
        myClass obj;
        obj.do_function();
    }
}
</code></pre>

<p>Output:</p>

<pre><code>Hello!
Something
Goodbye!
Hello!
Something
Goodbye!
Hello!
Something
Goodbye!
</code></pre>

<p>You are allocating <em>obj</em> on the stack. Whenever your program goes out of scope, the memory automatically gets released from the stack.</p>

<p>You create a scope for every iteration of a for loop. Or the inner curly brace:</p>

<pre><code>for (int i=0; i&lt;3; ++i) { &lt;-- Right there
</code></pre>

<p>And obj goes out of scope:</p>

<pre><code>    obj.do_function();
} &lt;-- Right here
</code></pre>
",0
38412612,38289992,1,"<p>If you don't create an object dynamically, the object is created on stack and it is deleted when the closing bracket, that defines its scope, is seen. You can have your own opening and closing brackets to restrict the scope of a variable. This would be helpful to just free memory from unnecessary variables. For example </p>

<pre><code>for(...)
{
    //do something
    {
        myclass obj;
        /// use obj here
    }//obj is deleted from stack
    //do something which doesnt require myclass obj
}
</code></pre>
",0
40955178,40926649,0,"<p>I haven't yet looked into std::map so I can comment on that but yeah Starl1ght is right, incorrect code I really didn't understand obj/classes  this worked in case another beginner needs a super simple example program:</p>

<pre><code>int main()
{
std::vector&lt;newclass&gt; vnewclass;
int x(1);
int z(0);
int c;
while(x == 1)
{
    std::cout &lt;&lt; z &lt;&lt; std::endl;
    newclass objs;
    objs.printhi();
    objs.enterdata();
    objs.printdata();
    vnewclass.push_back(objs);
    std::cout &lt;&lt; ""add obj ?"" &lt;&lt; std::endl;
    std::cin &gt;&gt; x;
    z++;
}
std::cout &lt;&lt; ""what obj would you like to view ?"" &lt;&lt; std::endl;
std::cin &gt;&gt; c;
vnewclass[c].printdata();
return 0;
}
</code></pre>
",0
37637782,37636441,1,"<p><code>find</code> and <code>find2</code> are unrelated until you make them related.</p>

<p>Change the <code>bruger</code> function to pass the <code>Regner</code> object as argument, rather than creating a local copy:</p>

<pre><code>void bruger(Regner one)
{
    z = one.x;
    w = one.y;
}
</code></pre>

<p>Then, call it in <code>main</code> as:</p>

<pre><code>find2.bruger(find);
</code></pre>
",0
37904574,37904097,0,"<p>It's a bit of a wonky solution but it dose work. Because of the way multidimensional indexing works the value in <code>B[i]</code> will be equal to the value in <code>A[0][i]</code>.</p>

<p>In your case you want something like this in your <code>sortingdiagonally2Darray</code> function.</p>

<pre><code>for (int i = 0; i &gt; r * c; i++) {
     A[0][i] = B[i];
}
</code></pre>

<p>This works because under the hood arrays are just pointers. <code>B[x]</code> is syntactic sugar for <code>*(B + x)</code> and <code>A[0][x]</code> will equate to <code>*(*(A + 0) + x)</code> because it's a pointer to a pointer (hence the double star/double brackets).</p>
",0
46942728,46942636,1,"<p>You can't declare an array with a size unknown at compile time like this:</p>

<pre><code>int output[size];
</code></pre>

<p>You need to declare it dynamically like this:</p>

<pre><code>int* output = new int[size];
</code></pre>

<p>Note that you are now responsible for cleaning up the memory you have allocated here and will need to delete it when you're finished with it:</p>

<pre><code>delete[] output;
</code></pre>

<p>Or better yet use a standard c++ container like std::vector</p>
",2
37639579,37639509,1,"<p>The line:</p>

<pre><code>if(word[i]==word[i+1]){
</code></pre>

<p>Needs to be:</p>

<pre><code>if(word[y]==word[y+1]){
</code></pre>

<p>In fact, nearly all references to  <code>i</code> need to be to the appropriate loop variable.</p>

<p>In addition, most of the literal <code>5</code>s need to be <code>4</code>s instead.  (You want to iterate through the values 0, 1, 2, and 3.  You do not want to access <code>word[4]</code> (it doesn't exist).</p>

<p>Finally, the line:</p>

<pre><code>for(int y=0;y&lt;5;y++){
</code></pre>

<p>should be:</p>

<pre><code>for(int y=0;y&lt;3;y++){
</code></pre>

<p>because you are going to access <code>word[y+1]</code></p>
",4
37639553,37639509,0,"<p>You don't need to loop till the end of the array. you need to go till the place before the last one.   </p>

<p>And also you need to change the <strong>i</strong> in the index to the loops.</p>

<pre><code>  char word[4];
    int i;
     cout&lt;&lt;""Enter Word:"";
     for(i=0;i&lt;5;i++) 
       cin&gt;&gt;word[i];



for(int y=0;y&lt;4;y++){
if(word[y]==word[y+1]){
for(int k=y;k&lt;4;k++){
    word[k]=word[k+1];
}   
for(int g=0;g&lt;5;g++)
  cout&lt;&lt;word[g];
}
}
</code></pre>
",2
37626928,37626892,0,"<p>Try to compile with support for C++11 (or later).<br>
Up to C++11 in a nested class / struct you can use only type names, static members, and enumerators from the enclosing class.  </p>

<p>See <a href=""http://en.cppreference.com/w/cpp/language/nested_types"" rel=""nofollow"">here</a> </p>
",0
37626936,37626892,0,"<p>The <code>previousComp</code> structure have no <code>master</code> member. You need an instance of the object(s) where <code>master</code> is a member variable to access it.</p>

<p>This can be done by having a reference to the class that <code>previousComp</code> is nested in, and using it. Like</p>

<pre><code>struct previousComp
{
    ContainingClass const&amp; object_;

    previousComp(ContainingClass const&amp; object)
        : object_(object)
    {}

    bool operator()(...)
    {
        // Use object_.master here
    }
};
</code></pre>

<p>Pass <code>*this</code> to the constructor when creating the (temporary) instance of the structure.</p>
",0
41925803,41925531,0,"<p>Just to answer your question: the following line should do the job:</p>

<pre><code>if(first.find(temp) != std::string::npos)
</code></pre>
",0
41659685,41659654,6,"<p>Preprocessing simply generates the text that gets compiled. Your suggestion leads to the same body of source code, so it will have no effect on optimization.</p>

<p>Including all the headers, all the time (call it a ""super-header"") may lead to slow compilation.</p>

<p>However, <em>precompiled headers</em> are a popular solution to allow such super-headers to work quickly. You might check your IDE or compiler's documentation to learn its precompiled header facility.</p>

<p>In any case, typically the super-header is still named with <code>.h</code>; since it implements nothing a <code>.cpp</code> name would not be appropriate.</p>
",0
41660337,41659654,0,"<p>You can, but you may want to reconsider.</p>

<p>You may have trouble with accidentally trying to compile Loader.cpp by itself since you've named it as if it was a source file. Since you're using it as a header - and it is a concatenation of multiple headers - it would make sense to name it according to the convention and use .h file name extension.</p>

<blockquote>
  <p>Would it be optimizable</p>
</blockquote>

<p>It would have zero effect on the compiled program, so in that sense optimization is irrelevant.</p>

<p>This will bring problems with compilation speed however. And those problems are not ""optimizable"". Copying every header into the source file - needed or not - slow the time (and the slowdown is bound to the hard drive speed) needed to compile the source file. Much bigger problem is that it prevents incremental building because a change in any header file would force the source file to be recompiled, because its content will have changed.</p>

<p>These problems are compounded over multiple source files assuming you intend to use this ""technique"" with all source files that you have. Having to recompile the entire project when any header is modified is usually non acceptable for any project that is not trivially small.</p>
",0
41660438,41659654,0,"<p>It really depends on the compiler.
Visual studio has a thing called <code>stdafx.h</code>.</p>

<p><a href=""https://stackoverflow.com/questions/4726155/whats-the-use-for-stdafx-h-in-visual-studio"">What&#39;s the use for &quot;stdafx.h&quot; in Visual Studio?</a></p>
",0
37641306,37641264,5,"<p>You don't <code>cin &gt;&gt;</code> something to <code>endl</code>. That doesn't make sense ¨C <code>endl</code> is a construct to give things like <code>cout</code> the instruction to do whatever is right to end a line on your specific  platform, not something you can save input to.</p>
",6
40985246,40984348,0,"<p>I dont have permission to comment, hence adding it here.
In you main(), 
        get_selection(menu_choice);
            switch (menu_choice)
You return menu_choice, but there is none to take the value, you end you using garbage value as it is uninitialized.
So two ways you can do it, either by passing the address/reference of menu_choice or by return value. try either of these it should work, though I have not gone through the rest of your program.
As suggested by others, try a debugger e.g. gdb?</p>
",3
40988034,40987583,0,"<p>As I don't have enough points to comment, so answering it here.</p>

<pre><code> /* 1 */     d= Fraction x.n * cs231::Fraction z{3};
</code></pre>

<p>What are you trying to do here with x?
For an example, do you think below will work?</p>

<pre><code>d = int x * int y;
</code></pre>

<p>try compiling it.</p>
",1
37701851,37701747,2,"<p>First, you should <strong>always format your code</strong> (kind of did it for you now). Second, indexing in C and C++ starts from <code>0</code>, so the maximum allowable index is <code>D-1</code>, where <code>D</code> is the dimension. This is in contrast with e.g. MATLAB, where indexing starts from <code>1</code>. You have out of bounds access in your code, e.g. <code>Mat[1][3]=2.5;</code>, as <code>Mat</code> is declared as <code>double Mat[2][3];</code>, so the maximum row/column indexes are <code>1</code> and <code>2</code>, respectively. Same for the <code>q</code> when you display it, <code>q[1]</code> should be <code>q[0]</code> and <code>q[2]</code> should be <code>q[1]</code>. Your code will cause undefined behaviour. Compiling the code with all warnings turned on, i.e. <code>-Wall -Wextra</code> on gcc will most likely catch those kind of mistakes. Also, make sure your <code>for</code> loops don't go out of bounds as well. </p>

<p>As a side note, you can also directly initialize your matrix as:</p>

<pre><code>double Mat[2][3] = { {a,b,c}, {d,e,f} }; // where a, b etc are the coefficients
</code></pre>
",0
37702796,37701747,2,"<p>I would highly recommend you read through this page. It gives a more in-depth analysis on solving linear equations with Gaussian elimination <a href=""https://martin-thoma.com/solving-linear-equations-with-gaussian-elimination/"" rel=""nofollow"">https://martin-thoma.com/solving-linear-equations-with-gaussian-elimination/</a></p>

<p>The main problem with your code is out-of-bounds access to your matrix. The index of an array's element starts at <code>0</code> which means that by having an <code>array[3]</code> your accessible elements are of index <code>0</code>, <code>1</code> and <code>2</code>.</p>

<p>I have hence fixed that in this edit of your code:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{

const int Nx = 2;
const int Ny = 3;
double Mat[Nx][Ny];
double q[2];

Mat[0][0] = 2.0;
Mat[0][1] = 3.0;
Mat[0][2] = 2.5;
Mat[1][0] = 1.3;
Mat[1][1] = 3.0;
Mat[1][2] = 2.5;

cout &lt;&lt; ""Matrix: "" &lt;&lt; endl;
for (int i = 0; i &lt; Nx; i++)
{
    for (int j = 0; j &lt; Ny; j++)
    {
        cout &lt;&lt; Mat[i][j] &lt;&lt; ""   "";
    }
    cout &lt;&lt; endl;
}
cout &lt;&lt; endl;

// Triangularization
for (int i = 0; i &lt; Nx - 1; i++)
    for (int h = i + 1; h &lt; Nx; h++)
    {
        double t = Mat[h][i] / Mat[i][i];
        for (int j = 0; j &lt;= Nx; j++)
        {
            Mat[h][j] = Mat[h][j] - t * Mat[i][j];
        }
    }

// Resolution
for (int i = Nx - 1; i &gt;= 0; i--)
{
    q[i] = Mat[i][Nx];
    for (int j = Nx - 1; j &gt; i; j--)
    {
        q[i] = q[i] - Mat[i][j] * q[j];
    }
    q[i] = q[i] / Mat[i][i];
}

cout &lt;&lt; ""Solution of the system: "" &lt;&lt; endl;
cout &lt;&lt; q[0] &lt;&lt; endl;
cout &lt;&lt; q[1] &lt;&lt; endl;


return 0;
}
</code></pre>

<p>Using Wolfram Alpha to calculate the result of the given matrix, the result was:
<a href=""http://i.stack.imgur.com/tRLHH.png"" rel=""nofollow"">this</a><br>
And <code>5/6</code> is approximately equal to <code>0.8(3)</code> on the Y axis. I haven't managed to find the mistake in you algorithm for the X axis as it returns <code>-2.22045e-016</code>, which is either another out-of-bounds or just a mathematical error , but hopefully this will give you a start.</p>
",2
43176245,43176110,1,"<p><strong>Try it with these changes:</strong>    </p>

<pre><code>template&lt;class KeyType, class ItemType&gt;
class AVL
{
 protected:
 // Unnecessary -&gt; template&lt;class KeyType, class ItemType&gt;
 class AVLNode
 {
  public:
     AVLNode(KeyType key, ItemType item) : m_Balance(0), m_Depth(0),
                                           m_Key(key), m_Data(item),
                                           m_pLeft(0), m_pRight(0)
  { }

  private:
     int m_Balance;  // Missing from the ctor declaration
     int m_Depth;  // Missing from the ctor declaration
     KeyType m_Key;
     ItemType m_Data;

     AVLNode&lt;KeyType, ItemType&gt;*  m_pLeft;  // Change here
     AVLNode&lt;KeyType, ItemType&gt;*  m_pRight; // Change here
  };

  AVLNode&lt;KeyType, ItemType&gt;* m_pRoot;
  public:
  AVL() : m_pRoot(0) { }
  ~AVL() { }
};
</code></pre>
",2
47524073,47523848,1,"<p>Some pseudo-code to give you an idea of how it could be done:</p>

<pre><code>time_type last_time = now();  // Initialize to the current time

// Main game loop
forever
{
    // Do other game-related things...

    // Now handle things that should be done on regular intervals
    time_type current_time = now();
    time_diff_type difference = current_time - last_time;

    if (difference &gt; 2 second)
    {
        // Do things that should be done every two seconds
    }

    if (difference &gt; 1 second)
    {
        // Do things that should be done every second
    }

    last_time = current_time;
}
</code></pre>

<p>For the <code>time_type</code> and <code>now</code> functions, use the functionality in <a href=""http://en.cppreference.com/w/cpp/header/chrono"" rel=""nofollow noreferrer""><code>std::chrono</code></a>.</p>

<p>For example, to get the current time do e.g.</p>

<pre><code>auto current_time = std::chrono::system_clock::now();
</code></pre>

<p>And with a newer compiler and a <code>using namespace std::literals::chrono_literals;</code> you could actually use e.g. <code>1s</code> as a second:</p>

<pre><code>auto difference = current_time - last_time;
if (difference &gt; 1s) { /* Code here... */ }
</code></pre>

<p>The above is valid C++ code.</p>
",2
41673221,41673136,12,"<p>You can use <a href=""http://en.cppreference.com/w/cpp/types/is_empty"" rel=""nofollow noreferrer""><code>std::is_empty</code></a> to make sure that the class you're inheriting from is zero-sized:</p>

<pre><code>static_assert(std::is_empty&lt;Empty&gt;{});
</code></pre>

<p>If it is, <a href=""http://en.cppreference.com/w/cpp/language/ebo"" rel=""nofollow noreferrer""><em>empty base optimization</em></a> is <a href=""https://stackoverflow.com/questions/10788823/is-the-empty-base-class-optimization-now-a-mandatory-optimization-at-least-for"">guaranteed to take place for <em>standard-layout classes</em></a>.</p>

<hr>

<blockquote>
  <p>I understand that I can do check like <code>sizeof(Derived) = sizeof(a) + sizeof(b) ...</code> But It is too verbose. Is there more elegant solution?</p>
</blockquote>

<p>This does not work properly because you need to take padding into account and eventual attributes such as <code>packed</code>.</p>
",3
41675189,41673136,3,"<p>You can use more ""old"" (<strong>before</strong> C++11) macro - <a href=""http://en.cppreference.com/w/cpp/types/offsetof"" rel=""nofollow noreferrer"">offsetof</a>:</p>

<pre><code>struct Empty {};
struct NonEmpty {
  int a;
};
struct Derived1: Empty {
  int a;
  int b;
  char c;
};
struct Derived2: NonEmpty {
  int a;
  int b;
  char c;
};
static_assert(offsetof(Derived1,a) == 0,"""");
static_assert(offsetof(Derived2,a) != 0,"""");
</code></pre>

<p>You can use this macro to check order of your member variables too:</p>

<pre><code>static_assert(offsetof(Derived,a) &lt; offsetof(Derived,b),"""");
static_assert(offsetof(Derived,b) &lt; offsetof(Derived,c),"""");
</code></pre>

<p>But do not forget - offsetof has the same limitation: </p>

<blockquote>
  <p>If type is not a standard layout type, the behavior is undefined.
  If member is a static member or a member function, the behavior is undefined. </p>
</blockquote>
",0
37902864,37902857,0,"<p><strong><em>No.</em></strong></p>

<p>You should do it as you say.</p>
",0
37902865,37902857,2,"<blockquote>
<pre><code>MyClass *instance = new MyClass(j);
</code></pre>
  
  <p>works, but the syntax has ""MyClass"" two times, which is a bit
  redundant.</p>
</blockquote>

<p>How about:</p>

<pre><code> auto instance = new MyClass(j);
</code></pre>

<p>But why will you want to allocate on the heap? See <a href=""https://stackoverflow.com/questions/10157122/object-creation-on-the-stack-heap"">Object creation on the stack/heap?</a>
and <a href=""https://stackoverflow.com/questions/599308/proper-stack-and-heap-usage-in-c"">Proper stack and heap usage in C++?</a></p>
",2
38295542,38295487,0,"<p>You need to use <code>app</code> in your second writer to append the content to the file instead of rewritting it, as follows:</p>

<pre><code>#include ""stdafx.h""
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
using namespace std;

int main()
{
    ofstream a{ ""1.txt"",ios_base::ate };
    a &lt;&lt; ""123"";
    a.close();
    ofstream b{ ""1.txt"",ios_base::app }; //notice here is app instead of ate
    b &lt;&lt; ""456"";
    b.close();
    ifstream c{ ""1.txt"" };
    string str;
    c &gt;&gt; str;
    cout &lt;&lt; str;
    return 0;
}
</code></pre>

<p>As in <a href=""https://stackoverflow.com/questions/12253183/stdios-baseate-and-stdios-basetrunc"">this question</a> :</p>

<blockquote>
  <p>std::ios_base::ate does NOT imply std::ios_base::app</p>
</blockquote>

<p>So if you use <code>ate</code> it does not mean that it will append the content to the file.</p>
",0
38298239,38295487,0,"<p>You can find the different between <code>ios_base:ate</code> and <code>ios_base:app</code> <a href=""https://stackoverflow.com/questions/10359702/c-filehandling-difference-between-iosapp-and-iosate"">here</a></p>

<p>For your code, you can change it like this:</p>

<pre><code>ofstream b {""1.txt"", ios_base:app};
</code></pre>
",0
38285960,38285935,1,"<pre><code>while((again='Y') || (again='y'));
</code></pre>

<p>should be</p>

<pre><code>while((again=='Y') || (again=='y'));
</code></pre>

<p>You have mistaken assignment for comparison operator. Those are different in C and C++.</p>

<p>The effect of your code is that <code>Y</code>  or <code>y</code> is assigned to <code>again</code> and the new value is returned. That char is non-zero so converts to <code>true</code>. Thus, <code>true</code> is returned, and the loop turns endless.</p>

<p><strong>Edit:</strong></p>

<p>How you could've found it out yourself with a debugger:</p>

<p>The loop appears to be endless thus we need to check its condition variable. So, place a watch on the <code>again</code> variable and see it change when the loop condition is being evaluated. Problem found.</p>
",1
38285969,38285935,1,"<p><code>while ((again='Y') || (again='y')</code> does not do what you think it does. You are assigning to the <code>again</code> variable.
What you want to do is use the <code>==</code> operator to <em>compare</em> <code>again</code> to either 'Y' or 'y'.</p>
",0
38190704,38190573,0,"<p>I don't really understand what are you asking for, but I'll give you some help:</p>

<p>1) Code like <code>if (Answer = 1)</code> is totally wrong (but it's compilable), because for sure you want to compare <code>Answer</code> with the number 1, not to assign 1 to <code>Answer</code> and then use it as the condition of the if statement.
To compare two values, use <code>==</code>
Example:</p>

<pre><code>if (Answer == 1)
</code></pre>

<p>2) Code inside <code>if (false)</code> will never be executed.
I don't know what you wanted to do, but surely not to skip these instructions.</p>

<p>3) Why do you return 0 from functions with <code>std::string</code> as return type? This in non-sense.</p>

<p>I suggest you to read some basic programming books, especially before diving into OOP (!)</p>

<p><strong>EDIT</strong>: If you just wanted to check if a number is contained in a range (lets say between 1 and 1337), just do:</p>

<pre><code>int n;
std::cin &gt;&gt; n;
if (n &gt; 0 &amp;&amp; n &lt; 1338)
{
 /* do whatever you want */
}
else
{
 /* number is not in the range */
}
</code></pre>
",2
37761544,37761521,4,"<p><code>cout &lt;&lt; x++;</code> outputs the value of <code>x</code> before the increment as you are using the postfix increment operator. </p>

<p><code>cout &lt;&lt; ++x;</code> would do what you expect.</p>
",0
37761548,37761521,0,"<p><code>x++</code> simply returns <code>x</code> and then increases <code>x</code> by one.</p>

<p>So <code>cout &lt;&lt; x++</code> in your example would be the equivalent of <code>cout &lt;&lt; x; x = x+ 1;</code></p>
",9
37761549,37761521,0,"<p>That's post-increment, which means that it will execute the variable as-is, and then add to the variable.</p>

<p>Had you tried the pre-increment <code>++x</code>, then it would add to the variable, and execute the variable as-is (which is now incremented).</p>

<p>Therefore, <code>int x = 0; x = x + 1; cout &lt;&lt; x;</code> and <code>int x = 0; x++; cout &lt;&lt; x++;</code> will all print <code>1</code>.</p>
",0
37761551,37761521,0,"<p>Cout &lt;&lt; x++ will first print x and then increase it, x++ is post increment so after the operation x is increased. Instead ++x will do the opposite. And also if you cout some expression like x+1 the expression will be evaluated before printing</p>
",0
37761558,37761521,0,"<p>x++ is a post increment, which means that it increments after it has run the current statement.</p>

<p>In contrast, ++x executes the current statement before executing the increment.</p>

<p>Hope this helps.</p>
",0
37761565,37761521,1,"<p>There are two forms of the <code>++</code> operator: prefix and postfix. You're using the postfix form.</p>

<p><code>x++</code> returns the <em>current</em> value of x, then increments it. When you use <code>cout &lt;&lt; x++</code>, it prints x <em>then</em> increments it.</p>

<p><code>++x</code> does what you want: it increments x <em>then</em> returns it. <code>cout &lt;&lt; ++x</code> will give you what you want.</p>
",0
40563862,40563827,1,"<p>The code looks fine.</p>

<p>It seems that you did not add <code>Hi.cpp</code> to your IDE project.</p>

<p>It's strange that you didn't call it <code>Hello.cpp</code> - do you have a file of <em>that</em> name (perhaps empty) that you're building instead?</p>
",0
41179344,41179282,6,"<p>This simply says that the macros <em>is defined</em>, so you can do this in <code>main</code> or any other function:</p>

<pre><code>#ifdef TML_ID
printf(""Defined!\n"");
#else
printf(""Undefined!\n"");
#endif
</code></pre>
",6
41179752,41179282,1,"<p><code>#define</code> doesn't assign a value to the macro. In fact, it's considered as a flag to tell the compiler that a specific macro has been defined. </p>

<p>You can imagine it as if you declare a variable without assigning any values. It will have a garbage value but it will reserve a space in the memory. But in case of a macro, the definition won't reserve a space. Only a hint for the compiler. </p>
",3
41181264,41179282,0,"<p>Without assigned a value, macros in this way are usually used to prevent including same .h file multiple times, this way:</p>

<pre><code>#ifndef _FILENAME
#define _FILENAME

//declaration code

#endif
</code></pre>

<p>If some .cpp file includes, for example, two different .h files, which both include our .h file, then .cpp will have only one copy of declaration code, since second time _FILENAME macro will be DEFINED, and declaration code will be skipped.</p>
",1
41185884,41179282,0,"<pre><code>#define MACRO
</code></pre>

<p>defines a macro named MACRO. It has no content, so if you wrote something like <code>std::cout &lt;&lt; MACRO</code> you'd get an error because there's nothing there. This is often used to conditionally use new keywords:</p>

<pre><code>#if CPP_VERSION_C11
    #define NOEXCEPT noexcept
#else
    #define NOEXCEPT
#endif

void f() NOEXCEPT {
    // whatever
}
</code></pre>

<p>There are two other ways you can use such a macro. You can check whether it's defined:</p>

<pre><code>#ifdef MACRO
    // code for one branch
#else
    // code for other branch
#endif
</code></pre>

<p>For that code, since <code>MACRO</code> has been defined, the preprocessor will look at the code in the first branch, and skip the code in the second branch. If <code>MACRO</code> had not been defined, it would skip the code in the first branch rather than the second. You can also do the same thing this way:</p>

<pre><code>#if defined(MACRO)
</code></pre>

<p>or you can use it in a constant expression in a preprocessor directive:</p>

<pre><code>#if MACRO
    // code for one branch
#else
    // code for other branch
#endif
</code></pre>

<p>here, <code>MACRO</code> gets the value 0, the <code>#if</code> sees the value 0, and the preprocessor skips the first branch. The same thing occurs in more complex expressions:</p>

<pre><code>#if MACRO + 1 &gt; 0
    // code for one branch
#else
    // code for other branch
#endif
</code></pre>

<p>Here, <code>MACRO</code> has the value 0, <code>MACRO + 1</code> has the value 1, and the first branch will be selected.</p>
",0
38287996,38287803,2,"<p>Inside of your game loop, you'll need a function that updates the position of the ship based on its x and y velocity.  You're close in getting the new x and y coordinates of your ship, but you don't account for the velocity of the ship.  When you apply thrust, get the x and y components of your <em>velocity</em>, not your new position.  You'll have an additional function to update position which should be called within the game loop at a timed interval - e.g. every time you update the frame.  So your <em>applyThrust</em> function should actually update your ship's velocity.  That means you'll need to add variables to your <em>Ship</em> class for your ship's position and your ship's velocity if you don't already have them.  I'm breaking out the components of position and velocity for simplicity, but you'll probably want to store them in a vector for clarity:</p>

<pre><code>class Ship 
{
    private float xpos, ypos; // current position of your ship
    private float velocityX, velocityY; // current velocity of your ship
}
</code></pre>

<p>Then, when you apply thrust, you change the <em>velocity</em>, and remember that applyThrust is only called when the thrust button is pushed, not every frame as the position update is:</p>

<pre><code>void Ship::applyThrust()
{
    /* 
       Assume 1 total unit of thrust is applied each time you hit the thrust button
       so you break down the velocity into x and y components depending on the direction
       your ship is facing. 
    */    
    // thrustUnit is how much thrust each thrust button press gets you, it's arbitrary
    // and can be the 2.5 multiplier you're using in your question
    float thrustUnit = 1.0;

    // now get the x and y thrust components of velocity based on your ship's direction
    // assuming 0 degrees is pointing to the right
    float newVX, newVY = 0.0;        
    newVX = thrustUnit * cos(_angle);
    newVY = thrustUnit * sin(_angle); // radian conversion left out to save space

    // Update your ship's velocity
    updateVelocity(newVX, newVY);
}
</code></pre>

<p><em>updateVelocity</em> will look something like: (note that the velocity is <em>additive</em> so it continues to drift unless a thrust is applied in the opposite direction - the same as if it were in a frictionless medium such as space)</p>

<pre><code>void Ship::updateVelocity(newVX, newVY)
{
    // update the x component
    velocityX += newVX;
    velocityY += newVY;
}
</code></pre>

<p>So now you'll also need an updatePosition function that takes into account your ship's velocity.  This gets called with each frame update:</p>

<pre><code>void Ship::updatePosition()
{
    // add the x component of velocity to the ship's x position
    // assuming xpos and ypos are variables in the Ship class for tracking position
    xpos += velocityX;
    ypos += velocityY;
}
</code></pre>

<p>Now the position of the ship changes incrementally according to each velocity component at each frame update.  You can also make <em>thrustUnit</em> a member variable to allow for power-ups that can either boost or decrease your thrust component for your ship's speed and being able to control it better with a smaller <em>thrustUnit</em> or giving it hyperspeed with a large <em>thrustUnit</em>.  </p>

<p>Good luck with your game!</p>
",1
41210246,41210096,0,"<p>You can check if the number if odd by:</p>

<pre><code>if (x % 2) {
    cout &lt;&lt; ""x is odd"" &lt;&lt; endl;
}
</code></pre>

<p>Therefore, the final code would be:</p>

<pre><code>int N = 20; // array length
odd_arr[N], even_arr[N], odd_idx = 0, even_idx = 0;

for (int i = 0; i &lt; N; i++) {
    if (A[i] % 2) {  // odd
        odd_arr[odd_idx] = A[i];
        odd_idx++;
    } else {  // even
        even_arr[even_idx] = A[i];
        even_idx++;
    }
}
</code></pre>
",4
41210252,41210096,0,"<p>First: you didn't initialize <code>j</code> and <code>k</code>, so when you store numbers into <code>b[]</code> and <code>c[]</code> you are likely be storing them into undetermined positions that may or may not lie within the array, invoking undefined behaviour.</p>

<p>Second: judging from your for loops, you seem to assume that arrays in C++ starts at element 1, when they actually starts at element 0. This doesn't hurt your program, as long as you choose a value for <code>n</code> not greater than 49.</p>
",0
41210270,41210096,1,"<p>Instead of </p>

<pre><code>for(i=1;i&lt;=n;i++)
</code></pre>

<p>you need (everywhere)</p>

<pre><code>for(int i=0; i&lt;n; i++)
</code></pre>

<p>In C++, indices start from 0, and the loop variable is usually declared within the loop.</p>

<p>Beside, you should initialize j and k:
    int j=0, k=0;</p>

<p>Finally, in C++, variables are usually declared when they are needed:</p>

<pre><code>int j=0, k=0;
for(int i=0; i&lt;n; i++) {
    if(a[i]%2!=0){
        b[j]=a[i];
        j++;
    }else{
        c[k]=a[i];
        k++;
    }
}
</code></pre>

<p>In your final loops you need <code>i&lt;j</code> and <code>i&lt;k</code>, because j and k are incremented after the last time you wrote something into arrays.</p>

<p>You probably need cout &lt;&lt; ""\n"" at the end.</p>
",1
38400097,38398367,0,"<p>Looks like you could use an Abstraction class and several type classes.  </p>

<p>The Abstract, Parent or Root class would contain generic methods that all children have to implement.  </p>

<p>For example:  </p>

<pre><code>class Base_Type
{
  public:  
    virtual bool value_is_in_range(const std::string&amp; value_as_text) const = 0;
};  
</code></pre>

<p>Each child class would specialize the abstract method:  </p>

<pre><code>class Uint8_Type
{
  public:
    bool  value_is_in_range(const std::string&amp; value_as_text) const
    {
       std::istringstream value_stream(text);
       unsigned int value;
       value_stream &gt;&gt; value;
       if (value &gt; CHAR_MAX)
       {
          return false;
       }
       return true;
    }
  };
</code></pre>

<p>Two concepts here:  1) a common, universal data type for passing values; 2) If converting the string to number for range checking, the number must be of a larger type.  </p>

<p>I chose a <code>std::string</code> and using text as a universal data type.  Most PODs can be represented as text.  </p>
",0
38020750,38020553,0,"<p>declare  average variable</p>

<pre><code>float average;       

 average=calificacion_1+calificacion_2+calificacion_3+calificacion_4)/4;
if(average&gt;=80)
{
 printf(""\nAbsolved"");
}
else if(average&gt;=45 &amp;&amp; average&lt;80)
{
 printf(""\nExam"");
}
else
{
printf(""\nFail"");
}
</code></pre>
",0
38020624,38020553,0,"<p>just do one thing re install code-blocks..it worked for me..Also i ran your code on dev-c++ which ran fine...so i recommend you to install dev-c++</p>
",0
41217085,41217029,0,"<p>Use </p>

<pre><code>if(Uattempt != username1 &amp;&amp; Uattempt != username2 &amp;&amp; Uattempt != username3 &amp;&amp; Uattempt != username4)
</code></pre>

<p>instead of </p>

<pre><code>if(Uattempt!=username1 || username2 || username3 || username4)
</code></pre>
",1
41217119,41217029,0,"<p>std::string does not define || operator.</p>

<p>Change the following:</p>

<pre><code>if(Uattempt!=username1 || username2 || username3 || username4) ...
</code></pre>

<p>to:</p>

<pre><code>if (Uattempt!=username1 || Uattempt!=username2 || Uattempt!=username3 || Uattempt!=username4) ...
</code></pre>
",1
41217848,41217029,0,"<p>Consider using a map of usernames and passwords if you plan on getting a lot of them:</p>

<pre><code>std::map&lt;string, string&gt; userandpass{
  {""user1"", ""pass1""},
  {""user2"", ""pass2""}};

string Uattempt, Pattempt;
std::cout &lt;&lt; ""Please enter your username.\n"";
std::cin &gt;&gt; Uattempt;
std::cout &lt;&lt; ""Please enter your password \n"";   //Asks for username and password entry by user
std::cin &gt;&gt; Pattempt;

auto userIt = userandpass.find(Uattempt);
if (userIt == userandpass.end())
{
  std::cout &lt;&lt; ""Access Denied."";
  return;
}
string &amp;password = userIt-&gt;second;
if (password  != Pattempt)
{
  std::cout &lt;&lt; ""Access Denied."";
  return;
}
std::cout &lt;&lt; ""Access Granted."";
</code></pre>
",0
38309176,38309136,2,"<p>You need to write <code>void add::z(){</code> when <em>defining</em> the member function <code>void z()</code>.</p>

<p>Else you're just defining a <em>global</em> function <code>void z()</code>, and <code>w</code> cannot be found. That's what is confusing the compiler.</p>
",0
38309206,38309136,1,"<p>variable 'w' is defined as member of class add. Class add also has 2 public member functions. In given code z is not implementation of <code>void add::z()</code>, but a new global function called z(). Change line <code>void (){</code> into <code>void add::z(){</code> and it will be fine.</p>
",0
46957295,46957225,4,"<p>It's C++, use std::vector</p>

<pre><code>#include &lt;vector&gt;
class MyImage
{
public :
    int height;
    int width;
    std::vector&lt;int&gt; matrix;

    MyImage(int h, int w) : height(h), witdh(w), matrix(h*w)
    {
    }
}
</code></pre>
",0
46957328,46957225,7,"<blockquote>
  <p>What is the best way ?</p>
</blockquote>

<p>In your case if you know size at compile time, use <code>std::array</code>, if you do not use <code>std::vector</code> and initialize it properly. Creating memory manually would not give you anything, only headaches, <code>std::vector</code> does the same under the hood.</p>
",0
39130334,39130296,3,"<p>You have 9 format specifiers and only 8 following <code>printf</code> arguments.</p>

<p>The warning explains itself. It is good that you have not ignored this, because the resulting behavior of this call is <em>undefined</em>. </p>

<p>To fix this either add the extra argument or remove one of the format specifiers (<code>%</code>).</p>
",2
40990369,40989768,1,"<p>Issue with the conversion of degree into radian</p>

<pre><code>float degree = (angle * 180 / M_PI);
</code></pre>

<p>The correct conversion formula is </p>

<pre><code>float radian = (angle * M_PI / 180);
</code></pre>

<p>Also as mentioned in the comment use the good name to avoid any confusion. </p>
",0
40990569,40989768,1,"<p>Since your default angles are in degrees, you need to convert them to radians first before using <code>sin()</code> and <code>cos()</code>, then multiplying it to the radius.</p>

<pre><code>double cordinate_print()
{
    int number_of_chunks = 5;
    double degrees = 0;                         // &lt;-- correction
    double x_p[5]; // number of chunks 
    double y_p[5]; // number of chunks 
    double radius = 150;                        // &lt;-- correction

    for (int i = 0; i &lt; number_of_chunks; i++)
    {
        degrees = i * (360 / number_of_chunks); // &lt;-- correction
        float radian = (degrees * (M_PI / 180));  // &lt;-- correction
        x_p[i] = radius * cos(radian);          // &lt;-- correction
        y_p[i] = radius * sin(radian);          // &lt;-- correction

        cout &lt;&lt; ""x -&gt; "" &lt;&lt; x_p[i] &lt;&lt; ""y -&gt; "" &lt;&lt; y_p[i] &lt;&lt; ""\n"";
    }

    //printing x and y values
    printf(""\n \n"");

    return 0;
}
</code></pre>
",0
43230315,43230223,3,"<p>Two problems: The lesser of them is that your program is technically not a valid C++ program, since C++ doesn't have <a href=""https://en.wikipedia.org/wiki/Variable-length_array"" rel=""nofollow noreferrer"">variable-length arrays</a> (which your arrays <code>temp1</code>, <code>temp2</code> and <code>temp3</code> are).</p>

<p>The more serious problem is that you save pointers to local variables. When a function returns, local variables go out of scope and no longer exist. Pointers to them will become invalid, and using those pointers will lead to <em>undefined behavior</em>.</p>

<p>Both problems are easily solved by using <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow noreferrer""><code>std::vector</code></a> instead of arrays and pointers.</p>
",0
43230467,43230223,0,"<p>You cannot declare an array in C++ without a ""constant"" expression for its size (the bounds must be known at compile time). That means this code is invalid:</p>

<pre><code>double temp1[thickness], temp2[thickness], temp3[thickness];
</code></pre>

<p>What you should instead do is the following:</p>

<pre><code>class cmpl
{
   //...
   std::vector&lt;double&gt; kappa_x_tau_xy, sigma_x_tau_xy, alpha_x_tau_xy;
   // ...
};

void cpml::set_cpml_parameters_tau_xy(){
   alpha_x_tau_xy.resize(thickness);
   kappa_x_tau_xy.resize(thickness);
   sigma_x_tau_xy.resize(thickness);
   //...
</code></pre>

<p><a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow noreferrer""><code>std::vector</code></a> will handle all the dynamic allocation under the hood for you. If your code compiled, it was because you were using a nonstandard GCC extension for <a href=""https://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html"" rel=""nofollow noreferrer"">variable length arrays</a>. Turn your warnings up <code>-Wall -pedantic -Werror</code> when you compile and it should complain more.</p>

<p>Note that you also have issues in array bounds. Whereas Matlab is 1-indexed, C++ is 0-indexed, so you'll need to do this, too:</p>

<pre><code>for(int j = 0; j &lt; thickness; j++){ 
    alpha_x_tau_xy[j] = 1 + kappa_x_max * pow((double)(thickness - j - 0.5) / (double)(thickness - 1), n_1);
    kappa_x_tau_xy = sigma_x_1_max * pow((double)(thickness - j - 0.5) / (double)(thickness - 1), n_1 + n_2);
    sigma_x_tau_xy = alpha_x_max * pow((double)(j - 0.5) / (double)(thickness - 1), n_3);
}
</code></pre>

<p>You have a similar issue in <code>main</code>:</p>

<pre><code>for(int j = 1; j &lt; cpml.thickness; j++){

    cout &lt;&lt; *(cpml.sigma_x_tau_xy + j) &lt;&lt; endl;

}
</code></pre>

<p>Should become:</p>

<pre><code>for(int j = 0; j &lt; cpml.thickness; j++){
    cout &lt;&lt; cpml.sigma_x_tau_xy[j] &lt;&lt; endl;
}
</code></pre>

<h3>Additional Notes:</h3>

<ul>
<li><p>Your code is very unstructured. Consider putting all of the <code>cmpl</code>-related getting and setting into the <code>cmpl</code> class ([Encapsulation])(<a href=""https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)</a>). This will make it easer for the client (you in this case) to interact with the object.</p>

<ul>
<li>This will include hiding your class data as <code>protected</code> or <code>private</code> and exposing functions to get and set those variables (don't forget <code>const</code> where appropriate).</li>
<li>Add a constructor to initialize all of the fields at once. As it stands now, your class consists of mostly uninitialized garbage for much of its lifetime. If someone where to prematurely try to access a field, you're in Undefined Behavior territory.</li>
</ul></li>
<li><p><code>std::endl</code> is good for printing newline characters, but restrict that to <strong>Debug</strong>-only code. The reason being is that it flushes the buffer every time its called, which can make your code overall slower if it's printing a lot. Use a newline character <code>""\n""</code> instead for Release.</p></li>
<li>An additional benefit of <code>std::vector</code> is that it makes copying and assigning to a <code>cmpl</code> well behaved. Otherwise, the compiler will generate a copy constructor and copy assignment, which when used will be a <a href=""https://stackoverflow.com/questions/184710/what-is-the-difference-between-a-deep-copy-and-a-shallow-copy""><strong>shallow copy</strong></a> instead of the <strong>deep copy</strong> that you'd want.</li>
</ul>

<p>After restructuring your class, your <code>main</code> might look something like this:</p>

<pre><code>int main() {
    int cpml_thickness = 10; 
    int n_1 = 3, n_2 = 0, n_3 = 3;  
    double cut_off_freq = 1;

    double kappa_x_max = 0;
    double sigma_x_1_max = 0.8 * (n_1 + 1) / (sqrt(simulation_medium.mu/simulation_medium.rho) * simulation_grid.big_delta_x), sigma_x_2_max = 0.8 * (n_1 + 1) / (sqrt(simulation_medium.mu/simulation_medium.rho) * simulation_grid.big_delta_x);
    double alpha_x_max = 2 * PI * cut_off_freq;

    double kappa_y_max = 0;
    double sigma_y_1_max = 0.8 * (n_1 + 1) / (sqrt(simulation_medium.mu/simulation_medium.rho) * simulation_grid.big_delta_y), sigma_y_2_max = 0.8 * (n_1 + 1) / (sqrt(simulation_medium.mu/simulation_medium.rho) * simulation_grid.big_delta_y);
    double alpha_y_max = 2 * PI * cut_off_freq;

    cpml cpml(cpml_thickness, n_1, n_2, n_3, cut_off_freq, kappa_x_max, kappa_y_max, sigma_x_1_max, sigma_x_2max, alpha_x_max, alpha_y_max);
    cpml.set_cpml_parameters_tau_xy();
    cpml.PrintSigmaTauXY(std::cout);
}
</code></pre>

<p>Which is arguably better. (You might use a getter to get <code>sigma_tau_xy</code> from the class and then print it yourself, though). And then you can think about how to simplify things even further by creating objects that represent the logical groupings of <code>alpha_x_max</code> and <code>alpha_y_max</code> etc. This could be a <code>std::pair</code> or a full-on struct with its own getters and setters. Now their own logic is grouped together and is easy to pass around/reference/think about. Your constructor for <code>cmpl</code> also becomes simpler, where you accept a single parameter that represents both <code>x</code> and <code>y</code> instead of separate ones for both.</p>

<p>Matlab doesn't really encourage an Object-Oriented approach in my (admittedly breif) experience, but in C++ it's easy.</p>
",0
41645110,41644910,0,"<p>you are creating an array of a garbage value:</p>

<pre><code>int n; // n has a garbage value
int A[n]; // creating of array of ?? element?
cin &gt;&gt; n; // this should be before declaring the array:

int n;
cin &gt;&gt; n ; 
int j=0;
int A[n];
</code></pre>
",2
40971133,40970814,1,"<p>String <code>line</code> will be one line of text. First it will be ""Tstart: 13:51:45"", and in the next iteration it will be ""Tend: 13:58:00"".</p>

<p>String <code>token</code> will be part of the <code>line</code> that is delimited with space. So, if line is ""Tstart: 13:51:45"" then token will be ""Tstart:"" in first iteration and ""13:51:45"" in second iteration. This is not what you need.</p>

<p>Instead of the inner <code>while</code> loop I suggest searching for a space with <code>string::find</code> and then taking everything after the space with <code>string::substr</code>:</p>

<pre><code>bool is_first_line = true;
string tStart, tEnd;

while (getline(infile, line))
{
    int space_index = line.find(' ');

    if (space_index != string::npos)
    {
        if (is_first_line)
            tStart = line.substr(space_index + 1);
        else
            tEnd = line.substr(space_index + 1);
    }

    is_first_line = false;
}

cout &lt;&lt; tStart &lt;&lt; tEnd &lt;&lt; endl;
</code></pre>

<p>If it is not known in advance which line has which value then we can still get away from inner loop:</p>

<pre><code>string tStart, tEnd;

while (getline(infile, line))
{
    int space_index = line.find(' ');

    if (space_index != string::npos)
    {
        string property_name = line.substr(0, space_index);

        if (property_name == ""Tstart:"")
            tStart = line.substr(space_index + 1);
        else if (property_name == ""Tend:"")
            tEnd = line.substr(space_index + 1);
    }
}

cout &lt;&lt; tStart &lt;&lt; tEnd &lt;&lt; endl;
</code></pre>
",2
46974417,46973089,1,"<p>C++ and C# are different languages, with different rules and different compilers. Since floating point is inexact by definition, any subtle difference can result in the different values you see.</p>

<p>I don't know the C# rules at all, but in C++, notice that while you have typed <code>pAB</code> as <code>double</code>, you're actually computing its value in <code>float</code> (because <code>Ax</code>, <code>Ay</code>, <code>Bx</code>, <code>By</code> are all <code>float</code>s) and only after that is the value promoted to a <code>double</code>. In other words, you do not gain any precision here by using <code>double</code>. Maybe the C# rules are different here, no idea.</p>

<p>Anyway, if you make sure <code>pAB</code> is computed in <code>double</code>, you get exact values with these particular numbers: <a href=""http://coliru.stacked-crooked.com/a/1232b1dd28762ee4"" rel=""nofollow noreferrer"">[live example]</a>, compared to <a href=""http://coliru.stacked-crooked.com/a/d409ced501190d7d"" rel=""nofollow noreferrer"">[the unchanged code]</a>.</p>

<p>Making sure the <code>double</code> value is actually computed in <code>double</code> is probably the correct solution here. Nevertheless, since floating point <em>is</em> inexact and could ""fail"" for you with other values, I suggest using <a href=""http://en.cppreference.com/w/cpp/numeric/math/round"" rel=""nofollow noreferrer""><code>std::round</code></a> instead of casting to <code>int</code> if you want rounding behaviour.</p>
",0
38511097,38510920,2,"<p>Suppose that you have class definition:</p>

<pre><code>class DataBase {
public
   bool isUserAndPassMatch() {return true;}
};
</code></pre>

<p>If you want to call the isUserAndPassMatch member function, you have to have object:</p>

<pre><code>DataBase db;
if( db.isUserAndPassMatch() ) {
}
</code></pre>

<p>Try it.</p>
",0
44352370,44352347,2,"<p>The <code>'T'</code> in the template is just a placeholder for the type used in the function, the class or the entity it is associated with. And the scope of the template parameter ends with the scope of this entity.</p>

<p><a href=""https://stackoverflow.com/questions/43956589/when-does-a-template-end""><em>See here: When does a template end?</em></a></p>

<p>You have to write another template for <code>binary(X x, X y)</code> as follows:</p>

<pre><code>template&lt; typename X&gt;   
X unary(X x)
{
  return x*10;
}

template&lt; typename X&gt; 
X binary( X x,X y)
{
    return x+y;
}
</code></pre>
",0
38208666,38208604,7,"<p>This is the time to learn how to use a debugger.</p>

<p>Your <code>setMemberName</code> method will never set the name if it's the correct length from the start. Only errors will trigger the actual setting of the member variable.</p>
",2
38208686,38208604,3,"<p>The problem is in the function itself, here it is modified:</p>

<pre><code>void DigitalPet::setMemberName ( std::string name)
{
    while (name.length() &gt; 10 )
    {
        std::cout &lt;&lt; ""The name you entered is too long. Please enter a smaller name!!!"" &lt;&lt; std::endl;
        std::cin &gt;&gt; name;
    }

    m_memberName = name;
}
</code></pre>

<p>The problem was you only assign a name when the parameter was longer than 10 characters and you didn't check it again, just assigned it.</p>
",1
38403552,38403414,2,"<p>Your global array takes up 40GB; you can't put that in the program's <code>.data</code> section. It doesn't fit there.</p>
<p>Even if it did, you would end up with a gigantic binary, so it's a bad idea in the first place.</p>
<p>If you have like 45+GB RAM installed, you can use a dynamic allocation (via <code>std::vector</code>) for this, otherwise, rethink your code to need less memory.</p>
",0
39247994,39247868,2,"<p>As @Bo Persson has said, <code>*=</code> is an existing operator. In this case, <code>x*=0</code> would simply multiply x by 0 instead of what you wish to achieve. </p>
",0
36365419,36365209,4,"<p>If your cities are numbered 1, 2, 3, then <code>printcities</code> will be a string containing three characters, of value <code>'\0x01' '\0x02'</code> and <code>'\0x03'</code>.  This won't print well.  If you were trying to get printcities to hold ""123"", you either need a stringstream, or std::to_string().</p>
",0
38194713,38194644,1,"<p>The exam has asked a poorly-worded question! <code>char</code> and <code>int</code> do NOT have a direct equivalence - but a <code>char</code> can be <em>interpreted</em> as an <code>int</code>, <em>usually</em> using the ""ASCII"" coding scheme (""American Standard Code for Information Interchange""). But even that's not universal - there's also EBCDIC and others.</p>

<p>But try ""ASCII"".</p>

<h3>Edit</h3>

<p>According to the C standard, the character encoding doesn't have to be ASCII. But there are rules it has to follow:</p>

<ol>
<li>The repesentations for '0' to '9' <strong>must</strong> be consecutive and in that order, to make calculations easy when converting to <code>int</code>.</li>
<li>The representations for 'A' to 'Z' <strong>must</strong> be ascending, to make calculations for sorting easy (note <em>not</em> necessarily consecutive - for example in EBCDIC they're not).</li>
<li>The representations for 'a' to 'z' <strong>must</strong> also adhere to the above rule, but also the difference between upper and lower case <strong>must</strong> be the same for every character (note that lower could come before upper).</li>
</ol>
",0
40779497,40779442,1,"<p>You're invoking a undefined behaviour by out of bound indexing for array <code>a</code></p>

<p>The for loop </p>

<pre><code>for(i=0;i&lt;=10;i++)
        ~~~
</code></pre>

<p>should use <code>i &lt; 10</code> to index from 0 to 9 for 10 elements</p>
",2
40779499,40779442,1,"<pre><code>    int a[10];
    for(i=0;i&lt;=10;i++)
        a[i]=0;
</code></pre>

<p>In this part, you are writing a <code>0</code> into <code>a[10]</code>. But <code>a[10]</code> does not exist. <code>a[]</code> only has space for 10 integers, indexed 0 to 9. So you are writing a zero to somewhere in memory, and you overwrote your <code>final_time[0]</code> by chance. Could have been something else or could have crashed your program, too.</p>

<p>Fix this by correcting your loop to <code>for(i=0;i&lt;10;i++)</code> like your other loops.</p>

<p>Writing to an array out of it's allocated bounds is undefined behavior in C++. that basically means it's not defined in the standard and each compiler vendor will have to make something up for their product on what should happen if you do this. So it's rather random and therefor bad (tm). You may get a different behavior when you switch compilers, you may even get a different behavior when you restart your program. In your case, your compiler vendor (like many others) decided that they will just not check if the developer was correct. They just write that zero to the space in memory that <code>a[10]</code> <em>would</em> have been at, had it existed. But it did not. And by plain chance there was another variable at that spot in memory. So that one had it's value overwritten by the zero. </p>
",2
48038154,48038101,2,"<p><code>std::ios::binary</code> only has the effect of suppressing end-of-line conversion (so that e.g. <code>\r\n</code> in file is not converted to just <code>\n</code> in memory). It is certainly correct to supply this when dealing with binary files.</p>

<p>However, <code>&gt;&gt;</code> is still a <em>formatted</em> input function, which skips leading whitespace, terminates at whitespace and so on.</p>

<p>If you want to actually read the file as binary data, you must use the <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/read"" rel=""nofollow noreferrer""><code>read</code></a> function on the stream object.</p>
",0
41454739,41454656,0,"<p>Consider the situation where <code>Sales_data.h</code> is modified to use a forward deceleration of <code>std::string</code> (instead of getting <code>std::string</code>'s deceleration from the system header.)   This would allow <code>Sales_data.c</code> to compile with <code>Sales_data.h</code>, but would then cause compilation errors on any files including <code>Sales_data.h</code>, using <code>std::string</code>, but not including <code>&lt;string&gt;</code>.</p>

<p>You are correct in assuming that you may get this header indirectly from other header files, but it is not something you should rely on.  I believe the author is suggesting it as a best practice.</p>
",6
41454758,41454656,0,"<p>This sentence </p>

<blockquote>
  <p>Programs that use Sales_data also need to include the string header.</p>
</blockquote>

<p>can be interpreted (with a grain of salt) as pointing out that any program that uses Sales_data does include the string header, because it is included in the Sales_data header. </p>

<p>Of course a class should come with all required headers already included.</p>
",0
41454779,41454656,2,"<p>The description you read is bogus. If the definition of a class C uses a type T, such as <code>std::string</code>, then that type needs to be available. Usually (except with Microsoft code) the header that defines C includes the header that defines T. Client code of C then needs only include the header that defines C.</p>

<p>The situation is different with more arbitrary indirect header inclusions. Let's say class C doesn't use <code>std::string</code>, but its header includes <code>&lt;string&gt;</code>. Then if your code that uses C, also uses <code>std::string</code>, it's good practice to let your code also include <code>&lt;string&gt;</code>. Even if that's not necessary at the current point of the code's evolution.</p>

<p>The case for client code including the necessary headers, as with at least former Microsoft style, is that it by itself can give faster builds (fewer file accesses during a build), and supports some build optimization via primitive tools such as Visual C++'s precompiled headers, where all headers to be precompiled need to be collected in one big Mother Of All Headers. The case against that practice is that it makes for more work in maintenance. And 80% of all programming is maintenance.</p>
",1
38307818,38307727,3,"<p>Try:</p>

<pre><code>#include &lt;string&gt;
</code></pre>

<p>instead of:</p>

<pre><code>#include &lt;string.h&gt;
</code></pre>
",0
38308265,38307727,2,"<p>As already pointer out, you should try including C++'s string.</p>

<pre><code>#include &lt;string&gt;
</code></pre>

<p>However, if that's your problem, the compiler should have said <code>string</code> is not in the <code>std</code> namespace.</p>

<hr>

<p>To me it looks like the compiler doesn't know about the <code>::</code> namespace operator.</p>

<p>The possible cause is that you're using a C compiler instead of a C++ compiler.</p>

<p>C doesn't have a notion of namespace, and it has no <code>std::string</code>.</p>

<hr>

<p>Make sure your source file's extension is a C++ one (like <code>.cpp</code>) as opposed to C (<code>.c</code>).</p>

<p>Depending on your compiler, you might need to tell it you mean C++ and not C.
If you're using <em>gcc</em>, try <em>g++</em> instead.</p>
",3
41403529,41403273,3,"<p>The first error is telling you that <code>nullpointr</code> is not defined. You are probably meaning to use <code>nullptr</code>, which is part of the C++ language.</p>

<p>The other two errors deal with your third constructor. It appears you have placed two of your member initializers in the constructor, and done them incorrectly at that.</p>

<pre><code>Timer(const std::function&lt;void(void)&gt; &amp;f,
      const unsigned long &amp;i,
      const long repeat = Timer::Infinite) : funct (f)
                                            {
                                                interval(std::chrono::milliseconds(i)),
                                                CallNumber(repeat) {}
                                            }
</code></pre>

<p>What you probably want is:</p>

<pre><code>Timer(const std::function&lt;void(void)&gt; &amp;f,
      const unsigned long &amp;i,
      const long repeat = Timer::Infinite) : funct (f),interval(i), CallNumber(repeat) 
{}
</code></pre>
",0
41662946,41662899,0,"<p>You need to print the item before you recurse:</p>

<pre><code>void first7(int *aptr, int n)
{
  if(n == 0)
  {
    return;
  }

  cout &lt;&lt; *aptr;
  first7(aptr+1, n-1);
}
</code></pre>

<p>Note that there's also no need to return a value, so I've removed that.</p>

<p>If you want to output the array in reverse order then just do the recursion before the printing:</p>

<pre><code>void first7(int *aptr, int n)
{
  if(n == 0)
  {
    return;
  }

   first7(aptr+1, n-1);
   cout &lt;&lt; *aptr;
}
</code></pre>

<p>You've asked about the <code>return</code> statement in the comments. You only need a <code>return</code> statement to exit before the end of the function. When the functions gets to the last line it will automatically return without you having to do anything about it. If you're unsure about this then just run the code through a debugger and see what happens.</p>
",4
40756704,40756097,1,"<p>Check that you are not out of bound of array <code>a</code> in function <code>getPints</code> add check here</p>

<pre><code> while (!bloodInFile.eof())
 {
   if(i &gt;= h)
       break;
   bloodInFile &gt;&gt; a[i];
   i++;
 }
</code></pre>

<p>Because if you can have more lines that <code>MAX_HOURS</code> in bloodDrive.txt file. Also I don't see that you initialize <code>i</code> somewhere i suppose it should be  equal to 0 (<code>i=0</code>), so you're function should looks like that </p>

<pre><code>void getPints(double a[], int h)
{
    int i = 0;
    ifstream bloodInFile;

    bloodInFile.open(""bloodDrive.txt"");

    if (!bloodInFile)
        cout &lt;&lt; ""Cannot open file."" &lt;&lt; endl;

    while (!bloodInFile.eof())
    {
        if(i &gt; h)
            break;
        bloodInFile &gt;&gt; a[i];
        i++;
    }

    bloodInFile.close();
}
</code></pre>

<p>P.S. as @JonathanLeffler said (and I agree with him 100%) it's better to use dynamic array (<a href=""http://www.cplusplus.com/reference/vector/vector/"" rel=""nofollow noreferrer"">vector</a> e.g.) for such problem when you don't know how much input could be.</p>
",4
38092126,38091514,0,"<p>It appears that this <code>platform.h</code> attempts to use pre-defined macros to detect the target platform. However, it tries to use <code>_WINDOWS</code> macro to detect windows, which is apparently a pre-processor macro supported by the <a href=""http://www.ousob.com/ng/wcppug/ng91a37.php"" rel=""nofollow"">Watcom compiler</a>.</p>

<p>Your options:</p>

<ul>
<li>Since the library that you use apparently only supports the watcom compiler on windows, you could use that instead of visual studio. If you choose to use VS, there may be other issues down the line that need to be fixed to support it besides this one.</li>
<li>You could work around the issue by defining the macro yourself.</li>
<li>You could fix the header to work with visual studio by replacing <code>#elif _WINDOWS</code> with <code>#elif _WIN32</code>. See <a href=""https://msdn.microsoft.com/en-us/library/b0084kay.aspx"" rel=""nofollow"">macros pre-defined by visual studio</a>.</li>
</ul>

<p>I recommend going with the latter approach, however porting the library to VS may (or may not) involve a non-trivial amount of work.</p>
",0
48034712,48034633,1,"<p>2 / 3 is 0.666666666..., which is indeed closer to 0.67 than to 0.66. So if you want to the latter, you have to actually change the result. You can do this using a simple function:</p>

<pre><code>double truncate(double val, int precision)
{
  double shift = std::pow(10.0, precision);
  return std::trunc(val * shift) / shift;
}
</code></pre>
",0
48034714,48034633,2,"<p>Since you want truncation while <code>setprecision</code> uses rounding, you need to truncate the result manually:</p>

<pre><code>cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; trunc(100*result)/100;
</code></pre>

<p>Multiplying and dividing by 100 keeps two decimal digits in place.</p>

<p><a href=""https://ideone.com/k1b1Py"" rel=""nofollow noreferrer"">Demo.</a></p>

<p><strong>Note 1:</strong> You have to be careful not to pass numbers that are close to the top of <code>double</code>'s range to avoid overflowing on multiplication.</p>

<p><strong>Note 2:</strong> You can generalize this approach by multiplying and dividing by <code>pow(10,n)</code> where <code>n</code> is the number of decimal digits that you wish to keep.</p>
",0
48034716,48034633,0,"<p>You could try truncating with following:</p>

<pre><code>result = (int)( 100 * a / b ) / 100.0; 
</code></pre>
",0
44356416,44356033,-1,"<p>I don't think it makes sense to speak of function parameters as variables. They basically serve as placeholder for data you will provide to the function when you call it.</p>

<p>So, in your example you are not operating on <code>integerArray</code>, rather you are operating on the data pointed to by <code>int inputValues[128]</code>, which you declare in <code>main()</code>. <code>inputValue</code> is the variable, not <code>integerArray</code>.</p>

<p>In your case you happen to be doing what is called call-by-reference. I.e. your function prototypes are receiving a pointer to an integer. When you pass the pointer <code>inputValues</code> to readArray:</p>

<pre><code>int numberOfValues = readArray(inputValues, 128);
</code></pre>

<p>then you are giving it the address <code>inputValues</code>. <code>readValues</code> will then operate on the memory area pointed to by <code>inputValues</code>.</p>

<p>Thus, <code>displayArray</code> will display the data edited by <code>readArray</code> in your example.</p>

<p>Please note that this is a result of you doing a call-by-reference, not that the function parameters are in some sense in global scope.</p>

<p>If you function prototypes had looked something like this:</p>

<pre><code>int readArray (vector&lt;int&gt; integerArray);
void displayArray(vector&lt;int&gt; integerArray);
</code></pre>

<p>Then <code>displayArray</code> would not be printing the content of <code>integerArray</code> in any sense. When you call <code>readArray</code>, you would be doing a call by-value: It would get a copy of <code>inputValues</code> (in that case it would be declared as <code>vector&lt;int&gt; inputValues</code>) and when the function call returns, you are left with the original value of <code>inputValues</code> and in this particular case, <code>displayArray</code> would print an empty vector.</p>
",3
44356474,44356033,-2,"<p>No, they are not global. Functions create a local copy while receiving a parameter. You can verify this in C++ by creating your own class with a cout inside the copy constructor. Pass object of that class to a function(by value) and you will see the copy constructor being invoked. In C++, better way is to use std::array and std::vector. Also passing by value is not a wise idea for non-primitive types and huge data chunks. Always pass parameters by ""address"" (pointers) or by ""reference"" (you may want to read about std::ref)</p>
",8
44357660,44356033,0,"<p>Scope is about where names are visible. Names in global scope, for example, are visible from their point of declaration to the end of the translation unit in which they are declared; names in local scope are visible from their point of declaration to the end of the block in which they are declared (i.e., up to the closing <code>}</code>). The names of arguments in a function <strong>prototype</strong> are visible only in the prototype. The names of arguments that are passed to a function are visible throughout that function.</p>

<p>So, from your code:</p>

<pre><code>int readArray(int integerArray[], int maxNumElements);
</code></pre>

<p>The names <code>integerArray</code> and <code>maxNumElements</code> are not visible outside this prototype.</p>

<pre><code>int readArray(int integerArray[], int maxNumElements) {
    // ...
}
</code></pre>

<p>The names <code>integerArray</code> and <code>maxNumElements</code> are visible thoughout the function definition, but not outside it.</p>

<pre><code>int displayArray(int intgerArray[], int numElements) {
    // ...
}
</code></pre>

<p>The names <code>integerArray</code> and <code>numElements</code> are visible thoughout the function definition, but not outside it.</p>

<p>The three uses of the name <code>integerArray</code> have no connection to each other; it's as if each of them was a completely different name.</p>
",0
42661362,42661312,9,"<p>C and C++, unlike Java and C#, do not automatically zero-initialize memory or object members for performance reasons as there's no point overwriting memory twice if you're just going to set your own value anyway; the downside is you have to be very careful to ensure you don't use uninitialized data first.</p>

<p>To fix your problem, you can either set the member in the constructor, or in the initialization list:</p>

<pre><code>Trie() {
    this-&gt;color = 0;
    this-&gt;root  = nullptr;
}
</code></pre>

<p>Or:</p>

<pre><code>Trie() :
    color ( 0 ),
    root  ( nullptr )
{    
}
</code></pre>

<p>As for your <code>color</code> value, consider using a tuple instead because there are no guarantees that <code>int</code> will be a 32-bit integer (assuming you need to store 0-255 RGB values):</p>

<pre><code>struct RgbColor {
    uint8_t r;
    uint8_t g;
    uint8_t b;

    RgbColor() :
        RgbColor( 0, 0, 0 ) {
    }

    RgbColor(uint8_t r, uint8_t g, uint8_t b) :
        r(r),
        g(g),
        b(b) {
    }

    RgbColor(uint32_t rgb) :
        r( ( rgb &gt;&gt; 24 ) &amp; 0xFF ),
        g( ( rgb &gt;&gt; 16 ) &amp; 0xFF ),
        b( ( rgb &gt;&gt;  8 ) &amp; 0xFF ) {
    }
}
</code></pre>
",0
38396493,38396027,0,"<p>The first issue is that <code>Tsaved</code> only has enough space to contain one character. You need to allocate enough memory to hold the entire context of the text box. You can do this by calling <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms633521(v=vs.85).aspx"" rel=""nofollow"">GetWindowTextLength()</a> and <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms633520(v=vs.85).aspx"" rel=""nofollow"">GetWindowText()</a>:</p>

<pre><code>HWND hEditBox = GetDlgItem(IDC_EDIT1);
int len = GetWindowTextLength(hEditBox);

TCHAR* text = new TCHAR[len+1]; // need +1 to account for  trailing nullptr
GetWindowText(hEditBox, text, len);
</code></pre>

<p><code>text</code> should now contain the full text of the editbox. You can now write that to the file:</p>

<pre><code>std::ofstream inputfile(""filename.txt"");
inputFile &lt;&lt; text;
</code></pre>

<p>Since <code>text</code> was allocated using <code>new[]</code>, you will need to delete it as well:</p>

<pre><code>delete[] text;
</code></pre>

<p>Secondly, I don't know if your program is compiled as Unicode or not, but if it is <code>TCHAR</code> will be defined as <code>wchar_t</code> instead of <code>char</code>. Since it can contain non-ASCII characters, you should use <code>std::wofstream</code> instead of <code>std::ofstream</code>. The two classes have the same API, but the latter can handle all Unicode characters.</p>

<p>Finally, I don't know what version of Visual Studio you are using, but if it is a recent one you can replace the <code>new[]</code> and <code>delete[]</code> with a <a href=""https://msdn.microsoft.com/en-us/library/ee410601(v=vs.140).aspx"" rel=""nofollow"">unique_ptr</a> (which will automatically delete the allocated memory so you don't have to remember to do so):</p>

<pre><code>std::unique_ptr&lt;TCHAR[]&gt; text = std::make_unique&lt;TCHAR[]&gt;(len + 1);
GetWindowText(hEditBox, text.get(), len);

inputFile &lt;&lt; text.get();
</code></pre>
",2
38402637,38402573,2,"<p>Here <code>test.a()</code> is a call to <code>a</code> function whereas <code>test.a</code> is access to your object's public variable, both are different things.</p>

<p>Also, your syntax is incorrect it should be <code>class</code> instead of <code>Class</code>.</p>
",0
38402650,38402573,0,"<p>There is a big difference. <code>test.a</code> works, <code>test.a()</code> doesn't.</p>

<p><code>test.a()</code> is a function call, <code>a</code> in <code>class A</code> is not a function. </p>
",0
41918811,41918767,4,"<p>It is an infinite loop if you enter a number less than 95 because you never update x. What you meant to do was <code>a += 5</code>. Instead, after every time the loop does one iteration it will update <code>a</code> to be 5 greater than <code>x</code>, but since <code>x</code> is always the value the user inputted you never make any progress.</p>
",2
44356255,44356128,0,"<p>The problem is here:</p>

<pre><code>this-&gt;mas = (char*)realloc(this-&gt;mas, (this-&gt;n + 1) * sizeof(char));
this-&gt;mas = str;
</code></pre>

<p>The first line allocates memory, and makes <code>mas</code> point to that newly allocated memory. The second line makes <code>mas</code> point somewhere else completely. Here you should not just assign the pointer to point somewhere else, but <em>copy</em> the string using e.g. <a href=""http://en.cppreference.com/w/cpp/string/byte/strcpy"" rel=""nofollow noreferrer""><code>strcpy</code></a>.</p>

<p>With the code you have now, when you do</p>

<pre><code>b = ""ASD"";
</code></pre>

<p>you make <code>b.mas</code> point to the first character in the string literal. Then when you do</p>

<pre><code>b = a;
</code></pre>

<p>you use the pointer to the string literal in the <code>realloc</code> call, which is wrong since you have not allocated that memory through <code>malloc</code> or <code>realloc</code>.</p>

<hr>

<p>On another note, you should never assign right back to the pointer you passed to <code>realloc</code>. If <code>realloc</code> fails and returns a null pointer, you lose the original pointer and will have a memory leak.</p>
",0
41195020,41194977,10,"<p>""Iterator"" is some abstract concept, describing a certain set of operations a type must support with some specific semantics.</p>

<p>Pointers are iterators because they fulfill the concept <a href=""http://en.cppreference.com/w/cpp/concept/Iterator"" rel=""noreferrer"">iterator</a> (and, even stronger, <a href=""http://en.cppreference.com/w/cpp/concept/RandomAccessIterator"" rel=""noreferrer"">random access iterator</a>), e.g. the <code>operator++</code> to move to the next element and <code>operator *</code> to access the underlying element.</p>

<p>In your particular example, you get a standard iterator range with</p>

<pre><code>[p, p+1)
</code></pre>

<p>which can be used for example in the standard algorithms, like any iterator pair. (It may not be particularly useful, but it is still valid.) The above holds true for all ""valid"" pointers, that is pointers that point to some object.</p>

<p>The converse implication however is false: For example, consider the <code>std::list&lt;T&gt;::iterator</code>. That is still an iterator, but it cannot be a pointer because it does not have an <code>operator[]</code>.</p>
",4
45747870,45747819,0,"<p>I don't really understand your question, but when the compiler gives your variable a random number like 9255698272838000000, it's because you either didn't give this variable an initial value or assigned it to another variable that you didn't give an initial value.</p>
",2
45747874,45747819,0,"<p>By default, the compiler just allocates memory for the struct's members (or for any variable you create). It does not assign a value to them until you explicitly tell it to do so. For example, </p>

<pre><code>int i;
</code></pre>

<p>allocates an integer but does not give it a value. Because your computer's memory is constantly being passed around (but not zeroed-out) as programs execute and terminate by the operating system, the variable can contain literally any value before you assign it one. It is simply a region of memory, and it will probably contain whatever value it had when it was last used by a (different) program.</p>

<p>The following code:</p>

<pre><code>int i = 0;
</code></pre>

<p>will allocate a variable and assign it a value.</p>

<p>If you initialize your struct like so:</p>

<pre><code>traderecord order_temp = {};
</code></pre>

<p>the compiler will automatically zero-out your structure so all of its members are equal to zero. Then you can simply assign values to each member as it becomes necessary.</p>
",4
45747889,45747819,2,"<p>You should not use a variable without giving it a default value.
In C++ (unlike some other programming languages like Java) do not auto-initialize variables. So in your case, the integer will be in the stack with the value of whatever random data that was there. </p>
",1
46050344,46049480,1,"<p>in</p>

<pre><code>        for (int j = 0; j &lt; graph[i].size(); j++) {
            if (colors[graph[i][j]] == WHITE)
                ret = ret &amp;&amp; visit(graph, graph[i][j]);
            else if (colors[graph[i][j]] == GRAY)
                ret =  false;
            else
                ret =  false;
        }
</code></pre>

<p>The last else is when the node is BLACK, which means it already processed and pushed into the result. So it will not make the graph invalid. Just remove the last else, it will work. Like this:</p>

<pre><code>        for (int j = 0; j &lt; graph[i].size(); j++) {
            if (colors[graph[i][j]] == WHITE)
                ret = ret &amp;&amp; visit(graph, graph[i][j]);
            else if (colors[graph[i][j]] == GRAY)
                ret =  false;
            /* else
                ret =  false; */
        }
</code></pre>
",0
38290900,38290491,2,"<p>The biggest performance problems in your code are, in order of severity:</p>

<ul>
<li>Excessive memory allocations.</li>
<li>Unnecessary use of stringstream.</li>
<li>Failure to short-circuit after <code>t == 2</code>.</li>
<li>Unnecessary flush of <code>cout</code> (platform dependent).</li>
</ul>

<p>Something like this should be a lot faster:</p>

<pre><code>y.reserve(1000);
for (string aLine; getline(myFile, aLine); ) {
    string::size_type comma = aLine.find(',');
    if (comma == string::npos)
        continue;

    y.push_back(atof(aLine.c_str() + comma + 1));
    cout &lt;&lt; y.back() &lt;&lt; '\n';
}
</code></pre>
",2
38510785,38510487,0,"<p>To count the alpha characters you could do this:</p>

<p>Assuming <code>wrongletters</code> is an array container</p>

<pre><code>int count = 0;
for(int i = 0; i &lt; wrongletters.size(); i++)
    if(std::isalpha(wrongletters[i]))
        count++;
</code></pre>

<p>Now for your code, maybe you needed to check <code>wrongletters[i] != '0'</code> which will check for zero the <code>character</code> and not the <code>integer</code>.</p>
",0
38510569,38510487,1,"<blockquote>
  <p>I am trying to count how many values in the array <code>wrongLetters</code> are actually letters.</p>
</blockquote>

<p>Supposed you have something like </p>

<pre><code>std::string wrongLetters;

// input at wrongLetters
</code></pre>

<p>You can count the <em>alpha chars</em> like this</p>

<pre><code>size_t alphaChars = 0;
for(auto c : wrongLetters) { 
    if(std::isalpha(c)) ++alphaChars;
}
</code></pre>
",2
38193171,38193118,1,"<ol>
<li><p>You have declared strings for all the various fruits, but you don't assign any actual string values to them. ie <code>string cherries = ""cherries""</code></p></li>
<li><p>Just printing slot1 will only print an int as you have discovered. C++ doesn't know that you also want to print the name as well. You need to include your string as part of the cout statement</p></li>
</ol>
",0
42591774,42504592,7,"<p>I had same issue on different library that depends on flann and fixed by <a href=""https://github.com/mariusmuja/flann/issues/214"" rel=""noreferrer"">https://github.com/mariusmuja/flann/issues/214</a></p>

<blockquote>
  <p>We had a mysterious error in the serialization code if we included the flann headers after some opencv headers and used <code>g++ -std=c++11</code>. Changing the include order fixed the issue (including flann headers before any opencv headers). It seems that opencv headers leak <code>#define USE_UNORDERED_MAP 1</code> in case of std ¡Ý C++11. This then gets picked up by the <code>#if</code> in lsh_table.h in the original flann library.</p>
</blockquote>

<p>The solution is to include flann before OpenCV.</p>
",2
45042291,45042234,1,"<blockquote>
  <p>And the program knows that you're talking about the courseName variable. How is this possible since they are two different variables</p>
</blockquote>

<p>One was copied into the other, by virtue of passing it to a function.</p>

<p>This is how functions work. Consult the first couple of chapters of your C++ book for more info.</p>

<blockquote>
  <p>How does it tie in with the gradebook function class?</p>
</blockquote>

<p>It doesn't, at all. You simply passed a function argument.</p>
",0
39683981,39683963,-4,"<p>This takes a couple of seconds on my laptop.</p>

<pre><code>int main(){
    for(;;){
        int *a=new int[1000];
    }
}
</code></pre>
",3
48003460,48003359,1,"<p>I would say this generally depends on whether the a is of any use if the b allocation/initialization fails. If it's useless without b make it part of the ctor and let the exception propagate if either the b allocation or initialization fails. If a can be used without b then the b initialization can be put off.</p>
",0
38407100,38406933,0,"<p>The expectation is that a period, and exactly one period must come after all the amounts get printed out.</p>

<p>Therefore, it makes no logical sense to write complicated code that tries to figure out whether it should print a period before the rest of the code, for all the remaining denominations, is done.</p>

<p>Just get rid of that code that prints all those periods, inside all of those awkward if/else statements.</p>

<p>At the very end of everything, simply execute</p>

<pre><code>std::cout &lt;&lt; ""."";
</code></pre>

<p>No <code>if</code>s, <code>else</code>s, or buts.</p>

<p>Simply focus on the problem of writing out the counts of all the denominations, correctly separated by commas. Forget about the trailing period. Just focus on formatting a comma-separated list of all possible denominations. Put the trailing period out of your mind.</p>

<p>Then, once you get all of that working, simply append</p>

<pre><code>std::cout &lt;&lt; ""."";
</code></pre>

<p>at the end, and call it a day. This is a 100% guaranteed, or your money back, way to end up with exactly one period at the end of your output.</p>
",3
44377501,44377405,3,"<p>This is not correct</p>

<pre><code>grWert[3] = 70+(rand()%41);
</code></pre>

<p>your array is 3 is in size, but index is then 0-2, 3 will go past end of array.</p>
",0
38875363,38874990,-1,"<p>You can split the string and get root name of domain. </p>

<p>I will suggest you to try regular expression like this</p>

<p><code>(/^http?\:\/\/([^\/?#]+)(?:[\/?#]|$)/i);</code></p>

<p><code>(/^https?\:\/\/([^\/?#]+)(?:[\/?#]|$)/i);</code></p>

<p><code>(/^https?\:\/\/(?:www\.)?([^\/?#]+)(?:[\/?#]|$)/i);</code></p>
",0
42639802,42639401,0,"<p>If you are asking how to accept a string with spaces from user input, then you need to user the <a href=""http://www.cplusplus.com/reference/string/string/getline/"" rel=""nofollow noreferrer"">getline() function</a>. </p>

<pre><code>getline(cin,variableToStoreIn);
</code></pre>

<p>If your question is about inheritance, please reword your question for clarity.</p>
",0
38302434,38302347,0,"<p>If you are representing your user input's choice with a character, read it into a <code>char</code>.  </p>

<p>Dispatch based on their choice:  </p>

<pre><code>char choice;
if (cin &gt;&gt; choice) {
  switch (choice) {
  case 'a':
    money -= 50;
    break;
  case 'b':
    money -= 100;
    break;
  case 'c':
    money -= 500;
    break;
  case 'd':
    money -= 500;
    break;
  default:
    std::cerr &lt;&lt; ""invalid choice"";
  }
} else {
  std::cerr &lt;&lt; ""invalid choice"";
}
</code></pre>
",4
38302705,38302347,1,"<p>You must modify your code to make it logical and readable.
I write this for you.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
int age, money;
int priceA = 50, priceB = 100, priceC = 500, priceD = 500;
char choice;

cout &lt;&lt; ""How old are you?"" &lt;&lt; endl;
cin &gt;&gt; age;
if (age &lt;= 12) {
    cout &lt;&lt; ""Not for kids. Sorry!"" &lt;&lt; endl;
    return 0;
}

cout &lt;&lt; ""How much money do you have?"" &lt;&lt; endl;
cin &gt;&gt; money;
if (money &lt;= 50) {
    cout &lt;&lt; ""Sorry not enough"" &lt;&lt; endl;
    return 0;
}

cout &lt;&lt; ""Here are the items you can buy"" &lt;&lt; endl;
cout &lt;&lt; "" a = $ "" &lt;&lt; priceA &lt;&lt; "" Bat"" &lt;&lt; endl;
cout &lt;&lt; "" b = $ "" &lt;&lt; priceB &lt;&lt; "" Bat"" &lt;&lt; endl;
cout &lt;&lt; "" c = $ "" &lt;&lt; priceC &lt;&lt; "" Bat"" &lt;&lt; endl;
cout &lt;&lt; "" d = $ "" &lt;&lt; priceD &lt;&lt; "" Bat"" &lt;&lt; endl;

cin &gt;&gt; choice;

switch (choice) {
  case 'a':
    if(money &gt;= priceA) {
    money -= priceA;
    break;
    } else {
    cout &lt;&lt; ""You have not enough money!"" &lt;&lt; endl;
    return 0;
    }
  case 'b':
    if(money &gt;= priceB) {
    money -= priceB;
    break;
    } else {
    cout &lt;&lt; ""You have not enough money!"" &lt;&lt; endl;
    return 0;
    }
  case 'c':
    if(money &gt;= priceC) {
    money -= priceC;
    break;
    } else {
    cout &lt;&lt; ""You have not enough money!"" &lt;&lt; endl;
    return 0;
    }
  case 'd':
    if(money &gt;= priceD) {
    money -= priceD;
    break;
    } else {
    cout &lt;&lt; ""You have not enough money!"" &lt;&lt; endl;
    return 0;
    }
  default:
    cout &lt;&lt; ""Wrong input"" &lt;&lt; endl;
    return 0;
 }

cout &lt;&lt; ""You have "" &lt;&lt; money &lt;&lt; "" left"" &lt;&lt; endl;

return 0;
}
</code></pre>
",2
38288609,38288531,3,"<p><code>&amp;books.size</code> is not a valid expression.</p>

<p><code>size</code> is a member function of <code>std::vector</code>. To call the member function, you need to use <code>books.size()</code>. </p>

<p>The presence of <code>&amp;</code> in that expression leads the compiler to think that perhaps you are trying to get a pointer to the member function of the class, which can be obtained using <code>&amp;std::vector&lt;Book&gt;::size</code>. However, you cannot get a pointer to a member function of the class using an object of the class. That is the translation of the message <strong><em>'&amp;' illegal operation on bound member function error</em></strong> to plain English.</p>
",4
44378771,44378547,0,"<p>It is exploiting the fact that the <code>*</code> goes with the name, not the type.</p>

<p>i2 is declared as an integer by the question above this one</p>

<pre><code>int* ip, ip2;
</code></pre>

<p>not a pointer. So </p>

<pre><code> int *const p2 = &amp;i2;
</code></pre>

<p>p2 is assigned the address of i2, a pointer. 
The const pointer of p2 does not come in to play unless you try and change the value of p2.</p>
",0
38290083,38289922,0,"<p>I think <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms686025(v=vs.85).aspx"" rel=""nofollow"">SetConsoleCursorPosition</a> is what you're looking for.</p>
",0
38290121,38289922,1,"<p>the question needs further clarification but if you want to output numbers in a growing fashion to a console, you can use carriage return after each iteration and then sleep</p>

<p>the following example demonstrates how to do it in ubuntu using stdio and unistd:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;unistd.h&gt;

int main()
{
    int i = 0;
    for(;i &lt; 10; ++i)
    {
        printf(""\b%d"", i);
        fflush(stdout);
        sleep(1);
    }
}
</code></pre>

<p>hope this helps</p>
",0
45279607,45279579,4,"<p>You're not really asking about how to destroy a ""built-in type"" but rather how to destroy an object with automatic or static <em>storage duration</em>. And that you can't do: the behaviour of your code is <em>undefined</em>.</p>

<p>You can only call <code>delete</code> on a pointer that's given back to you as a result of a call to <code>new</code>.</p>

<p>Your approach is therefore an ineffective memory saving technique.</p>
",4
45279665,45279579,0,"<p>The simple built-in types do not need any destruction - you can just overwrite their memory with whatever you like. This will not have any negative effects when the variable's lifespan ends. <strong>However</strong> note that such variables - like <code>h</code> in your example - typically live on the stack, so that place in memory will get used by some other function's variables and you can't reserve it for your own use.</p>

<p>I think you might be confusing <em>free</em>ing allocated memory and <em>destroying</em> an object.</p>
",2
45280167,45279579,2,"<p>As said in the other answer, you can't manually destroy a built-in type(*).</p>

<p>However, you can reduce the scope where it's defined:</p>

<pre><code>int foo = 3;
...
{
    int bar = foo + 2;
    ...
}
// bar is not defined since it's been ""destroyed"" 
// when going out of scope
</code></pre>

<p>Here you create a anonymous scope. From this scope, you can access variable
defined in the parent scope but once you go out of anonymous scope, each variables defined in it is destroyed.</p>

<p><strong>EDIT</strong>:</p>

<p>(*) You can <em>delete</em> a dynamically allocated built-in type (<code>int * p = new int(); delete p;</code>) but you can't <em>destroy</em> them since they don't have a destructor.</p>
",2
38415157,38415107,1,"<p>You have an undefined behaviour because you use the address of a local variable <code>null</code> which is destroyed once your function <code>makeEmptyLine()</code> returns.</p>

<p>Does your compiler complain when you try to compile it with the highest warning level?</p>
",0
38620194,38620063,0,"<p>I would not, except if the <code>#include ""APIManager.h""</code> might not be in header.</p>

<p><code>&lt;string&gt;</code> might be included in <code>&lt;iostream&gt;</code>, but you should include <code>&lt;string&gt;</code> anyway even if your library include include it and you use <code>&lt;iostream&gt;</code></p>
",0
38620218,38620063,0,"<p>Include headers where they're needed.</p>

<p>You should include them in a header file if your class definition includes objects defined in the header you're including.  If you're only using the contents of a header in the cpp, then include it in the cpp.</p>

<p>Never include the same external header in both file.h and file.cpp if file.cpp also includes file.h.</p>
",0
38620117,38620063,2,"<p>This is basically a style question, but:</p>

<p>No you shouldn't include it in the cpp <em>and</em> the header. It's overly verbose and no one does it.</p>
",0
38620235,38620063,2,"<p>If the source file is Environment.cpp, where you are implementing what you declared in Environment.h, then no, you should not reinclude it.</p>

<p>If on the other hand, the source file is SomeOtherFile.cpp where you are simply using the declarations from Environment.h, and you are going to use the declarations from APIManager.h separately and independently of their usage as part of Environment.h, then yes, you should. You wouldn't want a future change which removes <code>#include &lt;Environment.h&gt;</code> from SomeOtherFile.cpp to break it unexpectedly. </p>

<p>In other words, if SomeOtherFile.cpp has a direct dependence on APIManager.h, then that dependence should be directly expressed via a #include.</p>
",0
41685448,41685346,7,"<p>I think what you're looking for is <code>boost::optional</code>.</p>

<pre><code>#include &lt;boost/optional.hpp&gt;
</code></pre>

<p>...</p>

<pre><code>boost::optional&lt;int&gt; maybe_int;
</code></pre>

<p>...</p>

<pre><code>if (maybe_int) // test if it has been assigned to
{
    if (maybe_int.value() == 0) // has is been set to zero?
    {
        // ...
    }
}    
</code></pre>
",0
41685527,41685346,4,"<p>I think you're making a conceptual mistake here. Even though <code>NULL</code> is defined as 0 somewhere, this does not mean they are the same on a conceptual level.</p>

<p><code>NULL</code> is a pointer with (usually) the value <code>0</code>. By convention, there cannot be an object at <code>NULL</code>. We can therefore use code such as <code>MyClass *obj = NULL;</code> to specify that there is no object at <code>obj</code>. This works because <code>obj</code> is a pointer.</p>

<p>For non-pointer types, this does not work and we need to use other tools such as arbitrarily defining one value as invalid (often <code>-1</code>is used for this) or using <a href=""http://en.cppreference.com/w/cpp/utility/optional"" rel=""nofollow noreferrer"">optionals</a>.</p>
",0
41928705,41928680,4,"<p>The only real downside might be if you want your code to be portable to a system that doesn't <em>have</em> a 32-bit integer type. In practice those are pretty rare, but they are out there.</p>

<p>C++ has access to the C99 (and newer) integer types via <a href=""http://en.cppreference.com/w/cpp/header/cstdint"" rel=""nofollow noreferrer""><code>cstdint</code></a>, which will give you access to the <code>int_leastN_t</code> and <code>int_fastN_t</code> types which might be the most portable way to get specific bit-widths into your code, should you really happen to care about that.</p>
",2
41928710,41928680,2,"<p>The original intent of the <code>int</code> type was for it to represent the natural size of the architecture you were running on; you could assume that any operations on it were the fastest possible for an integer type.</p>

<p>These days the picture is more complicated. Cache effects or vector instruction optimization might favor using an integer type that is smaller than the natural size.</p>

<p>Obviously if your algorithm requires an <code>int</code> of <em>at least</em> a certain size, you're better off being explicit about it.</p>
",3
41928746,41928680,0,"<p>E.g.</p>

<p>To save space, use <code>int_least32_t</code></p>

<p>To save time, use <code>int_fast32_t</code></p>

<p>But in actuality, I personally use <code>long</code> (at least 32-bit) and <code>int</code> (at least 16-bit) from time to time simply because they are easier to type.</p>

<p>(Besides, <code>int32_t</code> is optional, not guaranteed to exist.)</p>
",0
38391263,38390588,0,"<p>In my company I used the boost library to read from a COM port. It includes the <code>boost::asio::serial_port</code> class to handle this kind of communication.</p>

<p>I used this <a href=""https://gist.github.com/yoggy/3323808"" rel=""nofollow"">code snippet</a> for orientation and wrote my own wrapper class, for the needs of the project I was in. </p>
",0
38391364,38390588,0,"<p>You can take this:</p>

<p><a href=""http://www.codeproject.com/Articles/992/Serial-library-for-C"" rel=""nofollow"">http://www.codeproject.com/Articles/992/Serial-library-for-C</a></p>

<p>Or if you use Qt, i think there is also a lib from Qt to do this.</p>
",0
41920610,41920381,0,"<p>You can try obtaining information about where's your binary located using <code>fstat(2)</code> on <code>argv[0]</code>.</p>

<p>It's not C++ specific, it works in plain C as well.</p>

<p>After that you may want to enumerate USB devices connected to the system, this operation is OS-dependent (for Linux, e.g., the answer can be found <a href=""https://stackoverflow.com/questions/24722076/check-if-certain-usb-flash-memory-is-connected-to-my-system"">here</a>).</p>
",0
41921225,41920381,0,"<p>Using the <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ff551967(v=vs.85).aspx"" rel=""nofollow noreferrer"">SetupDiGetDeviceRegistryProperty</a> function you get what you want to know.</p>

<p>This may be also interesting for you: <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa364939(v=vs.85).aspx"" rel=""nofollow noreferrer"">GetDriveType</a> function documented on Microsoft developer resources.</p>

<p>The current drive letter you get from <code>argv [0]</code>.</p>
",0
43223098,43222867,2,"<p>I think you need,</p>

<pre><code>cin &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; a;
</code></pre>
",0
43222966,43222867,4,"<p>I think you have trying to scan multiple variables. So, Use: </p>

<pre><code>cin&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;a;
</code></pre>

<p>Full example:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int addNumbers(int x, int y, int z, int a) {
  int result = x + y + z + a;
  return result;
}

int main() {
int x,y,z,a;
cin&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;a;
int result = addNumbers(x,y,z,a);
cout&lt;&lt;result&lt;&lt;endl;

return 0;
}
</code></pre>
",3
38402700,38402641,0,"<p>You have missed some <code>;</code> in the code (and a few others). Try this version:</p>

<pre><code>using namespace std;

int main(int argc, char *argv[])
{

    int SIZE = 10;
    int NUMBERS[SIZE];

    int temp;

    for(int i = 0; i&lt; SIZE - 2; i++)
    {
           for(int j = 0; j &lt; SIZE - 2; j++)
           {
                  if(NUMBERS[j] &lt; NUMBERS[j + 1])
                  {
                  temp = NUMBERS[j];
                  NUMBERS[j] = NUMBERS[j+1];
                  NUMBERS[j+1] = temp;
                  }
           }
    }

    cout &lt;&lt; ""Sorted list"";
    cout &lt;&lt; ""==========="";

    for(int i = 0; i &lt; SIZE - 1; i++)
    {
        cout &lt;&lt; ""Number "", i + 1, "": "", NUMBERS[i];
    }


    system(""PAUSE"");
    return EXIT_SUCCESS;
}
</code></pre>

<p>Please consider that you should initialize the <code>NUMBERS</code>.</p>
",5
38402707,38402641,-1,"<p>Try :</p>

<pre><code>for(i = 0; i &lt;= (SIZE - 2); i++)
{
       for(j = 0; j&lt;=(SIZE - 2); j++)
       {
              if(NUMBERS[j] &lt; NUMBERS[j + 1])
              {
              temp = NUMBERS[j];
              NUMBERS[j] = NUMBERS[j+1];
              NUMBERS[j+1] = temp;
              }
       }
}
cout &lt;&lt; ""Sorted list"";
cout &lt;&lt; ""==========="";

for(int i = 0; i &lt;= SIZE - 1; i++)
{
    cout &lt;&lt; ""Number "", (i + 1), "": "", NUMBERS[i];
}
system(""PAUSE"");
return EXIT_SUCCESS;
</code></pre>
",1
36249036,36248850,2,"<p>You do not initialize <code>root</code> in your constructor.</p>

<blockquote>
  <p>Every time the program jump into a new loop, the rbt should be a totally new object.</p>
</blockquote>

<p>The object is <em>constructed</em> each time.  But the memory is <em>probably</em> at the same address each time through the loop (this is not a guarantee).  And since you don't initialize <code>root</code>, you're seeing some undefined behavior, which again is <em>probably</em> keeping the last value from the loop...but would be sensitive to conditions of compilation, debugging, optimization...</p>

<p><a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Undefined_behavior</a></p>

<blockquote>
  <p>Another weird thing is that when I run the program with code RedBlackTree rbt; in Window7, the result is right. When using Ubuntu, it shows the problem above.</p>
</blockquote>

<p>This is the kind of thing that happens with undefined behavior.</p>

<blockquote>
  <p><code>rbt-&gt;insert(array[n])</code></p>
</blockquote>

<p>As @SergeyTachenov has pointed out, this likely won't compile since your RedBlackTree is not a pointer in the given code (so would have to be <code>rbt.insert(array[n])</code>.  It is probably an artifact of you copying something halfway between the pointer-based version and the non-pointer based one.</p>

<p>Posting a complete and coherent example is important, so please read about <a href=""https://stackoverflow.com/help/mcve"">MCVE: Minimal, Complete, Verifiable Examples</a>.  The code in your question should ideally compile as-is <a href=""http://coliru.stacked-crooked.com/"" rel=""nofollow noreferrer"">in an online compiler</a> and clearly demonstrate your problem.</p>
",4
38856570,38856390,2,"<p>When you try to fill in a Sudoku grid with appropriate values, you eventually end up in deadlocks : situations where the cell you are trying to find a value for cannot be filled in without breaking Sudoku rules. As a simple example, consider a grid where the first row is <code>[x, 2, 3, 4, 5, 6, 7, 8, 9]</code> and the first column is <code>[x, 1, 8, 2, 3, 4, 5, 6, 7]</code>. x cannot be filled in, but all of the other values follow the rules.</p>

<p>In your case, when a deadlock happens, the <code>ok</code> condition isn't fulfilled by any of the values from 1 to 9 and the execution goes back one layer of recursion, to the previous cell, where a value has already been chosen. There, the function tries the next possible value.</p>

<p>In the case of a deadlock on a cell that has had a value (that is, a multiple-level deadlock), the execution goes back one layer of recursion again, but the value is still there. That causes subsequent <code>ok</code> conditions to fail when they should succeed, because of these ""ghost"" values. The problem doesn't occur for a simple deadlock because the value stays 0.</p>

<p>After the <code>for</code> loop, you need to set the value of <code>board[row][col]</code> back to 0.</p>
",12
38508255,38508079,0,"<p>Template are evaluated at compile time. Run-time <code>if</code> statements don't protect the code being run, as the compiler can't guarantee that the path won't be taken.</p>

<p>As of C++17 you would be able to use <code>constexpr</code> <code>if</code>, but meanwhile, you have to write different specializations for it (or even overloads, you don't even need a template):</p>

<pre><code>bool get_map_value(const wstring &amp;map_key, wstring&amp; map_value)
{
    auto tmp = my_data.find(map_key);

    if (tmp == my_data.end())
        return false;

    map_value = tmp-&gt;second;

    return true;
}

bool get_map_value(const wstring &amp;map_key, double&amp; map_value)
{
    auto tmp = my_data.find(map_key);

    if (tmp == my_data.end())
        return false;

    map_value = _wtof(tmp-&gt;second.c_str());    

    return true;
}

bool get_map_value(const wstring &amp;map_key, int&amp; map_value)
{
    auto tmp = my_data.find(map_key);

    if (tmp == my_data.end())
        return false;

    map_value = _wtoi(tmp-&gt;second.c_str());

    return true;
}
</code></pre>
",0
38508401,38508079,2,"<blockquote>
  <p>What is wrong</p>
</blockquote>

<p>The type of <code>tmp-&gt;second</code> is <code>wstring</code>. When the template is instantiated with <code>T = int</code>, then the type of <code>map_value</code> is <code>int&amp;</code>. The line</p>

<blockquote>
<pre><code>map_value = tmp-&gt;second;
</code></pre>
</blockquote>

<p>Has pretty self explanatory error message</p>

<blockquote>
<pre><code>Error C2440   '=': cannot convert from 'std::wstring' to 'int'
</code></pre>
</blockquote>

<p><code>std::wstring</code> is not implicitly convertible to <code>int</code>. That is the problem. You must remember that the entire function must be well formed, even if execution cannot reach some part of it.</p>

<hr>

<blockquote>
  <p>how can I solve that?</p>
</blockquote>

<p>What you need is just a few overloads. We shall refactor the differing part of the function, so that you don't need to repeat the identical part.</p>

<pre><code>parse_value(int&amp; variable, const std::wstring&amp; value) {
    variable = _wtoi(tmp-&gt;second.c_str());
}
parse_value(double&amp; variable, const std::wstring&amp; value) {
    variable = _wtof(tmp-&gt;second.c_str());
}
parse_value(std::wstring&amp; variable, const std::wstring&amp; value) {
    variable = value;
}

template&lt;class T&gt;
bool get_map_value(const wstring &amp;map_key, T&amp; map_value)
{
    auto tmp = my_data.find(map_key);

    if (tmp == my_data.end())
        return false;

    parse_value(map_value, tmp-&gt;second);

    return true;
</code></pre>

<p>}</p>
",0
38508299,38508079,0,"<p>First, remove these ugly <code>typeid()</code>s... And use SFINAE instead.</p>

<pre><code>template &lt;typename T, std::enable_if_t&lt;std::is_floating_point&lt;T&gt;::value&gt;* = nullptr&gt;
bool get_map_value(std::wstring const&amp; map_key, T&amp; map_value) {
    auto const val = std::find(my_data.cbegin(), my_data.cend(), map_key);
    if (val != std::cend(my_data)) {
        map_value = _wtof(val.second);
        return true;
    } else {
        return false;
    }
}
</code></pre>

<p>Similarly, you then add another definition for integral types:</p>

<pre><code>template &lt;typename T, std::enable_if_t&lt;std::is_integral&lt;T&gt;::value&gt;* = nullptr&gt;
bool get_map_value(std::wstring const&amp; map_key, T&amp; map_value) {
    auto const val = std::find(my_data.cbegin(), my_data.cend(), map_key);
    if (val != std::cend(my_data)) {
        map_value = _wtoi(val.second);
        return true;
    } else {
        return false;
    }
}
</code></pre>

<p>And finally a simple overload for <code>std::wstring</code>:</p>

<pre><code>bool get_map_value(std::wstring const&amp; map_key, std::wstring&amp; map_value) {
    auto const val = std::find(my_data.cbegin(), my_data.cend(), map_key);
    if (val != std::cend(my_data)) {
        map_value = val.second;
        return true;
    } else {
        return false;
    }
}
</code></pre>
",0
44230758,44230649,-1,"<p>There must be an run-time error message displayed too with it as your loop is never ending. you should take an char variable too and add else </p>

<pre><code>if(cin&gt;&gt;ch) cout&lt;&lt;ch else  break 
</code></pre>

<p>statement.</p>
",2
44230777,44230649,-1,"<p>You could try to get the line:</p>

<pre><code>std::string line;

std::getline( std::cin, line );
</code></pre>
",1
44231136,44230649,0,"<p>Character (such as '+') cannot be stored in a variable of the double type. Thus they are thrown away. If you want to be able to get the whole line, you'll need to use a std::string.</p>

<p>Then, if you are building a calculator, you'll need to go through the string and separating it's components into smaller subcomponent and calculate them accordingly.</p>
",0
45709820,45709665,0,"<blockquote>
  <p>If the key always goes left, when the function insert_all() runs to the position node = new Node(key) , whether the node is equivalent to header->left->left->left->left->left->......->left->left</p>
</blockquote>

<p>No, in the below call you are not changing <code>node</code> parameter which you received.You are just calling <code>insert_real()</code> with some other parameter.</p>

<pre><code>return insert_real(key, node-&gt;left);
</code></pre>

<p>The only time you change <code>node</code> is below</p>

<pre><code>if (node == nullptr)
    return node = new Node(key);
</code></pre>
",0
47651261,47651203,2,"<p>By means of <code>std::move()</code> you can perform an <em>unconditional</em> cast to a <em>rvalue</em>.</p>

<pre><code>fn(std::move(p[42]));
</code></pre>

<p>The name <code>move</code> is actually misleading here: nothing is being moved, but a cast is being performed.</p>

<hr>

<p>Consider then writing a pointer template <code>Ptr</code> whose operators <code>*</code> and <code>[]</code> are overloaded to return a rvalue:</p>

<pre><code>#include &lt;utility&gt;

class Foo {};

template&lt;typename T&gt;
class Ptr {
public:
    Ptr(T* ptr): ptr_{ptr} {}
    T&amp;&amp; operator*() { return std::move(*ptr_); }
    T&amp;&amp; operator[](int idx) { return std::move(*(ptr_ + idx)); }
private:
    T* ptr_;
};

void fn(Foo&amp;&amp; x) { return; }
void fn(const Foo&amp; x) { return; }

int main()
{
    Foo foo[50];
    Ptr&lt;Foo&gt; p{&amp;foo[0]};

    // call void fn(Foo&amp;&amp;)
    fn(p[42]);
}
</code></pre>
",1
47652251,47651203,0,"<p>The type of result of pointer dereferencing, that is type result of some overloaded operator can not depend of some information stored at pointer object at runtime because its signature is defined at compile-time. However it possible to overload operator based on pointer origin:</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;cstddef&gt;

template&lt;typename TItems&gt;
class t_FancyPointer;

template&lt;typename TItems&gt;
class t_FancyPointer&lt;TItems[]&gt;
{
    private: TItems * m_p_items;

    public: explicit
    t_FancyPointer(TItems * p_items) : m_p_items{p_items} {}

    public: TItems &amp;
    operator [](::std::size_t const index) &amp;
    {
        return(m_p_items[index]);
    }

    public: TItems &amp;&amp;
    operator [](::std::size_t const index) &amp;&amp;
    {
        return(::std::move(m_p_items[index]));
    }
};

void
fn(::std::string &amp;&amp;)
{
    ::std::cout &lt;&lt; ""rvalue reference"" &lt;&lt; ::std::endl;
}

void
fn(::std::string &amp;)
{
    ::std::cout &lt;&lt; ""lvalue reference"" &lt;&lt; ::std::endl;
}

::std::string items[4];
t_FancyPointer&lt;::std::string[]&gt; perma_storage{items};

t_FancyPointer&lt;::std::string[]&gt; &amp;
Get_PermaStorage(void)
{
    return(perma_storage);
}

t_FancyPointer&lt;::std::string[]&gt;
Get_TempStorage(void)
{
    return(t_FancyPointer&lt;::std::string[]&gt;{items});
}

int main()
{
    // calls fn(::std::string &amp;)
    fn(Get_PermaStorage()[42]);
    // calls fn(::std::string &amp;&amp;)
    fn(Get_TempStorage()[42]);
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>lvalue reference
rvalue reference
</code></pre>

<p>If you just want to always return &amp;&amp; then you can define a single operator [] returning an rvalue reference:</p>

<pre><code>public: TItems &amp;&amp;
operator [](::std::size_t const index)
{
    return(::std::move(m_p_items[index]));
}
</code></pre>

<p>Though I have no idea why would you do something like this.</p>
",1
39680481,39680287,0,"<p>A general answer for many performance-related questions is ""measure it and see for yourself"". If it's easy, just do it. In this case, it <strong>is</strong> easy.</p>

<p>Sometimes, it's good to look at assembly code - if the code is identical in your two cases (I guess it is), you don't even need to measure its performance.</p>
",2
39680730,39680287,2,"<p>The standard has very little to say about performance but there is one clear rule, that optimizations must not change observable side effects.</p>

<p>The standard does not describe stack or heap usage, so it would be perfectly legitimate for a compiler to allocate space for a variable on the stack at any point prior to its use.</p>

<p>But optimal would depend on various factors. On the most common architectures, it makes most sense to do all your stack pointer adjustments in just 2 places - entry and exit. There is no cost difference on an x86 to changing the stack pointer by 640 instead on 8.</p>

<p>Further, if the compiler can be sure the value doesn't change, then the optimizer may be able to hoist the assignment out of the loop too.</p>

<p>In practice, mainstream compilers (gcc, clang, msvc) on x86 and arm based platforms will aggregate stack allocations into single up and downs, and hoist loop invariants given sufficient optimizer settings/arguments.</p>

<p>If in doubt, inspect the assembly or benchmark.</p>

<p>We can very quickly demonstrate this with <a href=""http://gcc.godbolt.org/"" rel=""nofollow"">godbolt</a>:</p>

<pre><code>#include &lt;vector&gt;

struct Channel
{
  void test(int&amp;);
};

std::vector&lt;Channel&gt; channels;

void test1()
{
  while (!channels.empty())
  {
    for (auto&amp;&amp; channel : channels)
    {
      int stop_time;
      channel.test(stop_time);
    }
  }
}

void test2()
{
  while (!channels.empty())
  {
    int stop_time;
    for (auto&amp;&amp; channel : channels)
    {
      channel.test(stop_time);
    }
  }
}

void test3()
{
  int stop_time;
  while (!channels.empty())
  {
    for (auto&amp;&amp; channel : channels)
    {
      channel.test(stop_time);
    }
  }
}
</code></pre>

<p>With GCC 5.1 and -O3 this <a href=""http://gcc.godbolt.org/#compilers:!((compiler:g510,options:&#39;-O3+-Wall+-std%3Dc%2B%2B1z+-march%3Dnative+-mtune%3Dnative&#39;,sourcez:AQ4YgSwOwYwGwK4BMCmwA8A3FMAuB7AJwD4AoU0YAZ10IT2AGEALAQyihTgtAG8fKmfBCTBcKGgApouAGQBKANwDgAX2UqaSAFzbseIuhbtOcYsBhsOXKhsHDR4mgEZJ8lf0ogA7swhw0SQBCSxMbADoUAFsAB1wATzd3L2BPFOAAMyJgSVYEAllZCytTYG1isLgqZPS09OAZagIYgH1cCCiUZXqQUOs4cKdcSRp8VvbOpRVKVWm1FVmVIRExCVwAJjcPOd9/QJCSiOi4xPkayjqvRtHxjq65kCzCHLyCor7S8o%2Bbc69LlO%2BAyGI2abTuU3qsxSUNAi3sKyGAGYthc5tdQRN7ildgEcgdKlRIrEEkk5v9QE8Xvl8IUKv0ynTTNUHqkWb1DkC1iCxmDJt10jCZgtyEAAA)),filterAsm:(colouriseAsm:!t,commentOnly:!t,directives:!t,labels:!t),version:3"" rel=""nofollow"">generates three identical pieces of assembly</a>:</p>

<pre><code>    test1():
            pushq   %rbp
            pushq   %rbx
            subq    $24, %rsp
    .L8:
            movq    channels+8(%rip), %rbp
            movq    channels(%rip), %rbx
            cmpq    %rbp, %rbx
            je      .L10
    .L7:
            leaq    12(%rsp), %rsi
            movq    %rbx, %rdi
            addq    $1, %rbx
            call    Channel::test(int&amp;)
            cmpq    %rbx, %rbp
            jne     .L7
            jmp     .L8
    .L10:
            addq    $24, %rsp
            popq    %rbx
            popq    %rbp
            ret

    test2():
            pushq   %rbp
            pushq   %rbx
            subq    $24, %rsp
    .L22:
            movq    channels+8(%rip), %rbp
            movq    channels(%rip), %rbx
            cmpq    %rbp, %rbx
            je      .L20
    .L14:
            leaq    12(%rsp), %rsi
            movq    %rbx, %rdi
            addq    $1, %rbx
            call    Channel::test(int&amp;)
            cmpq    %rbx, %rbp
            jne     .L14
            jmp     .L22
    .L20:
            addq    $24, %rsp
            popq    %rbx
            popq    %rbp
            ret

    test3():
            pushq   %rbp
            pushq   %rbx
            subq    $24, %rsp
    .L26:
            movq    channels+8(%rip), %rbp
            movq    channels(%rip), %rbx
            cmpq    %rbp, %rbx
            je      .L28
    .L25:
            leaq    12(%rsp), %rsi
            movq    %rbx, %rdi
            addq    $1, %rbx
            call    Channel::test(int&amp;)
            cmpq    %rbx, %rbp
            jne     .L25
            jmp     .L26
    .L28:
            addq    $24, %rsp
            popq    %rbx
            popq    %rbp
            ret
</code></pre>
",0
40572140,40571923,0,"<p>In your code i find several mistake.</p>

<ul>
<li>your char array <code>word1</code>,<code>word2</code>,<code>temp</code> isn't initialize properly.you need to increase <code>size</code> of <code>array</code>.</li>
<li>in loop you use 3.it will break your output if your word's length become grater than 4.</li>
</ul>

<p>So here i give you little solution.But its better use <code>user input</code> as a size of <code>array</code> so that any input can match properly.</p>

<pre><code>#define _CRT_SECURE_NO_WARNINGS

#include &lt;cstring&gt;
#include &lt;iostream&gt;

using namespace std;

int main() {

    char word1[10][10] = { ""Hello"", ""Bonjour"", ""Ni Hao"" };//increase array size to fit word
    char word2[10][10] = { ""Steve"", ""Pei"", ""Frank"" };//same here

    char temp[10] = """";//same here

    for (int i = 0; i &lt; 10; i++) {
        strcpy(temp, word1[i]);
        strcpy(word1[i], word2[i]);
        strcpy(word2[i], temp);
    }


    for (int i = 0; i &lt;10; i++) {
        cout &lt;&lt; word2[i] &lt;&lt; "" "";
    }

    cout &lt;&lt; endl;
}
</code></pre>
",0
47486032,47485593,0,"<p>Now I know any variable declared outside a function is a global variable though it is in another *.cpp file. So the line <code>int i=sayHello();</code> will be executed before call <code>main()</code>.</p>
",0
47488191,47485593,0,"<p>When after the program is being complied the variables are initialized. As part of this it is calling your <code>int i=sayHello();</code> before int main() is called.</p>

<p>Hopes this helps!</p>
",0
42568523,42568175,0,"<p>Break down your task to smaller tasks and them achieve each small task in c++. You basically want:</p>

<ol>
<li><p>To find the smallest item of an array <code>n</code> times.</p></li>
<li><p>For each min item, get it's index as well.</p></li>
<li><p>Output the found indexs to screen.</p></li>
</ol>

<p>That's not very complicated. Do some research about the basics such as <strong>loops</strong> (to do something n times), <strong>functions</strong> (to do the same code of finding the smallest item in an array - with functions you write it once and call it again when you want to use that code) - you can also use known <code>sort</code>ing functions, <strong>arrays</strong> in <code>c++</code> and <strong>output</strong> to screen.</p>

<p>First try writing your own code before asking for it here :)</p>
",6
42568523,42568175,0,"<p>Break down your task to smaller tasks and them achieve each small task in c++. You basically want:</p>

<ol>
<li><p>To find the smallest item of an array <code>n</code> times.</p></li>
<li><p>For each min item, get it's index as well.</p></li>
<li><p>Output the found indexs to screen.</p></li>
</ol>

<p>That's not very complicated. Do some research about the basics such as <strong>loops</strong> (to do something n times), <strong>functions</strong> (to do the same code of finding the smallest item in an array - with functions you write it once and call it again when you want to use that code) - you can also use known <code>sort</code>ing functions, <strong>arrays</strong> in <code>c++</code> and <strong>output</strong> to screen.</p>

<p>First try writing your own code before asking for it here :)</p>
",6
37457221,37456992,1,"<p>You probably want to do</p>

<pre><code>base&amp; rp = *p;
</code></pre>

<p>Alternatively, if you really want a reference to a pointer, you can do it like that:</p>

<pre><code>base* tmp = p;
base*&amp; rp = tmp;
</code></pre>
",0
37457257,37456992,3,"<blockquote>
  <p>the reference of a base class pointer can not bind to the derived class poiner?</p>
</blockquote>

<p>It can't. What you are doing however, is trying to bind <strong>base</strong> class pointer reference to a temporary <strong>base</strong> class pointer (rvalue). But since it's a non-const reference, it cannot bind to an rvalue.</p>

<p>You have two options, depending on your intention. Use a const reference, which can be bound to rvalues. This extends the lifetime of the temporary:</p>

<pre><code>base * const &amp;rp = (base*)p;
</code></pre>

<p>Or bind the reference to an lvalue:</p>

<pre><code>base * b = p;
base * &amp;rp = b;
</code></pre>
",0
37457301,37456992,1,"<p>I'm not sure if you want to do</p>

<pre><code> base* rp = (base*)p;
</code></pre>
",0
41928627,41928323,4,"<blockquote>
  <p><code>if (k[a].m_name == foo)</code></p>
</blockquote>

<p>This is not how you compare two C-Style strings. This only compares the pointers, which should result in false almost certainly. You could use <code>strcmp</code> (<code>#include &lt;string.h&gt;</code>):</p>

<pre><code>if (!strcmp(k[a].m_name, foo))
</code></pre>

<p>A better way, though, since you're programming in C++, use <code>std::string</code>:</p>

<pre><code>std::string m_name;
</code></pre>

<p>and the comparison would have worked flawlessly.</p>
",0
38502693,38502256,1,"<p>You iterate through one element too many on creation:</p>

<pre><code>for (int i = 0; i &lt;= N; i++){
</code></pre>

<p>Shoule be</p>

<pre><code>for (int i = 0; i &lt; N; i++){
</code></pre>

<p>It's because with arrays being 0-based, you can't access the element N of an array of the size N, only N-1, but in return also element 0.</p>

<p>Also, to make the code clearer and less error prone, you could use std::array instead of a pure C style array, or even an std::vector to be able to loop through them range based. You might also rething your use of new which should be avoided in most cases. If you don't really need that, I'd change the function to</p>

<pre><code>std::vector&lt;HashEntry&gt; initHashList(int N) {
    std::vector&lt;HashEntry&gt; hashList(N, { """", false, -1, }); //Creating vector of N elements

    for (const HashEntry&amp; entry : hashList) { //Iterating through the elements
        std::cout &lt;&lt; entry.value &lt;&lt; std::endl;
    }
    return hashList;
}
</code></pre>

<p>I hope this makes it clearer how you can approach such a problem.</p>

<p>This way of creating the vector and looping through it avoids the potential access errors and is easier to read, imo. For more information, search for std::vector, its constructors, and range-based loops.</p>
",0
38514611,38514576,1,"<p>The <code>sum[T]</code> variable is not initialized.  You must initialize it:</p>

<pre><code>long long sum[T] = {};
</code></pre>
",0
38514758,38514576,0,"<p>The code</p>

<pre><code>long long int sum[T];
</code></pre>

<p>isn't valid C++.</p>

<p>Google for variable length array or dynamic array.  You'll likely see an answer like</p>

<pre><code>long long int *sum = new long long int[T].
</code></pre>
",2
38514933,38514576,1,"<p>This:</p>

<pre><code>cin &gt;&gt; T;
long long int sum[T];
</code></pre>

<p>is not valid C++.  An array in C++ must be created using a compile-time expression to denote the number of items, not a variable such as <code>T</code>.</p>

<p>The proper construct to use that is standard C++ is <code>std::vector&lt;long long&gt;</code>:</p>

<pre><code>#include &lt;vector&gt;
//...
cin &gt;&gt; T;
std::vector&lt;long long&gt; sum(T);
</code></pre>

<p>The code is now standard C++. </p>

<p>The other aspect that this code does is solve the issue brought up in the answer by DietrichEpp, in which you failed to initialize the VLA to 0.  The vector above would have automatically initialized the items to 0 for you.</p>

<p>So the moral of the story is that if you used standard C++, you probably would not have had a problem with your code. </p>
",0
38879517,38879386,1,"<blockquote>
  <p>My question is whether it's possible to move the <code>to_int</code> method outside of the classes, into the form of an overloaded function.</p>
</blockquote>

<p>Using overloaded non-member functions is a viable option only if you deal with the derived types at all times.</p>

<p>If you need the functionality through a reference or pointer to the base class type, then using overloaded non-member functions is not a viable option. In that case, a <code>virtual</code> member function is the right choice.</p>
",0
38879797,38879386,0,"<p>You can use a template class and an using declaration to do that:</p>

<pre><code>template&lt;int v&gt;
struct Numeric {};

using NotANumber = Numeric&lt;-1&gt;;

template&lt;int N&gt;
constexpr int Numeric_to_int (Numeric&lt;N&gt;) {
    return N;
}

int main() {
    static_assert(Numeric_to_int(NotANumber{}) == -1, ""!"");
    static_assert(Numeric_to_int(Numeric&lt;42&gt;{}) == 42, ""!"");
}
</code></pre>

<p>Also, consider the use of a <code>std::integral_constant</code> for the same purpose.<br>
As an example:</p>

<pre><code>template&lt;int v&gt;
using Numeric = std::integral_constant&lt;int, v&gt;;
</code></pre>
",4
38880313,38879386,1,"<blockquote>
<pre><code>int calculate_stuff (const Numeric n)
</code></pre>
</blockquote>

<p>How could it work? You passed in a base class. <em>By value</em>. The compiler cannot know what derived class it used to be. In fact, since you took the base class by value, the compiler <em>knows</em> that <code>n</code> is <em>neither</em> of the derived classes.</p>

<p>C++ isn't Java; if you pass something by value, you make a copy (or move to it). And if you passed one of the derived classes, that <a href=""https://stackoverflow.com/questions/274626/what-is-object-slicing"">causes <em>slicing</em></a>; you only copy the base class data. The parameter is therefore exactly what it says: an object who's dynamic type is <code>Numeric</code>. Exactly and only that, not one of its derived classes.</p>

<p>Even if you took a <code>const Numeric &amp;n</code> instead, that won't help. The compiler doesn't know what type it used to be. And you can't even use <code>dynamic_cast</code> to convert it back, since <code>Numeric</code> is not a polymorphic class.</p>

<p>A better way to handle this is to actually use a proper <code>variant</code> class (<code>optional</code> is effectively a specialized <code>variant</code>).</p>
",1
43939474,43935025,1,"<p>Yes, it is possible to pass a subclass as an argument to a function that takes a superclass parameter but only if you pass by reference or by pointer. If you try to pass by value you experience <a href=""https://stackoverflow.com/questions/274626/what-is-object-slicing"">object slicing</a>.</p>

<p>But that is only part of the story. The next important question is about ownership. Who owns the <code>Shape</code> (and the <code>Node</code> for that matter). Who ensures it is deleted? The easiest way of managing ownership is to use automatic storage and then they will be automatically deleted when they go out of scope. In this case you could consider the possibility that the <code>main</code> function holds a <code>Circle</code> object that goes out of scope at the end of the function. You could pass this <code>Circle</code> as a <code>Shape</code> reference to the <code>ShapeList</code> and then the <code>ShapeList</code> is not responsible for deleting it.</p>

<pre><code>int main() {
    ShapeList list;
    Circle c(5, 5, 3);
    list.add( c );
}
</code></pre>

<p>However, looking through your code it looks like you have committed to the <code>ShapeList</code> owning <code>Shape</code>. In which case you have to worry about memory management. I warn you, manual memory management is hard to get right (I may have got it wrong below). If you must take ownership of objects by-pointer I <strong>strongly recommend</strong> <a href=""https://stackoverflow.com/a/30143936/3422652"">using smart-pointers</a> like <a href=""http://en.cppreference.com/w/cpp/memory/unique_ptr"" rel=""nofollow noreferrer""><code>std::unique_ptr</code></a>.  But let's assume you <em>really</em> want to do manual memory management.</p>

<p>It would be very unusual to pass ownership using a reference so I would change <code>ShapeList::add</code> to take a pointer. If <code>ShapeList</code> does not need to modify the <code>Shape</code> it could be a pointer-to-const:</p>

<pre><code>void ShapeList::add( const Shape *s ){
    first = new Node(first, s);
}
</code></pre>

<p>Then in the main function create the <code>Circle</code> using <code>new</code>:</p>

<pre><code>int main() {
    ShapeList list;
    list.add( new Circle( 10, 10, 4) );
}
</code></pre>

<p>Now, <code>ShapeList</code> and <code>Node</code> need to worry about manual memory management so you need to consider the <a href=""https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three"">rule of three (five)</a>. At the very least you need to properly define the destructor for <code>Node</code> and <code>ShapeList</code> and prevent copy construction/assignment.  Also <code>Shape</code> must have a <code>virtual</code> destructor in order to properly delete it.</p>

<p>There were a few other minor changes I had to make in order to compile the code without warnings but I'll leave that to you to find:</p>

<pre><code>constexpr double PI = 3.141592653589793238463;

class Shape
{
    public:
        Shape();
        Shape(double x, double y) : posX(x), posY(y){};
        virtual ~Shape() {}  // Important if a pointer-to-shape is being deleted!

        virtual double area() const = 0;

    protected:
        double posX;
        double posY;
};

class Node
{
    public:
        Node *next;
        const Shape *shape;

        Node( Node *n, const Shape *s) : next(n), shape(s){};
        ~Node() { delete next; delete shape; }

        Node(const Node&amp;) = delete;             // Prevent copying to 
        Node&amp; operator=(const Node&amp;) = delete;  // avoid double-deletion.

};

class ShapeList
{
    public:
        ShapeList() : first(nullptr) {};
        ~ShapeList() { delete first; }

        ShapeList(const ShapeList&amp;) = delete;             // Prevent copying to 
        ShapeList&amp; operator=(const ShapeList&amp;) = delete;  // avoid double-deletion.

        void add( const Shape* s ){ first = new Node(first, s); }
    private:
        Node *first;
};

class Circle : public Shape
{
    public:
        Circle(): Shape(0, 0), radie(0) {}
        Circle( double x, double y, double r) : Shape(x, y), radie(r){};

        double area() const { return radie * radie * PI; }

    private:
        double radie;
};

int main() {
    ShapeList list;
    list.add( new Circle( 10, 10, 4) );
}
</code></pre>

<p>Another option, if you want to keep your main function looking like it does is for <code>Shape</code> to have a way of polymorphically copying itself to avoid object slicing. Typically, this is using a <a href=""https://stackoverflow.com/a/5148751/3422652""><code>virtual clone</code> function</a>. Then <code>ShapeList::add</code> could take by-reference then take a ""clone"" to own internally. </p>

<p>Of course, in practice you don't need to write your own list class given that there is already <code>std::list</code> in the standard library. Putting this together with <code>unique_ptr</code> <a href=""https://wandbox.org/permlink/kqN9Y80XKUkrORAH"" rel=""nofollow noreferrer"">is simple</a>.</p>
",0
36526646,36526614,2,"<p>Randomly generate a number and multiply it with 16.</p>
",0
36527052,36526614,2,"<p>You can use the <code>&lt;random&gt;</code> header (<code>C++11</code>) to generate random numbers:</p>

<pre><code>int get_random()
{
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution&lt;&gt; dis(1, 20); // range 1 - 20
    return dis(gen);
}
</code></pre>

<p>And multiply with <code>16</code>:</p>

<pre><code>int main()
{
    std::vector&lt;int&gt; nums;
    for (int i{}; i != 5; ++i)
        nums.emplace_back(get_random() * 16);
}
</code></pre>
",0
39245674,39245362,1,"<p>Instead of swapping only parts of you structure (<code>s[i].grade</code> inside <code>sort_grade()</code> and <code>s[i].name</code> inside <code>sort_name()</code>) you should swap the entire structure. It should be something like the following:</p>

<pre><code>void swap(int n, int m)
{
    char temp_string[50];
    int  temp_int;

    strcpy(temp,s[n].name);
    strcpy(s[n].name,s[m].name);
    strcpy(s[m].name,temp);

    strcpy(temp,s[n].firstname );
    strcpy(s[n].firstname ,s[m].firstname );
    strcpy(s[m].firstname ,temp);

    temp_int = s[n].grade;
    s[n].grade = s[m].grade;
    s[n].grade = temp_int;
}

void sort_name()
{
    char temp[30];
    while(!done)
    {
        done=1;
        for(i=1; i&lt;n; i++)
        {
            if(strcmp(s[i].name,s[i+1].name)&gt;0)
            {
                swap(i, i+1);
            }
       }
   }
}
</code></pre>
",2
39246628,39245362,1,"<p>There are many wrong things in the code.</p>

<p>Here, I fixed them all just for you, but it has probably suffered from my coding style impact:</p>

<p>Headers:</p>

<pre><code> #include &lt;iostream&gt;
 #include &lt;cstring&gt; //not &lt;string.h&gt;
 #include &lt;cstdio&gt; //not &lt;stdio.h&gt;
 //#include &lt;conio.h&gt; //you don't use any functionality from this header
 #include &lt;limits&gt;
 #include &lt;cinttypes&gt;
</code></pre>

<p>Namespace:</p>

<pre><code>// dont use ""using namespace std;"", it's considered bad (here it might not be visible)
</code></pre>

<p>Struct is like ok? I think:</p>

<pre><code>struct student
{
    char name[30];
    char firstname [50];
    int grade;
}s[50];
</code></pre>

<p>Don't rely on global variables (this program model requires <code>n</code> however:</p>

<pre><code>int /*i,*/n=0/*,o,done=0*/; //don't declare global variables if you don't need them to be global
</code></pre>

<p>Fixed <code>add_student()</code> (many errors):</p>

<pre><code>void add_student()
{
    std::cout&lt;&lt;""Number of students:""&lt;&lt;"" "";
    std::cin&gt;&gt;n;
    std::cout&lt;&lt;std::endl;
    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n'); //this is how you flush in c++

    for(int i=0/*1*/; i&lt;/*=*/n; i++) //declare iterator in loop
    {                       //also, first element index is 0, not 1!

        //fflush(stdin); //NEVER do that in C++, std::std::endl flushes output anyways
        std::cout&lt;&lt;""Student""&lt;&lt;"" ""&lt;&lt;i+1&lt;&lt;"":""&lt;&lt;std::endl/*;*/ //dont spam std::cout too much
              /*std::cout*/&lt;&lt;""name of student:""&lt;&lt;"" "";      //just go to next line and start with ""&lt;&lt;""
        std::gets(s[i].name);

        std::cout&lt;&lt;""first name of student:""&lt;&lt;"" "";
        std::gets(s[i].firstname);

        std::cout&lt;&lt;""grade of student:""&lt;&lt;"" "";
        std::cin&gt;&gt;s[i].grade;
        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
        std::cout&lt;&lt;std::endl; //this std::std::endl call flushes output, so that ""C flushin"" didn't do anything
    }
}
</code></pre>

<p>Sorting functions (many errors):</p>

<pre><code>void sort_name()
{
    bool done = false; //prefer bool over int for logical expressions
    /*char temp[30];*/ //not gonna use this, you need whole student, not only name
    student temp;
    while(!done)
    {
        // this whole section is wrong, you just go around swapping
        // students names, not students themselfs
        //        done=1;
        //        for(i=0/*1*/; i&lt;n-1; i++)
        //        {
        //            if(strcmp(s[i].name,s[i+1].name)&gt;0)
        //            {
        //                strcpy(temp,s[i].name);
        //                strcpy(s[i].name,s[i+1].name);
        //                strcpy(s[i+1].name,temp);

        //            }
        //        }
        done = true;
        for(int i=0; i&lt;n-1; ++i)
        {
            if(strcmp(s[i].name, s[i+1].name)&gt;0)
            {
                std::cout &lt;&lt; ""swapping"" &lt;&lt; std::endl;
                temp = s[i];
                s[i] = s[i+1];
                s[i+1] = temp;
                done = false;
            }
        }
    }

    for(int i=0/*1*/; i&lt;/*=*/n; i++)
    {
        std::cout&lt;&lt;""Student""&lt;&lt;"" ""&lt;&lt;i+1&lt;&lt;"":""&lt;&lt;std::endl
            &lt;&lt;""Name""&lt;&lt;"":""&lt;&lt;s[i].name&lt;&lt;std::endl
            &lt;&lt;""Firstname""&lt;&lt;"":""&lt;&lt;s[i].firstname&lt;&lt;std::endl
            &lt;&lt;std::endl;
    }
}


void sort_grade()
{
    bool done = false;
    student temp;

    //exact same mistakes like in sort_name()
    while(!done)
    {
        done = true;
        for(int i=0; i&lt;n-1; ++i)
        {
            if(s[i].grade &gt; s[i+1].grade)
            {
                temp = s[i];
                s[i] = s[i+1];
                s[i+1] = temp;
                done = false;
            }
        }
    }

    for(int i=0/*1*/; i&lt;/*=*/n; i++)
    {
        std::cout&lt;&lt;""Student""&lt;&lt;"" ""&lt;&lt;i+1&lt;&lt;"":""&lt;&lt;std::endl
            &lt;&lt;""Name""&lt;&lt;"":""&lt;&lt;s[i].name&lt;&lt;std::endl
            &lt;&lt;""Firstname""&lt;&lt;"":""&lt;&lt;s[i].firstname&lt;&lt;std::endl
            &lt;&lt;""Grade""&lt;&lt;"":""&lt;&lt;s[i].grade&lt;&lt;std::endl
            &lt;&lt;std::endl;
    } 
}
</code></pre>

<p><code>list_students()</code> function (<code>cout</code> spam and index shift again):</p>

<pre><code>void list_students()
{
    for(int i=0/*1*/; i&lt;/*=*/n; i++)
    {
        std::cout&lt;&lt;""Student""&lt;&lt;"" ""&lt;&lt;i+1&lt;&lt;"":""&lt;&lt;std::endl
            &lt;&lt;""Name""&lt;&lt;"":""&lt;&lt;s[i].name&lt;&lt;std::endl
            &lt;&lt;""Firstname""&lt;&lt;"":""&lt;&lt;s[i].firstname&lt;&lt;std::endl
            &lt;&lt;""Grade""&lt;&lt;"":""&lt;&lt;s[i].grade&lt;&lt;std::endl
            &lt;&lt;std::endl;
    }
}
</code></pre>

<p>And <code>main()</code> (made <code>int o</code> a local variable and fixed <code>cout</code> spam):</p>

<pre><code>int main()
{
    int o;
    do
    {
        //please, don't spam std::cout like that, it hurts
        std::cout&lt;&lt;""Menu:""&lt;&lt;std::endl
            &lt;&lt;""1.Add students""&lt;&lt;std::endl
            &lt;&lt;""2.Sort by name""&lt;&lt;std::endl
            &lt;&lt;""3.Sort by grade""&lt;&lt;std::endl
            &lt;&lt;""4.List  students""&lt;&lt;std::endl
            &lt;&lt;""5.Exit""&lt;&lt;std::endl&lt;&lt;std::endl
            &lt;&lt;""Pick option : "";
        std::cin&gt;&gt;o;
        std::cout&lt;&lt;std::endl;

        switch (o)
        {
        case 1:add_student();
            break;
        case 2:sort_name();
            break;
        case 3:sort_grade();
            break;
        case 4:list_students();
            break;
        }
    }while (o!=5);
}
</code></pre>

<p>In short, long way to go! But study your code, and read some good books so you can improve.</p>

<p>EDIT:</p>

<p>Headers:</p>

<p><a href=""https://stackoverflow.com/questions/10460250/cstdio-stdio-h-namespace"">cstdio stdio.h namespace</a></p>

<p>Namespace:</p>

<p><a href=""https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-in-c-considered-bad-practice"">Why is &quot;using namespace std&quot; considered bad practice?</a></p>

<p>Global variables:</p>

<p><a href=""https://stackoverflow.com/questions/484635/are-global-variables-bad"">Are global variables bad?</a></p>

<p>Indexing in C/C++:</p>

<p><a href=""https://stackoverflow.com/questions/7320686/why-does-the-indexing-start-with-zero-in-c"">Why does the indexing start with zero in &#39;C&#39;?</a></p>

<p>Flushing input/output in C++ and cin/get~ problem solution:</p>

<p>(output) </p>

<p><a href=""https://stackoverflow.com/questions/213907/c-stdendl-vs-n"">C++: &quot;std::endl&quot; vs &quot;\n&quot;</a></p>

<p>(input) </p>

<p><a href=""https://stackoverflow.com/questions/10553597/cin-and-getline-skipping-input"">cin and getline skipping input</a></p>

<p>Anti-cout spam:</p>

<p><a href=""http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt</a></p>

<p>Swapping structures:</p>

<p><a href=""https://stackoverflow.com/questions/873715/c-sort-with-structs"">c++ sort with structs</a></p>
",3
39247047,39245362,-2,"<p>while swapping use memcpy() like functions and swap entire structure instead of name / gRade</p>
",2
44713791,44712798,0,"<p>2) and 3) are of course the same, the visibility does not change anything on the problem.</p>

<p>You declare your variable, but you don't define it. In other words, in your .cpp file you should add</p>

<pre><code>int TrainComposition::wagons = 0;
</code></pre>

<p>This is most often not necessary for <code>static</code> members that are <code>const</code>, but sometimes even then.</p>
",0
40770831,40770324,1,"<p>Checklist:</p>

<ol>
<li><p>Your constructors are private, make them public if you want to derive and use.</p></li>
<li><p>In your for loop, increment <code>i</code>, right now its infinite loop</p></li>
<li><p>Not sure of your compiler but most compilers do not throw errors if the control reaches at the end of the function without a return statement, it displays a warning. However, if you see an error, you should <code>return 0</code> or something to make the compiler happy.</p></li>
</ol>
",0
40770423,40770324,1,"<p>Inside </p>

<pre><code>class foo_base {

    foo_base(){};
    ~foo_base(){};

    virtual int counter(){};
};
</code></pre>

<p>You define a function for <code>counter</code> that does not return an integer. Change to (Base Class will return 0, derived will override):</p>

<pre><code>class foo_base {

    foo_base(){};
    ~foo_base(){};

    virtual int counter(){return 0;};
};
</code></pre>

<p>And it should compile</p>
",0
40770433,40770324,0,"<p>You cannot implement your <code>counter()</code> function for the <code>foo_base</code> class in <code>foo_derived</code>. What you probably want is to make is either (1) make the base class abstract or (2) provide a implementation in <code>foo_base</code> for <code>counter()</code>.</p>

<p>However, if you define the <code>counter()</code> not as pure virtual (i.e. <code>virtual int counter() = 0;</code>, the compiler will complain, because you need an implementation.
One option would be to replace <code>virtual int counter(){};</code> with <code>virtual int counter(){ return 0; };</code>.</p>
",0
40770663,40770324,1,"<p>You need to have the counter() function in the base class return an int. You defined the return type of the function, yet did not provide a proper definition of the function. That should fix <em>that</em> issue, but you have others as well.</p>

<p>When you define classes, you cannot have the destrcutors be marked as private. In C++, unlike Java, variables &amp; functions are 'private' by default. You need to explicitly mark members as public in order to make them public.</p>

<p>To fix your first issue:</p>

<pre><code>`virtual int counter(){ return 0 }; //It doesn't have to return 0, just an int. Used this for demo sake'
</code></pre>

<p>To fix your second issue:</p>

<pre><code>class foo_base {
public: // This will make everything below public, so only do this if your goal is to have everything marked as public (i.e. use private where necessary)
    foo_base(){};
    ~foo_base(){};

    virtual int counter(){};
};

class foo_derived : public foo_base{
public:
    foo_derived(){};
    ~foo_derived(){};

    int counter() {   int temp = 0;
        for(int i = 0; i &lt; 10;)
            temp += i;
        return temp;
        }
};
</code></pre>

<p>As commented in the code, use public where necessary. But, it doesn't make sense to mark your constructor as private in this scenario (based on the code presented). Again, that is your choice. The destructor, however, must be marked as public in order for inheritance to work.</p>
",0
45279807,45279719,2,"<p>you should use <code>delete []</code> instead of <code>delete</code> to deallocate dynamic arrays.</p>

<p>Also, you don't seem to use the derived class but, nevertheless, the destructor in <code>MultipleChoiceTest</code> should be virtual</p>
",6
46637318,46637296,1,"<p>It comes from the difference between computation of integers and doubles. First expression is done between two integers, but the second one is between two floating point numbers. </p>
",0
46637399,46637296,2,"<p>In the first line,</p>

<pre><code>cout &lt;&lt; 0 * -5 &lt;&lt; endl;
</code></pre>

<p>both 0 and -5 are signed integers.  Integers do not distinguish between <code>0</code> and <code>-0</code>.</p>

<p>In the second line,</p>

<pre><code>cout &lt;&lt; 0 * -5.0 &lt;&lt; endl;
</code></pre>

<p>the second number is a double, so the 0 gets promoted to a double as well, for which IEEE floating point defines both <code>0</code> and <code>-0</code> values.</p>
",0
40955461,33595996,1,"<p>Yes you do need the x in your for loop. x is initialized inside your for loop. A for loop statement is composed of 3 parts, Variable initialization; your condition; and updating your variable. You will get an error with out it.</p>

<pre><code>for (var initialization; condition; var update)
{
    //code..... 
}
</code></pre>

<p>the difference between a while loop and a for loop is a while loop you initialize your variable before your while loop and update your variable within the loop it self.</p>

<pre><code>x = 0
while (x &lt; 5)
{
    x++
}
</code></pre>

<p>A for loop, it is all contained within the for statement.</p>

<pre><code>for (int x = 0; x &lt; 5; x++)
{
    //code...
}
</code></pre>

<p>So in your second for loop statement x is already being initialized to 0 within the for statement.</p>

<p>Also your for loop with the x's should have ; not , </p>
",0
38862637,38862584,2,"<p><code>std::getline</code> ignores the delimiter, which by default is <code>\n</code> when it reads a line. So, when it reads</p>

<pre><code>testing this is a test to see if this actually works\n
</code></pre>

<p><code>content</code> will actually be </p>

<pre><code>testing this is a test to see if this actually works
</code></pre>

<p>Note the missing newline. That's why there is one new line missing after every line :)</p>

<p>You have to add that discarded delimiter:</p>

<pre><code>output &lt;&lt; content &lt;&lt; '\n'; //Adds the discarded '\n' delimiter
</code></pre>
",1
40558583,40558480,0,"<p>As you have a char array</p>

<pre><code>char output[100];
</code></pre>

<p>there is no distinction between words in this data structure. File was simply read character by character and stored in the array.</p>

<p>A simple implementation of separation into words (using loops as you requested, with minimal changes to your code), assuming words are separated by a delimiter would be</p>

<pre><code>char wordsFromDictionary[40437][22];
char delimiter=...
int i=0;
int j=0
char c;
if(dictionaryFile.is_open()){
    while(!dictionaryFile.eof()){
        c=dictionaryFile.get();
        if(c==delimiter){
          i++;
          j=0;
        }
        else if(j&lt;22) {
          wordsFromDictionary[i][j]=c;
          j++;
        }
    }
}
</code></pre>

<p>Note that this simply cuts, shortens the words that are longer than 22 chars.</p>
",0
40558644,40558480,0,"<p>If you want to read in some strings, the obvious choice would be to use <code>std::string</code>s to do the job. If you want an array of them, store them in an <code>std::vector</code>:</p>

<pre><code>ifstream d(""dictionary.txt"");

std::vector&lt;std::string&gt; words{std::istream_iterator&lt;std::string&gt;(d), {}};
</code></pre>

<p>This reads all the words into the vector. If they're already sorted, you can then (for example) use <code>std::binary_search</code> to find whether a word is in the vector or not.</p>
",0
40561109,40560892,0,"<p>In every string if you have a string length of N you must have char array of size at least N+1 for '\0' which indicates that the string ends here for cout to stop printing. </p>

<p>In your case you declared char array of size 5 and you fill all 5 with characters so '\0' is put somewhere else. Notice that ""id"" and ""fullname"" locate next to each other , so my best guess is that gets put '\0' of when you scan ""ID"" which should be ""id[5]"" to ""fullname[0]"", and then when you scan ""FULLNAME"" , it replaces this '\0' , so ""id"" has no termination point and must use termination point of ""fullname"". That's why it seems like fullname has been appended to id. Be aware that this is not the default behavior , the program may act different on other machines.</p>

<p>Also , gets() is a broken function , if you use cin or scanf before , you should flush your stdin first by calling </p>

<pre><code>fflush(stdin);
</code></pre>

<p>before you use gets() because sometimes '\n' is left in the stdin but in your case this was taken care by</p>

<pre><code>cin.ignore(32323, '\n');
</code></pre>

<p>Using fgets() as Paul Rooney stated is much more preferable. I myself also had a lot of problems with gets.</p>

<p>Happy Coding!!</p>
",0
40560966,40560892,0,"<p>You need to put a terminal <code>'\0'</code> char at the end of every string.</p>

<p>When the ID gets printed, the code (<code>cout</code>) won't stop til it hits a <code>NULL</code>.</p>

<p>This is called overrunning your buffer.</p>
",3
39133869,39133806,1,"<p>These: </p>

<pre><code>int &amp;a = c;
int&amp; a = c;
int &amp; a = c;
int &amp; \
a = c;
</code></pre>

<p>Are all the same. <a href=""http://ideone.com/C4AKCT"" rel=""nofollow"">Live example</a></p>
",3
47963288,47963265,3,"<p>A string literal, <code>""name""</code> in your case, is of type<code>const char[]</code>. An array can decay to a pointer which is what's happening in this case. That pointer will then point to the first element in the array. Note that since C++11 assigning to a <code>char*</code> instead of a <code>const char*</code> (thus needing a conversion) as you are doing is illegal, always use <code>const char*</code> for string literals, or better yet, <code>std::string</code>.</p>

<p><code>8</code> is of type <code>int</code>, which has no conversion to a pointer type that an array has.</p>
",0
47964502,47963265,0,"<p>The rules for <code>int*</code> and <code>char*</code> are the same. However, you compare apples to oranges.</p>

<ul>
<li><p>You <em>cannot</em> assign a value of the respective type to its pointer (it doesn¡¯t matter whether there is a <code>const</code> here; I made things <code>const</code> for consistency with the next example where it matters to some extend):</p>

<pre><code>int const*  ip = 8;   // ERROR
char const* cp = ¡®8¡¯; // ERROR
</code></pre></li>
<li><p>Arrays <em>decay</em> into pointers upon the slightest opportunity. String literals are arrays of type <code>char const[N]</code> where <code>N</code> is the number of <code>char</code>s in the string literal, including the terminating null <code>char</code>.</p>

<pre><code>int  ia[] = { 8 };
char ca[] = { ¡®8¡¯ };
int const*  ip = ia;   // OK
char const* cp = ca;   // OK
char const* lp = ¡°8¡±;  // OK
</code></pre></li>
</ul>
",0
38616653,38616243,2,"<p>Given a <code>Score</code> class of;</p>

<pre><code>struct Score {
  int score;
  std::string time;
};
</code></pre>

<p>You will need an extraction operator (<code>operator &gt;&gt;</code>) for the stream and this type (<code>Score</code>), then the technique you are using should work (it will require a changing of the types);</p>

<pre><code>std::ifstream&amp; operator&gt;&gt;(std::ifstream&amp; fs, Score&amp; s)
{
  // construct sentry as required
  fs &gt;&gt; s.score;
  fs &gt;&gt; s.time;
  return fs;
}
</code></pre>

<p><em>Note</em>; Given the relative lack of detail for the data format in the OP, I've omitted error checking on the time etc., and left out the sentry object to focus on the ability of the code use the stream extraction operator.</p>
",0
44743015,44742978,0,"<p>Briefly, what graphics APIs have in their source is interaction with the graphics hardware, and telling it to write pixel values in memory. Ultimately this is usually done in an indirect way, such as setting up a scene graph, and and graphics APIs provide an interface to work with low level hardware systems.</p>
",0
44743093,44742978,1,"<p>Well, you <em>could</em> make your own graphics library.  In that case I suggest you grab a good math book, and get ready to do some rather serious maths. You'd also have to get going and start right now to learn about Windows graphics drivers and Windows Kernel development, or about the X11 API and Linux Kernel programming, or all of those. The documentation is available on the Net.</p>

<p>What OpenGL and other graphics libraries do is provide a relatively simple API so you don't have to reinvent the wheel, and make your own library which <strong>would</strong> take years before having anything close to what they provide.</p>

<p>Don't get me wrong, even with these nice API's, there is much room for doing 'magic'.  Computer graphics are an art in and of themselves. Mastering some of the techniques offered by the libraries require a good knowledge of the maths involved, and of the possibilities offered by the hardware as well.</p>

<p>But, like everything, it can be learnt.  If you are interested in doing graphics on a computer, you should start by finding a good source on the subject, there are many online. And start playing with the APIs.  OpenGL is a good place to start, but there are also open source libraries that build on that, since drawing polygons ans stuff involves many other aspects of computing.  Ogre3d comes to mind, but there are also others.</p>
",0
45096603,45096566,1,"<p>A <code>do { ... } while (...)</code> will always run, the test is performed at the end of the loop. A <code>while (...) { ... }</code> <em>might</em> run, the test is performed before each round starts.</p>

<p>Consider using a straight <code>while</code> loop if you want it to loop if and only if you make a mistake.</p>
",0
45097179,45096566,0,"<p>Use a <code>while(..){..}</code> loop because a <code>do{...}while(...)</code> loop runs for at least one time regardless of the condition moreover the loop will only terminate if you enter the id <code>123</code> so if you try to enter a string which is not <code>""123""</code> the loop will go on infinitely. Also, the type of <code>IDCheck</code> is defined as <code>int</code> so if you enter a string containing alphabets the value of <code>IDcheck</code> will change to the first integer part of the string.
For example if you enter 12ab, value of <code>IDCheck</code> will set to 12.</p>
",0
45097145,45096566,0,"<p>You are using do { statement(s); }while( condition ) but in your code no need for do while loop. In do { statement(s); }while( condition ) Notice that the conditional expression appears at the end of the loop, so the statement(s) in the loop execute once before the condition is tested.</p>

<pre><code>    #include &lt;iostream&gt;
    #include &lt;cmath&gt;
    #include &lt;ctime&gt;
    #include &lt;cstdlib&gt;
    using namespace std;
    int main()
        {
        const int ID = 123;
        const int password = 123456;
        int IDcheck, passwordcheck;
        cout &lt;&lt; ""Enter the ID: ""; cin &gt;&gt; IDcheck; cout &lt;&lt; endl;

        while (ID != IDcheck);
        {
            if(ID != IDcheck)
              {
             cout &lt;&lt; ""You entered the wrong ID, please try again: "";
              }
         else {
            cout &lt;&lt; ""Enter the ID: ""; cin &gt;&gt; IDcheck; cout &lt;&lt; endl;
            cout &lt;&lt; endl;
              }
        } 

        cout &lt;&lt; ""Enter the password: ""; cin &gt;&gt; passwordcheck; cout &lt;&lt; endl;

        while (password != passwordcheck);
        {
            if((password != passwordcheck)
              {
            cout &lt;&lt; ""You entered the wrong password, please try again: "";
              }
         else {
            cout &lt;&lt; ""Enter the password: ""; cin &gt;&gt; passwordcheck; cout &lt;&lt; endl;
            cout &lt;&lt; endl;
             }
        } 

        cout &lt;&lt; ""Welcome to my world!"" &lt;&lt; endl;


    system(""pause"");
    return 0;

    }
</code></pre>
",2
35260857,35260845,2,"<p>Make a file called ""convertdays.h"", containing the function declaration:</p>

<pre><code>int convertdays(int, int, int); 
</code></pre>

<p>This is called a header file.</p>

<p>Then at the top of <code>main.cpp</code>:</p>

<pre><code>#include ""convertdays.h""
</code></pre>

<p>(It's a good idea to put the same thing at the top of <code>convertdays.cpp</code>, though not strictly necessary.)</p>

<p>Then when you build the executable, link <code>main.o</code> and <code>convertdays.o</code>.</p>
",2
39114052,39114038,2,"<pre><code>obj = realloc(obj,12*sizeof(Perro*));
</code></pre>

<p>pointer will change after realloc!</p>
",3
39115045,39114038,0,"<p>SHOOULD BE BETTER IF I....</p>

<pre><code>Perro *obj[40];

perro[0] = new Perrito;
Perro[1] = new PerritoOther;
...
Perro[39]...

THEN IF THE USER WHAT TO ADD OTHER THINGS
MY TEACHER SAID YOU MUST USE REALLOC ?!  WHY,WHAT CAN I DO ? 
</code></pre>
",0
39111410,39111389,2,"<p>Your definition of <code>volume</code> doesn't match its prototype. It needs to have the three parameters <code>l</code>, <code>w</code>, and <code>h</code> as you defined in your function prototype.</p>

<pre><code>int volume (int l, int w, int h){
    return l*w*h;
}
</code></pre>
",0
38867219,38867111,1,"<p>The <em>expression</em>, <code>foo</code>, say within <code>if(foo)</code> is valid if the <em>type</em> of the expression <code>foo</code> has a valid conversion to the <code>bool</code> type.</p>

<p>Given that <code>_getch()</code> returns an integral type, it <em>is</em> therefore possible to write <code>if(_getch())</code>. The <code>if</code> will evaluate to <code>true</code> if <code>_getch()</code> returns a non-zero value, and <code>false</code> otherwise.</p>
",1
42470408,42470380,0,"<pre><code>double number2 = number2 * number3;
</code></pre>

<p>You're accessing <code>number2</code> before initializing it, <a href=""https://stackoverflow.com/q/4279264/3425536"">which causes undefined behavior</a>.</p>
",0
42470419,42470380,1,"<pre><code>double number2 = number2 * number3;
</code></pre>

<p>you need to initialize <code>number2</code> with some value otherwise it contains a garbage value which is getting multiplied with <code>number3</code></p>

<p>split above statement into two statements</p>

<pre><code>double number2 = /*some value to initialize number2*/;
number2 *= number3;    //now perform multiplication
</code></pre>

<p>Additionally, <code>number2</code> is being passed into function <code>mult</code> as an argument, and you are also declaring a new variable with the same name <code>number2</code> inside <code>mult</code> function. </p>
",1
42608879,42608819,0,"<p>You can use <a href=""https://msdn.microsoft.com/en-us/library/f02979c7(v=vs.110).aspx?cs-save-lang=1&amp;cs-lang=cpp#code-snippet-1"" rel=""nofollow noreferrer"">TryParse</a> in an if statement to check the type of the input and <a href=""https://msdn.microsoft.com/en-us/library/37zc9d2w.aspx"" rel=""nofollow noreferrer"">break</a> if <code>TryParse</code> returns false</p>
",0
43220856,43220803,0,"<pre><code>int mutateA(int &amp;);
int mutateB(int &amp;);
</code></pre>

<p>change this to</p>

<pre><code>twoVar&amp; mutateA(int &amp;);
twoVar&amp; mutateB(int &amp;);
</code></pre>

<p>and make the corresponding changes to the implementations.</p>
",0
38864044,38863968,4,"<p>Instead of doing</p>

<pre><code>cin &gt;&gt; nameofbook;
</code></pre>

<p>try</p>

<pre><code>getline(cin, nameofbook);
</code></pre>

<p>and similarly for the rest. When you just do <code>cin &gt;&gt; x</code> it will read only up to the next whitespace. If you want to read the whole line you should do <code>getline</code>.</p>
",0
38864063,38863968,4,"<p>You may use <code>getline()</code> instead of <code>cin</code> as it gets a token from <code>string</code>.</p>

<pre><code> cout&lt;&lt;""What is the first and middle name of the author in abbreviations?""&lt;&lt;endl;

 getline (std::cin, fmauthor); // and as for other qsns
</code></pre>
",0
38864090,38863968,0,"<p>You require to make an input using std::getline(cin,stringName) function which accepts whole line as input until you press a new line character .Getting a string input using cin would break input on occurence of first space character.</p>
",0
47468678,47468408,-1,"<p>To the question why E isn't printed take a look at the comments i made to your code here:</p>

<pre><code>void main ()
{
char ch='A';
while (ch &lt;='F'){
switch (ch){
case 'A': // ch: A=&gt;B; continue;
case 'B': // ch: B=&gt;C; continue;
case 'C': // ch: C=&gt;D; continue;
case 'D': ch++; continue; // ch: D=&gt;E; continue; | E isn't printed here ""continue"" is called instead.
case 'E'; // ch: E=&gt;F; putchar(F); | E isn't printed here either F is printed because F is assigned just before ""putchar"" is called.
case 'F': ch++; // ch: F=&gt;G; putchar(G);
}
putchar (ch);

}
</code></pre>

<p>The second question, why putchar prints two character:
It doesn't. It only writes one char to the output buffer each time but the output buffer is written to screen on late calls.</p>

<p>Use <code>std::cout.flush()</code> after putchar to display your output immediately.</p>

<p>Also change <code>case 'E';</code> to <code>case 'E':</code> to make your code compilable, please.</p>
",0
47468843,47468408,0,"<p>When it comes to case  E,  since there is no  break; after that statement it will execute every case after it in the switch statement thus doing  ch++;  of the case F
  E++ is F so putchar will print F 
Next since your condition in the while statement is less or equal to F it will enter again the switch
 In case F it will do again ch++ now ch holds the value of G and putchar prints G 
G is not less or equal F, it exits the while loop and ends.
So you have printed F then G.</p>
",0
43196366,43196166,-1,"<p>This is actually basic c++ coding. I think this is what you're after. Also, there are quite a few good c++ books out there that are decent priced. Don't forget to #include </p>

<pre><code>void newLine()
{
   char nextChar;
   do
   {
      cin.get(nextChar);
   } while (nextChar != '\n');
}
</code></pre>
",0
39655572,39654765,0,"<p>This compiles without warnings on gcc:</p>

<pre><code>#include &lt;iostream&gt;

void foo(int i)
{
  std::cout &lt;&lt; i &lt;&lt; std::endl;
}

int main()
{
  int r;
  std::cin &gt;&gt; r;
  foo(r);
}
</code></pre>

<p>whereas this generates the uninitialised variable warning (rightly):</p>

<pre><code>#include &lt;iostream&gt;

void foo(int i)
{
  std::cout &lt;&lt; i &lt;&lt; std::endl;
}

int main()
{
  int r;
  foo(r);
  std::cin &gt;&gt; r;
}
</code></pre>

<p>example compiler output:</p>

<pre><code>/tmp/gcc-explorer-compiler116823-58-135fozf/example.cpp: In function 'int main()':
11 : warning: 'r' is used uninitialized in this function [-Wuninitialized]
foo(r);
^
Compiled ok
</code></pre>
",0
39319142,39319035,2,"<p>You could have demonstrated this with much simpler code.</p>

<pre><code>#include &lt;iostream&gt;

class Noisy
{
public:
    Noisy()
        { std::cout &lt;&lt; ""Noisy default construct\n""; }
    ~Noisy()
        { std::cout &lt;&lt; ""Noisy destroy\n""; }
};

int main()
{
    Noisy noisy1;
    Noisy noisy2(noisy1);
}
</code></pre>

<p>Output</p>

<pre>
Noisy default construct
Noisy destroy
Noisy destroy
</pre>

<p>Notice that, apparently, only one object was constructed, but two were destroyed. The reason for this apparent inconsistency is because we are not logging all or our constructors. There is an implicitly generated copy constructor, which we are using to construct <code>noisy2</code> in this line here:</p>

<pre><code>Noisy noisy2(noisy1);
</code></pre>

<p>If we define the copy constructor ourselves,</p>

<pre><code>#include &lt;iostream&gt;

class Noisy
{
public:
    Noisy()
        { std::cout &lt;&lt; ""Noisy default construct\n""; }
    Noisy(Noisy const&amp;)
        { std::cout &lt;&lt; ""Noisy copy construct\n""; }
    ~Noisy()
        { std::cout &lt;&lt; ""Noisy destroy\n""; }
};

int main()
{
    Noisy noisy1;
    Noisy noisy2(noisy1);
}
</code></pre>

<p>Output:</p>

<pre>
Noisy default construct
Noisy copy construct
Noisy destroy
Noisy destroy
</pre>

<p>You can see that two objects are constructed, just with different constructors. If you do this with your various classes, you should see similar results. Your references will not be logged, neither a constructor or destructor, since they are not objects.</p>
",0
39319162,39319035,2,"<blockquote>
  <p>when it creates an A object,is creating a new block or it use the existing block? why isn't running the constructor of block?</p>
</blockquote>

<p>Looking at <code>A</code> constructor:</p>

<pre><code>A(Block&amp; blk)
        : block1(blk)
        , block2(blk)
    {
    }
</code></pre>

<p><code>block1</code> is a <a href=""http://www.cprogramming.com/tutorial/references.html"" rel=""nofollow"">reference</a> to a <code>Block</code> object. So it referes to the already created <code>blk</code> variable, and it won't create another one. So no constructor is invoked in this case.</p>

<p>That is not true for <code>block2</code> which is not a reference. In that case indeed a <em>new</em> object <code>Block</code> is created, but using <a href=""http://en.cppreference.com/w/cpp/language/copy_constructor"" rel=""nofollow"">copy constructor</a>.</p>

<p>What you've defined in your <code>Block</code> class is a <em>default constructor</em>.
When a class instance is created starting from another object of the same class, then the <em>copy constructor</em> will be invoked (note: not the <em>default constructor</em>).</p>

<p>The <em>copy constructor</em> is implicitly defined by the compiler unless you define one yourself.</p>

<p>For example:</p>

<pre><code>class Block {
 public:
   Block(const Block&amp; other) : data(oth.data) {
     std::cout &lt;&lt; ""Invoked copy 'ctor"" &lt;&lt; std::endl;
   }

   // ... other stuff
};
</code></pre>

<p>That's why your code invokes the <em>default constructor</em> of your class <code>Block</code> only once.</p>
",0
46969137,46968250,1,"<p>You have a typo:</p>

<pre><code>    while (a &lt;= N &amp;&amp; b &lt; N) {
//           ** &lt;--- here
</code></pre>

<p>I have found it using the <a href=""https://github.com/google/sanitizers/wiki/AddressSanitizer"" rel=""nofollow noreferrer"">address sanitizer</a> of gcc. The usual suspects, gdb and valgrind, were of little use. </p>

<p>Asan and other gcc sanitizers are wonderful and underrated tools, you should learn to use them (together with gdb and valgrind of course). </p>
",1
43177421,43177381,4,"<pre><code>new int 
</code></pre>

<p>is allocating memory. </p>

<p>By using defering operator * you are getting the value present at that memory location which would be garbage.</p>

<pre><code>#include &lt;iostream&gt;

void main()
{
    int x = *(new int);
    std::cout &lt;&lt; x;
    system(""pause"");
}
</code></pre>

<p>But this will cause the memory leak.</p>
",1
43178348,43177381,1,"<p>The expression <code>new int</code> creates an object of type <code>int</code> in allocated memory and returns a pointer to said object. Because no initializer is specified, the object is <em>default-initialized</em> and therefore has an <em>indeterminate value</em>.</p>

<p>The expression <code>int x = *(new int)</code> initializes <code>x</code> with the value of the object referenced by the pointer returned by <code>new int</code>. However, accessing indeterminate values in this way is <em>undefined behaviour</em>. Since standard imposes no requirements on the behaviour of programs containing undefined behaviour, any program containing the expression <code>int x = *(new int)</code> could, in theory, do <em>anything at all</em>.</p>

<p>If your were to initialize the object created by the <code>new</code> expression (e.g. <code>new int()</code>), then <code>x</code> would have whatever value you initialized the original object with. However, since you didn't store the pointer to the original object, there is no way to destroy the object using <code>delete</code>, so you have a <em>memory leak</em>.</p>
",3
39629060,39628963,0,"<p>You're declaring a useless variable <code>inflationRate</code> instead of calling the function <code>inflationRate</code>. I think this is what you want (I'm assuming the missing <code>#</code> on the first line was a copy-paste error):</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;


double inflationRate (double startingPrice, double currentPrice);  // &lt;-- Missing semicolon!


int main() // &lt;-- Not void; use int.
{
double startingPrice, currentPrice; // &lt;-- Removed inflationRate variable.
char again;

do 
{
    cout &lt;&lt; ""enter the price of the item when you bought it: "";
    cin &gt;&gt; startingPrice;

    cout &lt;&lt; ""enter the price of the item today: "";
    cin &gt;&gt; currentPrice;

    cout &lt;&lt; ""the inflation Rate is: "" &lt;&lt; inflationRate(startingPrice, currentPrice) &lt;&lt; ""%""; // &lt;-- Calling inflationRate

    cout &lt;&lt; ""would you like to try another item (y/n)?"";
    cin &gt;&gt; again;

}while((again == 'Y') || (again =='y'));

return 0;

}

double inflationRate(double startingPrice, double currentPrice)
{
    return ((currentPrice - startingPrice) / startingPrice);
}
</code></pre>
",0
47537743,47536985,1,"<p>On the default floating-point notation, the precision field specifies the maximum number of meaningful digits to display in total counting both those before and those after the decimal point. Notice that it is not a minimum and therefore it does not pad the displayed number with trailing zeros if the number can be displayed with less digits than the precision.</p>

<p>In both the <strong>fixed</strong> and <strong>scientific</strong> notations, the precision field specifies exactly how many digits to display after the decimal point, even if this includes trailing decimal zeros. The number of digits before the decimal point does not matter in this case.</p>

<p>thanks @UKMonkey.</p>

<pre><code>cout&lt;&lt;setprecision(5)&lt;&lt;1234.567;
    // output will be : 1234.5
</code></pre>
",0
45105617,45105539,2,"<p>When you use <code>delete</code> you are not deleting the pointer, so it makes no difference whether it is a stack pointer or any other kind of pointer.</p>

<p>When you use <code>delete</code> you are deleting the block of memory pointed by the pointer.  If that block was allocated with <code>new</code>, then it's always on the heap.  (If it was not allocated with <code>new</code>, then you should not <code>delete</code> it.)</p>
",2
45106432,45105539,2,"<p>The other angle is that no, you <strong>must not</strong> use operator <code>delete</code>, because you should never use naked pointers in non-library code. </p>

<p>In modern C++, your example should be:</p>

<pre><code>std::unique_ptr&lt;User&gt; p = std::make_unique&lt;User&gt;();
</code></pre>

<p>No <code>delete</code> and no <code>new</code> in sight.</p>

<p><strong>Note</strong>: in this particulate case, <code>make_unique</code> could be substituted for <code>new</code> painlessly, but since in other examples it might not be, it's a good practice to teach yourself - <code>make_unique</code> is a function to use.</p>
",0
42497872,42497841,1,"<p>You need to create an instance of the class, and call the member functions on that instance:</p>

<pre><code>int main() {
    weight my_weight;
    my_weight.get_curent_weight();
    my_weight.enter_data();
    my_weight.information();
    return 0;
}
</code></pre>
",0
42498456,42497841,0,"<p>A class can be called a blueprint; it's functions can only be implemented on an object of the class that function belongs to. That function cannot be called as a standalone. To resolve your error, you need to declare an object in your main() function with the data type <code>weight</code> and then call the function with that created object. An example of such would be like:</p>

<pre><code>weight object_name;

object_name.get_curent_weight();
object_name.enter_data();
object_name.information();
</code></pre>

<p>Alternatively, you can take the functions out of the class; this way, they can be used without an object of class <code>weight</code>. This will take a lot more effort over the first choice I suggested.</p>
",1
45702895,45702462,0,"<p>First, I'd like to suggest getting your input separately because it will greatly reduce the complexity of your code. </p>

<p>The problem you're facing is that all your inputs are <strong>treated at once</strong> when writing <code>34+56</code> and <strong>treated 3 times</strong> when read separately like in <code>34 + 56</code> (because of the space).</p>

<p>Therefore, what you need to do is read the whole line:</p>

<pre><code>std::cout &lt;&lt; ""Please enter a calculation:"";
std::string str;
std::getline (std::cin, str);
</code></pre>

<p>Then, you need to locate the sign and split your string there:</p>

<pre><code>// ""34+56""
std::size_t index = str.find_first_of(""+-/*"");    // returns the index 2
std::string operand1 = str.substr(0, index);      // ""34""
std::string operand2 = str.substr(index + 1);     // ""56""
</code></pre>

<p>Finally, you can output an </p>

<blockquote>
  <p>Error message for a number that has 2 digits or more and have only one digit in the variables val1 and val2.</p>
</blockquote>

<pre><code>// converts string -&gt; int
int val1 = atoi(operand1.c_str());
int val2 = atoi(operand1.c_str());

// check if in range
if( (val1&lt;0||val1&gt;9) || (val2&lt;0||val2&gt;9) ) {
    std::cout &lt;&lt; ""Operand must be between 0 and 10!"" &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Using first digit of operands...""  &lt;&lt; std::endl;

    //Edit(wrong operation): Use the leftmost character minus character '0'
    val1 = operand1[0] - '0';  
    val2 = operand2[0] - '0'; 
}
</code></pre>

<p><strong>Notes:</strong> I did not actually test this. There are many cases where this will fail(<strong>i.e</strong> there is more than one operation). You could also argue that finding the first valid character and saving it is more efficient, but I find extracting the whole operands into strings cleaner.</p>
",1
45702951,45702462,0,"<p>Solved it like this: </p>

<pre><code>while(true) {
    cout &lt;&lt; ""Please enter a calculation (operand operator operand):"" &lt;&lt; endl;
    while(true) {
        cin &gt;&gt; val1 &gt;&gt; op &gt;&gt; val2;
        if((val1&lt;0||val1&gt;9)||(val2&lt;0||val2&gt;9)) {
            cout &lt;&lt; ""Wrong input!  Try again."" &lt;&lt; endl;
            break;
        }
        cout &lt;&lt; ""val1: "" &lt;&lt; val1 &lt;&lt; ""  val2: "" &lt;&lt; val2 &lt;&lt; endl;
    }
}
</code></pre>

<p>Seems like the most obvious solution.  Thxalot!!</p>
",0
45702552,45702462,0,"<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
int main(){
    int x = 100;
    std::cout &lt;&lt;  std::to_string(x)[0] - '0';

}
</code></pre>

<p>okay that's fine. first digit in the number. I have c++11 solution.
while compiling add compiler flag <code>-std=c++11</code></p>
",2
39652332,39652281,2,"<p>First, you should declare the class before you use it's name. In your case it should be above the <code>main</code> function.</p>

<p>Second, you declared <code>Reloj</code> function with no return type, which is illegal.</p>

<p>The correct code may look like this:</p>

<pre><code>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

class Clock {
private:
    int h, m, s;
    char conv[];

    void Reloj() {
        h = 0;
        m = 0;
        s = 0;
        conv[10] = {};
    }

public:

    void processH(int ent) {
        int r =0; 
        while(r &lt;= 2) {
            conv[r] = 'I';
            if(conv == ""III"") {
                conv[0] = 'V';
                conv[1] = 'I';
                r++;
                break;
            }
            r++;
        }
        cout&lt;&lt; r;
    }
};


int main() {
    Clock r;
    r.processH(5);
    return 0;
}
</code></pre>
",0
39663589,39652281,0,"<p>Just a complement to Sergey's answer : You could also forward declare the class.
Just add the line</p>

<pre><code>class Clock;
</code></pre>

<p>before your <code>main</code> function to tell the compiler that the class exists.</p>
",0
34910828,34910422,1,"<p>You will need to do the addition one digit (4 bit) at a time because 9+9=18 and 18 won't fit in 4 bits.</p>

<p>x-oring multibit digits however is not the correct operation.. the correct algorithm for sum is something like</p>

<pre><code>int carry = 0;
for(int i=0; i&lt;n; i++) {
    if ((i &amp; 1) == 0) {
        int x = (a[i] &amp; 15) + (b[i] &amp; 15) + carry;
        result[i] = (x &amp; 15);
        carry = x &gt; 15;
    } else {
        int x = (a[i] &gt;&gt; 4) + (b[i] &gt;&gt; 4) + carry;
        result[i] |= (x &lt;&lt; 4);
        carry = x &gt; 15;
    }
}
</code></pre>

<p>Working in assembler many processors supports detection of an overflow in the lower 4 bits when doing an operation and there are specific instructions to ""fix"" the result so that it becomes the correct two-digit binary decimal representation (e.g. x86 provides <code>DAA</code> instruction to fix the result of an addition).</p>

<p>Working at the C level however this machinery is not available.</p>
",0
39247945,39247781,0,"<p>you are between space that try this line:</p>

<pre><code>cout &lt;&lt; x &lt;&lt;"" "";
</code></pre>

<p>but next number print new line that try this line:</p>

<pre><code>cout &lt;&lt; x &lt;&lt;""\n"";
</code></pre>
",2
39247833,39247781,2,"<pre><code>#include &lt;iostream&gt;

using namespace std;
int main()
{
    int x;
    for (x=0; x&lt;=5; x++)
    {
    cout &lt;&lt; x &lt;&lt; "" "";  // Add a trailing whitespace
    }
}
</code></pre>
",1
39247840,39247781,0,"<p>You need to let compiler know that you mean character. 
x\t is not valid c++.
Use this instead:</p>

<p><code>cout &lt;&lt; x &lt;&lt; '\t'</code></p>
",3
39317528,39317505,1,"<p>Currently your program is waiting for an EOF character which indicates the input has ended. If you are running this and entering the input from the command line, you can manually insert an EOF by pressing Ctrl+D on *nix, or Ctrl+Z on windows. This will cause your program to break out of your getline loop.</p>

<p>If you would rather not do that, you need a way to break out of the getline loop, otherwise it will continue to run in that loop.</p>

<p>A nice idea might be detecting an empty line, so pressing enter twice ends the loop:</p>

<pre><code>while(getline(cin,line)){     //on each line
    if(line == """")
        break;
    ...
}
</code></pre>
",15
39317606,39317505,2,"<p>Your loop is correct as written; you just don't know how to signify the end of input. You're sitting there waiting for the program to progress, but the program is sitting there waiting for you to give it more input.</p>

<p>Press Ctrl+D (Linux) or Ctrl+Z (Windows) to send the EOF character/signal/potion to end the loop.</p>

<p>This way, all the common shell techniques like file redirection and pipes will also work.</p>

<p>Introducing artificial means like a double-newline or some magic command is non-conventional and makes your program harder to automate. (And making your program magically know that one of the newlines came from a keyboard hit rather than copy/pasting, is just not possible. Nor do you want it to be! That breaks a ton of valuable abstractions.) When writing a command-line tool, stick to standard practices as much as possible.</p>
",4
43961088,43960756,0,"<p><code>cin</code> has <code>fail()</code> method that can be use to check if a read was successful or not, with conjuncture of properly placed code.</p>

<p>Try this:</p>

<pre><code># include &lt;iostream&gt;

using namespace std;
//Function Declarations
//Shouf shouf Habibi row.

int shouf_normal (int a, int b )
{   
    int shouf_normal=a* b;
    return shouf_normal; 
}

int shouf_Premium(int b, int c)
{
  int shouf_premium=b*c;
  return shouf_premium;
}

//The interview row
double interview_normal(double c, double d)
{
    double interview_normal=(c*d);
    return interview_normal;
}

double interview_premium(double d, double e)
{
    double interview_premium=d*e;
    return interview_premium;
}

//New Kids turbo row
int turbo_normal(int e, int f)
{
    int turbo_normal=e*f;
    return turbo_normal;
}

// The Butterflies row
int butterflies_normal(int f, int g)
{
    int butterflies_normal=f*g;
    return butterflies_normal;
}

void display_menu() {
    cout&lt;&lt;""\n\t""&lt;&lt;endl;
    cout&lt;&lt;""\t|******************************************************************|""&lt;&lt;endl;
    cout&lt;&lt;""\t|Welcome to A31 Cinema, where you watch latest and cheapest movies.|""&lt;&lt;endl;
    cout&lt;&lt;""\t|******************************************************************|""&lt;&lt;endl;
    cout&lt;&lt;""\n\tBelow are the movies screening lists.\n\tThe price of tickets are given according to seats classes\n\tand quality of movie.""&lt;&lt;endl;
    cout&lt;&lt;""\n\tNote:Glassses for 3D movies cost $3.00.""&lt;&lt;endl;
    cout&lt;&lt;""\t___________________________________________________________________""&lt;&lt;endl;
    cout&lt;&lt;""\t| Movie Title         |       Normal        |      Premium         |""&lt;&lt;endl;
    cout&lt;&lt;""\t|_____________________|_____________________|______________________|""&lt;&lt;endl;
    cout&lt;&lt;""\t|1.Shouf Shouf Habibi |        $5.00        |      $7.00           |""&lt;&lt;endl;
    cout&lt;&lt;""\t|_____________________|_____________________|______________________|""&lt;&lt;endl;
    cout&lt;&lt;""\t|2.The Interview (3D) |        $7.00        |      $9.50           |""&lt;&lt;endl;
    cout&lt;&lt;""\t|_____________________|_____________________|______________________|""&lt;&lt;endl;
    cout&lt;&lt;""\t|3.New Kids Turbo (3D)|        $7.00        |""&lt;&lt;endl;
    cout&lt;&lt;""\t|_____________________|_____________________|""&lt;&lt;endl;
    cout&lt;&lt;""\t|4.Black Butterflies  |        $5.00        |""&lt;&lt;endl;
    cout&lt;&lt;""\t|_____________________|_____________________|""&lt;&lt;endl;
}

int main()
{
    //constant initials
    const int a=5;
    const int b=7;
    const double c=7;
    const double d=9.5;
    const int e=7;
    const int glass=3;
    const int f=5;
    double total_tickets=0;
    int choice=0; 
    int number=0;
    char reply;

    bool correct_entry=true;
    string not_int;
    int not_char;


    while(true){

        display_menu();

        do {
            cout&lt;&lt;""\n\tPlease choose from the lists (1-4) above and press enter or \n\tPress any other key to quit:"";
            cin&gt;&gt;number;

            // You cannot check number for Q or q because number is int, and Q/q is char
            if(cin.fail()) {
                cout&lt;&lt;""\n\t\tThank You purchasing movie tickets with us!""&lt;&lt;endl;
                return 0;
            }

        } while(number &lt; 1 &amp;&amp; number &gt; 4 );

        if (number==1) {
            cout&lt;&lt;""\n\tYou have selected \""Shouf Shouf Habibi\""."";
            cout&lt;&lt;""\n\tFor Normal; Press \""N\"" or for premium class; Press \""P\"":"";
            cin&gt;&gt;reply;

           if (reply=='N'|| reply=='n') {
            cout&lt;&lt;""\n\tYou have selected Normal class.""&lt;&lt;endl;
            cout&lt;&lt;""\n\tPlease choose the number of tickets you want:"";
            cin&gt;&gt;choice;

            total_tickets=shouf_normal(a,choice);
            cout&lt;&lt;""\n\tYour total costs is=$""&lt;&lt;total_tickets&lt;&lt;endl;  //calculating &amp; printing out cost 

           } else if(reply=='P'||reply=='p'){

            cout&lt;&lt;""\n\tYou have selected Premium class.""&lt;&lt;endl;
            cout&lt;&lt;""\n\tPlease choose the number of tickets you want:"";
            cin&gt;&gt;choice;

            total_tickets=shouf_Premium (b,choice);
            cout&lt;&lt;""\n\tYour total costs is=$""&lt;&lt;total_tickets&lt;&lt;endl;  //calculating &amp; printing out cost 
          }
        } else if(number==2) {
            cout&lt;&lt;""\n\tYou have selected \""The interview\""in 3D quality."";
            cout&lt;&lt;""\n\tFor Normal; press \""N\"" or for premium class; Press \""P\"":"";
            cin&gt;&gt;reply;

            if(reply=='N'|| reply=='n'){
                cout&lt;&lt;""\n\tYou have selected Normal class."";
                cout&lt;&lt;""\n\tPlease choose the number of tickets you want:"";
                cin&gt;&gt;choice;
                total_tickets=interview_normal(c,choice)+(glass*choice);

                cout&lt;&lt;""\n\t Price for one ticket is $""&lt;&lt;c&lt;&lt;endl;
                cout&lt;&lt;""\n\tPrice for one 3D glass is $""&lt;&lt;glass&lt;&lt;endl;
                cout&lt;&lt;""\n\t Your total costs is=$""&lt;&lt;total_tickets&lt;&lt;endl;
            } else if  (reply=='P'|| reply=='p') {
                cout&lt;&lt;""\n\tYou have selected Premium class."";
                cout&lt;&lt;""\n\tPlease choose the number of tickets you want:"";
                cin&gt;&gt;choice;
                total_tickets=interview_premium(d,choice)+(glass*choice);

                cout&lt;&lt;""\n\t Price for one ticket is $""&lt;&lt;d&lt;&lt;endl;
                cout&lt;&lt;""\n\tPrice for one 3D glass is $""&lt;&lt;glass&lt;&lt;endl;
                cout&lt;&lt;""\n\t Your total costs is=$""&lt;&lt;total_tickets&lt;&lt;endl;
            }
        } else if(number==3) {

                cout&lt;&lt;""\n\tYou have selected \""The New Kids Turbo\"" in 3D quality."";
                cout&lt;&lt;""\n\tThis moview is available only in Normal class."";
                cout&lt;&lt;""\n\tPlease choose the number of tickets you want:"";
                cin&gt;&gt;choice;
                total_tickets=turbo_normal(e,choice)+(glass*choice);

                cout&lt;&lt;""\n\t Price for one ticket is $""&lt;&lt;e&lt;&lt;endl;
                cout&lt;&lt;""\n\tPrice for one 3D glass is $""&lt;&lt;glass&lt;&lt;endl;
                cout&lt;&lt;""\n\tYour total costs is=$""&lt;&lt;total_tickets&lt;&lt;endl;
        } else if(number==4) {

            cout&lt;&lt;""\n\tYou have selected \""Black Butterflies\""."";
            cout&lt;&lt;""\n\tThis Movie is available only in Normal class."";
            cout&lt;&lt;""\n\tPlease choose the number of tickets you want:"";
            cin&gt;&gt;choice;   
            total_tickets=butterflies_normal(f,choice);
            cout&lt;&lt;""\n\tYour total costs is=$""&lt;&lt;total_tickets&lt;&lt;endl; 
        } 

        // Wait for user to enter some key so that they can view their bill.
        cout&lt;&lt;endl&lt;&lt;""Press any key to continue...."";
        cin.ignore();
        cin.get();
    }
    return 0;
}
</code></pre>
",0
42635735,42635618,-3,"<p>The subreddit <a href=""https://www.reddit.com/r/dailyprogrammer/"" rel=""nofollow noreferrer"">The Daily programmer</a> post challenges, well, daily.</p>

<p>They are categorized by level, so you can test yourself and see what level are you and even compete with others.</p>

<p>enjoy</p>
",0
42636049,42635618,-2,"<p>Check Herb Sutter's <a href=""https://rads.stackoverflow.com/amzn/click/com/0201615622"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Exceptional C++</a> book, it has very good challenges. If you've already read it, there are sequels to that one as well, namely <a href=""https://rads.stackoverflow.com/amzn/click/com/020170434X"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">More Exceptional C++</a> and <a href=""https://rads.stackoverflow.com/amzn/click/com/0201760428"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Exceptional C++ Style</a></p>
",0
39320234,39320203,0,"<blockquote>
  <p>error C2955: 's_node': use of class template requires template
  argument list</p>
</blockquote>

<p>The above error is very obvious to what the issue is.</p>

<p>The usage <code>s_node *p_newNode = new s_node;</code> is wrong. You should be doing this instead:</p>

<pre><code>s_node&lt;T&gt; *p_newNode = new s_node&lt;T&gt;;
</code></pre>

<p>You require the template arguments for a templated class. In addition, the class return type needs to be:</p>

<pre><code>s_node&lt;T&gt;* createNode(s_node *p_parent = NULL) {
//....
}
</code></pre>

<p><strong>Side Note</strong>: As a recommendation, use <code>nullptr</code>, instead of <code>NULL</code>, it is more modern.</p>
",0
42639364,42639251,0,"<p>One of the problems is in your declaration of the main function:</p>

<pre><code>main()
</code></pre>

<p>In c++, the <code>main()</code> function <strong>must</strong> have a return type of <code>int</code>. Sin you have not specified any data type for the return value of <code>main()</code>, it sets the return data type to void, which is  produces the error just before <code>main()</code>. To learn and understand more about <code>main()</code> for C++, visit the following link <a href=""http://en.cppreference.com/w/cpp/language/main_function"" rel=""nofollow noreferrer"">Main Function</a>.</p>

<p>To sort this, change the above line of code to:</p>

<pre><code>int main() // notice that the return type here is int. This is required in c++
</code></pre>

<p>Another thing: in these lines:</p>

<pre><code>int index = search;
(SD2, lname, fname, last);
</code></pre>

<p>Over here, you want to pass <code>SD2</code>,  <code>lname</code>, <code>fname</code> and <code>last</code> to the  <code>search()</code> function. However, your syntax is wrong. The function and its parameters when called cannot be split by a semicolon, because a semicolon terminates the statement. Therefore, the compiler sees <code>search</code> as a variable, not a function. This along with the statement following it cause the error. You should change those 2 lines to:</p>

<pre><code>int index = search(SD2, lname, fname, last); // this is proper syntax to call a function.
</code></pre>

<p>Also, you need to take out <code>search()</code> from inside the main() function and place it above the main() function. That is also causing an error.</p>
",0
39324729,39324641,0,"<p>A single exit() statement close your code instantly but is not a desired statement.</p>

<p>You could use a if statement when your function return a bool like this.</p>

<pre><code>bool func();

func(){
// Do Stuff
return  // true or false
}

void main(){
    if(func()){
        // Do Stuff
    }else{
        //Do other Stuff
}
}
</code></pre>
",0
39324774,39324641,2,"<p>As pointed out by ¦Ð?¦Í¦Ó¦Á ?¦Å?  you can use <code>exit(0)</code> at the end of the <code>anotherMessage()</code> definition.</p>

<p><code>exit(0)</code> indicates successful program termination &amp; it is fully portable, While</p>

<p><code>exit(1)</code> (usually) indicates unsucessful termination. However, it's usage is non-portable.</p>

<p>If you're writing a function that could end up in a library for instance, calling exit from there is bad practice in general: it is much better to signal an error to the calling code (via a specific return value or exception for instance) and let the calling code decide what to do. (There are cases when it's perfectly valid though. e.g. if you're writing a function called quit_if_file_not_found, well, your users are expecting a termination.)</p>

<p>In your case, your parsing function probably shouldn't call exit: you might want, for example, at some point in the future, your main code to ask the user for a different file name if parsing the first one failed. If your parsing routine terminates the program, you have to modify both your main code and that function. If it had signaled an error condition, you'd only have to modify the logic in main.</p>

<p>(And don't just exit without printing an error message or logging something like you're doing above, that will make for frustrated users who can't know how to fix whatever issue it is the code encountered.)</p>
",2
39325183,39324641,1,"<p>You can define the type of anotherMessage() function as int, return an integer value ( 1 in the below code). Check if returned value is one, if yes, then exit from the program by calling exit(0).</p>

<pre><code>void main()
{
cout &lt;&lt; ""Hello World"";
int val = anotherMessage();
if(val) exit(0);
cout &lt;&lt; ""Dont print this"";
}
int anotherMessage()
{
cout &lt;&lt; ""Print this"";
return 1;
}
</code></pre>
",0
42641585,42641262,2,"<p>I found it!</p>

<p>its here</p>

<pre><code>PromptChoice(list[stillInTheRunning[i]], list[stillInTheRunning[i + 1]])
</code></pre>

<p>on the second run of the for loop i = 2;
after poping off one item off the back the vector's size was now 3 instead of 4 so stillInTheRunning[i + 1] was trying to get the item in index 3 which now does not exist.</p>
",0
42641592,42641262,0,"<p>The problem is when you <code>pop_back</code>, the size of <code>stillInTheRunning</code> decreases, but <code>matchupsThisRound</code> stays the same, so eventually the loop reaches the point where <code>i+1</code> is out of the <code>stillInTheRunning</code>'s range.</p>

<p>Also it's a bit weird that you're increasing <code>i</code> by 2 every cycle, but <code>pop_back</code> only once.</p>
",0
42651179,42650860,2,"<p>First of all you missed with indices.
Should be 
<code>cin &gt;&gt; matrix[x*rows + y];</code>
instead of
<code>cin &gt;&gt; matrix[x*rows + cols];</code></p>

<p>Second why do you want to create matrix of <code>float *</code> instead of just <code>float</code>?</p>

<pre><code>float *allocate(int rows, int cols) {
    float* matrix = new float[rows * cols];
    return matrix;
}//end allocate
</code></pre>
",0
39333406,39333188,1,"<blockquote>
  <p>What's the ""thing"" that I'm iterating through?</p>
</blockquote>

<p>The range that is delimited by the result of <code>foo.begin()</code> and <code>foo.end()</code>.</p>

<p>Yes, these function names are ""special"" in that regard. Call it a standard-approved convention.</p>
",1
42665537,42665173,0,"<p>This macro defines a mask for all ping types.</p>

<p>It is bitwise operation</p>

<p>Same as</p>

<pre><code>#define PINGTYPE_ICMP_PING 0x2
#define PINGTYPE_TCP  0x10
#define PINGTYPE_TCP_USE_SYN 0x40
#define PINGTYPE_ICMP_TS 0x8
</code></pre>

<p>When you do bitwise OR you get</p>

<pre><code>0x2 | 0x10 | 0x8 | 0x40 = 0x5A 
</code></pre>

<p>it is more clear in binary format (using 8 bits for simplify)</p>

<pre><code>00000010 (2)
01000000 (64)
00001000 (8)
00010000 (16)
=============
01011010  (5A)
</code></pre>
",0
39623053,39622905,1,"<p>Before you work on the extras, lets get started with fixing the program.</p>

<h1>What is wrong?</h1>

<ol>
<li><p><strong><code>=</code> operator vs. <code>==</code> operator</strong></p>

<p><code>else if (num = guess) cout &lt;&lt;""Congratulations you guessed corectly!!"" &lt;&lt; endl;</code></p></li>
</ol>

<p><code>num = guess</code> will ssign <code>guess</code> to <code>num</code> and return true. That will make sure you get this output on the first time, if no other input were chosen.</p>

<ol start=""2"">
<li><p><strong>user experience / logic exception</strong></p>

<p><code>while (guess != -1);</code> </p></li>
</ol>

<p>well, you ask a user to guess from 1 to 100 and wait till they hit the -1. that's kinda cruel.</p>

<ol start=""3"">
<li><p><strong>uninitialized input</strong></p>

<p><code>int guess;</code></p></li>
</ol>

<p>compilers use to yell at you if you don't initialize these before you input.</p>

<h1>How to fix?</h1>

<pre><code>int main()
{
    srand(time(NULL));
    int num = rand() % 100 + 1;
    int guess = 0;                           // Problem 3

    do {
        cout &lt;&lt; ""Pick a number 1-100: "";
        cin &gt;&gt; guess;
        if (num == guess)                    // Problem 1
            cout &lt;&lt;""Congratulations! you guessed corectly!!"" &lt;&lt; endl;
        else if (num &lt; guess) 
            cout &lt;&lt;""Too High"" &lt;&lt; endl;
        else 
            cout &lt;&lt;""Too Low"" &lt;&lt; endl;
        } 
    while (guess != num);                    // Problem 2   

    return 0;
}
</code></pre>

<hr>

<p>Now you can move on to continue with adding some more features.</p>
",3
39643054,39643011,1,"<p>Corrected code is:</p>

<pre><code>#include&lt;conio.h&gt;
#include&lt;stdio.h&gt;
int main(){
    int a;
    int b[20];
    int q = 0;
    printf(""decimal : "");scanf(""%d"",&amp;a);
    while(a&gt;0) {
        b[q]=a%2;
        a=a/2;      
        q++;

    }
    printf(""binary : "");

    for (int i = q-1; i&gt;=0;i--){
        printf(""%d"",b[i]);
    }

}
</code></pre>

<p>You were printing b[q] instead of b[i]</p>
",0
39643608,39643011,1,"<p>There are some problems with your code:</p>

<ol>
<li>you added an extra "")"" of the first while;</li>
<li>the second 'while' is useless (the code is being repeated due to the first one)</li>
<li>you are not printing the elements you want (you should use var 'i'), what you are really printing is the value after the last 0/1 (because you are using 'q')</li>
</ol>

<p>code should look like this:</p>

<pre><code>#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;

int main() {
    int a;
    int b[20];
    int q = 0;
    printf(""decimal: "");
    scanf(""%d"", &amp;a);
    while (a &gt; 0) {
        b[q] = a % 2;
        a = a / 2;
        q++;
    }
    printf(""binary: "");
    for (int i = q - 1; i &gt;= 0; i--) {
        printf(""%d"", b[i]);
    }
}
</code></pre>
",0
39643041,39642864,1,"<p>The code is far more complex than it needs to be. It's much simpler to just read one value at a time:</p>

<pre><code>std::vector&lt;double&gt; myArray;
double value;
std::ifstream myfile(temp2.csv);
if (!myfile) {
    std::cout &lt;&lt; ""Unable to open file\n"");
    return EXIT_FAILURE;
}
while (myfile &gt;&gt; value)
    myArray.push_back(value);
</code></pre>
",2
39642933,39642864,2,"<p>You can't do </p>

<pre><code>myArray[index++] = atoi( line.c_str() );
</code></pre>

<p>It is an empty vector. You either need to <code>push_back</code> elements into it. Or initialize it with sufficient memory.</p>

<p>This should work:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;stdlib.h&gt;
using namespace std;

int main () {
    string line;
    ifstream myfile (""temp2.csv"");
    std::vector&lt;double&gt; myArray;
    int index = 0;
    if (myfile.is_open())
    {
        while (! myfile.eof() )
        {
            getline (myfile,line);
            cout &lt;&lt; line &lt;&lt; endl;
//            myArray[index++] &lt;&lt; line;
            myArray.push_back(atoi( line.c_str() ));
        }
        myfile.close();
    }

    else cout &lt;&lt; ""Unable to open file"";

    return 0;
}
</code></pre>
",0
39642935,39642864,1,"<p>On this line:</p>

<pre><code>std::vector&lt;double&gt; myArray;
</code></pre>

<p>You create a vector using the default constructor. As you can see from the documentation, the default constructor creates an <strong>empty</strong> vector.</p>

<p>On this line:</p>

<pre><code>myArray[index++] = atoi( line.c_str() );
</code></pre>

<p>You access elements from the vector with successively increasing indices. But those elements do not exist and the indices are out of bounds because the vector is empty. Accessing outside the bounds of the vector has undefined behaviour.</p>

<p>TL;DR you forgot to add any elements into the vector.</p>
",0
37759122,37759067,0,"<pre><code>int d1[star1], d2[star2];
</code></pre>

<p>The size of the <code>d2</code> array is <code>star2</code>.</p>

<pre><code>for (int i=0; i&lt;star1; i++)
  {if (d1[begin]==d2[i])
</code></pre>

<p>The inner loop, <code>i</code>, iterates from 0 to <code>star1-1</code>, but the size of the <code>d2</code> array is <code>star2</code>.</p>

<p>This appears to be the bug. This should probably be:</p>

<pre><code>for (int i=0; i&lt;star2; i++)
  {if (d1[begin]==d2[i])
</code></pre>
",0
37759126,37759067,1,"<p>The first problem I see with you approach is you are assuming that the point of rotation is the origin. What if the set has been rotated about a different point?</p>

<p>Also, it seems to me that the prompt at the link you posted says the second image is a slight rotations <em>and a slight shift</em> from the first. This would imply that the point of rotation could be different in both sets. Also, note that the problem statement suggests a star near the edge may leave the image space. This case would need consideration.</p>

<p>Try thinking about how to find the point of rotation in each image. What properties does it have, and are there any ways you can use geometric properties to isolate it? If you were able to get both points of rotation, you would be able to proceed similarly to your suggested solution.</p>
",0
41945182,41945047,1,"<p>It seems as if your terminal does not receive or neglect the line feed, such that every new line overwrites the previously written one.</p>

<p>One thing could be that the input file contains only the carriage return but now line feed, and for some reason <code>getline</code> does not correct this. If this is the issue, see the following answer on <a href=""https://stackoverflow.com/a/6089413/2630032"">SO</a> (please don't forget to upvote if helpful).</p>

<p>Another thing could be that the line feed is not written to <code>cout</code>. I'd suggest - at least for diagnostic purpose - to try <code>printf(""%s\r\n"",line.c_str())</code>.</p>
",2
40573990,40573881,1,"<p>You get error message at <code>cout &lt;&lt; w * z &lt;&lt; endl;</code> because there is no overload of <code>operator&lt;&lt;</code> which takes class <code>Fraction</code> as an argument. Try defining this overload:</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Fraction&amp; f)
{
    return os &lt;&lt; f.den &lt;&lt; ""/"" &lt;&lt; f.num;
}
</code></pre>

<p>And add the following line to the definition of <code>class Fraction</code> in order to make <code>den</code> and <code>num</code> available to this function:</p>

<pre><code>friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Fraction&amp; f);
</code></pre>
",5
39668671,39668537,0,"<p>Your code is actually doing a mirror transformation about the vertical center. Also, you're looping through a vector and then re-assigning back to that vector. This means you're going to be filling the vector with values that dont reflect your original passed vector at some point in the second for-loop.</p>

<p>For an algorithm that is generic to the number of pixels in x,y here is something:</p>

<pre><code>typedef std::vector&lt;int&gt; IVec;

void pgm_cw( std::vector&lt;IVec&gt; &amp;p )
{
    // Need to allocate an array to store the transform
    std::vector&lt;IVec&gt; temp(p[0].size(), IVec(p.size()));

    int count = 0;        // count variable
    int count2 = 0;      // 2nd count variable

    for( count = 0; count &lt; p.size(); count++ )
    {
        for( count2 = 0; count2 &lt; p[0].size(); count2++ )
        {
            // Clockwise rotation
            temp[count2][temp[0].size()-count-1] = p[count][count2];
            // Counter-clockwise rotation
            //temp[temp.size()-count2-1][count] = p[count][count2];
        }
    }

    p = temp;       // set p equal to temp
}
</code></pre>

<p>I've included an explicit <code>typedef</code> so that I could test it out. Here's a quick test:</p>

<pre><code>BEFORE:
  1  2  3  4
  5  6  7  8
  9 10 11 12
AFTER:
  9  5  1
 10  6  2
 11  7  3
 12  8  4
</code></pre>

<p>Hopefully that helps a bit for the asymmetric array case.</p>
",4
39668769,39668537,2,"<p>A simpler approach for your problem.</p>

<pre><code>void pgm_cw( vector &lt;IVec&gt; &amp;temp )
{

    int N = temp.size();

    for (int x = 0; x &lt; N / 2; x++)
    {
        for (int y = x; y &lt; N-x-1; y++)
        {
            // store current cell in temp variable
            int tmp = temp[x][y];

            // move values from right to top
            temp[x][y] = temp[y][N-1-x];

            // move values from bottom to right
            temp[y][N-1-x] = temp[N-1-x][N-1-y];

            // move values from left to bottom
            temp[N-1-x][N-1-y] = temp[N-1-y][x];

            // assign temp to left
            temp[N-1-y][x] = tmp;
        }
    }
    //std::swap(p,temp);
    //p = temp;       // set p equal to temp
}
</code></pre>

<p><a href=""http://www.geeksforgeeks.org/inplace-rotate-square-matrix-by-90-degrees/"" rel=""nofollow"">Inplace rotate square matrix by 90 degrees</a></p>
",2
45743154,45743126,1,"<p>The problem is that you're using an unmodified <code>auto</code> in your for loop.  This creates a copy of each map element, and then you modify the copy.  You need a reference if you want to change the entry in the map.  Try this instead:</p>

<pre><code>for (auto&amp; m : smap)
{
  m.second /= 2;
}
</code></pre>
",5
45767694,45767657,3,"<p>In the second example, two object are passed. There's <code>a</code> and there is also <code>this</code>. The object passed as <code>this</code> is the left side of the operation.</p>

<p>Also note that your member <code>operator+</code> should be const, since it doesn't mutate any data members of <code>this</code>.</p>

<p>Your member operator also invoke undefined behavior, since you are using a unassigned value:</p>

<pre><code>// The member function
operatorOver operator+(const operatorOver &amp;a) {
    operatorOver aa;

    // What is the value of aa.a? Undefined behavior!
    aa.a = aa.a + a.a;
    return aa;
}
</code></pre>

<p>To be equivalent to you non-member function, it should be this implementation:</p>

<pre><code>// The member function
operatorOver operator+(const operatorOver &amp;a) const {
    operatorOver aa;

    // Member `a`, could be written `this-&gt;a`
    aa.a = a + a.a;
    return aa;
}
</code></pre>
",1
45767717,45767657,3,"<p>Some of the binary operators, such as <code>+</code>, can be overloaded as member functions as well as non-member functions.</p>

<p>When <code>+</code> is overloaded as a member function, the function needs to be declared with one argument. When the operator is used as:</p>

<pre><code>a + b
</code></pre>

<p>the call is resolved as</p>

<pre><code>a.operator+(b);
</code></pre>

<p>When it is overloaded as a non-member function, the function needs to be declared with two arguments. When the operator is used as:</p>

<pre><code>a + b
</code></pre>

<p>the call is resolved as</p>

<pre><code>operator+(a, b);
</code></pre>

<p>Further reading: <a href=""http://en.cppreference.com/w/cpp/language/operators"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/language/operators</a></p>
",3
47497582,47497435,0,"<p>Here is an example of how to overload the int addition.</p>

<pre><code>struct n { int x; };

int operator + (int lhs, n rhs)
{
    return lhs + rhs.x;
}
</code></pre>
",0
39669398,39581449,-1,"<p>I do belive it is easier to have a value <code>Something</code>. Half it each loop, or <code>somthing = 1/pow(2,n)</code>(1 divided by 2 to the power of n). Then sum is 1-<code>something</code>. Less code is always nice. :)</p>

<p>Another improvement is:</p>

<pre><code>for (denom = 2; nthTerm &lt; finalDenom; denom *= 2)
    {
        cout &lt;&lt; ""1/"" &lt;&lt; denom;
        ++nthTerm;

            cout &lt;&lt; "" + "";

        sum += 1.0 / denom;
    }
    Cout &lt;&lt; ""="";
</code></pre>

<p>And minor tweaking to this code</p>

<p>So my code would be</p>

<pre><code>for (denom = 2; nthTerm &lt; finalDenom; denom *= 2)
{
    cout &lt;&lt; ""1/"" &lt;&lt; denom;
    ++nthTerm;

        cout &lt;&lt; "" + "";
}
Cout &lt;&lt; ""="";
Sum = 1 - (pow(2,finalDenom));
</code></pre>

<p>If you think this i a bad answer, explain why so I can improve my answer.</p>
",6
39675225,39581449,2,"<p>I think that your approach is inefficient and imprecise. This is a geometric progression. The sum of this sequence could be found with a single expression. </p>

<p><a href=""https://i.stack.imgur.com/iRg3d.gif"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/iRg3d.gif"" alt=""enter image description here""></a></p>

<p>Just substitute r with 1/2 in this formula.</p>
",0
39681000,39581449,0,"<p>As mentioned your problem is in the if conduction.However I would throw it away completely.</p>

<pre><code>   #include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

int main()
{
    int denom,              // Denominator of a particular term
        finalDenom,         // Denominator of the final term
        nthTerm;            // Nth term run
    double sum = 0.0;          // Accumulator that adds up all terms in the series
    char repeat;

    do
    {
        cout &lt;&lt; ""This program sums the series 1/2^1 + 1/2^2 + 1/2^3 + . . . + 1/2^n\n"";
        cout &lt;&lt; ""What should n be in the final term (between numbers 2 and 10)? "";
        cin &gt;&gt; finalDenom;
        denom=2;
        for (nthTerm = 0; nthTerm &lt; finalDenom; nthTerm++)

        {
            denom*=2;

            cout &lt;&lt; ""1/"" &lt;&lt; denom;
            cout &lt;&lt; "" + "";                      
            sum += pow(denom, -1);
        }

        cout &lt;&lt; "" = "";

        cout &lt;&lt; sum &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;

        cout &lt;&lt; ""Do you wish to compute another series? "";
        cin &gt;&gt; repeat;
        repeat = toupper(repeat);
    } while ((repeat == 'Y'));


    return 0;
}
</code></pre>

<p>output:</p>

<pre><code>This program sums the series 1/2^1 + 1/2^2 + 1/2^3 + . . . + 1/2^n
What should n be in the final term (between numbers 2 and 10)? 1
1/4 +  = 0.25


Do you wish to compute another series? y
This program sums the series 1/2^1 + 1/2^2 + 1/2^3 + . . . + 1/2^n
What should n be in the final term (between numbers 2 and 10)? 2
1/4 + 1/8 +  = 0.625


Do you wish to compute another series? y
This program sums the series 1/2^1 + 1/2^2 + 1/2^3 + . . . + 1/2^n
What should n be in the final term (between numbers 2 and 10)? 4
1/4 + 1/8 + 1/16 + 1/32 +  = 1.09375


Do you wish to compute another series? n

Exit code: 0 (normal program termination)
</code></pre>
",0
34979609,34979554,0,"<p>According to the C++ Standard (9.2 Class members)</p>

<blockquote>
  <ol>
  <li>...<strong>A member shall not be declared twice in the member-specification</strong>, except that a nested class or member class
  template can be declared and then later defined, and except that an
  enumeration can be introduced with an opaque-enum-declaration and
  later redeclared with an enum-specifier.</li>
  </ol>
</blockquote>

<p>You declared and defined the default constructor  two times</p>

<pre><code> ManagedArray() :elements(NULL){};
 ManagedArray() :numberOfElements(0){}; &lt;--Where the error is
</code></pre>

<p>You could add a parameter to the second constructor as for example</p>

<pre><code> ManagedArray() :elements(NULL){};
 ManagedArray( int n ) :numberOfElements(n){};
</code></pre>

<p>or the following way</p>

<pre><code> explicit ManagedArray( int n ) :numberOfElements(n){};
 ^^^^^^^^
</code></pre>

<p>Take into account that instead of type <code>int</code> it is better to use type <code>size_t</code> for data member <code>numberOfElements</code> at least because the number of elements can not be negative.</p>

<p>Also the both constructors should initialize all data members.</p>

<p>For example</p>

<pre><code> ManagedArray() :elements(NULL), numberOfElements( 0 ){};
</code></pre>
",1
39684273,39684237,0,"<p>It should look more like this:</p>

<pre><code>for (int y = 0; y &lt; height; y++)
{
    string line;
    getline(file,line);

    std::istringstream line_stream(line);

    for (int x = 0; x &lt; width; x++)
    {
        int value;
        line_stream &gt;&gt; value;
    }
}
</code></pre>
",0
39684315,39684237,0,"<p>You can not access a stream like this, it is serial in nature.Using streams pseudo code could look like this (did not try to compile, however this is the idea)</p>

<pre><code>#include &lt;iostream&gt;     // std::cout
#include &lt;fstream&gt;      // std::ifstream

int main () {

  std::ifstream ifs (""test.txt"", std::ifstream::in);

#define LINE_SIZE 10    
  char c = ifs.get();

  for (int i=0;ifs.good();i++) {
      // this element is  at row :(i/LINE_SIZE)  col: i%LINE_SIZE
      int row=(int)(i/LINE_SIZE);
      int col=(i%LINE_SIZE);
    myFunction(row,col,c);
    c = ifs.get();
  }

  ifs.close();

  return 0;
}
</code></pre>
",0
41182626,41182355,0,"<p>One (ugly) solution is :</p>

<pre><code>for( mon = jan; mon &lt;= dec; mon = (months)(mon + 1) )
{
    printf(""%d"", mon);
}
</code></pre>

<p>But it only works because the values of your enum are continuous and won't work with your <code>TV enum</code> for exemple.</p>
",0
39597439,39596479,0,"<p>Please check if the file is opened correctly. Add the below code  after  <code>inputFile.open(""numbers.txt"");</code></p>

<pre><code>if(inputFile.fail())
{
    cerr&lt;&lt; ""Error Opening File"" &lt;&lt; endl;
    exit(1);
}
</code></pre>

<p>Also try giving the absolute path of the file if there is an error in opening the file.</p>
",5
46129068,46129024,17,"<ol>
<li><p>Adding the extra inline is a matter of style. That specifier has to do with linkage and ODR violations, not actual inlining. All inline member function definitions and template member functions in general have that specifier <em>implicitly</em>. I assume Scott Meyers added it there for pedagogical reasons.</p></li>
<li><p>Effective C++ was written for C++03 originally. There was no <code>= delete</code> back then. Declaring but not defining a function was all you could do back then.</p></li>
<li><p>This is aggregate initialization. This implementation of <code>nullptr_t</code> can be initialized like that even in C++03. It creates the value of <code>nullptr</code>. Since <code>nullptr_t</code> doesn't have a user provided default c'tor, it's required.</p></li>
</ol>
",8
34956877,34956856,1,"<p>Remove the <code>float</code> portion from <code>float avgQ &lt; 50</code> and <code>float markF &lt; 50</code></p>

<p>Not sure how you got the idea that was necessary.</p>
",0
34956939,34956856,1,"<p>It should be:</p>

<pre><code>if ((/*float*/ avgQ &lt; 50) || (/*float*/ markF &lt; 50))
</code></pre>
",1
39635764,39633899,1,"<p>The first warning is clear: the function is declared to return an <code>int</code>, but doesn't return anything. If it's ever called, it will cause Undefined Behaviour (UB) of the program.</p>

<p>For the second warning, whether UB will happen or not depends on the relationship between these two conditions:</p>

<ul>
<li><code>(rw &amp; fdwatch_type_read) &amp;&amp; !(rw &amp; fdwatch_type_accept) &amp;&amp; !(orig_state &amp; fdwatch_type_read)</code></li>
<li><code>fdw_rw(cfd) &amp; fdwatch_type_read &amp;&amp; pending_ev-&gt;events == fdwatch_type_read</code></li>
</ul>

<p>If the second one implies the first one, all is well and the warning can safely be ignored. If it's ever possible for the first one to be false and the second one to be true, such a case will again invoke UB (since <code>ret</code> is only initialised if the first one is true).</p>

<hr>

<p>So much for analysis, on to conclusions.</p>

<p>Without understanding what the program is supposed to do, it is impossible for us to say how to fix these warnings. Technically, the most stragihtforward fix would be to return <em>something<sub>1</sub></em> from <code>d2cs_conn_set_addr</code>, and to initialise <code>ret</code> to <em>something<sub>2</sub></em> in the other function.</p>

<p><strong>Let's look at <code>ret</code> first.</strong></p>

<p>Since both conditions involving <code>ret</code> seem to treat <code>-1</code> as an error value, a good value for <em>something<sub>2</sub></em> could be <code>-1</code> (basically, initialise it to an error state).</p>

<p>However, looking at the code a bit more shows a discrepancy between the code in the two conditions you've posted. The top one calls <code>WSARecv</code> and assigns its return value to <code>ret</code>, while the second one simply calls <code>WSARecv</code> and ignores the return value. Therefore, it's more likely that the proper fix would be to change the second such line from</p>

<pre><code>WSARecv(fdw_fd(fdw_fds + idx), &amp;wsaBuf, 1, &amp;dummy1, &amp;dummy2, (LPWSAOVERLAPPED)tmpev, NULL);
</code></pre>

<p>to</p>

<pre><code>ret = WSARecv(fdw_fd(fdw_fds + idx), &amp;wsaBuf, 1, &amp;dummy1, &amp;dummy2, (LPWSAOVERLAPPED)tmpev, NULL);
</code></pre>

<p>(This incidentally just shows why it's a good idea to only declare variables at the point where you need them)</p>

<p><strong>And now for <code>d2cs_conn_set_addr</code>.</strong></p>

<p>This one is trickier. If you want to find a suitable return value, you'll need to inspect the call sites (where that function is called) and see what return values they expect. It's possible they will expect a success/failure return value, perhaps non-zero vs. <code>0</code>, or <code>0</code> vs. <code>-1</code>, or something else. Such inspection would then tell you what to return. That would probably be the success code, since the function cannot fail in any obvious ways.</p>

<p>Unless of course that use of <code>ASSERT(c, -1)</code> actually expands to</p>

<pre><code>if (!c) return -1;
</code></pre>

<p>or similar, which would give it a failure mode (and also suggest that the correct return value could be <code>0</code> or ""anything other than <code>-1</code>"" or ""anything non-negative"").</p>

<p>So, in addition to the code which calls <code>d2cs_conn_set_addr</code>, also check the definition of <code>ASSERT</code> to hopefully better understand how to fix it.</p>

<hr>

<p>To summarise: this code is plain wrong, and if errors of <em>this</em> degree managed to slip into it, who knows what other problems lurk in there. You should steer clear of it and not use it if that's at all possible.</p>

<p>If you're stuck with it, it will require very thorough inspection for potential issues.</p>
",0
43950913,43950879,1,"<p>The function does not return a <code>Node</code>, but a <code>Node *</code>, or a pointer to a <code>Node</code>. To be fully clear about what types are being used here, you could rewrite it as:</p>

<pre><code>Node * List::getNewNode(const int &amp;value) {
    Node * ptrToReturn = new Node(value);
    return ptrToReturn;
}
</code></pre>
",0
43950935,43950879,0,"<p>The <code>new</code> operator allocates size for an instance of the class <code>Node</code> on the heap and calls the class' constructor to initialize that memory.  It then returns a pointer to the newly constructed instance.  This code receives that pointer and returns it to the caller... so the method is declared to return a pointer to a Node or Node*.  You might want to consider it as <code>Node* List::getNewNode...</code> but it's idiomatic to put in the space resulting in the code you presented.</p>
",0
43950958,43950879,1,"<p>The pointer symbol belongs to <code>Node</code> and not to <code>List</code>. Hence the return type is:
<code>Node*</code>
and the class method implementation is for:</p>

<p><code>List::getNewNode</code>.</p>

<p>To understand, you may use <code>typedef</code>:</p>

<p><code>typedef Node* PNode;</code></p>

<p>And implement it this way:</p>

<pre><code>PNode List::getNewNode(const int value) {
    PNode node = new Node(value);
    return node;
}
</code></pre>
",0
46065388,46065230,1,"<p>Your cin.fail isn't working because of  a small typo </p>

<blockquote>
  <p>Multi-character character constant</p>
</blockquote>

<pre><code>cin.ignore(999, '/n');
</code></pre>

<p>it should be </p>

<pre><code>    cin.ignore(999, '\n');
</code></pre>

<p>corrected code </p>

<p>Alright tried one more solution</p>

<p>So the idea is to use <code>continue</code> ..and garble the value of num1 and num2  for invalid value (only present sol for '+').I have used NULL but you can use any other garbled value you want</p>

<pre><code>#include&lt;iostream&gt;
#include &lt;math.h&gt;       /* isnan, sqrt */    

using namespace std;

int main()
{

    double num1;
    double num2;
    char operation;
    char again;

    cout &lt;&lt; ""Welcome to Brent's Calculator.\n"";
    cout &lt;&lt; ""Enter 'Value (operator) Value' ex. 2 + 2"" &lt;&lt; endl;
    cin &gt;&gt; num1 &gt;&gt; operation &gt;&gt; num2;
    cout &lt;&lt; num1 &lt;&lt; "" ""
    &lt;&lt; operation &lt;&lt; "" ""
    &lt;&lt; num2 &lt;&lt; "" = "";

    do {
        switch (operation) {
            case '+':
                if ((num1 != NULL) &amp;&amp; (num2 != NULL ))
                cout &lt;&lt; num1+ num2 &lt;&lt; endl;
                break;
            case '-':
                cout &lt;&lt; num1 - num2 &lt;&lt; endl;
                break;
            case '*':
            case 'x':
            case 'X':
                cout &lt;&lt; num1 * num2 &lt;&lt; endl;
                break;
            case '/':
            case '%':
                if (num2 == 0) {
                    cout &lt;&lt; ""You cant divide by 0"" &lt;&lt; endl;
                }
                else {
                    cout &lt;&lt; num1 / num2 &lt;&lt; endl;
                }
                break;
            default:
                cout &lt;&lt; ""not understood"";
        }
        cout &lt;&lt; ""would you like to enter another calculation? (y/n) "";
        cin &gt;&gt; again;
        cin &gt;&gt; num1 &gt;&gt; operation &gt;&gt; num2;
        if (cin.fail()) {
            cout &lt;&lt; ""you need to enter numbers"" &lt;&lt; endl; //this part added mess with it tomorrow
            cin.clear();
            cin.ignore(999, '\n');
            num1 = NULL;
            num2 = NULL;
            continue;
        }

        cout &lt;&lt; num1 &lt;&lt; "" ""
        &lt;&lt; operation &lt;&lt; "" ""
        &lt;&lt; num2 &lt;&lt; "" = "";


    } while (again == 'y' || again == 'Y');

    //closing bracket of the else for cin.fail
    cin.get();
    return 0;
}
</code></pre>

<p>Output After change</p>

<pre><code>Welcome to Brent's Calculator.
Enter 'Value (operator) Value' ex. 2 + 2
44+44
44 + 44 = 88
would you like to enter another calculation? (y/n) y
a+b
you need to enter numbers
would you like to enter another calculation? (y/n) y
4+4.4
4 + 4.4 = 8.4
would you like to enter another calculation? (y/n) 
</code></pre>

<p>Note: Corner case would be  when both entered number  is num1 =0 and num2=0 
0+0 = 0 (in that case better to use some other flag)</p>
",6
46084812,46084712,0,"<p>The <code>scanf()</code> function removes whitespaces <strong><em>automatically</em></strong> before trying to parse things other than characters (<code>%c</code>, <code>%[¡­]</code>, <code>%n</code>), so you dont have to skip them like you are <em>trying</em> to do <code>%d \n</code>.</p>

<p>Simply read digits and dont care about them.</p>

<pre><code>scanf(""%d"", &amp;arr[i]);
//    ^^^^
</code></pre>

<hr>

<p>Also you are coding in <a href=""/questions/tagged/c%2b%2b"" class=""post-tag"" title=""show questions tagged &#39;c++&#39;"" rel=""tag"">c++</a>, there are different(easier) IO operations, first you have to include <code>&lt;iostream&gt;</code>.</p>

<p>Then, for reading you use <code>std::cin</code></p>

<pre><code>int i{0};
std::cin &gt;&gt; i;
</code></pre>

<p>and printing via <code>std::cout</code></p>

<pre><code>std::cout &lt;&lt; i;
</code></pre>

<p><a href=""http://www.cplusplus.com/doc/tutorial/basic_io/"" rel=""nofollow noreferrer"">Here</a> you may get extended info about them.</p>
",3
39669603,39669497,1,"<p>Since there is one record per line, <code>std::getline</code> will be your friend, as will <code>std::string</code>.</p>

<p>Let's try something:  </p>

<pre><code>std::string record_text;
std::getline(my_data_file, record_text);
</code></pre>

<p>We can use <code>std::istringstream</code> to help convert the text record into numbers:  </p>

<pre><code>std::istringstream record_stream(record_text);
std::vector&lt;int&gt; student_values;
int student_id;
record_stream &gt;&gt; student_id;
int value;
while (record_stream &gt;&gt; value)
{
  student_values.push_back(value);
}
</code></pre>

<p>I'm using a <code>std::vector</code> to contain the student values; you may be required to use another container.  </p>

<p><strong>Edit 1: Overloading extraction operators</strong><br>
If you want to impress your instructor and fellow students, you should model the records with a <code>struct</code> and overload the input operators:  </p>

<pre><code>struct Student_Record
{
  int id;
  std::vector&lt;int&gt; values;
  friend std::istream&amp; operator&gt;&gt;(istream&amp; input, Student_Record&amp; sr);
};
std::istream&amp; operator&gt;&gt;(istream&amp; input, Student_Record&amp; sr)
{
  // See above on how to read a line of data.
  // Be sure to use ""sr."" when accessing the structure variables,
  //    such as sr.id
  return input;
}
</code></pre>

<p>The overloaded operator allows you to have simpler input:  </p>

<pre><code>std::vector&lt;Student_Record&gt; database;
Student_Record sr;
while (my_data_file &gt;&gt; sr)
{
  database.push_back(sr);
}
</code></pre>

<p>Be sure to recommend StackOverflow to your instructor and fellow students.</p>
",5
46084795,46084752,3,"<p>You just have the arguments the wrong way round for your <code>CanHit</code> invocation.</p>

<p>You should instead call it like:</p>

<pre><code>if (CanHit(&amp;Damage, Point))
{
    ...
}
</code></pre>

<p>You can tell as your error message shows you the type it was <em>expecting</em> (<code>bool CanHit(float *,const Vector &amp;)</code>), but you're passing in a <code>Vector</code> then a <code>float *</code> (the wrong way round).</p>
",6
46085354,46085211,3,"<p>Since I already explained what's wrong in the comment, I figured out that it might be helpful to write a full answer with additional hints.</p>

<p>Taking a second look at your problem: The expression <code>if(point &lt;= 100 &amp;&amp; &gt;= 90)</code> is incorrect since the <code>if</code> statement expects a <code>bool</code> expression. Logical operator <code>&amp;&amp;</code> determinates whether or not the left and right <code>bool</code> expressions are <code>true</code> and returns so if both indeed are. Pay attention to what you just read. <strong>Both expressions</strong> means that there is a need for two of them. The first one, being <code>point &lt;= 100</code> satisfies the requirements. However, the second one you provided is <code>&gt;= 90</code>. This is not a valid expression, since you are expected to provide an indepented one. What you probably have in mind is check if <em>100 &lt;= point &lt;= 90</em>. You have to separate it into two, independent expressions - <code>if (point &lt;= 100 &amp;&amp; point &gt;= 90) { // your code }</code></p>

<p>Additionally, I encourage you to read <a href=""https://stackoverflow.com/a/1452738/7151494"">why <code>using namespace std;</code> is wrong</a>.</p>
",1
46107971,46107945,2,"<p>use a for loop</p>

<pre><code>for(int i=1;i&lt;=temp;i++){
        cout &lt;&lt; i &lt;&lt; endl;        //output numbers in the iteration
        sum = sum + i;
 }
</code></pre>

<p>or with a while loop like this </p>

<pre><code>   int counter=1;

   while (counter&lt;=temp)
    {
            cout &lt;&lt; counter &lt;&lt; endl;           //output numbers in the iteration
            sum = sum + counter;               //sums the number of iteration
            counter ++;                        //counter, used to stop the while loop to avois an infinity loop
    }
</code></pre>

<p><a href=""https://www.tutorialspoint.com/cplusplus/cpp_for_loop.htm"" rel=""nofollow noreferrer"">https://www.tutorialspoint.com/cplusplus/cpp_for_loop.htm</a> </p>
",3
41912701,41912602,1,"<blockquote>
  <p>My guess is that AnimatedBitmap doesn't have a default constructor.<br>
  ¨C Some programmer dude 7 mins ago </p>
</blockquote>

<p>That was the problem.</p>
",0
41913094,41912602,0,"<p>You've left <code>LandCell</code> only its compiler-defined default constructor, which cannot be used because it has no way of knowing how to construct an <code>AnimatedBitmap</code> (which itself has no default constructor).</p>

<p>You'll have to create a constructor for <code>LandCell</code> yourself, and write it to initialise <code>sprite</code> in whichever way you choose after thinking about it for a while.</p>
",0
46117505,46116764,4,"<p><a href=""/questions/tagged/c%2b%2b"" class=""post-tag"" title=""show questions tagged &#39;c++&#39;"" rel=""tag"">c++</a> <a href=""http://en.cppreference.com/w/cpp/io"" rel=""nofollow noreferrer"">has its own</a> input/output operation and for the output, the standard is <code>std::cout</code>.<br>
But there is a function names <code>write</code> in <a href=""/questions/tagged/c"" class=""post-tag"" title=""show questions tagged &#39;c&#39;"" rel=""tag"">c</a> and also a <code>write</code> that uses <strong>file descriptor</strong> : <code>int</code> </p>

<p>here is the <code>man 2 write</code> </p>

<pre><code>WRITE(2)                            Linux Programmer's Manual                            WRITE(2)

NAME
       write - write to a file descriptor

SYNOPSIS
       #include &lt;unistd.h&gt;

       ssize_t write(int fd, const void *buf, size_t count);
</code></pre>

<p>a <em>system call</em> is implemented in the <code>Linux Kernel</code>
And the user has no access to it. But A library like <code>standard C library</code> or like <code>GNU C library</code> wraps system calls that others can use it easily.</p>

<p>See this page: <a href=""https://www.kernel.org/doc/man-pages/"" rel=""nofollow noreferrer"">https://www.kernel.org/doc/man-pages/</a></p>

<p>then go to<br>
2: <a href=""http://man7.org/linux/man-pages/dir_section_2.html"" rel=""nofollow noreferrer"">System calls</a> documents the system calls provided by the Linux kernel. </p>

<p>then at the bottom you will find <a href=""http://man7.org/linux/man-pages/man2/write.2.html"" rel=""nofollow noreferrer"">write(2)</a></p>

<p>and a simple example is:  </p>

<pre><code>int fd = open( ""file"", O_RDONLY );
if( fd == -1 )
{
    perror( ""open()"" );
    close( fd );
    exit( 1 );
}

char buffer[ 100 ];
ssize_t read_byte;

if( ( read_byte = read( fd, buffer, 100 ) ) == -1 )
{
    perror( ""read()"" );
    close( fd );
    exit( 1 );
}

if( write( STDOUT_FILENO, buffer, read_byte ) == -1 )
{
    perror( ""write()"" );
    close( fd );
    exit( 1 );
}

close( fd );
</code></pre>

<p>and you should use this header files as well:</p>

<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

#include &lt;stdlib.h&gt;   // exit()
#include &lt;stdio.h&gt;    // for perror()
</code></pre>

<p>and these functions also is known as <strong>Low-Level I/O</strong> function</p>

<p>Thus depending on what level you are coding, then you should decide to use what functionality is best for you. I do not think <a href=""/questions/tagged/c%2b%2b"" class=""post-tag"" title=""show questions tagged &#39;c++&#39;"" rel=""tag"">c++</a> programmers use these level for a standard <a href=""/questions/tagged/c%2b%2b"" class=""post-tag"" title=""show questions tagged &#39;c++&#39;"" rel=""tag"">c++</a> code.</p>

<hr>

<p>A simple screenshot of where is <code>system-called</code> located.</p>

<p><a href=""https://i.stack.imgur.com/DSOjW.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/DSOjW.png"" alt=""system-call""></a></p>

<p><a href=""http://derekmolloy.ie/"" rel=""nofollow noreferrer"">source</a></p>
",0
46124566,46124358,1,"<p>As I understand guessedWord is an empty string <code>string guessedWord = """";</code> so to set it up you need to add <code>'_'</code> characters to guessedWord, not to set them equal to <code>'_'</code>. So your function will be:</p>

<pre><code>void setupGuessString()
{
    int x = 0;
    while (chosenWord[x]))
    {
        guessedWord += '_';
    }
}
</code></pre>

<p>And I would strongly recommend not to use global variables, instead of them use the return statement, that is just a better practise. So your functions will be:</p>

<pre><code>string lowerCase(string chosenWord)
{
int x = 0;
while(chosenWord[x])
{
        chosenWord[x] = tolower(chosenWord[x]);
        x++;
    }
    return chosenWord;
}

string setupGuessString(string chosenWord)
{
    int x = 0;
    string guessedWord = """";
    while (chosenWord[x]))
    {
        guessedWord += '_';
    }
    return guessedWord;
}
</code></pre>

<p>Hope this helps.</p>
",4
46124608,46124358,0,"<p>Is guessedWord of type character array ?
Is it global array ?</p>

<pre><code>    #include &lt;stdio.h&gt;
char *chosenWord = ""Hello W"";
char guessedWord[10];
void setupGuessString() //Set guessed word to same length as chosen word and replace each letter with '_'
{
    int x = 0;
    while(chosenWord[x])
    {
        guessedWord[x] = '_';
        x++;
    }
     guessedWord[x] = '\0';
}
int main()
{
    setupGuessString();
    printf(""%s   ;; %s"",chosenWord, guessedWord);
    return 0;
}
</code></pre>

<p>This is the output I see.. :
Hello W    ;; _______   &lt;--- this</p>
",0
42605281,42605224,1,"<p>One simple solution would be to Simple Solution:</p>

<p>1) Create a temporary character array --> ex: myArr[].</p>

<p>2) Copy alphabetic characters from the given array to myArr[].</p>

<p>3) Reverse myArr[] using standard string reversal algorithm.</p>

<p>4) Now traverse input string and myArr in a single loop. Wherever there is alphabetic character is input string, replace it with current character of myArr[].</p>

<p>Little problem with above solution, it requires extra space and it does two traversals of input string.
You can reverse with one traversal and without extra space. Below is algorithm.</p>

<p>1) Let input string be 'str[]' and length of string be 'a'</p>

<p>2) l = 0, r = a-1</p>

<p>3) While l is smaller than r, do following
   a) If str[l] is not an alphabetic character, do l++</p>

<p>b) Else If str[r] is not an alphabetic character, do r--</p>

<p>c) Else swap str[l] and str[r]</p>
",0
42605328,42605224,1,"<p>Here's a solution that will do it ""in place"" in one pass.</p>

<pre><code>bool isspecial(char c)
{
    if ((c &gt;= 'a') &amp;&amp; (c &lt;= 'z')) return false;
    if ((c &gt;= 'A') &amp;&amp; (c &lt;= 'Z')) return false;
    return true;
}

void rev(char* array, int N)
{
    int i = 0;     // i points to the first index of the array 
    int j = N - 1; // j points to the last index of the array

    while (i &lt; j)
    {
        if (isspecial(array[i]))
        {
            i++;
        }
        else if (isspecial(array[j]))
        {
            j--;
        }
        else
        {
            char tmp = array[i];
            array[i] = array[j];
            array[j] = tmp;
            i++;
            j--;
        }
    }
}
</code></pre>
",2
42605340,42605224,-1,"<p>If you want the position of the special characters to remain the same and the rest of the string to be reversed then this should work -</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

void swap(char&amp; a, char&amp; b)
{
    char temp = a;
    a = b;
    b = temp;
}

int main()
{
   string s = ""Hell$o World""; 
   for(int i = 0, j = s.length() -1;i &lt; s.length()/2; i++, j--) {
       while((s[i] &lt;= 'a' &amp;&amp; s[i] &gt;= 'Z') || s[i] &gt;= 'z' || s[i] &lt;= 'A') {
           i++;
       }
       while((s[j] &lt;= 'a' &amp;&amp; s[j] &gt;= 'Z') || s[j] &gt;= 'z' || s[j] &lt;= 'A') {
           j--;
       }
       swap(s[i], s[j]);
   }
   cout &lt;&lt; s &lt;&lt; endl;     //dlro$W olleH
   return 0;
}
</code></pre>
",0
41945573,41945554,3,"<p>It is because you are using std namespace:</p>

<pre><code>using namespace std;
</code></pre>

<p>And there is already an <code>std::max</code> which conflicts with your variable <code>max</code>.</p>
",2
45293919,45293895,9,"<p><code>not</code> is an <em>alternative token</em>. It is used as an alternative spelling of operator <code>!</code>. It cannot be used as a function name.</p>

<p>Although an alternative token is technically not a <em>reserved keyword</em>, both kinds cannot be used as names.</p>

<p>See:</p>

<ul>
<li><a href=""http://en.cppreference.com/w/cpp/keyword"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/keyword</a></li>
<li><a href=""http://en.cppreference.com/w/cpp/language/operator_alternative"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/language/operator_alternative</a></li>
</ul>
",2
45293957,45293895,1,"<p>The token 'not' is one of the keywords that c++ preserve. You can not use 'not' to name a function.</p>

<p>What's more is that there are some other errors in your code, such as the function call misses a parameter. The following code would be what you want I suppose.</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int not_func(int x){
    cout &lt;&lt; ""Enter your number"";
    cin &gt;&gt; x;
    if(x==1){
    return 1;
    }
    else{
    return x * (x-1);
    }
}

int main()
{
    cout &lt;&lt; not_func(5);
}
</code></pre>
",0
40957838,40622548,0,"<p>Here is some sample code to reverse a character array.</p>

<pre><code>#include &lt;iostream&gt;

void reverse(char * inputArray, int len) {
    std::cout &lt;&lt; ""Reverse is as follows: "";
    for (int i = len - 1; i &gt;= 0; i--) {
        std::cout &lt;&lt; inputArray[i];
    }
    std::cout &lt;&lt; std::endl;
}

int main() {
    std::string myString;
    std::cout &lt;&lt; ""Enter a string: "";
    std::cin&gt;&gt;myString;

    int length = myString.length();
    char * charArray = new char[length];

    for (int i = 0; i &lt; length; i++) {
        charArray[i] = myString[i];
    }

    reverse(charArray, length);

    return 0;
}
</code></pre>

<p>Here the function <code>reverse()</code> will print the character array passed as argument in reverse.</p>

<p>The output of the above code will be as follows:</p>

<pre><code>Enter a string: Sample
Reverse is as follows: elpmaS
</code></pre>

<p>There are a number of ways to do this. Please share some solid code to have more apt response customized for your need.</p>
",0
42476133,42475994,1,"<p><code>operator+</code> only returns something when the if-statement is true. It has to <em>always</em> return something.</p>

<p>The <code>operator*</code>, on the other hand, returns a reference to the local variable <code>temp</code>. It should likely also return by value, like <code>operator+</code>.</p>
",3
41455820,41455807,4,"<blockquote>
  <p>Why is it only asking me to initialise <code>temp2</code> and not <code>temp1</code>?</p>
</blockquote>

<p>The following doesn't do what you think it does (it inadvertently uses the <a href=""https://stackoverflow.com/questions/54142/how-does-the-comma-operator-work"">comma operator</a>):</p>

<pre><code>cin &gt;&gt; temp1, temp2;
</code></pre>

<p>To read two values from <code>cin</code>, use:</p>

<pre><code>cin &gt;&gt; temp1 &gt;&gt; temp2;
</code></pre>
",0
40749545,40748727,0,"<p>There are a number of good reasons to use copy constructor rather than default constructing an empty object and than assigning the new object to some already existing object. </p>

<h2>Reason one. Const-correctness</h2>

<p>First, let's play a devil advocate and consider the case when it doesn't matter:</p>

<pre><code>struct X {
    int i;
};

X x;
x.i = 10;
X y; 
y = x;  // Option 1 
X y(x) // Option 2
</code></pre>

<p>In the example above, there is really no difference between option 1 and option 2, other than better readabilty and code reasoning. But, what if we would like to make our <code>y</code> object a <code>const</code> object - because we don't want it to change over it's lifetime? Than option 1 would not be valid:</p>

<pre><code>const X y;
y = x; // Compilation error!
</code></pre>

<p>So, even on the simplest example, we can tell that even for very simple types, differentiating between assignment and copy-construction is very important for <strong>const-correctness</strong>. (There could be other examples for the same point).</p>

<h2>Reason 2. Code efficiency</h2>

<p>Next comes performance implications. Let's consider a very broken and incorrect implementation of string class (illustration only, has no place in life other than that):</p>

<pre><code>struct VeryBrokenString {
    char* buffer;
    VeryBrokenString() buffer(new char[1]) { strcpy(buffer, """"); }
    ~VeryBrokenString() { delete[] buffer; }
    VeryBrokerString&amp; operator= (const VeryBrokenString&amp; rhs) {
        delete[] buffer;
        buffer = new [strlen(rhs.buffer) + 1];
        strcpy(buffer, rhs.buffer);
        return *this;
    }
   VeryBrokenString(const VeryBrokenString&amp; rhs) {
        buffer = new [strlen(rhs.buffer) + 1];
        strcpy(buffer, rhs.buffer);
   }
};

VeryBrokenString one; // init it somehow :)
VeryBrokenString two;
two = one; // Option 1
VeryBrokenString two(one); //Option 2
</code></pre>

<p>In the example above, option 1 leads to duplication of efforts - the buffer is first allocated, and than deallocated, only to be allocated again. In option 2 the buffer is allocated only once. So, second point: copy-constructors help to generate <strong>more efficient code</strong>.</p>

<h2>Reason 3. Correctness</h2>

<p>Now, let's consider above broken string. While it is wrong on many levels, one particularly bad piece of code is it's assignment operator. It deletes original buffer, and than allocates a new one, copying data from <code>rhs</code>. Two major issues are that if <code>rhs</code> is the same as <code>this</code>, there will be nothing to copy from after deletion. And the second problem is that if for any reason new allocation throws an exception (run out of memory, for example), we would already loose the the original buffer. While the first problem can be addressed with a check for self-assignment (<code>if (&amp;rhs == this) return *this;</code>) the second could not be easily addressed in a straightforward way. One can read about how to write assignment operators in different articles, but agreed approach would be (for this class) somewhere along following lines:</p>

<pre><code>// Rest of BrokenString remains the same
NotSoBrokenString&amp; operator= (const NotSoBrokenString&amp; rhs) {
    NotSoBrokenString temp(rhs);
    char* const buf = buffer;
    buffer = temp.buffer;
    temp.buffer = buf;
}
</code></pre>

<p>This is much better, since all the allocation is within <code>temp</code> constructor. If it fails - throws an exception - the original buffer remains valid and usable. (It also addresses the problem of self-assignment - no harm would be done when <code>this</code> is the same as <code>rhs</code>, albeit of slight inefficiency). 
So, point number three - assignment operators are often done in terms of copy constructors!</p>

<p>Now this answer is becoming quite big, so I won't have an example for this, but often the semantics of the class allows it to be copy-constructed, but not assigned. </p>

<h2>Conclusion</h2>

<p>The benefits of copy-constructors used over assignment operators include const-correctness, efficiency, code correctness and support for non-trivial semantics.</p>
",0
40541539,40541482,1,"<p>The problem is, as you have identified, that you call <code>getFahrenheit()</code> twice. (Actually the problem is ""I have no idea what I'm doing"", but let's gloss over that.) A solution is to make <code>fahrenheit</code> a parameter to <code>calcCelsius()</code>, so we get:</p>

<pre><code>double calcCelsius(double fahrenheit);

//...

    celsius = calcCelsius(fahrenheit);

//...

double calcCelsius(double fahrenheit)
{

//...
</code></pre>

<p>That should be enough to get you close to the answer.</p>
",0
42524303,42523029,0,"<p>More or less something like this:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;vector&gt;

struct Pair
{
    int x,y;
    friend bool operator==(Pair a, Pair b)
    {
        return a.x == b.x &amp;&amp; a.y == b.y;
    }
    friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Pair&amp; a)
    {
        is &gt;&gt; a.x &gt;&gt; a.y;
        return is;
    }
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Pair a)
    {
        os &lt;&lt; '(' &lt;&lt; a.x &lt;&lt; ',' &lt;&lt; a.y &lt;&lt; ')';
        return os;
    }
};

int main()
{
    std::fstream file;
    file.open(""Text.txt"", std::fstream::in);

    std::list&lt;std::vector&lt;Pair&gt; &gt; relations;
    int size = 0;
    while(file &gt;&gt; size)
    {
        relations.emplace_back(size);
        for(int i=0; i &lt; relations.back().size() &amp;&amp; file &gt;&gt; relations.back()[i]; i++);
    }

    //Print
    for(auto &amp;r : relations)
    {
        std::cout &lt;&lt; ""["";
        for(auto &amp;p : r)
        {
            std::cout &lt;&lt; p;
        }
        std::cout &lt;&lt; ""]\n"";
    }

    return 0;
}
</code></pre>

<p><a href=""https://www.tutorialspoint.com/viewproject.php?URL=compile_cpp11_online.php&amp;PID=0Bw_CjBb95KQMbUdzUjc0bWlqb3M"" rel=""nofollow noreferrer"">Example</a></p>
",0
38620567,38620450,2,"<p><code>func_map[problem]</code>, indeed, results in a function pointer. Applying the operator <code>()</code> on it, the function is invoked and the expression results in an <code>int</code>. Dereferencing a function pointer before its invocation is optional. This is symmetric with an optional address taking on a function name for initializing function pointers.</p>
",0
38620569,38620450,0,"<p>find returns an iterator; if this iterator is end, then the problem does not exist in the map; Because it is not end, it exists, then in the return line the pointer function obtained with [] is used to call it.</p>
",0
38620584,38620450,1,"<p>Indeed </p>

<pre><code> func_map[problem] 
</code></pre>

<p>is a pointer. However, you dereference the pointer with *: </p>

<pre><code> *(func_map[problem])
</code></pre>

<p>and call function by adding ():</p>

<pre><code> (*(func_map[problem]))()
</code></pre>

<p>which returns ""int"".</p>
",0
48028090,48028027,3,"<p>You can't. What you can do is use the <a href=""http://en.cppreference.com/w/cpp/container/array"" rel=""nofollow noreferrer"">std::array</a> wrapper instead:</p>

<pre><code>struct S {
    std::array&lt;double, 1&gt; arr;
    S(std::array&lt;double, 1&gt; arr) : arr(arr) {}
};
</code></pre>
",0
48028100,48028027,6,"<blockquote>
  <p>Do you know why this code won't compile?</p>
</blockquote>

<p>It won't compile because arrays cannot be copy-initialized (except copy-list-initialized, but you're not doing that).</p>

<p>Arrays have to be copied one element at a time, using a loop. There's also a standard algorithm for copying so you don't need to write that loop yourself: <code>std::copy</code>.</p>

<p>Or, you can use <code>std::array</code> that was introduced in C++11. <code>std::array</code> is copyable.</p>
",0
48028110,48028027,7,"<p>Arrays can't be copied.</p>

<pre><code>int a[3];
int b[3];
a = b; // illegal
</code></pre>

<p>Further, when you pass an array to a function, its name decays to a pointer, so <code>S(double arr[1])</code> is equivalent to <code>S(double* arr)</code>. Once you're inside the function, you have to copy the individual elements, so you also need the size of the array:</p>

<pre><code>S(double *x, std::size_t sz) {
    std::copy_n(x, sz, arr);
}
</code></pre>

<p>You can omit the size if you write the template as a function:</p>

<pre><code>template &lt;std::size_t sz)
S(double (&amp;x)[sz]) {
    std::copy_n(x, sz, arr);
}
</code></pre>

<p>Or, even better, use <code>std::array</code>, which works the way you expect.</p>
",2
48028118,48028027,3,"<p>Although the signature of a constructor is written like that, the array type is adjusted to a pointer, and the <a href=""https://stackoverflow.com/questions/1461432/what-is-array-decaying"">array argument decays</a> to a pointer to its first element.</p>

<p>However, the arr member in the struct is still of type array. And a pointer can't be assigned to an array (hence the error).</p>

<p>It's also not possible to assign one array to another (e.g. even if you change it to one of the ways described in the above link), so you need to copy the elements manually with a loop, or using <code>std::copy</code>, or use <code>std::array</code>, as in Ron's answer.</p>
",2
37708484,37708311,2,"<p>It is because <code>std::cout</code>'s <code>operator&lt;&lt;(char)</code> is overloaded such that it will display ascii character corresponding to the digit. Instead of changing type from <code>char</code> to <code>int</code>, you can do like this</p>

<pre><code>for (int i = 0; i &lt; 7; ++i)
    cout &lt;&lt; static_cast&lt;int&gt;(code[i]) &lt;&lt; endl;
</code></pre>

<p>See <a href=""https://en.wikipedia.org/wiki/ASCII"" rel=""nofollow"">this</a>.</p>
",0
46630566,46630303,0,"<p>Being able to divide a set of points into similar groups is part of <code>data mining</code>.  There is an algorithm <a href=""https://en.wikipedia.org/wiki/DBSCAN"" rel=""nofollow noreferrer"">wikipedia : DBScan</a> which does the calculation you need, but requires visiting every node.  In order to decide if it is part of a cluster or not.</p>

<h2>DBScan</h2>

<p>Each node is visited, and nearby nodes are checked to see whether they are within a distance delta.  If sufficient nodes are found, then a new cluster is started.  Then the nodes in the cluster are walked to see if they also have any nearby neighbours which belong in the cluster.  When these have been exhausted, a new (untested node), is used.</p>

<p>This is repeated until all the nodes have been visited, and the idea of how many clusters exist is now known.</p>
",0
46630998,46630303,0,"<p>as you described it, the problem is equivalent to finding the connected components of the graph with vertices the points and edges the r0-closer relation. This will be quadratic in time and linear in space ( or just linear time if you manage to get the edges in O(N) and the avarage number of edges per point is constant ).</p>

<p>A linear in time and quadratic in space solution, could be obtained by writing each point in a boolean matrix in such a way to build the graph in a single pass.</p>

<p>Inbetween solutions could be found by using spatial trees as well ...</p>
",1
46632823,46630303,0,"<p>Beware totally untested code:</p>

<pre><code>// some coordinates
struct point {
  int x,y;
};
using PointVec = std::vector&lt;point&gt;;

// implicit data structure
struct psetdata {
  point p;
  int parent; // [Disjoint-set data structure][1]

  psetdata(point&amp; p) : p(p), parent(-1) {}
}
using PSet = std::vector&lt;psetdata&gt;;


void Collapse(PSet&amp; pset, PSet::iterator p, int r_0) {
  // reduce the hight of the implicit sets.
  auto q = p;
  auto parent = q-&gt;parent;
  while (parent != pset[parent].parent) {
    q-&gt;parent = pset[parent].parent;
    q = &amp;pset[parent];
    parent = q-&gt;parent;
  }
  p-&gt;parent = q-&gt;parent; // ultimative parent
}

void Clusters(PointVec&amp; points) {
  PSet pset(points.begin(), points.end());

  for (int idx = 0, auto&amp; p = pset.begin(); p &lt; pset.end(); p++, idx++) {
    if (p.parent == -1)
      p.parent = idx; // my own parent defines a set

    for(auto ptry = p.next(); ptry &lt; pset.end; ptry++) {
      if (dist(p, ptry) &lt; r_0) {
        // ptry to a set.
        Collapse(pset, p);

        if (ptry-&gt;parent != -1) {
          Collapse(pset, ptry);
          pset[ptry-&gt;parent].parent = p-&gt;parent; // merge, need ultimative parent
        }

        ptry-&gt;parent = p-&gt;parent;
      }
    }
  }

  std::map&lt;int, int&gt; clusters;

  // count clusters
  for (auto p = pset.begin(); p != pset.end(); p++) {
    Collapse(pset, p);

    clusters[p-&gt;parent]++;
  }

  // print the sums
  std::cout &lt;&lt; ""#clusters:"" &lt;&lt; sets.size() &lt;&lt; ""\n"";
  for (auto&amp; c : clusters) {
    std::cout &lt;&lt; c.first &lt;&lt; "" size "" &lt;&lt; c.second &lt;&lt; ""\n"";
  }
}


int main() {
  // some sample points
  vector&lt;point&gt; points {{0,0}, {1,1}, {2,1}};

  Clusters(points, 1);
}
</code></pre>
",7
46949905,46949784,4,"<p>Do <strong>NOT</strong> use <code>reinterpret_cast</code> for serialization/deserialization or stringification. <code>reinterpret_cast</code> is a very dangerous tool that should be used only in very particular situations. The correct way of dealing with your issue is to provide an <code>operator&lt;&lt;</code> and an <code>operator&gt;&gt;</code> for your <code>Info</code> class. Example:</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Info&amp; p)
{
    os &lt;&lt; name;
    os &lt;&lt; weight;
    os &lt;&lt; grade;
    return os;
}
</code></pre>

<hr>

<p><code>reinterpret_cast&lt;T&gt;</code> literally asks the compiler to look at a memory location and act as if it were a <code>T</code>. Classes like <code>std::string</code> are complicated: they own resources and store pointers to other memory locations inside them. If you attempt to write the bytes of an <code>std::string</code> out, you'll get garbage, as your characters are likely not stored with the <code>std::string</code> instance itself... </p>
",1
46949939,46949784,0,"<p>std::string is a class that stores pointers to another memory location where the actual string is stored.  If you write std::string to file, only the bytes representing the pointers is written, not the string itself.</p>
",0
46045808,46045664,7,"<p>Use <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""noreferrer""><code>std::vector</code></a>, which is designed for exactly this use case.</p>

<p>The (rough) translation of the Perl code you have given to C++ using <code>std::vector</code> would be something like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    // Declare a vector that can only contain int values.
    std::vector&lt;int&gt; numbers;

    // Put the numbers [1,10] into the array.
    for (int i = 1; i &lt;= 10; ++i) {
        numbers.push_back(i);
    }

    // Display the contents of the vector.
    for (auto const &amp;values : numbers) { std::cout &lt;&lt; values &lt;&lt; '\n'; }

    return 0;
}
</code></pre>

<p>(<a href=""http://coliru.stacked-crooked.com/a/11565326f5ac57dc"" rel=""noreferrer"">Live demo</a>)</p>

<p>If you do not need the container allocations to be contiguous, <a href=""http://en.cppreference.com/w/cpp/container/deque"" rel=""noreferrer""><code>std::deque</code></a> might perform better under certain access/modification patterns, as it makes multiple allocations and therefore does not require that the existing contents be copied when the container runs out of capacity.</p>
",2
39630981,39630949,2,"<p>See here:</p>

<pre><code>double trip_mileage = end_mileage - start_mileage;

cout &lt;&lt; ""Enter your starting mileage: "";
cin &gt;&gt; start_mileage;

cout &lt;&lt; ""Enter your end mileage: "";
cin &gt;&gt; end_mileage;
</code></pre>

<p>You're computing your trip mileage before you asked your user for the necessary inputs. Declare the variable but don't do the computation until later:</p>

<pre><code>double trip_mileage;

cout &lt;&lt; ""Enter your starting mileage: "";
cin &gt;&gt; start_mileage;

cout &lt;&lt; ""Enter your end mileage: "";
cin &gt;&gt; end_mileage;

trip_mileage = end_mileage - start_mileage;
</code></pre>

<p>You make the some mistake again with <code>total_hours</code>. I'll let you figure that one out.</p>
",0
39630983,39630949,2,"<p>Change order of these lines. Because earlier you are computing <code>mph</code> even before you had input of <code>total_hours</code>. In that case <code>total_hours</code> is assigned a garbage value and your results differ.</p>

<pre><code>double total_hours, mph;
cout &lt;&lt; ""How man hours was the trip: "";
cin &gt;&gt; total_hours;
mph = trip_mileage / total_hours;
</code></pre>

<p>and same about <code>trip_mileage</code></p>

<pre><code>    cout &lt;&lt; ""Enter your starting mileage: "";
    cin &gt;&gt; start_mileage;

    cout &lt;&lt; ""Enter your end mileage: "";
    cin &gt;&gt; end_mileage;

    double trip_mileage = end_mileage - start_mileage;
</code></pre>
",0
39631002,39630949,2,"<p>Corrected code:</p>

<pre><code>// Lab 3 Exercise 2
// Calculate MPH (miles Per Hour) and KPH (Kilometers Per Hour).
//
// Program by: Mohamed El-Malah

#include &lt;iostream&gt;
#include &lt;iomanip&gt;

using namespace std;

int main ()
{

    // Have the user enter his start and end mileage
    double start_mileage, end_mileage;

    cout &lt;&lt; ""Enter your starting mileage: "";
    cin &gt;&gt; start_mileage;

    cout &lt;&lt; ""Enter your end mileage: "";
    cin &gt;&gt; end_mileage;

    double trip_mileage = end_mileage - start_mileage;
    // Have user input the hours the trip took
    double total_hours, mph;


    cout &lt;&lt; ""How man hours was the trip: "";
    cin &gt;&gt; total_hours;

    mph = trip_mileage / total_hours;
    // Print the results in Miles and Kilometers

    double trip_kilometers, kph;

    trip_kilometers = trip_mileage * 1.6;
    kph = trip_kilometers / total_hours;

    /**** fixed stream manipulator makes cout not use scientific notation ****/

    cout &lt;&lt; ""Total miles "" &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; setw(15) &lt;&lt; trip_mileage &lt;&lt; endl;
    cout &lt;&lt; "" Miles/Hour "" &lt;&lt; setw(15) &lt;&lt; mph &lt;&lt; endl;
    cout &lt;&lt; ""Total Kilometers"" &lt;&lt; setw(10) &lt;&lt; trip_kilometers &lt;&lt; endl;
    cout &lt;&lt; "" Kilometers/Hour"" &lt;&lt; setw(10) &lt;&lt; kph &lt;&lt; endl;


}
</code></pre>

<p>You had messed with the ordering of variables <code>total_hours</code> and <code>trip_mileage</code>. Make sure you use/calculate the value of the variables after you have taken relevant input from the user, otherwise random values will be used.</p>

<p>Additionally, to make cout not use scientific notation, you must use <code>std::fixed</code> stream manipulator. </p>
",2
43176850,43176773,1,"<pre><code>int flag = 0;
for(int i=1;i&lt;5;i++){
  if (i == 3){
    x = false;
    flag = 1;
  } else{
    x = true;
  }

  if(x &amp;&amp; flag == 0){
    cout &lt;&lt; ""true"";
  }else{
    cout &lt;&lt; ""false"";
  } 
}
</code></pre>

<p>If you specifically wish to switch your output upon getting <code>3</code>, you can <code>flag</code> up the case where there is a change in x. See the code above. This is in accordance to your code pattern.</p>
",0
43176878,43176773,0,"<p>Try this code</p>

<pre><code>x = true;

for(int i=1;i&lt;5;i++){
  if (i == 3){
    x = false;
  }

  if(x){
    cout &lt;&lt; ""true"";
  }else{
    cout &lt;&lt; ""false"";
  } 
}
</code></pre>
",0
45713584,45713055,2,"<p>The problem is:</p>

<pre><code>    std::string prefix = searchpath.substr(begin, next);
</code></pre>

<p><a href=""http://en.cppreference.com/w/cpp/string/basic_string/substr"" rel=""nofollow noreferrer""><code>std::string::substr</code></a> takes offset + count arguments, not start + end arguments.</p>

<p>You need: </p>

<pre><code>    std::string prefix = searchpath.substr(begin, next-begin);
</code></pre>

<p>So in full:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::string searchpath = ""a;b;c"";
    size_t begin = 0;
    size_t next = searchpath.find_first_of("";"", 0);
    do
    {
        if (next == std::string::npos)
            next = searchpath.length();
        std::string prefix = searchpath.substr(begin, next-begin);
        std::cout &lt;&lt; ""Trying: "" &lt;&lt; prefix &lt;&lt; ""\n"";
        begin = next + 1;
        next = searchpath.find_first_of("";"", begin);
    } while (begin &lt; (int)searchpath.length());
}
</code></pre>

<p>(Note, that is what your question should have looked like.  A complete program.)</p>

<p>I would actually write as:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    std::string searchpath = ""a;b;c"";
    for (size_t begin = 0, next; begin &lt; searchpath.length(); begin = next+1)
    {
        next = searchpath.find(';', begin);
        if (next == std::string::npos)
            next = searchpath.length();
        std::string prefix = searchpath.substr(begin, next-begin);
        std::cout &lt;&lt; ""Trying: "" &lt;&lt; prefix &lt;&lt; ""\n"";
    }
}
</code></pre>

<p>Which has less repetition, localizes begin and next to the loop, uses <code>find</code> not <code>find_first_of</code>, and doesn't have an unnecessary cast.</p>
",0
45713678,45713055,1,"<p>Just in addition to @Martin Bonner 's answer.</p>

<p>Its could be done easier and more readable in my opinion, check it out.</p>

<pre><code>char someInput[] = ""/home/user/?.lua;/home/test/?/init.lua;./lua"";

std::string searchpath(someInput);
std::string temp;
std::size_t pos = std::string::npos;

pos = searchpath.find("";"");
while (pos != std::string::npos)
{
    temp = searchpath.substr(0, pos);
    searchpath = searchpath.substr(pos + 1);
    pos = searchpath.find("";"");

    std::cout &lt;&lt; ""Trying: "" &lt;&lt; temp &lt;&lt; std::endl;
}
std::cout &lt;&lt; searchpath &lt;&lt; std::endl;
</code></pre>

<p>Output</p>

<pre><code>Trying: /home/user/?.lua
Trying: /home/test/?/init.lua
Trying: ./lua
</code></pre>
",2
45714087,45713055,0,"<p>Here you go, the simple version using <a href=""http://en.cppreference.com/w/cpp/string/basic_string/getline"" rel=""nofollow noreferrer"">std::getline()</a>:</p>

<pre><code>#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;iostream&gt;

int main()
{
    std::istringstream input{""/home/user/?.lua;/home/test/?/init.lua;./lua""};
    for (std::string prefix ; std::getline(input, prefix, ';') ; ) {
        std::cout &lt;&lt; ""Trying: "" &lt;&lt; prefix &lt;&lt; ""\n"";
    }
}
</code></pre>

<p><kbd><a href=""http://coliru.stacked-crooked.com/a/d1c6f64d46011b1a"" rel=""nofollow noreferrer"">demo</a></kbd></p>

<p><strong>Output</strong>:</p>

<blockquote>
  <p>Trying: /home/user/?.lua<br>
  Trying: /home/test/?/init.lua<br>
  Trying: ./lua</p>
</blockquote>
",0
47614779,47614585,1,"<p>It's so much simpler:</p>

<pre><code>#define N 100

vector&lt;int&gt; get_random_numbers()
{
    random_device rd;  //Will be used to obtain a seed for the random number engine
    mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    uniform_int_distribution&lt;&gt; dis(0, N);

    vector&lt;int&gt; randoms(N);
    for (int i = 0; i &lt; N; i++)
    {
        randoms[i] = dis(gen);
    }
    return randoms;
}

void insert_in_lists()
{
    vector&lt;int&gt; randoms = get_random_numbers();
    sort(randoms.begin(), randoms.end());
    list&lt;int&gt; l(randoms.begin(), randoms.end());
    for (list&lt;int&gt;::iterator p = l.begin(); p != l.end(); p++)
    {
        cout &lt;&lt; *p &lt;&lt; endl;
    }
}
</code></pre>

<p>This way, we efficiently construct and sort the vector, then copy its values to the list.  This will be much faster, and the code is much simpler.</p>
",0
47614779,47614585,1,"<p>It's so much simpler:</p>

<pre><code>#define N 100

vector&lt;int&gt; get_random_numbers()
{
    random_device rd;  //Will be used to obtain a seed for the random number engine
    mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    uniform_int_distribution&lt;&gt; dis(0, N);

    vector&lt;int&gt; randoms(N);
    for (int i = 0; i &lt; N; i++)
    {
        randoms[i] = dis(gen);
    }
    return randoms;
}

void insert_in_lists()
{
    vector&lt;int&gt; randoms = get_random_numbers();
    sort(randoms.begin(), randoms.end());
    list&lt;int&gt; l(randoms.begin(), randoms.end());
    for (list&lt;int&gt;::iterator p = l.begin(); p != l.end(); p++)
    {
        cout &lt;&lt; *p &lt;&lt; endl;
    }
}
</code></pre>

<p>This way, we efficiently construct and sort the vector, then copy its values to the list.  This will be much faster, and the code is much simpler.</p>
",0
40559220,40558353,3,"<p>Challenge accepted.</p>

<p>Using this <a href=""https://howardhinnant.github.io/date/date.html"" rel=""nofollow noreferrer"">free, open-source, header-only date library</a>:</p>

<pre><code>#include ""date.h""
#include &lt;iostream&gt;

namespace me
{

class date
{
    ::date::sys_days tp_;
public:
    date(int month, int day, int year)
        : tp_{::date::year(year)/month/day}
        {}

    friend
    int
    operator-(const date&amp; x, const date&amp; y)
    {
        return (x.tp_ - y.tp_).count();
    }
};

}  // namespace me

using namespace std;
#define date me::date

int main()...
</code></pre>
",4
43175644,43175599,0,"<p>You can try this:</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;string&gt;
using namespace std;
int main()
{
string filename; // string to take input
ofstream out; // Object to create file
getline(cin, filename); // Taking input for file Name
out.open(filename + "".txt""); // To create .txt file
out.close();
return 0;
}
</code></pre>
",2
34972875,34972843,4,"<p>It means pass by reference, the object that is passed can be manipluated directly. For example when you write <code>public void TestMethod(obj value)</code> any changes you make to value do not affect the original value(i.e a copy is made) however when you pass by reference any changes you make to value change the original value.</p>
",0
34972878,34972843,4,"<p>In the code you provided in your question <code>&amp;</code> symbol acts for passing argument by reference in your <code>operator+</code> function. If you remove it your code still will be able to compile and will act the same way (in your case) but arguments will be passed in your <code>operator+</code> function by value (will be copied).</p>
",0
34972880,34972843,18,"<p>""&amp;"" can mean several different things, depending on the context.</p>

<p>The example you gave above is the C++ ""reference operator"":</p>

<p><a href=""https://softwareengineering.stackexchange.com/questions/126895/need-help-understanding-reference-operatorc-in-specific-functions"">Need help understanding reference operator(C++) in specific functions</a></p>

<p>The reference operator is specific to C++.  ""&amp;"" can also be used as the ""address of"" operator, used in both C and C++:</p>

<p><a href=""https://stackoverflow.com/questions/57483/"">What are the differences between a pointer variable and a reference variable in C++?</a></p>

<p>Finally, ""&amp;"" can also be the bitwise ""AND"" operator:</p>

<p><a href=""http://www.cprogramming.com/tutorial/bitwise_operators.html"" rel=""noreferrer"">http://www.cprogramming.com/tutorial/bitwise_operators.html</a></p>
",1
46656473,46656319,2,"<p>A <a href=""http://en.cppreference.com/w/cpp/language/list_initialization#Narrowing_conversions"" rel=""nofollow noreferrer"">narrowing conversion</a> is (roughly speaking) a conversion between built-in types that might need to truncate or take a modulus on some values because the destination type is not capable of suitably representing a given source value if known at compile time, or some possible source values if the value is not known at compile time.</p>

<p>So conversion from the known value <code>2</code> or <code>4</code> to a <code>bool</code> is a narrowing conversion, since a <code>bool</code> can't really represent those numbers, only <code>0</code> or <code>1</code>.</p>

<p>Ever since C++11, it has been illegal for a program to require a narrowing conversion on any value found within <code>{</code> curly braces <code>}</code> used for aggregate initialization or list-initialization.</p>

<p>A narrowing conversion is still allowed when the source is not in curly braces, such as your <code>bool a = 2;</code>.</p>
",0
41190570,41190019,0,"<p>as long as you have names which don't contain white spaces and age as integer then you can read name as a string and age as an integer.</p>

<p>you don't need to check whether the file was successfully opened or not you can just abbreviate the operation:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;


int main()
{

    std::ifstream file;
    std::string   word;
    int age;

    file.open(""data.txt"");

    while( file &gt;&gt; word)
    {
        file &gt;&gt; age;
        std::cout &lt;&lt; word &lt;&lt; ""   "" &lt;&lt; age &lt;&lt; std::endl;
    }


    std::cout &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<ul>
<li><p>if you want to use one variable and for sure a string one then:</p>

<pre><code>while( file &gt;&gt; word)
{
    std::cout &lt;&lt; word &lt;&lt; ""   "";
    file &gt;&gt; word;
    std::cout &lt;&lt; word &lt;&lt; std::endl;
}
</code></pre></li>
</ul>

<p>I don't see any good thing to read age as a string and maybe later convert it back to an integer!</p>

<p>the output: </p>

<pre><code>Arthur   20
Mark   21
Josh   12
</code></pre>
",0
43755320,43753604,0,"<p>Supposing your question is about generating a binary tree out of a linked list previously ordered. The content of each leaf is either a letter [A-Z] or a '.' indicating empty leaf.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
using namespace std;
class BTree
{
    typedef unique_ptr&lt;BTree&gt; BTreePtr;
    char content='.';
    BTreePtr left=nullptr;
    BTreePtr right=nullptr;
public:
    BTree( const string&amp; s)
    {
        if (s.size()==0) return;//robustness check, 

        size_t sizeLeft = s.size()/2;
        content = s[sizeLeft]; // We are sure size&gt;0
        if (sizeLeft&gt;0) left=BTreePtr(new(nothrow) BTree( s.substr(0,sizeLeft)));
        if (s.size()&gt;sizeLeft+1) right=BTreePtr(new(nothrow)BTree(s.substr(sizeLeft+1)));
    }

    string serialize()
    {
        return (left?left-&gt;serialize():string()) + 
               content + (right?right-&gt;serialize():string());
    }
};
</code></pre>

<p>You could check how it works, like:</p>

<pre><code>int main()
{
    BTree b(""ABC..DE...F.G.."");
    cout &lt;&lt; b.serialize() &lt;&lt; endl;
    return 0;
}
</code></pre>
",0
43755320,43753604,0,"<p>Supposing your question is about generating a binary tree out of a linked list previously ordered. The content of each leaf is either a letter [A-Z] or a '.' indicating empty leaf.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
using namespace std;
class BTree
{
    typedef unique_ptr&lt;BTree&gt; BTreePtr;
    char content='.';
    BTreePtr left=nullptr;
    BTreePtr right=nullptr;
public:
    BTree( const string&amp; s)
    {
        if (s.size()==0) return;//robustness check, 

        size_t sizeLeft = s.size()/2;
        content = s[sizeLeft]; // We are sure size&gt;0
        if (sizeLeft&gt;0) left=BTreePtr(new(nothrow) BTree( s.substr(0,sizeLeft)));
        if (s.size()&gt;sizeLeft+1) right=BTreePtr(new(nothrow)BTree(s.substr(sizeLeft+1)));
    }

    string serialize()
    {
        return (left?left-&gt;serialize():string()) + 
               content + (right?right-&gt;serialize():string());
    }
};
</code></pre>

<p>You could check how it works, like:</p>

<pre><code>int main()
{
    BTree b(""ABC..DE...F.G.."");
    cout &lt;&lt; b.serialize() &lt;&lt; endl;
    return 0;
}
</code></pre>
",0
44369999,44369758,1,"<p>It is not possible to make a function that is already <code>virtual</code> be not <code>virtual</code> in a child class.</p>

<p>Virtuality is a property of the top-level base class, not the child classes. Once a method has been marked as <code>virtual</code>, and pointer to that class must use dynamic dispatch for that function when calling because the pointer could be pointing to a child class that has overridden the behaviour.</p>

<p>Consider this code:</p>

<pre><code>A a;
B b;
C c;

A * ap = &amp;a;
A * bp = &amp;b;
A * cp = &amp;c;

ap-&gt;print(); // 'function1'
bp-&gt;print(); // 'function2'
cp-&gt;print(); // 'function3'
</code></pre>

<p>Here, the calls to <code>print</code> cannot tell which function to call at compile time, they absolutely must use dynamic dispatch.</p>

<p>However, you can make <code>C::print</code> behave like <code>A::print</code></p>

<pre><code>struct C : public B {
    void print() {
        A::print();
    }
};
</code></pre>

<p>Which results in:</p>

<pre><code>ap-&gt;print(); // 'function1'
bp-&gt;print(); // 'function2'
cp-&gt;print(); // 'function1'
</code></pre>

<p>And if the behaviour of <code>A::print()</code> changes, <code>C::print()</code> mirrors those changes.</p>

<p>This will still be overridable though, unless you use the <code>final</code> keyword as outlined below.</p>

<hr>

<p><strong>Original answer:</strong></p>

<p>I believe you are looking for the <code>final</code> specifier.
It's only available as of C++11 though.</p>

<p>To quote en.cppreference's page about the <a href=""http://en.cppreference.com/w/cpp/language/final"" rel=""nofollow noreferrer"">final specifier</a>:</p>

<blockquote>
  <p>When used in a virtual function declaration or definition, final
  ensures that the function is virtual and specifies that it may not be
  overridden by derived classes. The program is ill-formed (a
  compile-time error is generated) otherwise.</p>
</blockquote>

<p>And a variation of the example they give, demonstrating the solution to your problem:</p>

<pre><code>struct A
{
    virtual void foo();
};

struct B : A
{
    void foo() final; // B::foo is overridden and it is the final override
};

struct C : B
{
    void foo() override; // Error: foo cannot be overridden as it's final in B
};
</code></pre>
",9
40984905,40984752,12,"<p>I can't comment yet, don't have enough points, but did you try adding <code>cin.ignore();</code> before the <code>getline(cin, name, '\n');</code> ?</p>

<p>Like this:</p>

<pre><code>string setBusinessName()
{
    string name = """";
    cout &lt;&lt; ""The name you desire for your business:"";
    cin.ignore();
    getline(cin, name, '\n');
    cout &lt;&lt; name;
    return name;
}
</code></pre>
",1
40984947,40984752,0,"<p>It is working fine. I just tried this.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

string setBusinessName(){
    string name = """";
    cout &lt;&lt; ""The name you desire for your business:"";
    getline(cin, name);
    cout &lt;&lt; name;
    return name;
}

int main() {
    setBusinessName();
    system(""PAUSE"");
}
</code></pre>
",2
40984959,40984752,4,"<p>Just adding some more explanation to the comments, when you do:</p>

<pre><code>cout &lt;&lt; ""Enter value:"";
cin &gt;&gt; x;
</code></pre>

<p>The cin instruction is executed when the user presses <kbd>Enter</kbd>, so the input buffer has the value the user inserted and an extra <code>'\n'</code> char. If you continue doing <code>cin</code> that is ok, but if you want to use <code>getline</code> (like in your case to include spaces in a string) you must be aware that <code>getline</code> will stop at the first occurence of <code>'\n'</code> in the buffer, so the result from <code>getline</code> will be empty. </p>

<p>To avoid this, and if you really must use both cin and getline, you need to remove that <code>'\n'</code> from the buffer by using <a href=""http://www.cplusplus.com/forum/beginner/9148/"" rel=""nofollow noreferrer"">cin.ignore(streamsize n = 1, int delim = EOF)</a>, this function clears <code>streamsize</code> chars from the buffer <strong>or</strong> until the first char that matches <code>delim</code> (including), here's an example:</p>

<pre><code>cin &lt;&lt; x;
cin.ignore(256, '\n');
getline(cin, name, '\n');
</code></pre>

<hr>

<p><strong>Note</strong> it is advisable to use:</p>

<pre><code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
</code></pre>

<p>if you don't want to guess how many chars are in the buffer.</p>
",0
40985099,40984752,2,"<p>It's possible that there is already something in the stream and <code>getline()</code> just reads it. </p>

<p>Make sure you didn't use <code>cin&gt;&gt;</code> before this function.
And you can use <code>cin.ignore()</code> before <code>getline()</code> to avoid something already existed in the stream.</p>
",0
41683571,41683450,1,"<p>With the <code>*</code>, <code>date</code> is declared as a pointer type, which stores the address of a <code>ADate</code> object (points to a <code>ADate</code> object). Otherwise, <code>date</code> would be declared as a <code>ADate</code> object type.</p>

<p>The operator <code>new</code> returns a pointer. Thus without the <code>*</code>, your program wouldn't be successfully compiled.</p>

<p><a href=""http://www.cplusplus.com/reference/new/operator%20new/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/new/operator%20new/</a></p>
",0
40559853,40559828,3,"<p><strong>C++ doesnt have C#-style-like properties.</strong></p>

<p>but you can have a setter and getter function declared in header and then define it in source files.</p>

<p>example:</p>

<pre><code>///in header file
class Test
{
    public:
         int getX();
         void setX(int newX);
    private:
         int x;
}

//in source file

int Test::getX()
{
     return x;
}

void Test::setX(int newX)
{
      x = newX;
}
</code></pre>

<p><strong>EDIT:</strong></p>

<p>when working with header files you should put a header guards on it.</p>

<p>read about this: <a href=""https://en.wikipedia.org/wiki/Include_guard"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Include_guard</a></p>
",0
40559864,40559828,1,"<pre><code>class Foo
{
public:
    int get()
    {
        return bar;
    }

    void set( int new_bar )
    {
        bar = new_bar;
    }

private:
    int bar;
};
</code></pre>

<p>This will give you a class name Foo. This class has a private member, bar. You can set the value of bar through the set() method, and you can get the value of bar via the set() method.</p>
",0
40560299,40559828,0,"<p>Like C# it is not possible same way but you can try some thing like below.</p>

<pre><code>class Foo
{
public:
    void bar(int val){ _bar=val;}
    int bar(){ return  _bar;}

private:
    int _bar;
};
</code></pre>
",0
40560508,40559828,2,"<p>Writing wrapping template class will help you.
In the class, by overloading some special functions, you can chase access to underlying object.</p>

<pre><code>template &lt;class T, class Object, T(Object::*real_getter)(), T(Object::*real_setter)(T const &amp;)&gt; 
class RWProperty 
{ 
private:
    Object * my_object;
public:
    RWProperty() : my_object(0) {}
    RWProperty(Object * me = 0) : my_object(me) {}
    void operator()(Object * obj) { my_object = obj; }
    T operator()() const { return (my_object-&gt;*real_getter)(); }
    T operator()(T const &amp; value) { return (my_object-&gt;*real_setter)(value); }
    T get() const { return (my_object-&gt;*real_getter)(); }
    T set(T const &amp; value) { return (my_object-&gt;*real_setter)(value); }
    operator T() const { return (my_object-&gt;*real_getter)(); }
    T operator=(T const &amp; value) { return (my_object-&gt;*real_setter)(value); }
    typedef T value_type;
};

//Use case from here.
#include &lt;iostream&gt;

struct Widget
{
private:
    int value_;
    int get(void) { std::cout &lt;&lt; ""Real getter called."" &lt;&lt; std::endl; return value_; }
    int set(const int&amp; _value) {  std::cout &lt;&lt; ""Real setter called."" &lt;&lt; std::endl; return value_ = _value; }
public:
    RWProperty&lt;int, Widget, &amp;get, &amp;set&gt; value;
    Widget(void):value(this){}
};


int main(void)
{
    Widget w;
    w.value = 31337; //Call Widget::set(Called real setter in RWProperty) indirectly.
    std::cout &lt;&lt; w.value; //Call Widget::get(Called real getter in RWProperty)
}
</code></pre>

<p>You should also read ""C++ Properties - a Library Solution"" for another information.
In the paper, several type of property classes, typed by its access authority, are introduced.</p>
",0
42660765,42660403,1,"<p>From the assignment one can assume that inputs are words/numbers separated by a white space. The code line <code>for (;cin &gt;&gt; input &amp;&amp; input != ""done"";)</code>, which I suppose to be given as part of the assignment, supports this assumption. Then, the following input is supposed to achieve the following output:</p>

<pre><code>100 200 + 100 200 - 10 done  --&gt; 290
</code></pre>

<p>Here's the code to achieve this:</p>

<pre><code>int main()
{
    string input;
    int result;
    int mode = 0;

    cout &lt;&lt; ""Type some stuff: \n"";


    for (;cin &gt;&gt; input &amp;&amp; input != ""done"";)
    {
        if (input == ""done"")
            break;
        else if (input == ""+"")
            mode = 1;
        else if (input == ""-"")
            mode = -1;
        else {
            try {
                int number = stoi(input);
                number *= mode;
                result += number;
            }
            catch( const std::exception&amp; e ) {  }  // ignore any conversion errors
        }
    }

    cout &lt;&lt; result;

    return 0;
}
</code></pre>
",0
35266667,35266618,3,"<p>You can use a <code>std::vector&lt;std::vector&lt;your_type&gt;&gt;</code> to store the result.</p>

<pre><code>int rows = 100000, cols = 100000;

std::vector&lt;std::vector&lt;double&gt;&gt; result;
result.resize(rows);

for(int i=0; i&lt;rows; i++) {
        result[i].resize(cols);
}    

for(int i=0; i&lt;rows; i++) {
    for(int j=0; j&lt;cols; j++){
        result[i][j] = a[i] * b[j];
    }
}
</code></pre>

<p>Or you can <strong>use a linear algebra library</strong>, for example Eigen (you'll may have less to code with this), which <strong>will surely be more efficient</strong>.</p>
",6
35266809,35266618,2,"<blockquote>
  <p>The <strong>NON-contiguity</strong> part of this answer should be re-researched. It
  may be wrong.</p>
</blockquote>

<p>If you want to work with big number of element such as <code>100000*100000</code>. I would not recommend to use <code>vector of vectors</code> due to the ""NON-contiguity"" property of the inner <code>vectors</code> elements to each other. Small <code>push_back</code> may results in a lot of mess.</p>

<p>I would use single <code>vector</code> with a wrapper. See this for more information <a href=""https://stackoverflow.com/questions/20994321/clean-ways-to-write-multiple-for-loops/20995125#20995125"">Clean ways to write multiple &#39;for&#39; loops</a> .</p>
",4
35271210,35266618,1,"<pre><code>    #include &lt;vector&gt;
    class C
    {
    public:
        C(const std::vector&lt;double&gt;&amp; a_, const std::vector&lt;double&gt;&amp; b_)
            :a(a_),b(b_){};
        double operator()(size_t i, size_t j) const { return a[i]*b[j]; }
    private:
         std::vector&lt;double&gt; a, b;
    };
</code></pre>

<p><strong>What the problem actually is?</strong></p>

<p>The original question asks about a way to save <code>C(i,j)=A(i)*B(j)</code> to a matrix. </p>

<p>From an OOP point of view, such an <code>matrix</code> can be defined as an object with a method takes two inputs(<code>i</code> and <code>j</code>), and returns a result (<code>ret=A(i)*B(j)</code>).</p>

<p>This could be implemented using nested array subscriptions(<code>c[i][j]</code>), or linear array indexing(<code>c[i*100000+j]</code>), or a function (<code>c.get(i, j)</code>). The third way could also be simplified to a functor (<code>c.operator()(i, j)</code> or <code>c(i, j)</code>).</p>

<p><strong>Then what?</strong></p>

<p>If you agree to all above that any of the three interfaces serves the purpose, or at least partially (like I mentioned in the comment, if the matrix is only required to provide random <strong>read</strong> access to its elements). Then we continue to implement one of them, 3rd one being my choice.</p>

<p><strong>Why do it that way?</strong></p>

<p>My observation is that, computing the return value is not expensive, so why not calculate the product ""lazily"" when the product is actually accessed?</p>

<p>In this way, the storage is very efficient (memory usage is reduced from <code>n^2</code> to <code>2n</code>).</p>

<p>Hiding the multiplication in the getter function does not significantly increase access time (two memory accesses and one multiplication, compared with the ideal case being one memory access only, but both cases are constant time, and this implementation is much more cache friendly for the reduced size of the data).</p>

<p><strong>So, instead of saving the product, just save the inputs, but calculate the product when a particular element is accessed.</strong></p>

<p><strong>What is missing?</strong></p>

<p>Although manipulating this ""matrix"" is possible ( by changing the member <code>a</code> and <code>b</code>), it does not allow changing arbitrary element to arbitrary value.</p>

<p>Member functions that implements array slicing (like <code>c(0:10:end, 4)</code>) is not present either, but is feasible.</p>

<p><strong>Test code</strong></p>

<pre><code>int main() {
    C c({1,2,3,4},{10,20,30,40}); // a={1,2,3,4}; b={10,20,30,40}
    cout &lt;&lt; ""3*30 ""&lt;&lt;c(2,2);      // c(2, 2) = a[2]*b[2] = 3*30 = 90
    return 0;
}
</code></pre>

<p><strong>Demo</strong></p>

<p><a href=""http://ideone.com/bZR7AU"" rel=""nofollow"">http://ideone.com/bZR7AU</a></p>
",4
35269461,35266618,0,"<p>Using an in-RAM <code>std::vector&lt;double&gt;</code> would probably not feasible if you have less than 80GB of RAM in your system (for a 100000¡Á100000 matrix of doubles).</p>

<p>Here is how you would do this using an mmap'd file. Please see the inline comments:</p>

<pre><code>#include &lt;sys/mman.h&gt;
#include &lt;stddef.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

#define ROWS 1000
#define COLS 1000
#define FILENAME ""./matrix.doubles""

int main(void)
{
    double (*matrix)[ROWS][COLS]; // pointer to our matrix
    int fd; // file descriptor of backing file

    // open backing file
    fd = open(FILENAME,
              O_CREAT | O_RDWR, // create (if absent) and/or read and writable
              S_IRUSR | S_IWUSR); // (only) user may read and write
    if (fd &lt; 0) {
        perror(""Could not open file"");
        return 1;
    }

    if ((lseek(fd, sizeof(*matrix), SEEK_SET) == (off_t) -1) ||
        ftruncate(fd, sizeof(*matrix)) ||
        (lseek(fd, 0, SEEK_SET) == (off_t) -1)) {
        perror(""Could not set file size."");
        return 1;
    }

    matrix = mmap(NULL, // I don't care were the address starts
                  sizeof(*matrix), // size of matrix in bytes
                  PROT_READ | PROT_WRITE, // readable and writable
                  MAP_PRIVATE, // we access the data exclusively
                  fd, // file descriptor of backing file
                  0); // offset
    if (matrix == MAP_FAILED) {
        perror(""Could not mmap file."");
        return 1;
    }

    // operate on matrix
    for (unsigned row = 0; row &lt; ROWS; ++row) {
        for (unsigned col = 0; col &lt; COLS; ++col) {
            (*matrix)[row][col] = row * col;
        }
    }

    // close backing file
    munmap(matrix, sizeof(*matrix));
    close(fd);

    return 0;
}
</code></pre>

<p>This is pure C code. You could fancy up the code by using e.g. <a href=""http://de.cppreference.com/w/cpp/container/array"" rel=""nofollow""><code>std::array&lt;double, ROWS, COLS&gt;&amp;</code></a> instead of a bare array, but I think the idea should be understandable.</p>
",0
47465423,47465387,0,"<p>Try adding some diagnostic printing statements:  </p>

<pre><code>for(int x=1;x&lt;=5;x++)
{
    cout &lt;&lt; ""--&gt; x before inner loop"" &lt;&lt; x &lt;&lt; endl;
    for(int x=0;x&lt;=1;x+=1)
    {
        cout &lt;&lt; ""--&gt; x in inner loop"" &lt;&lt; x &lt;&lt; endl;
        cout&lt;&lt;""###############""&lt;&lt;endl;
    }
}
</code></pre>
",1
47465450,47465387,0,"<p>You have nested for-loop, The outer loop will run from x=1 to x=5 (5 iterations)
and your inner loop runs from x=0 to x=1 (2 iterations), where every loop prints ""###############"".</p>

<p>For each iteration of the outer loop, you run the inner loop 2 times. Hence, 5 iterations produce 5*2 = 10 lines.</p>

<p>Just as a good programming practice, keep your control variables different. 
i.e.</p>

<pre><code>// outer loop
for(int x=1; x&lt;=5; x++){
    // inner loop
    for(int j=0; j&lt;=1; j+=1){
        cout &lt;&lt; ""###############"" &lt;&lt; endl;
    }
}
</code></pre>
",0
47465613,47465387,0,"<pre><code>for(int x=1;x&lt;=5;x++)
{
    for(int x=0;x&lt;=1;x+=1)
    {
        cout&lt;&lt;""###############""&lt;&lt;endl;
    }
}
</code></pre>

<p>Think about this: Assume you write 2 lines per day and you keep doing the work for five days, you will have written 10 lines by then.</p>

<p>If you're thinking why it shouldn't be 5 or 7, that's because the <code>int x=0</code> at line 3 <a href=""http://en.cppreference.com/w/cpp/language/unqualified_lookup#Namespace_scope"" rel=""nofollow noreferrer"">""hides""</a> the outer <code>x</code>, so the two variable <code>x</code>'s are isolated from each other, and they don't conflict.</p>
",0
39135614,39135585,2,"<p>The bind-expression is callable with any number of arguments; arguments that don't correspond to placeholders are discarded.</p>

<pre><code>auto f = std::bind(falseRead);

f(a, b, c);  // equivalent to falseRead();
</code></pre>

<p>Therefore, your bind-expression can be used to construct an <code>std::function&lt;void(int)&gt;</code> object:</p>

<pre><code>std::function&lt;void(int)&gt; g = f;

g(a);  // = f(a) = falseRead()
</code></pre>

<p>It's the opposite direction that's forbidden: If your bound function takes parameters, you must provide values for the arguments (either bound values or placeholders):</p>

<pre><code>void realRead(int fd, char* buf);

auto h = std::bind(realRead, _1, buf);  // h(fd) = realRead(fd, buf)
// auto h = std::bind(realRead);        // error
</code></pre>
",0
46110935,46110779,7,"<p><code>std::string</code> ultimately uses the global <code>operator new</code>. You're creating two <code>std::string</code>s. </p>
",0
46111187,46110779,1,"<p>You should override operator new in your base class if you don't want new to be called multiple times in this case:</p>

<pre><code>class CBaseTest
{
public:
    void *operator new(const size_t allocation_size)
    {
        cout&lt;&lt;""\n\nMy new invoked:\n"";
        return ::malloc(allocation_size);
    }

    void operator delete(void *block_of_memory)
    {
        cout&lt;&lt;""\n\nMy delete invoked:\n"";
        ::free(block_of_memory);
    }
};

class test : public CBaseTest
{
public:
    int age;
    string name;

    test(string str, int a)
    {
        age = a;
        name = str;
    }
    void display();
};

void test::display()
{
    cout &lt;&lt; ""\n\nname is:-"" &lt;&lt; name &lt;&lt; ""  and age is :- "" &lt;&lt; age &lt;&lt; endl;
}
</code></pre>

<p>Here</p>

<pre><code>test *t = new test(""sanjeev"", 29);
</code></pre>

<p>will invoke your new method. </p>

<p>Similarly,</p>

<pre><code>delete t;
</code></pre>

<p>will invoke your delete method</p>

<p>Now, if you try to allocate memory using new for your class test or any classes derived from CBaseTest then your new will be called.</p>
",0
46624258,46624193,3,"<p><code>rand()</code> shares state between threads; that already accounts for your observations.</p>
",0
42490518,42490337,1,"<p>First of all the variable <code>posicio</code> was not initialized. So in general case the program has undefined behavior.</p>

<p>And secondly you are finding the last element in the vector such that the condition <code>vector[i]&lt;vector[i-1]</code> is true. And indeed for this sequence
22, 72, 123, 45, 81  such an element is 45.</p>

<p>If you need to find the minimum element ypu should write</p>

<pre><code>int min=vector[0], posicio = 0;
                   ^^^^^^^^^^^
for(i=1;i&lt;MAX;i++){
    if( vector[i] &lt; min ){
    ^^^^^^^^^^^^^^^^^^^^^
        min=vector[i];
        posicio= i;
    }
}
</code></pre>

<p>If you need to determine only the position of the minimum element of the array then you can write</p>

<pre><code>int posicio = 0;

for ( i = 1; i &lt; MAX; i++ ){
    if( vector[i] &lt; vector[posicio} ){
        posicio = i;
    }
}
</code></pre>

<p>And it does not make sense to declare the variable <code>i</code> outside the loops.</p>

<p>So you may remove this declaration</p>

<pre><code>   int vector[MAX], i=0;
                  ^^^^^
</code></pre>

<p>And write for example</p>

<pre><code>for ( int i = 0;i &lt; MAX; i++ ){
    cin &gt;&gt; vector[i];
}
</code></pre>

<p>Take into account that there is standard algorithm <code>std::min_element</code> declared in header <code>&lt;algorithm&gt;</code> that performs this task.</p>
",0
42490441,42490337,2,"<p>You are only picking two elements from your vector to compare these:</p>

<pre><code> if(vector[i]&lt;vector[i-1]){
</code></pre>

<p>so that condition only gives you the minimum of these two, and not that of the whole array.</p>

<p>Change your condition to</p>

<pre><code> if(vector[i]&lt;min){
</code></pre>

<p>and your code will run as intended.</p>
",0
45293724,45292519,1,"<p>Please add the include directories as mentioned in the documentation : <a href=""https://cmake.org/cmake/help/v3.0/command/include_directories.html"" rel=""nofollow noreferrer"">https://cmake.org/cmake/help/v3.0/command/include_directories.html</a>
Otherwise cmake will not be able to find where to look in for include files.</p>
",0
40532599,40532186,2,"<p>Your <code>#include &lt;string&gt;</code> should be in your header file since it is you are using the <code>std::string</code> type with your methods.</p>

<p>Since it is not recommended to add <code>using namespace</code> in header files (see <a href=""https://stackoverflow.com/a/14575955/2481993"">this answer</a> for more info), declare your string types with the namespace : change your <code>string value</code> to <code>std::string value</code></p>

<p>Your files will look like this (compile test was done with GCC)</p>

<p>Also you should put an include guard in your header file</p>

<p>Example:</p>

<pre><code>// some_header_file.h
#ifndef SOME_HEADER_FILE_H
#define SOME_HEADER_FILE_H
// your code
#endif
</code></pre>

<p>Node.h</p>

<pre><code>#include &lt;string&gt;

class Node
{
public:
    Node();
    Node(std::string value);
    void setNext(Node *nextNode); // Allows the user to set where the ""next"" pointer of a node points

    friend class LinkedList;
private:
    std::string data; // Data box
    Node* next; // Pointer box
};
</code></pre>

<p>Node.cpp</p>

<pre><code>#include ""Node.h""
#include &lt;cstddef&gt;  // For NULL

Node::Node()
{
    data = """";
    next = NULL;
}

Node::Node(std::string value)
{
    data = value;
    next = NULL;
}

void Node::setNext(Node *nextNode) // Allows the user to set where the ""next"" pointer of a node points
{
    this-&gt;next = nextNode;
}
</code></pre>
",4
43928634,43928513,2,"<p>You need to move the <code>main</code> function out of the <code>InitInstance</code> function body.</p>

<p>In C++, it's not possible to define nested functions inside of other functions (except for lambda functions, but they are expressions, not function definitions).</p>
",0
43930321,43928513,0,"<p><code>main</code> is the entry point function for a console app.  It must be in global scope.  You cant nest functions inside of other functions anyway.</p>

<p>Try something more like this instead:</p>

<pre><code>BOOL CBasicApp::InitInstance()
{
    typedef BOOL (__stdcall *pFunc)();

    HMODULE hMod = LoadLibrary(""dbgghelp.dll"");
    if (!hMod)
    {
        printf(""Error loading dbgghelp.DLL\n"");
        return FALSE;
    }

    pFunc pf = GetProcAddress(hMod, ""L100A6F95"");
    if (!pf)
    {
        printf(""Error finding L100A6F95 function\n"");
        FreeLibrary(hMod);
        return FALSE;
    }

    if (!pf())
    {
        printf(""L100A6F95 function failed\n"");
        FreeLibrary(hMod);
        return FALSE;
    }

    FreeLibrary(hMod);
    return TRUE;
}

...

int main(int argc, char* argv[])
{
    CBasicApp app;
    if (app.InitInstance())
    {
        ...
    }
    else
    {
        ...
    }
}
</code></pre>
",0
43934366,43928513,0,"<p>thanks buddies to all who comment and help ..fixed by just added to my .h/header file the code  </p>

<pre><code>typedef BOOL (__stdcall *pFunc) ();
int main(int argc, char* argv[]);
</code></pre>

<p>below my</p>

<pre><code>public:
virtual BOOL InitInstance();`
</code></pre>

<p>then its successfull compile no error...but now my problem is why my mainapp.exe not execute when im launching the launcher btw my dgghelp.dll was a game protection for using ce,macro and other i just rename it...it has some i guess dumps code inside....</p>
",0
46636284,46636241,0,"<p>From the second 'L' on, your code appends the first asterisk to the last one of the previous 'L'. Put the <code>cout &lt;&lt; endl</code> such that it prints a new line after each 'L':</p>

<pre><code>for ( s=3; s&lt;ast; s++)
{
    for ( a=0; a&lt;s; ++a)
    {
        cout &lt;&lt; ""* "" &lt;&lt;endl;
    }
    for ( a=0; a&lt;s; a++)
    {
        cout &lt;&lt; ""* "";
    }
    cout &lt;&lt;endl;
}
</code></pre>
",2
36229800,36229728,2,"<p>You are passing the argument <code>double p</code> to the base class constructor by value. If you pass it by reference, the addresses of <code>p</code> will be the same. Plus, <code>p</code> is not a member of the base class, so there is no reason for the <code>p</code>'s to have the same address.</p>

<p>The addresses are different so you can modify <code>p</code> within <code>Quote::Quote(const std::string &amp;b, double p)</code> without worrying about changing <code>p</code> in the constructor <code>BulkQuote::Bulk_quote(const std::string&amp; b, double p, std::size_t q, double disc)</code>.</p>
",0
41665311,40577847,1,"<p>No, in HElib it is not possible to directly compare two ciphertexts. </p>

<p>This is due to the cryptographic system used in HElib. However, even without going into detail on that it can be said that no public-key cryptosystem (HElib is public-key) could ever support an operation like <code>c1 &lt; c2</code> that returns an unencrypted boolean since that would enable an attacker to easily find the plaintext of any ciphertext simply by encrypting new values and comparing.</p>

<p>If you want to do comparisons in HElib you need to represent your entire program as a binary circuit with individually encrypted bits. Then you can implement conditional branching as multiplexing. This is not only tedious but also in general too slow (HElib is not a fast encryption system) for any 'real' program.</p>
",0
40543878,40543791,1,"<p>You problem is that the <em>first</em> time you enter  the loop, <code>input</code> has no value. This can be fixed by giving it an initial value in its declaration</p>

<pre><code>int main()
{
char input = 'Y';
double voltage, current;

while (input == 'Y')
{
</code></pre>

<p>You then still have the problem that the user might enter <code>'y'</code> instead of <code>'Y'</code> at the end of the loop. We'll leave that as an exercise for the student.</p>
",2
44687717,44683222,-1,"<p>Pointer arithmetic can be used without actually creating any objects:</p>

<pre><code>class c {
    int member;
};

c *ptr = 0;
++ptr;
int size = reinterpret_cast&lt;int&gt;(ptr);
</code></pre>

<p>Alternatively:</p>

<pre><code>int size = reinterpret_cast&lt;int&gt;( static_cast&lt;c*&gt;(0) + 1 );
</code></pre>
",0
44688128,44683222,0,"<p>Yet another alternative without using pointers. You can use it if in the next interview they also forbid pointers. Your comment <em>""The interviewer was leading me to think on lines of overflow and underflow""</em> might also be pointing at this method or similar.</p>

<pre><code>#include &lt;iostream&gt;
int main() {
    unsigned int x = 0, numOfBits = 0;
    for(x--; x; x /= 2) numOfBits++;
    std::cout &lt;&lt; ""number of bits in an int is: "" &lt;&lt; numOfBits;
    return 0;
}
</code></pre>

<p>It gets the maximum value of an <code>unsigned int</code> (decrementing zero in unsigned mode) then subsequently divides by 2 until it reaches zero. To get the number of <em>bytes</em>, divide by <code>CHAR_BIT</code>.</p>
",0
43964049,43961341,2,"<p>According to the documentation found <a href=""https://fukuchi.org/works/qrencode/manual/structQRcode.html"" rel=""nofollow noreferrer"">here</a> libqrencode just returns you an array with the information needed to generate the image. To get an actual image you need to do something like this:</p>

<pre><code>for(int i = 0; i &lt; qrcode-&gt;width; ++i)
{
    for(int j = 0; j &lt; qrcode-&gt;width; ++j)
    {
        if(qrcode-&gt;data[i * qrcode-&gt;width + j] &amp; 1)
        {
            // draw black dot at (i,j)
        }
        else
        {
            // draw white dot at (i,j)
        }
    }
}
</code></pre>
",3
40563353,40563151,0,"<p>I would rewrite your input logic like this:</p>

<pre><code>// Process data until end of file is reached
string line;
while (getline(ins, line)) {
    std::istringstream iss(line);
    if (iss &gt;&gt; sin &gt;&gt; hourly &gt;&gt; exemption) {
        Employee e;
        e.setSin(sin);
        e.setPayRate(hourly);
        cout &lt;&lt; exemption &lt;&lt; endl;
    }
}
</code></pre>

<hr>

<p>As for your particular problem, <code>line.substr(line.find(' ')</code> takes the rest of the line from the position of the first <code>' '</code>. <code>line</code> isn't changed by this operation, so you get the same if you call it a second time.</p>
",0
40577027,40576941,1,"<p>Put a <code>break</code> statement in the first part of the loop. Although you do <code>tempinputfile.close()</code> my guess is that it still is a true value as far as the while loop is concerned.</p>

<p>So edit it to be like this:</p>

<pre><code>cin &gt;&gt; overwrite;
cout &lt;&lt; endl &lt;&lt; endl;
if ( overwrite == 'Y' || overwrite == 'y' )
{
tempInputFile.close();
break;
}
</code></pre>

<p>That should work! The break will immediately exit the while loop and allow you to overwrite. Do <strong>not</strong> put a break under the <code>else</code> statement because in that case you want the loop to execute again.</p>

<p>Cheers!</p>
",0
40577097,40576941,3,"<p>Let's focus on this part of your code:</p>

<pre><code>tempInputFile.open( outputFileName );
while ( tempInputFile )
{
  cout &lt;&lt; ""This file already exists. Would you like to overwrite?  (Y/N):"";
  cin &gt;&gt; overwrite;
  cout &lt;&lt; endl &lt;&lt; endl;
  if ( overwrite == 'Y' || overwrite == 'y' )
     tempInputFile.close();       
  else
  {
      // not important
  } // end else
} // end while
</code></pre>

<p>when <code>while</code> is called for the first time after successful <code>open</code> you ask user if (s)he wants to overwrite the file and if the answer is <code>Y</code> you close the file and <code>while</code> loop checks condition again.</p>

<p>The problem is that <code>while ( tempInputFile )</code> expression checks if there are any <a href=""http://en.cppreference.com/w/cpp/io/basic_ios/operator_bool"" rel=""nofollow noreferrer"">errors</a>. Since closing a file usualy doesn't cause any problems, the condition is <code>true</code> and you enter <code>while</code>'s body again. Then you try to close file again and here is where it fails as file was already closed. So when <code>while ( tempInputFile )</code> is called for the 3rd time, it quits with false.</p>
",1
48036246,48036087,0,"<p>I would suggest using std::regex_match:</p>

<pre><code>std::regex pattrn(""[0-9*/+-]+"");
bool only_legal_equation_chars(char const * equation)
{
  return std::regex_match(equation, equation+strlen(equation), pattern);
}
</code></pre>
",1
48036326,48036087,0,"<p><a href=""http://en.cppreference.com/w/cpp/algorithm/all_any_none_of"" rel=""nofollow noreferrer""><code>std::all_of</code></a> fits quite nicely here:</p>

<pre><code>std::string mystr{""123+-*[""};
auto is_allowed_character = [](unsigned char x) //related to C
                            {
                                return (x &gt;= 48 &amp;&amp; x &lt;= 57) ||
                                        x == '+' ||
                                        //so on
                                        ;
                            }
return std::all_of(mystr.begin(), mystr.end(), 
                   is_allowed_character);
</code></pre>

<p>I removes the <code>if</code>, the loop, and makes it more idiomatic C++. Also the thing can work on any iterator, even one made from <code>std::cin</code>.</p>
",0
48036431,48036087,0,"<p>I would be tempted to use good old <a href=""http://en.cppreference.com/w/cpp/string/byte/strspn"" rel=""nofollow noreferrer"">std::strspn</a> like this:</p>

<pre><code>bool containsOnlyAllowedSymbols(const char* equation)
{
    return std::strspn(equation, ""0123456789+-*/()[]{}"") == std::strlen(equation);
}
</code></pre>
",5
48036542,48036087,0,"<p>Another <code>regex</code> solution:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;regex&gt;

bool containsOnlyAllowedSymbols(char const *equation)
{
    std::regex re(R""([^0-9(){}[\]*+-/])"");
    return !std::regex_search(equation, re);
}

int main()
{

    std::cout &lt;&lt; containsOnlyAllowedSymbols(""(10+20)-200*4"") &lt;&lt; std::endl;
    std::cout &lt;&lt; containsOnlyAllowedSymbols(""10+20-{200}abc"") &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p><a href=""https://ideone.com/wR0yA0"" rel=""nofollow noreferrer"">https://ideone.com/wR0yA0</a></p>

<p>Add space to regex pattern if expression can contain spaces.</p>
",2
34976466,34972953,0,"<p>Figured it out, though I don't understand why the solution worked.</p>

<p>I moved the following line:</p>

<pre><code>template &lt;int TYPE, typename IMPL&gt; 
const uint16_t ProblemTmpl&lt;TYPE, IMPL&gt;::PROBLEM_ID =
ProblemFactory::getInstance()-&gt;Register(ProblemTmpl&lt;TYPE, IMPL&gt;::_PROBLEM_ID, &amp;ProblemTmpl&lt;TYPE, IMPL&gt;::Create);
</code></pre>

<p>From the top of <code>EulerProblem.cpp</code> to the bottom of <code>EulerProblem.h</code> and it worked. Does anyone have any insight as to why that is?</p>
",1
40570007,40569899,0,"<p>i am not big fan of C++ but i try to give the logic</p>

<pre><code>#include &lt;iostream.h&gt;

using namespace std;

int main() {
    int n; //height of the Char V
    int i, j;
    #char s=""""; //i know only to adding string if u add s as string 
    for(int x = 1, y = n ; x &lt;= y ; x++, y--) {
        cout &lt;&lt; s;
        cout &lt;&lt; ""*"";
        for(int t = 1 ; t &lt; t ; t++) {
            cout &lt;&lt; """";
        }
        cout &lt;&lt; ""*"";
        s=s+"""";
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
",0
40570083,40569899,1,"<pre><code>int main()
{
  std::cout &lt;&lt; ""*      *\n""
               "" *    *\n""
               ""  *  *\n""
               ""   **\n""
}
</code></pre>
",2
40573182,40569899,0,"<pre><code>private static void drawPattern(int height) {
    // TODO Auto-generated method stub
    int end=height * 2;
    int j=0;
    for ( int start=0;start&lt;height;start++,end--) {
        for ( j=0;j&lt;start;j++){
            System.out.print("" "");  
        }   
        System.out.print(""*"");
        for ( ;j&lt;end;j++) {
            System.out.print("" "");
        }
        System.out.println(""*"");
    }
}
</code></pre>

<p>One dirty implementation in JAVA , try to port it to C++, height can be user input</p>
",0
40578255,40577673,4,"<p>Your error is in trying to call the default constructor as</p>

<pre><code>Pesquisa ah();
</code></pre>

<p>or</p>

<pre><code>Trabalho&lt;Pesquisa&gt; ass();
</code></pre>

<p>Unfortunately, C++ is very misleading in this and it would declare your variable <code>ass</code> of type <code>Trabalho&lt;Pesquisa&gt;()</code>, which means ""a function of zero arguments returning <code>Trabalho&lt;Pesquisa&gt;</code>"" and that's exactly that the compiler error says: a function type is not a class type and as such does not have the member <code>add_nota</code>. Indeed, it does look <em>exactly</em> like a function declaration, if you look at it that way:</p>

<pre><code>int main();
 ^    ^  ^
type    arguments
    name
</code></pre>

<p>It's a very common mistake, especially for those coming from a Java background. But it can easily catch a C++ programmer off guard as well. More information can be found <a href=""https://stackoverflow.com/questions/180172/default-constructor-with-empty-brackets"">here</a> or <a href=""https://stackoverflow.com/questions/5116541/difference-between-creating-object-with-or-without"">here</a> or <a href=""https://stackoverflow.com/questions/2318650/is-no-parentheses-on-a-constructor-with-no-arguments-a-language-standard"">here</a>, you can see that the same error message has perplexed a good many people.</p>

<p>If you have a compiler conforming to the C++11 language revision, try replacing all those occurrences by</p>

<pre><code>Trabalho&lt;Pesquisa&gt; ass{};
</code></pre>

<p>If not, just leave</p>

<pre><code>Trabalho&lt;Pesquisa&gt; ass;
</code></pre>

<p>Unlike in Java, this does not mean that the variable will stay uninitialized. It's the C++ way to call a default (zero-argument) constructor.</p>
",4
46021878,46020364,4,"<p>So it turns out the answer was really easy. If you read from this website : <a href=""https://gist.github.com/roxlu/3077861"" rel=""nofollow noreferrer"">https://gist.github.com/roxlu/3077861</a></p>

<p>You'll see that <code>stb_image</code> doesn't support <code>progressive JPEG</code> image format (which I didn't even knew existed)</p>
",0
40552607,40552336,1,"<p>Vowels and consonants will always be zero because you are passing them by value, hence their values will not change to fix this you should pass them by reference and so the functions prototypes will be </p>

<pre><code>int Count(const char[], int&amp;); //function heading int Count(const char text[], int&amp; a)
int Count2(const char[], int&amp;); //function heading int Count2(const char text[], int &amp;b)
</code></pre>

<p>Also in the functions definition you are decrementing the values? They should be incremented.</p>
",0
40552432,40552336,1,"<p><code>Count()</code> did not return 0. You just didn't take its return value for printing.</p>

<p>And in <code>UpperCase()</code> and <code>LowerCase()</code>, you should assign the return value of <code>toupper()</code> and <code>tolower()</code> back into <code>text[i]</code>. That is,</p>

<pre><code>text[i] = toupper(text[i]);
</code></pre>
",1
46084349,46084288,1,"<p>The problem is that you are providing explicit template arguments to the function. Forwarding arguments does not work when you explicitly provide the template arguments for the type you want to forward (unless you really know what you are doing).</p>

<blockquote>
<pre><code>template &lt;class T, class X&gt;
void h1(T&amp;&amp; t, X x) { x(forward&lt;T&gt;(t)); }
</code></pre>
</blockquote>

<p>When you write <code>h1&lt;int, decltype(h2ref)&gt;</code>, you get a function like this:</p>

<pre><code>void h1(int&amp;&amp; t, decltype(h2ref) x) { x(forward&lt;int&gt;(t)); }
</code></pre>

<p><code>int&amp;&amp;</code> is a different type from <code>int</code> and cannot be bound to an lvalue of type <code>int</code> such as the <code>b</code> that you pass in; it can only be bound to rvalues of type <code>int</code></p>

<hr>

<p>If you leave off the template arguments, it just works:</p>

<pre><code>h1(b, h2ref);
</code></pre>

<p>This will instantiate a function that looks like this:</p>

<pre><code>void h1(int&amp; t, // int&amp; &amp;&amp; collapses to just int&amp;
        decltype(h2ref) x) {
    x(forward&lt;int&amp;&gt;(t));
}
</code></pre>
",3
41659172,41659088,0,"<p>Try this one. (too simple :-) )</p>

<pre><code> #include &lt;math.h&gt;
    int n,a, result=0;
        cout &lt;&lt; ""Please enter number: "";
        cin &gt;&gt; n;
        cout &lt;&lt; ""Please enter number of digits: "";
        cin &gt;&gt; a;
        int b=a;
        while(b&gt;0) {
             result += n%10 * pow(10,a-b--);
             n=n%10;
        }
        std::cout&lt;&lt;""result: ""&lt;&lt;result;
</code></pre>
",5
41659300,41659088,3,"<p>Here is an algorithm I didn't test it but it works {only with loops and if}</p>

<pre><code>int num = 3543125;
int temp = 0;
do             //get the result in reverse number
{
    temp += num % 10;
    temp *= 10;
    num /= 10;
    if (num % 10 == 1)
        temp += 1;

} while (num % 10 != 1);    
int result = 0;
while (temp &gt; 0)   //reverse the temp number to result
{
    result = result * 10 + (temp % 10);
    temp = temp / 10;
}
cout &lt;&lt; result;  // = 125
</code></pre>
",0
40681852,40681782,4,"<p>The algorithm is pretty straightforward - it follows the general approach to two-way merging that you see in all algorithms:</p>

<ul>
<li>Open both input files, and the output file, as streams</li>
<li>Read lines from the first file one-by-one</li>
<li>If the line that you read is non-empty, copy it into the output</li>
<li>Otherwise, read the next line from the second file, and copy it into the output</li>
<li>Once the first file is exhausted, copy the rest of the second file into the output.</li>
</ul>
",1
40744943,40744894,1,"<p><code>val += line[i] == "" * "";</code> is evaluated as <code>val += (line[i] == "" * "");</code> due to <em>operator precedence</em>.</p>

<p><code>val</code> will be incremented by 1 (<code>true</code> converts to an integral value of 1) if, and only if, <code>line[i]</code> compares <code>true</code> with <code>"" * ""</code>, else it will stay the same.</p>

<p>Finally <code>#define endl '\n'</code> is <em>very</em> naughty. Don't attempt to change symbols in the C++ standard library.</p>
",1
44231081,44207707,0,"<p>The project is building an installer.  The merge modules (.msm) are required to be able to install the product.  Consider that if that is your first error, you have built the .exe / .dll of your project and work out how to install your new code based on your more updated dependencies.</p>

<p>The likelihood, is that the merge-modules have been added from the original dependencies for the build. </p>

<p>As you have upgraded the project, they are probably not the correct merge modules for the upgraded project.</p>
",1
40782272,40778771,0,"<p>The reason for the error message is that you don't have any type named <code>struct node</code>. So you can't <code>new</code> a <code>struct node</code>.</p>

<p>To me it seems that the main problem is that you mix <code>C</code> and <code>C++</code> syntax. In <code>C</code> the correct syntax would be to repeat the <code>struct</code> part of the type but in <code>C++</code> <code>struct</code> is not repeated.</p>

<p>So the fix is simply to replace</p>

<pre><code>struct node
</code></pre>

<p>with </p>

<pre><code>Node
</code></pre>

<p>all places in the file.</p>

<p>Besides that you have a number of places where you mix up <code>tmp</code> with <code>temp</code></p>

<p>Also you have a problem in</p>

<pre><code>Node* DLinkedList::removeNode(Point XY)
</code></pre>

<p>as you say the function will return a <code>Node*</code> but inside the function, you call <code>return</code> with no arguments.</p>

<p>You probably want</p>

<pre><code>void DLinkedList::removeNode(Point XY)
</code></pre>
",0
35248313,35248154,3,"<p>The basic problem is that you don't having any timing in your game loop so everything is happening at the same speed.  There are some good articles online that discuss game timing loops, this one for  instance: <a href=""http://www.koonsolo.com/news/dewitters-gameloop/"" rel=""nofollow"">http://www.koonsolo.com/news/dewitters-gameloop/</a> walks you through the steps from the approach you're using now to the better approach of separating your game update timing from your display timing.</p>

<p>That article doesn't tell you how to slow your enemy down relative to your player - one approach is to have a enemySpeed variable and use something like:</p>

<pre><code>// outside main loop
int enemySlowness = 20;  // adjust this as needed
int enemyMoveTimer = 0;

...
if (++enemyMoveTimer &gt; enemySlowness)
{
    Enemy1Movements(enemy1, l1_map, lastloc);
    enemyMoveTime = 0;
}
</code></pre>

<p>There are problems with this approach, but coupled with some idea from that article should get you on the right track.</p>
",1
40773451,40773412,9,"<p>The comma operator <a href=""http://en.cppreference.com/w/cpp/language/operator_other#Built-in_comma_operator"" rel=""noreferrer"">introduces a sequence point</a> and, as such, this behavior is guaranteed by the C++ standard.</p>
",0
42681913,42681723,1,"<p>No, you cannot do that with any IDE that some headers are included by default.</p>

<p>The closest thing you can do is to provide a single header file</p>

<pre><code> #include ""MyProject.h""
</code></pre>

<p>that just includes all the other header files:</p>

<p><code>MyProject.h</code>:</p>

<pre><code>#include&lt;conio.h&gt;
#include&lt;iostream.h&gt;
</code></pre>

<hr>

<p>You should note that <code>conio.h</code> and <code>iostream.h</code> aren't standard c++ headers, and that code isn't portable because of that.</p>
",0
40776510,40776411,0,"<p>You have the <code>return</code> statement in compute in the wrong place.  It is inside of the loop instead of after it.</p>
",0
40776486,40776423,0,"<p>There are a couple of things you need to change for this to compile: you haven't defined an array called ""minmax"", so you need to do that first, before you try to assign the values of min and max to it. Your function also doesn't return the array yet. </p>
",3
40956721,40956688,3,"<p>This is a use case for <a href=""http://en.cppreference.com/w/cpp/types/conditional"" rel=""nofollow noreferrer""><code>std::conditional</code></a></p>

<pre><code>using sampleType = typename std::conditional&lt;
                     signalSampleType == QAudioFormat::Float,
                     float,
                     typename std::conditional&lt;
                       signalSampleType == QAudioFormat::SignedInt,
                       int, unsigned int&gt;::type
                   &gt;::type; 
</code></pre>

<p>Which can be made a bit less ugly with c++14:</p>

<pre><code>using sampleType = std::conditional_t&lt;
                     signalSampleType == QAudioFormat::Float,
                     float,
                     std::conditional_t&lt;
                       signalSampleType == QAudioFormat::SignedInt,
                       int, unsigned int&gt;
                   &gt;
</code></pre>
",1
35233520,35233474,3,"<p>The problem is caused by an unwanted <code>;</code>.</p>

<pre><code>    if (this-&gt;phone[i]-&gt;getBrand() == name);  // if ends here.
</code></pre>

<p>The next block is executed for all items.</p>

<pre><code>    {
        index = i;
        phoneFound = true;
        this-&gt;nrOfPhonesInArr--;            
    }
</code></pre>

<p>Remove that <code>;</code> in the <code>if</code> line.</p>
",1
40961551,40961340,1,"<p>By <code>if(fin>>data)</code> you are not just testing, but retrieving data from stream. I suggest use ifs.good() for testing. Overall, you can write such a code instead</p>

<pre><code>std::ifstream fin (""OUTPUT1.txt"", std::ifstream::in);
char c = fin.get();

while (fin.good()) 
{
   std::cout &lt;&lt; c;
   c = fin.get();
}
</code></pre>
",0
40961815,40961340,0,"<p><code>arr[n-1] = '\0';</code> is not correct because it's not an array of character so don't mind.</p>

<p>to correct it:</p>

<pre><code>int data;   
while(fin&gt;&gt;data)
{
    arr[n] = data;
    n++;
}

cout &lt;&lt; ""Displaying Array..."" &lt;&lt; endl &lt;&lt; endl;

for(int i = 0; i &lt; array_size; i++)
{
    cout &lt;&lt; arr[i];
}
</code></pre>

<ul>
<li><p>why allocating such huge array of integers? use vector is a good thing:</p>

<pre><code>vector&lt;int&gt; vec;
ifstream fin(""OUTPUT1.txt"");
int data;   
while(fin &gt;&gt; data)
{
    vec.push_back(data);
}

cout &lt;&lt; ""Displaying Array..."" &lt;&lt; endl &lt;&lt; endl;
for(int i = 0; i &lt; vec.size(); i++)
    cout &lt;&lt; vec[i] &lt;&lt; endl;
fin.close();
</code></pre></li>
<li><p><code>88764877846</code> out band of an integer which causes the loop stop reading so you have to either get values as strings then convert into <code>__int64</code> or <code>__int128</code></p></li>
</ul>

<p>to read values as strings:</p>

<pre><code>    string sLine;
    int nLines = 0;
    ifstream fin(""OUTPUT1.txt"");

    // first read to get number of lines
    while(getline(fin, sLine))
        nLines++;

    //create an array of strings
    string* pstrValues = new string[nLines];

    // set the get pointer to the beginning of file because the previous read moved it
    fin.clear();
    fin.seekg(0, ios::beg);
    int i = 0;

    while(getline(fin, sLine))
    {
        pstrValues[i] = sLine;
        i++;
    }

    cout &lt;&lt; ""Displaying Array..."" &lt;&lt; endl &lt;&lt; endl;
    for( i = 0; i &lt; nLines; i++)
        cout &lt;&lt; pstrValues[i] &lt;&lt; endl;
    fin.close();
</code></pre>

<ul>
<li>now you have an array of strings convert it to int values but you must convert to <code>__int64</code> because as I said there are values bigger than size of <code>int</code> (4bytes)</li>
</ul>
",4
44359335,44359303,6,"<p>It's because you declared it <code>extern</code>, extern tells the compiler that the definition and declaration of the variable are in another file and you are simply making your code ""aware"" of the existence of that variable, as such the compiler does not expect any assignment on the header.</p>
",0
44359428,44359303,2,"<p>Remember not only you don't <strong>need</strong> to, but you shouldn't assign a value to <code>extern</code> declarations because that makes them a definition. </p>
",0
35246827,35245981,2,"<p>The problem is that the series you create with <em>nthterm</em> does not converge. Try to change the line</p>

<pre><code>y=a+x-x*x;
</code></pre>

<p>to</p>

<pre><code>y=(x+a/x)/2;
</code></pre>

<p>EDIT: The code works if and only if the start value is not zero. For positive start values you get the positive square root; for negative start values you get the negative square root.</p>
",1
36512329,36512194,1,"<p>The problem lies here.</p>

<pre><code>                if (PlayerCanonUse &lt;= 0){
                    cout &lt;&lt; ""Sorry, you have used all of your canons. Choose a different weapon.\n"";
                cin &gt;&gt; WeaponChoice;
                }

                if (PlayerGrenadeUse &lt;= 0){
                    cout &lt;&lt; ""Sorry, you have used all of your grenades. Choose a different weapon.\n"";
                    cin &gt;&gt; WeaponChoice;
                }
</code></pre>

<p>These two if statements are checked even if you didn't choose the weapon.
This can be fixed with something like</p>

<pre><code>           if (WeaponChoice == 1 &amp;&amp; PlayerCanonUse &lt;= 0){
                cout &lt;&lt; ""Sorry, you have used all of your canons. Choose a different weapon.\n"";
            cin &gt;&gt; WeaponChoice;
            }

            if (WeaponChoice == 2 &amp;&amp; PlayerGrenadeUse &lt;= 0){
                cout &lt;&lt; ""Sorry, you have used all of your grenades. Choose a different weapon.\n"";
                cin &gt;&gt; WeaponChoice;
            }
</code></pre>

<p>It would be simpler to do this check inside the switch.</p>
",1
47557025,47556869,2,"<pre><code>for ( n = 0; n == 5; n++)
</code></pre>

<p>Is not what you want. A <code>for</code>-loop is nothing but a <code>while</code>-loop using different syntax:</p>

<pre><code>n = 0;

while(n == 5)
{
   // you loop body here
    n++;
}
</code></pre>

<p>As you can see, it executes <em>while your condition is</em> <code>true</code>. In this case... not at all because it's not <code>true</code> to begin with. </p>

<p>You probably meant </p>

<pre><code>for ( n = 0; n &lt; 5; n++)
</code></pre>
",0
47557053,47556869,1,"<p><code>n == 5</code> is the problem. When came to for function and makes the test to see if the block needs to run it get false because you initialize with <code>n = 0</code>; better than <code>n == 5</code> use <code>n!=5</code> but if you skip to make n = 5 you get an infinite loop. </p>

<p>For the best case use <code>n &lt; 5</code>.</p>
",0
41004097,41003900,3,"<p>Your code has several errors (missing <code>;</code> etc.). A <code>class</code> is not different from a <code>struct</code> in C++. The only difference is the default access specifier which is <code>private</code> in a <code>class</code> and <code>public</code> in a <code>struct</code> (members and inheritance). </p>

<p>Structs are typically used to indicate that it actually is just a data structure with no logic or methods. Imho they are nice to encapsulate input and output of methods. If you want to have it for a member function it could look like this:</p>

<pre><code>class Foo{
    public:
    struct BarIn {};              // need ; here
    struct BarOut {};             // and here
    BarOut bar(const BarIn&amp; b){return BarOut();}
};


int main() {
    Foo::BarOut result = Foo().bar(Foo::BarIn());
}
</code></pre>

<p>Note that I had to write <code>Foo:BarOut</code> and <code>Foo::BarIn</code>, because the structs are declared inside the class. Also there is no need to write <code>struct</code> when you declare a variable of a type that is declared as <code>struct</code> (because there really is no difference between an instance of a <code>class</code> or <code>struct</code>).</p>

<p>Last but not least you should <strong>never</strong> return a reference (or pointer) to a local variable: </p>

<pre><code>struct Astruct &amp; test::MethodOne(){
    Astruct testStruct;
    return testStruct;            // testStruct is destroyed here
}                                 // and the returned ref is invalid
</code></pre>
",0
46973277,46972707,0,"<p>I compiled your code using g++ and then run the binary. Result shown below:</p>

<pre><code>Enter first number: 10
Enter second number: 20
30Addition is: 0
</code></pre>

<p>I did not get an error when executing the binary however, like others have already pointed out, there is one error in your code. I guess your intention was to store the sum in variable ""add"". To do that you need this line of code before you print add:</p>

<pre><code>add = addition(num1, num2);
</code></pre>

<p>But your function addition returns a void, this needs to be changed to return an int as shown below:</p>

<pre><code>int addition(int, int);
</code></pre>

<p>The function body can be like shown below:</p>

<pre><code>int addition(int a, int b){return a+b;}
</code></pre>

<p>A suggested rewrite of your code:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int addition(const int&amp; a, const int&amp; b){return a+b;}

int main()
{
    int num1{};
    int num2{};

    cout&lt;&lt;""Enter first number: "";
    cin&gt;&gt;num1;

    cout&lt;&lt;""Enter second number: "";
    cin&gt;&gt;num2;

    int&amp;&amp; add = addition(num1,num2);
    cout&lt;&lt;""Addition is: ""&lt;&lt;add&lt;&lt;endl;

    return 0;
}
</code></pre>

<p>compile the code using g++ -std=c++11</p>
",3
43196764,43196749,6,"<p>Use a <code>std::vector&lt;T&gt;</code>, and call <a href=""http://en.cppreference.com/w/cpp/container/vector/push_back"" rel=""noreferrer""><code>v.push_back()</code></a>.</p>

<p>Arrays in C++ cannot change their size.</p>
",2
47544356,47544131,2,"<p>You cannot force the compiler to generate an error if <code>fn</code> is not overridden in <code>B</code>.</p>

<p>You can modify your code a little bit to get what you want.</p>

<ol>
<li><p>Make <code>A::fn</code> a pure-virtual. Leave the implementation as is in <code>A</code>. Remember that it's perfectly OK to implement <code>A::fn</code> even when it is declared pure-virtual.</p></li>
<li><p>That will force you to override <code>fn</code> in <code>B</code>. The implementation of <code>B::fn</code> can utilize as much of <code>A::fn</code> as it needs to.</p></li>
</ol>

<hr>

<pre><code>truct Base {
    virtual void fn() = 0;
};

struct A : Base {
    virtual void fn() = 0;
};

void A::fn()
{
   // Add implmentation details
}

struct B : A {
    // fn must be  overridden here
    virtual void fn();
};

void B::fn()
{
   A::fn();
   // Add additonal logic for B
}
</code></pre>

<hr>

<p>You can generate run time error though if <code>A::fn</code> is called an on <code>B</code> object.</p>

<p>Here's one way to do it.</p>

<pre><code>#include &lt;iostream&gt;

struct Base
{
   virtual void fn() = 0;

   virtual int getTypeID() = 0;

   protected:

   static int getNextID()
   {
      static int nextid = 0;
      return ++nextid;
   }

   static int getClassTypeID()
   {
      static int id = getNextID();
      return id;
   }
};

struct A : Base 
{
   virtual void fn();

   virtual int getTypeID()
   {
      return getClassTypeID();
   }

   private:

   static int getClassTypeID()
   {
      static int id = getNextID();
      return id;
   }
};

void A::fn()
{
   if ( this-&gt;getTypeID() != A::getClassTypeID()  )
   {
      // Problem.
      std::cout &lt;&lt; ""ERROR. fn() called on a derived class object.\n"";
   }
   else
   {
      std::cout &lt;&lt; ""OK. fn() called on an A object.\n"";
   }
}

struct B : A
{
   virtual int getTypeID()
   {
      return getClassTypeID();
   }

   static int getClassTypeID()
   {
      static int id = getNextID();
      return id;
   }
};

int main()
{
   A* a1Ptr = new A;
   A* a2Ptr = new B;

   a1Ptr-&gt;fn();
   a2Ptr-&gt;fn();
}
</code></pre>

<p>Output:</p>

<pre class=""lang-none prettyprint-override""><code>OK. fn() called on an A object.
ERROR. fn() called on a derived class object.
</code></pre>
",3
45276898,45276730,-2,"<p>From <a href=""http://www.cprogramming.com/declare_vs_define.html"" rel=""nofollow noreferrer"">here</a>:</p>

<blockquote>
  <p>Most of the time, when you declare a variable, you are also providing
  the definition. What does it mean to define a variable, exactly? It
  means you are telling the compiler where to create the storage for
  that variable. For example, if you write:</p>

<pre><code>int x;
int main()
{
    x = 3;
}
</code></pre>
  
  <p>The line int x; both declares and defines the variable; it effectively
  says, ""create a variable named x, of type int. Also, the storage for
  the variable is that it is a global variable defined in the object
  file associated with this source file</p>
</blockquote>

<p>this is a part from site more relevant to your question
please refer to the link for further your misconception will be hopefully cleared 
<a href=""http://www.cprogramming.com/declare_vs_define.html"" rel=""nofollow noreferrer"">http://www.cprogramming.com/declare_vs_define.html</a></p>
",7
45276970,45276730,1,"<p><code>int a;</code> is both a declaration (the variable can be used) and a definition (it has its own memory) but if it is an automatic variable, it is not initialized. </p>

<p><code>extern int a;</code> is a mere declaration and is not a definition. </p>
",0
36223054,36222296,1,"<p>Looks like it shows the content before initialization - that is, garbage.</p>

<p>Step to the next line.</p>
",0
36223056,36222296,0,"<p>You are keeping track of the <code>res_path</code> variable (Autos). This will look for the value of <code>res_path</code> in your current scope, which is before you declare the variable and set it to the value.</p>

<p>Press <kbd>F10</kbd> to execute the line and have <code>res_path</code> assigned a value. </p>
",1
42541646,42540950,0,"<p>You are welcome to write your own <code>getline</code> function that uses your string class:  </p>

<pre><code>std::istream&amp;
std::getline(std::istream&amp; input_stream, My_String&amp; s, char delimiter = '\n')
{
  //...
  return input_stream;
}
</code></pre>

<p>There are many advantages to using <code>std::string</code> instead of developing your own string class.</p>
",0
40977920,40977671,1,"<p>You probably have 4 files, card.h, card.cpp, player.h and player.cpp.
In player.h:</p>

<pre><code>#include ""card.h""

class Player { ... };
</code></pre>

<p>In player.cpp:</p>

<pre><code>#include ""player.h""

...
</code></pre>

<p>In card.h:</p>

<pre><code>class Player; // Forward declaration

class Card { ... };
</code></pre>

<p>In card.cpp:</p>

<pre><code>#include ""card.h""
#include ""player.h""

...
</code></pre>

<p>That's it.</p>
",4
45293745,45293525,5,"<p>Your understanding is correct.</p>

<pre><code>int &amp;refVal3 = refVal;
</code></pre>

<p>This makes <code>refVal3</code> a reference to the same thing <code>refVal</code> is a reference to. That is, <code>ival</code>.</p>

<blockquote>
  <p>just what exactly does the book mean when it mentioned ""Because
  references are not objects, we may not define a reference to a
  reference."" ?</p>
</blockquote>

<p>A reference can only refer to an object. But references are not objects. So a reference cannot refer to a reference. And when the book says this, it doesn't just mean that it's not allowed, and you'll get an error if you try. But you can't even try. There's no syntax for it. Because anything you try to do to a reference, you will actually be doing to the object it refers to, and not to the reference itself.</p>

<blockquote>
  <p>Can someone perhaps give me an example ?</p>
</blockquote>

<p>No. I can't. And that's the point. There's simply no syntax for it.</p>
",0
45781451,45781233,0,"<p>If <code>n</code> and <code>d</code> are both zero, then the count of <code>0</code> should be 1.</p>
",0
45781471,45781233,2,"<p>You dont count the first zero (0*0), because the loop condition is p (while(p)).</p>

<p>So add a condition to add one to c, if p is zero and d is zero</p>

<pre><code>class CountDig
{
public: static int nbDig(int n, int d)
{
    int c=0;
    if (d==0)
         c=1; // start from 1, when counting 0
   for(int i=1;i&lt;=n;i++)
  {
      int p=i*i;
      while(p)
     {
        int l;
        l=p%10;
         if(l==d)
            c++;
        p=p/10;
     }

  }
return c;
}
};
</code></pre>
",2
41209311,41208984,-1,"<p>I think is the efficient algo for you and easy to understand. You can change the value of k as per your constraints.     </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

int n,p=2,savePrime=2,k=100000;

void printNPrime(int n)
{
    bool prime[k];
    memset(prime, true, sizeof(prime));

   while(n&gt;0)
   {
        if (prime[p] == true)
        {
            if(p-savePrime == 2)
            {
                cout&lt;&lt;savePrime&lt;&lt;"" ""&lt;&lt;p&lt;&lt;endl;
                n--;
            }
            // Update all multiples of p
            for (int i=p*2; i&lt;=k; i += p)
                prime[i] = false;
            savePrime=p;    
        }
      p++;  
   }

}   

int main() {
    cin&gt;&gt;n;
    printNPrime(n);
    return 0;
}
</code></pre>
",0
41209050,41208984,1,"<p>Here is the top-level simple pseudo-code for such a beast:</p>
<pre><code>def printTwinPrimes(count):
    currNum = 3
    while count &gt; 0:
        if isPrime(currNum) and isPrime(currNum + 2):
            print currnum, currnum + 2
            count = count - 1
        currNum = currNum + 2
</code></pre>
<p>It simply starts at <code>3</code> (since we know <code>2,4</code> is impossible as a twin-prime pair because <code>4</code> is composite). For each possibility, it checks whether it constitutes a twin-prime pair and prints it if so.</p>
<p>So all you need to do (other than translating that into <em>real</em> code) is to create <code>isPrime()</code>, for which there are countless examples on the net.</p>
<p>For completeness, here's a simple one, by no means the most efficient but adequate for beginners:</p>
<pre><code>def isPrime(num):
    if num &lt; 2:
        return false
    root = 2
    while root * root &lt;= num:
        if num % root == 0:
            return false
        root = root + 1
    return true
</code></pre>
<p>Though you <em>could</em> make that more efficient by using the fact that all primes other than two or three are of the form <code>6n¡À1, n &gt;= 1</code><sup>(a)</sup>:</p>
<pre><code>def isPrime(num):
    if num &lt; 2: return false
    if num == 2 or num == 3: return true
    if num % 2 == 0 or num % 3 == 0: return false
    if num % 6 is neither 1 nor 5: return false

    root = 5
    adder = 2                   # initial adder 2, 5 -&gt; 7
    while root * root &lt;= num:
        if num % root == 0:
            return false
        root = root + adder     # checks 5, 7, 11, 13, 17, 19, ...
        adder = 6 - adder       # because alternate 2, 4 to give 6n¡À1
    return true
</code></pre>
<hr />
<p>In fact, you can use this divisibility trick to see if an arbitraily large number stored as a string is likely to be a prime. You just have to check if the number below it or above it is divisible by six. If not, the number is definitely not a prime. If so, more (slower) checks will be needed to fully ascertain primality.</p>
<p>A number is divisible by six only if it is divisible by both two and three. It's easy to tell the former, even numbers end with an even digit.</p>
<p>But it's also reasonably easy to tell if it's divisible by <em>three</em> since, in that case, the sum of the individual digits will <em>also</em> be divisible by three. For example, lets' use <code>31415926535902718281828459</code>.</p>
<p>The sum of all those digits is <code>118</code>. How do we tell if <em>that's</em> a multiple of three? Why, using exactly the same trick recursively:</p>
<pre><code>118: 1 + 1 + 8 = 10
 10: 1 + 0     = 1
</code></pre>
<p>Once you're down to a single digit, it'll be <code>0</code>, <code>3</code>, <code>6</code>, or <code>9</code> if the original number was a multiple of three. Any other digit means it wasn't (such as in this case).</p>
<hr />
<p><sup>(a)</sup> If you divide any non-negative number by six and the remainder is 0, 2 or 4, then it's even and therefore non-prime (2 is the exception case here):</p>
<pre><code>6n + 0 = 2(3n + 0), an even number.
6n + 2 = 2(3n + 1), an even number.
6n + 4 = 2(3n + 2), an even number.
</code></pre>
<p>If the remainder is 3, then it is divisible by 3 and therefore non-prime (3 is the exception case here):</p>
<pre><code>6n + 3 = 3(2n + 1), a multiple of three.
</code></pre>
<p>That leaves just the remainders 1 and 5, and those numbers are all of that form <code>6n¡À1</code>.</p>
",1
41209092,41208984,0,"<p>Might not be the most efficient but you can calculate all primes till n, store them in a vector then only print those which have a difference of 2</p>

<pre><code>#include &lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

void pr(int n, vector&lt;int&gt;&amp; v)
{
    for (int i=2; i&lt;n; i++) 
    {
        bool prime=true;
        for (int j=2; j*j&lt;=i; j++)
        {
            if (i % j == 0) 
            {
                prime=false;
                break;    
            }
        }   
        if(prime) v.push_back(i);
    }
}
int main()
{
   vector&lt;int&gt; v;
   pr(50, v);
   for(int i = 0;i &lt; v.size()-1; i++) {
       if(v[i+1]-v[i] == 2) {
           cout &lt;&lt; v[i+1] &lt;&lt; "" "" &lt;&lt; v[i] &lt;&lt; endl;
       }
   }

   return 0;
}
</code></pre>
",0
40962600,40962568,3,"<p>One way is to supply a default parameter to the second one:</p>

<pre><code>void test(int one, int two = 0)
</code></pre>

<p>Then if you call it with just one parameter then the second parameter assumes the default value.</p>

<p>Another approach is to overload the function:</p>

<pre><code>void test(int one)
</code></pre>

<p>This has the advantage that you can write specific behaviour for the case where a single parameter is passed.</p>
",2
40962601,40962568,-1,"<p>You can't.  You must supply arguments for every parameter a function has.  You may not need to do so explicitly if there's a default argument, but that still provides an argument for that parameter.</p>
",0
40962684,40962568,0,"<p>If you need partial evaluation, see <a href=""http://en.cppreference.com/w/cpp/utility/functional/bind"" rel=""nofollow noreferrer"">std::bind</a>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;functional&gt;

using namespace std::placeholders;

int adder(int a, int b) {
    return a + b;
}

int main() {
    auto add_to_1 = std::bind(adder, 1, _1);

    auto add_1_to = std::bind(adder, _1, 1);

    std::cout &lt;&lt; add_1_to(2) &lt;&lt; std::endl;

    std::cout &lt;&lt; add_to_1(2) &lt;&lt; std::endl;

    return 0;
}
</code></pre>
",3
40963722,40962568,0,"<p>There are 2 options:</p>

<pre><code>void test(int one, int two = -1) {
   /* ... */
}
</code></pre>

<p>This gives the function a default value for two so calling test(2) would mean that the test function would operate with one = 2 and two = -1. These default can only work if there are no variables without default parameter after them in function definition.</p>

<pre><code>void testA(int one, int two = -1); // OK
void testB(int one, int two = -1, int three); // ERROR
void testC(int one, int two = -1, int three = -1); // OK
</code></pre>

<p>Then the other option would be to overload this function. Overloading means that one function has two different definitions. There are some rules to follow when overloading function, mainly that the different overloads must be distinguishable by parameter that you feed them. So in your case the solution would be:</p>

<pre><code>void test(int one) {
   /* ... */
}
void test(int one, int two) {
   /* ... */
}
</code></pre>

<p>If you have any more questions feel free to ask.</p>
",0
40972630,40972159,1,"<p>This is one of the better use cases for #define macros.  Something like:</p>

<pre><code>#define LOG_INFO(args...)                                   \
    do {                                                    \
        if (Logging::logLevelReached(Logging::LevelInfo())) \
            Loging::info(__VAR_ARGS__);                     \
    } while (0)
</code></pre>

<p>(Note the use of the <code>do { ... } while(0)</code> idiom to create a statement that needs to be termninated with a semicolon).</p>

<p>Usage:</p>

<pre><code>LOG_INFO(px_object-&gt;longLognDebugString());
</code></pre>

<p>This doesn't support:</p>

<pre><code>LOG_INFO()
</code></pre>

<p>... but why would you want that?</p>
",1
41005499,41005439,2,"<pre><code>for(/*Initialize*/; /*Evaluate*/ ;/*update iterater*/); 
</code></pre>

<p>using the above you have <code>i++</code> in the Evaluate section of the for loop. </p>

<pre><code>0 == false 
</code></pre>

<p>try it like this : </p>

<pre><code>for (i=0 ; i &lt; 10; i++) 
</code></pre>
",1
41005556,41005439,4,"<p>Your syntax is wrong: for loop should have the form:</p>

<pre><code>for ( init; condition; increment ) 
</code></pre>

<p>Note the clauses are separated by <code>;</code>. But you wrote:</p>

<pre><code>for (i=0, i &lt; 10; i++;)
</code></pre>

<p>With a <code>,</code> instead of the first <code>;</code>. </p>

<p>So you have <code>i=0, i &lt; 10</code> as your <code>init</code>, <code>i++</code> as your <code>condition</code>, and nothing as your <code>increment</code>.</p>

<p>Therefore, when your loop runs, first you set <code>i=0</code>, then you evaluate <code>i &lt; 10</code> and throw away the result.</p>

<p>Then you check the ""condition"", which is <code>i++</code> - which returns <code>i</code> before the increment, which is <code>0</code>, which means <code>false</code>, and your loop therefore does not execute.</p>

<p>Instead, you meant to write:</p>

<pre><code>for (i=0; i &lt; 10; i++)
</code></pre>

<p>Which would function as you expect.</p>
",0
41663583,41663361,0,"<p>You need to cast you function pointer, so that the compiler will know how to call the function.</p>

<p>Here is one way to do it:</p>

<pre><code>randomNumbers[counter] = (int (*)())myCS-&gt;functionRandom();
</code></pre>

<p>The <code>(int (*)())</code> casts <code>myCS-&gt;functionRandom</code> to a function that gets void and returns int, and of course you need to call it with parenthesis.</p>

<p><strong>EDIT</strong></p>

<p>I haven't checked it, but I believe the cast has a higher priority over the last parenthesis. That is, it is understood as so: </p>

<pre><code>((int (*)())myCS-&gt;functionRandom) ();
</code></pre>

<p>If this is not the case, you will need also to add the parenthesis wrapping it all, to designate a stand alone function..</p>
",1
41921893,41663361,0,"<p>I found the answer i was looking for, how to store a addres to a function in a structure:</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;cstdarg&gt;
#include &lt;math.h&gt;

int randomNumber = 0;

int Random(){
    randomNumber++;
    return randomNumber;
}

struct CStructure{
    int rep;
    int (*FunctionRandom) ();
};

CStructure* ConstructorCS(CStructure** myCS, int rep, int(*myFunctionRandom)(void)){
    *myCS = (CStructure*) malloc (sizeof(CStructure));
    (*myCS)-&gt;rep = rep;
    (*myCS)-&gt;FunctionRandom = myFunctionRandom;
}

void ExecuteCStructure(CStructure* myCS){
    int counter = 0;
    int randomNumbers[myCS-&gt;rep];
    char* text;
    while(counter &lt; (myCS-&gt;rep)){
        //here i  receive a number from the function
        randomNumbers[counter] = myCS-&gt;FunctionRandom();
        printf(""\n number generated by the function: %d"", randomNumbers[counter]);
        counter++;
    }
}

int test01(){
    CStructure* code;
    ConstructorCS(&amp;code, 3, &amp;Random);
    ExecuteCStructure(code);
}

int main(){
    test01();
}
</code></pre>
",0
41184502,41184399,1,"<p>in your Main you have to call <code>Menu()</code> as:</p>

<pre><code>int main()
{

    Player Pl;
   Input=Menu();
    //if the chosen number was 1 it will make the Player move.
   //if the chosen number was 2 it will make the Player attack.
   if(Input == 1)
   {
       Pl.Movement();
   }
   else if(Input == 2)
   {
       Pl.Attack();
   }

   Menu();
  //calling the Menu function
  return 0;
}
</code></pre>
",0
41184692,41184399,1,"<p>As far as i can see you set Input up as a Global variable, but never initialised it. </p>

<p>So the flow of your Program is:</p>

<ol>
<li>P1 gets created</li>
<li>The if-statement gets called, but the Input is not initialised yet. So its undefined. As far as i know its random and the possibility that its one or two is rather small.</li>
<li>Menu gets called and within Menu() Input gets set. But at this point its to late.</li>
<li>The Program ends.</li>
</ol>

<p>My tip for you is to call Menu() right after the P1 gets created.</p>
",0
41211366,41210939,1,"<p>there are many errors in your code:</p>

<p>1- make <code>in_data()</code> public to be able to call it from outside like in your main otherwise you get compile-time error <code>accessing private data</code> remember members of a class is by default private whereas struct's are public</p>

<p>2- declare member data: question, a, b,... you are using them without declaring them.</p>

<p>3- you declared <code>in_data</code> to take a character as the sixth parameter while you pass to it a const character string in main:</p>

<pre><code>q[0].in_data(""what is 2+2"",""alpha"",""beta"",""gamma"",""delta"",""d""); // ""d"" is a constant character string not just a single character so change it to 'd'
q[1].in_data(""choose a"",""a"",""b"",""c"",""d"",""a""); // look at in_data how was defined.
</code></pre>

<p>your code will look like:</p>

<pre><code>#include&lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class ques
{
    public: // make in_data public to use from outside
        void in_data(char qu[500], char p[25], char q[25], char r[25], char s[25], char ans1) // so pass eg: 'a' not ""a""
        {
            strcpy(question, qu);
            strcpy(a, p);
            strcpy(b, q);
            strcpy(c, r);
            strcpy(d, s);
            ans = ans1;
        }
    private:
        char question[500];
        char a[25];
        char b[25];
        char c[25];
        char d[25];
        char ans;
};

int main()
{

    ques q[2];
    q[0].in_data(""what is 2+2"",""alpha"",""beta"",""gamma"",""delta"",'d');
    q[1].in_data(""choose a"",""a"",""b"",""c"",""d"",'a');

    return 0;
}
</code></pre>

<ul>
<li>Finally why don't you use <code>class string</code> as long as it is a must in your code instead of using arrays of characters?</li>
</ul>
",1
43954998,43954763,0,"<p>As you set the problem, you shouldn't check if one value is bigger than the other, but if the running time crossed the alarm.
So suppose the alarm is at point a.
Time was t_old and now it is t.
What we have to check is if a is between t_old and t.
That seems easy to say, but a little bit more difficult to do.</p>

<p>Any way, subtracting from all values t_old, we have t_old=0 a-t_old and t-t_old. So using usigned arithmetic if a-t_old is &lt; t-t_old it is your case ( check it and if I did any error inform me).</p>
",2
41185999,41184882,0,"<p>This is how you store an entire line in a string (you must <code>#include&lt;string&gt;</code>)</p>

<pre><code>string line;
getline(cin, line);

string op;
string a;
</code></pre>

<p>Then you can get the data from the string:</p>

<pre><code>if(string.length &gt; 1)
{
    op = line.substr(0,1);
    a  = line.substr(1,string.length);
}
else op = line.substr(0,1)
</code></pre>

<p>Then you convert the op to char: </p>

<pre><code>char chOp = line[0];
</code></pre>

<p>Convert the string a to int:</p>

<pre><code>int intA = std::stoi(a); 
</code></pre>
",0
41186311,41184882,0,"<p>@Some programmer dude is completely correct. A proper parser is the only reliable way to go. Below is an example of a brittle , that is to say 'easily broken', parser for the kind of input I think you're expecting. Cleverer people than I could probably write it better. Note the required error checking and assumptions within the code.</p>

<p>I've also taken the liberty to clean up your original main() a small bit.</p>

<p>Hope this inspires you to learn boost::spirit or any of the excellent C++ parsers out there.   </p>

<pre><code>    using namespace std;

    bool
    get_input_from_cin(char &amp; op, double &amp; d)
    {
    static const char * OPERATORS=""+-/*="";
    char lc ='\0';
    char d_buffer[64]; // where we'll store the number
    size_t d_buffer_counter = 0;
    memset(d_buffer,'\0',sizeof(d_buffer));  // initialize it to nulls
    for (char lc = ' '; lc != '\n'; cin.get(lc))
    { // loop gathering characters until you get a newline.

          if ( strchr(OPERATORS,lc) != nullptr)
          { // if we're expecting an operator and we find it then save it
                op = lc; // what happens if we get more than one operator before a new line?
          }
          else if ( ' ' == lc )
          {
                ; // No Operation : consume spaces with no action
          }
          else
          { // we assume a double, save the digits. Check they are digits using isdigit(..) or some call.
              d_buffer[d_buffer_counter++] = lc;
              if ( d_buffer_counter == sizeof(d_buffer) )
              { // issue a warning in here somehow
                  return false;
              }
          }
     }

    if ( '\0' == op )
    { // no operator included!
        return false;
    }

    if ( '\0' == d_buffer[0] )
    { // no number included!
        return false;
    }

    d = atof(d_buffer);
    return true;
    }

    int main()
    {
    double a = 0.0, sum = 0.0; // you're not using b or c, better not to declare them
    char op;

    cout    &lt;&lt; sum;
    op = '\0'; // initialize 
    while (op != '=')
    {

        if (false == get_input_from_cin(op, a))
        {
            if ('=' == op)
            {
                cout &lt;&lt; sum;
                return 0;
            }
            cerr &lt;&lt; ""Input parse error."" &lt;&lt; endl;
            return -1;
        }

        switch (op)
        {
        case '+':
            sum = sum + a;
            cout &lt;&lt; sum;
            break;
        case '-':
            sum = sum - a;
            cout &lt;&lt; sum;
            break;
        case '/':
            sum = sum / a;
            cout &lt;&lt; sum;
            break;
        case '*':
            sum = sum*a;
            cout &lt;&lt; sum;
            break;
        case '=':
            cout &lt;&lt; sum;
            break;
        }
    }

    return 0;
}
</code></pre>
",0
41215299,41214911,1,"<p>What you're looking for is the ASCII-Value/Code of the specific character.</p>

<pre><code>string str = ""apple"";
char c1;
char c2;

c1 = str[0];
c2 = str.at(0);

std::cout &lt;&lt; static_cast&lt;int&gt;(c1) &lt;&lt; std::endl;
std::cout &lt;&lt; static_cast&lt;int&gt;(c2) &lt;&lt; std::endl;
</code></pre>
",0
41211689,41211261,0,"<p>Your istream operator >> <code>as_int</code> is failing and really doing nothing so your loop just keeps going. Either input as chars and convert to ints with checks, or or check the stream for errors.</p>

<pre><code>cin&gt;&gt;a&gt;&gt;b;
if( cin.fail( ) )
    break;
</code></pre>

<p><a href=""https://stackoverflow.com/questions/37151597/istream-reading-after-failure"">istream reading after failure</a></p>

<p><strong>Additionally:</strong> If you had have traced into the istream operator you would have seen why it was not blocking, that it had failed. Always trace when something is wrong...</p>
",0
41211726,41211261,0,"<p>std::cin (and I think all streams) by default will set an error flag when you try to read into an invalid data type (e.g. here with trying to read a char into an int variable) and that flag will prevent other std::cin to run until the flag is cleared. To rest the stream, use std::cin.clear() to the reset the error flag and then you have to remove the bad input, either through std::cin.ignore() or read into a string buffer or something, from the stream as it will still be there.</p>
",0
41213202,41213011,0,"<p>It doesn't ""work"" for so many reasons. First of all make sure it compiles. Second, a thread is not like a simple class like a string. You cannot copy threads; you can only move threads. What you're doing is trying to initialize an ""empty"" thread to then copy another thread on top of it. What you can do, if you want an array, is to use pointers instead. To get current thread id, you have to use this_thread::get_id();</p>

<pre><code>#include &lt;thread&gt;
#include &lt;iostream&gt;

#define NUM_TH 4

using namespace std;

void printhello() { 
    auto th_id = this_thread::get_id();
    cout &lt;&lt; ""Hello world! Thread ID, ""&lt;&lt; th_id &lt;&lt; endl;
}

int main() {   
    thread* th[NUM_TH];

    for (int i = 0; i &lt; NUM_TH; i++)
    {
        th[i] = new thread(printhello);
        th[i]-&gt;join();
    }
}
</code></pre>
",0
41213209,41213011,1,"<p>Instead of passing the thread to the function, you could access the <code>printhello's</code> executing thread by <code>std::this_thread</code>;</p>

<p>Hence, remove the argument and use <code>std::thread::id this_id = std::this_thread::get_id();</code> instead.</p>
",0
42669299,42669004,4,"<p>Your <code>if</code> statement is not a <strong>compile-time</strong> branch, therefore the compiler will try to compile</p>

<pre><code>this-&gt;previousLineBroken = (a == debug::endl); 
</code></pre>

<p>for any <code>T</code>, even if </p>

<pre><code>std::is_same&lt;T, const char*&gt;::value 
</code></pre>

<p>is <code>false</code>. This <em>might</em> be the cause of your errors. You should add a <a href=""https://stackoverflow.com/help/mcve"">MCVE</a> to your question.</p>

<hr>

<p>In C++17, you can make the <code>if</code> a compile-time branch by using <code>if constexpr</code>:</p>

<pre><code>if constexpr(std::is_same&lt;T, const char*&gt;::value) { 
    this-&gt;previousLineBroken = (a == debug::endl); 
} 
</code></pre>

<hr>

<p>In C++11, you can use an additional helper function and <em>overloading</em> instead:</p>

<pre><code>template &lt;typename T&gt;
void setPreviousLineBroken(std::true_type, T a)
{
    this-&gt;previousLineBroken = (a == debug::endl); 
}

template &lt;typename T&gt;
void setPreviousLineBroken(std::false_type, T) { /* do nothing */ }
</code></pre>

<p>Your code will the look like: </p>

<pre><code>template &lt;typename T&gt;
inline Logger &amp; Logger::operator&lt;&lt;(const T &amp;a)
{
    if (debug::enabled)
    {
        std::cout &lt;&lt; a;
        file &lt;&lt; a;
        if (this-&gt;previousLineBroken)
        {
            std::cout &lt;&lt; std::flush;
            file &lt;&lt; std::flush;
            this-&gt;previousLineBroken = false;
        }
        setPreviousLineBroken(std::is_same&lt;T, const char*&gt;{});
        return *this;
    }
}
</code></pre>
",2
42499413,42499159,1,"<p>Well, you declare <code>folderList</code> as an <code>object</code> and attempt to use it here,</p>

<pre><code> Ipc3dxContainerPtr folder = NULL;  &lt;-- Error Here
</code></pre>

<p>and not as a <code>pointer to object</code>. If your <code>class</code> is not set up to handle that circumstance, the <code>compilation</code> <code>error</code> is likely coming from handling within the <code>class</code>.</p>

<p>The same would apply to why</p>

<pre><code>Ipc3dxContainerPtr folder = FindLastFolder(folderList, s_ForlderName);
</code></pre>

<p>is not working. So, basically just change <code>folderList</code> to be <code>*folderList</code>.</p>
",1
42500116,42499159,0,"<p>First Sorry that Explaining was not enough.
And solved this.</p>

<pre><code>void KmCdmMakeMultiProjectAction::MethodA()
{
    CStringArray s_ForlderName;
    s_ForlderName.Add(""Hi"");

    Ipc3dxContainerListPtr folderList = cabinet-&gt;GetContainerList();

    Ipc3dxContainerPtr folder = FindLastFolder(folderList, s_ForlderName);
}

Ipc3dxContainerPtr KmCdmMakeMultiProjectAction::FindLastFolder
(Ipc3dxContainerListPtr folderList, CStringArray folderNameArr)
{
    Ipc3dxContainerPtr folder = NULL;
    // skip other process
    folder = (Ipc3dxContainerPtr)folderList-&gt;GetItem(0)
    return folder;
}
</code></pre>

<p>That failed source. And I can solve with editing like this.</p>

<pre><code>Ipc3dxContainerPtr KmCdmMakeMultiProjectAction::FindLastFolder
(Ipc3dxContainerListPtr folderList, CStringArray&amp; folderNameArr)
{
     \\CStringArray folderNameArr -&gt; CStringArray&amp; folderNameArr
}
</code></pre>

<p>I still don't know why happen this problem.
Because i'm not understanding about c++'s basic theory.
Anyways I solved this problem.</p>

<p>Need to referenced by people have same problem, Thank you.</p>
",0
42500844,42499159,1,"<p>In</p>

<pre><code>Ipc3dxContainerPtr KmCdmMakeMultiProjectAction::FindLastFolder
(Ipc3dxContainerListPtr folderList, CStringArray folderNameArr)
</code></pre>

<p><code>CStringArray folderNameArr</code> is passed by value. This will trigger the copy constructor of <code>CStringArray</code> which will attempt to copy it's base class, <code>CObject</code>, and <code>CObject</code> cannot be copied because its copy constructor is <code>private</code> specifically to prevent copying. In C++11 and newer, the copy constructor would be <code>delete</code>d, most likely giving you a much easier to understand error message.</p>

<p>Solution: Pass by reference: <code>CStringArray &amp; folderNameArr</code> if you don't want <code>folderNameArr</code> to be altered inside the function, use <code>const CStringArray &amp; folderNameArr</code>. If you want to alter a copy of the parameter, but not the original, make a new <code>CStringArray</code> and <code>CStringArray::Append</code> <code>folderNameArr</code> to it.</p>
",1
41213894,41213505,7,"<p>Here is the difference:</p>

<pre><code>DerivedClass *der = dynamic_cast&lt;DerivedClass *&gt;(someBaseClassPtr);
</code></pre>

<p>Will return <code>nullptr</code> in the case where <code>someBaseClassPtr</code> does not refer to an object of <code>DerivedClass</code>.</p>

<pre><code>DerivedClass&amp; der = dynamic_cast&lt;DerivedClass&amp;&gt;(someBaseClassObj);
</code></pre>

<p>Will throw an exception if <code>someBaseClassObj</code> does not in fact reference an object of <code>DerivedClass</code>.</p>
",0
41213514,41213505,2,"<p>If the failed cast is to a pointer, a null pointer is returned; if it is to a reference, then an exception is thrown.</p>
",2
47565475,47565398,2,"<p>If <code>cin &gt;&gt; i</code> fails, the variable <code>i</code> is not assigned.  In your program, this means it still has an indeterminate value.  Using an indeterminate value as in <code>(i % 2 == 0)</code> is undefined behavior, meaning as far as the C++ Standard is concerned, anything could happen.</p>

<p>On most common systems, though, the variable <code>i</code> will have some value, whatever was left over from the last time some register or piece of memory was used.  This value will be either even or odd.  So if <code>i</code> happens to be zero or positive, your <code>fail</code> check will never be reached.</p>

<p>You will probably want to reorder your <code>if</code> checks to check <code>cin</code> first, and only use <code>i</code> if the extraction was successful.</p>
",0
47566128,47565398,0,"<p>I suppose a little tweak in your program should solve the issue for you :</p>

<pre><code>if (cin.fail())
            exit (0);
        else if(i % 2 == 0)
            even(i);
        else if (i % 2 == 1)
            odd(i);
</code></pre>
",0
44747801,44747780,2,"<p>Using the array <code>s</code> can make it <em>decay</em> to a pointer to its first element.</p>

<p>Using plain <code>s</code> when a pointer is wanted is equal to doing <code>&amp;s[0]</code>. That pointer will have the type <code>char *</code>. The expression <code>&amp;s</code> is a pointer to the <em>array</em> and it will have the type <code>char (*)[6]</code>. It's very different.</p>
",0
44747894,44747780,1,"<p>The expression <code>&amp;s</code> is a pointer to an object of type <code>char[6]</code> which is the type of the array <code>s</code>.</p>

<p>On the other hand the type <code>char **</code> is pointer type to an object of type <code>char *</code> . The types <code>char[6]</code> and <code>char *</code> are different types. So the pointer types are incompatible.</p>

<p>Your fallacy is that you think that in this expression <code>&amp;s</code> the array designator is implicitly converted to pointer to its first element. However such an assumption is wrong. </p>

<p>It is more explicitly expressed in the C Standard (6.3.2.1 Lvalues, arrays, and function designators) than in the C++ Standard</p>

<blockquote>
  <p>3 <strong>Except when it is the operand of the sizeof operator or the unary
  &amp; operator</strong>, or is a string literal used to initialize an array, an
  expression that has type ¡®¡®array of type¡¯¡¯ is converted to an
  expression with type ¡®¡®pointer to type¡¯¡¯ that points to the initial
  element of the array object and is not an lvalue. If the array object
  has register storage class, the behavior is undefined.</p>
</blockquote>
",0
41195635,41195538,0,"<p>The loop condition is wrong, you should set</p>

<pre><code>for(int i=1;i&lt;num.length();i++){
</code></pre>

<p>and the program will not crash. Still, I cannot claim if the result is a desired one.</p>
",0
41195667,41195538,0,"<p>When <code>i=num.length()</code>, <code>s2</code> is empty as  </p>

<pre><code>s2 = num.substr(i,num.length()-i); 
</code></pre>

<p>which is same as </p>

<pre><code>s2 = num.substr(i, 0);  //for i=num.length()
                   ^~~~~length of substring is zero
</code></pre>

<p>Then, this <strong>empty string</strong> is passed to <code>stol</code> as <code>s2</code>, consequently leading to the error ""<em>terminate called after throwing an instance of 'std::invalid_argument'</em>""</p>

<pre><code>long n2 = stol (s2, &amp;sz, 0);
                 ^~~~~Empty string.
</code></pre>

<p><a href=""http://melpon.org/wandbox/permlink/OfuG6PbOpe3Wwmo5"" rel=""nofollow noreferrer"">Demo</a> </p>
",0
41193849,41193785,0,"<p>A <code>do-while</code> loop in the main, without the <code>while</code> (and <code>test--</code>) in Menu()?</p>

<p>(<code>do-while</code> so you can choose to end the loop displaying the menu at least one time)</p>
",0
41192740,41192617,1,"<p>You have turned your logic around.</p>

<pre><code>} while ((ch1 != '\n') &amp;&amp; (ch2 != '\n'));
</code></pre>

<p>your here saying which i don't have a '\n' and and not have a '\n' but you do have a '\n' so the first part is false and then the second clause is irrelevant as C++ short-circuit evaluation of || &amp;&amp; expressions.</p>

<p>ie.</p>

<pre><code>false &amp;&amp; something 
</code></pre>

<p>is always false.</p>
",0
41192818,41192617,2,"<p>You should use <code>||</code> instead of <code>&amp;&amp;</code></p>

<pre><code>int main()
{
char ch1, ch2;
do 
{    
cin.get(ch1);
cout.put(ch1);
cin.get(ch2);
cout.put(ch2);
} while ((ch1 != '\n') || (ch2 != '\n'));
}
</code></pre>
",0
41192819,41192617,0,"<p>Try using | | instead of &amp;&amp;.     </p>
",0
36285148,36284787,0,"<p>As you do not have member variables, neither your problem defines an object then it does not make sense to create a class. A ""Static class"" in C++ does not exist, you are just ""creating a namespace with a class"". If you want to group functions then you should use namespaces.</p>
",0
47497760,47497596,1,"<p>1) The <code>Copy()</code> function in <code>TModel</code> differs in constness from the <code>Copy() const</code> in the base class. So it is not an override, making the derived class also abstract.</p>

<p>2) I don't know what you intend <code>Document.emplace_back(Document);</code> to do. To me it looks like it is trying to insert <code>Document</code> into itself. </p>

<p><strike>If nothing else, <code>Document</code> stores elements of type <code>TObject</code>, not of type <code>TDocument</code>, so this is not going to work.</strike></p>

<hr>

<p>Looking further, <code>Document</code> is storing objects holding <em>pointers</em> to other objects (well hidden in the nested classes). So possibly it could hold a wrapped pointer to itself.</p>

<p>The primary problem with <code>Document.emplace_back(Document);</code> is that the overridden <code>Copy()</code> function tries to do <code>return make_unique&lt;TConcept&gt;(*this);</code>. However, <code>make_unique&lt;TConcept&gt;</code> will attempt to do a <code>new TConcept(parameters)</code>, which doesn't work when <code>TConcept</code> is abstract.</p>

<p>I can get the code to compile and run by modifying the <code>TModel::Copy</code> function into this rather nasty piece:</p>

<pre><code>unique_ptr&lt;TConcept&gt; Copy() const override 
{ return unique_ptr&lt;TConcept&gt;(new TModel(*this)); }
</code></pre>

<p>Whether it now does anything useful, I still cannot tell.  :-)</p>
",2
41196191,41196165,3,"<p>Because <code>i</code> is uninitialized. Initialize the <code>i</code> value, Like</p>

<pre><code>for(int i = 0; i &lt; 5; i++)
</code></pre>

<p><code>uninitialized</code> variables to hold <strong>garbage</strong> data.So, this is <strong>undefined behaviour</strong>.</p>
",0
41196263,41196165,1,"<p>It is failing many times because it is undefined behaviour to use uninitialized variable i. Any thing can happen in that case.</p>
",0
41196494,41196165,0,"<p>Initialise the value of <strong>i</strong>.<strong>i++</strong> is trying to increment an uninitialised variable.</p>
",0
47478508,47478490,5,"<p>Because the compiler is not smart enough (or just doesn't bother trying) to understand that one of the <code>return</code>s is always reached.</p>
",1
47478514,47478490,0,"<p>The problem is that all control paths should either throw exception or return some value. Doing otherwise is undefined behavior, so compiler wants to warn you about that. In your case, compiler cannot prove that all execution paths lead to return/exception. </p>

<h2>Why?</h2>

<p>Because doing the check is expensive. Sometimes it might not even be possible. As a result, compiler just doesn't have such feature.</p>

<h2>In which cases?</h2>

<p>Well, this is more about discrete math. </p>
",0
47478636,47478490,2,"<p>In the case of an <code>if</code> and <code>else</code>, if both the <code>if</code> and <code>else</code> branch return you can be sure that something returns in all cases. </p>

<p>In your case, it requires an analyses to determine that the conditions fully cover all possible use cases which the compiler is not required to do. In this case it's pretty straight forward, but consider more complicated conditions. If such simple conditions were required to be analyzed, it would be a case of ""where do we draw the line?"" in terms of what complexity should the compiler be expected to analyze.</p>
",0
44340221,44340117,2,"<p>You are simply missing some parenthesis around your function pointer calls.</p>

<pre><code>#include&lt;iostream&gt;

class a
{
public:
    a(){}
    int f(float m) {
        std::cout&lt;&lt;""called.""&lt;&lt;std::endl;
        return 1;
    }
};

int main()
{
    int (a::*ptr2)(float m) = &amp;a::f;
    a *p ,obj;
    p = &amp;obj;
    (obj.*ptr2)(.8); //note the difference
    (p-&gt;*ptr2)(.5);
}
</code></pre>

<p>It is in situations like this that <code>std::invoke</code> can be extremely handy: <a href=""http://en.cppreference.com/w/cpp/utility/functional/invoke"" rel=""nofollow noreferrer""> std::invoke Reference</a></p>
",3
44340221,44340117,2,"<p>You are simply missing some parenthesis around your function pointer calls.</p>

<pre><code>#include&lt;iostream&gt;

class a
{
public:
    a(){}
    int f(float m) {
        std::cout&lt;&lt;""called.""&lt;&lt;std::endl;
        return 1;
    }
};

int main()
{
    int (a::*ptr2)(float m) = &amp;a::f;
    a *p ,obj;
    p = &amp;obj;
    (obj.*ptr2)(.8); //note the difference
    (p-&gt;*ptr2)(.5);
}
</code></pre>

<p>It is in situations like this that <code>std::invoke</code> can be extremely handy: <a href=""http://en.cppreference.com/w/cpp/utility/functional/invoke"" rel=""nofollow noreferrer""> std::invoke Reference</a></p>
",3
46631572,46631534,2,"<p>The line</p>

<pre><code>LinkedList&lt;Animal&gt; aL();
</code></pre>

<p>is not creating an instance of a <code>LinkedList&lt;Animal&gt;</code>, but is declaring a function <code>aL</code> with no arguments and <code>LinkedList&lt;Animal&gt;</code> as its return type.</p>

<p>To create an object using the default constructor, just don't use any braces:</p>

<pre><code>LinkedList&lt;Animal&gt; aL;
</code></pre>

<p>Alternatively, if you wish to be that explicit, you can use curly braces from C++11</p>

<pre><code>LinkedList&lt;Animal&gt; aL{};
</code></pre>

<p>Or, if you like function call syntax that much, you can</p>

<pre><code>LinkedList&lt;Animal&gt; aL = LinkedList&lt;Animal&gt;();
</code></pre>

<p>or even</p>

<pre><code>auto aL = LinkedList&lt;Animal&gt;();
</code></pre>
",0
36241703,36240233,0,"<pre><code>int myFloorForWhateverReason(double x) {
    if (x &gt; 0.0)
        return (int)x;
    else
        return (int)(x - 0.5);
}

double quickExampleee = 3.1459038585;
std::cout &lt;&lt; myFloorForWhateverReason(quickExamplee  * 100.) / 100. &lt;&lt; std::endl; 
</code></pre>
",1
36240324,36240233,3,"<p>What about using <code>std::setprecision</code> if you don't like to cast the numbers to int's, like</p>

<pre><code>std::cout &lt;&lt; std::setprecision(0) &lt;&lt; quickExamplee &lt;&lt; std::endl;
</code></pre>

<p>so to print out <strong>3.14</strong> you simply set precision to 2, like</p>

<pre><code>std::cout &lt;&lt; std::setprecision(2) &lt;&lt; quickExamplee &lt;&lt; std::endl;
</code></pre>
",2
36240298,36240233,2,"<p>You could do <code>static_cast&lt;int&gt;(quickExampleee * 100.)</code> as long as the double is greater than 0.</p>
",2
46084188,46083058,1,"<p>As others have said in the comments, you cannot concatenate strings in C using the addition operator. You can do something like in this example:</p>

<pre><code>#include &lt;string.h&gt;

char buf[4096];
snprintf(buf, sizeof(buf), ""\""C:\\Users\\%s\\Desktop\\Myapplication.exe\"" /background"", username);

const char* czExePath = buf;
</code></pre>
",6
41943014,41942995,5,"<p>You can't chain boolean comparisons like that (well you <em>can</em>, but it doesn't do what you might think). It would need to be:</p>

<pre><code>std::cout &lt;&lt; (str.find_first_of('=') == str.npos &amp;&amp; str.find_last_of('=') == str.npos);
</code></pre>

<p>i.e. two comparisons joined by a logical AND.</p>
",1
41943049,41942995,3,"<pre><code>(str.find_first_of('=') == str.find_last_of('=') == str.npos)
</code></pre>

<p>This is basically:</p>

<pre><code>(true == str.npos);
</code></pre>

<p>Which is <code>false</code>, thus, giving you <code>0</code>.</p>
",0
41943050,41942995,2,"<p>Change </p>

<pre><code>std::cout &lt;&lt; (str.find_first_of('=') == str.find_last_of('=') == str.npos); 
// compares the result of a==b with c
</code></pre>

<p>to </p>

<pre><code>std::cout &lt;&lt; (str.find_first_of('=') == str.find_last_of('=') &amp;&amp;  str.find_last_of('=') == str.npos); 
// ensures a == b &amp;&amp; b == c
</code></pre>

<hr>

<p>Also, you might pretty much know the answer yourself (just trying to relate things) - </p>

<pre><code>std::cout &lt;&lt; (str.find_first_of('=') == str.find_last_of('='))
</code></pre>

<p>gives you <code>1</code> and ofcourse you know <code>str.npos = 4294967295</code></p>

<p><em>Simplifying things</em> -  </p>

<pre><code>std::cout &lt;&lt; (str.find_first_of('=') == str.find_last_of('=') == str.npos)
</code></pre>

<p>changes to </p>

<pre><code>std::cout &lt;&lt; (1 == 4294967295) 
</code></pre>

<p>and results in <code>0</code>.</p>

<p><strong><em>Note</em></strong> - Specifically taking the example of <code>first_of</code> and <code>last_of</code> comparison since the <code>==</code> follows <em>left to right associativity</em>. Though in your case the result would be same irrespective of that.</p>
",4
45099698,45098048,0,"<p>Let me put this answer from the comments here. As @DeiDei already pointed out that the <code>gameState</code> and <code>mainWindow</code> are missing.</p>

<p>Actually they are mentioned on the Part 2 page of the tutorial, right at the bottom of the game.cpp section: </p>

<pre><code>Game::GameState Game::_gameState = Uninitialized; 
sf::RenderWindow Game::_mainWindow; 
</code></pre>

<p>I had to remove the underscores in order to get this to work.</p>
",0
41455391,41455327,5,"<p>Floats don't store their data in base 10, they store it in base 2. Thus, <code>4611690000000000000</code> isn't actually a very round number. It's binary representation is:</p>

<pre><code>100000000000000000000111001111100001000001110001010000000000000. 
</code></pre>

<p>As you can see, that would take a lot of data to precisely record. The number that's actually printed, however, has the following binary representation:</p>

<pre><code>11111111111111111111111111111111111111111111111111111111111100
</code></pre>

<p>As you can see, that's a much rounder number, and the fact that it's off by 4 from a power of two is likely due to rounding in the convert-to-base-10 algorithm.</p>

<p>As an example of a number that <em>won't</em> fit in a float properly, try the number you expected:</p>

<pre><code>4611690000000000000
</code></pre>

<p>You'll notice that that will come out very differently.</p>
",0
41455406,41455327,4,"<p>The float retains so much information because you're working with a number that is so close to a power of 2.</p>

<p>The float format stores numbers in basically binary scientific notation. In your case, it gets stored as something like</p>

<p>1.0000000...[61 zeroes]...00000001 * 2^62.</p>

<p>The float format can't store 62 decimal places, so the final 1 gets cut off... but we're left with 2^62, which is almost exactly equal to the number you're trying to store.</p>

<p>I'm bad at manufacturing examples, but CERT isn't; you can view an example of what happens with bungled number conversions <a href=""https://www.securecoding.cert.org/confluence/display/java/NUM13-J.+Avoid+loss+of+precision+when+converting+primitive+integers+to+floating-point"" rel=""nofollow noreferrer"">here</a>. Note that the example is in Java, but C++ uses the same floating point types; additionally, the first example is a conversion between a 4-byte <code>int</code> and a 4-byte <code>float</code>, but this further proves your point (there's less integer information that needs to be stored than there is in your example, yet it still fails).</p>
",0
46977763,46977516,2,"<blockquote>
  <p>Does deleting a class object delete all of its vectors objects?</p>
</blockquote>

<p>Yes. All sub objects are destroyed when the super object is destroyed.</p>

<blockquote>
  <p>Does every Player in players get their deconstructor called?</p>
</blockquote>

<p>Yes. All elements of container are destroyed when the container is destroyed.</p>

<hr>

<p>However, the dynamic objects pointed by <code>playerX</code> are never deleted, and when those local pointers go out of scope at the end of <code>Manager::AddSoManyPlayers</code>, there is no way to delete them anymore.</p>

<hr>

<blockquote>
  <p>Then why, if I loop through the vector and explicitly delete each <code>Player</code> does the compiler complain about memory corruption/double delete? Where am I supposed to delete each <code>Player</code>?</p>
</blockquote>

<p>As I said, the players within the vector are destroyed when the container is destroyed. You aren't supposed to delete them explicitly.</p>

<blockquote>
  <p>But it's quite unexpected from what I've read - ie there must always be a delete for every new.</p>
</blockquote>

<p>This is not the only rule of thumb to remember. Another rule is that the pointer to be deleted must be the one returned by <code>new</code>. You don't store those pointers in the vector, so you delete nothing from the vector. You store the pointers in the <code>playerX</code> variables, so those are the ones that must be deleted.</p>

<p>Even better: Don't create the dynamic objects in the first place. This is how you can create a new player into the vector without creating a dynamic one:</p>

<pre><code>players.emplace_back();
</code></pre>

<p>And this is how you can create all 4 in one call:</p>

<pre><code>players.resize(4 + players.size());
</code></pre>

<hr>

<blockquote>
  <p>I thought anything declared not as new will die out of scope, in this case <code>AddSoManyPlayers</code></p>
</blockquote>

<p>Indeed. That is why the <code>playerX</code> pointers are destroyed at the end of <code>AddSoManyPlayers</code> at which point the dynamic objects they point at can no longer be deleted.</p>

<blockquote>
  <p>How else will the Player objects survive once the <code>AddSoManyPlayers</code> method is complete (goes out of scope)</p>
</blockquote>

<p><code>vector&lt;Player&gt; players</code> is not declared within the scope of <code>AddSoManyPlayers</code>, so it will not be destroyed at the end of it, and so its elements are not destroyed yet either, and so will survive the return.</p>

<p>It seems that you haven't this out yet, which may be the source of confusion: The objects in the vector are not the same object that is given as the argument to <code>push_back</code>. The objects in the vector are copies of that argument.</p>
",8
46977806,46977516,1,"<blockquote>
  <p>Does every Player in players get their deconstructor called? </p>
</blockquote>

<p>Yes it does. You have different issue in your code, you dynamically allocate 4 objects by <code>operator new</code>, put copy of them into <code>std::vector</code> and then let them leak. Copies of those in <code>std::vector</code> would be destroyed either if you call <code>clear()</code> explicitly or by destructor of <code>std::vector</code>, but originals would not get destroyed. You need to destroy them manually or use smart pointers instead of raw ones:</p>

<pre><code>void Manager::AddSoManyPlayers(){
   Player* player1 = new Player();
   Player* player2 = new Player();
   Player* player3 = new Player();
   Player* player4 = new Player();
   players.push_back(*player1);
   players.push_back(*player2);
   players.push_back(*player3);
   players.push_back(*player4);
   delete player4;
   delete player3;
   delete player2;
   delete player1;
}
</code></pre>

<p>But it not clear why you need to allocate originals dynamically. </p>

<p>If your intention to dynamically allocate objects and let <code>Manager</code> to maintain their lifetime, then use smart pointers:</p>

<pre><code>class Manager {
   public:
     std::vector&lt;std::unique_ptr&lt;Player&gt;&gt; players;
     void AddSoManyPlayers() {
         players.emplace_back( new Player );
         ...
     }
}
</code></pre>

<p>then you would not put a copy into vector and your objects would be properly deleted by destructor (and you do not need to call <code>std::vector::clear()</code> explicitly</p>
",6
47563505,45628694,0,"<p>The main problem is that even if have empty dtor's, other background things, like the release of virtual method tables, will happen. My personal approach in such cases is to make a private dtor and use a member method (name it destroy if you want) for filtering the delete operator. For example</p>

<pre><code>class A
{
     bool _may_be_deleted;

public:

    A(bool may_be_deleted)
    : _may_be_deleted(may_be_deleted){;}

    void allow_delete()
    {
        _prevent_delete = false;
    }

    static bool destroy(A*);

private:

    virtual ~A(){;}
};

bool A::destroy(A *pA)
{
    if(pA-&gt;_may_be_deleted)
    {
        delete pA;
        return true;
    }
    return false;
}

int main(int argc, char* argv[])
{
    A* pA = new A(false);
    A::destroy(pA);     //returns false and A is not deleted
    pA-&gt;allow_delete();
    A::destroy(pA);     //Ok, now A is destroyed and returns true;
}
</code></pre>

<p>Hope that helps.</p>
",0
47480876,47480825,0,"<p>To properly call <code>winnable()</code> (or any function for that matter), you should not specify its return type.</p>

<p>Instead of attempting this:</p>

<pre><code>bool winnable(maze,  m,  ++n);
</code></pre>

<p>You should call it this way:</p>

<pre><code>bool result = winnable(maze,  m,  ++n); // store the result of winnable() for later use
</code></pre>
",0
46985302,46984812,3,"<p>It's not really a useful feature in terms of the <em>compiler</em> but it can be done with some quite easy pre-processing.</p>

<p>First, separate it into <em>two</em> files, a non-randomised-order input file and your original file which includes a randomised-order equivalent):</p>

<pre><code>randomOrder.h.in:
    int a;
    int b;
    int c;
    int d;
    int e;
&lt;your actual file containing the structure&gt;:
    struct DrlgLevel {
        #include ""randomOrder.h""
    };
</code></pre>

<p>Then, before the actual compilation step (i.e., before you compile <em>any</em> code that uses that header file), run a script which will create it from <code>randomOrder.h.in</code>:</p>

<pre><code>shuf randomOrder.h.in &gt;randomOrder.h
</code></pre>

<p>If you're on a platform without <code>shuf</code>, you can still <em>do</em> it, you just have to find the equivalent tool that can do the job, such as PowerShell in Windows ( or <code>sort -R</code> or <code>awk</code> if your *nix distro is missing <code>shuf</code> for some bizarre reason). Or you could try to <em>locate</em> a <code>shuf</code> executable for your platform and use it.</p>

<p>But the tool you <em>use</em> is not really important, it's the fact that you can reliably and repeated construct a randomly-ordered field list before compiling the code.</p>
",4
46984938,46984812,-1,"<p>its a horrible idea. IF you did this, how would the object files link, unless you compiled everything from a single source file?</p>

<p>IF you really really wanted this, you would have to change the headder file that contained the struct definition prior to each compile, this could be scripted if one really wanted</p>
",0
47651107,47651076,1,"<p>The behaviour of your code is <em>undefined</em>.</p>

<p><code>a</code> is <em>originally</em> declared as <code>const</code>.</p>

<p>You attempt to change its value via a pointer that has had the <code>const</code>-ness cast away. The language does not allow that.</p>

<p>The <code>volatile</code> is a red-herring in this case.</p>
",0
47494888,47494862,2,"<p>You are suffering from incorrect use of tabulators. Amount of spaces added by tabulator depends or text viewing application settings and initial tab offset so adding them does not necessary make resulting document have proper columns. Use fixed-width printing instead:</p>

<pre><code>&lt;&lt; ::std::setw(6) &lt;&lt; N &lt;&lt; ::std::setw(10) &lt;&lt; area &lt;&lt; ::std::setw(10) &lt;&lt; (true_value - area) &lt;&lt; ""\n"";
</code></pre>
",0
47497634,47497578,1,"<p><code>system()</code> takes a C-style string <code>char*</code> but you're trying to pass a <code>string</code>. To fix, create a temporary string something like this and convert it into a C-style string:</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;

using namespace std;

int main()
{
    string a;
    string b;
    cout &lt;&lt; ""Wifi Name : "";
    cin &gt;&gt; a;
    cout &lt;&lt; ""Password : "";
    cin &gt;&gt; b;

    string str = ""netsh wlan set hostednetwork mode=allow ssid="";
    str += a;
    str += "" key="";
    str += b;
    system( str.c_str() );
    system(""control.exe /name Microsoft.NetworkAndSharingCenter"");          
    cout&lt;&lt;""Press Enter for Menu..."";
} 
</code></pre>
",3
46102410,46102118,1,"<p>You're referring to the Hackerrank challenge right? The trick is to check if the stack is empty at the end of the process. <br>You could have balanced brackets and incomplete brackets in the end!</p>
",0
46102412,46102118,2,"<p>You push on the 3 open bracket types to the stack. However your case statement is checking for the 3 close types, so it always returns what was passed in so the check will fail.</p>

<p>Switch the logic so its like this :</p>

<pre><code>char convert_bracket(char s)
{
     switch(s)
     {
         case '(': s = ')';
                   break;
         case '[': s= ']';
                   break;
         case '{': s= '}';
                   break;
     }
     return s;
}
</code></pre>
",1
47497521,47497441,0,"<p>Based on your above code the error is that the [] operator for vectors are not overloaded to accept the type of MachineID.</p>
",2
43220270,43218888,2,"<p>The variable <code>next</code> is defined like so:</p>

<pre><code>FDHNode&lt;ItemType&gt;* next; //Pointer to a next node
</code></pre>

<p>And the variable <code>NEXTPTR</code> is defined like so:</p>

<pre><code>const FDHNode&lt;ItemType&gt;* NEXTPTR
</code></pre>

<p>The added <code>const</code> has its significance, in stating that it cannot be modified. When you're assigning <code>NEXTPTR</code> to <code>next</code>, it becomes a problem because <code>next</code> could be modified, but <code>NEXTPTR</code> is a constant.</p>

<p>There are two ways in which this could be resolved, depending on certain things:</p>

<ol>
<li>If the <code>next</code> pointer is something that could in fact be changed, you then have to modify the definition of <code>NEXTPTR</code> such that it's not a <code>const</code>. If you do this, your function declaration would like so: <code>void FDHNode&lt;ItemType&gt;::setNext(FDHNode&lt;ItemType&gt;* NEXTPTR)</code></li>
<li>Or the parameter really is a constant, in which case you should define your <code>next</code> variable as a <code>const</code> as well. Like so: <code>const FDHNode&lt;ItemType&gt;* next;</code></li>
</ol>

<p>Note: There's <code>const_cast&lt;&gt;</code> which could cast away the <code>const</code>-ness of a variable. But if you didn't know the answer to this question, it's unlikely that you need that cast here as it could do more harm than good in such a case.</p>
",3
43220295,43218888,1,"<p>It is said very clear in the error, <code>NEXTPTR</code> is <code>const FDHNode&lt;ItemType&gt;*</code> while <code>next</code> is <code>FDHNode&lt;ItemType&gt;*</code>, you can not assign <code>const FDHNode&lt;ItemType&gt;*</code> to <code>FDHNode&lt;ItemType&gt;*</code>.</p>

<p>You can use <code>const_cast</code> to make it <code>non-const</code>, for example:</p>

<pre><code>FDHNode&lt;ItemType&gt;* non_const_next = const_cast&lt;FDHNode&lt;ItemType&gt;*&gt;(NEXTPTR);
</code></pre>

<p>And the best way to do it is to change the parameter of <code>setNext()</code>, change it to <code>FDHNode&lt;ItemType&gt;* NEXTPTR</code></p>
",0
43946844,43946364,0,"<p>The code below runs, you need to delete the extra doubles. I removed the  <code>#include ""stdafx.h""</code> beacuse i am not using VS, but you can put it back</p>

<pre><code>#include &lt;iostream&gt;

  using namespace std;

  int main()
{

    const double inchesFactor = 12;

    const double metersFactor = 0.0254;

    const double massFactor = 2.2;

    double height;
    double weight;
    double BMI;
    double inches;
    double mass;
    double meters;


    cout &lt;&lt; ""Enter height "" &lt;&lt; flush;
    cin &gt;&gt; height;
    cout &lt;&lt; ""Enter weight "" &lt;&lt; flush;
    cin &gt;&gt; weight;

    inches = (height * inchesFactor);
    mass = weight / massFactor;
    meters = inches / 0.5;
    BMI = mass / meters;

    cout &lt;&lt; ""Your BMI is "" &lt;&lt; BMI &lt;&lt; endl;

    return 0;
    }
</code></pre>
",0
43947028,43946364,0,"<p>Let's take a look at your code. Here you declare a bunch of variables of type <code>double</code>:</p>

<pre><code>double height;
double weight;
double BMI;
double inches;
double mass;
double meters;
</code></pre>

<p>Then you ask the user to input height and weight:</p>

<pre><code>cout &lt;&lt; ""Enter height "" &lt;&lt; flush;
cin &gt;&gt; height;
cout &lt;&lt; ""Enter weight "" &lt;&lt; flush;
cin &gt;&gt; weight;
</code></pre>

<p>And here you make bunch of calculations:</p>

<pre><code>double inches = (height * inchesFactor);
double mass = weight / massFactor;
double meters = inches / 0.5;
double BMI = mass / meters;
</code></pre>

<p>When you write <code>double inches = (height * inchesFactor);</code> you're telling the compiler that ""I want a <strong><em>new</em></strong> variable of type <code>double</code> with the name <code>inches</code>, and I want to set it to the value of <code>(height * inchesFactor)</code>. But you can't make a new variable named <code>inches</code> because you have already declared a variable with that name earlier.</p>

<p>If you omit the type and just write <code>inches = (height * inchesFactor);</code> you are instead telling the compiler: ""I want to set the variable <code>inches</code>, <strong><em>which I've declared elsewhere</em></strong>, to the value of <code>(height * inchesFactor)</code>.</p>

<p>So to fix your code, replace the last block of code above to just:</p>

<pre><code>inches = (height * inchesFactor);
mass = weight / massFactor;
meters = inches / 0.5;
BMI = mass / meters;
</code></pre>

<p>since you've already declared <code>inches</code>, <code>mass</code>, <code>meters</code> and <code>BMI</code> earlier.</p>
",0
48045803,48045726,0,"<p>This seems to me to be an incredibly messy way of setting things up but anyway.
I would avoid putting...</p>

<pre><code>using namespace std;
</code></pre>

<p>in any header files or at all to keep the code clean.</p>

<p>center.h</p>

<pre><code>//declaration
void centerStr(const char*);
</code></pre>

<p>center.CPP</p>

<pre><code>#include ""center.h""
#include &lt;iomanip&gt;
#include &lt;iostream&gt;

//definition
void centerStr(const char* str) {
    int consoleWidth = 80;
    std::cout &lt;&lt; std::setw(consoleWidth / 2) &lt;&lt; "" "" &lt;&lt; str &lt;&lt; std::endl;
}
</code></pre>

<p>main.cpp</p>

<pre><code>#include ""center.h""

int main() {
    centerStr(""Unit Converter By DualKeys"");
    system(""PAUSE"");
    return 0;
}
</code></pre>

<p>You will need an overload for an std::string version of this function or a function template may suffice.</p>

<pre><code>template&lt;typename T&gt;
void centerStr(const T&amp; t) {
    int consoleWidth = 80;
    std::cout &lt;&lt; std::setw(consoleWidth / 2) &lt;&lt; "" "" &lt;&lt; t &lt;&lt; std::endl;
}
</code></pre>

<p>Finally just declare consoleWidth as a global const variable. Seems wasteful to do it on each call! :)</p>
",2
41642024,41641971,4,"<p>You are setting up the node to point to a local stack variable, which is getting destroyed as you go to the next iteration of the for loop.</p>

<p>Your usage of <code>new Student</code> fixed this by making a heap allocation</p>

<p>Lots of good discussion on Heap vs Stack memory at <a href=""https://stackoverflow.com/questions/5836309/stack-memory-vs-heap-memory"">Stack Memory vs Heap Memory</a></p>
",0
41642037,41641971,3,"<p>When you declare a student like this</p>

<p><code>Student next(0);</code></p>

<p>It allocates temporary memory on the stack that should only be considered usable within that block.</p>

<p>When you use <code>new</code> you allocate memory on the heap that can be used anywhere. Watch out for memory leaks and always define destructors.</p>

<pre><code>new Student(0);
</code></pre>
",0
41642049,41641971,1,"<p>By doing </p>

<pre><code>Student next(0);
</code></pre>

<p>You are allocating the object on the stack.</p>

<p>With</p>

<pre><code>new Student(0);
</code></pre>

<p>You are allocating the object in the heap.</p>

<p>Once you are leaving the scope, you will be accessing memory which is no longer yours and can be overwritten by other functions. </p>
",6
41642148,41641971,3,"<blockquote>
<pre><code>for(int i=0;i&lt;3;i++){
   pointer-&gt;val = i;
   Student next(0);
   pointer-&gt;next = &amp;next;
   pointer = pointer-&gt;next;
}
</code></pre>
</blockquote>

<p>You are creating object student on automatic storage (commonly implemented as a stack).  Then you are storing a pointer to this object in your linked list.  When 'Student' goes out of scope the object is deleted. Now your pointer is a dangling pointer.  De-referencing that pointer is now undefined behavior.</p>

<blockquote>
  <p><code>pointer-&gt;next = new Student(0);</code></p>
</blockquote>

<p>Is created on dynamic storage (commonly implemented as a heap).  This object will live until you tell it to die (delete it).</p>

<p>I suggest you read about the differences between the stack/heap in C++.  It is a very important topic if you want to learn C++.</p>

<p>Also, make sure you deleted anything newed objects!  If you don't you will end up with memory leaks in your programs.  </p>
",1
41652450,41652418,2,"<p>If by <code>static</code>, you mean a function that can run without an object instance, then you can bury them deep within a translation unit using an <em>anonymous namespace</em>:</p>

<pre><code>namespace /*No name here; i.e. it's anonymous*/
{
    foo Foo(/*parameters*/)
    {
        // ToDo - code here
    }
}
</code></pre>

<p><code>Foo</code> will not be visible to any other translation unit.</p>
",0
41672975,41672921,1,"<p>I'd prefer <code>static myObject* myObjectPtr;</code> since all <code>static</code> pointers will be initialised to <code>nullptr</code> anyway. The C++ standard guarantees that.</p>

<p>But your code is vulnerable to two threads calling <code>inline myObject&amp; myObjectRef()</code> for the first time which <em>could</em> lead to multiple <code>new</code> to be balanced with only one <code>delete</code>. You ought to use a mutex in that function to obviate that.</p>
",2
41673020,41672921,5,"<p>Your solution is portable, but it's not thread-safe.<br>
It's also needlessly complicated.</p>

<p>Don't use dynamic allocation:</p>

<pre><code>inline myObject&amp; myObjectRef()
{
    static myObject theObject;
    return theObject;
}
</code></pre>

<p>Leak-free (since the dawn of time) and thread-safe (since C++11).</p>
",3
47567215,47565025,0,"<pre><code>  // try this 
  // this should work as you want

   #include&lt;iostream&gt;
   using namespace std;

int main() {
    double majorexam,score,long1exam,long2exam,longexam,shortquiz,short1quiz,short2quiz,short3quiz,grade;

    cout&lt;&lt;""Input Major Exam Grade : "";cin&gt;&gt;majorexam;
    cout&lt;&lt;""Input Long 1 Exam Grade : "";cin&gt;&gt;long1exam;
    cout&lt;&lt;""Input Long 2 Exam Grade : "";cin&gt;&gt;long2exam;
    cout&lt;&lt;""Input Short 1 Quiz Grade : "";cin&gt;&gt;short1quiz;
    cout&lt;&lt;""Input Short 2 Quiz Grade : "";cin&gt;&gt;short2quiz;
    cout&lt;&lt;""Input Short 3 Quiz Grade : "";cin&gt;&gt;short3quiz;

    score = majorexam*.04;
    double aveLongExam=(long1exam+long2exam)/2;
    longexam = (aveLongExam)*.03;
    double aveShortExam=(short1quiz+short2quiz+short3quiz)/3;
    shortquiz = (aveShortExam)*.03;
    grade = (score+longexam+shortquiz)*100;
    cout&lt;&lt;""Ave of Quiz:: ""&lt;&lt;aveShortExam&lt;&lt;"" Ave of Long Exam :: ""
    &lt;&lt;aveLongExam&lt;&lt;endl;
    cout&lt;&lt;""Final Grade : ""&lt;&lt;grade;
    return 0;
}
</code></pre>
",0
46956732,46956239,1,"<p>When you do <code>infile &gt;&gt; x</code> and <code>x</code> is an <code>int</code>, the input only reads characters that could be part of an integer value. A comma cannot, so the input operation stops there.</p>

<p>Then the input continues with <code>&gt;&gt; a</code> which looks for a single <code>char</code>. A comma is a char, so it is read into <code>a</code>.</p>

<p>Then it continues to try to read another integer, and luckily the next part is again digits.</p>
",0
43220209,43219721,0,"<p>A letter by itself is a letter that is surrounded by whitespace, not other letters. A letter by itself is also easy to account for because it is always surrounded by whitespace. </p>

<pre><code>replace(textMessage.begin(), textMessage.end(), ' i ', ' I '); 
</code></pre>

<p>If you change the code in your program to this (it replaces i's that have whitespace with uppercase I's) it should work. </p>
",3
43223085,43219721,0,"<p>Instead of using the replace function you will have to traverse through the string and check for only those 'i' which are preceded and succeeded by a whitespace and replace them with 'I'. I guess the following code segment would do what you are trying to achieve :-</p>

<pre><code>for (int iTraverse = 0; iTraverse&lt; textMessage.length(); iTraverse++)
{
    if (textMessage[iTraverse] == 'i' &amp;&amp; textMessage[iTraverse-1] == ' ' &amp;&amp; textMessage[iTraverse+1]     == ' ')
    {
        textMessage[iTraverse] = 'I';
    }
}
</code></pre>
",4
46114474,46114458,6,"<p>In C++17, you can use a <a href=""http://en.cppreference.com/w/cpp/language/parameter_pack"" rel=""nofollow noreferrer""><em>variadic template</em></a> and a <a href=""http://en.cppreference.com/w/cpp/language/fold"" rel=""nofollow noreferrer""><em>fold expression</em></a> to create a function that takes an arbitrary amount of arguments and generates a <code>cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; ...</code> chain for you:</p>

<pre><code>template &lt;typename... Ts&gt;
std::istream&amp; scan(Ts&amp;... xs)
{
    return (std::cin &gt;&gt; ... &gt;&gt; xs);
}
</code></pre>

<p>Usage:</p>

<pre><code>int i;
double j;
scan(i);
scan(i, j);

if (scan(i, j))
   std::cout &lt;&lt; ""Read "" &lt;&lt; i &lt;&lt; "", "" &lt;&lt; j &lt;&lt; ""\n"";
else
   std::cout &lt;&lt; ""Invalid input\n"";
</code></pre>

<p><a href=""https://wandbox.org/permlink/WmisYgSTVaXmfGP0"" rel=""nofollow noreferrer""><strong>live example on wandbox</strong></a></p>
",4
46123121,46114458,1,"<p>If you just want to make a function which assigned a value to a paramater you pass based on your input you could do something like this</p>

<pre><code>void scan( std::string &amp; input )
{
  std::string newInput;

  cin &lt;&lt; newInput;

  input = newInput;

}


std::string myString;

scan( myString );
</code></pre>

<p>You will be asked to input a string and then your input will be assigned to myString.</p>
",0
41647305,41647271,5,"<p>There is no difference between <code>long</code> and <code>long int</code>, and between <code>long long</code> and <code>long long int</code>.  <code>long</code> is a size modifier for <code>int</code> and <code>double</code>.  If an actual type is not explicitly stated, <code>int</code> is assumed.</p>
",0
43197067,43197027,0,"<p><code>istream_iterator</code> is a single-pass iterator, not a ForwardIterator.  After you do <code>++iter</code>, an old copy of <code>iter</code> is invalid.</p>
",1
41924714,41924614,1,"<p>in insert_beg, the pointer to start is changed to the new start position which is the newly inserted node.</p>

<p>in my opinion, pointer operations are better to undrstand in a graphical model..</p>

<p><a href=""https://i.stack.imgur.com/GJOG4.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/GJOG4.png"" alt=""Pointer issue graphically explained""></a></p>
",0
41924726,41924614,0,"<blockquote>
  <p>Why is the argument for display in main() start and not newptr?</p>
</blockquote>

<p>Because <code>start</code> is the head pointer in your linked list and always points to the first node in the linked list. To display the linked list, you have to start from the first node and that first node is pointed to by <code>start</code> pointer.</p>

<blockquote>
  <p>how does np->next=save; and np=np->next work in their respective
  functions?</p>
</blockquote>

<p><code>np-&gt;next=save;</code> it means that <code>next</code> pointer of node <code>np</code> should point to the node which is pointed to by <code>save</code> pointer.</p>

<p><code>np=np-&gt;next;</code> it is being used in <code>display</code> function to iterate over your linked list. </p>
",0
42600311,42600262,2,"<p>You have unnecessary semicolon in lines 13 &amp; 14, should be:</p>

<pre><code>cout &lt;&lt;  iks   &lt;&lt; endl;
cout &lt;&lt; *iks   &lt;&lt; endl;
</code></pre>

<p>And, by the way, the thing you call <em>indicators</em> are really called <em>pointers</em> in English.</p>
",0
41904127,41904080,8,"<p>The % operator is not defined for real numbers - you want the fmod() function declared in <code>&lt;cmath&gt;</code>. See <a href=""http://en.cppreference.com/w/cpp/numeric/math/fmod"" rel=""noreferrer"">http://en.cppreference.com/w/cpp/numeric/math/fmod</a></p>
",0
41912005,41911852,1,"<p>Those 'weird symbols' are unicode characters. After declaring your board, the char values are just random symbols, what else should the <code>board</code> elements contain?</p>

<p>You have to initialize your board like this:<br>
Either on declaration:</p>

<pre><code>char board[3][3] = {
    {' ',' ',' '},
    {' ',' ',' '},
    {' ',' ',' '}
};
</code></pre>

<p>Or in the constructor/some initialization method:</p>

<pre><code>board = {
    {' ',' ',' '},
    {' ',' ',' '},
    {' ',' ',' '}
};
</code></pre>

<p>Now your board should consist of spaces only.</p>
",0
41673961,41673695,2,"<p>If you are sure that all the <code>Frame*</code> pointers in <code>MechanicalFrame::getChildren()</code> are pointing to <code>MechanicalFrame</code> instances, I don't see any problem with <code>static_cast</code>. Make sure you use <code>dynamic_cast</code> + <code>assert</code> in <strong>debug builds</strong> to catch mistakes.</p>

<pre><code>void MechanicalFrame::compute()
{
    for(auto frame_ptr : getChildren())
    {
        downcast&lt;MechanicalFrame*&gt;(frame_ptr)-&gt;compute();
    }
}
</code></pre>

<p>Where <code>downcast</code> is something like:</p>

<pre><code>template &lt;typename TOut, typename T&gt;
auto downcast(T* ptr)
{
    static_assert(std::is_base_of&lt;T, TOut&gt;{});

    assert(ptr != nullptr);
    assert(dynamic_cast&lt;TOut&gt;(ptr) == ptr);

    return static_cast&lt;TOut&gt;(ptr);
}
</code></pre>

<p><em>(For a more thorough implementation of <code>downcast</code> see my <a href=""https://www.youtube.com/watch?v=62c_Xm6Zh1k"" rel=""nofollow noreferrer"">Meeting C++ 2015 lightning talk <strong>""Meaningful casts""</strong></a> or my <a href=""https://github.com/SuperV1234/vrm_core/blob/master/include/vrm/core/casts/polymorphic.hpp"" rel=""nofollow noreferrer"">current implementation in <code>vrm_core</code></a>.)</em></p>

<hr>

<p>Notice that there's a performance advantage here, as you avoid <code>virtual</code> dispatch. Play around with <a href=""https://godbolt.org/g/GMLUbj"" rel=""nofollow noreferrer"">this snippet on gcc.godbolt.org</a> to see differences in the generated assembly.</p>
",0
41673970,41673695,3,"<p>Use polymorphic behaviour, use your Solution 2)</p>

<p>You can follow below pattern (Interface -> Base class -> Derived class)</p>

<pre><code>class IFrame
{
public:
    virtual void compute()=0;
}

class Frame:public IFrame
{
public:
    virtual void compute() {/*nothing to do*/}
}

class MechanicalFrame:public Frame
{
public:
    virtual void compute() {/*your implementation with mass*/}
}
</code></pre>
",1
41674116,41673695,0,"<p>Since you're asking for new ideas, I will not explain in detail anything you written about in solutions 1-3.</p>

<p>You could add extra functionality to the <code>MechanicalFrame</code> class, splitting its <code>children</code> of <code>MechanicalFrame</code> class and all other classes, like this:</p>

<pre><code>class Frame {
public:
    std::vector&lt;Frame*&gt; getChildren(); // returns children
    void addChild(Frame* child);       // adds child to children
private:
    std::vector&lt;Frame*&gt; children;
}

class MechanicalFrame : public Frame {
public:
    void compute();
    std::vector&lt;MechanicalFrame*&gt; getMechanicalChildren(); // returns mechanical_children
    void addChild(MechanicalFrame* child);                 // adds child to mechanical_children
private:
    std::vector&lt;MechanicalFrame*&gt; mechanical_children;
}
</code></pre>

<p>One possible implementation of <code>compute</code> is the following:</p>

<pre><code>void MechanicalFrame::compute() {
    ...
    for (auto* child : getMechanicalChildren()) {
        child-&gt;compute();
    }
}
</code></pre>

<p><strong>UP:</strong> As far as I understand, one of the problems with casts is that the code starts behaving very differently depending on the actual class of the object, and we cannot substitute the parent class object with child class (see <a href=""https://en.wikipedia.org/wiki/Liskov_substitution_principle"" rel=""nofollow noreferrer"">Liskov principle</a>). The approach described in this answer actually changes the principle of using the ""mechanicity"" of your <code>Frame</code>s, allowing adding <code>MechanicalFrame</code> children in such a way that they're ignored in <code>compute</code> method.</p>
",0
41674505,41673695,1,"<p>Another option is to use the Visitor pattern:</p>

<pre><code>class Frame;
class MechanicalFrame;

class FrameVisitor
{
public:
    virtual ~FrameVisitor() = default;

    virtual void visit(Frame&amp;) = 0;

    virtual void visit(MechanicalFrame&amp;) = 0;
};

class Frame
{
public:
    virtual void accept(FrameVisitor&amp; visitor)
    {
        visitor.visit(*this);
    }

    void acceptRecursive(FrameVisitor&amp; visitor)
    {
        accept(visitor);

        for (Frame* child : getChildren())
        {
            child-&gt;acceptRecursive(visitor);
        }
    }

    ...
};

class MechanicalFrame : public Frame
{
public:
    virtual void accept(FrameVisitor&amp; visitor) override
    {
        visitor.visit(*this);
    }

    ...
};
</code></pre>

<p>Then the client code will be:</p>

<pre><code>class ConcreteVisitor : public FrameVisitor
{
public:
    virtual void visit(Frame&amp; frame) override
    {
        // Deal with Frame (not a subclass) object.
    }

    virtual void visit(MechanicalFrame&amp; frame) override
    {
        // Deal with MechanicalFrame object.
    }
};

Frame root = ...;
ConcreteVisitor visitor;
root.acceptRecursive(visitor);
</code></pre>

<p>In general, the Visitor pattern allows you to traverse a hierarchy of heterogeneous objects and perform operations on them without type casting. It's most useful when the number of operations is expected to grow while your type hierarchy is more or less stable.</p>
",0
41649101,41649066,2,"<pre><code> while((key&lt;a[i])&amp;&amp;(i&gt;=0));
</code></pre>

<p>You have an infinite <code>while</code> loop here. The semi colon at the end means that the while loop body is empty. Hence <code>i</code> is never decremented and the loop runs forever. </p>

<p>Also, you need to check if the index is valid (<code>i &gt;= 0</code>) before trying to access it's value. </p>

<p>So change the line as below. </p>

<pre><code> while((i &gt;= 0) &amp;&amp; (key &lt; a[i]))
</code></pre>
",0
42505116,42504887,5,"<p>Representing 2^1000 in binary would take a 1000 bits. Doubles are only 64bits long (long doubles are 80 or 128 bits depending on compiler/architecture). So doubles represent 2^1000 approximately. The input to <code>calculate</code> isn't 2^1000, but rather as close an approximation to it as 80bits allow. That approximation does not contain the lowest digits that <code>calculate</code> would like to sum over.</p>
",0
42505338,42504887,2,"<p>You can't use any primitive datatype to calculate 2^1000 and later sum of its digits, as its a big number (however, in languages like python and ruby you can do it).</p>

<p>For solving this problem in C/C++, you have to use array (or any other linear data structure like linked list, etc) and apply logic similar to usual pen-paper method of multiplying numbers.</p>

<p>First try to find a bound on number of digits in 2^1000 and then initialize an integer array of size greater than it with all zeroes. Keep the last element to be 1. Now multiply the array (thinking it as a large number such that each digit is in a different cell of the array) with 2, thousand times, taking modulo and carry overs.</p>

<p>Here is the code for above logic:</p>

<pre><code>int ar[303];
int sum =0;
ar[0]=1;
for(int j=1;j&lt;303;j++)
    ar[j]=0;
for(int i=1;i&lt;1001;i++)
{
    ar[0]=2*ar[0];
    for(int k=1;k&lt;303;k++)
        ar[k]=2*ar[k] + ar[k-1]/10;
    for(int j=0;j&lt;303;j++)
        ar[j]=ar[j]%10;
}
for(int i=0;i&lt;303;i++)
sum = sum + ar[i];
cout&lt;&lt;sum;
</code></pre>

<p>Hope it helps.</p>
",0
42505858,42504887,0,"<p>The reason why you are getting your sum with decimal points is because you are dividing a <strong>double</strong> by 10. This will not result in a clean integer unless the doubles last digit before the decimal point is a zero.</p>

<p>example:
376 / 10 = 37.6</p>

<p>370 / 10 = 37</p>

<p>To solve this change this in your code on line 12:
n = (n-temp)/10;</p>

<p>This will cut the float numbers from your sum at least.</p>
",0
42506314,42504887,0,"<p>finally i have solved my problem.</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;math.h&gt;
#include&lt;string&gt;
using namespace std;

long double calculate(string n)
{
    long double i,j,temp = 0,sum = 0;
    for (i = 0;i &lt; n.length();i++)
    {
        if(n[i] == '.')
        {
            break;
        }
        sum = sum + (n[i] - 48);
    }
    return sum;
}
int main()
{
    long double i,j,n = 1000,temp = 1,value = 0;
    string str;
    temp = pow(2,n);
    cout &lt;&lt; ""Power is : "" &lt;&lt; temp &lt;&lt; endl;
    str = to_string(temp);
    cout &lt;&lt; str &lt;&lt; endl;
    value = calculate(str);
    cout.precision(100);
    cout &lt;&lt; ""Sum is : "" &lt;&lt; value &lt;&lt; endl;
    return 0;
}
</code></pre>
",0
42476171,42476062,1,"<p>You need to start thinking from an abstraction point of view and not get lost in the details. You need the abstractions <code>Point</code> and <code>Transform</code> and create functions that work with those abstractions.</p>

<p>If you are working with 2D points, use:</p>

<pre><code>struct Point
{
   double x;
   double y;
};
</code></pre>

<p>If you need to work with 3D points, use:</p>

<pre><code>struct Point
{
   double x;
   double y;
   double z;
};
</code></pre>

<p>If you are interested only in rotational transforms, you can use the following for 2D transforms:</p>

<pre><code>struct Transform
{
    double matrix[2][2];
};
</code></pre>

<p>For 3D transforms, you can use:</p>

<pre><code>struct Transform
{
    double matrix[3][3];
};
</code></pre>

<p>and then add functions to construct points, transforms and performs operations on them. E.g.</p>

<pre><code>Point constructPoint(double x, double y);

Transfrom constructIdentityTransform();
Transfrom constructRotateAroundXTransform(double xrot);
Transfrom constructRotateAroundYTransform(double yrot);
Transfrom constructRotateAroundZTransform(double yrot);

Transform operator*(Transform const&amp; lhs, Transform const&amp; rhs);

Point operator*(Transform const&amp; trans, Point const&amp; p);
</code></pre>

<p>I hope this gives you enough information to complete the rest.</p>
",0
40782221,40778456,0,"<p>I think you should pass pointer to the Node in the tree to get the height of that node like,</p>

<pre><code>NODETYPE *node = &lt;get a node from wherever possible&gt;
int height = getHeight(node);
</code></pre>
",0
41654925,41654885,1,"<p>The error message tells you everything you need to know: <code>stoi</code> threw <code>std::invalid_argument</code> exception with message ""no conversion"" and that exception was not caught, so program terminates.</p>

<p><code>std::stoi</code> can throw <code>std::invalid_argument</code> if you pass something that can't be converted to integer. Add <code>try-catch</code> to catch <code>std::exception</code> to avoid crash. Output your <code>item</code> to <code>cout</code> to examine the value you are trying to convert to integer.</p>

<p>You can also use debugger to execute your program step by step and examine different variables after each step. Trying to understand what's wrong just by looking at the code is useful for your brain but not very effective, unfortunately.</p>
",0
42540086,42537842,1,"<p>The problem seems to be that you sprinkled a few too many <code>typename</code>s at the usage of <code>IntegerList</code> and <code>TypeList</code>. The following compiles:</p>

<pre><code>template &lt;class H, class T&gt;
struct IntegerList&lt;TypeList&lt; H,  T&gt; &gt; :  public std::list&lt;Integer*&gt;
{ 
  typedef TypeList&lt; H,  T&gt; List_t;
  typedef H Head_t;
  typedef T Tail_t;
  . . .
}
</code></pre>

<p>Full example <a href=""http://coliru.stacked-crooked.com/a/5086e3015dc12ea0"" rel=""nofollow noreferrer"">http://coliru.stacked-crooked.com/a/5086e3015dc12ea0</a></p>
",2
41930963,41930654,2,"<p>You didn't include library that has <code>getchar</code>. Add <code>#include &lt;cstdio&gt;</code> at the beginning. </p>

<p>Second thing is that after grabbing the first number you don't increase <code>len</code>, which causes the second input overwrite the first one. The last input is doubled at the end.</p>

<p>Third. When allocating memory, the compiler needs to know how much it has to allocate. You need to specify that in <code>x = new int[]</code>.</p>
",0
41930925,41930654,3,"<pre><code>x = new int[];
</code></pre>

<p>is invalid as standard C++ and shouldn't compile.</p>
",0
36341110,36146695,0,"<p>The problem was that bird.wav was not in the Visual Studio project file. I moved it there and the sound played correctly.</p>
",0
43729638,43729563,0,"<p>Aside from your current issue in your functions you can simplify them by removing their local variables and just simply return the evaluated expression.</p>

<p>For Example: You have this -></p>

<pre><code>double cost( double cp, double inrate ) {
    double totalc = cp + inrate;
    return totalc;
}
</code></pre>

<p>It is safe and efficient to do this instead:</p>

<pre><code>double cost( double cp, double inrate ) {
    return cp + inrate;
}
</code></pre>

<p>You can do that for any simple function that doesn't go through any loops.</p>

<p>As for your actual issue check out this quick program;</p>

<p><strong>Sample.cpp</strong></p>

<pre><code>#include &lt;iostream&gt;

int five() {
    return 5;
}

int ten() {
    return 10;
}

int add( int a, int b ) {
    return a + b;
}

int main() {

    std::cout &lt;&lt; add( five(), ten() ) &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Set a break point within the first line of your main function and step through the code line by line while examining your stack calls as well as your local and auto variables to see what is happening on each line of your functions to see the values that are being assigned to each variable. </p>
",5
43729669,43729563,0,"<p>Yes you can like this <code>inflatio n = inflan(dif(lyp,cyp),lyp);</code></p>

<p>However, since you use the function returned value more than once, it make more sense to keep it as it is.</p>
",0
43203347,43196656,1,"<p>I see two major problems.</p>

<p>You have a for loop inside a for loop both initializing and using <code>int i</code></p>

<p>Change the variable name of the inner loop.</p>

<pre><code>for (int i = 0; i &lt; q.size(); i++) //if the string gets big, it seems to become an infinite loop in here
.
.
    if (check == 0)
    {
        for (int i = 0; i &lt; q.size(); i++) //Change this to int j for example
        {
        .
        .
</code></pre>

<p>And the Sorter struct. I would rewrite it as this.</p>

<pre><code>static struct {
    bool operator()(NodeInterface* a, NodeInterface* b) {
        if (a-&gt;getFrequency() == b-&gt;getFrequency()) {//if the frequencies are even,
            if (b-&gt;getCharacter() == '\0') return false;
            if (a-&gt;getCharacter() == '\0') return true;
            return (int)a-&gt;getCharacter() &lt; (int)b-&gt;getCharacter();
        }
        return a-&gt;getFrequency() &lt; b-&gt;getFrequency();
    }
} sorter;
</code></pre>

<p>A few suggestions for your for loop:</p>

<pre><code>for (int i = 0; i &lt; q.size(); i++) //if the string gets big, it seems to become an infinite loop in here
{
    y = q[i];
    //You can avoid this entire loop by using a structure like map
    for (int x = i - 1; x &gt; 0; x--)  //make sure not counting the same char
    {
        if (y == q[x])
        {
        check++;
        //break; //if you use a loop, break it once you find the character.
        }
    }
    if (check == 0)
    {
        for (int j = 0; j &lt; q.size(); j++)//Renamed variable + you can start this loop from j = i as you know there is no occurrence of y before that.
        {
            if (q[i] == y)
            {
                count++;
            }
        }
        node*x = new node;
        x-&gt;char1 = y;   //my node have char 
        x-&gt;freq = count; //my node has frequency
        list1.push_back(x);
    }
    count = 0;
    check = 0;
}
</code></pre>
",0
36485243,36484888,0,"<pre><code>Pair *find(const char *key){
        for(int i = 0; i &lt; sizeOfPair; ++i){
        if(pair[i].getKey() == key){
            return pair + i; // Address of pair[i]
        }else{
            return NULL;
        }
    }
}
</code></pre>
",1
41927391,41927376,1,"<p>Your copy constructor is incorrect. You cannot just copy the address of the internal storage, otherwise you'll end up freeing it twice.</p>
",0
41927573,41927376,0,"<p>The problem is the assignment in this code snippet.</p>

<pre><code>Array2 b; b = a;
          ^^^^^
</code></pre>

<p>You did not define the copy assignment operator. So the compiler define it implicitly in the similar way as you defined incorrectly yourself the copy constructor.</p>

<pre><code>    Array2(Array2 &amp; b)
    {
        a = b.a;
    }
</code></pre>

<p>You have to make a deep copy of objects during construction using the copy constructor or during assignment using the copy assignment operator.</p>

<p>Otherwise several pointers point to the same memory that will be deleted at least twice.</p>
",0
43191649,43191549,0,"<p>In the first example, you have a typo:</p>

<pre><code>for (Iterator == tempList.begin(); Iterator != tempList.end(); Iterator++)
//            ^^
</code></pre>

<p><code>Iterator</code> was never initialised to anything! Comparing it, then dereferencing it (and, if you got that far, incrementing and comparing it again) all has <em>undefined behaviour</em>.</p>

<p>In the second example you correctly wrote <code>=</code>.</p>

<p>Pay closer attention to your code, and turn on your compiler's warnings.</p>
",2
47973101,47973090,12,"<p><code>.01 * 10^4</code> is 100 however due to floating point precision you most likely end up with <code>99.999324234</code> or something similar. This is due to the conversion from binary numbers to decimals.</p>

<p>Hope this explanation helps.</p>
",2
45774229,45657406,0,"<p>This is my code hope it helps:</p>

<pre><code>int n;
cin&gt;&gt;n;
while (!(n==42))  {
    cout&lt;&lt;n&lt;&lt;""\n"";
    cin&gt;&gt;n;

}
</code></pre>
",0
46130476,46130117,3,"<p>You can use std::map and std::function to achieve this, although it still required a 'hard coded' string at point of insertion.</p>

<pre><code>void status() 
{
    std::cout &lt;&lt; ""status"" &lt;&lt; std::endl;
}

void account()
{
    std::cout &lt;&lt; ""account"" &lt;&lt; std::endl;
}

int main()
{
    std::map&lt; std::string, std::function&lt;void()&gt; &gt; functions;

    functions.emplace( ""status"" , status  );
    functions.emplace( ""account"", account );

    std::string method_name;
    std::cin &gt;&gt; method_name;

    auto iter( functions.find( method_name ) );
    if( iter != functions.end() )
    {
        iter-&gt;second();   
    }
    else
    {
        std::cout &lt;&lt; ""Method "" &lt;&lt; method_name &lt;&lt; "" not found!!"" &lt;&lt; std::endl;
    } 
}
</code></pre>

<p>If you're willing to use macros then you can avoid the extra string like this:</p>

<pre><code>#define ADD_FUNCTION( map, func ) map.emplace( #func, func );

std::map&lt; std::string, std::function&lt; void() &gt; &gt; functions;
ADD_FUNCTION( functions, status  );
ADD_FUNCTION( functions, account );
</code></pre>
",2
41935466,41935434,2,"<p>You need to use <code>==</code> instead of <code>=</code>.</p>

<p>In <code>c++</code>, assignment operator (<code>=</code>) returns the value equal to the assigned value (this allows writing something like <code>a = b = c</code>). That's why <code>slope = 1</code> is equal to <code>1</code>, which, when converted to <code>bool</code>, equals <code>true</code>, and so you end up entering the <code>if</code> section.</p>
",1
41935499,41935434,2,"<p>Your assigned value in condition, not check it. First you use <code>==</code> instead of <code>=</code></p>
",0
41935516,41935434,2,"<p>There is a difference between = and ==. In your if statement you want to check the value, hence you should use ==.</p>

<pre><code>if(slope == 1)
{
/*...*/
}
</code></pre>
",1
41936728,41935434,0,"<p>The following lines in your code are invalid:</p>

<pre><code>    if (slope = 0)
    if (slope = +1)
    if (slope = -1)
</code></pre>

<p>This is because you use the assignment operator <code>=</code> instead of the equality operator <code>==</code>. As a result of this, your if-statements are not making the desired comparison between the <code>slope</code> and the values +1, 0, or -1. </p>

<p>If we have to compare 2 values, 2 variables, or a variable to a value in an if-statement, then we use the equality operator <code>==</code> to compare them over the <code>=</code>. There are a few exceptions to this; see the following page:
<a href=""https://stackoverflow.com/questions/17681535/variable-assignment-in-if-condition""><strong>Variable assignment in ¡°if¡± condition</strong></a>.</p>

<p>Just a side note, I would like to point out that you should use some more whitespace in your code; it helps make it more readable. Also, try posting the code itself in your question instead of posting a snapshot of it. </p>

<p>Good luck!</p>
",0
36644989,36644904,2,"<p>The limit is defined by your implementation. C++14 ¡ìB does suggest some recommended minimum quantities for things like maximum line length, maximum program size, maximum number of nested parenthesised expressions ... but there are no exact, standardised constraints in this sense.</p>

<p>It doesn't matter, anyway, because if you go above three or so your code is terrible.</p>
",8
47997822,47997290,0,"<p>Your do while loop makes it impossible for the program to proceed with the value of ""selection"" different than 1,2,3 or 4. In that case your switch statement can only reach your 4 defined cases and cannot reach the default case. You could change your code by excluding the do while loop and just make the input possible only once. </p>
",0
48007835,48007573,1,"<p>You can evaluate your input right inside condition of <code>while</code> loop.</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    char ch;
    int count = 0;
    std::cout &lt;&lt; ""Enter characters; enter # to quit:\n"";

    while (std::cin &gt;&gt; ch &amp;&amp; ch != '#')
    {
        std::cout &lt;&lt; ""entered: "" &lt;&lt; ch &lt;&lt; std::endl;
        ++count;
    }

    std::cout &lt;&lt; std::endl &lt;&lt; count &lt;&lt; "" characters read"" &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>When <code>while</code> condition is entered it will wait for you to enter anything first. Once input is received it will check if the input is not #. If input is not #  the loop is entered, input printed out, counter increased, and back to waiting for another input. If # is entered, condition becomes false, and loop is aborted.</p>
",0
48007909,48007573,-1,"<p>The first cin>>ch is obviously used to take input from user but you
have again accepting data in while loop using the same variable name ""ch"" ,
So when you run the program it will not give u error but accept only first value that you have accept before the while loop not in while loop.
  In while loop you can assign new value to variable ""ch"" but not accept the new value again.</p>
",0
48007686,48007573,0,"<p>If you remove the first <code>cin</code> then count will never be incremented. The user can enter <code>#</code> character before entering the loop and the program can never enter it therefore.</p>
",1
43232039,43231768,1,"<p>One option available to you is to create a while loop encapsulating the body of your <code>menu()</code> function, and using <code>break;</code> if the user enters 6.</p>

<pre><code>void menu(){
    int x = 0;
    while(1){
        cin &gt;&gt; x;
        //your code here
        if(x==6)
            break;
    }
}
</code></pre>

<p>This example will cause your menu to repeat until the user enters 6.</p>

<p>The purpose of <code>break;</code> is to 'break' from the while loop. In this case, breaking will end your <code>menu()</code>and return to <code>main()</code>.</p>

<p>Further, it is good practice to add <code>return 0;</code> to the end of your main function.</p>
",1
43232320,43231768,0,"<p>If the user selects a correct option, call the menu function again. Otherwise, return control to main. I think this may work.</p>

<pre><code> int menu(){int x;
    cout&lt;&lt;""Enter an option: \n"";
    cout&lt;&lt;""1- Add new value\n2- Search Value\n3- Modify value\n4- Print Value\n5- Print sum of all values\n6- Quit/terminate\n"";
    cin&gt;&gt;x;
    if(x!=1||x!=2||x!=3||x!=4||x!=5) return 0;
    if(x==1){
        AddNewValue();
    }
    else if (x==2){
        SearchValue();
    }
    else if(x==3){
        ModifyValue();
    }
    else if(x==4){
        PrintValue();
    }
    else if(x==5){
        PrintSum();
    }
    menu();
}
</code></pre>

<p>You could also wrap your code in a do-while loop.</p>

<pre><code>void menu(){
    do{
        int x;
        cout&lt;&lt;""Enter an option: \n"";
        cout&lt;&lt;""1- Add new value\n2- Search Value\n3- Modify value\n4- Print Value\n5- Print sum of all values\n6- Quit/terminate\n"";
        cin&gt;&gt;x;     
        if(x==1){
            AddNewValue();
        }
        else if (x==2){
            SearchValue();
        }
        else if(x==3){
            ModifyValue();
        }
        else if(x==4){
            PrintValue();
        }
        else if(x==5){
            PrintSum();
        }

    }while(x==1||x==2||x==3||x==4||x==5);
}
</code></pre>
",2
43232943,43231768,0,"<p>Keep it simple. The function in charge of displaying the menu should only display the menu and return the user's choice.</p>

<pre><code>enum choice
{
    ADD_NEW_VALUE,
    SEARCH_VALUE,
    // ...
    QUIT
};

choice menu()
{
    choice result = QUIT;
    // display menu
    // input choice
    // (the more I think about it, the more I'd split it in two separate functions)
    return result;
}

int main()
{
    while (true) {
        switch (menu())
        {
        case ADD_NEW_VALUE: AddNewValue(); break;
        // ...
        case QUIT: return 0;
        }
    }
}
</code></pre>

<p>This helps <code>menu()</code>'s testing and make it easier to add new options and new features.</p>
",0
43959167,43959135,5,"<p><code>cin</code> doesn't use exceptions by default, you can turn them on with </p>

<pre><code>cin.exceptions(std::ifstream::failbit);
</code></pre>

<p>Without exceptions, you can also detect bad input by checking the stream state explicitly, like </p>

<pre><code>if (cin &gt;&gt; choice) { /* ok */ }
else { /* bad input */ }
</code></pre>

<p>Either way, you have to reset the failure state (<code>cin.clear()</code>) and remove the bad data from the stream (<code>std::numeric_limits&lt;std::streamsize&gt;::max()</code>) before trying again.</p>
",0
43959244,43959135,3,"<p>Besides what <a href=""https://stackoverflow.com/a/43959167/1413395"">@Ben said</a>, it's a fairly bad idea to <code>catch</code> any exeption unspecified with </p>

<pre><code>catch (...) {
    cout &lt;&lt; ""Invalid entry"" &lt;&lt; endl;
}
</code></pre>

<p>That should be the absolutely last resort, and you can't reliably tell that it was an exception because of an <code>""Invalid entry""</code> or any different reason.</p>

<p>At least you should catch a <code>std::exception</code> before instead</p>

<pre><code>catch (const std::exception&amp; e) {
   cout &lt;&lt; ""Exception caught: '"" &lt;&lt; e.what() &lt;&lt; ""'!"" &lt;&lt; endl;
}
catch(...)  {
   cout &lt;&lt; ""Exception caught: Unspecified reason!"" &lt;&lt; endl;
}
</code></pre>

<p>and use the <code>what()</code> function to provide more specific information.</p>
",1
43957695,43957649,0,"<blockquote>
  <p>In other words, does it or not do a <code>malloc()</code> syscall everytime it is called?</p>
</blockquote>

<p>It's actually implementation dependend. But usually implementations of <code>new</code> will make use of <code>malloc()</code> syscalls/c-library bindings.</p>

<blockquote>
  <p>(maybe by allocation a large chunk in advance)</p>
</blockquote>

<p>Yes, you have to consider that as a drawback. Frequently calling something like</p>

<pre><code>char* newChar = new char();
</code></pre>

<p>may clutter your dynamic storage space unnecessarily with larger chunks allocated, than a single <code>char</code> would need.</p>

<p>If you want to override that behavior for some more efficient memory management, you can always use <a href=""http://en.cppreference.com/w/cpp/language/new"" rel=""nofollow noreferrer""><em>placement <code>new</code></em></a>.</p>
",0
43957822,43957649,0,"<p>As others have said, this is implementation defined. However, I would think that a high-performance C++ implementation would probably not use malloc(), but would use OS-specific memory allocation APIs or system calls (which malloc() must itself use). After all, why add an extra function call to every memory allocation? But I have no hard evidence for this.</p>
",0
43957862,43957649,2,"<p>Before C++14 the standard prohibited the implementation from combining allocations.  Therefor each <code>new</code> expression did correspond one-to-one with a call to some system allocation function (possibly <code>malloc</code>).</p>

<p>C++14 <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3664.html"" rel=""nofollow noreferrer"">relaxed this restriction</a> in some cases.  It's now possible for the implementation to combine allocations if the lifetime of one is strictly within the lifetime of the other.  This is a fairly narrow restriction though, so I expect allocations don't actually get combined all that often.</p>
",0
46089654,46089298,5,"<p>Use a <a href=""http://en.cppreference.com/w/cpp/io/basic_stringstream"" rel=""nofollow noreferrer"">std::stringstream</a> and <a href=""http://en.cppreference.com/w/cpp/io/manip/setprecision"" rel=""nofollow noreferrer"">std::setprecision()</a> function in combination with the <a href=""http://en.cppreference.com/w/cpp/io/manip/fixed"" rel=""nofollow noreferrer"">std::fixed</a> stream manipulator:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

int main(){
    float myfloat = 15.56f;
    std::stringstream ss;
    ss &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; myfloat;
    std::string s = ss.str();
    std::cout &lt;&lt; s;
}
</code></pre>

<p>The <code>const char*</code> variable can be obtained via:</p>

<pre><code>const char* c = s.c_str();
</code></pre>

<p>Update:<br>
Prefer <code>std::ostringstream</code> since the stream is used only for the output.</p>
",2
42520265,42520051,0,"<p>You're just calling reverseString recursively on same string this will only lead to the same process repeating ad infinitum and lead to stackoverflow</p>
",0
42520286,42520051,0,"<p>This line:</p>

<pre><code>strIndex = strIndex + 1;
</code></pre>

<p>can never have an effect, because local variables are not ""reused"" for the next invocation of the function. Each function call creates a new set of local variables.</p>

<p>Since you can not change the function signature, you'll have to change the string. Maybe something like:</p>

<pre><code>void reverseString(string &amp;s) {
    if(s.size() &lt;= 1)
        return;
    char c = s[0];
    s = s.substr(1, s.size() - 1);
    reverseString(s);
    s += c;
}
</code></pre>
",1
44711469,44711107,1,"<p>A <code>break</code> statement only breaks the closest switch/loop that it is called in.</p>

<p>In your example, the <code>break</code> statements of the inner <code>switch</code> would only break out of the inner <code>switch</code>, execution would return to <code>case 0</code> of the other <code>switch</code>.  And then, since that <code>case 0</code> does not have a <code>break</code> of its own, execution would fall through to <code>case 1</code>, which also does not have a <code>break</code>, so execution would fall through to <code>case 4</code>, which does have a <code>break</code> to end the outer <code>switch</code>.</p>

<p>This is certainly true in C and C++, anyway.  Not necessarily in other languages.  For example, Delphi does not fall-through between case blocks.  <code>Break</code> can be used to end a <code>case</code> block early, but it is optional, the block is finished when the end of its scope is reached.</p>
",0
44711114,44711107,1,"<p>The break will only break out of the innermost switch.</p>

<p>The example you provided would be easy to test this behavior with the addition of some <code>print</code> statements or line breaks.</p>

<p>Please see <a href=""http://en.cppreference.com/w/cpp/language/break"" rel=""nofollow noreferrer"">this documentation</a> on the behavior of C++ breaks.</p>
",0
42571792,42571529,2,"<p>You get a too small result because the line endings in your text file are encoded in a different way than the convention on your system.</p>

<p>Save or recreate the file with correct line endings for your system.</p>

<hr>

<p>In the other direction, towards a too high result, the presented code</p>

<pre><code>while(in)
{
    getline(in,str);
    j++;
}
</code></pre>

<p>&hellip; would produce a count of 1 for an empty file.</p>

<p>Instead do</p>

<pre><code>while( getline(in,str) )
{
    j++;
}
</code></pre>

<p>Note: this remark only covers correctness, not efficiency.</p>
",3
42571792,42571529,2,"<p>You get a too small result because the line endings in your text file are encoded in a different way than the convention on your system.</p>

<p>Save or recreate the file with correct line endings for your system.</p>

<hr>

<p>In the other direction, towards a too high result, the presented code</p>

<pre><code>while(in)
{
    getline(in,str);
    j++;
}
</code></pre>

<p>&hellip; would produce a count of 1 for an empty file.</p>

<p>Instead do</p>

<pre><code>while( getline(in,str) )
{
    j++;
}
</code></pre>

<p>Note: this remark only covers correctness, not efficiency.</p>
",3
42571826,42571529,2,"<p>First, your text file has not new character so in the text there is only one line </p>

<p>Change it and try in your code with </p>

<pre><code>while(getline(in,str))
{
    j++;
}
</code></pre>

<p>in this way you avoid to count extra line </p>
",0
44650759,44650608,9,"<p>While you can cast function pointers to other function pointers and back, calling a function through a pointer that doesn't match its signature is undefined behavior. You cannot just cast it and pass to an API.</p>

<p>In C and C++03, you'd have to create a named wrapper function that matches the signature and preforms the cast. In C++11 and beyond, you can just use a capture-less lambda instead (properly cast):</p>

<pre><code>void fun(SomeType* p){
    ...
}

int main() {
  api_call(+[](void *v) {
    fun(static_cast&lt;SomeType*&gt;(v));
  });
}
</code></pre>

<p>The <code>+</code> in front of the lambda causes it to be converted into a regular function pointer so long as it's not capturing. It's not strictly needed, but it makes the intent more explicit IMO, without too much verbosity.</p>
",6
42480070,42479957,0,"<p><code>std::string</code> is an array of chars, isn't it? </p>

<p>For inputing without <code>\n</code> you can use <code>conio.h</code> and <code>_getch()</code></p>
",3
43969972,43969803,0,"<p>One Problem is, as Tyger mentioned that you didn't initialize the x, you could get that from a cin like in the menu funciton.
The other problem is that even though you get the string form the functions, you doesn't write it out. So your main function should look something like this:</p>

<pre><code>int main(){

string out;  // Do you realy need the out string here?
int mod,x;   // or the mod here
int choice;

cout &lt;&lt; ""Give x: "" &lt;&lt; endl;
cin &gt;&gt; x;

out = "" "";

do{
    menu(choice);
    switch(choice)
    {
        case 1 : cout &lt;&lt; base10to2(x) &lt;&lt; endl; break;
        case 2 : cout &lt;&lt; base10to8(x) &lt;&lt; endl; break;
        case 3 : cout &lt;&lt; base10to16(x) &lt;&lt; endl; break;
    }
}
while(choice != 4);{
cout&lt;&lt;""End Program / Thank You"";
}

return 0;
</code></pre>

<p>}</p>
",1
44345980,44345494,2,"<p>I have no idea why you'd want to do such a thing, but if you can cope with using a compiler extension, Clang and GCC will let you write a templated user-defined literal operator which will chop off the trailing null:</p>

<pre><code>template &lt;typename CharT, std::size_t N&gt;
struct string_literal {
    static constexpr std::size_t size = N;
    const CharT str[N];
};

template &lt;typename CharT, CharT... Str&gt;
constexpr string_literal&lt;CharT, sizeof...(Str)&gt; operator"""" _lit()
{
    return {{ Str... }};
}

int main()
{
    constexpr auto s = ""test""_lit;
    static_assert(s.size == 4);
    static_assert(s.str[0] == 't'); // etc
}
</code></pre>

<p>(Returning a <code>std::array&lt;const char, N&gt;</code> is another option.)</p>

<p>I've no idea whether this is what you're after, but then I don't really understand the motivation to be honest -- even back in the 70s the designers of C weren't too worried about ""wasting"" a single byte in string literal.</p>
",2
44345539,44345494,3,"<p>In C, you could write </p>

<pre><code>const char digits[16] = ""0123456789abcdef"";
</code></pre>

<p>This is actually supported in C as defined in <a href=""http://en.cppreference.com/w/c/language/array_initialization"" rel=""nofollow noreferrer"">array initialization</a>:</p>

<blockquote>
  <p>If the size of the array is known, it may be one less than the size of
  the string literal, in which case the terminating null character is
  ignored: <code>char str[3] = ""abc""; // str has type char[3] and holds 'a',
  'b', 'c'</code></p>
</blockquote>

<p>For C++, I see no direct way; but one could come around this as follows:</p>

<pre><code>char digits_t[16] = ""0123456789abcde"";
digits_t[15]='f';    
const char* digits = digits_t;
</code></pre>
",7
44346379,44345494,0,"<p>This might be overkill, but if it¡¯s acceptable to use <code>std::array</code>, then you can statically build one from a string literal using <code>constexpr</code> functions:</p>

<pre><code>#include &lt;array&gt;
#include &lt;iostream&gt;

// A type-level list of indices.

template &lt;size_t... Xs&gt;
struct indices { using type = indices&lt;Xs..., sizeof...(Xs)&gt;; };

// Generate indices from 0 to N.

template &lt;std::size_t N&gt;
struct upto { using type = typename upto&lt;N - 1&gt;::type::type; };

template &lt;&gt;
struct upto&lt;0&gt; { using type = indices&lt;&gt;; };

// Make an array by assigning each character
// from the corresponding index in the source.

template &lt;std::size_t... X, typename A = std::array&lt;char, sizeof...(X)&gt;&gt;
constexpr A make_array(char const *const source, const indices&lt;X...&gt;&amp;) {
    return A{{source[X]...}};
}

// A convenience function that deduces the size.

template &lt;std::size_t N&gt;
constexpr std::array&lt;char, N - 1&gt; string_constant(char const (&amp;data)[N]) {
    return make_array(&amp;data[0], typename upto&lt;N - 1&gt;::type{});
}

int main() {
    constexpr auto s = string_constant(""123456"");
    std::cout &lt;&lt; sizeof(s) &lt;&lt; '\n';
}
</code></pre>

<p>Now <code>sizeof(s)</code> is <code>6</code>, and if you look at the generated assembly, the string literal is stored as <code>.ascii</code>, not <code>.asciz</code>, so there is no trailing null character. You can use the member functions of <code>std::array</code> such as <code>size()</code>, <code>begin()</code>, and <code>end()</code>, and can cast <code>&amp;s[0]</code> to <code>const char *</code> to access character data directly.</p>
",0
44346379,44345494,0,"<p>This might be overkill, but if it¡¯s acceptable to use <code>std::array</code>, then you can statically build one from a string literal using <code>constexpr</code> functions:</p>

<pre><code>#include &lt;array&gt;
#include &lt;iostream&gt;

// A type-level list of indices.

template &lt;size_t... Xs&gt;
struct indices { using type = indices&lt;Xs..., sizeof...(Xs)&gt;; };

// Generate indices from 0 to N.

template &lt;std::size_t N&gt;
struct upto { using type = typename upto&lt;N - 1&gt;::type::type; };

template &lt;&gt;
struct upto&lt;0&gt; { using type = indices&lt;&gt;; };

// Make an array by assigning each character
// from the corresponding index in the source.

template &lt;std::size_t... X, typename A = std::array&lt;char, sizeof...(X)&gt;&gt;
constexpr A make_array(char const *const source, const indices&lt;X...&gt;&amp;) {
    return A{{source[X]...}};
}

// A convenience function that deduces the size.

template &lt;std::size_t N&gt;
constexpr std::array&lt;char, N - 1&gt; string_constant(char const (&amp;data)[N]) {
    return make_array(&amp;data[0], typename upto&lt;N - 1&gt;::type{});
}

int main() {
    constexpr auto s = string_constant(""123456"");
    std::cout &lt;&lt; sizeof(s) &lt;&lt; '\n';
}
</code></pre>

<p>Now <code>sizeof(s)</code> is <code>6</code>, and if you look at the generated assembly, the string literal is stored as <code>.ascii</code>, not <code>.asciz</code>, so there is no trailing null character. You can use the member functions of <code>std::array</code> such as <code>size()</code>, <code>begin()</code>, and <code>end()</code>, and can cast <code>&amp;s[0]</code> to <code>const char *</code> to access character data directly.</p>
",0
44345980,44345494,2,"<p>I have no idea why you'd want to do such a thing, but if you can cope with using a compiler extension, Clang and GCC will let you write a templated user-defined literal operator which will chop off the trailing null:</p>

<pre><code>template &lt;typename CharT, std::size_t N&gt;
struct string_literal {
    static constexpr std::size_t size = N;
    const CharT str[N];
};

template &lt;typename CharT, CharT... Str&gt;
constexpr string_literal&lt;CharT, sizeof...(Str)&gt; operator"""" _lit()
{
    return {{ Str... }};
}

int main()
{
    constexpr auto s = ""test""_lit;
    static_assert(s.size == 4);
    static_assert(s.str[0] == 't'); // etc
}
</code></pre>

<p>(Returning a <code>std::array&lt;const char, N&gt;</code> is another option.)</p>

<p>I've no idea whether this is what you're after, but then I don't really understand the motivation to be honest -- even back in the 70s the designers of C weren't too worried about ""wasting"" a single byte in string literal.</p>
",2
44345539,44345494,3,"<p>In C, you could write </p>

<pre><code>const char digits[16] = ""0123456789abcdef"";
</code></pre>

<p>This is actually supported in C as defined in <a href=""http://en.cppreference.com/w/c/language/array_initialization"" rel=""nofollow noreferrer"">array initialization</a>:</p>

<blockquote>
  <p>If the size of the array is known, it may be one less than the size of
  the string literal, in which case the terminating null character is
  ignored: <code>char str[3] = ""abc""; // str has type char[3] and holds 'a',
  'b', 'c'</code></p>
</blockquote>

<p>For C++, I see no direct way; but one could come around this as follows:</p>

<pre><code>char digits_t[16] = ""0123456789abcde"";
digits_t[15]='f';    
const char* digits = digits_t;
</code></pre>
",7
42581594,42580126,1,"<p>I'm not sure what is the deal with the macro at the end, but you can do what you want like this:</p>

<pre><code>template &lt;bool do_lock, bool do_increment&gt;
V sol::compare(uchar start_lev, V *a , V *b){
  if (do_lock) solMutex.lock(); // not needed by all callers 
  for(auto lev:solVec){ 
    switch (lev.group){ 
    case a: 
      dontRemove=0;
      if (do_increment) val++; // not used by all callers
      return something; 
    case b: 
      if (do_increment) val++; //not used by all callers
      return something; 
    case c: 
      etc... 
}
</code></pre>

<p>To call this, you would then do</p>

<pre><code>auto v = sol::compare&lt;false, false&gt;(....);
</code></pre>

<p>And vary those booleans depending on whether the specific caller needs it. Note that you <em>have</em> to  know the booleans you feed in at compile time since the compiler is generating a different function for each combination of booleans. Because the booleans are known at compile time, those branches will (if a bool is false) simply get pruned away as dead code by any compiler.</p>
",1
42581829,42580126,1,"<p>You have subsequently give a sketch of several ideas in a comment.</p>

<pre><code>V sol::compare(uchar start_lev, V *a , V *b) {
    solMutex.lock(); // not needed by all callers
    for(auto lev:solVec){
       switch (lev.group){
           case a:
               dontRemove=0;
               val++; // not used by all callers 
               return something;
           case b:
               val++; //not used by all callers
               return something;
           case c: 
               ///etc...
      } 
      #ifdef QT_DEBUG // not needed by all callers
}
</code></pre>

<p>For the preprocessor there isn't much you can do, codewise. </p>

<p>Aside from that you could use booleans. There are alternatives.</p>

<p>For other patterns, you could separate the commonality and differences. 
For example, if <code>solMutex</code> is a member variable of some fictious <code>sol</code> calls, we could have a <code>lockingSol</code></p>

<pre><code>class sol
{
public:
    V sol::compare(uchar start_lev, V *a , V *b);
        for(auto lev:solVec){
            //etc
        } 
    }
 };


class lockingSol
{
public:
    V compare(uchar start_lev, V *a , V *b)
    {
        solMutex.lock();
        return sol_.compare(start_lev, a, b);
    }

private:
    mutex solMutex;
    sol sol_;
};
</code></pre>

<p>This allows <code>nonlockingSol</code> to call <code>solMutex.lock();</code> and then call <code>sol_</code>'s method.</p>

<p>The template and stragey desgin patterns give you ways to switch out behaviour.</p>

<p>Alternatively you can send in a functor or lambda to swicth out what happens in the middle of an algorithm. The standard library iteself gives many example of this.</p>

<p>For example consider </p>

<pre><code>template&lt; class RandomIt, class Compare &gt;
void sort( RandomIt first, RandomIt last, Compare comp );
</code></pre>

<p>This iterates over something, and the caller sends in the <code>Compare</code> function to vary what happens inside the iteration.</p>
",0
46064089,46062186,1,"<p>You created a constructor that expects 5 input arguments (and you are not using it anywhere in your code). When you create an instance of the struct in <code>main()</code>, it tries to call a constructor with no arguments, and fails, because if you don't have a default constructor, you are telling it must be created your way. Just create another constructor without parameters and it should work. </p>

<pre><code>struct secure
{
    string surname;
    string name;
    string age;
    string placeofbirth;
    string tel;
    secure(const string&amp; s, const string&amp; n, string a, const string&amp; p, const string&amp; t);
    secure(); //Defaul constr with no args
};

secure::secure()
{ 
    //you can do something here if you want
}
</code></pre>

<p>If you want to use your 5 arg. constructor, you have to declare it like this:</p>

<pre><code>secure exotic(arg1, arg2, arg3, arg4, arg5);
</code></pre>
",4
42476091,42476036,0,"<p>Your <code>tail</code> is <code>-1</code> after the object is constructed. </p>

<p>When you add first element your method <code>MyQueue::myEnqueue</code> does something like this:</p>

<pre><code>data[-1]=el;
</code></pre>

<p>Your last element always has garbage in it which is potentially big negative number. <code>Head</code> being -1 is also a bad idea.</p>

<p>Fix:</p>

<ol>
<li>Your head and tail should be <code>0</code></li>
<li><p>You code of adding the elements should be:</p>

<pre><code>if (tail == size)
{
    tail = 0;
}
data[tail++] = el;  
</code></pre></li>
</ol>
",2
46104931,46103512,0,"<p>Quote from the standard:</p>

<blockquote>
  <p>A name is said to have linkage when it might denote the same object, reference, function, type, template, namespace or value as a name introduced by a declaration in another scope</p>
</blockquote>

<p>Translation to plain English:</p>

<p><em>If you can redeclare it in another scope, it has linkage. Otherwise, nope.</em></p>

<p>You cannot redeclare a non-static class data member in another scope, so it has no linkage.</p>
",0
46104387,46103512,2,"<p>Following example:</p>

<pre><code>class C
{
public:
    int n;
};

C e;
namespace { C i; }
</code></pre>

<p><code>e</code> has external linkage, <code>i</code> internal. How much sense would it make to speak of linkage of <code>n</code> now? If at all, you could consider <code>n</code> inheriting the linkage of the containing object, thus <code>e.n</code> would have external, <code>i.n</code> internal linkage &ndash; for better understanding only, I do not consider this as correct wording...</p>
",8
42509522,42507263,1,"<p>The first one is correct regarding ""dynamic array allocation in C++"".  It looks a bit weird, but it'll do.</p>

<p>Just to make a valid point:</p>

<ul>
<li>declaration as <code>char *</code> is correct</li>
<li>allocation via <code>new char[ size ];</code> also is correct.  Because this makes your array fixed-size at runtime. (unless you delete and new it again with a different size)</li>
</ul>
",0
42509610,42507263,1,"<p>Your 1st example is correct, the 2nd one only allocates memory for a single <code>char</code>, which you don't want.</p>

<p>However, If you want a dynamic array with no known compile time length then you should use <code>std::vector</code> to make life easier for yourself and your code less error-prone:</p>

<pre><code>std::cout&lt;&lt;""enter the length of string\n"";    
int length; 
std::cin&gt;&gt;length; 
std::vector&lt;char&gt; ch(length);     
for(int i=0;i&lt;length;i++)     
  std::cin&gt;&gt;ch[i];
ch.push_back('\0');
std::cout&lt;&lt;ch.data();
</code></pre>
",0
45222919,45222875,1,"<p>You have an error with the initialization of your vector. Since the vector of yours is empty, trying to assign values at indexes of the vector is not possible. The corrected code would be:</p>

<pre><code>vector&lt;int&gt; test(5);
for(int i = 0; i &lt; 5; i++)
{
    test[i] = i;
}
for(int i = 0; i &lt; 5; i++)
{
    cout &lt;&lt; test[i] &lt;&lt; "" "";
}
</code></pre>

<p>As you can see above, the vector <code>test</code> has a size of 5, which can now be filled using indexes.</p>

<p>On the other hand, you could also have changed the first part of your code to:</p>

<pre><code>vector&lt;int&gt; test;
test.reserve(5);
for(int i = 0; i &lt; 5; i++)
{
    test.push_back(i);
}
</code></pre>

<p>since now you are actually <em>adding</em> values to the vector, instead of just assigning non existent array positions. <a href=""http://en.cppreference.com/w/cpp/container/vector/reserve"" rel=""nofollow noreferrer""><code>reserve()</code></a> increases the capacity of a <code>vector</code> to a given amount.</p>
",8
45222966,45222875,1,"<p><code>vec[i]</code> does not allocate space, it presumes the space is already there.</p>

<p>Either you need to preallocate the vector, like so:</p>

<pre><code>std::vector&lt;int&gt; test; //I avoid the constructor that takes a size, because I don't trust it
test.resize(5);

for(int i = 0; i &lt; 5; i++)
{
    test[i] = i;
}
</code></pre>

<p>Or you need to use one of the methods that explicitly performs an allocation:</p>

<pre><code>std::vector&lt;int&gt; test;

for(int i = 0; i &lt; 5; i++)
{
    test.emplace_back(i);
    //OR: test.push_back(i); //Will not work for un-movable objects, like std::mutex
    //OR: test.insert(test.end(), i);
}
</code></pre>
",3
36263117,36262792,0,"<p>If the code <code>int cost id;</code> compiles something weird is going on, perhaps <code>cost</code> is defined as a macro? Anyway I am assuming here you really meant <code>int const id;</code>.</p>

<p>So I compiled and ran the following file, using Visual C++ 2015, and it worked with the input ""John"" and ""12345"" so you should not be getting an error.</p>

<pre><code>#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;

class Student
{
public:
    Student(std::string name_, int const id_);
private:
    std::string name;
    int const id;
};

Student::Student(std::string name_, int const id_) : name(name_), id(id_)
{
    string idStr = to_string(id);
    if (name.size() &gt;= 20)
    {
        throw(121);
        cout&lt;&lt;""Name should be less than 20 chars""&lt;&lt;endl;
    }
    if (idStr.size() != 5)
    {
        throw(122);
        cout&lt;&lt;""Id should be 5 nums""&lt;&lt;endl;
    }
    if (!all_of(idStr.begin(), idStr.end(), ::isdigit))
    {
        throw(123);
    }
}

int main()
{
    string n = """";
    cin &gt;&gt; n;
    int i = 0;
    cin &gt;&gt; i;
    Student s {n, i};
    cin.ignore(2);
}
</code></pre>

<p>What compiler/OS are you using? does other C++ code work? Perhaps your compiler is broken, or there is something wrong with other parts of your code that you have not shown. More information would be verry useful!</p>
",2
36263353,36262792,3,"<p>This whole approach is kind of barmy.</p>

<p>An integer converted to a string can never contain anything other than numeric digits (or <code>-</code>). It's a number. Plus you can check the range numerically (and handle the <code>-</code> as part of that). So your conversion is pointless and leading your debugging to be harder than necessary.</p>

<p>Why not just the following simple function?</p>

<pre><code>Student::Student(const std::string&amp; name_, int const id_)
  : name(name_)
  , id(id_)
{
    if (name.empty() || name.size() &gt;= 20)
        throw std::runtime_error(""Name must have 1-20 chars"");

    // Require that the ID has exactly five decimal digits (also implies positive)
    if (id &lt; 10000 || id &gt; 99999)
        throw std::runtime_error(""ID must have five decimal digits"");
}
</code></pre>

<p>Now when your code fails (which nobody can reproduce), simply output the value of <code>id</code> to console, or set a watch on <code>id</code>, and put breakpoints in the relevant conditional block.</p>
",9
42557482,42557182,0,"<p>Here is the reference of the <code>SHFILEOPSTRUCTW</code> structure:
<a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/bb759795(v=vs.85).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/bb759795(v=vs.85).aspx</a></p>

<blockquote>
  <p>FOF_FILESONLY 
     Perform the operation only on files (not on folders) if a wildcard file name (*.*) is specified.</p>
</blockquote>

<p>The full solution will be something like this:</p>

<pre><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char ** argv)
{
    const wchar_t *const sourceFile = L""A:\\*.*\0"";
    const wchar_t *const outputFile = L""C:\\test\\disk1\0"";

    SHFILEOPSTRUCTW fileOperation;
    memset(&amp;fileOperation, 0, sizeof(SHFILEOPSTRUCTW));

    fileOperation.wFunc = FO_COPY;
    fileOperation.fFlags = FOF_SILENT | FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR | FOF_NOERRORUI | FOF_FILESONLY;
    fileOperation.pFrom = sourceFile;
    fileOperation.pTo = outputFile;

    int result = SHFileOperationW(&amp;fileOperation);
    if (result != 0)
    {
        printf(""SHFileOperation Failure: Error%u\n"", result);
        return 1;
    }

    memset(&amp;fileOperation, 0, sizeof(SHFILEOPSTRUCTW));

    printf(""Transfer complete\n"");

}
</code></pre>
",3
42520769,42520696,0,"<p>As one of the comments suggests, you need to create a string from your chars.  After that, I would suggest looking at:</p>

<p><a href=""http://www.cplusplus.com/reference/string/string/find/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/string/string/find/</a></p>

<p>its a search function for strings used on other strings... which is exactly what you're looking for.</p>

<p>One of the comments also suggest using == to compare the string you created from chars and the user input string, but there isn't much use in doing it this way when the string::find function does the exact same thing but more efficently</p>
",0
42521623,42520696,0,"<p>A Modern C++ solution.
The interesting part in the main function which is below.</p>

<pre><code>#include &lt;random&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;sstream&gt;

void NotFoundMessage(std::list&lt;char&gt;&amp; randomSequence); 
void FoundMessage(long long iterationCount);

// Seed with a real random value, if available
std::random_device r;
std::default_random_engine e1(r());    
// A random character between 'A' and 'Z'
std::uniform_int_distribution&lt;int&gt; uniform_dist('A', 'Z');

char nextRandomCharacter()
{
    return static_cast&lt;char&gt;(uniform_dist(e1));
}

int main()
{
    std::string input;
    std::cin &gt;&gt; input;

    // &lt;--- NEEDS CHECKS IF INPUT IS CORRECT!!!!

    std::list&lt; char &gt; randomSequence;

    // Fill randomSequence with initial data
    for ( const auto&amp; c : input )
    {
        randomSequence.push_back( nextRandomCharacter() );
    }

    long long iterationCount = 1;

    while ( !std::equal( input.begin(), input.end(), 
                         randomSequence.begin() ) )
    {
        NotFoundMessage( randomSequence );

        // remove character from front and add random char at end.
        randomSequence.pop_front();
        randomSequence.push_back( nextRandomCharacter() );

        iterationCount++;
    }

    FoundMessage(iterationCount);
}

void NotFoundMessage(std::list&lt;char&gt;&amp; randomSequence)
{
    std::cout &lt;&lt; ""Not found in: "";
    for ( const auto&amp; c : randomSequence )
        std::cout &lt;&lt; c &lt;&lt; ' ';
    std::cout &lt;&lt; '\n';
}

void FoundMessage(long long iterationCount)
{
    std::cout &lt;&lt; ""Found after "" 
            &lt;&lt; iterationCount 
            &lt;&lt; "" iterations."" 
            &lt;&lt; std::endl;
}
</code></pre>
",0
42570004,42569814,4,"<p>You can try </p>

<pre><code>#include &lt;string&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include ""strtk.hpp""

std::string int_string = ""1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"";
std::vector&lt;string&gt; int_list;
strtk::parse(int_string,"","",int_list);
</code></pre>

<p>Then use the vector to assign to multiple variables</p>

<p>Edit: you can find the strtk.hpp <a href=""https://github.com/ArashPartow/strtk"" rel=""nofollow noreferrer"">here</a></p>
",3
42570004,42569814,4,"<p>You can try </p>

<pre><code>#include &lt;string&gt;
#include &lt;deque&gt;
#include &lt;vector&gt;
#include ""strtk.hpp""

std::string int_string = ""1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"";
std::vector&lt;string&gt; int_list;
strtk::parse(int_string,"","",int_list);
</code></pre>

<p>Then use the vector to assign to multiple variables</p>

<p>Edit: you can find the strtk.hpp <a href=""https://github.com/ArashPartow/strtk"" rel=""nofollow noreferrer"">here</a></p>
",3
42573180,42569814,0,"<p>First - remove all spaces to make a string delimiter unified:</p>

<pre><code>string base_str = ""a, b, val1,FALSE, TRUE, 24.5"";   
stringstream ab(base_str);
string buf;
string res_str;
while (ab &gt;&gt; buf)
    res_str+=buf;
</code></pre>

<p>It will be a string without unexpected tabs or spaces <code>string res_str = ""a,b,val1,FALSE,TRUE,24.5"";</code><br>
Then - split the string by needed delimiter to <code>vector</code>:</p>

<pre><code>int split (
    const string&amp; a_str,
    const string&amp; a_sep,
    vector&lt;string&gt;&amp; a_vect,
    const int a_maxcnt
    )
{
a_vect.clear();
size_t beg = 0;
int cnt = 0;

do
{
    size_t sep_pos = a_str.find(a_sep, beg);
    if (sep_pos == string::npos)
        sep_pos = a_str.length();

    string expr = a_str.substr(beg, sep_pos-beg);
    a_vect.push_back(expr);
    cnt++;
    beg = sep_pos+a_sep.length();
    if (a_maxcnt &amp;&amp; cnt == a_maxcnt-1)
        break;
}
while (beg &lt; a_str.length());
if (beg &lt; a_str.length())
{
    string expr = a_str.substr(beg);
    a_vect.push_back(expr);
}
else if (beg == a_str.length()) {
    a_vect.push_back("""");
}
return (int) a_vect.size();
}
</code></pre>
",0
42564109,42564067,6,"<p>The only side effect that I see is that in your second code snippet, the PrintIntro() function will only be called once. It wont be called everytime the user decides to play again.</p>
",0
42564141,42564067,4,"<p>There are two functional differences between the two methods:</p>

<ol>
<li>In the second version, PrintIntro() will only be called once rather than before every game.</li>
<li>AsktoPlayAgain can return any nonzero value in the first one, but it can only return 1 in the second. (If AsktoPlayAgain only ever returns 0 or 1, this isn't really a difference at all.)</li>
</ol>
",0
42564189,42564067,0,"<p>The second version doesn't print the Intro on every loop. Other than that, there is no side effect of calling <code>AsktoPlayAgain()</code> as the while parameter.</p>

<p>I'd like to add that version 1 has the added benefit that you can do stuff after asking but before replaying. For example:</p>

<pre><code>int main()
{
   bool bPlayAgain = false:
   do {
       PrintIntro();
       PlayGame();
       bPlayAgain = AsktoPlayAgain();
       if(bPlayAgain){
         ShowReload();
       }
   }
   while(bPlayAgain);
   return 0;
}
</code></pre>
",0
42564233,42564067,0,"<p>the only unwanted side effects that I see are </p>

<ul>
<li>PrintIntro() is only called at the beginning. It won't re-execute if a player decides to play again. Though, this may be your intention.</li>
<li>You have issues on some systems when casting a <code>bool</code> to an <code>int</code> in your <code>while</code> statement: <code>while(AskToPlayAgain() == 1);</code>. AskToPlayAgain returns a <code>bool</code> but 1 is an <code>int</code>. You could replace that statement with <code>while(AskToPlayAgain());</code> and achieve the same effect without issues since a <code>bool</code> is returned.</li>
</ul>
",0
42593069,42592973,1,"<p>The behavior of your code is undefined.  </p>

<p>If <code>a &lt;= 1</code> in the <code>fact</code> function, you failed to return a value.  Failure to return a value results in undefined behavior, thus the different results you're seeing.</p>

<p>The correction should be:</p>

<pre><code>int fact( int a)
{
    if (a&gt;1)
       return a*fact(a-1);
    return 1; 
}
</code></pre>
",3
42606148,42606093,1,"<p>Try:</p>

<pre><code>class proxy {
public:
    enum class type { direct, http };
    type getType() const { return type_; }
private:
    type type_ = type::direct;
};
</code></pre>

<ul>
<li>Replace <code>enum type</code> by <code>type</code>, you do not need <code>enum</code> when using an enum type in C++.</li>
<li>Rename the function <code>type()</code>, it conflicts with the enum name.</li>
</ul>
",0
42606184,42606093,3,"<p>For VS 2015, this compiles for me:</p>

<pre><code>class proxy {
public:
    enum class type { direct, http };
    enum class type type() const { return type_; }
private:
    enum class type type_ = type::direct;
};
</code></pre>

<p>You just have to add the ""class"" keyword in since it's a scoped enum.</p>

<p>Usage for VS:</p>

<pre><code>proxy p;
enum class proxy::type var = p.type();
</code></pre>

<p>Your original solution compiles for gcc 6.3 and clang 3.9.1:</p>

<pre><code>class proxy {
public:
    enum class type { direct, http };
    enum type type() const { return type_; }
private:
    enum type type_ = type::direct;
};
</code></pre>

<p>Usage for clang and gcc:</p>

<pre><code>proxy p;
enum proxy::type var = p.type();
</code></pre>

<p>For gcc 5.4, you can typedef the enum in the private section of the class.</p>
",14
42606553,42606414,-4,"<p>c++ has the  header file, there are some minimum and maximum for different datatypes for the implementation you are using.</p>

<p>look there. furthermore, you must use 64bit integer, see if its smaller then the maximum or bigger then the minimum for 32bit integere, then you can convert.</p>
",1
42606554,42606414,1,"<p>What you want to do is really hard to check for. Just like checking if you have saved a negative number into unsigned integer. Once it is saved there, the information is lost and the value becomes corrupted, because of different representation of information stored inside that variable. </p>

<p>I'm not sure what happens if you try to save a value bigger than variable space but still the best option would be to load it up as string and parse it with std::stoi(), which would give you error if the values was exceeding the int range.</p>
",1
42606565,42606414,4,"<p>In C++ you  should use std::numeric_limits (from <code>&lt;limits&gt;</code>). Name of header <code>&lt;climits&gt;</code> starting with C suggests that it is an old C header, left for compatibility (former <code>limits.h</code>). You forgot parenthesis in expression, it would be evaluated wrong way. Literal is too big for int. Value can't actually exceed bounds for bound types</p>

<p><a href=""http://en.cppreference.com/w/cpp/types/numeric_limits"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/types/numeric_limits</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;typeinfo&gt;
#include&lt;limits&gt;

long long g1, g2;

int main() 
{
  //...

  if ((g1 &gt; std::numeric_limits&lt;int&gt;::lowest()) 
       || (g1 &lt; std::numeric_limits&lt;int&gt;::max())) 
  {
       //...
  } 

  return 0;
}
</code></pre>

<p>You must handle input from cin in way that would reset input if  user done something wrong. To actually (close can of worms) check for range, you need a  bigger (can of worms) storage. Consider this function:</p>

<pre><code>int  getInt()
{
    while (1) // Loop until user enters a valid input
    {
        std::cout &lt;&lt; ""Enter an int value: "";
        long long x;  // if we'll use char, cin would assume it is character
        // other integral types are fine
        std::cin &gt;&gt; x;

        if (std::cin.fail()) // has a previous extraction failed?
        {
            // yep, so let's handle the failure, or next &gt;&gt; will try parse same input
            std::cout &lt;&lt; ""Invalid input from user.\n"";
            std::cin.clear(); // put us back in 'normal' operation mode
            std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(),'\n'); // and remove the bad input
        }
        // Thechnically you may do only the above part, but then you can't distingusih invalid format from out of range
        else if(( x  &gt; std::numeric_limits&lt;int&gt;::max()) ||
            ( x  &lt; std::numeric_limits&lt;int&gt;::min()))
        {
            std::cout &lt;&lt; ""Invalid value.\n"";
        }
        else // nope, so return our good x
            return x;
    }
}
</code></pre>

<p>If istream fails to parse  input into required type, the remaining content  of buffer is left unmodified until you clear it or you request action that will result in success. For example you can check if user had entered a float.. or if he entered a command to stop program.</p>
",0
42606832,42606414,0,"<p>If your goal is to check whether an input number is in the range of integer or not? Then you can take the input number as string and with string functions you can check if the number is in the range or not. Here is one implementation.</p>

<pre><code>std::string inputNum = """"; //input number as string
std::cin&gt;&gt;inputNum; //assuming you are going to input numbers only
std::string maxNum = std::to_string(INT_MAX); //2147483647
std::string minNum = std::to_string(INT_MIN); //-2147483648

if(inputNum[0] == '-') //negative number
{
    /* if num of digits are more than min Number's digit
     * then the number is already out of range 
     * if num of digits are equal then you would have 
     * to check whether it is less than the min number or not
     * all numbers with lesser number of digits are in the range
    */
    if(inputNum.length() &gt; minNum.length()) 
        std::cout&lt;&lt;""Not an integer"" &lt;&lt; std::endl;
    else if(inputNum.length() == minNum.length())
        if(inputNum &gt; minNum)
            std::cout&lt;&lt;""Not an integer"" &lt;&lt; std::endl;
        else
            std::cout&lt;&lt;""Integer"" &lt;&lt; std::endl;
    else
        std::cout&lt;&lt;""Integer"" &lt;&lt; std::endl;
}

else //positive number
{
    if(inputNum.length() &gt; maxNum.length())
        std::cout&lt;&lt;""Not an integer"" &lt;&lt; std::endl;
    else if(inputNum.length() == maxNum.length())
        if(inputNum &gt; maxNum)
            std::cout&lt;&lt;""Not an integer"" &lt;&lt; std::endl;
        else
            std::cout&lt;&lt;""Integer"" &lt;&lt; std::endl;
    else
        std::cout&lt;&lt;""Integer"" &lt;&lt; std::endl;
}
</code></pre>
",0
42607246,42606414,8,"<p>Because C++ is deliberately vague about the minimum and maximum sizes of primitive types like <code>int</code>, big integer literals like <code>2100000000000000000000000</code> are dangerously platform-dependent. </p>

<p>Your program may even be ill-formed and not compile at all as a result of it. Fortunately, checking user input does not have anything to do with integer literals. The former occurs at <strong>runtime</strong>, the latter is a <strong>compile-time</strong> aspect.</p>

<p>This means that your example code is an unrealistic scenario. In a real program, the value of <code>g1</code> will <em>not</em> be a compile-time constant but a number entered by the user.</p>

<p>A very good practice is to first let the user enter the number into a <code>std::string</code> with <code>std::getline</code>, and then use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/stol"" rel=""noreferrer""><code>std::stoi</code></a> to convert the string into an <code>int</code>.</p>

<p>If you follow that practice, all error checking is performed by the standard library and you don't have to use <code>INT_MIN</code>, <code>INT_MAX</code> or their C++ counterparts <code>std::numeric_limits&lt;int&gt;::min()</code> and <code>std::numeric_limits&lt;int&gt;::max()</code> at all.</p>

<p>Example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

auto const text  = "" year"";
auto const text2 = "" age"";

int main() {
  try {
    std::string input;

    std::getline(std::cin, input);
    auto const g1 = std::stoi(input);

    std::getline(std::cin, input);
    auto const g2 = std::stoi(input);

    std::cout &lt;&lt; g1 &lt;&lt; text;
    std::cout &lt;&lt; g2 &lt;&lt; text2;
    std::cout &lt;&lt; '\n';

  } catch (std::out_of_range const&amp;) {
    std::cout &lt;&lt; ""Please enter an integer\n"";
  }
}
</code></pre>

<p>The great thing is that this will also detect <em>other</em> kinds of bad user input, for example when the user enters letters instead of digits. Extending the error handling in this piece of example code to catch other kinds of exceptions is left as an exercise to the reader.</p>
",2
42607370,42606414,0,"<p>Simply check that the input has succeeded:</p>

<pre><code>#include &lt;iostream&gt;


int main()
{
    int val;
    if (std::cin &gt;&gt; val)
        std::cout &lt;&lt; ""value is "" &lt;&lt; val &lt;&lt; ""\n"";
    else
        std::cout &lt;&lt; ""value input failure\n"";

    return 0;
}
</code></pre>

<p><kbd><a href=""http://coliru.stacked-crooked.com/a/01eee14791edaa0b"" rel=""nofollow noreferrer"">Live on Coliru</a></kbd></p>
",0
42654540,42637205,0,"<p>I ended up building libstudxml-1.0.1 (<a href=""http://www.codesynthesis.com/projects/libstudxml/"" rel=""nofollow noreferrer"">http://www.codesynthesis.com/projects/libstudxml/</a> ) and linking xlnt.test with that library resolves the undefined symbol issue. 
Also note that on my system xlnt does not link successfully with libstudxml-1.0.1 and it has to be linked with xlnt-master\third-party\libstudxml...\libstudxml.lib</p>
",0
42384236,42383085,0,"<p>Your if else conditions are not completely defined... you have to set those in a range... otherwise is not going to work...</p>

<pre><code>if (input &lt; 60)
    {
        cout &lt;&lt; ""The time is "" &lt;&lt; input &lt;&lt; "" seconds."" &lt;&lt; endl;
    }
    else if (input &gt;= 60 &amp;&amp; input &lt; 3600))
    {
        cout &lt;&lt; ""The time is "" &lt;&lt; input &lt;&lt; "" minutes."" &lt;&lt; endl;
    }
    else if (input &gt;= 3600 &amp;&amp; input &lt; 86400))
    {
        cout &lt;&lt; ""The time is "" &lt;&lt; input &lt;&lt; "" hours."" &lt;&lt; endl;
    }
    else if (input &gt;= 86400)
    {
        cout &lt;&lt; ""The time is "" &lt;&lt; input &lt;&lt; "" days."" &lt;&lt; endl;
    }
</code></pre>
",0
42666607,42666514,2,"<p>Second blank place is ""return""</p>

<p>First may be ""inline"" or nothing</p>
",0
42663319,42662863,1,"<p>In function <code>void Graph::printGraph()</code>, inside for loop you are using <code>V</code> which will be same for all the iterations. It should be,</p>

<p><code>for(list&lt;pair&lt;int,int&gt; &gt;::iterator it = adj[i].begin(); it != adj[i].end(); ++it)</code></p>

<p>You have declared <code>string s</code> and not using it anywhere in your program.  </p>
",0
42663410,42662863,0,"<p>In <code>printGraph()</code>: <code>V</code> should not be used as index in the loop (need to use <code>i</code>).
Below code works:</p>

<pre><code> void Graph::printGraph() {
   for(int i=0; i&lt;V; i++){
     string s = to_string(i) + ""-&gt;"";
     for(list&lt;pair&lt;int,int&gt; &gt;::iterator it = adj[i].begin(); it != adj[i].end(); ++it)
         cout&lt;&lt; s &lt;&lt; it-&gt;first&lt;&lt; "" and weight is ["" &lt;&lt; it-&gt;second &lt;&lt;""]""&lt;&lt; endl;
    }
 }
</code></pre>
",0
42678800,42677646,1,"<h1>Linker problems</h1>

<p>This error means that <code>registrador_nivel</code> is supposed to exist somewhere, but the linker could not find where. I can't tell exactly what your problem is because you have <em>so much code</em>.</p>

<p>Let me show you an example that will produce the error you just got. Let's assume I only have this file:</p>

<pre><code>// main.cpp
extern char registrador_nivel;

int main() {
    registrador_nivel = 2;
}
</code></pre>

<p>The line <code>extern char registrador_nivel;</code> tells your compiler that, <em>somewhere</em>, you have a global variable called <code>registrador_nivel</code>. However, <code>main.cpp</code> <em>does not specify where <code>registrador_nivel</code> is</em>. It only says that <code>registrador_nivel</code> exists somewhere.</p>

<p>The line <code>registrador_nivel = 2;</code> tries to change the value of <code>registrador_nivel</code>. You still don't know <em>where</em> <code>registrador_nivel</code> is. You just know you have to change it.</p>

<p>The object file (<code>main.o</code> file) will be produced during the compilation. It is a file that contains the same thing as <code>main.cpp</code>, but it a format that is more understandable to the computer. So <code>main.o</code> still doesn't say where <code>registrador_nivel</code> is.</p>

<p>Now, you want to make the final executable from the <code>main.o</code> file. The linker tries to find where <code>registrador_nivel</code> actually is. To do that, it looks inside static libraries (<code>.lib</code> and <code>.a</code> files) as well as other object files (<code>.o</code> files). If no library or object file says where <code>registrador_nivel</code> is, then the linker will send the error <code>undefined reference to registrador_nivel</code>.</p>

<hr>

<h1>Typical solutions</h1>

<p>Once again, I can't tell you exactly what you have to do to solve your problem ; I can only guess.</p>

<ol>
<li><p>Are you using static libraries (<code>.lib</code> or <code>.a</code> files)? Since I see in your code that you talk about <em>Bibliotecas</em>, I guess that's your problem. Maybe <code>registrador_nivel</code> is defined in a library. In that case, you should link against these libraries. You're following a tutorial, aren't you? Your tutorial probably says what library to link against, and how.</p></li>
<li><p>Are you sure you compiled all the files you should be compiling? If you aren't then you might be missing the <code>.o</code> file where <code>registrador_nivel</code> is, so your linker can't find it.</p></li>
<li><p>If you're compiling everything you should be and you're linking against all static libraries you should be, then maybe they require you to declare <code>registrador_nivel</code>. In that case, try declaring a global variable called <code>registrador_nivel</code>.</p></li>
</ol>
",4
45662754,45662708,4,"<p>You have undefined behaviour in your code, <code>getTokens()</code> returns a vector by <em>value</em> and you call that twice (once for <code>begin()</code>, once for <code>end()</code>) which means your two iterators don't point to the same container. This just cannot work. And then, you call it a <em>third</em> time to compare the result of <code>find</code> which is also incorrect for the same reason.</p>

<p>You can easily fix this by changing it to be: </p>

<pre><code>auto tokens = st.getTokens();
if(find(tokens.begin(), tokens.end(), item) != tokens.end())
</code></pre>

<p>or you can return <code>const vector&lt;string&gt;&amp;</code> from <code>getTokens()</code>.</p>
",0
45739231,45739068,2,"<p>You are rewriting content of your file with each line.
You need to open file for append. Change line</p>

<pre><code>out.open(""student-info.txt"");
</code></pre>

<p>to</p>

<pre><code>out.open(""student-info.txt"", std::fstream::app);
</code></pre>

<p>See <a href=""http://www.cplusplus.com/reference/fstream/fstream/open/"" rel=""nofollow noreferrer"">std::fstream::open</a></p>
",0
42492967,42491243,3,"<p><a href=""https://msdn.microsoft.com/en-us/library/mt763946.aspx"" rel=""nofollow noreferrer"">The error</a> is caused by your conversion of a <code>double</code> to <code>int</code> in the second <code>Segment</code> constructor. From the context of your code, I would assume that <code>the_end</code> is defined as an <code>int</code>, yet you are assigning it a <code>double</code>.</p>

<pre><code>Segment::Segment(double new_end, double new_acceleration)
  : the_end{ new_end },               // &lt;-- Here
    acceleration{ new_acceleration }
{

}
</code></pre>

<p>Your use of an initializer list in particular is causing the error as they <a href=""https://stackoverflow.com/a/18222927/735425"">do not allow for narrowing</a>. </p>

<p>Of special note for your situation:</p>

<ul>
<li>A floating-point value cannot be converted to an integer type.</li>
</ul>

<p>To fix the error, simply provide an explicit cast:</p>

<pre><code>Segment::Segment(double new_end, double new_acceleration)
  : the_end{ static_cast&lt;int&gt;(new_end) },
    acceleration{ new_acceleration }
{

}
</code></pre>

<p>Do note of course the potential dangers of casting from an <code>int</code> to a <code>double</code> (integer truncation, potential loss of data from going from 8 bytes to 4 bytes, etc.).</p>
",0
42655016,42654953,1,"<blockquote>
  <p>Some people say that it is unnamed object</p>
</blockquote>

<p>The correct term is <em>temporary instance</em>.</p>

<blockquote>
  <p>Some of them say that it is constructor.</p>
</blockquote>

<p>It's in fact a constructor call.</p>

<p>A constructor call outside of a variable declaration statement will create a <em>temporary instance</em> of <code>Box</code>, and that one is returned by value from the function.</p>
",2
36365380,36365202,2,"<p>First use getline to grab an entire line, then you can use a <a href=""http://en.cppreference.com/w/cpp/io/basic_istringstream"" rel=""nofollow""><code>istringstream</code></a> to create a stream of <code>int</code>s just for that line.</p>

<p>At that point it's just a matter of creating each subvector of ints using the vector constructor that takes two iterators. An <a href=""http://en.cppreference.com/w/cpp/iterator/istream_iterator"" rel=""nofollow""><code>istream_iterator&lt;int&gt;</code></a> on your <code>istringstream</code> gets this done:</p>

<pre><code>std::vector&lt;std::vector&lt;int&gt;&gt; nums;
std::string line;
while (std::getline(std::cin, line)) {
    std::istringstream ss(line);
    nums.emplace_back(std::istream_iterator&lt;int&gt;{ss}, std::istream_iterator&lt;int&gt;{});
}
</code></pre>
",0
36365512,36365202,2,"<p>What is happening is since you are using only ' '(space) as deliminator, the input happens to be</p>

<pre><code>1
2
3\n4 //&lt;------ Newline also comes with the input

...
</code></pre>

<p>So, you are passing <code>3\n4</code>, <code>6\n7</code> etc to <code>atoi</code> it returns 3,6 etc(atoi parses the input till first non-digit input) and the <code>4,7</code> is lost.</p>

<p>To achieve want you want you can use getline with istringstream (keeping the default deliminator as newline)</p>

<pre><code>string rawInput;
vector&lt;vector&lt;int&gt;&gt; temp;
while(getline(cin, rawInput) ){
  istringstream bufferInput(rawInput); 
  temp.push_back(vector&lt;int&gt;{std::istream_iterator&lt;int&gt;{bufferInput}, std::istream_iterator&lt;int&gt;{}});
}
</code></pre>
",1
36365334,36365202,0,"<p>you can use stringstream</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>string rawInput;
vector&lt;int&gt; temp;
stringstream ss;

while(getline(cin,rawInput)){
  ss&lt;&lt;rawInput;
  vector&lt;int&gt; temp;
  int x;
  
  while(ss&gt;&gt;x){
    temp.push_back(x);
  }
  
  num.push_back(temp)
}</code></pre>
</div>
</div>
</p>
",0
36365941,36365202,0,"<p>I recently wrote an answer to another question but with a few adaptations it achieves exactly what you are looking for (I hope):</p>

<pre><code>#ifndef _IOSTREAM_H
#include &lt;iostream&gt;
#endif
#ifndef _STRING_H
#include &lt;string&gt;
#endif
#ifndef _VECTOR_H
#include &lt;vector&gt;
#endif

using namespace std;

enum XYZ { X = 0, Y = 1, Z = 2 };

struct Vector {
    float x, y, z;
    Vector(float _x=0, float _y=0, float _z=0) {
        x = _x;
        y = _y;
        z = _z;
    }
    float&amp; operator[](size_t index) {
        if (index == XYZ::X) return x;
        if (index == XYZ::Y) return y;
        if (index == XYZ::Z) return z;
        throw new exception;
    }
};



#define min(a, b) (((a) &lt; (b)) ? (a) : (b))

bool isCharNumeric(char c) {
    const char* numbers = ""0123456789"";
    for (size_t index = 0; index &lt; strlen(numbers); index++)
        if (c == numbers[index]) return true; return false;
}

vector&lt;Vector&gt; parseNumbers(string str_in) {
    str_in += ""  ""; //safe, no out of bounds
    vector&lt;Vector&gt; results = {};
    char currentChar;
    char skipChar = ' ';
    bool found_period = false;
    size_t count_len = 0;
    Vector vector_buffer(0,0,0);
    XYZ current_axis = (XYZ)0;
    for (size_t index = 0; index &lt; str_in.length(); index++) {
        currentChar = str_in[index];
        if (currentChar == skipChar || currentChar == '\n' || currentChar == '\t')
            continue;

        else if (isCharNumeric(currentChar)) {
            string word = """"; //word buffer
            size_t word_len = min(min(str_in.find_first_of(' ', index + 1) - (index), str_in.find_first_of('\n', index + 1) - (index)), str_in.find_first_of('\t', index + 1) - (index)); //whatever char comes first; newline, tab or space
                                                                                                                                                              //append chars of following word checking if it is still valid number char
            if (word_len &gt; 0) {
                size_t count_word_len = 0;
                for (count_word_len = 0; count_word_len &lt; word_len; count_word_len++)
                    if (isCharNumeric(str_in[index + count_word_len])) {
                        word += str_in[index + count_word_len];
                    }
                    else if (str_in[index + count_word_len] == '.' &amp;&amp; isCharNumeric(str_in[index + count_word_len + 1])) {
                        //Floating-point numbers
                        word += '.';
                        found_period = true;
                        continue;
                    }
                    else {
                        word = """";
                        continue;
                    }

                    vector_buffer[current_axis] = stof(word);


                    if (current_axis == XYZ::Z) {
                        current_axis = XYZ::X;
                        results.push_back(vector_buffer);
                    }
                    else {
                        current_axis = (XYZ)(current_axis + 1);
                    }


                    index += count_word_len;
                    word = """";
                    continue;
            }

        }
    }
    return results;
}
</code></pre>

<p>Example implementation:</p>

<pre><code>int main(int argc, char** argv) {
    string user_input;
    cin &gt;&gt; user_input;
    vector&lt;Vector&gt; numbers = parseNumbers(user_input);
    for each (Vector v in numbers) {
        cout &lt;&lt; ""X="" &lt;&lt; v.X &lt;&lt; ""\n"";
        cout &lt;&lt; ""Y="" &lt;&lt; v.Y &lt;&lt; ""\n"";
        cout &lt;&lt; ""Z="" &lt;&lt; v.Z &lt;&lt; ""\n\n"";
    }
}
</code></pre>
",1
36366240,36365202,0,"<p>Suprisingly none of the answers use the istream stream operator:
<a href=""http://www.cplusplus.com/reference/istream/istream/operator%3E%3E/"" rel=""nofollow"">http://www.cplusplus.com/reference/istream/istream/operator%3E%3E/</a></p>

<p>When stream is empty eofbit is set, so run a while loop on that.</p>

<p>Works great for all types, and can be overloaded for custom types (such as 2D texture).</p>
",0
36733573,36733552,10,"<p>Alongside your <code>vector</code>, you can test whether the word is already in a <a href=""http://en.cppreference.com/w/cpp/container/set/insert""><code>std::set&lt;std::string&gt;</code></a>, ignoring it if so, otherwise inserting it in both containers:</p>

<pre><code>while (cin &gt;&gt; s)
    if (mySet.insert(s).second) // newly inserted in set?
        myVec.push_back(s);
</code></pre>
",0
37202755,37202662,1,"<p>The expression <code>x - 'a'</code> gives you the distance between the character value in <code>x</code> and the first lowercase letter of the alphabet.  </p>

<p>For example:<br>
'b' - 'a' == 1<br>
'c' - 'a' == 2  </p>

<p><strong>Edit 1: an easier method</strong><br>
Declare your array of counts to have 256 slots.<br>
Use the character as an index into the array.<br>
Increment the value at the index.  </p>

<p>For example:</p>

<pre><code>unsigned int counts[256];
char c = 'b';
//...
counts[c] += 1;
</code></pre>

<p>Using the subtraction, <code>x - 'a'</code> allows for a smaller size array.  </p>

<p><strong>Edit 2: More portable solution</strong><br>
A more portable solution, one that doesn't depend on the encoding, is to use an array of characters containing the alphabet.  Search for the character, if found, the index is the characters' offset.  </p>

<pre><code>char c = 'j';
const std::string lowercase_alphabet = ""abcdefghijklmnopqrstuvwxyz"";
const std::string uppercase_alphabet = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
unsigned int counts[26] = {0};
//...
unsigned int index = lowercase_alphabet.find(c);
if (index != std::string::npos)
{
    ++counts[index];
}
else
{
  index = uppercase_alphabet.find(c);
  if (index != std::string::npos)
  {
    ++counts[index];
  }
}
</code></pre>

<p>The same concept can be applied to character arrays instead of the <code>std::string</code> type.  </p>

<p><em>Note:  The <code>toupper</code> and <code>tolower</code> functions are not used to avoid the localization overhead.</em>  </p>
",3
37203446,37202662,0,"<p>Few point to note:</p>

<ol>
<li><p>The program assumes string contains only LowerCase letters(a-z) and nothing else. Thus, there can be at maximum <code>26 possible character</code> from <code>[a-z]</code></p></li>
<li><p>By doing <code>-'a'</code>, we are simply subtracting ascii value of <code>'a'</code> from the <code>s[i]</code>. Each characters has a unique <a href=""https://www.google.co.in/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=19&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjc3OSRvtbMAhXLqY8KHXCZDd0QFghqMBI&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FASCII&amp;usg=AFQjCNFSokt7M__Fqagb0Pu_skP7NDsFfA&amp;sig2=W7DyFNk5L7sJnG2_Y2IYbw"" rel=""nofollow"">ascii value</a>. During the compilation, compiler checks for the the ascii value of <code>'a'</code> and replaces <code>-'a'</code> with <code>-48</code>. Instead of doing <code>-'a'</code>, we could have done <code>-48</code>, but in this case, we don't need to remember ascii value of <code>'a'</code> .</p></li>
<li><p>All the ascii values of <code>[a-z]</code> are continuous. <code>a's</code>  value being 48 and <code>z's</code> value being 57. Thus, by doing <code>s[i]-'a'</code>, we get to know what is the difference of <code>ith varaible</code> from <code>a</code>.</p></li>
<li><p>In the end <code>Letter = 'a' + i;</code> is done to get the original character.</p></li>
</ol>
",0
42620591,42620497,4,"<p>The <code>if</code> statement works fine in the block of a <code>switch</code>, you've just put it in a place where it never gets executed. The <code>switch</code> statement jumps to the corresponding <code>case</code>, that is its purpose. Whatever it jumps to, it will skip over the <code>if</code>, so the <code>if</code> never executes.</p>

<p>If you were to add code to make it possible to jump to between the <code>switch</code> and the <code>if</code>, then the <code>if</code> would execute normally. You could do this with a loop of any kind or a <code>goto</code>.</p>

<p>A <code>default</code> is only taken if <em>no</em> <code>case</code> is matched. Otherwise, the <code>switch</code> jumps to the matching <code>case</code>.</p>
",0
42620636,42620497,2,"<p>The <code>switch</code> statement doesn't work the way you imagine that it works. The way it behaves is not as a substitute of an <code>if</code>-<code>else if</code>-<code>else</code>, but somewhat differently.</p>

<p>Upon encountering the <code>switch</code> the process will jump to the code following the correct <code>case</code>. This means that you actually completely skip the execution of the <code>if</code> that you have placed there.</p>

<p>And yes, it does look weird, since you assume that because you have the curly braces you must execute <code>if</code> condition or not enter into them at all, but this is simply not the case.</p>
",0
42620677,42620497,0,"<p>Well the placement of your if-statement doesn't really make sense. The switch-statement jumps to the corresponding case and then exists, hence your if-statement won't be executed. And I wouldn't recommend to use goto, cause it's considered as a bad-practice.</p>
",0
47998830,47998765,3,"<p>If <code>origine</code> is a <code>TPoint</code> there is no difference. </p>

<p>If <code>origine</code> is not a <code>TPoint</code> then it will invoke either an operator <code>TPoint</code> of whatever <code>origine</code> is or <code>TPoint::TPoint(&lt;whatever origne is&gt;)</code></p>
",0
47998847,47998765,6,"<p>The cast in your teachers code is totally pointless</p>

<blockquote>
<pre><code>TPoint TObjetGraphique::getOrigine() const
    {return (TPoint(origine));}
          // ^^^^^^^       ^ You can just omit this as proposed
</code></pre>
</blockquote>

<p>assumed that <code>origine</code> is of type <code>TPoint</code> as stated.</p>

<hr>

<p>If <code>origine</code>'s type can be converted to <code>TPoint</code> in any way the explicit cast is pointless either.</p>

<p>If there's a reason for that syntax then that <code>TPoint</code> has constructor declarations like</p>

<pre><code>struct SomethingElse {
    int a_;
    int b_;

    explicit SomethingElse(int a, int b) : a_(a), b_(b) {}
    SomethingElse() = default;
};

class TPoint {
public:
    explicit TPoint(SomethingElse rhs)  : x_(rhs.a_), y_(rhs.b_) {
        std::cout &lt;&lt; ""TPoint::TPoint(const SomethingElse&amp; rhs)"" &lt;&lt; std::endl;
    }
private:
    int x_;
    int y_;
};

int main() {
    SomethingElse something;
    // TPoint pt1({2,3}); // &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Fails
    TPoint pt2(something);
}
</code></pre>

<p>which looks quite unusual but finally works to prevent <code>TPoint</code> being instantiated from <code>SomethingElse</code> inadvertently (see the <a href=""http://coliru.stacked-crooked.com/a/57df4eb495405db3"" rel=""nofollow noreferrer"">Live Demo</a>). </p>
",8
42543328,42543281,1,"<p>Check your boolean logic.
ACCT>9999&amp;&amp;ACCT&lt;0</p>

<p>Can it be the case that ACCT is simultaneously larger than 9999, AND smaller than 0?</p>

<p>Replace the AND (&amp;&amp;) with OR (||).</p>
",5
45679061,45677469,0,"<p>Try this code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;

using namespace std;

struct myBook{
    string name;
    string author;
    int ID;
    int copiesNumber;
    float price;
};

int main() {
    ofstream books(""My Library Books.txt"", ios::app); //creating a file
    myBook bookInfo;
    cout&lt;&lt;""Enter the book's name: ""&lt;&lt;endl;
    std::getline(cin, bookInfo.name) ;
    cout&lt;&lt;""Enter the author of the book: ""&lt;&lt;endl;
    std::getline(cin, bookInfo.author);
    cout&lt;&lt;""Enter the books ID: ""&lt;&lt;endl;
    cin&gt;&gt;bookInfo.ID;
    cout&lt;&lt;""Enter number of the book's copies available: ""&lt;&lt;endl;
    cin&gt;&gt;bookInfo.copiesNumber;
    cout&lt;&lt;""Enter the book's price: ""&lt;&lt;endl;
    cin&gt;&gt;bookInfo.price;

    return 0;
}
</code></pre>

<p>I have changed <code>name</code> and <code>author</code> to string and using <code>std::getline</code> instead of <code>cin.get</code>.</p>

<p>Reference <a href=""https://stackoverflow.com/questions/2184125/getting-input-from-user-using-cin"">here</a>.</p>
",4
45679435,45677469,0,"<p>You need to insert cin.ignore() everytime before you ask for more input like so:</p>

<pre><code>int main() {
   ofstream books(""My Library Books.txt"", ios::app); //creating a file  
   myBook bookInfo;
   cout &lt;&lt; ""Enter the book's name: "" &lt;&lt; endl;
   cin.get(bookInfo.name, 50);
   cout &lt;&lt; ""Enter the author of the book: "" &lt;&lt; endl;
   cin.ignore(); // &lt;--
   cin.get(bookInfo.author, 50);
   cout &lt;&lt; ""Enter the books ID: "" &lt;&lt; endl;
   cin.ignore(); // &lt;--
   cin &gt;&gt; bookInfo.ID;
   cout &lt;&lt; ""Enter number of the book's copies available: "" &lt;&lt; endl;
   cin.ignore(); // &lt;--
   cin &gt;&gt; bookInfo.copiesNumber;
   cout &lt;&lt; ""Enter the book's price: "" &lt;&lt; endl;
   cin.ignore(); // &lt;--
   cin &gt;&gt; bookInfo.price;

   return 0;
}
</code></pre>
",0
43219957,43219928,0,"<p>To use the std::string class you have to include the header file string, so to import it to the corresponding hpp file, you need to write this</p>

<pre><code>#include &lt;string&gt;
</code></pre>

<p>now instead of always typing std::string you can add</p>

<pre><code>using std::string;
</code></pre>

<p>before you program out the class</p>
",0
46127402,46127306,2,"<p>You are typing a *nix command and getting a Windows error. The command shells work differently on *nix and Windows.</p>

<p>Windows cmd.exe</p>

<pre><code>C:\Users\Ahaman\prog\BML&gt; CheckBML
</code></pre>

<p>Linux/Unix/etc /usr/bin/bash (or whatever)</p>

<pre><code>~/prog/BML% ./CheckBML
</code></pre>
",0
44708274,44708218,3,"<p>It depends on the compiler for exact translation of assembly instructions, but it is most likely exactly the same and/or so negligible it is irrelevant.</p>

<p>This is often used for readability over any sort of speed optimization attempt. </p>
",0
44708301,44708218,0,"<p>The former is preferred. It is simpler and more readable.</p>

<pre><code>void foo()
{
    if( error_condition)
    {
       // Handle error
       return;
    }

    // Carry on

    if( other_error_condition)
    {
       // Handle error
       return;
    }

    // Carry on

    // Done
}
</code></pre>

<p>Some argue that there should only be one return from any function, but this has not been a best practice for quite a long time and is a left over myth from assembly days.</p>

<p>The alternative results in a lot of nesting ugliness</p>

<pre><code>void foo()
{
    if( !error_condition)
    {
       // Do stuff

       if ( !other_error_condition )
       {
           // Do other stuff
       }
       else           
       {
            // Handle error
       }
    }
    else
    {
        // Handle error
    } 

    // Done
}
</code></pre>
",1
42591207,42591164,0,"<p>Just guessing because we lack a <em>lot</em> of information:</p>

<pre><code>// some init of Area &amp; minArea here

while (!in.fail()) {
    if (Area &lt; minArea) {
        minArea = Area;
    }
    readRecord(in, ISO, ISO3, ISONumeric, fips, Country, Capital,
        Area, Population, Continent, tld, CurrencyCode, CurrencyName, Phone,
        PostalCodeForm, PostalCodeRegex, Languages, geonameid, neighbors,
        EquivalentFipsCode);

}
</code></pre>
",1
43984820,43098669,0,"<p>This question has been answered <a href=""http://answers.opencv.org/question/136689/freeman-chain-code-in-opencv-3/"" rel=""nofollow noreferrer"">here</a>. Maybe it helps someone else like me when searching for this.</p>

<p>Tested the code listed there and it works.</p>
",0
42603929,42603870,2,"<p>What you need to do is to use a flag variable to determine if the user is done adding stuff to the cart.</p>

<p>For example, the interface looks like this</p>

<pre><code>Menu list
-
food 1
food 2
food 3
-
quit (q)
</code></pre>

<p>Then its just a matter of seeing if the <code>input == ""q""</code> and breaking out of the loop if it is</p>

<pre><code>while(true){ 
    cin &lt;&lt; input;
    if(input == ""q"") break;
    else //other-logic-here
}
</code></pre>
",0
42604599,42603870,0,"<p>Way to implement your idea:</p>

<pre><code>const int menu[]{ 10,20,30 };
int a=0, b=0, c=0;

cout &lt;&lt; ""enter your mix.(a=10,b=20 and c=30). Press other keys to sum."" &lt;&lt; endl;
char input;
cin &gt;&gt; input;

while (input != 'q')
{
    switch (input)
    {
        case 'a'  :a += menu[0]; break;
        case 'b'  :b += menu[1]; break;
        case 'c'  :c += menu[2]; break;
        default:
            cout &lt;&lt; a &lt;&lt; "" + "" &lt;&lt; b &lt;&lt; "" + "" &lt;&lt; c &lt;&lt;"" = ""&lt;&lt;  a + b + c &lt;&lt; endl;
            a = b = c = 0;
            cout &lt;&lt; ""enter a,b,or c."" &lt;&lt; endl;
    }
    cin &gt;&gt; input;
}
</code></pre>

<p>Results:</p>

<pre><code> enter your mix.(a=10,b=20 and c=30). Press other keys to sum.
b
b
c
c
c
7
0 + 40 + 90 = 130
enter a,b,or c.
</code></pre>
",0
42640934,42640876,1,"<pre><code>int choice:&gt;=1&amp;&amp;&lt;=100.
</code></pre>

<p>You're not really ""comparing"" anything. When you do this, what you want to do is, Does Is choice greater than or equal to 1, AND is choice less than or equal to 100. What your code is saying is more ""human"" and natural. IS choice greater than or equal to 1, AND less than or equal to one. But remember, our computers are pretty dumb, so you need to declare it more precisely, like so...  </p>

<pre><code>choice &gt;= 1 &amp;&amp; choice &lt;= 100
</code></pre>

<p>Also, make sure to declare choice somewhere else. Like so...   </p>

<pre><code>int choice = 5;
...
if(choice &gt;= 1 &amp;&amp; choice &lt;= 100){
   ...
}
</code></pre>
",0
42640938,42640876,3,"<p>You've confused datatype declarations, user input, and range-testing.  These are not magic C++ statements -- they are three separate things.</p>

<pre><code>int choice;
if( std::cin &gt;&gt; choice &amp;&amp; choice &gt;= 1 &amp;&amp; choice &lt;= 100 )
{
    std::cout &lt;&lt; ""Valid choice: "" &lt;&lt; choice &lt;&lt; std::endl;
}
else
{
    std::cout &lt;&lt; ""Invalid choice"" &lt;&lt; std::endl;
}
</code></pre>
",0
42612484,42612443,2,"<p>You have to provide the size of the array, since you did not provide an initializer from which the compiler can deduce the size. Again, from C++11 you cannot have a <em>string-literal</em> bind to <code>char*</code>, use <code>const char*</code>.</p>

<pre><code>int main()
{
    constexpr int argc = 2;
    const char *argv[argc] = {};

    argv[0] = ""./server"";
    argv[1] = ""127.0.0.1"";
}
</code></pre>

<p>You may want to explore good use of <code>std::array&lt;std::string, 2&gt;</code> instead.</p>
",1
43222158,43222109,2,"<p>The loop must go to 5 so that the indexes are 0, 1, 2, 3, 4</p>

<p>Like this:</p>

<pre><code>for(int i=0;i&lt;5;i++)
</code></pre>

<p>Besides that you are missing <code>;</code> in the end of two lines.</p>

<p>So the whole code:</p>

<pre><code>char a[5]={1,2,3,4,5};  // added ;
int sum=0;              // added ;
for(int i=0;i&lt;5;i++)sum = sum + a[i];  // Changed 4 to 5
cout&lt;&lt;sum;
</code></pre>

<p>will print <code>15</code></p>
",0
43224083,43222109,0,"<p>The issue is that you are not looping enough times and missing the final item. That is already established in another answer. </p>

<p>There are mechanisms in c++ to avoid such out by one errors (one of the most common types).</p>

<p>Take these two examples that do not require to explicitly state how many elements are in the collection you are iterating over.</p>

<pre><code>#include &lt;iterator&gt;
#include &lt;numeric&gt;
#include &lt;iostream&gt;

int main()
{
    const char a[5] = {1, 2, 3, 4, 5};

    /*
        #1 use range based for loop
    */
    int t = 0;
    for(char c: a) 
        t += c;
    std::cout &lt;&lt; t &lt;&lt; '\n';

    /*
        #2 use implicit loop in accumulate algorithm
    */
    int i = std::accumulate(std::begin(a), std::end(a), 0);
    std::cout &lt;&lt; i &lt;&lt; '\n';
}
</code></pre>

<p>These are two idiomatic ways to write c++ and should eliminate a large number of simple errors from your code.</p>
",0
42620766,42620464,3,"<p>You have to initialize your fp&lt;>() first:</p>

<pre><code>template&lt;typename T&gt;
static void (*fp)() = nullptr;
</code></pre>

<p>It compiles and runs fine in Clang 4.0: <a href=""http://ideone.com/pznunQ"" rel=""nofollow noreferrer"">sample code</a>. 
And try to always initialize your variables ¡ª it may save you from all sorts of headaches. :)</p>
",0
36275943,36274879,1,"<p>......</p>

<pre><code>if (inFile.fail()) {
    cout &lt;&lt; ""can't open the input file"" &lt;&lt; endl;
}
else {
    cout &lt;&lt; ""input file is open"" &lt;&lt; endl;
}
//return 0;
</code></pre>

<p>....</p>

<p>comment this <code>return 0;</code>, which makes you program to exit.</p>
",0
43197118,43196850,1,"<p>To start: create two classes derived from Employee:</p>

<pre><code>class HourlyEmployee: public Employee
{
};

class SalariedEmployee: public Employee
{
}
</code></pre>

<p>and move members related to Hourly working from Employee to HourlyEmployee, then add members related to Salary to SalariedEmployee (WeeklySalary).</p>

<p>This way (removing attributes related to hourly working) you make Employee class more general that can be a base for other kind of employees to (SalariedEmployee).</p>

<p>When you derive HourlyEmployee or SalariedEmployee from Employee, you mean they are kind of Employee, so members that Employee has, they will inherit automatically.</p>
",0
44746944,44746756,1,"<p>Having interdependent classes is bad as you can't test one without the other. This built-in inability to test is often taken as a reason not to test rather than a reason to refactor the setup to break the dependency cycle. As with interdependent classes singletons are also an anti-pattern as they effectively inhibit testing of different setups. While it is short-term easier to just access a global variable mid to long term it is a massive headache and other approaches, e.g., explicitly passing a suitable everywhere it is needed actually makes things easier.</p>

<p>There are many ways to break dependency cycles (John Lakos's <em>Large Scale C++</em> discusses those in detail; be warned, though: while the discussion on dependencies is reasonable, a lot of what is said in this book felt rather dated when the book was released 20+ years ago...). The easiest for your setup is probably to split the menu functionality into an abstraction providing the menu interface and its actual implementation:</p>

<ul>
<li>The menu abstraction is just a base class which probably doesn't do anything or does very little, certainly not depending on an application entity.</li>
<li>The application class would travel in terms of the menu abstraction, having a dependency on the [abstract?] menu base class but not on the actual menu implementation.</li>
<li>The menu implementation derives from the menu abstraction and uses the application as appropriate. The menu implementation would have a dependency on both the menu abstraction and the application but there is no cyclic dependency.</li>
</ul>
",0
43748173,43747905,-1,"<p>I will answer both questions mentioned separately as follows:</p>

<ol>
<li><p>Yes, passing arrays to functions is just like passing their original addresses.</p></li>
<li><p>You will use Dynamic Allocation and work on heap rather than stack.</p></li>
</ol>

<p>For completeness, here is a simple example on Dynamic Allocation:</p>

<pre><code>int** mat = new int*[m];
for (int = 0; i &lt; m; ++i) {
    mat[i] = new int[n];
}
</code></pre>
",0
43175090,43175053,2,"<p>You can't compare fin with 0, fin wont return the next input.
First store the input in a variable, then compare it.</p>

<p>For your case, you probably want to check if the <strong>next</strong> character is a '0', or even a '\0'. 
Try using this:
<a href=""http://www.cplusplus.com/reference/istream/istream/peek/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/istream/istream/peek/</a></p>

<p>Your condition becomes (assuming you want '\0'):</p>

<pre><code>fin.peek() != 0
</code></pre>
",0
43175369,43175053,1,"<p>You cannot test <code>fin != 0</code>. <code>fin</code> isn't a number, to testing for equality with 0 makes about as much sense as testing what kind of orange an apple is. You can test that <code>fin</code> is still readable though with a simple <code>fin</code> by taking advantage of <a href=""http://en.cppreference.com/w/cpp/io/basic_ios/operator_bool"" rel=""nofollow noreferrer"">operator bool</a>, but that's tricky because the test for is readable will be made before reading. You can't test for failure before you have a chance to fail and that leaves open the possibility that the last reads failed and were not checked for validity.</p>

<p>Instead of trying to fix this, I'm going to <a href=""https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem"">go all X-Y</a> on you here and suggest something completely different.</p>

<p>Define a structure</p>

<pre><code>struct room
{
    int room_no;
    string room_status;
    string category;
    int rent; // could be a float. Don't care much for this example
              // that said, watch out for rounding errors when dealing with floats  
};
</code></pre>

<p>Create a function that makes it really easy to read into this structure</p>

<pre><code>std::istream &amp; operator&gt;&gt;(std::istream &amp; in,
                          room &amp; inroom)
{
    in &gt;&gt; inroom.room_no &gt;&gt; inroom.room_status &gt;&gt; inroom.category &gt;&gt; inroom.rent;
    return in;
}
</code></pre>

<p>Create a function that makes it really easy to write this structure</p>

<pre><code>std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out,
                          const room &amp; outroom)
{
    out &lt;&lt; outroom.room_no &lt;&lt; setw(10) &lt;&lt; outroom.room_status &lt;&lt; 
           setw(10) &lt;&lt; outroom.category &lt;&lt; setw(10) &lt;&lt; outroom.rent;
    return out;
}
</code></pre>

<p>Make a <code>std::vector</code> of the above structure a member of the <code>Hotel</code> class</p>

<pre><code>std::vector&lt;room&gt; rooms;
</code></pre>

<p>Read the file into it</p>

<pre><code>room temp;
while (in &gt;&gt; temp)
{    
    rooms.push_back(temp);
}
</code></pre>

<p>Now the hotel knows the status of all the rooms without having to keep looking at the file. This makes printing easy.</p>

<pre><code>for(room &amp; r: rooms)
{
    cout &lt;&lt; r &lt;&lt; '\n';
}
</code></pre>

<p>It makes finding any room a simple traversal of rooms</p>

<pre><code>for(room &amp; r: rooms)
{
    if (r.whatever == desiredwhatever)
    {
        return r;
    }
}
</code></pre>

<p>and every now and then you rewrite the file if a room was changed.</p>

<pre><code>std::ostream outfile(""path to file goes here"");
for(room &amp; r: rooms)
{
    if (!(outfile &lt;&lt; r &lt;&lt; '\n'))
    {
        //handle error
    }
}
</code></pre>

<p>All of these things you probably have to do anyway. The only downside is if you are not allowed to use <code>std::vector</code>. In that case you either write a simple <code>vector</code> substitute or use an array and pray it never overflows.</p>
",0
43189278,43189161,1,"<p>From what I can see, <code>items</code> is just an array of <code>element</code>. In C++ arrays don't have any methods/properties. It's just aligned data without any logic. Consider using <code>vector</code> instead.</p>

<p>edit: change</p>

<pre><code>element items[MLS]
</code></pre>

<p>to </p>

<pre><code>vector&lt;element&gt; items
</code></pre>

<p>You will be able to use <code>items.empty()</code> or <code>items.size()</code> You won,t need to set an initial size of 50, the vector will resize itself whenever its needed.</p>
",1
43189358,43189161,1,"<pre><code>typedef int element;
...
class AList {
    element items[MLS];
    ...
};
...
void AList::Menu() {
    ...
    if (items.empty == true)
        ...
    ...
}
</code></pre>

<p>As you can see, <code>items</code> is just an array of <code>int</code>s. However, in c++, arrays have neither named members (such as java's <code>arr.length</code>) nor methods associated with them. If you want this functionality in your code, I recommend you use <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow noreferrer"">std::vector</a>.</p>
",0
44373722,44372512,2,"<p>I have a solution which uses variable templates (C++14), but it looks like a horrible hack. One disadvantage of it is that variable templates can only be static. Assuming you can live with it (though it's already bad)...</p>

<p>For each type of message (here type = list of parameters passed to the handler), you are going to have a separate list of handlers. This can be implemented like this:</p>

<pre><code>template&lt;typename F&gt; static map&lt;string, vector&lt;F&gt;&gt; list;
</code></pre>

<p>Here an example for <code>F</code> is <code>void(int)</code> - a function that receives one <code>int</code> argument. Another example is <code>void(int, int)</code> - a function that receives two <code>int</code> arguments. The data structure I use here stores a <code>vector</code> of handlers for each message name. I could alternatively use <code>multimap</code>.</p>

<p>When ""registering"" an event handler, just add it to the list of handlers:</p>

<pre><code>template&lt;typename F&gt; static void add_handler(string s, F f)
{
    list&lt;F&gt;[s].push_back(f);
}
</code></pre>

<p>When looking up the event handlers, you should specify their type explicitly. This is a crucial part, which implements type safety - it will lookup only in the data structure that corresponds to the type of the called handler.</p>

<pre><code>template&lt;typename F, typename... A&gt; static void call_handlers(string s, A... args)
{
    for (F f: list&lt;F&gt;[s])
        f(args...);
}
</code></pre>

<hr>

<p>Usage:</p>

<pre><code>// Define event handlers
// Their type SHOULD be explicit (not lambda), because we will reference it further
function&lt;void(int)&gt; action1 = [](int k){cout &lt;&lt; ""notify user "" &lt;&lt; k &lt;&lt; '\n';};
function&lt;void(int)&gt; action2 = [](int k){cout &lt;&lt; ""alert user "" &lt;&lt; k &lt;&lt; '\n';};
function&lt;void(int, int)&gt; action3 = [](int a, int b){cout &lt;&lt; ""give $"" &lt;&lt; a &lt;&lt; "" to user "" &lt;&lt; b &lt;&lt; '\n';};

// Register the handlers
add_handler(""good_event"", action1);
add_handler(""good_event"", action2);
add_handler(""bad_event"", action2);
add_handler(""money_event"", action3);

// Generate events, which will call the handlers
call_handlers&lt;function&lt;void(int)&gt;&gt;(""good_event"", 7);
call_handlers&lt;function&lt;void(int)&gt;&gt;(""bad_event"", 8);
call_handlers&lt;function&lt;void(int, int)&gt;&gt;(""money_event"", 100, 9);

// Wrong call, but no compilation error - the handler is just not found
call_handlers&lt;function&lt;void(int)&gt;&gt;(""money_event"", 99);
</code></pre>
",0
48037193,48037158,4,"<blockquote>
  <p>Why Stroustrup in his ""A Tour of C++"" catches by value?</p>
</blockquote>

<p>Unless you want to copy the exception for some reason <em>(e.g. store a custom exception type)</em>, you should always catch by <code>const&amp;</code>. This might have been an oversight from Bjarne, or in that particular snippet it didn't really matter whether or not the exception was copied. </p>

<p>Related:</p>

<ul>
<li><p><a href=""https://blog.knatten.org/2010/04/02/always-catch-exceptions-by-reference/"" rel=""nofollow noreferrer"">""Always catch exceptions by reference""</a></p></li>
<li><p><a href=""https://stackoverflow.com/questions/2522299/c-catch-blocks-catch-exception-by-value-or-reference"">C++ catch blocks - catch exception by value or reference?</a></p></li>
</ul>

<hr>

<blockquote>
  <p>Why C++ is changing inconsistently? I mean from time to time everything changes. eg: in C++ 11:</p>
</blockquote>

<p>There is no inconsistency here - <code>static_assert</code> merely became more flexible, as it doesn't force the user to provide an error message anymore. This is useful for cases where the boolean condition itself is self-explanatory and an error message would not add anything useful.</p>
",5
43957926,43957863,0,"<p>This is part of the language itself... the compiler translate the string ""c=a+b;"" to add the value stored in a to the value stored in b and set the result to c.</p>
",0
43957930,43957863,3,"<p>The compiler generates the code for these operations - they are not part of the Standard Library. Your compiler will almost certainly have an option to allow you to examine the generated assembly language code.</p>
",6
43957934,43957863,0,"<blockquote>
  <p>yet I cant find a location of the function definition.</p>
</blockquote>

<p>There might not be a <em>function definition</em> at all, but a simple assembly instruction set:</p>

<pre><code>mov 1,r1
mov 5,r2
add r1,r2
</code></pre>
",0
43958047,43957863,0,"<p>In C++, there is no <code>operator+(int,int)</code>. The addition operator is built-in and no function corresponds to it. In particular, you cannot do this:</p>

<pre><code>using intDyadic = int(*)(int, int);
intDyadic add = operator+(int,int);
</code></pre>

<p>By contrast, you could create a function pointer to an operator override defined in a library, including the standard library.</p>
",2
43227020,43226611,0,"<h2><strong>To restore path:</strong></h2>

<p>Store additional n-sized array, say, <code>prev[n]</code>, <code>prev[0]=-1</code>. If your dp decides for i'th step that you came from i-1, (i.e. dp[i - 1] + abs(v[i] - v[i - 1]) was larger than dp[i - 2] + 3 * abs(v[i] - v[i - 2])), then <code>prev[i]=i - 1</code>, otherwise <code>prev[i]=i - 2</code>. Then starting from n-1'th element (assuming that your numeration starts from 0), build the path using <code>prev</code>.</p>

<h2>Code snippet:</h2>

<pre><code>int v = n - 1;
while(v != -1) {
    path.push_back(v + 1);
    v = prev[v];
}
std::reverse(path.begin(), path.end());
</code></pre>
",1
43226723,43226475,0,"<blockquote>
  <p>C++ allows you to have a member with an incomplete data type (such as char[]) at the end of a struct.</p>
</blockquote>

<p>No. C++ does not allow flexible array members. However, C does and some C++ compilers support it as a language extension.</p>

<p>According to the standard, your program is ill-formed.</p>

<blockquote>
  <p>I would expect fooPtr->bar to either be 'e'</p>
</blockquote>

<p>There is no reason to expect that. <code>bar</code> is an array, and so it will decay into a pointer when used in a value context. When a character pointer is inserted into a stream, the operator will read the characters until null character is reached. Since there is no null character after <code>e</code>, the output will continue past it.</p>

<blockquote>
  <p>or throw some kind of read access violation error.</p>
</blockquote>

<p>Access violations are undefined behaviour. You can hope for, but not expect an error.</p>

<blockquote>
  <p>Why does it perfectly print the string up to the null termination character?</p>
</blockquote>

<p>This is how the flexible arrays work in C. You allocate a memory buffer for the object; The initial segment is used for other members, and the rest are part of the flexible array member.</p>

<p>Note that the example program is not correct even if we assume support for flexible array members due to aliasing violation. This would be correct, if you were to insist on using the extension:</p>

<pre><code>auto&amp; str = ""hello"";
auto fooPtr = (foo*)std::malloc(sizeof str);
std::memcpy(fooPtr, str, sizeof str);
std::cout &lt;&lt; fooPtr-&gt;bar;
</code></pre>
",3
47972413,47971395,1,"<p>You need to template the <code>using</code></p>

<pre><code>template&lt;class T&gt;
using VectorPtr = std::vector&lt;T&gt;*;

template&lt;ENUM e, class T&gt; struct foo {
public:
    static VectorPtr&lt;T&gt; getVal() { return ptr; }
private:
    static VectorPtr&lt;T&gt; ptr;
};
</code></pre>

<p><strong>Or</strong> (using same templated <code>using</code>):</p>

<pre><code>template&lt;ENUM e, class T&gt; struct foo;
template&lt;class T&gt;
class foo&lt;ENUM::E1, T&gt; {
public:
    static VectorPtr&lt;T&gt; getVal() { return ptr; }
private:
    static VectorPtr&lt;T&gt; ptr;
};

template&lt;class T&gt;
class foo&lt;ENUM::E2, T&gt; {
public:
    static VectorPtr&lt;T&gt; getVal() { return ptr; }
private:
    static VectorPtr&lt;T&gt; ptr;
};
</code></pre>
",1
36366516,36366471,2,"<p>Yes you can have prototypes declared and not defined.</p>

<p>A very good example is making a class not copyable by declaring the copy constructor and assignment private but not defining them. This is good practice.</p>

<p>e.g.</p>

<pre><code>class Foo {
   private:
     Foo( const Foo&amp; other ); // non construction-copyable - not defined
     Foo&amp; operator=( const Foo&amp; ); // non copyable - not defined
 };
</code></pre>
",2
45110641,45110351,0,"<p>Your problem is caused by calling <code>delete []</code> on uninitialized memory.</p>

<p>In the copy constructor, the <code>data</code> member is not initialized before calling <code>getData()</code>. In <code>getData()</code>, you are using <code>delete [] data;</code>.</p>

<p>You could initialize <code>data</code> to <code>nullptr</code> in the constructors to avoid the problem.</p>

<p>It's always a good idea to initialize all variables to some sensible value before the body of the constructor. E.g. you can implement the copy constructor as:</p>

<pre><code>String::String(const String &amp;other) : currentSize(0),
                                      maxSize(other.maxSize),
                                      data(nullptr)
{
    getData(other.data, maxSize);
}
</code></pre>

<p>Similarly, implement the constructor from <code>char const*</code>   as:</p>

<pre><code>String::String(const char *other) : currentSize(0),
                                    maxSize(strlen(other) *2),
                                    data(nullptr)
{
    getData(other, maxSize);
}
</code></pre>
",1
43950027,43949991,0,"<p>You can't create variables names like that using a loop.</p>

<p>Perhaps a <code>std::map&lt;int, Point&gt;</code> will work for your needs.</p>

<pre><code>std::map&lt;int, Point&gt; pointsMap;
for (int i = 0; i &lt; N; ++i )
{
   pointsMap[i+1] = Point{...}:
}
</code></pre>

<p>Then, can use <code>pointMap[n]</code> to access the items from the map.</p>

<p>If you want to use a string as the key of the map, you can construct the keys in the loop using <code>i</code>.</p>

<pre><code>std::map&lt;std::string, Point&gt; pointsMap;
for (int i = 0; i &lt; N; ++i )
{
   std::string key = ""Point"" + std::to_string(i+1);
   pointsMap[key] = Point{...}:
}
</code></pre>

<p>Then, can use <code>pointMap[key]</code> to access the items from the map.</p>
",2
43950148,43949991,0,"<p>Symbol names are compile-time entities not present in the compiled run-time code, so generating a symbol name at run-time makes no sense. Instead you would use an array or container class.</p>
",0
36462206,36461976,0,"<p>You could use the <code>any</code> type that boost provides in the map-container (or any other container that you like)
<a href=""http://www.boost.org/doc/libs/1_60_0/doc/html/any.html"" rel=""nofollow"">http://www.boost.org/doc/libs/1_60_0/doc/html/any.html</a></p>

<blockquote>
  <p>The boost::any class supports copying of any value type and safe checked extraction of that value strictly against its type.</p>
</blockquote>

<p>To get implementation-specific information about an element's type use the following function member of <code>boost::any</code></p>

<pre><code> const std::type_info &amp; type() const;
</code></pre>

<p>Example here (using a std::list):
<a href=""http://www.boost.org/doc/libs/1_60_0/doc/html/any/s02.html"" rel=""nofollow"">http://www.boost.org/doc/libs/1_60_0/doc/html/any/s02.html</a></p>

<p>Should be the safest and quickest approach.</p>
",2
36462240,36461976,1,"<p>You can use a union and a ""type tag"" (enum or string) indicating what the union actually holds. Let's suppose you want to hold strings, ints and floats:</p>

<pre><code>union valU { float f; int i; char *s; };
enum valE { fl, in, st };
struct variousT { valU val; valE type; };

void print(variousT v)
{
   switch(v.type)
   {
      case fl: printf(""%f"", v.val.f); break;
      case in:  printf(""%d"", v.val.i); break;      
      case st:  printf(""%s"", v.val.s); break;
   }
}
</code></pre>

<p>Of course <code>print</code> could be a member function, there should be overloaded setters in <code>variousT</code> which set the tag together with the value etc. But this is the raw mechanism.</p>
",0
36463216,36461976,0,"<p>You can implement your own '<code>any</code>' type (using a nested <code>union</code> in a <code>struct</code>) and store that as a value in your map. However, non-primitive type like <code>std::string</code> are a little tricky here.</p>

<p>Here is some rudimentary example:</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;map&gt;

struct any {
    enum any_type:char { string_t = 0, int_t = 1 };
    any(){
    }
    any(const any&amp; a) {
        this-&gt;type = a.type;
        switch (this-&gt;type) {
            case any_type::string_t: new(&amp;(this-&gt;str)) std::string(a.str); break;
            case any_type::int_t   : this-&gt;i = a.i; break;
            /* more types */
        }
    }
    ~any(){
        switch (this-&gt;type) {
            case any_type::string_t: { if (str.size()) { str.std::string::~string(); } } break;  
            /* more types */
            default: ;
        }
    }
    std::string descr() const {
        switch (this-&gt;type) {
            case any_type::string_t: { std::stringstream s; s &lt;&lt; ""string : "" &lt;&lt; str; return s.str(); }  
            case any_type::int_t   : { std::stringstream s; s &lt;&lt; ""int    : "" &lt;&lt; i; return s.str(); }
            /* more types */
        }
    }
    any_type type;
    union {
        std::string str;
        int i;
        /* more types */
    };
};
using any_t = any::any_type;

int main() {
    std::map&lt;std::string,any&gt; m;
    any a;
    a.type = any_t::string_t;
    new(&amp;(a.str)) std::string(""aaa"");
    //a.str = std::string{""aaa""};
    m.insert({""a"",a});

    any b;
    b.type = any_t::int_t;
    b.i = 5;
    m.insert({""b"",b});

    for(auto&amp; a : m) {
        std::cout &lt;&lt; a.second.descr() &lt;&lt; ""\n"";
    }

    return 0;
}
</code></pre>
",2
44232938,44231588,2,"<p>The problem you are encountering is there is no nullary constructor for either <code>std::istream</code> nor <code>std::ostream</code>, they both require a <code>std::streambuf*</code> parameter. Therefore <code>Mystream</code> can't have a defaulted constructor, you will have to write one. <code>std::fstream</code> and <code>std::stringstream</code> do this with related subclasses of <code>std::streambuf</code>, <code>std::filebuf</code> and <code>std::stringbuf</code>. I suggest that you provide a streambuf subclass also.</p>

<p>Note that you may as well inherit from <code>std::iostream</code>, which is already a combined input/output stream. Note also that all of these names I have mentioned are type aliases for <code>std::basic_*&lt;char, std::char_traits&lt;char&gt;&gt;</code>, you can easily generalise to <code>template &lt;Char = char, Traits = std::char_traits&lt;Char&gt;&gt; class MyStream : std::basic_iostream&lt;Char, Traits&gt;{ ... }</code></p>
",0
43176380,43176286,-2,"<p>You shouldn't  pass uniform-dimension arrays in this fashion:</p>

<pre><code>bool writeFile(int board[9][9]);
</code></pre>

<p>you initialize your array ONCE:</p>

<pre><code>int board[9][9];
</code></pre>

<p>Then, you pass it to a method,specifying how long each row is, aka the column count ONLY, in the case of a 2D construct. Such a method signature would look like this:</p>

<pre><code>bool writeFile(int board[][9]);
</code></pre>

<p>Within writeFile, board IS the same array you passed in, NOT a copy by value to which you may be accustomed.
If you use c style arrays, you're using pointers whether you like it or not, because all an array variable in fact is IS a pointer to the first array element. For example:</p>

<pre><code>//given
int array[9];
//array can be passed into a method signed ""void DoSomethingWithArray(int* array);
//or a method signed ""void DoSomethingWithArray(int array[]);
</code></pre>

<p>and all changes made in such a method affect array, the original declaration variable.</p>

<p>In the case of passing a 2D array, ""board"" in your case, the parameter board decays into(is programtically) a pointer to an int array, aka a pointer to the first row of your construct, which in turn is a pointer to the first element(int) of your construct. This fact shouldn't overtly matter, because you can double subscript it to access any elements in the familiar way. Knowing this is important though, as you wouldn't wonder how to manipulate the same array in various functions once you know that the way they get there is by address, not by value.</p>

<p>One additional note that may shed light on some of these points:</p>

<pre><code>array[1]; 
//is the same as
*(array + 1);
//take the address of the first array element, move index*sizeof(elementT) addresses forward,
 //and then dereference. [] is just a syntactical abstraction of this behavior.
</code></pre>
",9
43196417,43196271,0,"<p>Your first order of business is to call <code>getRowCol()</code> which, in a rather roundabout way, attempts to determine in advance the size of the map in the file. It does this by determining the size of the file, then rewinding back to the beginning of the file, reading the first line, obtaining its length, and from that compute the number of rows.</p>

<p>However, if you paid very careful attention, you would've realized that when <code>getRowCol()</code> returned, it did that <strong>after</strong> reading the first line of the file. But the code that follows assumes that it's reading from the beginning of the file, and reads the entire map. Which, of course, is not going to happen any more, because the first line in the file has been read.</p>

<p>This explains the first part of your question, with the missing line and a gap.</p>

<p>As far as the second part of your question: all of this complicated logic is definitely, completely, and totally unnecessary.</p>

<p>Your code demonstrates that you have the basic knowledge and understanding of how vectors work.</p>

<p>So, why is this complicated logic needed in the first place?</p>

<p>Just open the file, and read each line of the file into a vector, <code>push_back()</code>ing each line after it's read, until the end of the file is reached.</p>

<p>When all is said and done, the vector's size is how tall the map is. because the vector contains one value for each row in the file. And by looking at the size of each line, you then know how wide the map is.</p>

<p>That's it. Maybe a dozen of lines of code, and no more than that. Much simpler, and easier to understand, than what you've shown here. Your existing logic (obtaining the file size, obtaining the size of the first row, then dividing one by the other) is very fragile. If, for some reason, the lines in the file have varying lengths (perhaps some of them have some trailing whitespace), your computed result will be completely off. With this, much simpler approach, it becomes much easier to handle this error situation, and still come up with some meaningful results.</p>
",4
43219187,43218692,1,"<p><a href=""http://en.cppreference.com/w/cpp/string/basic_string/getline"" rel=""nofollow noreferrer""><code>std::getline</code></a> does <strong>not</strong> add the delimiting character (the newline in your case) to the output string. Thus, none of those <code>std::string</code> of your <code>std::vector&lt;std::string&gt; course</code> contains a newline. Thus you need to output a newline yourself after writing each of those strings.</p>

<p>Then please note that the inner <code>for</code> loop is completely unnecessary. There's an overload/specialization of <code>operator&lt;&lt;</code> for <code>std::string</code>, thus you can simplify to:</p>

<pre><code>for (std::size_t i = 0; i &lt; course.size(); ++i) {
  std::cout &lt;&lt; course[i] &lt;&lt; std::endl; // or '\n' if you don't need flushing
}
</code></pre>

<hr>

<p>If you insist on the inner loop:</p>

<pre><code>for (std::size_t i = 0; i &lt; course.size(); i++) {
    for (std::size_t j = 0; j &lt; course[i].size(); j++) {
        std::cout &lt;&lt; course[i][j];
    }
    std::cout &lt;&lt; '\n';
}
</code></pre>

<p><a href=""http://ideone.com/Nk8XZ3"" rel=""nofollow noreferrer"">Live in action.</a></p>
",2
37298874,37298620,0,"<p>Something like this(I didn't run it):</p>

<pre><code>int Dictionary::processFilePhrases(string file) {
    vector&lt;string&gt; wordList;
    string word;
    ifstream fin;
    fin.open(file.c_str());

    while (fin &gt;&gt; word) {
        wordList.push_back(word);
    }
    fin.close();

    for (int i=0; i&lt;wordList.size(); i++){
        string phrase;
        for (int j = i; j &lt; i + 3 &amp;&amp; j &lt; wordList.size(); ++j) {
            phrase += wordList[j] + "" "";
            cout &lt;&lt; phrase &lt;&lt; endl;
        }
        cout &lt;&lt; phrase &lt;&lt; endl;

    }
    return wordCount;
}
</code></pre>
",0
37298785,37298620,1,"<p>Well the ""concatenating"" loop runs once over all the words you got, so that's why you get all the words.</p>

<p>The way you describe the wanted output, it seems like you want <em>two</em> loops, nested inside each other, where the inner loops from one to n, and where n is the current value from the outer loop.</p>

<p>Perhaps something like</p>

<pre><code>for (unsigned i = 0; i &lt; wordList.size(); ++i)
{
    std::string phrase;

    for (unsigned j = 0; j &lt;= i; ++j)
    {
        phrase += wordList[j];
        phrase += ' ';  // Spacing between words
    }

    std::cout &lt;&lt; phrase &lt;&lt; '\n';
}
</code></pre>

<p>If we now step through the code above, in the first iteration of the outer loop, <code>i</code> is equal to zero. In the inner loop we loop while <code>j</code> is less than or equal to <code>i</code> (which now is zero), which means the inner loop will iterate only once, making <code>phrase</code> equal to the string <code>""The ""</code> (with the input you have given in the question).</p>

<p>Once the inner loop finishes the phrase is printed, and the outer loop iterates, which makes <code>i</code> equal to one. The inner loop now iterates two times (for <code>j</code> being zero and one) constructing the phrase <code>""The next ""</code>.</p>

<hr>

<p>Of course this doesn't <em>exactly</em> do what you want, printing only up to three words at a time, and starting with the next word after the three first words have been printed. You probably need yet <em>another</em> loop, to handle the one to three counting. The above is a starting point though, and I suggest you experiment with that, and other loops outside the outer, in between, and as a new inner loop. Experimentation and failure is how you learn.</p>
",0
43175531,43173806,0,"<p>Your returning by value in your dereference operator, creating a copy, which means that the value that has the multiply assigned to is a different instance for each assignment and is not the iterator instance.</p>
",0
43214510,43213985,-1,"<p>Here is a simple code to get you started.  Of course there is no checking here to see if the user is inputting correct format, so you can get a runtime error.  I also haven't provided a way out of the loop because I don't know what you need the string to look like to know that you're done collecting strings.  It also just throws the integers in a vector.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;int&gt; nums;
    std::string str;
    while (std::cin &gt;&gt; str)
        {
        int num = std::stoi(str);
        nums.push_back(num);
        }
    return 0;
}
</code></pre>
",0
43218960,43213985,0,"<p>Got a way out thanks to everyone </p>

<p>Would have put the code up but can't actually get indenting on stack right. Because I'm actually new to stack so I'm  going to skip putting up the code anyway I used the string to integer function I noticed it was my compiler that was giving me the problem @first because it doesn't support C++11 library functions, it's an outdated compiler I'm guessing C++99. </p>

<p>Anyway thanks to everyone.</p>
",0
46028252,46028204,1,"<p>The closest thing I can think of is using a <a href=""http://en.cppreference.com/w/cpp/container/map"" rel=""nofollow noreferrer""><code>std::map&lt;char,char&gt;</code></a> to do that:</p>

<pre><code> std::map&lt;char,char&gt; Letter {
        { '.' , 'E' } ,
        { '$' , 'S' } ,
        // ...
     };
 auto found_translation = Letter.find('.');
 if(found_translation != std::end(Letter)) {
     // Do stuff using found_translation-&gt;second 
 }
</code></pre>

<p>or like <a href=""https://stackoverflow.com/questions/46028204/could-you-tell-any-function-from-standard-library-or-anwhere-else-which-finds-u#comment79016456_46028204"">@cdhowie proposed</a>:</p>

<pre><code>std::string input;
std::cin &gt;&gt; input;
std::transform(input.begin(), input.end(), input.begin(),
               [Letter](char c) -&gt; char {  
                   return Letter.find(c) != std::end(Letter) ? Letter[c] : c;
               });
</code></pre>
",0
46937839,46937796,0,"<p>It's completely normal, as far as I understand.<br>
The program is executed, and once finished it's closed.<br>
If you want to see the results execute the program from an existing CMD.  </p>

<pre><code>C:/location&gt; program.exe
</code></pre>
",2
46937870,46937796,0,"<p>Did you try running without debugging? Try hitting ctrl + f5 if you're in visual studio and the command should stay opened when your code finishes.</p>
",0
46982195,46982078,1,"<p>your implemented if-condition is just checking if the condition fails for any of the elements in the second set and so takes action. However, according to your discription, you want it to check the comparision to all elements of the second set before you take action:</p>

<pre><code>for (auto iter=set1.begin(); ...) {
  bool equal_toany = False;
  for (auto iter1=set2.begin(); ...) {
     if (*iter == *iter1) {
        equal_toany = True;
        break;
     }
   }
   if (!equal_toany) {
     dostuff() // B[*iter -1] =1
   }
}
</code></pre>
",2
46982268,46982078,2,"<blockquote>
  <p>I have and 2 sets. I want to pick one element from the first set and compare it with all elements of the second set, and if it is not equal to non of them, do some thing!</p>
</blockquote>

<p>What you are looking for is called <a href=""http://en.cppreference.com/w/cpp/algorithm/set_difference"" rel=""nofollow noreferrer""><code>std::set_difference</code></a> (as long as your containers are sorted and <code>std::set</code> is a sorted container, of course).</p>

<p>Just get rid of your loops, invoke the function above and find the elements that are in the first set and are not in the second one, then iterate them.<br>
Complexity should be lower than the one of your approach in almost all the real world cases (you have at most <code>2(N+M-1)</code> comparisons vs a fixed number of <code>N*M</code> comparisons, where <code>N</code> is the size of the first set, <code>M</code> is the size of the second set).<br>
The drawback is that it requires to allocate memory to store aside the elements to iterate. If it's a price you can pay mostly depends on the real problem, it's hard to say.</p>
",0
46982512,46982078,1,"<p>Use <a href=""http://www.cplusplus.com/reference/set/set/find/"" rel=""nofollow noreferrer""><code>std::set::find()</code></a> to tell if a value is a member of a set:</p>

<pre><code>for (auto iter = Y.begin(); iter != Y.end(); iter++) {
    if (X.find(*iter) != X.end())
        B[*iter1 - 1] = 1;
    }
}
</code></pre>
",0
43191612,43191520,0,"<p>You can do it like this:</p>

<pre><code>ifstream infile {name + ¡°.txt¡±};
string password;
infile &gt;&gt; password;
</code></pre>
",1
44354071,44354049,2,"<p>You forgot to initialize the bool array:</p>

<pre><code>bool theChars[128] = {};
</code></pre>

<p>The empty initializer means ""use the default value"" which is zero, aka false for bool.</p>

<p>P.S. Your code produces undefined behavior if you have any character outside [0, 127].  You could fix this by making <code>theChars</code> 256 long and casting the character to <code>uint8_t</code> before indexing.  Or use <code>std::array&lt;char, 128&gt;</code> and <code>theChars.at(loc)</code> to throw an exception if out of bounds.</p>
",0
44354195,44354049,1,"<p>easier way is use <code>set</code>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;set&gt;
using namespace std;
bool isUnique(string str) {
    set&lt;char&gt;st(str.begin(),str.end());
    if(st.size()==str.size())
        return true;
    return false;
}

int main() {

    string timmy = ""abcdefghijklmnop"";
    cout &lt;&lt; boolalpha&lt;&lt;isUnique(timmy)&lt;&lt;endl;
    timmy = ""aaaaabbbcdefghijklmnop"";
    cout &lt;&lt; boolalpha&lt;&lt;isUnique(timmy)&lt;&lt;endl;
    return 0;
}
</code></pre>

<p>p.s. if not use <code>boolalpha</code>, it will print 1 for <code>true</code> and 0 for <code>false</code>.</p>
",2
44357782,44354049,0,"<pre><code>std::sort(str.begin(), str.end());
return std::adjacent_find(str.begin(), str.end()) == str.end();
</code></pre>

<p>This doesn't use any additional space, and works for any character encoding.</p>
",0
41680826,41680812,9,"<p>The following line declares an <code>int</code> that happens to be called <code>cout</code> (it is not the <code>std::cout</code> stream)</p>

<pre><code>int cout = 5;
</code></pre>

<p>The <code>&lt;&lt;</code> operator peforms a bit shift.</p>

<p>So </p>

<pre><code>cout &lt;&lt; cout;
</code></pre>

<p>is only performing a bit shift and not storing the result.</p>

<hr>

<p>To clarify, have a look at the following program:</p>

<pre><code>#include&lt;iostream&gt;

int main()
{
    int cout = 5;
    auto shiftedval = cout &lt;&lt; cout;
    std::cout &lt;&lt; ""cout's value is "" &lt;&lt; cout &lt;&lt; "", and the result of the bit shift is "" &lt;&lt; shiftedval &lt;&lt; '\n';

    return 0;
}
</code></pre>

<p>It will output:</p>

<pre><code>cout's value is 5, and the result of the bit shift is 160
</code></pre>

<hr>

<p>What is happening behind the scenes is that <code>operator&lt;&lt;</code> <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt2"" rel=""nofollow noreferrer"">has been overloaded</a> to take an <code>ostream</code> on the left hand side. </p>

<p>By including <code>iostream</code> you get this function and the compiler will know what you mean if you have an <code>ostream</code> to the left of the <code>&lt;&lt;</code> operator.</p>

<p>Without a library the <code>&lt;&lt;</code> would just simply have been a <a href=""http://en.cppreference.com/w/cpp/language/operator_arithmetic#Bitwise_shift_operators"" rel=""nofollow noreferrer"">bitwise shift operator</a>.</p>

<hr>

<p>Also note that if you had <a href=""https://stackoverflow.com/q/1452721/1460794"">ill-advisedly</a> included <code>using namespace std;</code> or <code>using std::cout</code> then <code>cout</code> would then mean <code>ostream</code> and <code>&lt;&lt;</code> would trigger a call to the library <code>operator&lt;&lt;</code> function. If after adding the <code>using</code> declaration above you include another declaration of <code>cout</code> the newly declared name <a href=""https://stackoverflow.com/a/35895314/1460794"">will hide</a> the previous declaration and <code>cout</code> will now be considered an <code>int</code> again and we're back to the bit shift operator functionality being used.</p>

<p>Example:</p>

<pre><code>#include&lt;iostream&gt;

using namespace std; // using std:: at global scope

int main()
{
    int cout = 5;
    auto shiftedval = cout &lt;&lt; cout;

    //the following will not compile, cout is an int:
    cout &lt;&lt; ""cout's value is "" &lt;&lt; cout &lt;&lt; "", and the result of the bit shift is "" &lt;&lt; shiftedval &lt;&lt; '\n';

    //but we can get the cout from the global scope and the following will compile
    ::cout &lt;&lt; ""cout's value is "" &lt;&lt; cout &lt;&lt; "", and the result of the bit shift is "" &lt;&lt; shiftedval &lt;&lt; '\n';

    return 0;
}
</code></pre>
",1
41680897,41680812,3,"<p>You are naming your variable <code>cout</code>, which you are confusing with <code>std::cout</code>. Your example preforms a <a href=""http://en.cppreference.com/w/cpp/language/operator_arithmetic#Bitwise_shift_operators"" rel=""nofollow noreferrer"">bit shift operation</a>. Try this instead :</p>

<pre><code>int main()
{
    int cout = 5;   
    std::cout &lt;&lt; cout;

    return 0;
}
</code></pre>

<p>Better yet, name your variable anything else to avoid the confusion :</p>

<pre><code>int main()
{
    int foo = 5;   
    std::cout &lt;&lt; foo;

    return 0;
}
</code></pre>
",0
41681261,41680812,1,"<p>If you don't explicitly declare the <code>std</code> namespace, either by including <code>using namespace std;</code> in your code or calling <code>std::cout</code> then <code>cout</code> resolves to the local variable <code>cout</code> in your <code>main()</code> function.</p>

<p>Even if you <em>do</em> declare <code>using namespace std;</code> <code>cout</code> will still resolve to the local variable instead - this is one reason why a lot of people, books, and tutorials will recommend that you explicitly write <code>std::whatever</code> instead of using the namespace.</p>
",0
43191992,43191879,0,"<p>(edit:: added some explanation)</p>

<p>I can't know what exactly your teacher wanted, but it might be something like this:</p>

<pre><code>void foo(float a, float b){
    return a+4*b;
}
</code></pre>

<p>Allowing your calculator to use a function like that would work in the following way:</p>

<pre><code>... //Your previous code here

switch(op){

    ... // Your other switches here

    case 'f':
        cout&lt;&lt;foo(num1,num2)&lt;&lt;endl;
    break;
}

... //Your following code here
</code></pre>

<p>The 'f' here stands for the command ""EXECUTE PREDEFINED FUNCTION"" instead of '+' for ""ADD"" or '-' for ""SUBTRACT"".
That way you could have a predefined function and execute that on your numbers.</p>

<p>In this case we would see the entred number num1 be added to four times the entered number num2</p>

<p>I hope it helped :)</p>
",3
43192115,43191879,0,"<p>these function are in library <code>#include&lt;math.h&gt;</code> You need to use this header file in order to use those function in your code . 
It includes predefined functions such as </p>

<pre><code>sqrt(number);
</code></pre>

<p>This function is used to find square root of the argument passed to this function.</p>

<pre><code>pow(number);
</code></pre>

<p>This is used to find the power of the given number.</p>

<pre><code>trunc(number);
</code></pre>

<p>This function truncates the decimal value from floating point value and returns integer value</p>
",2
47972126,47972121,3,"<p>Constructing <code>A</code> requires all of <code>A</code>'s data members to be constructed. In this case, <code>B</code> must be default-constructed as you did not provide a member initialization list. As <code>B</code> defines a non-default constructor, generation of its implicit default constructor is suppressed - that's why you're getting the error.</p>
",0
47972154,47972121,1,"<p>When class <code>A</code> contains an instance of class <code>B</code>, constructing an instance of <code>A</code> also requires construction of the contained instance of <code>B</code>.</p>

<p>If no constructor of <code>B</code> is listed in the initialiser of class <code>A</code>, the default is to invoke a constructor of <code>B</code> that accepts no arguments.  For example</p>

<pre><code> class A
 {
     public:
      A::A() {};

     private:

       B b;
 };
</code></pre>

<p>is functionally equivalent to</p>

<pre><code> class A
 {
     public:
      A::A() : b() {};

     private:

       B b;
 };
</code></pre>

<p>This involves a constructor of <code>B</code> with no arguments.   If no such constructor exists, the result is a diagnostic (error message).   Since you have declared/defined a constructor with arguments, a constructor for <code>B</code> with no arguments is not implicitly generated.</p>
",0
43747134,43747070,2,"<ul>
<li>In <code>main</code>, you created an uninitialised variable named <code>enemyHealth</code>, and passed it to a function.</li>
<li>Then, in that function, you gave the resulting <em>copy</em> a value. Then you returned from the function.</li>
<li>Back in <code>main</code>, you're using the old, uninitialised variable again.</li>
<li>Then, you pass it to another function, which attempts to read the value.<br>
However, that value is <strong>indeterminate</strong> because, contrary to your belief, you never set it!</li>
</ul>

<p>I think perhaps you intended to pass by reference instead, so it's just the one variable at all times.</p>

<p>This is actually a compiler <em>warning</em> that's been promoted to an error by some setting. But that's good!</p>

<p>By the way, indenting your code will make it so that we can read it without sacrificing life expectancy.</p>
",3
43747695,43747591,1,"<p>The problem is in your check function. <br/></p>

<p>if(sqrt(tempspot) * sqrt(tempspot) == tempspot) is always true <br/>
Therefore when the condition of being equal to 11,22,... is not met the program will always return perfect square. <br/></p>
",4
43747878,43747591,0,"<p>your problem is that you're passing ""message"" into the function as a reference. That reference was only ever changed if one of the conditions were true, it wasn't being set to """" in case they were all false. If both checks were false you were doing return """"; but the return value is discarded so it wasn't relevant.</p>

<p>One quick fix is to make sure a blank message is stored in the default case. You could optionally get rid of the return value in that case, since you only need pass by reference OR getting a return value, you don't need both.</p>

<pre><code>void check(int tempspot, string &amp;message)
{

    if(tempspot == 11 || tempspot == 22 || tempspot == 33 || tempspot == 44 || tempspot == 55 || tempspot == 66 || tempspot == 77 || tempspot == 88 || tempspot == 99) {

        message = ""go to jail"";
    }

    else if(sqrt(tempspot) * sqrt(tempspot) == tempspot) {
        message = ""perfect square"";
    }
    else
    { 
        message = """"; // this line was missing
    }
}
</code></pre>

<p>Another better idea might be to remove the pass by reference altogether and use the return value. You only need one or the other, and using the return value is clearer on the client side of the function:</p>

<pre><code>string check(int tempspot)
{
    string message; // string for message is now local to function

    if(tempspot == 11 || tempspot == 22 || tempspot == 33 || tempspot == 44 || tempspot == 55 || tempspot == 66 || tempspot == 77 || tempspot == 88 || tempspot == 99) {

        message = ""go to jail"";
    }

    else if(sqrt(tempspot) * sqrt(tempspot) == tempspot) {
        message = ""perfect square"";
    }
    else
    { 
        message = """";
    }

    return message; // only return once in this spot, cleaner
}
</code></pre>

<p>Usage changes to:</p>

<pre><code>message = check(num);
</code></pre>
",0
43748092,43747591,0,"<p>Since I could not comment on existing post due to low reputation, I'm posting here in an effort to resolve the issue Tiago pointed out.</p>

<blockquote>
  <p>A perfect square is an integer that can be expressed as the product of two equal integers. For example, <strong>100</strong> is a perfect square because it is equal to <strong>10x10</strong>. If <strong>N</strong> is an any integer, then <strong>NxN</strong> is a perfect square.</p>
</blockquote>

<p>Thereby, to check for perfect squares, checking if the result of an <code>sqrt(tempspot)</code> call is integer should be enough. Try typecasting the <code>sqrt()</code> call to integer (checking 
<code>
(int)sqrt(tempspot) == sqrt(tempspot)
</code></p>

<p>should be enough and give the expected result)</p>
",0
36760311,36760063,2,"<p>It's not true the code 'doesn't work'. Of course it works, just as it is written. The problem is you wrote something different from what you need.</p>

<p>when you pass an argument to <code>insertRec()</code>, the routine gets a <em>copy</em> of a pointer to the <code>Node</code> object. So when you assign a value in</p>

<pre><code>    current = new Node(key);
</code></pre>

<p>you overwrite a <em>local copy</em> in the local variable <code>current</code>. The calling function (and its data) do not know about it.</p>

<p>If you want the caller to recieve the new value, declare a function takes <strong><a href=""http://en.cppreference.com/w/cpp/language/reference"" rel=""nofollow"">a reference</a></strong> to a variable:</p>

<pre><code>void insertRec(int key, Node *&amp;current)
</code></pre>
",2
43207637,43206836,0,"<p><strong>Solution I ended up using after ADT implementation</strong>:</p>

<pre><code>  void readCourse(std::istream&amp; fin) {
        std::vector&lt;std::string&gt; level
        std::string line;
        while(std::getline(fin, line) {
            level.push_back(line);
        }            

        for (std::size_t i = 0; i &lt; 3; i++) {
            for (std::size_t j = 0; j &lt; 7; j++) {
                std::cout &lt;&lt; data[i][j];
            }
            std::cout &lt;&lt; std::endl;
        }
    }
</code></pre>
",1
43207899,43206836,0,"<p>I'd keep it simple and efficient with a single <code>vector&lt;char&gt;</code>:</p>

<pre><code>vector&lt;char&gt; readCourse(istream&amp; fin) {
    vector&lt;char&gt; course(3*(7+2)); // 3x7 plus newlines
    fin.read(course.data(), course.size());
    course.resize(fin.gcount());
    auto end = remove(course.begin(), course.end(), '\n');
    end = remove(course.begin(), end, '\r');
    course.erase(end, course.end()); // purge all \n and \r
    return course;
}
</code></pre>

<p>That's a single input operation to get all the data, followed by removing the characters you don't need.  You can then access the result in a 2D way like this:</p>

<pre><code>course.at(x + y*7) // assuming width 7
</code></pre>

<p>That may seem a bit inconvenient, but it is efficient and compact--the overhead is always three pointers and a single heap allocation, instead of being proportional to the number of rows.</p>
",0
43958267,43958186,1,"<blockquote>
  <p>I don't see why I can't assign a value here, is it because the vector does not contain any elements yet?</p>
</blockquote>

<p>That's exactly your problem. The vector is empty, and doesn't contain any elements yet. So you can't assign any particular element in your vector with a value.</p>

<p>You have a misconception how <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow noreferrer""><code>std::vector</code></a> actually works. You can't create arbitrary positions there using the <code>operator[]()</code> or <code>at()</code> functions, these need to be there already when those functions are called.</p>
",0
43926112,43925953,0,"<p>As people suggested, you can add another do-while loop to repeat the game.</p>

<pre><code>int choice = 0;

do {
  // first part of code..

  do { 
     // inner do-while
  } while (inputtedGuess != selectedNumber);

  std::cout &lt;&lt; ""\nCongratulations! You solved it in "" &lt;&lt; numberOfTries &lt;&lt; "" tries!\n"" std::endl; 

  cout &lt;&lt; ""\nWould you like to play again?\n\n"";
  cout &lt;&lt; ""1 - Yes\n"";
  cout &lt;&lt; ""2 - No\n\n"";

  cout &lt;&lt; ""Choice: "";
  cin &gt;&gt; choice;

} while(choice == 1);
</code></pre>
",1
43926531,43925953,1,"<p>The last line of your output should actually be printed. The reason why the last line ""is not printed"" is probably that your IDE closes the console before you can see the final output (though it should be there). Many IDEs allow to make the console visible after program termination. BTW: Note that when pasting the code you probably lost a <code>&lt;&lt;</code> before <code>std::endl</code> in <code>std::cout &lt;&lt; ""\nCongratulations! You solved it in "" &lt;&lt; numberOfTries &lt;&lt; "" tries!\n"" std::endl;</code> But this has actually to be a copy-paste problem, because your program would not have compiled otherwise.</p>

<p>Anyway, by providing a ""Try again?""-logic, your program does not terminate and the problem is solved.</p>

<p>I'd suggest to provide a separate function performing the guess, which is then called in a do-while loop with the <code>""Try again=""</code>-question.</p>

<pre><code>void guess() {
   // your code (except srand) goes here...
}

int main() {

    srand(time(0));  //Seed the random number generator only once

    char doAgain;
    do {
        guess();
        cout &lt;&lt; ""Try again (Y/N)?"";
        cin &gt;&gt; doAgain;
    }
    while (toupper(doAgain)=='Y');
    return 0;
}
</code></pre>
",1
37340970,37336119,1,"<p>The <code>graphics.h</code> is ancient <strong>BGI</strong> lib from <strong>Borland</strong> I found this doc:</p>

<ul>
<li><a href=""https://www.cs.colorado.edu/~main/bgi/doc/getimage.html"" rel=""nofollow noreferrer"">getimage</a></li>
</ul>

<p>So this just copies image from your screen to some memory buffer (to allow back buffering techniques). You are calling it with <code>ifstream</code> that is wrong. You are overwriting the pointer with the memory buffer or the area where its pointer points to (depends on the <code>getimage</code> behavior). If you really want to use <strong>BGI</strong> for this then decode the image to memory and use <code>putimage</code> to view it. But I am afraid it is not encoded in RAW and safer would be draw the image directly with pixel access instead.</p>

<p>As I wrote to your other question You need to use some lib or code the image decoding your self. <code>iostream</code> is not a good way for this. </p>

<p>For <strong>MS-DOS</strong> use <strong>OS</strong> api (<code>int 21h</code> if you do not have functions covering it properly) ... for <strong>Windows</strong> and <strong>Borland</strong> environment use <code>FileOpen FileRead FileClose</code>. For non Borland environment use WinAPI or relevant <strong>API</strong> from target <strong>OS</strong> (if not windows). To decode image you first need to chose file-format to decode I recommend to start with <strong>PCX,BMP</strong> (restricted to single pixelformat) or <strong>TGA</strong>. Fileformats like <strong>JPG,PNG,GIF</strong> are really too much for a rookie coder to start with. For example My <strong>GIF</strong> decoder/encoder in C++ is about <code>36 KByte</code> of source code + another <code>15 KBytes</code> for file <strong>CACHE</strong> buffering and <strong>multi-threaded RT</strong> encoding scheduler. In comparison to <strong>PCX</strong> with around <code>1.5KByte</code> of code to load/decode it.</p>

<p>This is small example of how I load textures into my GL engine in <strong>Borland/Embarcadero VCL C++ Windows</strong>:</p>

<pre><code>int picture_load(Graphics::TBitmap *bmp,AnsiString name,int *_alpha)
    {
    if (bmp==NULL)        { _errorlog+=""picture_load bmp is NULL\n""; return 0; }
    if (!FileExists(name)){ _errorlog+=""picture_load file \""""+name+""\"" dont exist\n""; return 0; }
    bmp-&gt;HandleType=bmDIB;
    bmp-&gt;PixelFormat=pf32bit;
    AnsiString ext=ExtractFileExt(name).LowerCase();
    for(;;)
        {
        if (ext=="".bmp"")
            {
            bmp-&gt;LoadFromFile(name);
            break;
            }
        if (ext=="".jpg"")
            {
            TJPEGImage *jpg=new TJPEGImage;
            #ifdef _mmap_h
            if (jpg) mmap_new('GL',jpg,sizeof(TJPEGImage));
            #endif
            if (jpg==NULL) { _errorlog+=""picture_load not enough memory\n""; return 0; }
            jpg-&gt;LoadFromFile(name);
            bmp-&gt;Assign(jpg);
            #ifdef _mmap_h
            mmap_del('GL',jpg);
            #endif
            delete jpg;
            break;
            }
        if (ext=="".png"")
            {
            TPNGObject *png=new TPNGObject;
            #ifdef _mmap_h
            if (png) mmap_new('GL',png,sizeof(TJPEGImage));
            #endif
            if (png==NULL) { _errorlog+=""picture_load not enough memory\n""; return 0; }
            png-&gt;LoadFromFile(name);
            bmp-&gt;Assign(png);
            #ifdef _mmap_h
            mmap_del('GL',png);
            #endif
            delete png;
            break;
            }
        if ((ext=="".sgi"")||(ext=="".rgb""))
            {
            sgi sss;
            sss.load(name);
            bmp-&gt;Width=sss.rgba-&gt;Width;
            bmp-&gt;Height=sss.rgba-&gt;Height;
            bmp-&gt;Canvas-&gt;Draw(0,0,sss.rgba);
            break;
            }
        if (ext=="".pcx"")
            {
            unsigned int *p,c;
            int     x,y,adr;
            int hnd,siz,l,xs,ys;
            unsigned int pal[256],r,g,b;
            Byte *dat;
            for(;;)
                {
                hnd=FileOpen(name,fmOpenRead);
                if (hnd&lt;0) { _errorlog+=""picture_load file \""""+name+""\"" dont exist\n""; return 0; }
                siz=FileSeek(hnd,0,2);
                FileSeek(hnd,0,0);
                dat=new Byte[siz];
                #ifdef _mmap_h
                if (dat) mmap_new('GL',dat,siz*sizeof(BYTE));
                #endif
                if (dat==NULL) { FileClose(hnd); _errorlog+=""picture_load not enough memory\n""; return 0; }
                FileRead(hnd,dat,siz);
                FileClose(hnd);
                adr=siz-3*256;
                for (l=0;l&lt;256;l++)
                    {
                    r=dat[adr]; adr++; r&amp;=255;
                    g=dat[adr]; adr++; g&amp;=255;
                    b=dat[adr]; adr++; b&amp;=255;
                    c=(r&lt;&lt;16)|(g&lt;&lt;8)|(b);
                    c&amp;=0x00FFFFFF;
                    pal[l]=c;
                    }
                xs=int(dat[ 8])-int(dat[4])+((int(dat[ 9])-int(dat[5]))&lt;&lt;8)+1;
                ys=int(dat[10])-int(dat[6])+((int(dat[11])-int(dat[7]))&lt;&lt;8)+1;

                bmp-&gt;HandleType=bmDIB;
                bmp-&gt;PixelFormat=pf32bit;
                bmp-&gt;Width=xs;
                bmp-&gt;Height=ys;
                xs=bmp-&gt;Width;
                ys=bmp-&gt;Height;

                adr=128;
                for (y=0;y&lt;ys;y++)
                    {
                    p=(unsigned int*)bmp-&gt;ScanLine[y];
                    for (x=0;x&lt;xs;)
                        {
                        c=dat[adr];
                        if (c&lt;192) l=1;
                        else{
                            l=c&amp;63;
                            adr++;
                            c=dat[adr];
                            }
                        adr++;
                        for (;l&gt;0;l--)
                            {
                            if (x&gt;=xs) break;
                            p[x]=pal[c];
                            x++;
                            }
                        }
                    }
                #ifdef _mmap_h
                mmap_del('GL',dat);
                #endif
                delete[] dat;
                break;
                }
            break;
            }
        if (ext=="".dds"")
            {
            DDS::load(bmp,name);
            _errorlog+=DDS::_errorlog;
            DDS::_errorlog="""";
            break;
            }
        _errorlog+=""picture_load unsuported file extension \""""+ext+""\""\n"";
        return 0;
        }
    bmp-&gt;HandleType=bmDIB;
    if (_alpha) _alpha[0]=(bmp-&gt;PixelFormat==pf32bit);
    bmp-&gt;PixelFormat=pf32bit;
    return 1;
    }
</code></pre>

<p>As your code looks like you are in <strong>MS-DOS</strong> this will not work. but you can extract the <strong>PCX</strong> part which does not use any lib. Just port the code (replace <code>AnsiString</code> and File access with the functions you have at disposal)</p>

<p>The <code>Graphics::TBitmap</code> is <strong>VCL/GDI</strong> bitmap to understand its use see:</p>

<ul>
<li><a href=""https://stackoverflow.com/a/21699076/2521214"">Display an array of color in C</a></li>
</ul>

<p>So you can port this to your <strong>BGI</strong>. Also you can ignore all the <code>#ifdef _mmap_h</code> stuff it is just leftover from memory leak tracking/debugging related to this:</p>

<ul>
<li><a href=""https://stackoverflow.com/a/20565511/2521214"">traceback a pointer in c++ code gdb</a></li>
<li><a href=""https://stackoverflow.com/a/18016392/2521214"">bds 2006 C hidden memory manager conflicts</a></li>
</ul>

<p>And look here <a href=""https://www.daubnet.com/en/file-format-pcx"" rel=""nofollow noreferrer"">PCX file-format specification</a></p>
",0
37341502,37336119,2,"<p>This:</p>

<pre><code>ifstream image(""bg.png"");
</code></pre>

<p>&hellip; opens the file in <strong>text mode</strong>, where, in Windows and on old Macs, certain byte sequences denoting end-of-line and end-of-text, are changed on input and output.</p>

<p>You don't want that.</p>

<p><a href=""http://en.cppreference.com/w/cpp/io/basic_ifstream/basic_ifstream"" rel=""nofollow"">Specify <strong>binary mode</strong></a>.</p>

<hr>

<p>That said, the closest you get to &ldquo;standard&rdquo; image handling in C++ is the <a href=""http://www.boost.org/doc/libs/1_61_0/libs/gil/doc/index.html"" rel=""nofollow"">Boost Image library</a>.</p>
",1
43949018,43948775,0,"<ul>
<li>At <code>MiniVend.hpp</code> your buySnack does not take any parameters <code>void buySnack();</code>, but at Minivend.cpp you are defining an argument at your        function header 
<code>void MiniVend::buySnack(int slot);</code>, and you shouldn't be using an semicolon too.</li>
<li><p>Your MiniVend.cpp file should also include the <code>""MiniVend.hpp""</code> header as well.</p></li>
<li><p>At MiniVend.cpp in the declaration of function <code>int MiniVend::numEmptySlots()</code> <code>vs0</code> is not defined anywhere in the code as well as <code>slots</code></p></li>
<li><p>At you main function you are trying to declare this <code>VendSlot groucho(s1, 2);</code>, but you have not defined <code>s1</code> anywhere in your main function</p></li>
</ul>

<p>That's what I have found so far. Hope this helps and please use comments when posting a question so that everyone can understand the purpose of the code.</p>
",0
36838328,36838049,0,"<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

int main()
{

    int age; //Declares the variable ""age""
    string name;
    string course;


    cout &lt;&lt; ""Hi\n""; //Prints out ""Hello World""
    cout &lt;&lt; ""What is your name? "";
        getline(cin, name);
    while(true) {
        cout &lt;&lt; ""\nHow old are you ? "";  //Ask the user their age
        cin &gt;&gt; age; //Records the value entered by user
        if(age&gt;=0)
            break;
        cout &lt;&lt; ""\nYou can't be younger than 0 years old.\nPlease try again."";
    } 
    cout &lt;&lt; ""What course are you picking up in university ? "";
        getline(cin, course);

    //If number entered is larger than 100, print the following message
    if (age &gt; 100) {
        cout &lt;&lt; ""\nYou are such a blessed person !\n\n"";
    }

    //If number entered is between 1 and 99, print the following message
    if (age &gt; 1 &amp;&amp; age &lt; 99) {
        cout &lt;&lt; ""Your name is "" &lt;&lt; name &lt;&lt; "" ,and you are "" &lt;&lt; age &lt;&lt; "" years old."";
        cout &lt;&lt; ""\n You are planning on taking "" &lt;&lt; course &lt;&lt; "" in university."";
    }

    return 0;
}
</code></pre>
",0
36838916,36838049,1,"<p>If <code>getline()</code> is used after <code>cin &gt;&gt;</code>, the <code>getline()</code> sees this newline character as leading whitespace, and it just stops reading any further.</p>

<p>Solution:</p>

<ul>
<li>Call <code>cin.ignore()</code> before calling <code>getline()</code></li>
</ul>

<p>Or</p>

<ul>
<li>Make a dummy call <code>getline()</code> to consume the trailing newline character from the <code>cin&gt;&gt;</code></li>
</ul>
",0
45111525,45111470,6,"<p>Those expressions are being evaluated in a boolean context.  </p>

<p>Here, a value of 0 (or NULL) is false, while any non-zero (or non-null) value is true.</p>

<p>So the above is equivalent to:</p>

<pre><code>if (whereto != 0)
if (nE == 0)
for (cur=first; cur != NULL; cur=cur-&gt;next)
if (del-&gt;prev != NULL)
</code></pre>
",4
45283456,45283060,1,"<p>You're not not using <code>alignof</code> in the right way.</p>

<pre><code>#include &lt;iostream&gt;

int main(){
    std:: cout&lt;&lt; sizeof(int) &lt;&lt; ' ' &lt;&lt; alignof(int) &lt;&lt; '\n'; //This is how to use it.
    return 0;
}
</code></pre>

<p>Typical output:</p>

<pre><code>4 4
</code></pre>

<p>Size and alignment varies from platform to platform but <code>sizeof(int)==alignof(int)</code> known as being 'fully aligned' is commonly required (or just best performance) on modern platforms.</p>

<p>Edit: It's been pointed out you don't need to <code>#include &lt;cstdalign&gt;</code> to use <code>alignof</code> but the other point remains. <code>#include &lt;stdalign.h&gt;</code> is not the recommended way to import C standard libraries and you should use the c-prefix model <code>#include &lt;cstdalign&gt;</code> where you do. </p>
",2
44731309,44731260,4,"<p>You only need one variable, to contain the maximum value.</p>

<pre><code>int maximum_value = std::numeric_limits&lt;int&gt;min();
for (size_t i = 0; i &lt; array_capacity; ++i)
{
  if (array[i] &gt; maximum_value)
  {
    maximum_value = array[i];
  }
}
</code></pre>

<p>See also <a href=""http://en.cppreference.com/w/cpp/algorithm/max_element"" rel=""nofollow noreferrer""><code>std::max_element</code></a>.</p>

<p><strong>Edit 1:  No additional variables, except loop index</strong>  </p>

<pre><code>for (size_t i = 1U; i &lt; array_capacity; ++i)
{
  if (array[i] &gt; array[0])
  {
    array[0] = array[i];
  }
}
</code></pre>
",4
44731439,44731260,2,"<p>When I got this question, in an interview, the interviewer disallowed sorting because it either alters the source array or forces you to sort into a temporary array. He balked at a looping variable (though he didn't object to tracking the size of the array - go figure). He also argued that there are better than O(n log n) solutions. So here's the O(n) solution to this dumb question.</p>

<pre><code>#include &lt;algorithm&gt;

int int_max(int * array, int size) {
  if (size == 1)
    return *array;

  return std::max(*array, int_max(array+1, size-1));
}
</code></pre>

<p>Under no circumstances, whatsoever, should anyone, ever, ever, ever, consider this to be a good idea. <strong>It answers a stupid interview question, and that's about it.</strong> You will blow the stack. Bad things will happen. And, just because I'm not declaring a variable doesn't mean I'm not generating one on the stack.</p>
",1
45729490,45728737,1,"<p>To count the number of occurrences of 1, 2 and 3 in a single integer value it would be easiest IMO to convert the integer into a string and then count the digits you are interested in:</p>

<pre><code>int countDigits(int number, std::string digitsOfInterest = ""123"") {
  int ret = 0;
  std::string numberAsString = std::to_string(number); // convert it to string
  for (const char&amp; digit : numberAsString) { // loop over every character
    if (digitsOfInterest.find(digit) != std::string::npos) {
      ret++;
    }
  }
  return ret;
}
</code></pre>

<p>Simply pass a randomly generated number into the function and add up the results. As you can see, by changing <code>digitsOfInterest</code> to another string, you can alter the digits you want to count.</p>

<p>PS.: Since I'm assuming that you have access to C++11 I would recommend to change your number generation to <a href=""http://www.cplusplus.com/reference/random/"" rel=""nofollow noreferrer""><code>&lt;random&gt;</code></a>.</p>

<hr>

<p>Here is a non C++11 solution which works the same way the above one does:</p>

<pre><code>int countDigits(int number, std::string digitsOfInterest = ""123"") {
  int ret = 0;
  std::ostringstream oss;
  oss &lt;&lt; number;
  std::string numberAsString = oss.str(); // convert it to string
  for (size_t i = 0; i &lt; numberAsString.size(); ++i) { // loop over every character
    if (digitsOfInterest.find(numberAsString[i]) != std::string::npos) {
      ret++;
    }
  }
  return ret;
}
</code></pre>

<p>Here is an example:</p>

<pre><code>std::cout &lt;&lt; ""This number: '1243' contains "" &lt;&lt; countDigits(1243) &lt;&lt; "" times a digit of 1,2 or 3\n"";
</code></pre>

<p>Result: This number: '1243' contains 3 times a digit of 1,2 or 3</p>
",2
45730665,45728737,0,"<p>I divided it to functions so it will be easier to understand.
I used switch case because that what you asked, but there are other ways as well.</p>

<pre><code>#include&lt;time.h&gt;
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;

// This function is the UI, i.e. asking the user how many numbers to generate
int HowManyNumbers()
{
    int input;
    std::cout &lt;&lt; ""Enter the number of time to loop"" &lt;&lt; std::endl;
    std::cin &gt;&gt; input;
    return input; 
}

// This function counts 1,2,3 for individual number 
int Count123InNum(int num)
{
        int count = 0;
        while(num)
        {
            int lastDig = num % 10;
            // count only if lastDigit in number is 1,2 or 3
            switch(lastDig)
            {
                case 1:
                case 2:
                case 3:
                    ++count;
                    break;

                default:
                    break;                          
            }
            num /= 10;
        }
        return count;
}

// This function receives number of random numbers to generate,
// and its output is a print of the numbers and the joint occurences of 1,2 and 3
void Get123FromRandomNums(int nRandNumbers)
{
    srand(time(NULL));
    std::cout &lt;&lt; ""In the numbers: "";
    int count = 0;

    while(nRandNumbers--)
    {
        int num = rand() % 10000;
        std::cout &lt;&lt; num &lt;&lt; "" "";
        count += Count123InNum(num);
    }
    std::cout &lt;&lt; ""There are "" &lt;&lt; count &lt;&lt; "" digits 1, digit 2, digit 3."" &lt;&lt; std::endl;
}

int main()
{
    // Get number of random numbers (i.e. iterations)
    int nRandNumbers = HowManyNumbers();

    // check validity
    if (nRandNumbers &lt; 0 || nRandNumbers &gt; 50)
    {
        std::cout &lt;&lt; ""Invalid entry"" &lt;&lt; std::endl;
    }
    else
    {
        //if valid, count and print 1,2,3 occurences
        Get123FromRandomNums(nRandNumbers);
    }
    return 0;
}
</code></pre>
",0
43746839,43746457,1,"<p>I know why nothing is stored in your <code>Rucksack</code></p>

<pre><code>int index(Loot x[], int n)
{
    int i = 0;
    int index;
    while (x[i].Name != ""empty"" &amp;&amp; 0 &amp;&amp; false &amp;&amp; i &lt; n)
    {
        i++;
        index = i;
        return index;
    }
    while (i == n)
    {
        cout &lt;&lt; ""BAG FULL"" &lt;&lt; endl;
    }
}
</code></pre>

<p>Take a careful look at this line:</p>

<pre><code>while (x[i].Name != ""empty"" &amp;&amp; 0 &amp;&amp; false &amp;&amp; i &lt; n)
</code></pre>

<p><code>&amp;&amp; 0 &amp;&amp; false</code>? Both <code>0</code> and <code>false</code> mean this is always false and the Rucksack will be reported as empty no matter what.</p>

<p>Then the code will fall out the bottom of <code>index()</code> without returning a value.
After that program behaviour is undefined because you use a return value that was not returned. Any craziness might come after that.</p>

<p>Fix that and come back with another question if you can't figure out your other problem.
It is currently a bit vague.</p>
",3
43730062,43729967,0,"<p>Perhaps you wanted to use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/getline"" rel=""nofollow noreferrer"">std::getline</a>?</p>

<pre><code>#include &lt;string&gt;
#include &lt;list&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;

using namespace std;

int main()
{
    ifstream file(""input.txt"");
    list&lt;string&gt; lines;
    string line;
    while (getline(file, lie)) {
        cout &lt;&lt; ""&gt; "" &lt;&lt; line &lt;&lt; endl;
        lines.push_back(line);
    }
}
</code></pre>

<p>If you wanted to use <a href=""http://man7.org/linux/man-pages/man3/getdelim.3.html"" rel=""nofollow noreferrer"">getline from linux</a> then it should be something like this:</p>

<pre><code>#define _GNU_SOURCE
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;list&gt;

using namespace std;

int main()
{
    FILE* file = fopen(""input.txt"");
    list&lt;string&gt; lines;
    char *line = NULL;
    size_t len = 0;
    ssize_t nread;
    while ((nread = getline(&amp;line, &amp;len, file)) != -1) {
        cout &lt;&lt; ""&gt; "" &lt;&lt; line &lt;&lt; endl;
        lines.push_back(string(line, nread));
    }
    free(line);
    fclose(stream);
}
</code></pre>
",0
47483307,47482619,0,"<p>The issue with your code is that <code>k</code> gets incremented <strong>post</strong> the assignment in the <code>x[]</code> array i.e. In the last iteration <code>k</code> gets incremented to <code>8</code>. Then in case of <code>k-i</code> when the value of <code>i</code> is 0 .. <code>x[k-i]</code> goes out of bounds.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

void base(int n,int b)
{
    int x[20],k=-1;
    while(n!=0)
    {
        x[++k]=n%b; //pre increment
        n=n/b;
    }
    for(int i=0;i&lt;=k; i++)//now k contains the index of the last element
    {
        cout&lt;&lt;x[k-i];
    }
    return ;
}

int main()
{
    int number,baise;
    cin&gt;&gt;number;
    cin&gt;&gt;baise;
    base(number,baise); 
    return 0;
}
</code></pre>
",0
47483336,47482619,0,"<pre><code>for(int i=0;i&lt;=k;i++)
{
    cout&lt;&lt;x[k-i];
}
</code></pre>

<p>At the first iteration of the loop, the executed statement is:</p>

<pre><code>cout &lt;&lt; x[k];
</code></pre>

<p>where <code>x[k]</code> is never assigned, which is an UB.</p>

<p>Changing the loop initialization statement to <code>x = 1</code> solves this problem. Or more clearly,</p>

<pre><code>for(int i = k-1; i &gt;= 0; i--)
{
    cout &lt;&lt; x[i];
}
</code></pre>
",0
43746877,43746761,1,"<p>If you can modify <code>BasePet</code> and its derived classes, the typical way is to create a <code>clone</code> method in <code>BasePet</code> and require that each derived class override it. Generally this looks like: </p>

<pre><code>/*
This is what BasePet::clone() would look like if you wrote it, but normally that would be pure virtual.    

BasePet *BasePet::clone() const
{
    return new BasePet(*this);
}
*/

BasePet *Dog::clone() const
{
    return new Dog(*this);
}

BasePet *Cat::clone() const
{
    return new Cat(*this);
}

// ... and so on ...
</code></pre>

<p>If you don't have access to the class implementations, my first recommendation would be to try and figure out a way to do what you're trying to do without copying the objects, due to the concerns you raised about new derived classes appearing, as well as the implementations of the classes changing in ways that might affect what the code needs to do. If there's absolutely no way around it, you'll need to use some form of run-time type identification (RTTI); I would use <code>typeid</code> rather than <code>dynamic_cast</code> so that you can test for an exact match and don't get tripped up if the derived class <code>D</code> Is itself the base class for another derived class <code>D2</code> that you didn't know about. </p>
",2
47467690,47467627,0,"<p>At that point, you are trying to access an element in position <code>i</code>, but the vector is initially empty. <code>vector</code> construction doesn't behave like old-style array, where you must specify the size and all those spaces are reserved in memory.</p>

<p>You must <strong>create</strong> your vector with size like so</p>

<pre><code>std::vector&lt;struct studentDatabase&gt; student(30);
getUserInput(student);
</code></pre>

<p>But if you don't know the size previously, i recommend you to get the input one by one and use <code>push_back()</code></p>
",0
47467720,47467627,1,"<p>The <code>std::vector&lt;studentDatabase&gt;</code> intially is a empty container. So when you access the <code>vector</code> via <code>vector::at(i)</code>, no item is found and <code>out_of_range</code> exception is thrown.</p>

<p>You may collect the data into a local <code>studentDatabase</code> variable first, then put it into vector, like:</p>

<pre><code>for (unsigned int i = 0; i &lt; noOfStudents; ++i)
{
    studentDatabase s;
    std::cout &lt;&lt; ""Enter name n"";
    std::cin &gt;&gt; s.name;

   std::cout &lt;&lt; ""Enter grade n"";
   std::cin &gt;&gt; s.grade;
   student.push_back(s);
}
</code></pre>
",0
47468098,47467627,0,"<p>Initially your vector is an empty container. so when you are trying to access the vector, it will throws an exception.</p>

<pre><code>void getUserInput(std::vector&lt;struct studentDatabase&gt; &amp;student)
{
    std::cout &lt;&lt; ""No of students for which the data is to be entered n"";
    int noOfStudents(0);
    std::cin &gt;&gt; noOfStudents;

    for (unsigned int i = 0; i &lt; noOfStudents; ++i)
    {
       studentDatabase stud;
       std::cout &lt;&lt; ""Enter name n"";
       std::cin &gt;&gt; student.name;       // this will get student name.

       std::cout &lt;&lt; ""Enter grade n"";
       std::cin &gt;&gt; student.grade;     // this will get student grade.

       student.push_back(stud);   // Here we are storing the data into vector.
   }
}
</code></pre>

<p>you need to store the data into vecotor to access them to avoid the exception.
Replace this code snippet with your code, your problem will be solved.</p>
",0
44337742,44337635,0,"<p>Works fine no issues - something else later tampers the o/p line since you don;t have '\n'</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;iostream&gt;

using namespace std;

int main(){
    int lengthRec, widthRec, areaRec;
    cout &lt;&lt; ""you entered 2 for Rectangle\n"";
    cout &lt;&lt; ""Enter the length of the Rectangle.\n"";
    cin &gt;&gt; lengthRec;

    cout &lt;&lt; ""Enter the width of the Rectangle.\n"";
    cin &gt;&gt; widthRec; //CHECK HERE

    areaRec = lengthRec * widthRec;
    cout &lt;&lt; areaRec&lt;&lt;""\n"";

    if ((lengthRec &gt; 0) &amp;&amp; (widthRec &gt; 0)) {

        areaRec = lengthRec * widthRec;
        cout &lt;&lt; ""\nlength is "" &lt;&lt; lengthRec &lt;&lt; ""\n""&lt;&lt; ""width is "" &lt;&lt; 
        widthRec &lt;&lt; ""\n"";
        cout &lt;&lt; ""The area is "";
        cout &lt;&lt; areaRec&lt;&lt;""\n""; //CHECK HERE
    }
    else {
        cout &lt;&lt; ""Invalid entry, Please re run with a positive number\n"";
    }
    return 0;
}
</code></pre>

<p>Output:-</p>

<pre><code>you entered 2 for Rectangle
Enter the length of the Rectangle.
Enter the width of the Rectangle.
9
length is 3
width is 3
The area is 9
</code></pre>
",2
47490904,47490884,1,"<p>Like this:</p>

<pre><code>#include &lt;fstream&gt;

std::ifstream infile(""thefile.txt"");
if (infile.is_open()) {
    float number;
    std::string str;
    char c;
    while (infile &gt;&gt; str &gt;&gt; c &gt;&gt; number &amp;&amp; c == ',')
        cout &lt;&lt; number &lt;&lt; "" "" &lt;&lt; str &lt;&lt; ""\n"";
}
infile.close();
</code></pre>
",1
44350601,44350579,-4,"<p>Try and do std::cout, it won't work. </p>

<p><code>using namespace std</code> just defines the namespace</p>

<p><code>#include {x}</code> 'includes' the code within the namespace</p>

<p>I.e, <code>std::cout</code> would need <code>#include &lt;iostream&gt;</code>. Very simple explanation but it's what is going on.</p>
",2
44350684,44350579,1,"<p>All <code>using namespace std</code> does is tell the compiler that, when an identifier (named variable, type, etc) appears in code, to look in the <code>std</code> namespace for candidates to match the name.</p>

<p>Within your <code>main()</code> function, no identifiers are being used at all (the <code>{}</code> is an empty block).   So there is no need to find matching candidates, and the result of compiling will be the same in both cases.</p>

<p>If you add a statement like <code>cout &lt;&lt; ""Hello\n""</code> to <code>main()</code>, then the <code>using namespace std</code> will cause the compiler to consider anything named <code>cout</code>  within namespace <code>std</code> as a valid match for the identifier <code>cout</code>.   If this comes after <code>#include &lt;iostream&gt;</code>, then <code>std::cout</code> is considered a viable match.   If declarations in <code>&lt;iostream&gt;</code> are not visible to the compiler (in your case, because there is no <code>#include &lt;iostream&gt;</code>) then the compiler cannot consider <code>std::cout</code> to be a candidate match for <code>cout</code>, and will issue a diagnostic accordingly.</p>

<p>The C++ standard does not specify anything different about <code>std</code> or about using directives that require <code>using namespace std</code> and <code>using namespace othername</code> to behave differently.   If your compiler treats them differently (recognising namespace <code>std</code> but not others, even if there is no declaration of one) then that is specific to your compiler.</p>
",5
44350720,44350579,8,"<p>Your code is illegal. Directive <code>using</code> can only nominate previously declared namespaces, i.e. namespaces whose names can be found by name lookup. </p>

<p>In this case your compiler apparently gives special treatment to name <code>std</code>. It is a compiler-specific extension, which regards <code>std</code> as an <em>implicitly defined</em> namespace. If your try a different namespace name in your code, it will most likely fail to compile.</p>
",0
43944179,43943979,4,"<p>You wrote:</p>

<pre><code>while (selection != (1 || 2))
</code></pre>

<p>This is ""while selection is not one or two"".</p>

<p>The actual correct English is ""while selection is neither one nor two"", and that's true in C++ also:</p>

<pre><code>while (!(selection == 1 || selection == 2))
</code></pre>

<p>Or, simpler, ""while selection is not one, and selection is not two"":</p>

<pre><code>while (selection != 1 &amp;&amp; selection != 2)
</code></pre>

<p>The expression <code>1 || 2</code> evaluates to <code>true</code>, so you wrote <code>while (selection != true)</code>, which is the case for <em>any</em> non-zero value of <code>selection</code>.</p>
",0
46639778,46639694,0,"<pre><code>outfile &lt;&lt; buildArray(arrayScore, numOfScores);
</code></pre>

<p>attempts to send the <em>value returned by <code>buildArray</code></em> to <code>outfile</code>. But you have declared that <code>buildArray</code> <em>does not return anything</em>! You have done this by writing <code>void</code> before its name in its declaration (and definition).</p>

<p>You have two options</p>

<ol>
<li>Return whatever it is that you want to be printed, as the result of <code>buildArray</code>.</li>
<li>Instead of sending the <em>results</em> of <code>buildArray</code> to <code>outfile</code>, pass <code>outfile</code> as an argument to <code>buildArray</code> and send date to <code>outfile</code> inside the body of <code>buildArray</code>.</li>
</ol>

<p>Here is some code to get you going with the second idea.</p>

<pre><code>#include &lt;ostream&gt;

void buildArray(std::ostream&amp; outfile, float arrayScores[], int numOfScores){
    float score = 0;
    for (int i=0; i&lt;numOfScores; i++){
    cout &lt;&lt; ""Enter the score: "";
    cin &gt;&gt; score;
    arrayScores[i] = score;
    outfile &lt;&lt; /* whatever you want to write goes here */
}
</code></pre>

<p>Points to note:</p>

<ol>
<li>Include the <code>ostream</code> header.</li>
<li>Add a parameter to the function, for the filestream you want to use.</li>
<li>Use the stream inside the function, show on the last line of the body.</li>
</ol>
",0
43748808,43748746,1,"<p>It's C++, not C. I edited your question to fix that.</p>

<pre><code>Difficulty&amp; easy = Difficulty(""EASY"",""Normal RNG and Hunger Loss"",false,0);
Difficulty&amp; hard = Difficulty(""HARD"",""Harder RNG and cumulative Hunger Loss"",true,5);
Difficulty&amp; insane = Difficulty(""INSANE"",""Very Hard RNG and Cumulative Hunger Loss"",true,15);
</code></pre>

<p>The problem is you're attempting to bind temporary objects to non-const references. You don't need references, just define some named objects directly:</p>

<pre><code>const Difficulty easy(""EASY"",""Normal RNG and Hunger Loss"",false,0);
const Difficulty hard(""HARD"",""Harder RNG and cumulative Hunger Loss"",true,5);
const Difficulty insane(""INSANE"",""Very Hard RNG and Cumulative Hunger Loss"",true,15);
</code></pre>

<p>That's not the only problem, but it's the one you asked about.</p>
",1
43768125,43768071,0,"<p>You're not initialising any of your class <code>edgeList</code>'s members.</p>

<p>Well, you are, but <em>by default</em>. Doing that requires a default constructor, which <code>point</code> doesn't have. Hence the error.</p>

<p>Those three lines in the <code>edgeList</code> constructor are assignments after-the-fact:</p>

<pre><code>  edgeList(const point&amp; origin, const point&amp; terminal) {
     this-&gt;origin = origin;
     this-&gt;terminal = terminal;
     this-&gt;weight = findWeight(origin, terminal);
  }
</code></pre>

<p>Here's what you're supposed to do, to initialise members:</p>

<pre><code>  edgeList(const point&amp; origin, const point&amp; terminal)
     : origin(origin)
     , terminal(terminal)
     , weight(findWeight(origin, terminal))
  {}
</code></pre>

<p>Currently your code is more like:</p>

<pre><code>  edgeList(const point&amp; origin, const point&amp; terminal)
     : origin()
     , terminal()
     , weight()
  {
     this-&gt;origin = origin;
     this-&gt;terminal = terminal;
     this-&gt;weight = findWeight(origin, terminal);
  }
</code></pre>

<p>If your C++ book doesn't explain this, you need <a href=""https://stackoverflow.com/q/388242/560648"">a better one</a>!</p>
",1
43768125,43768071,0,"<p>You're not initialising any of your class <code>edgeList</code>'s members.</p>

<p>Well, you are, but <em>by default</em>. Doing that requires a default constructor, which <code>point</code> doesn't have. Hence the error.</p>

<p>Those three lines in the <code>edgeList</code> constructor are assignments after-the-fact:</p>

<pre><code>  edgeList(const point&amp; origin, const point&amp; terminal) {
     this-&gt;origin = origin;
     this-&gt;terminal = terminal;
     this-&gt;weight = findWeight(origin, terminal);
  }
</code></pre>

<p>Here's what you're supposed to do, to initialise members:</p>

<pre><code>  edgeList(const point&amp; origin, const point&amp; terminal)
     : origin(origin)
     , terminal(terminal)
     , weight(findWeight(origin, terminal))
  {}
</code></pre>

<p>Currently your code is more like:</p>

<pre><code>  edgeList(const point&amp; origin, const point&amp; terminal)
     : origin()
     , terminal()
     , weight()
  {
     this-&gt;origin = origin;
     this-&gt;terminal = terminal;
     this-&gt;weight = findWeight(origin, terminal);
  }
</code></pre>

<p>If your C++ book doesn't explain this, you need <a href=""https://stackoverflow.com/q/388242/560648"">a better one</a>!</p>
",1
44743864,44743845,2,"<blockquote>
  <p>is there a way I can just make it so it can look like this?:</p>
</blockquote>

<p>Sure. You can use a member function template.</p>

<p>Declaration:</p>

<pre><code>template &lt;typename T&gt; Molecule(T&amp; t);
</code></pre>

<p>Implementation:</p>

<pre><code>template &lt;typename T&gt;
Molecule::Molecule(T&amp; t){
   // The common code.
}
</code></pre>
",0
43768805,43768085,-1,"<p>This code should work for you (if i understood the question)</p>

<pre><code> int search(string name[], string searchedName){
        for(int i=0; i&lt;100; i++){
            if(searchedName == name[i])
                return i;   //Returns the position of the person, which is also the index of his phone number
        }
        return -1;   //If -1 is returned it means there is no such name an ""searchedName"" in the vector
    }
</code></pre>

<p>You can call this function like this</p>

<pre><code>int main(){
      /* all the stuff you already have inside here */
    string nameToSearch;
    cout&lt;&lt;""Insert the name of the person you want to see the number of""&lt;&lt;endl;
    cin&gt;&gt;nameToSearch;
    int position = search(name, nameToSearch);
    if(position == -1)
       cout&lt;&lt;""Sorry, ""&lt;&lt;nameToSearch&lt;&lt;"" is not in our list""&lt;&lt;endl;
    else
      cout&lt;&lt;""The phone number of ""&lt;&lt;nameToSearch&lt;&lt;"" is ""&lt;&lt;phone[position]&lt;&lt;endl;

    return 0;
}
</code></pre>

<p>Of course this is pretty basic and you can make it better, hope it helps!</p>
",4
43768805,43768085,-1,"<p>This code should work for you (if i understood the question)</p>

<pre><code> int search(string name[], string searchedName){
        for(int i=0; i&lt;100; i++){
            if(searchedName == name[i])
                return i;   //Returns the position of the person, which is also the index of his phone number
        }
        return -1;   //If -1 is returned it means there is no such name an ""searchedName"" in the vector
    }
</code></pre>

<p>You can call this function like this</p>

<pre><code>int main(){
      /* all the stuff you already have inside here */
    string nameToSearch;
    cout&lt;&lt;""Insert the name of the person you want to see the number of""&lt;&lt;endl;
    cin&gt;&gt;nameToSearch;
    int position = search(name, nameToSearch);
    if(position == -1)
       cout&lt;&lt;""Sorry, ""&lt;&lt;nameToSearch&lt;&lt;"" is not in our list""&lt;&lt;endl;
    else
      cout&lt;&lt;""The phone number of ""&lt;&lt;nameToSearch&lt;&lt;"" is ""&lt;&lt;phone[position]&lt;&lt;endl;

    return 0;
}
</code></pre>

<p>Of course this is pretty basic and you can make it better, hope it helps!</p>
",4
45049450,45048224,2,"<p>Most of the things have been already said in the comments:</p>

<p>Your problem is, that you expect the loop to check its condition continuously, which it does not.</p>

<pre><code>while(name != ""//"") // here the condition is evaluated
{
    name = ""//"";    // here it is not 
     // the following code is executed, independent of the current name value
} // here the program jumps back to the loop condition, which is now false and it will not enter another time.
</code></pre>

<p>Like mentioned in the comments, a working alternative could be:</p>

<pre><code>while(true)
{
    std::cin &gt;&gt; name;
    if(name == ""//"")
        break;
    else
        evaluateScore();
}
</code></pre>
",0
45049459,45048224,0,"<p>Try this:</p>

<pre><code>#include ""stdafx.h""
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

int main()
{
    string name, grade;
    int score;
    int count1 = 0;
    int acount = 0;
    int bcount = 0;
    int ccount = 0;
    int dcount = 0;
    int fcount = 0;
    while (true) {  // keep running the loop
        cout &lt;&lt; ""Enter Student Name \n"";
        cin &gt;&gt; name;
        if(name == ""//"")  // if ""//"" found, break the loop
            break;
        cout &lt;&lt; ""Enter Student Score \n"";
        cin &gt;&gt; score;
        count1 += 1;
        if (score &gt;= 90) {
            grade = ""A"";
            acount += 1;
            cout &lt;&lt; name &lt;&lt; "" "" &lt;&lt; score &lt;&lt; "" "" &lt;&lt; grade &lt;&lt; endl;
        }
        else if (score &gt;= 80) {
            grade = ""B"";
            bcount += 1;
            cout &lt;&lt; name &lt;&lt; "" "" &lt;&lt; score &lt;&lt; "" "" &lt;&lt; grade &lt;&lt; endl;
        }
        else if (score &gt;= 70) {
            grade = ""C"";
            ccount += 1;
            cout &lt;&lt; name &lt;&lt; "" "" &lt;&lt; score &lt;&lt; "" "" &lt;&lt; grade &lt;&lt; endl;
        }
        else if (score &gt;= 60) {
            grade = ""D"";
            dcount += 1;
            cout &lt;&lt; name &lt;&lt; "" "" &lt;&lt; score &lt;&lt; "" "" &lt;&lt; grade &lt;&lt; endl;
        }
        else if (score &lt;= 59) {
            grade = ""F"";
            fcount += 1;
            cout &lt;&lt; name &lt;&lt; "" "" &lt;&lt; score &lt;&lt; "" "" &lt;&lt; grade &lt;&lt; endl;
        }
    };
    cout &lt;&lt; ""Summary Report \n"" &lt;&lt; ""Total Students Count: "" &lt;&lt; count1 &lt;&lt; endl;
    cout &lt;&lt; ""A student count: "" &lt;&lt; acount &lt;&lt; endl;
    cout &lt;&lt; ""B student count: "" &lt;&lt; bcount &lt;&lt; endl;
    cout &lt;&lt; ""C student count: "" &lt;&lt; ccount &lt;&lt; endl;
    cout &lt;&lt; ""D student count: "" &lt;&lt; dcount &lt;&lt; endl;
    cout &lt;&lt; ""F student count: "" &lt;&lt; fcount &lt;&lt; endl;
    return 0;
}
</code></pre>
",2
46975000,46974968,14,"<p>The comma token <em>can</em> act as a separator. But those contexts are explicitly enumerated. It's a separator for declarations, function/template parameters, function call/template instantiation arguments, and in initializers like <code>{1, 2}</code>. It is not a separator for statements, that's the role of a semi-colon.</p>

<p>The comma operator separates <strong>expressions</strong>. And a <code>continue</code> <strong>statement</strong> is not an expression.</p>

<p>Don't be a ""clever"" coder. Write clear code, understandable at a glance. Put the assignment in its own statement and wrap the two statements in one block scope for the <code>if</code> to execute.</p>
",7
43740050,43739985,6,"<pre><code>std::find_if(friendlist.begin(), friendlist.end(),
  [=](const std::pair&lt;PersonID, Cost&gt;&amp; elem) {
    return elem.first == toid;
  });
</code></pre>
",0
43749648,43749425,0,"<p>Try something more like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

static const int max_strings = 6;

int main()
{
    //6 entries
    std::string strings[max_strings] = { ""apple"", ""apple"", ""strawberries"", ""bananas"", ""dairy"", ""main"" };

    // sort the strings in ascending order
    std::sort(strings, &amp;strings[max_strings]);

    // display the strings and their repeat counts
    int i = 0;
    while (i &lt; max_strings)
    {
        std::string str = strings[i];
        int count = 1;

        while (++i &lt; max_strings)
        {
            if (strings[i] != str)
                break;
            ++count;
        }

        std::cout &lt;&lt; ""'"" &lt;&lt; str &lt;&lt; ""' appears "" &lt;&lt; count &lt;&lt; "" time"";
        if (count != 1)
            std::cout &lt;&lt; ""s"";
        std::cout &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>

<p>Output:</p>

<pre>
'apple' appears 2 times
'bananas' appears 1 time
'dairy' appears 1 time
'main' appears 1 time
'strawberries' appears 1 time
</pre>

<p><a href=""http://ideone.com/Buigjs"" rel=""nofollow noreferrer"">Live Demo</a></p>
",0
43749648,43749425,0,"<p>Try something more like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

static const int max_strings = 6;

int main()
{
    //6 entries
    std::string strings[max_strings] = { ""apple"", ""apple"", ""strawberries"", ""bananas"", ""dairy"", ""main"" };

    // sort the strings in ascending order
    std::sort(strings, &amp;strings[max_strings]);

    // display the strings and their repeat counts
    int i = 0;
    while (i &lt; max_strings)
    {
        std::string str = strings[i];
        int count = 1;

        while (++i &lt; max_strings)
        {
            if (strings[i] != str)
                break;
            ++count;
        }

        std::cout &lt;&lt; ""'"" &lt;&lt; str &lt;&lt; ""' appears "" &lt;&lt; count &lt;&lt; "" time"";
        if (count != 1)
            std::cout &lt;&lt; ""s"";
        std::cout &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>

<p>Output:</p>

<pre>
'apple' appears 2 times
'bananas' appears 1 time
'dairy' appears 1 time
'main' appears 1 time
'strawberries' appears 1 time
</pre>

<p><a href=""http://ideone.com/Buigjs"" rel=""nofollow noreferrer"">Live Demo</a></p>
",0
47651567,47651548,1,"<p>Because the behaviour of your code is <em>undefined</em>, and appearing to work correctly on at least one occasion is an acceptable manifestation of undefined behaviour.</p>

<p>You may well get <code>""777""</code>: a NUL-terminated <code>const char[4]</code> type.</p>
",0
47651949,47651548,0,"<p>Like Bathsheba already answered, returning a reference to a temporary variable causes undefined behaviour.</p>

<p>Unfortunately, in my experience two bad things come together regarding this:</p>

<ul>
<li>Due to the structure of a compiler, the reference will very often be 'seemingly' correct, like in your example.</li>
<li>The ""return reference to temporary"" issues only a compiler warning, not an error!</li>
</ul>

<p>Both things together makes this problem very dangerous, because it can be easily missed and work even for years... until the day of that very important presentation.</p>

<p>Solution is to treat this warning as an error (consult your compiler's documentation for compiler flags) or - even better - treat all warnings as errors.</p>
",0
44731987,44731925,1,"<p>first of all instead of using strings you can use a simple shift</p>

<pre><code>long long unsigned bin = 1LL &lt;&lt; i;
</code></pre>

<p>Other than that there is no standard functions to convert binaries. You can invent one by looping through the string elements and shifting. something like the following:</p>

<pre><code>long long unsigned bin = 0;
for (int i = 0; i &lt; 64; i++) {
  long long unsigned bit = binaryString[i] - '0';
  bin |= (bit &lt;&lt; i);
 }
</code></pre>
",4
44731939,44731925,1,"<p>Use <a href=""http://www.cplusplus.com/reference/cstdlib/strtoull/"" rel=""nofollow noreferrer""><code>strtoull</code></a>, like this:</p>

<pre><code>std::string s = ""747"";
int64_t n = std::strtoull(s.c_str(), NULL, 0);
</code></pre>
",3
47658697,47658636,1,"<p>You haven't defined the <code>&lt;&lt;</code> operator for your class <code>numcall</code>, so the compiler doesn't know how to apply it.</p>

<p>So define it.</p>
",0
47658740,47658636,0,"<p>You need to define a friend method for the &lt;&lt; stream operator, otherwise he doesn't know what to print.</p>

<pre><code>  friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const numcall &amp;numcall1) {
    os &lt;&lt; ""a: "" &lt;&lt; numcall1.a &lt;&lt; "" b: "" &lt;&lt; numcall1.b;
    return os;
}
</code></pre>

<p>This is just an example of implementation.</p>

<p>By the way there are other mistakes: c=a means assign a to c, you want to do the other way around. Welcome to the programming world mate ;)</p>
",0
43944663,43943768,0,"<p>In constructor of your class</p>

<pre><code>cruiser(SDL_Surface *screen)
</code></pre>

<p>you are not passing an object of <code>class level</code> and inside the constructor you are trying to access a non static member variable of that class. Your constructor for <code>class cruiser</code> should take object of <code>class level</code> as an input parameter.</p>

<p>It should be</p>

<pre><code>cruiser(SDL_Surface *screen, level obj_level)
{
//your stuff
}
</code></pre>

<p>constructor of <code>class level</code> should be</p>

<pre><code>level(SDL_Surface *battleground)
{
  //your stuff
  cruiser cruiser(SDL_Surface *screen, *this);
}
</code></pre>

<p>Hope this helps.</p>

<p>P.S: There are various design flaws in your code and I am not addressing those here.</p>
",4
44688151,44687994,0,"<pre><code>for(int i=0; i&lt;5; i++){
        for(int c=0; c&lt;4; c++){
            totals.push_back((pay[i][0]+pay[i][1]+pay[i][2]+pay[i][3]));
            }
        cout&lt;&lt;totals[i]&lt;&lt;""  "";
    }
</code></pre>

<p>Try removing the inner loop (the one with variable c). Should work.</p>
",0
44689306,44687994,0,"<p>You add the sum <code>pay[i][0]+pay[i][1]+pay[i][2]+pay[i][3]</code> to the vector four times due to your inner loop c.</p>

<p>What you really want is the following,</p>

<pre><code>for(int i=0; i&lt;5; i++){
    int sum = 0;
    for(int c=0; c&lt;4; c++)
        sum += pay[i][c];
    totals.push_back(sum);
    cout&lt;&lt;totals[i]&lt;&lt;""  "";
}
</code></pre>
",0
45067008,45066946,5,"<p><code>cout</code> is meant to output stuff to the command line, but you are writing a function that's supposed to return a <code>string</code>, that makes little sense.</p>

<p><code>ostringstream</code> is a neat class that allows you to build strings using the same mechanisms as <code>cout</code>, try this:</p>

<pre><code>string Box::toString() 
{
    std::ostringstream result;
    result &lt;&lt; ""Height: "" &lt;&lt; getHeight() &lt;&lt; "" Width: "" &lt;&lt; getWidth() &lt;&lt; "" Depth: "" &lt;&lt; getDepth();
    return result.str();
}
</code></pre>
",2
43966241,43964667,1,"<p>In your first example, we see a lot of construction and destruction of ""A"" objects that seems mysterious if you are not familiar with C++. Your B class has a private A variable ""a"". This object is default constructed when you first call the constructor to your B class. This is the very first ""constructor A"" print out that you see. The next print out is from the call to the A constructor here:</p>

<pre><code>B()
{
    a = A(); //A() calls the A constructor and returns an r-value
    printf(""Constructor B\n"");
}
</code></pre>

<p>Assigning ""a"", an already instantiated object of class A, to the r-value returned by the call of the default constructor of class A causes you to print ""Constructor A"" when the r-value is created, and ""Destructor A"" when the r-value itself is destroyed. These behaviors can be changed by creating copy and move constructors/operators which will allow you to specify how these semantics operate. Check out this page: <a href=""http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html"" rel=""nofollow noreferrer"">http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html</a> or a book (C++ 11 primer is a good one) for more info on these operations. </p>

<p>Following the above logic, when you assign your created B object ""b"" to the B class default constructor's returned rvalue in the line:</p>

<pre><code>b = B();
</code></pre>

<p>You construct a new B object, which must
 1) construct an A object
 2) create an A r-value
 3) destruct the A r-value
 4) construct a B object</p>

<p>The last two print statements are simply your B object being destructed as the main exits. The B object is destructed and so is it's member, the A object. Your first question seems to be about this behavior. It looks like you're asking whether you should destruct class members manually. This is only done in C++ if your class allocates memory for its members. If, for instance, instead of creating a local A object, your constructor in B did this: </p>

<pre><code>B()
{
    a = new A();
    printf(""Constructor B\n"");
}
...
private:
A* a;
</code></pre>

<p>Then you would have to deallocate this A* in your destructor. As long as you are not allocating new memory using the new operator or otherwise, C++ will handle all other deallocation for you. </p>

<p>Your questions 2 and 3 are about how to prevent/work with object construction and whether or not a given way of constructing/destructing objects is right or wrong. I would like to point you to the rule of 0/3/5. This basically deals with how many constructors you should create for a given class. This is a pretty simple explanation of the rule <a href=""http://en.cppreference.com/w/cpp/language/rule_of_three"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/language/rule_of_three</a>, but there are many others online.</p>

<p>Your last question has to do with the mesh class you have and why one of your variables is being destructed. Again, this has to do with the r-value returned by the call to the constructor. Basically, when you call your mesh constructor and assign its returned value to your variable ""mesh"" here: </p>

<pre><code>void init()
{
    int cool_data = 3;
    mesh = Mesh(cool_data);
}
</code></pre>

<p>The mesh constructor returns an r-value which is an object of class Mesh with a data value of 3; The r-value is copied into your ""mesh"" variable and is promptly destroyed, leaving your ""mesh"" variable as an exact copy of it. Again, all of these behaviors can be changed by creating appropriate constructors and operators. </p>
",1
43965289,43964977,1,"<p>The problem is that you aren't clearing your matrix after the game is won. Your matrix is a global variable, so it is created at the beginning of the program, and is not destroyed until the program stops. When you loop, all of the local variables created in the loop are destroyed, but not global variables. You need to manually clear this array. A function like this: </p>

<pre><code>void clearMatrix()
{
        for(int i = 0; i&lt;10; i++)
                matrix[i] = '0'+i;
}
</code></pre>

<p>would clear the matrix if you execute it in the appropriate place. </p>

<pre><code>int main(){
    char repeat;
    do {

    clearMatrix();
    string playername, player1, player2;
    int winner = 0;
    char mark = 0;
    ...
}
</code></pre>

<p>If you call this clearMatrix() function at the beginning of your do-while loop, your matrix will be reset every time.</p>
",0
43966652,43964977,0,"<pre><code>cout &lt;&lt; ""Player 1 please enter your name: "";
    cin &gt;&gt; player1;
    cout &lt;&lt; ""Player 2 please enter your name: "";
    cin &gt;&gt; player2;
</code></pre>

<p>note that you can use ""cin"" instead of using ""getline"" to avoid an error when typing the names again.</p>

<p>also do this: </p>

<pre><code>else
            cout &lt;&lt; ""Its a draw!"" &lt;&lt; endl;
    }
     clearMatrix();
    cout &lt;&lt; ""do u wanna repeat?"" &lt;&lt; endl;
    cin &gt;&gt; repeat;


}
</code></pre>

<p>as you have to clear the matrix so it is a good programming practice to call the function <code>clearMatrix();</code> at the bottom as defined above, while remaining inside the do-while loop.</p>
",0
45104370,45104067,2,"<p>The main reason for the usage of them is to make <a href=""https://stackoverflow.com/questions/1031273/what-is-polymorphism-what-is-it-for-and-how-is-it-used"">polymorphism</a> possible. Another technique that is needed for polymorphism is <a href=""https://stackoverflow.com/questions/3670726/late-binding-vs-polymorphism-what-is-the-difference"">late/dynamic binding</a>.</p>
<p>Upcasting allows us to use inherited classes (sub-classes) with the base class interface. You can handle those object with the same base class interface without need to know what concrete child class object it is.<br>
On the other hand, downcasting is needed because you may want to get the special methods or member variables of a child object. Then, you need to downcast.<br>
To cast up or down you can safely use the <a href=""http://en.cppreference.com/w/cpp/language/dynamic_cast"" rel=""nofollow noreferrer""><code>dynamic_cast</code></a> which is described <a href=""http://en.cppreference.com/w/cpp/language/dynamic_cast"" rel=""nofollow noreferrer"">here</a>.</p>
<blockquote>
<p>If the cast is successful, dynamic_cast returns a value of type new_type. If the cast fails and new_type is a pointer type, it returns a null pointer of that type. If the cast fails and new_type is a reference type, it throws an exception that matches a handler of type <a href=""http://en.cppreference.com/w/cpp/types/bad_cast"" rel=""nofollow noreferrer"">std::bad_cast</a>.</p>
</blockquote>
<p>To up or downcast between base and child class you need either a pointer (<code>type*</code>) or a reference type (<code>type&amp;</code>) because only the view to the object changes not the concrete object itself. If you use the object itself <a href=""https://stackoverflow.com/a/274634/8051589"">object slicing</a> would occur and you would lose information of an inherited class.</p>
<hr />
<p>I give you one example when to use up- and downcasting. Consider you have a parent class <code>Car</code> and 2 classes <code>Porsche</code> and <code>Ford</code> that are inherited from <code>Car</code>. Now you have a <code>std::vector&lt;Car*&gt; cars</code> for example where you want to put in different cars. You would do something like:</p>
<pre><code>std::vector&lt;Car*&gt; cars;
cars.push_back(new Porsche()); /* implicit upcast */
cars.push_back(new Ford());    /* implicit upcast */
</code></pre>
<p>The benefit is you have one vector of &quot;different&quot; objects, it's possible because both have the same parent class.</p>
<p>If you now want to get those cars you can do:</p>
<pre><code>Car*     porscheAsCar = cars.at(0);
Porsche* porsche      = dynamic_cast&lt;Porsche*&gt;(cars.at(0));
</code></pre>
<p>Now for example the <code>Car</code> class does have a <code>drive()</code> method and the <code>Porsche</code> class a <code>driveFast()</code> method implemented. You would access them:</p>
<pre><code>porscheAsCar-&gt;drive(); /* Call Porsche drive() method     */
porsche-&gt;drive();      /* Call Porsche drive() method     */
porsche-&gt;driveFast();  /* Call Porsche driveFast() method */
</code></pre>
<p>Even though we call the <code>drive</code> method with the base class interface it will be the <code>drive</code> method of the <code>Porsche</code>, if the method is declared with <a href=""https://stackoverflow.com/a/2392656/8051589"">virtual</a>. With the downcast you can access the methods/member variables that are specific for the inherited class. But it is just possible if the <code>Car</code> is really a <code>Porsche</code> and not a <code>Ford</code> for example.</p>
<p>Full example with some output on <a href=""https://ideone.com/5Pp097"" rel=""nofollow noreferrer"">ideone see here</a>.</p>
",0
45104467,45104067,2,"<p>When have a base class, from which several classes inherit, we often want a pointer that can point to one of those derived classes.</p>

<p>For example we can have an Animal class and derived Dog and Cat classes:</p>

<pre><code>class Animal {};

class Dog : public Animal {};
class Cat : public Animal {};

Dog dog;
Animal* a = &amp;dog;

Cat cat;
Animal* b = &amp;cat;
</code></pre>

<p>Often times, we want to have a pointer that can pointer to one of these objects. We can use an Animal pointer, since both a Dog and a Cat are a type of Animal. This is the nature of upcast. We upcast a derived class and represent it as the base class.</p>

<p>What about downcasting? We can do so using a dynamic_cast:</p>

<pre><code>Cat c;
Animal* animal = &amp;c; //Implicit upcast
Cat* cat = dynamic_cast&lt;Cat*&gt;(animal); //Explicit downcast
//Check if dynamic cast worked:
if(!cat) {
    //ERROR: Not a cat object
}
</code></pre>
",4
45104876,45104067,0,"<p>In my humble opinion, the website you are using is of a poor quality. I've tried to read some article: they are not incorrect but they are not even suitable for who is trying to enter in the C++ world with a little programming experience. Even I, with my little 15 years experience as professional C++ programmer, found it a little bit stressful to read.</p>

<p>As someone said a good book, even free, it's a better solution. Google is your best friend for search. That's a good answer to your question, more complete than whatever I could write: <a href=""https://www.tutorialcup.com/cplusplus/upcasting-downcasting.htm"" rel=""nofollow noreferrer"">https://www.tutorialcup.com/cplusplus/upcasting-downcasting.htm</a></p>

<p>Have a nice day, Ste.</p>
",0
43957167,43956660,3,"<p>The <a href=""https://en.cppreference.com/w/cpp/chrono/time_point/operator_arith2"" rel=""nofollow noreferrer"">minus operator</a> is overloaded for a pair of <code>time_points</code> to produce a floating point <code>duration</code>. If you want an integral duration, you can use a <a href=""http://en.cppreference.com/w/cpp/chrono/duration/duration_cast"" rel=""nofollow noreferrer"">duration cast</a>.</p>
<pre><code>// Option 1
std::chrono::duration&lt;float, std::milli&gt; diff = mElapsedTime - mStartedTime;
// Access the float with .count
std::cout &lt;&lt; diff.count() &lt;&lt; '\n';

// Option 2
// Or convert to a discrete unit of time, with underlying integral type
std::chrono::milliseconds integral_diff =
   std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(mElapsedTime - mStartedTime);
std::cout &lt;&lt; integral_diff.count() &lt;&lt; '\n';

// What actually is std::chrono::milliseconds?
static_assert(
   std::is_same_v&lt;std::chrono::milliseconds, std::chrono::duration&lt;int64_t, std::milli&gt;&gt;);
</code></pre>
<p>I've left the types in my example above as I feel it helps see what we're dealing with, in real world code I would use auto, especially for the duration cast.</p>
",0
44732401,44732305,0,"<p>This sequence of instructions in <code>detachWagonFromLeft()</code> is a problem:</p>

<pre><code>std::deque&lt;int&gt;::iterator it = wagons.begin();
wagons.pop_front();
return *it;
</code></pre>

<p>You save an iterator to the first element but the <a href=""http://en.cppreference.com/w/cpp/container/deque/pop_front"" rel=""nofollow noreferrer""><code>pop_front()</code></a> then invalidates that iterator. Dereferencing an invalidated iterator is undefined behavior.</p>

<p>I suggest this simpler version that works:</p>

<pre><code>int temp = wagons.front();
wagons.pop_front();
return temp;
</code></pre>

<p>You have a similar problem in the <code>detachWagonFromRight()</code> function that can be fixed as:</p>

<pre><code>int temp = wagons.back();
wagons.pop_back();
return temp;
</code></pre>
",0
44747679,44747574,2,"<p>main is a function, so you should declare it as:</p>

<pre><code>int main() {...
</code></pre>

<p>The 
 #include ""stdafx.h"" is microsoft specific and won't compile on other platforms.
stdafx.h is not necessary for this code to work.</p>
",0
44747691,44747574,1,"<p>Well, you've just missed some Syntax in the above code. The correct code is :</p>

<pre><code>    #include &lt;iostream&gt;
    using namespace std;
    int main ()
    {
       bool alternate = true ;
       for (int x = 0; x &lt; 8; x++)
       {
         for (int y = 0; y &lt; 4; y++)
         {
            if (alternate)
            {
               cout &lt;&lt; ""X "";
               cout &lt;&lt; ""O "";

            }
            else
            {
              cout &lt;&lt; ""O "";
              cout &lt;&lt; ""X "";

            }
         }
        alternate = !alternate;
        cout &lt;&lt; endl;
      }
      return 0;
   }
</code></pre>

<p>The mistake in your code was that you missed ""()"" after the main method. Also, you forgot to write the return statement.</p>
",5
47552663,47552259,3,"<pre><code>todo(iA, static_cast&lt;void (*)(int)&gt;(&amp;foo));
</code></pre>

<p>is one way, at the expense of readability at the call site.</p>

<p>Test code (retaining your 2 character indentation - I am a Myrmidon):</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

template &lt;typename T, typename F&gt;
void todo(const T&amp; param, const F&amp; function)
{
  function(param);
}
void foo(double a)
{
  cout &lt;&lt; ""double "" &lt;&lt; a &lt;&lt; endl;
}

void foo(int a)
{
  cout &lt;&lt; ""int "" &lt;&lt; a &lt;&lt; endl;
}

int main()
{
  int iA = 1051;

  todo(iA, static_cast&lt;void (*)(int)&gt;(&amp;foo));
  todo(iA, static_cast&lt;void (*)(double)&gt;(&amp;foo));

  return 0;
}
</code></pre>

<p>outputs:</p>

<pre><code>int 1051
double 1051
</code></pre>

<p>See <a href=""https://www.ideone.com/DEiLBE"" rel=""nofollow noreferrer"">https://www.ideone.com/DEiLBE</a></p>
",13
47552691,47552259,3,"<pre><code>auto identifier = type{value}
</code></pre>

<p>This is the syntax suggested by Sutter Mill in its <a href=""https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/"" rel=""nofollow noreferrer"">AAA (Almost Always Auto) Guru of the Week #94</a> when one needs to commit to a specific type.</p>

<p>It perfectly applies here:</p>

<pre><code>int iA = 1051;

using foo_int_type = void(*)(int);
auto non_ambiguous_int_foo = foo_int_type{foo};
todo(iA, non_ambiguous_int_foo);
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/43bf5b42bfad5f30"" rel=""nofollow noreferrer"">Live demo on coliru</a></p>
",5
47552711,47552259,1,"<p>You can use <code>static_cast</code> to select the right function overload. For example: <code>todo(iA, static_cast&lt;void(&amp;)(double)&gt;(foo))</code></p>
",2
47963400,47963357,2,"<p>You should not use static variables for such a case. Use it as a parameter:</p>

<pre><code>int lcm(int a, int b, int &amp;common)
{ 
  if (common % a == 0 &amp;&amp; common % b == 0)
    return common;

  common++;
  lcm(a, b, common);
  return common;
}

// now you can also overload it to avoid using argument:
int lcm(int a, int b)
{
    int common = 1;
    return lcm(a, b, common);
}
</code></pre>

<p>With static variable, you also break the thread-safety of the function. You would have to make sure only one thread is calling it.</p>

<p><strong><em>EDIT</em></strong></p>

<p>If you change the function a little bit:</p>

<pre><code>int lcm(int a, int b, int common = 1)
{ 
   if (common % a == 0 &amp;&amp; common % b == 0)
      return common;

   return lcm(a, b, ++common);
}
</code></pre>

<p>Now you don't need the common to be a reference and it's much simpler.</p>
",0
47963407,47963357,4,"<p>There is no built-in language mechanism for resetting function-level static variables. Although you can built your own way of communicating the need to reset the <code>static</code> to its initial value, it would remain a poorly-readable abuse of the language.</p>

<p>In particular, you should never use <code>static</code> variables in recursive functions, because non-reentrant recursive functions are nearly useless. In addition, your recursive implementation is painfully slow, because it tries candidate <code>lcm</code>s sequentially one by one. Feeding it two reasonably large prime numbers would result in stack overflow.</p>

<p>Rewrite your recursive <code>lcm</code> in a way that does not use <code>static</code>.</p>
",2
37911050,37910978,0,"<p>something more like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
void menu(int opccion);
void agregar();
void consultar();
void eliminar();

int menu(){
    static const string Menu[] = {""agregar"",""consultar"",""eliminar""};
    for (int i = 0; i &lt; 3; ++i){
        cout &lt;&lt; i+1 &lt;&lt; "" : "" &lt;&lt; Menu[i] &lt;&lt; endl;
    }
    int opccion;
    do {
        cout &lt;&lt; ""what would you do? "" &lt;&lt; endl;
        cin &gt;&gt; opccion;
        switch(opccion){
            case 1:
                cout &lt;&lt; ""menu 2"" &lt;&lt; endl;
                break;

            case 2:
                cout &lt;&lt; ""menu 3"" &lt;&lt; endl;
                break;

            case 3:
                cout &lt;&lt; ""menu 24"" &lt;&lt; endl;
                break;

            default:
                cout &lt;&lt; ""opccion invalida"" &lt;&lt; endl;
        }
    } while (opccion &lt;1 || opccion &gt;= 4);
    return opccion;
}

int main(){
    int opccion = menu();
    return 0;
}
</code></pre>
",0
48023808,48003867,0,"<p>sorry guys, this is the first time for me to ask a question of this type,, i have to be more specific,for the DeleteNode(T &amp; val) function it just delete one desired node , for the DeleteNodes(T &amp; val1, T &amp; val2) function it deletes all the nodes that have the value in range between val1 and val2, here is the DeleteNode() function :</p>

<pre><code>bool DLList&lt;T&gt;::DeleteNode(T&amp; val) 
{
bool found = false;

if(IsEmpty() == true)
    return false;

if(val == head-&gt;val)
{
    DeleteHead();
    return true;
}

if(val == tail-&gt;val)
{
    DeleteTail();
    return true;
}

DLLNode&lt;T&gt; *node, *predNode, *succNode;
node = predNode = succNode = NULL;

//Traverse list to find the node to be deleted
for(node = head-&gt;next; node != NULL; node = node-&gt;next)
{
    if(node-&gt;val == val)
    {
        found = true;
        break;
    }
}
if(found == true)
{
    // Unlink deleted node from list
    predNode = node-&gt;prev;
    succNode = node-&gt;next;
    predNode-&gt;next = node-&gt;next; 
    succNode-&gt;prev = node-&gt;prev;
    delete node;
}
return found;
}
</code></pre>
",0
48011204,48010891,0,"<p>There are three things confusing you here.</p>

<p>First the expressions:</p>

<pre><code>i1 = data[0];
i2 = data[p1];
</code></pre>

<p>Assign the character values of <code>data[0]</code> and <code>data[p1]</code> 
If the input is <code>2+4</code> you're actually assigning the character values of '2' and '+'. In ASCII ""2"" is represented by code-point 50 and ""+"" by 43.</p>

<p>So then the expression <code>i1+i2</code> actually equals 93.</p>

<p>What is also confusing you is that <code>s=i1+i2</code> actually binds to the overloading <code>basic_string&amp; operator=( CharT ch );</code> and so converts 93 back to a character and assigns a singleton string to <code>s</code> which happens to be <code>]</code> as you see!</p>

<p>This is your code with those three faults fixed:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
    string input;
    int length;
    int p1;
    int i1;
    int i2;
    string result;

    cout &lt;&lt; ""Enter your expression"" &lt;&lt; endl;
    cin &gt;&gt; input;
    length = input.size();

    char data[length];
    input.copy( data, length );

    switch(data[1]){
    case '+' : p1 = length - 1; //Not -2 as was.
    i1 = data[0]-'0';//Works for ASCII compatible and so all modern systems...
    i2 = data[p1]-'0';
    result = std::to_string(i1 + i2);//Force the creation of a decimal string of the result.
    cout &lt;&lt; result &lt;&lt; endl;
    break;
    }
    return 0;
}
</code></pre>
",5
43949253,43948982,0,"<p>Check you <code>Score(int)</code> constructor. You use the <code>size</code> argument but don't initialize the <code>size</code> member, leaving it in an uninitialized state.</p>

<p>Your code:</p>

<pre><code>Scores(int size)
{
    fPtr = new float[size];
}
</code></pre>

<p>You need to do:</p>

<pre><code>Scores(int size) : size(size)
{
    fPtr = new float[size];
}
</code></pre>

<p>After this you can use your class variable <code>size</code> inside of <code>getHi</code>,  <code>getLow</code> and <code>getAvg</code>.</p>
",2
43960277,43960083,0,"<p>Yes u can use the constructor of base class in derived class either creating the constructor of derived class or if u are not creating constructor of derive class when you create its object the constructor of base classnis automatically called</p>
",0
43960160,43960120,2,"<p>You need to delete the word <code>class</code> here:</p>

<pre><code>class Triangle :: Triangle
</code></pre>

<p>And of course you need to make sure <code>class Triangle</code> is declared before that.</p>
",2
43960237,43960120,-1,"<p>Use this following code snippet . </p>

<pre><code>#include ""Polygon.h""
    #include &lt;iostream&gt;
    #include &lt;cmath&gt;
    using namespace std;

    //Polygon constructor
    Polygon :: Polygon(double side1, double side2, double side3, double side4)
    {
        s1 = side1;
        s2 = side2;
        s3 = side3;
        s4 = side4;
    }
    //get area method
    double Polygon :: getArea()
    {
        float length, width, area;

        if (s1 == s2)
            {
                length = s1;
                width = s3;
            }
        else if (s1 == s3)
            {
                length = s1;
                width = s2;
            }
        else if (s1 == s4)
            {
                length = s1;
                width = s3;
            }
        area = length * width;
        return area;
    }
    //Triangle class
     Triangle :: Triangle(double s1, double s2, double s3) : Polygon(s1,       s2, s3, 0.0) {}

    double Triangle :: getArea()
    {
        float s, area;

            s = (s1 + s2 + s3)/2;
            area = sqrt(s * (s - s1) * (s - s2) * (s - s3));

            return area;
    }
</code></pre>
",0
44349905,44349883,1,"<p>It should look like this</p>

<pre><code>   void owed(int classchoice)
    {
      double cost;
      if (classchoice == 1)
        cost = 1750.00;
      else if  (classchoice == 2)
        cost = 1500.00;
      else if (classchoice == 3)
        cost = 1000.00;

      cout &lt;&lt; ""You owe about: "" &lt;&lt; cost &lt;&lt; endl;
      cout &lt;&lt; ""Enjoy your flight!\n\n\n"";
    }
</code></pre>
",1
43968984,43968870,2,"<p><strong>TL;DR</strong> - Remove the <code>\\</code> before the <code>;</code>.</p>

<p>In the context of a shell, a command is interpreted before the individual arguments being passed to the <code>find</code> executable.  <code>;</code> is a special character, so needs escaping in order to be interpreted as a literal (as it's a special character) - <code>find</code> actually only needs <code>;</code>.</p>

<p>However, you're not passing the arguments on the shell - <code>execl</code> passes the arguments directly to the target executable.  So there's no need to escape it.</p>

<hr>

<p>As pointed out by @AndrewHenle in comments below, you'll also need to remove both the <code>'</code> from <code>'*.mp3'</code> for similar reasons.</p>
",3
43968998,43968870,0,"<p>There is no Bash in sight, despite your question title. Yet you are using Bash-style quoting.</p>

<pre><code>""'*.mp3'""
</code></pre>

<p>Your <code>find</code> will find nothing unless you have files with single quotation marks in their names. Use <code>""*.mp3""</code>.</p>

<pre><code>""\\;""
</code></pre>

<p><code>find</code> requires <strong>a single semicolon</strong> to terminate the <code>-exec</code> arguments. <code>\;</code> is the Bash way to use a literal semicolon. Normally <code>;</code> is a reserved character in Bash. Use a simple <code>"";""</code>.</p>
",1
47519474,47519375,2,"<pre><code>cout &lt;&lt; *serieA[i];
</code></pre>

<p>is like:</p>

<pre><code>operator&lt;&lt;(cout, *serieA[i]);
</code></pre>

<p>The <code>operator&lt;&lt;</code> cannot be member of your class because it takes the stream as its first parameter.</p>

<p>You need to make it global (non-member function) and change its parameters to stream and a reference to a <code>Team</code> object:</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Team const&amp; team)
{ 
    // put your code here
    return os;
}
</code></pre>

<p>And if necessary declare it as friend in your <code>Team</code> class:</p>

<pre><code>friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Team const&amp; team);
</code></pre>

<p>You can also define the friend, not just declare in the class if you want:</p>

<pre><code>class Team {
...
    bool operator&gt;(Team const&amp;);

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Team const&amp; team)
    { 
        // put your code here
        return os;
    }

private:
...
</code></pre>

<p>A good read is <a href=""http://en.cppreference.com/w/cpp/language/operators"" rel=""nofollow noreferrer"">operator overloading</a> on cppreference.com</p>
",4
44733912,44733870,0,"<p>Hy, you have on line 17 some mistake:
replace </p>

<pre><code>for (i = 0; i &lt;= up &amp;&amp; ok != 1; i++)
</code></pre>

<p>with</p>

<pre><code> for(i=0;i&lt;=middle &amp;&amp; ok==1;i++)
</code></pre>

<p>and in the next for:</p>

<pre><code>for (i = k - up; i &lt; 0 &amp;&amp; ok == 1; i--) {
</code></pre>

<p>you write this:</p>

<pre><code>for(i=k-middle;i&gt;0 &amp;&amp; ok==1;i--)
</code></pre>
",0
45046139,45046092,3,"<p>Your problem lies in the try of deleting a <code>std::shared_ptr&lt;T&gt;</code>. You do not perfom a <code>delete</code> on that object. The destructor of it does what you really want for you. Simply call <code>erase</code> on your map at specified key and, while you erase that object, the destructor will automatically <code>delete</code> the content if there are no remaining <code>shared_ptr</code>s referencing this allocation (<em>very good point</em> <strong><em>user4581301</em></strong> ).*</p>

<p>Your function would look like that:</p>

<pre><code>void directory::remove (const string&amp; filename) {
   DEBUGF ('i', filename);
   dirents.erase(filename); // erasing that object makes it call a delete on content
}
</code></pre>

<p>EDIT: Just some quick tip - if your <code>map</code> provides the only way of accessing those pointers, consider using <code>std::unique_ptr&lt;T&gt;</code> instead of <code>std::shared_ptr&lt;T&gt;</code>.</p>

<p>*if you really want to perform a <code>delete</code> there, I would highly encourage you to switch to unique pointers. Usage of shared ones indicates that there might be some other pointers pointing to the memory you want to deallocate. If that's the case - your original approach was not correct. Either use <code>std::unique_ptr</code> here or don't assume you could delete the content of the <code>ptr</code>s.</p>
",9
37396269,37396177,2,"<p>Your variables <code>frameType</code>, <code>yes_no</code> and <code>colorSelection</code> are declared as <code>int</code> and you are doing the comparison against <code>char</code> in your <code>switch</code>.</p>

<p>You should remove the quotes.</p>

<p>e.g.:</p>

<pre><code>cout&lt;&lt;""My frame type: ""&lt;&lt;frameType&lt;&lt;endl;
switch(frameType)
{                                 // type of frame
case 1:
    cost += 0.15;
    break;
case 2:
    cost += 0.25;
    break;
default:
    cout &lt;&lt; ""wrong input!"";
}
</code></pre>

<p>Note that you can display your variable before the <code>switch</code> statement</p>
",1
37396471,37396177,0,"<p>Case statements check to see whether the input value matches some constant.</p>

<p>In your case you are checking to see whether the <code>int</code> value for <code>frameType</code> which will be 1 or 0 is the same as the constant value for '1'.</p>

<p>This '1' (wich is a <code>char</code> type) will actually automatically convert to an integer when compared with an integer, but it will convert to an integer based on the <a href=""http://www.asciitable.com/"" rel=""nofollow"">ascii table</a> so it will become the integer <code>49</code>.</p>

<p>So when it all compiles its as if you had written something like this:</p>

<pre><code>switch (frameType) {
case 49:
  // Clearly frametype won't be 49 so this won't happen
case 50:
  // Same problem
</code></pre>

<p>These hidden conversions can be a big pain for everyone and so most people will turn on compiler warnings that will stop the compilation if these 'implicit conversions' happen. </p>

<p>If you compile with all warnings turned on and treat them as errors most compilers would catch this sort of thing for you! Where I work this is the default mode of compilation because we all make these mistakes ... lets say occasionally.</p>
",0
44329159,44326414,2,"<p>Instead of a cout, you should indeed use exception handling. </p>

<pre><code>if(tempdata&gt;=1 &amp;&amp; tempdata&lt;=9)
{
  data=tempdata;
}
else
{
  throw std::runtime_error(""Soduku contains numbers from 1 to 9 only.Please try again"");
}
</code></pre>

<p>By putting all this into a function, and not your main, you can then call this function within a try/catch block, and deal properly with the exception: display a pop-up message if you have a GUI, ignore the input, etc. The important part is that, if you ignore it, it is not actually ignored. It is dealt with. Which makes your code a LOT cleaner and maintainable. Example:</p>

<pre><code>try
{
    input();
}
catch(std::runtime_error&amp; e)
{
    // deal with your invalid input here
}
</code></pre>

<p>Also, goto statements are considered bad practice. They can be easily replaced by if/else or while statements, or with return codes in functions. And using them tend to make the code unreadable, difficult to follow.</p>
",1
44333066,44326414,0,"<p>You need to validate that <code>cin &gt;&gt;</code> is successful before you can then use the value entered.  If the user enters data that does not match the expected type, you have to clear the error before you can read new input again.</p>

<p>Try this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;limits&gt;

int i, j, data;

bool isNumValid(int data) {
    return ((data &gt;= 1) &amp;&amp; (data &lt;= 9));
}

void clearInput() {
    std::cin.clear();
    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
}

int main() {
    int tempdata;

    do {
        std::cout &lt;&lt; ""\n\n Enter the row and column where you want to enter data"" &lt;&lt; std::endl;

        if (!(std::cin &gt;&gt; i &gt;&gt; j)) {
            std::cout  &lt;&lt; ""\n Please enter numbers only!"" &lt;&lt; std::endl;
            clearInput();
            continue;
        }

        if (!isNumValid(i) || !isNumValid(j)) {
            std::cout &lt;&lt; ""\nEntered row or column is not valid"" &lt;&lt; std::endl;
            std::cout &lt;&lt; ""Please try again"" &lt;&lt; std::endl;
            continue;
        }

        std::cout &lt;&lt; ""\n Enter your desired value to put in that place"" &lt;&lt; std::endl;
        if (!(std::cin &gt;&gt; tempdata)) {
            std::cout  &lt;&lt; ""\n Please enter a number only!"" &lt;&lt; std::endl;
            clearInput();
            continue;
        }

        if (!isNumValid(tempdata) {
            std::cout &lt;&lt; ""\n Soduku contains numbers from 1 to 9 only"" &lt;&lt; std::endl;
            std::cout &lt;&lt; ""Please try again"" &lt;&lt; std::endl;
            continue;
        }

        data = tempdata;
    }
    while (true);

    std::cin.get();
    return 0;
}
</code></pre>

<p>Alternatively:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;stdexcept&gt;

int i, j, data;

bool isNumValid(int data) {
    return ((data &gt;= 1) &amp;&amp; (data &lt;= 9));
}

void checkRowColValid(int row, not col) {
    if (!isNumValid(row) || !isNumValid(col))
        throw std::out_of_range(""Entered row or column is not valid"");
}

void checkDataValid(int data) {
    if (!isNumValid(data))
        throw std::out_of_range(""Soduku contains numbers from 1 to 9 only"");
}

int main() {
    int tempdata;

    std::cin.exceptions(std::ios_base::failbit);

    do {
        try  {
            std::cout &lt;&lt; ""\n\n Enter the row and column where you want to enter data"" &lt;&lt; std::endl;

            std::cin &gt;&gt; i &gt;&gt; j;    
            checkRowColValid(i, j);

            std::cout &lt;&lt; ""\n Enter your desired value to put in that place"" &lt;&lt; std::endl;

            std::cin &gt;&gt; tempdata;
            checkDataValid(tempdata);

            data = tempdata;
        }
        catch (const std::out_of_range &amp;e) {
            std::cout &lt;&lt; ""\n "" &lt;&lt; e.what() &lt;&lt; std::endl;
            std::cout &lt;&lt; ""Please try again"" &lt;&lt; std::endl;
        }
        catch (const std::ios_base::failure &amp;) {
            std::cout  &lt;&lt; ""\n Please enter numbers only!"" &lt;&lt; std::endl;
            std::cin.clear();
            std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
        }
    }
    while (true);

    std::cin.get();
    return 0;
}
</code></pre>
",0
44353629,44353602,1,"<p>""C++ Will copy elision happen when returning a temporary object"" - it may. It's not guaranteed until C++17 (and even there, certain conditions apply). But, most compilers will elide the copy. </p>
",0
45080932,45079898,1,"<p>The whole point of debug builds is that the executable incorporates things that you can, y'know, debug with. That includes information that would usually not be kept, like the names of variables.</p>

<p>The code is also less terse because it has not been optimised as much (optimisations being unhelpful to the debugging process).</p>

<p>You can definitely expect debug builds to be larger.</p>
",3
44230113,44229968,-1,"<p>Just do</p>

<pre><code>int i,j;
std::string line;
  while(std::getline(cin,line) &amp;&amp; !line.empty()){
      std::istringstream iss(line);
      if(iss &gt;&gt;i&gt;&gt;j) {
         //LOOP BODY
      }
 }
</code></pre>
",2
46635711,46635630,1,"<p>You have expressions that are based on uninitialized variables, e.g. <code>area = length * length</code> in <code>double length, area = length * length</code>; Note that C++ is not like, for example, Excel, where you can define a formula which is automatically recalculated when parameters change. The ""formula"" is rather evaluated right where the code is stated.</p>

<p>So your code like ...</p>

<pre><code>double length,
    area = length * length;

cout &lt;&lt; ""Enter the length of the square."";
cin &gt;&gt; length;
cout &lt;&lt; ""The area of your square is "" &lt;&lt; area &lt;&lt; endl;
</code></pre>

<p>should be written like ...</p>

<pre><code>double length = 0.0, area;


cout &lt;&lt; ""Enter the length of the square."";
cin &gt;&gt; length;
area = length * length;
cout &lt;&lt; ""The area of your square is "" &lt;&lt; area &lt;&lt; endl;
</code></pre>
",1
37299908,37299527,1,"<p>A few suggestions have already been made in the comments, but the main performance issue is that your algorithm has a time complexity of O(n^2).</p>

<p>If I understand it correctly, you want to find all pairs with a distance smaller than <code>Rcut</code>. You could save a lot of time if you first sort your array of points with respect to one of the components. Then you will only have to compare each point with a small range of other points because if the difference in coordinate values is larger than <code>Rcut</code>, the distance also has to be larger. </p>

<p>I am assuming here that most of the point pairs hava a distance larger than <code>Rcut</code>. In this case you will only have a time complexity of approximately O(n log(n)), which is due to the sorting. Of course in the worst case, meaninc that all points are within a sphere of diameter <code>Rcut</code>, this won't save you anything.</p>
",0
37299982,37299527,5,"<p>Your performance problem is basic math:</p>

<pre><code>int size = 100000;

// ...

for(int i = 0; i &lt; size; ++i) {
    H[i] = new double[size];
    K[i] = new double[size];
    L[i] = new double[size];
    D[i] = new double[size];
}
</code></pre>

<p>So, you run this loop 100000 times. Each time in the loop you allocate four 100000 element arrays. <code>sizeof(double)</code> is 8. Let's calculate how much RAM you need.</p>

<pre><code>100000 * 100000 * 4 doubles
</code></pre>

<p>That's how many <code>double</code>s you are allocating. With each <code>double</code> taking up 8 bytes, the total amount of bytes required is</p>

<pre><code>100000 * 100000 * 4 * 8 = 320000000000 bytes
</code></pre>

<p>Or about 300 gigabytes of RAM. It's somewhat unlikely that your machine has 300 gigabytes of RAM. Your host operating system probably uses a variable-sized swap file, so, before long, you're going to be thrashing all of this data to/from your hard drive, constantly.</p>

<p>That's your performance problem (I am not including the dozen misc 100000-element arrays you also allocate, which by this time are insignificant line noise).</p>
",0
37299995,37299527,0,"<p>calculate:</p>

<pre><code>`D[i][j] = 0;
D[i][j] += H[i][j]*H[i][j];
D[i][j] += K[i][j]*K[i][j];
D[i][j] += L[i][j]*L[i][j]);
D[i][j] = sqrt(D[i][j]);`
</code></pre>

<p>And so you can calculate H,K,L one by one.
But it seems that a double type matrix of size 100000*100000 is too large.
It require 74G memory above.
And so you can read file in piecewise,and calculate D[i][j] for i,j piecewise.
Here's the O(n log n) code by @Frank Puffer@philipp</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

struct point3d
{
public:
    point3d(double x_,double y_,double z_):
        x(x_), y(y_), z(z_)
    {}
    point3d(const point3d&amp; rhs)
    {
        *this = rhs;
    }
    double x;
    double y;
    double z;
    point3d&amp; operator=(const point3d&amp; rhs)
    {
        x = rhs.x;
        y = rhs.y;
        z = rhs.z;
        return *this;
    }
    point3d operator-(const point3d&amp; rhs) const
    {
        return point3d(x - rhs.x, y - rhs.y, z - rhs.z);
    }
    double square_norm() const
    {
        return x*x + y*y + z*z;
    }
};

vector&lt;std::pair&lt;point3d, point3d&gt;&gt; find_point_pairs_by_max_distance(vector&lt;point3d&gt;&amp; points, double max_distance)
{
    vector&lt;std::pair&lt;point3d, point3d&gt;&gt; ret;
    double square_max_distance = max_distance*max_distance;

    std::sort(points.begin(), points.end(),
        [&amp;](const point3d&amp; a, const point3d&amp; b)
    {
        return a.x &lt; b.x;
    });

    for (size_t i = 0; i &lt; points.size();++i)
    {
        for (size_t j = i+1; j &lt; points.size();++j)
        {
            double dx = points[i].x - points[j].x;
            if (dx*dx &gt;= square_max_distance) break;

            double square_distance = (points[i] - points[j]).square_norm();
            if (square_distance &lt; square_max_distance)
            {
                ret.push_back({ points[i], points[j] });
            }
        }
    }
    return ret;
}

void print_point(const point3d&amp; point)
{
    cout &lt;&lt; '(' &lt;&lt; point.x &lt;&lt; ',' &lt;&lt; point.y &lt;&lt; ',' &lt;&lt; point.z &lt;&lt; ')';
}

void print_point_pairs(const vector&lt;std::pair&lt;point3d, point3d&gt;&gt;&amp; point_pairs)
{
    for (auto&amp; v: point_pairs)
    {
        print_point(v.first);
        cout &lt;&lt; ' ';
        print_point(v.second);
        cout &lt;&lt; endl;
    }
}

int main()
{
    vector&lt;point3d&gt; points{ point3d(1, 2, 3), point3d(2, 3, 4), point3d(2, 2, 2) };
    auto point_pairs = find_point_pairs_by_max_distance(points,1.5);
    print_point_pairs(point_pairs);
}
</code></pre>

<p>If your points are bounded in a small region,and Rcut is not very small,you can quantizate the coordinate components by Rcut,then add each point to the corresponding voxel list in a bounded cube,then you only need search for a small Rcut-neighbourhood.This is O(n * (2*Rcut+1)^3)</p>
",1
37300003,37299527,1,"<ul>
<li>As Mark states in the comment, do not store intermediate results in arrays if you do not need them later</li>
<li>You are iterating over a 2D array with every combination of i and j in the full range. this leads to O(n^2) complexity. But, there is a condition <code>D &lt; Rcut</code>, which basically means that the distance between i and j has to be below a limit for the iteration to be relevant. Rcut is already named to be interpreted as radius. For any i, you only have to iterate over a range of values for j, which are near i. If you get the math straight there, you essentially get O(n)</li>
<li>a small thing you could do: do not calculate the sqrt, compare against (Rcut)^2 instead. (This will <em>not</em> really help you in any way, just mentioning for completeness)</li>
</ul>
",0
44370943,44370412,-2,"<p><code>system(""cls"")</code> don't clear the value of variables. If you have problems with it, save the variables in a file before you clear the screen and load after the <code>system(""cls"")</code> line.</p>
",0
42524127,42523981,0,"<p>If only one element you want to erase, you could try code below:</p>

<pre><code>for(auto iter = playerRoster.begin(); iter != playerRoster.end(); ++iter){
    if(iter-&gt;jerseyNumber == searchValue){
        iter = playerRoster.erase(iter);
        break;
    }
}
</code></pre>

<p>Or if you want to erase all element that match, you could try :</p>

<pre><code>for(auto iter = playerRoster.begin(); iter != playerRoster.end(); ){
    if(iter-&gt;jerseyNumber == searchValue){
        iter = playerRoster.erase(iter);
    }else{
        ++iter;
    }
}
</code></pre>

<p>Remember erase return the element after the one that be erased.</p>

<p>Sample code can be found : <a href=""http://www.cplusplus.com/reference/vector/vector/erase/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/vector/vector/erase/</a></p>
",2
46988711,46988615,0,"<p>The maximum value for a variable of type int is 2147483647, whereas the max value of float is : 3.40282e+38 or 0x1.fffffep+127. You could use double also.</p>
",1
46988806,46988615,0,"<pre><code>long long problem3(long long num) {
long long returnum;
for (long long i = 2; i &lt; num; ++i) {
    if (num % i == 0 &amp;&amp; primecheck(i)) {
       returnum = i;
    }
}
return returnum;
}
</code></pre>

<p>And this is my 'primecheck' function:</p>

<pre><code>bool primecheck(long long num) {
     for (long long i = 2; i &lt;= num / 2; ++i) {
         if (num % i == 0) {
            return false;
        }
    }
    return true;
}
</code></pre>

<p><a href=""https://msdn.microsoft.com/en-us/library/cc953fe1.aspx"" rel=""nofollow noreferrer"">Fundamental Types (C++)</a></p>

<p>tested! OK!
VS2017</p>

<pre><code>#include ""stdafx.h""
#include &lt;stdio.h&gt;

bool primecheck(long long num);
long long problem3(long long num);

bool primecheck(long long num) {
    for (long long i = 2; i &lt;= num / 2; ++i) {
        if (num % i == 0) {
            return false;
        }
    }
    return true;
}

long long problem3(long long num) {
    long long returnum;
    for (long long i = 2; i &lt; num; ++i) {
        if (num % i == 0 &amp;&amp; primecheck(i)) {
            returnum = i;
        }
        if (i % 100000 == 0) {
            printf(""tick - %lld\n"", i);
        }
    }
    return returnum;
}


int main()
{
    printf(""out number %lld\n"", problem3(600851475143));
    return 0;
}
</code></pre>

<p><a href=""https://i.stack.imgur.com/gH7i3.png"" rel=""nofollow noreferrer"">32 037 210 000</a> - screenshot 10 000 000 per/sec . 
(in this moment > (long)2^32)
and what you want with this program? wait 65K sec? (18 hours)
may be need use math algorithm for best time ?</p>
",2
45785919,45785852,2,"<p>First, variable length arrays as you introduce with <code>cin &gt;&gt; n; Complex A[n]</code> are not part of the C++ standard and might not be supported by your compiler.
Second, if your compiler supports VLAs in general, it will not support to create a VLA of a non-<a href=""http://en.cppreference.com/w/cpp/concept/PODType"" rel=""nofollow noreferrer"">POD (plain old data)</a> type like <code>std::Complex</code>. </p>

<p>To overcome both issues, use a <code>std::vector</code> instead of the plain array:</p>

<pre><code>std::vector&lt;Complex&gt; A(n);
</code></pre>
",0
46986008,46985886,0,"<p>Since you have declaration of your class in the Calender.h file, your implementation in the Calender.cpp is in fact redfining your class. The correct way to do that would be to reference the class using the scope resolution operator ' <strong>::</strong> '</p>

<p>Your Calender.cpp file should look like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include ""Calendar.h""

char months[12][10] = { ""January"", ""February"", ""March"",""April"",""May"",""June"",""July"",""August"",""September"",""October"",""November"",""December"" };

// your default no-args class constructor
Date::Date(){
    dd = 1; mm = 1; yy = 1900;
}

/*
        Another Way you could implement your constructor is by using initialisation lists (check our the second link in my answer to know more)
        Date::Date(int m, int d, int y) : mm(m), dd(d), yy(y) { }
*/

Date::Date(int m, int d, int y) {
    // your constructor code here
}

bool Date::checkdate(){
    // your implementation here
}
bool Date::checkleapyear(){
    // your implementation here
}
string Date::toString(){
    // your implementation here
}
Date Date::nextDate(){
    // your implementation here
}
void Date::compareDates(Date &amp;d){
    // your implementation here
}
</code></pre>

<p>That's it. It really helps in having your class declaration and implementation separate.</p>

<p>Check out these links below to help you better understand:</p>

<p><a href=""http://www.learncpp.com/cpp-tutorial/89-class-code-and-header-files/"" rel=""nofollow noreferrer"">http://www.learncpp.com/cpp-tutorial/89-class-code-and-header-files/</a></p>

<p><a href=""http://www.cppforschool.com/tutorial/separate-header-and-implementation-files.html"" rel=""nofollow noreferrer"">http://www.cppforschool.com/tutorial/separate-header-and-implementation-files.html</a></p>
",1
46963186,46963036,1,"<p>VisualStudio tells me the code crashes for accessing not-allocated memory.  </p>

<p>You use <code>list[listMax]</code> several times, which shouldn't be and isn't OK.<br>
The last item in an array <code>a</code> with length <code>len</code> is <code>a[len-1]</code>, not <code>a[len]</code> (Because array indices start from 0 in C).  </p>

<p>By the way, it also tells me that in <code>findName()</code> you use <code>z</code> while it's uninitialized, which is undefined behavior.</p>
",1
37402222,37402001,0,"<p>The problem is that the Integrators you create are destroyed when the function CreateIntegrator finishes execution. For example:</p>

<pre><code>if(string(argv[1])==""Euler"") {
  EulerIntegrator Euler;
  integrator=&amp;Euler;
  return integrator;
}
</code></pre>

<p>Here, the instance of Euler is local within this scope and will be destroyed when you exit the function. This instance is stored in the stack. You need to create it in the heap. To do so you need to do something like this:</p>

<pre><code>if(string(argv[1])==""Euler"") {
  EulerIntegrator *Euler = new Euler();
  integrator = Euler;
  return integrator;
}
</code></pre>

<p>Make sure to delete the pointer after you use it or, even better, use a unique_ptr if you use C++11 or above.</p>
",0
44369811,44369754,1,"<p>It doesn't look like you ever assigned the new value to anything</p>

<pre><code>BRUCH t1;
BRUCH new_value = t1.Eingabe();
</code></pre>
",0
44369974,44369754,1,"<p>I solved the problem. </p>

<p>I changed the <code>return bruch;</code> to <code>return *this;</code> and removed the 'bruch' obj. from the code. The assignment is now <code>z = _z, n = _n;</code>. This returns the current object I am working with. </p>

<p>Sorry for any inconvenience.</p>
",1
45037198,44984078,0,"<p>The easiest way is to use a lambda expression like this:</p>

<pre><code>auto add = [](int a, int b) { return a+b; };
cout &lt;&lt; add(10, 20) &lt;&lt; endl; // Output: 30
</code></pre>

<p>More info about how lambda expressions work: <a href=""http://en.cppreference.com/w/cpp/language/lambda"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/language/lambda</a></p>
",0
46084923,46079351,0,"<p>Several things:</p>

<ul>
<li>You should be counting <em>down</em> from 999 thru 100.</li>
<li>You should be using two loops for the two factors of your product</li>
<li><code>rev</code> should be initially zero before each entrance into your inner do-while loop</li>
</ul>

<p>The results would look something like this, with all but the detected palindromes and final result being output (the amount of worthless noise in your output is mind-bending)</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    int  product;
    int  n, digit, rev = 0;
    int  greatest = 0;

    for(int i = 999;i&gt;=100; --i)
    {
        for (int j =999; j&gt;=100; --j)
        {
            product = j * i;
            n = product;
            rev = 0;
            do
            {
                rev = (rev * 10) + (product % 10);
                product /= 10;
            } while(product != 0);

            if(n == rev)
            {
                cout &lt;&lt; ""Palindrome : "" &lt;&lt; i &lt;&lt; "" * "" &lt;&lt; j &lt;&lt; "" = "" &lt;&lt; n &lt;&lt; endl;
                if(rev &gt; greatest)
                    greatest = rev;
            }
        }
    }
    cout &lt;&lt; ""The Greatest Palindrome Number Is : "" &lt;&lt; greatest &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>This will conclude the correct answer you seek.</p>

<p><strong>Faster</strong></p>

<p>Optionally, you can squeeze better performance out of this by understanding a few additional details:</p>

<ul>
<li>The task is to find the largest palindrome, not just the <em>longest</em> palindrome. Therefore, once you find one, any product, palindrome or not, that is a smaller magnitude than the current largest palindrome is pointless to even check and the inner loop can be terminated (thus the reason you're counting <em>down</em>).</li>
<li>A little number crunching will allow you to conclude that at least one of the factors <em>must</em> be divisible by 11. I won't cover why, but do the math, it's true. Therefore, you can make one of your loops a count-down from the largest 3-digit multiple of 11 (990) to 100, in steps of (-11).</li>
</ul>

<p>The result looks like this:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    int  greatest = 0;

    for(int i = 999;i&gt;=100; --i)
    {
        for (int j =990; j&gt;=100; j-=11)
        {
            int product = j * i;
            if (product &lt; greatest)
                break;

            int n = product;
            int rev = 0;
            do
            {
                rev = (rev * 10) + (product % 10);
                product /= 10;
            } while(product != 0);

            if(n == rev)
            {
                cout &lt;&lt; ""Palindrome : "" &lt;&lt; i &lt;&lt; "" * "" &lt;&lt; j &lt;&lt; "" = "" &lt;&lt; n &lt;&lt; endl;
                if(rev &gt; greatest)
                    greatest = rev;
            }
        }
    }
    cout &lt;&lt; ""The Greatest Palindrome Number Is : "" &lt;&lt; greatest &lt;&lt; endl;
    return 0;
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>Palindrome : 995 * 583 = 580085
Palindrome : 993 * 913 = 906609
The Greatest Palindrome Number Is : 906609
</code></pre>
",3
38092336,38092220,3,"<p>You successfully included <code>sys/stat.h</code> which gives you access to the function: <code>int stat(const char *path, struct stat *buf);</code> whose address you are trying to cast to an unsigned. On a 32 bit platform this is ok (since possibly both the address and <code>unsigned</code> are 32 bit values), but for your 64 bit the `unsigned^ (possibly) is 32 bit and the address is 64 bit. That's why the compiler is complaining about losing precision.</p>

<p>See more about stat: <a href=""http://linux.die.net/man/2/stat"" rel=""nofollow"">http://linux.die.net/man/2/stat</a></p>

<p>But why actually do you want to cast the address of a function in bitwise operations?</p>
",3
46631838,46631719,0,"<p>You can replace the:</p>

<pre><code>    if (j &gt; (i / j))
        cout &lt;&lt; i &lt;&lt; "" is "" &lt;&lt; sum &lt;&lt; endl;
</code></pre>

<p>with:</p>

<pre><code>    if (j &gt; (i / j)) {
        cout &lt;&lt; i &lt;&lt; "" is "" &lt;&lt; sum &lt;&lt; endl;
        sum++;
    }
</code></pre>

<p>or even (in the same line) with:</p>

<pre><code>    if (j &gt; (i / j))
        cout &lt;&lt; i &lt;&lt; "" is "" &lt;&lt; sum++ &lt;&lt; endl;
</code></pre>
",0
46631888,46631719,0,"<pre><code>int sum = 1;

for (int i = 2; i &lt; 1000; i++) {
  bool found=false;
  for (int j = 2; j*j &lt;= i; j++) {
    if (!(i % j)) {
      found=true; // if factor found, not prime
      break;
    }
  }

  if (!found) {
    std::cout &lt;&lt; i &lt;&lt; "" is "" &lt;&lt; sum &lt;&lt; std::endl;
    ++sum;
    break;
  }
}
</code></pre>
",0
46631890,46631719,-1,"<p>From what I can understand the below code should do your job</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;math.h&gt;
using namespace std;

int main() {
    int num=0,i,j;
    for(i=2;i&lt;1000;i++){
        int flag=0;
        for(j=2;j&lt;=sqrt(i);j++){
            if(i%j==0){
                flag=1;
                break;
            }
        }
        if(flag==0){
            num++;
            cout&lt;&lt;num&lt;&lt;""is""&lt;&lt;i&lt;&lt;""\n"";
        }
    }
    return 0;
}
</code></pre>

<p>The output it produces is </p>

<pre><code>1is2
2is3
3is5
4is7
5is11
6is13
7is17
8is19
9is23
</code></pre>

<p>and so on till 1000</p>
",1
46633793,46631719,-1,"<p>I think you want the output like this: (like this: 2 is 1, 3 is 2 , 5 is 3, 7 is 4, 11 is 5 and so on</p>

<pre><code>int main(){

int i, j, num;

num = 1;

for (i = 2; i &lt; 1000; i++) {

    for (j = 2; j &lt;= (i / j); j++)

        if (!(i % j))
            break; // if factor found, not prime

    if (j &gt; (i / j))
        cout &lt;&lt; i &lt;&lt; "" is "" &lt;&lt; num++ &lt;&lt; endl;
}
return 0;
}
</code></pre>
",0
47548716,47548643,0,"<p>PDF has special encoding, so you can't just open it as text. </p>

<p>You can use <a href=""http://www.xpdfreader.com/"" rel=""nofollow noreferrer"">Xpdf</a> C++ library to extract plain text from a PDF file.</p>
",0
44645037,44644817,1,"<p>For better understanding read it from right to left.</p>

<pre><code>(struct in_addr*)&amp;(address-&gt;sin_addr.s_addr)
</code></pre>

<p>So,</p>

<pre><code>address-&gt;sin_addr.s_addr --&gt; uses the ""address"" ptr to access sin_addr.s_addr
</code></pre>

<p>then</p>

<pre><code>&amp;(address-&gt;sin_addr.s_addr) takes the address of s_addr.
</code></pre>

<p>then </p>

<pre><code>(struct in_addr*) casts the address taken by &amp; to in_addr.
</code></pre>

<p>The above makes sense because the following 2 are equivalent in this case</p>

<pre><code>(struct in_addr*)&amp;(address-&gt;sin_addr.s_addr) 
(struct in_addr*)&amp;(address-&gt;sin_addr)
</code></pre>

<p>The address of the struct is the same as the address of its first member in C/C++.</p>
",5
44645555,44644817,1,"<p>To answer your first question, it is indeed casting the <em>address</em> of?the <code>address-&gt;sin_addr.s_addr</code>?field to a <code>struct in_addr*</code> pointer. Since the question is tagged <code>c++</code>, a C++ style cast would make this clearer:</p>

<pre><code>inet_ntop(PF_INET, reinterpret_cast&lt;struct in_addr*&gt;(&amp;(address-&gt;sin_addr.s_addr)), ip, sizeof(ip)-1);
</code></pre>

<p>To answer your second question, it is not casting a variable itself to a pointer. It is casting the <em>address</em> of the variable to a different pointer type. In this case, the <em>address</em> of the <code>s_addr</code> field is casted to a <code>struct in_addr*</code> pointer. The address of the first field of a type is the same as the address of the type itself. So it is technically safe to cast the <em>address</em> of <code>s_addr</code> to <code>struct in_addr*</code>.</p>

<p>However, that being said, the cast is <em>redundant</em> and should be removed. The second parameter of <code>inet_ntop()</code> is a <code>const void*</code>, and any pointer can be assigned as_is to a <code>void*</code>.  When the first parameter is <code>(AF|PF)_INET</code>, the second parameter must be a pointer to a <code>struct in_addr</code>, so you should use the address of the <code>sin_addr</code> field itself (which is an actual <code>in_addr</code>), not its <code>s_addr</code> field (which is a field inside of the <code>in_addr</code>):</p>

<pre><code>inet_ntop(AF_INET, &amp;(address-&gt;sin_addr), ip, sizeof(ip)-1);
</code></pre>

<p>If you have an IPv6 address (the first parameter is <code>(AF|PF)_INET6</code>), the second parameter must be a pointer to a <code>struct in6_addr</code>, which would be the <code>sin6_addr</code> field of a <code>sockaddr_in6</code>:</p>

<pre><code>inet_ntop(AF_INET6, &amp;(address-&gt;sin6_addr), ip, sizeof(ip)-1);
</code></pre>

<p>In order to support both families (the primary reason  for using <code>inet_ntop()</code> in the first place), <code>address</code> should be a pointer to a <code>struct sockaddr_storage</code> (which is large enough to hold any <code>struct sockaddr_...</code> type, but in this case IPv4 and IPv6 addresses), and <code>ip</code> needs to be at least 46 chars (best to use the <code>INET6_ADDRSTRLEN</code> define for that). Then you can do the following:</p>

<pre><code>switch (address-&gt;ss_family) 
{
    case AF_INET:
        inet_ntop(AF_INET, &amp;(reinterpret_cast&lt;struct sockaddr_in*&gt;(address)-&gt;sin_addr), ip, sizeof(ip)-1);
        break;
    case AF_INET6:
        inet_ntop(AF_INET6, &amp;(reinterpret_cast&lt;struct sockaddr_in6*&gt;(address)-&gt;sin6_addr), ip, sizeof(ip)-1);
        break;
}
</code></pre>
",0
44743732,44737119,1,"<p>First, you need to understand the difference between numeric addition and string concatenation.</p>

<p>Yes, in C++, the <code>+</code> operator is used for both of them (we call that operator overloading). But that doesn't mean it's the same thing.
In your example, you are subtracting ordinal number of character <code>'0'</code> from your <code>char</code> digit, which indeed gives you the numeric value your digit represents. You add these up, ending with 11.</p>

<p>If you want to concatenate the digits into a string, you need to 1/ create the string and 2/ concatenate the digits to it. As you'll be using the string's <code>+</code> operator, the compiler will do concatenation instead of numeric addition.</p>

<p>So something like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main(int argc, char * const argv[]) {
    char a[] = {'1', '2', '3', '5'};

    int num = 0;
    std::string str;

    for (char c : a) {
        num += c - '0';
        str += c;
    }

    std::cout &lt;&lt; ""num == "" &lt;&lt; num &lt;&lt; std::endl;
    std::cout &lt;&lt; ""str == "" &lt;&lt; str &lt;&lt; std::endl;

    return 0;
}
</code></pre>
",1
45745141,45744980,0,"<p>First off, welcome to the C++ world! Now, let's move onto your problem. If you take a look at this line, </p>

<pre><code>while (name != ""Alice"" || name!= ""Bob"")
</code></pre>

<p>As others have said, this contains the problem. You are basically saying: </p>

<pre><code>while (the name is NOT ""Alice"" OR the name is NOT ""Bob"")
</code></pre>

<p>Names cannot be two things at once. In order to hit this condition, your name will have to be Bob Alice or Alice Bob. If you look at the following line of code</p>

<pre><code>std::cin &gt;&gt; name;
</code></pre>

<p>This will be impossible. The computer is only taking one word. The condition will never hit. In order to fix this, you should do the following:</p>

<pre><code>while (name != ""Alice"" &amp;&amp; name != ""Bob"")
</code></pre>

<p>That will fix the problem. Also, if you would like to improve your code, you can do the following:</p>

<pre><code> #include &lt;iostream&gt;
 #include &lt;string&gt;

int main()
{
std::string name = """";

std::cout &lt;&lt; ""Please enter the correct name: "";
std::cin &gt;&gt; name;

while (name != ""Alice"" &amp;&amp; name != ""Bob"")
{
    std::cout &lt;&lt; ""Please enter the correct name: "";
    std::cin &gt;&gt; name;
}

std::cout &lt;&lt; ""Hi "" &lt;&lt; name &lt;&lt; ""!"" &lt;&lt; endl;
</code></pre>
",2
39632973,39632847,0,"<p>Try this code:    </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;

using namespace std;

class dateType {
  // defining the class

public:

  void setDate(int month, int day, int year);
  // Function to set the date

  int getDay() const;

  int getMonth() const;

  int getYear() const;

  void printDate() const;

  dateType(int month, int day, int year);
  dateType();

  bool isLeapYear(int yNumber);
  int dMonth;
  int dDay;
  int dYear;

private:
  int yearCalc;
  // integer to store the year, only numbers above 0 will be valid
  int monthCalc;
  // variable to store the month, January through December (1-12)
  int dayCalc;
  // variable to store the day, this varies depending on the month
  // aka 28 days in February unless it is a leap year, 31 days January, etc.
  int outputDate;
  //
};

// function definitions - setDate needs to check for validity
void dateType::setDate(int month, int day, int year) {
  bool notValid;
  // we need to use a switch in order to run through each month.

  switch (month) {
    // months with 28 days - February (2), unless Leap year - test for Leap year
  case 2:
    cout &lt;&lt; ""February"" &lt;&lt; endl;
    if (isLeapYear(year))
      cout &lt;&lt; ""Leap year - 29 days"" &lt;&lt; endl;
    if (day &gt; 29)
      notValid = true;
    break;


    // months with 31 days - April (4), June (6), September (9) November(11)
  case 4:
    cout &lt;&lt; ""April - valid, 30 days"" &lt;&lt; endl;
    break;
  case 6:
    cout &lt;&lt; ""June - valid, 30 days"" &lt;&lt; endl;
    break;
  case 9:
    cout &lt;&lt; ""September - valid, 30 days"" &lt;&lt; endl;
    break;
  case 11:
    cout &lt;&lt; ""November - valid, 30 days"" &lt;&lt; endl;
    if (day &gt; 30)
      notValid = true;
    break;

    // months with 31 days - January (1), March (3), May (5) July(7), August (8), October (10), December (12)
    // will not incude break statement as we do not want to break
    // out of switch until the 31 day checks have been run through
  case 1:
    cout &lt;&lt; ""January - valid, 31 days"" &lt;&lt; endl;
    break;
  case 3:
    cout &lt;&lt; ""March - valid, 31 days"" &lt;&lt; endl;
    // printing out as a test to validate these months
    break;
  case 5:
    cout &lt;&lt; ""May - valid, 31 days"" &lt;&lt; endl;
    break;

  case 7:
    cout &lt;&lt; ""July - valid, 31 days"" &lt;&lt; endl;
    break;

  case 8:
    cout &lt;&lt; ""August - valid, 31 days"" &lt;&lt; endl;
    break;

  case 10:
    cout &lt;&lt; ""October - valid, 31 days"" &lt;&lt; endl;
    break;

  case 12:
    cout &lt;&lt; ""December - valid, 31 days"" &lt;&lt; endl;
    break;
    // now break as we have checked all months ending in 31 days
  default:
    cout &lt;&lt; ""This is not a valid entry"" &lt;&lt; endl;
    break;

  }
  if (day &gt;= 32) {
       notValid = true;
       cout &lt;&lt; ""This is not a valid entry"" &lt;&lt; endl;
  }
  dMonth = month;
  dDay = day;
  dYear = year;
}

int dateType::getDay() const {
  return dDay;
}

int dateType::getMonth() const {
  return dMonth;
}

int dateType::getYear() const {
  return dYear;
}

void dateType::printDate() const {
  cout &lt;&lt; dMonth &lt;&lt; ""-"" &lt;&lt; dDay &lt;&lt; ""-"" &lt;&lt; dYear;

}

dateType::dateType(int month, int day, int year) {
  setDate(month, day, year);
}

bool dateType::isLeapYear(int yNumber)

{

  if ((yNumber % 4 == 0 &amp;&amp; yNumber % 100 != 0) || (yNumber % 400 == 0))
    return true;
  else
    return false;
}

int main() {
  int day;
  int month;
  int year;

  dateType year1(80, 52, 2013);
  cout &lt;&lt; ""Date: "";
  year1.printDate();

  system(""pause"");
  return 0;


}
</code></pre>

<p>You had missed <code>default</code> case in <code>switch(month)</code>. You also have to move this:</p>

<pre><code>if (day &gt;= 32) {
    notValid = true;
    cout &lt;&lt; ""This is not a valid entry"" &lt;&lt; endl;
}
</code></pre>

<p>after switch block. If the month is valid but the day isn't this will handle that case. You had also missed <code>{}</code> in the if block.</p>
",2
39633070,39632847,0,"<p>If month is not in one of the values you specified, nothing is done except setting the month. So for 52, as there is no <code>case 52</code> or <code>default</code>, it just set the month to 52 and that's all.</p>
",0
45068307,45068136,1,"<p>Operator <code>&gt;</code> groups left-to-right, such that <code>10 &gt; value &gt; -1</code> is parsed as <code>(10 &gt; value) &gt; -1</code>; Expression <code>(10 &gt; value)</code> gives either <code>true</code> or <code>false</code>, and both options <code>true &gt; -1</code> and <code>false &gt; -1</code> will always evaluate to <code>true</code>. So your complex condition <code>(10 &gt; value &gt; -1) || ....</code> will always give <code>true</code> (shortcut evaluation).</p>

<p>Write <code>(10 &gt; value &amp;&amp; value &gt; -1)</code> instead.</p>
",0
45068411,45068212,1,"<p>You're getting only numbers because there's no specialization of <code>std::to_string()</code> for <code>char</code>. So when you do <code>to_string(alphabet[random]))</code>, it converts the <code>char</code> to <code>int</code> (which returns the letter's character code) and then converts that to a string. So <code>to_string('a')</code> is <code>""97""</code>, not <code>""a""</code>.</p>

<p>Instead of an array, you could use a string containing the alphabet. <code>std::string::append()</code> allows you to specify a substring to copy from. So you can do:</p>

<pre><code>string alphabet = ""abcdefghijklmnopqrstuvwxyz"";
int random = rand() % alphabet.size();
password.append(alphabet, random, 1);
</code></pre>

<p>This also explains why your password isn't the desired length. When it intends to append a character, it's instead appending 2 or 3 digit numbers.</p>

<p>Finally, you're not clearing <code>password</code> each time you want to generate a new password, so you're appending to the old password. The simple solution to this is to move the <code>string password;</code> declaration inside the first <code>for</code> loop.</p>

<p>You should also call <code>srand(time())</code> at the beginning of your program, so you'll get different passwords every time you run it. Otherwise the program always starts with the same random seed.</p>
",0
45081273,45081183,1,"<p>Constructor uses <a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""nofollow noreferrer"">initialization list</a> in which you simply dynamically allocate memory for <code>mInt</code> variable.</p>

<p>That constructor is the same as this:</p>

<pre><code>int_ptr_wrapper(int value = 0){
mInt = new int(value);
}
</code></pre>
",0
45103720,45103643,2,"<p>This is because your <code>Ninja</code> class is not inhereted from <code>Enemy</code> class. You must define Ninja class like this:</p>

<pre><code>#include ""Enemy.h""

class Ninja : public Enemy
{
    public:
        Ninja();
        void attack();

    protected:

    private:
};
</code></pre>

<p>EDIT: I added #include directive. Without it compiler won't know, where to find <code>Enemy</code> class declaration.</p>
",5
46623541,46623193,0,"<p>One cause of your issues is that <code>==</code> can't be used to compare contents of character arrays.  </p>

<p><strong>Solution 1:  Use <code>std::string</code></strong><br>
The <code>std::string</code> data type is the preferred data structure in C++ for text strings.  </p>

<p>The <code>std::string</code> has overloaded <code>==</code> for comparing strings.  </p>

<p>The <code>std::string</code> also has a <code>find</code> method for searching for a substring.</p>

<p><strong>Solution 2:  Use <code>strcmp</code></strong><br>
The C language uses character arrays for strings.  The C language also has <code>str*()</code> functions for processing character arrays.  </p>

<p>The C++ language uses the <code>str*()</code> functions for processing the C-Style strings (character arrays).  </p>

<p>Use <code>strcmp</code> to compare character arrays with string literals:  </p>

<pre><code>if (strcmp(name, ""Hell"") == 0)
</code></pre>

<p>You may also want to use <code>strstr</code> for finding substrings or <code>strchr</code> for finding characters in a character array (C-style string).  </p>
",0
46066857,46066824,2,"<p><code>test()</code> returns a pointer, it is not a variable, therefore you can't assign anything to it.</p>

<p>If you simply want a void pointer you can just use <code>void* variable_name = new string()</code> or whatever you want to assign to it.</p>
",0
46066902,46066824,1,"<p>@MikaelMello is correct that you cannot set the value of a function.</p>

<p>Extending your code and @MikaelMello 's, you can take the pointer that your function returns and make it point to an object like this:</p>

<pre><code>void* test(){ void * p1; return p1}
...
void* voidPointer = test();
voidPointer = new string();
</code></pre>
",0
46066962,46066824,0,"<p>The lvalue must be a variable. it cannot be a function. When we use assignment operator ""="", what program does is, it assigns the value in the right hand side of the assignment(called the rvalue) to the left hand side value(called the lvalue). So the lvalue must be a variable that have memory to store some value in it.</p>

<p>In your program the lvalue is a function test() which does not have any memory to store anything therefore throws a syntax error.</p>
",0
46066989,46066824,0,"<p>the function <code>test</code> has a return type of <code>void *</code>, thus the expression <code>test()</code> is a rvalue, which cannot be assigned to. only lvalue can appear on the left of an assignment operator. see the <a href=""http://en.cppreference.com/w/cpp/language/value_category"" rel=""nofollow noreferrer"">explanation</a> of lvalue, rvalue, and others.</p>

<p>I'm guessing you probably want to dereference a pointer and assign a new value to it. but if you really want to assign to a return value of a function, the return type must be a lvalue reference type. like</p>

<pre><code>// this function returns a reference to a pointer
void * &amp;test ();
test() = new string;
</code></pre>

<p>you really know what the code should mean, right? if you return a dangling reference and assign value to it, even the syntax has the correct type, the program is still not correct.</p>
",0
45114876,45114780,0,"<p>Move the <code>value = 0;</code> statement from your <code>currentRoll()</code> function to your constructor:</p>

<pre><code>myClass::myClass() : value(0){}
</code></pre>

<p>Replace <code>std::string</code> types with <code>char</code>. Live example on <a href=""http://cpp.sh/8yfm"" rel=""nofollow noreferrer"">cpp.sh</a>.</p>
",3
37693194,37692758,3,"<blockquote>
<pre><code>while(n&gt;(pow(5,p)))
</code></pre>
</blockquote>

<pre><code>while(n&gt;=(pow(5,p)))
</code></pre>

<hr>

<p>Also:</p>

<ol>
<li>You can use <code>n/=5</code> while <code>n</code> instead of using pow.</li>
<li>You don't need extra braces in condition.</li>
<li>You can output result without pushing it into vector.</li>
</ol>
",2
45786994,45786993,2,"<blockquote>
  <p>For sake of exception safe implementation what can I do to ensure that bar's resource member is properly released?</p>
</blockquote>

<p>You can <code>catch</code>, handle and rethrow an anonymous excption in your constructor:</p>

<pre><code>struct bar {
    CostlyResource cr;
    bar() {
        try { // Wrap the whole constructor body with try/catch
            cr.Open(); // Aquire resource

            // something else throws ...
            throw -1;
         }
         catch(...) { // Catch anonymously
             releaseResources(); // Release the resources
             throw; // Rethrow the caught exception
         }
    }
    ~bar() {
        releaseResources(); // Reuse the code ro release resources
    }
private:
    void releaseResources() {
        if(cr.IsOpen()) {
            cr.Release(); // Free resource
        }
    }
};
</code></pre>

<p>See the full example code <a href=""http://coliru.stacked-crooked.com/a/021bd8e87dc2fe85"" rel=""nofollow noreferrer"">here</a> please.</p>

<hr>

<p>As that's a problem frequently asked for dynamic memory allocation done in constructors like</p>

<pre><code>class MyClass {
     TypeA* typeAArray;
     TypeB* typeBArray;
public:
     MyClass() {
         typeAAArray = new TypeA[50];
         // Something else might throw here
         typeBAArray = new TypeB[100];
     }
     ~MyClass() {
         delete[] typeAAArray;
         delete[] typeBAArray;
     }
};
</code></pre>

<p>the easiest way to come over this is either to use an appropriate container (e.g. <code>std::vector&lt;TypeA&gt;</code>, <code>std::vector&lt;TypeB&gt;</code>), or a smart pointer (e.g. <code>std::unique_ptr&lt;TypeA[50]&gt;</code>).</p>
",0
45787248,45786993,1,"<p>An object's lifetime doesn't begin until the constructor is completed.  If you throw an exception from the constructor, then that object's destructor will not be called. Of course, any subobjects that have already been constructed will then be destructed, in reverse order of construction, as you saw in your first example with <code>~foo()</code> appearing.</p>

<p>The code in your second example is not exception-safe. <code>CostlyResource</code> is poorly designed - its own destructor should free the resource. Then your code would be correct.</p>

<p>If you have to work with an existing class that doesn't clean itself up properly then you should make a wrapper that does, e.g.:</p>

<pre><code>struct SafeCostlyResource : CostlyResource
{
    ~SafeCostlyResource()
    {
        if (IsOpen()) 
           Release(); 
    }
};
</code></pre>

<p>and use that as the type of <code>cr</code>. 
(note - this is illustrative pseudocode, there are several ways to approach this problem).</p>
",3
47549462,47548821,0,"<p>you can not call book methods directly from an object of the science class.</p>

<pre><code>science s;
s.read();
</code></pre>

<p>won't work
You can only access the book methods from insight the science class. For example a method in the science class that calls the now private methods from the book class.</p>
",0
47553312,47548821,0,"<p>An easy way to remember if you can access base class functions/members is to see the type of inheritance used.</p>

<h3>Public inheritance</h3>

<p>Every public member/function of the base class remains public in the derived class.</p>

<h3>Protected inheritance</h3>

<p>Every public member/function of the base class becomes protected in the derived class.</p>

<h3>Private inheritance</h3>

<p>Both public and protected members/functions in the base class become private in the derived class.</p>

<p>However it's still possible to expose the interface of private base class by writting a using declaration.</p>

<pre><code>class book
{
  public:
  void show();
};
class science : private book
{
  public:
  void showscience();
  using book::show;
}
</code></pre>

<p>Now you can call book::show through a science object</p>

<pre><code>science s;
s.show();
</code></pre>
",0
45070578,45069913,0,"<p>Sorting 4 parallel arrays can be implemented in exactly the same way as a sorting a single array, except in the part where you would swap two values of the single array, you instead swap the corresponding indices in all 4 of the arrays.</p>

<p>Another approach is to ""zip"" the arrays into a single array of class objects and sort that. This allows you to use a regular sorting algorithm with no changes to swapping, but of course requires zipping and unzipping of the parallel arrays.</p>
",0
45070616,45069913,0,"<p>One way to sort parallel arrays is to not sort the arrays themselves, but sort an array of index values that point to the first, second, third, etc. item into the arrays.  </p>

<p>Here is an example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

int main()
{
    std::string names[5] = { ""Jack"", ""Joe"", ""Alice"", ""Bob"", ""Carol"" };
    int grades[5] = { 80, 75, 90, 95, 68 };
    //...
    int index[5] = { 0,1,2,3,4 };
    //...
    // perform bubble sort on the grades in ascending order
    for (int i = 0; i &lt; 5; ++i)
    {
        for (int j = 0; j &lt; 4; ++j)
            if (grades[index[j]] &gt; grades[index[j+1]])
                std::swap(index[j], index[j+1]);
    }

    // print out the sorted values, sorted by grade in ascending order
    for (int i = 0; i &lt; 5; ++i)
        std::cout &lt;&lt; names[index[i]] &lt;&lt; "" "" &lt;&lt; grades[index[i]] &lt;&lt; ""\n"";
}
</code></pre>

<p><a href=""http://ideone.com/2IaMm1"" rel=""nofollow noreferrer"">Live Example</a></p>

<p>Note that the only thing actually swapped are values in the array of indices.  The arrays with the actual data are never changed.  </p>
",1
45771633,44865495,-2,"<pre><code>bool GodBoolOn = 0;
bool GodBoolOff = 0;

AddLocal(""God Mode"", GET_PLAYER_INVINCIBLE(PLAYER_ID()), GodBoolOn, GodBoolOff);


        if (GodBoolOn)
    {
         SET_ENTITY_INVINCIBLE(PLAYER_PED_ID(), TRUE);
         return;
    }
    else if (GodBoolOff)
    {
         SET_ENTITY_INVINCIBLE(PLAYER_PED_ID(), FALSE);
         return;
    }
</code></pre>

<p>No problem ;)</p>
",1
45041470,45041380,0,"<p>The answer is not the same.
The string ""13.45"" and the floating value 13.45 will be displayed in the same manner. If you want to confirm that result holds a float value try printing result+1 instead of result, it will behave like a normal float.</p>
",5
45073797,45073232,0,"<p>You're defining function in header. This defines the function in every .cpp file you include that header. Linker sees all those functions, doesnt know, that they are intended as the same function and drops you with an error.</p>

<p>Add inline keyword as quick fick.</p>

<pre><code>inline std::ofstream &amp;operator &lt;&lt; (std::ofstream &amp;stream, Triangle &amp;obj) {
   ...
}
</code></pre>

<p>Or declare functions in header and define them in single .cpp file.</p>
",2
45094278,45094171,1,"<p>There's some problems here. First, you reset the value of factorialNumber2 to something undefined. </p>

<p>Next problem is that you have a semicolon after the while loop and that the condition for the loop was wrong. Here is working code:</p>

<pre><code>int main()
{
    int number;
    int factorialNumber;
    int counter = 1;

    cout &lt;&lt; ""Enter a number and I shall find its factorial value."";
    cin &gt;&gt; number;
    factorialNumber=1;

    while(counter &lt;= number)
    {  
        factorialNumber=counter * factorialNumber;
        counter++;
    }

    cout &lt;&lt; factorialNumber;
}
</code></pre>

<p>I renamed the variables, cause factorialNumber and factorialNumber2 didn't really make sense. Another thing you should think of is to not use <code>using namespace</code>. It will hardly affect you at your level, but it's generally a bad idea. <a href=""https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice"">Read why here</a></p>

<p>Also, a pretty good way to start debugging this would have been just some printouts. Here is an example:</p>

<pre><code>int main()
{
    int number;
    int factorialNumber;
    int counter = 1;

    cout &lt;&lt; ""Enter a number and I shall find its factorial value."";
    cin &gt;&gt; number;
    factorialNumber=1;

    cout &lt;&lt; ""Before loop"" &lt;&lt; endl
         &lt;&lt; ""number: "" &lt;&lt; number 
         &lt;&lt; "" factorialNumber: "" &lt;&lt; factorialNumber
         &lt;&lt; "" counter: "" &lt;&lt; counter &lt;&lt; endl;

    while(counter &lt;= number)
    {  
    cout &lt;&lt; ""Begin loop"" &lt;&lt; endl
         &lt;&lt; ""number: "" &lt;&lt; number 
         &lt;&lt; "" factorialNumber: "" &lt;&lt; factorialNumber
         &lt;&lt; "" counter: "" &lt;&lt; counter &lt;&lt; endl;


        factorialNumber=counter * factorialNumber;
        counter++;

    cout &lt;&lt; ""End loop"" &lt;&lt; endl
         &lt;&lt; ""number: "" &lt;&lt; number 
         &lt;&lt; "" factorialNumber: "" &lt;&lt; factorialNumber
         &lt;&lt; "" counter: "" &lt;&lt; counter &lt;&lt; endl;
    }

    cout &lt;&lt; ""After loop"" &lt;&lt; endl
         &lt;&lt; ""number: "" &lt;&lt; number 
         &lt;&lt; "" factorialNumber: "" &lt;&lt; factorialNumber
         &lt;&lt; "" counter: "" &lt;&lt; counter &lt;&lt; endl;

    cout &lt;&lt; factorialNumber;
}
</code></pre>

<p>It looks a bit crappy, but those printouts are intended to be temporary anyway. Also, of course this is a bit overkill, but it shows the general idea.  </p>

<p>Here is what it would have looked like with your original code:</p>

<pre><code>$ ./a.out 
Enter a number and I shall find its factorial value.5
Before loop
number: -155928352 factorialNumber: -155928352 counter: 1
Begin loop
number: -155928352 factorialNumber: -155928352 counter: 1
End loop
number: -155928352 factorialNumber: -155928352 counter: 2
After loop
number: -155928352 factorialNumber: -155928352 counter: 2
-155928352
</code></pre>

<p>With a little experience, you can clearly see what's wrong here. Lastly, use compiler flags to get warnings. Here is an example:</p>

<pre><code>$ g++ yourcode.cpp -Wall -Wextra
yourcode.cpp: In function ¡®int main()¡¯:
yourcode.cpp:18:3: warning: this ¡®while¡¯ clause does not guard... [-Wmisleading-indentation]
   while(counter == factorialNumber2);
   ^~~~~
yourcode.cpp:19:3: note: ...this statement, but the latter is misleadingly indented as if it is guarded by the ¡®while¡¯
   {
   ^
</code></pre>
",0
45094475,45094171,0,"<p>In your code remove semicolon after while loop condition statement</p>

<p>and  replace</p>

<pre><code>factorialNumber=factorialNumber2;
</code></pre>

<p>with</p>

<pre><code>factorialNumber=1;
</code></pre>

<p>Also chnage while loop condition to</p>

<pre><code>while(counter &lt;= factorialNumber2)
</code></pre>

<p>Because this is the variable you're using to store factorials. SO firstly value should be 1.</p>

<p>Whole Code will become</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
int factorialNumber;
int factorialNumber2;
int counter = 1;

 factorialNumber2=5;
factorialNumber=1;

while(counter &lt;= factorialNumber2)
{  
    factorialNumber=counter * factorialNumber;
    counter++;
}

cout &lt;&lt;""Value is""&lt;&lt; factorialNumber;

}
</code></pre>

<p>The Most efficient way of find out factorial is using recursive function.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;
float fact;

int main()
{
  int inputNumber;

  cout &lt;&lt; ""Enter a number and I shall find its factorial value."";
  cin &gt;&gt; inputNumber;
  float result=factorial(inoutNumber);
  cout &lt;&lt; result; 
}

float factorial(n) {

  fact = 1;   
  for i = 1 to N do     
  fact = fact*i; 
  return fact;
}
</code></pre>
",0
45094883,45094171,0,"<p>Your while condition is counter==factorialNumber2"" and its mean that it will run only when both variable values are equal. So while condition always false because couneter start from 1. That's why your program return the value you entered . so try to use following code.  </p>

<pre><code> #include &lt;iostream&gt;
    #include &lt;string&gt;
    using namespace std;
    int main()
    {
    int factorialNumber;
    int factorialNumber2;
    int counter = 1;
    cout &lt;&lt; ""Enter a number and I shall find its factorial value."";
    cin &gt;&gt; factorialNumber2;
    factorialNumber= factorialNumber2;

    while(counter &lt;= factorialNumber2);
    {  
        factorialNumber=counter * factorialNumber;
        counter++;
    }

    cout &lt;&lt; factorialNumber;

    }
</code></pre>
",0
45096659,45096428,0,"<p>Your <code>choose1</code> function does not always return a value, so that means you have <em>undefined behaviour</em> and you're getting garbage results.</p>

<p>Any function of the form <code>int f()</code> <em>must</em> <code>return</code> an integer value. Your <code>switch</code> statement side-steps the only <code>return</code> in the function in all but the default case.</p>

<p>You may have a more aggressive compiler warning that can alert you to this situation, so if you're making mistakes like this there's no shame in turning on a lot of those so these are made more obvious and you don't waste your time debugging.</p>

<p>The basic fix is this:</p>

<pre><code>int choose1(char input){    
    switch(input){
        case 1:
            cout&lt;&lt;""The answer is wrong.... Better luck next time""&lt;&lt;endl;
            return 1;
        case 2:
            cout&lt;&lt;""The answer is wrong.... Better luck next time""&lt;&lt;endl;
            return 1;
        case 3:
            cout&lt;&lt;""The answer is RIGHT.... Because she kick the ball and gravity pull it down ;) ""&lt;&lt;endl;
            return 0;
        default:
            cout&lt;&lt;""You've entered a wrong digit""&lt;&lt;endl;
            return 1; //Same thing with a boolean. If it doesn't have a matching case, return 1 to note that is was a failure.
    }
}
</code></pre>

<p>Using <code>int</code> to represent what's actually a <code>bool</code> is problematic, as is a lot of the duplication here. When approaching a problem like this try and think in terms of <em>data</em> first, then how to display it second. For example, define a <code>std::vector</code> containing a simple <code>struct</code> that defines a question, possible answers, and the correct answer. This minimizes code duplication since you can write one function that displays one of these, asks for input, and validates the answer without having to be copy-pasted over and over.</p>
",3
37829641,37829414,0,"<p>The const char* mean that the caller to what() will receive a string and will not be able to change the string (the char that the pointer is pointing to).
This is an overriding of std::exception::what() so you can return a new explanation to your own exception (this is why you must return const char*, the original method does too)</p>
",2
37829655,37829414,2,"<p>[Update] Since the author is asking more questions, I'll update the answer with both parts.</p>

<p>First of all, this function is an override function of <code>std::exception::what()</code>, the base function is defined that way, so the overrided version has to be the same syntax.</p>

<p>Then let's split the statement into two parts.</p>

<ol>
<li>The return value <code>const char*</code></li>
<li>The part after <code>what() const throw()</code></li>
</ol>

<p>First, check the return statement <code>return ""My exception happened"";</code>, it's returning a const c-like string, the type is <code>const char*</code>, so the return value is defined that way.</p>

<p>Second, the <code>const</code> after <code>what()</code> indicates it's a const function that will not modify any member (except for <code>mutable</code> though) of the class.
The <code>throw()</code> means it never throws.</p>
",2
45067076,45066655,2,"<p>You made a few mistakes in addition to the function declaration.
Function declarations must contain the type of each parameter, so the correct way is:</p>

<pre><code>int winlose(int g);
</code></pre>

<p>You cannot use a condition in an else statement: (<code>else (g=n)</code>). An else statement is a catch-all, if none of the previous conditions (the ones in the <code>if</code> and <code>else if()</code>'s) were met. If you only want this to trigger on a specific condition, use another <code>else if()</code>. You are not required to have an <code>else</code> at the end of every <code>if</code> statement; it is perfectly correct to end with an <code>else if(){...}</code>. </p>

<p>You also need to compare with <code>'=='</code> rather than <code>'='</code>. <code>=</code> is the assignment operator and <code>g=n</code> will set the value of g to n. If you want to check if g is equal to n, you will have to use <code>g==n</code></p>

<p>You should call <code>srand()</code> in the outer loop, otherwise after every guess, value changes.</p>

<p>The rest is corrected and sometimes slightly changed for correct performance:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
using namespace std;

bool winlose(int number, int givenNumber);

int main(){
    int g, n, x;
    bool guessed;
    do {
        srand(time(NULL));
        n = 1 + rand()%100;
        cout&lt;&lt;""Welcome to the guessing game. I have a number between 1-100. Can you guess it?""&lt;&lt;endl;
        do {
            cout&lt;&lt;""Please enter your guess""&lt;&lt;endl;
            cin&gt;&gt;g;
            guessed = winlose(g, n); 
        } while (!guessed);

        cout&lt;&lt;""Play again? Enter 0 for no, any other number for yes.""&lt;&lt;endl;
        cin&gt;&gt;x;
    } while (x!=0);
    return 0;
}

bool winlose(int g, int n) {
    if (g&lt;n) {
        cout&lt;&lt;""Your guess is too low. Try again.""&lt;&lt;endl;
        return false;
    }
    else if (g&gt;n) {
        cout&lt;&lt;""Your guess is too high. Try again.""&lt;&lt;endl;
        return false;
    }
    else {
        cout&lt;&lt;""Congrats! You win. The number was ""&lt;&lt;n&lt;&lt;endl;
        return true;
    }
}
</code></pre>
",0
45112397,45111464,1,"<p>I made my own getline() with while() in it with an integer that increases with every line, and the number that i entered ignores the number of that line, writes to a new file, removes the original file, and renames the temporary file to the original, many thanks</p>
",0
45292307,45292289,0,"<p>Take a look at the data type of myarr and the contents of data.txt.  How would you convert those lines to an integer?  Also maybe check the fail state of infile after doing the read.  Remember that if you just declare an array without initializing its values the array can contain any random number.</p>
",0
45735484,45735231,1,"<blockquote>
  <p>[...] for e.g using ""rand()%2-1"" can help with getting the total sum of 1s
  outputted in the table.</p>
</blockquote>

<p>I dont really understand what you mean by that. Counting and randomness dont go well together. I mean of course you can fill a matrix with random numbers and <strong>then</strong> do some counting, but <code>rand()</code> wont help anything for the counting.</p>

<p>You need something as simple as that:</p>

<pre><code> int main() {
srand(time(0));
const int ROWS=3;
const int COLS=4;

int table[ROWS][COLS];

for (int i = 0; i &lt; ROWS; i ++) {
    for (int j = 0; j &lt; COLS; j++)   {
        table[i][j] = rand()%3-1;
    }
}

unsigned ones_counter = 0;

for (int i = 0; i &lt; ROWS; i ++)  {
    for (int j = 0; j &lt; COLS; j++) {               // dont forget the bracket
        cout &lt;&lt; setw(3) &lt;&lt; table[i][j];
        if (table[i][j] == 1) { ones_counter++;}   // &lt;- this is counting
    }
    cout &lt;&lt; endl;
}

std::cout &lt;&lt; ""number of 1s in the table : "" &lt;&lt; ones_counter &lt;&lt; ""\n"";
....
</code></pre>
",1
38517227,38515846,2,"<p>As mentioned your code does work as expected.</p>

<p>The issue is when you build a c++ program in sublime text it will compile that file and then run. What you see is sublime text piping the output from your program back to a window within sublime text.</p>

<p>Sublime does not have the ability to send input back to your program. Hence why your program ""does not proceed after I input something through cin"". There are some plugins available on the linux version of sublime that give access to a full terminal emulator, I have not tried using one of these but they do exist.</p>

<p>What I would recommend is that you learn how to use the gnu tool chain using the command line.</p>
",0
47462985,47462789,2,"<p>It is not possible at language level, aside from one ""bizarre"" language feature you mentioned yourself: replaceable <code>operator new</code> and <code>operator delete</code> functions. These functions can be replaced through a dedicated mechanism, which is why it is formally referred to as <em>replacement</em> (as opposed to <em>overriding</em> or <em>overloading</em>). This feature is not available to the language user for their own functions.</p>

<p>Outside the limits of standard language you can employ such implementation-specific features as <em>weak symbols</em>, which would allow you to create replaceable functions. For example, virtually all functions in GNU standard C library are declared as weak symbols and can be replaced with user-provided implementations.</p>

<p>The latter is exactly what would facilitate replacement of <code>void sort(int* arr)</code> function in your library. However this does not look like a good design for a library. Function replacement capability should probably reserved for debugging/logging and for other internal library-tuning purposes.</p>
",0
47462920,47462789,2,"<blockquote>
  <p>I mean, is there any legal syntax of function declaration /
  implementation that allows alternative implementation?</p>
</blockquote>

<p>No. That would break the one-definition rule (ODR).</p>

<blockquote>
  <p>Second, I've learned that the global <code>new</code> can be overrided (Although
  it is strongly not recommended).</p>
</blockquote>

<p><em>Replaceable allocation functions</em> as documented at <a href=""http://en.cppreference.com/w/cpp/memory/new/operator_new"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/memory/new/operator_new</a> are really just a very special case, a grey area between language and standard library; certainly not something from which you can infer general rules for your own code.</p>

<blockquote>
  <p>Third, assume that I have written a library: AwsomeLibrary.hpp, which
  my friend wants to include. Among a lot of functions, there is a
  function like void sort(int* arr), which he thinks that he could
  implement better (and of course call it with the same name).</p>
</blockquote>

<p>Such problems are beyond the scope of C++. They are more related to source control versioning systems like <a href=""https://en.wikipedia.org/wiki/Git"" rel=""nofollow noreferrer"">Git</a>. If, for example, your project is under Git control, then your friend could create a branch of the code with his better implementation.</p>
",0
45095309,45093790,0,"<p>Template:  <code>int strcmp ( const char * str1, const char * str2 );</code></p>
<p>strcmp() compares the C string str1 to the C string str2.</p>
<h1>1. return value&lt;0 :</h1>
<p>the first character that does not match has a lower value in ptr1 than in ptr2.</p>
<h1>2. return value=0</h1>
<p>the contents of both strings are equal.</p>
<h1>3. return value&gt;0</h1>
<p>the first character that does not match has a greater value in ptr1 than in ptr2.</p>
<p>The line <code>if(result &gt; 1)</code> should be <code>if(result&gt;0)</code> .</p>
",0
45779527,45779037,4,"<p>Your problem can be found in the error message: <code>no match for 'operator&lt;' (operand types are 'const p_pointer' and 'const p_pointer')|</code>. In order to use <code>map</code> with a custom type (<code>p_pointer</code> in this case), that type needs to declare a comparison operator <code>&lt;</code> which is used to sort the keys in the map. You'll need to implement the <code>&lt;</code> operator, and that should fix this error. (Other errors may show up to replace it though.)</p>

<p>Again, I would recommend just using the existing <code>std::shared_ptr</code> rather than re-implementing it yourself, unless you have some reason not to do so.</p>
",0
46054007,46053655,0,"<p>You can do this:</p>

<pre><code>for (int k = 0; k &lt; width*height; k++)
{
    for(int b = 0; b &lt; 3; b++)
    {
        dst[k*3 + b] = src[k*4 + b];

    }
}
</code></pre>
",0
46054919,46053655,0,"<p>Probably the destination image requires lines aligned on a 4 bytes boundary:</p>

<pre><code>for(unsigned int y(0); y != height; ++y)
{
    unsigned int sourceStart(y * width * 4);
    unsigned int destStart(y * ((width * 3 + 3) &amp; 0xfffffffc) ); // align on 4 bytes
    for(unsigned int x(0); x != width; ++x)
    {
        for(unsigned int color(0); color != 3; ++color)
        {
            dst[destStart++] = src[sourceStart++];
        }
        ++sourceStart; // account for 4th byte in source
    }
}
</code></pre>
",1
47507471,47506761,0,"<p>Make sure you instantiate the same type as the target array element</p>

<pre><code>map[b] =  new Entry{};
</code></pre>

<p>Also, consider not using <code>new</code>/<code>delete</code> in C++. Or raw C arrays.</p>
",2
45678211,45677774,15,"<p>Fundamentally, use <code>wchar_t</code> when the encoding has more symbols than a <code>char</code> can contain.  </p>

<p><strong>Background</strong><br>
The <code>char</code> type has enough capacity to hold any character (encoding) in the ASCII character set.  </p>

<p>The issue is that many languages require more encodings than the ASCII accounts for.  So, instead of 127 possible encodings, more are needed.  Some languages have more than 256 possible encodings.  A <code>char</code> type does not guarantee a range greater than 256.  Thus a new data type is required.  </p>

<p>The <code>wchar_t</code>, a.k.a. wide characters, provides more room for encodings.  </p>

<p><strong>Summary</strong><br>
Use <code>char</code> data type when the range of encodings is 256 or less, such as ASCII.  Use <code>wchar_t</code> when you need the capacity for more than 256.  </p>

<p>Prefer Unicode to handle large character sets (such as emojis).  </p>
",7
45679028,45677774,15,"<p>Never use <code>wchar_t</code>.</p>

<p>When possible, use (some kind of array of) <code>char</code>, such as <code>std::string</code>, and ensure that it is encoded in UTF-8.</p>

<p>When you must interface with APIs that don't speak UTF-8, use <code>char16_t</code> or <code>char32_t</code>. Never use them otherwise; they provide only illusory advantages and encourage faulty code.</p>

<p>Note that there are <em>plenty</em> of cases where more than one <code>char32_t</code> is required to represent a single user-visible character. OTOH, using UTF-8 with <code>char</code> forces you to handle variable width very early.</p>
",1
45679546,45677774,21,"<p><strong>Short anwser:</strong></p>
<p>You should never use <code>wchar_t</code> in modern C++, except when interacting with OS-specific APIs (basically use <code>wchar_t</code> only to call Windows API functions).</p>
<p><strong>Long answer:</strong></p>
<p>Design of standard C++ library implies there is only one way to handle Unicode - by storing UTF-8 encoded strings in char arrays, as almost all functions exist only in char variants (think of <code>std::exception::what</code>).</p>
<p>In a C++ program you have two locales:</p>
<ul>
<li>Standard C library locale set by <code>std::setlocale</code></li>
<li>Standard C++ library locale set by <code>std::locale::global</code></li>
</ul>
<p>Unfortunately, none of them defines behavior of standard functions that open files (like <code>std::fopen</code>, <code>std::fstream::open</code> etc). Behavior differs between OSes:</p>
<ul>
<li>Linux is encoding agnostic, so those function simply pass char string to underlying system call</li>
<li>On Windows char string is converted to wide string using user specific locale before system call is made</li>
</ul>
<p>Everything usually works fine on Linux as everyone uses UTF-8 based locales so all user input and arguments passed to <code>main</code> functions will be UTF-8 encoded. But you might still need to switch current locales to UTF-8 variants explicitly as by default C++ program starts using default <code>&quot;C&quot;</code> locale. At this point, if you only care about Linux and don't need to support Windows, you can use char arrays and <code>std::string</code> assuming it is UTF-8 sequences and everything &quot;just works&quot;.</p>
<p>Problems appear when you want to support Windows, as there you always have additional 3rd locale: the one set for the current user which can be configured somewhere in &quot;Control Panel&quot;. The main issue is that this locale is never a unicode locale, so it is <em>impossible</em> to use functions like <code>std::fopen(const char *)</code> and <code>std::fstream::open(const char *)</code> to open a file using Unicode path. On Windows you will have to use custom wrappers that use non-standard Windows specific functions like <code>_wfopen</code>, <code>std::fstream::open(const wchar_t *)</code> on Windows. You can check Boost.Nowide (not yet included in Boost) to see how this can be done: <a href=""http://cppcms.com/files/nowide/html/"" rel=""nofollow noreferrer"">http://cppcms.com/files/nowide/html/</a></p>
<p>With C++17 you can use <code>std::filesystem::path</code> to store file path in a portable way, but it is still broken on Windows:</p>
<ul>
<li>Implicit constructor <code>std::filesystem::path::path(const char *)</code> uses user-specific locale on MSVC and there is no way to make it use UTF-8. Function <code>std::filesystem::u8string</code> should be used to construct path from UTF-8 string, but it is too easy to forget about this and use implicit constructor instead.</li>
<li><code>std::error_category::message(int)</code> for both error categories returns error description using user-specific encoding.</li>
</ul>
<p>So what we have on Windows is:</p>
<ul>
<li>Standard library functions that open files are broken and should never be used.</li>
<li>Arguments passed to <code>main(int, char**)</code> are broken and should never be used.</li>
<li>WinAPI functions ending with *A and macros are broken and should never be used.</li>
<li><code>std::filesystem::path</code> is partially broken and should never be used directly.</li>
<li>Error categories returned by <code>std::generic_category</code> and <code>std::system_category</code> are broken and should never be used.</li>
</ul>
<p>If you need long term solution for a non-trivial project, I would recommend:</p>
<ul>
<li>Using Boost.Nowide or implementing similar functionality directly - this fixes broken standard library.</li>
<li>Re-implementing standard error categories returned by <code>std::generic_category</code> and <code>std::system_category</code> so that they would always return UTF-8 encoded strings.</li>
<li>Wrapping <code>std::filesystem::path</code> so that new class would always use UTF-8 when converting path to string and string to path.</li>
<li>Wrapping all required functions from <code>std::filesystem</code> so that they would use your path wrapper and your error categories.</li>
</ul>
<p>Unfortunately, this won't fix issues with other libraries that work with files, but many are broken anyway (do not support unicode).</p>
<p>You can check this link for further explanation: <a href=""http://utf8everywhere.org/"" rel=""nofollow noreferrer"">http://utf8everywhere.org/</a></p>
",0
46656511,46656408,1,"<p><code>ofstream ost {""mydata.txt""};</code> opens the file.  </p>

<p>And then your attempt to open it again in the next line fails, because it's already open.<br>
Remove the second line.  </p>

<p>Remove the line <code>ost.close();</code> while you're at it ¡ª the destructor will close it for you when it's time.</p>
",4
46656485,46656408,0,"<p>Try this</p>

<pre><code>    #include ""std_lib_facilities_5.h""

class Point{
    public:

    int x;
    int y;

    // Coordinate members x and y
    Point(int nn = 0 , int mm = 0): x(nn), y(mm){}
    friend ostream&amp; operator&lt;&lt; (ostream &amp;out, const Point &amp;point);
};

ostream&amp; operator&lt;&lt;(ostream&amp; os, const Point&amp; point){
    os &lt;&lt; point.x &lt;&lt; "" "" &lt;&lt; point.y;
    return os;
}

int main()
try {
    int x1, x2;
    vector&lt;Point&gt; original_points;

    for(int i = 0; i &lt; 7; ++i) {
        cout &lt;&lt; ""Please input coordinate points as (x,y): "";
        cin &gt;&gt; x1 &gt;&gt; x2;
        original_points.push_back(Point(x1,x2));
    }
    for(int i = 0; i &lt; 7; ++i){
        cout &lt;&lt; ""Original points: "" &lt;&lt; original_points[i] &lt;&lt; endl;
    }
    ofstream ost;
    ost.open(""mydata.txt"");

    if(!ost) error(""can't open output file "", ""mydata.txt"");

    for(int i = 0; i &lt; original_points.size(); ++i){
        ost &lt;&lt; original_points[i] &lt;&lt; "" "" &lt;&lt; original_points[i];
    }
    ost.close();
}
catch (exception&amp; e) {
    cerr &lt;&lt; ""error: "" &lt;&lt;e.what() &lt;&lt; '\n';
    return 1;
    }
    catch (...) {
        cerr &lt;&lt; ""Oops: unknown exception!\n"";
        return 2;
    }
</code></pre>
",2
45214999,45214582,1,"<p>Well, in C++ you can't concatenante strings with other types like it would be done in Javascript. 
You need to tranform you variables in strings and then concatenate all of theses.</p>

<p>My solution uses stringstreams, wich have the operators defined to push various native types into the stream. Then you can just get the final string from the stream.</p>

<pre><code>std::ostringstream update_cmd;

update_cmd &lt;&lt; ""UPDATE cropdatabase1 SET CropLatitude = '"";
update_cmd &lt;&lt; latitude;
update_cmd &lt;&lt; ""', CropLongitude = '"";
update_cmd &lt;&lt; longitude;
update_cmd &lt;&lt; ""', SownDate = '"";
update_cmd &lt;&lt; SownDate;
update_cmd &lt;&lt; ""', Status = '1',Where UNC = '"";
update_cmd &lt;&lt; unc;

QSqlQuery update_values;
update_values.prepare(update_cmd.str());
update_values.exec();
</code></pre>
",0
46046463,46046427,2,"<p>In the general case, using function pointers <em>requests</em> late binding, but a sufficiently smart compiler could optimize that request and early-bind instead if it can prove that only one function could ever be bound.  This is permitted by the <a href=""http://en.cppreference.com/w/cpp/language/as_if"" rel=""nofollow noreferrer"">as-if</a> optimization rule:</p>

<ul>
<li>Late binding was requested by the program.</li>
<li>But <em>early binding does not change the observable behavior of the program.</em>  Early binding is desirable because it is faster, makes the program smaller, and requires less RAM (<code>pFcn</code> can be removed).</li>
<li>Therefore, early binding may be performed instead.</li>
</ul>

<p>Consider instead where you might pass function pointers around in a way where the compiler is unable to early-bind, either because it is not smart enough to detect that it is possible, or because it is interacting with code that it cannot observe:</p>

<pre><code>using BinaryIntegerOperator = int (*)(int, int);

int Add(int a, int b) { return a + b; }
int Subtract(int a, int b) { return a - b; }

extern int accumulate(
    int initial,
    int *first,
    std::size_t count,
    BinaryIntegerOperator op
);
</code></pre>

<p>Now you can pass <code>Add</code> or <code>Subtract</code> as the fourth argument.  The called function may not be part of the same binary (perhaps it's part of a dynamically-linked library) and so late binding is inevitable -- <code>accumulate()</code> would have already been compiled by a different compiler.</p>
",4
46048966,46046427,0,"<p>In cases where the compilation system can prove there is exactly one function that can be called, it is allowed, but not required, to remove the indirect call and to call the function directly. This applies for both function pointers and virtual method dispatch. Generally for virtual methods, the optimization would happen as part of link time optimization where the linker realizes there is only one instance of a given class with a virtual method, or perhaps no classes which ever override a virtual method.</p>

<p>I'm not sure either optimization is considered incredibly important, but I expect both do happen in simple circumstances with the best compilers. (The first example will fall out of fairly standard compiler optimization techniques. Doing it for vtables will almost certainly require a purpose built optimization pass as the compiler has to know how the vtable is and is not modified at runtime.)</p>

<p>Generally that a use of a mechanism simplifies away does not mean one is not using the named mechanism. That is why one might say the function pointer is dynamic binding even though the compiler can prove it does not have interesting dynamic behavior.</p>

<p>Given the updated code above, consider the following:</p>

<pre><code>int main(int argc, char **argv) {
    Base* bBase = new Base();
    Base* bDerived = new Derived();

    // Use test on argc to abstract arbitrary computation.
    Base *one_or_the_other = (argc &gt; 1) ? bDerived : bBase;
    one_or_the_other-&gt;NonVirtual();
    one_or_the_other-&gt;Virtual();
}
</code></pre>

<p>The compiler can no longer determine at compile time which virtual method to call for the second dispatch.</p>
",0
45773870,45773853,2,"<p>The <code>else if</code> needs a condition to evaluate. So something like <code>else if(some condition){...}</code>.</p>

<p>If you're looking to default after the first <code>if</code> fails, just use <code>else{...}</code>.</p>

<p>Also, you need curly braces around your if and else blocks, and at the end of main.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    float salary,taxrate,incometax;

    cout &lt;&lt; ""Enter your Annual Salary"" &lt;&lt; endl;
    cin &gt;&gt; salary;

    if (salary&gt;= 70000){
      taxrate = 0.4;
      incometax= taxrate*salary;
    }
    else{
      taxrate= 0.3;
      incometax= taxrate*salary;
    }

    cout &lt;&lt; ""The income tax due is: R""&lt;&lt; incometax;
}
</code></pre>
",2
45774006,45773853,0,"<p>Your code has some syntax and logical errors. Like <code>else if()</code> have to given condition, income will be <strong>modified twice</strong>  if you will not put parenthesis.
I will suggest you to follow some tutorial for learning syntax of language.</p>

<p>modified code is below with changes described as comments  .  </p>

<pre><code>#include &lt;iostream&gt;
   using namespace std;

    int main()
    {
        float salary,taxrate,incometax;

        cout &lt;&lt; ""Enter your Annual Salary"" &lt;&lt; endl;
        cin &gt;&gt; salary;

        if (salary&gt;= 70000)//without braces {} if includes only one statement in it
          taxrate = 0.4;
        else         //else if() have to given a condition so use else instead
          taxrate= 0.3;

          incometax= taxrate*salary;//it is conman for both so no need to put it 2 times  

    cout &lt;&lt; ""The income tax due is: R""&lt;&lt; incometax;
</code></pre>
",2
38196043,38195894,2,"<p>
Your problem:</p>

<pre class=""lang-cpp prettyprint-override""><code>int penny = 0.01;
</code></pre>

<p><code>penny</code> is an int, the name is short for 'integral value'. 0.01 is of type double. If you assign a double (either as literal or from another variable) to any form of int (int, long int, short int, ...), only the integral part is assigned and the decimals are dropped (simply dropped, no rounding occurs - no matter how close the value is to the next greater integral one).</p>

<p>So <code>penny</code> actually holds only 0. Alike the other variables, <code>dollar</code> is 1, <code>nickle</code> again 0, ...</p>

<p>You have now two choices. Either, you convert all numbers to double, or you do a little trick by assigning all values in cents:</p>

<pre class=""lang-cpp prettyprint-override""><code>int penny = 1;
int dollar = 100;
</code></pre>

<p>This is what I would prefer. Then only when it comes to outputting you would do appropriate formatting:</p>

<pre class=""lang-cpp prettyprint-override""><code>printf(""the value of my variable is %d.%.2d $\n"", value / 100, value % 100);
</code></pre>

<p><strong>Edit:</strong></p>

<p>As many prefer outputting via std::cout and this gets rather a hassle, a way to do it conveniently would be the following:</p>

<pre class=""lang-cpp prettyprint-override""><code>class Formatter
{
    int value;
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, Formatter f);
public:
    Formatter(int value)
            : value(value)
    {
    }
};
typedef Formatter F, M;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, Formatter f)
{
    char c = s.fill();
    return s &lt;&lt; f.value / 100 &lt;&lt; '.'
        &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; f.value % 100
        &lt;&lt; std::setfill(c); // restore previous fill character!
}
</code></pre>

<p>Typedef is not necessary, of course, just to illustrate other names &ndash; select any one that seems most appropriate to you (F: Formatter, M: Money, D: Dollar, ...). Usage then:</p>

<pre class=""lang-cpp prettyprint-override""><code>std::cout &lt;&lt; F(penny) &lt;&lt; std::endl;
</code></pre>
",2
38196922,38195894,0,"<blockquote>
  <p>I use ""cout"" instead of ""printf"" if that matters.</p>
</blockquote>

<p>No it won't matter with whatever output you were expecting.</p>

<p>Use all the variables you want to manipulate w.r.t. decimals as 'double' data type. </p>
",2
38197154,38195894,1,"<p>As stated, the problem is that you are trying to assign a decimal value to an integer variable.</p>

<p>What occurs, is that your input (in the case of decimal values) can either be interpreted as a <code>double</code> or a <code>float</code> -type variable by the compiler. During the assignment of the given input however, <code>int</code> or fully, an integer, can only hold a value without a fractional component. Compiler takes note of this, and simply narrows your given input into a value the <code>int</code> variable can hold. The compiler isn't interested about anything after the decimal point, and simply discards the rest.</p>

<p>Thus,</p>

<pre><code>int a = 3.5 // int can't hold the decimal 0.5, narrows into 3
int b = 3 // int can hold this, no narrowing
double d = 3.5 // double can hold this, no narrowing
float f = 3.5 // float can hold this, no narrowing
</code></pre>

<p>A good way would be to replace all your integer variables with the type <code>double</code>. In this simple a program, you shouldn't have the need to use <code>printf</code> to format the input.</p>

<p>And in the case you are wondering, why would I want to use <code>double</code> instead of <code>float</code>. </p>

<p>Here is some additional information:</p>

<p><a href=""https://softwareengineering.stackexchange.com/questions/188721/when-do-you-use-float-and-when-do-you-use-double"">https://softwareengineering.stackexchange.com/questions/188721/when-do-you-use-float-and-when-do-you-use-double</a></p>

<p><a href=""https://stackoverflow.com/questions/1074474/should-i-use-double-or-float"">Should I use double or float?</a></p>
",4
38198023,38195894,1,"<p>If you want to keep integers, cast the result to a float or double. Then set precision to 2 digits and fixed format. </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

...

float total = (float) ((hundred * hundredBill) + (fifty * fiftyBill) + (twenty *    twentyBill) + (ten * tenBill) + (five * fiveBill) + (dollars * dollar) + (halfDollar * halfDollars) + (quarter * quarters) + (dime * dimes) + (nickle * nickles) + (penny * pennies));
cout &lt;&lt; std::setprecision(2) &lt;&lt; std::fixed &lt;&lt; total &lt;&lt; endl;
</code></pre>
",1
38200128,38199843,2,"<p>Assuming you want to restart the iteration-through-file from scratch each time, you need to <a href=""http://en.cppreference.com/w/cpp/io/basic_istream/seekg"" rel=""nofollow""><em>seek</em> the read cursor</a> before your <code>while</code> loop so that it works even when a previous run reached EOF. You'll also need to first clear the EOF flag (unless you're writing C++11 or later, in which this is done for you).</p>

<p>The language doesn't have any special rule to do this for you when you re-enter a <code>while</code> loop predicated on extraction from a stream.</p>

<pre><code>    for(int counter = 0; counter &lt; 1000; counter++)
    {
        // Clear EOF flag, and revert to the beginning of the stream
        points.clear();
        points.seekg(0);

        // Extract all ""points"" from the file
        while(points &gt;&gt; Xi &gt;&gt; Yi)
</code></pre>

<p>I'm not quite sure what <code>SSE</code> is supposed to do here as you never actually use its value other than for debug output. I might suggest resetting its value to <code>0</code> on each iteration of the <code>for</code> loop, if I knew what it did. :)</p>
",5
46945868,46945844,1,"<p>You have a problem with recursive header includes: <code>dungeon.h</code> includes <code>character.h</code> while <code>character.h</code> includes <code>dungeon.h</code>. To solve it you can write a header with a forward declaration of <code>dungeon_t</code> and include it into <code>character.h</code> instead.</p>
",0
45722872,45722747,-1,"<p>You can do this via assigning the data to a <a href=""http://en.cppreference.com/w/cpp/string/basic_string/basic_string"" rel=""nofollow noreferrer""><code>std::string</code></a> and use a <a href=""http://en.cppreference.com/w/cpp/io/basic_istringstream"" rel=""nofollow noreferrer""><code>std::istringstream</code></a> bound to that (leaving aside the <code>unsigned char</code> to <code>signed char</code> conversion issues):</p>

<pre><code>std::string s((char*)networkMessage.data(),networkMessage.size());
std::istringstream iss(s);

std::istream&amp; stream = iss;
         // ^ Note the reference here.

processData(stream);
stream.close();
</code></pre>
",5
45723736,45722747,-2,"<p>This will work with vector of any type, not just <code>uint8_t</code>:</p>

<h3>std</h3>

<pre><code>template &lt;class T&gt;
auto make_istringstream_std_1(const std::vector&lt;T&gt;&amp; v) -&gt; std::istringstream
{
    using namespace std::string_literals;
    std::string str;

    for (auto&amp; e : v)
    {
        str += std::to_string(e) + "" ""s;
    }
    // the trailing space is not an issue

    return std::istringstream{str};
}
</code></pre>

<h3>std algorithm</h3>

<pre><code>template &lt;class T&gt;
auto make_istringstream_std_2(const std::vector&lt;T&gt;&amp; v) -&gt; std::istringstream
{
    std::stringstream ss;
    std::copy(v.begin(), v.end(), std::ostream_iterator&lt;int&gt;(ss, "" ""));
    // the trailing space is not an issue

    return std::istringstream{ss.str()};
}
</code></pre>

<h3>boost</h3>

<pre><code>template &lt;class T&gt;
auto make_istringstream_boost(const std::vector&lt;T&gt;&amp; v) -&gt; std::istringstream
{
    using boost::adaptors::transformed;
    using boost::algorithm::join;

    return std::istringstream{
        join(v | transformed([](int a) { return std::to_string(a); }), "" "")};
}
</code></pre>

<hr>

<p>attribution:</p>

<p><a href=""https://stackoverflow.com/questions/2518979/how-to-transform-a-vectorint-into-a-string"">How to transform a vector&lt;int&gt; into a string?</a></p>

<p><a href=""https://stackoverflow.com/questions/1833447/a-good-example-for-boostalgorithmjoin"">A good example for boost::algorithm::join</a></p>
",2
45723485,45722747,4,"<p><code>std::basic_istream</code> gets its data from an associated <code>std::basic_streambuf</code> derived class.  The STL provides such classes for file I/O and string I/O, but not for memory I/O or network I/O.</p>

<p>You could easily write (or find a 3rd party) memory-based <code>streambuf</code> class that uses the <code>std::vector</code> as its underlying buffer, and then you can construct an <code>std::istream</code> that uses that memory <code>streambuf</code>. For example (using the <code>imemstream</code> class from 
<a href=""https://stackoverflow.com/a/13059195/65863"">this answer</a>):</p>

<pre class=""lang-cpp prettyprint-override""><code>std::vector&lt;uint8_t&gt; &amp;data = networkMessage.data;
imemstream stream(reinterpret_cast&lt;const char*&gt;(data.data()), data.size());
processData(stream);
</code></pre>
",0
47614225,47614091,1,"<p>In C++11, you can do this with standard library facilities:
Imports:</p>

<pre><code>#include &lt;chrono&gt;
#include &lt;thread&gt;
std::this_thread::sleep_for(std::chrono::milliseconds(x));
</code></pre>

<p>This is the most basic way to sleep in a thread and works with multithreading.</p>
",1
47614225,47614091,1,"<p>In C++11, you can do this with standard library facilities:
Imports:</p>

<pre><code>#include &lt;chrono&gt;
#include &lt;thread&gt;
std::this_thread::sleep_for(std::chrono::milliseconds(x));
</code></pre>

<p>This is the most basic way to sleep in a thread and works with multithreading.</p>
",1
45739443,45738669,0,"<p>If you want to use the same function for different dimensions within the same program, the only way I see is to pass a pointer to the first element of the array together with the dimensions and then calculate each index on your own, i.e. by  <code>current_row_index * column_size + current_column_index</code>: </p>

<pre><code>void func(int rows, int columns, int **hist) {

    static int arr[10] = {0,1,2,3,4,5,6,7,8,9};

    for(int r=0; r&lt;rows; r++) {
        for(int c=0; c&lt;columns; c++) {
            int* aPtr = &amp;arr[(r*columns+c)%10];
            hist[r*columns + c] = aPtr;
            cout &lt;&lt; *hist[r*columns + c] &lt;&lt; "" "";
        }
        cout &lt;&lt; endl;
    }
}

int main() {


    int *a20x10[20][10] = {};
    int *a5x3[5][3] = {};

    func(20,10,&amp;a20x10[0][0]);
    func(5,3,&amp;a5x3[0][0]);

    return 0;
}
</code></pre>
",0
45739454,45738669,0,"<pre><code>/*But first of all you want to pass by reference, so a 
* more correct function call might be:
*/

void Call(TH1F **Hist, size_t size_x, size_t size_y);

/* allows changing hist or setting to NULL
 * in function
 */
void Call2(TH1F ***Hist, size_t size_x, size_t size_y);

/* with a call like */

int main(void)
{
    TH1F *hist[xlen][ylen] = NULL;

    /* malloc here/memset hist */

    Call(*hist, xlen, ylen);
    Call2(hist, xlen, ylen);
    return (0);
}</code></pre>
",0
45743279,45738669,0,"<p>You can do this with a template function. The template will automatically pick up the dimensions of the array.</p>

<pre><code>template&lt;int C, int R&gt;
void func(TH1F* (&amp;hist)[C][R])
{
    cout &lt;&lt; hist[0][0] &lt;&lt; endl;
}
</code></pre>
",2
45757866,45738669,0,"<p>I managed to get it to work trivially by circumventing the issue: Using a vector of vectors instead of a 2D array. </p>

<p>The answer by Stephan seems the closest to solving it as intended, but did not work. It is also a bit too complicated for me to know how to adjust the code to make it work.</p>
",0
38295788,38295760,0,"<blockquote>
  <p>i want to be able to solve it with out having to include <code>max_proft= -100000000000</code>.</p>
</blockquote>

<p>Well, you'll need to have a minimum starting value somehow. So what's your concern about it?</p>

<p>The lowest starting value you can get is <code>std::numeric_limits&lt;int&gt;::lowest();</code></p>
",1
38295797,38295760,1,"<p>If you want the lowest number possible for <code>max_profit</code> initially then use:</p>

<pre><code>#include &lt;limits&gt;

//...

int max_profit = std::numeric_limits&lt;int&gt;::lowest();
</code></pre>

<p>And if someone has lost more money than that on a stock trade then they have some serious problems ahead...</p>
",4
38298242,38298226,6,"<p>Replace your code with:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    int age;
    cin &gt;&gt; age;
    if (age &lt;= 17) {
        cout &lt;&lt;""Too young"";
    } else if (age &lt;= 42) {
        cout &lt;&lt; ""Adult"";
    } else {
        cout &lt;&lt; ""Senior"";
    }

    return 0;
}
</code></pre>
",8
38298246,38298226,1,"<p>To check if something is 2 conditions at the same time, use the <code>&amp;&amp;</code> operator, which means <code>and</code> and checks for two conditions being true either side. Example for age between <code>44 and 56</code>:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    int age=55;
    if ((age&gt;=44) &amp;&amp; (age &lt;= 56))
    {
       std::cout &lt;&lt; ""YAY!!!\n"";
    }
    return 0;
}
</code></pre>

<p>In C++11 - instead of <code>&amp;&amp;</code>, you can use <code>and</code> keyword.</p>
",10
38298458,38298226,1,"<p>In the above answer, if you wish to use <code>using namespace std;</code>, simply use this piece of code:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    int age;
    cin &gt;&gt; age;
    if ((age&gt;=44) &amp;&amp; (age &lt;= 56))
    {
       cout &lt;&lt; ""YAY!!!\n"";
    }
    return 0;
}
</code></pre>
",3
38298820,38298226,1,"<p>This is how you would do it with a <code>switch</code> statement btw:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main(){

    int age;
    cin &gt;&gt; age;

    switch (age) {
        case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: case 8: case 9: case 10: case 11: case 12: case 13: case 14: case 15: case 16: case 17:
            cout &lt;&lt; ""Too young\n"";
            break;
        case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 27: case 28: case 29: case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37: case 38: case 39: case 40:
            cout &lt;&lt; ""Adult\n"";
            break;
        default:
            cout &lt;&lt; ""Senior\n"";

    }

    return 0;
}
</code></pre>
",0
38298821,38298226,1,"<p>The perfect way:-</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    int age;
    cin &gt;&gt; age;
    if (age &lt; 18 &amp;&amp; age &gt;=0) {
        cout &lt;&lt;""Too young"";
    } else if (age &gt;= 18 &amp;&amp; age &lt;= 42) {
        cout &lt;&lt; ""Adult"";
    } else if(age &gt; 42)
        cout &lt;&lt; ""Senior"";
    }

    return 0;
}
</code></pre>
",1
38291004,38290907,0,"<p>Names may consist of up to 20 characters. You need to reserve space for the terminating NUL character as well. Otherwise, your code <em>may</em> crash if the input really is 20 chars long</p>

<p><code>letternum</code>: Performance (hardly relevant here): You always count to the maximal length <code>20</code>, which may be unnecessarily long; also, you are just lucky that you did not forget to zero the full array.
If you replace the <code>++</code> with a <code>=1</code> in the first loop, you need only sum in the second loop. </p>

<p>Also, why don't you use standards such as <code>string</code> or <code>strcmp</code>?</p>
",2
38294757,38294726,3,"<p>You could check for valid integer inputs, and just reject these:</p>

<pre><code> std::string input;
 while(std::cin &gt;&gt; input) {
      int dummy;
      std::istringstream iss(input);
      if(cin &gt;&gt; dummy) {
          cout &lt;&lt; ""Invalid Entry"" &lt;&lt; endl; //an integer is detected
          continue; // Read again
      }
      // ... process input
 }
</code></pre>
",1
38295569,38294726,0,"<p>There's many possible solutions, but one of my favorites is to call a function that will handle it for me.</p>

<pre><code>bool IsInteger(string line) {
    for (int i=0; i&lt;line.size(); ++i) {
        if (!isdigit(line[i])) {
            return false;
        }
    }

    return true;
}

int main() {
    string input;

    while (cin &gt;&gt; input) {
        if (IsInteger(input)) {
            cout &lt;&lt; ""Integer detected!"" &lt;&lt; endl;
        } else {
            // Do stuff
        }
    }
}
</code></pre>
",0
47968752,47968699,0,"<p>It wasn't a member function, but it would be more OOP and consistent with the <code>add</code> function to simply make <code>reset</code> a <code>public</code> member function.</p>

<pre><code>class Accumulator
{
private:
    int m_value;
public:
    Accumulator() { m_value = 0; } 
    void add(int value) { m_value += value; }

    void reset();
};

// reset() is now a member of the Accumulator class
void Accumulator::reset()
{
    m_value = 0;
}

int main()
{
    Accumulator acc;
    acc.add(5); // add 5 to the accumulator
    acc.reset(); // reset the accumulator to 0

    return 0; 
}
</code></pre>
",0
47968790,47968699,0,"<p>For the syntax <code>reset(acc);</code> to work <code>reset</code> needs to be a free function rather than a member function which would require the syntax <code>acc.reset()</code> for invocation.</p>

<p>The free function <code>void reset(Accumulator &amp;accumulator)</code> has no relation to <code>class Accumulator</code>, so it cannot access the private member <code>m_value</code>.
The friend declaration changes the latter and gives the free function the same access than member functions of <code>Accumulator</code>.</p>

<hr>

<p>Note that this is particularly useful when overloading operators. E.g. <code>operator +</code> should always be declared as free function and usually as friend.</p>
",0
47968803,47968699,0,"<p><code>reset</code> is not a member function. In fact, this code illustrates syntactic differences between a member function <code>add</code> and a non-member function <code>reset</code>, with a <code>friend</code> designation.</p>

<p>Although both functions can access member variables, <code>add</code> does so directly by assigning <code>m_value</code>, while <code>reset</code> must specify <code>accumulator</code> explicitly.</p>

<p>The member/non-member difference shows up at the call site, too, because <code>add</code> is called using member syntax, i.e. <code>acc.add(5)</code>, while <code>reset</code> is called using non-member syntax, i.e. <code>reset(acc)</code>.</p>
",0
47479948,47479905,3,"<p>You need to specify the return type. You have:</p>

<pre><code>template&lt;class ItemType&gt;
PriorityQueueHasAStackedQueue&lt;ItemType&gt;::isEmpty() const
{
    return pq.peek() == nullptr;
}
</code></pre>

<p>You need:</p>

<pre><code>template&lt;class ItemType&gt;
bool PriorityQueueHasAStackedQueue&lt;ItemType&gt;::isEmpty() const
{
    return pq.peek() == nullptr;
}
</code></pre>

<p>(Note the <code>bool</code>.)</p>

<p>Likewise for the other functions.</p>

<p>Your main issue however, is that you do this:</p>

<pre><code>temp.pop();
</code></pre>

<p><code>temp</code> is a pointer. With pointers, you need to use <code>-&gt;</code>. So:</p>

<pre><code>temp-&gt;pop();
</code></pre>

<p>Do this in all places you use <code>pq</code> or <code>temp</code>.</p>
",9
46960663,46960535,1,"<p>Firstly you need to understand that the use of global variables should be avoided </p>

<pre><code>char a;
float c,f;
float resultC, resultF;
</code></pre>

<p>The reason you are getting wrong answers is because you are calculating <code>resultF</code> and <code>resultC</code> before actually taking user input which provides you with garbage values. You need to take <strong>input from the user first then calculate your results</strong>.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main () {
    char a;
    float c,f;
    float resultC, resultF;

cout &lt;&lt; ""Enter your operation (C/F):"" &lt;&lt; endl;
 cin &gt;&gt; a;

 switch (a) {

  case 'C':
      cout &lt;&lt; ""Enter your number to convert Celsius to Fahrenheit""&lt;&lt;endl;
          cin &gt;&gt; c;
      resultF = c*9.0/5.0+32.0;
      cout &lt;&lt; resultF &lt;&lt; endl;
      break;

  case 'F':
      cout &lt;&lt; ""Enter your number to convert Fahrenheit to Celsius""&lt;&lt;endl;

      cin &gt;&gt; f;
      resultC = (f-32.0)*5.0/9.0;  
      cout &lt;&lt; resultC &lt;&lt; endl;
      break;
  }
</code></pre>

<p>}</p>
",1
46960704,46960535,1,"<p>You are doing calculations for doing conversion before you have read the input.
You should read the input and then do the conversions as necessary.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

char a;
float c,f;
float resultC, resultF;

int main () {

    cout &lt;&lt; ""Enter your operation (C/F):"" &lt;&lt; endl;
    cin &gt;&gt; a;

    switch (a) {

        case 'C':
            cout &lt;&lt; ""Enter your number to convert Celsius to Fahrenheit:"" &lt;&lt; endl;
            cin &gt;&gt; c;
            resultF = c*9.0/5.0+32.0;
            cout &lt;&lt; resultF &lt;&lt; endl;
            break;

        case 'F':
            cout &lt;&lt; ""Enter your number to convert Fahrenheit to Celsius""&lt;&lt;endl;                         
            cin &gt;&gt; f;
            resultC = (f-32.0)*5.0/9.0;
            cout &lt;&lt; resultC &lt;&lt; endl;
            break;
    }

}
</code></pre>

<p>You can see in the above code that calculation is done after the input is read. </p>

<p>In your code you are using global variables to store the result and input. Which is not necessary here as there are no other functions you have to share those values.</p>

<p>You can add those variables inside the <code>main()</code> and make it local. You can make them local and re-write the code like this.</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;



int main () {

    char a;
    float c,f;
    float resultC, resultF;

    cout &lt;&lt; ""Enter your operation (C/F):"" &lt;&lt; endl;
    cin &gt;&gt; a;

    switch (a) {

        case 'C':
            cout &lt;&lt; ""Enter your number to convert Celsius to Fahrenheit:"" &lt;&lt; endl;
            cin &gt;&gt; c;
            resultF = c*9.0/5.0+32.0;
            cout &lt;&lt; resultF &lt;&lt; endl;
            break;

        case 'F':
            cout &lt;&lt; ""Enter your number to convert Fahrenheit to Celsius""&lt;&lt;endl;                         
            cin &gt;&gt; f;
            resultC = (f-32.0)*5.0/9.0;
            cout &lt;&lt; resultC &lt;&lt; endl;
            break;
    }

}
</code></pre>

<p>So, If you are declaring a variable outside a function it is global. That is it's value can be accessed and altered by other functions in the program.
If a variable is declared inside the scope of the function it is local to that function. That means, that variable can be used only inside that function.</p>

<p>You can follow this <a href=""https://www.codesdope.com/cpp-scope-of-variables/"" rel=""nofollow noreferrer"">link</a> to learn more and understand about the scopes.</p>

<p>Hope this helps.!</p>
",4
38400968,38400914,3,"<p>The problem is in your function, replace the last line:</p>

<pre><code>int towerheight(void)
{
    int num;
    do
    {
        printf(""Your number must be between 1 - 23: "");
        num = GetInt();
    }
    while (num &lt;= 0 || num &gt;= 24);
    return num; // replace by this
}
</code></pre>

<p>You always return <code>0</code> and the <code>for</code> loop doesn't met the condition because <code>height</code> is always <code>0</code>.</p>
",2
46128004,46127980,1,"<p>Your comparison code is fine. The problem is that you're not calling the function correctly. You need to call the member function through an object. Otherwise, how will it know that it should be comparing with <code>pepper</code>?</p>

<pre><code>if (pepper.sameAge(salty)) {
    // do something
}
</code></pre>

<p>This is basic to all object-oriented programming -- methods are called through objects.</p>
",1
46133204,46133152,1,"<p>There are many ways to achive this,</p>

<p>here's one way:</p>

<pre><code>#include &lt;memory&gt;

class A { 
    public:
    virtual ~A() = default;   // important
    };

class B: public A { };

class C: public A{ };

class D: public A{ };

static std::unique_ptr&lt;A&gt; anArray[] = { 
    std::make_unique&lt;B&gt;(), 
    std::make_unique&lt;C&gt;(), 
    std::make_unique&lt;D&gt;()
    };
</code></pre>
",2
46640027,46639939,1,"<p>You missed to mention array index <code>letters[0]</code></p>

<p>Try this:</p>

<pre><code>char *letters[79] = { ""Aa "",""Bb "",""Cc "", ""/0""};
cout  &lt;&lt; ""Letters are: "" &lt;&lt; letters[0] &lt;&lt; endl;
</code></pre>

<p>output:</p>

<pre><code>Letters are:  Aa  
</code></pre>

<p>Or in loop like this :</p>

<pre><code>char *letters[79] = { ""Aa "",""Bb "",""Cc "", ""/0""};
for(int i=0; i&lt;sizeof(*letters); i++)
    cout  &lt;&lt; ""Letters are: "" &lt;&lt; letters[i] &lt;&lt; endl;
</code></pre>

<p>output:</p>

<pre><code>Letters are:  Aa  

Letters are:  Bb  

Letters are:  Cc  

Letters are:  /0 
</code></pre>
",0
46640271,46639939,0,"<p>Your console output shows the address of the <strong><em>letters</em></strong>, because you are telling it to print the pointer, which points to a memory address. You need a loop to iterate over it. The rest is <a href=""https://www.tutorialspoint.com/cprogramming/c_pointer_arithmetic.htm"" rel=""nofollow noreferrer"">pointer arithmetic</a>.    </p>

<p>Also, ""Aa"" is not a char type, but ""A"" and ""a"" are. So, you should also define them separately; otherwise, it is very likely that you get a compiler warning. Please note that the last character should be ""\0"", not ""/0"". If you could try this:    </p>

<pre><code>int main()
{
    char *letters[79] = { ""A"",""a"",""B"", ""b"", ""C"", ""c"", ""\0""} ;
    int pause;
    cout &lt;&lt; ""Letters are: "";
    for(int i = 0; i &lt; 79; i++){
        cout &lt;&lt; letters[i];
    }
    cout &lt;&lt; endl &lt;&lt; ""Continue (Y or N)"" &lt;&lt; endl ;
    cin &gt;&gt; pause;
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>Then, the output is:   </p>

<pre><code>Letters are: AaBbCc
</code></pre>
",1
46122634,46119957,0,"<p>This works perfectly fine. But only if <code>a_</code> is not <code>private</code>:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

class A {
public:
  A(size_t const&amp; a) : a_(a) {};
  ~A(){};

  //private:                                                                                                                                                    
  size_t a_;
};

bool operator&lt;(A const&amp; left, A const&amp; right) {
  return left.a_ &lt; right.a_;
}


int main() {
  std::vector&lt;A*&gt; v;
  v.push_back(new A(10));
  v.push_back(new A(6));
  v.push_back(new A(8));
  for(auto const&amp; a : v) {
    std::cout &lt;&lt; a-&gt;get() &lt;&lt; std::endl;
  }
  std::sort(v.begin(),v.end());
  for(auto const&amp; a : v) {
    std::cout &lt;&lt; a-&gt;get() &lt;&lt; std::endl;
  }
}
</code></pre>

<p>Implement <code>operator&lt;</code> as a member and that would be solved too:</p>

<pre><code>bool operator&lt;(A const&amp; other) {
  return a_ &lt; other.a_;
}
</code></pre>

<p>Then, <code>a_</code> can be private. </p>
",1
46122830,46119957,1,"<p>Since <code>vector&lt;Team*&gt;</code> stores a pointer you need to overload the <code>operator&lt;(const Team*, const Team*) operator</code> like so:</p>

<pre><code>bool operator&lt;(const Team* left, const Team* right) {
    return left-&gt;whatever &lt; right-&gt;whatever;
}
</code></pre>
",0
43227617,43227540,1,"<p><a href=""http://en.cppreference.com/w/cpp/container/set"" rel=""nofollow noreferrer""><code>std::set</code></a> doesn't have a <code>operator&lt;&lt;</code> defined for it.</p>

<p>Either define your own <code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::set&lt;int&gt;&amp; s)</code>. Eg. :</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::set&lt;int&gt;&amp; s) {
  os &lt;&lt; ""{"";
  std::copy(s.begin(), s.end(), std::ostream_iterator&lt;int&gt;(os, "",""));
  os &lt;&lt; ""}"";
  return os;
}
</code></pre>

<p>Be careful about unintentionally calling this though - you might be hiding mistakes (ref. @Peter's comment below).</p>

<p>Alternatively, you can write a print function (part of a wrapper class around the set or otherwise) of some kind to print the contents of a <code>std::set</code> to a <code>std::ostream</code> in the format that you want. Eg. :</p>

<pre><code>void print_set(std::ostream&amp; os, const std::set&lt;int&gt;&amp; s) {
  os &lt;&lt; ""{"";
  std::copy(s.begin(), s.end(), std::ostream_iterator&lt;int&gt;(os, "",""));
  os &lt;&lt; ""}"";
  return os;
}
</code></pre>
",4
46613650,46613290,0,"<p>Simply change your generator line to:</p>

<pre><code>uniform_int_distribution&lt;char&gt; dis{'A', 'A' + amount - 1};
</code></pre>

<p>I would also recommend adding some validation beforehand, such as:</p>

<pre><code>if (amount &lt; 1 || amount &gt; 26) {
    cout &lt;&lt; ""Bad amount"" &lt;&lt; endl;
    // exit or something
}
</code></pre>
",0
46638760,46638709,-2,"<p>You never make <code>num</code> positive in your loop. All your doing is changing other variables. Also you don't need to reassign num to <code>-1</code> if it's already negative.</p>

<p>You need to add this:</p>

<pre><code>else if (num &gt; 0) {
    odds++;
    oddSum += num;
    num = 1; //becomes positive and breaks the loop.
}
</code></pre>
",0
46638794,46638709,1,"<p>You are also processing negative numbers in this <code>if (num % 2 == 0)</code> part(example: this condition when encountered for first negative integer will also be true e.g <code>-6</code>), thereby incrementing <code>evens</code> and adding this negative number to <code>evenSum</code>, which shoudln't have been done as per your question's requirement; Other thing is that the <code>else</code> part is not necessary, I mean why assign -1 to <code>num</code> instead letting it stay the same number you just read(as it is not in your question's requirement).</p>

<p>I think your <code>else if</code> and <code>else</code> part needs to be changed like this:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main(){

int num;
int evens = 0;
int odds = 0;
int evenSum = 0;
int oddSum = 0;

while (true) {
    cin &gt;&gt; num;

    if (num &lt; 0){
        break;
    }

    if (num % 2 == 0){
        evens++;
        evenSum += num;
    }
    else {
        odds++;
        oddSum += num;
    }
}

cout &lt;&lt; evenSum &lt;&lt; "" "" &lt;&lt; oddSum &lt;&lt; "" "" &lt;&lt; evens &lt;&lt; "" "" &lt;&lt; odds;
return 0;
}
</code></pre>

<p>Keep taking the numbers from input, <code>if num &lt; 0</code> then <code>break</code> and show the results, <code>else</code> check for the number being either <code>odd</code> or <code>even</code> and increment the counters accordingly.</p>
",2
46638795,46638709,-2,"<p>The while part of your loop will keep going until a negative answer is put in. Where are you getting your num from? User input? Your declaration has made it 0, which is making your while loop continue since the condition is >=. If you want user input there should be a cout statement proceeding your cin. </p>
",0
47508442,47508300,0,"<p>I would say:<br>
0 &lt;= (rand()%20) &lt; 20<br>
then:<br>
-10 &lt;= -10 + (rand()%20) &lt; 10</p>

<p>be careful of operator precedence
<a href=""http://en.cppreference.com/w/cpp/language/operator_precedence"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/language/operator_precedence</a></p>
",0
46639244,46638962,1,"<p>I believe an if statement could fix the problem.
If statement in the 4th inner for loop of the first loop.</p>

<pre><code>  for (int j=i;j&gt;=1;j--){
       if(i != n+1 || j != 1){ 
           cout&lt;&lt;""* "";
       }
   }
  cout &lt;&lt; endl;
</code></pre>

<p>when <code>i</code> is in the middle row meaning when <code>i == n+1</code> you have an extra star and when <code>j == 1</code> you have the last star in that middle row so this if statement won't display that last star. you can try this with any input it'll work.  </p>
",3
40534045,40522572,1,"<p>The error is telling you that the signature in the definition of your <code>ParseString</code> method doesn't match that found in the declaration inside the class. You have to copy the <code>enable_if</code> and use it in the declaration as well.</p>

<pre><code>template&lt;typename T&gt;
static typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, void&gt;::type ParseString(T&amp;, std::string);
</code></pre>

<p>You also need another declaration of <code>ParseString</code> that uses <code>enable_if&lt;is_enum&lt;T&gt;&gt;</code> in its declaration, since you define another function that uses it:</p>

<pre><code>template&lt;typename T&gt;
static typename std::enable_if&lt;std::is_enum&lt;T&gt;::value, void&gt;::type ParseString(T&amp;, std::string);
</code></pre>
",1
46965910,46965863,0,"<p>We would need to know the input data values to have a complete understanding, however as others have pointed out, comparisons don't work like that in C++.</p>

<p>Take this comparison:
(m - (1.5*s)) &lt;= score &lt; (m - (0.5 * s))</p>

<p>What this is doing is first evaluating:
(m - (1.5*s)) &lt;= score</p>

<p>Due to the first if statement failing, this will always evaluate to true.  In C++, boolean values are integers, and true is usually represented by ""1"" (in practice it doesn't have to be, and can be represented by any non-zero number, but I think in this specific case it's being set to 1).</p>

<p>Then it's evaluating:
1 &lt; (m - (0.5*s))</p>

<p>Which I'm assuming always returns true given your values of ""m"" and ""s"".</p>

<p>What you should be doing instead is using a compound statement:</p>

<p>if (m - 1.5*s &lt;= score &amp;&amp; score &lt; m - 0.5*s)</p>

<p>(you can keep the parentheses if you like, but they're unnecessary here due to C++'s <a href=""http://en.cppreference.com/w/cpp/language/operator_precedence"" rel=""nofollow noreferrer"">operator precedence rules</a>)</p>
",2
46965948,46965863,2,"<p>An expression like:</p>

<pre><code>a &lt; b &lt; c
</code></pre>

<p>does not do what you think it does. It actually evaluates as:</p>

<pre><code>(a &lt; b) &lt; c
</code></pre>

<p>where <code>a &lt; b</code> is a truth value giving <code>0</code> for false and <code>1</code> for true`. Then <em>that</em> value is used in the rest of the expression.</p>

<p>By way of example, the expression <code>100 &lt; 200 &lt; 42</code> will be true because <code>100 &lt; 200</code> evaluates to <code>1</code>, which is definitely less than <code>42</code>.</p>

<p>Instead you should be using something like:</p>

<pre><code>(a &lt; b) &amp;&amp; (b &lt; c)
</code></pre>

<hr>

<p>In any case, you can clean up that code quite a bit by realising that:</p>

<ol>
<li><p>The construct <code>if (condition) return else ...</code> is totally unnecessary - the <code>return</code> means that the rest of the code will execute only if <code>condition</code> is false, rendering the <code>else</code> superfluous.</p></li>
<li><p>Because your ranges are mutually exclusive, the checks can be simplified. In other words, no need to check if <code>(m - (1.5*s)) &lt;= score</code> in the <code>D</code> case since, if that weren't true, the code would already have returned <code>F</code>.</p></li>
<li><p>It is currently impossible to get an <code>X</code> grade since there is no score that doesn't get captured one of the <code>if</code> statements, excepting <em>possibly</em> some edge cases like <code>NaN</code> but I'm going to assume you're not worried about that.</p></li>
</ol>

<p>With those points in mind, the code can be simplified to:</p>

<pre><code>char grade(double score, double m, double s) {
    if (score &lt; m - 1.5 * s) return 'F';
    if (score &lt; m - 0.5 * s) return 'D';
    if (score &lt; m + 0.5 * s) return 'C';
    if (score &lt; m + 1.5 * s) return 'B';
    return 'A';
}
</code></pre>
",0
46966039,46965863,0,"<p>Just drop all of the lower-bound comparisons (which, as others have said, do not do what you thought): if any of them don¡¯t apply, you would already have returned one of the lower scores.</p>
",0
42659094,42658999,1,"<p>The test</p>

<pre><code>(result != X_WON || result != O_WON || result != DRAW)
</code></pre>

<p>is always true, since result can't be equal to all 3 values.
<code>result</code> should be initialised to <code>UNFINISHED</code> and the test changed to:</p>

<pre><code>(taken != 9 &amp;&amp; result == UNFINISHED)
</code></pre>
",0
47536232,47535943,3,"<p>Your <code>gcd</code> function has a local variable <code>gcd</code> that isn't initialized. It is possible for the function to execute through to the <code>normalize</code> call without assigning a value to <code>gcd</code>. That uninitialized variable's value is then  passed as an argument to <code>normalize</code>.</p>

<p>Your loop inside <code>gcd</code> starts from <code>i = 0</code>. Then <code>i</code> is used as a divisor in the loop as in <code>numerator % i</code>.  That's a division by zero; <code>%</code> calculates the residue of a division, and so is a kind of division operation.</p>

<p>As an aside, you should know about <a href=""https://en.wikipedia.org/wiki/Euclidean_algorithm#Implementations"" rel=""nofollow noreferrer"">Euclid's algorithm for GCD</a>.  Also the <a href=""https://en.wikipedia.org/wiki/Binary_GCD_algorithm#Implementation"" rel=""nofollow noreferrer"">Binary GCD algorithm</a> which uses only bit operations and shifts.</p>
",0
47492042,47492030,0,"<p>OK, I assume your loop is outside the function? 
I further assume that rangeCheck is setting one global, like <code>isValid</code>.</p>

<p>So if your first number is invalid, then the global will be false, but then the second is valid, then that will set <code>isValid</code> to true, so even though the input was invalid, it will not be noted.  You should probably have <code>rangeCheck</code> return true or false if it is valid or not valid.</p>

<p>You also need getDate to return a boolean, so that you will know if the individual responses were valid.</p>
",0
47968544,47968305,10,"<p><strong>TL;DR;</strong> This is <em>ill-formed</em> according to the standard, which is why you get warnings/errors when compiling with gcc/clang. There is an ambiguity between the first and the third call because the implicit conversion sequence from <code>unsigned char</code> to <code>short</code> is worse than the one from <code>unsigned char</code> to <code>int</code> (first one is a conversion while the second one is a promotion).</p>

<hr>

<p>You have to consider 3 different implicit conversion sequences in this example, each one containing a single standard conversion:</p>

<ul>
<li><code>unsigned char</code> to <code>unsigned char</code>, which is an <strong>exact match</strong>.</li>
<li><code>unsigned char</code> to <code>short</code> which is an integral <strong>conversion</strong>.</li>
<li><code>unsigned char</code> to <code>int</code> which is an integral <strong>promotion</strong>.</li>
</ul>

<p>The ranking of the conversion sequences is a follows:</p>

<p><strong>exact match</strong> > <strong>integral promotion</strong> > <strong>integral conversion</strong></p>

<p>For an overload <code>FooA</code> to be better than an overload <code>FooB</code>, implicit conversions for all arguments of <code>FooA</code> have to be <em>not worse</em> than implicit conversions for arguments of <code>FooB</code>, and at least one of the implicit conversion for <code>FooA</code> must be <em>better</em> than the corresponding conversion for <code>FooB</code>.</p>

<p>In your case:</p>

<ul>
<li><code>Foo(int, int)</code> vs. <code>Foo(short, short)</code> &mdash; First one is better because <code>unsigned char</code> to <code>int</code> (promotion) is better than <code>unsigned char</code> to <code>short</code> (conversion).</li>
<li><code>Foo(int, int)</code> vs. <code>Foo(short, unsigned char)</code> &mdash; This is ambiguous:

<ul>
<li><code>unsigned char</code> to <code>int</code> is better than <code>unsigned char</code> to <code>short</code>.</li>
<li><code>unsigned char</code> to <code>int</code> is worse than <code>unsigned char</code> to <code>unsigned char</code>.</li>
</ul></li>
<li><code>Foo(short, short)</code> vs. <code>Foo(short, unsigned char)</code> &mdash; Second one is better because <code>unsigned char</code> to <code>unsigned char</code> (exact match) is better than <code>unsigned char</code> to <code>short</code> (conversion).</li>
</ul>

<p>There is an ambiguity only between <code>Foo(int, int)</code> and <code>Foo(short, unsigned char)</code>, the second overload <code>Foo(short, short)</code> does not participate in the ""ambiguity"". If you remove either the first or the third overload, the ambiguity disappears and the first or the third overload is chosen.</p>
",4
38861206,38861158,7,"<p>If you look higher up in the same source, there are different definitions for those same macros for different compiler syntaxes:</p>

<pre><code>/*
 * Define macros for an interpreter loop. Opcode dispatch may be either by a
 * switch statement or by indirect goto (aka a threaded interpreter), depending
 * on compiler support.
 *
 * Threaded interpretation appears to be well-supported by GCC 3 and higher.
 * IBM's C compiler when run with the right options (e.g., -qlanglvl=extended)
 * also supports threading. Ditto the SunPro C compiler.
 */
#if (defined(__GNUC__) ||                                                         \
     (__IBMC__ &gt;= 700 &amp;&amp; defined __IBM_COMPUTED_GOTO) ||                      \
     __SUNPRO_C &gt;= 0x570)
// Non-standard but faster indirect-goto-based dispatch.
# define INTERPRETER_LOOP()
# define CASE(OP)                 label_##OP:
# define DEFAULT()                label_default:
# define DISPATCH_TO(OP)          goto* addresses[(OP)]

//...

#else
// Portable switch-based dispatch.
# define INTERPRETER_LOOP()       the_switch: switch (switchOp)
# define CASE(OP)                 case OP:
# define DEFAULT()                default:
# define DISPATCH_TO(OP)                                                      \
    JS_BEGIN_MACRO                                                            \
        switchOp = (OP);                                                      \
        goto the_switch;                                                      \
    JS_END_MACRO

// ...

#endif
</code></pre>

<p>If you look further down in the same source, you will see these macros actually being used:</p>

<pre><code>INTERPRETER_LOOP() {

CASE(EnableInterruptsPseudoOpcode)
{
    //...
    DISPATCH_TO(op);
}

* Various 1-byte no-ops. */
CASE(JSOP_NOP)
CASE(JSOP_UNUSED14)
CASE(JSOP_BACKPATCH)
//...
{
    //...
    ADVANCE_AND_DISPATCH(1);
}

CASE(JSOP_LOOPHEAD)
END_CASE(JSOP_LOOPHEAD)

//...

DEFAULT()
{
    //...
    goto error;
}

} /* interpreter loop */
</code></pre>

<p>Depending on the compiler, that code would compile to either this:</p>

<pre><code>static const void* const addresses[EnableInterruptsPseudoOpcode + 1] = {
    ...
};

...

{

label_EnableInterruptsPseudoOpcode:
{
    //...
    goto* addresses[op];
}

* Various 1-byte no-ops. */
label_JSOP_NOP:
label_JSOP_UNUSED14:
label_JSOP_BACKPATCH:
//...
{
    //...
    REGS.pc += 1;
    SANITY_CHECKS();
    goto* addresses[*REGS.pc | activation.opMask()];
}

label_JSOP_LOOPHEAD:
    goto* addresses[JSOP_LOOPHEAD_LENGTH];

//...

label_default:
{
    //...
    goto error;
}

} /* interpreter loop */
</code></pre>

<p>Or to this:</p>

<pre><code>jsbytecode switchOp;

...

the_switch:
switch (switchOp) {

case EnableInterruptsPseudoOpcode:
{
    //...
    switchOp = op;
    goto the_switch;
}

* Various 1-byte no-ops. */
case JSOP_NOP:
case JSOP_UNUSED14:
case JSOP_BACKPATCH:
//...
{
    //...
    REGS.pc += 1;
    SANITY_CHECKS();
    switchOp = *REGS.pc | activation.opMask;
    goto the_switch;
}

case JSOP_LOOPHEAD:
    REGS.pc += JSOP_LOOPHEAD_LENGTH;
    SANITY_CHECKS();
    switchOp = *REGS.pc | activation.opMask();
    goto the_switch;  

//...

default:
{
    //...
    goto error;
}

} /* interpreter loop */
</code></pre>
",1
38861210,38861158,11,"<p><a href=""https://dxr.mozilla.org/mozilla-b2g44_v2_5/source/js/src/vm/Interpreter.cpp#1553"">Look up</a> half a screen:</p>

<pre><code>#if (defined(__GNUC__) ||                                                         \
     (__IBMC__ &gt;= 700 &amp;&amp; defined __IBM_COMPUTED_GOTO) ||                      \
     __SUNPRO_C &gt;= 0x570)
// Non-standard but faster indirect-goto-based dispatch.
# define INTERPRETER_LOOP()
# define CASE(OP)                 label_##OP:
// ... &lt;snip&gt;
#else
// Portable switch-based dispatch.
# define INTERPRETER_LOOP()       the_switch: switch (switchOp)
# define CASE(OP)                 case OP:
// ... &lt;snip&gt;
#endif
</code></pre>

<p>GCC and some other compilers support <a href=""https://gcc.gnu.org/onlinedocs/gcc-3.1/gcc/Labels-as-Values.html"">""computed goto""</a>, which is <a href=""http://eli.thegreenplace.net/2012/07/12/computed-goto-for-efficient-dispatch-tables"">faster than a loop-switch for an interpreter loop</a>, but is non-standard and hence non-portable.</p>

<p>If the compiler supports computed goto, the first branch of this <code>#if</code> defines <code>INTERPRETER_LOOP</code>, <code>CASE(OP)</code> etc. to use computed goto; otherwise, the <code>#else</code> branch defines them in terms of standard facilities.</p>
",3
38863525,38863405,0,"<p>You could think about your problem this way: Get number of chores to input; That number of times, get a specific chore input; Get whether to repeat, and do so if yes.</p>

<p>If you have already covered how to write simple functions, I would suggest breaking up your program into functional (pun intended) parts, each in their own function. This is widely considered good programming practice, and can make programs much more readable. If you aren't comfortable with writing/calling your own functions, don't sweat it for now, but keep this in mind later.</p>

<p>C++ has a bit of a learning curve, but is extremely powerful once you've got the hang of it. Keep it up!</p>
",0
38864791,38863405,0,"<p>You need 2 loops, but your code only has 1 loop.  You need 1 loop to keep asking if chores should be entered, and 1 loop to enter the actual chores.</p>

<p>For example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;limits&gt;

using namespace std;

template &lt;typename T&gt;
T prompt(const char *msg)
{
    T input;
    cout &lt;&lt; msg &lt;&lt; "" "";
    while (!(cin &gt;&gt; input)) {
        cout &lt;&lt; ""Invalid input, try again: "";
        cin.clear();
        cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');
    }

    cin.clear();
    cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');

    return input;
}

template &lt;&gt;
string prompt&lt;string&gt;(const char *msg)
{
    string input;
    cout &lt;&lt; msg &lt;&lt; "" "";
    getline(cin, input);
    return input;
}

int main()
{
    int chores_num;
    string chore;
    char choice;

    do {
        chores_num = prompt&lt;int&gt;(""How many chores would you like to input?"");

        for  (int i = 0; i &lt; chores_num; ++i) {
            chore = prompt&lt;string&gt;(""Enter chore:"");
            //...
        }

        choice = prompt&lt;char&gt;(""Input more chores (Y|N)?"");
    }
    while ((choice == 'y') || (choice == 'Y'));

    // print chore chart...

    return 0;
}
</code></pre>
",2
46937829,46933013,1,"<p>It would be very messy to use same type for enumeration and collection of days. You should differentiate between <code>WeekDay</code> as symbols of days and collections of days as in <code>Weekend</code>. Look at <code>int</code> type. Variable <code>int something</code> could contain only one number. If you want more, you have to use collection: array, <code>vector</code> etc.</p>

<p>I assume that you want to create collections of week days where each day appears only once. For this we usually use sets.</p>

<p>This answer contains samples using <code>std::set</code>, then <code>std::bitset</code>, and custom class.</p>

<p>Sample for <code>std::set</code>.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;set&gt;

enum WeekDay { Saturday, Sunday, Monday, Tuesday, Wednesday, Thursday, Friday };

int main()
{
    std::set&lt;WeekDay&gt;   Weekend{ WeekDay::Saturday, WeekDay::Sunday };
    // For older compilers can be replaced with:
    // std::set&lt;WeekDay&gt;    Weekend;
    // Weekend.insert( WeekDay::Saturday );
    // Weekend.insert( WeekDay::Sunday );

    WeekDay today = WeekDay::Wednesday;

    // There is no Weekend.contains( today )
    // nor something likie Pascal
    // today in Weekend

    // Not so pretty
    if ( Weekend.find( today ) != Weekend.end() )
    //alternative:
    //if ( Weekend.count( today ) )
        std::cout &lt;&lt; ""Weekend :)\n"";
    else
        std::cout &lt;&lt; ""Not weekend :(\n"";
    return 0;
}
</code></pre>

<p>Unfortunately it isn't looking pretty or elegant. I'm open for improvement.</p>

<p>And <code>std::bitset</code> version:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;bitset&gt;

enum WeekDay { Saturday, Sunday, Monday, Tuesday, Wednesday, Thursday, Friday };

int main()
{
    // I don't like this. Number of elements = last element + 1.
    std::bitset&lt;WeekDay::Friday+1&gt;  Weekend;
    Weekend[ WeekDay::Saturday ] = true;
    Weekend[ WeekDay::Sunday ] = true;

    WeekDay today = WeekDay::Wednesday;

    if ( Weekend[ today ] )
        std::cout &lt;&lt; ""Weekend :)\n"";
    else
        std::cout &lt;&lt; ""Not weekend :(\n"";
    return 0;
}
</code></pre>

<p>And custom solution:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;assert.h&gt;

enum WeekDay { Saturday, Sunday, Monday, Tuesday, Wednesday, Thursday, Friday };

class WeekDays
{
public:
    WeekDays() : set( 0 ) {}

    // For older compilers just omit this constructor.    
    WeekDays( const std::initializer_list&lt;WeekDay&gt;&amp; init )
        : set( 0 )
    {
        for ( auto it = init.begin() ; it != init.end() ; ++it )
            insert( *it );
    }

    void insert( WeekDay d )
    {
        assert( d &gt;= WeekDay::Saturday &amp;&amp; d &lt; WeekDay::Friday &amp;&amp; d &gt;= 0 &amp;&amp; d &lt;= 31 );
        set |= 1 &lt;&lt; d;
    }

    bool contains( WeekDay d )
    {
        assert( d &gt;= WeekDay::Saturday &amp;&amp; d &lt; WeekDay::Friday &amp;&amp; d &gt;= 0 &amp;&amp; d &lt;= 31 );
        return ( set &amp; ( 1 &lt;&lt; d ) ) != 0;
    }

private:
    unsigned int    set;
};

int main()
{
    WeekDays    Weekend{ WeekDay::Saturday, WeekDay::Sunday };
    // For older compilers can be replaced with:
    // WeekDays Weekend;
    // Weekend.insert( WeekDay::Saturday );
    // Weekend.insert( WeekDay::Sunday );

    WeekDay     today = WeekDay::Wednesday;
    if ( Weekend.contains( today ) )
        std::cout &lt;&lt; ""Weekend :)\n"";
    else
        std::cout &lt;&lt; ""Not weekend :(\n"";
    return 0;
}
</code></pre>
",1
46938714,46938560,0,"<p>If you want to set <code>new_yaw</code> to <code>10</code> when <code>missedbullets &gt;= 1</code>, then you can combine the two checks into a single <code>if</code> statement using the <code>&amp;&amp;</code> operator:</p>

<pre><code>else if (HasStaticRealAngle(cur) &amp;&amp; (Global::bulletresolver[player-&gt;EntIndex()].missedbullets &lt; 1))
    new_yaw = 32;
else
    new_yaw = 10;
</code></pre>
",3
46978267,46976900,0,"<p>Looking at your student/course code, i notice that <code>Course::getStudent</code> returns a <code>Student</code> rather than a <code>Student &amp;</code>. Basically, that means each time you call <code>getStudent(x)</code>, you get a <em>temporary copy</em> of student <code>x</code>, whose <code>getMt1</code> function will give you a pointer to a temporary field, and any changes you make won't even survive past that statement.</p>

<p>If you have <code>getStudent</code> return a reference or pointer instead, your changes should persist to the Student contained in the array. (They still won't affect <code>tmp_student</code>, though, because <code>addStudent</code> copied it to add it to the array. If you want that reliably, then you need to redo quite a bit of stuff.)</p>
",2
46658659,46658496,1,"<p>Variables as long as they are not <code>const</code> can always be re-written or copied. What it looks like from your code there is an issue with how your extracting the text.</p>

<pre><code>dataIn &gt;&gt; buyingAMT;//These just store whatever is in the line before every space, and sets it with a name 
dataIn &gt;&gt; buyingComm;//So like it takes the characters leading up to the first space and stores it as buyingAMT.
dataIn &gt;&gt; numberBought;
dataIn &gt;&gt; sellingAMT;
dataIn &gt;&gt; sellingComm;
dataIn &gt;&gt; numberSold;
</code></pre>

<p>So what kind of types are <code>dataIn</code> and the other variables here? It seems as though your not splitting the text correctly or don't have a way to do that from dataIn.</p>

<p>This is a small example where one line is taken from stdin (although it can be any stream)</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
  int i;
  std::string input;
  for(i=0;i&lt;3;i++)
  {
    std::cout &lt;&lt; ""Please give me some input:"";
    std::cin &gt;&gt; input;
    std::cout &lt;&lt; ""You gave me:"" &lt;&lt; input &lt;&lt; std::endl;
  }
}

ofstream fout;//data type used to write the data taken from input file and put it on output file
fout.open(output_File_Name);

if (fout.fail())
{
    fout &lt;&lt; ""Input file not found: "" &lt;&lt; output_File_Name &lt;&lt; endl;
    system(""pause"");
    return 0;
}

fout &lt;&lt; setw(20) &lt;&lt; left;//Setting the labels
fout &lt;&lt; ""STOCK"";

fout &lt;&lt; setw(15) &lt;&lt; right;
fout &lt;&lt; ""BUYING AMT"";

fout &lt;&lt; setw(15) &lt;&lt; right;
fout &lt;&lt; ""BUYING COMM"";

fout &lt;&lt; setw(15) &lt;&lt; right;
fout &lt;&lt; ""SELLING AMT"";

fout &lt;&lt; setw(15) &lt;&lt; right;
fout &lt;&lt; ""SELLING COMM"";


fout &lt;&lt; setw(15) &lt;&lt; right;
fout &lt;&lt; ""PROFIT"" &lt;&lt; endl;
</code></pre>
",7
46079553,46079321,0,"<p>No, you cannot make the implicit copy assignment skip members. Defining a custom assignment operator as you have done is the way to achieve your desired behaviour.</p>

<blockquote>
  <p>Doing it this way is verbose and prone to bugs if I later modify this class</p>
</blockquote>

<p>You can group the copied members into a single subobject. That way the custom copy assignment is not fragile to changes and verbosity remains constant in relation to number of copied members.</p>

<p>Bonus: You don't need to specify value initialization for the members separately, but one for the entire subobject is enough.</p>

<pre><code>class Example
{

    int a = 0;
    struct {
        int b;
        int c;
        int d;
        double e;
    } state = {};

public:
    Example&amp; operator=(const Example &amp;rhs)
    {
        state = rhs.state;
        return *this;
    }
...
</code></pre>

<p>Since the members are private this won't change the existing API of the class.</p>
",0
46079700,46079321,3,"<p>You can wrap the ""odd man out"", <code>a</code>, in a struct and define that structs behavior separately:</p>

<pre><code>class Example
{
private:
    CopyLess a;
    int b = 0;
    int c = 0;
    int d = 0;
    double e = 0;

    struct CopyLess {
        int a = 0;
        CopyLess&amp; operator=(const CopyLess&amp;) { return *this; }
        CopyLess(const CopyLess&amp;) {}
    };              
};
</code></pre>

<p>Note that I didn't bother writing any special members for <code>Example</code> anymore because the defaults do what you want. Writing code this way to avoid writing special members as much as possible is called the ""Rule of Zero"", more information and examples: <a href=""http://www.nirfriedman.com/2015/06/27/cpp-rule-of-zero/"" rel=""nofollow noreferrer"">http://www.nirfriedman.com/2015/06/27/cpp-rule-of-zero/</a>.</p>
",0
46936734,46936698,1,"<p>You declare <code>long long* tmp = new long long[this-&gt;amtNumbers + 1];</code> and then use <code>tmp[amtNumbers + 1] = phone;</code> which is out of range. The max index is <code>this-&gt;amtNumbers</code> since the array is 0-indexed.</p>
",0
47615282,47614942,0,"<p>You should use another var for moving next elements to its prev positions. And after removal, you should start searching from the same j position.</p>

<pre><code>for (i=0;i!=n;i++)
{
    for (j=i+1; j!=n; j++)
    {
        if(arr[i]==arr[j])
        {
            int k = j;
            while(k != n-1)
            {
                arr[k]=arr[k+1];
                k++;
            }
            n--;
            --j;
        }
    }
}
</code></pre>
",0
47615282,47614942,0,"<p>You should use another var for moving next elements to its prev positions. And after removal, you should start searching from the same j position.</p>

<pre><code>for (i=0;i!=n;i++)
{
    for (j=i+1; j!=n; j++)
    {
        if(arr[i]==arr[j])
        {
            int k = j;
            while(k != n-1)
            {
                arr[k]=arr[k+1];
                k++;
            }
            n--;
            --j;
        }
    }
}
</code></pre>
",0
46943828,46943626,1,"<p>Note that since you've declared your map, <code>myMap</code> inside the for loop, you're creating an entirely new map every iteration of the loop. You also won't be able to access it outside the loop. Therefore you should declare it before the loop.</p>

<p>From your comment, it looks like you're trying to map all items in your set to 0 except the first. In that case, begin by mapping them all to 0, and then just change the first after:</p>

<pre><code>map&lt;int, int&gt; m;
for(auto iter = Y.begin(); iter != Y.end(); iter++) {
    m[*iter] = 0;
}
if(Y.size() != 0) {
    m[*Y.begin()] = 1;
}
</code></pre>

<p><strong>EDIT</strong></p>

<p>As per your comments below, this should be what you're looking for:</p>

<pre><code>vector&lt;map&lt;int,int&gt;&gt; v;
for(auto iter = Y.begin(); iter != Y.end(); iter++) {
    map&lt;int, int&gt; m;
    for(auto iter2 = Y.begin(); iter2 != Y.end(); iter2++) {
        m[*iter2] = (*iter == *iter2);
    }
    v.push_back(m);
}
</code></pre>

<p><a href=""https://ideone.com/V3X8mZ"" rel=""nofollow noreferrer"">See it in action here</a></p>

<p><strong>EDIT 2</strong></p>

<p>After more comments, it sounds like this is what you're actually looking for:</p>

<pre><code>int arr[ARR_SIZE][ARR_SIZE] = {0}; //initialize whole array to 0's

int count = 0;
for(auto iter = Y.begin(); iter != Y.end(); iter++, count++) {
    arr[count][*iter-1] = 1; //pick out the specific values we want to be 1
}
</code></pre>

<p>(Note that I'm not sure what you mean by <code>e</code>, so I'm ignoring it)</p>

<p><a href=""https://ideone.com/UVBEYR"" rel=""nofollow noreferrer"">See it in action here</a></p>
",15
46944383,46944341,1,"<p>Put the if else condition outside the while loop and remove <code>cout&lt;&lt;""\nWell that was a poor day! I had "" &lt;&lt;customers&lt;&lt;"" customer&lt;s&gt; today. Tomorrow is another day ...""&lt;&lt; endl;</code> outside your while loop.</p>

<pre><code>while (answer == ""yes"")
{
   ...
}
if (customers &gt;= 5)
   cout&lt;&lt;""\nWell that was a good day! I had "" 
       &lt;&lt;customers
       &lt;&lt;"" customer&lt;s&gt; today. Tomorrow is another day ...""
       &lt;&lt; endl;
else
   cout&lt;&lt;""\nWell that was a poor day! I had "" 
       &lt;&lt;customers
       &lt;&lt;"" customer&lt;s&gt; today. Tomorrow is another day ...""
       &lt;&lt; endl;
</code></pre>
",2
39107295,39107009,0,"<p>As Nathan noted, a debugger is a key tool for a programmer.  Stepping through a program line by line and looking for the problem is a key skill for success. </p>

<p>I used a couple of tools to reproduce your problem.  'gdb' is the debugger on Linux.  'valgrind' is a Linux tool that will look for a variety of error including bad memory access.</p>

<p>Valgrind pointed to the neg function.  </p>

<pre><code>void neg()
 {
  node *temp=tail;
  while(temp!=NULL)
  {
   if(temp-&gt;bin==0)
   {  
    cout&lt;&lt;""1"";
    temp=temp-&gt;prev;  // likely temp is first node so temp-&gt;prev == nullptr
   }  
   // missing an 'else' statement here?
   if(temp-&gt;bin==1)  // crash here accessing a nullptr
   {  
    cout&lt;&lt;""0"";
    temp=temp-&gt;prev;                                                                                           
   }
  }
  cout&lt;&lt;endl;
 }  
};
</code></pre>

<p>I added an 'else' statement and the program worked as excepted for your test cases.  </p>

<p>There may be other errors, test your code well. Investigate 'unit testing' for more about testing.</p>
",0
47965218,47965202,1,"<p>Because all members of a class are friends which each other. Private data members can only be modified by members of the class or friend classes.</p>

<p>When you try to access <code>rect.p</code> in <code>main()</code>, you're trying to access private data members from a public interface.</p>

<p>EDIT: fixed a wording error</p>
",0
47965222,47965202,1,"<p><em>p</em> is a private member of your class, therefore only a <em>method</em> of your class can access and/or modify it.</p>

<p><a href=""https://stackoverflow.com/questions/1568091/why-use-getters-and-setters-accessors"">Make some research</a> about getters and setters if you want to know more about it.</p>
",3
47965275,47965202,1,"<p>This is a basic question about access right for a class.</p>

<p>Everything you defined in ""private"":
All the members, functions, friend members/functions of the class have access to the stuff in ""private"" block.</p>

<p>Everything you defined in ""public"":
On the opposite side of ""private"", everyone have access to the stuff in ""public"" block. Integer pointer p is defined in ""private"" block, so it can be used by constructor(because constructor is one part of the class). But main function is ""out of"" class. So main function have no access of pointer p.</p>

<p>If you want to get the point p in main funcion, you can define a public function ""getPointer()"" to return pointer p and call ""getPointer()"" in main function.</p>

<p>Come back to your code.</p>
",3
46940136,46939939,0,"<p>The lines</p>

<pre><code>std::cout &lt;&lt; std::fixed;   // sets a format
std::cout &lt;&lt; std::setprecision(2);  // sets a format
</code></pre>

<p>set the streams output format. </p>

<p>The lines</p>

<pre><code>std::cout &lt;&lt; price1;  // outputs a number
std::cout &lt;&lt; price2;  // outputs a number
std::cout &lt;&lt; priceofitemplustax1;  // outputs a number
std::cout &lt;&lt; priceofitemplustax2;  // outputs a number
std::cout &lt;&lt; total;  // outputs a number
</code></pre>

<p>print the variables to the stream.</p>

<p>Just remove the variable output lines. Do not accept this answer - Credit goes to manni66</p>
",0
46940737,46939939,1,"<pre><code>std::cout &lt;&lt; std::setprecision(2); 
std::cout &lt;&lt; price1;
std::cout &lt;&lt; price2;
std::cout &lt;&lt; priceofitemplustax1; 
std::cout &lt;&lt; priceofitemplustax2; std::cout &lt;&lt; total;
</code></pre>

<p>here you write 5 floats</p>
",0
43966101,43965742,0,"<p>You may use:</p>

<pre><code>std::uint32_t decrypt(std::uint32_t instruction, int increment)
{
    instruction = instruction ^ (0x1F3D8AF * increment);

    for (int i = 0; i != 15; ++i) {
        instruction = Encrypt(instruction, 0);
    }
    return instruction;
}
</code></pre>

<p>And then you have </p>

<pre><code>decrypt(Encrypt(value, increment), increment) == value
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/2dd26d6fd38728e1"" rel=""nofollow noreferrer"">Demo</a></p>
",4
47479788,47479728,1,"<p>Try something like this:</p>

<pre><code>int number1;
int number2;
std::string opr;
cin &gt;&gt; number1 &gt;&gt; number2 &gt;&gt; opr;
</code></pre>

<p>To get to the beginning of the next line, you could add:</p>

<pre><code>cin.ignore(1000, '\n');
</code></pre>
",0
47480034,47479728,-1,"<p>Another possibility is to read it in as a character, and then typecast it to a string, although this is not standard procedure, and I don't recommend it. But, if you want to get the job done, it is a fast an easy way:</p>

<pre><code>  int number 1;
  int number 2;
  char ch;
  string opr;
  cin &gt;&gt; number1 &gt;&gt; number2 &gt;&gt; ch;
  opr = """" + ch;
</code></pre>
",0
47480120,47479728,0,"<p>Assuming I understand what you want correctly.</p>

<pre><code>string x = something.substr(5, 1); // = ""+""
</code></pre>
",0
47650739,47650704,2,"<p>Without quotes, <code>calvin</code> is a variable (which is undefined). You should make it a literal (i.e. <code>""calvin""</code>).</p>
",0
47652287,47650704,1,"<p>firstly i would suggest if you had made and age private class members and also create get name/age and set name/age member functions to protect your data and finally </p>

<pre><code>peeps[1].name = calvin; 
//calvin is an undefined variable
</code></pre>

<p>you should have used string literals for example </p>

<pre><code>peeps[1].name = ""calvin"";
</code></pre>
",0
39338099,39337972,1,"<p>No. ?</p>
<p>You are calling your function 10 times, so whatever memory your function is using is used 10 times. But the function is called again only after it already ended execution, so whatever resources it used are already deallocated.</p>
<p>So in the end, it's using the same amount of memory, just holding it 10 times longer.</p>
<blockquote>
<p>?: This is assuming your function is not leaking memory.</p>
<p>Any memory it allocates manually without freeing, will remain used. So if your function leaks N bytes, that loop will leak 10 times N bytes. But let's hope you're not leaking anything. ;)</p>
</blockquote>
",0
39338682,39337972,0,"<p>This question is ambiguous because there are 2 types memory for C++, dynamic and automatic (often called heap and stack), which have different characteristics.</p>

<pre><code>int count = 0;
while (count &lt; 10) {
   function_call(); // Will this consume 10x more memory?
   ++count;
}
</code></pre>

<hr>

<p>1) will this consume 10x more automatic memory?</p>

<p>Answer - no.  Automatic memory is allocated upon scope entry, and released upon scope exit.  The loop repeated call to function_call() will 'start fresh' each invocation. </p>

<hr>

<p>2) will this consume 10x more dynamic memory?</p>

<p>Answer - not really knowable with what you have provided.</p>

<p>NO - if function_call() does not use dynamic memory</p>

<p>NO - a) if function_call() 'uses' a finite amount of dynamic memory 
        acquired with new(), and 
        b) releases all that dynamic memory using delete prior to returning.</p>

<p>NO - a) if function_call 'uses' a finite amount of dynamic memory acquired 
           with new(), and 
        b) a different_function_call releases the memory appropriately.  </p>

<pre><code>    Research term for you: object lifetime.  Some dynamic memory
    needs to exists longer than the lifetime of the function_call.

    Several other answers mentioned 'memory leaking'.  I consider this a 
    coding error, and thus not relevant to your question.
</code></pre>

<p>Yes - a) if function_call 'uses' a finite amount of dynamic memory acquired
            with new(), and 
         b) no other code releases it, and 
         c) the process (containing function_call) does not terminate.</p>

<pre><code>     On most OS's, terminating the process in which this code runs will 
     cause the release of all dynamic memory (and other resource) back
     to the OS's control, and no longer accessible to the terminated 
     process (or any other process in the form created).

     If it is possible that this process can run until dynamic memory is 
     exhausted, I think what happens next is UB (undefined behavior).
</code></pre>
",0
47690045,47689449,0,"<pre><code>typename Container::iterator iter = ...;
</code></pre>

<p>The compiler defaults to seeing template members as variables, if it's a type you have to say so with ""typename"".</p>
",0
47689888,47689449,0,"<p>If you are able to use a C++11 (or later) compiler, you have couple of more ways to declare <code>iter</code>.</p>

<ol>
<li><p>If you can declare and initialize it in one statement, you can use:</p>

<pre><code>auto iter = map.begin();
</code></pre></li>
<li><p>You can also use <code>decltype</code> to deduce the type.</p>

<pre><code>using iterator_type = decltype(map.begin());
iterator_type iter;
</code></pre></li>
</ol>

<p>I would recommend using the first method. It is less code to deal with. It's also a better programming habit to declare and initialize a variable in one statement.</p>
",0
47650393,47650333,9,"<p>The behaviour of the code is <em>undefined</em>.</p>

<p>After the first <code>cout</code> statement, the pointers are <em>dangling</em>. They were pointing to variables that had automatic storage duration, and are now out of scope.</p>

<p>A C++ compiler is <strong>not required</strong> to issue a diagnostic (a dangling pointer cannot always be identified at compilation time), although some will warn you if you have the appropriate flags set. You can cut down the source of the undefined behaviour to</p>

<pre><code>int main()
{
    int* p;
    {
        int n;
        p = &amp;n;
    }
    *p = 0; // oops
}
</code></pre>
",2
47650854,47650333,0,"<p>Visual C++17 also fails to detect the undefined behavior, and gives the same output.</p>
",3
47481981,47481923,0,"<pre><code>m_srcNode = Node(src);
m_dstNode = Node(dst);
</code></pre>

<p>Here, the two objects are first constructed with default constructor, then the overloaded constructed is called with <code>Node(src)</code> and <code>Node(dst)</code>. After that, the implicitly defined <strong>copy assigner</strong> is called to assign the temporary objects to <code>m_srcNode</code> and <code>m_dstNode</code>. Finally the temporary objects are destroyed.</p>

<p>If you want to avoid extra constructor calls, you can write a <a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""nofollow noreferrer""><strong>member initializer list</strong></a>:</p>

<pre><code>Edge::Edge(string src, string dst) : m_srcNode(src), m_dstNode(dst) {}
</code></pre>


",5
47482003,47481923,2,"<p>A constructor is not like other functions in C++. A constructor's job is to initialize an object. In order to ensure the object gets initialized in a sensible way, all of the member objects (and base objects) need to be initialized. *This happens <strong>before</strong> the opening brace of the constructor body, so that everything is in a sensible state when you're in the constructor body.</p>

<p>To make sure this happens in the way you want, you can use an <a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""nofollow noreferrer""><em>initializer list</em></a> (note that this term also refers to something else when initializing various containers; if you've heard the term before in relation to that, it's not what I'm discussing here). After the function signature, you put a colon, followed by each member of your class (in the same order they're declared in the class) and how you want to initialize it. For example, if you have the following <code>struct</code></p>

<pre><code>struct A {
    int i;
    char c;
    std::string s;
    A();
};
</code></pre>

<p>you can declare define your constructor as</p>

<pre><code>A::A() : i{17}, c{'q'}, s{""Hello, mrb! Welcome to Stack Overflow""}
{
    // Nothing to do in the body of the constructor
}
</code></pre>

<p>That way, an <code>A</code> object's members are initialized to <code>17</code>, <code>'q'</code>, and a greeting <em>before the start of the function</em>, and are not initialized any other way.</p>

<hr>

<p>Since you do not do this, the compiler instead uses the default constructor for the nodes. You then create other nodes inside the constructor body, and assign them to the nodes in your class.</p>
",0
47498909,47498758,2,"<pre><code>unsigned char Mem[0x1000] {0};
</code></pre>

<p>It creates an array of 0x1000 elements, and initializes it using the initializer <code>{0}</code>. That sets the first element to <code>0</code> and then value-initializes the remaining elements, which sets them to <code>0</code> as well.</p>

<p>i.e. it's identical to this, which just value-initializes every element:</p>

<pre><code>unsigned char Mem[0x1000] {};
</code></pre>

<p>That's also identical to saying ={}, except that before C++11 it was only possible to use the ={} form, now you can also use {} without the =</p>

<p>For this case:</p>

<pre><code>unsigned char Mem[0x1000] {0x12, 0x00};
</code></pre>

<p>it sets the first element to <code>0x12</code>, then the second element to <code>0x00</code>, then sets the remainder to <code>0</code>. i.e. it's the same as:</p>

<pre><code>unsigned char Mem[0x1000] {0x12};
</code></pre>

<blockquote>
  <p>If every element is being filled with a zero, why do that?</p>
</blockquote>

<p>In C you can't have an empty initializer, so you can't say <code>{}</code> and have to do <code>{0}</code>. That's not true in C++, so there's no reason to prefer <code>{0}</code> to <code>{}</code> when they do the same thing.</p>

<blockquote>
  <p>Do i need to  ""clean"" every variable I declare?</p>
</blockquote>

<p>If you don't use <em>any</em> initializer then the elements will be uninitialized, so have indeterminate values, and reading an element before you've assigned a value to it would be undefined behaviour.</p>
",1
47533677,47533575,2,"<p>The obvious way would be to write a new function which does exactly what you want, i.e. set <code>letters[0]</code> to <code>'a'</code> etc.</p>

<p>You will probably learn about classes later. A class holds multiple functions, and also multiple data members. Each instance of such a class is called an object, and you'd implement each round of the game as a new object.</p>
",0
47550280,47550226,2,"<p>Your code fails probably because it invokes <em>undefined behaviour</em>.</p>

<pre><code>delete head;
head = head-&gt;next;
</code></pre>

<p>You cannot read the memory located where <code>head</code> points <em>after</em> having <code>delete</code>d <code>head</code>.</p>

<p>You should make a copy of <code>head-&gt;next</code> to reuse it:</p>

<pre><code>const auto next = head-&gt;next;
delete head;
head = next;
</code></pre>
",5
47550485,47550226,0,"<p>This can help you in deleting every node of linked list.</p>

<pre><code>   List&lt;T&gt; *current = head;
   while (current != NULL) 
   {
       next = current-&gt;next;
       delete current;
       current = next;
   }
</code></pre>
",2
47551108,47550226,0,"<p>It depends what type the head variable is. If it is the class, you can even use ""recursive"" deleting in ""head"" (I mean node) destructor. Something similar to:</p>

<pre><code>Node::~Node(){
    if(this-&gt;next != nullptr)
        delete this-&gt;next;
    delete this-&gt;content;
}
</code></pre>

<p>If the node is internal struct, you need temporary pointer to next node as mentioned above:</p>

<pre><code>template&lt;typename T&gt;
List&lt;T&gt;::~List()
{
    struct nodeType *temp;
    while(head != nullptr){
        temp = head-&gt;next;
        delete head;
        head = temp;
    }
}
</code></pre>

<p>In this case, you don't need to explicitly set head to null, since it is done by the logic of while loop.</p>

<p>In your loop (in question) you don't remove *head node, I don't know if it is expected behavior.</p>

<p>Ad. comment above (I can't put it directly):
while(head->next!=NULL){ Node*next = head->next; delete head; head = next; } head = NULL;
is wrong. It doesn't delete last node on the list (especially if the list has only one object, it won't be deleted).</p>
",0
47553755,47550226,1,"<p>I would go with the following solution. No invalid memory access, no memory leak, and it automatically assigns NULL to <code>head</code> before leaving the loop:</p>

<pre><code>template&lt;typename T&gt;
List&lt;T&gt;::~List()
{
    while (head)
    {
        Node&lt;T&gt; *next = head-&gt;next;
        delete head;
        head = next;
    }
}
</code></pre>

<p>Please note that I made a guess with the node type and you have to replace it by whatever is present in your code.</p>
",1
40754741,40754693,1,"<p>You need to <a href=""https://stackoverflow.com/questions/14914595/what-is-a-seed-in-terms-of-generating-a-random-number"">seed your random number generator</a> by calling</p>

<pre><code>srand(static_cast&lt;unsigned&gt;(time(NULL)));
</code></pre>

<p>PS: do not forget to <code>#include &lt;ctime&gt;</code> to call <a href=""http://www.cplusplus.com/reference/cstdlib/srand/"" rel=""nofollow noreferrer""><code>srand()</code></a> with the right parameter.</p>
",1
40754759,40754693,1,"<p>You are only assigning values to <code>num1</code>, <code>num2</code> and for that matter <code>response</code> once.  You need to assign new values inside the loop, otherwise the same values will be used for each iteration.</p>

<p>Instead of this:</p>

<pre><code>int num1 = (rand()% 9) + 1;
int num2 = (rand()% 9) + 1;
int ans,response = rand()% 4 + 1;
int totalans = 0, correctans = 0, wrongans = 0;


while (totalans != 10){//This will make the function repeat 10 times, collecting 10 answers.

        cout&lt;&lt;""What is the product of ""&lt;&lt; num1 &lt;&lt; "" and ""&lt;&lt;num2&lt;&lt;""?\n"";
        cin&gt;&gt;ans;
        if (ans != num1 * num2){
            // More code removed...
</code></pre>

<p>Try this:</p>

<pre><code>int ans;
int totalans = 0, correctans = 0, wrongans = 0;


while (totalans != 10){//This will make the function repeat 10 times, collecting 10 answers.

        int num1 = (rand()% 9) + 1;
        int num2 = (rand()% 9) + 1;
        int response = rand()% 4 + 1;

        cout&lt;&lt;""What is the product of ""&lt;&lt; num1 &lt;&lt; "" and ""&lt;&lt;num2&lt;&lt;""?\n"";
        cin&gt;&gt;ans;
        if (ans != num1 * num2){
            // More code removed...
</code></pre>
",6
40754832,40754693,0,"<p>You have no ""break"" after each of your switch statements. That is why it's calling all cases.</p>

<pre><code> if (ans != num1 * num2)
 {
        wrongans += 1;
        switch(response)
        {
            case 1 :
                cout&lt;&lt;""No. Please Try Again.\n"";
                break;
            case 2 :
                cout&lt;&lt;""Wrong.  Try once more.\n"";
                break;
            case 3 :
                cout&lt;&lt;""Don¡¯t give up!\n"";
                break;
            case 4 :
                cout&lt;&lt;""No.  Keep trying.\n"";
                break;
        }

    }
</code></pre>

<blockquote>
  <p>A better way to check percentage of answers:</p>
</blockquote>

<pre><code>totalAnswers = correctAnswers + wrongAnswers;
float rightAnswerPercentage = (correctAnswers/totalAnswers) * 100;
if (rightAnswerPercentage &lt; 75)
{
    cout &lt;&lt; ""You suck!"";
}
else cout &lt;&lt; ""You rock!"";
</code></pre>
",1
47454722,47454289,0,"<p>Two things:</p>

<p>As StoryTeller notes, you'll want to declare <code>Directory::pointerStringSort</code> as a <code>static</code> method of <code>Directory</code>. </p>

<p>Furthermore, you want to pass <code>&amp;Directory::pointerStringSort</code> to <code>std::sort</code>. For backward compatibility with C, ordinary functions don't require an ampersand to take their address (implicit conversion). This applies only to functions, not objects, and in C++ this exception doesn't apply to member functions either (C didn't have them)</p>
",7
47454616,47454289,0,"<p><code>_M_comp()</code> has to be either a functional object without context, i.e. no 'this' required, or an object with overloaded <code>operator()</code>. In the case of latter, you would have to provide an actual instance. The options are:</p>

<ol>
<li>provide a free function;</li>
<li>provide a static function in a class;</li>
<li>provide a lambda;</li>
<li>provide an instance of an object with overloaded <code>operator()</code></li>
</ol>

<p>Learn more: <a href=""http://en.cppreference.com/w/cpp/concept/Compare"" rel=""nofollow noreferrer"">Compare concept</a>.</p>
",0
47465432,47244662,0,"<p>The reason is you have an error is because of the ""|"" in your first if statement. It should be the boolean operator ""||"" instead.</p>
",0
47460042,47460012,3,"<p>The <code>ostream</code> overload of <code>&lt;&lt;</code> for <code>const char*</code> works in a special way: it outputs the memory as characters up to the next NUL-terminator.</p>

<p>If you want to switch this behaviour off, and output the actual address of the pointer, then cast to <code>const void*</code>:</p>

<pre><code>std::cout &lt;&lt; (const void*)(data);
</code></pre>

<hr>

<p>Note that you should really write </p>

<pre><code>const char* data = ""hamz"";
</code></pre>

<p>and bin the <code>new</code>. Currently you leak memory like a colander leaks water.</p>
",0
47460160,47460012,0,"<p>First, just to answer your question, you need to cast the <code>char*</code>-type to <code>void*</code>, i.e. write <code>cout &lt;&lt; (void*)data;</code>. Otherwise, when the data type is <code>char*</code>, <code>cout</code> treats <code>data</code> as a <code>'\0'</code>-terminated sequence of characters. </p>

<p>There are, however, other issues:
Statement</p>

<pre><code>data = ""hamz"";
</code></pre>

<p>lets <code>data</code> point to a string literal, but it does not copy the string <code>""hamz""</code> into the memory allocated on the heap. You actually loose the pointer to the allocated memory in the heap and produce a memory leak. For copying contents, you'd have to use <code>strcpy(data,""hamz"")</code>. </p>

<p>Then, as <code>data</code> will point to an (by definition) immutable string literal, data type should be <code>const char*</code>, i.e. <code>const char* myData = ""hamz""</code>.</p>
",0
47460188,47460012,1,"<p>You can use the <code>std::cout</code>'s member function call syntax to output the <code>data</code> pointer value instead of a string literal:</p>

<pre><code>std::cout.operator&lt;&lt;(data);
</code></pre>

<p>This will call the 7th <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt"" rel=""nofollow noreferrer"">std::basic_ostream::operator&lt;&lt;</a> overload that accepts the parameter of type <code>const void*</code>. Prefer <a href=""http://en.cppreference.com/w/cpp/string/basic_string"" rel=""nofollow noreferrer"">std::string</a> to raw character arrays.</p>
",0
47471855,47471344,0,"<pre><code>#include&lt;iostream&gt;
using namespace std;

void initarray(int a[], int n)
{
    for(int i = 0; i&lt;n; i++)
    {
        a[i]=0;
    }
}

void acceptarray(int a[], int n)
{
    for(int i = 0; i&lt;n; i++)
    {
        cin &gt;&gt; a[i];
    }
}

int pivotelement(int a[], int n)   //function has return type int so return the index of pivot element
{
    int s1 = 0;
    int s2 = 0;

    for(int i = 0; i &lt; n-1; i++)
    {
        if(i==0 || i==n-1) /* this condition added */
            continue;

        s1=0, s2=0; /* make s1 s2 zero inside for loop */

        for(int k = 0; k&lt;i; k++) /* k&lt;i not k&lt;=i */
        {
            s1 += a[k];
        }
        for(int j = i+1; j&lt;n; j++) /* j=i+1 not j=i+2 */
        {
            s2 +=a[j];
        }
        if(s1 == s2)
        {
            return i;               //returning the index of pivot element
        }

    }
    return -1;         //return -1 if pivot not found
}

int main(void)
{
    int a[100];
    int n =0;
    cin&gt;&gt;n;
    initarray(a,n);
    acceptarray(a,n);
    int x=pivotelement(a,n);         //call pivot element function and take the value returned

    if(x==-1)
        cout&lt;&lt;""no pivot"";
    else
        cout&lt;&lt;""pivot element ""&lt;&lt;a[x];


    return 0;
}
</code></pre>

<p>I have pointed out your errors in comments. This code is working fine.</p>
",4
47503294,47503242,0,"<p>The solution to the problem is due to comparing doubles and strings a solution would be:</p>

<pre><code>double value;
while (infile&gt;&gt;value)
{
    if (value &lt;= -2.4 &amp;&amp; value &gt;=-2.6)
    {
    cout &lt;&lt; ""Passed"";
    }
}
</code></pre>
",7
47496763,47495107,0,"<p>The defined standalone function <code>vector&lt;string&gt; morsecode()</code> is not the desired <code>vector&lt;string&gt; Code::morsecode()</code>.</p>
",1
47499185,47499122,1,"<p>This sum can be expressed in a simple recursive formula (as do many things the pertain to the structure of binary trees):</p>

<pre class=""lang-none prettyprint-override""><code>S(root, 0) = root-&gt;value;
S(root, n) = S(root-&gt;left_child, n - 1) + S(root-&gt;right_child, n - 1); 
</code></pre>

<p>You may notice from the formula, that it's not enough to just invoke the recursive function twice. You need to actually sum the results. Which means the function must return something that can even be summed:</p>

<pre><code>int nSum (RBTreeNode* B, int n) {
   // Take a stab at completing it yourself

   return nSum(B-&gt;left, n-1) + nSum(B-&gt;right, n-1);
}
</code></pre>
",0
47499186,47499122,1,"<p>When you declare a function like this:</p>

<pre><code>void nSum (RBTreeNode* B, int n, vector &lt;int&gt; sum)
</code></pre>

<p>The vector that the function gets is a copy of the vector that you pass in. So if nSum modifies the vector, that has no effect on the vector in the code that called nSum. This is called passing by value.</p>

<p>You can also pass by reference, which would give nSum access to the same vector that is passed in, and any modification made in nSum will be affect the vector in the calling code. The way you pass by reference is like this:</p>

<pre><code>void nSum (RBTreeNode* B, int n, vector &lt;int&gt;&amp; sum)
</code></pre>

<p>Notice the ""&amp;"". But the vector is not necessary, you only need to keep track of the sum. You could do this instead:</p>

<pre><code>void nSum (RBTreeNode* B, int n, int&amp; sum)
</code></pre>

<p>Now every time nSum is called it can modify the sum int, and it will effect the value outside the function.</p>
",1
47654035,47650699,0,"<p>If your using visual studio as the compiler, then the resource file (.rc) can be accessed by the resource id which is defined in resource.h. The version number can be retrieved/modified/saved as a string resource (std::string, TCHAR, CString etc).    </p>
",0
47556709,47556182,0,"<p>Your main problem is you are declaring node and ptr inside main. Your function definition for enter and the rest of your functions will not see the declarations inside main(). You need to move </p>

<pre><code>struct node {
    int info;
    node* next;
} * ptr, *y, *save, *start;
</code></pre>

<p>to before int main() to fix this issue.</p>
",0
47540178,47540045,0,"<p>The problem here is that you are comparing an int variable (choice), with a character literal ('1'). When you compare with '1', you are actually comparing with the ASCII value of the character '1', which is 49.</p>

<p>So to solve your problem, replace</p>

<pre><code>if (choice =='1') 
</code></pre>

<p>with</p>

<pre><code>if (choice ==1) 
</code></pre>
",2
39600473,39598990,1,"<p>First, I'll point out that your array <code>p</code> has only 15000 elements and that the 15001-th prime number is 163,847. This means that if you do a check for <code>a &gt;= 165000</code> before quiting you'll end up trying to fill indices of your array that are outside the bounds of your array.</p>

<p>Second, everyone is quite right that you should be careful when doing recursion. With each run of <code>prime()</code> you're allocating space for 5 new integer variables <code>a</code>, <code>i</code>, <code>q</code>, <code>s</code>, and <code>d</code>. This means you're allocating memory for tens of thousands of integers when (from the looks of your method) all you really need is 5.</p>

<p>Since it looks like these values are independent of all other iterations, you can employ a couple tricks. First, for q, s, and d by declaring them as globals they will only be allocated once. Secondly, by changing <code>prime(int a, int i)</code> to <code>prime(int &amp;a, int &amp;i)</code> you wont be allocating memory for <code>a</code> and <code>i</code> with each loop. This changes your code to look like the following:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

const int max_size = 15000 ;
int p[max_size];
int q ;
int s ;
int d ;

void prime(int &amp;a, int &amp;i)
{
    if (i&gt;=max_size) return ;

    q = 0;
    s=sqrt(a) ;
    d=3;

    while(d&lt;=s){
        if(a % d == 0) {
            q = 1;
        }
        d += 2;
    }
    if(q == 0) {
        p[i] = a;
        i++;
        a += 2;
        prime(a, i);
    }
    else {
        a += 2;
        prime(a, i);
    }

}

int main()
{
    p[0]=2;
    int a(3), i(1) ;
    prime(a, i);
    int k, T;
    cin &gt;&gt; T;
    for(int i = 1; i &lt;= T; i++){
        cin &gt;&gt; k;
        // You should do a check of whether k is larger than
        // the size of your array, otherwise the check on p[k-1]
        // will cause a seg fault.
        if (k&gt;max_size) {
            std::cout &lt;&lt; ""That value is too large, try a number &lt;= "" &lt;&lt; max_size &lt;&lt; ""."" &lt;&lt; std::endl;
        } else {
            cout &lt;&lt; p[k - 1] &lt;&lt; endl;
        }
    }

    return 0;
}
</code></pre>

<p>A couple of other changes:</p>

<ul>
<li>instead of filling the array until you reach a specific prime number, I've changed your check so that it will fill the array until it hits the maximum number of entries.</li>
<li>I've also included a check as to whether the user has passed an index number outside the range of the ""p"" array. Otherwise it will produce a segmentation fault.</li>
</ul>

<p>Now compiling this and running gives:</p>

<pre><code>$ g++ prime_calc.cpp -o prime_calc
$ ./prime_calc
3
1500
12553
15000
163841
15001
That value is too large, try a number &lt;= 15000.
</code></pre>
",2
39618698,39599387,0,"<p>I got it to work myself. For anyone who needs a program like this here it is:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main(){
    int a,b;
    cin &gt;&gt; a &gt;&gt; b;
    int d = a/b;
    int r = a%b;
    if (r &lt; 0){
        d = d-1;
        int s = d*b;
        r = -s+a;
    }
    cout &lt;&lt; d &lt;&lt; "" "" &lt;&lt; r &lt;&lt; endl;
}
</code></pre>
",0
39599496,39599387,2,"<p>You are looking for the <code>modulus</code> operator, <code>'%'</code>.</p>

<pre><code>int a = 5 % 2;
cout &lt;&lt; a &lt;&lt; endl;
</code></pre>

<p>The modulus operator returns the remainder of the first value divided by the second.  </p>
",0
47702039,47702015,1,"<p><code>bool(Int*)</code> is not the same type as <code>bool(Number*)</code>, hence your function <code>Int::isEqual</code> does <em>not</em> override <code>Number::isEqual</code> -- rather, it's a completely separate function.</p>

<p>Just think about it for a minute; the attempted override makes no sense: Your derived class expects a constrained argument, but the base function's parameter is less constrained! If what you wanted were allowed,  <code>nPtr-&gt;isEqual</code> could be called with <em>any</em> <code>Number</code> pointer, which the derived class does not support!</p>

<hr>

<p><sub>The correct question would be for <em>covariant</em> return types but <em>contravariant</em> parameters. However, C++ does not allow contravariant parameter overriders.</sub></p>
",4
47490622,47489372,4,"<p>The C# feature you are referring to is called ""Just My Code"". Unfortunately, Visual Studio does not implement it in the same way for C++. As <a href=""https://docs.microsoft.com/en-us/visualstudio/debugger/just-my-code"" rel=""nofollow noreferrer"">documentation</a> says:</p>

<blockquote>
  <p>C++ Just My Code is different than .NET Framework and JavaScript Just
  My Code because the stepping behavior is independent of the call stack
  behavior.</p>
</blockquote>

<p>There is a workaround, however:</p>

<blockquote>
  <p>You can create your own <code>.natstepfilter</code> and <code>.natjmc</code> to customize the
  stepping and call stack window behavior in the <code>%USERPROFILE%\My Documents\Visual Studio 2015\Visualizers</code>.</p>
</blockquote>

<p>Despite of the typo in the documentation (""2015"") and the horribly convoluted way this was designed, the trick actually works!</p>

<p>For example, with the Visual Studio 2017 installation on my machine, I can go to <code>C:\Program Files (x86)\Microsoft Visual Studio\2017\Community\Common7\Packages\Debugger\Visualizers</code> and a add file called <code>.natstepfilter</code> with the following content:</p>

<pre><code>&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;  
&lt;StepFilter xmlns=""http://schemas.microsoft.com/vstudio/debugger/natstepfilter/2010""&gt;  
    &lt;Function&gt;  
        &lt;Name&gt;std::.*&lt;/Name&gt;  
        &lt;Action&gt;NoStepInto&lt;/Action&gt;  
    &lt;/Function&gt;  
&lt;/StepFilter&gt;  
</code></pre>

<p>Now when I debug in Visual Studio and <em>step into</em> something, all C++ standard-library functions are skipped.</p>

<p>Note that the actual format of the XML file is not validated very strictly by Visual Studio. I've actually used the simpler form explained in the <a href=""https://msdn.microsoft.com/en-us/library/dn457346.aspx"" rel=""nofollow noreferrer"">Visual Studio 2015 documentation</a>.</p>
",0
47511427,47511398,5,"<p>Just use std::string instead of a C array of char.  It will be sized automatically according to the input length.</p>

<p>Use the free function <code>std::getline()</code> instead of <code>istream::getline()</code>:</p>

<pre><code>string line;
getline(cin, line);
</code></pre>

<p><a href=""http://en.cppreference.com/w/cpp/string/basic_string/getline"" rel=""noreferrer"">http://en.cppreference.com/w/cpp/string/basic_string/getline</a></p>
",3
47511673,47511398,0,"<p>You can use a temporary dynamic array then copy the part you wanted from the original array then delete the original array then assign the original pointer to the temporary pointer:</p>

<pre><code>char* szTxt = new char[256];
std::cin.getline(szTxt, 256, '\n');
std::cout &lt;&lt; szTxt &lt;&lt; std::endl;

const int size = strlen(szTxt);
char* szTmp = new char[size + 1];
strncpy(szTmp, szTxt, size);

szTmp[size] = '\0';

delete[] szTxt;
szTxt = szTmp;

std::cout &lt;&lt; szTxt &lt;&lt; std::endl;
std::cout &lt;&lt; ""Size: "" &lt;&lt; size &lt;&lt; std::endl;

delete[] szTxt;
</code></pre>
",2
39684610,39684424,2,"<p>It's a bit hard to debug the  specific problem in your code, as it isn't complete (can't copy-paste it to an editor and build it). In particular, not sure what are <code>p</code>, <code>cntArray</code>, and how they are initialized.</p>

<p>However, fundamentally, this code could be made shorter and more efficient. Instead of sorting (immediate <em>&Theta;(n log(n))</em> complexity), use an <a href=""http://www.cplusplus.com/reference/unordered_map/unordered_map/"" rel=""nofollow""><code>std::unordered_map</code></a> to store the multiplicity of each element. Shorter, fewer potential bugs, and (expected) linear complexity.</p>

<pre><code>#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

int main() {
    const std::vector&lt;int&gt; a{10, 40, 30, 40, 30};
    std::unordered_map&lt;int, std::size_t&gt; counts; 
    std::for_each(std::begin(a), std::end(a), [&amp;](int e){ ++counts[e]; });
    std::for_each(std::begin(a), std::end(a), 
        [&amp;](int e){ std::cout &lt;&lt; e / static_cast&lt;double&gt;(counts[e]) &lt;&lt; std::endl; });
}
</code></pre>

<p>Outputs:</p>

<pre><code>$ ./a.out 
10
20
15
20
15
</code></pre>
",1
47615155,47614998,1,"<p><strong>For production code:</strong></p>

<p>If you have access to C++11 features then you should be using <code>std::normal_distribution</code> 
 (<a href=""http://en.cppreference.com/w/cpp/numeric/random/normal_distribution"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/numeric/random/normal_distribution</a>) or one of its variants, rather than implementing the functionality yourself. This should give you a robust (does not use <code>rand()</code>), thread safe (yours is not), well tested implementation.</p>

<p><strong>For learning purposes</strong></p>

<p>Wikipedia has an example implementation of this algorithm in C++. Specifically I can see two issues with your code.</p>

<ol>
<li><p>You do not correctly handle the case of <code>w==0</code>. I.e. <code>log(0)</code> and division by zero are undefined. </p></li>
<li><p>Your update function for <code>y1</code> and <code>y2</code> is incorrect. The correct algorithm (in pseudo-code): <code>y1 = sqrt(-2 * log(u1)) * cos(2*PI*u2)</code> and <code>y2 = sqrt(-2 * log(u1)) * sin(2*PI*u2)</code> where clearly <code>u1</code> must be in the range (0, 1), while u2 is unconstrained.</p></li>
</ol>

<p>Also on a minor syntactic point. Your <code>use_last</code> variable should be a <code>bool</code>, rather than an <code>int</code> in C++.</p>
",2
47615189,47614998,0,"<p>Your code is almost fine (almost, because sometimes it¡¯ll crash with division by zero).</p>

<p>If you need random numbers that are limited to some range, you probably don¡¯t want to use Gaussian distribution. Gaussian values are unlimited. The probability falls pretty quickly around the mean value, but it never reaches the exact zero. For example, the probability of the value to fall outside [m-3*s; m+3*s] interval is only 0.27%, but it¡¯s not 0.</p>
",0
47615155,47614998,1,"<p><strong>For production code:</strong></p>

<p>If you have access to C++11 features then you should be using <code>std::normal_distribution</code> 
 (<a href=""http://en.cppreference.com/w/cpp/numeric/random/normal_distribution"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/numeric/random/normal_distribution</a>) or one of its variants, rather than implementing the functionality yourself. This should give you a robust (does not use <code>rand()</code>), thread safe (yours is not), well tested implementation.</p>

<p><strong>For learning purposes</strong></p>

<p>Wikipedia has an example implementation of this algorithm in C++. Specifically I can see two issues with your code.</p>

<ol>
<li><p>You do not correctly handle the case of <code>w==0</code>. I.e. <code>log(0)</code> and division by zero are undefined. </p></li>
<li><p>Your update function for <code>y1</code> and <code>y2</code> is incorrect. The correct algorithm (in pseudo-code): <code>y1 = sqrt(-2 * log(u1)) * cos(2*PI*u2)</code> and <code>y2 = sqrt(-2 * log(u1)) * sin(2*PI*u2)</code> where clearly <code>u1</code> must be in the range (0, 1), while u2 is unconstrained.</p></li>
</ol>

<p>Also on a minor syntactic point. Your <code>use_last</code> variable should be a <code>bool</code>, rather than an <code>int</code> in C++.</p>
",2
47615189,47614998,0,"<p>Your code is almost fine (almost, because sometimes it¡¯ll crash with division by zero).</p>

<p>If you need random numbers that are limited to some range, you probably don¡¯t want to use Gaussian distribution. Gaussian values are unlimited. The probability falls pretty quickly around the mean value, but it never reaches the exact zero. For example, the probability of the value to fall outside [m-3*s; m+3*s] interval is only 0.27%, but it¡¯s not 0.</p>
",0
48003015,47992712,0,"<p>I had posted this query on <a href=""http://www.cplusplus.com/forum/general/227484/"" rel=""nofollow noreferrer"">another forum</a>.</p>

<p>Based on the reply, it appears that this action was deliberate on the part of the C++ standard setters, to prevent novices from instantiating standard-library facets, such as collate.</p>

<p>After all, as Stroustrup states [""The C++ Programming Language"", 4th Ed, pg 1125],</p>

<pre><code>It is essential for one to have a detailed knowledge of individual facets, 
to be able to successfully mix and match facets or add new versions of 
the standard facets.
</code></pre>
",0
47657208,47657058,1,"<p>What about a <strong>recursive</strong> and <strong>more generic</strong> approach?
<strong>No arrays</strong>, <strong>no loops</strong> and not limited to just 5 integers.</p>

<p>The following function <code>get_2nd_min()</code> keeps track of the two lowest integers read from <code>std::cin</code> a total of <code>count</code> times:</p>

<pre><code>#include &lt;climits&gt;
#include &lt;cstddef&gt;
#include &lt;iostream&gt;

int get_2nd_min(size_t count, int min = INT_MAX, int second_min = INT_MAX)
{
   if (!count)
      return second_min; // end of recursion

   // read next value from cin
   int value;
   std::cin &gt;&gt; value;

   // Does second_min need to be updated?
   if (value &lt; second_min) {

     // Does min also need to be updated?
     if (value &lt; min) {
        // new min found
        second_min = min; // move the so far min to second_min
        min = value; // update the new min
     } else {
        // value is lower than second_min but higher than min
        second_min = value; // new second_min found, update it
     }
   }
   // perform recursion
   return get_2nd_min(count - 1, min, second_min);
}
</code></pre>

<hr>

<p>In order to read 5 integers and obtain the 2nd lowest:</p>

<pre><code>int second_min = get_2nd_min(5);
</code></pre>
",2
47657354,47657058,4,"<p>The problem you have with your logic is that you do not enforce yourself to print only 1 item, and at least one item.
By using the 'else' part of the if/else syntax, you will ensure that only one branch can ever be hit.  You can then follow this up with just an else at the end, as you know all other conditions are false.</p>

<p>Once you've done this, you'll see that you print the last value, (1) rather than the expected (4).  This is because your logic regarding how to find the 2nd lowest is wrong.  b>a is false for the case 5,4... </p>

<p>Note:
Every employed engineer, ever, would make this a loop in a std::vector / std::array, and I would suggest you point your teacher to this post because encouraging loops is a good thing rather than bad.</p>

<p>Something like</p>

<pre><code>vector&lt;int&gt; data;
for (int i=0; i&lt;5; ++i) {
    int t;
    cin &gt;&gt; t;
    data.push_back(t);
}
std::nth_element(data.begin(), data.begin()+1, data.end(), std::greater&lt;int&gt;());
cout &lt;&lt; data[1];
</code></pre>
",10
47657595,47657058,2,"<p>This should work for you. (Note that it might not be the best approach and you can minimize it with a function to calculate min and secondMin instead of the ugly copy paste of the logic but it will get you started:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
int main () {
int a,b,c,d,e;
int min, secondMin;


cin&gt;&gt;a&gt;&gt;b;

min = a &lt; b ? a : b;
secondMin = a &lt; b ? b : a;

cin&gt;&gt;c;

if (c &lt; min)
{
    secondMin = min;
    min = c;
}
else if (c &lt; secondMin)
{
    secondMin = c;
}

cin&gt;&gt;d;

if (d &lt; min)
{
    secondMin = min;
    min = d;
}
else if (c &lt; secondMin)
{
    secondMin = d;
}

cin&gt;&gt;e;

if (e &lt; min)
{
    secondMin = min;
    min = e;
}
else if (e &lt; secondMin)
{
    secondMin = e;
}

cout &lt;&lt; ""min = "" &lt;&lt; min &lt;&lt; "", secondMin = "" &lt;&lt; secondMin &lt;&lt; endl;

return 0;

}
</code></pre>

<p>if you have any questions feel free to ask in the comment</p>
",2
47657644,47657058,0,"<p><strong>Update</strong>
In this solution I'm using the <em>min</em> function: </p>

<pre><code>#include &lt;iostream&gt;
using namespace std;


int minDifferentFromFirstMin(int x, int y, int firstMin) {
    if(x &lt; y) {
        if(x != firstMin) {
            return x;
        }
        else {
            return y;
         }
    }

    if(y &lt; x) {
        if(y != firstMin) {
            return y;
        }
        else {
            return x;
         }
    }
    //if x &amp; y are equals, return one of them
    return x;
}

int main () {
 int a,b,c,d,e;
 int iter11, iter12, iter13;
 int iter21, iter22, iter23;
 int firstMinimum, secondMinimum;
 cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;

 //iteration 1: find the first minimum
 iter11 = min(a, b);
 iter12 = min(c, d);
 iter13 = min(iter11, iter12);
 firstMinimum = min(iter13, e);

 //iteration 2: find the second minimum
 iter21 = minDifferentFromFirstMin(a, b, firstMinimum);
 iter22 = minDifferentFromFirstMin(c, d, firstMinimum);
 iter23 = minDifferentFromFirstMin(iter21, iter22, firstMinimum);
 secondMinimum = minDifferentFromFirstMin(iter23, e, firstMinimum);

 cout&lt;&lt;secondMinimum&lt;&lt;endl;
}
</code></pre>
",1
47657865,47657058,3,"<p>There are 120 possible permutations on 5 elements. Your code should output the correct number for all of them. So a fool-proof code would use 120 repetitions of a check, like the following:</p>

<pre><code>if (a &gt; b &amp;&amp; b &gt; c &amp;&amp; c &gt; d &amp;&amp; d &gt; e) // the order is a&gt;b&gt;c&gt;d&gt;e
    cout &lt;&lt; d;
else if (a &gt; b &amp;&amp; b &gt; c &amp;&amp; c &gt; e &amp;&amp; e &gt; d) // the order is a&gt;b&gt;c&gt;e&gt;d
    cout &lt;&lt; e;
...
else if (e &gt; d &amp;&amp; d &gt; c &amp;&amp; c &gt; a &amp;&amp; e &gt; b) // the order is e&gt;d&gt;c&gt;a&gt;b
    cout &lt;&lt; a;
else // the order is e&gt;d&gt;c&gt;b&gt;a
    cout &lt;&lt; b;
</code></pre>

<p>This is very long, inefficient and tricky code. If you do a typo in just one variable, it will output a wrong answer in some rare cases. Also, it doesn't handle the possibility of some inputs being equal.</p>

<hr>

<p>If the number of inputs to a sorting algorithm is a known small constant, you can use an approach called <a href=""https://en.wikipedia.org/wiki/Sorting_network"" rel=""nofollow noreferrer"">sorting networks</a>. This is a well-defined computer science problem, which has well-known optimal solutions for small numbers of inputs, and 5 certainly is small. An optimal sorting network for 5 inputs contains 9 comparators, and is described e.g. <a href=""http://www.angelfire.com/blog/ronz/Articles/999SortingNetworksReferen.html"" rel=""nofollow noreferrer"">here</a>.</p>

<p>Since you don't need to sort the numbers, but only to know the second smallest input, you can reduce the size of the network further, to 7 comparators.</p>

<p>The full sorting network (without the reduction from 9 to 7) translated to C++:</p>

<pre><code>if (b &lt; c)
    swap(b, c);
if (d &lt; e)
    swap(d, e);
if (b &lt; d)
    swap(b, d);
if (a &lt; c)
    swap(a, c);
if (c &lt; e)
    swap(c, e);
if (a &lt; d)
    swap(a, d);
if (a &lt; b)
    swap(a, b);
if (c &lt; d)
    swap(c, d);
if (b &lt; c)
    swap(b, c);
// now the order is a ¡Ý b ¡Ý c ¡Ý d ¡Ý e
cout &lt;&lt; d;
</code></pre>

<p>This code is also obscure - not obvious at all how and why it works - but at least it is small and in a sense optimal. Also, it's clear that it always prints something (so it fixes the original problem) and supports the case of partially equal inputs.</p>

<p>If you ever use such code in a larger project, you should document where you took it from, and test it. Fortunately, there are exactly 120 different possibilities (or 32, if you use the 
<a href=""https://en.wikipedia.org/wiki/Sorting_network#Zero-one_principle"" rel=""nofollow noreferrer"">zero-one principle</a>), so there is a way to prove that this code has no bugs.</p>
",1
47658409,47657058,2,"<pre><code>#include &lt;set&gt;

std::set&lt;int&gt; values = { a, b, c, d, e }; // not an array.
int second_min = *std::next(values.begin(), 1); // not a loop
</code></pre>
",1
47658635,47657058,0,"<p>One approach is to first find the minimum number, <code>min</code> and then find the smallest value that isn't <code>min</code>. To do this first find the minimum value:</p>

<pre><code>int min = std::min(a, std::min(b, std::min(c, std::min(d, e))));
</code></pre>

<p>Now we need to do the same again, but ignoring <code>min</code>. We can do this using a function called <code>triMin</code> which takes 3 values and discards any value that is the minimum:</p>

<pre><code>int triMin(int currentMin, int left, int right)
{
    if(currentMin == left) return right;
    if(currentMin == right) return left;

    return std::min(left, right);
}
</code></pre>

<p>You can now combine them to get the answer:</p>

<pre><code>int a = 5, b = 4, c = 3, d = 2, e = 1;

int min = std::min(a, std::min(b, std::min(c, std::min(d, e))));
int min2 = triMin(min, a, triMin(min, b, triMin(min, c, triMin(min, d, e))));

std::cout &lt;&lt; ""Second min = "" &lt;&lt; min2 &lt;&lt; std::endl;
</code></pre>

<p>This prints <code>2</code></p>
",0
47661256,47657058,0,"<p>This task can be fulfilled using <a href=""https://en.wikipedia.org/wiki/One-pass_algorithm"" rel=""nofollow noreferrer"">one-pass</a> algorithm. There is no need to use any collections (arrays, sets or anything).<br>
This one-pass algorithm is memory efficient - it does not require storing all elements in collection (and wasting memory) and will work even with large number of elements when other solutions fail with out of memory.<br>
General idea of this algorithm is like this:  </p>

<ul>
<li>take each number in order</li>
<li>you need two variables to store <code>minimum</code> and <code>second minimum</code> numbers from all already seen numbers.</li>
<li>when you get number you need to test it with current <code>minumum</code> to find if it is new minimum number.

<ul>
<li>if it is store it as <code>minimum</code>, store old minimum in <code>second minimum</code>number</li>
</ul></li>
<li>otherwise check if it is less than <code>second minimum</code> number.

<ul>
<li>if it is store it as <code>second minimum</code> number.</li>
</ul></li>
<li>now <code>second minimum</code> number contains answer for all already seen numbers.</li>
<li>repeat while there numbers that was not seen.</li>
</ul>

<p>After investigating all numbers <code>second minimum</code> contain the answer.<br>
Here is implementation with c++17 (<a href=""https://wandbox.org/permlink/m8PJj2l1RMIhCsO4"" rel=""nofollow noreferrer"">link to wandbox</a>):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;optional&gt;

int main()
{
    int a, b, c, d, e;
    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e;

    // you can find second minimal number while going through each number once
    auto find_current_answer = [minimum = std::optional&lt;int&gt;{}, next_to_minimum = std::optional&lt;int&gt;{}](int next) mutable {
        // when receiving next number
        // 1. check if it is new minimum
        if (!minimum || minimum &gt; next) {
            // move values like this: next_to_minimum &lt;- minimum &lt;- next
            next_to_minimum = std::exchange(minimum, next);
        }
        // 2. else check if it is new next_to_minimum
        else if (!next_to_minimum || next_to_minimum &gt; next) {
            next_to_minimum = next;
        }
        // 3. return current answer
        return next_to_minimum;
    };

    // repeat as much as you like
    find_current_answer(a);
    find_current_answer(b);
    find_current_answer(c);
    find_current_answer(d);
    // store answer that is interesting to you
    auto result = find_current_answer(e);

    // if it has value - it is the answer
    if (result) {
        std::cout &lt;&lt; ""Answer: "" &lt;&lt; *result &lt;&lt; '\n';
    }
    else {
        std::cout &lt;&lt; ""Not enough numbers!\n"";
    }
}
</code></pre>
",0
47972942,47972912,6,"<p>It is not possible to provide explicit template arguments for operator syntax, your foo.at(ndx) is the usual answer if you want that sort of thing.</p>
",0
47996808,47996523,0,"<p>Cast your buffers to char * and pass the size of the buffer in bytes as the length. Note that send() can only deal with whole bytes.</p>
",1
41665736,41665381,1,"<p>You need to take more care with how you're accessing arrays and keeping track of the sizes of them.</p>

<p>As a comment already pointed out, <code>for (int i = 0; team-&gt;players[i].name != NULL; i++)</code> is asking for trouble. You should ensure that the loop is constrained by something, either the total number of entries in the <code>players</code> array (presumably <code>maxOfPlayers</code>) or the current number of valid players which seems like it should be <code>numOfPlayers</code>. However your code never actually increments <code>numOfPlayers</code> when adding new entries.</p>

<p>The following code from <code>getAllPlayersStartWithA</code> is also a problem:</p>

<pre><code>player_t **p = new player_t*[sum + 1];

for (int i = 0; i &lt; team-&gt;maxOfPlayers; i++)
{
    p[i] = NULL;
}
</code></pre>

<p>The <code>sum + 1</code> can easily be much less than <code>maxOfPlayers</code>. In that case the for loop will overwrite memory beyond the end of the array. This could very well be the cause of your current heap corruption error.</p>
",0
41665513,41665381,12,"<p>I have not reviewed the whole code, but there are tools available that can help you in this situation that track the usage of memory and indicate if something went wrong. One example is valgrind that is at least available for Linux environments. Anyway, this tool allowed me to find at least one bug in your code as follows.</p>

<ol>
<li><p>Compile with debug information. If you are using gcc, use the -g command line flag e.g.</p>

<pre><code>g++ foo.cpp -g -o foo -std=gnu++11
</code></pre></li>
<li><p>Run with valgrind</p>

<pre><code>valgrind ./foo
</code></pre></li>
<li><p>Look at the output</p>

<pre><code>==6423== Memcheck, a memory error detector
==6423== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==6423== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info
==6423== Command: ./foo
==6423== 
 please enter your team name
sdfads
please enter the number of the max players on your team
3
 please enter the name of the player 
efwf
 please enter the num of the shirt 
5
 please enter the name of the player 
dsfdsa
 please enter the num of the shirt 
3
Team name: sdfads
Max Number of players in team: 3
Current number of players in team: 0
Team Players:
Player name: efwf, Player shirt: 5
Player name: dsfdsa, Player shirt: 3

==6423== Invalid write of size 8
==6423==    at 0x4011FF: getAllPlayersStartWithA(team_t*) (foo.cpp:155)
==6423==    by 0x400C08: main (foo.cpp:38)
==6423==  Address 0x5ab6668 is 0 bytes after a block of size 8 alloc'd
==6423==    at 0x4C2E80F: operator new[](unsigned long) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==6423==    by 0x4011CC: getAllPlayersStartWithA(team_t*) (foo.cpp:151)
==6423==    by 0x400C08: main (foo.cpp:38)
==6423== 
==6423== 
==6423== HEAP SUMMARY:
==6423==     in use at exit: 72,719 bytes in 3 blocks
==6423==   total heap usage: 8 allocs, 5 frees, 74,829 bytes allocated
==6423== 
==6423== LEAK SUMMARY:
==6423==    definitely lost: 15 bytes in 2 blocks
==6423==    indirectly lost: 0 bytes in 0 blocks
==6423==      possibly lost: 0 bytes in 0 blocks
==6423==    still reachable: 72,704 bytes in 1 blocks
==6423==         suppressed: 0 bytes in 0 blocks
==6423== Rerun with --leak-check=full to see details of leaked memory
==6423== 
==6423== For counts of detected and suppressed errors, rerun with: -v
==6423== ERROR SUMMARY: 2 errors from 1 contexts (suppressed: 0 from 0)
</code></pre></li>
<li><p>Apparently you have a problem in line 155 according to this output</p>

<pre><code>==6423== Invalid write of size 8
==6423==    at 0x4011FF: getAllPlayersStartWithA(team_t*) (foo.cpp:155)
</code></pre>

<p>And if we look closer, we see the following:</p>

<pre><code>player_t **p = new player_t*[sum + 1];
for (int i = 0; i &lt; team-&gt;maxOfPlayers; i++)
{
     p[i] = NULL;
}
</code></pre>

<p>You create an array of size sum+1, but iterate over it up to team->maxOfPlayers that might or might not be the same. This means you write to some memory outside of the array that you want to modify and therefore you write somewhere in the heap where you should not (leading to a heap corruption).</p></li>
</ol>

<p>This is at least one problem. Repeat 1.-4. until valgrind has nothing else to complain about.</p>
",6
48030550,48030540,2,"<p>Simply:</p>

<pre><code>displayInfoBox = !displayInfoBox;
</code></pre>

<p>or</p>

<pre><code>xbool = !xbool;
</code></pre>

<p><code>!</code> by itself does not change the value of the variable, it just creates a new value by negating it, so you have to reassign it.</p>

<p>You also will have to make <code>swapBool</code> pass <code>xbool</code> by reference.</p>

<pre><code>void swapBool(bool&amp; xbool);
</code></pre>
",7
48037985,48037719,0,"<p>here some simplified variant using some old-fashioned c-style:</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cctype&gt;
#include &lt;iostream&gt;

int main() {
  const int len = 101;
  char s[len] = {'\0'};

  std::cin.getline(s, len);

  int i = 0;

  while (i &lt; len) {
    char t[len] = {'\0'};  // here will the every next number be extracted
    int j = -1;

    while (isdigit(s[i]) &amp;&amp; i &lt; len &amp;&amp; j &lt; len) {
      t[++j] = s[i++];
  }

  if (0 &lt;= j) {
    printf(""%s\n"", t);     // just print the number as string. here would the conversion to int, unsisigned int or whatsoever take place
  }

  ++i;
}
</code></pre>

<p>}</p>

<p>char t[] holds the string number. you can conver't it to number using the standard library functions.</p>
",0
48038083,48037719,0,"<p>When you're scanning through the string you can be in one of two states: scanning a number and scanning something that's not a number. When you're scanning a number, accumulate the digits; when you hit something that isn't a number, write out the accumulated value. Like this:</p>

<pre><code>const char *str = ""24cd[*43-28/5*93}9(ks)"";
bool in_number = false;
int value;
while (*str) {
    if (isdigit(*str)) {
        if (!in_number) {
            in_number = true;
            value = *str - '0';
        } else {
            value += *str - '0';
        }
    } else if (in_number) {
            std::cout &lt;&lt; value &lt;&lt; '\n';
            in_number = false;
    }
    ++str;
}
</code></pre>
",0
48037850,48037719,0,"<p>Try Somthing like this:</p>

<pre><code>#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;cctype&gt;

int main(int argc, char *argv[])
{
    int j=0;
    char equation[101]{'2','4','c','d','[','*','4','3','-','2','8','/','5','*','9','3','}','9','(','k','s',')'};
    char number[j];

    for (int i=0; i &lt; sizeof(equation); i++)
    {
        if (isdigit(equation[i]))
        {
            number[j++] = equation[i];
        }
    }

    std::cout &lt;&lt; number &lt;&lt; std::endl;
}
</code></pre>
",9
47961253,47961110,1,"<p>I'm actually not totally understanding your statement. What I assume here is that you want to calculate the sum and avg of all the numbers entered. In that way, your most critical mistake is the scope of <code>newtotal</code>. x will always be the sum of <code>a</code> and <code>b</code>, so <code>newtotal</code> will always be <code>a + b + c</code> where c is the last number you've entered.</p>

<p>Plus, your program would still add the 0 that indicates termination because it will only break at the next iteration.</p>

<p>And I really don't know why you need the last 3 lines of code in <code>main()</code>.</p>

<p>My version of the corrected code:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;


int main()
{
    int e = 3, a, b, x, c;
    cout &lt;&lt; ""Please enter 2 numbers"" &lt;&lt; endl;
    cout &lt;&lt; ""Enter your first number"" &lt;&lt; endl;
    cin &gt;&gt; a;
    cout &lt;&lt; ""Enter your second number"" &lt;&lt; endl;
    cin &gt;&gt; b;
    x = a + b;
    cout &lt;&lt; ""The sum of your 2 numbers is "" &lt;&lt; x &lt;&lt; endl;
    cout &lt;&lt; ""The mean of your 2 numbers is "" &lt;&lt; (float)x/2 &lt;&lt; endl;


    while (true)
    {
        cout &lt;&lt; ""Enter the next number"" &lt;&lt; endl;
        cin &gt;&gt; c;
        x += c;
        if (c == 0)
            break;
        cout &lt;&lt; ""The sum of the new numbers are "" &lt;&lt; x &lt;&lt; endl;
        cout &lt;&lt; ""The mean of the new numbers are "" &lt;&lt; (float)x / e++ &lt;&lt; endl;
    }
    // I don't know why you need the code here
}
</code></pre>
",0
47963603,47963502,1,"<p>The basic issue with your code is that you are re-evaluating the size of respective stack at each iteration (while checking condition of the <code>for</code> loop).<br>
At say iteration <code>i</code> you pop off an element of the stack and at  iteration <code>i+1</code> you again evaluate the size of your stack which is now one less than the original size.<br>
The following changes would help you.</p>

<pre><code>int myStack_size = myStack.size(), myStack2_size = myStack.size();

cout &lt;&lt; ""myStack contents: "" &lt;&lt; endl;
  for(int i = 0; i &lt; myStack_size; ++i) {
    cout &lt;&lt; myStack.top() &lt;&lt; endl;
    myStack.pop();
  }

  cout &lt;&lt; ""myStack2 contents: "" &lt;&lt; endl;
  for(int j = 0; j &lt; myStack2_size; ++j) {
    cout &lt;&lt; j &lt;&lt; "". iteration: "";
    cout &lt;&lt; myStack2.top() &lt;&lt; endl;
    myStack2.pop();
  }
  cout &lt;&lt; ""myStack2 size after output iterations: "" &lt;&lt; myStack2.size() &lt;&lt; endl;
</code></pre>
",0
47963546,47963502,1,"<p>Every time you call pop(), you decrease the size of the stack. And so, first time in the loop you compare j (0) with size(3). Second time, j(1) with size (2). Third time the loop condition is false becase j is 2 and size is 1</p>
",0
48042338,48042308,2,"<p>Using <code>std::endl</code> is not the <em>only</em> thing that flushes <code>cout</code>. </p>

<p>Reading from <code>cin</code> will also cause the <code>cout</code> buffer to be flushed, so that prompts can be visible on the console. By default the streams are <a href=""http://en.cppreference.com/w/cpp/io/basic_ios/tie"" rel=""nofollow noreferrer"">""tied""</a> to each other.</p>
",1
47980320,47980180,1,"<p>It is a warning in msvc which is telling you the functions are a bit more risky than others.</p>

<p>You can suppress it by adding <strong>_crt_secure_no_warnings</strong> to the preprocessor settings in the project properties.</p>
",0
47993409,47993248,1,"<p>Here you create an array of 10000 liste-pointers</p>

<pre><code>liste* table[100000];
</code></pre>

<p>but you never create any liste objects for them to point to. 
Later you want to call the member function </p>

<pre><code>table[x]-&gt;createnode(word);
</code></pre>

<p>As your pointers in table are still not initialized your call crashes.</p>

<p>My assumption is that you want to have <em>table</em> to be an array of liste objects</p>

<pre><code>liste table[100000];
</code></pre>

<p>What I still don't get is why you call <em>liste()</em> (a constructor?) in your <em>createNode</em> function.</p>
",1
47993659,47993248,0,"<p>apparently not initializing your class array causes this.adding this fixed it.</p>

<pre><code>for ( i = 0; i &lt; 100000; i++)
        {
            table[i] = new liste;

        }
</code></pre>

<p>note to self : do not watched tutorials about code implementation if they are telling on board. people might forget things.</p>
",0
47988069,47985263,2,"<p>To use the C++ member function <code>void key_callback()</code>, as a parameter to the C-implemented library function <code>glfwSetKeyCallback()</code>, you should declare it as <code>static</code>, but outside of the class declaration first. So try something like this for your <strong>window.h</strong>.</p>

<pre><code>class Window;
static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods);

class Window {
    private:
        // fields here

    public:
        // other member functions here

    private:
        friend void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods);
};
</code></pre>

<p>And then in <strong>window.cpp</strong>:</p>

<pre><code>static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods) {
    Window* win = (Window*) glfwGetWindowUserPointer(window);
    win-&gt;m_Keys[key] = action != GLFW_RELEASE;
}
</code></pre>

<p>I haven't written in this glfw library, so my answer might not be sufficient for your purposes. Have a look at these questions: <a href=""https://stackoverflow.com/questions/7676971/pointing-to-a-function-that-is-a-class-member-glfw-setkeycallback"">Pointing to a function that is a class member</a> , <a href=""https://stackoverflow.com/questions/19845478/is-it-possible-to-declare-a-friend-function-as-static"">Is it possible to declare a friend function as static?</a></p>
",1
47999829,47999723,0,"<pre><code>int value = 0;
for(int ndx = 0; count != ndx; ++ndx)
{
  value *= 10;
  value += str[ndx] - '0';
}
</code></pre>

<p>Assumes  the length is already known and that all characters are between 0 and 9 inclusive.</p>
",0
47999845,47999723,2,"<p>There are several problems with this part of the code:</p>

<pre><code>char oddId[8];
for (int c = 0; c &lt; 8; c++)
{
    if (studentId[c] % 2 != 0)
    {
        oddId[c] = studentId[c];
    }
}
</code></pre>

<p>First, <code>oddId</code> isn't big enough. To hold an 8-digit string, you need 9 elements, because you need a null terminator.</p>

<p>Second, you're using the same index <code>c</code> for the input array and the output array. This means that the elements of <code>oddId</code> that correspond to the even elements of <code>studentId</code> will never be filled in. That's why you see all those garbage characters in the middle of the output.</p>

<p>Third, you never add a null terminator when you're done. That's why you see more garbage characters at the end of the output.</p>

<p>Fourth, if the input string is less than 8 characters long, you'll read past the end of it. You need to use <code>strlen()</code> to get the limit. You should also use this in the earlier loop that prints all the even places, instead of <code>sizeof(studentId)</code>.</p>

<p>Try this:</p>

<pre><code>char oddId[9];
int indexout = 0;
int len = strlen(studentId);
for (int indexin = 0; indexin &lt; len; indexin++)
{
    if (studentId[indexin] % 2 != 0)
    {
        oddId[indexout++] = studentId[indexin];
    }
}
oddId[indexout] = '\0';
</code></pre>

<p>BTW, things would be much easier if you used <code>std::string</code> instead of a C-style string, since it supports concatenation.</p>
",2
48043834,48043752,1,"<p>You seem to have both a class and an array, both named <code>cargaison</code>. That will cause some confusion. Not only for the compiler but also for everyone reading the code.</p>

<p>For example, in code like this</p>

<pre><code>void societe::setcargaison(int i, cargaison a){
    cargaison[i]=a;
}
</code></pre>

<p>how do we know when <code>cargaison</code> is the name of a type and when it is the name of an array? Or, maybe, also the type of the array?  :-)</p>

<p>And, if you create an array, the compiler will call the default constructor for all array members. Does the class have a default constructor?</p>

<p>Also, explicitly calling a destructor like <code>cargaison[i].~cargaison();</code> is wrong in at least 99.99% of all cases. If you have an array, the compiler will do that for you when the array goes our of scope, or when the containing object is destroyed.</p>
",1
48030098,48030053,0,"<blockquote>
  <p>What is wrong?</p>
</blockquote>

<p>This part:</p>

<pre><code>for (auto v : users) {
    v.id = 2;
}
</code></pre>

<p>is wrong. <code>auto v</code> copies the <code>v</code> and loop body applies the changes to the <em>copy</em>. What you want is to work with <em>references</em> in the for loop, like so:</p>

<pre><code>for (auto&amp; v : users) {
    v.id = 2;
}
</code></pre>

<p>Notice that this is not required in your loop that uses <code>printf</code>, but still preferred, since your <code>User</code> objects are not that cheap to copy, especially when <code>name</code>s are big</p>
",0
48014928,48014897,4,"<p>Operator precedence.</p>

<p>Member access (<code>.push_back</code>) has higher precedence than indirection/dereference (<code>*v1</code>), so <code>*v1.push_back(1)</code> is equivalent to <code>*(v1.push_back(1))</code>. This is not what you want.</p>

<p>The parentheses in <code>(*v1)</code> give the expression higher precedence from left-to-right than the member access, thus why it's valid and equivalent to <code>-&gt;</code>.</p>

<p><code>v1-&gt;</code> is syntactic sugar for <code>(*v1).</code> </p>

<p><a href=""http://en.cppreference.com/w/cpp/language/operator_precedence"" rel=""nofollow noreferrer"">Operator Precedence Reference</a></p>
",3
48014991,48014897,0,"<p>Let's say you have this example:</p>

<pre><code>int a[] = {100, 70, 55, 12};
int* pA = &amp;a[0];

*pA++; // you think 100 + 1 but a[0 + 1] so result: 70
</code></pre>

<p>Above you de-referenced pA after incrementing the address it points to not the value it stores in the address it points to.</p>

<p>So you need <code>()</code>:</p>

<pre><code>(*pA)++;
</code></pre>

<ul>
<li>TIP: To change <code>operator precedence</code> use parenthesis.   </li>
</ul>
",0
48015007,48014897,0,"<p>First you need to dereference the pointer to vector in order to be able to call it's member function, hence the syntax:</p>

<pre><code>(*v1).push_back(1);
</code></pre>

<p>The same can be achieved by using the <em>arrow</em> <code>-&gt;</code> operator:</p>

<pre><code>v1-&gt;push_back(1);
</code></pre>

<p>Alternatively pass the argument by reference:</p>

<pre><code>void foo(vector&lt;int&gt;&amp; v1) {
    v1.push_back(1);
}

int main() {
    vector&lt;int&gt; A;
    foo(A);
}
</code></pre>
",0
48043993,48042894,0,"<p>Your txt file contains 11 line, you first need to read string part that you added in option 1.</p>

<pre><code>myfile &lt;&lt; ""Top Ten Highscores.\n"";
</code></pre>

<p>For read this part, you can simlply use <code>getline(myfile, line)</code> and <code>line</code> should be string. Then you can read numbers from txt file. </p>
",0
41899460,41899422,1,"<p>Basicly it reads the standart input until you type in some digits, then it returns the value composed of the digits after you type something different than a digit. It could be used to filter the first number in some input.</p>
",0
40992175,40992099,1,"<p>You could move variable <code>height</code> to <code>main()</code> (make it local) and pass it by reference to all your functions. Actually, I'd say that would be a better style than passing data through global variables.</p>

<p>But in a real project it's typically better to think of what behavior you want from your program, not of what awesome language features you want to use.</p>
",7
40992189,40992099,2,"<p>You pass <code>height</code> by reference in one of your gender functions.</p>

<p>For example:</p>

<pre><code>int getMale(int &amp;height) {
    /* do stuff */
}
</code></pre>

<p>And then simply call it by:</p>

<pre><code>getMale(height);
</code></pre>

<p>Also, are you required go use a global variable?  If not, then make <code>height</code> a local variable in your <code>main</code> as other commenters have stated.  Global variables are considered bad style, as they can cause hard-to-diagnose problems when you're working on a much larger project.</p>
",2
40992276,40992099,1,"<p>Is this program not giving you the correct answer and that's why you want to pass by reference? or what is the exact situation? 
Anyways in order for you to pass by reference then you remove height from being a global variable and have it local in your main, then for your prototypes include a reference parameter then when you call them in main pass your local variable.
This is example of how pass by reference would work.</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

//Prototype
void add(int num1, int num2, int &amp;res);
int main()
{
    int res;
    add(1, 2, res);
    cout&lt;&lt;""I got the value by passing my variable by reference""&lt;&lt;res&lt;&lt;endl;
    return 0;
}
void add(int num1, int num2, int &amp;res)
{
    res = num1 + num2;
}
</code></pre>
",0
40992291,40992099,2,"<p>Declare your two functions like this</p>

<pre><code>int getMale   ( int&amp; height );
int getFemale ( int&amp; height );
</code></pre>

<p>And in your main you declare a variable that you can pass to the functions</p>

<pre><code>int main()
{
    // Declare here instead of globally
    int height = 0;

    // Then you can call
    int result = getMale(height);
        result = getFemale(height);
}
</code></pre>

<p>It will behave the same way. It is considered better practice to pass by reference than to use a global variable, so kudos to you for asking this question.</p>
",0
40750725,40747718,0,"<p>I have written a demo, which works on my computer.</p>

<pre><code>#include &lt;cassert&gt;

#include &lt;complex&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;type_traits&gt;
#include &lt;vector&gt;

int main() {
  assert( std::is_trivially_copy_assignable&lt;std::complex&lt;short&gt; &gt;::value );

  std::vector&lt;std::complex&lt;short&gt; &gt; vtr(256);
  for (int i=0; i&lt;256; ++i)
    vtr[i] = std::complex&lt;short&gt;(i*2,i*2+1);

  {
    std::ofstream output(""data.bin"", std::ofstream::binary);
    for (int i=0; i&lt;256; ++i)
      output.write((char *)&amp;vtr[i],sizeof(vtr[i]));
  }
  vtr.clear();

  std::cout &lt;&lt; vtr.size() &lt;&lt; std::endl;

  vtr.resize(256);
  {
    std::ifstream input(""data.bin"", std::ifstream::binary);
    for (int i=0; i&lt;256; ++i)
      input.read((char *)&amp;vtr[i],sizeof(vtr[i]));
  }

  for (size_t i=0; i&lt;vtr.size(); ++i)
    std::cout &lt;&lt; vtr[i] &lt;&lt; "" "";
  std::cout &lt;&lt; std::endl;

  return 0;
}
</code></pre>

<p>You could run this demo on your computer. If this demo works, it's likely that you made some mistakes in your code. Please provide a complete, and verifiable example.</p>
",12
40572315,40572289,6,"<p>When both classes have a variable named <code>value</code> The <code>B</code> constructor refers to <code>B::value</code>.</p>

<p>After you removed it from <code>B</code>, it started referring to <code>A::value</code>, and assigning to it.</p>

<p>Make the variables <code>A::value</code> private, and you'll see the compiler complain that you try to access an inaccessible member variable.</p>
",0
40572323,40572289,6,"<p>There's no such thing as overriding variables in C++, you don't need to re-declare <code>value</code> in <code>B</code> to make it accessible (being <code>public</code> or <code>protected</code> in <code>A</code> does that for you). In fact, at the moment you declare <code>string value</code> within B, it creates a <strong>different</strong> member <strong>shadowing</strong> the other unqualified identifier. The assignment in <code>B::B()</code> assigns to that and leaves <code>A::value</code> untouched. (You could still specifically refer to <code>A::value</code> from within <code>B</code> if you wanted, though.)</p>

<p>If you remove <code>value</code> from <code>B</code>, you see the inherited <code>A::value</code> <strong>as</strong> <code>B::value</code>, they refer to the same object. Assigning <code>""B""</code> to that changes what <code>A::display()</code> sees.</p>

<h2>What you may have intended</h2>

<p>If you want to make it explicit that you are taking the name <code>value</code> from <code>A</code>, you can use <code>using</code>:</p>

<pre><code>class B : public A{
public:

    using A::value;
    B(){
        value = ""B"";
    }

};
</code></pre>

<p>The primary uses of this construct are</p>

<ul>
<li><p>exposing the member, e.g., if <code>A</code> was derived from as <code>class B : private A</code> only,</p></li>
<li><p>referring to a member in a dependent scope, e.g., if you were writing a <code>template&lt;class A&gt; class B : public A</code>. (Not knowing <em>a priori</em> what <code>A</code>'s going to be the compiler wouldn't know what the <code>value</code> is you're referring to in the constructor, so it needs a hint it's expected to be a member of the template parameter.)</p></li>
</ul>

<h2>Why it's good</h2>

<p>Allowing a member of the same name in a derived class can be useful. Imagine that you're writing your class <code>B</code> and depend on a member called <code>value</code> in it having some semantics. You don't care if someone independently decided to add some utility to your base class <code>A</code> for which they also needed a <code>value</code>. You don't want errors because the other is a <code>const</code> or something. But most importantly, you don't want that to suddenly start overwriting whatever you put into that member variable within the logic of <code>B</code>.</p>

<p>Another interesting case is when designing something like a <code>std::tuple</code> with a non-fixed inheritance graph. But that's a separate discussion.</p>
",0
43965920,43965798,-1,"<p>In a real world application you would use a Database to store the data of your stock and would write a class order which gets its values from the databas. However i dont think you want to have that much effort so here's a esier way: 
Your stock data gets saved in a simple excel table and the order is a textfile 
Order.txt:</p>

<pre><code>Beer 1|Paint 5|Oil 3|.....
</code></pre>

<p>Use the <code>|</code> as markers to create substrings of the individual products in the order 
Bsp. ProductName quantity id|ProductName2 quantity id2|....</p>

<p>As for the excel table you have to to a little research yourself but editing files with a filereader isn't that hard though.</p>

<p>Hope i can help</p>
",1
43966024,43965798,0,"<p>I don't understand what the second and third column signify, I assume one of them is order size.</p>

<p>There are many ways to do this and my method might not be the best in all cases but at least it should work in yours:</p>

<ol>
<li>Read the <code>stock.txt</code> file, you can look at this <a href=""http://www.cplusplus.com/forum/general/13087/"" rel=""nofollow noreferrer"">example</a> but it doesn't really matter what method you use. The important thing is to get the information as a variable into the program. Hopefully your text files uses a tab to separate the fields (this information is lost in the question). </li>
<li>Put the information you get into a <a href=""http://www.cplusplus.com/reference/map/map/map/"" rel=""nofollow noreferrer""><code>std::map</code></a>, call it <code>orders</code>, use the name as <code>key</code> and the <code>ItemCount</code> as value.</li>
<li>Now read the information in <code>order.txt</code>, use the <code>key</code> to look up the <code>value</code> in your <code>orders</code>.</li>
<li>Check that <code>ItemCount</code> is at least a large as the order size.</li>
</ol>
",2
41655846,41655828,0,"<p>You need to make a loop all over the array like this</p>

<pre><code>for(int i=0; i &lt; 6; ++i)
   for(int j=0; j&lt;5; ++j)
        cout &lt;&lt; tic[i][j];
</code></pre>
",4
41655851,41655828,-1,"<p>The key insight here is that <code>tic</code> is in fact a pointer to an array of arrays of strings.
When you try to print <code>tic</code> directly, you will get a memory address.</p>

<p>To print the elements of your string array, you will need to go through it and print each element, e.g. using two nested <code>for</code> loops (since your array has two dimensions).</p>
",6
41686528,41686452,1,"<p>Yes, there are problems.</p>

<p>You will not be able to determine how many bytes were read, because you don't have access to that value, because the temporary pointer was lost.</p>

<p>And you will never be able to free the <code>DWORD</code> object, so you have a memory leak.</p>
",0
41686745,41686452,0,"<p>In this case, you have a memory leak. You will not be able to recover the address of your new <code>DWORD</code> to delete it. The correct usage for this function is to provide the address of an existing <code>DWORD</code> and then to read it.</p>

<pre><code>DWORD bytesRead;
ReadProcessMemory(this-&gt;processHandle, 0, &amp;ret, sizeof(int), &amp;bytesRead);
// bytesRead can be read to see how many bytes were read
</code></pre>

<p>It would be strange, but not impossible, that a function would accept a pointer to a new variable and then delete it internally. Make sure to read the documentation attentively when using a library or API.</p>
",1
40681536,40680880,0,"<p>I recommend using an array of strings:  </p>

<pre><code>std::string getGamerTag(unsigned int t)
{
  static const char * tag_names[] =
  {
    ""Diamond"", ""Silver"", ""Bronze"", ""Wood"", ""Unistall"",
  };
  static const unsigned int name_quantity =
    sizeof(tag_names) / sizeof(tag_names[0]);

  std::string name;
  if ((t &gt; 0) &amp;&amp; (t &lt;= name_quantity))
  {
    name = tag_names[t - 1];
  }
  return name;
}
</code></pre>
",0
40753258,40753174,0,"<p>Assuming your <code>Number</code> class looks like that:</p>

<pre><code>class Number
{
public:
    std::string value;
};
</code></pre>

<p>Then you can print value with :</p>

<pre><code>Number* n1 = new Number();
std::cout &lt;&lt; n1-&gt;value;
</code></pre>
",0
40753738,40753174,3,"<p>In c++ you can overload all kind of operators, etc. +, ++, -, --, ...
You can also overload &lt;&lt; to do whatever you want it to do.</p>

<p>For your example you can do following:</p>

<p>In class definition put</p>

<pre><code>class Number
{
public:
    std::string value;
    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Number&amp; num);
}
</code></pre>

<p>and then define function however you want.
For example:</p>

<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; os, const Number&amp; num)
{
    os &lt;&lt; num.value;
    return os;
}
</code></pre>

<p>After that operator &lt;&lt; on object from class Number will print value saved in string value.</p>

<p>For more informations you can look into: <a href=""http://en.cppreference.com/w/cpp/language/operators"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/language/operators</a></p>
",0
40753718,40753530,3,"<p>Your destructor fails because you are not following the <a href=""https://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming)"" rel=""nofollow noreferrer"">Rule of Three</a> correctly:</p>

<blockquote>
  <p>The rule of three (also known as the Law of The Big Three or The Big Three) is a rule of thumb in C++ (prior to C++11) that claims that if a class defines one (or more) of the following it should probably explicitly define all three:</p>
  
  <ul>
  <li>destructor</li>
  <li><strong>copy constructor</strong></li>
  <li><strong>copy assignment operator</strong></li>
  </ul>
</blockquote>

<ol>
<li><p>your class is <strong>missing a copy constructor</strong> that accepts a <code>test</code> object as input.  You have a <em>converting constructor</em> that accepts a <code>char*</code> as input, but if that input is more than 9 characters than you will trash surrounding memory while copying characters.</p></li>
<li><p>your class is <strong>missing a copy assignment operator</strong> that accepts a <code>test</code> object as input.  You have a <em>converting assignment operator</em> that accepts a <code>char*</code> as input, but it is taking <em>ownership</em> of that <code>char*</code> instead of making a <em>copy</em> of the character data, and it is leaking the previously allocated <code>string</code> buffer.  And worse, it is returning a <em>copy</em> of the <code>test</code> object that is being modified, instead of returning a <em>reference</em> to the object, and that copy does not work correctly because of your missing <em>copy constructor</em>.  So you end up with multiple <code>test</code> objects that are pointing to the same <code>string</code> buffer in memory, so you will have destructors calling <code>delete[]</code> on the same memory too many times.</p></li>
</ol>

<p>Also, your <code>operator+</code> is implemented incorrectly as well.  It returns a new <code>test</code> object, but it is not allocating new memory that accounts for the total length of the two source strings.  You are simply copying character data from the right-hand <code>test</code> object directly into the <code>char*</code> string of the left-hand <code>test</code> object without expanding it first.  So you are trashing surrounding memory.  This <code>operator+</code> is supposed to return a new <code>test</code> object that is a <em>copy</em> of the input strings concatenated together without modifying either of the source strings at all.</p>

<p>Try something more like this instead:</p>

<pre><code>class test
{
public:
    // default constructor
    test()
        : string(0)
    {
    }

    // copy constructor
    test(const test &amp;src)
        : string(new char[src.starlen()+1])
    {
        strcpy(string, src.string);
    }

    // converting constructor
    test(const char* src)
        : string(new char[strlen(src)+1])
    {
        strcpy(string, src);
    }

    // destructor
    ~test()
    {
        delete[] string;
    }

    // copy assignment operator
    test&amp; operator=(const test &amp;rhs)
    {
        if (&amp;rhs != this)
            std::swap(string, test(rhs).string);
        return *this;
    }

    // converting assignment operator
    test&amp; operator=(const char *rhs)
    {
        std::swap(string, test(rhs).string);
        return *this;
    }

    int starlen() const
    {
        return strlen(string);
    }

    test operator+(const test&amp; rhs) const
    {
        int a = starlen();
        int b = rhs.starlen();

        test ret;
        ret.string = new char[a+b+1];
        strcpy(ret.string, string);
        strcpy(ret.string+a, rhs.string);

        return ret;
    }

    void printit() const
    {
        std::cout &lt;&lt; string;
    }

private:
    char* string;
};

int main()
{
    test t1(""book"");
    test t2(""shelf"");
    test t3;
    t3 = t1 + t2;
    cout &lt;&lt; t3.starlen() &lt;&lt; endl;

    t3.printit();

    return 0;
}
</code></pre>

<p>If you are using C++11 or later, you should also follow the <a href=""https://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming)#Rule_of_Five"" rel=""nofollow noreferrer"">Rule of Five</a> as well:</p>

<blockquote>
  <p>With the advent of C++11 the rule of three can be broadened to the rule of five as C++11 implements move semantics, allowing destination objects to grab (or steal) data from temporary objects. The following example also shows the new moving members: move constructor and move assignment operator. Consequently, for the rule of five we have the following special members:</p>
  
  <ul>
  <li>destructor</li>
  <li>copy constructor</li>
  <li><strong>move constructor</strong></li>
  <li>copy assignment operator</li>
  <li><strong>move assignment operator</strong></li>
  </ul>
</blockquote>

<pre><code>class test
{
public:
    // default constructor
    test()
        : string(0)
    {
    }

    // copy constructor
    test(const test &amp;src)
        : string(new char[src.starlen()+1])
    {
        strcpy(string, src.string);
    }

    // converting constructor
    test(const char* src)
        : string(new char[strlen(src)+1])
    {
        strcpy(string, src);
    }

    // move constructor
    test(test &amp;&amp;src)
        : string(0)
    {
        std::swap(string, src.string);
    }

    // destructor
    ~test()
    {
        delete[] string;
    }

    // copy assignment operator
    test&amp; operator=(const test &amp;rhs)
    {
        if (&amp;rhs != this)
            std::swap(string, test(rhs).string);
        return *this;
    }

    // converting assignment operator
    test&amp; operator=(const char *rhs)
    {
        std::swap(string, test(rhs).string);
        return *this;
    }

    // move assignment operator
    test&amp; operator=(test &amp;&amp;rhs)
    {
        std::swap(string, rhs.string);
        return *this;
    }

    int starlen() const
    {
        return strlen(string);
    }

    test operator+(const test&amp; rhs) const
    {
        int a = starlen();
        int b = rhs.starlen();

        test ret;
        ret.string = new char[a+b+1];
        strcpy(ret.string, string);
        strcpy(ret.string+a, rhs.string);

        return ret;
    }

    void printit() const
    {
        std::cout &lt;&lt; string;
    }

private:
    char* string;
};
</code></pre>

<p>That being said, this is probably just a learning exercise in how to write a custom string class.  However, the C++ standard defines a <code>std::string</code> class, you should use it instead.  If you want your own class, you can delegate to <code>std::string</code>, let the compiler and STL do the heavy work for you:</p>

<pre><code>class test
{
public:
    // default constructor
    test()
    {
    }

    // copy constructor
    test(const test &amp;src)
        : str(src.str)
    {
    }

    // converting constructor
    test(const std::string &amp;src)
        : str(src)
    {
    }

    // move constructor
    test(test &amp;&amp;src)
        : str(std::move(src.str))
    {
    }

    int starlen() const
    {
        return str.length();
    }

    test operator+(const test&amp; rhs) const
    {
        return str + rhs.str;
    }

    void printit() const
    {
        std::cout &lt;&lt; str;
    }

private:
    std::string str;
};
</code></pre>
",2
40753727,40753530,0,"<p>Who's responsibility is it to delete the internal string?  I notice you are assigning the string's memory into t3 with no constructor, then calling a destructor on probably the same memory address twice.  Also, your operator +, the coping is very likely going to write passed the end of the array it is being assigned back into.  You at the very least should have a strlen() end check there to prevent that from occuring.  If you have corrupted your buffer, then any call to delete[] will complain due to memory overwrites on the heap.</p>

<p>Please see Remy's answer for a much better solution that properly handles the (quite complex) nature of string manipulation and memory allocation issues.  That answer is even exception safe from what I can see.</p>
",0
40890553,40890468,0,"<p>gdb would help to see where it actually crashes but:</p>

<p><code>f[i+1][n]</code> and <code>i</code> grows up to <code>nstep_x</code>, but <code>f</code> is allocated as <code>f[nstep_x]</code>[nstep_t],
so it seems like you'd be accessing <code>f[nstep_x+1][n]</code>, but the maximum you can is <code>f[nstep_x-1][n]</code>.</p>
",0
40893087,40892937,0,"<pre><code>    r=(r)*11;
    curr=int(r);
    //...
    arr[curr]=//...
</code></pre>

<p><code>r</code> can take a value of 10.X at low probability, causing <code>curr</code> to take the value of 10, assigning to <code>arr</code> at 10, which corrupts memory.</p>
",5
40893192,40892971,2,"<p>This is not a silly question, and there's a <em>ton</em> of bad advice on this particular subject out there.</p>

<p>First, to get the <code>ray_factor</code> into <code>saveIntensityMap</code>, simply pass it as another argument:</p>

<pre><code>void IOFile::saveIntensityMap(const char* fileName,
                              float ray_factor,
                              vector&lt;float&gt;* intensityMap)
{
   ...
}
</code></pre>

<p>Second, forget you ever heard of formatted iostreams output, it is enormously more trouble than it's worth.  (This is the part where there's lots of bad advice on the 'net.  I personally never use iostreams at all; I think the old-fashioned <code>&lt;stdio.h&gt;</code> API is a much more ergonomic interface.  Writing a floating-point number into a string with proper control over the output format is one of the things that iostreams are especially bad at.)</p>

<p>To construct the filename you want, use <code>snprintf</code> to format the number and concatenation of <code>std::string</code> objects to assemble the name, like this:  (note that I am assuming the <code>fileName</code> argument to <code>saveIntensityMap</code> does <em>not</em> have the <code>.txt</code> extension already - it will probably be easier to change that than to take the string apart and put it back together; C++ is not really very good at strings)</p>

<pre><code>char ray_factor_buf[10];
snprintf(ray_factor_buf, sizeof ray_factor_buf, ""%.2f"", ray_factor);

string full_filename = fileName;
full_filename += ""_"";
full_filename += ray_factor_buf;
full_filename += "".txt"";

std::ofstream file(full_filename, std::fstream::out|std::fstream::trunc);
</code></pre>

<p>If your C++ library has not yet been updated to C++11, that last line will need to be</p>

<pre><code>std::ofstream file(full_filename.c_str(), std::fstream::out|std::fstream::trunc);
</code></pre>
",2
40953930,40953381,0,"<p>If you have different intermediary folders for .obj files or .o files, it will work, but it is the worst solution.
Version control will solve this problem nicely and CI will help you by compiling over night, running tests....</p>
",0
40967725,40965911,0,"<p>You need to fix that warning.</p>

<p>Your case is a little different but there's an easy way. Create a little container object that looks like this </p>

<p>class Context { AIShell* theObject; int number; } </p>

<p>Create a static function that looks like this </p>

<p>static void* ThreadFunction(void* context) </p>

<p>Then, where you are currently calling pthread_create, instantiate a Context object with ""this"" and the number (1 through 3). </p>

<p>Pass ThreadFunction as the start_routine, and the Context object as the last arg. Then, within ThreadFunction, you can call </p>

<p>Context* ctxt = (Context*) arg;
ctxt->theObject->thread_work(ctxt->num) </p>
",1
40966241,40965911,1,"<p>You're leaking memory there, for one. you malloc memory  and assign pointer to se in thread function, then assign  value of arg to the same pointer. Memory , allocated by first line of thread_work will be lost.</p>

<p>Second, why you cast so  <code>(void * (*)(void *)) &amp;AIShell::thread_work</code>? </p>

<p>Function declared as</p>

<pre><code>void * AIShell::thread_work(void * arg)
</code></pre>

<p>doesn't require such cast unless.. it's a method of class and AIShell is class, not namespace. Is AIShell a class then? In that case you either need a static function or use std::bind to generate a wrapper for it, non-static methods actually have hidden argument of ""this"".</p>

<p>Line </p>

<pre><code>se = (struct start_end *) &amp;arg;
</code></pre>

<p>is wrong because you get address of argument arg(which is in stack supposedly?) and convert it to pointer to struct, while actually that memory contains pointer. It doesn't produce segfault because most likely you appear to access stack or data segment, no violation there.
Debug program and check value of arg in worker and compare it to value of se+i given to pthread_create. That is value of pointer in first place.</p>
",6
48034357,48034299,0,"<pre><code>Robot newRobot(mapnum, x, y);
</code></pre>

<p>This creates an object of type <code>Robot</code> named <code>newRobot</code>. At the end of the block where it was created it will be destroyed.</p>
",1
48034756,48034299,2,"<p>This constructor has three local variables with the same names as other variables:</p>

<pre><code>Game::Game()
{
    vector &lt;Robot&gt; RobotVec; // Not your global variable
    Map map1(1);             // Not your member variable
    Map map2(2);             // Not your member variable either
}
</code></pre>

<p>In order to initialise members, you use the <em>initialiser list</em>:</p>

<pre><code>Game::Game()
  : map1(1),
    map2(2)
{
}
</code></pre>

<p>In <code>addRobot</code>, this creates a robot and points <code>X</code> at it:</p>

<pre><code>Robot* X = new Robot;
</code></pre>

<p>This also creates a robot, so now you have two:</p>

<pre><code>Robot newRobot(mapnum, x, y);
</code></pre>

<p>And this memory leak points <code>X</code> away from its original robot and instead points it at <code>newRobot</code>, which will be destroyed immediately afterwards:</p>

<pre><code>X = &amp;newRobot;
</code></pre>

<p>Note that <code>addRobot</code> does not at any point add either robot to anything ¨C it creates two and ignores them both.  </p>

<p>You should make the vector a member (avoid global variables unless repeating other people's mistakes is a particular passion of yours):</p>

<pre><code>class Game
{
private:
    int robotsNum;
    vector&lt;Robot&gt; robotVec;
    Map map1;
    Map map2;
// ...
};

Game::Game()
  : robotsNum(0),
    map1(1),
    map2(2)
{
}
</code></pre>

<p>And add your new robot to the vector:</p>

<pre><code>void Game::AddRobot(int mapnum, int x, int y) {
    // ...

    Robot newRobot(mapnum, x, y);
    robotsNum++;
    newRobot.setRobotID(robotsNum);
    robotVec.push_back(newRobot);
}
</code></pre>
",2
41206161,41206024,0,"<p>Adding rows are very easy in two dimensional arrays e.g</p>

<p>I'm assuming your 2048 game is of 4*4 matrix</p>

<pre><code>void addRows(int matrix[4][4],int row1,int row2,int col)
{
  for(int i= 0;i&lt;col;i++)
  {

     matrix[row1][i]+=matrix[row2][i];
  }
 }
</code></pre>
",1
41651553,41651490,0,"<p>There is no built-in type that can accommodate you. You will need to implement the logic yourself, or use an existing library such as <a href=""https://mattmccutchen.net/bigint/"" rel=""nofollow noreferrer"">this one</a>.</p>
",0
41218167,41218151,8,"<p>a <code>new</code> expression returns a pointer, so your <code>cipher</code> must be one:</p>

<pre><code>long *cipher = new long[regular.length()];
</code></pre>

<p>But using raw arrays is error prone. Consider substituting <code>std::vector</code> instead:</p>

<pre><code>std::vector&lt;long&gt; cipher(regular.length());
</code></pre>
",2
47690121,41536407,0,"<p>Until yesterday (2017-12-06) this was not compiling under MSVC. But after VS 15.5 update it does.</p>

<pre><code>    auto msvc_does_compile = [](auto _string)
     {
      using string_type = decltype(_string);
      return std::vector&lt;string_type&gt;{};
     };
   /*
    OK since VS 2017 15.5 update
   auto vec1 = msvc_does_compile( std::string{} );
   */
</code></pre>

<p>Adding explicit return type will choke MSVC , but not gcc/clang as usual:</p>

<pre><code>auto msvc_does_not_compile = [](auto _string)
    // explicit return type makes msvc not to compile
    -&gt; std::vector&lt; decltype(_string) &gt;
  {
    using string_type = decltype(_string);
    return std::vector&lt;string_type&gt;{};
  };
</code></pre>

<p>And something of the same but simpler will be stopped even at the IDE stage:</p>

<pre><code>    auto msvc_ide_does_not_allow = []( bool wide )
    {
       if (wide)
        return std::vector&lt;std::string&gt;();

        return std::vector&lt;std::wstring&gt;();
    };
</code></pre>

<p>Yes, again that troublesome pair gcc/clang has no problems with the above. Try which ever online ide you prefer to convince yourself...</p>
",0
46079349,46079223,0,"<p>It is not clear, what you are trying to do with that loop, and it looks very suspicious (you need to provide more information on what you are trying to do here for advise on how to fix it if necessary), but assuming it is correct your code can be fixed by eliminating that buffer  and <code>strcpy()</code> call at all:</p>

<pre><code>int wordLen = 0;

for (int i = 0; i &lt; word[i]; i++){
    wordLen++;
}
</code></pre>

<p>if you need a copy of variable <code>word</code> to modify, not changing original, then just create another <code>std::string</code> instance as a copy. There is no reason to create raw char array in your case.</p>
",6
42515554,42515509,5,"<ol>
<li>Its <code>cout</code> not <code>Cout</code>, notice the case difference.</li>
<li><code>cout</code> is in the namespace <code>std</code>. In order to use it you need to resolve the namespace with <code>std::</code>, so use <code>std::cout &lt;&lt; ...</code>.</li>
<li>As much as people will tell you to just do <code>using namespace std</code>, <strong>dont</strong>. For more info, <a href=""https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice"">see <em>Why is ¡°using namespace std¡± considered bad practice?</em>.</a></li>
</ol>
",0
42515616,42515509,-1,"<p>Change your code to this:</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
int main()
{
    Sally so;
    cout&lt;&lt;""the text""&lt;&lt;endl;
}    
</code></pre>

<p>Hope it helps!!
Cheers</p>
",2
42515630,42515509,2,"<ol>
<li><p>You are writing ""Cout"" not ""cout"" - C++ is case sensitive, so those two are not the same thing.</p></li>
<li><p>You should write <code>std::cout</code> since the <code>cout</code> stream lives in the <code>std</code> namespace.</p></li>
<li><p>The same goes for <code>endl</code> which should be <code>std::endl</code>.</p></li>
</ol>

<p>You <em>could</em> avoid writing <code>std::</code> by using <code>using namespace std;</code> but I wouldn't advice it - it pulls all of the namespace into the current scope which may not hurt for a trivial program <em>will</em> bite for a more complex one (at the very least, don't do it in headers).</p>

<p>Just do this:</p>

<pre><code>#include &lt;iostream&gt;
int main(){
    Sally so;
    std::cout &lt;&lt; ""omg wtf is this on my shoe"" &lt;&lt; std::endl;
}
</code></pre>

<p>Btw; unless you know you want to flush the stream, prefer <code>'\n'</code> over <code>std::endl</code>.</p>
",2
41401241,41400199,0,"<p>The problem with <code>delete []</code> name you was facing is the direct result of <em>creating a student without a name</em>. </p>

<pre><code>Student student; // student.name is uninitialized. Accessing its value 
                 // would be undefined behaviour.
</code></pre>

<p>When you try to use <code>SetName</code> for the first time, you have an uninitialiised value, and deleting it leads to a crash; so you leave out the <code>delete[]</code>, and it leads to a memory leak. </p>

<p>Perhaps you expected to <code>student.name</code> to start its life as a null pointer, however this is not how C++ is defined. You must do it yourself.</p>

<p>The idiomatic C++ way is to initialize it in your constructor.</p>

<pre><code> class Student {
  public:
    Student : name(nullptr) {}
    ...
</code></pre>

<p>Now you can uncomment that <code>delete</code> </p>

<p>Let this bug be an important lesson for you. Always write a constructor for your class, and always initialise all data members in it.</p>

<p>Which brings us to the next point. How do you initialize ID and faculty? There are no default ""empty"" values for them. Even if there were, a student with no ID and no faculty is some kind of ghost we don't want to deal with. </p>

<p>The idiomatic C++ way is to pass these values as parameters to your constructor.</p>

<pre><code> class Student {
  public:
    Student (int ID_, Faculty faculty_) : 
          name(nullptr), ID(ID_), faculty(faculty_) {}
    ..
</code></pre>

<p>But wait, we have created an unnamed student, which may lead to all kinds of problems down the road. Perhaps pass the name to the constructor too?</p>

<pre><code> class Student {
  public:
    Student (const char* name_, int ID_, Faculty faculty_) :
         name(nullptr), ID(ID_), faculty(faculty_) {
       SetName(name_);
    }
  ...
</code></pre>

<p>Now this is a student we can be proud of... except for one thing. We can still pass a null pointer as a name, and the student will be left nameless. In <code>SetName</code> you deal with it by returning <code>false</code> to indicate a failure. Constructors don't return values. What to do?</p>

<p>The idiomatic C++ way is <em>to throw an exception</em>.</p>

<pre><code> class Student {
  public:
    Student (const char* name_, int ID_, Faculty faculty_) :
         name(nullptr), ID(ID_), faculty(faculty_) {
       if (!name_)
          throw std::domain_error(""Null name passed to Student::Student"");
       SetName(name_);
    }
  ...
</code></pre>

<p>Your class should have a copy constructor according to the rule of three:</p>

<pre><code> class Student {
  public:
    Student(const Student&amp; other) : 
         Student(other.name, other.ID, other.faculty) {}
    Student (const char* name_, int ID_, Faculty faculty_) :
         name(nullptr), ID(ID_), faculty(faculty_) {
       if (!name_)
          throw std::domain_error(""Null name passed to Student::Student"");
       SetName(name_);
    }
</code></pre>

<p>Of course in real code you want to use <code>std::string</code> rather than manually managing C-style strings.</p>
",0
41906004,41905875,4,"<p>You just need to create a struct variable; set attribute for it; then push that struct to the vector.   </p>

<p>In C++, declare a struct variable with <code>Movie aMovie;</code> is good enough. No need for <code>struct Movie aMovie;</code>.</p>

<pre><code>using namespace std;
    struct Movie {
        string title;
        string director;
        string genre;
        string yearRelease;
        string duration;
    };
int main(){
    cout &lt;&lt; ""Hi"";
    ifstream fin;
    string line;

    vector &lt;Movie&gt; m;
    fin.open(""Movie_entries.txt"");
    while (getline(fin, line)) {
        cout &lt;&lt; line &lt;&lt; endl;
        stringstream lineStream(line);
        struct Movie aMovie;
        getline(lineStream, aMovie.title, ',');
        getline(lineStream, aMovie.director, ',');
        getline(lineStream, aMovie.genre, ',');
        getline(lineStream, aMovie.yearRelease, ',');
        getline(lineStream, aMovie.duration, ',');
        m.push_back(aMovie);
    }
}
</code></pre>
",3
44737007,44736966,1,"<p>You are creating a new file on each iteration.<br>
Just put the line:</p>

<pre><code>ofstream o(""keylogger.txt"");
</code></pre>

<p>before the while loop</p>
",4
42388181,42387937,0,"<p>You can pass a complete object by p pointer and push it to the vector, it would look the same, but without string <code>Product* p(std::string id, std::string t, std::string d, double p, int qa);</code> Also you can create a copy of your Product, this way is valid if you have a copy constructor.</p>

<pre><code>void Store::addProduct(Product* p)
{

    Product* copyOfP = new Product(*p);
    inventory.push_back(copyOfP);
}
</code></pre>

<p>Or another not very good way:
    void Store::addProduct(Product* p)
    {</p>

<pre><code>    Product* copyOfP = new Product(p-&gt;getId(), p-&gt;getT(), p-&gt;getD, ... );
    inventory.push_back(copyOfP);
}
</code></pre>

<p>If you choose a variant with copies - don't forget to delete them manually in destructor of Store.</p>
",0
42388189,42387937,0,"<p>Your code</p>

<pre><code>void Store::addProduct(Product* p)
{
    Product* p(std::string id, std::string t, std::string d, double p, int qa);
    inventory.push_back(p);
}
</code></pre>

<p>might issue a warning - you have redeclared the formal parameter <code>p</code>.</p>

<p>The line</p>

<pre><code>    Product* p(std::string id, std::string t, std::string d, double p, int qa);
</code></pre>

<p>looks like a function declaration for something return a pointer to a <code>Product</code>. You sent a <code>Product</code> pointer in to the function, so just use that:</p>

<pre><code>void Store::addProduct(Product* p)
{
    inventory.push_back(p);
}
</code></pre>

<p>You are trying to push_back the function <code>p</code> - don't ignore warnings.</p>
",0
41930032,41929969,0,"<p>Your boolean expression is wrong. You need to loop while any of the conditions is true since it has to end when i % 17 == 0, i % 32 == 0 or sqrt(i) &lt;= 120. The negation of this is an or'd expression.</p>
",0
41930048,41929969,2,"<p><code>i%17!=0 &amp;&amp; i%32!=0 &amp;&amp; sqrt(i)&lt;120</code> here is the problem. Your stopping condition should be:</p>

<p>while (it is <strong>NOT</strong> (Divisible by 17 <strong>AND</strong> Divisible by 18 <strong>AND</strong> its root more than 120)).</p>

<p>This is equal to:</p>

<pre><code>while(!(i%17==0 &amp;&amp; i%32==0 &amp;&amp; sqrt(i)&gt;120))
</code></pre>

<p>Or even shorter using <a href=""https://en.wikipedia.org/wiki/De_Morgan&#39;s_laws"" rel=""nofollow noreferrer"">Demorgan Law</a>:</p>

<pre><code>while(i%17!=0 || i%32!=0 || sqrt(i)&lt;=120)
</code></pre>
",0
41930243,41929969,0,"<p>The answer is</p>

<pre><code>#include &lt;math.h&gt;       /* ceil */
#include &lt;iostream&gt;
int main ()
{
    std::cout&lt;&lt;ceil((120*120)/(32*17))*(32*17);
}
</code></pre>

<p>Do not use loops for simple math problems</p>
",0
41930255,41929969,0,"<p>To improve efficiency, you should start with LCM of 17 &amp; 32 i.e. 544 and then work your way up instead of starting from 1.</p>
",0
43221189,43220869,0,"<p>You declare elems as a vector of pointers to node(s), but you never actually cut out any memory for them; so I think you are effectively dereferencing a NULL pointer- hence why it failed. Either cut out the memory or make elems a vector of just node(s).</p>

<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;

struct node {
    std::string s;
    node* next;
};

int main() 
{
    // Constructs the container with 5 copies of a pointer to a node- note no actual memory is given to them yet.
    std::vector&lt;node*&gt; elems(5); // efectivly the same as your initalizer list for elems(bucket_count)
    std::cout&lt;&lt;""Size is: ""&lt;&lt;elems.size()&lt;&lt;std::endl;
    if(elems[0] == NULL)
    {
        std::cout&lt;&lt;""elems[0] is a null pointer so dont use it!""&lt;&lt;std::endl;
    }
    else
    {
        std::cout&lt;&lt;""elems[0] has the string: ""&lt;&lt; elems[0]-&gt;s &lt;&lt;std::endl;
    }
}
</code></pre>
",2
42465818,42465790,1,"<p><code>new_node</code> is referencing an element in a local variable (the <code>vector</code> is passed as copy argument). Try passing it as reference.</p>
",6
43220791,43220732,0,"<p>Reduction:</p>

<pre><code>while(condition1)
{
    if(condition2)
    {
         statements
    } else {
         statement that doesn't affect condition1
         if (condition2)
         {
             statements
         } else {
             // infinite loop happens here
             if (condition3)
             {
                statements
             }
         }
    }
}
</code></pre>

<p>Problem:</p>

<p>You have a while loop that descends into a state where it cannot advance. Your comment locates the position pretty good. If <code>condition1</code> is true and <code>condition3</code> is false nothing happens ever so the code never stops.</p>

<p>I'm very sure the remaining case is <code>node == node-&gt;parent-&gt;right</code> but I have no certainty of being able to write it. red-black is not symmetric.</p>
",1
45705711,45705514,1,"<p>You can use <a href=""https://www.tutorialspoint.com/cplusplus/cpp_references.htm"" rel=""nofollow noreferrer"">references</a> to achieve what you need. </p>

<p>So your function declaration will change to </p>

<pre><code>func(int arr[], int size, int &amp;sum, int &amp;avg, int &amp;min, int &amp;max)
</code></pre>

<p>And inside you can use the variables directly as <code>min</code>, <code>max</code>, <code>avg</code> etc. </p>

<p>In the main you will have to call as </p>

<pre><code>func(arr, size, sum, avg, min, max);
</code></pre>

<p>Finally, I will suggest you to create local variables, do all the calculations in them and them finally assign the values to the references passed (This might be a bit optimized in most cases).</p>
",0
45706130,45705514,1,"<p>To reduce dereference-cluttering, use local variables for the computations and write to the parameters when you're done.</p>

<p>Example:</p>

<pre><code>void sum(const std::vector&lt;int&gt;&amp; numbers, int* result)
{
    int total = 0;
    for (auto i: numbers)
    {
        total += i;
    }
    *result = total;
}
</code></pre>

<p>This has a couple of other benefits in addition to readability:</p>

<ul>
<li>It's faster, because there's no need to constantly read and write through an indirection. (References are just as bad as pointers in this regard.)    </li>
<li>It leaves the out parameter unmodified if something throws an exception. </li>
</ul>
",1
48038639,48038627,1,"<p>Yes, look up delay-loaded DLLs. It can even be done with a custom resolution function.</p>
",1
43935055,43935002,1,"<p>You can use <code>static_cast</code> instead of <code>forward</code> here, as your goal is to cast to the exact types specified in <code>Ts...</code>:</p>

<pre><code>// ...
P(static_cast&lt;Ts&gt;(ts)...);
// ...
</code></pre>
",1
42679393,42679269,0,"<p>With the parentheses, you increment the object the pointer is referencing, without them, you are incrementing the pointer to the next memory address and THEN dereferencing it (which in this case would do nothing).</p>
",0
42679447,42679269,0,"<p>If parentheses are not there then you are basically modifying the memory address stored inside <code>xPtr</code> and then dereferencing the pointer. So clearly this is not what is desired.</p>

<p>Say we want the value stored at memory location <code>1000</code> to be incremented, but</p>

<pre><code>*xPtr++;
</code></pre>

<p>results in incrementing the memory location by 4 and then,value at memory location <code>1004</code> is accessed, assuming size of integer on the machine is <code>4 bytes</code>.</p>
",0
42679521,42679269,0,"<p><code>(*xPtr)++</code> will increment the thing <code>xPtr</code> points to.</p>

<p>Postfix <code>++</code> has higher precedence than unary <code>*</code>; without parentheses, the code would be parsed as <code>*(xPtr++)</code> - you're incrementing <code>xPtr</code>, not the thing <code>xPtr</code> points to.</p>
",0
45214121,45214054,1,"<p>Yes, the execution time is quadratic in <code>n</code>, so it's O(n<sup>2</sup>).</p>

<p>By the way, you could have written this as</p>

<pre><code>for(int i=0;i&lt;n;i+=2)
    for(int j=i;j&lt;n;j++)
         cout&lt;&lt;j;
</code></pre>
",1
42615494,42615034,0,"<p>you can just declare a <code>vector&lt;vector&lt;int&gt;&gt; nameVector</code>,(give it a size) and inside of while you put the data. Or be more specific on what you want.</p>
",0
43220176,43220111,0,"<p>This function call <code>loadArray(&amp;infoArray[6]);</code> will pass the address of the 7th element to your function.  Your array only has 6 elements so this will result in an out of bounds access.  </p>

<p>I believe you want to pass the array itself, `loadArray(infoArray);</p>
",0
43220699,43220111,0,"<p>Piggy backing off of Huynh. When you add to count you start at one. IE Count = count +1. This can be fixed by adding -1 to arraySize = count</p>

<pre><code>  while(!fileData.eof()){
        for(int i = 0; i &lt; 6; i++){
            fileData &gt;&gt; infoArray[i].id &gt;&gt; infoArray[i].firstName &gt;&gt; infoArray[i].lastName &gt;&gt; infoArray[i].salary;
            count++;
        }
    }
    arraySize = count -1;

    for(int i = 0; i&lt; arraySize; i++){

        cout &lt;&lt; infoArray[i].id &lt;&lt; infoArray[i].firstName &lt;&lt; infoArray[i].lastName &lt;&lt; infoArray[i].salary &lt;&lt; endl;

    }
}
</code></pre>

<p>Also lastly you could check the size of the array for your for loop insted using count by doing:</p>

<pre><code>for(int i = 0; i&lt; sizeof(infoArray)/sizeof(*infoArray) ; i++)
</code></pre>
",1
43209791,43209662,0,"<p>Even supposing that this code works properly (that means that number of items is even):</p>

<pre><code>while (a != NULL)
{
    nodePtr temp = a-&gt;next;
    nodePtr temp1 = c-&gt;bottom;
    delete a;
    delete c;
    a = temp;
    c = temp1; // fixed definitely incorrect assignment
}
</code></pre>

<p>You have an undefined behavior when <code>a</code> and <code>c</code> pointer are met you start delete nodes that are already deleted.</p>

<p>So, the proper way IMHO is to delete nodes only in one direction (I'd choose the forward direction).</p>
",0
43221104,43220798,0,"<p>What is happening is that <code>push_back</code> is never called for the last <code>input</code>.  This is because the new <code>input</code> is read in during the <code>while</code> loop but only at the end.  You can make it work by checking the <code>while</code> at the end with a <code>do</code> loop.  Or reading the <code>input</code> at the start of the loop and then <code>push_back</code>.</p>

<pre><code>do {
    cin &gt;&gt; input;
    newMyVector.push_back(input);
    cin.ignore(numeric_limits&lt;streamsize&gt;::max(), ',');
} while(cin.peek() != '\n');
</code></pre>

<p>Or</p>

<pre><code>void fillVector(vector&lt;int&gt;&amp; newMyVector) {
cout &lt;&lt; ""Please type in a series of numbers separated by a comma, and press Enter when done."" &lt;&lt; endl;
int input;
while (cin.peek()!= '\n') {
    cin &gt;&gt; input;        
    newMyVector.push_back(input);
    cin.ignore(numeric_limits&lt;streamsize&gt;::max(), ',');
}
cout &lt;&lt; endl;
}
</code></pre>

<p>Both of these are basically the same.</p>
",1
45046045,45046031,2,"<p>Change</p>

<pre><code>cout &lt;&lt; arr[x] &lt;&lt; endl;
</code></pre>

<p>To</p>

<pre><code>cout &lt;&lt; arr[c] &lt;&lt; endl;
</code></pre>
",0
45046046,45046031,3,"<p>Since <code>x</code> is 4, <code>arr[x]</code> is <code>arr[4]</code>. But <code>_arr</code> only has four entries, it doesn't have a fifth entry. So you are outputting garbage. You probably meant <code>arr[c]</code> in the loop.</p>
",0
45046051,45046031,5,"<p>You are confusing the array limit with the indexer. Should be:</p>

<pre><code> cout &lt;&lt; arr[c] &lt;&lt; endl;
</code></pre>

<p>Arrays are zero indexed. You are trying to print out the element that is out of bounds thus invoking undefined behaviour. Depending on the platform your output might look like four <code>0</code> or something like <code>-858993460</code>. By convention counter variables usually start with the letter <code>i</code>.</p>
",1
45046153,45046031,1,"<p>There is a typo in the loop inside the function</p>

<pre><code>for(int c = 0;c &lt; x;c++){
    cout &lt;&lt; arr[x] &lt;&lt; endl;
               ^^^
}
</code></pre>

<p>There should be</p>

<pre><code>for(int c = 0;c &lt; x;c++){
    cout &lt;&lt; arr[c] &lt;&lt; endl;
               ^^^
}
</code></pre>

<p>It is the variable <code>c</code> that serves as an index in the array.</p>

<p>Nevertheless the program has several drawbacks.</p>

<p>You should not use identifiers starting with an underscore. Such names can be reserved by the compiler implementation.</p>

<p>Do not use ""magic numbers"". They are usually serve as a reason for bugs.</p>

<p>To store sizes of objects or arrays use the type <code>size_t</code> instead of the type <code>int</code>.</p>

<p>The function does not change the array. So the corresponding parameter should be declared with the qualifier <code>const</code>.</p>

<p>The program can look the following way</p>

<pre><code>#include &lt;iostream&gt;

void pi( const int arr[], size_t n )
{
    for ( size_t i = 0; i &lt; n; i++ )
    {
        std::cout &lt;&lt; arr[i] &lt;&lt; std::endl;
    }
}

int main()
{
    int arr[] = { 3543, 146, 961262,-242 };
    pi( arr, sizeof( arr ) / sizeof( *arr ) );
}
</code></pre>

<p>Take into account that you could output the array using a standard algorithm as for example <code>std::for_each</code> or <code>std::copy</code>.</p>

<p>Here is a demonstrative program that uses the standard algorithm <code>std::copy</code> to output the array.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

int main()
{
    int arr[] = { 3543, 146, 961262,-242 };
    std::copy( std::begin( arr ), 
               std::end( arr ), 
               std::ostream_iterator&lt;int&gt;( std::cout, ""\n"" ) );
}
</code></pre>
",0
43734484,43731500,0,"<p>As you would not like to use arrays, vectors or anything like that here you are a solution that may help you.</p>

<p>Note: using a temp storage will make it more compact.</p>

<p>The idea is to use three function:</p>

<p>1- get_line_num: counts line numbers of the file.<br>
2- goto_line: puts the reading cursor into a specific line.<br>
3- reset: put the reading cursor in the beginning of the file. </p>

<p>Program has a lot of I/O which is not good, but as you do not want to use advanced structures, this may help. </p>

<p>algorithm:</p>

<ol>
<li>open original file. </li>
<li>open temp file.</li>
<li>loop from last line to first line  </li>
<li>read line from input file.</li>
<li>add the line into the temp output file</li>
<li>end loop.</li>
<li>delete the old original file.</li>
<li>rename the temp file same as the original file.</li>
</ol>

<p>Headers:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
using namespace std;

int get_line_num(ifstream&amp; myfile);
ifstream&amp; goto_line(ifstream&amp; myfile, int line_num);
void reset(ifstream&amp; myfile);

int main()
{
    ifstream in;
    ofstream out;

    string line;

    char* original = ""original file name"";
    char* dest = ""temp file name"";

    in.open(original);
    out.open(dest, ios::app);

    int num_of_lines = get_line_num(in);

    for (int i = num_of_lines ; i ; --i)

    {
         goto_line(in, i);
         getline(in, line);
         reset (in);
         out &lt;&lt; line &lt;&lt; ""\n"";
    }

    in.close();
    out.close();

    remove(original);
    rename(dest, original);

    cout &lt;&lt;""\n\n\n"";
}


int get_line_num(ifstream&amp; myfile)
{
    int number_of_lines = 0;
    string line;

    while (getline(myfile, line))
        ++number_of_lines;

    reset (myfile);

    return number_of_lines;
}

ifstream&amp; goto_line(ifstream&amp; myfile, int line_num)
{
    string s;
    myfile.seekg(ios::beg);
    for(int i = 1; i &lt; line_num; ++i)
        getline(myfile, s);

    return myfile;
}

void reset(ifstream&amp; myfile)
{
    myfile.clear();
    myfile.seekg(0, ios::beg);
}
</code></pre>
",0
46674586,46674466,0,"<p>I don't understand why you added the last <code>catch (char x)</code> clause.</p>

<p>When the program looks like this:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
  int x;
  cin&gt;&gt;x;
  cout &lt;&lt; ""Before try \n"";
  try {
    cout &lt;&lt; ""Inside try \n"";
    if (x &lt;0)
    {
       throw x;
       //cout &lt;&lt; ""After throw (Never executed) \n"";
    }
  }
  catch (int x ) {
    cout &lt;&lt; ""Exception Caught \n"";
  }
}
</code></pre>

<p>It seems to work:</p>

<ul>
<li>positive numbers won't throw exception</li>
<li>negative numbers throw an exception</li>
</ul>
",0
43752311,43751221,2,"<p>You could just call the string's <code>substring</code> method, after figuring out the range of characters that are either digits, arithmetic characters, or unwanted. </p>
",1
43751539,43751221,1,"<p>You mentioned - <em>The type of the value returned is char, so there is no way to put it in the vector.</em></p>

<p>You have some function that returns a character. You want to then insert the equivalent string into the vector.</p>

<p>Assuming your vector is defined as</p>

<pre><code>std::vector&lt;std::string&gt; broken_strings;
</code></pre>

<p>So you can do it as follows.</p>

<pre><code>char ch = ...; // Here comes the character that you get from the function.
std::string str(1, ch);
broken_strings.push_back(str);
</code></pre>

<p>Then you can return broken_strings.   </p>

<p>Edit:</p>

<p>OP mentions that he wants to tokenize algebraic expressions.
So it will have to be done it a different way. </p>

<p>Following is a simple approach.</p>

<pre><code> std::vector&lt;std::string&gt; broken;
 std::string temp;
 for ( int i = 0; i&lt;s.length() ;i++){
     char ch = s[i];
     if (ch == ' ')
         continue;
     else if (ch &gt;= '0' &amp;&amp; ch &lt;='9')
         temp += ch;
     else{
         if (temp.length() != 0)
             broken.push_back(temp);
         temp = """";
         temp += ch;
         broken.push_back(temp);
         temp = """";
     }
 } 
 if (temp.length() != 0)
     broken.push_back(token);
 return broken; 
</code></pre>

<p>You can see the demo of the same here</p>

<p><a href=""https://ideone.com/ePYxNI"" rel=""nofollow noreferrer"">Ideone</a></p>
",7
43753177,43751221,0,"<pre><code>vector&lt;string&gt; tokenise(string s)
{
    vector&lt;string&gt; v;

    string number;

    for(int i = 0; i &lt; s.length(); ++i)
    {
        if((s[i] &gt;= '0') &amp;&amp; (s[i] &lt;= '9'))
        {
            number += string(1, s[i]);
        }
        else if(s[i] == '.')
        {
            number += string(1, s[i]);
        }
        else if((s[i] == '+') || (s[i] == '-') || (s[i] == '*') || (s[i] == '/'))
        {
            if(number.size())
            {
                v.push_back(number);
                number.clear();
            }
            v.push_back(string(1, c));
        }
    }

    if(number.size())
    {
        v.push_back(number);
        number.clear();
    }

    return v;
}
</code></pre>
",1
43752311,43751221,2,"<p>You could just call the string's <code>substring</code> method, after figuring out the range of characters that are either digits, arithmetic characters, or unwanted. </p>
",1
43751539,43751221,1,"<p>You mentioned - <em>The type of the value returned is char, so there is no way to put it in the vector.</em></p>

<p>You have some function that returns a character. You want to then insert the equivalent string into the vector.</p>

<p>Assuming your vector is defined as</p>

<pre><code>std::vector&lt;std::string&gt; broken_strings;
</code></pre>

<p>So you can do it as follows.</p>

<pre><code>char ch = ...; // Here comes the character that you get from the function.
std::string str(1, ch);
broken_strings.push_back(str);
</code></pre>

<p>Then you can return broken_strings.   </p>

<p>Edit:</p>

<p>OP mentions that he wants to tokenize algebraic expressions.
So it will have to be done it a different way. </p>

<p>Following is a simple approach.</p>

<pre><code> std::vector&lt;std::string&gt; broken;
 std::string temp;
 for ( int i = 0; i&lt;s.length() ;i++){
     char ch = s[i];
     if (ch == ' ')
         continue;
     else if (ch &gt;= '0' &amp;&amp; ch &lt;='9')
         temp += ch;
     else{
         if (temp.length() != 0)
             broken.push_back(temp);
         temp = """";
         temp += ch;
         broken.push_back(temp);
         temp = """";
     }
 } 
 if (temp.length() != 0)
     broken.push_back(token);
 return broken; 
</code></pre>

<p>You can see the demo of the same here</p>

<p><a href=""https://ideone.com/ePYxNI"" rel=""nofollow noreferrer"">Ideone</a></p>
",7
43753177,43751221,0,"<pre><code>vector&lt;string&gt; tokenise(string s)
{
    vector&lt;string&gt; v;

    string number;

    for(int i = 0; i &lt; s.length(); ++i)
    {
        if((s[i] &gt;= '0') &amp;&amp; (s[i] &lt;= '9'))
        {
            number += string(1, s[i]);
        }
        else if(s[i] == '.')
        {
            number += string(1, s[i]);
        }
        else if((s[i] == '+') || (s[i] == '-') || (s[i] == '*') || (s[i] == '/'))
        {
            if(number.size())
            {
                v.push_back(number);
                number.clear();
            }
            v.push_back(string(1, c));
        }
    }

    if(number.size())
    {
        v.push_back(number);
        number.clear();
    }

    return v;
}
</code></pre>
",1
43966317,43965913,2,"<p>I think it is okay for simple programs. </p>

<blockquote>
  <p>However, you should name a variable using the same care with which you
  name a first-born child.</p>
</blockquote>

<p><em>Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship</em></p>

<p>For instance, nobody prefers to read the declaration <code>int foo(int x, int y, int z, int xx, int bb, int cc .....)</code></p>
",1
43966166,43965913,0,"<p>Whenever there is a variable inside braces <code>{ }</code>, it is local to the scope. Once out of the <code>braces</code> it simply dies.</p>

<p>Now the code that you are asking, </p>

<pre><code>// y is declared in abs and is alive only in the abs
int abs(int y) {
    if (y &lt; 0) {
        return -1 * y;
    }
    return y;
}

// the previous y dies here and is inaccessible.

// a new instance of y is created in randomNum and it's valid till the brace ends
int randomNum(int x, int y) {
    srand((int)time(0));
    return abs(x * rand() % y) + 1;
}
</code></pre>

<p>Now a little thing to try out as pointed out by <code>Jawad Le Wywadi</code></p>

<pre><code>int main()
{
    int a = 0;
    ++a;
    {
        int a = 1;
        a = 42;
        cout &lt;&lt; a;
    }
    cout &lt;&lt; a;
}
</code></pre>

<p>Try it yourself and let us know what do you realize in the comments.</p>
",0
43966482,43966436,2,"<p>The problem with your code is its handling of border condition: it converts <code>12:15:00PM</code>, which is fifteen past noon, to invalid time <code>24:15:00</code>.</p>

<p>Same goes for 12 AM, midnight, which becomes 12 noon after the conversion.</p>
",1
43945433,43945364,0,"<p>This is the correct C++ file:</p>

<pre><code>#include ""stdafx.h""
#include ""Biom.h""

Biom::Biom() {}
Biom::~Biom() {}
</code></pre>

<p>I could have omitted the constructor and destructor and let it be default generated. Then I wouldn't need the .cpp file at all.</p>
",0
43945731,43945714,3,"<p>Nobody uses a namespace as a type in this snippet. <code>std::ios_base::fmtflags</code> is a type, not a namespace, and this <code>using flags = std::ios_base::fmtflags;</code> line just introduces an alias to it.</p>
",0
43945775,43945714,5,"<p>You seem to be confusing <a href=""http://en.cppreference.com/w/cpp/language/type_alias"" rel=""nofollow noreferrer"">type aliasing</a> with <a href=""http://en.cppreference.com/w/cpp/language/namespace#Using-declarations"" rel=""nofollow noreferrer""><code>using</code> declerations</a>. Type aliasing behaves like a <code>typedef</code>, it defines another name for an existing type.
Your example is equivalent to the following :</p>

<pre><code>typedef std::ios_base::fmtflags flags;
flags fl = std::ios_base::dec;
</code></pre>
",2
44234449,44234409,0,"<p>You need to write <code>combinedresistors = 1/((1/r1) + (1/r2) + (1/r3));</code> in some function. Like,</p>

<pre><code>double GetCombinedResistors()
{
 return 1/((1/r1) + (1/r2) + (1/r3));
} 
</code></pre>

<p>And use,</p>

<pre><code>  cout &lt;&lt; ""Your combined Resistance is:"" &lt;&lt; GetCombinedResistors() &lt;&lt; endl;
</code></pre>
",4
44234480,44234409,0,"<p>I'm not a good cpp programmer but you can try with this:</p>

<pre><code>//#include &lt;cmath&gt;
#include ""formula.h""
//using namespace std;


int main()
{
double r1;
double r2;
double r3;
double combinedresistors;
double counter;

cout &lt;&lt; ""Enter your first resistance value:"";
cin &gt;&gt; r1;
cout &lt;&lt; ""Enter your second resistance value:"";
cin &gt;&gt; r2;
cout &lt;&lt; ""Enter your third resistance value:"";
cin &gt;&gt; r3;

if (r1 == 0 || r2 == 0 || r3 == 0){
  cout &lt;&lt; ""ERROR:You can't have your resistance(s) value be zero"";
}
else{
  combinedresistors = 1/((1/r1) + (1/r2) + (1/r3));
  cout &lt;&lt; ""Your combined Resistance is:"" &lt;&lt; combinedresistors &lt;&lt; endl;
}

return 0;
}
</code></pre>
",1
44334211,44334101,3,"<blockquote>
  <p>But when I debug, it warns me that I haven't initialized the element of <code>a</code>. I know that I need to input the data through <code>worker(istream &amp;f)</code></p>
</blockquote>

<p>It's good that you realized the warning is really a problem. It's a warning from a syntactic point of view but it is an error from a semantic point of view.</p>

<p>The <em>I know that</em> part is ill-founded. You realized the need to initialize <code>a.data</code> but your approach to doing it is flawed.</p>

<blockquote>
  <p>but I don't know how to invoke the constructor function to intiallize <code>a.data</code>.</p>
</blockquote>

<p>First of all, you cannot call constructor on already constructed object. Constructors are used only to construct objects, not to be called again on an already constructed object.</p>

<p>Secondly, use a different strategy to initialize the object. Remove the constructor <code>worker(istream&amp;)</code> altogether. Use <code>read</code> on the already constructed object, such as:</p>

<pre><code>int main()
{
    worker a;
    read(std::cin, a);
    std::cout &lt;&lt; a.data &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>Further refinement.</p>

<p>Instead of <code>read</code>, use <code>operator&gt;&gt;</code>.</p>

<pre><code>std::istream&amp; operator&gt;&gt;(std::istream&amp; f, worker&amp; w)
{
   f &gt;&gt; w.data;
   return f;
}
</code></pre>

<p>Then, you can use:</p>

<pre><code>int main()
{
    worker a;
    std::cin &gt;&gt; a;
    std::cout &lt;&lt; a.data &lt;&lt; std::endl;
    return 0;
}
</code></pre>
",4
45754525,45754485,1,"<p>srand must be called once and not in each loop.</p>

<pre><code>void setcolor()
{
    int col = rand() % 4 + 1;
    if (col == 1)
    { cout &lt;&lt; ""white ""; }
    else if (col == 2)
    { cout &lt;&lt; ""brown ""; }
    else if (col == 3)
    { cout &lt;&lt; ""black ""; }
    else if (col == 4)
    { cout &lt;&lt; ""spotted ""; }
}

int main() 
{
    srand(time(NULL));
    for (int i = 0; i &lt;= 5; ++i)
    {
         setcolor();
    }
}
</code></pre>

<p>It works this way because srand initialize a ""global variable"" that is used by rand() function.</p>

<p>time(null) return something like the number of seconds that are elapsed from 1st january 1970. So you are using 5 times the same value because of the initialisation of the ""global variable"".</p>

<p>However, in C++, it is not the right way to use random values.
Please prefer use random header instead (<a href=""http://en.cppreference.com/w/cpp/numeric/random"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/numeric/random</a>) :</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;random&gt;

int main()
{
    std::random_device rd;
    std::map&lt;int, int&gt; hist;
    std::uniform_int_distribution&lt;int&gt; dist(0, 9);
    for (int n = 0; n &lt; 20000; ++n) {
        ++hist[dist(rd)]; // note: demo only: the performance of many 
                          // implementations of random_device degrades sharply
                          // once the entropy pool is exhausted. For practical use
                          // random_device is generally only used to seed 
                          // a PRNG such as mt19937
    }
    for (auto p : hist) {
        std::cout &lt;&lt; p.first &lt;&lt; "" : "" &lt;&lt; std::string(p.second/100, '*') &lt;&lt; '\n';
    }
}
</code></pre>
",2
45754587,45754485,0,"<p>Using <code>time</code> to seed in your case <code>srand(time(NULL));</code> may lead to situation when the value returned by <code>time</code> stays the same on each iteration because of its low precision so random generation restarts from the same spot. So you should call it only once before starting the loop.</p>
",1
46125415,45924578,0,"<p>Thank you for the help. It appears that the problem had to do with the bit count of strings in <em>32-bit</em> vs <em>64-bit</em>. Changing <em>honeyB_libs[]</em> from a string array to a const char* array solved the issue.
honeyB_lib.h</p>

<pre><code>extern const char* honeyB_libs[];
</code></pre>

<p>honeyB_lib.cpp</p>

<pre><code>const char* honeyB_libs[] = { ""libHoneyB.so"", ""libHoneyB3.so"", ""libHoneyB2.so"", """" }
</code></pre>

<p>function.cpp</p>

<pre><code>deque&lt;string&gt; get_array()
{
   deque&lt;string&gt; dst;
   string temp;
   int i =0;

   for(;;)
   {
    if(strlen(honeyB_libs[i]) == 0)
        break;
    else
    {
        temp = honeyB_libs[i];
        dst.push_front(temp);
        i++;
    }
   }

  return dst;
}
</code></pre>

<p>Doing this allows my program to compile and run as <em>64-bit</em> and <em>32-bit</em></p>
",0
44350027,44350012,1,"<p>Just move the <code>#endif</code> to after the last <code>}</code>.</p>
",0
45091086,45090713,0,"<p>Arrays in C++ cannot be assigned, they can just be initialised with a well-defined set of expressions, e.g. with initialization lists.</p>

<p>So the following statements wont't work as they are <em>assignments</em>:</p>

<pre><code>int static_Array[5];
int array2[5];
int *dynamic_Array = new int [5];

static_Array = dynamic_Array;  // error: static_Array is not a pointer, and it is not assignable
static_Array = array2; // error: static_Array is an array and therefore not assignable
static_Array[5] = { 1,2,3,4,5 };  // error
</code></pre>

<p>But the following statement works, because it is an <em>initialisation</em> done at the time of variable definition; it cannot be repeated later (where it would be an illegal assignment then):</p>

<pre><code>int static_Array[5] = { 1,2,3,4,5 };
</code></pre>

<p>When you talk about ""dynamic_Array"", you actually mean a pointer to an integer, which is not an array. It just points to an integer, or to the first of a sequence of integers, but it is not an array by itself. And you may assign a pointer value, but note that this does not ""copy"" any array content, it just sets a pointer to an integer:</p>

<pre><code>int static_Array[5] = { 1,2,3,4,5 };
int *dynamic_Array = new int [5];
dynamic_Array = static_Array;  // OK (apart from leaking memory): lets dynamic_Array point to the first value of static_Array; No copy!

static_Array[0] = 10;
cout &lt;&lt; dymanic_Array[0]; // will print 10.
</code></pre>

<p>Hope it helps.</p>
",0
46080114,46080006,5,"<p>Its a bitwise operator. There's a search term for you!</p>

<p>The &amp; operator provides a mask that ""cancels out"" bits in the first depending if they're set in the second parameter - so assume N is the number 17, that expressed in binary is 00010001, the number 1 in binary is 00000001, so masking the two together will ""blank"" the first set of bits, leaving you with N as 00000001.</p>

<p>Basically that particular if statement drops all except the last bit, which is either 0 or 1, so it is a condition detecting if N is odd or even.</p>
",0
45771502,45771055,0,"<p>may be using <code>scanf(""%d "",&amp;n)</code> to input n helps you solve the problem because <code>scanf()</code> is faster than cin
in order to be able to use it you must include studio or cstudio library</p>

<p>another thing that may work is that you try <code>getchar()</code> method to get the digits of n as characters and you check if each character equals 1 or 0 otherwise the number is not binary</p>

<p>hope this help</p>
",0
45772254,45771055,0,"<p>You don't need to count up to <code>n</code>. All you have to do, is find the largest number with ones and zeros, that when interpreted as decimal, is smaller than n.</p>

<p>To do this, just read the input as string, iterate over the digits, and from the first place you see a digit larger than one, change the rest to <code>'1'</code>.</p>

<p>Then interpret the string as a binary number. Which is basically the number of numbers with only ones and zeros, that are smaller than it.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main() {
    string n; cin &gt;&gt; n;
    for(int i = 0 ; i &lt; n.size() ; i++)
        if(n[i] &gt; '1') {
            for(int j=i ; j&lt;n.size() ; j++)
                n[j] = '1';

            break;
        }

    cout &lt;&lt; stoi(n, nullptr, 2) &lt;&lt; endl;
    return 0;
}
</code></pre>
",1
45286652,45286585,-3,"<p>I think your main problem here is your declaration of the 2d array: </p>

<pre><code>int masyvas[x][y];
</code></pre>

<p>x and y are not known at compile time,  you need to either use dynamic memory allocation, use something like std::vector, or set <code>masyvas</code>s size to something larger than you'll need: </p>

<pre><code>int masyvas[100][100];
</code></pre>

<p>Try that instead.</p>
",6
45286950,45286585,3,"<p>There is a few problems with your code. First, x and y are not initialized before the line:</p>

<pre><code>int masyvas[x][y];  // masyvas is 2D array
</code></pre>

<p>Then, when you read into the array:</p>

<pre><code>D &gt;&gt; masyvas[i][j];
</code></pre>

<p>the indices you use (i and j) range from 1 to x and from 1 to y. But arrays in C/C++ are 0-based, thus i and j should range from 0 to x-1 and 0 to y-1.</p>

<p>I would suggest that instead of loops and arrays, you use the C++ way: containers (vector) and iterators.</p>

<p>For instance, instead of calling ""D >> masyvas[i][j]"" y times, you can simply use </p>

<pre><code>copy_n(istream_iterator&lt;int&gt;(input_data),
       cols,
       back_inserter(row));
</code></pre>

<p>This simply says that ""cols"" integers are read from input_data and then appended to the back of the vector called ""row"".</p>

<p>For output you can use a similar technique: the following line says that the entire ""row"" vector is copied to the output ""cout"", such that between each two elements there is a space:</p>

<pre><code>copy(row.begin(), row.end(),
     ostream_iterator&lt;int&gt;(cout,"" ""));
</code></pre>

<p>Finally, to compute the total of a row, we can use the function ""accumulate"" which does just that:</p>

<pre><code>cout &lt;&lt; accumulate(row.begin(), row.end(), 0) &lt;&lt; ""\n"";
</code></pre>

<p>The complete code is below:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;iterator&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;vector&gt;
int main(int argc, char *argv[])
{
    using namespace std;
    int rows, cols;
    ifstream input_data(""Duomenys.txt"");
    input_data &gt;&gt; rows &gt;&gt; cols;
    for(int i = 0; i &lt; rows; i++)
        {
            vector&lt;int&gt; row;
            copy_n(istream_iterator&lt;int&gt;(input_data),
                         cols,
                         back_inserter(row));
            copy(row.begin(), row.end(),
                     ostream_iterator&lt;int&gt;(cout,"" ""));
            cout &lt;&lt; accumulate(row.begin(), row.end(), 0) &lt;&lt; ""\n"";
        }
    return 0;
}
</code></pre>
",5
45287210,45286585,0,"<p>A few things to note:</p>

<ol>
<li>In your 'printing' for loops, you're cout'ing <code>masyvas[x][j]</code> with an <strong>x</strong>. Shouldn't that be <code>masyvas[i][j]</code> with an <strong>i</strong>?</li>
<li><p>Arrays in C++ start with 0 and go up to <code>arraySize - 1</code> but your for loops start at index 1 and go to <code>arraySize + 1</code>. Suppose I write a for loop like this:</p>

<pre><code>int array[10] = {1, 2, 3, 5, 8, 13, 21, 34, 55, 89};
for (int x = 1; x &lt; 10 + 1; x++) {
    cout &lt;&lt; array[10] &lt;&lt; "" "" &lt;&lt; endl;
}
</code></pre>

<p>We get the first index in an array using 0, not 1. So instead of printing out the sequence of numbers in the array, it's going to start at the 1st index (2) and go until the 11th index (out of range) and crash my program.</p></li>
<li><p>How is your array creation not giving you compiler errors? It does on mine. When you create an int, C++ isn't going to initalize it to 0 so you don't know what could be in it. As an example:</p>

<pre><code>int x;
int y;
cout &lt;&lt; x &lt;&lt; "", "" &lt;&lt; y &lt;&lt; endl;
</code></pre>

<p>This won't compile for me. It tells me that x contains -858993460. Imagine trying to create an array with that as one of the sizes. The two most basic solutions would be <code>vector</code> and dynamic arrays using the <code>new</code> operator.</p></li>
</ol>

<p>Hope this helps.</p>
",0
45703107,45703037,1,"<p>You need to print <code>:</code> for each strength point and fill the remaining with spaces (capacity).  There are several methods.  </p>

<p><strong>Method 1:  The loop</strong>  </p>

<pre><code>cout &lt;&lt; '{';
for (unsigned int i = 0; i &lt; capacity; ++i)
{
  if (i &lt; strength)
  {
    cout &lt;&lt; ':';
  }
  else
  {
    cout &lt;&lt; ' ';
  }
}
</code></pre>

<p><strong>Method 2: String of repeated characters</strong>  </p>

<pre><code>const std::string strength_text(strength, ':');
const std::string filler_text(capacity-strength, ' ');
cout &lt;&lt; '{';
cout &lt;&lt; strength_text &lt;&lt; filler_text;
cout &lt;&lt; '}';
</code></pre>

<p><strong>Method 3: Setting field width</strong>  </p>

<pre><code>const std::string strength_text(strength, ':');
cout &lt;&lt; '{';
cout &lt;&lt; setw(capacity) &lt;&lt; strength_text;
cout &lt;&lt; '}';
</code></pre>

<p>You should research the <code>setw</code> modifier to see if it performs a right justified or left justified fill.  </p>

<p>Other methods involve cursor positioning, which requires an external library.  </p>
",0
45774641,45774614,1,"<p>You need to assign the value back to the index of the string. </p>

<pre><code>if(isupper(str.at(i)))
        str[i] = tolower(str.at(i));
</code></pre>
",3
45766357,45766297,0,"<p>You are assigning a text string to a string variable, then comparing a string variable to an integer.  Your compiler should generate at least some warnings.</p>

<p>Maybe you want this:</p>

<pre><code>constexpr int one = CHAR_MAX;
if (one == 127)
//...
</code></pre>

<p>The <a href=""http://en.cppreference.com/w/cpp/types/climits"" rel=""nofollow noreferrer""><code>CHAR_MAX</code></a> is a predefined constant (identifier/macro).</p>

<p>You could also do this:</p>

<pre><code>if (CHAR_MAX == 127)
{
  //...
</code></pre>
",1
46620039,46619806,0,"<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() {
    int a = 0, b = 0;
    cin &gt;&gt; a;
    cin &gt;&gt; b;
    for (int i = a; i &lt;= b; i++)
        cout &lt;&lt; i &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>EDIT: I removed something as it wasn't true :P Silly me.</p>

<p>Also 'endl' doesn't work with cin :)</p>
",1
46620366,46619806,0,"<pre><code>    #include &lt;iostream&gt;
using namespace std;
int main() {
    int a=0,b=0;
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;endl;
    for(int i=a;i&lt;=b;++i)
    cout&lt;&lt;i&lt;&lt;endl;
    return 0;
}
</code></pre>

<p>First you can't use endl in cin
Second you wrote ++i inside your for loop which will increase value of by i means value of will become 1 from 0.
Therefore the condition will never be true as value of b is 0.</p>

<p><strong>THE CORRECT WAY</strong></p>

<pre><code>    #include &lt;iostream&gt;
using namespace std;
int main() {
    int a=0,b=0;
    cin&gt;&gt;a&gt;&gt;b;
    for(int i=a;i&lt;=b;i++)
    cout&lt;&lt;i&lt;&lt;endl;
    return 0;
}
</code></pre>
",1
46102213,46102180,3,"<p>You didn't declare the <code>arr</code> parameter as an array, it's just a single variable.</p>

<pre><code>template &lt;typename T&gt;void Sort(T arr[], int size);
</code></pre>

<p>or</p>

<pre><code>template &lt;typename T&gt;void Sort(T *arr, int size);
</code></pre>
",0
46102405,46102180,0,"<p>In <code>Sort</code>, <code>temp</code> is not the correct type:</p>

<pre><code>template &lt;typename T&gt;
void Sort(T arr, int size)
{
    for (int i = 0; i &lt; size - 1; i++)
    {
        for (int j = i + 1; j &lt; size; j++)
        {
            if (arr[i] &gt; arr[j])
            {
                T temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
}
</code></pre>

<p>You should use <code>auto</code> instead of <code>T</code>, or create the swap function:</p>

<pre><code>template &lt;typename T&gt;
void swap(T&amp; t1, T&amp; t2)
{
    // Real version would use move assignment instead of copy
    T temp = t1;
    t1 = t2;
    t2 = temp;
}
</code></pre>

<p>And to be more generic, you could take your argument <code>arr</code> by reference (as currently, only usable by pointer, and you even don't use <code>T*</code> as arg). So your code now works also with <code>std::vector</code>, <code>std::array</code> for example.</p>

<pre><code>template &lt;typename T&gt;
void Sort(T&amp; arr, int size)
{
    for (int i = 0; i &lt; size - 1; i++)
    {
        for (int j = i + 1; j &lt; size; j++)
        {
            if (arr[i] &gt; arr[j])
            {
                swap(arr[i], arr[j]);
            }
        }
    }
}
</code></pre>
",6
46128597,46128226,1,"<p>There are a couple of ways you can deal with this. One is to put in a dummy statement that casts the variable to (void).</p>

<pre><code>(void) prev_offset; // this should stop the warning.
</code></pre>

<p>Another is to conditionally include the variable in a similar way to how <code>assert()</code> conditionally includes its check based on whether or not the <code>NDEBUG</code> macro is set.</p>

<pre><code>// When you use ASSERT_CODE() the code only appears in debug builds
// the same as the assert() checks. That code is removed in 
// release builds.

#ifndef NDEBUG
#define ASSERT_CODE(code) code
#else
#define ASSERT_CODE(code)
#endif

// ...


T offset = ps-&gt;first;
ASSERT_CODE(T prev_offset); // give it its own line
bool first = true;

while (1) {
  if (first)
    first = false;
  else
    assert(offset &gt; prev_offset);
  pl = l.find_inc(offset);

  ASSERT_CODE(prev_offset = offset); 

  if (pl == l.m.end())
    break;
  while (ps != s.m.end() &amp;&amp; ps-&gt;first + ps-&gt;second &lt;= pl-&gt;first)
    ++ps;
  if (ps == s.m.end())
    break;
  offset = pl-&gt;first + pl-&gt;second;
  if (offset &lt;= ps-&gt;first) {
    offset = ps-&gt;first;
    continue;
  }
}
</code></pre>
",0
47508861,47505273,0,"<p>You have not mentioned what is the error that you are getting. From what I see, you have a vector that stores pointers to ScoreKeeper class. new operator returns a pointer reference and your code should be changed from</p>

<pre><code>ScoreKeeper Player1 = new ScoreKeeper;
ScoreKeeper Player2 = new ScoreKeeper;
</code></pre>

<p>to</p>

<pre><code>ScoreKeeper* Player1 = new ScoreKeeper;
ScoreKeeper* Player2 = new ScoreKeeper;
</code></pre>

<p>Also when you are reading from the vector use ""->"" instead of ""."" operator.</p>
",0
47566129,47565986,0,"<p>You can use a variable maxComplexRent to keep the track of complexRent.</p>

<pre><code>double maxComplexRent = 0.0;
for (int complex = 1; complex &lt;= numComplex; complex++)
{
    cout &lt;&lt; ""Enter Complex Name "";
    cin &gt;&gt; nameComplex;
    outputFile &lt;&lt; nameComplex &lt;&lt; "" "";

        for (int months = 1; months &lt;= numMonths; months++)
        {
            cout &lt;&lt; ""Enter Rent "" &lt;&lt; months &lt;&lt; "" for "";
            cout &lt;&lt; "" Complex "" &lt;&lt; complex &lt;&lt; "": "";
            cin &gt;&gt; rent;
            totalAllRent = totalAllRent + rent;
            averageRent = totalAllRent / numComplex;
            outputFile &lt;&lt; rent &lt;&lt; endl; //write data to output file 
            currentRentAmount = currentRentAmount + rent;
            cout &lt;&lt; currentRentAmount &lt;&lt; endl;




            }   
    //Here
    maxComplexRent = maxComplexRent&gt;currentRentAmount? maxComplexRent:currentRentAmount;
    currentRentAmount = 0;

    }
</code></pre>
",2
47566188,47565986,0,"<p>First a friendly note; 'Complex number' means something very specific , you are talking about apartment complex numbers. However, when most people read complex number they think x+iy (think imaginary numbers)</p>

<p>Second , the problem you have is one of logic. You want to find the apt complex with the highest rent, but you seem to update the highest rent value in this condition.</p>

<pre><code>if (currentRentAmount &gt; previousRentAmount)
{
    highestComplexRent = currentRentAmount;
}
</code></pre>

<p>Ask yourself why you are doing this , what happens in every iteration of the loop. IF <code>currentRentAmount &gt; previousRentAmount</code> since previousRentAmount is always 0.Effectively, this means, if the value of current rent is greater than 0 highest rent is set to current rent.</p>

<p>What you want here is: 
1. Make sure highestRentAmount is set to 0 outside of the loops.
2. The if check should be <code>if(currentRentAmount &gt; highestComplexRent)</code> (think through why this will work, I can tell you the answer, but just think about it for a second, its much better to arrive at it yourself)</p>

<p>Good luck</p>
",6
47566485,47565986,0,"<p>if statement was wrong able to fix </p>

<pre><code>if (currentRentAmount &gt; highestComplexRent)
        {
            highestComplexRent = currentRentAmount;
        }
</code></pre>
",0
47566226,47565986,0,"<p>Few suggestions here:</p>

<ol>
<li><p>It does not use the correct variable:</p>

<pre><code>if (currentRentAmount &gt; previousRentAmount)
</code></pre></li>
</ol>

<p>should be changed to</p>

<pre><code>    if (currentRentAmount &gt; highestComplexRent)
</code></pre>

<ol start=""2"">
<li><p>This line should be moved out to the outer loop (although it is unused):</p>

<pre><code>averageRent = totalAllRent / numComplex;
</code></pre></li>
<li><p>Remove the unused variables.</p></li>
</ol>
",0
46636191,46635749,0,"<p>For comparing strings, or portions of strings, you want to use the <a href=""http://en.cppreference.com/w/cpp/string/basic_string/compare"" rel=""nofollow noreferrer"">compare</a> method of the STL string class in C++. This allows you to compare one <code>std::string</code> against another or compare it against a substring of another.</p>

<pre><code>  std::string str1 (""blue fruit"");
  std::string str2 (""red fruit"");

  if (str1.compare(6,5,""fruit"") == 0)
    std::cout &lt;&lt; ""still, "" &lt;&lt; str1 &lt;&lt; "" is a fruit\n"";
</code></pre>

<p>The first parameter is a <code>size_t</code> position while the second is the amount of characters you want to compare. You can also simply just put in one parameter, another string, to compare the whole string against each other.</p>

<p><strong>Check for a numerical digit</strong></p>

<p>If your interested in checking if a char is a 0-9 digit for example, use the <a href=""http://en.cppreference.com/w/cpp/string/byte/isdigit"" rel=""nofollow noreferrer"">isdigit</a> method from the C portion of the STL.</p>
",0
46985011,46984971,3,"<p>Change</p>

<pre><code>        swap(s2[i], replacementChar);
</code></pre>

<p>to:</p>

<pre><code>        s2[i] = replacementChar;
</code></pre>

<p><code>swap()</code> exchanges the values of the two variables, so after the first replacement, <code>replacementChar</code> contains the same thing as <code>target</code>, so nothing gets updated.</p>
",1
46988444,46988334,0,"<p>Your constructor never sets <code>integer</code> nor <code>size</code>. You can set them using a member initializer list:</p>

<pre><code>Data::Data(int *arrayint, int size)
    : integers(arrayint), size(size)
{
    for(int i=0; i&lt;size;i++)
    {
        if (i % 2 == 0)
        {
            arrayint[i] = 1;
        }
        else
        {
            arrayint[i] = 0;
        }
    }

}
</code></pre>

<p>Alternatively, you can set the variables in the body of your function. In this instance, I changed the name of the function parameter to be different than the member variable.</p>

<pre><code>Data::Data(int *arrayint, int size_)
{
    integers = arrayInt;
    size = size_;
    for(int i=0; i&lt;size;i++)
    {
        if (i % 2 == 0)
        {
            arrayint[i] = 1;
        }
        else
        {
            arrayint[i] = 0;
        }
    }

}
</code></pre>

<p>Finally, your definition of the <code>!</code> operator doesn't match its use. In the definition, you declare the parameter as <code>const Data&amp;</code>, but in its use, you pass a <code>Data*</code>. Either change the function declaration to <code>Data*</code> or change the use to <code>!*data</code>.</p>
",2
46626236,46626226,5,"<p>""Move the decimal point two places to the left"" is the same operation as ""divide the number by 100.""</p>

<pre><code>markup /= 100;
</code></pre>
",0
47661096,47636606,2,"<p>It's a shame that this question wasn't asked with more effort and detail so that it was taken seriously.  I've always been confused by the appearance and concept of continued fractions, but it's been nice taking the time to think about them and implement one.</p>

<p>This particular one can be done iteratively.  As @wally states, the continued fraction shown in the question does not converge to sqrt(3), but to ~1.36603.  The two top-most coefficients should be 1.  Notice that sqrt(3) ~= 1 + (1/1.36603), and that all the coefficients in the continued fraction alternate.</p>

<p>So, if a loop works from the bottom up until the alternating continued fraction converges then one more calculation after the loop will give us the correct answer.  At each iteration the reciprocal of the current value is added to either 1 or 2.  The initial value can be anything.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
#include &lt;limits&gt;

// Calculate square root of 3 with a continued fraction
int main(void) {
  int iterations = 0;
  double epsilon = 1.0e-12; //error bounds
  double prev = 0.0;
  double curr = 1.0; //initial estimate
  double error = curr - prev;

  // Don't show more precision than we have
  std::cout.precision(std::numeric_limits&lt;double&gt;::digits10);

  // Iterate the continued fraction [1;1,2,1,2...]
  // from the bottom up until it converges with errors
  // less than epsilon.
  while (std::abs(error) &gt; epsilon) {
    prev = curr;
    // Unroll the loop with the repeating pattern here
    curr = 2 + (1/curr);
    curr = 1 + (1/curr);

    iterations++;
    error = curr - prev;
    std::cout &lt;&lt; ""error at iteration "" &lt;&lt; iterations
              &lt;&lt; "" was "" &lt;&lt; error &lt;&lt; std::endl;
  }

  // The actual continued fraction we want to evaluate
  // is [1;1,1,2,1,2,...].
  // The two top-level coefficients are 1, so do
  // another half iteration here. 
  curr = 1 + (1/curr);

  std::cout &lt;&lt; ""sqrt(3) = "" &lt;&lt; curr &lt;&lt; "" after ""
            &lt;&lt; iterations &lt;&lt; "" iterations"" &lt;&lt; std::endl;

  return 0;
}
</code></pre>

<p>This strategy should work for any continued fraction with that ends in a repeating pattern of coefficients.</p>

<p>As for why the original code does not complete, I'll leave that to the author to figure out.  Print statements or a pocket calculator will help.</p>
",0
46623070,46622431,0,"<p>The static storage of the program (where global variables are stored) is there for the life of the program, not of the computer.  </p>

<p>Each process (program) running on a computer gets a defined area of RAM memory from the OS for it's use.  </p>

<p>This memory holds everything needed for the process to run - including the code running, readonly (and const) variables, the stack (where local variables resides), the heap (where dynamically allocated variable resides) and the static variables and some more stuff.  </p>

<p>When the program exits, this memory is freed and is no longer associated to this process, or to any process, until reassigned.  </p>

<p>Save the data to a file (on the hard drive) if you want to use it in two distinct runs. </p>
",3
46639594,46639270,0,"<p>It is not the responsibility of <code>add_cust()</code> to prompt the user for input. It is being passed input parameters from the caller. So, the parameters should be used as-is. The caller should handle prompting the user as needed, and then pass the input values to <code>add_cust()</code>.</p>

<p>And no, the code you have shown won't work anyway. The constructor of the <code>customer</code> class requires 2 input parameters, but you are constructing 2 separate <code>customer</code> objects with 1 input value each.</p>

<p>Use something more like this instead:</p>

<pre><code>void customers::add_cust(int id, string name)
{
    custVector.push_back(customer(id, name));
}
</code></pre>

<p>Then the caller can do this:</p>

<pre><code>customers cust;
...
int id;
string name;
cout &lt;&lt; ""Enter customer ID: "";
cin &gt;&gt; id;
cout &lt;&lt; ""Enter customer Name: "";
cin &gt;&gt; name;
cust.add_cust(id, name);
</code></pre>

<p>Then, to print the entries, simply call the class method you already defined:</p>

<pre><code>cust.printCust();
</code></pre>

<p>Where the implementation may look like this:</p>

<pre><code>void customers::printCust()
{
    for(vector&lt;customer&gt;::iterator iter =  custVector.begin(); iter != custVector.end(); ++iter) {
        cout &lt;&lt; ""id: "" &lt;&lt; iter-&gt;getID() &lt;&lt; "", name: "" &lt;&lt; iter-&gt;getName() &lt;&lt; endl;
    }
}
</code></pre>
",0
46639401,46639270,1,"<p>To add a customer to <code>custVec</code> all you need to do (assuming your constructor for <code>customer</code> is valid) is:</p>

<pre><code>void customers::add_cust(int id, string name)
{
   int id;
   string name; 

   cout &lt;&lt; ""Enter customer ID: "";
   cin &gt;&gt; id;

   cout &lt;&lt; ""Enter customer Name: "";
   cin &gt;&gt; name;
   custVector.push_back(customer(id,name));
}
</code></pre>

<p>To answer your question about printing a customer's info, you can have a global function as you've defined, preferably a friend function (I'll leave that as research for you) such as:</p>

<pre><code>void printCust(const customer&amp; cst)
{
   cout&lt;&lt;cst.getID()&lt;&lt;'\t'&lt;&lt;cst.getName();
}
</code></pre>
",0
46639522,46639270,0,"<p>Your definition for the vector does not match with what you are trying to add to it. Consider the definition:</p>

<p><code>vector&lt;customer&gt; custVector;</code> </p>

<p>Whats being added to it is: </p>

<p><code>custVector.push_back(id);</code> and <code>custVector.push_back(name);</code></p>

<p>Where the <code>id</code> is an <code>int</code>and the <code>name</code> is a <code>string</code> instead of a <code>customer</code> object which you have defined your <code>vector</code> to contain. </p>

<p>To correct this define a constructor in your <code>customer</code> class which initializes a <code>customer</code> object</p>

<pre><code>customer(int id, string name) : customer_id(id), customer_name(name) { }
</code></pre>

<p>In your add function you push the <code>customer</code> objects after getting the input as:</p>

<pre><code>custVector.push_back(customer(id, name));
</code></pre>

<p>Also try getting hold of a good beginner c++ book.</p>
",0
46972096,46971850,0,"<p>If you have a large number and multiply by 10, the number may overflow.  This means that the number that you're trying to store is too big to fit into the memory allocated for that number.  The exact consequence for a signed integer overflowing is called ""undefined behaviour"" meaning that it's up to the compiler to decide how to deal with this.</p>

<p>When you divide by 100, the number you're dividing is now different than the number than you're expecting - thus giving you the wrong result.</p>

<p>This is likely only a problem on debug builds; as the compiler will probably replace the *10/100 to be /10 as part of the optimisation that it will do for a release build.</p>

<p>The other item where you multiply by 1 and then divide by 10 will always be defined however, since the multiplication will leave the number unchanged.</p>
",0
46965373,46965331,2,"<p>There are 2 main problems.</p>

<ol>
<li><p>You are declaring the function <code>calcABCSum()</code> at the top of your file as a function which takes 3 variables, but then when you define it below, it takes no parameters.</p></li>
<li><p>Once you fix the first issue, you are still just declaring a variable <code>x</code> and not assigning it to any value.</p></li>
</ol>

<p>You need to assign your local <code>x</code> variable to the return value of the function you are calling:</p>

<pre><code>double x = calcABCSum(1, 2, 3);
</code></pre>
",2
46966618,46966595,-1,"<p>Ready steps</p>

<ol>
<li>Ready to Print : ""int     (value)""</li>
<li>TestFunc is called.</li>
<li>""parameter a: 3"" is printed.</li>
<li>TestFunc returns value ""3""</li>
<li>Ready to Print : ""int     (value)"" --> Print : ""int      3""</li>
</ol>
",0
46967418,46966595,0,"<p>Where you call ""cout &lt;&lt; ""int\t"" &lt;&lt; TestFunction(3) &lt;&lt; endl;"" it needs to evaluate the function call first, before it can print out ""int\t (returned value)"" The only way it will know what to print out is by running the function. When the function runs, it prints out ""paramater a :"". The three is then returned, and the second cout statement can be performed: (int\t)</p>
",0
47505355,47505282,1,"<p>You cannot obtain mod of float and int objects together. if you need integer mod then</p>

<pre><code>float a = 10.0;
int b = 10;
// parse float to int and get the mod
int mod = b % ((int)a); 
</code></pre>

<p>if you want absolute mod</p>

<pre><code>float a = 10.5;
int b = 100;
int d = b / a;
float mod = b - (a * d);
</code></pre>

<p>Edit as per suggestion:<br>
use <code>fmod</code> function. defined in <code>&lt;math.h&gt;</code>
<a href=""http://www.cplusplus.com/reference/cmath/fmod/"" rel=""nofollow noreferrer"">fmod reference</a></p>
",1
47492281,47492261,1,"<p>I think you should add the code</p>

<pre><code>par[src] = src
</code></pre>

<p>if you don't want to change </p>

<pre><code>for(int p = sink; p != par[p]; p = par[p])
</code></pre>

<p>and I think it's better if you change</p>

<pre><code>p != par[p] 
</code></pre>

<p>to</p>

<pre><code>p != src
</code></pre>

<p>in your for loop.</p>

<p>because It's more clear to understand the code and you don't have to add 'par[src] = src'</p>

<p>Here is the full code if you correct the parts what I said</p>

<pre class=""lang-cpp prettyprint-override""><code>struct MCMF{
    struct edge{
        int to, cap, cost, rev;
    };
    int size, src, sink;
    vector&lt;vector&lt;edge&gt; &gt; G;
    vector&lt;int&gt; dist, par, edgeIdx;
    MCMF(int size, int src, int sink){
        G = vector&lt;vector&lt;edge&gt; &gt;(size);
        par = vector&lt;int&gt;(size);
        edgeIdx = vector&lt;int&gt;(size);
        this-&gt;size = size;
        this-&gt;src = src;
        this-&gt;sink = sink;
    }
    bool spfa(){
        dist = vector&lt;int&gt;(size, inf);
        vector&lt;bool&gt; inQ = vector&lt;bool&gt;(size, false);
        queue&lt;int&gt; q;
        q.push(src);
        inQ[src] = true;
        dist[src] = 0;
        while(!q.empty()){
            int here = q.front();
            q.pop();
            inQ[here] = false;
            for(int i = 0 ; i &lt; (int)G[here].size(); i++){
                auto e = G[here][i];
                if(e.cap &gt; 0 &amp;&amp; dist[here] + e.cost &lt; dist[e.to]) {
                    dist[e.to] = dist[here] + e.cost;
                    par[e.to] = here;
                    edgeIdx[e.to] = i;
                    if(!inQ[e.to]) q.push(e.to), inQ[e.to] = true;
                }
            }
        }
        return dist[sink] != inf;
    }
    pair&lt;int,int&gt; getMCMF(){
        int maxFlow = 0;
        int minCost = 0;
        while(1){
            if(!spfa()) break;
            int minFlow = inf;
            int costSum = 0;
            for(int p = sink; p != src; p = par[p]){
                auto&amp; e = G[par[p]][edgeIdx[p]];
                minFlow = min(minFlow, e.cap);
                costSum += e.cost;
            }
            for(int p = sink; p != src; p = par[p]){
                auto&amp; e = G[par[p]][edgeIdx[p]];
                e.cap -= minFlow;
                G[e.to][e.rev].cap += minFlow;
            }
            maxFlow += minFlow;
            minCost += costSum * minFlow;
        }
        return {maxFlow, minCost};
    }
    void addEdge(int from, int to, int cap, int cost){
        G[from].push_back({to, cap, cost, (int)G[to].size()});
        G[to].push_back({from, 0, -cost, (int)G[from].size()-1});
    }
};
</code></pre>
",0
47499162,47498986,1,"<p><strong>Use <code>char* aux;</code> instead.</strong></p>

<p>When we write <code>char aux[50];</code>, we are immediately allocating memory for ~50 <code>char</code>s. Here you're only swapping pointers <em>to</em> the <code>char</code> arrays (elements in the array of <code>char</code> array, i.e. 2D <code>char</code> array called <code>name</code>), so a <code>char*</code> is what you're looking for.</p>

<p>If you are okay with using the standard library, use <code>std::swap</code> like so: </p>

<pre><code>std::swap(name[i], name[i + 1]);
</code></pre>
",1
47697067,47696861,0,"<p>You cannot achieve this with a getLine, the best way I know of to do this would be to get your line, store it in a string and use the find() function to find your delimiters.</p>

<pre><code>string string; // Your line
string ABC = struct.delimiter; // Delimited
getline(input, string); // Get line from stream - Thx Kevin
string subStr = str.substr(0, str.find(ABC)); // this will get you the first segment
</code></pre>

<p>From here on you can develop your loop to go over the read data and find all segments.</p>
",2
47697108,47696861,0,"<p>If <code>ABC</code> is guaranteed to be a single character in length you can use <code>ABC[0]</code> to get the first character out of the string:</p>

<pre><code>getline(string1, string2, ABC[0]);
</code></pre>

<p>Or just make <code>ABC</code> a <code>char</code> to make that guarantee even more apparent.</p>

<pre><code>char ABC = struct.delimiter; // (assuming struct.delimiter is also a char,
                             //  if not use srtuct.delimiter[0])
getline(string1, string2, ABC);
</code></pre>
",2
47977330,47977284,1,"<p>You need to first resize your new string <code>str1</code>. This is because you are accesing areas of memory outside of the string (you are looking where the string isn't, in a way). The <code>resize</code> makes the string large enough to fit your new string.</p>

<p>Try this:</p>

<pre><code>string str;
str = ""1234"";
string str1;
str1.resize(str.length());  // NEW LINE
for (int i = 0; i &lt; str.length(); ++i) {
    str1[i] = str[i];
}
cout &lt;&lt; str1.length() &lt;&lt; endl;
</code></pre>

<p>But if you just want to copy the string, you can use <code>str1 = str</code></p>
",1
48007047,48006770,0,"<p>As coderedoc was a little short in his comment: <code>^</code> is a bit-wise operator, just as <code>|</code> and <code>&amp;</code>, too. Those operators are applied on every pair of corresponding bits (and for such a pair, XOR as you understood it) within two variables:</p>

<pre><code>unsigned char c1 =                0b11001010;
unsigned char c2 =                0b10101100;
unsigned char c3 = c1 ^ c2; // == 0b01100110
unsigned char c4 = c1 &amp; c2; // == 0b11101110
unsigned char c5 = c1 | c2; // == 0b10001000
</code></pre>
",0
48006998,48006770,1,"<p>Let's see this line :</p>

<pre><code>possible += (n_size[i] ^ n_size[i + 1]) &lt; 0;
</code></pre>

<p>We don't know about <code>n_size</code> but I'll suppose it is an array of <code>n</code> <code>int</code>. So we XOR (bitwise) two consecutive terms of <code>n_size</code>, and determine the sign of the result (by comparing it to 0).</p>

<p>Bitwise-XOR is operating bit per bit, so (<code>ABCD = 1011 ^ 0101</code> &lt;=> <code>A = 1 ^ 0</code> , <code>B = 0 ^ 1</code>, <code>C = 1 ^ 0</code>, <code>D = 1 ^ 1</code>).</p>

<p><code>int</code> are encoded in a certain manner, which allows us to get the sign with the most-significant bit (in the number <code>0bX???????</code>, if X=1 the number is negative, else the number is positive).</p>

<p>So <code>(A ^ B) &lt; 0</code> is equivalent to <code>(A &lt; 0) ^ (B &lt; 0)</code>.</p>

<p>So this line increments <code>possible</code> when two consecutive terms have not the same sign.</p>

<p>Finally, <code>possible</code> counts the number of consecutive terms alterning their sign.</p>

<p>PS : notice that <code>float</code> and <code>double</code> have their sign determined by their most-significant-bit too, so it works the same if <code>n_size</code> is an array of <code>float</code> or <code>double</code>.</p>
",2
48024334,48023547,2,"<p>Besides obvious error with <code>strcat</code> pointed out already, you don't need it as you can populate <code>pal</code> array directly. Also when you iterate backwards, you should start with the last character of the string and not null terminator, like this:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{

    char s[101], pal[101];

    if (std::cin.getline(s, 100))
    {
        int j = 0;
        for (int i = strlen(s) - 1; i &gt;= 0; i--)
            pal[j++] = s[i];

        pal[j] = 0;

        if (strcmp(s, pal) == 0)
            std::cout &lt;&lt; ""corect"";
        else
            std::cout &lt;&lt; ""incorect"";
    }

    return 0;
} 
</code></pre>

<p><strong>And C++ version:</strong></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{

    std::string str;

    if (std::getline(std::cin, str))
        std::cout &lt;&lt; (str == std::string(str.crbegin(), str.crend()) ? ""corect"" : ""incorect"") &lt;&lt; std::endl;

    return 0;
}
</code></pre>
",0
48024351,48023547,2,"<p>As has already been pointed out the reason you are getting the error is because you are passing a <code>char</code> and not a <code>const char*</code> to <code>strcat</code>.</p>

<p>As the question is marked as <code>c++</code> I'll go ahead and show the c++-way of doing this.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main() {
    std::string s, pal;
    std::getline(std::cin, s);

    for (auto it = s.rbegin(), end = s.rend(); it != end; ++it)
        pal.push_back(*it);

    if (s == pal)
        std::cout &lt;&lt; ""correct"" &lt;&lt; std::endl;
    else
        std::cout &lt;&lt; ""incorrect"" &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Prefer std::string to using raw c-style char arrays, and with is comes the use of a <a href=""http://en.cppreference.com/w/cpp/iterator/reverse_iterator"" rel=""nofollow noreferrer"">reverse_iterator</a> in the loop.</p>
",2
48025359,48023547,0,"<p>Just for completeness as the OP was more C wish in style, here is a way of detecting palindromes in C with loops:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int is_palindrone(const char *str)
    {
    const char *first, *last;
    first=last=str;
    while(*last) last++;
    last--;
    while(first &lt; last &amp;&amp; *first==*last) { first++; last--; }
    if(*first==*last) return 1;
    return 0;
    }
</code></pre>
",0
48027746,48027437,2,"<blockquote>
  <p>My question is, why I only get the first bit of stream?</p>
</blockquote>

<p>as it was mentioned in the comments, any further calls after the 1st one of the <code>Debug::operator&lt;&lt;()</code> overload, will go to the overloaded operator of <code>std::stringstream</code> because you return a reference to that one.</p>

<p>What you probably want is a class that wraps a <code>std::ostream</code> interface like follows:</p>

<pre><code>class Debug {
    std::ostream&amp; os_;
public:
    Debug(std::ostream&amp; os) : os_(os) {}
    template&lt;typename T&gt;
    Debug&amp; operator&lt;&lt;(T val) {
       // Intercept whatever you want to intercept here ...
       os_ &lt;&lt; val;
       return *this;
    }
};
</code></pre>

<p>This will ensure that the <code>Debug::operator&lt;&lt;()</code> overload is called repeatedly when the statement</p>

<pre><code>    debug &lt;&lt; ""Hello guys, "" &lt;&lt; ""I can't get here!"" &lt;&lt; str &lt;&lt; ""\n"";
</code></pre>

<p>is going to be executed.</p>

<hr>

<pre><code>int main() {
    Debug debug(std::cout);
    std::string str(""Bad input"");
    debug &lt;&lt; ""Hello guys, "" &lt;&lt; ""I can't get here!"" &lt;&lt; str &lt;&lt; ""\n"";
    return 0;
}
</code></pre>

<p>Outputs:</p>

<pre><code>Hello guys, I can't get here!Bad input
</code></pre>

<p>See the <a href=""http://coliru.stacked-crooked.com/a/baecee3f3710eaa6"" rel=""nofollow noreferrer""><strong>Live Demo</strong></a>.</p>

<hr>

<p>To collect the stuff at an inner stream, and just output the contents at a certain point, you can do it as follows:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

class Debug {
    std::ostringstream os_;
public:
    template&lt;typename T&gt;
    Debug&amp; operator&lt;&lt;(T val) {
       os_ &lt;&lt; val;
       return *this;
    }

    // Overload the operator&lt;&lt; to output the buffered stuff
    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Debug&amp; debug) {
        os &lt;&lt; debug.os_.str();
        return os;
    }
};


int main() {
    Debug debug;
    std::string str(""Bad input"");
    debug &lt;&lt; ""Hello guys, "" &lt;&lt; ""I can't get here!"" &lt;&lt; str &lt;&lt; ""\n"";
    std::cout &lt;&lt; debug;
    return 0;
}
</code></pre>

<p>Another <a href=""http://coliru.stacked-crooked.com/a/86ccf2ba52605ae7"" rel=""nofollow noreferrer"">Live Demo</a>.</p>
",0
40781612,40781495,6,"<p>You can templatize your <code>make_array</code> (similar to <a href=""http://en.cppreference.com/w/cpp/experimental/make_array"" rel=""nofollow noreferrer""><code>make_array</code></a> from Library Fundamentals TS):</p>

<pre><code>template&lt;typename T, typename... Params&gt;
std::array&lt;T, sizeof...(Params)&gt; make_array(Params&amp;&amp;... ps) {
    return { std::forward&lt;Params&gt;(ps)... };
}
</code></pre>

<p>Now, just create your array:</p>

<pre><code>int main() {
    // This works.
    const auto lookup = makeArray&lt;int&gt;(2, 4, 6, 8, 10);
    static_assert(lookup.size() == elementCount, """");


    // This doesn't. :-)
    const auto lookup2 = makeArray&lt;int&gt;(2, 4, 6);
    static_assert(lookup2.size() == elementCount, """"); // error
}
</code></pre>

<p>If you want, you can move the assert to your <code>make_array</code> function (or make a wrapper for it), but then, perhaps a name change would be in order:</p>

<pre><code>template&lt;typename T, typename... Params&gt;
std::array&lt;T, sizeof...(Params)&gt; make_lookup_array(Params&amp;&amp;... ps) {
    static_assert(sizeof...(Params) == elementCount, ""must be equal!"");
    return { std::forward&lt;Params&gt;(ps)... };
}
</code></pre>
",1
40781835,40781495,1,"<p>You can use <strong>variadic templates</strong>:</p>

<pre><code>#include &lt;array&gt;

// Assume this comes from some included file
constexpr size_t elementCount = 5;

template&lt;class first, class ... T&gt;
std::array&lt;first, 1 + sizeof...(T)&gt; makeArray(first e1, T ... rest) {
    static_assert(1 + sizeof...(T) == elementCount, ""Must match elementCount"");
    return {  std::forward&lt;first&gt;(e1), std::forward&lt;T&gt;(rest) ...};
}

int main() {
    // This works.
    const auto lookup = makeArray(2, 4, 6, 8, 10);

    // This doesn't. :-)
    const auto lookup2 = makeArray(2, 4, 6);
}
</code></pre>

<p>You can try it <a href=""http://ideone.com/iHVp6d"" rel=""nofollow noreferrer"">here</a></p>

<p>EDIT:</p>

<p>The use of both <code>class first</code> and <code>class ... T</code> allow the compiler to auto deduce the type of the elements. That is, the type of the first parameter to makeArray defines <code>std::array::value_type</code>.</p>
",1
39325972,39325855,29,"<p><a href=""http://en.cppreference.com/w/cpp/io/basic_filebuf/open""><code>ios_base::in</code> requires the file to exist</a>.</p>

<p>If you provide <strong>only</strong> <code>ios_base::out</code>, only then will the file be created if it doesn't exist.</p>

<pre class=""lang-none prettyprint-override""><code>+--------------------+-------------------------------+-------------------------------+
| openmode           | Action if file already exists | Action if file does not exist |
+--------------------+-------------------------------+-------------------------------+
| in                 | Read from start               | Failure to open               |
+--------------------+-------------------------------+-------------------------------+
| out, out|trunc     | Destroy contents              | Create new                    |
+--------------------+-------------------------------+-------------------------------+
| app, out|app       | Append to file                | Create new                    |
+--------------------+-------------------------------+-------------------------------+
| out|in             | Read from start               | Error                         |
+--------------------+-------------------------------+-------------------------------+
| out|in|trunc       | Destroy contents              | Create new                    |
+--------------------+-------------------------------+-------------------------------+
| out|in|app, in|app | Write to end                  | Create new                    |
+--------------------+-------------------------------+-------------------------------+
</code></pre>

<hr>

<p><strong>PS:</strong></p>

<p>Some basic error handling could also prove useful in understanding what's going on:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

int main()
{
  std::fstream file(""triangle.txt"");
  if (!file) {
    std::cerr &lt;&lt; ""file open failed: "" &lt;&lt; std::strerror(errno) &lt;&lt; ""\n"";
    return 1;
  }
  file &lt;&lt; ""Some text "" &lt;&lt; std::endl;
}
</code></pre>

<p>Output:</p>

<pre class=""lang-none prettyprint-override""><code> C:\temp&gt; mytest.exe
 file open failed: No such file or directory

 C:\temp&gt;
</code></pre>
",0
42647712,42647267,1,"<p>The more acceptable way to achieve this is to derive from <a href=""http://en.cppreference.com/w/cpp/io/basic_filebuf"" rel=""nofollow noreferrer""><code>std::basic_filebuf</code></a> and use it to wrap the original stream buffer.  You would then perform the decryption (and encryption if you want to support writing) of the stream data prior to handing it off to the <code>fstream</code>.</p>

<p>You can access and replace the stream buffer with your own one by calling <a href=""http://en.cppreference.com/w/cpp/io/basic_ios/rdbuf"" rel=""nofollow noreferrer""><code>std::fstream::rdbuf</code></a>. In your case you could open the file, pass the filebuf into your custom one and then replace the stream buffer.</p>

<p>There are a lot of functions in this class, but you should only need to handle a few.  You probably have some extra rules about valid operations, such as random seeks invalidating your decryption state machine, etc...</p>
",3
42534003,42533976,1,"<p>How about:</p>

<pre><code>std::string myStr(myVec.begin(), myVec.end());
</code></pre>

<p>Although this works, I don't understand why you need to use vectors in the first place. Just use <code>std::string</code> from the beginning, and use <code>myStr.append()</code> to add characters or strings.</p>

<p>Here's an example:</p>

<pre><code>std::string myStr = ""abcd"";
myStr.append(1,'e');
myStr.append(std::string(""fghi""));
//now myStr is ""abcdefghi""
</code></pre>
",0
42534343,42533976,1,"<p>In addition to The Quantum Physicist's answer: std::string should behave quite similar as vector does. Even the 'reserve' function is available in the string class, if you intend to use it for efficiency.</p>

<p>Adding the characters is just as easy as it can get:</p>

<pre><code>std::string s;
char c = 's';
s += c;
</code></pre>

<p>You could add the characters directly to your member, and you are fine. But if you want to keep your member clean until the whole string is collected, you still should use a std::string object instead of the vector. You then add the characters to the temporary string and upon completion, you can <strong>swap</strong> the contents then. No copying, just pointer exchange (and some additional data such as capacity and size...).</p>
",3
36366395,36365021,0,"<p>I don't think there's a general way to solve your problem. But in case of the string literal recently I proposed a (not perfect) way of passing it to template class as parameter you can find it <a href=""https://stackoverflow.com/questions/18031818/trying-to-pass-string-literals-as-template-arguments/36273815#36273815"" title=""way of passing string literal as a template argument"">here</a>.</p>

<p>Using this you could create kind of array indexed by the string literal e.g. by specialization:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;functional&gt;

#include ""string_literal.h""

template &lt;class SLiteral&gt;
struct switch_;

template &lt;&gt;
struct switch_&lt;STRING_LITERAL(3, ""abc"")&gt; {
   int do_something() { return 1; }
};

template &lt;&gt;
struct switch_&lt;STRING_LITERAL(12, ""123456789012"")&gt; {
   int do_something() { return [](){ return 5;}(); }
};

template &lt;&gt;
struct switch_&lt;STRING_LITERAL(8, ""blahblah"")&gt; {
   std::function&lt;int()&gt; foo;
   template &lt;class T&gt;
   switch_(T t) {
      foo = t;
   }
   int do_something() { return foo(); }
};

int main() {
   std::cout &lt;&lt; switch_&lt;STRING_LITERAL(3, ""abc"")&gt;().do_something() &lt;&lt; std::endl;
   std::cout &lt;&lt; switch_&lt;STRING_LITERAL(12, ""123456789012"")&gt;().do_something() &lt;&lt; std::endl;
   std::cout &lt;&lt; switch_&lt;STRING_LITERAL(8, ""blahblah"")&gt;([](){return 10;}).do_something() &lt;&lt; std::endl;
}
</code></pre>

<p>output of a program is:</p>

<pre><code>1
5
10
</code></pre>
",2
43192949,43192866,2,"<p>You need to implement <code>operator&lt;&lt;</code> for <code>edge</code> structure e.g.:</p>

<pre><code>struct edge
{
    int a, b;
    float weight;//edge  a-b  has weight
    bool operator() (edge x, edge y)
    {
        x.weight &lt; y.weight;
    }

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const edge&amp; obj);
};


std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const edge&amp; obj)
{
    os &lt;&lt; ""a = "" &lt;&lt; obj.a &lt;&lt; "" b = "" &lt;&lt; obj.b &lt;&lt; "" weight = "" &lt;&lt; obj.weight;
    return os;
}
</code></pre>

<p><strong>EDIT</strong>:</p>

<p>You also use vector not quite as you intended:</p>

<pre><code>vector&lt;edge&gt; myvector(Edge); // creates a vector of 'Edge' elements initialized with default constructor
// ...
myvector.push_back(e); // Adds element instead of intended overwriting
</code></pre>

<p>You should use either:</p>

<pre><code>vector&lt;edge&gt; myvector; // initializes empty vector
</code></pre>

<p>or </p>

<pre><code>myvector.at(i) = e; // overwrites element of the vector
</code></pre>
",11
43193407,43192866,2,"<p>Let's say <code>Edge</code> is 3.  This line:</p>

<pre><code>vector&lt;edge&gt;myvector(Edge);
</code></pre>

<p>already sizes the <code>vector</code> with 3 entries.  </p>

<p>Then in the loop, you are calling <code>push_back</code>, meaning you are adding more entries at the tail end of the <code>vector</code>.  </p>

<pre><code> for (int i = 0; i &lt; Edge; i++)
 {
        cin &gt;&gt; e.a &gt;&gt; e.b &gt;&gt; e.weight;
        myvector.push_back(e); 
 }
</code></pre>

<p>So at the end of all of this, you have <code>6</code> total entries in the vector.  The first 3 entries are all 0, and the ""real data"" was added at the tail end.  </p>

<p>You should either:</p>

<p>1) Start out with an <strong>empty vector</strong>, not with a vector with <code>Edge</code> elements already in it.</p>

<pre><code>vector&lt;edge&gt; myvector;  // an empty vector
for (int i = 0; i &lt; Edge; i++)
{
    cin &gt;&gt; e.a &gt;&gt; e.b &gt;&gt; e.weight;
    myvector.push_back(e); 
}
</code></pre>

<p>Or </p>

<p>2) Size the vector with <code>Edge</code> items, and access each one of the entries in the loop:</p>

<pre><code>vector&lt;edge&gt; myvector(Edge);  // size the vector with Edge number of items

for (int i = 0; i &lt; Edge; i++)
{
    cin &gt;&gt; e.a &gt;&gt; e.b &gt;&gt; e.weight;
    myvector[i] = e; // access the item we want
}
</code></pre>

<hr>

<p>Note that once you have the <code>std::vector</code> the proper size, there is no need to further use variables such as <code>Edge</code> or any other variable you may or would use to denote the number of entries.  The reason is that the <code>std::vector</code> knows its own size by calling <code>std::vector::size()</code>.  </p>

<p>Having extraneous variables to denote the number of entries increases the chances that bugs may appear (the number of entries in the vector may change and you forget to update this ""size"" variable, for example).  Bottom line, always use <code>std::vector::size()</code> to give you the number of entries.</p>
",1
47660106,47659721,0,"<p>So this is a restriction that you can't initialize const variables other than in the constructor so there is one approach in my mind. You can have one overloaded constructor with all the possible variable types as arguments and the last argument being the integer that represent which argument to take care off assuming you are considering one variable at each overload. So you can do something like this. Hope this one helps. You can increase on the number of variables to initialize.</p>

<p>Please note to just pass null to the references not in consideration.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"" data-console=""true"" data-babel=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-js lang-js prettyprint-override""><code>class Obj {
  const typea var1;
  const typeb var2;
  const typec var3;
  const typed var4;

  public Obj(typea * ptr1, typeb * ptr2, typec * ptr3, typed * ptr4, int index) {

    switch (index) {

      case 1:
        var1 = * ptr1;
        break;
      case 2:
        var2 = * ptr2;
        break;
      case 3:
        var3 = * ptr3;
        break;
      case 4:
        var4 = * ptr4;
        break;
    }

  }

}</code></pre>
</div>
</div>
</p>
",1
47660196,47659721,3,"<p>In a comment, you said,</p>

<blockquote>
  <p>Yes that is the structure however const items, references, and class items can't be initialized in the body of constructors or in a non-constructor method.</p>
</blockquote>

<p>A <a href=""http://www.stroustrup.com/C++11FAQ.html#delegating-ctor"" rel=""nofollow noreferrer"">delegating constructor</a> can be used to initialize reference member variables.</p>

<p>Expanding your example code a bit, I can see something like:</p>

<pre><code>class Obj {
   static const AType defaultAType; 
   const AType &amp;aRef;
   static const BType defaultBType; 
   const BType &amp;bRef;
public: 

   // Delegate with default values for both references
   Obj() : Obj(defaultAType, defaultBType) {}

   // Delegate with default value for the B reference
   Obj(AType &amp;aType) : Obj(aType, defaultBType) {}

   // Delegate with default value for the A reference
   Obj(BType &amp;bType) : Obj(defaultAType, bType) {}

   // A constructor that has all the arguments.
   Obj(AType&amp; aType, BType&amp; bType) : aRef(aType), bRef(bType) {}
};
</code></pre>
",2
47660255,47659721,0,"<p>No. Unless you are using C++11, where you can initialize some of them in class definition:</p>

<pre><code>struct B
{
    B(int) {}
    constexpr B(double) {}
};

class A
{
    const B b1 = 1;
    static constexpr B b2 = 2.0;
};
</code></pre>

<p>For const values constructed from constructor input parameters, you need to use <a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""nofollow noreferrer"">initializer list</a>.</p>
",0
40782689,40782387,1,"<p>Assuming the <code>C c();</code> is placed inside main you are right the code would compile. </p>

<p>Since the methods are exactly the same in both base classes they are overriden by the definition in class C.</p>

<p>One pitfall I can think of would be the classic diamond problem. It could occur in case A and B were subclasses of the same Base class where the <code>void f()</code> would be implemented and not overriden afterwards. For example:</p>

<pre><code>class Base
{
  public: void f() {/*do something*/}
};
class A : public Base {};

class B : public Base {};

class C : public A, public B {};
</code></pre>

<p>In this case if you only create the object instance in your code everything works fine until you try to call the method:</p>

<pre><code>C c;
c.f(); // compiler error
</code></pre>

<p>Then you will get an error message about ambiguous call to <code>f</code> member.</p>

<p>But there is a solution for this as well (<em>virtual inheritance</em>)</p>

<p>You can read more about the topic for example <a href=""http://www.programmerinterview.com/index.php/c-cplusplus/diamond-problem/"" rel=""nofollow noreferrer"">here</a>.</p>
",0
40782732,40782387,2,"<p>The <a href=""https://en.wikipedia.org/wiki/Most_vexing_parse"" rel=""nofollow noreferrer"">most vexing parse</a> strikes again (have you turned on your compiler warnings?):</p>

<pre><code>C c();
</code></pre>

<p>is a function declaration therefore no object was constructed. Anyway there would be no ambiguity if you had declared <code>c</code> as</p>

<pre><code>C c;
</code></pre>

<p>since the two pure virtual functions would be overridden by the most derived <code>C::f()</code>.</p>

<p>Ambiguity would arise if you were to write something like</p>

<pre><code>class A
{
  public: void f() {}
};

class B
{
  public: void f() {}
};

class C : public A,B
{
public: 


};

int main() {

    C c;
    c.f(); // Need to call a base one, but which one?

}
</code></pre>

<blockquote>
  <p>error: member 'f' found in multiple base classes of different types</p>
</blockquote>
",0
40782560,40782387,1,"<pre><code>C c();
</code></pre>

<p>is a function declaration, not a creation of object of class <code>C</code>.</p>

<p>And <code>C c;</code> will still compile, because your class C's two virtual functions <code>f</code>, ( inherited from each <code>A</code> and <code>B</code> ). is overridden by single function <code>C::f()</code>.</p>
",0
40774545,40774418,1,"<pre><code>r += r + 1
</code></pre>

<p>is the same as writing</p>

<pre><code>r = r + r + 1
</code></pre>

<p>r is doubling every time.  Interestingly, it's always 1 less than 2^n</p>

<pre><code>r = 0 + 0 + 1 (1)
r = 1 + 1 + 1 (3)
r = 3 + 3 + 1 (7)
r = 7 + 7 + 1 (15)
r = 15 + 15 + 1 (31)
r = 31 + 31 + 1 (63)
r = 63 + 63 + 1 (127)
r = 127 + 127 + 1 (255)
r = 255 + 255 + 1 (511)
r = 511 + 511 + 1 (1023)
r = 1023 + 1023 + 1 (2047)
r = 2047 + 2047 + 1 (4095)
r = 4095 + 4095 + 1 (8191)
</code></pre>

<p>Your program is counting 13 matches.  For yahtzee, you probably want an array that counts matches, otherwise you're doubling up on each die.  For example, if you had </p>

<pre><code>1 2 3 4 1
</code></pre>

<p>It would count the first 1 matching the last die AND the last die matching the first (2 matches).</p>

<p>What would be more sensible is to count how many 1's you have, how many 2s you have, and store in an array</p>

<pre><code>int diceCount[6];
for(int num = 1; num &lt;= 6; num++) {
        for(int w = 0; w &lt; 5; w++) {
          int count = 0;
          if(keptDice[w] == num ) {
            count++;
          }
          diceCount[num-1] = count;
        }
</code></pre>

<p>This way when it's done, if you had two 1's, then diceCount[0] will be 2</p>
",2
40774566,40774418,1,"<p>The point is that in the second for loop yo have tor start from t (int w = t;...) otherwise you would compare each dice with itself which will be naturally equal. Plus use r++ instead of r += r + 1 which is definitely wrong but I think that is just a misspelling. </p>

<pre><code>int r = 0;
cout &lt;&lt; ""first value of R is "" &lt;&lt; r &lt;&lt; endl;
for(int t = 0; t &lt; 5; t++) {
    for(int w = t; w &lt; 5; w++) {
        if(keptDice[t] == keptDice[w] ) {
            r++;
        }
    }
}
cout &lt;&lt; ""Value of R is "" &lt;&lt; r &lt;&lt; endl;
</code></pre>
",0
40775013,40774418,0,"<p>Based on your approach, but generalized to N-of-a-kind:</p>

<pre><code>int N = 3; // N in [1;5]
bool isNOfAKind = false;
for(int t = 0; t &lt; 6-N; t++) { // skip searches with less elements than N
    int r = 0; // r must be reset for each count
    for(int w = t+1; w &lt; 5; w++) { // avoid comparing to self
        if(keptDice[t] == keptDice[w]) {
            r++;
        }
    }
    // found a solution already? then bail out.
    if(r == N) {
        isNOfAKind = true;
        break;
    }
}
cout &lt;&lt; N &lt;&lt; "" of a kind? "" &lt;&lt; isNOfAKind &lt;&lt; endl;
</code></pre>
",0
37832080,37831804,1,"<p>Sadly for you, the compiler in optimising the code for a particular architecture reserves the right to <em>pad</em> out the structure by inserting spaces between members <em>and</em> even at the end of the structure.</p>

<p>Using a bit field does <em>not</em> reduce the size of the <code>struct</code>; you still get the whole of the ""fielded"" type in the <code>struct</code>.</p>

<p>The standard guarantees that the address of the first member of a <code>struct</code> is the same as the address of the <code>struct</code>, <em>unless</em> it's a polymorphic type.</p>

<p>But all is not lost: you can rely on the fact that an <em>array</em> of <code>char</code> <em>will</em> always be contiguous and contain no packing.</p>

<p>If CHAR_BIT is defined as 8 on your system (it <em>probably</em> is), you can model an array of 24 bit types on an array of <code>char</code>. If it's not 8 then even this approach will not work: I'd then suggest resorting to inline assembly.</p>
",3
37832123,37831804,3,"<p>There are two reasons, each of which would be enough by themselves.</p>

<ul>
<li>Presumably the size of <code>INT32</code> is 4 bytes. The size of <code>INT24</code> is also 4 bytes, because it contains a <code>INT32</code> bit field. Since, <code>myStruct</code> contains 3 members of size 4, its size must therefore be at least 12.</li>
<li>Presumably the alignment requirement of <code>INT32</code> is 4. So, even if the size of <code>INT24</code> were 3, the size of <code>myStruct</code> would still have to be 12, because it must have at least the alignment requirement of <code>INT32</code> and therefore the size of <code>myStruct</code> must be padded to the nearest multiple of 4.</li>
</ul>

<blockquote>
  <p>any way or workaround ?</p>
</blockquote>

<p>This is implementation specific, but the following hack may work for some compilers/cpu combinations. See the manual of your compiler for the syntax for similar feature, and the manual for your target cpu whether it supports unaligned memory access. Also do realize that unaligned memory access does have a performance penalty.</p>

<pre><code>#pragma pack(push, 1)
struct INT24
{
 INT32 data : 24;
};
#pragma pack(pop)

#pragma pack(push, 1)
struct myStruct
{
INT32 a;
INT32 b;
INT24 c;
};
#pragma pack(pop)
</code></pre>

<p>Packing a bit field might not work the same in all compilers. Be sure to check how yours behaves.</p>

<p>I think that a standard compliant way would be to store char arrays of sizes 3 and 4, and whenever you need to read or write one of the integer, you'd have to <code>std::memcpy</code> the value. That would be a bit burdensome to implement and possibly also slower than the #pragma pack hack.</p>
",2
38979027,38973687,0,"<p>This is kind of typical case you will need to deal with in network programming, as other comments said, you can't detect if a pointer is deleted or not.</p>

<p>The solution I personally use is shared_ptr, when connection is closed, decreasing the refcount and set the connection status to closed.</p>
",0
45719501,45719407,2,"<p>As a rule, all static const names should be defined in .cpp file if they are <a href=""https://stackoverflow.com/questions/23491781/when-is-a-variable-odr-used-in-c14"">ODR used</a>. Taking a reference to the argument is <code>ODR using</code> them. However, having violated this rule is undefined behavior, and MSVC not reporting an error is just one of the ways undefined behavior can be manifested.</p>

<p>As a practical consideration, you are likely to have the error when function is not inlined, and probably won't see it for the inlined functions. My guess is that inlining works differently with the level of optimization you are using for those compilers.</p>
",3
45719751,45719407,1,"<blockquote>
  <p>¡ì 9.4.2 Static data members [class.static.data]</p>
  
  <ol start=""3"">
  <li><p>If a non-volatile const static data member is of integral or enumeration type, its declaration in the class definition can specify
  a brace-or-equal-initializer [...] The
  member <strong>shall still be defined in a namespace scope if it is odr-used</strong>
  (3.2) in the program and the namespace scope definition shall not
  contain an initializer.</p></li>
  <li><p>[ Note: There shall be <strong>exactly one definition</strong> of a static data member that is odr-used (3.2) in a program; <strong>no diagnostic is required.</strong>
  ¡ªend note ]</p></li>
  </ol>
</blockquote>
",0
39682337,39682309,0,"<p>I'm quite sure this is an error caused by the fact that <code>student.h</code> is included twice in a certain <code>.cpp</code> file. Thus you need to use so-called header guards to make sure the file is only included once in every <code>.cpp</code> file:</p>

<pre><code>#ifndef STUDENT_H
#define STUDENT_H

#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Student {

/* ... */

};

#endif
</code></pre>

<p>The idea behind this is that an <code>#include</code> is a preprocessor directive that results in the argument file being copied into the file where the <code>#include</code> was issued. Hence, if files A and B include <code>Student.h</code>, and file C includes both files A and B, then the declaration of <code>class Student</code> is going to end up duplicated. Hence the error. The above macros make sure that this doesn't happen.</p>

<p>Edit as per the question author's comment:</p>

<p><code>#pragma once</code> is the same as <code>#ifndef .. #define #endif</code> but non-standard .</p>

<p>See <a href=""https://stackoverflow.com/questions/1143936/pragma-once-vs-include-guards"">#pragma once vs include guards?</a> for reference.</p>
",10
36323788,36323728,0,"<p>The same way, but dereference it before returning:</p>

<pre><code>int (&amp;h(int n))[10]
{
    return *g(n);
}
</code></pre>

<p>or (less briefly)</p>

<pre><code>int (&amp;h(int n))[10]
{
    int (*ptr)[10] = (int (*)[10])malloc(sizeof(int) * 10);
    for (int i = 0; i &lt; 10; i++) {
        (*ptr)[i] = n;
    }
    return *ptr;
}
</code></pre>

<p>or more explicity</p>

<pre><code>int (&amp;h(int n))[10]
{
    int (*ptr)[10] = (int (*)[10])malloc(sizeof(int) * 10);
    for (int i = 0; i &lt; 10; i++) {
        (*ptr)[i] = n;
    }
    int&amp; ref = *ptr;
    return ref;
}
</code></pre>
",1
42635467,42635399,3,"<p>You are forced to use the long form to call the operator, and explicitly pass template parameters</p>

<pre><code>int main()
{
    std::stringstream s;
    bar b;
    ::operator&lt;&lt;&lt;1&gt;(s, b);
    return 0;
}
</code></pre>

<h2><a href=""http://melpon.org/wandbox/permlink/RXD3EPsf3od7DRWd"" rel=""nofollow noreferrer"">Demo</a></h2>

<p>The <code>::operator&lt;&lt;&lt;1&gt;(s, b);</code> syntax looks weird, but focus on the <code>::operator&lt;&lt;</code> portion, which is referencing the operator in the global namespace. Since you've written it as a template, and the template parameter (<code>size_t</code>) cannot be inferred from the arguments, you are forced to use an explicit template parameter in the form of <code>&lt;1&gt;</code> (<code>&lt;2&gt;</code>, <code>&lt;3&gt;</code>, etc.)</p>
",5
42635493,42635399,1,"<p>Since your <em>function template</em> has no deducable argument, you will have to explicitly call it with the template argument. Its ugly.</p>

<pre><code>operator &lt;&lt; &lt;4&gt;(s, b);
</code></pre>

<p>Another ugly hack is to use a proxy <em>template-class</em>:</p>

<pre><code>template&lt;std::size_t K&gt;
struct bT{
    bT(bar&amp; bb) : b(bb) {} bar&amp; b;
    static constexpr std::size_t i = K;
};
</code></pre>

<p>Then modify your template <code>operator &lt;&lt;</code> to:</p>

<pre><code>template&lt;size_t i&gt;
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, bT&lt;i&gt; b)
{
    s &lt;&lt; b.b.foo + b.i;
    return s;
}
</code></pre>

<p>And call like:</p>

<pre><code>s &lt;&lt; bT&lt;4&gt;(b);
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/0ab58129f235f9e4"" rel=""nofollow noreferrer"">Demo</a>.. Anyhow we panel beat this, it still ends up being ugly. Save everyone the stress, and use a named function. That will be more legible an intuitive.</p>
",1
37630180,37625294,1,"<p>Look at your <code>for</code> cycle in <code>mergeArrays()</code></p>

<pre><code>for(int s =0 ; s &lt; leftArraySize + rightArraySize; i++)
</code></pre>

<p>You define a cycle variable, <code>s</code>; you test the loop condition against <code>s</code> <strong>but</strong> you increment another variable, <code>i</code>.</p>

<p>Look at the full cycle and you can see that you never modify <code>s</code>.</p>

<p>So the cycle should continue forever.</p>

<p>But I'm surprised that the program doesn't crash, because it could write in <code>mArr[i+j]</code>, with <code>i</code> very high.</p>

<p>p.s.: sorry for my bad English</p>
",0
37635980,37625294,0,"<p>Thanks for your replies everyone,</p>

<p>I made two mistakes. 
First,</p>

<p>for(int s =0 ; s &lt; leftArraySize + rightArraySize; i++)</p>

<p>i++ should be replaced by s++</p>

<p>Secondly,</p>

<p>if(leftArray[i] &lt; rightArray[j]   ||  j ==  rightArraySize + leftArraySize)
should be replaced by 
if(leftArray[i] &lt; rightArray[j]   ||  j ==  rightArraySize)</p>

<p>As pointed out earlier, i++ is causing indefinite loop that crashes the program.</p>

<p>But I am still curious, that why can't reach DEBUG POINT 2 ?</p>

<p>DEBUG POINT 2 in Sort(), comes before we enter indefinite loop in MergeSort(), Shouldn't the program crash after at-least printing DEBUG POINT 2 in output.</p>

<p>Can anyone shed light on that ? </p>
",0
36686719,36686680,5,"<p>Drop this lines from your function:</p>

<pre><code>    default:
        return false;
</code></pre>

<p>They make your function return <code>false</code> on the <em>first</em> non-vowel it encounters.</p>

<p>You only want to return <code>false</code> if you reach the <em>end</em> of the loop and haven't returned <code>true</code> yet.</p>

<pre><code>bool scanStr(string userInp) 
{
    for (int i = 0; i &lt; userInp.size(); i++) 
    {
        switch (userInp[i])
        {
        case 'a':
        case 'A':
        case 'e':
        case 'E':
        case 'i':
        case 'I':
        case 'o':
        case 'O':
        case 'u':
        case 'U':
        case 'y':
        case 'Y':
            return true;
        }
    }

    return false;
}
</code></pre>

<p>A better approach in modern C++ would be:</p>

<pre><code>bool scanStr(const std::string&amp; userInp) 
{
    for (const auto c : userInp) 
    {
        switch (c)
        {
        case 'a':
        case 'A':
        case 'e':
        case 'E':
        case 'i':
        case 'I':
        case 'o':
        case 'O':
        case 'u':
        case 'U':
        case 'y':
        case 'Y':
            return true;
        }
    }

    return false;
}
</code></pre>

<p>But if you don't know what it means, don't worry about it now, your book or tutorial will explain soon enough.</p>
",12
36686730,36686680,1,"<p>Problem was, if any character wasn't vowel, that function imediatelly returned false. Also use <code>const &amp;</code>. <code>const</code> allows you to pass const strings and reference saves some time, because C++ doesn't have to copy whole string.</p>

<pre><code>bool scanStr(const string &amp; userInp) {
    for (int i = 0; i &lt; userInp.size(); i++) {
        switch (userInp[i])
        {
        case 'a':
        case 'A':
        case 'e':
        case 'E':
        case 'i':
        case 'I':
        case 'o':
        case 'O':
        case 'u':
        case 'U':
        case 'y':
        case 'Y':
            return true;
            break;
        }
    }
    return false;
}
</code></pre>
",7
36686977,36686680,13,"<p>I would suggest that you extract the logic of vowel testing into its own function:</p>

<pre><code>bool is_vowel(char x)
{
    switch (x)
    {
    case 'a':
    case 'A':
    case 'e':
    case 'E':
    case 'i':
    case 'I':
    case 'o':
    case 'O':
    case 'u':
    case 'U':
    case 'y':
    case 'Y':
        return true;
    default:
        return false;
    }
}
</code></pre>

<p>Then you can use a standard algorithm instead of a loop:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;string&gt;

bool contains_vowel(const std::string&amp; str)
{
    return std::any_of(str.begin(), str.end(), is_vowel);
}
</code></pre>

<p>(I renamed <code>scanStr</code> to <code>contains_vowel</code> because that name is much more descriptive.)</p>
",3
36687890,36686680,0,"<p>First the compiler will turn the switch case into a lookup table, then <code>auto</code> will be decided as a data-type by the compiler based on the value assigned (in this case it's <code>char</code>).</p>

<p><em>Or just give it to your compiler, it knows how to do it.</em></p>

<pre><code>bool scanStr(string userInp)
{
    for(auto c : userInp)
    {
        switch (c)
        {
            case 'a': case 'A':
            case 'e': case 'E':
            case 'i': case 'I':
            case 'o': case 'O':
            case 'u': case 'U':
            case 'y': case 'Y':

            return true;
        }
    }

    return false;
}
</code></pre>
",0
39669957,39669789,3,"<p>You may create wrapper around <code>std::unique_ptr</code></p>

<pre><code>// To handle your cusstom Destroy
struct DestroyDeleter
{
     void operator(Interface* o) {
         object-&gt;Destroy();
         delete object;
     }
};

using InterfacePtr = std::unique_ptr&lt;Interface, DestroyDeleter&gt;;

// To handle the copy with clone:
class wrapper
{
public:
    explicit wrapper(InterfacePtr o) : data(std::move(o)) {}

    wrapper(const wrapper&amp; rhs) : data(rhs.data-&gt;Clone()) {}
    wrapper(wrapper&amp;&amp; rhs) = default;

    wrapper&amp; operator =(const wrapper&amp; rhs) { data = rhs.data-&gt;Clone(); }
    wrapper&amp; operator =(wrapper&amp;&amp; rhs) = default;

    const Interface* operator -&gt;() const { return data.get(); }
    Interface* operator -&gt;() { return data.get(); }

    const Interface&amp; operator *() const { return data; }
    Interface&amp; operator *() { return *data; }

private:
    InterfacePtr data;
};
</code></pre>
",0
39670006,39669789,0,"<p>One of the reasons for having a <code>unique_ptr</code> and a <code>shared_ptr</code> is that copying and juggling these pointers around is a cheap operation that does not involve copying the underlying object.</p>

<p>And that's why smart pointers do not implement any means for you to install your own <code>operator=</code>. As I understand your question, you want to wedge in a call to your custom <code>Clone()</code> and <code>Destroy()</code> methods, when a smart pointer gets copied.</p>

<p>Well, <code>unique_ptr</code> and <code>shared_ptr</code> implement their own <code>operator=</code> that does the right thing.</p>

<p>For starters whatever is being done by your <code>Destroy()</code> should really be done in your class's destructor. That's what a destructor is for. Then, your <code>clone()</code> method simply needs to clone its own object, and return a new <code>unique_ptr</code>, so, when you already have an existing <code>unique_ptr</code> or a <code>shared_ptr</code>, using it to invoke the <code>clone()</code> method clones the object and returns a smart pointer to the cloned object:</p>

<pre><code>std::unique_ptr&lt;myClass&gt; p;  // Or std::shared_ptr

// p is initialized, populated from there.

std::unique_ptr&lt;myClass&gt; new_p=p-&gt;clone();
</code></pre>

<p>Having a distinct <code>Destroy()</code> method that must be invoked before destroying an object is an invitation to spawn an endless parade of bugs. It's only a matter of time before you forget to call it when destroying a cloned object.</p>

<p>The best way to avoid creating and wasting time with bugs in your code is to make it logically impossible for them to happen. If something needs to be done in order to destroy an object, this needs to be done in the destructor. If something extra needs to be done in order to destroy an object that was cloned from another object, the object needs to have an internal flag that indicates that it's a cloned object, and have its destructor do the right thing, based on that.</p>

<p>Once that's done, it will become logically impossible for your code to screw up, by forgetting to do something to get rid of a cloned object. You can congratulate yourself for saving yourself, in the future, from wasting time searching for a bunch of bugs that will never be created, now. Your future self will thank your past self. Just use smart pointers as they were intended to be used, and have <code>clone()</code> give you a smart pointer right from the start.</p>
",2
43983080,43982903,6,"<h1>No</h1>
<p>You cannot exchange or reset the base class. If it had a reset method of it's own, you could call this, but you cannot call the constructor again.</p>
<p>If you want to do this, you should <a href=""https://en.wikipedia.org/wiki/Composition_over_inheritance"" rel=""noreferrer"">favor composition over inheritance</a>. You can then create a completely new instance of the inner composition class and replace your existing instance.</p>
",0
43983166,43982903,1,"<p>Your current demo isn't hard to implement, but you'll need to modify the parent class:</p>

<pre><code>#include &lt;iostream&gt;

class singleNum
{
public:
    int m_a;
    singleNum(int a)
    {
        std::cout &lt;&lt; ""SETUP"" &lt;&lt; std::endl;
        reset(a);
    }
    ~singleNum()
    {
        std::cout &lt;&lt; ""CLOSEDOWN"" &lt;&lt; std::endl;
    }

    virtual void reset(int b)
    {
        m_a = b;
    }
};


class inheritor : public singleNum
{
public:
    inheritor(int a) : singleNum(a) {}
    void reset(int b) override
    {
        singleNum::reset(b);
    }

};


int main()
{
    inheritor z(5);
    std::cout &lt;&lt; z.m_a &lt;&lt; std::endl;
    z.reset(5);
    return 0;
}
</code></pre>

<p>But this is the closest you will get to ""replacing the base class"". If your case is different than the demo presented and you <em>need</em> to call the base class constructor on an already constructed derived object then no, this is not doable.</p>
",0
34923806,34923757,6,"<p>Simply with</p>

<pre><code>foo(*o);
</code></pre>

<p>That will create a copy by the way.</p>
",1
39381287,39378821,0,"<p>Well, there is <a href=""http://www.boost.org/doc/libs/1_62_0_b1/libs/endian/doc/conversion.html"" rel=""nofollow"">Boost.Endian</a>.</p>

<pre><code>#include &lt;boost/endian/conversion.hpp&gt;

#include &lt;iostream&gt;
#include &lt;cstddef&gt;

int main() {
   std::uint64_t foo = 1;
   std::cout &lt;&lt; boost::endian::endian_reverse(foo);
}
</code></pre>

<p>Output: <code>72057594037927936</code></p>
",0
40992205,40991729,1,"<h2>Layout:</h2>

<p>As said in the text you quoted, the layout depends on both the order of declaration and the access control. All members with the same access control are allocated such that later declared members have a higher within the object. Order of members with different access control is unspecified. Note that this allows for all members to be laid out according to declaration order.</p>

<blockquote>
  <p>Nonstatic data members of a (non-union) class with the same access
  control (Clause 11) are allocated so that later members have higher
  addresses within a class object. The order of allocation of non-static
  data members with different access control is unspecified (Clause 11).</p>
  
  <p><a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf"" rel=""nofollow noreferrer"">N4296</a> ¡ì9.2/13</p>
</blockquote>

<p>.</p>

<h2>Initialization</h2>

<p>Initialisation occurs in order of member delcaration, the order of the member initialisers (what's after the <code>:</code> of the constructor) does not matter:</p>

<blockquote>
  <p>Then, non-static data members are initialized in the order they were
  declared in the class definition (again regardless of the order of the
  mem-initializers).</p>
  
  <p><a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf"" rel=""nofollow noreferrer"">N4296</a> ¡ì12.6.2/13.3</p>
</blockquote>

<p>Access control does not matter.</p>

<h2>Empirical verification</h2>

<pre><code>#include &lt;iostream&gt;
using std::cout;
using std::endl;

struct A
{
    A()
    {
        cout &lt;&lt; ""A"" &lt;&lt; endl;
    }
};

struct B
{
    B()
    {
        cout &lt;&lt; ""B"" &lt;&lt; endl;
    }
};

struct X
{
    A a;
    B b;
    X() : b(), a() {}
};

int main() {
    X x;
    cout &lt;&lt; ""a @ "" &lt;&lt; &amp;(x.a) &lt;&lt; endl;
    cout &lt;&lt; ""b @ "" &lt;&lt; &amp;(x.b) &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>will output (<a href=""http://ideone.com/Y5ibG1"" rel=""nofollow noreferrer"">live on ideone</a>)</p>

<pre><code>A
B
some_address
some_address + 1
</code></pre>

<hr>

<h2>Addressing your edit:</h2>

<pre><code>class Foo
{
public:
     Foo(): a_(1), b_(2) {}
public:
     int a_;
private:
     int b_;
};
</code></pre>

<blockquote>
  <p>As I understand, I cannot be sure that a_ is initialized before b_ is initialized.</p>
</blockquote>

<p>Yes, you can be sure that <code>a_</code> is initialized before <code>b_</code>. This is guaranteed by the standard.</p>

<blockquote>
  <p>But in the quoute above is said, that the order of declaration of a_ (as public) and b_ (as private) is unspecified.</p>
</blockquote>

<p>The quote says that the (relative) layout in memory of <code>a_</code> and <code>b_</code> is unspecified. This has nothing to do with the order of initialization.</p>
",1
40533705,40533624,5,"<pre><code>string divider = arr;
</code></pre>

<p>This <code>std::string</code> gets constructed from <code>arr</code>, which is a <code>char</code> array that gets decayed to a <code>char *</code>. When constructing from a <code>char *</code>, the <code>char *</code> must be a null-terminated string.</p>

<p>Your code fills the entire <code>char</code> array with characters, but fails to append an additional <code>'\0'</code> byte. This results in undefined behavior.</p>
",0
34924465,34924147,3,"<p>You get the error because you pass a void pointer to a function that expects a pointer of another type. Since void pointers are not implicitly convertible to other pointers in c++, trying to do so is an error.</p>

<p>You can explicitly convert a void pointer to any other pointer though. So, if you know what type of object the pointer actually points to, then you'll need to share you knowledge with the compiler by casting to the correct pointer type with <code>static_cast</code>. </p>
",0
34924381,34924147,4,"<p>As mentioned in the comment, you need to typecast <code>void*</code> parameter to the desired type (<code>FilterAuthenticate*</code> in your case) before passing it to <code>Authenticate(....)</code>.</p>

<p>Do this:</p>

<pre><code>return Authenticate( context, static_cast&lt;FilterAuthenticate*&gt;(eventData) );
</code></pre>
",5
34924388,34924147,2,"<p>you can call it like. </p>

<pre><code>   DLLEXPORT int HttpFilterProc(FilterContext* context, unsigned int eventType, void* eventData) {
        switch (eventType) {
        case kFilterAuthUser:
            return Authenticate(context, (FilterAuthenticate *)eventData);
        default:
            return kFilterNotHandled;
        }
    }
</code></pre>

<p>You have to cast the <code>void * data</code> to <code>FilterAuthenticate *</code>.</p>
",0
43933091,20299153,0,"<p>Whenever you return a local object of a function, the compiler tends to keep and redirect the local object to the place you return(so the local object won't be deleted and compiler need not to create another object to copy the detail of the local object.)
After the statement finishes(;),the local object is then deleted. 
On the other hand,if you return a formal parameter,compiler will copy the corresponding argument(with copy constructor),then return the clone of the argument.</p>
",0
34924134,34923991,3,"<p>Just because operator precendence, you are casting result of <code>f</code> function to <code>A*</code>, instead of cast <code>this</code> to <code>A*</code> and it's actually better to use <code>static_cast</code>.</p>

<pre><code>MyT f() {return static_cast&lt;A*&gt;(this)-&gt;f&lt;MyT&gt;();}
</code></pre>

<p>this will work. And also you have name hiding, you just do this:</p>

<pre><code>struct B : A {
    using MyT = int;
    using A::f;
    MyT f() {return this-&gt;f&lt;MyT&gt;();}
};
</code></pre>
",2
38096223,38095990,1,"<p>The only way of doing it without breaking strict aliasing and being well-defined is to copy from the character array into the correct array of the union.</p>

<p>Perhaps something like</p>

<pre><code>DATA data;
if (std::is_signed&lt;char&gt;::value)
{
    std::copy_n(one, 32, data.iByte);
}
else
{
    std::copy_n(one, 32, data.byte);
}
</code></pre>

<p>And no it's not going to be ""slow"", unless you do this thousands of time per second. Measure and profile first, don't fall into the trap of premature optimization.</p>
",0
45107929,45107657,-2,"<p>Well returned type should always be <code>X&amp;</code>. Reasoning is - suppose you have two X a, b ¨¤nd you have one function.<br>
void getdata().</p>

<p>You can call (a+b).getdata(). But if return type would be <code>const X&amp;</code>, it couldn't be possible. Now suppose <code>getdata()</code> is <code>const</code>. Then still you can call (a+b).getdata. 
     So having <code>X&amp;</code> instead of <code>const X&amp;</code> gives you liberty to call <code>const</code> and non const both functions.</p>
",0
39638791,39638730,1,"<p><code>BlkType</code> isn't a member function, it's a type, possibly an enum or struct if not an inner class.</p>

<p>The <code>BaseSetAssoc::</code> is needed to access such ""inner"" types (defined within a class, <em>i.e.</em> <code>BaseSetAssoc</code>).</p>

<p>So <code>BaseSetAssoc::BlkType*</code> is just a <code>BaseSetAssoc::BlkType</code> pointer.</p>
",0
39638846,39638730,0,"<p>It's not ""following"", it's ""preceding"". As the comments have said: it means that it is returning a <em>pointer</em> to <code>BaseSetAssoc::BlkType</code>, rather than a whole <code>BaseSetAssoc::BlkType</code>.</p>

<p>What does this mean? It means mostly that the pointer can be <code>NULL</code>, or non-existent. Before using the result of this function, it is almost <em>mandatory</em> that you check if it is <code>NULL</code> first.</p>
",10
36687978,19005485,0,"<pre><code>Q. Does the value of arrayB get copied over to arrayA? 
Ans. NO
</code></pre>

<p>Or</p>

<pre><code>Q. does arrayA become a pointer to arrayB?
Ans YES.
</code></pre>

<p>But the memory chunk which you allocated using new is lost. As no one is having the address which was starting point of that chunk.</p>

<p>This is vindicated by this program :</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

const int MAX=4;
int main(){
   int* arrayA = new int[MAX];
   for(int i=0;i&lt;MAX;i++){  arrayA[i]=i;    }
   int arrayB[MAX] = {10,20,30,40};
   arrayA = arrayB;
   for(int i=0; i&lt;MAX;i++){ cout&lt;&lt;"" a[""&lt;&lt;i&lt;&lt;""] = ""&lt;&lt;arrayA[i]&lt;&lt;endl;    }
   return 0;
}
</code></pre>

<p>The output of this code is :</p>

<pre><code> a[0] = 10
 a[1] = 20
 a[2] = 30
 a[3] = 40
</code></pre>

<p>on </p>

<blockquote>
  <p>g++ (Ubuntu 4.8.4-2ubuntu1~14.04) 4.8.4</p>
</blockquote>

<p>which is true in general as well.</p>

<p>visualization of this is somewhat like this</p>

<pre><code>arrayA-&gt; [0][1][2][3]
arrayB-&gt; [10][20][30][40]
</code></pre>

<p>Intially arrayA has address of [0] ( + sum extra memory on the negative indexes for size used by compiler to do the de-alloctation ).</p>

<p>after<br>
     arrayA=arrayB;</p>

<p>arrayA has address of [10];</p>

<p>suppose you call delete on arrayA what shall happen ??</p>

<pre><code>*** Error in `./a.out': double free or corruption (out): 0x00007fff561281d0 ***
</code></pre>

<p>This is evident from the following code also</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

const int MAX=4;
int main(){
    int* arrayA = new int[MAX*2];
    for(int i=0;i&lt;MAX;i++){ arrayA[i]=i;    }
    int* arrayC = new int[MAX];
    int j=0;
    for(int i=MAX*100;i&gt;=0;i-=10,j++){  arrayC[j]=i;    }
    arrayA = arrayC;
    for(int i=0; i&lt;MAX;i++){    cout&lt;&lt;"" a[""&lt;&lt;i&lt;&lt;""] = ""&lt;&lt;arrayA[i]&lt;&lt;endl;    }

    delete[] arrayA;
return 0;
}
</code></pre>

<p>The out put is : </p>

<pre><code> a[0] = 400
 a[1] = 390
 a[2] = 380
 a[3] = 370
*** Error in `./a.out': free(): invalid next size (fast): 0x0000000002028040 ***
Aborted (core dumped)
</code></pre>

<p>Just pay attention to : </p>

<blockquote>
  <p>""invalid next size""</p>
</blockquote>

<p>This clearly says about the size value written before the arrayA in the negative indexes.</p>
",0
35283518,35280362,0,"<p>Here is an example which illustrates how to go about doing this.
Using the pow function and calculating the factorial at each iteration is very inefficient -- these can often be maintained as running values which are updated alongside the sum during each iteration.</p>

<p>In this case, each iteration's addend is the product of two factors: a power of x and a (reciprocal) factorial.  To get from one iteration's power factor to the next iteration's, just multiply by x*x.  To get from one iteration's factorial factor to the next iteration's, just multiply by ((2*n+1) + 1) * ((2*n+1) + 2), before incrementing n (the iteration number).</p>

<p>And because these two factors are updated multiplicatively, they do not need to exist as separate running values, they can exists as a single running product.  This also helps avoid precision problems -- both the power factor and the factorial can become large very quickly, but the ratio of their values goes to zero relatively gradually and is well-behaved as a running value.</p>

<p>So this example maintains these running values, updated at each iteration:</p>

<ul>
<li>""sum"" (of course)</li>
<li>""prod"", the ratio: pow(x, 2n+1) / factorial 2n+1</li>
<li>""tnp1"", the value of 2*n+1 (used in the factorial update)</li>
</ul>

<p>The running update value, ""prod"" is negated every iteration in order to to factor in the (-1)^n.</p>

<p>I also included the function ""XlatedSine"".  When x is too far away from zero, the sum requires more iterations for an accurate result, which takes longer to run and also can require more precision than our floating-point values can provide.  When the magnitude of x goes beyond PI, ""XlatedSine"" finds another x, close to zero, with an equivalent value for sin(x), then uses this shifted x in a call to MaclaurinSine. </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

// Importing cmath seemed wrong LOL, so define Abs and PI
static double Abs(double x) { return x &lt; 0 ? -x : x; }
const double PI = 3.14159265358979323846;

// Taylor series about x==0 for sin(x):
//
// Sum(n=[0...oo]) { ((-1)^n) * (x^(2*n+1)) / (2*n + 1)! }
//

double MaclaurinSine(double x) {
    const double xsq = x*x;        // cached constant x squared
    int    tnp1      = 3;          // 2*n+1                      | n==1
    double prod      = xsq*x / 6;  // pow(x, 2*n+1) / (2*n+1)!   | n==1
    double sum       = x;          // sum after n==0

    for(;;) {
        prod = -prod;
        sum += prod;

        static const double MinUpdate = 0.00001; // try zero -- the factorial will always dominate the power of x, eventually

        if(Abs(prod) &lt;= MinUpdate) {
            return sum;
        }

        // Update the two factors in prod
        prod *= xsq;                      // add 2 to the power factor's exponent
        prod /= (tnp1 + 1) * (tnp1 + 2);  // update the factorial factor by two iterations
        tnp1 += 2;
    }
}

// XlatedSine translates x to an angle close to zero which will produce the equivalent result.
double XlatedSine(double x) {
    if(Abs(x) &gt;= PI) {
        // Use int casting to do an fmod PI (but symmetric about zero).
        // Keep in mind that a really big x could overflow the int,
        // however such a large double value will have lost so much precision
        // at a sub-PI-sized scale that doing this in a legit fashion 
        // would also disappoint.
        const int p = static_cast&lt;int&gt;(x / PI);
        x -= PI * p;
        if(p % 2) {
            x = -x;
        }
    }
    return MaclaurinSine(x);
}

double DegreesToRadians(double angle_deg) {
    return PI / 180 * angle_deg;
}

int main() {
    std::cout&lt;&lt;""Angle\tSine\n"" &lt;&lt; std::setprecision(12);
    for(int i = 0; i&lt;=360; i+=15) {
        std::cout &lt;&lt; i &lt;&lt; ""\t"" &lt;&lt; MaclaurinSine(DegreesToRadians(i)) &lt;&lt; ""\n"";
        //std::cout &lt;&lt; i &lt;&lt; ""\t"" &lt;&lt; XlatedSine(DegreesToRadians(i)) &lt;&lt; ""\n"";
    }
}
</code></pre>
",0
37902233,21769331,1,"<p>This is what I did in this example.</p>

<ol>
<li><p>First I thought to create a function like printA(), printB() just described in the question details. But I realized the same problem. Also, it would mean that we need to create more than 26 such functions for each of the letters in alphabet and symbols. So, didn't use this approach.</p></li>
<li><p>I considered that the letter would be of 5x5 size. We need something what dot matrix printer does. It prints 1st line of dots of each letter in the string and then second line of dots of next and so on. Instead of dots, the letter we are printing needs the same symbol. For example if we are printing H, the dots will be 'H'.</p></li>
<li><p>So, how to do this in minimum lines of code and less complexity? 
I decided to create bitflags for rows. Considering that there are 5 dots in a row, there will be 32 combinations possible. Like - 10000, 11000, 11100 etc.
While implementing that, I came to know that we don't need that many to define letters in alphabet. Something like this - </p>

<p><code>const unsigned char EOne  = 0x1F;       // 000 11111
const unsigned char BOne  = 0x1E;       // 000 11110</code></p></li>
</ol>

<p>I gave intuitive names to the bitFlags to know where they belong in the letter.
Here is nice information about bitflags - <a href=""http://www.learncpp.com/cpp-tutorial/3-8a-bit-flags-and-bit-masks/"" rel=""nofollow"">http://www.learncpp.com/cpp-tutorial/3-8a-bit-flags-and-bit-masks/</a></p>

<ol start=""4"">
<li><p>Next step is to create the design for each letter in alphabet. Like - </p>

<p><code>const unsigned char A[5] = {AOne, ATwo, EOne, AFiv, AFiv};
const unsigned char B[5] = {BOne, AFiv, BOne, AFiv, BOne};
const unsigned char J[5] = {~EThr, ~BOne, ~BOne, AFiv, ~AFiv};</code></p></li>
</ol>

<p>So, this formed the design of letters A, B, C.. Z.</p>

<ol start=""5"">
<li><p>In the next step, a map can be created between letters in alphabet and their design.</p></li>
<li><p>When the user enters string to print, in a for loop of 5 iterations, you can take - 0th letter: 0th bitflag in its design, 1st letter: 1st bitflag in its design.. nth letter: 1st bitflag in its design.
Then again, 0th letter: 1st bitflag, 1st letter: 1st bitflag, nth letter: 1st bitflag.. until you print all the 5 rows.</p></li>
<li><p>What to do with the bitflag? I used std::bitset and tested each bit so that to print or leave blank space. lineBits is the bitflag for particular letter's design row.</p>

<p>std::bitset&lt;8> bits(lineBits);</p>

<pre><code>// Since we have only 5x5 letter, we start with leftmost bit (4th) to rightmost (0th)
for(int bitpos = 4; bitpos &gt;= 0; bitpos--)
{
    if(bits.test(bitpos))
    {
        cout &lt;&lt; letter;
        outFile &lt;&lt; letter; // In file.
    }
    else
    {
        cout &lt;&lt; "" "";
        outFile &lt;&lt; "" ""; // In file.
    }
}
</code></pre></li>
</ol>

<p>This way, with reduced lines of code, I could print any string. Since, I used map, it was easy to print the symbol of the letter which was getting printed.</p>

<pre><code>FFFFF  RRRR   EEEEE  EEEEE  ZZZZZ  Y   Y  
F      R   R  E      E          Z   Y Y   
FFF    RRRR   EEE    EEE      Z      Y    
F      R R    E      E      Z        Y    
F      R  RR  EEEEE  EEEEE  ZZZZZ    Y   
</code></pre>

<p>Takes a while to design all the letters though. Let me know how this code can be improved.</p>
",0
40747653,40747504,0,"<p>I see 2 simple ways to implement this:</p>

<ul>- Make print() a member function of posX class.</ul>

<ul>- Specialize print() function in entity class. </ul>

<pre><code>    #include &lt;iostream&gt;

    class pos2d
    {
        float x, y;
    public:
        float getx() const { return x; }
        float gety() const { return y; }
        void print() const
        {
            std::cout &lt;&lt; ""Object is of type and has coordinates as ("" &lt;&lt; getx() &lt;&lt; "", "" &lt;&lt; gety() &lt;&lt; "")\n\n"";
        }
    };

    class pos3d
    {
        float x, y, z;
    public:
        float getx() const { return x; }
        float gety() const { return y; }
        float getz() const { return z; }
        void print() const
        {
            std::cout &lt;&lt; ""Object is of type  and has coordinates as ("" &lt;&lt; getx() &lt;&lt; "", "" &lt;&lt; gety() &lt;&lt; "", "" &lt;&lt; getz() &lt;&lt; "")\n\n"";
        }
    };

    template &lt;class P&gt;
    class entity
    {
        P position;
    public:
        void print() const { position.print(); }
        void print_specialized() const;
    };

    template &lt;&gt;
    void entity&lt;pos3d&gt;::print_specialized() const {
        std::cout &lt;&lt; ""Object is of type  and has coordinates as ("" &lt;&lt; position.getx() &lt;&lt; "", "" &lt;&lt; position.gety() &lt;&lt; "", "" &lt;&lt; position.getz() &lt;&lt; "")\n\n"";
    }

    template &lt;&gt;
    void entity&lt;pos2d&gt;::print_specialized() const  {
        std::cout &lt;&lt; ""Object is of type and has coordinates as ("" &lt;&lt; position.getx() &lt;&lt; "", "" &lt;&lt; position.gety() &lt;&lt; "")\n\n"";
    }


    int main() {
        entity&lt;pos2d&gt; e;
        e.print();
        e.print_specialized();
        entity&lt;pos3d&gt; e2;
        e2.print();
        e2.print_specialized();
        return 0;
    }
</code></pre>
",0
40747751,40747504,0,"<p>The problem is if you pass <code>pos2d</code> as template parameter the line </p>

<pre><code>cout &lt;&lt; ""Object is of type "" &lt;&lt; type &lt;&lt; "" and has coordinates as ("" &lt;&lt; position.getx() &lt;&lt; "", "" &lt;&lt; position.gety() &lt;&lt; "", "" &lt;&lt; position.getz() &lt;&lt; "")\n\n"";
</code></pre>

<p>is still instantiated (<code>if</code> is done at runtime), the function cannot be resolved.</p>

<p>The usual way is to use specializations (<code>Type</code> parameter can be omitted):</p>

<pre><code>template&lt;class P&gt;
class entity
{
    P position;
public:
    void print() const;
};

template&lt;&gt;
void entity&lt;pos3d&gt;::print() const
{
    cout &lt;&lt; ""Object is of type pos3d and has coordinates as ("" 
         &lt;&lt; position.getx() &lt;&lt; "", "" &lt;&lt; position.gety() &lt;&lt; "", "" &lt;&lt; position.getz() &lt;&lt; "")\n\n"";
}        

template&lt;&gt;
void entity&lt;pos2d&gt;::print() const
{
        cout &lt;&lt; ""Object is of type pos2d and has coordinates as ("" 
             &lt;&lt; position.getx() &lt;&lt; "", "" &lt;&lt; position.gety() &lt;&lt; "")\n\n"";
}
</code></pre>
",0
37963903,37963848,3,"<p>It's a compiler bug: <code>sub(std::string(""a""));</code> is an adequate workaround. (Binding an anonymous temporary to a <code>const</code> reference is legal in C++.)</p>

<p>MSVC2013 compiles the statement</p>

<pre><code>std::function&lt;std::string()&gt; foo(""a"");
</code></pre>

<p>Showing that <code>""a""</code> is a valid constructor argument for that type. (It appears to be using, in error, the constructor <code>function( std::nullptr_t )</code>).</p>

<p>Reference: <a href=""http://en.cppreference.com/w/cpp/utility/functional/function/function"" rel=""nofollow"">http://en.cppreference.com/w/cpp/utility/functional/function/function</a></p>
",12
40748920,40748855,0,"<p>You cannot give a class the name of a specialized template:</p>

<pre><code>template &lt;&gt;
class store&lt;int&gt;
</code></pre>

<p>what you can do is give it a concrete typename:</p>

<pre><code>class store_int : public store&lt;int&gt;
</code></pre>

<p>or use a <code>typedef</code> or <code>using</code> statement</p>

<pre><code>typdef store&lt;int&gt; store_int;

using store_int = store&lt;int&gt;;
</code></pre>
",0
40749304,40748855,2,"<p>You can maybe do something like this:</p>

<pre><code>template &lt;typename T&gt;
class store_impl
{
  public:
    store_impl(T value) : value(value) {}
  private:
    T value;
}

// default class accepting any type
// provides the default methods
template &lt;typename T&gt;
class store: public store_impl&lt;T&gt;
{
public:
    store(T value) : store_impl(value) {}
}

// specialization for int with extra methods
template &lt;&gt;
class store&lt;int&gt;: public store_impl&lt;int&gt;
{
  public:
    store(int value) : store_impl&lt;int&gt;(value)
    {}
    void my_additional_int_method();
}
</code></pre>
",2
46089342,24776262,0,"<p>This works for me.</p>

<pre><code>void pause()
{
    cin.clear();
    cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');
    std::string dummy;
    std::cout &lt;&lt; ""Press any key to continue . . ."";
    std::getline(std::cin, dummy);
}
</code></pre>
",0
46963412,46963292,1,"<p>First of all, turning on optimization might get you what you want with the first syntax. Without it, here's what you asked the compiler to do:</p>

<ol>
<li>Create a temporary object of type <code>VeryLargeObject</code>.</li>
<li>Assign that into a global variable called <code>x</code>.</li>
</ol>

<p>Since temporary objects need storage, the compiler allocates them on the stack. What the compiler is doing is, literally, what you asked the compiler to do.</p>

<p>The compiler may, if optimizations are turned on, understand that what the sequence is and save the copy. This requires that the compiler can positively prove to itself that the old value of <code>x</code> will not get in the way in any way. Since you admit that the initialization is quite complex, you can forgive the compiler if it did not manage to do so.</p>

<p>You have two options. You can either create an in-place initialization function and call that instead of the constructor, or you can use placement new, like you did.</p>

<p>The danger with placement new, as you used it, is that it replaces the old value of <code>x</code> without properly destructing it. It simply assumes that <code>x</code> is uninitialized. If that's okay for your use, then go ahead and use it. The compiler, for its part, is not allowed to assume that.</p>
",2
36229817,36229714,3,"<p>It is clearly defined that within one compilation unit the order is well defined and it follows declaration order. The problem appears across different units which is not a case here so the code is totally fine.</p>
",0
36229819,36229714,3,"<p>If they are all in the same compilation unit, then it's fine (if you order them correctly). But if they're not, then it's undefined behavior, because of the initialization order. You could however declare <code>center</code> as <code>constexpr</code> instead of <code>const</code>, then <code>center</code> is known at compile time which should be ok, but then <code>CalculateCenter()</code> would also need to be a <code>constexpr</code>, which is maybe not possible in your case.</p>
",0
36230077,36229714,2,"<p>As the previous answer said, in the same translation unit there is no problem. The order is preserved.</p>

<p>If the two static variables are not in the same translation unit you should use function instead as follow:</p>

<pre><code>//somewhere in a class X
static const Point&amp; center() { const static Point _center = CalculateCenter(); return _center; }

//somewhere in a class Y
static Point&amp; currentPoint() { static Point _current_point = X::center(); return _current_point; }
</code></pre>

<p>Then when you need the variables you use the function accessors <code>X::center()</code> or <code>Y::currentPoint()</code>.</p>
",0
46952376,24734102,1,"<p>You may use abs() function for this issue.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;

int main()
{
   double input;
   scanf(""%lf"",&amp;input);

   int absulate = abs(input);
   printf( (input==absulate)? ""It is integer\n"" : ""It is float"");

   return 0;
}
</code></pre>
",1
44688671,31736361,0,"<p>I had this error on VS2017 after upgrading from VS2015. I tried a clean + reinstall and it did not fix the error. The problem that I found was two-fold:</p>

<ol>
<li>$(VC_IncludePath);$(WindowsSDK_IncludePath); was not in the default include path.</li>
<li>$(VC_IncludePath);$(WindowsSDK_IncludePath); was actually EXCLUDED in the default properties (how did this happen?!)</li>
</ol>

<p>To fix for new projects:
Manually edit the following files:
%LOCALAPPDATA%\Microsoft\MSBuild\v4.0\Microsoft.Cpp.Win32.user.props
%LOCALAPPDATA%\Microsoft\MSBuild\v4.0\Microsoft.Cpp.x64.user.props</p>

<p>Make sure that $(VC_IncludePath);$(WindowsSDK_IncludePath); is in the IncludePath and NOT in the ExcludePath.</p>

<p>To fix for old projects (that don't just inherit from the above files):
Manually edit your project properties in the Solution Explorer and make sure that $(VC_IncludePath);$(WindowsSDK_IncludePath); is in the IncludePath and NOT in the ExcludePath.</p>
",0
38203213,31736361,-1,"<p>Installing Visual Studio 2015 Update 3 solves this issue, both for new projects and for existing projects created before the update.</p>

<p><a href=""https://www.visualstudio.com/news/releasenotes/vs2015-update3-vs"" rel=""nofollow"">https://www.visualstudio.com/news/releasenotes/vs2015-update3-vs</a></p>
",0
37827995,31736361,0,"<p>I faced the same issue , it got resolved when I ran <strong>vcvarsall.bat</strong> which is present at <strong>C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC</strong></p>
",0
41687856,41687772,4,"<p>The usual thinking on which to choose is: it depends on how often you expect it to fail.</p>

<ul>
<li><p>If you expect it to fail often, post-checks are better since the check will likely be cheaper than handling an exception. </p></li>
<li><p>If you expect failure to be rarer, exceptions may be a better choice since then you're not wasting resources constantly checking what you know is probably correct. Use <strong>exceptions</strong> to handle <strong>exceptional</strong> circumstances. </p></li>
</ul>

<p>Of course, this is entirely subjective though without benchmarking a particular scenario. At what point is failure rare enough to warrant exceptions? </p>

<p>This doesn't answer your title question, but it's a good guideline to keep in mind. Hopefully someone else can answer the other part. </p>
",0
46654123,46652217,1,"<p>I've made small changes in your source code in order to test it and fix it. I've created a method called SetfileName in Frame class and also changed the <code>char *fileName</code> to <code>char fileName[40]</code>, so that <code>Frame class</code> holds the value of fileName instead of the pointer.</p>

<pre><code> #include &lt;iostream&gt;
 #include &lt;string.h&gt;

 using namespace std;

 class Frame {
        char fileName[40];
        Frame *pNext;

    public:
        Frame() {}
        ~Frame() {}
        const char *GetfileName () { return fileName; }
        const Frame *GetpNext () { return pNext; };

        void SetfileName(const char *name) { strncpy(fileName, name, sizeof(fileName)); }

        void printFileName() { cout &lt;&lt; fileName &lt;&lt; endl;  }
};


void InsertFrame() {
        Frame* frame = new Frame; //used to hold the frames
        char* firstName = new char[40];

        cout &lt;&lt; ""Please enter the Frame filename :"";

        cin.getline(firstName, 40); //enter a filename
        frame-&gt;SetfileName(firstName);
        frame-&gt;printFileName();
}

int main() {

    InsertFrame();

    return 0;
}
</code></pre>
",0
36339055,36338557,3,"<p>I think you want to check if <code>http</code> occurs in the beginning of <code>response</code>.<br>
<code>strstr (char *str1, char *str2)</code> returns a <strong>pointer</strong> to the first occurrence of <code>str2</code> in <code>str1</code>, so you should compare it to <code>response</code>, not to <code>&amp;response</code>.</p>

<p>Change your condition statement to <code>if (strstr(response,http) == response)</code>.<br>
See a working example <a href=""http://ideone.com/NP0AgG"" rel=""nofollow"">here</a>.</p>
",1
43963539,36169334,0,"<pre><code>int square(int x)
{
    int result = 0;
    for (int counter = 0; counter &lt; x; ++counter) result += x;
    return result;
}
</code></pre>
",0
35238735,35238434,1,"<p>You write:</p>

<blockquote>
  <p>I don't want to allocate a peel with new and return a pointer because for one I like the ease of the peel getting automatically destroyed once it goes out of scope and also, peel has a bracket operator which is much nicer without having to dereference the peel in brackets first.</p>
</blockquote>

<p>You might consider the following. Start by writing <code>peel</code> with the interface you want (e.g., the bracket operator). Hold everything as regular value members, without the pointers, boolean flags indicating no deleteion, and so forth.</p>

<pre><code>struct peel
{
    /* Hold here everything as regular value members, without 
    pointers or boolean flags indicating whether to delete, and
    so forth.*/

    // Here's your brackets operator.
    ... operator[](...);
};
</code></pre>

<p>Now just use this</p>

<pre><code>struct banana
{
    peel getPeel() {
        peel ret;
        ...
        return ret;
    }
};
</code></pre>

<p>Profile to see if there's any problem using this. There's a fairly good chance there won't be, due to <a href=""https://en.wikipedia.org/wiki/Return_value_optimization"" rel=""nofollow""><em>NRVO</em></a>.</p>

<p><em>If</em>, for some reason, you find that you can't manipulate <code>peel</code> objects by value efficiently, then consider refactoring as follows. First, move all heavy parts to <code>peel_imp</code> (again avoiding the pointers and boolean flags).</p>

<pre><code>// ""Heavy"" peel stuff.
struct peel_imp
{
    /* Hold here everything as regular value members, without 
    pointers or boolean flags indicating whether to delete, and
    so forth.*/
};
</code></pre>

<p>Then, as @EdHeal suggests in the comments, use a smart pointer to hold the implementation.</p>

<pre><code>struct peel
{
    ... operator[](...);

    std::shared_ptr&lt;peel_imp&gt; m_imp;
};
</code></pre>

<p>Again making <code>peel</code> objects efficient for value manipulation.</p>
",2
35238830,35238434,0,"<p>Why to destroy the object on assignment and return. It'll be invalid pointer and useless.
Better option is use move constructor/ Move assignment operator.</p>
",0
37920559,37920478,1,"<p>It's correct, but you should give tart a value. Otherwise, it gets initialized with a random one.</p>
",1
37920517,37920478,8,"<p>Since <code>tart</code> has not been assigned to before it is used (in the compare), the result of the initial comparison is undefined behavior.</p>
",0
36440929,36440010,1,"<blockquote>
  <p>Unfortunately, as destructor in Base is virtual, thus un-overrided PutSat will be called.</p>
</blockquote>

<p>Correct, but not for that reason. The destructor being virtual has nothing to do with it. The base class's methods will be called because the object has been partially destroyed back to the base class, which includes causing its VFT be that of a base class instance.</p>

<blockquote>
  <p>How to call the overridden version</p>
</blockquote>

<p>You can't. It's gone. The object has gone. It wouldn't make sense, so C++ doesn't allow it.</p>
",0
36370359,36369947,7,"<ul>
<li>Reference is to avoid copying large size objects. However, for small objects, it is more preferable to have non-reference, since reference-creation will incur more overhead than it would save. For example <code>&lt;=pointer-size</code> data type on a given platform.</li>
<li><code>const</code> is to make sure that given object will not be changed by function, which is a safety-check for the programmer writing given function, a contract for the caller. It also makes the caller to pass a non-const as well as const object.</li>
<li>Some may argue that <code>const</code> without reference doesn't make sense (as original object will not be modified anyway). But, as a safety-net, it is advised for function implementer to have <code>const</code> parameters, so that by mistake function doesn't change its arguments. That's the reason, some functional languages have <code>constness</code> by default (unless you make them mutable).</li>
</ul>
",0
36370386,36369947,4,"<p>What you don't see is without profiling the code and looking for differences in performance is what is happening behind the scenes. </p>

<p>A <code>Matrix a</code> parameter is pass by value. The source <code>Matrix</code> will be copied into <code>Matrix a</code>, and depending on the size of the matrix, this may take a while. A 3x3 matrix isn't much, but if it happens a lot... And if instead of 3x3 you have a 300x300 matrix, that is a lot of vector construction and data copying. Probably going to be a performance killer. It will almost certainly certainly take longer than the pass by reference version of the function, <code>const Matrix&amp; a</code> which will only copy the address of the source <code>Matrix</code> unless the compiler sees some advantages in performing a copy of the <code>Matrix</code> itself. </p>

<p>So you could get by with <code>Matrix &amp; a</code>, but that allows the function to play with the contents of <code>Matrix a</code>, possibly to the detriment of the calling function. Changing the declaration to <code>const Matrix &amp; a</code> promises the caller that <code>a</code> will not be changed inside the function and the compiler backs this up by refusing to compile if you try. This is mostly a safety thing. It prevents the possibility of subtle mistakes introducing hard-to-detect errors.</p>
",0
40962248,40962201,3,"<p>because the result of calling <code>square()</code> is an r-value, which can bind to a const l-value reference or an r-value reference, but not a mutable l-value reference.</p>

<p>This is by design, to prevent you from accidentally creating temporaries that you then mutate and throw away without meaning to.</p>

<p>(does not apply to rule-breaking Microsoft compilers)</p>
",10
36610264,36610031,5,"<p>Looks like the code is populating the vector with tokens from the command line.</p>

<p>The code is using <a href=""http://en.cppreference.com/w/cpp/container/vector/vector"" rel=""noreferrer"">the std::vector constructor for sequences</a> and passing in an <em>iterator</em> to the first argument (after the program name) and one past the last argument on the command line.  </p>

<p>To verify, try this:</p>

<pre><code>for (unsigned int i = 0; i &lt; argc; ++i)
{
  std::cout &lt;&lt; ""Argument ["" &lt;&lt; i &lt;&lt; ""]: "" &lt;&lt; argv[i] &lt;&lt; std::endl;
}
std::cout &lt;&lt; ""\nFrom vector:\n""
for (unsigned int j = 0; j &lt; params.size(); ++j)
{
  std::cout &lt;&lt; ""params["" &lt;&lt; j &lt;&lt; ""]: "" &lt;&lt; params[j] &lt;&lt; ""\n"";
}
</code></pre>
",0
36224817,36224213,2,"<p>Move the definition of matrix inside the constructor. Change:</p>

<pre><code>vector&lt;vector&lt;double&gt; &gt; matrix(matrixSize, vector&lt;double&gt;(matrixSize));
</code></pre>

<p>to:</p>

<pre><code>vector&lt;vector&lt;double&gt; &gt; matrix;
</code></pre>

<p>And then inside the constructor:</p>

<pre><code>CParser(const string &amp; str) : iss(str) {
        this-&gt;matrix = vector&lt;vector&lt;double&gt;&gt;(this-&gt;matrixSize, vector&lt;double&gt;(this-&gt;matrixSize));
}
</code></pre>
",6
36254322,36254298,2,"<p>The declaration <code>checkloc();</code> has no type indicated, and the compiler is assuming you mean that it returns <code>int</code> (this is allowed in C, not C++).  Simply indicate the return type as <code>void</code> to fix your problem</p>

<pre><code>LPCSTR adsf;

void checkloc();
</code></pre>

<p>However, there's really no point in declaring a function and then immediately defining it. The definition can also serve as the declaration, so in your case your best move is to delete the line <code>checkloc();</code></p>
",1
37340653,37340428,6,"<p>The operating system's memory statistics is only a rough indicator for what you're investigating. You'd be better off using and understanding a memory leak detector like the one in <a href=""http://valgrind.org/docs/manual/quick-start.html"" rel=""noreferrer"">valgrind</a>. </p>
",0
37340906,37340428,0,"<p>Task manager is not showing the exact memory your program consumes, operating system reserves memory as per the programs request (not the program directly allocate it), and shared libraries can also make contributions for memory usage </p>
",0
41654609,41654559,1,"<p>You need to define variables that you're using. Moreover, you only need to define them where you need them. For example</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;                      // this is not recommended but I won't 
                                          // change your code completely
int addNumbers()
{
    int FirstNumber, SecondNumber;        // local variables
    cout &lt;&lt; ""enter first number: "" &lt;&lt; endl;
    cin &gt;&gt; FirstNumber;
    cout &lt;&lt; ""enter second number: "" &lt;&lt; endl;
    cin &gt;&gt; SecondNumber;
    return FirstNumber + SecondNumber;    // compute and return result
}

int main() {    
    cout &lt;&lt; ""Test\n"";
    cout &lt;&lt; addNumbers();
    // note: return 0; is not needed.
}
</code></pre>
",12
42485801,42485679,0,"<p>Firstly, both of your snippets are ill-formed - please use a modern compiler to try them out.</p>

<ul>
<li><p><a href=""http://melpon.org/wandbox/permlink/sCCBF4GJDnI99eP6"" rel=""nofollow noreferrer"">first snippet on <strong>wandbox</strong></a></p></li>
<li><p><a href=""http://melpon.org/wandbox/permlink/jHnscw7Fs84H4yqi"" rel=""nofollow noreferrer"">second snippet on <strong>wandbox</strong></a></p></li>
</ul>

<p>When declaring a variable in <em>global scope</em>, it is automatically zero-initialized. This is the reason you're getting a <em>redefinition</em> error - <code>x</code> is already defined to zero.</p>

<p>The following snippet will compile:</p>

<pre><code>extern int x;
int x;
int main()
{
}
</code></pre>
",0
36784542,36784443,0,"<p>As the error message says, There is no version of the constructor for your String class that takes a single parameter. You have a default constructor and one that takes two parameters. </p>

<p>You need to define one which takes a single parameter and initializes the str</p>
",0
36784549,36784443,-1,"<p>String s4(""This String built by constructor"");
this statement needs construction function</p>

<p>String(char *);</p>
",1
36784502,36784443,0,"<p>It looks like your <code>Copy</code> and <code>Concat</code> functions each take two parameters, yet you pass them both a single parameter. If you want to copy them into a String object, your code should look more like:</p>

<pre><code>String Copy(char* orig)
{
    // Same copy logic you have, 
    // except copy into ""*this""
}
</code></pre>
",2
45764272,45764207,1,"<p>You have a off-by-one index error.</p>

<p>The way you have implemented your class, when there are <code>N</code> items in the stack, the value of <code>top</code> is <code>N</code>.</p>

<p>Hence, <code>top</code> is not a valid index to access the elements of <code>v</code>. You can use:</p>

<pre><code>int pop()
{
    int x=v[top-1];
    top--;
    return x;
}
</code></pre>

<p>or</p>

<pre><code>int pop()
{
    top--;
    int x=v[top];
    return x;
}
</code></pre>
",0
45764274,45764207,2,"<p>You can use the vector functions</p>

<pre><code>int k = s.back();
s.pop_back();
cout &lt;&lt; k;
</code></pre>

<p>more information<a href=""http://www.cplusplus.com/reference/vector/vector/back/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/vector/vector/back/</a></p>
",0
45764366,45764207,1,"<p>As some of the other answers say, you can use the built-in vector functions to do these things (see <a href=""http://www.cplusplus.com/reference/vector/vector/pop_back/"" rel=""nofollow noreferrer"" title=""pop_back""><code>pop_back</code></a> and <a href=""http://www.cplusplus.com/reference/vector/vector/back/"" rel=""nofollow noreferrer""><code>back</code></a>.</p>

<p>However, if you want to define your own, I would use the <code>vector.at(index)</code> function. Addressing the values with the index as you have works, but it doesn't do any bounds checking <code>at()</code> does. Which would solve your problem above where your index isn't correct for the zero-based indexing of a vector.</p>
",0
34971650,34971424,3,"<ol>
<li>Convert everything to the smallest unit.</li>
<li>Add them together.</li>
<li>Divide up into larger units if desired.</li>
</ol>

<p>In the U.S.A., our smallest denomination is the penny.  A quarter is equal to 25 pennies, a dime is equal to 10 pennies.</p>

<p>To add a dime and a quarter, one would convert them to pennies and add, resulting in 35 pennies (equivalence).  </p>

<p>Lastly, use a <em>debugger</em> to execute each statement separately.  Also, print out, display or watch the contents of the variables.</p>
",0
34971753,34971424,0,"<p>You are confused because there are no types with two decimal points in the number, right? Then you have to use a string value for old amount and a float one for new amount like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;

class Money
{
public:
    Money(int pound, int shilling, int pence):
        pence(pence),
        shilling(shilling),
        pound(pound)
    {
    }

    Money&amp; operator+=(const Money&amp; money)
    {
        auto newPence = this-&gt;pence + money.pence;
        auto newShilling = this-&gt;shilling + money.shilling + newPence / 12;
        this-&gt;pence = newPence % 12;
        this-&gt;shilling = newShilling % 20;
        this-&gt;pound += money.pound;
        this-&gt;pound += newShilling / 20;
    }
    std::string GetOldAmount()
    {
        return std::to_string(pound) + ""."" + std::to_string(shilling) + ""."" + std::to_string(pence);
    }
    float GetNewAmount()
    {
        auto totalPences = 1.0f * (pound * 240 + shilling * 12 + pence) / 240;
        return totalPences;
    }
private:
    int pence = 0;
    int shilling = 0;
    int pound = 0;
};

int main()
{
    int pound, shill, pence;
    char dot1, dot2;
    std::cout &lt;&lt; ""Enter first old-pound amount:"";
    std::cin &gt;&gt; pound &gt;&gt; dot1 &gt;&gt; shill &gt;&gt; dot2 &gt;&gt; pence;
    Money money1(pound, shill, pence);
    std::cout &lt;&lt; ""Enter second old-pound amount:"";
    std::cin &gt;&gt; pound &gt;&gt; dot1 &gt;&gt; shill &gt;&gt; dot2 &gt;&gt; pence;
    Money money2(pound, shill, pence);
    money1 += money2;
    std::cout &lt;&lt; ""Old-pound total = "";
    std::cout &lt;&lt; money1.GetOldAmount() &lt;&lt; std::endl;
    std::cout &lt;&lt; ""Decimal-pound total = "";
    std::cout &lt;&lt; std::setprecision(3) &lt;&lt; money1.GetNewAmount() &lt;&lt; std::endl;
}
</code></pre>

<h2>Result</h2>

<pre><code>Enter first old-pound amount:5.10.11
Enter second old-pound amount:3.9.5
Old-pound total = 9.0.4
Decimal-pound total = 9.02
</code></pre>
",1
41646354,37931691,0,"<p>There's multiple ways you can handle it. A pretty common one is making a file with the new strings in it, deleting the old file, and then renaming the new file to the old file name. </p>

<p>If that suits you, you can snag this console application. </p>

<hr>

<p>Parameter 1 is the string to search for </p>

<p>Parameter 2 is the replacement text to use </p>

<p>Parameter 3 is the file path </p>

<hr>

<p>Basically, I'm making some STD streams to the new file, and from the old file, locating the string in question if it exists, and if so, replace that string, and then pipe the result, regardless if substitution occurred as a new line for the new file.</p>

<p>Then, we're closing the streams, checking the file size, and if it succeeded to make a non-empty file, we're deleting the old file and renaming the new file to the old file name.</p>

<p>If the exit code aka errorlevel is 2, it means the input stream didn't work. If it's -1, that means we didn't successfully find and replace with a new file in-tact. If it's 1, that means you didn't provide the correct parameters. Only a zero exit will indicate success.</p>

<p>If you want to use this, you should add some exception handling, and probably a more robust file backup solution.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;sys\stat.h&gt;

using namespace std;

int main(int argc, char * argv[])
{
    if (argc != 4) { return 1; }
    int exit_code = -1;

    string textToFind = string(argv[1]);
    string replacementText = string(argv[2]);
    string fileToParse = string(argv[3]);
    string fileToWrite = fileToParse+"".rep"";

    ifstream inputFileStream(fileToParse, ifstream::in);
    if (!inputFileStream.good()) { return 2; }

    ofstream outputFileStream(fileToWrite);

    string fileLine;
    while (getline(inputFileStream, fileLine))
    {
        size_t substringPos = fileLine.find(textToFind);
        if (substringPos != string::npos)
        {
            fileLine.replace(substringPos, textToFind.size(), replacementText);
        }       
        outputFileStream &lt;&lt; fileLine &lt;&lt; '\n';
    }
    outputFileStream.close();
    inputFileStream.close();

    struct stat st;
    stat(fileToWrite.c_str(), &amp;st);
    int new_file_size = st.st_size;

    if (new_file_size &gt; 0)
    {
        if (remove(fileToParse.c_str())==0)
        {
            if (rename(fileToWrite.c_str(), fileToParse.c_str())==0)
            {
                exit_code = 0;
            }
        }
    }

    return exit_code;
}
</code></pre>
",0
36252607,36252494,0,"<p>The basic problem is that you're reinventing Run-Time Type information. You don't need to add ""command_type=A"" to <code>class A_COMMAND</code>. C++ already knows what types your objects have, if there's at least one virtual method. And it looks like your class needs a virtual destructor.</p>
",0
36253922,36252494,2,"<p>First, if <code>translateLine()</code> should be able to accept <code>A_COMMAND</code>, <code>C_COMMAND</code>, or <code>L_COMMAND</code> objects, then it needs to take a <code>Command*</code> parameter, not a <code>Command</code> parameter. A pointer to a base class can hold a pointer to a class derived from that base, but an object of the base class cannot hold a derived object.</p>

<p>Second, you cannot call a function that belongs to <code>A_COMMAND</code> even with a <code>Command</code> pointer that is really pointing to a <code>A_COMMAND</code> object without doing a <code>dynamic_cast</code>. A <code>dynamic_cast</code> can convert a pointer from <code>Command*</code> to <code>A_COMMAND</code> at run-time and will return <code>NULL</code> if the object pointed to is not really an <code>A_COMMAND</code> object.</p>
",6
42527629,29572852,0,"<p>A Modern C++ solution.</p>

<pre><code>#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;random&gt;
#include &lt;iostream&gt;

// List of choices we want to give the user.
std::vector&lt; std::string &gt; options = { 
        {""Option 1""}, 
        {""Option 2""}, 
        {""Option 3""}, 
        {""Option 4""}, 
        {""Option 5""} };

// Prepare random number generator /////////////////////////////////////////
// Seed with a real random value, if available
std::random_device r;
std::default_random_engine e1(r());
// A random value from 0 up to (and including) count of options - 1
std::uniform_int_distribution&lt;int&gt; uniform_dist(0, options.size()-1);

int nextRandomChoice()
{
    return uniform_dist(e1);
}

int main()
{
    std::string input;

    do 
    {
        const auto firstSelection = nextRandomChoice();
        const auto secondSelection = nextRandomChoice();
        const auto thirdSelection = nextRandomChoice();

        std::cout &lt;&lt; options[firstSelection] &lt;&lt; '\n'
            &lt;&lt; options[secondSelection] &lt;&lt; '\n'
            &lt;&lt; options[thirdSelection] &lt;&lt; '\n';

        std::cout &lt;&lt; ""Press Q to quit or ENTER for next selection:"";
        std::getline(std::cin, input);
    } while ( input != ""Q"" );

    return 0;
}
</code></pre>
",0
36379664,36379643,2,"<p>These do different things. For example, in the int case:</p>

<pre><code>answer = 43;
cout &lt;&lt; use_answer_option_1 &lt;&lt; '\n';     // 43
cout &lt;&lt; use_answer_option_2 &lt;&lt; '\n';     // 42
</code></pre>

<p>In other words, option 2 makes a copy and option 1 doesn't. </p>

<p>Decide whether you want to make a copy or not (i.e. whether you want to see changes to the original initializer reflected in your reference).  The <code>mystruct</code> case is the same.</p>
",0
41896217,41895880,4,"<p>In my experience, it would take forever and a waste of time to figure these problems out. A simple solution is trying other IDE. For C++, try <a href=""http://www.codeblocks.org/"" rel=""nofollow noreferrer"">Code Block</a> or <a href=""http://www.cplusplus.com/doc/tutorial/introduction/visualstudio/"" rel=""nofollow noreferrer"">Visual Studio Express</a>. I did have a lot of weird errors with string library in Code Block, but in Visual Studio it runs well. The problem was that there are some errors in Code Block itself. </p>
",2
43965570,30294488,1,"<p>Save your code with .cpp extension as sometimes the extension is .c, so it shows this error.</p>

<p>file-> save file as... -> filename.cpp</p>
",0
38207733,38207682,5,"<p>The problem is that once you have passed the array to the function, it has decays to a <em>pointer</em> to its first element. You can't really use <code>begin</code> and <code>end</code> of pointers. Instead pass the size of the array (the number of elements) to the function as an extra argument and use <code>guess_number</code> as the start iterator and <code>guess_number + size_of_array</code> as the end iterator.</p>

<p>Or start using <a href=""http://en.cppreference.com/w/cpp/container/array"" rel=""nofollow""><code>std::array</code></a> for your arrays instead.</p>
",2
38207904,38207682,2,"<blockquote>
  <p>anyone know how to improve this? thanks.</p>
</blockquote>

<p>Yes, make the length of the array deducable through a template</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

template&lt;std::size_t Length&gt;
void input_guess_number(int (&amp;guess_number)[Length])
{

    int num, check = 0;

    for(int i = 0; i &lt; Length ; i++){

        cout &lt;&lt; ""please enter no."" &lt;&lt; i+1 &lt;&lt; "" number (0-9) and press enter: "";
        cin &gt;&gt; num;

        if (any_of(begin(guess_number), end(guess_number), [=](int n){return n == num;})){
            check = 1;
        }
        else{
            check = 0;
        }

        if (check == 1){
            cout &lt;&lt; ""\nyou cannot use this number. try another one!\n\n"";
            i--;
        }
        else if (num &gt;=0 &amp;&amp; num &lt; 10){
            guess_number[i] = num;
        }
        else{
            cout &lt;&lt; ""\nwrong number! please choose a number from 0 to 9.\n\n"";
            i--;
        }

    }

    cout &lt;&lt; ""\nYour number is: "";

    for(int i = 0; i &lt; 4; i++){
        cout &lt;&lt; guess_number[i];
    }
}

int main()
{
    int guess_number[4] = {100, 100, 100, 100};
    input_guess_number(guess_number);
}
</code></pre>

<p>for fun, here's a version which uses <code>std::vector</code> to accumulate the digits, and also shows which remaining digits are allowed in the prompt.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iterator&gt;
#include &lt;utility&gt;

using namespace std;

vector&lt;pair&lt;int, int&gt;&gt; allowed_range(int min, int max, const std::vector&lt;int&gt;&amp; used)
{
    vector&lt;pair&lt;int, int&gt;&gt; result;

    while (min != max)
    {
        while ((min != max) &amp;&amp; std::find(begin(used), end(used), min) != end(used))
        {
            ++min;
        }

        if (min != max)
        {
            pair&lt;int, int&gt; current = { min, min };
            while ((min != max) &amp;&amp; std::find(begin(used), end(used), min+1) == end(used))
                ++min;
            current.second = min;
            result.push_back(current);
            if (min == max) break;
            ++min;
        }
    }

    return result;
}

std::ostream&amp; emit_range(std::ostream&amp; os, const pair&lt;int, int&gt;&amp; range)
{
    if (range.first == range.second) {
        return os &lt;&lt; range.first;
    }
    else {
        return os &lt;&lt; range.first &lt;&lt; ""-"" &lt;&lt; range.second;
    }
}

std::ostream&amp; emit_ranges(std::ostream&amp; os, const vector&lt;pair&lt;int, int&gt;&gt;&amp; ranges)
{
    auto sep = """";
    for (auto&amp; range : ranges) {
        emit_range(os &lt;&lt; sep, range);
        sep = "","";
    }
    return os;
}

std::ostream&amp; emit_ranges(std::ostream&amp; os, int min, int max, const std::vector&lt;int&gt;&amp; used)
{
    return emit_ranges(os, allowed_range(min, max, used));
}

std::vector&lt;int&gt; input_guess_number(std::size_t desired_length)
{
    std::vector&lt;int&gt; accumulator;

    while (accumulator.size() &lt; desired_length)
    {
        cout &lt;&lt; ""please enter no."" &lt;&lt; accumulator.size() + 1 &lt;&lt; "" number in range "";
        emit_ranges(cout, 0, 9, accumulator) &lt;&lt; "" and press enter: "";
        int num;
        cin &gt;&gt; num;

        if (std::find(begin(accumulator), end(accumulator), num) != end(accumulator))
        {
            cout &lt;&lt; ""\nyou cannot use this number. try another one!\n\n"";
            continue;
        }
        else if (num &lt; 0 or num &gt; 9) {
            cout &lt;&lt; ""\nwrong number! please choose a number from 0 to 9.\n\n"";
            continue;
        }
        else {
            accumulator.push_back(num);
        }
    }

    return accumulator;
}

int main()
{
    auto digits = input_guess_number(4);
    cout &lt;&lt; ""\nYour number is: "";
    std::copy(begin(digits), end(digits), ostream_iterator&lt;int&gt;(cout));
    cout &lt;&lt; endl;

}
</code></pre>
",3
47702824,47702776,0,"<p>It's exactly what the compiler is warning you about.  You need to define and implement your own destructors for each class, and make sure they are defined as <code>virtual</code> for inheritance.</p>
",0
47703087,47702776,9,"<p>A basic C++ rule says that destructors work their way up from the derived class to the base class. When a <code>Cat</code> is destroyed, then the <code>Cat</code> part is destroyed first and the <code>Animal</code> part is destroyed after.</p>

<p><code>delete animal;</code> is undefined behaviour because in order to properly follow C++ destruction rules, one must know, at runtime, which derived class part should be destroyed before the <code>Animal</code> base part. A <code>virtual</code> destructor does exactly that - it enables a dynamic dispatch mechanism that makes sure destruction works as designed.</p>

<p>You have no <code>virtual</code> destructor, however, so <code>delete animal</code> just doesn't make sense. There is no way to call the correct derived-class destructor, and destroying only the <code>Animal</code> part wouldn't exactly be meaningful behaviour, either.</p>

<p>Therefore, the C++ language makes no assumptions about what will happen in such a situation.</p>

<p>Your compiler is nice enough to warn you about this.</p>

<hr>

<p>With <code>delete cat</code>, the situation is slightly different. The static type of the <code>cat</code> pointer is <code>Cat*</code>, not <code>Animal*</code>, so it is clear even without any dynamic dispatch mechanism which derived-class destructor to call first.</p>

<p>The compiler still warns you about this, but it does so with a different wording (""might cause"" vs. ""will cause""). I believe the reason is that <code>Cat</code> might itself be the base class for more derived classes, seeing as it is already part of a class hierarchy with <code>virtual</code> functions.</p>

<p>It apparently doesn't bother to execute a more complete code analysis to find out that <code>delete cat</code> is really harmless.</p>

<hr>

<p>In order to fix this, make the <code>Animal</code> destructor <code>virtual</code>. While you're at it, replace your raw pointers with <code>std::unique_ptr</code>. You still have to follow the <code>virtual</code> destructor rule for classes like yours, but you no longer have to perform a manual <code>delete</code>.</p>
",0
34889234,34889219,3,"<p><code>STRCPY</code> is not <code>strcpy</code>, as C/C++ are case sensitive! Probably <code>STRCPY</code> is a preprocessor macro wrapping <a href=""http://en.cppreference.com/w/cpp/string/byte/strncpy"" rel=""nofollow""><code>strncpy</code></a>.</p>

<pre><code>#define STRCPY(dst, size, src)  strncpy(dst, src, size)
</code></pre>

<p>You should ask your IDE where <code>STRCPY</code> is defined.</p>
",5
47492790,47492723,0,"<p>Well, its not possible to check if a key is hit and continue if not. You need to wait until the user press enter and
here in your code, you have an infinite loop, dont forget to update cont.</p>

<pre><code>cont = std::cin.get();
</code></pre>
",0
47492807,47492723,2,"<pre><code>#include&lt;Windows.h&gt;
#include&lt;iostream&gt;

int main()
{
    while(true)
    {    // GetAsyncKeyState take virtual key code
         if(GetAsyncKeyState(VK_ESCAPE) {
             std::cout &lt;&lt; ""escape key pressed"" &lt;&lt;endl;
         }
         if(GetAsyncKeyState(VK_ENTER) {
             std::cout &lt;&lt; ""enter key pressed"" &lt;&lt; endl;
         }
     }
}
</code></pre>
",0
47492830,47492723,0,"<p>As others have said, the terminal will wait for a full line of test to be entered, followed by a newline, so you can't really get this behavior with just C++, independent of platform. The terminal will also not accept a blank input with just a newline. If you want real-time input with C++, there are libraries you can look at (like SDL), but it probably isn't a good place to start for a beginner.</p>

<p>Something like this will give similar behavior to what you want:</p>

<pre><code>#include &lt;iostream&gt;


void StartMessage()
{
    std::string s;
    do
    {
    std::cout &lt;&lt; ""&gt; PROTOCOL: Overloaded Hospital\n""
        &lt;&lt; ""&gt; Running. . .\n""
        &lt;&lt; ""&gt; Hello\n""
        &lt;&lt; ""&gt; Esc to exit"";


    std::cin &gt;&gt; s;
    } while(s[0] != 27);
   std::cout &lt;&lt; ""\nExiting\n"";
}


int main()
{



StartMessage();

return 0;
}
</code></pre>

<p>This will exit only if you enter a line starting with escape, but you have to hit enter after. It might be better to use a character like 'q' for this so it prints out more clearly on the terminal.</p>
",0
39629404,39629388,3,"<p>You call <code>object.GetName()</code> twice which causes the input to be asked for twice.  Store the result of this function to a variable and use that in the if statement.  The || statement is short-circuited if the first expression is true.  This leads to the second call not being executed if the first is true. </p>
",0
39629419,39629388,2,"<p>That is because GetName() is asking for input every time,</p>

<p>So the first time it is asking for x, if x isnt john it goes to the next test, which then gets input and tests that against x = chris.</p>

<p>try changing it to this:</p>

<pre><code>int main()
{
FooFoo object;
string test = object.GetName()
if (test == ""John"" || test == ""Chris"")
{
    cout &lt;&lt; ""Yes"";

}
else {
    cout &lt;&lt; ""No"";
}

}
</code></pre>

<p>Hope that helps</p>
",1
39629486,39629388,0,"<p>Your current if statement effectively evaluates to:</p>

<pre><code>if (object.GetName() == ""John"")
  cout &lt;&lt; ""Yes"";
else if (object.GetName() == ""Chris"")
  cout &lt;&lt; ""Yes"";
else
  cout &lt;&lt; ""No"";
</code></pre>

<p>Try entering <code>Chris</code> followed by <code>John</code> and you should get <code>No</code>.</p>

<p>Just call <code>getName()</code> before the if statement, store the value in a local variable, then test that instead:</p>

<pre><code>string name = object.GetName();
if (name == ""John"" || name == ""Chris"")
  cout &lt;&lt; ""Yes"";
else
  cout &lt;&lt; ""No;
</code></pre>
",0
46980652,46980591,1,"<p>According to the <a href=""http://www.cplusplus.com/reference/string/string/assign/"" rel=""nofollow noreferrer"">docs</a>, you'd be using fill(5).  As it says in the docs, this version of <code>assign()</code> <code>Replaces the current value by n consecutive copies of character c.</code>  In this case, <code>n</code> would be <code>x</code> or <code>row</code>, and the character would be <code>character</code> or <code>'#'</code>.  So in the first usage, you are saying <code>wSpace</code> is now a string of <code>'#'</code> characters repeated <code>row</code> times, and the second instance, you are saying <code>charSpace</code> is now a string of <code>character</code> characters repeated <code>x</code> times. </p>
",0
36363674,36362813,0,"<pre><code>vector&lt;int &gt; ::iterator it;
</code></pre>

<p>Is a global variable. Each time the ham function is called recursively it is used and overwritten so when ham returns the iterator is in a wrong state. Move the iterator inside the ham function so each time ham is called it has its own iterator.</p>
",0
42501899,42501758,1,"<p>I would do like that:</p>

<p>The declaration of the class and the structure -> to a header (or separate headers). The node variables are to be put to a source file (c or cpp) to be not accessed from outside directly; if other source files need access to them - you can provide get/set functions for this purpose. Also to the source file should come the implementation of the class' methods if they are not inline.</p>
",1
42503043,42501758,0,"<p>If you want to have</p>

<pre><code>queueNode * head;
queueNode * tail;
queueNode * n;
</code></pre>

<p>accessible through your main function you would normally either put them inside a header file to be included in the spot you want (as including a header file is simply copy pasting it) or just declare them above your main function in the main.cpp file.  simple as that.</p>

<p>like what was said though it's usually best to put the definitions (class/struct and member outlines) inside a header file to include at the top.  and flesh out the functions in the source files.</p>

<p>usually when declaring a variable/object you do it right next to where you need it unless there's multiple places it's needed in which case just slapping it into a header with include guards would do the trick.
Example:</p>

<p>main.cpp</p>

<pre><code>#include ""queue.h""
#pragma once

queueNode * head;
queueNode * tail;
queueNode * n;

//class functions that use head, tail, and n


int main ()
{

//functions that use head, tail, and n

return 0;
}
</code></pre>

<p>queue.h</p>

<pre><code>class Queue
{
public:
    void enqueue (int x);
    void dequeue ();
    void print ();
};

struct queueNode
{
    int data;
    queueNode * next;
    queueNode * prev;
};
</code></pre>

<p>queue.cpp</p>

<pre><code>#include ""queue.h""
//queue and other methods should go here.
</code></pre>

<p>just remember that if your compiling multiple source files without an ide you need to link them together.</p>
",1
41660415,41658743,2,"<ul>
<li>You are using a non-standard header <code>&lt;iostream.h&gt;</code>. It must be <code>&lt;iostream&gt;</code>. You aren't using an ancient compiler from the 1990s, are you? There are excellent free and modern C++ compilers available for Windows and Linux. Download one and use it.</li>
<li><code>&lt;string.h&gt;</code> exists but is not the correct header to get <code>std::string</code>; it instead contains C-style <code>char*</code> functions and is not what you want here.</li>
<li><code>main</code> must return <code>int</code>, even though a <code>return 0</code> statement is not necessary.</li>
<li>You cannot use <code>string</code>, <code>cout</code> or <code>endl</code> without the <code>std::</code> prefix. So make it <code>std::string</code>, <code>std::cout</code> and <code>std::endl</code>. <a href=""https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice"">Do not use <code>using namespace std</code></a>.</li>
<li><a href=""https://stackoverflow.com/questions/8311058/n-or-n-or-stdendl-to-stdcout"">Do not use <code>std::endl</code> but <code>'\n'</code>.</a></li>
<li>C++ does not guarantee ASCII, and it does not even guarantee that letters are consecutive (it does guarantee that for digits, see below). While it's unlikely for you to encounter a system which is not ASCII-compatible, you should still get into the habit of writing safe, portable code. Which means that you should not use magic numbers like 65 but use <code>'A'</code> instead. And of course, your <code>&gt;=</code> comparisons are not guaranteed to work. Getting this right is surprisingly difficult in C++. You can use <a href=""http://en.cppreference.com/w/cpp/string/byte/isalpha"" rel=""nofollow noreferrer""><code>std::isalpha</code></a> but must pay attention not to invoke undefined behaviour. See also a <a href=""https://stackoverflow.com/a/7616973/3313064"">more detailed treatise on this subject</a>.</li>
<li>91 is ASCII for ']'. You certainly meant 90 for 'Z'. 95 and 123 are likewise off. Have a look at <a href=""http://www.asciitable.com/"" rel=""nofollow noreferrer"">http://www.asciitable.com/</a>. But, see above, do not use the magic numbers and do not use <code>&gt;=</code> comparisons.</li>
<li>Your code could use more spaces to make it more readable.</li>
<li>Why declare <code>i</code> outside of the loop? It needlessly increases its scope. And it has the wrong type; it's a signed int when it should be an unsigned one, or simply <code>std::string::size_type</code>. However, you should consider using a range-based for loop to iterate through the string anyway.</li>
<li>Testing a character for 0 and 9 does not make sense. You want to test for <code>'0'</code> and <code>'9'</code>. Note how in this case, C++ does guarantee consecutive values for the characters even if ASCII is not guaranteed. You can therefore use range comparisons safely.</li>
</ul>

<p>Here we go:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cctype&gt;

int main()
{
   std::string s = ""124#$&amp;afhj"";
   for (auto&amp;&amp; character : s)
   {
      if (std::isalpha(static_cast&lt;unsigned char&gt;(character)))
      {
         std::cout &lt;&lt; character &lt;&lt; '\n';
      }
      else
      {
        if (character &gt;= '0' &amp;&amp; character &lt;= '9')
        {
            std::cout &lt;&lt; character &lt;&lt; '\n';
        }
        else
        {
            std::cout &lt;&lt; character;
        }
      }
   }
}
</code></pre>

<p>This will work. I don't think it's really useful, because what it does is:</p>

<ul>
<li>Print digits and letters with a linebreak.</li>
<li>Print everything else without a linebreak.</li>
</ul>

<p>But after all, that's what the original program's intention was.</p>
",0
41660380,41658743,-1,"<p>In your code is many mistakes. In my opinion your code should look like:</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

int main() {
    string s = ""124#$&amp;afhj"";
    unsigned int i;
    for (i = 0; i &lt; s.length(); i++) {
        if ((s[i] &gt;= 65 &amp;&amp; 91 &gt;= s[i]) || (s[i] &gt;= 95 &amp;&amp; 123 &gt;= s[i])) {
            cout &lt;&lt; s[i] &lt;&lt; endl;
        } else {
            if (s[i] &gt;= 0 &amp;&amp; s[i] &lt;= 9) {
                cout &lt;&lt; s[i] &lt;&lt; endl;
            } else {
                cout &lt;&lt; s[i];
            }
        }
    }
}
</code></pre>
",1
37770853,37770835,0,"<p>In the code that you have posted, <code>amount</code> is not initialised; </p>

<p>So the line <code>fifties= amount/50;</code> results in <code>fifties</code> having random garbage value.</p>

<p>To overcome, you must assign some value to <code>amount</code> as:</p>

<pre><code>int amount=100
</code></pre>

<p>or ideally, move the line <code>fifties= amount/50;</code> below <code>cin&gt;&gt;amount</code>.  By writing 
<code>fifties= amount/50;</code> below the <code>cin&gt;&gt;amount</code> line, you are making sure that <code>amount</code> contains the value entered by the user.  So, you perform valid division in the next line, which results in <code>fifties</code> containing the expected answer.</p>

<p>Working code <a href=""http://ideone.com/TgfR7P"" rel=""nofollow""><strong>here</strong></a>.</p>
",1
37770864,37770835,0,"<p>Just move the <code>fifties = amount / 50;</code> line <em>after</em> the <code>cin &gt;&gt; amount;</code> line, so that <code>amount</code> has a useful value first.</p>
",1
37771276,37770835,0,"<p>Initialize the value of ""amount"" and calculate the fifties after receiving the input value from user.</p>

<p>Uninitialized value amount will contain garbage value and you are calculating the fifties even before you receive the input</p>
",0
41655056,41654603,0,"<p>The first glaring error is this in your <code>BinarySearchTree</code> constructor:</p>

<pre><code> if(root != NULL){
   root-&gt;data = rootValue;  // undefined behavior
</code></pre>

<p><code>root</code> is uninitialized, so it contains any garbage value.  Then when you use that garbage value (<code>root-&gt;data</code>), your program has gone into the land of <em>undefined behavior</em>.</p>
",2
34915355,32575310,-1,"<p>If you working with Eclipse on Windows platform, try to install TDM-GCC MinGW Compiler. It just a few clicks setup. Don't forget to choose MinGW compiler, when you create a new c++ project in Eclipse</p>
",0
39629300,39629250,0,"<p>Your problem is in these two lines in <code>int main()</code>:</p>

<pre><code>(Stud1+1)-&gt;mark_entry();
(Stud1+1)-&gt;average();
</code></pre>

<p>At each loop iteration, you're accessing the same element: the second one (index <code>1</code>). To access the <code>i</code>th element, just index into the array with brackets:</p>

<pre><code>Stud1[i].mark_entry();
Stud1[i].average();
</code></pre>

<p>If you really want to add the index to the pointer like you were doing (although there is no reason to do that in this scenario), then replace <code>(Stud1+1)</code> with <code>(Stud1+i)</code>.</p>
",0
40958095,40682594,1,"<p>The solution is very simple as follows:</p>

<pre><code>#include &lt;iostream&gt;

int main() {

    for (int i = 1; i &lt;= 3; i++) {
        std::cout &lt;&lt; i &lt;&lt; ""\t"" &lt;&lt; (i + 3) &lt;&lt; ""\t"" &lt;&lt; (i + 6) &lt;&lt; ""\n"";
    }

    return 0;
}
</code></pre>

<p>I would suggest that you should think on the basic maths logic to solve these kind of problems.</p>

<p>The above code will generate the following output:</p>

<pre><code>1   4   7
2   5   8
3   6   9
</code></pre>

<p>Here if you see each line, you can see that each value is incremented by 3.</p>

<ul>
<li>When <code>i = 1</code>, the first value is i itself.</li>
<li>The second value is <code>i+3</code>.</li>
<li>The third value is <code>i+6</code>.</li>
</ul>
",0
36364753,36364699,3,"<blockquote>
  <p>Can I access 'num1' variable using object of class A type?</p>
</blockquote>

<p>No, you cannot.<code>num1</code> is declared inside a function <code>data()</code> so you have no access to it through object of type A. You would have to move declaration of <code>int num1;</code> to class body.:</p>

<pre><code>class A 
{ 
  int a;
  double b;
  public:
  int num1;
  A(){a=20;B=78.438;}
  void data()
  {  
    num1=a;
  }
}
</code></pre>

<p>now you can write:</p>

<pre><code>A a;
a.num1 = 1;
</code></pre>
",0
36379673,36379632,3,"<p>Read the error message! You need to compile with <code>-std=c++11</code> or <code>-std=gnu++11</code>.</p>
",3
40531789,40531573,0,"<p>Arrays are not classes and do not have member functions. Moreover you have a typo. I think you mean</p>

<pre><code>int ca[6] = {38,38,40,38,40,37};
cout&lt;&lt;count(ca.begin(),ca.end(),40);
</code></pre>

<p>Write either like</p>

<pre><code>cout &lt;&lt; count( ca, ca + sizeof( ca ) / sizeof( *ca ), 40 );
</code></pre>

<p>or include header <code>&lt;iterator&gt;</code></p>

<pre><code>#include &lt;iterator&gt;
</code></pre>

<p>and write</p>

<pre><code>cout &lt;&lt; count( begin( ca ), end( ca), 40 );
</code></pre>

<p>On the other hand if you will use class std::array instead of your array then you may write</p>

<pre><code>array&lt;int, 6&gt; ca = {38,38,40,38,40,37};
cout&lt;&lt;count(ca.begin(),ca.end(),40);
</code></pre>

<p>Here I a demonstrative program</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;array&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

int main() 
{
    int a1[6] = { 38, 38, 40, 38, 40, 37 };

    std::cout &lt;&lt; std::count( std::begin( a1 ), std::end( a1 ), 40 ) &lt;&lt; std::endl;

    std::array&lt;int, 6&gt; a2 = { 38, 38, 40, 38, 40, 37 };

    std::cout &lt;&lt; std::count( a2.begin(), a2.end(), 40 ) &lt;&lt; std::endl;

    return 0;
}
</code></pre>
",0
40531804,40531573,0,"<p>Of course <code>ca</code> is not recognized, you forgot to initialize it :)
<p>The <code>count</code> function needs to receive the beginning and the end of the range over which you want to count. In your case, the array begins at <code>array</code>, and ends at <code>array+5</code>, but it's a strict comparison so you must pass <code>array+6</code>.
<p>The <code>main</code> becomes:</p>

<pre><code>int main(){
    int myArray[] = {38,38,40,38,40,37};

    cout &lt;&lt; count(myArray, myArray+6 40);
    return 0;
}
</code></pre>
",0
40531814,40531573,2,"<p>The example you have linked to is using a <code>std::array</code> called <code>ca</code>.
It takes a type and number of elements, so <code>std::array&lt;int, 6&gt;</code> expects 6 <code>int</code>s and is a fixed length array. </p>

<p>This has a <code>begin</code> and <code>end</code> method and plays nicely with the algorithms in the stl.</p>

<p>If you have a C style array instead, you can use <code>std::begin</code> and <code>std::end</code> to achieve the same thing.</p>

<pre><code>array&lt;int, 6&gt; ca{ 38,38,40,38,40,37 };
cout &lt;&lt; count(ca.begin(), ca.end(), 40) &lt;&lt; '\n';

int c_style_array[] = { 38,38,40,38,40,37 };
cout &lt;&lt; count(std::begin(c_style_array), std::end(c_style_array), 40) &lt;&lt; '\n';
</code></pre>
",0
36710276,36710229,2,"<p>Possible errors:</p>

<ul>
<li>Your compiler is possibly not recognising the <code>L""?""</code> as a unicode string in the source file.</li>
<li>Your console doesn't support it</li>
</ul>

<p>You could use the unicode character code for it instead (<code>""\u263B""</code>). Make sure the console supports unicode and that the font has a corresponding character for it.</p>

<p>It may also be easier (depending on the compiler support) to use the <a href=""http://en.cppreference.com/w/cpp/language/string_literal"" rel=""nofollow"">unicode character literals</a> for C++ 11;</p>

<pre><code>char a[] = u8""My \u263B character"";
cout &lt;&lt; a;
</code></pre>
",2
36710282,36710229,0,"<p>Its the Unicode 263B <a href=""http://unicode-table.com/de/search/?q=%E2%98%BB"" rel=""nofollow"">source</a></p>

<p>Simple use the <code>wchar_t a = 0x263B</code>;</p>
",1
36711044,36710229,0,"<p>This should work (<code>u8</code> since <code>c++11</code>):</p>

<pre><code>char smiley[] { u8""\u263b"" };
cout &lt;&lt; smiley &lt;&lt; '\n';
</code></pre>

<p>Or you could also just do:</p>

<pre><code>char smiley[] { ""\u263b"" };
cout &lt;&lt; smiley &lt;&lt; '\n';
</code></pre>
",0
36309730,36309481,0,"<p>The way to go is</p>

<ol>
<li><p>Sort all arrays. There is an overload of <code>operator&lt;</code> which <code>std::sort</code> can use to place the elements in lexicographical order.</p></li>
<li><p>Pairwise apply <code>std::set_intersection</code>.</p></li>
</ol>

<p>Example code:</p>

<pre><code>std::vector&lt;std::string&gt; v1 {""hello"",""world""};
std::vector&lt;std::string&gt; v2 {""goodbye"",""world""};

std::sort(std::begin(v1), std::end(v1));
std::sort(std::begin(v2), std::end(v2));

std::vector&lt;std::string&gt; common_elements;
std::set_intersection(std::begin(v1), std::end(v1)
                    , std::begin(v2), std::end(v2)
                    , std::back_inserter(common_elements));
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/e51babf0b182dc49"" rel=""nofollow"">DEMO</a></p>

<p>For more string-vectors, do that recursively. (There are more efficient solutions where you loop over all arrays at once, but this one is quick and standard-library-supported).</p>
",1
40537421,40537358,4,"<p>The answer is neither.</p>

<p>There is no ""original value"", and there is nothing to remember.</p>

<p>They are two separate, independent, variables. Within the inner scope, the symbol <code>nValue1</code> refers to one variable. Outside of the inner scope the symbol <code>nValue1</code> refers to a different variable.</p>

<p>Even inside the inner scope, the outer scope's <code>nValue1</code> can be modified (through a pointer, or some equivalent mechanism). When the inner scope exist, <code>nValue1</code> isn't ""remembered"" to have the same value as it did before the scope, but whatever value was updated, indirectly, while the inner scope was in effect.</p>
",2
40537955,40537358,0,"<p>Just as an <strong>addition to Sam Varshavchiks correct answer</strong>, because of your comment on it. So if you mean, you spare a variable in your case, because you reuse the name, it is not the case. I'll try to illustrate for you, how equivalent code but without reusing the name of a variable in an inner scope (which is also known as ""shadowing"") would look like:</p>

<pre><code>int nValue1 = 12, nTotal =0;
nTotal += nValue1;
{
    int nValue2 = 14;
    nTotal += nValue2;
}
nTotal += nValue1;
</code></pre>

<p>if you put it into a </p>

<pre><code>int main() {
 // place the relevant code snipped here
}
</code></pre>

<p>and look at the generated assembler code, you will see the same output for both cases:</p>

<pre><code>    push    rbp
    mov     rbp, rsp
    mov     DWORD PTR [rbp-4], 12
    mov     DWORD PTR [rbp-8], 0
    mov     eax, DWORD PTR [rbp-4]
    add     DWORD PTR [rbp-8], eax
    mov     DWORD PTR [rbp-12], 14
    mov     eax, DWORD PTR [rbp-12]
    add     DWORD PTR [rbp-8], eax
    mov     eax, DWORD PTR [rbp-4]
    add     DWORD PTR [rbp-8], eax
    mov     eax, 0
    pop     rbp
    ret
</code></pre>

<p>You can verify this with the Compiler Explorer: </p>

<p>Your code using <code>nValue1</code>: <a href=""https://godbolt.org/g/80YlDB"" rel=""nofollow noreferrer"">Your code + assembler</a></p>

<p>My equivalent using <code>nValue2</code>: <a href=""https://godbolt.org/g/jksn2e"" rel=""nofollow noreferrer"">My code + assembler</a></p>
",0
37075434,37074490,1,"<p>let's divide the problem into segments:
a) find the minimal x value 
b) once founded and you got the location in the vector run in a modulu vector's size</p>

<p>code: (and not with too much emphasis on proper style)</p>

<pre><code>vector&lt;pair&lt;double, double&gt;&gt; vec = { {319.402,213.309} ,{184.437,312.164 },{54.9806,183.36} ,{187.458,95.2848} }
, vec2;

double minX = vec[0].first;
int minIndx = 0;
for (int i = 1; i &lt; static_cast&lt;int&gt;(vec.size()); i++)
    if (vec[i].first &lt; minX)
    {
        minIndx = i; //saves the index
        minX = vec[i].first; //saves the minX value
    }

vec2.emplace_back(vec[minIndx]); //put it in the result vector (vec2)


//emplace everything else to the result vector modulu vec.size()
for (int i = minIndx + 1; i != minIndx; i = (i + 1) % static_cast&lt;int&gt;(vec.size()))
    vec2.emplace_back(vec[i]);

//prints the result
for (const auto &amp;v: vec2)
    cout &lt;&lt; ""("" &lt;&lt;v.first &lt;&lt; "", "" &lt;&lt;v.second &lt;&lt; "")\n"";
</code></pre>
",5
41654626,41654566,2,"<p>Every time you call <code>q.dequeue()</code> then obviously <code>q.size()</code> will decrease, and you will only ever output around half of your queue elements. So you probably want to cache the initial size before you start iterating, e.g.</p>

<pre><code>const size_t n = q.size();
for (size_t i = 0; i &lt; n; ++i)
    std::cout &lt;&lt; q.dequeue() &lt;&lt; std::endl;
</code></pre>
",0
41654740,41654566,2,"<p>Similar in logic to Paul R's answer above. The items in the queue are all being dequeued, so loop until the queue is empty.</p>

<pre><code>while (q.size()) 
{
    std::cout &lt;&lt; q.dequeue() &lt;&lt; std::endl;
}
</code></pre>
",0
37243216,37243115,6,"<p>If you always want one figure after the decimal point regardless of how many digits the answer is, use <code>std::fixed</code> along with <code>std::setprecision</code></p>

<pre><code>#include &lt;iomanip&gt;

std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; g;
</code></pre>
",0
37243157,37243115,4,"<p>One way: </p>

<pre><code>#include &lt;iomanip&gt;
//...
std::cout &lt;&lt; std::setprecision(2) &lt;&lt; g;
</code></pre>

<p>This sets the precision of the output to 2 significant figures.</p>

<p>Edit: as the other answer points out, prepend <code>std::setprecision</code> with <code>std::fixed</code>.</p>
",1
34933734,34924174,0,"<p>First off, there is no reason for flight number and gate number to be strings. they are just numbers. Translate the string from the file to an int. If you can't use stl, you'll just have to keep the datetime as a string I guess :(</p>

<p>Break this into pieces. You need three different comparisons: numeric, datetime, and lexicographical, depending on what you are sorting by.</p>

<p>A numeric sort is just number comparison: <code>if( a &lt; b )</code>. </p>

<p>A lexicographical sort is relatively simple. Characters are just 8 bit numbers that map to a glyph stored somewhere. You can compare the strings character by character the same way you compare ints. Once you find characters that differ from each other, you can compare the chars and determine which is greater.</p>

<p>Datetime will be tricky without stl. You'll have to find a way to parse the string into something you can compare. Google ways to parse that string.</p>

<p>The only thing left is your sorting algorithm. Visit the Wikipedia pages on Insertion sort, Merge sort, Quicksort, and Selection sort. They give detailed descriptions on how each algorithm works, and in most cases pseudocode on their implementation.</p>

<p>There's really not much else to say on this subject.</p>
",2
44353430,44353248,0,"<p>Your code doesn't compile, but I'll consider it as pseudo code and answer your question specifically.</p>

<p>Basically, your stopping condition would be when <code>low</code> is equal to <code>size</code>, and you have only one number remaining. At this point you have two options:</p>

<ul>
<li>The user will enter 'y', then this is the correct guess and you can return from the function.</li>
<li>The user will enter 'l' or 'h'. In this case, the user is cheating since only one number is remaining and it's not the correct one.</li>
</ul>

<p>I'd suggest moving the checking for 'y' to the beginning, before the other two checks for 'h' and 'l', then write something as the following:</p>

<pre><code>if (answer == ""y"" || answer == ""Y"")
{
    cout &lt;&lt; ""Told ya i'd guess it!\n"";
}

else if (low == size)
{
    cout &lt;&lt; ""Not fair! You're cheating.\n"";
   // exit the routine.
}

else if (answer == ""l"" || answer == ""L"")
{
    low = median;
    guessingGame(size, low);
}
else if (answer == ""h"" || answer == ""H"")
{
    size = median;
    guessingGame(size, low);
}
</code></pre>

<p>If the user doesn't answer with 'y', and you have only one number left, then they're cheating.</p>

<p>Again, your code has problems, but this is just an idea of how the stopping condition would be.</p>
",2
39138577,39138330,1,"<p>I changed your ""y/n"" while loop to this :</p>

<pre><code>cout &lt;&lt; ""ready to play? (y/n to play.): "" &lt;&lt; endl;
cin &gt;&gt; ready;
if (ready != ""y"")
{
   cout &lt;&lt; ""O.K. Goodbye!"" &lt;&lt; endl;
return 0;

}
 else
    cout &lt;&lt; ""OK!"" &lt;&lt; endl;
</code></pre>

<p>I am also giving you a while version if you want to force the user to press either 'y' or 'n' to go further :</p>

<pre><code>        cout &lt;&lt; ""ready to play? (y/n to play.): "" &lt;&lt; endl;
        cin &gt;&gt; ready;
while ( ready != 'y' &amp;&amp; ready != 'n')
{
cout &lt;&lt; ""Only answer with 'y' or 'n' ""&lt;&lt; endl;
cin &gt;&gt; ready;
}
</code></pre>

<p>and the game loop where user guesses to this :</p>

<pre><code>int guesses_left = 10;
cout &lt;&lt; ""please try to guess a number between 1 and 125, you currently have: "" &lt;&lt; guesses_left &lt;&lt; "" guesses left"" &lt;&lt; endl;
while (guesses_left != 0)
{
                cin &gt;&gt; userinput;
                if (userinput &gt; number){
                    cout &lt;&lt; ""Sorry your guess is too high, please guess again."";
                    cout &lt;&lt; endl;
            --guesses_left;
                    cout &lt;&lt; ""you now have: "" &lt;&lt; guesses_left &lt;&lt; "" guesses left. Please choose again."";

                }
                else if (userinput &lt; number){
                    cout &lt;&lt; ""Soory, your guess is too low, please guess again."" &lt;&lt; endl;
            --guesses_left;
                    cout &lt;&lt; ""You now have: "" &lt;&lt; guesses_left &lt;&lt; "" guesses left. Please choose again."";

                }
                else if (userinput == number){
                    cout &lt;&lt; ""congrats you won :)... Here have a prize as you won with: "" &lt;&lt; guesses_left &lt;&lt; "" guesses left."" &lt;&lt; endl &lt;&lt; ""no but seriously WELL DONE!!! :D"";
                    system(""cd C:\Program Files\Internet Explorer"");
                    system(""iexplore https://media.property118.com/wp-content/uploads/2013/12/Best-Property-Forum.jpg"");
                    return 0;
            }
}
cout &lt;&lt; ""You have used up all your guesses."" &lt;&lt; endl;
return 0;
</code></pre>
",4
35207869,35207306,0,"<p>Try using fstream.h library. e.g; </p>

<pre><code>#include&lt;iostream&gt;
//fstream is the library from which we use file input and output resources.
#include&lt;fstream&gt;

using namespace std;

/*
There are three basic operations, you already know about
1. LOAD | we load any thing on which we are supposed to work, into MAIN     MEMORY i.e. RAM
2. PROCESS | any task we are supposed to do on it.
3. STORE | write data back onto STORAGE i.e. HARD DISK
*/

int main()
{
    //*************************INPUT FORM FILE****************************//
    //to get data from file
    //file input variable declaration
    ifstream fin;

    //load the file into memory
    //file.txt must exists in same folder where you placed your cpp file.
    fin.open(""file.txt"");

    char x[100];

    //tp get data from file.
    fin &gt;&gt; x;
    cout &lt;&lt; ""Data from file.txt is :: "" &lt;&lt; x &lt;&lt; endl;

    //now as we are done taking input from file.
    //so now we must close the open file.
    fin.close();
    //*************************INPUT FORM FILE****************************//


    cout &lt;&lt; ""\n\n\n"";

    //*************************SAVING DATA INTO FILE | FILE REPACE CODE****************************//
    //to enter a data in a file
    ofstream fout;

    //load the file into memory
    //file.txt must exists in same folder where you placed your cpp file.
    // if file isn;t available then fout will create the file with specified name
    fout.open(""file.txt"");

    char str[100];
    //to get data from console.
    cout &lt;&lt; ""Enter some string to write in file.txt (file replace mode)"" &lt;&lt; endl;
    cin &gt;&gt;str;

    cout &lt;&lt; ""Writing data into file now."" &lt;&lt; endl;
    fout &lt;&lt; str;

    //now as we are done saving data into file.
    //so now we must close the opened file.
    fout.close();
    //*************************SAVING DATA INTO FILE | FILE REPACE CODE****************************//

     /*
     remember code o fout given above will replace data
     */


    cout &lt;&lt; ""\n\n\n"";

     ////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////

    //*************************SAVING DATA INTO FILE | FILE APPEND CODE****************************//
    //to enter a data in a file
    ofstream fout2;

    //load the file into memory
    //file.txt must exists in same folder where you placed your cpp file.
    // if file isn;t available then fout2 will create the file with specified name
    fout2.open(""file.txt"", ios::app);

    //to get data from console.
    cout &lt;&lt; ""Enter some string to write in file.txt (Append mode)"" &lt;&lt; endl;
    cin &gt;&gt; str;
    cout &lt;&lt; ""Data from console. is "" &lt;&lt; str &lt;&lt; endl;

    cout &lt;&lt; ""Writing data into file now."" &lt;&lt; endl;
    fout2 &lt;&lt; str;



    cout &lt;&lt; ""\n\n\n"";
    cout &lt;&lt; ""\n\n\n"";
    //now as we are done saving data into file.
    //so now we must close the opened file.
    fout2.close();

    fout2.open(""file.txt"", ios::app);

    //to get data from console.
    cout &lt;&lt; ""Enter some string to write in file.txt *(append mode)"" &lt;&lt; endl;
    cin &gt;&gt; str;
    cout &lt;&lt; ""Data from console. is "" &lt;&lt; str &lt;&lt; endl;

    cout &lt;&lt; ""Writing data into file now."" &lt;&lt; endl;
    fout2 &lt;&lt; str;

    //now as we are done saving data into file.
    //so now we must close the opened file.
    fout2.close();
    //*************************SAVING DATA INTO FILE | FILE APPEND CODE****************************//

    return 0;
}
//This code is actually written by a friend of mine , Ammar Tahir :) 
</code></pre>
",0
35215265,35215248,7,"<p>Change <code>if (1 &lt;= n &lt;= 9)</code> to <code>if (n&gt;= 1 &amp;&amp; n&lt;=9)</code></p>
",3
35215290,35215248,5,"<p><code>if (1 &lt;= n &lt;= 9)</code> doesn't do what you think it does. It's evaluated as ((1 &lt;= n) &lt;= 9). &lt;= returns a Boolean, so you're checking if 'true' or 'false' is less than 9.</p>

<p>You want to use the 'and' operator, &amp;&amp;.</p>
",0
35215341,35215248,1,"<p><code>if (1 &lt;= n &lt;= 9) {</code> should be <code>if (1 &lt;= n &amp;&amp; n &lt;= 9) {</code></p>

<p>You could also arrive at the solution by using the <code>switch</code> statement:</p>

<pre><code>//Problem states n is a positive integer, so no need to check if n &lt; 1
switch(n)
{
  case 1: cout &lt;&lt; ""one"" &lt;&lt; endl; break;
  case 2: cout &lt;&lt; ""two"" &lt;&lt; endl; break;
  //etc...
  case 9: cout &lt;&lt; ""nine"" &lt;&lt; endl; break;
  default: cout &lt;&lt; ""Greater than 9"" &lt;&lt; endl;
}
</code></pre>

<p>It does the same thing, but it looks cleaner in my opinion.</p>
",0
35219323,35219028,0,"<p>As far as the language itself is concerned, all <code>cout &lt;&lt; ends</code> does is write <code>\0</code> to the stream. It does <em>not</em> close the stream or cause things to be unexpectedly re-ordered. For the avoidance of any doubt, in your case, the language guarantees that <code>""Hi!""</code> will be be buffered <em>before</em> <code>\0</code> and that is buffered <em>before</em> <code>""1234""</code>.</p>

<p>My understanding is that a terminal <em>ought</em> to silently ignore <code>\0</code>. (It should regard it as an NOP, i.e. no-operation, instruction), but some terminals interpret it, in error, as a space.</p>

<p>That appears to be happening in your case.</p>
",1
35221572,35221404,1,"<p><code>cout</code> is being helpful here: if the <code>double</code> value is a whole number, then it, by default, does not display a decimal separator followed by an arbitrary number of zeros.</p>

<p>If you <em>want</em> to display as many numbers as the precision that your particular <code>double</code> on your platform has, then use something on the lines of</p>

<pre><code>cout.precision(std::numeric_limits&lt;double&gt;::max_digits10);
cout &lt;&lt; fixed &lt;&lt; x &lt;&lt; endl;
</code></pre>
",0
35221642,35221404,0,"<p>Floating point numbers with no digits after the floating point are printed as integers by default.</p>

<p>To always show the floating point, use <code>setiosflags(ios::showpoint)</code>.</p>

<p>You can combine that with <code>fixed</code> and <code>setprecision(n)</code> I/O flags to limit how many digits to print after the floating point. For example:</p>

<pre><code>double d = 5.0;
cout &lt;&lt; setiosflags(ios::showpoint) &lt;&lt; d &lt;&lt; endl; // prints 5.00000
cout &lt;&lt; setiosflags(ios::showpoint) &lt;&lt; fixed &lt;&lt; setprecision(1)
     &lt;&lt; d &lt;&lt; endl; // prints 5.0
</code></pre>
",0
35236466,35236457,3,"<p>You missed the initialisation of  the variables.  Local variables are not initialised to 0 if you don't tell so. </p>

<p>This means that the starting value can be any unpredicatable value, which explains that you find weird numbers.   </p>

<p>Try:  </p>

<pre><code>int input=0, vcoff=0, vtea=0, vcoke=0, voj=0, personNumber = 1;
</code></pre>
",1
35236474,35236457,1,"<p>Instead of <code>int input, vcoff, vtea, vcoke, voj, personNumber = 1;</code>
Do <code>int input = 0, vcoff = 0, vtea = 0, vcoke = 0, voj = 0, personNumber = 1;</code> to initialise the variables.</p>
",1
35244377,35244342,9,"<pre><code>class Someotherclass; that has not been defined yet
class HelloWorld
{
    Someotherclass* my_pointer;
};

or alternative:

class HelloWorld
{
    class Someotherclass* my_pointer;
};
</code></pre>

<p>The first one is obviously the correct if you have multiple pointers (or references) to such class that has not been defined yet.</p>

<p>The second is better? (i don't know) if you only need to do it once, otherwise doing </p>

<pre><code>class HelloWorld
{
    class Someotherclass* my_pointer;
    class Someotherclass* my_pointer2;
    class Someotherclass* my_pointer3;

    void func(class Someotherclass* my_pointer, class Someotherclass&amp; my_ref);
};
</code></pre>

<p>may not be the best.</p>
",2
35288947,35288786,0,"<p>You use <code>Remaining[0]</code> and <code>Remaining[i+1]</code> specially, which probably means that you need one extra element of that array.</p>

<p>Otherwise the <code>[i+1]</code> will be out of bounds during the last turn in the loop.</p>
",0
35288961,35288786,0,"<p>well, the following line tries to access out of range:</p>

<pre><code>Remaining[i+1] = Remaining[i] - Principal[i];
</code></pre>

<p>try this:</p>

<pre><code>if (i + 1 &lt; payments)
    Remaining[i+1] = Remaining[i] - Principal[i];
</code></pre>
",0
35295159,35295032,4,"<p>Use <code>std::sqrt</code> to compute the square root.</p>

<p>Given <code>mass</code> and <code>energy</code> as numeric types, you can use use <code>std::sqrt(2.0 * energy / mass)</code> to compute the speed. I take care to write <code>2.0</code> to force the floating point overload of <code>std::sqrt</code> to be used, and to ensure that the division is <strong>not</strong> an integral one.</p>

<p>Take care that <code>mass</code> is not zero, or negative, else you'll get a NaN on a platform that uses IEEE754 floating point types.</p>
",0
35297706,35295032,-1,"<p>First include header file math.h</p>

<p>And then write the formula as 
int a = (2*k)/m;
V=sqrt (a);</p>

<p>Here sqrt() function is used for square root in above example it is square root of a</p>
",0
41403626,41403606,2,"<pre><code>if (choice = 'A' )
</code></pre>

<p><code>=</code> is the assignment operator, which assigns <code>'A'</code> to <code>choice</code>.</p>

<p>That's probably not what you want. You probably want to compare <code>choice</code> to <code>'A'</code>. Equality comparison uses the <code>==</code> operator:</p>

<pre><code>if (choice == 'A')
</code></pre>
",0
41403629,41403606,1,"<p>The problem is that in your if statements you are using '=', and it should be '=='</p>

<p>For example:</p>

<pre><code>if (choice = 'A')
</code></pre>

<p>Should be</p>

<pre><code>if (choice == 'A')
</code></pre>
",1
40968080,40967459,0,"<p>If I understand correctly your input file is in below format: 
 @  </p>

<p>And based upon the symbol you want to call appropriate function by passing value of length.</p>

<p>You can achieve this by parsing the line that you read from file:</p>

<pre><code>const char s[2] = "" "";// assuming the tokens in line are space separated
while (getline (myfile,line))
{
    cout &lt;&lt; line &lt;&lt; '\n';
    char *token;
    /* get the first token */
    token = strtok(line, s); // this will be the symbol token
    switch(token)
    {
        case ""s"" : 
        /* walk through other tokens to get the value of length*/
        while( token != NULL )
        {
           ...
        }
        drawSquare(...);// after reading all tokens in that line call drawSquare function
        break;

        ... //similarly write cases for other functions based on symbol value
    }
}
</code></pre>
",0
36667331,36667248,0,"<p>Since you have char as a data type it reads in the first two letters of what you wrote in. (In this case 1 and D) and saves them in the two different arrays. try using string instead.</p>
",0
36667497,36667248,-1,"<p>The problem is in the way you take input ,you are using array of CHAR which can take only one value at a time so when you type 2 digit character it actually store the 2nd digit in 2nd array (i.e. hex2[0]).try FF it will give you  000000001E (same as F+F). To make it correct you should add an condition that if an user doesn't type two digit char than set second element in array as null(i.e. hex1[1]='\0') same goes for 2nd input hope it help u.</p>
",0
39106171,39100377,1,"<p>It is not a division actually</p>

<p>float fmod (float numer, float denom);
Returns the floating-point remainder of numer/denom.</p>

<p>In your case remainder is 1.</p>
",0
36626442,36626213,1,"<p>Variant with <code>Line()</code> will compile. <code>OtherThing</code> constructor accepts lvalue reference, you pass rvalue (temporary object); you can use this temporary <code>Line</code> object in <code>OtherThing</code> constructor. The question is what's type of <code>theLine</code>.</p>

<p>If <code>theLine</code> is <code>const Line&amp;</code> and you refer to <code>theLine</code> after object is constructed, you will invoke undefined behavior. If <code>theLine</code> is just <code>Line</code>, you call copy constructor which should be OK.</p>
",3
36834219,36833639,2,"<p>When you read using <code>&gt;&gt;</code>, separation between the values it reads occurs only at whitespace by default. So you can't write <code>textfile &gt;&gt; key &gt;&gt; value</code> and expect to get comma separated strings in <code>key</code> &amp; <code>value</code>. Instead, read a key value pair as a single string and then split it.</p>

<pre><code>#include &lt;sstream&gt;
...
string keyValuePair, key, value;
while (textfile &gt;&gt; keyValuePair) {
    istringstream myStream (keyValuePair);
    getline(myStream, key, ',');
    getline(myStream, value);
    myMap[stoi(key)] = value;
}
</code></pre>
",2
36834399,36833639,1,"<blockquote>
  <p>If there are multiple keys the how to get the value of first key e.g key = 90, value == ""hello"" &amp; key = 90, value = world. I need output of very first key. </p>
</blockquote>

<p>Keys in a map must be unique. Now you just overwrite values in the map, so it holds the last read value for each key. You should check key presence and just don't write a new value if the key is already present in the map, or you can use map of vectors:</p>

<pre><code>while (...) {
    if (!myMap.count(key)) {
        myMap[key] = value;
    }
}
</code></pre>

<p>or</p>

<pre><code>std::map&lt;int, std::vector&lt;std::string&gt;&gt; myMap;
...
while (...) {
    if (!myMap.count(key)) {
        myMap[key] = {};
    }
    myMap[key].push_back(value);
}
</code></pre>
",0
36834542,36833639,0,"<p>Do not forget to consume ',' unless you don't want it in your next token.
A quickfix:</p>

<pre><code>int key;
char comma;
string value;

while (textfile &gt;&gt; key &gt;&gt; comma &gt;&gt; value)
</code></pre>
",2
36834660,36833639,1,"<blockquote>
  <p>Please help me to read map without "","" from the file.</p>
</blockquote>

<p>You can do that by first reading a string up to the comma using <code>getline</code> and converting it to <code>int</code>.</p>

<pre><code>getline(textfile,key,',');//read a line upto a comma from the file
int ikey=atoi(key.c_str());//convert to int
</code></pre>

<blockquote>
  <p>If there are multiple keys the how to get the value of first key e.g
  key = 90, value == ""hello"" &amp; key = 90, value = world. I need output of
  very first key.</p>
</blockquote>

<p>Use the <code>find</code> function to get the value of the first element with the given key.</p>

<pre><code>myMap.find(ikey)-&gt;second
</code></pre>

<blockquote>
  <p>how to traverse the output to the map again.</p>
</blockquote>

<p>You can uses the maps iterator in a for loop to do that.</p>

<p>so you may do something like this:</p>

<pre><code>#include &lt;string&gt;
#include &lt;fstream&gt;

....

ifstream textfile(""your file name"");
multimap&lt;int,string&gt; myMap;//key value can be duplicate here
typedef pair &lt;int, string&gt; IntStr_Pair;//this will be used to insert key/value pairs to the map
int ikey;
string key,value;

if(textfile)
{//file opened
    while (!textfile.eof())
    {
        getline(textfile,key,',');//read the next line upto a comma from the file, which would be the next key
        textfile&gt;&gt;value;//read the next value from the file

        ikey=atoi(key.c_str());//convert the key to integer

        myMap.insert(IntStr_Pair(ikey,value));//insert into map
    }
}

multimap&lt;int,string&gt;::iterator it;
for(it=myMap.begin();it!=myMap.end();it++)
    cout&lt;&lt;it-&gt;first&lt;&lt;"".......""&lt;&lt;it-&gt;second&lt;&lt;endl;//display the key/value pair
</code></pre>

<p>To get the first value of a specific key,say 90 in your case, you could do:</p>

<pre><code>myMap.find(90)-&gt;second
</code></pre>

<p>To get the values of all elements with the given key, you can use <a href=""http://en.cppreference.com/w/cpp/container/multimap/equal_range"" rel=""nofollow""><code>multimap::equal_range</code></a> function and do something like this(this is somewhat similar to using <code>lower_bound</code> and <code>upper_bound</code> function):</p>

<pre><code>typedef pair&lt;multimap&lt;int,string&gt;::iterator,multimap&lt;int,string&gt;::iterator&gt; itPair;//iterator pair

itPair range=test.equal_range(90);//get the range of all elements with the given key(90 in this case)

for( ; range.first!=range.second ; range.first++)//iterate through the range to display the elements
    cout&lt;&lt;range.first-&gt;first&lt;&lt;"".....""&lt;&lt;range.first-&gt;second&lt;&lt;endl;//display key/value pairs
</code></pre>
",7
42559301,42559023,0,"<p>Since you have already defined your bounds or threshold for accepting a value, why not just write</p>

<pre><code>if ( val &gt; 2-1e-10 &amp;&amp; val &lt; 2+1e-10 ) {}
</code></pre>
",0
42559556,42559023,1,"<p>Just use a predicate:</p>

<pre><code>std::count_if(
    begin(array),
    end(array),
    [](double v) { return std::abs(v - 2.0) &lt;= 1e-10; }
);
</code></pre>
",0
37159332,37159008,2,"<p>This code has a number of problems.</p>

<p>The ""close before read"" problem is that, in <code>main</code>, you close the read end of the pipe <em>before</em> the fork.  That means the child process doesn't have a valid file descriptor to read from.  It also means the write (in the main process) is quite likely to go wrong, because there is no way to read the data out of the pipe.</p>

<p>The solution is to move the call to <code>fork</code> much higher, and put the code which writes to the pipe inside the <code>if (child1 &gt; 0)</code> test (before the wait).</p>

<p>So main will look like:</p>

<pre><code>int main()
{
    int pfd[2]; // file disriptors controlling the pipe ends
    pipe(pfd); //create pipe.

    const int child1 = fork();

    if ( child1 &gt; 0 ) //parent process.
    {
        close ( pfd[0] ); // close read of pipe. Only do this once 
                          // - not in the while loop.
        ifstream myfile;
        myfile.open(""Things.txt"");
        string line;

        while ( !myfile.eof() )
        {
            getline(myfile,line);
            cout &lt;&lt; line &lt;&lt; endl;

            const char * const cstr = line.c_str();

            write ( pfd[1] , cstr , line.length()+1 ); 
        }

        myfile.close();
    }
    else if ( child1 == 0 ) //Child 1 process.
    {
        char words[10];
        cout &lt;&lt; ""hello""&lt;&lt;endl;
        close ( pfd[1] ); //close write pipe1.
        read ( pfd[0] , words , sizeof(words)); //read - pipe1.
        string Str = count( words , strlen(words)+1 );//call function count to calculate.
        cout &lt;&lt; Str &lt;&lt; ""****""&lt;&lt; endl;


        int pfd2[2]; //file descriptors controlling the pipe ends.
        pipe(pfd2);  //create pipe 2 .

        int child2 = fork();

        if ( child2 &gt; 0 )//parent process.
        {
            wait(NULL);

            //close ( pfd2[0] ); //close read of pipe 2. 
            //write ( pfd2[1] , ,  )

        }
        else if ( child2 == 0 )//child 2 process.
        {
            //close ( pfd2[1] ); //close write pipe1.
            //read ( pfd2[0] ,  ,  ); 

            exit(0);
        }
        else
        { cout &lt;&lt; ""No Child 2 process! Error in creation"" &lt;&lt; endl; }


        exit(0);
     } 
     else
     { cout &lt;&lt; ""No Child 1 process! Error in creation"" &lt;&lt; endl; }


     return 0 ;
}
</code></pre>

<p>In addition to that problem, you use <code>strlen(word)</code>, but you never write a terminating <code>'\0'</code> after the string.  A better way would be:</p>

<pre><code> size_t wordlen;
 ...
                  wordlen = i;
                  for ( int j=i-1 ; j &gt;= 0 ; j-- )
                      { word[j] = C[j]; } //save the word before the space.
 ...
          for ( size_t z=0 ; z &lt; wordlen; z++ )
          {
              if ( word[z] == ch )
              { counter++ ; }
          }
</code></pre>

<p>You will notice I have used <code>size_t</code> rather than <code>int</code>.  You will find that you get fewer warnings about signed/unsigned comparisons if you do that.  Most index operators return <code>size_t</code>, as does <code>strlen</code>.</p>

<p>Final comment: Your actual problem would have been a lot more obvious if you had simplified <code>count</code> to <code>return ""a 1"";</code> - this is why we ask for a <em>minimal</em> example.</p>
",2
41926171,41926089,0,"<p>Add a boolean and set it to true after printing.</p>

<pre><code>void westeros::display(Kingdom total[], int count, char m_name[])
{
    cout &lt;&lt; ""Searching for kingdom Mordor in Westeros"" &lt;&lt; endl;
    cout &lt;&lt; ""------------------------------"" &lt;&lt; endl;
    bool hasPrinted = false;
    for (int i = 0; i &lt; count; ++i)
    {
        if (total[i].m_name != m_name &amp;&amp; !hasPrinted)
        {
            cout &lt;&lt; m_name &lt;&lt; "" is not a part of Westeros"" &lt;&lt; endl;
            hasPrinted = true;
        }
    }
}
</code></pre>
",3
36241500,36241179,0,"<p>A floating point exception is reported not only for floating-point errors, but also for an integer division by 0, including taking the modulus with respect to 0 (as ¦Ð?¦Í¦Ó¦Á-?¦Å? says in the first comment). Your <code>i</code> loop does iterate down to zero. Once this happens -- i.e. when the <code>break</code> statement didn't trigger for previous values of <code>i</code> -- you'll see the floating-point exception.</p>
",1
36247043,36246937,3,"<p>You cannot use forward declaration in this case. You should include the header file containing the full class definition. class MACAddress {...}</p>

<p>Forward declaration can be used only for pointers or references. Here is a more complete answer - <a href=""https://stackoverflow.com/questions/553682/when-can-i-use-a-forward-declaration"">When can I use a forward declaration?</a></p>
",7
36734456,36734261,0,"<p>As R Sahu said </p>

<blockquote>
  <p>Just use <code>insertion_sort(ch);</code></p>
</blockquote>

<p>this is an answer to your question what I want to add is that it is unnecessary to write return in your function so you may omit it. </p>

<p>Remember that the name of an array is an address to a first element of an array. </p>
",0
40574940,40574851,2,"<ol>
<li><code>char name[10];</code>:

<ol>
<li><code>10</code> characters is too short for a name.</li>
<li><code>char</code> assumes names are not outside ASCII or UTF-8, and it doesn't look like you're using a Unicode library.</li>
<li>Fixed-sized arrays for storing strings is not keeping with idiomatic C++.</li>
<li>Solution: use <code>std::string</code> or <code>std::wstring</code> - and use a Unicode library!</li>
</ol></li>
<li><code>struct student s[10]</code> 

<ol>
<li>This is not idiomatic C++. The <code>struct</code> keyword is unnecessary. Just <code>student s[10];</code> is sufficient.</li>
<li>Again, avoid fixed-sized arrays unless you know for certain you will be using 10 records. Use <code>std::vector&lt;student&gt;</code> instead.</li>
<li>You don't initialize the array, so the data-members will contain undefined/uninitialized data. Use <code>= {0}</code> to zero-out memory and/or define a <code>student</code> constructor.</li>
</ol></li>
<li><code>student s[0].name = ""Jack"";</code>

<ol>
<li>This won't compile. I think you meant to put just <code>s[0].name = ""Jack""</code></li>
<li>The assignment operator <code>=</code> is not defined (by default) for strings. Note that your struct's member type is <code>char</code> whereas a string literal is <code>const char[N]</code>, so in reality you're assigning a pointer (due to Array Decay) to a <code>char</code> member. This is a meaningless operation.</li>
</ol></li>
<li>Your <code>main</code> does not return a value. Use <code>return EXIT_SUCCESS;</code> on success. This is not strictly required, but I personally believe it's good practice to explicitly return a value.</li>
</ol>
",6
45670048,45669320,0,"<p>You want to compute sub-array for middle point, so for the left part, you have to compute from right to left.
For example for</p>

<pre><code>[5, -42, 2, 0, 1, 2, 3]
</code></pre>

<p>parts are</p>

<pre><code>[5, -42, 2, 0] [1, 2, 3]
</code></pre>

<p>computing from left to right for <code>[5, -42, 2, 0]</code> gives <code>5</code><br>
whereas computing from left to right gives <code>2</code></p>

<p>so the sub-array sum containing 0 (<code>mid</code>) is</p>

<pre><code>[2, 0] + [1, 2, 3]
</code></pre>

<p>BTW, your algorithm is not optimal, it could be done in linear complexity.</p>
",1
36558229,36557695,0,"<pre><code>//in heapsort() function
for (i = size; i &gt;= 2; i--)
{
      swap(array[i], array[1]);
      heapify(array, 1, (i - 1));
}

//in buildHeap() function
heapify(array, i, size);
</code></pre>

<p>This code block will give you a problem(assuming you are passing the actual size of the array to the <code>heapsort()</code> function) because when you say <code>array[i]</code>, initially <code>i=size</code> and since array indexing starts from <strong>0</strong>,the maximum index is <strong>size-1</strong> and <code>array[i]</code> gives you a garbage data. So use <code>i=size-1</code> in <code>heapsort()</code> function and <code>heapify(array, i, size-1)</code> in <code>buildHeap()</code> function.</p>
",2
36365121,36365107,3,"<p>Becasue passing by value requires a copy-constructor, and stream objects are specifically made non-copy-constructible. You can pass the stream by reference or move it.</p>
",0
36365130,36365107,3,"<p>You cannot pass streams by value, they do not include copy constructors. You should pass them by reference:</p>

<pre><code>static void copy(byte_array src, int end, stringstream&amp; sb) {
    copy(src, 0, end, sb);
}
</code></pre>

<p>[edit]</p>

<p>examples on how you can pass your stream to function in order to modify it:</p>

<p><a href=""http://coliru.stacked-crooked.com/a/84e78bdf99575eb4"" rel=""nofollow"">http://coliru.stacked-crooked.com/a/84e78bdf99575eb4</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iterator&gt;

// By reference
static void copy1(const char* src, int end, std::stringstream&amp; sb) {
    std::copy(src, src + end, std::ostream_iterator&lt;char&gt;(sb));
}

// By pointer
static void copy2(const char* src, int end, std::stringstream* sb) {
    std::copy(src, src + end, std::ostream_iterator&lt;char&gt;(*sb));
}

// By value, but uses move semantics
static std::stringstream copy3(const char* src, int end, std::stringstream sb) {
    std::copy(src, src + end, std::ostream_iterator&lt;char&gt;(sb));
    return sb;
}

// Actually also by reference but using std::ref
template&lt;typename S&gt;
static void copy4(const char* src, int end, S sb) {
    std::copy(src, src + end, std::ostream_iterator&lt;char&gt;(sb));
}

int main(int argc, char *argv[])
{
    char arr[3] = {'a', 'b', 'c'};
    {
    std::stringstream s;    
    copy1(arr, 3, s);
    std::cout &lt;&lt; s.str() &lt;&lt; std::endl;
    }

    {
    std::stringstream s;
    copy2(arr, 3, &amp;s);
    std::cout &lt;&lt; s.str() &lt;&lt; std::endl;
    }

    {
    std::stringstream s;
    s = copy3(arr, 3, std::move(s));
    std::cout &lt;&lt; s.str() &lt;&lt; std::endl;
    }

    {
    std::stringstream s;
    copy4(arr, 3, std::ref(s));
    std::cout &lt;&lt; s.str() &lt;&lt; std::endl;
    }    

    return 0;
}
</code></pre>
",10
36364658,36362873,0,"<p>Move your <code>const</code> to the 2nd parameter:</p>

<pre><code>void duplicateNodes(SortedList&amp; o, Node const * const copyIter)
</code></pre>

<p>You are modifying the first parameter, so it can't be <code>const</code>.  </p>
",0
36365146,36365074,1,"<p>You need to check the result or status of this statement:</p>

<pre><code>cin &gt;&gt; base;
</code></pre>

<p>It will fail if the input is not a number.  The value of <code>base</code> when the input fails is undefined.</p>

<p>Try this:  </p>

<pre><code>if (cin &gt;&gt; base)
{
  // User input a valid number
}
</code></pre>
",0
36365154,36365074,0,"<p>It's because if you don't enter input that can be parsed as an integer, then the input will not be extracted and will stay in the input buffer so the next iteration of the loop you will read the exact same input as previous iteration and have the same problem all over again.</p>

<p>This is the reason I recommend you use <a href=""http://en.cppreference.com/w/cpp/string/basic_string/getline"" rel=""nofollow""><code>std::getline</code></a> to read the whole line into a string, and then use <a href=""http://en.cppreference.com/w/cpp/io/basic_istringstream"" rel=""nofollow""><code>std::istringstream</code></a> to try and extract/parse the data.</p>

<p>You also need to remember that most input (and output for that matter) operations return a reference to the stream, and that it can be <a href=""http://en.cppreference.com/w/cpp/io/basic_ios/operator_bool"" rel=""nofollow"">used as a boolean expression</a>, so you can use something like</p>

<pre><code>std::istringstream is(someString);
if (is &gt;&gt; base)
{
    // Successfully read and parsed an integer
}
else
{
    // Some error occurred
}
</code></pre>
",0
36365160,36365074,0,"<p>Inputting a letter causes the <code>cin</code> object to get stuck in an error state, failing to read to base regardless of what you feed it afterwards.</p>

<p>You have two options for solving this.</p>

<p>You could either check &amp; clear the error after it occurs, like so:</p>

<pre><code>if(!std::cin) {
    std::cin.clear();
    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(),'\n');
}
</code></pre>

<p>Or you could read entire lines at once, and parse the lines for numbers:</p>

<pre><code>std::string line;
std::getline(std::cin, line);
int value = std::stoi(line);
</code></pre>
",0
36498153,36491610,1,"<p>I'm guessing your question is actually about how to make your class' constructor accept that kind of initializer list.  However, the commentors seem to think you are asking about how to implement a matrix class.</p>

<p>Just in case I'm right about this, here is an example of construction from an initializer list.</p>

<p>But if I'm wrong, keep in mind that this example's implementation of an array is bad and you don't want to use it.  I chose a C-Style static array just because it is simple to set up and people are familiar with how they work.</p>

<p>Also, this initialization will write outside the array's bounds if the list has too many elements, so keep that in mind for your class. </p>

<p>And I also assume you don't care about keeping your constructor constexpr.</p>

<p>So here it is, an example of a constructor accepting a 2-nested initializer list, only that...:</p>

<pre><code>#include &lt;initializer_list&gt;
#include &lt;iostream&gt;

template &lt;typename T, int row_count, int col_count&gt;
class matrix {
    T carray[row_count][col_count];
public:
    matrix(std::initializer_list&lt; std::initializer_list&lt;T&gt; &gt; init_list) {
        int rowidx=0;
        for(const auto&amp; row : init_list) {
            int colidx=0;
            for(const auto&amp; elem : row) {
                carray[rowidx][colidx++] = elem;
            }
            ++rowidx;
        }
    }

    void Print() const {
        for(const auto&amp; row : carray) {
            for(const T&amp; elem : row) {
                std::cout &lt;&lt; elem &lt;&lt; ""  "";
            }
            std::cout &lt;&lt; '\n';
        }
    }
};


int main() {
    matrix&lt;int, 2, 2&gt; tonpai = { { 1,2 }, { 3,4 } };
    tonpai.Print();
}
</code></pre>
",4
41204549,41202097,1,"<p>I think the first thing you ought to do is switch from storing your points as a <code>std::vector&lt;int&gt;</code> to a <em>class</em> with fixed-size storage; using a <code>std::vector</code> to always store a fixed number of values that is known at compile-time is overkill and introduces a significant per-point memory overhead with no compensating benefit.</p>

<p>Given that, here's how I would do it:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;vector&gt;

class Point
{
public:
   Point() : x(0), y(0), z(0) {/* empty */}
   Point(int xa, int ya, int za) : x(xa), y(ya), z(za) {/* empty */}

   bool operator &lt; (const Point &amp; rhs) const
   {
      return (x &lt; rhs.x) ||
             ((x == rhs.x) &amp;&amp; (y &lt; rhs.y)) ||
             ((x == rhs.x) &amp;&amp; (y == rhs.y) &amp;&amp; (z &lt; rhs.z));
   }

   bool operator == (const Point &amp; rhs) const
   {
      return (x == rhs.x) &amp;&amp; (y == rhs.y) &amp;&amp; (z == rhs.z);
   }

   int x, y, z;
};


int main(int, char **)
{
   std::map&lt;Point, std::vector&lt;int&gt; &gt; some_points;
   some_points[Point(1,2,3)] = std::vector&lt;int&gt;();
   some_points[Point(3,2,1)] = std::vector&lt;int&gt;();
   some_points[Point(1,3,2)] = std::vector&lt;int&gt;();

   for (std::map&lt;Point, std::vector&lt;int&gt; &gt;::iterator iter = some_points.begin(); iter != some_points.end(); iter++)
   {
      const Point &amp; key = iter-&gt;first;
      const std::vector&lt;int&gt; &amp; val = iter-&gt;second;
      std::cout &lt;&lt; ""x="" &lt;&lt; key.x &lt;&lt; "" y="" &lt;&lt; key.y &lt;&lt; "" z="" &lt;&lt; key.z &lt;&lt; "" --&gt; vector with "" &lt;&lt; val.size() &lt;&lt; "" elements"" &lt;&lt; std::endl;
   }

   return 0;
}
</code></pre>
",1
36646648,36646293,2,"<p>C++ will not magically do the math for you, you need to parse input, check for errors and do the calculation. For simple math you can use stream operations, to make it more advances I suggest regexp, for further more advances syntax you need parser <a href=""http://www.boost.org/doc/libs/1_59_0/libs/spirit/repository/example/qi/calc1_sr.cpp"" rel=""nofollow"">http://www.boost.org/doc/libs/1_59_0/libs/spirit/repository/example/qi/calc1_sr.cpp</a>.</p>

<pre><code>std::regex pattern(""(\\d+)\\s*(\\+)\\s*(\\d+)"");
std::string line;
while (std::getline(std::cin, line)) {
  std::smatch sm;
  if (std::regex_match(line, sm, pattern)) {
    int val1 = std::stoi(sm[1]);
    std::string op = sm[2];
    int val2 = std::stoi(sm[3]);
    std::cout &lt;&lt; (val1 + val2) &lt;&lt; ""\n"";
  }
}
</code></pre>
",2
47519075,47519015,1,"<p>You probably mean <code>string&amp; mode</code> as in ""reference to a string"" not <code>&amp;string mode</code> as in ""address of string"". Typical C++ code would have this signature look like:</p>

<pre><code>int BranchSim::readMode(const string&amp; mode);
</code></pre>

<p>Where the implementation follows the same spec.</p>
",2
44747651,44747035,0,"<p>Slight error you made while passing the values inside the function.</p>

<p>You must begin by element k=0 as you have to search by 0th index first, not 1. </p>

<p><strong>Beware</strong> that this will allow you to search for sum starting from <strong>0th index till the end</strong>. That is, in this particular case, <code>7</code> or <code>7+11</code> or <code>7+11+13</code> or <code>7+11+13+24</code>. With the code the OP provides you cannot check something <strong>like</strong>  <code>11+24</code>. </p>

<p>Here: </p>

<ul>
<li>sum is current sum of the elements traversed yet.</li>
<li>k is the index to begin with</li>
<li>tsum is total sum of the array elements</li>
<li>m is the sum of sub array elements to be found</li>
<li>n is the size of the array(or the range you want to check from the kth index).</li>
</ul>

<p>OP also forgot to add return statements before the recursive calls. Also the k>n should be checked early.</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;
bool sum1(int arr[],int sum,int k,int tsum,int m,int n)
{

    if(sum+arr[k]==m)
    {
        return true;
    }
    else if(k&gt;n)
    {
        return false;
    }
    else if(sum+arr[k]+arr[k+1]&lt;=m)
    {
        return sum1(arr,sum+arr[k],k+1,tsum-arr[k],m,n-1);
    }
    else if((sum+tsum-arr[k]&gt;=tsum) &amp;&amp; (sum+arr[k+1]&lt;=tsum))
    {
        return sum1(arr,sum,k+1,tsum-arr[k],m,n);
    }


    return false;
}
int main()
{
    int arr[]={7,11,13,24};
    if(sum1(arr,0,0,55,31,4))
    {
        cout&lt;&lt;1;
    }
    else{
        cout&lt;&lt;0;
    }
}
</code></pre>

<p>You can also manually specify the range to check. Example k=1 and n=4 will add these possibilities:  <code>11+13</code> or <code>11+13+24</code>. But beware, if you change n, also change tsum correspondingly for the range. Example for k=0 and n=3 tsum should be 31.</p>
",4
37116064,37110606,0,"<p>I don't know if it's the problem you're looking for but... it's a problem.</p>

<p>Look at the method <code>Menue::addNewItem()</code></p>

<pre><code>    void addNewtItem(Node&lt;Item&gt;&amp;  nextNode)   {if(_head)    _head-&gt;addNode(nextNode);   else _head=nextNode;}
</code></pre>

<p>I don't know what is an <code>Item</code> but <code>_head</code> is a pointer to a <code>Node&lt;Item&gt;</code>. And <code>Node::addNode()</code> receive a <code>Node&lt;T&gt;</code> (<code>Node&lt;Item&gt;</code>, in this case) pointer. But <code>nextNode</code> is a reference to a <code>Node&lt;Item&gt;</code>, not a pointer to a <code>Node&lt;Item&gt;</code></p>

<p>So, when you write</p>

<pre><code>_head-&gt;addNode(nextNode);
</code></pre>

<p>you're trying to pass a <code>Node&lt;Item&gt;</code> to a method that expect a <strong>pointer</strong> to a <code>Node&lt;Item&gt;</code>; and when you write</p>

<pre><code>_head = nextNode;
</code></pre>

<p>you're trying to assign a <code>Node&lt;Item&gt;</code> to a variable of type <strong>pointer</strong> to a <code>Node&lt;Item&gt;</code>.</p>

<p>Your intention was</p>

<pre><code>_head-&gt;addNode(&amp;nextNode);
_head = &amp; nextNode;
</code></pre>

<p>?</p>
",0
39603272,39602299,0,"<p>This is just a simple warning and you're free to ignore it - it's not an error, so your code compiled fine. It wouldn't have if you passed the <code>-Werror</code> to <code>g++</code>, which turns all warnings into errors.</p>

<p>If you are going to use this variable someday in your code, just keep it or comment it out until you need it. Else, you can remove it safely : That's what the compiler warned you about, it's unused.</p>

<p>To silence out this warning, you can pass <code>-Wno-unused-variable</code> to <code>g++</code>. <code>clang</code> probably will accept this flag as well.</p>

<p>Do note this warning exists for a reason : It can highlight issues you didn't see. I stumbled upon <a href=""https://stackoverflow.com/questions/10340515/wunused-variable-warning"">this</a> question on SO, for example.</p>
",0
39602314,39602299,4,"<p>If the variable is unused, then remove it.</p>
",3
39602340,39602299,2,"<p>I think you can say:</p>

<pre><code>__unused const int m = n*(n-1)/2;
</code></pre>

<p>To suppress the warning.</p>

<p>Or perhaps more correctly:</p>

<pre><code>const int m __attribute__ ((unused)) = n*(n-1)/2;
</code></pre>

<p>See the <a href=""https://gcc.gnu.org/onlinedocs/gcc-3.3/gcc/Variable-Attributes.html"" rel=""nofollow"">documentation</a>.</p>
",0
39602447,39602299,0,"<p>Note:
Why do use the extension "".c"" for a C++ file? It would be more correct to use '.cpp'</p>

<p>Now - here is your answer:</p>

<p>First of all - it is NOT an error - it is a huge difference between an error and a warning. Any warning can be ignored - it is not the same with errors.</p>

<p>It looks like you are not using the constant in your code (you are just declaring it). If this happens, G++ will tell you that you might want to remove it.</p>
",1
37077433,37077354,3,"<p>The problem is that</p>

<pre><code>template&lt;typename T1&gt;
int findElement(T1 field[],T1 element,long int indx);
</code></pre>

<p>Requires <code>field</code> and <code>element</code> to have the same type.  When you call </p>

<pre><code>findElement(arr2,15133,sizeof(arr2)/sizeof(long int));
</code></pre>

<p><code>arr2</code> is a <code>long</code> but <code>15133</code> as a integer literal with type <code>int</code>.  since <code>long</code> and <code>int</code> are not the same type template argument deduction fails and you get a compiler error.  Do note that the compiler so no conversions during template argument deduction.  If the types do not match during that step then the template will not be used.</p>

<p>You can fix it by making <code>15133</code> a <code>long</code> integer literal like</p>

<pre><code>findElement(arr2,15133L,sizeof(arr2)/sizeof(long int));
                      ^ L for long
</code></pre>
",1
37405811,37405519,6,"<p>No... and by the way with <code>memset</code> you don't have a guaranteed constant-time operation either (in most implementation is just very fast but still linear in the number of elements).</p>

<p>If you need to do this kind of operation (addition/subtraction of a constant over a range) on a very huge vector a lot of times and you need to get the final result then you can get O(1) per update using a different algorithm:</p>

<h3>Step 1: convert the data to its ""derivative""</h3>

<p>This mean replacing each element with the difference from previous one.</p>

<pre><code>// O(n) on the size of the vector, but done only once
for (int n=v.size()-1; i&gt;0; i--) {
    v[i] -= v[i-1];
}
</code></pre>

<h3>Step 2: do all the interval operations (each in constant time)</h3>

<p>With this representation adding a constant to a range simply means adding it to the first element and subtracting it from the element past the ending one. In code:</p>

<pre><code>// intervals contains structures with start/stop/value fields
// Operation is O(n) on the **number of intervals**, and does
// not depend on the size of them
for (auto r : intervals) {
    v[r.start] += r.value;
    v[r.stop+1] -= r.value;
}
</code></pre>

<h3>Step 3: Collect the results</h3>

<p>Finally you just need to un-do the initial processing, getting back to the normal values on each cell by integrating. In code:</p>

<pre><code>// O(n) on the size of vector, but done only once
for (int i=1,n=v.size(); i&lt;n; i++) {
    v[i] += v[i-1];
}
</code></pre>

<p>Note that both step 1 and 3 (derivation and integration) can be done in parallel on N cores with perfect efficiency if the size is large enough, even if how this is possible may be not obvious at a first sight (it wasn't for me, at least).</p>
",2
37196987,37196954,4,"<p>This is because <code>std::vector</code> is not a single-argument template. Standard mandates an element type and allocator type arguments for <code>std::vector</code>.</p>

<p>If you are not on legacy C++ and can use variadic templates, you can declare your function like this:</p>

<pre><code>template&lt;typename T, template&lt;typename...&gt; class C&gt;
void print2(C&lt;T&gt;&amp; c);
</code></pre>
",10
37199408,37199303,2,"<p>The compiler looks for <code>iterator</code> on first-phase lookup, which is before the template is ever instantiated. In order to know from which type the class derives, the template must be instantiated (so that <code>Seq&lt;T*&gt;</code> is an actual type). Thus, the compiler never finds <code>iterator</code> in the base class yet.</p>

<p>You can get around this in two easy ways:</p>

<p>A one-off:</p>

<pre><code>typename Seq&lt;T*&gt;::iterator
</code></pre>

<p>A type alias in your derived class:</p>

<pre><code>using iterator = typename Seq&lt;T*&gt;::iterator;
</code></pre>

<p>All of these unambiguously specify to which type <code>iterator</code> belongs, looked up in the second phase of lookup when <code>Seq</code> and <code>T</code> are known. <a href=""https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords"">More on <code>typename</code></a>. </p>

<p>You can do the same for your functions:</p>

<p>A one-off:</p>

<pre><code>Seq&lt;T*&gt;::begin()
this-&gt;begin() // if inside a member function
</code></pre>

<p>A using declaration:</p>

<pre><code>using Seq&lt;T*&gt;::begin;
</code></pre>
",5
37199990,37199303,0,"<p>The book you're using may be out of date. These days c++ has moved in the direction of using free functions for better decoupling.</p>

<p>Example:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;

// an example Gromit
struct Gromit
{
    Gromit(int index) : index(index) {};

    void speak(int i) { std::cout &lt;&lt; name() &lt;&lt; "" speaking "" &lt;&lt; i &lt;&lt; std::endl; }
    void eat(float f) { std::cout &lt;&lt; name() &lt;&lt; "" eating "" &lt;&lt; f &lt;&lt; std::endl; }
    void sleep(char c, double f) { std::cout &lt;&lt; name() &lt;&lt; "" sleeping "" &lt;&lt; c &lt;&lt; "" "" &lt;&lt; f &lt;&lt; std::endl; }
    void sit() { std::cout &lt;&lt; name() &lt;&lt; "" sitting"" &lt;&lt; std::endl; }

private:
    std::string name() const {
        return ""Gromit "" + std::to_string(index);
    }
    int index;
};

// apply some function object to each item in a container    
template&lt;class Container, class F&gt;
void apply(Container&amp; container, F f)
{
    for (const auto&amp; p : container)
    {
        f(p);
    }

}

int main() {
    std::vector&lt;std::unique_ptr&lt;Gromit&gt;&gt; dogs;
    for(int i = 0; i &lt; 5; i++)
        dogs.emplace_back(new Gromit(i));

    using namespace std::placeholders;

    // apply dog.speak(1) to each dog in dogs...        
    apply(dogs, std::bind(&amp;Gromit::speak, _1, 1));

    // dog.eat(2.0f) for each dog in dogs...
    apply(dogs, std::bind(&amp;Gromit::eat, _1, 2.0f));

    // ...etc
    apply(dogs, std::bind(&amp;Gromit::sleep, _1, 'z', 3.0));
    apply(dogs, std::bind(&amp;Gromit::sit, _1));
}
</code></pre>

<p>expected output:</p>

<pre><code>Gromit 0 speaking 1
Gromit 1 speaking 1
Gromit 2 speaking 1
Gromit 3 speaking 1
Gromit 4 speaking 1
Gromit 0 eating 2
Gromit 1 eating 2
Gromit 2 eating 2
Gromit 3 eating 2
Gromit 4 eating 2
Gromit 0 sleeping z 3
Gromit 1 sleeping z 3
Gromit 2 sleeping z 3
Gromit 3 sleeping z 3
Gromit 4 sleeping z 3
Gromit 0 sitting
Gromit 1 sitting
Gromit 2 sitting
Gromit 3 sitting
Gromit 4 sitting
</code></pre>
",0
38988767,38988667,0,"<p>You can check whether <strong>cin</strong> is accepting the space separated string completely, by doing a <strong>cout</strong> instantly after the <strong>cin</strong>. If <strong>cin</strong> is not accepting the space separated string, then try using <strong>getline</strong></p>

<p><strong>Issue resolved:</strong></p>

<p>Use the following:</p>

<pre><code>cout &lt;&lt; ""Enter string to encrypt: "";
scanf("" %[^\n]s"",word);

for (int i=0; word[i]!='\0'; i++)
{
</code></pre>

<p>use </p>

<pre><code>include &lt;cstdio&gt;
</code></pre>

<p>Hope this solves the problem!! I will get back to you with the solution using string..</p>
",3
38988778,38988667,1,"<pre><code>cin &gt;&gt; word;
</code></pre>

<p>will read only the first word and leave the second word in the input stream. After that, the call</p>

<pre><code>cin &gt;&gt; a;
</code></pre>

<p>will result in an error unless the second word starts with a number. Once the program enters a state of error, nothing is read and the program stays in a loop.</p>

<p>To diagnose problems like these, always check the state of the stream after a read operation.</p>

<pre><code>if ( cin &gt;&gt; word )
{
   // Use word
}
else
{
   // Deal with error.
}


if ( cin &gt;&gt; a )
{
   // Use a
}
else
{
   // Deal with error.
}
</code></pre>

<p>To address your real problem, don't use <code>operator&gt;&gt;</code> to read space separated string. Use <code>getline</code> (and use a variable name different from <code>word</code>).</p>

<pre><code>std::string str;
if ( getline(std::cin, str) )
{
   // Use str
}
else
{
   // Deal with error.
}
</code></pre>

<p>However, in order to use <code>getline</code> successfully, you have to make sure that after <code>a</code> is read, you ignore the rest of the line. Otherwise, the rest of the line will be read by <code>getline</code>.</p>

<pre><code>if ( cin &gt;&gt; a )
{
   // Ignore rest of the line
   cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');

   // Use a
}
else
{
   // Deal with error.
}
</code></pre>
",2
38989238,38988667,0,"<p>Replace <code>cin &gt;&gt; word;</code> with <code>getline(cin, word);</code>. It will accept a line as input. Which will resolves your input containing spaces. </p>

<p>As far as infinite loop concern, clear the error bits on the stream <code>cin.clear();</code></p>
",0
37242761,37242721,0,"<p>Same idea as 100   </p>

<pre><code>int r = rand() % 17;
</code></pre>
",0
37768944,37768662,1,"<p>In most cases, A+=B is preferable. As you have pointed out, there would be more register loads in A = A + B vs A+=B. Also of interest might be to read up on <a href=""https://en.wikipedia.org/wiki/Static_single_assignment_form"" rel=""nofollow"">SSA</a>. This is used in compiler optimization, and might help understand how such case is dealt with. As you have said, most of these considerations are taken out of the programmers hands thanks to the compiler, but it is good to be aware of these things. </p>

<p>Another consideration to account for in complex objects is the possible side effects caused by calling getters, and the fallout for calling such getter twice. (Think, A.get() = A.get() + B.get()). This however should be relatively rare, since getters should not have side effects in most cases. </p>
",1
37768695,37768662,4,"<p>The big thing to remember is that C++ have <em>operator overloading</em> which means that te <code>+=</code> operator can mean something completely different from what you expect.</p>

<p>The <code>+=</code> operator only works as add and assign to <em>if</em> the ""destination"" class doesn't have an <code>+=</code> operator defined for it. Operator overloading also means that e.g <code>x++</code> can mean different thing depending on what the class instance of <code>x</code> defines for operator overloads.</p>
",3
37768718,37768662,6,"<p>I would say the reasons aren't quite the same.  My main reason for prefering <code>A += B</code> over <code>A = A + B</code> is conciseness.  <code>A += B</code> clearly states that you want to add B to A.  This is especially true if <code>A</code> is a more complex expression:</p>

<pre><code>node_capacities[std::make_pair(node1,node2)] += edge.capacity;
</code></pre>

<p>I've never found the performance of <code>A += B</code> to be worse than <code>A = A + B</code> either.</p>
",0
45219043,45218826,1,"<p><a href=""https://stackoverflow.com/a/45218888/6594779"">hnefatl</a>'s answer is one way.</p>

<p>You can also use switch case without break statements to check vowel. Something like:</p>

<pre><code>switch(firstChar)
{
case 'a':
case 'e':
case 'i':
case 'o':
case 'u':
case 'A':
case 'E':
case 'I':
case 'O': 
case 'U': cout&lt;&lt;""Vowel"";
}
</code></pre>

<p>On top of that <code>switch-case</code> have many advantages over <code>if-else ladder</code> as stated here <a href=""https://stackoverflow.com/a/1028463/6594779"">https://stackoverflow.com/a/1028463/6594779</a>.</p>
",0
45219048,45218826,1,"<p>Logical operator <code>||</code> combines two boolean expressions, e.g. <code>a==0 || b==1</code>, and returns true if either of the two operands is <code>true</code>. If you pass a single character like <code>'a'</code> as operand, this will be interpreted as <code>true</code>, since the value of <code>'a'</code> is <code>97</code> and <code>97 != 0 =&gt; true</code>. Hence, your expression <code>('a' || 'e' || 'i' || 'o' || 'u' || 'A' || 'E' || 'I' || 'O' || 'U')</code> will always be <code>true</code>, and <code>firstchar == (....)</code> is the same as <code>firstchar == true</code>, which will probably give <code>false</code>.</p>

<p>You could write...</p>

<pre><code>if (firstChar == 'a' || firstChar == 'e' || firstChar == 'i' || ...)
</code></pre>

<p>or...</p>

<pre><code>if (strchr(firstChar, ""aeiouAEIOU"") != NULL)) ...
</code></pre>
",0
45218888,45218826,3,"<p>The <code>||</code> operator needs to be applied to two arguments, like so:</p>

<pre><code>if (firstChar == 'a' || firstChar == 'e' || firstChar == 'i' || ...)
</code></pre>

<p><code>firstChar == 'a'</code> evaluates to a boolean. <code>firstChar == 'a' || firstChar == 'e'</code> takes the two booleans that results from those two operations, and returns another boolean, which is then fed into the next <code>||</code> operation as the first argument. In this way you can ""chain"" the <code>||</code> operations until one of them is true, or until they're all false.</p>

<p>See <a href=""http://en.cppreference.com/w/cpp/language/operator_logical"" rel=""nofollow noreferrer"">here</a> for examples and explanation.</p>
",0
45222712,45218826,1,"<p>You can use an array too wherein you store all the vowels and then compare it. Something like shown below:</p>

<pre><code>   char vowels[10]={'a','e','i','o','u','A','E','I','O','U'};
   int flag=0;
   for(int i=0;i&lt;10;i++)
   {
       if(vowels[i]==firstChar)
       {
           flag=1;
           anN=""n"";
       }
   }
   if(flag==1)
        cout &lt;&lt; ""I am having a"" &lt;&lt; anN &lt;&lt; "" "" &lt;&lt; adj_3 &lt;&lt; "" time at camp."" &lt;&lt; endl;
   else
       cout &lt;&lt; ""not working"" &lt;&lt; endl;
</code></pre>
",0
37840372,37840270,5,"<p>You must call <code>srand()</code> once, whereas you call it on every entry into <code>generateWeight()</code>. Since nowadays computers are fast and <code>time()</code> returns the time in seconds, this mostly restarts the random number generator from the same seed.</p>
",0
37912032,37911874,0,"<p>Well, the statement </p>

<pre><code> cin&gt;&gt;i;
</code></pre>

<p>reads a number from the standard input stream. So an input of </p>

<pre><code> 3
</code></pre>

<p>results in an integer value <code>3</code>. </p>

<p>The <code>isdigit(i)</code> function checks if <code>i</code> is a character value in the range of <code>['0'-'9']</code>, in decimal <code>[48-57]</code>.</p>

<p>To check for invalid inputs, you rather want to write</p>

<pre><code>  while(cin &gt;&gt; i) {
    sum+=i;
  }
</code></pre>
",2
37912352,37911874,0,"<p>Read a full line, then parse it element by element. To read the line:</p>

<pre><code>std::string line;
std::getline(cin, line);
</code></pre>

<p>To parse it, create a <code>std::istringstream</code> and read from that:</p>

<pre><code>std::istringstream in(line);
int val;
while (in &gt;&gt; val) {
    // whatever
}
</code></pre>

<p>And when the loop exits, check <strong>why</strong> it exited:</p>

<pre><code>if (in.eof())
    // got through the full line, hit end of file
else
    // stopped short, because something was wrong with the input
</code></pre>

<p>i</p>
",0
37912271,37911874,0,"<p>Try something like this:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
int main(){

    // Get the full line of input
    string line;
    getline(cin, line);

    // Variables used to loop through your input
    bool failed = false;
    int sum = 0;
    int place = 1;

    // Start from the back keeping track of current place values
    for (int i = line.length() - 1; i &gt;= 0; i--) {

        if (isdigit( line[i] )) {
            // For digits we add the 
            sum +=  place * ((int) line[i] - 48); // Subtract 48 (It gives ASCII)
            place *= 10; // Prepare for next digit
        }
        else if (line[i] == ' ') {
            // Our delimiter
            place = 1; // Prepare for next number
        }
        else {
            // Not a space our a digit
            cout &lt;&lt; ""invalid Input"";
            failed = true;
            break;
        }
    } 
    if (!failed){
        cout &lt;&lt; sum;
    }
    return 0;
}
</code></pre>

<p>Instead of a straight <code>cin</code>, we use <code>getline</code> to take the whole line as input into a string, traverse it backwards, and add digits to our sum. </p>

<p><strong>As for the question in your title</strong></p>

<p>In your version, you have a couple problems, but the biggest is that you are running <code>isdigit</code> with an integer, and the results you get are not useful. If you want to check if a cast from cin to and int worked correctly, you should use cin's builtin failbit. </p>

<p>For example:</p>

<pre><code>int i;
cin &gt;&gt; i;
</code></pre>

<p>with input:</p>

<pre><code>hello
</code></pre>

<p>Will activate the failbit in cin. You can check for it by using cin as a bool. </p>

<p>The below code :</p>

<pre><code>int i;
cin &gt;&gt; i;
while (cin){
    cin &gt;&gt; i;
}
</code></pre>

<p>will keep putting integers into i until it gets an invalid int like ""hello"".</p>

<p>This will not however, catch the end of a line, or if the user just presses space bar with no input, and so it is not useful for keeping track of where input ends, because <code>cin</code> ignores an empty input, and will just keep waiting. That is why I recommend <code>getline</code> for this.</p>
",0
43216435,43216300,7,"<p><code>this</code> is a pointer to that object, within the scope of its member functions.</p>

<p>Every object has an address, no matter how it was allocated or what its storage duration is. So, whether or not you used <code>new</code> is irrelevant.</p>

<p>You will find, though, that the address of dynamically allocated objects is numerically distant from the address of other ones, because they're typically stored in different places in virtual memory (your ""heap"" vs ""stack"" nomenclature).</p>
",0
43216632,43216300,1,"<p>C pointers are not limited to manualy allocated memory, they can point on any part of the memory. Including zones that are not designed to be used by variables, like the code segment which is the part of memory where the machine instructions are stored to be executed.</p>

<p>You can see pointers as a sort of big indexes of the computer RAM. And the RAM as a big array of bytes.</p>

<p>When you declare an object, like in you example, the compiler take memory somewhere. This memory have its own address (the big index I was talking above) and we can use it like any other memory address.</p>

<p>So, in your case, if you declare:</p>

<pre><code>SomeObject O;
</code></pre>

<p>...then the ""this"" pointer have the same value as a manualy declared pointer like that:</p>

<pre><code>SomeObject 0;
SomeObject *MyThis = &amp;O;
</code></pre>
",9
37637973,37637960,2,"<p>The capsule summary: in C++14 the return type of a lambda (or a function, in most instances) can be given as <code>auto</code>, and then compiler figures out what the actual return type is based on the <code>return</code> statement from the lamba/function.</p>

<p>In this case, nothing is returned, so the return type is <code>void</code>.</p>
",2
37705929,37705839,6,"<p>It should be <code>input == ""a"" || input == ""A""</code>. You have to test each case individually. Right now your code is equivalent to <code>(input == ""a"") || ""A""</code>, which evaluates to <code>true</code> because <code>""A""</code> decays to a non-zero pointer.</p>
",0
37705933,37705839,3,"<p><code>""A""</code> and <code>'B'</code> will always be true in typical implementation.</p>

<p>You should also compare <code>input</code> against them.</p>

<p>Also compareing <code>std::string</code> with <code>char</code> doesn't seem supported, so you should also use string literals for <code>b</code> and <code>B</code>.</p>

<pre><code>Try this:

#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    cout &lt;&lt; ""-----------------------------"" &lt;&lt; endl;
    cout &lt;&lt; ""|Welcome to Castle Clashers!|"" &lt;&lt; endl;
    cout &lt;&lt; ""-----------------------------"" &lt;&lt; endl;

    cout &lt;&lt; ""Would you like to start?"" &lt;&lt; endl;

    string input;

    cout &lt;&lt; ""A. Yes "";
    cout &lt;&lt; ""B. No "" &lt;&lt; endl;
    cin &gt;&gt; input;
    if(input == ""a"" || input == ""A""){
        cout &lt;&lt; ""Yes"" &lt;&lt; endl;
    }else{
        if(input == ""b"" || input == ""B""){
            return 0;
        }
    }
    return 0;
}
</code></pre>
",0
37706321,37705839,2,"<p>C didn't have ""real"" boolean values - instead, anything that equals 0 is considered <em>false</em>, and anything different from that is considered <em>true</em>. While C++ introduced a <code>bool</code> type, it still maintains the old C behavior for compatibility reasons.</p>

<p>As Cornstalk said, your <code>(input == ""a"" || ""A"")</code> is the same as <code>((input == ""a"") || (""A""))</code>, and <code>""A"" != 0</code>, so it always evaluates to <code>true</code> - that's why it'll always enter into that if block.  What you want is:</p>

<p><code>if (input == ""a"" || input == ""A"")</code></p>

<p>The same holds true to the next statement (comparing it to 'B'), but there's one extra problem in there: You're using single quotes ( ' ) instead of double quotes ( "" ), which makes it a <code>char</code> instead of a <code>string</code>. To make both variables the same type, just use double quotes, and it'll end up like this: </p>

<p><code>if(input == ""b"" || input == ""B"")</code></p>
",2
37772587,37772539,0,"<p>The problem is in </p>

<pre><code>degreesC = 5.0/9*(degreesF -32);
</code></pre>

<p>beacuse <code>=</code> is assignements operator in C and C++. This is not a definition of relation. And it done when <code>degreesF</code> is <code>0</code>.</p>

<p>Later</p>

<pre><code>degreesC = temp;
</code></pre>

<p><code>degreesC</code> vlaue is replaced with value of <code>temp</code>. No calculation, just copying of data.</p>

<p>And the main problem is in </p>

<pre><code>cout &lt;&lt; temp &lt;&lt; endl;
</code></pre>

<p>where must be</p>

<pre><code>cout &lt;&lt; degreesC &lt;&lt; endl;
</code></pre>

<p>Try this:</p>

<pre class=""lang-cpp prettyprint-override""><code>#include &lt;iostream&gt;
#include &lt;cassert&gt;
using namespace std;

int main(void)
{
    double degreesC = 0.0;
    double degreesF;

    //Prompt user for degreesF
    cout &lt;&lt; ""Enter the temperate in degrees F: "";
    cin &gt;&gt; degreesF;
    // Calculation
    degreesC = 5.0/9*(degreesF -32);
    //Report the result
    cout &lt;&lt; degreesC &lt;&lt; endl;
    return 0;
};
</code></pre>
",1
37772616,37772539,0,"<pre><code>#include &lt;iostream&gt;
#include &lt;cassert&gt;
using namespace std;

int main(){

    double degreesF = 0;
    double degreesC = 0;

    //Prompt user for degreesF
    cout &lt;&lt; ""Enter the temperate in degrees F: "";
    cin &gt;&gt; degreesF;

    //Define relationship between C and F
    degreesC = 5.0/9*(degreesF -32);

    //Report the result
    cout &lt;&lt; degreesC &lt;&lt; endl;
    return 0;
};
</code></pre>

<p>Is that what you wanna do?</p>
",1
37773057,37772539,0,"<p>in c++ <code>=</code> is an assignment operator (it makes what's on the left hand side logically equal to what's on the right hand side).</p>

<p>It's obvious that you want to declare that <code>degreesC</code> represents a conversion <em>function</em> rather than an assignment.</p>

<p>Here's one way:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cassert&gt;
using namespace std;

int main(){

    double degreesF{0};
    double temp;
    //Define relationship between C and F
    auto degreesC = [](double degreesF) { return 5.0/9*(degreesF -32); };
    //Prompt user for degreesF
    cout &lt;&lt; ""Enter the temperate in degrees F: "";
    cin &gt;&gt; degreesF;
    temp = degreesC(degreesF);

    //Report the result
    cout &lt;&lt; temp &lt;&lt; endl;
    return 0;

};
</code></pre>

<p>example I/O:</p>

<pre><code>Enter the temperate in degrees F: 89
31.6667
</code></pre>
",3
45100909,45100758,2,"<p>I believe what you want is something like this:</p>

<pre><code>cout &lt;&lt; std::setprecision(1) &lt;&lt; a+b;
</code></pre>
",0
37914819,37914772,1,"<p>You are not passing anything by reference. To pass by reference your function should be declared as <code>void addv(one &amp;par)</code> . So you are passing a copy and initializing the copy which gets destroyed before the function returns.</p>
",0
37914821,37914772,3,"<p>You need to pass by <a href=""https://en.wikipedia.org/wiki/Reference_(C%2B%2B)"" rel=""nofollow"">reference</a>.  See the modified code below:</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

class one
{
    public:
        int datam;
        void show()
        {
            cout&lt;&lt;datam;
        }
};

void addv(one &amp;par)
{ 
     par.datam=5;
}

int main()
{
    one w;
    addv(w);
    w.show();

    return 0;
}
</code></pre>

<p>Note that I have changed the prototype of function <code>addv()</code> as:</p>

<pre><code>void addv(one &amp;par)
//------------^^^^
</code></pre>

<p>In your code, you are passing by value (and not reference) due to which, you get a garbage value.  Working code <a href=""http://ideone.com/VOXtlE"" rel=""nofollow""><strong>here</strong></a>.</p>
",0
38098108,38094791,0,"<p>It depends on the case.</p>

<p>In general you would add a function which knows both ways and return the value you need in every case.</p>

<p>So in your case you could do something like</p>

<pre><code>bool myFuction(bool condition, int i, int k)
{
  if(condition == true)
  {
    return (i + MIN_SIZE + k &lt; CK_SIZE); 
  }
  else
  {
    return (i - MIN_SIZE - k &gt;= CK_SIZE);
  }
}
</code></pre>

<p>Now you can call <code>myFunction(..)</code></p>

<p>The <code>bool condition</code> would be the condition wether you decide to use the first or the second way. </p>
",0
46118909,46118808,1,"<p>You should never return a reference to a local variable unless it is dynamically allocated or a static variable since when the function returns, it is destroyed and then you will try to access an area that you have no right to.</p>
",0
38288439,38288308,1,"<p>Here's how I would go about it, without much thought. I presume you're asking about scoring the definite territory at the end of the game, and not trying to score a position's likely territory during a game (which is a MUCH harder problem even conceptually).</p>

<p>First, in the outer loop, I would scan for empty positions, left-to-right top-to-bottom</p>

<p>When I find one, I would fill it in with a territory ID (instead of white or black), and for each adjacent empty I would recursively repeat the process. Filling it with a territory ID ensures you don't redo the same square. You could use a single value, but I think an ID will make debugging easier!</p>

<p>As I do this, I would count track whether I have seen a white or black boundary. If, when I run out of empty spaces, it is only bordered by white or black, I would add the count of this territory to the total for that side. If both, it is uncaptured.</p>

<p>You only consider running out of empty space, when the topmost recursion run has no more adjacent empties to examine. You can do this by having each recursion return the state -- white, black, or disputed. If all the recursions on empty neighbors are the same as for this position, return that value; otherwise return disputed. If the top pass returns black or white, it's captured territory.</p>

<p>Basically, one level of 2D iteration looking for empty, and recursion within each territory, marking and counting/evaluating.</p>
",1
38288332,38288308,0,"<p>Counting territory in GO is an especially hard problem, and generations of developers have tried to solve it. I do not recommend to try to program that as a beginner - it is probably a multi-month project for experienced developers.</p>

<p>No wonder you struggle with that.</p>
",1
38299840,38299775,1,"<p>Using a <code>return</code> statement or the <code>exit()</code> function in C++ will exit the program. Your code would look like:<br></p>

<pre><code>int main()
{
cin &gt;&gt; money;
if (money &lt;= 50) {
    cout &lt;&lt; ""Sorry not enough"" &lt;&lt; endl;
    return 0;
}
cout &lt;&lt; ""Here are the items you can buy"" &lt;&lt; endl;
int a = 50;
int b = 200;
}
</code></pre>

<p>Conversely, with exit() function, it would look like:</p>

<pre><code>#include&lt;stdlib.h&gt; //For exit function
int main()
{
cin &gt;&gt; money;
if (money &lt;= 50) {
    cout &lt;&lt; ""Sorry not enough"" &lt;&lt; endl;
    exit(0);
}
cout &lt;&lt; ""Here are the items you can buy"" &lt;&lt; endl;
int a = 50;
int b = 200;
}
</code></pre>
",5
38299801,38299775,1,"<p>You have to write <code>return</code> after:</p>

<pre><code>cout &lt;&lt; ""Sorry not enough"" &lt;&lt; endl; 
</code></pre>

<p>This will stop the code.</p>
",2
38299813,38299775,1,"<p>Your program ends when you <code>return</code> from <code>main()</code>, so you should arrange for that to happen.</p>

<p>Alternatively you <em>could</em> call <code>exit()</code>, but that's a bad idea since destructors won't run.</p>
",0
38299816,38299775,1,"<p>You can write your code like this:</p>

<pre><code>cin &gt;&gt; money;
if (money &lt;= 50) {
    cout &lt;&lt; ""Sorry not enough"" &lt;&lt; endl;
}
else {
   cout &lt;&lt; ""Here are the items you can buy"" &lt;&lt; endl;
   // Operations you want to perform 
}
</code></pre>
",1
39645036,39644999,11,"<p>This should work:   </p>

<pre><code>        index = i * columns + j;
</code></pre>
",1
38516409,38516265,1,"<pre><code>void enter(a); 
</code></pre>

<p>is likely being seen by the compiler as either </p>

<ol>
<li>a declaration of <code>enter</code> as a variable of type <code>void</code> and passing <code>a</code> into the <code>void</code> constructor, and <code>void</code>'s not a complete type because you can't make a void. <code>void</code> is nothing. </li>
<li>a declaration of function <code>enter</code> that returns <code>void</code> that expects a parameter of type <code>a</code> passed by value. <code>a</code> would be the incomplete type. </li>
</ol>

<p>I think the first interpretation is more likely.</p>

<p>Anyway, you likely wanted to call</p>

<pre><code>enter(a); 
</code></pre>

<p>But that won't work because the <code>enter</code> function doesn't take any parameters. Let's look at <code>enter</code> for a moment.</p>

<pre><code>void enter() {
    char a;
    cout &lt;&lt; ""Enter a letter. "";
    cin &gt;&gt; a;
}
</code></pre>

<p>This function unfortunately doesn't do much. it reads a character from the user and promptly throws it away. We probably want to use that character, so</p>

<pre><code>char enter() {
    char a;
    cout &lt;&lt; ""Enter a letter. "";
    cin &gt;&gt; a;
    return a;
}
</code></pre>

<p>Now we get a copy of the character returned to the caller. That means </p>

<pre><code>enter(a); 
</code></pre>

<p>Should look more like</p>

<pre><code>a = enter(); 
</code></pre>

<p>You have similar problems with </p>

<pre><code>int isVowel(counter);
void outputResult();
</code></pre>

<p>right below the call to <code>enter</code>.</p>

<p>Unfortunately <code>enter</code> is not visible to <code>main</code> because it is declared after <code>main</code> is declared. I recommend moving the function declaration to above <code>main</code> in the file. You could forward declare <code>enter</code> as you have done with the other functions, but why bother? A forward declaration means you may have two places to change the code if the function changes.</p>

<p>I recommend pulling out your programming textbook and reading the first few chapters to get a better grasp of functions. If you are learning on your own and have no textbook, or if your textbook sucks, <a href=""https://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list"">The Definitive C++ Book Guide and List</a> may be of use to you.</p>

<p>Side note: There are more than just guys running around here.</p>
",0
38516355,38516265,0,"<p>This has a few issues with it.</p>

<p>Firstly, you don't seem to prototype the <code>enter</code> function (you don't declare it with the rest of the functions near the top of the code).</p>

<p>Secondly, I think you're trying to call the functions using the code within the <code>do</code> loops, however it's not clear due to the fact that you've put a type before your reference to the functions. If you're trying to call them, you shouldn't mention any types beforehand, so <code>void enter(a);</code> should just become <code>enter(a);</code> (not really, due to the ""a"", more on that on the next point).</p>

<p>Thirdly, assuming that you were trying to call the functions in that bit of code, as I assumed above, the arguments you're passing in aren't consistent with the way the functions are defined. For example, <code>enter</code> requires no arguments in the function you've created, however when you attempt to call it in the <code>do</code> loop, you're trying to pass in a variable ""a"" which it isn't prepared for. Checking the other function calls in that block, you'll find it to be inconsistent with those, too.</p>

<p>Fourthly, and building off of the last point, I believe you made the mistake of leaving out the ""a"" variable being passed into <code>enter</code>, as you reference it whilst within the function however it is never passed in.</p>

<p>Don't be discouraged by this! Keep learning and prosper!</p>
",0
38516520,38516265,0,"<p>There's quite a few issues with your code, I've put some meaningful comments in my code to help you. It sounds harsh, but I'm must in a rush, so I'm not trying to be. This will fully compile and run like I think you'd like.</p>

<pre><code>#include ""stdafx.h""
#include &lt;iostream&gt;
#include &lt;string&gt;

void enter(char&amp;); /*You forget to put the function prototype here.*/
void isVowel(char &amp;, int &amp;); /*Since you are passing by reference, and NOT using the return value, you don't need have have it return int.*/
bool enterAnotherOne();
void outputResult(int &amp;);
bool goAgain();


using namespace std;

int main() {
    int counter = 0;
    char a;

    do
    {
        do
        {
            enter(a); //you don't need to declare the function type when calling a function :(
            isVowel(a, counter); /*You didn't properly pass the argument here*/
            outputResult(counter); //This needs an argument.

        } while (enterAnotherOne());

        //Did you want to reset the counter? if so, do it here.
        counter = 0;
    } while (goAgain());

    return 0;
}// END OF Function main() /*Make sure you clarify it is the END OF function main().*/
// ===================


void enter(char &amp;letter) { /*This requires an argument to be useful.*/
    cout &lt;&lt; ""Enter a letter. "";
    cin &gt;&gt; letter;
}
// END OF Function Letter() also, you had an extra bracket, which means this wouldn't compile.
//  ===========================

void isVowel(char &amp;a, int &amp;num) {
    //counter = 0; //if your're coing to pass counter as a argument, why doe this?
    //counter = 0 resets counter back to 0.

    if (a == 'a' || a == 'e' || a == 'i' || a == 'o' || a == 'u' || a == 'y')
    {
        num++;
    }
}// END OF isVowel()
//  ==============

bool enterAnotherOne() {
    char choice; //give meaningful variable names!

    cout &lt;&lt; ""Would you like to enter another letter? "";
    cin &gt;&gt; choice;

    if (choice == 'y')
    {
        return true;
    }
    else
    {
        return false;
    }
}//If you're going ot comment END OF on every function, might as well do it here.

void outputResult(int &amp;num) {
    cout &lt;&lt; ""The number of vowels that you entered are "" &lt;&lt; num &lt;&lt; endl;
}// END OF outputResult()
//  ===================

bool goAgain() {
    char choice;

    cout &lt;&lt; ""Would you like to go again? "";
    cin &gt;&gt; choice;

    if (choice == 'y')
    {
        return true;
    }
    else
    {
        return false;
    }
}//where's END OF for this function?
</code></pre>
",0
38413929,38413896,0,"<p>You probably wanted to write</p>

<pre><code>BOOL bFullScreen != (dwOpt &amp; USE_FULLSCREEN) ? TRUE : FALSE;
                        // ^^^^^^^^^^^^^^^^ Use the boolean &amp; (and) operator
                        //                  to check if particular bits are set.
</code></pre>
",1
38868051,38867942,0,"<pre><code>while (ret = GetMessage(&amp;msg, NULL, 0, 0) &gt; 0) {
    if (ret == -1)
    {
        return;
    }
</code></pre>

<p>the if statement won't be true in this case, so you won't get to the return.
ret can't be greater than 0 and -1 at the same time </p>
",0
38868132,38867942,1,"<pre><code>if (ret = GetMessage(&amp;msg, NULL, 0, 0) &gt; 0)
</code></pre>

<p>is equal to</p>

<pre><code>if (ret = (GetMessage(&amp;msg, NULL, 0, 0) &gt; 0))
</code></pre>
",2
41943589,41943231,0,"<p>You have a type mismatch between passed arguments and types of parameters in your <code>funkcja</code>. That was explained in other answers. In addition you can also pass arrays by reference, and the easiest way is to use templates. This way you can also pass their sizes at compile time.:</p>

<p><a href=""http://coliru.stacked-crooked.com/a/a7f4c754f448c3e4"" rel=""nofollow noreferrer"">[live]</a></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include &lt;iostream&gt;
using namespace std;

template&lt;int N, int M&gt;
bool funkcja (char (&amp;a)[N][M], char (&amp;b)[M]);

int main()
{

    char T[3][7]={{'A', 'L', 'A', 'M','A', 'k', 'o'},
            {'M', 'A','M','K','O','T','A'},
            {'T', 'E','Q','U','I','L','A'}};

    char tab[7]={ 'A', 'L', 'A', 'M','A', 'k', 'o' }; 

    cout&lt;&lt;funkcja(T, tab)&lt;&lt;endl;

    return 0;
}

template&lt;int N, int M&gt;
bool funkcja (char (&amp;a)[N][M], char (&amp;b)[M])
{
    int licznik=0;

    for (int i=0;i&lt;N;i++)
    {
        for (int j=0; j&lt;M;j++)
        {
                if (a[i][j]==b[j])
                {
                    licznik++;
                    if (licznik==M) return true;
                }
                else {
                    licznik=0;
                }
        }
        licznik=0;
    }
    return false;
}
</code></pre>
",0
41943277,41943231,6,"<p>Your function definition is not correct. You need to change:</p>

<pre><code>bool funkcja (char * a[3][7], char * b[7])
</code></pre>

<p>to:</p>

<pre><code>bool funkcja (char a[3][7], char b[7])
</code></pre>

<p>Note that you can omit the first array dimension, so this can be reduced to:</p>

<pre><code>bool funkcja (char a[][7], char b[])
</code></pre>
",2
41943281,41943231,2,"<p>Your <code>funkcja</code> accepts two arrays of <strong>pointers</strong>, yet you are passing it the arrays of chars.</p>

<p>You should change your signature to:</p>

<pre><code>bool funkcja (char a[][7], char b[]);
</code></pre>
",1
39668204,39667738,2,"<p>If your intent is to reference a variable through a runtime string you cannot do that. (For example in <em>php</em> you can do that with <code>$$variable</code>, in <em>C++</em> there is no that kind of feature).</p>

<p>The most similar way is to play with the <em>preprocessor</em>, but I strongly suggest you to avoid it because usually that kind of solutions are quite <em>""dirty""</em>.</p>

<p>The most simple and optimal solution, instead, is to use an array, and then access the variables with the index.</p>

<p>A little example:</p>

<pre><code>int main(int argc, char *argv[]) {
  std::array&lt;double, 3&gt; nrs = {111, 222, 333};
  for (int i = 0; i &lt; nrs.size(); ++i) {
    std::cout &lt;&lt; ""Num"" &lt;&lt; i + 1 &lt;&lt; "": "" &lt;&lt; nrs[i] &lt;&lt; '\n';
  }

  return 0;
}
</code></pre>

<p>There are a lots of variant of this approach, for example: you may use <code>std::vector</code> is the number of variables are not defined at compile time.</p>

<p>I think that will solve your problem.</p>

<p>Anyway just for completeness, there is another way to <em>""address""</em> a variable with a name. The principle is the same, but instead of use a numeric index you can use a string name.</p>

<p>This can be achieve just using a <code>map</code> or an <code>hash</code>.</p>

<pre><code>int main(int argc, char *argv[]) {
  std::map&lt;std::string, double&gt; nrs = {std::make_pair(""nr1"", 111),
                                       std::make_pair(""nr2"", 222),
                                       std::make_pair(""nr3"", 333)};

  for (int i = 0; i &lt; nrs.size(); ++i) {
    std::string num = ""nr"" + std::to_string(i + 1);
    std::cout &lt;&lt; num &lt;&lt; "": "" &lt;&lt; nrs.at(num) &lt;&lt; '\n';
  }

  return 0;
}
</code></pre>

<p>So with the method <a href=""http://www.cplusplus.com/reference/map/map/at/"" rel=""nofollow""><code>at</code></a> you can access the value associated with that name.</p>

<p><em>Note:</em> if the variable name is not found and you try to access an exception will be thrown.</p>
",0
39668278,39667738,1,"<p>The typical way to do this would be using a <code>std::map</code> like this:</p>

<pre><code>int main()
{
    std::map&lt;std::string, double&gt; nums;

    nums[""nr1""] = 111;
    nums[""nr2""] = 222;
    nums[""nr3""] = 333;

    for(int i = 1; i &lt;= 3; i++)
    {
        std::ostringstream number;
        number &lt;&lt; ""nr"" &lt;&lt; i;
        std::string num = number.str();
        std::cout &lt;&lt; ""Num: "" &lt;&lt; nums[num] &lt;&lt; '\n';
    }
}
</code></pre>
",1
39324152,39324130,1,"<p>Just call it like
Test t4(0,4);</p>
",1
39324176,39324130,0,"<p>Create 3 constructors, and no default values, java-style</p>

<p>sample code:</p>

<pre><code>#include&lt;iostream&gt;    
using namespace std;

class Test
{
    public:
    int sum,a,b;

Test(int x,int y) // constructor created
{
    a=x;
    b=y;
    sum= a+b;
    cout&lt;&lt;""X=""&lt;&lt;x&lt;&lt;""\t""&lt;&lt;""Y=""&lt;&lt;y&lt;&lt;""\t""&lt;&lt;""Sum =""&lt;&lt;sum&lt;&lt;""\n"";
}
Test(int y) : Test(0,y) {}  // constructor created
Test() : Test(0,0) {} // constructor created
};

int main()
{
     Test t1; // constructor calling without any values
    Test t2(2,4); // same as above but with two values
    Test t3(4); // it is only with a single value
    return 0;
}
</code></pre>

<p>build with: <code>g++ -std=c++11 test.cpp</code></p>

<p>result:</p>

<pre><code>X=0     Y=0     Sum =0
X=2     Y=4     Sum =6
X=0     Y=4     Sum =4
</code></pre>

<p>Alternate pre-C++11 method: use an inlined helper method, maybe even faster.</p>

<pre><code>#include&lt;iostream&gt;    
using namespace std;

class Test
{
    public:
    int sum,a,b;

Test(int x,int y) // constructor created
{
    build(x,y);
}
Test(int y) { build(0,y); }  // constructor created
Test() { build(0,0); } // constructor created

private:
inline void build(int x,int y)
{
    a=x;
    b=y;
    sum= a+b;
    cout&lt;&lt;""X=""&lt;&lt;x&lt;&lt;""\t""&lt;&lt;""Y=""&lt;&lt;y&lt;&lt;""\t""&lt;&lt;""Sum =""&lt;&lt;sum&lt;&lt;""\n"";
}
};

int main()
{
     Test t1; // constructor calling without any values
    Test t2(2,4); // same as above but with two values
    Test t3(4); // it is only with a single value
    return 0;
}
</code></pre>
",5
39324181,39324130,0,"<p>If you want 'y' to be passed as parameter when Test object's constructor is called with 1 argument, change the order of arguments in constructor definition</p>

<pre><code>Test(int y=0, int x=0)
{ /*--- */}
</code></pre>
",4
39324194,39324130,-2,"<p>The above answer answers your question. But, if you want a constructor that takes only 1 argument, you could use polymorphism and create another constructor.</p>

<pre><code>#include&lt;iostream&gt;

class Test // class created
{   
    int a,b,sum; 
    public:
    Test(int x=0,int y=0) // constructor created
    {
        a=x;
        b=y;
        sum= a+b;
        cout&lt;&lt;""X=""&lt;&lt;x&lt;&lt;""\t""&lt;&lt;""Y=""&lt;&lt;y&lt;&lt;""\t""&lt;&lt;""Sum =""&lt;&lt;sum&lt;&lt;""\n"";
    }

    Test(int y=0) // another constructor
    {
        a=0;
        b=y;
        sum= a+b;
        cout&lt;&lt;""X=""&lt;&lt;x&lt;&lt;""\t""&lt;&lt;""Y=""&lt;&lt;y&lt;&lt;""\t""&lt;&lt;""Sum =""&lt;&lt;sum&lt;&lt;""\n"";
    }
};

void main()
{
    Test t1; // constructor calling without any values
    Test t2(2,4); // same as above but with two values
    Test t3(4); // it is only with a single value
    getch();
}  
</code></pre>
",10
39328472,39324130,1,"<p>Use <em>named</em> constructor</p>

<pre><code>class Test
{   
    int a, b, sum; 
public:
    Test(int x = 0, int y = 0) : a(x), b(y), sum(a + b)
    {
        std::cout &lt;&lt; ""X="" &lt;&lt; x &lt;&lt; ""\tY="" &lt;&lt; y &lt;&lt; ""\tSum ="" &lt;&lt; sum &lt;&lt; ""\n"";
    }

    static Test TestY(int y) { return Test(0, y); }
};

int main()
{
    Test t3 = Test::TestY(4);
}
</code></pre>

<p>or tag constructor</p>

<pre><code>struct tagY{};

class Test
{   
    int a, b, sum; 
public:
    Test(int x = 0, int y = 0) : a(x), b(y), sum(a + b)
    {
        std::cout &lt;&lt; ""X="" &lt;&lt; x &lt;&lt; ""\tY="" &lt;&lt; y &lt;&lt; ""\tSum ="" &lt;&lt; sum &lt;&lt; ""\n"";
    }

    Test(tagY, int y) : Test(0, y) {}
};

int main()
{
    Test t3(tagY{}, 4); // it is only with a single value
}
</code></pre>
",1
39625792,39625767,3,"<p>This might work better:</p>

<pre><code>if ( unit == 'c' || unit == 'C')
</code></pre>
",5
39624952,39624872,1,"<p>Did you look at <a href=""http://en.cppreference.com/w/cpp/container/list/splice"" rel=""nofollow""><code>std::list::splice</code></a>?</p>

<blockquote>
  <p>Transfers elements from one list to another.
  No elements are copied or moved, only the internal pointers of the list nodes are re-pointed. The behavior is undefined if: get_allocator() != other.get_allocator(). No iterators or references become invalidated, the iterators to moved elements remain valid, but now refer into *this, not into other.</p>
</blockquote>

<p>Note that when splicing in a range, the time is linear, rather than O(1).</p>
",0
39649166,39648523,1,"<p>Writing a <code>telephone</code> to a file as a binary blob will not work. <code>telephone</code> contains <code>name</code> and name is a <code>std::string</code>. A <code>std::string</code> does not typically contain the string data it represents; it contains a pointer to the string data.</p>

<p>So when you </p>

<pre><code>f.write((char*)&amp;p,sizeof(telephone));
</code></pre>

<p>what you actually wrote to the file was not the string data, but a pointer to the string data. This means that </p>

<pre><code> f.read((char*)&amp;q,sizeof(telephone));
</code></pre>

<p>reads back <code>p</code>'s pointer to <code>q</code> and that means that <code>p</code> and <code>q</code> both point at the same string data. This is bad.</p>

<p>When <code>p</code> or <code>q</code> go out of scope and are destroyed, they destroy <code>name</code>, and <code>name</code>, like a good little <code>std::string</code>, and frees the memory it points at. This leaves the other object containing a <code>std::string</code> pointing at memory that has been freed, and sooner or later that other object will either be used and invoke <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">undefined behaviour</a> or be destroyed and attempt to free the previously freed memory. This is what is meant in the error message by ""double free"". The same memory has been freed twice.</p>

<p>In your case,  if <code>q</code> is deleted before <code>p</code>, <code>q</code> releases the memory that both <code>p</code> and <code>q</code> point at leaving <code>p</code> pointing at an invalid memory location. A few nanoseconds later <code>p</code> is deleted and <code>p</code> cannot free the already freed memory. </p>

<p>To get around this you must ensure the contents of the <code>std::string</code> are written to the file and then read back. This is called <a href=""https://en.wikipedia.org/wiki/Serialization"" rel=""nofollow"">serialization</a>.</p>

<p>Typical solutions to this problem are to write the data to the file in a text format with <code>&lt;&lt;</code> and read it back with <code>&gt;&gt;</code> (which may require you to implement the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators for your class) </p>

<pre><code>class telephone
{
   string name;
   long number;
   public :
     void getdata();
     void display();
     friend std::istream &amp; operator&lt;&lt;(std::istream &amp; out, const telephone &amp; tp);
     friend std::ostream &amp; operator&gt;&gt;(std::ostream &amp; in, telephone &amp; tp);
};
</code></pre>

<p>or add serialization functions to the class</p>

<pre><code>class telephone
{
   string name;
   long number;
   public :
     void getdata();
     void display();
     bool serialize(std::iostream &amp; out);
     bool deserialize(std::iostream &amp; in);
};
</code></pre>

<p>The writing of these functions is probably the point of this assignment, so I'll stop here. Don't worry. Both are approaches are exceedingly well documented online if you have trouble. I recommend starting with the first option. It is much easier to debug because you can read the text file to see if you got it wrong.</p>
",2
48041334,48038508,0,"<p>Since in both the cases you have initialized the class object and then the check condition and then the next step to be followed are identically placed both will work similarly algorithmically as well as in execution owing to the fact that both FOR and WHILE are interconvertible . </p>
",0
48041389,48038508,1,"<p>Absolutely. A <code>for (init; cond; step) {statements}</code> syntax is equivalent to</p>

<pre><code>{
    init;
    while (cond) {
        statements;
        step;
    }
}
</code></pre>

<p>So they are totally interchangeable (except for readability in certain cases).</p>

<p>The purpose of the standalone braces in the first and the last line is to restrict the scope of the initialized variables to the loop itself.</p>
",0
41196944,41196913,0,"<p>You should write </p>

<pre><code>Player *ptr = new Player[k+1]; 
</code></pre>

<p>Suppose your value of <code>k</code> is 5 then your loop will iterate 6 times (0 to 5) , and you have allocated space only for 5 objects. That's why it will throw an exception.</p>
",5
41196967,41196913,1,"<p>your array size should be (k+1) or the for loop should be like :</p>

<pre><code>for (int i = 0; i&lt;k; i++) {

cout &lt;&lt; ""Enter name"" &lt;&lt; endl;
cin &gt;&gt; n;
ptr[i].setName(n);

cout &lt;&lt; ""Enter score"" &lt;&lt; endl;
cin &gt;&gt; s;
ptr[i].setScore(s);

ptr[i].getName();
ptr[i].getScore();

}
</code></pre>
",0
42622184,40789370,0,"<p><a href=""https://en.wikipedia.org/wiki/C++11#Object_construction_improvement"" rel=""nofollow noreferrer"">C++</a> don't allow a constructor to call other constructors definition of the same class at the initialization level.</p>

<p>When you write <code>Paddle(int posX, int posY) : Paddle() ...</code> the compiler understands <code>Paddle</code> is a super class of <code>Paddle</code> or a member of <code>Paddle</code> which is not the case.
All what you need is a default parameters like this:</p>

<pre><code>class Paddle{
private:

    int x, y;
    int startX, startY;

public:
    Paddle(int posX=0, int posY=0):x(posX),y(posY),startX(posX),startY(posY) {}
};
</code></pre>
",0
40789419,40789370,6,"<p>This is the correct syntax, but <em>constructor delegation</em> is not supported until C++11.</p>

<p>Visual Studio 2012 does not purport to implement the C++11 standard. Constructor delegation is one of those things that is <em>doesn't</em> support.</p>
",8
40789544,40789370,2,"<p>You mentioned you use visual studio 2012. Unfortunately it doesn't support delegating constructors. You can see a table of supported features by version at msdn.</p>

<p><a href=""https://msdn.microsoft.com/en-us/library/hh567368.aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/hh567368.aspx</a></p>
",0
40790282,40789370,-1,"<p>this is allowed in C++11 see <a href=""https://en.wikipedia.org/wiki/C++11#Object_construction_improvement"" rel=""nofollow noreferrer"">Object construction</a></p>
",0
40525849,40525788,4,"<p>As the error says, C++ requires a type specifier for the declaration. For instance, change <code>const MAX = 10;</code> to <code>const int MAX = 10;</code>.</p>
",0
40526009,40525788,-4,"<p>Have you considered using </p>

<pre><code>#define MAX 10
</code></pre>

<p>?</p>
",6
40952769,40952745,1,"<p>You are performing integer division here</p>

<pre><code>return ((scoreRating[0] + scoreRating[1] + scoreRating[2] + scoreRating[3] + scoreRating[4]) / 5);
</code></pre>

<p>You need to perform floating point division, you can do this by changing at least one of the types (the literal <code>5.0</code> in this case) to a <code>double</code></p>

<pre><code> return ((scoreRating[0] + scoreRating[1] + scoreRating[2] + scoreRating[3] + scoreRating[4]) / 5.0);
</code></pre>
",1
40952769,40952745,1,"<p>You are performing integer division here</p>

<pre><code>return ((scoreRating[0] + scoreRating[1] + scoreRating[2] + scoreRating[3] + scoreRating[4]) / 5);
</code></pre>

<p>You need to perform floating point division, you can do this by changing at least one of the types (the literal <code>5.0</code> in this case) to a <code>double</code></p>

<pre><code> return ((scoreRating[0] + scoreRating[1] + scoreRating[2] + scoreRating[3] + scoreRating[4]) / 5.0);
</code></pre>
",1
40980331,40973099,0,"<p>A literal is a declarative object, however I think that maybe you are getting hung up on a distinction that primitives and objects. Primitives are objects and can be seen them as objects easily but due to there notation and lack of members, it can be easy to see why they could be perceived as not objects. Therefore it easy to see why it could be thought that a literal is not an object because literals usually define primitives (not many complex data structures are easy to define in literals).</p>

<p>However, a primitive is an object (no useful reason to not define them as objects) because it is a member of a type. Therefore since is just a static definition of an object they are also an object we just don't interact with them in the same way as other objects because they are static.</p>

<p>While the idea that a literal is not object probably won't cause any problems in code it can make OOP more complicated especially since the idea of OOP is that we should interact with object in programming because that is how we interact with everything outside of programming.</p>
",0
40548834,40455142,1,"<p>There is no specified size limit on IO buffers that I could find in the standard, but there may be for your OS input buffer.</p>
",0
42468643,42468586,2,"<p>Well <code>arr[x]</code> is an array, which decays to a pointer to its first element. So when you print <code>arr[x]</code> you are in fact printing <code>&amp;arr[x][0]</code>.</p>

<p>I assume you want to print <code>x</code> only:</p>

<pre><code>cout &lt;&lt; ""Row: "" &lt;&lt; x &lt;&lt; ...
</code></pre>
",0
42468666,42468586,0,"<p>I would suggest you to use brackets on loops always. This</p>

<pre><code> for (int y = 0; y &lt; 3; y++)
    sum += arr[x][y];
 cout &lt;&lt; ""Row: "" &lt;&lt; arr[x] &lt;&lt; ""addition is:"" &lt;&lt; sum &lt;&lt; endl;
</code></pre>

<p>is equivalent to </p>

<pre><code> for (int y = 0; y &lt; 3; y++) {
    sum += arr[x][y];
 }
 cout &lt;&lt; ""Row: "" &lt;&lt; arr[x] &lt;&lt; ""addition is:"" &lt;&lt; sum &lt;&lt; endl;
</code></pre>

<p>and outside of the loop <code>y</code> is not declared. You probably wanted</p>

<pre><code>for (int y = 0; y &lt; 3; y++) {
   sum += arr[x][y];
   cout &lt;&lt; ""Row: "" &lt;&lt; arr[x] &lt;&lt; ""addition is:"" &lt;&lt; sum &lt;&lt; endl;
}
</code></pre>

<p>Further, you say you want to print the row index, which is either <code>x</code> or <code>y</code>, but not <code>arr[x][y]</code> which is the element at index <code>[x][y]</code>.</p>
",0
42468669,42468586,1,"<p>'y' is undefined because it went out of its scope.</p>

<p>To add numbers diagonally, you can do:</p>

<pre><code>sum = 0;
for (int i = 0; i &lt; 3; ++i)
    sum += arr[i][i];
</code></pre>
",0
45045074,45044948,0,"<blockquote>
<p>I would like to do lookup on the map and get the pointer to the item held in set to increase its value.</p>
<p>Is there a way to do so with current containers in STL?</p>
</blockquote>
<p>No. Elements of a <code>std::set</code> may not be modified. As such, the iterators are constant, and you couldn't use them to modify the elements.</p>
<p>The simple way to achieve similar effect would be to remove the old element, and insert a modified copy.  However, any iterator that used to point to the old element will of course be invalidated by the removal of the element and will not point to the modified one.</p>
<blockquote>
<p>Is there a way to have a tree which automatically re-sorts its elements, or when calling some method (not when inserting new element)?</p>
</blockquote>
<p>Sure, but there is no such structure in the standard library.</p>
",4
40742703,40742625,0,"<p>adding extern std::ostream&amp; operator&lt;&lt;(std::ostream&amp;,Foo); in bar.cpp fixed it and it works.</p>
",0
40742706,40742625,2,"<p><code>operator &lt;&lt;</code> is still a function like any other (with some additional properties). Its declaration must be visible in all files which want to use it. So if you move its definition from <code>main.cpp</code> into <code>foo.cpp</code>, you will need to put a declaration for it in <code>foo.hpp</code>:</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Foo x);
</code></pre>
",0
41212861,41212805,3,"<p>operator&lt;&lt; is a <code>friend</code> function, it's not actually a member of the class <code>JSON</code>. Therefore, if you just say <code>allInfo</code>, the compiler doesn't know what <code>allInfo</code> you're talking about.</p>

<p>However, the correct <code>JSON</code> instance is passed as a parameter. You should write lines like this:</p>

<pre><code>it = js.allInfo.begin();
/* ... */
for(it; it != js.allInfo.end();it++){
</code></pre>

<p>Now, you're telling the compiler you want to use the <code>allInfo</code> that belongs to instance <code>js</code>.</p>
",0
41180598,41180546,5,"<pre><code>(r3.n)%(r3.d)
</code></pre>

<p><code>n</code> and <code>d</code> are of type <code>double</code>. Operator <code>%</code> (modulo) is only available for integers.</p>

<p>As @Cheers and hth. - Alf kindly pointed in the comments, the best solution would be to declare <code>n</code> and <code>d</code> as integers, since it will be more coherent to represent a rational number.</p>

<p>If you can't do that and really have a reason to use doubles, you will have to use <a href=""http://en.cppreference.com/w/cpp/numeric/math/fmod"" rel=""nofollow noreferrer""><code>std::fmod</code></a> instead:</p>

<pre><code>std::fmod(r3.n, r3.d)
</code></pre>
",1
41180860,41180546,0,"<p>As <code>%</code> is only for integers, therefore you will have to use <code>fmod(x,y)</code>. You will also have to add <code>#include &lt;math.h&gt;</code> as header.</p>
",3
41180958,41180546,2,"<p>In C++ <code>%</code> is only available for integers.</p>

<p>Use an integer type for <code>n</code> and <code>d</code>.</p>

<p>This also helps ensure that the <em>values</em> are mathematical integers, which you're not guaranteed with a floating point type.</p>
",0
41197156,41197021,2,"<p>You could repeatedly multiply it by 10, until there is nothing after decimal point.</p>

<pre><code>double c = x - d;

while(c - floor(c) &gt; 0.0)
{c *= 10;}
</code></pre>

<p>you may also need to <code>#include &lt;math.h&gt;</code> for floor function, which rounds down a number. e.g. <code>floor(4.9)</code> returns 4.0</p>
",1
41198006,41197021,0,"<p>Floating point calculations are little bit tricky in C++ (same is true for Java and other languages). You should avoid their direct comparison and do some other stuff to get predictable result when using them, consider:</p>

<pre><code>double d1=1.1;
double d2= d1 / 10.0;

if(d2==0.11)cout &lt;&lt; ""equals"" &lt;&lt; endl;
else cout &lt;&lt; ""not equals"" &lt;&lt; endl;   //result is ""not equals""

d1=1.99;
float  f1=0.01f;
double d3=d1+f1;
if(d3==2.0)cout &lt;&lt; ""equals"" &lt;&lt; endl;
else cout &lt;&lt; ""not equals"" &lt;&lt; endl;  //result is ""not equals""

d1=1.99;
d2=0.01;
d3=d1+d2-2.0;
if(d3==0.0)cout &lt;&lt; ""equals"" &lt;&lt; endl;
else cout &lt;&lt; ""not equals"" &lt;&lt; endl;   //result is ""not equals""
</code></pre>

<p>As for practical solution of the problem I can suggest 2 variants:
Var 1 is to use a function that allows to specify number of digits:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;


void split_double(const double value, int&amp; i_part, int&amp; r_part,
                  const int max_digits_after_dp, int min_digits_after_dp){


    auto powerOfTenL = [](int power){ int result = 1;
        for(int i=0;i&lt;power;++i)result *= 10;
        return result;
    };
    //Get integral part
    i_part = (int)value;
    double temp = (value-i_part);
    double pOfTen = powerOfTenL(max_digits_after_dp);
    temp *= pOfTen;
    //Get real part
    r_part = round(temp);

    //Remove zeroes at the right in real part
    int num_of_d = max_digits_after_dp;
    if(min_digits_after_dp&gt;max_digits_after_dp)
        min_digits_after_dp=max_digits_after_dp;
    while (num_of_d&gt;min_digits_after_dp) {
        //If the number is divisible by 10, divide it by 10
        if(0==(r_part%10)) { r_part /=10; num_of_d--;
        }
        else break; //Last digit is not 0
    }
}

int main(int argc, char *argv[])
{

    double value = 10.120019;
    int ipart,rpart;
    const int digitsMax = 6;
    const int digitsMin = 3;

    split_double(value,ipart,rpart,digitsMax,digitsMin);
    cout&lt;&lt;""Double "" &lt;&lt;value &lt;&lt; "" has integral part "" &lt;&lt;ipart
       &lt;&lt;"" and real part ""&lt;&lt;rpart&lt;&lt;endl;

    return 0;
}
</code></pre>

<p>Second variant to solve the problem is to use C/C++ formatting functions like vsprintf and then split the resulting string.</p>
",0
40973239,40973132,0,"<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
int x[5], count=0;
for (int i=0;i&lt;5;i++)
cin&gt;&gt;x[i];

for (int i=0;i&lt;5;i++)
{
    bool check = true;
    for (int n=2;n&lt;x[i];n++)
    {
        if (x[i]%n==0)
        {
            check = false;
            break;
        }
    }    
    if (check)
    cout&lt;&lt;x[i]&lt;&lt;"" "";
}
}
</code></pre>

<p>For better complexity, change your nested for loop to :</p>

<pre><code>for (int n=2;n&lt;=sqrt(x[i]);n++)
</code></pre>

<p>Other way :</p>

<pre><code>int main () 
{
    for (int i=2; i&lt;100; i++) 
    {
        bool check=true;
        for (int n=2; n*n&lt;=x[i]; n++)
        {
            if (x[i] % n == 0) 
            {
                check=false;
                break;    
            }
        }   
        if(check) cout &lt;&lt; x[i] &lt;&lt; "" "";
    }
    return 0;
}
</code></pre>
",2
40974254,40973132,0,"<p>Here's my solution.
I basically assume all numbers are prime, but if I find them not to be prime I don't print them out.</p>

<pre><code>int main()  {
    bool primeNumber;
    int length = 0;
    int x[5], count=0;

    for (int i=0;i&lt;5;i++){
        length++;
        cin&gt;&gt;x[i];
    }
    for (int i = 0;  i &lt; length;  i++ )
    {
        primeNumber = true;
        for (int j = 3;  j &lt;= x[i]/2;  j += 2 )//Not necessary to check agains numbers higher than half the number you want to check
        {

        if (x[i] % j == 0) 
        {
            primeNumber = false;
        }
    }
    if(primeNumber){cout &lt;&lt; ""Primenumber: "" &lt;&lt; x[i] &lt;&lt; endl;}
    }
}
</code></pre>

<p><strong>EDIT:</strong>
Here's a comment on your code
Let's say your array looks like this</p>

<pre><code>{5,9,13,15, 17}



int main()
{
    int x[5], count=0;
    for (int i=0;i&lt;5;i++)
    cin&gt;&gt;x[i];

    for (int i=0;i&lt;5;i++)   
    {
        for (int n=2;n&lt;x[i];n++)
        {
</code></pre>

<blockquote>
  <p>Here you loop from 2-4(2,3,4). It's only necessary to loop half the number you want to check. e.g. (x[i]/2), but you can do it like you have done here.</p>
</blockquote>

<pre><code>            if (x[i]%n==0){       
            count++;}
</code></pre>

<blockquote>
  <p>When your number is 5 and you check agains n numbers This will produce 5%2=1,5%3=2,5%4=1. <em>But 5 is a prime number</em> and your code didn't manage to detect that. </p>
</blockquote>

<pre><code>        }    
    if (count==1)    
</code></pre>

<blockquote>
  <p>Let's say you did find that 5 is a prime above and you managed to increment count to 1. What happens when you find another prime number in your array e.g. 7. That will make count be equal to 2. But you only check against 1, so therefor your next prime number doesn't get printed because count will only be equal to 1 after the first prime number and not the rest.</p>
</blockquote>

<pre><code>    cout&lt;&lt;x[i]&lt;&lt;"" "";
    }
</code></pre>

<p>}</p>

<p>Hopefully you understood my explanation. It always helps to go over your code by hand or debug mode and think what the code will do with different numbers. </p>
",4
40979235,40973132,0,"<p>All numers are divideable by itself. That will make all numbers prime if you try to divide numbers with themselves</p>
",0
41177751,41177725,2,"<p>Look up ""pass by value"" and ""pass by reference"" - you have ""pass by value"" but you are expecting ""pass by reference""</p>

<p>In C++: <code>void convert(string&amp; response) {</code></p>

<p>In your case things are slightly ""odd"" because as pointed out in the comments by @NeilLocketz, you have a global <code>response</code>, the local <code>response</code> in the method - which is actually the global one since you use that as the calling parameter. If you want to do things properly, you probably don't want <code>response</code> to be global.</p>

<p>Note that the accepted answer still has more memory copies than this. The real key is to understand pass by value and pass by reference and use whichever one is appropriate to your circumstances.</p>
",1
41177757,41177725,1,"<p>Another option is to change your function header so that it returns a <code>string</code>. That is:</p>

<pre><code>string convert(const string &amp;inResponse) {
    string outResponse(inResponse);
    for (int i = 0; i &lt; inResponse.length(); i++) {
        outResponse[i] = toupper(inResponse[i]);
    }
    return outResponse;
}
</code></pre>

<p>And then you use the returned string in your main function like:</p>

<pre><code>....
// response is input, outputResponse is output:
string outputResponse = convert(response);
....
</code></pre>
",3
41177811,41177725,2,"<p>Aside from the need to pass a reference instead of a value, you should try to use C++-11 features:</p>

<pre><code>void convert(string &amp;response) {
    for (auto &amp;c: response) {
         c = toupper(c);
    }
}
</code></pre>

<p>it is much cleaner, and simpler. </p>
",0
41926118,41925854,5,"<p>In C++, all variables are declared with type. C++ forces<sup>1</sup> you to specify the type explicitly, but doesn't force you to initialize the variable at all.</p>

<pre><code>long int a = 2;
long int b = 2L;
long int c;
</code></pre>

<p>This code makes 3 variables of the same type <code>long int</code>.</p>

<pre><code>int a = 2;
int b = 2L;
int c;
</code></pre>

<p>This code makes 3 variables of the same type <code>int</code>.</p>

<p>The idea of <em>type</em> is roughly ""the set of all values the variable can take"". It doesn't (and cannot) depend on the initial value of the variable - whether it's <code>2</code> or <code>2L</code> or anything else.</p>

<p>So, if you have two variables of different type but same value</p>

<pre><code>int a = 2L;
long int b = 2;
</code></pre>

<p>The difference between them is what they can do <em>further in the code</em>. For example:</p>

<pre><code>a += 2147483647; // most likely, overflow
b += 2147483647; // probably calculates correctly
</code></pre>

<p>The type of the variable won't change from the point it's defined onwards.</p>

<p>Another example:</p>

<pre><code>int x = 2.5;
</code></pre>

<p>Here the type of <code>x</code> is <code>int</code>, and it's initialized to 2. Even though the initializer has a different type, C++ regards the declaration type of <code>x</code> ""more important"".</p>

<hr>

<p><sup>1</sup> BTW C++ has support for ""type inference""; you can use it if you want the type of the initializer to be important:</p>

<pre><code>auto a = 2L; // ""a"" has type ""long int""
auto b = 2; // ""b"" has type ""int""
</code></pre>
",3
41926025,41925854,4,"<blockquote>
<p>What is difference between &quot;long int a=2&quot; and &quot;int a=2L&quot;?</p>
</blockquote>
<p>The former defines a variable <code>a</code> as having type <code>long int</code> initialised from the value <code>2</code>, the latter defines it as having type <code>int</code> initialised from the value <code>2L</code>. The initialiser is implicitly converted to the type of the variable, and does not affect the type of the variable.</p>
<blockquote>
<p>Or what is the difference between <code>long char c='a'</code> and <code>char c=L'a'</code></p>
</blockquote>
<p>The former defines a variable <code>c</code> as having type <code>long char</code> initialised from the value <code>'a'</code>, the latter defines it as having type <code>char</code> initialised from the value <code>L'a'</code>. Since the type <code>long char</code> doesn't exist, the former is an error. The type of <code>L'a'</code> is called <code>wchar_t</code>, not <code>long char</code>, and in the latter case is again converted to the type of the variable.</p>
<blockquote>
<p>or what is the difference between <code>unsigned int a=2</code> and <code>int a=2U</code></p>
</blockquote>
<p>The former defines a variable <code>a</code> as having type <code>unsigned int</code> initialised from the value <code>2</code>, the latter defines it as having type <code>int</code> initialised from the value <code>2U</code>. Yet again, the initialiser does not affect the type of the variable.</p>
<blockquote>
<p>Also,</p>
<p><code>sizeof(a)</code> operator gives the same value for <code>int a=2</code> and <code>int a=2L</code> , why? Shouldn't the size be doubled.</p>
</blockquote>
<p>Since they both define <code>a</code> as type <code>int</code>, <code>sizeof(a)</code> should give <code>sizeof(int)</code> for both.</p>
",2
46033001,46032881,2,"<p>Function <a href=""http://en.cppreference.com/w/cpp/string/byte/strtof"" rel=""nofollow noreferrer""><code>strtod</code></a> accepts C-like strings aka char array</p>

<pre><code>double strtod(const char *str, char **endptr);
</code></pre>

<p>so you <strong>cant</strong> pass instance of class <a href=""http://www.cplusplus.com/reference/string/string/"" rel=""nofollow noreferrer""><code>std::string</code></a>, but you may get pointer to constant chararacter array which this object contains using <a href=""http://www.cplusplus.com/reference/string/string/c_str/"" rel=""nofollow noreferrer""><code>c_str</code></a> method.</p>

<pre><code>eulersGuess.c_str();
</code></pre>

<p>Or you may use function <a href=""http://www.cplusplus.com/reference/string/stod/"" rel=""nofollow noreferrer""><code>std::stod</code></a> which accepts <code>std::string</code> parameters.</p>

<p><strong><a href=""https://ideone.com/8bmaab"" rel=""nofollow noreferrer"">[Live on ideone]</a></strong></p>
",0
41687829,41687652,3,"<p>Pseudo random numbers aren't truly random numbers because they are generated using a deterministic process. For example, if I wanted a random number between 0 and 4 and I had access to the current time in seconds, I could generate pseudo random numbers by applying modulus 5 to the time value and this would return a different number between 0 and 4.The reason the number isn't truly random is because it is possible to predict that number before generation by knowing the time. A truly random number could never be predicted.</p>

<p>You could Google ""determinism"" for more.</p>
",6
41688191,41687652,2,"<p>This question could lead into a very deep philosophical rabbit hole. It is an open question if there really is a process in nature that can be truly non-deterministic. Quantum mechanics suggests that the universe is non-deterministic, but with deterministic probabilistic laws on some level. Nevertheless, this does not rule out the possibility that at some more fundamental level, a deterministic process resides, which simply appears random, at a larger scale. Randomness and chaos are intimately related, but they do not necessarily mean the same thing.</p>

<p>As a result, the word random could mean several different things. For practical purposes, we can consider randomness as a certain type of mathematical pattern, with certain characteristics. A random process typically follows some probabilistic distribution (i.e. white noise, pink noise, Gaussian, Poisson, ...), but it is not possible to practically predict individual results of when you sample the output of the random process.</p>

<p>A pseudo random number generator or PRNG uses an algorithm that employs <strong>deterministic chaos</strong> to create a pattern that <em>appears</em> statistically similar to a true random process. PRNGs typically use a starting point or <em>seed</em>. It is common to use the output of a time function to seed a PRNG. There are a multitude of different algorithms for PRGNs, which differ in performance and quality.</p>

<p>One significant weaknesses of a PRNG, is that the output eventually repeats or is periodic. It is also possible, if one knows the algorithm, and the starting point (<em>seed</em>), to recreate the exact same sequence, because digital computers are necessarily deterministic devices. Security mechanisms which rely on PRNGs often have hidden vulnerabilities, due to the PRNGs that they employ.</p>

<p>Certain applications, especially in security, or for example a lottery, require what is, for practical purposes considered a true random number generator. Hardware devices are available, which exploit physical phenomena. Thermal noise (i.e. random motion of electrons), for example, is governed by Quantum Mechanical behaviour and is often used in RNG hardware implementations. Certain quantum mechanical phenomena are generally considered to be random. According to most standard interpretations of Quantum Mechanics, even if you had a complete model of the system (i.e. time evolution of Schr?dinger Equation) and knowledge of all the initial variables, to infinite precision, you still would not be able to predict exactly the next outcome of a measurement.</p>

<p>In theory, you could also use radio background noise (think television static or radio noise between the stations). Any of these signal sources can be filtered or used as input themselves for a PRNG to create high quality random sequences, without any noticeable statistical predictability.</p>

<p>Here is very simple toy PRNG algorithm for you to play around with and help understand the concept.</p>

<pre class=""lang-cpp prettyprint-override""><code>// linear congruential generator
int seed 123456789;

int rand() {
    seed = ( a * seed + c ) % m;
    return seed;
}
</code></pre>

<p>The above is taken from <a href=""https://stackoverflow.com/questions/3062746/special-simple-random-number-generator"">Special simple random number generator</a>. I hope that sheds some light on your question.</p>
",0
41689397,41687652,1,"<blockquote>
  <p>What is the difference between a truly random number and a pseudo
  random number in C++?</p>
</blockquote>

<p>In C++, it is possible to repeat a pseudo random number sequence.  A 'truly random' number (I think not supported by C++ nor C, without custom hardware) can not be repeated.</p>

<hr>

<p>Marked as C++, so here is one C++ approach.</p>

<p>Lately I have been using what C++ provides, but I still control the range of my numbers by shuffling a simple vector of values.  This also supports applying the same random shuffle to more than one test, or to repeat a sequence.</p>

<pre><code>typedef std::vector&lt;int&gt; IntVec_t;  // a convenient type

IntVec_t  iVec;                     // a std vector of int

for (int i=1; i&lt;=32; ++i)
   iVec.push_back(i);               // add 32 ints, range 1..32

{        
   std::random_device rd;      // the generator uses this
   std::mt19937_64 gen(rd());  // there are several generators available

   std::shuffle (iVec.begin(), iVec.end(), gen); // shuffle the vector
}
</code></pre>

<p>initialized to:  ( 16 elements to a line)</p>

<pre><code> 1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 

17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32 
</code></pre>

<p>Shuffled contents (possible) : </p>

<pre><code>29   26   12   16   20    7   31   28   30   18    4   23   17   14   32    1 

11   13    5    6    9    2   19   10   21   24    3    8   25   27   22   15 
</code></pre>
",0
44332397,44332074,9,"<blockquote>
  <p>Do I have to implement begin/end?</p>
</blockquote>

<p>Yes.</p>

<blockquote>
  <p>As far as I understood it, it should choose <code>cbegin/cend</code> if it's <code>const auto &amp;x</code> and not <code>auto &amp;x</code>.</p>
</blockquote>

<p>That's not how the range-based <code>for</code> is defined in the standard. Range-based <code>for</code> always looks for <code>begin()</code> and <code>end()</code>. From <a href=""https://timsong-cpp.github.io/cppwp/n3337/stmt.ranged"" rel=""noreferrer"">https://timsong-cpp.github.io/cppwp/n3337/stmt.ranged</a>.</p>

<blockquote>
  <p>otherwise, <em>begin-expr</em> and <em>end-expr</em> are <code>begin(__range)</code> and <code>end(__range)</code>, respectively, where <code>begin</code> and <code>end</code> are looked up with argument-dependent lookup ([basic.lookup.argdep]). For the purposes of this name lookup, namespace std is an associated namespace.</p>
</blockquote>
",0
44741797,43451246,5,"<p>This is just a typo, the <code>arg.elem.sz</code> is not a valid expression because the <code>arg.elem</code> is a <code>double*</code> which has no member to access (nor with the <code>-&gt;</code> opertor). It should be <code>arg.elem&nbsp;+&nbsp;arg.sz</code> there because this is how the <a href=""http://en.cppreference.com/w/cpp/algorithm/copy"" rel=""nofollow noreferrer""><code>std::copy</code></a> works.</p>

<p>In your update you asked about the <em>iterator</em> and the <a href=""http://en.cppreference.com/w/cpp/algorithm/copy"" rel=""nofollow noreferrer""><code>std::copy</code></a> algorithm. The <code>std::copy</code> is a <a href=""http://en.cppreference.com/w/cpp/language/function_template"" rel=""nofollow noreferrer"">function template</a> which accepts any type as input and as output iterators if they satisfy the requirements of an <a href=""http://en.cppreference.com/w/cpp/concept/InputIterator"" rel=""nofollow noreferrer"">input iterator</a> and of an <a href=""http://en.cppreference.com/w/cpp/concept/OutputIterator"" rel=""nofollow noreferrer"">output iterator</a>. A pointer to an array element satisfies the mentioned requirements, so the <code>arg.elem</code> as being an <code>double*</code> can be used as an iterator.</p>

<p>If we change the questioned line of code to the following, it will make sense:</p>

<pre><code>copy(arg.elem, arg.elem + arg.sz, elem);
</code></pre>

<p>The code above will copy the content of array between <code>arg.elem</code> and <code>arg.elem&nbsp;+&nbsp;arg.sz</code> to the array pointed by <code>elem</code>.</p>
",1
44689197,44689097,1,"<p>There is no direct support in language for this, but you can emulate it using function. For example, let us define a function that accept a string and a vector of strings to be compared:</p>

<pre><code>bool in(const std::string&amp; s, std::vector&lt;std::string&gt; v)
{
    for (auto&amp;&amp; i : v)
        if ( s == i)
            return true;
    return false;
}
</code></pre>

<p>now you can use this function directly in you if statement, using an initilizer list:</p>

<pre><code>int main()
{
    std::string c = ""B"";
    if ( in(c, {""C"",""X"",""I"", ""B""}) )
        std::cout &lt;&lt; ""found\n"";
    else
        std::cout &lt;&lt; ""not found\n""; 
}
</code></pre>
",0
44689227,44689097,1,"<p>You can use the std:: find function to search your array.Suppose your array is arr=[""C"",""X"",""I""] :
tofind string c=""C""
For example your statement will change to:-</p>

<pre><code>  if(find(arr.begin(),arr.end(),c)!=arr.end())
   {
   //found do something

    }
</code></pre>

<p>There is no ""in"" in C++</p>
",0
44689273,44689097,0,"<p>If doing multiple searches, <code>std::set</code> or <code>std::unordered_map</code> (C++11 hash table) will be better performance-wise than linear search through an array with <code>std::find</code>. </p>

<pre><code>std::set&lt;std::string&gt; data_set{""B"",""X"",""I""};
//...somewhere else
bool has_c = data_set.count(c)&gt;0;
</code></pre>

<p>Both <code>std::set</code> and <code>std::unordered_map</code>have a <code>count</code> function that makes testing for a value pretty clean looking, i.e. avoiding iterators.</p>

<h3>Program</h3>

<p>Here's a full working program, </p>

<pre><code>#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;iostream&gt;
using namespace std;
int main()
{
    set&lt;string&gt; data_set{""C"",""X"",""I""}

    //...somewhere else
    string c=""B"";
    if( data_set.count(c)&gt;0 )
    {
        cout &lt;&lt; ""here\n"";
    }
    else
    {
        cout &lt;&lt; ""not\n"";
    }
}
</code></pre>

<p>Don't forget to set C++11 standard when you compile, e.g. <code>g++ -std=c++11 main.cc</code>.</p>
",2
42587371,42587346,4,"<p><code>repeat</code> is a <code>char</code>, you should test against <code>'1'</code>:</p>

<pre><code>//...
while (repeat == '1');
</code></pre>

<p>Otherwise, you're testing against a decimal value of 1, which in the ASCII table is equivalent to an <code>SOH</code> or ""Start of heading"" character, which is not printable.</p>

<p>Additionally, you need to move your request for input to be <em>inside</em> the <code>do</code> portion of the loop:</p>

<pre><code>do
{
    cout &lt;&lt; ""Please enter your expression: "";
    cin &gt;&gt; num_one &gt;&gt; user_operator_one &gt;&gt; num_two;
    cout &lt;&lt; ""\n\n"";
    // ...
</code></pre>
",5
42587445,42587346,0,"<p>You can change </p>

<pre><code>char repeat;
</code></pre>

<p>to</p>

<pre><code>int repeat;
</code></pre>
",2
43962245,43962231,3,"<p>You use \ character to display special characters</p>

<pre><code>cout&lt;&lt;""\\n"";
</code></pre>
",0
43962266,43962231,0,"<p>If you want to display it as escape sequence then you need to escape <code>\</code> like this ""\\n"". If you want to display it as ""non-printable character"" then you might want to use corresponding <a href=""https://en.wikipedia.org/wiki/Unicode_control_characters"" rel=""nofollow noreferrer"">Unicode control characters</a> (<code>u240A</code> particularly).</p>
",0
42641113,42641007,0,"<p>Use <code>*(ptrr+1)</code> and <code>*(ptrr+2)</code>. <code>*</code> has higher priority than <code>+</code>.</p>
",0
42641211,42641007,0,"<p>You have two different issues in your code.</p>

<p>First your loop iterator is wrong. Your array is of size 3 (valid indices are 0, 1, 2), so there is no array[3] (this memory location is out of scope).</p>

<p>you should rewrite your loops like given below</p>

<pre><code>for(int i=2;i&gt;=0;--i){
      array[i]=i*100;cout&lt;&lt;array[i]&lt;&lt;"" ""&lt;&lt; &amp; array[i]&lt;&lt;endl;
}
</code></pre>

<p>Secondly you should use () in below statement.</p>

<pre><code>cout&lt;&lt;ptrr&lt;&lt;"" ""&lt;&lt;*ptrr&lt;&lt;"" ""&lt;&lt;*ptrr+1&lt;&lt;*ptrr+2&lt;&lt;endl;
</code></pre>

<p>and rewrite your statement as </p>

<pre><code>cout&lt;&lt;ptrr &lt;&lt;"" ""&lt;&lt;*ptrr&lt;&lt;"" ""&lt;&lt;*(ptrr+1)&lt;&lt; "" "" &lt;&lt; *(ptrr+2)&lt;&lt;endl;
</code></pre>

<p>The syntax *ptrr is perfectly fine but since you had started your loop from i=3 and terminated at i>0 (i.e. i=1) so array[0] remained uninitialized and garbage value was assigned. But with the initialization in my answer it will work.</p>
",0
42643047,42642935,0,"<p>Head is just a pointer, pointing to NULL. There is no real object / memory allocated for Node. You have first to allocate memory for it. </p>

<p>In your assignment, you can and should (as far as i understand it) add nodes to linked list, so you will have to allocate new nodes . </p>

<pre><code>    struct Node {
    char key;
    Node *next;
};

Node *head = NULL;

int main() {
    char x = 'a';
    head = new Node();
    cout &lt;&lt; x &lt;&lt; endl;
    head-&gt;key = x;
    delete head;
    return 0;
}
</code></pre>
",1
42463662,42462904,0,"<p>This question can be answered by doing a bit of research on google, as it is a very simple program. However, here is a quick explaination:</p>

<pre><code>int a[3] = { 9, 3, 4 };
</code></pre>

<p>This line creates an array that can hold 3 integer values. The values assigned are:</p>

<ul>
<li>a[0] = 9</li>
<li>a[1] = 3</li>
<li>a[2] = 4</li>
</ul>

<p>Then in the for-loop condition:</p>

<pre><code>for (int i = 2; i &gt; 0; i--) {
</code></pre>

<p>A counter int is declared and set to 2. The for loop runs while the counter is greater than 0. After every run, the counter is decremented by 1. If you notice, it runs for <code>i</code> equal to 2 and 1, which covers a[2] and a[1], but NOT a[0]</p>

<p>For every run, the first element of array <code>a</code> is decremented by the value at <code>a[i]</code></p>

<p>In the end, the first element is printed out. Here, <code>9 - 3 - 4 = 0</code></p>
",2
42478066,42477332,0,"<p>First, PaulMckenzie is right in their comment, you should really be using std::vector instead of directly using heap pointers, it is much simpler. </p>

<p>Also I didn't really know what you problem was, so here are some comments.</p>

<p>How is this a matrix if each row can have a different number of elements? That's is just a conceptual thing for me, as of now it is just a list of lists. If that is what you wanted cool, but if you wanted a matrix you need to be stricter on the dimensions.</p>

<p>There isn't anything objectively wrong with the code, I would say that this question really doesn't belong here. There isn't a problem with the code, and if there is please be explicit in saying what the problem is.</p>

<p>EDIT: I see you wanted to adapt it for a matrix, really I would say if you want practice just make a matrix class using std::vector</p>

<p>EDIT: What I meant about create a matrix class is literally that. Define a matrix class type that will handle all the generic operations of matrix of given dimensons, then your main does need all those for loops and iteration for creating the matrix. You would just store them with
<code>std::vector&lt;Matrix&gt; matricies; matricies.push_back(Matrix(2,3))</code></p>

<p>Here is a reference for C++ classes <a href=""http://www.cplusplus.com/doc/tutorial/classes/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/doc/tutorial/classes/</a></p>
",2
42500276,42500204,1,"<blockquote>
  <p>can i limit number of characters to 50?</p>
</blockquote>

<p>You can construct a string with the capacity to hold 50 characters by using:</p>

<pre><code>std::string str(50, '\0');
</code></pre>

<p>However, unlike C arrays, it is possible to increase its size by adding more data to it.</p>

<p>Example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
   std::string str(50, '\0');
   for (size_t i = 0; i &lt; 49; ++i )
   {
      str[i] = 'A'+i;
   }

   std::cout &lt;&lt; str &lt;&lt; std::endl;

   str += "" Some more characters."";

   std::cout &lt;&lt; str &lt;&lt; std::endl;
}
</code></pre>

<p>Output:</p>

<pre class=""lang-none prettyprint-override""><code>ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopq
ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopq Some more characters.
</code></pre>
",1
42533057,42533001,0,"<p>The size of <code>MyClass</code> depends on the size of <code>Data1</code>, which can only be known from the <strong>definition</strong> of <code>Data1</code>. That's why you cannot have incomplete types as fields in your types.</p>
",2
42566195,42565721,0,"<p>You can use ""nested loops"" - an outer loop for games, and an inner loop for turns. I've used a <code>for</code> loop in my example.</p>

<p>Also, no need to convert everything to <code>int</code>. <code>char</code> is an integral type and can be used just like a number:</p>

<pre><code>while (x &lt;= number_of_games) //Need to get it for how many rounds, not how many guesses
{
    // Select a new char (a-z) for each game
    char n = 97 + rand() % 27;
    cout &lt;&lt; ""Lets play game "" &lt;&lt; x &lt;&lt; '\n';
    // 5 guesses
    for (int number_of_guesses = 0; number_of_guesses &lt; 5; number_of_guesses++) {
        cout &lt;&lt; ""Enter your guess: "";
        cin &gt;&gt; guess;
        if (guess &gt; n)
        {
            cout &lt;&lt; ""The letter you are trying to guess is before "" &lt;&lt; guess &lt;&lt; ""\n"";
        }
        else if (guess &lt; n)
        {
            cout &lt;&lt; ""The letter you are trying to guess is after "" &lt;&lt; guess &lt;&lt; ""\n"";
        }
        else
        {
            cout &lt;&lt; ""Your guess is correct! \n"";
            // Break out of the inner for loop, not the while
            break;
        }
    }
    x++;
}
</code></pre>
",1
42590314,42590221,0,"<p>May be you can try something like this :</p>

<pre><code>int main() { cout &lt;&lt; ""Press 1 to enter numbers or 2 to read them from a list."" &lt;&lt; ""\n"";
int choice;
cin &gt;&gt; choice;

if (choice == 1)
{
    choice1();

}
else if (choice == 2)
{
    choice2();

}
return 0;}
</code></pre>

<p>when <code>choice1</code> contains <code>int [...] list.push_back(x);}</code>
etc...</p>
",2
42602263,42602226,1,"<p>Think about what the iterator points to for each go around the loop.</p>

<p>When the iterator becomes equal to <code>colors.end()</code>, it doesn't point to anything and you're not allowed to dereference it.</p>

<p>But you dereference the iterator (<code>itr-&gt;first</code>) <em>before</em> you check whether it is equal to <code>colors.end()</code>.</p>
",1
42602277,42602226,0,"<p>See comments:</p>

<pre><code>for(int i=0; i&lt;10; i++) {
    std::cout &lt;&lt; itr-&gt;first &lt;&lt; std::endl;//Problematic..
    if(itr == colors.end())
        itr = colors.begin();  
    else
        itr++;                           //If this increment results to an `end()` iterator  
}
</code></pre>

<p>You are <strong>unconditionally</strong> accessing the iterator without checking if it's an <code>end()</code> iterator. You should check that the iterator isn't an <code>end()</code> iterator before you access the element it points to.</p>

<p>You can change your loop to:</p>

<pre><code>for(int i=0; i&lt;10; i++){        // Loop more than entries in map
    if( itr != colors.end() ){
        std::cout&lt;&lt; itr-&gt;first &lt;&lt; std::endl;
        ++itr;
    }
    else
         itr = colors.begin();  //start from beginning
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/238075d9a06cf567"" rel=""nofollow noreferrer""><strong>Demo</strong></a></p>
",0
42605131,42605118,3,"<pre><code>if(x == 0)
</code></pre>

<p><code>=</code> is a assignment</p>

<p><code>==</code> is a boolean conditional check.</p>
",0
42605218,42605118,2,"<p>Your if-statement condition should be:</p>

<pre><code>if (x == 0)
</code></pre>

<p>Rather than:</p>

<pre><code>if (x = 0)
</code></pre>

<p>The reason for this is that (=) represents the assignment operator. If we take the following statement:</p>

<pre><code>int num = 5;
</code></pre>

<p>Then, by using the assignment operator here, we set the variable on the left the value on the right; here, we set <code>num</code> to 5. The assignment operator only does this unless it is overloaded (research ""overload operators in c++""). This operator cannot be used to make comparisons.</p>

<p>To make a comparison between 2 values/variables, we use the comparison operator, which is 2 equal signs together (==). This operator checks whether the value or variable on the left side of it equals the value or variable on the right side of it. If they are equal, then it returns true, else it returns false. You want this operator in your if-statement.</p>
",1
42667490,42667312,0,"<p>You want to invert the sequence - so just invert the outer loop:
</p>

<pre><code>for (int row = wordLength; row &gt;= 0; row--)
</code></pre>
",1
43930232,43930043,3,"<p>The constructor for <strong>SquareRectangle</strong> needs to invoke the constructor of its parent class <strong>Rectangle</strong>. The constructor can be coded-up like so:</p>

<pre><code>SquareRectangle::SquareRectangle(double side)
: Rectangle(side, side) {
    this-&gt;side = side;
}
</code></pre>
",0
43963317,43962950,2,"<p>The problem you are still having comes from the fact that you are in no way storing the progress in your key sequence.</p>

<p>Let's say your password is stored in a <code>char</code> array (for easier access to the single characters later on):</p>

<pre><code>#define PWD_LEN 6 // bcqwl has a length of 5 characters but you need +1 for the '\0' (terminating character) at the end of your string
// ...
char password[PWD_LEN] = ""bcqwl"";
</code></pre>

<p>In addition you will need a counter:</p>

<pre><code>#define PWD_LEN 5
// ...
char password[PWD_LEN] = ""bcqwl"";
int progress = 0;

while(true) { ... }
</code></pre>

<p>Both need to be stored before and outside the <code>while</code> loop because both store data that you don't want to reset in each iteration step in your loop.</p>

<p>The counter will be used to track the progress of the user towards completing the key sequence your password represents.</p>

<p>Whenever the user presses a key you will need to do the following checks:</p>

<ul>
<li>Is the key allowed? - if you have a password <code>abc</code> but the user presses <code>y</code> or <code>!</code>, or something other then <code>a</code>, <code>b</code> or <code>c</code> the key is not allowed.</li>
<li><p>If the key is allowed take the character it represents and check if it's the same as the character in your <code>password</code> at index <code>progress</code>:</p>

<pre><code>if ( key allowed )
{
  if (password[progress] == '&lt;your key character here&gt;')
  {
    ++progress;
  }
  else
  {
    // Handle incorrect key stroke relative to key sequence
  }
}
</code></pre></li>
</ul>

<p>Now in order to prevent the counter going bananas I would suggest doing all the checking upon <strong>key released</strong>, which unlike <strong>key pressed</strong> is a one time event. A key being pressed can also be part of <strong>key hold</strong>, in which case you will land in the <code>else</code> (from the code snippet above) many times, which might not be such a good idea.</p>

<p>If the key is ok and in terms of sequence it fits your password then you increase the progress so that in the next iteration step you can do the same check with a new released key event and a new index value for accessing your password array.</p>

<p>When your <code>progress</code> reaches the required value indicating that the key sequence is completed and that all the characters your password consists of have been ""inserted"" you can break the loop.</p>

<p>This is very basic so I hope that the instructions are clear enough for you to implement.</p>

<hr>

<p><strong>PREVIOUS ANSWER</strong> (now obsolete due to change in the question)</p>

<p>Unless other out-of-the-box way is available to do that (I haven't used <code>GetKeyState()</code> or anything else from <code>windows.h</code>) the general practice is to simply store the <code>pressed</code> state of each button (in an array, a <code>struct</code> etc.).</p>

<p>In your loop you can use a simple chain of <code>if</code> statements (but not nested like you do it!) to check which button is pressed during the current iteration step. Whenever a known key (one that you application wants to process) is pressed, you just need to toggle the respective state of that button in your array, <code>struct</code> or whatever other container you use to store this information:</p>

<pre><code>while(true)
{
  // Check state of supported buttons
  if(GetKeyState('A') &amp; 0x8000)
  {
    // store change of state of key A
  }
  if(GetKeyState('B') &amp; 0x8000)
  {
    // store change of state of key B
  }
  if (...)
  {
    // ...
  }
}
</code></pre>

<p>At the end or beginning of your <code>while</code>'s body you can then ask for the state of each button and also make combined queries:</p>

<pre><code>while(true)
{
  // Check state of supported buttons
  if(GetKeyState('A') &amp; 0x8000)
  {
    // store change of state of key A
  }
  if(GetKeyState('B') &amp; 0x8000)
  {
    // store change of state of key B
  }
  if (...)
  {
    // ...
  }


  // Do something


  // Check for states of buttons
  // ...
}
</code></pre>

<p>For example let's say you are using the following structure to store the key's state:</p>

<pre><code>typedef struct Key
{
  char keyCode;
  bool pressed;
} Key;

Key keyA;
keyA.pressed = false;
</code></pre>

<p>you can simply do</p>

<pre><code>if (keyA.pressed)
{
  // Trigger some change that key 'A' controls
}
</code></pre>

<p>to check if your specific button is currently pressed and respectively trigger some action.</p>

<p>For key combinations things are not much different. You just need to use simply boolean logic to handle it:</p>

<pre><code>if (keyA.pressed &amp;&amp; keyB.pressed)
{
  // Both key 'A' and 'B' are pressed - we have a key combo!
}
</code></pre>

<p>You can improve the readability of your code by storing all supported buttons in an array and even adding a nice <code>enum</code> to provide easy access to each button:</p>

<pre><code>enum KeyCode
{
  A,
  B,
  ...
};

 Key keys[n]; //with n being the number of keys you want to support and also the number of elements your enum has

// Access with an improved readability
if (keys[A].pressed &amp;&amp; keys[B].pressed)
{
  // ...
}
</code></pre>

<p>If you can't find any code for <code>GetKeyState()</code> in particular (highly unlikely) you can look at <code>SDL</code> for example.</p>
",11
43972835,43971954,0,"<p>To me this seems like a typical code generalization problem (so i won't go into details regarding this specific example). There's propably a lot of different ways of dealing with this, but this would be a way by refactoring the existing code base.</p>

<p>As pointed out in your code comments, the repeating code is the part responsible for reading and processing the file input so i would recommend starting by trying to write that part into it¡äs own subroutine by using variables when necessary. For instance (returning the resulting vector):</p>

<pre><code>vector&lt;CircleData&gt; read_and_process_file_input(std::string filename)
{
    // Read data
    ifstream data (filename);
    vector&lt;float&gt; row(2);
    vector&lt;vector&lt;float&gt;&gt; XY;

    while (data &gt;&gt; row[0] &gt;&gt; row[1])
    {
        XY.push_back(row);
    }
    data.close();
    // Convert XY-coordinates to pixels with image size as parameter
    CoordinatesToImage convert1(XY, 300);
    // Do Hough transformation, then search for the strongest circles in the data 
    CircleHough test1;
    return test1.houghPeaks(test1.houghTransform(convert1.getScan(), radius), radius, 7);
}
</code></pre>

<p>You can iterate over this with a for loop (indexing starting from 1):</p>

<pre><code>for(int i = 1; i &lt; no_files+1; i++)
    read_and_process_file_input(""data"" + i + "".txt"");
</code></pre>

<p>If you don't know the number of input files or if you want to avoid hard-coding those you would have to add existence check 
for each new input file.</p>

<p>How you want to store the resulting data depends largely on the application; You could use a data structure to replace variables out*.
Alternatively (knowing the no of input files) it might be more efficient to store those in a matrix (each output data as a column)</p>
",3
43972626,43971954,1,"<p>Add a method.</p>

<pre><code>void do_something(std::string file_name){
    ifstream data1{file_name};
    vector&lt; vector&lt;float&gt; &gt; XY;
    while (data1 &gt;&gt; row1[0] &gt;&gt; row1[1])
    {
        XY.push_back(row1);
    }
    data1.close();
    // Convert XY-coordinates to pixels with image size as parameter
    CoordinatesToImage convert1(XY, 300);
    // Do Hough transformation, then search for the strongest circles in the data 
    CircleHough test1;
    out1 = test1.houghPeaks(test1.houghTransform(convert1.getScan(), radius), radius, 7);
}
</code></pre>
",1
43231395,43230091,0,"<p>Assuming you write the matrix in <a href=""https://en.wikipedia.org/wiki/Row-_and_column-major_order"" rel=""nofollow noreferrer"">row-major order</a> into an <code>std::vector&lt;int&gt;</code> named <code>m</code> and <code>width</code> is the number of digits in one row, this would be an implementation of a breadth-first search algorithm:</p>

<pre><code>// these are the x values
#define OBSTACLE -1
// these are empty fields
#define EMPTY -2

std::vector&lt;int&gt; m;
int width;

// TODO: fill the vector here with OBSTACLEs and EMPTY and set the width!

// the list contains indexes of filled, yet unprocessed fields
std::queue&lt;int&gt; worklist;

// now initialize the starting zeroes. I am using the indexes
// from your example matrix here.
worklist.push(1 * width + 12); m[1 * width + 12] = 0; // second row, 13th field
worklist.push(1 * width + 13); m[1 * width + 13] = 0; // second row, 14th field
worklist.push(1 * width + 14); m[1 * width + 14] = 0; // .. and so on.
worklist.push(1 * width + 15); m[1 * width + 15] = 0;

// algorithm
while (worklist.size() &gt; 0) {
    const int cur = worklist.front();
    worklist.pop();
    const int newval = m[cur] + 1;
    int directions[4] = {0, 0, 0, 0};
    if (cur &gt;= width) {
        // we are not on the first row, check upwards
        directions[0] = -width;
    }
    if (cur % width != 0) {
        // we are not on the first column, check left
        directions[1] = -1;
    }
    if ((cur + 1) % width != 0) {
        // we are not on the last column, check right
        directions[2] = 1;
    }
    if (cur + width &lt; m.size()) {
        // we are not on the last row, check downwards
        directions[3] = width;
    }
    // I am not calculating diagonal connections here; you also seem to
    // want those. They would be trivial to add.
    for (int i = 0; i &lt; 4; ++i) {
        if (directions[i] != 0) {
            const int index = cur + directions[i];
            if (m[index] == EMPTY) {
                m[index] = newval;
                worklist.push(index);
            }
        }
    }
}
</code></pre>
",7
43769079,43434559,0,"<p>The member function in your class <code>Symbol_table</code> is called <code>double get(string s);</code>, but you actually defined it as <code>double Symbol_table::get_value(string s)</code></p>

<pre><code>double Symbol_table::get(string s) { //instead of get_value(string s)
</code></pre>
",0
43983995,43983910,1,"<p>The issue lies in the function definition: <code>void BST::insert(node *tree, node *newnode)</code>.  Your declaration in the class <code>BST</code> indicates one argument <code>void insert(int);</code> rather than two as is created in your definition.  The compiler sees it as a different definition from the declaration.</p>

<p>Also, if I might add, you're passing an integer variable type in the definition rather than two node pointers</p>
",1
43984003,43983910,2,"<p>The signature of the insert method differ between declaration and definition:</p>

<pre><code>...
void insert(int);
...

void BST::insert(node *tree, node *newnode) {...}
</code></pre>
",0
43749068,43723080,4,"<p><strong>for this code you you need to two more header file</strong></p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
</code></pre>

<p><strong>your full code will be</strong></p>

<pre><code>#include&lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
using namespace std;

int main()
{
    char input[2000];


    cin.getline(input, sizeof(input));

    int lol = strlen(input);
    int boing = 0;
    for (int p = 0; p &lt; lol; p++)
    {

        if (input[p] == '\""')
       {
           boing++;
           if (boing % 2 == 1)
           {
               cout &lt;&lt; '\`'&lt;&lt;'\`';
           }
           if (boing % 2 == 0)
           {
              cout &lt;&lt; '\''&lt;&lt;'\'';
           }
      }
      else
        cout &lt;&lt; input[p];
   }

   cout&lt;&lt;endl;   //this line is for making ur code look nice

   system(""pause"");
}
</code></pre>

<p><strong>but i personally suggest you to use c++ string class for string handling</strong>
<strong>it easy and very useful</strong></p>

<p><strong>using string class your code will be</strong></p>

<pre><code>#include&lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdlib.h&gt;
using namespace std;

int main()
{

   string input;

   getline(cin,input);

   int lol = input.size();

   int boing = 0;
   for (int p = 0; p &lt; lol; p++)
   {

      if (input[p] == '\""')
      {
          boing++;
          if (boing % 2 == 1)
          {
             cout &lt;&lt; '\`'&lt;&lt;'\`';
          }
          if (boing % 2 == 0)
          {
              cout &lt;&lt; '\''&lt;&lt;'\'';
          }
      }
      else
          cout &lt;&lt; input[p];
   }

   cout&lt;&lt;endl;
   system(""pause"");

   return 0;

}
</code></pre>

<p><strong>Happy Coding</strong></p>
",0
43723170,43723080,4,"<p>You need to wrap your <code>getline</code> in some form of loop.  Right now you are getting 1 line, then manipulating <code>input</code> then exiting.  Right now you are pulling it in from the user so you need to look for a terminator.</p>
",0
43723991,43723080,5,"<p><code>getline</code> will take input until the ""enter"" button is pressed. 
Your code runs fine on my machine.
Just add <code>string.h</code> header file like this:</p>

<p><code>#include&lt;string.h&gt;</code></p>

<p>This is for the <code>strlen</code> function.</p>
",0
43749068,43723080,4,"<p><strong>for this code you you need to two more header file</strong></p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
</code></pre>

<p><strong>your full code will be</strong></p>

<pre><code>#include&lt;iostream&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
using namespace std;

int main()
{
    char input[2000];


    cin.getline(input, sizeof(input));

    int lol = strlen(input);
    int boing = 0;
    for (int p = 0; p &lt; lol; p++)
    {

        if (input[p] == '\""')
       {
           boing++;
           if (boing % 2 == 1)
           {
               cout &lt;&lt; '\`'&lt;&lt;'\`';
           }
           if (boing % 2 == 0)
           {
              cout &lt;&lt; '\''&lt;&lt;'\'';
           }
      }
      else
        cout &lt;&lt; input[p];
   }

   cout&lt;&lt;endl;   //this line is for making ur code look nice

   system(""pause"");
}
</code></pre>

<p><strong>but i personally suggest you to use c++ string class for string handling</strong>
<strong>it easy and very useful</strong></p>

<p><strong>using string class your code will be</strong></p>

<pre><code>#include&lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdlib.h&gt;
using namespace std;

int main()
{

   string input;

   getline(cin,input);

   int lol = input.size();

   int boing = 0;
   for (int p = 0; p &lt; lol; p++)
   {

      if (input[p] == '\""')
      {
          boing++;
          if (boing % 2 == 1)
          {
             cout &lt;&lt; '\`'&lt;&lt;'\`';
          }
          if (boing % 2 == 0)
          {
              cout &lt;&lt; '\''&lt;&lt;'\'';
          }
      }
      else
          cout &lt;&lt; input[p];
   }

   cout&lt;&lt;endl;
   system(""pause"");

   return 0;

}
</code></pre>

<p><strong>Happy Coding</strong></p>
",0
43952732,43952697,-1,"<p><strong>Overloading</strong> happens when you change the original types for the arguments in the signature of a method.</p>

<p><strong>Overriding</strong> happens when you change the original definition of a method</p>
",2
45109578,45109060,3,"<p>Floating point numbers have a limited precision. Usually, float is a 32-bit number, double is a 64-bit one. Float can store integer numbers precisely if the number is less than or equal to 16777216 (it is 2^24).</p>

<p>So, when 123456789 is read into a float variable, will have a different value, it becomes 123456792. At this point, there is no rationale to count trailing zeros.</p>

<p>Double can store integer numbers precisely if it is less than or equal to 9007199254740992 (2^53).</p>

<p>An <code>unsigned long long int</code> can store integer numbers less than 2^64. If you choose this way, use this condition for checking trailing zero: <code>if (number%10==0)</code></p>

<p>If you only want to count trailing zeros, and that's all, then use <code>std::string</code> instead. This way you can handle as big numbers as you like.</p>
",0
43934509,43930161,0,"<p>Method 2 is better. Some comments:</p>

<p>1) all behavior for handling the data should be encapsulated in a class for handling the data. there should be no conditional statements which depend on types of data in the managing classes.</p>

<p>2) use factory pattern for creating new objects without changing the previously defined classes:</p>
",0
43941630,43941513,3,"<p>From the problem page:</p>

<blockquote>
  <p>both not greater than 200</p>
</blockquote>

<p>That's almost certainly a clue. But you shouldn't care.</p>

<p>The real answer to this question is to stop playing with these utterly stupid ""online judges"" that test nothing of any real value whatsoever. Maybe you could ""optimise"" this code to be faster, with some assembly or something, but why on earth would you want to? This is about as good as it gets for most real-world practical purposes. Anything else is just a waste of your time, unless you have an extremely narrow and niche use case.</p>

<p>Speaking more opportunely, is it possible that you have misunderstood the requirements of the task, and are trying to read too much input from STDIN? Then your program would be blocking on the rest. This program should not take anywhere near 0.2s. <a href=""http://coliru.stacked-crooked.com/a/ea7fda326bf89e17"" rel=""nofollow noreferrer"">For me it takes 0.009s</a>.</p>
",2
43951895,43951656,2,"<p>There's no need for <em>conversion</em>, <code>std::vector&lt;CategoryStruct&gt;</code> already stores the data in a contigous memory area. so your function could be boiled down to</p>

<pre><code>std::vector&lt;CategoryStruct&gt; categories;
char * Category::decodeCategoryToCharArray()
{
    return reinterpret_cast&lt;char*&gt;(categories.data());
}
</code></pre>
",2
43962842,43962769,0,"<p>Class A has a constructor which receives an integer as a parameter.</p>

<p>Therefore, the integer parameter passed to fun is automatically casted to A.</p>

<p>In this automatic cast process, an A object (called temp) is created, and it's field 'a' is initialized with 1.</p>
",2
43962863,43962769,0,"<p>I commented the code for you and made it a bit more clear to read. 
Read the comments from (1) -> (5).</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

class A {

public:
    A(int x) // (3): gets called by f to initialize an object of class A with x=1
    {
        a = x;
    }

    int a;
};

void fun(A temp) // (2): Assumes 1 is a type class A. But it hasn't yet been initialized. So it calls Constructor. (tmp = new A(1))
{
    // (4): Now temp is an object of class A
    cout &lt;&lt; temp.a &lt;&lt; endl; // Prints temp.a
    // (5): temp object is getting destroyed.
}

int main()
{
    fun(1); // (1): Calls fun() with argument of 1
}
</code></pre>
",0
44233498,44233103,0,"<p>Use a vector to store the input.</p>

<pre><code>#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
using names pace std;

int main ()
{
   vector &lt;string&gt; input;
   string tmp;

   while (getline(cin, tmp))
      input.push_back(tmp));

   for(auto s : input)
      cout &lt;&lt; s &lt;&lt; '\n';
}
</code></pre>
",0
44233212,44233103,0,"<p>Arrays must have a constant size at compile-time so to create an array with dynamic size you can create it on the heap using keyword <code>new</code> and <code>delete[]</code> to free up memory.</p>

<p>Also what is the point in: </p>

<pre><code>cin &gt;&gt; a;
b = a - 1; //?
</code></pre>

<p>You can easily do it like this:</p>

<pre><code>int n;
cout &lt;&lt; ""how many input you want to give ? "";
cin &gt;&gt; n;
string* str = new string[n];            
for(int i = 0; i &lt; n; i++){
    cout &lt;&lt; ""Enter a string: "";
    getline(cin, str[i]);
}

for(int k = 0; k &lt; n; k++){
    cout &lt;&lt; ""You entered: "" &lt;&lt; str[k] &lt;&lt; endl;
}
</code></pre>

<p>Don't forget to clean when you're done:</p>

<pre><code>delete[] str;
</code></pre>
",0
44233233,44233103,0,"<p>You'll want to clear the input buffer, the newline from ""How many input you want to give ?"" is being fed into the first ""Enter a string:"".</p>

<p>Add this line after cin>>a;</p>

<pre><code>cin.ignore(INT_MAX, '\n');
</code></pre>
",0
44350882,44350438,1,"<p>It's easier to understand with some aliasing.</p>

<pre><code>//pointer to function taking no arguments and void return
typedef void(*function_pointer)();

//function taking ""function_pointer"" and returning ""function_pointer""
function_pointer __set_malloc_handler(function_pointer __f);
</code></pre>

<hr>

<p>To read something like that, I recommend the <a href=""http://c-faq.com/decl/spiral.anderson.html"" rel=""nofollow noreferrer"">right-left rule</a>. It's what I always use. There's also a <a href=""http://c-faq.com/decl/spiral.anderson.html"" rel=""nofollow noreferrer"">spiral rule</a>, but I get annoyed when it doesn't form a perfect spiral and I get too distracted by that to focus. You probably won't have that issue.</p>

<p>The explanation on either page is more thorough, but here's a crash course.</p>

<p>Essentially, read these symbols as:</p>

<ol>
<li><code>*</code> = ""pointer to""</li>
<li><code>(...)</code> = ""function taking <code>...</code>""</li>
<li><code>[...]</code> = ""array of size <code>...</code>""</li>
</ol>

<p>Read to the right until you find a <code>)</code> that didn't have a matching <code>(</code> yet. Then read to the left until you find a <code>(</code> to match it. Start reading right again. If you hit the end of the line on the right, you finish reading to the left.</p>

<p>To the immediate right of the identifier <code>__set_malloc_handler</code> is an open parenthetical <code>(</code>, meaning it is a function. Everything from that to the matching <code>)</code> is the parameter type. I'd recommend ignoring it at first and coming back to it later. Step by step:</p>

<pre><code>       __set_malloc_handler(...)    //function taking ...
     (*__set_malloc_handler(...))   //and returning a pointer
     (*__set_malloc_handler(...))() //to a function taking no arguments
void (*__set_malloc_handler(...))() //that returns void
</code></pre>

<p>Looking at the parameter, we have:</p>

<pre><code>     (*__f)   //pointer
     (*__f)() //to function taking no arguments
void (*__f)() //and returning void
</code></pre>
",1
44350920,44350438,1,"<p><code>__set_malloc_handler</code> is a function that takes a ""function pointer to a void function"" and returns a ""function pointer to a void function"". Keyword <code>static</code> makes it only visible to the current file.</p>
",0
44358696,44358221,0,"<p>If you are using decimals then you need to use <code>double</code> instead of <code>int</code>. A <code>double</code> is a floating point type. An <code>int</code> (integer) is a whole number and a number that is not a fraction. Therefore, using <code>int</code> for decimal won't work</p>

<pre><code>int a = 1.22;
cout &lt;&lt; a &lt;&lt; endl;
//this will display 1
double b = 1.22;
cout &lt;&lt; b &lt;&lt; endl;
//this will display 1.22
</code></pre>

<p>because your compiler will use the whole number in front of the decimal not anything after it. </p>
",3
44361046,44358221,0,"<p>I figured it out, the only issue is that the tax is off by a penny. I dunno why but it's close enough.</p>

<p>Final code: </p>

<pre><code>    // John Mayer Learning Unit 2 Assessment

#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;


int main()
{
    string roomName; // declarations
    double roomLength;  
    double roomWidth;
    double squareFeet;
    double carpetPrice;
    double paddingCost;
    double totalCarpetCost;
    const double TAX_RATE = .057;
    double laborCost;
    const double LABOR_RATE = 6.03;
    int squareYard;
    double subtotal;
    double taxCost;
    double totalCost;

    cout &lt;&lt; setw(15)&lt;&lt;""""&lt;&lt; ""Welcome to John Mayer's Carpet Calculator!""; // displays this at the top
    cout &lt;&lt; ""\n\n What is the name of the room to be carpeted? ""; // asks for the room name
    cin &gt;&gt; roomName; // stores the room name
    cout &lt;&lt; ""\n What is the length of the room (in feet)? ""; // asks for the length
    cin &gt;&gt; roomLength; // stores the length
    cout &lt;&lt; ""\n What is the width of the room (in feet)? ""; // asks for the width
    cin &gt;&gt; roomWidth; // stores the width
    cout &lt;&lt; ""\n What is the price of the carpet per yard? ""; // asks for the price of the carpet
    cin &gt;&gt; carpetPrice; // stores the price
    cout &lt;&lt; ""\n What is the padding cost? ""; // asks for the padding cost 
    cin &gt;&gt; paddingCost; // stores the padding cost (this didn't originally work because carpetPrice was int, not double

    squareFeet = roomLength * roomWidth; // finds square feet by multiplying length and width
    //squareYard = (squareFeet / 9) + 1; // (Original code before realizing a 3x3 room would not work correctly
    squareYard = squareFeet / 9; // finds square yardage
    if ((int)squareFeet % 9 != 0)  // if the remainder does not equal 0 after dividing by nine, then...
        {squareYard++;} // ...round up 1
    totalCarpetCost = carpetPrice * squareYard; // finds the carpet cost by multiplying the input carpet price by the square yardage
    laborCost = squareYard * LABOR_RATE; // finds the labor cost by multiplying the yardage by the labor rate of 6.03
    subtotal = (totalCarpetCost + paddingCost + laborCost); // finds the subtotal by adding the labor cost, carpet cost, and padding cost
    taxCost = subtotal * TAX_RATE; // finds the tax cost by multiplying the subtotal by the tax rate of .057 (5.7%)
    totalCost = taxCost + subtotal; // adds the subtotal and tax to find the total overall cost
    cout &lt;&lt; ""\n\n"" &lt;&lt; setw(20) &lt;&lt; """" &lt;&lt; ""Carpet estimate for "" &lt;&lt; roomName; // displays text and the room name

    cout &lt;&lt; ""\n\n Total square feet of the room: "" &lt;&lt; squareFeet; //displays the square feet calculation **CORRECT
    cout &lt;&lt; ""\n\n Total square yards of the room: "" &lt;&lt; squareYard; // displays the square yards calculation **CORRECT
    cout &lt;&lt; ""\n\n\n Total cost of the carpet needed: "" &lt;&lt; totalCarpetCost; // displays the carpet cost **INCORRECT
    cout &lt;&lt; ""\n\n Total cost of labor (at $6.03/yd): "" &lt;&lt; laborCost; // displays the labor cost 
    cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; ""\n\n Padding Cost: "" &lt;&lt; paddingCost; // displays the padding cost 
    cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; ""\n\n\n Subtotal: "" &lt;&lt; subtotal; // displays the subtotal
    cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; ""\n\n Tax: "" &lt;&lt; taxCost; // displays the tax calculation
    cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; ""\n\n Total: "" &lt;&lt; totalCost; // displays the final total cost
    cout &lt;&lt; ""\n\n""; // line break


    system(""PAUSE""); 
  return 0;


}
</code></pre>
",2
44358637,44358557,3,"<p>The problem is that C functions are not compatible with C++ structures. Try doing this instead:</p>

<pre><code>printf(""%s"", transicoes[i][j][k].c_str());
</code></pre>

<p>The <code>c_str()</code> call returns a const <code>char*</code> to a null-terminated character array with data equivalent to those stored in the string, which is a C-like string.</p>

<p>But if you are working with C++, you should use the stream operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code>. The code would then loop like this:</p>

<pre><code>std::cout &lt;&lt; transicoes[i][j][k] &lt;&lt; endl;
</code></pre>
",1
44369186,44369035,0,"<p>You know, a string is an array of <code>char</code>, which means you can do this.</p>
<pre><code>string stringToGuess;
cout &lt;&lt; &quot;Hello user, please enter a word to play hangman&quot; &lt;&lt; endl;
cin &gt;&gt; stringToGuess;
for(int  i = 0; i &lt; stringToGuess.length(); i++)
{
    cout &lt;&lt; stringToGuess[i];
}
</code></pre>
",1
44369119,44369035,0,"<p>Since the length of the array is not known at compile time, you can not use an automatic array. The array has to be allocated dynamically. The simplest solution to copy a string into an array would be to use <code>std::vector</code>.</p>

<p>However, I suspect that your desire to create an array from a string is ill-founded. You probably don't need to do it. You could rewrite your loop like this:</p>

<pre><code>cin &gt;&gt; stringToGuess;
for (char c : stringToGuess) { 
    cout &lt;&lt; c &lt;&lt; "" "";
}
</code></pre>

<hr>

<blockquote>
<pre><code>char arr_To_Guess[arrLength]
</code></pre>
</blockquote>

<p>The problem I mentioned earlier, <code>arrLength</code> is not known at compile time, so this declaration is ill-formed.</p>

<blockquote>
<pre><code>= {atoi(stringToGuess.c_str())};
</code></pre>
</blockquote>

<p>This is very strange. You attempt to initialize the first character of the new array to have the numeric value of whatever the string represents. For example:</p>

<pre><code>string: ""123""
becomes: [123, 0, 0]
</code></pre>

<p>I suspect that this is not what you intended.</p>
",0
44697182,44697164,2,"<p>(Restricting this answer to IEEE754).</p>

<p>This is <em>only</em> possible if one of the terms is NaN, or some manifestation of undefined behaviour in your accessing outside the bounds of the array <code>a</code> or <code>b</code>, or reading uninitialised data.</p>

<p>Under IEEE754, you can't attain NaN by a multiplication of large values.</p>

<p>From C++11, you can use <code>std::isnan</code> to detect a NaN, prior to that or in C, use the idiom </p>

<pre><code>if (f != f){
    // `f` is NaN
}
</code></pre>

<p>So, setting the undefined behaviour aside, the cause of the issue is higher up the call stack. Expressions such as 0.0 / 0.0 will generate a NaN.</p>

<hr>

<p>Regarding your statement</p>

<blockquote>
  <p>some value is divided by 0</p>
</blockquote>

<p>the <em>only</em> value of ""some value"" that when divided by 0.0 gives you NaN is 0: <code>0.0 / 0.0</code> is NaN, and <code>a / 0.0</code> is +Inf if <code>a</code> is positive, and -Inf if <code>a</code> is negative.</p>
",3
44700439,44700344,1,"<p>Try to use faster approach. Use binary_search to find the last element less than given one. </p>
",1
44700706,44700344,0,"<p>Using the fact that the vector is sorted can help speed up the code by not looking at the whole vector. </p>

<pre><code>If (sortedVector[i]&gt;=lessthan)
{
     return a;
}
</code></pre>

<p>This will terminate your loop when you hit an element that is greater than the lessthan and will save you unnecessary iterations. For your given main, it'll only go through 2 iterations instead of 4.</p>

<p>While this doesn't specifically address the problems mentioned above, see if it gives you enough performance boost with the test cases to pass them. This'll also make your worst case performance O(n) instead of O(n) for every run </p>
",2
44706181,44700344,4,"<p>You can take advantage of the fact the data is sorted to find the answer in logarithmic time. The C++ standard library has an algorithm for this task.</p>

<p>Use <a href=""http://en.cppreference.com/w/cpp/algorithm/lower_bound"" rel=""nofollow noreferrer""><code>std::lower_bound</code></a> to find the first element greater or equal to your target value. Then call <a href=""http://en.cppreference.com/w/cpp/iterator/distance"" rel=""nofollow noreferrer""><code>std::distance</code></a> to return the count of elements from the start of the container to the location found in the previous step.</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iterator&gt;

class SortedSearch
{
public:
    static int countNumbers(const std::vector&lt;int&gt;&amp; sortedVector, int lessThan)
    {
        // get an iterator to the first element &gt;= lessThan
        auto itr = std::lower_bound(std::begin(sortedVector), std::end(sortedVector), lessThan); // O(log n)

        // return the distance between two iterators
        return std::distance(std::begin(sortedVector), itr); // O(1)
    }
};
</code></pre>
",9
46946018,46945748,1,"<p>I don't see any reason why you should be printing the contents of the vector with the same index variable which is looping around the even numbers that you are adding. Perhaps, you should structure your code this way :</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main()
{
    vector&lt;int&gt; vect_name;
    //push to vector
    for (int i=10; i&lt;21; i=i+2) {
        vect_name.push_back(i);
    }

    // print the contents of vector
    for (size_t i =0; i &lt; vect_name.size(); ++i) {
        cout &lt;&lt; vect_name[i] &lt;&lt; "" "";
    }
    cout &lt;&lt; '\n';

    return 0;    
}
</code></pre>
",1
46945804,46945748,0,"<p>This is because you are missing a brace of the for loop.
The looping variable you created in the for loop has a scope limited to it's braces, since you are missing the braces it takes just the next line only.</p>

<p>Because of that the loop variable i is not available</p>

<pre><code> int main()
{
vector&lt;int&gt; vect_name;
for (int i=10; i&lt;21; i=i+2)
   vect_name.push_back(i);


for(int i=0; i&lt;vect_name.size(); i++)
   cout &lt;&lt; vect_name[i] &lt;&lt;endl;

return 0;

}
</code></pre>

<p>This should fix it.</p>
",4
46946443,46945748,0,"<p>You must be getting this error</p>

<pre><code>error: ¡®i¡¯ was not declared in this scope
cout &lt;&lt; vect_name[i] &lt;&lt;endl;
                  ^
</code></pre>

<p>Enclose the statements in parentheses to indicate loop body. Without the braces, only one following statement is taken as loop body.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
    vector&lt;int&gt; vect_name;
    for (int i = 10; i &lt; 21; i = i + 2) {
        vect_name.push_back(i);
        cout &lt;&lt; vect_name[i] &lt;&lt; endl;    // Will print zeroes
    }
    return 0;
}
</code></pre>

<p>However this will still give wrong results because arrays/vectors are 0 indexed in C++. You need to print in a separate loop.</p>

<p>A correct version of code will look like</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
    vector&lt;int&gt; v(6, 10);
    for (int i = 0; i &lt; v.size(); i++) {
        v[i] += (i * 2);
        cout &lt;&lt; v[i] &lt;&lt;endl;
    }
    return 0;
}
</code></pre>

<p>Output</p>

<pre><code>10
12
14
16
18
20
</code></pre>
",0
46950300,46949897,2,"<pre><code>class data_base
{
  string name;
  ...
}
...
data_base d;
...
file.write((char *)&amp;d,sizeof(d));
</code></pre>

<p>You are already doomed here. The <code>std::string</code> struct has a pointer inside. Reinterpreting this pointer as a char array gives you some sequence of chars. You save it to a file and then read it some time later.</p>

<p>At that moment your newly read <code>data_base</code> variable has <strong>exact</strong> binary representation as the one before. But now the internal pointer of <code>std::string</code> no longer points to a valid memory address, hence segfault.</p>

<p>Note that segfaulting is actually good. In some bad case the memory address would be valid but it would point to some completely unrelated (random) data. That would be a bug <strong>extremely</strong> hard to find.</p>

<p>You are doing this wrong from the begining. <strong>Don't cast to/from <code>char*</code> for serialization/deserialization</strong> of data. Use proper serialization techniques, e.g. convert the structure to xml, json, google protobuf or even come up with something custom. Just don't reinterpret raw memory. Even if there are no pointers inside your struct the binary representation is compiler, os and cpu dependent.</p>
",0
46061938,46040124,0,"<p>Almost <strong>50</strong> years have passed since professor Edsger W. Dijkstra wrote his paper ""Go To Statement Considered Harmful"" (<em>Communications of the ACM</em> 11, 3, March 1968, p. 147-148.) and still unjustified uses of that construct can be found.</p>

<p>OP's first snippet can be summerised as:</p>

<pre><code>bool add_new_number_when_up()
{
    // ...
    while(true) {
        if( /* some unexplained condition */ ) {
            loop:                    // &lt;- ""loop"" start
            int a = rand() % 8;
            switch(a) {
            case 0:
                if( /* something */ ) {
                    // ...
                    return false;
                }
                else {
                    goto loop;      // &lt;- ""loop"" end
                }
                break;              // never reached...
            // many other cases...
            }
        }
        else {
            return false;
        }
    }
}
</code></pre>

<p>Which, besides the lack of any <code>return true</code>, could be (but really should not) rewritten as</p>

<pre><code>bool add_new_number_when_up()
{
    // ...
    while(true) {
        if( /* some unexplained condition */ ) {
            while(true) {                    // &lt;- nested loop!
                int a = rand() % 8;
                switch(a) {
                case 0:
                    if( /* something */ ) {
                        // ...
                        return false;        // true?
                    }
                    break;                   // &lt;- restart the loop...
                // many other cases...
                }
            }            
        }
        else {
            return false;
        }
    }
}
</code></pre>

<p>Writing an infinite loop as <code>loop: ... goto loop;</code> instead of <code>while(1) {...}</code> doesn't make it magically faster, but it can surely obfuscate your code and it's more error prone.</p>

<p>The second snippet is even worse:</p>

<pre><code>bool add_new_number(int num)
{
    Loop:                      // &lt;- what kind of loop is this?
    // some expansive function which shouldn't be here...
    // ... 
    while(true) {
        if( /* call to another relatively expansive function */ ) {
            if( /* some condition */ ) {
                // call to another expansive function...
                return false;
            }
            else {
                goto Loop;          // &lt;- end of loop?
            }
        }
        else {
            break;
        }
    }
}           // &lt;- a return statement is missing!
</code></pre>

<p>The OP complains about the slowness of this code, which is unsurprising, given the overall design and the functions involved.</p>

<p>For example, there are multiple calls to <code>srand</code>, which are not only expansive, but also unnecessary as one call in the entire program, to seed the pseudo random number generator, is enough. The same would hold even for the ""modern"" <code>&lt;random&gt;</code> generators, like <code>std::random_device</code> and <code>std::mt19937</code>.</p>

<p>Making any kind of micro optimization at this point is useless, though. It is far better to figure out a completely different algorithm.</p>

<blockquote>
  <p>Those functions are about to find a place where no number has taken
  and then place the new number.</p>
</blockquote>

<p>My suggestion is to firstly determine which cells of the grid are empty. Just traverse half of the grid (which part, depends on the direction passed to the function) and add the empty ones (or their indeces) to a list (could be an array...) of candidates. There are 8 at most of those, it is a very small domain, it has to be a fast loop (or nested loops).</p>

<p>If there aren't any valid candidates, then return false, no number is added.</p>

<p>Otherwise, you can extract a random index between 0 and the number of candidates - 1 to choose between them the cell to be updated. You don't need to check again if it is empty, thanks to the previous step, just extract a number between 1 and 2 to use as new value and return true.</p>
",0
45056427,45056234,6,"<p>You have made an <em>assumption</em> that <code>&gt;</code> and <code>&lt;</code> perform lexicographic comparison on string literals.</p>

<p>Unfortunately, that assumption does not hold. You are just comparing pointers.</p>

<p>Use <a href=""http://en.cppreference.com/w/cpp/string/byte/strcmp"" rel=""noreferrer""><code>strcmp</code></a> instead and, next time, <em>read the documentation</em> instead of making assumptions.</p>

<p>Also, <code>main</code> returns <code>int</code>, not <code>void</code>.</p>
",5
45056428,45056234,3,"<p>You are comparing pointers. </p>

<p><code>""A""</code> is a pointer to chararaters. (Actaully const char[2] as pointed out in comments)
<code>'A'</code> is a character.</p>

<p>Try this: </p>

<pre><code>int main ()
{
    cout &lt;&lt; ('A' &gt; 'A') &lt;&lt; endl;
    cout &lt;&lt; ('a' &gt; 'A')&lt;&lt; endl;
    cout &lt;&lt; ('B' &gt; 'a')&lt;&lt; endl;
    cout &lt;&lt; ('b' &gt; 'B')&lt;&lt; endl;
    cout &lt;&lt; ('C' &gt; 'b')&lt;&lt; endl; 
    cout &lt;&lt; ('c' &gt; 'C')&lt;&lt; endl;
}
</code></pre>

<p>You now need to think about what you want from a string (or char array).</p>

<p>Is ""AA"" less or greater than ""c""? It comes first in a dictionary, but it's shorter. </p>

<p>If you want ""dictionary"" (lexographical) order you need to compare strings; <code>strcmp</code> or look at <a href=""http://en.cppreference.com/w/cpp/string/basic_string/operator_cmp"" rel=""nofollow noreferrer"">string comparision operators</a> (if you decide to use std::string instead)</p>
",6
45056630,45056234,0,"<p>In the statements like these</p>

<pre><code>cout &lt;&lt; (""A"" &gt; ""A"") &lt;&lt; endl;
cout &lt;&lt; (""a"" &gt; ""A"")&lt;&lt; endl;
cout &lt;&lt; (""B"" &gt; ""a"")&lt;&lt; endl;
//...
</code></pre>

<p>there are used string literals that have the static storage duration. In C++ string literals have types of constant character arrays. For example the string literal <code>""A""</code> has type <code>const char[2]</code> because in memory it is stored like <code>{ 'A', '\0' }</code>.</p>

<p>Execute this statement</p>

<pre><code>std::cout &lt;&lt; sizeof( ""A"" ) &lt;&lt; std::endl;
</code></pre>

<p>and you will see that the result will be 2.</p>

<p>From the C++ Standard (2.13.5 String literals)</p>

<blockquote>
  <p>8 Ordinary string literals and UTF-8 string literals are also referred
  to as narrow string literals. <strong>A narrow string literal has type
  ¡°array of n const char¡±, where n is the size of the string as defined
  below, and has static storage duration</strong> (3.7).</p>
</blockquote>

<p>In expressions like this <code>""A"" &gt; ""A""</code> arrays are implicitly converted to pointers to their first characters. So in this expression there are compared two pointers.</p>

<p>From the C++ STandard (4.2 Array-to-pointer conversion)</p>

<blockquote>
  <p>1 An lvalue or rvalue of type ¡°array of N T¡± or ¡°array of unknown
  bound of T¡± can be converted to a prvalue of type ¡°pointer to T¡±. The
  temporary materialization conversion (4.4) is applied. <strong>The result is
  a pointer to the first element of the array.</strong></p>
</blockquote>

<p>In general it is not necessary that string literals with equal contents will be stored as one character array. So in fact this expression</p>

<pre><code>""A"" == ""A""
</code></pre>

<p>can yield either <code>true</code> or <code>false</code> depending on compiler options that is whether these two string literals stored as one array or as two distinct arrays by the compiler.</p>

<p>It seems your compiler stores equal string literals as one array. In this case this statement</p>

<pre><code>cout &lt;&lt; (""A"" &gt; ""A"") &lt;&lt; endl;
</code></pre>

<p>outputs 0.</p>

<p>Also it seems that the compiler placed the array that stores the string literal <code>""a""</code> after the array that stores string literal <code>""A""</code>. So the address of the first character of the string literal <code>""a""</code>, that is of the character <code>'a'</code>, is higher than the address of the first character of the string literal <code>""A""</code>.  So this statement</p>

<pre><code>cout &lt;&lt; (""a"" &gt; ""A"")&lt;&lt; endl;
</code></pre>

<p>outputs 1.</p>

<p>Also the compiler placed the array that stores the string literal <code>""B""</code> after the array that stores the string literal <code>""a""</code>. So again the address of the first character of the string literal <code>""B""</code> is higher than the address of the first character of the string literal <code>""a""</code> and in this statement</p>

<pre><code>cout &lt;&lt; (""B"" &gt; ""a"")&lt;&lt; endl;
</code></pre>

<p>there are compared these addresses. So the statement outputs 1. </p>

<p>And so on.</p>

<p>It seems what you need to do is to compare character literals instead of the string literals. For example</p>

<pre><code>cout &lt;&lt; ( 'A' &gt; 'A') &lt;&lt; endl;
cout &lt;&lt; ('a' &gt; 'A')&lt;&lt; endl;
cout &lt;&lt; ('B' &gt; 'a')&lt;&lt; endl;
//...
</code></pre>
",0
45066197,45065606,0,"<p>You are not escaping the \ properly.</p>

<p>If escaping them is too much of a pain, which they usually can be you can try using a verbatim string literal. 
Used as a prefix it asks the compiler to ignore escape characters. Very useful when writing regex.</p>

<p>Have a read here :
<a href=""http://stroustrup.com/C++11FAQ.html#raw-strings"" rel=""nofollow noreferrer"">http://stroustrup.com/C++11FAQ.html#raw-strings</a></p>
",2
47968363,47968166,0,"<p>it depended by your solution architecture, but in common cause:
in .h:
<i>extern YourClassName class_inst;</i>
in .cpp
<i>YourClassName class_inst;</i></p>
",0
45287535,45287468,0,"<p>Your for loop is not embedded in a function. It's just sitting alone while everything else you have is in its own functions. You should put it in its own function. That might help.</p>
",0
47553169,47553080,0,"<p>This is C++ using the CRT.</p>

<p>But you can use cout...</p>

<pre><code>int age = 19;
cout &lt;&lt; ""my age is "" &lt;&lt; age &lt;&lt; "" years old"":
</code></pre>
",0
47553212,47553080,0,"<p>// first include header file</p>

<pre><code>#include &lt;iostream&gt;
</code></pre>

<p>// then write your code</p>

<pre><code>   cout &lt;&lt; ""my age is : "" &lt;&lt; str;
   cout &lt;&lt; ""years old"" &lt;&lt; endl;
</code></pre>
",0
45721747,45721688,2,"<p><code>*it = tolower(*it);</code> is modifying the string in place. I do not think this is what you want to do, as usually counting assumes unmodified incoming sequence. I suggest you use <code>const_iterator</code> to prevent yourself from those issues.</p>
",0
45722098,45721688,0,"<p>You should use the normal <code>for</code> loop or one of its cousins if you need to modify the container as you go along, access an element more than once, or otherwise iterate in a non-linear fashion through the container.</p>

<p>Range-based <code>for</code> is for when you need to access each element of a container once. While you are accessing some elements multiple times which may lead to problems.</p>

<p>You should use <code>const_iterator</code> as @SergeyA mentioned.
And insted of modifying <code>*it</code> do</p>

<pre><code>switch (tolower(*it))
</code></pre>

<p>Or store it to <code>temp</code> variable.</p>

<hr>

<p>Also good practice is to use <code>map</code> instad of counter for every <code>char</code> or <code>string</code> or whatever.</p>

<pre><code>std::map&lt;char,unsigned&gt; charCounter;
charCounter['a']++;
</code></pre>

<p>And instead of <code>10</code> <code>printf()</code>'s</p>

<pre><code>for(auto const &amp; c : charCounter)
{
    for(auto const &amp; i : charCounter.second)
    {
        cout &lt;&lt; ""The number of "" &lt;&lt; c &lt;&lt; "" vowels is: \t"" &lt;&lt; i &lt;&lt; endl;
    }
}
</code></pre>
",0
46027921,46027886,-1,"<p>The integer division does that. To prevent it, cast the value either explicitly or implicitly, e.g.</p>

<pre><code>&lt;&lt; ""total: "" &lt;&lt; (100.0 * matches / (matches + mismatch)) &lt;&lt; endl;
</code></pre>
",0
46028590,46027886,1,"<p>In this statement, the <code>static_cast</code> is applied <strong>after</strong> the calculation is done.</p>

<pre><code>static_cast&lt;double&gt;(matches / (matches + mismatch) * 100)
</code></pre>

<p>So what the program <em>actually</em> does is do the calculation in <code>int</code>, then convert to <code>double</code>, and you're getting <code>0.0</code> because the result of the integer arithmetic is zero.</p>

<p>To fix, manually cast at least one value to <code>double</code>:</p>

<pre><code>(1.0 * matches / (matches + mismatch) * 100)
 ^^^
(double(matches) / (matches + mismatch) * 100)
 ^^^^^^^       ^
</code></pre>
",0
46081809,46081740,1,"<blockquote>
  <p>Then, what is the difference?</p>
</blockquote>

<p>A source file will be compiled to a single object file that implements the interface declared in a corresponding header.</p>

<p>A library usually consists of the object files build from more than a single source file.<br>
That's the only difference more or less.</p>

<hr>

<p>I'll try to put a better methaphor than the accepted answer from your <a href=""https://stackoverflow.com/questions/924485/whats-the-difference-between-a-header-file-and-a-library"">link</a>:</p>

<ul>
<li>A header file is like a books table of contents</li>
<li>A source file fleshes out all the chapters of that book</li>
<li>A library stores many books</li>
</ul>
",0
46109437,46109014,0,"<p>You are using the distance formula wrong
it should be
distance1 = sqrt(squareofx1 + squareofy1);
instead of 
distance1 = sqrt(squareofx1 - squareofy1);
due to the wrong formula if squareofx1 is less than squareofy1 you get an error as  sqrt of a negative number is not possible in case of real coordinates.</p>
",0
46109586,46109014,0,"<p><strong>Firstly</strong>, your formula is incorrect change it to <code>distance1 = sqrt(squareofx1 + squareofy1)</code> as @fefe mentioned. Btw All your calculation can be represented in one line of code:</p>

<pre><code>distance1 = sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
</code></pre>

<p>No need for variables like <strong>differenceofx1</strong>, <strong>differenceofy1</strong>, <strong>squareofx1</strong>, <strong>squareofy1</strong> unless you are using the results stored in these variables again in your program.</p>

<p><strong>Secondly</strong>, <a href=""http://en.cppreference.com/w/cpp/language/types"" rel=""nofollow noreferrer"">Double</a> give you more precision than <a href=""http://en.cppreference.com/w/cpp/language/types"" rel=""nofollow noreferrer"">float</a>. If you need precision more than 6-7 places after decimal use Double else float works too. Read more about <a href=""https://stackoverflow.com/questions/5098558/float-vs-double-precision"">Float vs Double</a></p>
",0
47544662,47544375,0,"<p>Well...if it's me, I'll design the program as follows:<br>
1. Define a <code>vector&lt;vector&lt;double&gt;&gt; vvRents</code> for storing the rents of all apartments by month.<br>
2. Each element in <code>vvRents</code> stores the rents of all months of each apartment.<br>
3. Once all data is collected, calculate summed rents of the year by apartment, and store the total rents in a new vector <code>vTotalRents</code>.<br>
4. Use a <code>max_element</code> algorithm to pick the most expensive apartment.<br>
You must include <code>&lt;vector&gt;</code> to use <code>vector</code> class, and include <code>&lt;algorithm&gt;</code> to use <code>max_element</code>. </p>
",0
47663365,47662115,1,"<p>General-purpose copy logic looks something like:</p>

<pre><code>DoubleListNode * from = source.head; // copying from
DoubleListNode ** to = &amp;head; // pointer to where we want to copy to
while (from != nullptr) // keep going until end of list. You did mark 
                        // the end of the list, didn't you?
{
    *to = new node(*from); //copy construct a new node around from and store it at to
    to = &amp;(*to)-&gt;next; // advance to
    from = from.next; // advance from
}
*to = nullptr; // all done. Terminate list.
</code></pre>

<p>The real magic is going on up here at the double pointer: <code>DoubleListNode ** to</code> By having a pointer to a pointer, we don't care whether we're pointing at <code>head</code>, another node's <code>next</code> or what have you. It's just another node, so there are no special cases to cover.</p>

<p>You can do the above in both the copy constructor and assignment operator, though you are better off not repeating yourself and putting it in a function called by the copy constructor and assignment operator. Note that there are different assumptions about pre-existing data in the copy constructor (eg, list will be empty) and the assignment operator (eg, list may not be empty, so clear it and free all of the nodes before you begin) that need to be taken into account.</p>

<p>The primary alternative, as discussed in the comments above, is to use <a href=""https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom"">the Copy and Swap Idiom</a>. For this, the above copy loop only exists in the copy constructor. </p>
",0
47548880,47548276,-1,"<p>Instead of using int arrays, you should use <code>std::vector&lt;int&gt;</code> type, which can have any size. </p>

<p>Then, you can use <a href=""http://en.cppreference.com/w/cpp/algorithm/search"" rel=""nofollow noreferrer"">std::search</a> to search for vector in a vector.</p>
",3
47549755,47548276,0,"<p>Check at each position of <code>vector1</code>, if that position contains the whole <code>vector2</code>. If yes,  increment <code>count</code>. Increment position.</p>

<p>A pseudo code</p>

<pre><code>init count with 0
init pos1 with 0
while pos1 &lt; v1Size - v2Size
    init pos2 with 0
    init match with true
    while pos2 &lt; v2Size
        if vector1[pos1 + pos2] not equals vector2[pos2]
            set match = false
            break while loop
    if match
        increment count
    increment pos1
</code></pre>
",0
47549800,47548276,0,"<p>You can use <code>std::search</code>.</p>

<pre><code>int main()
{
int v1Size = 5;
int v2Size = 3;

int vector1[] = {1,2,1,2,1};
int * v1End = vector1 + v1Size;
int vector2[] = {1,2,1};
int * v2End = vector2 + v2Size;

int counter = 0;
for (int * p = vector1; p != v1End; ++p) {
    counter += (std::search(p, v1End, vector2, v2End) == p);
}

std::cout &lt;&lt; counter &lt;&lt; std::endl;
return 0;
}
</code></pre>
",2
47551196,47551100,1,"<p>You are dividing two literal integers, so the result truncates to 0 (as the division is less than 1). To have a correct result you should do <code>double n = 5.0/9.0;</code>, so the division is between two float literals.</p>
",0
46616986,46616527,0,"<p>You need to read the command with <code>getline</code> then split it to tokens.  Check for the <code>getline</code> function, and google for <em>split line to tokens c++</em> .</p>
",0
46617012,46616527,0,"<p>Use getline to store whole command in a single String.</p>

<pre><code>String command;
std::getline (std::cin,command);
</code></pre>

<p>Now, you can split the command into token words using following code.</p>

<pre><code>int counter =0;
string words[10];
for (int i = 0; i&lt;command.length(); i++){
    if (command[i] == ' ')
        counter++;
    else
        words[counter] += command[i];
}
</code></pre>
",1
46617284,46616527,0,"<p>You could read the input line by line and then split each line into a <code>std::vector</code> containing each command followed by its arguments:</p>

<pre><code>void command_help()
{
    // display help
}

void command_timer(std::string const&amp; ctrl, std::string const&amp; time)
{
    int t = std::stoi(time);

    // ... etc ...
}

int main()
{
    // read the input one line at a time
    for(std::string line; std::getline(std::cin, line);)
    {
        // convert each input line into a stream
        std::istringstream iss(line);

        std::vector&lt;std::string&gt; args;

        // read each item from the stream into a vector
        for(std::string arg; iss &gt;&gt; arg;)
            args.push_back(arg);

        // ignore blank lines
        if(args.empty())
            continue;

        // Now your vector contains

        args[0]; // the command
        args[1]; // first argument
        args[2]; // second argument
        // ...
        args[n]; // nth argument

        // so you could use it like this

        if(args[0] == ""help"")
            command_help(); // no arguments
        else if(args[0] == ""timer"")
        {
            if(args.size() != 3)
                throw std::runtime_error(""wrong number of arguments to command: "" + args[0]);

            command_timer(args[1], args[2]); // takes two arguments
        }
    }
}
</code></pre>
",0
46652833,46651523,0,"<p>On first glance, the fact that your friend declaration is referring to  but is outside of the template  declaration seems like your first issue.</p>

<p>Check out this question. It seems very much related:
<a href=""https://stackoverflow.com/questions/4039817/friend-declaration-declares-a-non-template-function"">friend declaration declares a non-template function</a></p>
",0
46668492,46668301,2,"<p>I would recommend following the next pattern:</p>

<ul>
<li>Run your application</li>
<li>Read/Load the configuration</li>
<li>Create a factory for that object from that configuration</li>
<li>Use the factory to create more instances of the same object throught the lifetime of your application</li>
</ul>

<p>For example:</p>

<pre><code>struct Object {
  Object(int x, int y) : _x(x), _y(y) {}

  int _x, _y;
};

struct DynamicFactory {
  DynamicFactory(int x, int y) : _x(x), _y(y) {}

  std::shared_ptr&lt;Object&gt; generate() { return std::make_shared&lt;Object&gt;(_x, _y); }

  int _x, _y;
};

int main(){

  // Load configuration

  // Initialize dynamic factory using configuration
  DynamicFactory factory(1, 3);

  // Generate objects
  auto obj1 = factory.generate();
  auto obj2 = factory.generate();

  return 0;
}
</code></pre>
",0
46668360,46668301,0,"<p>Try to use static members so these are shared across the objects.</p>
",1
46668453,46668301,7,"<p>Just because you can, doesn't mean you should. Now that I got that out of the way, here's how:</p>

<pre><code>#include &lt;iostream&gt;

struct C {
    static int default_val;
    C(int i = default_val) {
        std::cout &lt;&lt; i &lt;&lt; '\n';
    }
};

int C::default_val = 0;

int main() {
    C c;

    C::default_val = 1;

    C c2;

    return 0;
}
</code></pre>

<p>A default argument to a function doesn't have to be a constant expression, it just has to be ""available"" at every place the function is called. And a static variable is just that.</p>

<p>It also doesn't have to be accessible at the call site. So if you want the class to control it, but not have it be modifiable from outside the class, you can make it private.</p>
",0
46979191,46978802,2,"<p>Variable length arrays are <a href=""https://stackoverflow.com/questions/15013077/arrayn-vs-array10-initializing-array-with-variable-vs-real-number"">not allowed</a> in C++. You have a couple options... (see them running by clicking the option numbers)</p>

<h1>Option 1</h1>

<p>Define a macro:</p>

<pre><code>#define j 3
int arr[5][j] = {0};
</code></pre>

<h1><a href=""https://ideone.com/rPcQBH"" rel=""nofollow noreferrer"">Option 2</a></h1>

<p>Define a constant variable:</p>

<pre><code>const int j = 3;
int arr[5][j] = {0};
</code></pre>

<h1><a href=""https://ideone.com/vVdcOY"" rel=""nofollow noreferrer"">Option 3</a></h1>

<p>Use dynamically allocated arrays (but make sure to delete them after you're done so we don't get memory leaks!)</p>

<pre><code>int j = 3;
int** arr = new int*[5];
for(int i = 0; i &lt; 5; i++)
    arr[i] = new int[j];
</code></pre>

<p>If you go dynamic, you'll need to make sure to deallocate the array after you're done:</p>

<pre><code>for(int i = 0; i &lt; 5; i++)
    delete [] arr[i];
delete [] arr;
</code></pre>

<h1><a href=""https://ideone.com/WYFqn8"" rel=""nofollow noreferrer"">Option 4</a></h1>

<p>Use a C++ Standard Library container:</p>

<pre><code>int j = 3;
std::vector&lt;vector&lt;int&gt;&gt; v(5, vector&lt;int&gt;(j, 0));
</code></pre>
",6
46942216,46941899,6,"<p>Make a stream operator for the key type.</p>

<p>I personally dislike creating the overload in the <code>std</code> namespace, so I create a ""manipulator"" wrapper:</p>

<p><strong><kbd><a href=""http://coliru.stacked-crooked.com/a/b782340c5747434f"" rel=""noreferrer"">Live On Coliru</a></kbd></strong></p>

<pre><code>#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;

template &lt;typename T&gt;
struct io {
    io(T const&amp; t) : t(t) {}
  private:
    T const&amp; t;

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, io const&amp; o) {
        os &lt;&lt; ""{ "";
        using namespace std;
        copy(begin(o.t), end(o.t), ostream_iterator&lt;typename T::value_type&gt;(os, "" ""));
        return os &lt;&lt; ""}"";
    }
};

int main() {  
    using namespace std;
    auto myMap = map&lt;set&lt;int&gt;, int&gt; { { { { 4, 3 }, 8 } } };

    for (auto&amp; [k,v] : myMap)
        std::cout &lt;&lt; io{k} &lt;&lt; "" -&gt; "" &lt;&lt; v &lt;&lt; ""\n"";
}
</code></pre>

<p>Prints</p>

<pre><code>{ 3 4 } -&gt; 8
</code></pre>

<ul>
<li>A version just using c++11: <a href=""http://coliru.stacked-crooked.com/a/bfb571f3e43bda18"" rel=""noreferrer"">http://coliru.stacked-crooked.com/a/bfb571f3e43bda18</a></li>
<li>A version just using c++03: <a href=""http://coliru.stacked-crooked.com/a/3f28f8f90c386b50"" rel=""noreferrer"">http://coliru.stacked-crooked.com/a/3f28f8f90c386b50</a> (man that was tedious)</li>
</ul>
",4
46954134,46953414,2,"<p>You are using the variable i in the inner second for loop(which resets the value of i) hence the infinite loop.</p>
",1
46957880,46953414,0,"<p>Here's a version w/o hand-written loops, using regex &amp; string view: </p>

<pre><code>static const std::regex expr{ ""(\\d)*[a-zA-Z]"" }; // zero or more digits + letter

std::string uncompress(std::string_view const&amp; input)
{
    char what{ '\0' };
    unsigned long rep{ 1 };

    if (std::regex_match(input.begin(), input.end(), expr))
    {
        char *end = const_cast&lt;char*&gt;(&amp;input.back()) - 1;
        rep       = 1 == input.size() ? 1 : strtoul(input.data(), &amp;end, 10);
        what      = input.back();
    }

    return std::string(rep, what);
}
</code></pre>

<p>In the <a href=""https://wandbox.org/permlink/JddErDDA0YsYR1QP"" rel=""nofollow noreferrer""><kbd>Demo</kbd></a>, minor modifications allow calling this while searching your input. Input sanitization is also showcased.</p>
",0
46966265,46966165,0,"<p>The short answer is that you can't. Changing it to a 1D vector won't help either.</p>

<p>If you want to combine a container with inheritance, you almost certainly need the container to store some sort of pointer-like or reference-like thing, rather than storing the objects directly.</p>

<p>Depending on the situation, those might be <code>std::unique_ptr</code>, or <code>std::reference_wrapper</code>, or possibly just raw pointers in something like a <a href=""http://www.boost.org/doc/libs/1_65_1/libs/ptr_container/doc/ptr_vector.html"" rel=""nofollow noreferrer"">Boost <code>ptr_vector</code></a>. One way or another, however, if you're using inheritance, you just about need to deal with the objects via something pointer-like or something reference-like rather than working directly with objects themselves.</p>
",0
46966315,46966165,0,"<p>The way to do this kind of thing is using dynamic_cast and store pointers, rather than values.  For example:</p>

<pre><code>RectangleShape r1 = new RectangleShape();
RectangleShape r2 = new tile();

tile* t1 = dynamic_cast&lt;tile&gt;(r1);
tile* t2 = dynamic_cast&lt;tile&gt;(r2);
</code></pre>

<p>In the above code snippet, t1 will be nullptr, because r1 is not a tile object.  t2 will point to the correct tile object.  Storing the pointers in a vector should probably be done with unique_ptr to prevent memory management issues.</p>

<p>If this is not what you want to do, if you want to actually create a tile object out of a RectangleShape object, then you would need to give the tile class a constructor that takes a RectangleShape object (preferably explicit), or create a function that takes a RectangleShape object and returns a tile object.</p>

<p>Finally, make sure when you're doing this that RectangleShape is actually the kind of object you would want to derive another class from.  It must have a virtual destructor, and any overriden methods should also be virtual.</p>
",1
47494357,47494003,0,"<h2>Easy solution</h2>

<p>If performance is not a concern, <code>std::vector&lt;bool&gt;</code> is a good fit. It also doesn't support some library concepts, but it doesn't seem like you're using them anyway. It might require overloading of <code>operator&gt;&gt;</code> and <code>operator&lt;&lt;</code>.</p>

<h2>Harder solution</h2>

<p>Roll your own. This will take some development time, but if you're not overgeneralizing, it should be pretty quick. Just test it before deployment.</p>

<h2>Taking dependency</h2>

<p>Boost has dynamic bitset. I believe they have their own license, so it might take some time to figure out if it fits your project, but otherwise it is pretty well tested. I've used it myself, and it landed itself pretty nicely.</p>
",1
47496580,47496373,0,"<p>How about to add include-guard?</p>

<hr>

<blockquote>
  <p>In ""Submenu.h"" --- case 2: { system(""cls""); Mainmenu a(""a"", ""b"", ""return""); a.Firstmenu(); }break;
  C2605 'Mainmenu' : Undefined identifier. </p>
</blockquote>

<p>include ""Mainmenu.h"" in ""Submenu.h"".(Don't forget include guard for all header files)</p>
",3
47497423,47496373,0,"<blockquote>
  <p>this is Mainmenu.h header</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include ""windows.h""
#include ""Mainmenu.h"" // ERROR C1014
</code></pre>
</blockquote>

<p>Why are you including ""Mainmenu.h"" inside itself?  That is <em>at best</em> pointless, and in this case actively harmfull.</p>
",3
47500471,47500438,0,"<p>You can use the method below to split the string into words:</p>

<pre><code>vector&lt;string&gt; words;
istringstream n(myString);
string word;
while(getline(n, word, ' ')) words.push_back(word);
</code></pre>
",2
47532247,47532090,0,"<p>Just do a while loop over words and reverse them instead of the whole line:</p>

<pre><code>string word;
while(your_end_condition)
{
  cin &gt;&gt; word; // this takes one word at a time
  cout &lt;&lt; ReverseString(word, word.size()) &lt;&lt; "" "";
}
</code></pre>

<p>You can make stringstream from you original string if you don't want to use cin</p>
",2
47532639,47532090,0,"<p>What about this way:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;regex&gt;

void myReplace(std::string&amp; str,
               const std::string&amp; oldStr,
               const std::string&amp; newStr)
{
    std::string::size_type pos = 0u;
    while((pos = str.find(oldStr, pos)) != std::string::npos)
    {
        str.replace(pos, oldStr.length(), newStr);
        pos += newStr.length();
    }
}

std::string reverWords(const std::string&amp; str)
{
    auto inp{str};
    auto out{str};
    std::regex rgx(""[a-zA-Z]+"");

    std::smatch res;

    while(regex_search(inp, res, rgx))
    {
        std::string s{res[0]};
        std::reverse(s.begin(), s.end());
        myReplace(out, std::string{res[0]}, s);
        inp = res.suffix();
    }
    return out;
}
int main(int /*argc*/, char* argv[])
{
    std::string str = ""Welcome to AC, CVB!"";
    std::cout &lt;&lt; reverWords(str);
    return 0;
}
</code></pre>
",3
47546309,47546213,3,"<p>At first: There is no ""screen"" for c++. There is only input and output to ""something"" which is a typically a terminal. But how this terminal behaves is not part of c++ standard and as this not portable. So the results with different terminals and especially on different OS are different.</p>

<p>If you are working with a terminal which have e.g. VT100 support, you can use the special characters to control the cursor and erase chars on the terminal screen.  <a href=""https://en.wikipedia.org/wiki/VT100"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/VT100</a> <a href=""https://www.csie.ntu.edu.tw/~r92094/c++/VT100.html"" rel=""nofollow noreferrer"">https://www.csie.ntu.edu.tw/~r92094/c++/VT100.html</a></p>

<p>There are hundreds of libraries arround which are dealing with such kind of terminal ( emulators ).</p>
",0
47546446,47546213,1,"<p>There's no platform independent way of doing that but since you mentioned <code>system('cls')</code> I assume you are on Windows.</p>

<p>Windows has the <a href=""https://docs.microsoft.com/en-us/windows/console/console-functions"" rel=""nofollow noreferrer"">Console Functions API</a> which is a set of utility functions used for manipulating the console. You have 2 options here:</p>

<p>Set the cursor's position and overwrite it with spaces:</p>

<pre><code>#include &lt;windows.h&gt;
..
auto consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
COORD coordsToDelete = { row, col }; // the coordinates of what you want to delete
// Move the current cursor position back. Writing with std::cout will
// now print on those coordinates
::SetConsoleCursorPosition(consoleHandle, position);
// This will replace the character at (row, col) with space.
// Repeat as many times as you need to clear the line
std::cout &lt;&lt; "" "";
</code></pre>

<p>Alternatively, you can get the entire console buffer and directly modify it:</p>

<pre><code>#include &lt;windows.h&gt;
..
auto consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
CONSOLE_SCREEN_BUFFER_INFO csbi;
// Get a handle to the console buffer
GetConsoleScreenBufferInfo(consoleHandle, &amp;csbi));
DWORD count;
COORD coords = { row, 0 };
DWORD cellCount = /* the length of your row */;
// Write the whitespace character to the coordinates  in cellCount number of cells
// starting from coords. This effectively erases whatever has been written in those cells
FillConsoleOutputCharacter(
        consoleHandle,
        (TCHAR) ' ',
        cellCount,
        coords,
        &amp;count);
</code></pre>
",0
47550104,47546403,0,"<p>Here is a complete example on how you write (fixed size) matrices to a file and how you can build them reading from that file:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {

    const size_t matrixSize = 3;

    // 
    ofstream matrixOutput(""matrix.txt"");

    for (size_t i = 0; i &lt; matrixSize; i++) {
        for (size_t j = 0; j &lt; matrixSize; j++) {
            matrixOutput &lt;&lt; j*i &lt;&lt; ' ';
        }
        matrixOutput &lt;&lt; '\n';
    }

    for (size_t i = 0; i &lt; matrixSize; i++) {
        for (size_t j = 0; j &lt; matrixSize; j++) {
            matrixOutput &lt;&lt; j*i * 2 &lt;&lt; ' ';
        }
        matrixOutput &lt;&lt; '\n';
    }

    matrixOutput.close();

    //

    ifstream matrixData(""matrix.txt"");

    size_t matrixInput[matrixSize][matrixSize];
    size_t matrixInput2[matrixSize][matrixSize];

    size_t position = 0;
    size_t number = 0;

    while (matrixData &gt;&gt; number) {

        const size_t matrixNumber = size_t(floor(position / (matrixSize*matrixSize)));
        const size_t row = size_t(floor(position / matrixSize)) % matrixSize;

        switch (matrixNumber) {
            case 0:
                matrixInput[row][position % 3] = number; break;
            case 1: 
                matrixInput2[row][position % 3] = number; break;
        }
        position++;
    }

    matrixData.close();

    cout &lt;&lt; ""Matrices: "" &lt;&lt; endl;

    for (size_t i = 0; i &lt; matrixSize; i++) {
        for (size_t j = 0; j &lt; matrixSize; j++) {
            cout &lt;&lt; matrixInput[i][j] &lt;&lt; ' ';
        }
        cout &lt;&lt; endl;
    }

    cout &lt;&lt; endl;

    for (size_t i = 0; i &lt; matrixSize; i++) {
        for (size_t j = 0; j &lt; matrixSize; j++) {
            cout &lt;&lt; matrixInput2[i][j] &lt;&lt; ' ';
        }
        cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;

    cout &lt;&lt; ""Matrices multiplication: "" &lt;&lt; endl;

    for (size_t i = 0; i &lt; matrixSize; i++) {
        for (size_t j = 0; j &lt; matrixSize; j++) {
            cout &lt;&lt; matrixInput[i][j] * matrixInput2[i][j] &lt;&lt; ' ';
        }
        cout &lt;&lt; endl;
    }
    // ...
}
</code></pre>

<p><strong>Note:</strong> if you want you can write the matrix size to the file too, so you can retrieve it later and build custom size matrices.</p>
",0
47561924,47561807,1,"<p>You can define it like that:</p>

<pre><code>#define TOKENPASTE(x, y) x ## y
#define TOKENPASTE2(x, y) TOKENPASTE(x, y)
#define PADDING(size) char TOKENPASTE2(padding_, __LINE__) [size]
</code></pre>

<p>Change field name prefix as you like it (preferably one that won't ever
collide with other possible members).</p>

<p>Keep in mind (as mentioned by Remy Lebeau and Fran?ois Andrieux in comments) that compiler can sometimes add unexpected padding. For reference you can read:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member"">Why isn&#39;t sizeof for a struct equal to the sum of sizeof of each member?</a></li>
<li><a href=""http://en.cppreference.com/w/cpp/language/data_members#Standard_layout"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/language/data_members#Standard_layout</a></li>
</ul>

<p>EDIT: Sorry, initial code was incorrect (it was incorrectly using <code>__LINE__</code> expansion in macro). I fixed it using solution from: <a href=""https://stackoverflow.com/a/1597129/1561140"">https://stackoverflow.com/a/1597129/1561140</a></p>
",5
47567044,47566974,0,"<p>Think about what you are printing. You pass to the stream a <code>char</code>, not a <code>char *</code>:</p>

<pre><code>cout &lt;&lt; ""from main function-&gt;"" &lt;&lt; *(con_host.desc) &lt;&lt; ""\n\n"";
// *(con_host.desc) = *(char *) = char
// Above is a simplification but you get the point.
</code></pre>

<p>So long as <code>con_host.desc</code> is a null terminated c string you can print it like this:</p>

<pre><code>cout &lt;&lt; ""from main function-&gt;"" &lt;&lt; con_host.desc &lt;&lt; ""\n\n"";
</code></pre>

<p><a href=""https://ideone.com/pDDGlN"" rel=""nofollow noreferrer"">Here is a live example.</a></p>
",2
47567051,47566974,0,"<p>It's not memory allocation error. It's caused by the output statement. Change to</p>

<pre><code>      cout &lt;&lt; ""from main function-&gt;"" &lt;&lt; con_host.desc &lt;&lt; ""\n\n"";
</code></pre>
",0
48012304,48012263,0,"<p>You will need a loop:</p>

<pre><code>do {
  int num;
  if(cin &gt;&gt; num)
  { /* input is good */ 
    ...
    break;
  }
  else
  { /* error */ }
} while(true);
</code></pre>
",2
48012954,48012263,1,"<p>Use a loop to allow user to re-enter the input in a case when the user enters an invalid input.</p>

<p>You can do:</p>

<pre><code>bool validinput = true;

if(x == ""D"" || x == ""d""){
        do{
                validinput = true;
                cout &lt;&lt; ""How many 5c coins? ==&gt; "";
                cin &gt;&gt; j;
                if (cin.fail()) { 
                        cout &lt;&lt; ""Please enter a valid value.."" &lt;&lt; endl;
                        cin.clear(); //reset state bits
                        cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n'); //discard all characters from the input buffer, or until a newline is read.
                        validinput = false;
                }
        }while(validinput == false);

//repeat same to validate other numeric inputs
</code></pre>
",2
48035652,48035457,1,"<hr>

<p><code>vec</code> is empty, and <code>merge</code> doesn't (can't) change the size of it through a regular iterator.<br>
This is why <code>std::back_inserter</code> was invented ¨C it's an ""iterator"" that uses <code>push_back</code> to add elements:</p>

<pre><code>merge(even, even+100, odd.begin(), odd.end(), back_inserter(vec));
</code></pre>

<p>Since you know the size of the result, you can also ""pre-size"" <code>vec</code> and use your current method:</p>

<pre><code>vector &lt;int&gt; vec(100 + odd.size());
merge(even, even+100, odd.begin(), odd.end(), vec.begin());
</code></pre>
",0
48035658,48035457,0,"<p>change <code>vector&lt;int&gt; vec</code>;</p>

<p>to<code>vector &lt;int&gt; vec (100+odd.size());</code></p>
",0
48039558,48039467,0,"<p>Following is corrected code.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;initializer_list&gt;

int sum1(std::initializer_list&lt;int&gt; lst1)
{
    int res1=0;
    for(auto v1:lst1)
    {
        res1 += v1;
    }
    return res1;
}
int main()
{
    std::cout&lt;&lt;"" sum = ""&lt;&lt;sum1({1,2,3,4,5,6,7,8,9,10});
    //auto b = sum1({1,2,3,4,5,6,7,8,9,10});
    return 0;
}
</code></pre>

<p>You can see working <a href=""https://ideone.com/oJs2QU"" rel=""nofollow noreferrer"">here</a>.</p>

<p><strong>Note:</strong> You can change the type of <code>res0</code> to <code>long</code> or other type if result is not in the limits of <code>int</code>. Also, Change the return type of function <code>sum1</code> accordingly.</p>
",0
48039565,48039467,1,"<p><code>size_type</code> is not needed for anything in your function. The <code>initializer_list</code> has type <code>int</code>, therefore <code>res1</code> should be an <code>int</code> and your return type should be <code>int</code>. If you really want to derive the value type from the initializer_list then do so like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;initializer_list&gt;

auto sum1(std::initializer_list&lt;int&gt; lst1)
{
    typename std::initializer_list&lt;int&gt;::value_type res1 = 0;
    for(auto v1:lst1)
    {
        res1 += v1;
    }

    return res1;
}

int main()
{
    sum1({1,2,3,4,5,6,7,8,9,10});
    auto b = sum1({1,2,3,4,5,6,7,8,9,10});
    std::cout &lt;&lt; b &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p>If you want the function to be generic, in which case it is necessary to derive the value type, then the template function looks like this.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;initializer_list&gt;

template&lt;typename T&gt;
auto sum1(std::initializer_list&lt;T&gt; lst1)
{
    typename std::initializer_list&lt;T&gt;::value_type res1 = 0;
    for(auto v1:lst1)
    {
        res1 += v1;
    }

    return res1;
}

int main()
{
    sum1({1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9,10.10});
    auto b = sum1({1.1,2.2,3.3,4.4,5.5,6.6,7.7,8.8,9.9,10.10});
    std::cout &lt;&lt; b &lt;&lt; std::endl;
    return 0;
}
</code></pre>
",1
