19208594,19205948,1,"<p>I know of nothing standard for that.</p>

<p>If you want to stay in the language, you'll have to look at extensions as compilers have provided pragmas and attributes to control such things for a long time.  In the case of gcc, <a href=""http://gcc.gnu.org/onlinedocs/gcc-4.8.1/gcc/Asm-Labels.html"" rel=""nofollow"">asm labels</a> seems designed for that problem.  I've not used it and I've the <em>a priori</em> that it can't be used with templates excepted perhaps for explicit specializations.</p>

<p>The alternative is obviously playing with linker level tricks. </p>

<ul>
<li><p>AFAIK a weak symbol doesn't make an object file providing it to be extracted from a static library if it is the only symbol provided by the object.  You could arrange that the object file providing from C to your template provide also another unique symbol which is needed by the instantiation you want.</p></li>
<li><p>Linker scripts have a lot of power and if things haven't changed too much since the last time I took care of embedded systems (that's so long ago that they must changed, I just don't know if they have changed in that aspect) custom linker scripts are still pretty much mandatory in that field.</p></li>
</ul>
",0
19563793,19563396,3,"<p>Some remarks to your code:</p>

<p>You're reading <code>a</code> and <code>b</code> as <code>int</code>, though using them as <code>long long int</code> in the methods. That's nonsense, read them as the type they are going to be used.</p>

<p>Although unlikely, you might experience overflows. To avoid that, you can double your range of integers by using <code>unsigned long long</code>.</p>

<p>Mathematically speaking, you're doing too much.</p>

<p>For an odd integer <code>n = 2 k + 1</code>, the result <code>3 n + 1</code> will always be even: <code>3 n + 1 = 3(2 k + 1) + 1 = 6k + 4</code>. Therefore you can combine the case for odd <code>n</code> with the following division by two. The result of that would be <code>3 k + 2</code> which is <code>k + 1</code> greater than <code>n</code>. Using integer arithmetic in C++, this is can be calculated with <code>n += (n / 2) + 1</code> as <code>n / 2</code> will evaluate to <code>k</code>.</p>

<p>Another possibility of why your code doesn't get accepted is input/output. You'll have to follow the exact requirements of the platform.</p>

<hr>

<p>The following bit of the problem description is ignored by your code:</p>

<blockquote>
  <p>The input will consist of a series of pairs of integers</p>
</blockquote>

<p>This can be fixed easily</p>

<pre><code>int main()
{
    int max=0,a,b,step;
    while ( cin &gt;&gt; a &gt;&gt; b )
    {
       std::cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; ' ';
       if (a &gt;= b)
       {
           std::cout &lt;&lt; max_between(b,a);
       }
       else
       {
           std::cout &lt;&lt; max_between(a,b);
       }
       std::cout &lt;&lt; std::endl;
    }
    return 0;   
}
</code></pre>
",0
19209939,19209882,3,"<p>Suppose you were able to perform this cast. Consider:</p>

<pre><code>const int n = 42;
const int* cp = &amp;n;

int* p;
int** a = &amp;p;

const int** b;
b = a;  // hypothetical, doesn't compile
*b = cp;  // equivalent to p = cp;
*p = 84;  // equivalent to n = 84: oops
</code></pre>

<p>Therefore, allowing an implicit cast from <code>int**</code> to <code>const int**</code> would allow a program to violate const correctness.</p>
",0
19971934,19971832,1,"<p>You can write a short function to do the check:</p>

<pre><code>bool alreadyExists(int *array, int array_size, int value)
{
    for (int i = 0; i &lt; array_size; i++)
        if (array[i] == value)
            return true; // we found the same value, return true

    return false; // if we get here we have not found it
}
</code></pre>

<p>Call it with</p>

<pre><code>int input = 1;
if alreadyExists(num, 5, input)
{
    printf(""already exists\n"");
}
else
{
    printf(""Ok to add..."");
}
</code></pre>
",0
20408166,20408131,1,"<p>You need a logical not operator is '!'.You may try this;</p>

<pre><code>cout &lt;&lt; !(digit);
</code></pre>

<p><strong>EDIT:-</strong></p>

<p>Although I know its late but trying to improve my answer, <code>~</code> is the bitwise not operator. So if you write something like <code>~1000</code> then it would result out to be <code>0001</code></p>
",2
20408171,20408131,4,"<p><code>~</code> is the bitwise not (or bit inversion) operator.  The logical not operator is '!'.</p>

<pre><code>    cout &lt;&lt; !digit;
</code></pre>
",0
20408179,20408131,1,"<p>Essentially:</p>

<pre><code> 1 -&gt; 00000001
~1 -&gt; 11111110
</code></pre>
",0
20408186,20408131,13,"<p><code>~</code> performs bitwise negation. The operand is promoted (in this case) to <code>int</code>, and all the bits are inverted. 1 has a binary representation of <code>00....001</code>, so this gives the binary value <code>11....110</code>, which is interpreted (on most modern computers) as -2.</p>

<p>Use <code>!</code> for logical negation.</p>
",2
20409343,20408131,0,"<pre><code>4 bits integer
1 -&gt; 0001

find the complement by adding 1
0001 + 0001 = 0010 = 2

the complement is -2
</code></pre>
",0
18941199,18941179,1,"<p>You can use <code>istringstream</code>:</p>

<pre><code>string str;
getline(cin, str);
istringstream ss(str);

for(string word; ss &gt;&gt; word; )
    cout &lt;&lt; word &lt;&lt; endl;
</code></pre>

<p>&nbsp;</p>

<p>Your <code>while(cin &gt;&gt; str);</code> doesn't stop unless:</p>

<ol>
<li><p>Something fails in <code>&gt;&gt;</code> which is hard in your case.</p></li>
<li><p>EOF occurs (You can use <kbd>Ctrl</kbd>+<kbd>Z</kbd>, <kbd>Ctrl</kbd>+<kbd>D</kbd>, <kbd>F6</kbd> It depends on your system)</p></li>
<li><p>A user defined condition: <code>if(str.find('\n')) break;</code></p></li>
</ol>
",1
20182510,20182464,0,"<p>Non-static data members of a class are created there where an object of the class is created.</p>
",1
20182512,20182464,2,"<p>The <code>poo</code> instance <code>p</code> points to is always located on the heap, the pointer itself though (<code>p</code>) is located in/at the <code>foo</code> instance.</p>

<p>In the first version (<code>foo* f = new foo()</code>) a <code>foo</code> instance is created on the heap (including all of its members, they are always at the same place) and the pointer to it (the <code>f</code> var) is stored at the stack or in some register (thats up to the compiler).</p>

<p>In the second version the foo instance is located on the stack (including all of its members).</p>

<p>But notice that the actual location of an object is not that important as the actual scope of an object. You should really look up the term RAII.</p>
",3
18402534,18402501,10,"<p>Yes, with <a href=""http://en.cppreference.com/w/cpp/string/basic_string/to_string"">std::to_string</a>:</p>

<pre><code>output_string = std::to_string(input_value);
</code></pre>

<p>(For C++03, look into <code>boost::lexical_cast</code>).</p>
",1
18402536,18402501,12,"<p>Using the <a href=""http://en.cppreference.com/w/cpp/string/basic_string/to_string""><code>std::to_string</code></a> family of functions:</p>

<pre><code>std::string s = std::to_string(3.1416);
</code></pre>

<p>If you don't have the required C++11, another option is <a href=""http://www.boost.org/doc/libs/1_54_0/doc/html/boost_lexical_cast.html""><code>boost::lexical_cast</code></a>.</p>

<pre><code>std::string s = boost::lexical_cast&lt;std::string&gt;(3.1416);
</code></pre>
",0
18402562,18402501,3,"<p>If you don't have C++11, you can use something like:</p>

<pre><code>boost::lexical_cast&lt;std::string&gt;(input_value);
</code></pre>

<p>(it's easy enough to write your own to_string if you don't want Boost though - you're really just wrapping your existing code in a function).</p>

<p>If you <em>do</em> have C++11, stick with the <code>std::to_string</code> Jesse Good &amp; juanchopanza already mentioned.</p>
",3
18402615,18402501,0,"<p>Both are one-liners in C++ 11:</p>

<pre><code>std::string s1 = std::to_string(42);
</code></pre>

<p>and</p>

<pre><code>std::string s2 = std::to_string(42.0);
</code></pre>
",0
18862346,18862311,1,"<pre><code>D = x * pow ((1 + (R/100)), Y);
</code></pre>

<p><code>R/100</code> will result in an integer since both operands are ints. At least one of them must be <code>double</code> for it to work.</p>

<pre><code>D = x * pow ((1 + (R/100.0)), Y);
</code></pre>
",1
18862357,18862311,2,"<p>Make at least one of operand to double  to make it work.  </p>

<pre><code>  Y = m / 12.;

  D = x * pow ((1 + (R/100.)), Y);
</code></pre>
",0
19260148,19260102,1,"<p>I think what you are looking for is something along the lines of the following:</p>

<pre><code>template&lt;typename T&gt;
class Node
{
private:
    T data;
    Node* next;
public:
    Node(const T&amp; d);
    virtual ~Node();
    // ... etc
};
</code></pre>

<p>Note that you will either need to implement the template class inline, in the same file, or include the implementation at the bottom of the header file.</p>
",0
19260194,19260102,1,"<p>The point is that you change your class so that it can be used for other types except <code>double</code>, for example <code>int</code>, <code>float</code> etc in the same way. If we think of it in more abstractly, you need to use the class for objects of type <code>T</code>, where <code>T</code> can be any of the types mentioned above (or even more).
So, in general, you need to put <code>template &lt;class T&gt;</code> (Setting it as a template class) before your class and replace <code>double</code> with <code>T</code> type.</p>
",0
19260871,19260102,0,"<p>for class declaration:</p>

<pre><code>template&lt;typename T&gt;
class Node
</code></pre>

<p>for class functions implementation:</p>

<pre><code> template&lt;typename T&gt;
 Node&lt;T&gt;::Node()
</code></pre>
",2
18737721,18726774,1,"<p>You are creating instance for </p>

<pre><code>     PeiorityQueueType c; 
</code></pre>

<p>of type </p>

<pre><code>      PriorityQueue&lt; WeightType, NodeIterator, HeapStorage&gt;
</code></pre>

<p>Once you create an instance following insert function will b grnerated by the compiler.</p>

<pre><code>      void insert(const WeightType&amp; key, const NodeItrator&amp; data, const DescriptorType ptr = 0);
</code></pre>

<p>but you are calling insert function as </p>

<pre><code>       c.insert( cert.tfail, cert, cert.citem);
</code></pre>

<p>which is of</p>

<pre><code>     template&lt;const float&amp;, const certificate&amp;, unsigned int &gt;.
</code></pre>

<p>Which controverse the datatype you are declared. So, Change the calling insert functions datatype for function.</p>
",0
18732325,18732257,4,"<p>If you've put the function in the header file you need to make it <code>inline</code>. Otherwise the compiler will spit out a separate copy of it in any source file that uses it, leading to linker clashes.</p>

<pre><code>inline bool operator==(
  const Node&amp; lhs,
  const Node&amp; rhs)
{
  return lhs.uid == rhs.uid;
}
</code></pre>
",1
20408154,20408088,0,"<p>If you are delivering binaries only, there should be a manual describing all the use cases for the user and a description of all the files and processes (including installation and removal) an administrator should be aware of without going into details about the source.</p>

<p>If you deliver the source, you should export Doxygen code comments, or whatever equivalent you are using, into a some mutually agreed upon format. There should also be a description of how the source is organized if it does not appear in the code comments somewhere. This in addition to the manuals.</p>

<p>This information is from my personal experience about what keeps customers happy. I do not really know what is ""normal"" per se.</p>
",2
20511832,20511729,2,"<p>Once you return i's current value, it no longer is affiliated with the global variable, it's just a copy that has the value of i upon return. The destructor can then change whatever it likes, the copied value is frozen</p>
",0
20511842,20511729,4,"<p>You set the value <code>i = 10</code> in the destructor. And destructor get called in the block exit.</p>

<p>So in your code, after <code>return i;</code> in <code>foo()</code>, when the block exits, the value of i is getting set to 10.</p>

<p>In the <code>cout</code> statement, you are not printing the value of <code>i</code>, rather the return value of function <code>foo()</code>, so its giving 3;</p>

<pre><code>cout &lt;&lt; ""i = "" &lt;&lt; foo() &lt;&lt; endl;  // gives result 3
cout &lt;&lt; ""i = "" &lt;&lt; i &lt;&lt; endl;      // gives result 10
</code></pre>
",0
20511850,20511729,6,"<p>When you initialize a destructor, in your case, the object's destructor is called just before it is destroyed, that is, just before foo's execution completes. Since i becomes equal to 3 in the call to foo() you get 3. It would be equal to 10 only *<em>after *</em> the destructor is called.
If you do this, you can probably observe  destructor's behaviour and understand:</p>

<pre><code>class A
{
    public:
    ~A()
    {
        i=10;
         cout &lt;&lt; ""In destructor function, i = "" &lt;&lt; i&lt;&lt; endl;
    }
};
</code></pre>
",0
20511764,20511729,6,"<p>Because destructors are conceptually run at block exit.</p>

<p>So ?<code>ob</code> is constructed in the middle of <code>foo</code> but is destructed when returning from <code>foo</code></p>
",0
20511773,20511729,2,"<p>You are setting </p>

<p><strong>i to 10
 only in destructor</strong>. So the object <strong>ob</strong> is still valid when you print the value of i which is returned from the function before the object is destroyed.</p>
",0
20511778,20511729,-3,"<p><code>~A()</code></p>

<p>If it is without <code>~</code> i will be <code>i=10</code></p>
",0
20511991,20511729,2,"<pre><code>int foo()
{
    i=3;
    A ob;
    return i;
}
</code></pre>

<p>The <code>return</code> statement is encountered before we reach the <code>}</code>
The <code>return</code> value is already estimated before  calling the destructor which sets the variable value to <code>10</code></p>
",0
18372803,18372751,0,"<p>dstStr is not allocated so you're not puttign your data anywhere.
Use malloc to allocate a proper memory block then copy.</p>

<p>The reason it works with array is that the string is stored on the stack with memory automatically allcoated for it.</p>

<p>Also this is C not C++ as C++ string handlign is done via std::string.</p>
",2
18372838,18372751,7,"<p>You need to return the value of mStr after you malloc it. Right now the return value of malloc and the pointer to your copy of the string disappears when you exit the function. It leaks the memory from malloc because it loses track of it.</p>

<p>Change your function to <code>char* copyFrom(const char * str)</code></p>

<p>and then return mStr from that function. Then you can write <code>dstStr = copyFrom(srcStr)</code></p>

<p>Now, POSIX C already has this function. It is called <code>strdup</code>.</p>
",3
18372923,18372751,1,"<p>You can do this,</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void copyFrom(char * mStr, char * str);

int main() {
    char * srcStr = ""Robert bought a good ford car"";
    char * dstStr = NULL;
    dstStr = (char *)malloc((strlen(srcStr)) + 1);
    copyFrom(srcStr, dstStr);
    printf(""The string copied here is %s"", dstStr);
    return 0;
}

void copyFrom(char * str, char * mStr)
{
    while(*mStr++ = *str++) {
        ;
    }

    mStr[strlen(str)] = '\0';
}
</code></pre>
",0
18372871,18372751,2,"<pre><code>char * dstStr = NULL;
copyFrom(srcStr, dstStr);
printf(""The string copied here is %s"", dstStr);
</code></pre>

<p><code>dstStr</code> is NULL, the first line set it. While <code>copyFrom</code> allocates a string, it doesn't return that string to the caller. So your <code>printf</code> gets a NULL.</p>
",3
18372963,18372751,0,"<p>Rather than return, you can do pass the dest by reference:</p>

<pre><code>void copyFrom(const char * src, char *&amp; dest); 


int main() {  

    char * srcStr = ""Robert bought a good ford car"";  
    char * dstStr = 0;  
    copyFrom(srcStr, dstStr);
    printf(""The string copied here is %s"", dstStr);

    return 0;
}
void copyFrom(char * str, char *&amp; mStr)
{
    if(!mStr) {
        mStr = (char *)malloc((strlen(str)) + 1);
        if(mStr == NULL)
            return;
    }
    char* it = mStr;
    while(*it++ = *str++)
    {
        ;
    }
    *it = 0;
}
</code></pre>
",0
18372977,18372751,3,"<p>In C, even pointers are passed by value. When you pass a pointer to a function, the function receives a copy--i.e., a new pointer that points to the same place as the pointer in the calling function.</p>

<p>So in your code, when you pass <code>dstStr</code>, you are passing a null pointer. <code>mStr</code> is a new null pointer. While you allocate memory for <code>mStr</code>, this memory is allocated to this new pointer, not to <code>dstStr</code>. So when your function returns, <code>dstStr</code> in the calling function is still NULL, and there is nothing pointing to the memory that was allocated in <code>copyFrom()</code>. You have a memory leak!</p>

<p>You need to pass <code>dststr()</code> as a two-level pointer in order to change what it points to in the calling function:</p>

<pre><code>void copyFrom(char * str, char **dstStr)
{   
    char* mStr; 

    mStr = (char *)malloc((strlen(str)) + 1);
    if(mStr == NULL)
        return;


    while(*mStr++ = *str++) {
        ;
    }

    mStr[strlen(str)] = '\0';

    *dststr = mStr;

    return;
}
</code></pre>

<p>And of course your function declaration and call need to be changed accordingly. Your call would need to pass <code>&amp;dstStr</code> as the argument, not just <code>dstStr</code>.</p>
",0
18829029,18828771,2,"<p>You could use <code>copy_if</code> and a counter - that unfortunately doesn't break early.</p>

<pre><code>int count = 0;
std::copy_if(std::istream_iterator&lt;T&gt;(input), std::istream_iterator&lt;T&gt;(), output,
    [&amp;]() { return ++count &lt; 10; });
</code></pre>

<p>If you'd like to stick with algorithms (instead of plain <code>for</code> loop), I'd suggest you roll you own (I answered a <a href=""https://stackoverflow.com/questions/14055138/combining-c-standard-algorithms-by-looping-only-once/14055955#14055955"">similar question</a> in the past.)</p>
",0
18829080,18828771,4,"<p>Sadly, there is currently in general no way to limit the number of processed elements using STL algorithms. My personal view is that <code>std::copy()</code> should take two ranges both delimited by begin and end. If either end can't be reached the corresponding range would be unbounded. That is, if anything I would roll my own <code>copy()</code> algorithm like this:</p>

<pre><code>template &lt;typename InIt, typename OutIt&gt;
std::pair&lt;InIt, OutIt&gt;
copy(InIt init, InIt inend, OutIt outit, OutIt outend) {
    for (; init != inend &amp;&amp; outit != outend; ++init, ++outit) {
        *outit = *init;
    }
    return std::make_pair(init, outit);
}
</code></pre>

<p>To deal with the current iterator system, the comparison between output iterators actually can't be done. Thus, the comparison for output iterator actually requires a bit of template programming to make sure actual output iterators are never compared and, instead, <code>true</code> is returned. For all other iterator classes the above algorithm should just work (assuming I didn't introduce any typos).</p>
",0
18415283,18415237,2,"<p>1) From the context, in general. C++ does not have context free grammar like Rust for instance. However in this special case, it is always the string construction. Also, note that it does not compile since you would pass a rvalue to a non-const refeference.</p>

<p>2) hello2 creates a new string object on the heap, and hello1 does not. Also, note that you cannot pass a pointer to a function expecting a reference like this. It will not simply build with msvc, gcc, cland and so forth.</p>
",0
20199808,20199758,2,"<p>The better solution is not to require an <code>Init</code> function at all. You're trying to reinvent constructors, and breaking their design in the process.</p>

<p>If <code>Init</code> does too much work for a constructor, then do it outside and pass the resulting resources into <code>ClassMain</code> as a constructor argument; notice how you're already doing all the work in the constructor's scope anyway, thereby not gaining anything appreciable over proper initialisation.</p>

<p>Of course, if you must perform a ton of work before initialising <code>a</code>, and you cannot pass in a <code>ClassA&amp;</code> from the outside and initialise from that, then you're simply going to have to have <code>a</code> be an indirect member.</p>

<p>There is <em>one</em> nasty workaround you could use: have <code>Init</code> actually be a base constructor...</p>
",4
20199977,20199758,0,"<p>It's easier to take a pointer to ClassA; So, you can instantiate it whenever you want.(after the init())<br>
If you used a pointer, don't forget to implement the virtual destructor and release the allocated memory for the ClassA *a</p>
",0
20200074,20199758,0,"<p>If you absolutely must call some function at the start of your constructor, and can't put that setup into some base class or early-constructed member, you could use this ugly trick:</p>

<pre><code>ClassMain::ClassMain(int main_param)
  : a( (Init(init_arg), class_a_arg1), class_a_arg2 )
{
}
</code></pre>
",0
20200087,20199758,2,"<p>The obvious solution is to call <code>Init()</code> from the initializer list of an early member or a base class. Once this subobject is constructed its results can be passed to the constructors of other subobjects. For example, when defining stream classes I typically privately inherit from a virtual base containing the stream buffer:</p>

<pre><code>struct somebuf_base {
    somebuf sbuf;
    // ...
};
class somestream
    : private virtual somebuf_base
    , public std::ostream
{
public:
    somestream(someargs)
        : somebuf_base(someargs)
        , std::ostream(&amp;this-&gt;sbuf) {
    }
    // ...
};
</code></pre>

<p>Since base classes are constructed in the order they appear but virtual bases before non-virtual bases, the base class containing the <code>sbuf</code> member is constructed first. Its constructor replaces your <code>Init()</code> function.</p>

<p>When using C++ as of the 2011 revision, you might also use forwarding constructors to share logic between multiple constructors.</p>
",2
20200099,20199758,0,"<p>In this case: No, we cannot avoid that.</p>

<p>The reason is that when calling <code>Init</code> or any other member function you are guaranteed by the language that the object you are in exists. As <code>a</code> is a member of <code>ClassMain</code> it must be constructed before any function in <code>ClassMain</code> can be called.</p>

<p>The only chance that you have here is to refactor the code.</p>
",0
19269120,19269013,12,"<p><code>n</code> is incremented. It's just that C++ doesn't have a fixed order of evaluating arguments in a statement. Therefore, in the statement where you call <code>test_n</code> (the <code>std::cout</code> line just before the end), the compiler probably decides first to check the value of <code>n</code>, and only then call <code>test_n</code> and get its output.</p>

<p>My advice: Separate the calls - do test_n before cout and you should see the change.
So:</p>

<pre><code>int testnresult = test_n(v.begin(), v.end(), n);
std::cout &lt;&lt; testnresult  &lt;&lt; "" (n="" &lt;&lt; n &lt;&lt; "")\n"";
</code></pre>

<p>See e.g. the question <a href=""https://stackoverflow.com/questions/621542/compilers-and-argument-order-of-evaluation-in-c"">Compilers and argument order of evaluation in C++</a> for details on order in which arguments are evaluated in C++.</p>
",1
19210038,19209797,2,"<p>This proved to be the underlying problem:</p>

<p>Have you tried dumping the input file (e.g. with <code>hexdump -C</code> or similar) to check for rogue control sequences such as <code>\r</code> which might explain the behaviour which you are seeing.</p>

<p>Your input file might be a text file from a DOS/Windows-like system and you might be using a Unix-like system.</p>
",0
18430998,18430957,0,"<p>You return by value for example when you want to modify the returned object without affecting the object which member function was called. In the following example you can modify <code>b</code> (which is returned by value) without changing object <code>a</code> (and value <code>_val</code> inside it):</p>

<pre><code>#include&lt;iostream&gt;
using namespace std;

class A{
public:
    A(int val) : _val(val){}
    int val(){return _val;}
private:
    int _val;
};

int main()
{
        A a(3);
        int b = a.val();
        ++b;
        cout &lt;&lt; ""a.val() = "" &lt;&lt; a.val() &lt;&lt; endl;
        cout &lt;&lt; ""b = "" &lt;&lt; b &lt;&lt; endl;
}
</code></pre>

<p>See <a href=""https://stackoverflow.com/questions/2939165/c-get-method-returning-by-value-or-by-reference"">more reasons</a></p>
",2
18431031,18430957,2,"<p>I think you are starting this question with the incorrect assumption that returning by value is less efficient than other forms of return.  This is just simply not the case for a few reasons</p>

<ul>
<li>Simple built-in types like <code>int</code>, <code>char</code>, etc ...  can be returned via a register</li>
<li>Even large values can be returned by value efficiently due to named return value optimization (<a href=""http://blogs.msdn.com/b/slippman/archive/2004/02/03/66739.aspx"" rel=""nofollow"">NRVO</a>)</li>
</ul>

<p>There are certainly cases where return by value is inefficient.  However this does not mean that every case is so.  </p>
",0
18431038,18430957,2,"<p>A Beginner's Answer:</p>

<p>Returning by value makes sense if I do not need the variables I am passing to be changed but just want the value of the solution of the function for purposes like printing the value and I do not need to store the answer anywhere!</p>

<p>Just trying to help! </p>
",0
18431063,18430957,3,"<p>Returning by value is <strong>no less efficient</strong> in two cases: <strong>1</strong> if you're moving an object (C++11) and <strong>2</strong> if the compiler can elide the copy or optimise the return value away (always possible for built-in types, see also JaredPar's answer).</p>

<p>There are <strong>several advantages</strong>: <strong>1</strong> no variable needs to be declared prior to the function call (which may not always be possible) and the returned variable type is detectable via <code>auto</code> <strong>2</strong> the intent of setting the returned variable is obvious.</p>

<pre><code>void foo(some_type &amp;obj_ref);
some_type bar();

// using reference
some_type A;          // requires default constructor for A
foo(A);               // modification of A is not obvious

// returning a value
auto B = bar();       // move or copy construction of B
</code></pre>

<p>Note that the last statement can either use return-value optimisation or move semantics (C++11)</p>
",4
18431168,18430957,3,"<p>This is what g++ produces by default when using the -O3 flag for a method that returns an integer by reference:</p>

<pre><code>void Foo(int&amp; rc) {
    rc = 42;
}
</code></pre>

<p>Becomes:</p>

<pre><code>__Z3FooRi:
Leh_func_begin1:
    pushq   %rbp
Ltmp0:   
    movq    %rsp, %rbp
Ltmp1:
    movl    $42, (%rdi)
    popq    %rbp
    ret
Leh_func_end1:
</code></pre>

<p>Here's the same method returning by value:</p>

<pre><code>int Foo() {
  return 42;
}
</code></pre>

<p>Becomes:</p>

<pre><code>__Z3Foov:
Leh_func_begin1:
    pushq   %rbp
Ltmp0:
    movq    %rsp, %rbp
Ltmp1:
    movl    $42, %eax
    popq    %rbp
    ret
Leh_func_end1:
</code></pre>

<p>As you can see, your premise is flawed.  Both versions result in nearly identical machine code.</p>

<p>People have been producing optimizing compilers for C/C++ for three decades.  You can assume they've thought of any common use cases, and done their damnedest to ensure that any common code pattern will produce optimal code.  Never, ever change your coding style to improve performance unless you are armed with profiling results that definitively prove that it there is a difference.  Far too many of these sorts of ""optimizations"" not only make code harder to read, but actually make performance worse.</p>

<p><strong>EDIT</strong></p>

<p>Here's a similar comparison with a larger type.  Here, both methods return the following <code>struct</code>:</p>

<pre><code>struct Bar
{
    unsigned int a;
    unsigned int b;
    unsigned int c;
    unsigned int d;
};
</code></pre>

<p>This code:</p>

<pre><code>void Foo(Bar&amp; rc) {
    rc.a = 1;
    rc.b = 2;
    rc.c = 3;
    rc.d = 4;
}
</code></pre>

<p>produces this output:</p>

<pre><code>__Z3FooR3Bar:
Leh_func_begin1:
    pushq   %rbp
Ltmp0:
    movq    %rsp, %rbp
Ltmp1:
    movl    $1, (%rdi)
    movl    $2, 4(%rdi)
    movl    $3, 8(%rdi)
    movl    $4, 12(%rdi)
    popq    %rbp
    ret
</code></pre>

<p>Leh_func_end1:</p>

<p>On the other hand, this return by value version:</p>

<pre><code>Bar Foo() {
    Bar rc;
    rc.a = 1;
    rc.a = 2;
    rc.a = 3;
    rc.a = 4;

    return rc;
}
</code></pre>

<p>ends up producing <em>fewer</em> machine code instructions:</p>

<pre><code>__Z3Foov:
Leh_func_begin1:
    pushq   %rbp
Ltmp0:
    movq    %rsp, %rbp
Ltmp1:
    movl    $4, %eax
    xorl    %edx, %edx
    popq    %rbp
    ret
Leh_func_end1:
</code></pre>

<p>If you want to do these comparisons yourself in g++, use <code>g++ -S -O3</code>.  Other compilers will have similar methods of producing assembly.</p>
",2
18431126,18430957,7,"<p>You're missing the big point here - returning by reference doesn't always makes sense, nor is it always legal. Returning a local by reference leads to undefined behavior. You can return by reference a variable that lives beyond the scope of the function, which can be:</p>

<ul>
<li>dynamically allocated - bad idea, you have to manage the lifetime yourself</li>
<li>member of a class - this is commonly used with getters that have 2 versions: one that returns a reference &amp; you can modify the member or a <code>const</code> getter that returns a <code>const</code> reference</li>
<li>a <code>static</code> local variable (or any variable with static storage) - more often than not, this isn't needed in functions just for returning by reference.</li>
</ul>

<p>NRVO makes return by value feasible in practice, so unless you have clear measurements that indicate return by value is a bottleneck don't worry about it. Worry instead about the semantics of what either imply.</p>
",0
18431443,18430957,1,"<p>Your assumption is disputable (comments have been given), but for the question: I recommend reading</p>

<p>Scott Meyers' <em>Effective C++ (Third Edition)</em>,<br>
<strong>Item 21: Don't try to return a reference when you must return an object.</strong></p>

<p>The example is (slightly modified):</p>

<pre><code>class Rational {
public:
    Rational(int numerator = 0, int denominator = 1)
        : n(numerator), d(denominator) {}

    // ...

private:
    int n, d;

    friend Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs);
};
</code></pre>

<p>The use is like this:</p>

<pre><code>    Rational a(1, 2);    // a = 1/2
    Rational b(3, 5);    // b = 3/5

    Rational c = a * b;  // c should be 3/10
</code></pre>

<p>And the implementation:</p>

<pre><code>Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)
{
    Rational result(lhs.n * rhs.n, lhs.d * rhs.d);
    // Would you return that local variable by reference?
    //  You don't want a dangling reference...
    //  Returning by value is the correct thing to do.
    return result;
}
</code></pre>

<p>or shorter:</p>

<pre><code>Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)
{
    return Rational(lhs.n * rhs.n, lhs.d * rhs.d);
}
</code></pre>

<p>(you can make it <code>inline</code> and put it in the header).</p>

<p>Read the complete Item for a review of the ""alternatives"" (dynamic allocation, static variables...) and a detailed argumentation of why they're all bad (that's the point: <em>they're all bad</em>: subtly dangerous or even downright incorrect).</p>

<p>Finally, quoting from there:</p>

<blockquote>
  <p>The right way to write a function that must return a new object is to
  have that function return a new object.</p>
</blockquote>

<p>So: when it's the natural semantics, just return by value.</p>
",0
19887639,19887596,0,"<p>What you want to do is something like this I think:</p>

<pre><code>char Table[10][50];
char block[1000] = ""the cat and the hat."";
int pos = 0;
int row = 0;
int col = 0;

while (pos &lt; strLen(block)) {
    if(block[pos] == ' ')
    {
      table[row][col] = '\0';
      row++;
      col = 0;
    }
    else
    {
      table[row][col] = block[pos];
      col++;
    }
    }
    pos++;
}
</code></pre>

<p><a href=""https://stackoverflow.com/questions/19887232/how-to-loop-through-a-string-by-space-how-do-i-know-the-index-no-of-the-word-i/19887488#19887488"">This</a> link could also help you.</p>
",2
19887661,19887596,0,"<p>How about this</p>

<pre><code>int row = 0;
int col = 0;
for (int pos = 0; pos &lt; strlen(block); ++pos)
{
    if (block[pos] == ' ')
    {
        Table[row][col] = '\0'; // make sure each row is null terminated
        ++row;                  // move to the next row
        col = 0;                // starting at column zero
    }
    else
    {
        Table[row][col] = block[pos];
        ++col;
    }
}
</code></pre>

<p>Untested code.</p>

<p>Unlike your code it does look for spaces in the input, which if you think about it, is pretty much required to separate text into words.</p>
",0
19887690,19887596,0,"<p>Because everytime iterating the outer 'while' loop, it will overwrite 'Table[i][y]', move away the outer loop and make the following modification.</p>

<pre><code>char Table[10][50];
char block[1000] = ""the cat and the hat."";
int pos = 0;

for(int i = 0; i &lt; 10 &amp;&amp; i&lt;strlen(block); i++) {
   for(int y = 0; y &lt; 50; y++) {
       Table[i][y] = block[pos];       
    }
    pos++;
}
</code></pre>
",2
18869006,18868901,2,"<p>Totally illegal and UB, but you would do something like <code>*reinterpret_cast&lt;int*&gt;(data+offset)</code>.</p>

<p>Watch out for alignment and stuff.</p>
",7
18869200,18868901,0,"<p>First of all, in C++ as they have stated in the comments, this is illegal. Nevertheless, assuming your compiler assumes you might do something like this and has a well-defined behavior for it, then let's go ahead.</p>

<p>So <em>semantically</em>, you have such a struct:</p>

<pre><code>typedef struct {
    int32_t  DataLen;
    char     Data[N];
} MTEMSG;
</code></pre>

<p>where <code>N</code> is ""large enough"".</p>

<p>And you need to convert <code>Data</code> to a 4-byte little endian integer. That's quite simple:</p>

<pre><code>MTEMSG* data;
int offset = 0;
....
int Reader::ReadInt()
{
    /* Note: int32_t would be more precise */
    int result = data-&gt;Data[offset + 0]
              | (data-&gt;Data[offset + 1] &lt;&lt; 8)
              | (data-&gt;Data[offset + 2] &lt;&lt; 16)
              | (data-&gt;Data[offset + 3] &lt;&lt; 24);
    offset += 4;
}
</code></pre>
",13
20407102,20406699,1,"<pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;

using namespace std;

int main()
{
    //5 seconds
    auto duration = chrono::duration&lt;float&gt;(5);

    this_thread::sleep_for(duration);
    return 0;
}
</code></pre>

<p>However, even if this code is completely fine, I can't seem to compile it with the provided MinGW compiler from Code::Blocks.</p>
",0
20511177,20511019,0,"<p>According to <code>ldd</code> The following libraries are linked by default with g++ 4.8 on my ubuntu linux machine for basic c++ programs.</p>

<pre><code>linux-vdso.so.1 =&gt;  (0x00007fffe11fe000)
libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f1d1e49b000)
libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f1d1e285000)
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f1d1debc000)
libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f1d1dbb8000)
/lib64/ld-linux-x86-64.so.2 (0x00007f1d1e7c7000)
</code></pre>

<p>You can disable linking them using <code>-nodefaultlibs</code> switch but you also need to specify that they need to be linked later using the appropriate switches.</p>
",0
20511185,20511019,2,"<p>By default, G++ in Linux will link against the C standard library and C++ standard library.  Occasionally it will also bring in the math library automatically, although historically you need to ask for that with <code>-lm</code>.</p>

<p>On my Ubuntu box, I compiled and linked the following simple ""Hello World"" app:</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; ""Hello world!"" &lt;&lt; std::endl;
}
</code></pre>

<p>I compiled it as follows: <code>g++ hello.cpp</code></p>

<p>The <code>ldd</code> utility lists the libraries <code>g++</code> linked this against:</p>

<pre><code>$ ldd a.out
linux-vdso.so.1 =&gt;  (0x00007fff1d344000)
libstdc++.so.6 =&gt; /usr/local/lib64/libstdc++.so.6 (0x00007fd7fb031000)
libm.so.6 =&gt; /lib/libm.so.6 (0x00007fd7fadae000)
libgcc_s.so.1 =&gt; /usr/local/lib64/libgcc_s.so.1 (0x00007fd7fab97000)
libc.so.6 =&gt; /lib/libc.so.6 (0x00007fd7fa813000)
/lib64/ld-linux-x86-64.so.2 (0x00007fd7fb365000)
</code></pre>

<p>The first line, <code>linux-vdso.so.1</code> isn't actually a library.  Google it if you want to learn about some magic hackery.  The rest are pretty pedestrian:</p>

<ul>
<li><code>libstdc++</code> is the C++ standard library</li>
<li><code>libm</code> is the aforementioned math library.  I don't know if C++ includes it by default, but historically the C compiler did not include it unless you specified <code>-lm</code> at link time.</li>
<li><code>libgcc_s</code> is a GCC-specific support library, containing various support routines (ie. for oddball things like oddball divides, structure-copies, etc.)</li>
<li><code>libc</code> is the C standard library.  It also contains a lot of POSIX functionality.  </li>
<li><code>ld-linux-x86-64</code> is the dynamic library loader.  This is actually an <em>executable</em>.</li>
</ul>

<p>So, that's the default bit of kit.</p>

<p>Pieces such as <code>malloc</code>, <code>new</code>, <code>printf</code>, etc. are all in there, along with the full C++ standard library (what some call the ""STL"").</p>

<p>If you're asking what support comes by default, this is it.  If you're trying to implement your own versions of these things... the <code>-nodefaultlibs</code> flag will let you.  You might also need <code>-ffreestanding</code> and maybe even <code>-fno-builtins</code>.</p>

<p>If you want to see how these pieces are built (including how glibc calls <code>mmap</code> and/or <code>sbrk</code> to get memory to populate a <code>malloc</code> heap), you can download the source for glibc and take a look.  There isn't a level below <code>glibc</code> you can target directly other than making system calls directly.</p>

<p>Assuming you're building your code with GCC / G++, you may need to include some of these libraries, such as <code>libgcc_s</code> and <code>libstdc++</code>.  You might be able to limit / eliminate your dependence on <code>libstdc++</code> if you refrain from using standard library functions, and build with <code>-ffreestanding</code>.  But, I'll be honest:  I only know of the flag, I've never used it.</p>
",3
20511099,20511019,1,"<p>I think you want some lower level API for memory management. Then this <a href=""https://stackoverflow.com/questions/18033518/what-are-the-windows-and-linux-native-os-system-calls-made-from-malloc"">question</a> might help you.</p>

<p>It suggests <code>mmap</code> function. It hope it might help you.</p>
",2
20512900,20511019,0,"<p>On Linux, glibc is equivalent of a lot of stuff in the Windows libraries. The POSIX C interface functions, including the C standard library and also the kernel system call wrappers are all in libc. It is the primary wrapper layer providing ABI compatibility between various kernel versions. Not using it is very stupid.</p>

<p>The Windows CRT indeed has a different status, because POSIX has a different status on Windows. Where the Win32 API provides the OS interface on Windows, it is POSIX (including the C stdlib!) on Linux.</p>

<p>When on Linux, link glibc.</p>

<p>You will also need to link some compiler support library, be it LLVM's compiler-rt or GCC's libgcc.</p>
",0
18944081,18944026,6,"<p>From <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/aa366877%28v=vs.85%29.aspx"" rel=""noreferrer"">MSDN</a>:</p>

<blockquote>
  <p>Use this function instead of <code>ZeroMemory</code> when you want to ensure that your data will be overwritten promptly, as some C++ compilers can optimize a call to <code>ZeroMemory</code> by removing it entirely.</p>
</blockquote>

<p>Additionally a simple assignment, w/o a barrier, may be cached by hardware and not make it to the RAM for long time. Or a local variable may be optimized away. SecureZeroMemory makes sure none of that happens.</p>

<p>As to why use for initializing <code>addrinfo</code>, a clearly non-security related concern, beats me.</p>
",0
18944094,18944026,9,"<p>If (for example) the variable is not used anymore in the present scope (or in any other scenario where the compiler proves it doesn't change the internal coherence the program), the compiler could optimize away the zeroing statement. For security-critical memory, this could compromise the security of the application when it comes to external processes examining the memory of yours. <code>SecureZeroMemory</code> is written so that it does not get optimized away.</p>

<p>I can't tell for sure why this particular code snippet chooses that function over other methods of zeroing a memory range. It could be a misunderstanding of its purpose by the code's author or a misguided company policy.</p>
",0
20644361,20644166,2,"<p>Another option would be to actually make name of each implementation platform specific and have a simple typedef switch in header to control which one is chosen based on target/architecture:</p>

<pre><code>#ifdef target1
typedef AClass Target1ClassImplementation;
#elif  defined target2
typedef AClass Target2ClassImplementation;
#else
#error AClass is not implemented for current target
#endif
</code></pre>

<p>If desired, common interface can be encapsulated in a base class implementations derive from. It is less error prone since is more explicit in sense which implementation is for what target, while allows using AClass regardlesss of a platform target outside of header.</p>
",0
20644429,20644166,0,"<p>B is much better in most cases:</p>

<p>Advantages:</p>

<ul>
<li>Hide implementation details.</li>
<li>Less #includes in header files (less exposed dependencies!):
<ul>
<li>Faster builds</li>
<li>2 classes can call each other's functions. Very tricky to do if both are in headers.</li>
<li>Changes to implementation do affect other classes (build time).</li>
</ul></li>
</ul>

<p>Disadvantages:
  - Functions in CPP file do not inline in other modules (across library boundaries)</p>

<p>Optimal: Decide per function which is best. Short one liners to the header and longer ones to the cpp(s). You can have more than 1 source file for the class implementation.</p>
",0
19443094,19442928,-1,"<p>Yes, There is a reason to make the destructor in private section.It will create C++ class<br>
 whose objects can only be dynamically allocated.</p>

<p>you can take this example:</p>

<pre><code> #include &lt;iostream&gt;
  using namespace std;

  // A class whose object can only be dynamically created
  class Test
     {
      private:
        ~Test() { cout &lt;&lt; ""Destroying Object\n""; }
      public:
        Test() { cout &lt;&lt; ""Object Created\n""; }
        friend void destructTest(Test* );
 };

// Only this function can destruct objects of Test
  void destructTest(Test* ptr)
    {
delete ptr;
cout &lt;&lt; ""Object Destroyed\n"";
}

  int main()
     {
   /* Uncommenting following following line would cause compiler error */
   // Test t1;

 // create an object
     Test *ptr = new Test;

 // destruct the object to avoid memory leak
destructTest(ptr);

return 0;
    }
</code></pre>

<p>If you try to crate a static object compiler gives an error</p>
",2
19443118,19442928,2,"<p>It might come up in the case of shared libraries to limit what an application can do.</p>

<p>The application using the shared library uses an exported function to get a handle to the object and has to explicitly call another exported function to destroy the object. </p>

<p>Its like a contract of usage with good reason - it exists in the DLL/so 's heap or data segment - so the application can't deallocate it). </p>

<p>That exported function in turn would call your static function. Something like:</p>

<pre><code>extern ""C"" __declspec(dllexport) MyClass* CreateMyClass() {
    return &amp;MyClass::GetInstance();
}


extern ""C"" __declspec(dllexport) void     DestroyMyClass(MyClass* handle) {
    delete handle; // assumes destructor isn't private. 
    // if destructor is private, you can't use delete since it calls the destructor, which is .... private!
    handle-&gt;Destroy(); // A member function that calls the private destructor
}

MyClass::Destroy() {
    if (it_is_safe_to_destroy_the_class)
        ~Destroy();
}
</code></pre>

<p>But, then the Destroy() member function ought to be public, so this example isn't good enough (it served as a good reason for private constructor)</p>

<p>Essentially, you want to limit what users of your class can do via private construction and/or destruction. 
You ""create"" the instance, not them, via a static variable and allow them to only use the functionality (public interface) and not anything else.
Similarly, you destroy it when you deem it safe.</p>

<p>(Edit: My previous answer was focused towards private construction, so I added a more explicit example for private destruction)</p>
",0
19443223,19442928,0,"<p>A <code>private</code> destructor <strong>is accessible</strong> by all member functions (including <code>static</code> ones) of the class itself and all its <code>friend</code>s. So, obviously, if you only want those to be able to destroy an object, then making the destructor <code>private</code> is the way to go.</p>
",3
19443372,19442928,0,"<p>The class you posted looks like a singleton, which is a class that is only allowed to be instanced once per execution. Both the constructor and destructor are made private, to make sure the only way you can access an instance of the object is via the GetInstance call, which is written in such a way as to ensure only one instance will exist.</p>

<p><a href=""https://stackoverflow.com/questions/1008019/c-singleton-design-pattern"">C++ Singleton design pattern</a></p>

<p>With your implementation, the instance is a static object, which means it will be deleted when static objects are cleaned up by your program, basically when the program ends.</p>

<p><a href=""https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function"">What is the lifetime of a static variable in a C++ function?</a></p>
",0
20522582,20522541,11,"<p>Your parentheses are in the wrong place. You meant to write:</p>

<pre><code>strlen((LPCTSTR)strTemp) + 1
</code></pre>

<p>You'll therefore be allocating a buffer that is two characters shorter that it needs to be.</p>

<p>It would make more sense to use the <code>GetLength()</code> method:</p>

<pre><code>strr = new char[strTemp.GetLength() + 1)];
</code></pre>

<p>And this code is clearly wrong:</p>

<pre><code>strr = NULL;
delete[] strr;
</code></pre>

<p>Surely you cannot expect to use <code>delete[]</code> on <code>NULL</code>.</p>
",3
20522586,20522541,7,"<p>I think you meant:</p>

<pre><code>strr = new char[strlen((LPCTSTR)strTemp) + 1];
</code></pre>

<p>this +1 is for '\0' right?</p>
",0
19877093,19862884,0,"<p>Well, here's one version, but VC doesn't support it.
IntelC and gcc do though.</p>

<pre><code>template&lt; class wrap, class pad, pad wrap::*X &gt; struct pin {
  int y1;
  void test( void ) {
    wrap&amp; W = *(wrap*)(((char*)this) - size_t(&amp;(((wrap*)0)-&gt;*X)) - sizeof(pad));
    printf( ""y1=%i W.x1=%i W.x2=%i\n"", y1, W.x1, W.x2 );
  }
};

struct wrap {
  int x1;
  char x2;
  typedef pin&lt; wrap, char, &amp;wrap::x2 &gt; r3_t;
  r3_t r3;
  typedef pin&lt; wrap, r3_t, &amp;wrap::r3 &gt; r4_t;
  r4_t r4;
};

wrap Z = {456,123,33333,44444};

int main( void ) {
  Z.r3.test();
  Z.r4.test();
}
</code></pre>

<p>VC: <a href=""http://rextester.com/QFY31637"" rel=""nofollow"">http://rextester.com/QFY31637</a>
gcc: <a href=""http://rextester.com/HEN91787"" rel=""nofollow"">http://rextester.com/HEN91787</a></p>
",0
20405600,20405518,3,"<p>C++ encapsulation is class based. Instances of a class can freely access private members of other objects of the same class.</p>
",2
20405822,20405518,1,"<p>This is a very good basic explanation <a href=""http://www.cplusplus.com/doc/tutorial/inheritance/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/inheritance/</a></p>

<p>You will find there, among others, a table with access types. This is what interests you, but the whole article is useful.</p>
",0
20202159,20201622,1,"<p>Perhaps you want to do a dynamic_cast&lt;></p>

<p>You may want C++ to behave like some language with reflection such as C#. That is not true.<br>
This is another post that is similar.  </p>

<pre><code>http://stackoverflow.com/questions/3049404/apples-oranges-and-pointers-to-the-most-derived-c-class
</code></pre>

<p>You may be asking something of C++ that it does not have.</p>

<pre><code>class basex
{
    public:
    virtual ~basex() {};
};
class middlex : public basex
{
    public:
    //middlex() = default;
};
int dynamic_test()
{
    basex * cbq = new middlex;
    basex * cbq2 = new basex;
    middlex * mcp = dynamic_cast&lt;middlex *&gt;(cbq);
    //should suceed
    if (nullptr != mcp)
    {
        cout &lt;&lt; ""dynamic cast worked"" &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; ""dynamic cast failed"" &lt;&lt; endl;
    }
    //should fail
    middlex * mcp2 = dynamic_cast&lt;middlex *&gt;(cbq2);
    if (nullptr != mcp2)
    {
        cout &lt;&lt; ""dynamic cast worked"" &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; ""dynamic cast failed"" &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<p>You seem like you really want to do simple casts and the member function does not seem useful  </p>

<p>.....................</p>

<pre><code>template &lt; class T &gt;
T* GetTop()
</code></pre>

<p>needs improvement
It is simply doing a cast .... and casts require the destination type
static_cast requires explicit type argument
thus..
GetTop requires explicit type argument</p>

<p>GetTop
is a member function  ... the T can be any class ... the code provided .. has no given parameters for type deduction ... the pointer your provide is ... C++ this ...thus you may call it only TopClass or derived objects. (Lets exclude complicated casts)</p>

<pre><code>TopClass * top = m-&gt;GetTop();
</code></pre>

<p>Compiler will try to make sense of right side .............not considering left side<br>
The compiler does not consider the left side for type deduction.. there is no assistance to type deduction .. it will simply try to make sense of the right side<br>
I say that because it seems you might believe the compiler will use the type TopClass for type deduction ... it will not    </p>

<p>This will work compile    </p>

<pre><code>TopClass * top = m-&gt;GetTop&lt;TopClass&gt;();
</code></pre>

<p>But its doing nothing more than an explicit static_cast</p>

<p>Maybe you should state what you are intending to do</p>
",3
19325782,19293489,3,"<p>Sorry if the answer is too late, but you should also study the complexity of this function to understand better why it doesn't work fine.</p>

<p>Since for every appeal of the function you call <strong>fib(n-1)</strong> and <strong>fib(n-2)</strong> , the number of operations performed by <strong>fib(n)</strong> will be around <strong>2^n</strong>. Check the following program which counts how many times <strong>fib()</strong> is called:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int cnt = 0;

int fib(int n) {
    cnt++;
    if (n &lt;= 1) return n;
    return fib(n - 1) + fib(n - 2);
}

int main() {
    cout &lt;&lt; fib(15) &lt;&lt; '\n';
    cout &lt;&lt; cnt &lt;&lt; '\n';
}
</code></pre>

<p>So, if you want to call <strong>fib(100)</strong>, it will perform about <strong>10^18</strong> operations, and assuming that your computer is fast enought to make <strong>10^9</strong> operations in <strong>1 second</strong>, it will take like <strong>33 years</strong> to finish this. </p>

<p>But this will cause a stack overflow error earlier.</p>

<p>It is true that <strong>fib(100)</strong> will have more than <strong>19 digits</strong>, which is (aprox.) the max value that <strong>long long</strong> can hold, but this is not the main reason why your function is <strong><em>""sticky""</em></strong>.</p>

<p>A good (and maybe the best) alternative here would be to do as @soon said above, using an <strong>iterative</strong> function / algorithm that have <strong>linear complexity</strong> (your function is <strong>exponential</strong>, read more <a href=""http://en.wikipedia.org/wiki/Time_complexity"" rel=""nofollow noreferrer"">here</a>).</p>

<p>Here's a code of fibonacci function implemented using big numbers in <strong>C++</strong> (there's more <strong>C</strong> actually, but, anyways):</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

const int maxsize = 10000; // number of digits
int n;

// note that the digits are keep reversed in the vector
// the bigsum function is as you would use add in math
// a = a + b
void bigsum(int a[], int b[]) { // in a[0] I hold the number of digits of 'a'
    int i, t = 0;
    for (i = 1; i &lt;= a[0] || i &lt;= b[0] || t; ++i) { // while you still have digits to add
        t = t + a[i] + b[i]; 
        a[i] = t % 10;
        t /= 10;
    }
    a[0] = i - 1; // the new a[0]
}

int zero[maxsize];

// a = b
void copy(int a[], int b[]) {
    for (int i = 0; i &lt;= b[0]; ++i) {
        a[i] = b[i];
    }
}

void fib(int n) {
    if (n &lt; 0) {
        cout &lt;&lt; ""NA"";
    } else if (n == 0) {
        cout &lt;&lt; 0;
    } else if (n == 1 || n == 2) {
        cout &lt;&lt; 1;
    } else if (n == 3) {
        cout &lt;&lt; 2;
    } else {
        int first[maxsize], second[maxsize], third[maxsize];
        copy(first, zero); copy(second, zero); copy(third, zero);
        first[0] = first[1] = second[0] = second[1] = 1; // initializing the numbers with 1
        third[0] = 1; third[1] = 2; // initializing with 2

        for (int i = 4; i &lt;= n; ++i) {
            copy(first, second);
            copy(second, third); // if you don't understand why these 3, try to do it on a paper
            bigsum(third, first);
        }

        for (int i = third[0]; i &gt;= 1; --i) { // because the digits are reversed
            cout &lt;&lt; third[i];
        }
    }
    cout &lt;&lt; '\n';
}

int main() {
    cin &gt;&gt; n;
    fib(n);
}
</code></pre>

<p>Now the <strong>fib</strong> function works for higher numbers (<strong>10000</strong> digits, just change the <strong>maxsize</strong> value if you want higher) and the total number of operations is <strong>n * NUMBER_OF_DIGITS</strong>, which is around <strong>n^2</strong> (way smaller than <strong>2^n</strong>).</p>

<p>Another very nice solution would be using a <strong>2x2 matrix</strong>, which allows you to calculate the remainder <strong>fib(n) % SOME_NUMBER</strong> in aprox. <strong>log2(n)</strong> operations (you can use <strong>""exponentiation by squaring""</strong>, see <a href=""https://stackoverflow.com/questions/101439/the-most-efficient-way-to-implement-an-integer-based-power-function-powint-int"">this</a>). Read more about the matrix solution <a href=""http://en.wikipedia.org/wiki/Fibonacci_number#Matrix_form"" rel=""nofollow noreferrer"">here</a>.</p>

<p>In conclusion, your program isn't good because it runs in <strong>exponential</strong> complexity and also it uses too much stack memory (even if it returns the correct value).</p>

<p>Hope you understand now the issues of your function. Sorry again if this post shouldn't be here.</p>

<p>All the best!</p>
",0
19434743,19432898,0,"<p>This is not really an answer, but another question about your design approach in general: </p>

<p>Apparently you're trying to design a tree node, right?<br>
Why are you storing the parent class in the node and not vice versa (i.e. holding a <code>std::vector</code> of the child node instances or pointers). This would simplify semantics for assignment (copying) a lot. You'll need methods to add/remove/clear child nodes in turn of course, setting the <code>_parent</code> member should be done internally within add/remove implementation then. Tree leaf implementations of nodes would just provide empty methods for this functionality. Also I would add another level of indirection then and declare <code>Node</code> as a pure abstract class and provide s.th. like <code>ContainerNodeBase</code> and <code>LeafNodeBase</code> as 1st level of implementation.</p>

<p>Also I would avoid using raw pointers in (at least) production code. You should use <code>std::shared_ptr</code> or <a href=""http://en.cppreference.com/w/cpp/memory"" rel=""nofollow"">alike</a>.</p>

<p>Let me give an example what I think your <code>Node</code> design should look like:</p>

<p><strong>1st Level</strong> provide abstract interfaces:</p>

<pre><code> struct INode
 {
     virtual const std::string &amp; name() const = 0;
     virtual void name(const std::string&amp; value) = 0;
     virtual INode* parent() const = 0;
     virtual ~INode() {}
 };

 struct INodeCotainer
 {
     virtual void add(std::shared_ptr&lt;INode&gt; child) = 0;
     virtual void remove(const INode* child) = 0;
     virtual void clear() = 0;
     virtual const std::vector&lt;std::shared_ptr&lt;INode&gt;&gt;&amp; childs() const = 0; 
     virtual ~INodeCotainer() {}
 };
</code></pre>

<p><strong>2nd Level</strong> provide base implementation:</p>

<pre><code> class NodeBase
 : public INode
 {
 public:
     virtual const std::string &amp; name() const { return name_; }
     virtual void name(const std::string&amp; value) { name_ = value; }
     virtual INode* parent() const { return parent_; }

 protected: // protect this class from direct instantiation
     NodeBase() {}
     NodeBase(const NodeBase&amp; rhs) { parent_ = nullptr; name_ = rhs.name; }
     NodeBase&amp; operator=(const NodeBase&amp; rhs) 
     { 
        if(&amp;rhs != this)
        {
            parent_ = nullptr; name_ = rhs.name;
        }
        return *this;
     }

     INode* parent_;

 private:
     std::string name_;
 };
</code></pre>

<p><strong>3rd Level</strong> provide concrete implementation(s)</p>

<pre><code> class ContainerNode
 : public NodeBase
 , public INodeContainer
 {
 public:
     ContainerNode() : NodeBase {}
     ContainerNode(const ContainerNode&amp; rhs) : NodeBase(rhs) 
     {
         std::copy(childs_,rhs.childs_);
     }
     ContainerNode&amp; operator=(const ContainerNode&amp; rhs)
     {
         NodeBase::operator=(rhs);
         childs_.clear();
         std::copy(childs_,rhs.childs_);
     }

     virtual void add(std::shared_ptr&lt;INode&gt; child) 
     { 
         childs_.push_back(child);
         childs_.back()-&gt;parent_ = this;
     }         
     virtual void remove(const INode* child)
     {
         // Find the child reference in the childs_ vector remove it 
         // and set it's parent_ member to nullptr
     }
     virtual void clear() { childs_.clear(); }
     virtual const std::vector&lt;std::shared_ptr&lt;INode&gt;&gt;&amp; childs() const
         { return childs_; }

 private:
     std::vector&lt;std::shared_ptr&lt;INode&gt;&gt; childs_;
 }
</code></pre>

<hr>

<pre><code> class LeafNode
 : public NodeBase
 {
 public:
     LeafNode() : NodeBase {}
     LeafNode(const LeafNode&amp; rhs) : NodeBase(rhs) {}
     LeafNode&amp; operator=(const LeafNode&amp; rhs)
     {
         NodeBase::operator=(rhs);
     }
 }
</code></pre>
",2
20023353,20023306,0,"<p>Yes, in fact the compiler can check this for you: if the code compiles, the compiler was able to generate code which calls the default constructor of <code>test</code>, which in turn takes care of creating the object - so the object exists, and is initialized to some (possibly unknown, depending on how the <code>test</code> default constructor is implemented) state.</p>
",0
19887246,19886952,0,"<p>You haven't implemented for formulae correctly. For instance </p>

<pre><code>s = s0 - f(s0)/((s0-p0)*(s0-q0)*(s0-r0));
</code></pre>

<p>should be</p>

<pre><code>s = s0 - f(s0)/((s0-p)*(s0-q)*(s0-r));
</code></pre>

<p>Look again at the wiki article</p>
",2
20099210,20099106,2,"<p>This is extremely compiler and/or platform specific.  In fact, I just spent the better part of a day chasing down an incompatibility between two different compilers' way of handling this.  </p>

<p>Try your compiler's documentation, in particular the sections on C++ runtime initialization.  </p>
",0
20099678,20099106,2,"<p>The best way at run-time is to find the startup file for your C++ run-time.  This is the code that executes before main.  It is responsible for system initialization including initializing memory, static variables, and calling constructors of global objects.  In MS VC++ this file is crt0.c.  You can find it by setting a breakpoint at main and then looking at the stack trace.</p>
",0
20099425,20099106,3,"<p>In GCCs case you have:</p>

<pre><code>__CTOR_LIST__ (list of initialization functions called - pointers) 
__DTOR_LIST__ (list of functions called for cleanup)
</code></pre>

<p>They are automatically generated by the compiler for each translation unit (C/C++ file).</p>

<p>You can find more information about this <a href=""http://gcc.gnu.org/onlinedocs/gccint/Initialization.html"" rel=""nofollow"">here</a>. For other compilers this must be similar but you can ""guess"" it by using utilities like <a href=""http://linux.die.net/man/1/objdump"" rel=""nofollow"">objdump</a> or <a href=""http://linux.die.net/man/1/nm"" rel=""nofollow"">nm</a> (for your compiler suite, of course).</p>

<p>We called those pointer functions ( void (*func)(void) ) manually on a custom embedded platform on which we used g++.</p>

<hr>

<p>I saw that you are interested in finding the static/global variables.</p>

<p>For this task you can really use some tools like objdump and nm (previously mentioned). First create 2-3 test files (and compile them to obtain the .o/.obj) and see how the static/global variables are seen by those tools (in the .obj/.o files. Once you see that, you can go through all the .obj/.o files with a script and make a list of the static/global variables.</p>
",6
18429614,18426056,0,"<p>Assignment in C++ for any sophisticated type is user-defined.  Scalar and simple aggregate assignments are by value, but once an object starts acquiring relationships with peers and dependents you'll have told C++ exactly what parts need real duplication and what other effects the duplication will have.  Your game's top-level inventory of media objects will almost certainly be a simple reference copy.</p>
",0
18941267,18941247,6,"<p>This is wrong</p>

<pre><code>Site capital(""Capital"", year, &amp;civ);  // when I comment these three lines out
civ.capital = &amp;capital;               // the program doesn't crash, so I know
civ.sites.push_back(capital);         // that the dodgy site originates here.

// Add capital to tile
world[y][x].site = &amp;capital;
</code></pre>

<p>You are storing a pointer <code>&amp;capital</code> to a <em>local object</em> (and doing it twice it seems). When your <code>createCivilisation</code> method exits that local object is destroyed and so you end up with pointers to garbage.</p>

<p>The simple answer is for you to copy the object itself instead of trying to store a pointer. If the objects are large and therefore copying them is an issue, you should look to <em>dynamic heap allocation</em> and <em>smart pointers</em>.</p>
",3
18941312,18941247,4,"<p>When running in debug mode, Visual Studio automatically fills freed (or out-of-scope) memory with 0xCCCCCCCC. This enables you to catch use-after-free bugs, like the one you just encountered.</p>

<p>You are creating a reference to a local variable (stack variable). The variable goes out of scope at the conclusion of the method, leaving a dangling pointer in <code>world</code>.</p>

<p>You may wish to allocate the objects on the heap instead:</p>

<pre><code>Site *capital = new Site(""Capital"", year, &amp;civ);
</code></pre>

<p>though you must figure out when to free <code>capital</code> to avoid memory leaks. You can also use smart pointers (in this case a <code>shared_ptr</code> or similar) to simplify your life.</p>
",0
19788629,19788592,6,"<p>Wrong minus sign, type the minus sign again, then it works perfectly. Unicode...</p>

<p>You <code>C</code> -> me <code>-</code></p>
",0
19788704,19788592,3,"<p>You've somehow ended up with a Unicode ""en dash"" character instead of an ASCII <code>-</code>.</p>

<p>Make sure you're using a plain text editor not a word processor; delete and retype the dash; and be careful where you copy and paste code from.</p>
",0
19796810,19796515,3,"<p>feof() does not detect an EOF character in the input stream.  It indicates whether a read was attempted past the end of the file.  Additionally, in my experience, I'd say that most commands <em>do not</em> write an EOF character at the end of their output.  The fread() call will block until there is data to read, unless it is interrupted, so it doesn't matter how long the command runs.  depending on which operating system you are using, you may be able to tell the system to resume the interrupted system call in the event of a signal.  I also agree with Bastile.  You should use a bigger buffer for more efficient I/O.</p>
",4
19796584,19796515,2,"<p>Unless that function is interrupted, it will run as you expect. BTW you <code>buf</code> is quite small (only 128 bytes). I would suggest 4 or 8 kilobytes (see <a href=""http://linux.die.net/man/1/getconf"" rel=""nofollow"">getconf(1)</a> with  <code>PIPE_BUF</code>):</p>

<pre><code>while( !feof( stream ) &amp;&amp; !ferror( stream ))
{
    char buf[4096];
    memset (buf, 0, sizeof(buf)); //probably useless
    int bytesRead = fread(buf, 1, sizeof(buf), stream);
    if (bytesRead &lt; 0) 
       break;
    output.write(buf,bytesRead);
}
</code></pre>

<p>Read also <a href=""http://advancedlinuxprogramming.com/"" rel=""nofollow"">Advanced Linux Programming</a> ... If you want to read and write from the same process, you'll probably need to multiplex e.g. with <a href=""http://man7.org/linux/man-pages/man2/poll.2.html"" rel=""nofollow"">poll(2)</a> after having created the <a href=""http://man7.org/linux/man-pages/man2/pipe.2.html"" rel=""nofollow"">pipe(2)</a>-s.... etc etc..</p>

<p><sup>The zeroing of <code>buf</code> with <code>memset</code> is probably not really needed; however, if the above program has bugs, it will make it much more reproducible. This is why I like zeroing memory. and here zeroing memory is much faster than reading it.</sup></p>

<p>See also <a href=""http://man7.org/linux/man-pages/man3/fread.3.html"" rel=""nofollow"">fread(3)</a></p>
",3
18629013,18628918,1,"<p>Failure to allocate probably is such a major error that the program have to be terminated anyway, so if anything it's more often handled at a higher level (if at all) where the handling of the error is to simply inform the user about it and then exit.</p>
",3
18629394,18628918,1,"<p>It depends, it depends on how you want to treat the error in your specific code path.</p>

<p>If your code can check the error and move on with a different code path on error, say take a different condition or return an error to user while the program continues, then nothrow option is better. If your program cannot proceed if you run out of memory (the more common case) then instead of doing a try/catch on each new, you could catch the exception at the top level (main) and log the right error and abort the program.</p>
",2
20404157,20404085,2,"<p>The class you want to use is obsolete, use <code>std::unordered_set</code> instead.
As you can still include the header you could also try to use <code>stdext::hash_set</code>, though this is discouraged.</p>
",1
19803955,19803932,0,"<p>erm, you might want to look at <code>stringstream</code>.</p>
",0
19803958,19803932,3,"<p>Use <a href=""http://en.cppreference.com/w/cpp/io/basic_stringstream"" rel=""nofollow""><code>std::stringstream</code></a>:</p>

<pre><code>// Initialize contents of the stream with your string
std::stringstream myReadString(my_string);  

float x;
int y;

// Use the stream just like an fstream
// my_string = ""0.5 5""
myReadString &gt;&gt; x &gt;&gt; y;
</code></pre>
",3
19800394,19800353,3,"<p>You can't reassign <code>this</code>. Like the error says, it's not a modifiable l-value.</p>

<p>However, if <code>this</code> was a pointing at an object that had a mutable field of the same type you're trying to assign, you could access it through <code>this-&gt;myField</code> or <code>this.myField</code>, depending on whether it's a pointer or a reference.</p>
",3
19800464,19800353,1,"<p>""this"" is a reserved keyword that is a pointer to the object currently in scope (loosely similar to ""self"" if you're familiar with Python). It is designed to ALWAYS point to the object currently in scope, which means you cannot change its value.</p>

<p>What you're trying to do when you use ""this = tmp;"" is a little bit like trying to use ""false = 10;""</p>
",3
18499794,18488988,0,"<p>I really hope that i understood what you meant.
I tried to make a program as you showed here and i came up with this:</p>

<p>Macros.h:</p>

<pre><code>#ifndef MY_MACROS_H
#define MY_MACROS_H

#define VALUES(base)                \
                ADD_VALUE(0,base)   \
                ADD_VALUE(1,base)   \
                ADD_VALUE(2,base)   \
                ADD_VALUE(3,base)   \
                ADD_VALUE(4,base)   \
                ADD_VALUE(5,base)   \
                ADD_VALUE(6,base)   \
                ADD_VALUE(7,base)   \
                ADD_VALUE(8,base)   \
                VALUE(9,base)

#define VALUE(val,base) +1

#define ADD_VALUE(val,base) VALUE(val, base)


#define DIGIT_COUNT (0 VALUES(1))
#define BASE_COUNT  (DIGIT_COUNT + 1)

#define ALL_VALUES   ADD_ARRAY_VALUES(1)                                  \
                     ADD_ARRAY_VALUES(BASE_COUNT)                         \
                     ADD_ARRAY_VALUES(BASE_COUNT * BASE_COUNT)            \
                     ARRAY_VALUES(BASE_COUNT * BASE_COUNT * BASE_COUNT)

#define ARRAY_VALUES(rank) +1

#define ADD_ARRAY_VALUES(rank) ARRAY_VALUES(rank)

#define UNKNOWN_LETTER_PATTERN """"
#define ARRAYS_COUNT (0 ALL_VALUES)

#endif
</code></pre>

<p>Header.h:</p>

<pre><code>    #ifndef _MY_HEADER_H
#define _MY_HEADER_H

/*****
* Includes
******/
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include ""Macros.h""

using namespace std;

/*****
* Definitions
******/
#define FIRST_LETTER 'a'
#define LAST_LETTER  'z'

typedef unsigned char byte;

typedef int NumberValueType;

#define BASE_CHAR_VALUE '0'

// character 
#define CHAR_TO_CHAR_INDEX(character) (character - FIRST_LETTER) 
#define CHAR_TO_NUM_INDEX(character)  (character - BASE_CHAR_VALUE)

#define IS_CHAR_VALID(character) ((character &gt;= FIRST_LETTER) &amp;&amp; (character &lt;= LAST_LETTER))

int ParseInput();
string texttopattern(char c);

#endif
</code></pre>

<p>And the implementation file: (of course that i also printed and haven't done anything important with the output).</p>

<p>Main.cpp:</p>

<pre><code>    #include ""Header.h""

int s_arValues[ARRAYS_COUNT][DIGIT_COUNT] =
{   
    #undef  VALUE
    #define VALUE(val,base) (base * val)

    #undef ADD_VALUE
    #define ADD_VALUE(val,base) VALUE(val, base),

    #undef ARRAY_VALUES
    #define ARRAY_VALUES(rank) { VALUES(rank) }

    #undef ADD_ARRAY_VALUES
    #define ADD_ARRAY_VALUES(rank) ARRAY_VALUES(rank),

    ALL_VALUES
};


string texttopattern(char c)
{
    string code[] = {""1"",""12"",""14"",""145"", ""15"", ""124"", ""1245"",
                      ""125"", ""24"", ""245"", ""13"", ""123"", ""134"",
                      ""1345"", ""135"", ""1234"", ""12345"", ""1235"", ""234"", ""2345"",
                      ""136"", ""1236"", ""1346"", ""13456"", ""1356"", ""12346""};
    if (IS_CHAR_VALID(c))
        return code[CHAR_TO_CHAR_INDEX(c)];
    else
        return UNKNOWN_LETTER_PATTERN ;
}

int ParseInput()
{
    string ord;
    getline(cin, ord);
    vector&lt;string&gt; code;

    for(int i=0; i&lt;ord.length(); i++)
    {
        code.push_back(texttopattern(tolower(ord[i])));
    }

    // Loop inputs
    for (vector&lt;string&gt;::iterator itInputs = code.begin(); itInputs != code.end(); itInputs++) 
    {
        if (*itInputs == UNKNOWN_LETTER_PATTERN)
        {
            // Don't know what to do with unknown chars like spaces - your problem
            cout &lt;&lt; ""unknown letter"" &lt;&lt; endl;
            continue;
        }

        int number = 0;
        int nInputSize = itInputs-&gt;size();

        // Loop every digit in the current pattern
        for (int nDigitIndex = 0; nDigitIndex &lt; nInputSize; nDigitIndex++)
        {
            if(nDigitIndex &gt;= sizeof(NumberValueType))
            {
                cout &lt;&lt; number;
                number = 0;
                continue;
            }

            char cChar = itInputs-&gt;at(nDigitIndex);

            number += s_arValues[nInputSize - nDigitIndex - 1][CHAR_TO_NUM_INDEX(cChar)]; 
        }

        // At this point you can use number
        cout &lt;&lt; number;
        cout &lt;&lt; endl;
        cout &lt;&lt; ""End of letter"" &lt;&lt; endl;
    }

    cin.get();

    return 0;
}

void main()
{   
    ParseInput();
}
</code></pre>
",0
19504207,19504077,1,"<p>There are a number of changes that you need in <code>customers.h</code>.  See the comments in the code.</p>

<pre><code>#pragma once;

#include &lt;string&gt;        // including string as it is referenced in the struct

struct customer
{
    std::string name;    // using std qualifer in header
    customer *next;
};

// moved to below the struct, so that customer is known about
void print_customers(customer &amp;head);
</code></pre>

<p>You must then <code>#include ""customers.h""</code> in <code>customers.cpp</code>.  </p>

<p>Note how I didn't write <code>using namespace std</code> in the header file.  As this would import the <code>std</code> namespace into anything that included <code>customer.h</code>.  For more details see: <a href=""https://stackoverflow.com/questions/4872373/why-is-including-using-namespace-into-a-header-file-a-bad-idea-in-c"">Why is including &quot;using namespace&quot; into a header file a bad idea in C++?</a></p>
",0
19504106,19504077,2,"<pre><code>void print_customers(customer &amp;head);
</code></pre>

<p>C++ compiler work in top to bottom approach. So, every type, identifier it sees at the point must be known to it. </p>

<p>The problem is that compiler doesn't know the type <code>customer</code> in the above statement. Try forward declaring the type before the function's forward declaration.</p>

<pre><code>struct customer;
</code></pre>

<p>Or move the function forward declaration after the struct definition.</p>
",0
19504113,19504077,2,"<p>First,</p>

<pre><code>#include ""customers.h""  // in the ""customers.cpp"" file.
</code></pre>

<p>Second, <code>print_customers</code> uses <code>customer</code>, but this type is not declared yet. You have two ways to fix the problem.</p>

<ol>
<li>Put declaration of the function after declaration of the struct.</li>
<li>Put a forwarded declaration (<code>struct customer;</code>) before declaration of the function,</li>
</ol>
",0
18650966,18649634,1,"<p>Typically it will create a copy of the protos, 'typically' because compiler might add some optimizations depending on the specific code paths, but while coding we need not worry about that. Since you are looking only for a reference the following change would avoid the copy.</p>

<pre><code>const RangeOfUInt&amp; protos = filterDesc.getProto(); //Make the return variable a reference
</code></pre>
",4
18652535,18649634,0,"<p>I think if you want a const reference then keep the method as is change and your call as noted by @jayadev to be <code>const RangeOfUInt&amp; protos = filterDesc.getProto();</code>  If you want to modify a copy, then have a method call that just returns a copy. If you are using c++11 most items ( not sure what ValueType is ) seem move constructable and with copy value optimization you will not lose performance it will get constructed directly into the new object.  ( see NVRO )</p>

<pre><code>RangeOfUInt protos = filterDesc.getProto();

class gFilter 
{
  public:
  .
  inline RangeOfUInt  getProto()
  {
       return proto; 
  }
  private:
     
     RangeOfUInt   proto;
     
};
</code></pre>
",5
18654371,18649634,2,"<p>Yes, you are exactly right. <code>protos</code> is a copy made from the reference returned from <code>getProto</code>. (The caller creates the copy, <code>getProto</code> doesn't.)</p>
",0
19974691,19974629,0,"<p>Variant 1 will copy the address of the object and will be fast</p>

<p>Variant 2 will copy the whole object and will be slow (as already pointed out in Variant2 you cant delete the object which you created by calling new)</p>

<p>for the edit: Both f contain the same Object</p>
",2
19974881,19974629,2,"<p>First, you never want to return a reference to an object which
was dynamically allocated in the function.  This is a memory
leak waiting to happen. </p>

<p>Beyond that, it depends on the semantics of the object, and what
you are doing.  Using the reference (variant 1) allows
modification of the object it refers to, so that some other
function will see the modified value.  Declaring a value
(variant 2) means that you have your own local copy, and any
modifications, etc. will be to it, and not to the object
referred to in the function return.</p>

<p>Typically, if a function returns a reference to a non-const,
it's because it expects the value to be modified; a typical
example would be something like <code>std::vector&lt;&gt;::operator[]</code>,
where an expression like:</p>

<pre><code>v[i] = 42;
</code></pre>

<p>is expected to modify the element in the vector.  If this is
<em>not</em> the case, then the function should return a value, not
a reference (and you should almost never use such a function to
initialize a local reference).  And of course, this only makes
sense if you return a reference to something that is accessible
elsewhere; either a global variable or (far more likely) data
owned by the class of which the function is a member.</p>
",0
19974892,19974629,0,"<p>None of the two options you asked about is very good. In this particular case you should use <code>shared_ptr</code> or <code>unique_ptr</code>, or <code>auto_ptr</code> if you use older C++ compilers, and change the function so it returns pointer, not reference. Another good option is returning the object by value, especially if the object is small and cheap to construct. </p>

<p>Modification to return the object by value:</p>

<pre><code>SomeObject f() { return SomeObject(); }

SomeObject s(f());
</code></pre>

<p>Simple, clean, safe - no memory leaking here.</p>

<p>Using <code>unique_ptr</code>:</p>

<pre><code>SomeObject* f() { return new SomeObject(); }

unique_ptr&lt;SomeObject&gt; s(f());
</code></pre>

<p>One of the advantages of using a <code>unique_ptr</code> or <code>shared_ptr</code> here is that you can change your function <code>f</code> at some point to return objects of a class derived from <code>SomeObject</code> and none of your client code will need to be changed - just make sure the base class (<code>SomeObject</code>) has a virtual constructor.</p>

<p>Why the options you were considering are not very good:</p>

<p>Variant 1:</p>

<pre><code>SomeObject&amp; s = f();
</code></pre>

<p>How are you going to destroy the object? You will need address of the object to call it's destructor anyway, so at some point you would need to dereference the object that <code>s</code> refers to (<code>&amp;s</code>)</p>

<p>Variant 2. You have a leak here and not a chance to call destructor of the object returned from your function.</p>
",5
19975590,19974629,1,"<p>In the first variant you attach a reference directly to a dynamically allocated object. This is a rather unorthodox way to own dynamic memory (a pointer would be better suited for that purpose), but still it gives you the opportunity to properly deallocate that object. I.e. at the end of your first <code>main</code> you can do</p>

<pre><code>delete &amp;s;
</code></pre>

<p>In the second variant you lose the reference, i.e. you lose the only link to that dynamically allocated object. The object becomes a memory leak.</p>

<p>Again, owning a dynamically allocated object through a reference does not strike me as a good practice. It is usually better to use a pointer or a smart pointer for that purpose. For that reason, both of your variants are flawed, even though the first one is formally redeemable.</p>
",0
20199212,20199184,12,"<pre><code>Blah a();
</code></pre>

<p>This doesn't create an object, it declares a function. Change it to</p>

<pre><code>Blah a;
</code></pre>

<p>This is sometimes known as a ""vexing parse"".</p>
",0
19567637,19567559,3,"<p>They will each cause different std::string constructors.</p>

<p>The std::string() -- will create an empty object.</p>

<p>The """" will construct using std::string(char*)</p>

<p>The later will internally do a strlen+strcpy which is not needed in the first, so very small difference.</p>
",1
19567652,19567559,1,"<p>In the example you posted, <code>return """";</code> will be automatically translated to <code>return string("""");</code> <em>at compile time</em>. Unless <code>string("""")</code> is significantly slower than <code>string()</code>, then there shouldn't be much of a difference.</p>

<hr>

<p>In your comment you mention that you're actually using <code>QString</code>, not <code>std::string</code>. Note that <code>QString()</code> constructs a <em>null string</em> (<code>isNull()</code> and <code>isEmpty()</code> both return true), whereas <code>QString("""")</code> constructs an <em>empty string</em> (<code>isEmpty()</code> returns true but <code>isNull()</code> returns false). <strong>They're not the same thing!</strong> You can think of <code>QString()</code> like <code>char * str = NULL;</code>, and <code>QString("""")</code> like <code>char * str = """";</code>.</p>
",1
19567816,19567559,1,"<p>Use <code>return string();</code> as that will use the default constructor. A good Standard Library implementation will probably not even initialise the string buffer at that point.</p>

<p>The constructor from <code>const char*</code> must take a string copy. So I think <code>return """";</code> will be slower.</p>

<p>But, to be really sure, <em>race your horses</em>.</p>
",8
19317614,19308957,1,"<p>Using Keith's sample code. The difference under GCC are as follows:</p>

<p>GCC 4.7.3: g++ -Wall -Wextra -std=c++0x -O3 -c array-fill.cpp</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;cstring&gt;

int  fref() {
    int a[1024];
    return a[512] - a[256]; }

int f1() {
    int a[1024] = {};
    return a[512] - a[256]; }

int  f2() {
    int a[1024];
    std::memset(a, 0, sizeof(a));
    return a[512] - a[256]; }

int f3() {
    int a[1024];
    std::fill(a, a + 100, 0);
    return a[512] - a[256]; }
</code></pre>

<p>Disassemble</p>

<p>objdump -d array-fill.o | c++filt</p>

<pre><code>00000000 &lt;fref()&gt;:
   0:   b8 00 10 00 00          mov    $0x1000,%eax
   5:   e8 00 00 00 00          call   a &lt;fref()+0xa&gt;
   a:   29 c4                   sub    %eax,%esp
   c:   8b 84 24 00 08 00 00    mov    0x800(%esp),%eax
  13:   2b 84 24 00 04 00 00    sub    0x400(%esp),%eax
  1a:   81 c4 00 10 00 00       add    $0x1000,%esp
  20:   c3                      ret
  21:   eb 0d                   jmp    30 &lt;f1()&gt;

00000030 &lt;f1()&gt;:
  30:   31 c0                   xor    %eax,%eax
  32:   c3                      ret
  33:   8d b6 00 00 00 00       lea    0x0(%esi),%esi
  39:   8d bc 27 00 00 00 00    lea    0x0(%edi,%eiz,1),%edi

00000040 &lt;f2()&gt;:
  40:   b8 00 10 00 00          mov    $0x1000,%eax
  45:   e8 00 00 00 00          call   4a &lt;f2()+0xa&gt;
  4a:   29 c4                   sub    %eax,%esp
  4c:   31 c0                   xor    %eax,%eax
  4e:   81 c4 00 10 00 00       add    $0x1000,%esp
  54:   c3                      ret
  55:   8d 74 26 00             lea    0x0(%esi,%eiz,1),%esi
  59:   8d bc 27 00 00 00 00    lea    0x0(%edi,%eiz,1),%edi

00000060 &lt;f3()&gt;:
  60:   b8 00 10 00 00          mov    $0x1000,%eax
  65:   e8 00 00 00 00          call   6a &lt;f3()+0xa&gt;
  6a:   29 c4                   sub    %eax,%esp
  6c:   89 e0                   mov    %esp,%eax
  6e:   8d 94 24 90 01 00 00    lea    0x190(%esp),%edx
  75:   c7 00 00 00 00 00       movl   $0x0,(%eax)
  7b:   83 c0 04                add    $0x4,%eax
  7e:   39 d0                   cmp    %edx,%eax
  80:   75 f3                   jne    75 &lt;f3()+0x15&gt;
  82:   8b 84 24 00 08 00 00    mov    0x800(%esp),%eax
  89:   2b 84 24 00 04 00 00    sub    0x400(%esp),%eax
  90:   81 c4 00 10 00 00       add    $0x1000,%esp
  96:   c3                      ret
</code></pre>

<p>The C style initialization (<code>f1</code>) certainly allowed optimization in this case!</p>
",0
18944812,18944772,2,"<p>The function argument is already taken by value, so a copy will already have been made. The local object <code>p</code> is unquestioningly yours and yours alone, so you can move from it unconditionally.</p>

<p>The beauty of taking the argument by value is that it works for both lvalues and rvalues: For lvalues you make a genuine copy, since there's nothing else you can do, but for rvalues the function argument itself can be constructed by moving, so there's only one expensive construction happening ever, and everything else is moved.</p>
",0
18944822,18944772,2,"<p>When you construct an object from an lvalue, it will be copied. When you construct an object from a non-<code>const</code> rvalue it can be moved (whether it will be moved depends on the class having a move constructor). In the context of your constructor, <code>p</code> is clearly a lvalue: it has a name. However, it is a local variable and about to go away, i.e., it is save to move from it: <code>std::move(p)</code> makes the object appear as if it is an rvalue: in this context, <code>std::move()</code>ing the value is the right way to go.</p>

<p>Note that the recommendations are different if you return an object: a local value returned in a <code>return</code> statement is automatically moved from. Using <code>std::move()</code> would just reinforce the statement but would also inhibit the possibility of eliding the copy/move entirely. In your constructor the copy/move cannot be elided because copy elision only works with temporary objects or with local objects in <code>return</code> statements.</p>

<pre><code>T f() {
    T local;
    return local; // good: elided, moved, or copied in this order of preference
}
T g() {
    T local;
    return std::move(local); // bad: can't be elided and will be moved or copied
}
</code></pre>
",0
20758753,20758643,6,"<p>You are passing a raw string to your function, which is not a <code>std::string</code>, is a character array, a <code>const char []</code>.<br>
Even if <code>std::string</code> has a constructor which gets a char array, implicit type conversions are not applied during template argumment deduction (Exactly the problem you have). See <a href=""https://stackoverflow.com/questions/8890051/implicit-conversion-when-overloading-operators-for-template-classes"">this thread</a> for more information about the topic.</p>

<p>There are two possible solutions:</p>

<ol>
<li><p>Pass a <code>std::string</code> instead of a raw string to your function:  </p>

<pre><code>f( std::string( ""hello"" ) );
</code></pre></li>
<li><p>Write an overload of your function which works with raw strings:</p>

<pre><code>template&lt;typename CHAR_T , std::size_t LENGHT&gt;
void f( const CHAR_T (&amp;string)[LENGTH] )
{
    f( std::string( string ) ); //Just wrap the call to not duplicate code.
}
</code></pre></li>
</ol>
",0
20758837,20758643,0,"<p>This should do the trick. </p>

<p>You're specifying a char array to your function witch is supposed to get std::string. You need to use a constructor to convert these.</p>

<pre><code>#include &lt;string&gt;


template&lt;class CharT, class Traits = std::char_traits&lt;CharT &gt;, class Allocator = std::allocator&lt;CharT &gt;&gt;
void f(const std::basic_string&lt;CharT, Traits, Allocator&gt;&amp; s) {
}

int main() {
     std::string str(""Hello World!"");
     f(str);
}
</code></pre>
",0
20759879,20758643,1,"<p>What you ask would require the compiler iterate over every <code>basic_string&lt;T&gt;</code> until it determined that there was exactly one <code>T</code> that matched.  Alternatively, it could invert the possibly Turing complete process to figure out what the <code>template</code> argument is.  <code>template</code> argument deduction like that is pattern matching: it takes the arguments, and matches it against your pattern, and deduces the types simply.  If you want more, you need to tell it how to invert the mapping from <code>CharT</code> to <code>basic_string&lt;CharT,A&gt;</code> constructors.  C++1y makes it a touch easier with concepts lite, but the kind of machinery you want still will not be there.</p>

<p>By far the easiest solution is to have two overloads for <code>char</code> and <code>wchar_t</code> <code>basic_string</code>s (actual functions, not <code>template</code>s), and then have them call a <code>template</code> generic function like what you wrote passing in the <code>CharT</code> explicitly.</p>

<p>Fancier would involve code that actually did the above inversion, where you might have it work from an acceptable set of strings, and check which the arguments can be constructed from, assert that there is only one option, and deduce <code>CharT</code> that way.  While fun, I doubt this is worth it.</p>
",0
19577461,19577419,3,"<p><code>foo.back()</code> will return a reference (i.e. <code>Foo &amp;</code>), but you're trying to assign it to a pointer.</p>

<p>To get it to work, you can assign to a reference instead:</p>

<pre><code>Foo &amp;ret = foo.back();
</code></pre>

<p>Or get the address of the item returned, and assign that to a pointer:</p>

<pre><code>Foo *ret = &amp;foo.back();
</code></pre>
",1
19443631,19443578,2,"<p>From <a href=""http://www.cplusplus.com/reference/cstring/memcpy/"" rel=""nofollow"">memcpy description</a>: </p>

<blockquote>
  <p>To avoid overflows, the size of the arrays pointed by both the
  destination and source parameters, shall be at least num bytes, and
  should not overlap (for overlapping memory blocks, memmove is a safer
  approach).</p>
</blockquote>

<p>Use <a href=""http://www.cplusplus.com/reference/cstring/memmove/"" rel=""nofollow"">memmove</a>, in other words.</p>
",0
19443647,19443578,0,"<pre><code> SYNOPSIS
        #include &lt;string.h&gt;

        void *memcpy(void *dest, const void *src, size_t n);

 DESCRIPTION
        The  memcpy()  function  copies  n bytes from memory area src to memory
        area dest.  The memory areas must not overlap.  Use memmove(3)  if  the
        memory areas do overlap.
</code></pre>

<p>Your memory areas must not overlap, otherwise <code>memcpy</code>'s behavior is not defined.  You should use <code>memmove</code> instead.</p>
",0
19443654,19443578,0,"<p>You may not use <code>memcpy</code> for overlapping ranges, as is stated in the library documentation:</p>

<blockquote>
  <p>7.21.2 Copying functions</p>
  
  <p>7.21.2.1 The memcpy function</p>
  
  <p>...</p>
  
  <p>2 The memcpy function copies n characters from the object pointed to by s2 into the object pointed to by s1. If copying takes place between objects that overlap, <strong>the behavior is undefined</strong>.</p>
  
  <p>7.21.2.2 The memmove function</p>
  
  <p>...</p>
  
  <p>2 The memmove function copies n characters from the object pointed to by s2 into the
  object pointed to by s1. Copying takes place as if the n characters from the object
  pointed to by s2 are first copied into a temporary array of n characters that does not
  overlap the objects pointed to by s1 and s2, and then the n characters from the
  temporary array are copied into the object pointed to by s1.</p>
</blockquote>

<p>For POD or trivially initialized types, you can either use <code>memmove</code> (as suggested above) or <code>std::copy_backward</code> (so long as the last destination element is not within the source range)</p>

<p><a href=""https://stackoverflow.com/questions/4415910/memcpy-vs-memmove"">This question</a> has more discussion of the memcpy-vs-memmove part.</p>

<p>For non-trivial types such as <code>std::string</code>, you can't use either <code>memcpy</code> <em>or</em> <code>memmove</code>, but <em>must</em> use <code>std::copy</code> or <code>std::copy_backward</code>. </p>
",0
19444141,19443578,6,"<p>Neither <code>memcpy</code> nor <code>memmove</code> are possible when your array contains <code>std::string</code> objects. The reason is that both tamper with the objects' internals when they shouldn't (the integrity of a C++ object is ensured by its constructor / assignment operator / destructor / member functions, you <strong>must not</strong> modify its bytes manually unless you know exactly what you do).</p>

<p>As already suggested, use a method that takes constructors, assignment operators and destructors into account (<code>std::copy_backward</code> for example) or better yet, get rid of those legacy C arrays and use proper C++ containers like <code>vector</code> and use the container's functions to insert/remove items.</p>

<p>In other words, as soon as you start using C++ objects then you have to begin writing C++, not ""C with classes"" any more.</p>
",0
19443884,19443578,1,"<p>Like most people here say you can use <a href=""http://en.cppreference.com/w/cpp/string/byte/memmove"" rel=""nofollow""><code>memmove</code></a> instead of <a href=""http://en.cppreference.com/w/cpp/string/byte/memcpy"" rel=""nofollow""><code>memcpy</code></a> because it can handle overlapping ranges.</p>

<p>However, the C++ solution would be to use <a href=""http://en.cppreference.com/w/cpp/algorithm/copy_backward"" rel=""nofollow""><code>copy_backward</code></a>, which does explicitly what you asked for and will behind the screens choose the fastest copy method for you. That would look something like this:</p>

<pre><code>std::copy_backward(std::begin(_array)+newItem, std::end(_array)-1, std::end(array));
</code></pre>

<p>This means you will copy backwards from the previous-to-last element to position newItem and will insert that starting from the back. This can obviously handle the overlap this requires. It might be that behind the screens memmove or other platform-specific memory copies are used.</p>
",0
20522260,20522234,5,"<p>You should compute <code>area</code> inside of <code>setRadius()</code>, as the relationship between <code>area</code> and <code>radius</code> is fixed, and is a class-invariant.</p>

<p>Then <code>getArea()</code> simply needs to <code>return area;</code> and can be <code>const</code>.</p>

<p>This separation of duties (setters maintain class invariants, getters just return internal state) is the purpose of getters and setters.</p>

<p><strong>Edit:</strong> Also note that in this example, you don't strictly need <code>area</code> to be a member of your class.  You could have defined your class as follows:</p>

<pre><code>class Circle
{
  private:
    double radius;

  public:
    void setRadius(double r);
    double getArea() const;
};

void Circle::setRadius(double r)
{
    radius = r;
}

double Circle::getArea() const
{
    double area = 3.142 * radius * radius;
    return area;
}
</code></pre>

<p>By making <code>area</code> a local variable to the method rather than a class member, the method can remain <code>const</code>.</p>

<p>As others have noted, there is also a <code>mutable</code> keyword that you could have applied to <code>area</code>.  This is useful if modifying the variable doesn't change the outward meaning of the class.  It can be useful for lazy initialization, or maintaining internal statistics.</p>

<p>Usually, though, it's easier to reason about a class's properties and invariants if they're maintained up-front.</p>
",10
20522265,20522234,2,"<p>You can make <code>area</code> a <code>mutable</code>, and mark <code>getArea() const</code>:</p>

<pre><code>mutable double area;

double Circle::getArea() const 
{
    area = 3.142 * radius * radius;
    return area;
}
</code></pre>

<p>This is a common idiom for lazy initialization of data members, typically used when said data members are expensive to construct.</p>

<p>In this case it isn't clear that there is a benefit from caching <code>area</code> at all. You could sidestep the issue by removing the <code>area</code> data member, and returning the result</p>

<pre><code>double Circle::getArea() const 
{
    return 3.142 * radius * radius;
}
</code></pre>
",3
20522301,20522234,1,"<blockquote>
  <p>Some people might say that it is stupid programming on my part, but sometimes I find myself in such situations.</p>
</blockquote>

<p>Yes, it is, and you shouldn't.</p>

<p>If you find you must cache such calculations, do it when the component factors are computed and <em>not</em> in a getter. (Frankly, in this case, I wouldn't store <code>area</code> at all.)</p>

<p>The <code>const</code> rule is trying to tell you this.</p>
",2
20522869,20522234,0,"<p>As others have pointed out, you should not store <code>area</code>. What determines what circle you are talking about is only the <code>radius</code>.</p>

<p>Here is what you lose if you declare <code>area</code>as a member:</p>

<ul>
<li>the <code>const</code> qualifier on your getter function, as you noted.</li>
<li>CPU &lt;-> memory IO, as you are systematically trying to update the area in your object data whenever you're trying to read your area. Memory accesses take EONS. It is really way faster to recompute the area at every access than to fetch it from memory.</li>
<li>Compactness of your memory layout. You're uselessly doubling your storage need, losing the opportunity to load twice as much of your objects into a single cache line, if you're putting your structures in a <code>vector</code>.</li>
</ul>

<p>I know your <code>Circle</code> class is really illustrative, but try transposing this way of thinking onto your project.</p>
",0
20508250,20507908,0,"<p>Update:</p>

<p>Found the error:</p>

<pre><code>int z=0;
int z1,z2;
</code></pre>

<p>z1,z2 should be doubles instead of integers. This was messing up the rest of the number</p>
",0
20415106,20414715,1,"<p>The constant you want to define is <code>_WIN32_WINNT</code> not <code>_WIN32_WINNT_MAXVER</code>.  The possible values are listed here: <a href=""http://msdn.microsoft.com/en-us/library/aa383745%28VS.85%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/aa383745%28VS.85%29.aspx</a></p>

<p>You should define it before including <code>windows.h</code>.</p>
",3
20203395,20203363,4,"<p>No, it doesn't. It only means that they are equally wide.</p>
",7
20182044,20182006,4,"<p>All of the C++ standard functions (and classes) that use a less-than comparator do not care whether or not objects are equal. Instead, they use a concept of ""equivalence"" defined that <code>x</code> and <code>y</code> are equivalent if and only if <code>!(x &lt; y) &amp;&amp; !(y &lt; x)</code>. If <code>x &lt; y</code> is a strict weak order, then <code>!(x &lt; y) &amp;&amp; !(y &lt; x)</code> is an equivalence relation.</p>

<p>So no, there is no precise equivalent of the Ruby spaceship because those C++ operations do not accept the trichotomy of less than, equal, or greater than. However, you can quite easily write:</p>

<pre><code>template &lt;typename T&gt;
int spaceship(const T &amp;lhs, const T &amp;rhs) {
    if (lhs &lt; rhs) return -1;
    if (rhs &lt; lhs) return 1;
    return 0;
}
</code></pre>
",6
19870994,19870926,6,"<p>When you write a header file, always remember to write an include guard.</p>

<pre><code>#ifndef NODE_H
#define NODE_H

class Node{      

public:
    explicit Node(int val); // add explicit to disable implicit conversion
    int val;
    Node* l_node;
    Node* r_node; 
};
#endif
</code></pre>

<p>Also, do <strong>NOT</strong> use <code>using</code> directives in header file; it's bad practice.</p>

<p>And in constructors, beware of member initialization order. Initialize members in declaration order, otherwise you might get caught by an initialize order issue:</p>

<pre><code>Node::Node(int x) : val(x), l_node(nullptr), r_node(nullptr){

}
</code></pre>
",1
19871147,19870926,0,"<p>Aside from include guards, you should almost always create a corresponding .cpp file for every header, and put the implementation there. If you have multiple libs using the same header, and they get linked in together by a third program, it will produce linker errors. Include guards won't protect you against this scenario.</p>
",0
20182804,20182733,2,"<p>You are passing the <code>this</code> pointer to the thread. A pointer, well, can point to an arbitrary location, in that case it will point to the stack. This works theoretically but is very unsafe.</p>

<p>Consider the following code:</p>

<pre><code>if (...) 
{
    foo f;
}
</code></pre>

<p>What will happen?</p>

<ol>
<li>The scope of the if-block is entered</li>
<li>The <code>foo</code> instance is initialized on the stack</li>
<li>The thread starts with a <code>foo*</code> pointing to the stack</li>
<li>The scope of the if-block is left</li>
<li>Thus <code>f</code> becomes destructed/deleted and the space where it was contained (the stack) possible deallocated.</li>
</ol>

<p>Now while the thread might run flawlessly for some micro seconds, after that little little little time you will get big big big trouble because the <code>this</code> pointer the thread works with is now invalid. Very bad!</p>
",0
18797173,18797103,3,"<p>This is exactly what <code>dynamic_cast</code> is for:</p>

<pre><code>void SomeMethod(QObject *ptr) {
    A *a = dynamic_cast&lt;A *&gt;(ptr);
    if (a) { DoStuffA(a); return; }
    B *b = dynamic_cast&lt;B *&gt;(ptr);
    if (b) { DoStuffB(b); return; }
    C *c = dynamic_cast&lt;C *&gt;(ptr);
    if (c) { DoStuffC(c); return; }
    DoStuffNOTA(ptr);
}
</code></pre>

<p>Since you're using Qt, you'd probably want to use <a href=""http://qt-project.org/doc/qt-4.8/qobject.html#qobject_cast"" rel=""nofollow""><code>qobject_cast</code></a> instead of <code>dynamic_cast</code>,* but otherwise everything is the same.</p>

<p>However, all that repetition is, as usually, a sign that you're doing something wrong. You can eliminate a lot of it by using templates, but usually, you usually don't want to do this at all. Instead, use the <a href=""http://en.wikipedia.org/wiki/Double_dispatch"" rel=""nofollow"">""double dispatch""</a> (aka ""reverse dispatch"") pattern.</p>

<p>The whole reason we have virtual functions, and OO in general, is to avoid type switching. The problem is that virtual functions (the way C++ does them) only dispatch on the <code>this</code> object: <code>Foo::SomeMethod(QObject *)</code> can be overridden for subclasses of <code>Foo</code>, but not for subclasses of <code>QObject</code>. But you can just add a method to <code>QObject</code>or, in this case, to an intemediate class (or a multiple-inheritance mixin, if that isn't possible)that all of your real classes can override:</p>

<pre><code>class ClassIntermediate: public QObject {
public:
    virtual void DoSomeMethodStuff() = 0;
};

class ClassA : public ClassIntermediate {
public:
    virtual void DoSomeMethodStuff() { /* DoStuffA code here */ }
    // all the stuff you were already doing in ClassA as a QObject
};

// likewise for ClassB and ClassC

class Foo {
    void SomeMethod(ClassIntermediate *ptr) { ptr-&gt;DoSomeMethodStuff(); }
};
</code></pre>

<p>If there's some work that has to be done for all types, leave it in <code>SomeMethod</code>, before or after the call to <code>DoSomeMethodStuff</code>. (If that work is intermixed with the subclass-specific stuff, and you can't rearrange it, just factor out multiple methods to double-dispatch to instead of just one.)</p>

<p>If the code needs the <code>Foo</code> object's <code>this</code> pointer, just pass it as an argument to <code>DoSomeMethodStuff</code>.</p>

<p>If you need to handle any <code>QObject</code>, not just your subclasses, then you may want to use a single <code>dynamic_cast&lt;ClassIntermediate *&gt;</code> and double-dispatch to that.</p>

<p>So, why is this better than type switching? Today, you have three classes, and one method that switches on them. If you add another method tomorrow, you have to write the same 3-way type switch again. If you then add a fourth class, you have to remember to go back and edit them both. If you end up with N classes and M methods that have to switch on them, you've written N*M blocks of code instead of N+M. All that extra code isn't just annoying; it virtually guarantees that you're going to miss one of the edits one day, leading to a painful debugging problem.</p>

<hr>

<p>The main advantage of <code>qobject_cast</code> is that Qt provides its own, more extensive, RTTI system than what's built in to C++, and it's possible to build Qt without C++ RTTI at all (or, on Windows, in such a way that classes in different DLLs can be connected up via Qt RTTI but not C++ RTTI), and <code>qobject_cast</code> will still work.</p>
",0
18428775,18428487,1,"<p>Associative containers (<code>set</code>, <code>multi_set</code>, <code>map</code>, <code>multi_map</code>, and their <code>unordered_</code> brethren) do <strong>not</strong> invalidate pointers or references when you add elements to the container;  they can invalidate iterators. In addition, when you remove elements, only iterators, pointers, and references to those elements are invalidated. One consequence of this is that if you take the address of an element, that address remains valid as long as that element remains in the container.</p>

<p>There is no portable way to directly convert from the address of an element to an iterator that points to that element. If you need to do this you have to search for the element.</p>
",1
18428874,18428487,2,"<p>The first question is simple: in general, there is no direct way to get an iterator from a pointer to an element or from a value. That is, to get an iterator from a value you generally need to search the container. Since <code>std::vector&lt;T&gt;</code> is required to be contiguous you can get an iterator from a pointer using a simple computation (which requires that <code>v</code> is non-empty):</p>

<pre><code>std::vector&lt;T&gt; v(...);
T* ptr = ...;
std::vector&lt;T&gt;::iterator it(v.begin() + (ptr - &amp;v[0]));
</code></pre>

<p>To track down whether iterators and values stay stable, isn't entirely trivial as the relevant guarantees are distributed over multiple clauses, e.g.:</p>

<ol>
<li><p>23.2.1 [container.requirements.general] paragraph 11:</p>

<blockquote>
  <p>Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, or change the values of, objects within that container.</p>
</blockquote></li>
<li><p>23.2.4 [associative.reqmts] paragraph 9:</p>

<blockquote>
  <p>The insert and emplace members shall not affect the validity of iterators and references to the container, and the erase members shall invalidate only iterators and references to the erased elements.</p>
</blockquote></li>
<li><p>23.2.5 [unord.req] paragraph 9:</p>

<blockquote>
  <p>... Rehashing invalidates iterators, changes ordering between elements, and changes which buckets elements appear in, but does not invalidate pointers or references to elements. ...</p>
</blockquote></li>
<li><p>23.2.5 [unord.req] paragraph 14:</p>

<blockquote>
  <p>The insert and emplace members shall not affect the validity of references to container elements, but may invalidate all iterators to the container. ...</p>
</blockquote></li>
<li><p>23.2.5 [unord.req] paragraph 15:</p>

<blockquote>
  <p>The insert and emplace members shall not affect the validity of iterators if (N+n) &lt; z * B, where N is the number of elements in the container prior to the insert operation, n is the number of elements inserted, B is the containers bucket count, and z is the containers maximum load factor.</p>
</blockquote></li>
</ol>

<p>The above clauses should to be the important clauses with respect to iterator validity of the associative containers. The iterator validity in the unordered associative containers entirely depends on whether the container is rehashed. It seems the rehashing can be controlled to avoid it happening by surprise.</p>

<p>However, the entire idea of the unordered containers is that it is very efficient to locate an object using <code>find()</code>. It should never be necessary to store an iterator to an element because you can find them back. Of course, if you have a <code>std::unordered_multimap&lt;K, V&gt;</code> or a <code>std::unordered_multiset&lt;V&gt;</code> you may need to know which of the equivalent elements you are looking at.</p>
",0
19433416,19432793,2,"<p>So this is getting a little more complex.  It's also a bit of an <a href=""https://meta.stackexchange.com/questions/66377/what-is-the-xy-problem"">XY Problem</a>, but at least here you're explicit about both X and Y.  </p>

<p>Let's start with your proposed approach.  This is never going to work:</p>

<pre><code>std::get&lt;i&gt;(_t);
</code></pre>

<p><code>get</code> is a function <em>template</em>, and so <code>i</code> must be an Integral Constant Expression.  In other words, <code>i</code> must be known at compile-time.</p>

<p>Since your proposed solution is fundamentally based on a <code>tuple</code>, the whole thing unravels and falls apart when you can't make <code>i</code> and ICE.  So, let's forget the proposed approach, and look at the problem again.  You have a file with a bunch of stuff in it, presumably separated in to something that looks like fields.  Those fields represent (as far as I can tell) different types of data.  Suppose this is an example of such a file:</p>

<pre><code>IBM
123.45
1000
</code></pre>

<p>Here we have a string, a float and an integer.  Different files might have different data entirely, and the data at a given position in one file might not be the same type as the data at the same position in a different file.  You then have a bunch of different classes that need to be initialized with these different files, each with it's own collection of different data members of different types, pulled from different positions in the files.  Yuck.</p>

<p>Given the complexity of the problem, my natural tendency is to keep the solution as simple as possible.  There's enough complexity here already.   The simplest possible approach I can think of is to simply have a different concrete <code>LineParser</code> class for each type of file you want to parse.  This will however result in code bloat if you have a lot of different types of files, and becomes exponentially more difficult to maintain as that number grows.  So let's continue on the assumption you don't want to do that.</p>

<p>One thing that will not increase however is the number of different types of fields in the file.  Ultimately, there's really ony a few:  strings, integral, floats, and maybe some other special stuff specific to your domain.  Even as you add more data files however, the number of types of fields will remain relatively constant.  Another constant is the file itself:  it's character data.  So let's leverage that.</p>

<p>Implement some free functions that convert from the file storage type (character data, I'm assuming here) to the different fields.  If you're using Boost, you can use <code>lexical_cast</code> to do most of this.  Otherwise you can use <code>stringstream</code> or something else.  Here's one possible implementation, there are many others:</p>

<pre><code>template &lt;typename Return&gt; Return As (const std::string&amp; val)
{
  std::stringstream ss;
  ss &lt;&lt; val;
  Return retval;
  ss &gt;&gt; retval;
  return retval;
}
</code></pre>

<p>Now I'm assuming that for a given <code>Base</code>-type class, you know the positions and types of the fields of interest to you, and those are invariant.  For example, for a <code>Base</code> that represents a stock quote, you know the first field is the ticker symbol and it's a string.</p>

<p>Your <code>FileParser</code> class can be generic if all it does is pull everything out of the file and cache it as character data in an array, one element per field in the file.  Again, there are many possible implementation here -- my focus is the design, not the actual code.</p>

<pre><code>class LineParser
{
    private:
        std::vector &lt;string&gt; mItems;
    public:
        LineParser(const std::string &amp; fileName)
        {   
          std::ifstream fs(fileName);
          std::copy(
            std::istream_iterator&lt;int&gt;(fs), 
            std::istream_iterator&lt;int&gt;(), 
            std::back_inserter(mItems));
        }   

        std::string GetAt (size_t i) const
        { 
          return mItems [i];
        }
};
</code></pre>

<p>Now in the <code>Base</code> constructor, for each <code>const</code> data member, pull a specific item from the <code>LineParser</code> and convert it with your free function:</p>

<pre><code>class Base
{ 
private:
  const std::string mTicker;
  const uint32_t mSize;
  const float mPrice;
public:
  Base (const LineParser&amp; parser)
  : 
    mTicker (As &lt;std::string&gt; (parser.GetAt (0))),  // We know the ticker is at field 0
    mPrice (As &lt;float&gt; (parser.GetAt (1))),  // Price is at field 1...
    mSize (As &lt;uint32_t&gt; (parser.GetAt (2))
  {
  }
};
</code></pre>

<p>There's a number of things I like about this approach.    For one, even though there are a number of classes and functions involved, each one is simple.  Each little gizmo here has a single, clearly defined responsibility, and doesn't try to do too much.</p>

<p>For another, the self-documentation of your business logic code is concise and where it belongs:  in the code where the <code>const</code> members are initialized:</p>

<pre><code> Base (const LineParser&amp; parser)
 : 
   mTicker (As &lt;std::string&gt; (parser.GetAt (0))),  // We know the ticker is at field 0
   mPrice (As &lt;float&gt; (parser.GetAt (1))),  // Price is at field 1...
   mSize (As &lt;uint32_t&gt; (parser.GetAt (2))
 {
 }
</code></pre>

<p>The initializer for <code>mTicker</code> for example says ""The ticker symbol is a string, and it is pulled from position 1 in the file.""  Clean.</p>
",1
19869141,19869042,2,"<pre><code>theirAccType = accType();
...
split = pricePerCheck(accType(), checksWritten());
//                    ^^^^^^^^^
</code></pre>

<p>You're calling <code>accType</code> for the second time. You should be passing in the variable that you used to hold the initial call on the first line.</p>

<pre><code>split = pricePerCheck(theirAccType, checksWritten());
//                    ^^^^^^^^^^^^
</code></pre>
",1
19869206,19869042,0,"<p>When you call <code>pricePerCheck()</code> you pass the result of calling <code>accType()</code> rather than <code>theirAccType</code>: you stored the result of the first call but you are making a second call. C++ doesn't memoize the result of function calls.</p>

<p>BTW, you want to compile your code with a higher warning level! There are number of fatal issues in your code:</p>

<ol>
<li><code>personalCalc()</code> is declared to return an <code>int</code> but doesn't return anything (the function isn't call, though, i.e. your question, obviously, isn't a <a href=""http://sscce.org"" rel=""nofollow"">SSCCE</a>.</li>
<li>The function <code>commericalCalc()</code> uses the the value of an uninitialized variable (<code>written</code>). It seems to be also badly named.</li>
</ol>
",2
19869161,19869042,0,"<p>The request for account type is made in the <code>accType()</code> function. You're calling that function twice in this code:</p>

<pre><code> displayInstructions();
  theirAccType = accType();
  accountNumb = readAccNumb();
  split = pricePerCheck(accType(), checksWritten());
</code></pre>

<p><code>accType()</code> is called to assign the value to <code>theirAccType</code>, and again as an argument to <code>pricePerCheck()</code>.</p>

<p>You probably need</p>

<pre><code>  split = pricePerCheck(theirAccType, checksWritten());
</code></pre>
",0
18705869,18701504,0,"<p>Of course, you can use the C preprocessor for this as David suggests, but when you have more complex tasks at hand, you should think about other tools to generate the code you need.</p>

<p>Examples of such preprocessors I have seen in use include <code>m4</code> and <code>python</code>.</p>

<p><code>python</code> seems to be more suited to the syntax you are envisioning, however, you cannot execute it as a preprocessor, you have to run a python program <em>on</em> your file to generate the desired output.</p>

<p><code>m4</code>, on the other hand is a real preprocessor, meaning that you basically feed your source file directly into <code>m4</code>, just like your compiler feeds C files through the C preprocessor. Its syntax is very functional in style, which may be good or bad depending on what you want to achieve.</p>
",0
19262570,19262471,1,"<p>use a for loop (start at 0), and on each iteration print a substring from i to string.length()-1 an use the set width to increase the indent, following code below:</p>

<pre><code>string num = ""10987654321"";

for (int i = 0; i &lt; num.length(); ++i){
   cout &lt;&lt; setw(i) &lt;&lt; right &lt;&lt; num.substr(i, num.length()-i) &lt;&lt; endl;
}
</code></pre>

<p>This should give you your desired output. (if ""&lt;&lt; right &lt;&lt;"" doesn't work, swap ""right"" with ""left"")</p>

<p><strong>ALSO</strong>
you need to include iomanip to use setw()</p>
",1
19263053,19262471,0,"<pre><code>int num = 10987654321;
int numSpaces = 1;

cout &lt;&lt; num &lt;&lt; endl;

for (int i = 0; i &gt;= 1; i--)
{
    for (int j = 0; j &lt; numSpaces; j++)
    {
         cout &lt;&lt; "" "";
    } 

    cout &lt;&lt; num % 10 &lt;&lt; endl;

    num = num / 10;

    numSpaces++;
}
</code></pre>

<p>Voila a beautiful triangle :)</p>
",0
20645808,20645396,37,"<p>You could write your own version of <code>std::getline</code> with a maximum number of characters read parameter, something called <code>getline_n</code> or something.</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;

template&lt;typename CharT, typename Traits, typename Alloc&gt;
auto getline_n(std::basic_istream&lt;CharT, Traits&gt;&amp; in, std::basic_string&lt;CharT, Traits, Alloc&gt;&amp; str, std::streamsize n) -&gt; decltype(in) {
    std::ios_base::iostate state = std::ios_base::goodbit;
    bool extracted = false;
    const typename std::basic_istream&lt;CharT, Traits&gt;::sentry s(in, true);
    if(s) {
        try {
            str.erase();
            typename Traits::int_type ch = in.rdbuf()-&gt;sgetc();
            for(; ; ch = in.rdbuf()-&gt;snextc()) {
                if(Traits::eq_int_type(ch, Traits::eof())) {
                    // eof spotted, quit
                    state |= std::ios_base::eofbit;
                    break;
                }
                else if(str.size() == n) {
                    // maximum number of characters met, quit
                    extracted = true;
                    in.rdbuf()-&gt;sbumpc();
                    break;
                }
                else if(str.max_size() &lt;= str.size()) {
                    // string too big
                    state |= std::ios_base::failbit;
                    break;
                }
                else {
                    // character valid
                    str += Traits::to_char_type(ch);
                    extracted = true;
                }
            }
        }
        catch(...) {
            in.setstate(std::ios_base::badbit);
        }
    }

    if(!extracted) {
        state |= std::ios_base::failbit;
    }

    in.setstate(state);
    return in;
}

int main() {
    std::string s;
    getline_n(std::cin, s, 10); // maximum of 10 characters
    std::cout &lt;&lt; s &lt;&lt; '\n';
}
</code></pre>

<p>Might be overkill though.</p>
",4
20646320,20645396,8,"<p>Replace <a href=""http://www.cplusplus.com/reference/string/string/getline"" rel=""nofollow"">std::getline</a> by creating a wrapper around <a href=""http://www.cplusplus.com/reference/istream/istream/getline"" rel=""nofollow"">std::istream::getline</a>:</p>

<pre><code>std::istream&amp; my::getline( std::istream&amp; is, std::streamsize n, std::string&amp; str, char delim )
    {
    try
       {
       str.resize(n);
       is.getline(&amp;str[0],n,delim);
       str.resize(is.gcount());
       return is;
       }
    catch(...) { str.resize(0); throw; }
    }
</code></pre>

<p>If you want to avoid excessive temporary memory allocations, you could use a loop which grows the allocation as needed (probably doubling in size on each pass).  Don't forget that exceptions might or might not be enabled on the istream object.</p>

<p>Here's a version with the more efficient allocation strategy:</p>

<pre><code>std::istream&amp; my::getline( std::istream&amp; is, std::streamsize n, std::string&amp; str, char delim )
    {
    std::streamsize base=0;
    do {
       try
          {
          is.clear();
          std::streamsize chunk=std::min(n-base,std::max(static_cast&lt;std::streamsize&gt;(2),base));
          if ( chunk == 0 ) break;
          str.resize(base+chunk);
          is.getline(&amp;str[base],chunk,delim);
          }
       catch( std::ios_base::failure ) { if ( !is.gcount () ) str.resize(0), throw; }
       base += is.gcount();
       } while ( is.fail() &amp;&amp; is.gcount() );
    str.resize(base);
    return is;
    }
</code></pre>
",3
20646364,20645396,18,"<p>There is already such a <code>getline</code> function as a member function of <code>istream</code>, you just need to wrap it for buffer management.</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;istream&gt;
#include &lt;stddef.h&gt;         // ptrdiff_t
#include &lt;string&gt;           // std::string, std::char_traits

typedef ptrdiff_t Size;

namespace my {
    using std::istream;
    using std::string;
    using std::char_traits;

    istream&amp; getline(
        istream&amp; stream, string&amp; s, Size const buf_size, char const delimiter = '\n'
        )
    {
        s.resize( buf_size );  assert( s.size() &gt; 1 );
        stream.getline( &amp;s[0], buf_size, delimiter );
        if( !stream.fail() )
        {
            Size const n = char_traits&lt;char&gt;::length( &amp;s[0] );
            s.resize( n );      // Downsizing.
        }
        return stream;
    }
}  // namespace my
</code></pre>
",10
19214054,19214038,6,"<p>The first variant <em>default-initializes</em> the dynamically allocated <code>int</code>, which for built-in types such as <code>int</code> does not perform any initialization.</p>

<p>The second variant <em>value-initializes</em> it, which for <code>int</code> means <em>zero-initialization</em>, giving it value <code>0</code>. </p>
",0
19214059,19214038,14,"<pre><code>int *a = new int;
</code></pre>

<p><code>a</code> is pointing to <strong>default-initialized</strong> object (which is <strong>uninitialized</strong> object in <em>this</em> case i.e the value is <em>indeterminate</em> as per the Standard).</p>

<pre><code>int *a = new int();
</code></pre>

<p><code>a</code> is pointing to <strong>value-initialized</strong> object (which is <strong>zero-initialized</strong> object in <em>this</em> case i.e the value is <em>zero</em> as per the Standard).</p>
",2
19376525,19376394,1,"<p>Vector is just an array, so this is 0-indexed. Of course you can store a dummy data on position 0, but I recommend you to subtract 1 from the position you desire.<br />
Or if you can find some library (wrapper) that uses 1-indexed vector like:<br />
 <a href=""https://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/d3/dd5/classutility_1_1vector1.html"" rel=""nofollow"">https://www.rosettacommons.org/manuals/archive/rosetta3.4_user_guide/d3/dd5/classutility_1_1vector1.html</a><br />
Or you can simply create the desired class that can access the desired element by the index which starts by 1.</p>
",0
19376412,19376394,3,"<p>You can create a wrapper around vector and overwrite the <code>[]</code> operator. However I believe this is highly inadvisable   as any sane developer will be mislead by your code. </p>
",1
19376413,19376394,6,"<p>You can make a dummy first element. Please don't though, everyone using C++ expects vectors to be 0-based.</p>

<p>If that isn't what you had in mind, then no, there's no way. Simply because the element in the first position is accessed using the index <code>0</code>. So <code>position 1</code> is <em>your</em> representation of <code>vec[0]</code>. Just  a name.</p>

<p>Or switch to Pascal.</p>
",0
19376438,19376394,2,"<p>Yes. You can insert a dummy into position 0. And the real value one later on.
Surely You want to iterate AND access using ""humanly indexers"".
This will mostly fail for the last entry.
This language is zero index based.</p>
",2
19214268,19214240,1,"<p>The best way to deal with this is creating a class that contains your allocated memory and deletes it in the constructor.</p>

<p>This is what <code>std::vector</code> does, so when it goes out of scope, the compiler ensures that the memory is deleted (even if it goes out of scope because of a destructor).</p>

<p>For pointers to single values, that's what smart pointers are for. <code>std::auto_ptr</code> (now deprecated) and <code>std::unique_ptr</code> (new in C++ 2011) do that for you.</p>
",0
19214256,19214240,1,"<p>Use <code>std::unique_ptr</code> or similar to hold your heap-allocated memory. Then it would be deallocated automatically when that smart pointer goes out of scope, whether or not an exception was thrown.</p>
",0
18983787,18983745,79,"<p>You need to include the header which declares it: </p>

<pre><code>#include &lt;iomanip&gt;
</code></pre>
",0
20397935,20352941,7,"<p>After two days of searching, I finally solved it, well actually a colleague of mine :-) !</p>

<p>Read this article for the details:
<a href=""https://web.archive.org/web/20140209015215/http://support.microsoft.com/kb/819760"" rel=""noreferrer"">https://web.archive.org/web/20140209015215/http://support.microsoft.com/kb/819760</a></p>

<p>Essentially it comes down to running:</p>

<pre><code>reg add HKLM\Software\Policies\Microsoft\Windows NT /v DontPowerOffAfterShutdown /t REG_DWORD /d 1 /f
</code></pre>

<p>And then calling <code>ExitWindowsEx</code> with option <code>EWX_SHUTDOWN</code> from my application.</p>
",2
20629467,20629420,3,"<p><code>Driver::age</code> is a <code>private</code> member of <code>class Driver</code>. Hence, it is only accessible to the members of <code>class Driver</code></p>

<p>However, you may use accessor methods to let the outside world access the <code>private</code> members.</p>

<pre><code>class Driver
{
    private:
        int age;

    public:
        int get_age() { return age; }
};
</code></pre>

<p>And use the accessor method to get the <code>private</code> members of the class.</p>

<pre><code>if (driver.get_age() &lt;= 16)
    cout &lt;&lt; ""Sorry the driver is too young to drive"";
else
    realCar-&gt;MoveCar();
</code></pre>

<p>For more on access modifiers: <a href=""http://en.wikipedia.org/wiki/Access_modifiers"" rel=""nofollow"">http://en.wikipedia.org/wiki/Access_modifiers</a></p>
",0
20629471,20629420,0,"<p>You are accessing a private member of <code>Driver</code>. This is a separate class and you have no visibility to its private members. </p>
",0
20629477,20629420,4,"<p>Because <code>age</code> is a private member in the <code>Driver</code> class.</p>

<p>Do you intent to do this:</p>

<pre><code>     if (driver.get()&lt;= 16)
         cout &lt;&lt; ""Sorry the driver is too young to drive"";
     else
         realCar-&gt;MoveCar();
</code></pre>
",0
19959792,19957764,0,"<p>Have you tried binary save?</p>

<pre><code>fs.write(world[i], sizeof(POINT));
...
</code></pre>

<p>It'll be machine-dependent though (like @Jimbo suggested)</p>
",2
19497514,19497426,2,"<p>Have you looked at the <a href=""http://msdn.microsoft.com/en-us/library/dd374074%28VS.85%29.aspx"" rel=""nofollow"">MSDN</a></p>

<blockquote>
  <p><strong>Identifies a string as Unicode when UNICODE is defined by a
  preprocessor directive during compilation. Otherwise, the macro
  identifies a string as an ANSI string.</strong></p>
  
  <p>This macro interprets an ANSI string at runtime according to the
  current Windows ANSI code page. Literal ANSI strings that are not
  strictly ASCII are interpreted differently when processed with
  different Windows ANSI code pages. For example, ""\0xC4"" in code page
  1252 (Latin-1) represents Upper Case A with Dieresis (?). However, in
  code page 1253 (Greek), the string represents Upper Case Delta ().
  These different interpretations lead to development and maintenance
  issues. For example, a developer might correct a string when using a
  different system code page from the page used by the original
  developer; or a build computer might use a different code page. The
  different interpretations also pose runtime issues, for example, when
  the end user computer uses a different code page to interpret a string
  from that used by the build computer.</p>
</blockquote>

<p>Found one more link on <strong><a href=""http://msdn.microsoft.com/en-us/library/ms648008%28VS.85%29.aspx"" rel=""nofollow"">MSDN</a></strong> where you will find TEXT() function is used.</p>
",0
19497546,19497426,0,"<p>Here are a few links:</p>

<ul>
<li><a href=""http://msdn.microsoft.com/en-us/library/se784sk6.aspx"" rel=""nofollow"">Data Type Mappings</a></li>
<li><a href=""http://msdn.microsoft.com/en-us/library/dybsewaf.aspx"" rel=""nofollow"">Unicode Programming Summary</a></li>
<li><a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/dd374074%28v=vs.85%29.aspx"" rel=""nofollow"">TEXT macro</a></li>
</ul>
",0
19497499,19497426,2,"<p>Here's the MSDN docs on the <code>TEXT</code> macro.</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/dd374074%28v=vs.85%29.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/windows/desktop/dd374074%28v=vs.85%29.aspx</a></p>
",0
20530492,20530319,1,"<p>To make the code compile, you can do the following:</p>

<pre><code>small = reinterpret_cast&lt;uint8_t *&gt;(bigptr);
</code></pre>

<p>but I wouldn't do that, you should probably dereference the uint32_t pointer and then cast to the type you desire - there's no point casting to a uint8_t pointer in my mind.</p>

<p>ie. </p>

<pre><code>uint8_t small_one = *bigptr;
</code></pre>
",0
20530416,20530319,9,"<p><code>dynamic_cast</code> only works on classes with virtual member functions.  To cast raw pointer types between each other, you need <code>reinterpret_cast</code>.</p>
",0
20530420,20530319,0,"<p>Use reinterpret_cast. dynamic_cast has a different purpose.</p>
",0
20530425,20530319,3,"<p>You are using the wrong cast.  <code>dynamic_cast</code> only works with polymorphic class types, as it performs RTTI lookups at runtime.  You are not using polymorphic class types in your code.  To simply treat one pointer type as another pointer type, you need to use <code>reinterpret_cast</code> instead:</p>

<pre><code>small = reinterpret_cast&lt;uint8_t *&gt;(bigptr);
</code></pre>
",0
20094764,20094693,0,"<p>""Undefined Behavior"". C++ doesn't try to protect you from yourself. If you violate the C++ rules, anything can happen.</p>
",0
20094799,20094693,3,"<p>If you mean the handler set by <a href=""http://en.cppreference.com/w/cpp/memory/new/set_new_handler"" rel=""nofollow""><code>std::set_new_handler</code></a>, then if the handler returns and <code>new</code> still can't allocate memory the handler will be called again, and again and again...</p>
",3
19206407,19206262,2,"<p>The problem seem to be a lack of understanding of how streams work. You are <strong>not</strong> supposed to create your own ifstream, you are supposed to use the <code>istream&amp;</code> supplied to the function</p>

<p>Write some code like this to read the document one character at a time</p>

<pre><code>void typeset (int maxWidth, istream&amp; documentIn)
{
    char ch;
    while (documentIn.get(ch))
    {
        ...
    }
}
</code></pre>

<p>To me your confusion seems to characterise someone who just looks on the internet for something close to what they want to do. At some point you have to get a more fundamental understanding of C++, so that you can understand code and write original code, instead of just copying and modifying code. You're only going to get that by reading a textbook, which explains the principles behind C++.</p>

<p>In this case the principle is that all the different input streams <em>derive</em> from <code>istream</code> so input from any kind of stream can be done with an <code>istream</code>.</p>
",1
19505220,19505112,1,"<p>There are many subtle differences that distinguish <code>new</code> from <code>malloc</code> and <code>delete</code> from <code>free</code>. I believe they are only equivalent if the class is POD type.</p>

<p>I should warn that you can never mix the two types freely. A <code>new</code> must always be balanced by a <code>delete</code> and never by a <code>free</code>. Similarly <code>malloc</code> must be balanced only by <code>free</code>. Mixing the two results in undefined behaviour.</p>
",1
19505273,19505112,1,"<p>The actual answer to your question is that you are incorrect, not calling <code>delete xP</code> will lead to a memory leak. It is very likely that the OS then cleans up the memory for you, but it's not GUARANTEED by the C++ runtime library that this happens - it's something that OS's generally offer as a nice service [and very handy it is too, since it allows us to write imperfect code and have code that does things like <code>if (condition) { cout &lt;&lt; ""Oh horror, condition is true, I can't continue"" &lt;&lt; endl; exit(2); }</code> without having to worry about cleaning everything up when we've got something that went horribly wrong]. </p>

<p>My main point, however, is that this sort of stuff gets very messy as soon as you add members that in themselves need destruction, e.g. </p>

<pre><code>class X
{
  private:
    std::string str;
  ... 
};
</code></pre>

<p>There is no trivial way to call the destructor for <code>str</code>. And it gets even worse if you decide to use exceptions and automated cleanup. </p>
",0
20520011,20519749,0,"<p>You say you don't want to change the file, but you say you tried to save it in another format. Can you change it or not ?
Does something prevents you to set another line ending for a copy of your document ?</p>
",0
20520053,20519749,1,"<p>There is no way to change the line endings in a file without changing the file.  The best you could do is to copy the files (to a new name, or a new location), fixing the line endings in the process, and compile the copies.</p>

<p>You could even automate the whole ridiculous process if you wanted.</p>

<p>The error stems from the fact that lines in text files can be separated in several ways:</p>

<pre><code> Line 1&lt;CR&gt;&lt;LF&gt;Line2 - Windows/DOS/Most Internet protocols
 Line 1&lt;LF&gt;Line 2 - Unix and some Macs
 Line 1&lt;CR&gt;Line 2 - Some Macs
</code></pre>

<p>The MS compilers can apparently cope with either of the first two, but not the third.</p>

<p>Some version control systems are notorious for causing newline-related problems, so if you don't know how you got into this mess, that's where I'd look.</p>
",0
20656219,20656058,2,"<p>As I can think of, there are two ways.</p>

<h2>Use Sub-Class</h2>

<p>You can make <code>LInput</code> private inherit from <code>LIO</code>, but mark input methods as public:</p>

<pre><code>template &lt;typename IO&gt;
class LIO : public LThreadSafe
{
public:
    LIO() {}
    LIO(const LIO&amp; in) { /* make a copy for read-only */ }
    LIO(LIO&amp; io) { /* make a copy for write-only */ }

    shared_ptr&lt;LInput&lt;IO&gt;&gt; toInput() const { return make_shared&lt;LInput&lt;IO&gt;&gt;(*this); }
    shared_ptr&lt;LOutput&lt;IO&gt;&gt; toOutput() { return make_shared&lt;LOutput&lt;IO&gt;&gt;(*this); }
};

template &lt;class IO&gt;
class LInput : private LIO
{
public:
    LInput(LIO&lt;IO&gt;* pio) : LIO&lt;IO&gt;(*pio) {}
    using LIO&lt;IO&gt;::getValue;
};

LInput&lt;int&gt; in;
auto v = in.getValue();        // OK

in.setValue(xyz);              // Error: inaccessible
LIO&lt;int&gt;&amp; io = in;                  // Error: inaccessible
</code></pre>

<p>Give this solution a second thought, you will find it's good when the IO object can be copied; if it cannot be copied, you will need to wrap the implementation class reference inside <code>LIO</code> class.</p>

<p><strong>If you cannot copy</strong>, a complete example would be:</p>

<pre><code>template &lt;typename IO&gt; class LIOImpl {};

template &lt;typename IO&gt; class LInput;
template &lt;typename IO&gt; class LOutput;

template &lt;typename IO&gt; class LIO {
  shared_ptr&lt;LIOImpl&lt;IO&gt; &gt; pimpl_;

public:
  LIO() : pimpl_(make_shared&lt;LIOImpl&lt;IO&gt; &gt;()) {}
  LIO(const LIO &amp;io) : pimpl_(io.pimpl_) {}

  IO getValue() const { ... }

  LInput&lt;IO&gt; toInput() const { return LInput&lt;IO&gt;(*this); }
  LOutput&lt;IO&gt; toOutput() { return LOutput&lt;IO&gt;(*this); }
};

template &lt;class IO&gt; class LInput : private LIO&lt;IO&gt; {
public:
  LInput(const LIO&lt;IO&gt; &amp;io) : LIO&lt;IO&gt;(io) {}
  using LIO&lt;IO&gt;::getValue;
};

template &lt;class IO&gt; class LOutput : private LIO&lt;IO&gt; {
public:
  LOutput(LIO&lt;IO&gt; io) : LIO&lt;IO&gt;(io) {}
  using LIO&lt;IO&gt;::setValue;
};
</code></pre>

<hr>

<h2>Use Multiple Inheritance</h2>

<p>The C++ STL <code>iostream</code> use the multiple inheritance way to implement the <code>istream</code> and <code>ostream</code>. The constraints is pulled up in the hirarchy. This <em>diamond inheritance</em> sometimes is considered as a bad practice. </p>

<p>This push down constraints method avoids <em>diamond inheritance</em>.</p>

<p>You can also use <em>diamond inheritance</em> using pure class as interface:</p>

<pre><code>template &lt;typename IO&gt;
class LInput
{
public:
    virtual IO getValue() const = 0;
};

template &lt;typename IO&gt;
class LOutput
{
public:
    virtual void setValue(const IO&amp; v) const = 0;
};

template &lt;typename IO&gt;
class LIO : public LInput&lt;IO&gt;, public LOutput&lt;IO&gt;, public LThreadSafe
{
public:
    IO getValue() const override { ... }
    void setValue(const IO&amp; v) const override { ... }

    LInput&lt;IO&gt;* toInput() const { return this; }
    LOutput&lt;IO&gt;* toOutput() { return this; }
};
</code></pre>

<hr>

<p>Choose the way you feel good, in the meantime, try to isolate your interface from implementation. Once you reach the limitation, (or your just don't like it any more) you can change the interface easily without re-implement.</p>

<p>BTW, if you are using C++ 11, you should use <a href=""http://en.cppreference.com/w/cpp/thread/lock_guard"" rel=""nofollow"">std::lock_guard</a> instead of hand writting <code>lock/unlock</code> pairs:</p>

<pre><code>{
    lock_guard&lt;LThreadSafe&gt; lock;
    // ok you have lock now.
} 
// here lock is automatically released
</code></pre>
",8
19314432,19311647,1,"<p>@sehe gives you great advice, but I suspect a lot of that stuff won't make sense until you know more C++.</p>

<p>Here's a simple improvement to eliminate a slow loop:</p>

<p>When doing your row swaps swap the row pointers instead of copying every value that they point to. Replace this:</p>

<pre><code>    for (int k = 0; k &lt; m; ++k)
    {
        int temp1 = mas[i][k];
        mas[i][k] = mas[min][k];
        mas[min][k] = temp1;
    }
</code></pre>

<p>With:</p>

<pre><code>    int* temp1 = mas[i];
    mas[i] = mas[min];
    mas[min] = temp1;
</code></pre>

<p>If you can figure out how to use a built-in sort algorithm that would be another improvement on top of this, but even this small change will gain you a lot.</p>
",1
19803040,19803005,0,"<p>Here you are translating ASCII digits to some internal representation:</p>

<pre><code>x.digitList[x.currentSize] = C2I(c);
</code></pre>

<p>But there is no translation in the other direction, back to text, when you perform output.</p>
",0
20640027,20639973,2,"<p>This initializes all 256 chars to <code>0</code>:</p>

<pre><code>char str[256] = {0};
</code></pre>

<p>This one initializes the first one to <code>1</code>, and all the rest to <code>0</code>:</p>

<pre><code>char str[256] = {1};
</code></pre>

<p>Concerning the behaviour of <code>printf</code>, <code>""%c""</code> expects a single <code>char</code>. You pass it <code>0</code>, which is <code>NUL</code> (the character string termination) so it prints nothing. <code>""%s""</code> expects a <code>char*</code> with the first character in a nul-terminated character string. You pass it a single <code>char</code> with value <code>0</code>, which it interprets as a null pointer.</p>
",0
18680393,18680362,7,"<p>You need to change <code>int</code> to <code>unsigned int</code> or even better <code>unsigned long long</code>. Your result is overflowing the maximum value of <code>int</code> on your system. Because <code>int</code> is signed, when the <a href=""http://en.wikipedia.org/wiki/Most_significant_bit"" rel=""nofollow noreferrer"">most significant bit</a> gets set, it becomes a negative number.  See the Stack Overflow question titled <a href=""https://stackoverflow.com/questions/1855459/maximum-value-of-int"">maximum value of int</a>, and this Swarthmore College page on <a href=""http://www.swarthmore.edu/NatSci/echeeve1/Ref/BinaryMath/BinaryMath.html"" rel=""nofollow noreferrer"">binary arithmatic</a> for more information. If you're using Visual Studio, take a look at the <a href=""http://msdn.microsoft.com/en-us/library/s3f49ktz%28v=vs.90%29.aspx"" rel=""nofollow noreferrer"">Data Type Ranges</a> article on MSDN. </p>

<p>In addition to switching to <code>unsigned long long</code>, you should probably check for overflow errors such as this and throw an exception. A revised version of your code could look like this. </p>

<pre><code>unsigned long long fib(int n) {
    vector&lt;unsigned long long&gt; v;
    v.push_back(1);
    v.push_back(1);
    for (int i = 2; i &lt;= n; i++) {
        if( v.at(i-1) &gt; (std::numeric_limits&lt;unsigned long long&gt;::max() - v.at(i-2)) )
            throw std::overflow_error(""number too large to calculate"");
        v.push_back( v.at(i-1) + v.at(i-2) );
        cout &lt;&lt; v.at(i-1) &lt;&lt; "" + "" &lt;&lt; v.at(i-2) &lt;&lt; "" = "" &lt;&lt; (v.at(i-1) + v.at(i-2)) &lt;&lt; endl;
    }
    return v.at(n);
}
</code></pre>

<p>You would also want to make sure the code calling your function can handle an exception by using a <code>try... catch...</code>. Here's an example</p>

<pre><code>try {
    std::cout &lt;&lt; ""2000th number = "" &lt;&lt; fib(2000) &lt;&lt; std::endl;
} catch( std::overflow_error&amp; ex ) {
    std::cerr &lt;&lt; ex.what() &lt;&lt; std::endl; 
}
</code></pre>
",7
18680439,18680362,2,"<p>Because of how C stores your <code>int</code> (signed int) in memory, the most significant bit indicates a negative number. So you'll get negative number if you overflow it with large numbers.</p>

<p>Reference:</p>

<ul>
<li><a href=""http://en.wikipedia.org/wiki/Integer_overflow"" rel=""nofollow"">http://en.wikipedia.org/wiki/Integer_overflow</a></li>
<li><a href=""http://en.wikipedia.org/wiki/2%27s_complement"" rel=""nofollow"">http://en.wikipedia.org/wiki/2%27s_complement</a>  </li>
</ul>
",2
18429733,18429707,3,"<p>This is due to <strong><a href=""http://en.wikipedia.org/wiki/Copy_elision"" rel=""nofollow"">copy elision</a></strong> compiler optimization. An compiler is allowed to elide copy constructor calls in certain cases. What you see is this optimization in action. You are right in assuming calls to:     </p>

<ul>
<li>Conversion constructor and then a </li>
<li>Copy constructor </li>
</ul>

<p>But in this case the second call is elided/removed/optimized by the constructor by using return value optimization. The compiler constructs the object directly in to <code>e</code> rather than creating a temporary object and then copying it to <code>e</code>.       </p>

<p>If you are using GCC you can use <code>-fno-elide-constructors</code> option to disable copy-elision and you should see the result you expected.</p>
",8
18429739,18429707,0,"<p>It seems that the compiler is optimising your code not ot call the copy constructor which is known as <code>copy elision</code></p>

<p>Please look <a href=""http://en.wikipedia.org/wiki/Copy_elision"" rel=""nofollow"">HERE</a> for more details.</p>

<p>Basically in copy elision a compiler optimizez your code to omit unnessesary intermediate temporary objects.</p>
",0
18429757,18429707,0,"<p>You are right about that <code>cls e = 15</code> is the same as <code>cls e = cls(15)</code>. This is because your <code>cls(int a)</code> is not declared explicit. Next is just compiler copy elision optimization.</p>
",4
19798031,19797903,1,"<p>Take a look at <a href=""http://www.doxygen.nl/"" rel=""nofollow noreferrer"">Doxygen</a>.</p>

<p>In addition to C++, it supports many 'mainstream languages'.</p>

<p>For generating call graphs and class diagrams, etc., Doxygen requires the <a href=""https://graphviz.org/"" rel=""nofollow noreferrer"">graphviz package</a> to be installed.</p>

<p>However, Doxygen cannot render (any or all) 'uses' dependencies among classes, AFAIK.</p>

<p>You may also look into generating UML from C++: <a href=""https://stackoverflow.com/q/405953/1175253"">Generating UML from C++ code?</a></p>
",1
18864350,18864291,2,"<p>It seems easy enough.</p>

<p>Firstly if the time is PM you add 12 hours (in minutes). Then if time 1 is later than time 2 you return time1 - time2.</p>

<pre><code>// Convert time to minutes past midnight
int ConvertTimeToMinutes(int hour, int min, bool pm)
{
    if (hour == 12)
        hour = 0;
    int calc = hour*60 + min;
    if (pm)
        calc += 12*60;
    return calc;
}

// Compare times and return the absolute time difference in minutes
int ComputeTime(int hour1, int hour2, int min1, int min2, bool pm1, bool pm2)
{
    int calc1 = ConvertTimeToMinutes(hour1, min1, pm1);
    int calc2 = ConvertTimeToMinutes(hour2, min2, pm2);
    if (calc2 &gt; calc1)
    {
        return calc2 - calc1;
    }
    else
    {
        return calc1 - calc2;
    }
}
</code></pre>

<p>Not a good idea to name a <em>boolean</em> variable ampm1, because it's completely unclear whether true means AM or PM. I've assumed that true is PM and renamed the variables accordingly.</p>

<p>I've also written a separate function to do the time conversion, to cut down on duplicated code.</p>
",8
18374505,18374335,2,"<p>The <code>operator[]</code> on <code>std::map&lt; class Key, class Value</code> is used to get the value that corresponds to a specific key (actually, it returns a reference, but w/e). In your case you will use it like this:</p>

<p>(<strong>code piece 1</strong>)</p>

<pre><code>std::map&lt;std::string,std::vector&lt;std::string&gt;&gt; m;
&lt;...&gt;
std::string the_key_you_need(""this is the key"");
std::vector&lt; std::string &gt; value = m[the_key_you_need];
value.push_back(&lt;...&gt;)
</code></pre>

<p>which is NOT the same as:</p>

<p>(<strong>code piece 2</strong>)</p>

<pre><code>std::map&lt;std::string,std::vector&lt;std::string&gt;&gt; m;
&lt;...&gt;
m[the_key_you_need].push_back(&lt;...&gt;);
</code></pre>

<p>because in the first one, you are making a <em>copy</em> of <code>m[the_key_you_need]</code> named <code>value</code>, and pushing the new string <em>into the copy</em>, meaning it will not end up in <code>m</code>. The second one is the proper way to do it.</p>

<p>Also, <code>m[&lt;something&gt;] = value.push_back(&lt;something_else&gt;)</code> will not work, because <code>vector::push_back()</code> returns void. If you want to do it this way, you will need to:</p>

<p>(<strong>code piece 3</strong>)</p>

<pre><code>std::map&lt;std::string,std::vector&lt;std::string&gt;&gt; m;
&lt;...&gt;
std::string the_key_you_need(""this is the key"");
std::vector&lt; std::string &gt; value = m[the_key_you_need];
value.push_back(&lt;...&gt;)
m[the_key_you_need] = value;//here you are putting the copy back into the map
</code></pre>

<p>In this case, code pieces 2 and 3 are indeed equivalent (but code piece 2 is better because it doesn't create an unnecessary copy).</p>
",3
19876097,19875957,2,"<p>You can always override overload resolution with an explicit cast of the function:</p>

<pre><code>int x = 10;
static_cast&lt;void(&amp;)(int&amp;)&gt;(pp)(x);     // calls void pp(int&amp;)
</code></pre>

<p>Otherwise, indeed, the call <code>pp(x)</code> is ambiguous, because binding to a reference has exactly the same ""matching priority"" as binding to a value in terms of overload resolution. The same holds if the second overload is <code>pp(const int &amp;)</code>, since ""qualification adjustments"" are also ""exact matches"".</p>

<p>See ""Standard conversion sequences"" [over.ics.scs] in the standard (e.g. 13.3.3.1.1 in C++11), and ""Reference binding"" [over.ics.ref] (13.3.3.1.4).</p>
",4
19800488,19800437,0,"<p>For this particular command use <code>mkdir -p new_folder</code>.</p>

<p>Generally, you want to fork your process and on one of the branches redirect stdout and stderr to /dev/null or similar then do exec to replace the process with the new one.</p>
",0
20507823,20507590,0,"<p>It is not possible with vanilla C++, but it is certainly doable with a custom implementation. Qt's property system allows adding dynamic properties during the runtime which do not exist during compile time.</p>

<blockquote>
  <p>QObject::setProperty() can also be used to add new properties to an
  instance of a class at runtime. When it is called with a name and a
  value, if a property with the given name exists in the QObject, and if
  the given value is compatible with the property's type, the value is
  stored in the property, and true is returned. If the value is not
  compatible with the property's type, the property is not changed, and
  false is returned. But if the property with the given name doesn't
  exist in the QObject (i.e., if it wasn't declared with Q_PROPERTY(), a
  new property with the given name and value is automatically added to
  the QObject, but false is still returned. This means that a return of
  false can't be used to determine whether a particular property was
  actually set, unless you know in advance that the property already
  exists in the QObject.</p>
</blockquote>
",0
19374458,19374206,1,"<p>So there is 2 ways in which you can do this:</p>

<ol>
<li>Write over the current file with the new values, this means reading all data in, then writing back out in the same format, this is the easiest method, just use ofstream to write the same data out </li>
<li>Use a stream pointer in the ofstream library, check out <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream"" rel=""nofollow"">this</a> resource (hint: seekp, tellp and write), this will ""move"" to a point in the file and then write out directly from that point, this is a more complex but more efficient method.</li>
</ol>

<p>Example of #1:</p>

<pre><code>int rowCount = 0;
// read in file here and count the number of rows in the text file.

ofstream output;
output.open(""itemInfo.txt"", ofstream::out);

for (int i = 0; i &lt; rowCount; i++) // 
    output &lt;&lt; itemId[i] &lt;&lt; "","" &lt;&lt; itemName[i] &lt;&lt; "","" &lt;&lt; price[i] &lt;&lt; endl;
</code></pre>

<p>Example of #2:
    I cant be bothered</p>
",0
20508284,20508271,6,"<p>In C++11 (only) you can use a raw string literal:</p>

<pre><code>std::string str = R""(This is the first line.\r\nThis is still the first line)"";
</code></pre>
",1
20198516,20198370,2,"<p>The last character is displayed twice because you are checking for file stream errors before reading from the file (i.e., before reading end-of-file). You need to check for an error <em>after</em> getting the character.</p>
",1
20198596,20198370,1,"<p>You need to check if the ifstream is still valid when you read from it; You read and then display, but if the stream has ended... Try this:</p>

<pre><code>std::ifstream file1;
file1.open(""RO1.TXT"");
char ch;
while(file1.good())
{
   file1.get(ch);
   if (file1.good())
    std::cout&lt;&lt;ch;
}
</code></pre>

<p><strong>UPDATE</strong></p>

<p>This may help you with the first problem:</p>

<p><a href=""https://stackoverflow.com/questions/8835888/stdfstream-doesnt-create-file"">std::fstream doesn&#39;t create file</a></p>

<p>You have to remove std::fstream::in from your mode argument, or specify std::fstream::trunc as it's said in the above link</p>
",0
20198604,20198370,2,"<pre><code>while (file1)
{
    file1.get(ch);
    std::cout&lt;&lt;ch;
}
</code></pre>

<p>is wrong</p>

<pre><code>while (file1.get(ch))
{
    std::cout&lt;&lt;ch;
}
</code></pre>

<p>is right. </p>

<p>Your version is wrong beceause it's only after you try to read and fail that <code>file1</code> becomes false. This is why you get a repeated character at the end of your file. You call <code>file.get</code> one more time than you have characters in the file but because you don't check for an error at the right place you also call <code>std::cout&lt;&lt;ch</code> one more time than you have characters in the file.</p>

<p>Sometimes seems that every single programmer in the world makes this mistake when they are starting out.</p>
",1
19270358,19270178,33,"<p><em><strong>""helper function""</em></strong> is not a term that you would find in a standard, neither it has an exact definition... standard mentions <em>""helper class""</em> or <em>""helper template""</em> few times to refer to a class, which is not meant to be instantiated by end-users but it provides an useful functionality internally used within another class.</p>

<p>Helper functions are (what I believe the most people mean when they say it) usually functions that wrap some useful functionality that you're going to reuse, most likely over and over again. You can create helper functions meant to be used for many different kinds of purposes... </p>

<p>An example might be conversion function of any kind, for example function converting multi-byte encoded <code>std::string</code> to <code>std::wstring</code>:</p>

<pre><code>std::wstring s2ws(const std::string&amp; str)
{
    int size_needed = MultiByteToWideChar(CP_UTF8, 0, &amp;str[0], (int)str.size(), NULL, 0);
    std::wstring wstrTo( size_needed, 0 );
    MultiByteToWideChar(CP_UTF8, 0, &amp;str[0], (int)str.size(), &amp;wstrTo[0], size_needed);
    return wstrTo;
}
</code></pre>
",1
19562163,19562103,206,"<p>It doesn't really print a blank, but most probably the ASCII character with value 5, which is non-printable (or invisible). There's a number of <a href=""http://www.cs.tut.fi/~jkorpela/chars/c0.html"" rel=""noreferrer"">invisible ASCII character codes</a>, most of them below value 32, which is the blank actually.</p>

<p>You have to convert <code>aa</code> to <code>unsigned int</code> to output the numeric value, since <code>ostream&amp; operator&lt;&lt;(ostream&amp;, unsigned char)</code> tries to output the visible character value.</p>

<pre><code>uint8_t aa=5;

cout &lt;&lt; ""value is "" &lt;&lt; unsigned(aa) &lt;&lt; endl;
</code></pre>
",26
19562175,19562103,56,"<p><code>uint8_t</code> will most likely be a <code>typedef</code> for <code>unsigned char</code>. The <code>ostream</code> class has a special overload for <code>unsigned char</code>, i.e. it prints the character with the number 5, which is non-printable, hence the empty space.</p>
",1
19562181,19562103,18,"<p>It's because the output operator treats the <code>uint8_t</code> like a <code>char</code> (<code>uint8_t</code> is usually just an alias for <code>unsigned char</code>), so it prints the character with the ASCII code (which is the most common character encoding system) <code>5</code>.</p>

<p>See e.g. <a href=""http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt2"" rel=""noreferrer"">this reference</a>.</p>
",3
19562187,19562103,8,"<p><code>cout</code> is treating <code>aa</code> as <code>char</code> of ASCII value <code>5</code> which is an unprintable character, try typecasting to <code>int</code> before printing.</p>
",1
18798744,18798714,3,"<p>As you noticed, it is no longer the same.</p>

<p>Sure, you segregated the checksum bit, but now you are incrementing <code>BufPos</code> a different number of times.  Your loop is now iterating more times, so <code>BuffPos</code> has a different value once you start creating the checksum than it did in the first version.</p>

<p>Look at it this way; the first version starts accumulating the checksum at <code>BuffPos + 3</code>.  The second version begins accumulating the checksum from <code>BuffPos + (Start * Width) + 3</code>.  </p>

<p>Honestly, the first version is better.  I can't tell you which one is <em>correct</em>, but assuming the first version is (iterating from <code>Start</code>) then why introduce a branch at all?  It just muddles up the code.</p>

<p>If you want the second version to be the same as the first you'll need to initialize <code>BuffPos</code> to <code>Data + Start * Width</code> or place both statements within the <code>if</code>.  Of course, if you do that, you're just doing nothing at all until <code>I == Start</code>, and that should tell you something.</p>
",9
18798772,18798714,0,"<p>Both statements(Buffpos and cheksum) should come under if statement . </p>
",0
18798800,18798714,1,"<p>how's this version?</p>

<pre><code>int K = 0;
std::uint32_t CheckSum = 0;
const std::uint8_t* BuffPos = static_cast&lt;const std::uint8_t*&gt;(Data);
int Start = Height &lt; 12 ? 1 : 12;

for (std::size_t I = 0; I &lt; Height; ++I)
{
    if (I &lt; Start)  //The if statement.
        continue; 
    for (std::size_t J = 0; J &lt; Width; ++J, ++K)
    {
        BuffPos += 3; //Skip RGB and move to alpha pixel.
        CheckSum += *(BuffPos++);  //Checksum = count of alpha pixels.
    }
}

std::cout&lt;&lt;CheckSum;
</code></pre>
",7
19786982,19786813,0,"<p>Each compiler usually has its own language extensions. It is valid as for g++ and as for example MS VC++.  For example in MS VC++ you can use statement for each. </p>
",3
19788747,19786813,-1,"<p>It seems you found a <em>feature</em> of the gcc compiler: an undocumented extension that cannot be suppressed or be warned about by using any options (such as <code>-pedantic -std=XXXX</code>).</p>

<p>If you want to be reasonably certain that your code complies with the standard, I recommend to always use a variety of compilers and make sure your code passes all of them without warnings (and use the most strict warning options). gcc and clang are free, so you can always use at least two compilers (and clang is quite good at standard compliance).</p>
",0
19576532,19575145,1,"<p>With VS2012, I can see the input cut off when I paste the string into the console window. But it works if I save this long string to a file, then run the program with the input redirected from said file, as in <code>test.exe &lt; input.txt</code>.</p>

<p>So it seems to be a limitation of the Windows console, not of the C++ streams implementation.</p>
",2
19507261,19507132,1,"<p>Why not just write a bunch of static Get functions (GetInt/GetDouble...) that validates the input, returns the appropriate type result and throws an exception if it isn't that type?</p>
",0
19507381,19507132,1,"<p>Technically you can achieve the public interface that you've outlined there but that would involve very ugly looking template specialization.
It would probably be better if you just had a bunch of static functions instead. Here is what template specialization would look like:</p>

<pre><code>template &lt;typename T&gt; class MyClass { 
    static T getValue(ThirdPartyClass someObj, const string &amp;key) {
       // handle types that you didn't specialize for
    } 
};
template &lt;&gt; class MyClass &lt;string&gt; { 
    static string getValue(ThirdPartyClass someObj, const string &amp;key) {
       return someObj[key].GetString();
    } 
};
template &lt;&gt; class MyClass &lt;int&gt; { 
    static int getValue(ThirdPartyClass someObj, const string &amp;key) {
       return someObj[key].GetInt();
    } 
};
//..
</code></pre>
",2
19507445,19507132,0,"<p>The code you showed won't compile. You can't in the same function return a <code>double</code>, a <code>string</code>, and an <code>int</code>. What you'd have to do it specialize for each return type, and then call only the function for that type:</p>

<pre><code>template &lt;&gt;
class MyClass&lt;int&gt; getValue(ThirdPartyClass someObj, const string&amp; key) {
    if(someOjb[key].IsInt()) return someObj[key].GetInt();
    else { /* Maybe throw an exception */ }
};
</code></pre>

<p>and repeat for each type.</p>

<p>Now, you're probably thinking, ""this is silly, how come I have to specialize each type?"" That's because your JSON library is using type erasure, so you have to check the type at runtime. The only way to save yourself the work is if the library provides a templated <code>get</code>.</p>

<p>If you want, you could create a macro to stamp these instantiations out. It would take advantage of the <code>#</code> (<a href=""http://gcc.gnu.org/onlinedocs/cpp/Stringification.html#Stringification"" rel=""nofollow"">stringification</a>) and <code>##</code> (<a href=""http://gcc.gnu.org/onlinedocs/cpp/Concatenation.html"" rel=""nofollow"">concatenation</a>) features of the preprocessor. It'll probably be clearer to just write them out.</p>
",1
19507585,19507132,1,"<p>Skeleton key for software engineering: add an intermediate layer.</p>

<pre><code>#include &lt;string&gt;
#include &lt;cassert&gt;
using std::string;

class Proxy {
public:
  enum Type {
    Int,
    Bool,
    String,
    Double
  };
  Type type;
  int i;
  bool b;
  string s;
  double d;
  operator int() const {
    assert(type == Int);
    return i;
  }
  operator bool() const {
    assert(type == Bool);
    return b;
  }
  operator string() const {
    assert(type == String);
    return s;
  }
  operator double() const {
    assert(type == Double);
    return d;
  }
  Proxy(int i) : type(Int), i(i) {}
  Proxy(bool b) : type(Bool), b(b) {}
  Proxy(string s) : type(String), s(s) {}
  Proxy(double d) : type(Double), d(d) {}
}; // class Proxy

Proxy getValue(ThirdPartyClass someObj, const string &amp;key) {
  if (someObj[key].IsDouble())
    return someObj[key].GetDouble();
  else if (someObj[key].IsString())
    return someObj[key].GetString();
   //... (for other types)
}

int main() {
  int i = getValue(someObj, ""intKey""); // if type does not match, a exception will be thrown.
  string s = getValue(someObj, ""strKey"");
}
</code></pre>
",0
20635944,20635882,10,"<p>Simplified: This means <code>unsigned long</code>.</p>

<p>Please also refer to <a href=""http://www.cplusplus.com/doc/tutorial/constants/"" rel=""noreferrer"">this.</a></p>
",0
18864225,18864065,5,"<p>You can use <code>std::rotate</code> for this task. It does a left rotate of the data in the collection, so you specify a ""cut"" point, and it moves the elements so the one immediately after the specified cut point will be at the beginning, and those that were before the cut point will be moved to the end.</p>

<p><img src=""https://i.stack.imgur.com/IEMWV.png"" alt=""enter image description here""></p>
",3
18864103,18864065,0,"<p>Yes, you can - store the first element of the second half, shift first half to the right. Assign 0'th array element to this stored number. You've just moved the first number of second half to the start. Repeat it for next etc.</p>

<p>Draft of the code:</p>

<pre><code>for(int i = start; i &lt; arr.size(); i++){
    double temp = arr[i];
    for(int j = start-1; j &gt; i - start; j--){
        arr[j+1] = arr[j];
    }
    arr[i - start] = temp;
}
</code></pre>
",0
19885916,19885731,0,"<p>As you liked the proposition in comments, here is an example:</p>

<pre><code>template&lt;typename Key&gt;
class Timer
{
 class CachePair
 {
  clock_t lastTimestamp, diff;

 public:
  CachePair() :
   lastTimestamp(0), diff(0)
  { }

  void update()
  {
   clock_t now = std::clock();
   diff = now - lastTimestamp;
   lastTimestamp = now;
  }
 };

 std::map&lt;Key, CachePair&gt; cache;

public:
 Timer()
 { }

 void tick(Key const&amp; key)
 {
  cache[key].update();
 }

 clock_t const&amp; value(Key const&amp; key)
 {
  return cache[key].diff;
 }
};
</code></pre>

<p>Did not test it. This could be improved if you are using C++11 to avoid initialization in <code>CachePair</code> constructor when you are calling <code>update(Key)</code> for the first time on a <code>Key</code>.</p>

<p>Actually you can even eliminate the second variable if size matters <em>that</em> much and also eliminate much of the complication.</p>

<pre><code>template&lt;typename Key&gt;
class Timer
{    
 std::map&lt;Key, clock_t&gt; cache;

public:
 Timer()
 { }

 clock_t tick(Key const&amp; key)
 {
  clock_t&amp; val = cache[key];

  clock_t now = std::clock();
  val = now; //this will update the value in map because it is defined as a reference to the variable in map
  return now - val;
 }
};
</code></pre>

<p>Way simpler huh, naturally better because has easier interface / less methods. You just need to type <code>size_t timeElapsed = timer.tick(key);</code> to get the time elapsed between two ticks.</p>
",0
19373518,19373490,10,"<p><a href=""http://en.cppreference.com/w/cpp/iterator/iterator_traits"">std::iterator_traits</a>:</p>

<pre><code>static_assert(is_same&lt;typename std::iterator_traits&lt;InputIterator&gt;::value_type, 
               SomeType&gt;::value, """");
</code></pre>
",0
19374813,19373490,3,"<p>An alternative using <code>decltype</code>, with a note in passing that it often produces a reference (but may not!).</p>

<pre><code>// If you want to assert that the dereferenced item is indeed a reference
static_assert(std::is_same&lt;decltype(*begin), SomeType&amp;&gt;::value, """");

// If you are only interested in the ""bare"" type
// (equivalent to Jesse's providing iterator_traits was properly specialized)
static_assert(std::is_same&lt;
    typename std::remove_reference&lt;decltype(*begin)&gt;::type,
    SomeType
&gt;::value, """");
</code></pre>
",0
19373709,19373649,2,"<p>you could use</p>

<pre><code> static_assert(std::is_same&lt;typename T::value_type,SomeType&gt;::value, ""type in the container is different"");
</code></pre>
",0
19373719,19373649,1,"<p>If it is an standard container...</p>

<pre><code>template &lt;typename Container&gt;
MyFun(const Constainer&amp; container)
{
    static_assert(std::is_same&lt;typename Container::value_type, SomeType&gt;::value)
    // I want to static_assert that all elements in Container are equal to SomeType
}
</code></pre>
",0
19373724,19373649,1,"<p>You need something like</p>

<pre><code>static_assert(std::is_same&lt;typename T::value_type, SomeType&gt;::value, 
              ""It does not work"");
</code></pre>

<p>Assumng the container type defined <code>value_type</code> to be the type of the elements it holds (like standard library containers do).</p>

<p>See <a href=""http://en.cppreference.com/w/cpp/types/is_same"" rel=""nofollow""><code>std::is_same</code></a> and <a href=""http://en.cppreference.com/w/cpp/language/static_assert"" rel=""nofollow""><code>static_assert</code></a>.</p>
",0
18500630,18500613,2,"<p>You're just screwing up the constructor syntax. Don't use brackets; use braces. (This will only work in C++11.)</p>
",4
19879518,19879506,3,"<p><a href=""http://en.cppreference.com/w/cpp/string/basic_string/stof"" rel=""nofollow""><code>std::stof</code></a> is located in the standard C++ header <code>&lt;string&gt;</code>.</p>
",6
19323237,19323195,13,"<p>You defined <code>Mob</code> to... nothing. That makes your code equivalent to:</p>

<pre><code>class {
private:
    int lvl;
    float hp;
public:
    (int, float); // Expecting an identifier indeed
};
</code></pre>

<p>and that holds for the rest of the code where <code>#define Mob</code> is included.</p>

<p>If you're trying to make include guards, you need a unique name and define it conditionaly:</p>

<pre><code>#ifndef UNIQUE_MOB
#define UNIQUE_MOB
// code
#endif
</code></pre>
",0
19323244,19323195,16,"<p>This line:</p>

<pre><code>#define Mob
</code></pre>

<p>Causes every instance of the word <code>Mob</code> to be replaced with nothing in your code.  Don't do that.  </p>

<p>It looks like you wanted to make an <a href=""http://en.wikipedia.org/wiki/Include_guard"" rel=""noreferrer"">include guard</a>, which should look something like:</p>

<pre><code>#ifndef MOB_H
#define MOB_H


  ...

#endif
</code></pre>
",0
19868819,19868667,0,"<p>If array size is variable-dependent you must: loop through or</p>
<blockquote>
<p>int array[x];</p>
<p>memset(array, 0, x);</p>
</blockquote>
<p>If array size is hardcoded you can:</p>
<blockquote>
<p>int array[10] = {0};</p>
</blockquote>
",1
19868832,19868667,1,"<p>This should work, and will zero-initialize the 9 remaining elements.</p>

<p><code>int array[10] = {0};</code></p>

<p>See: <a href=""https://stackoverflow.com/questions/4984228/"">Array initialization in C++</a></p>
",0
19868754,19868667,1,"<p>What you need to do is up at the top where you have:</p>

<p>int array[SIZE];</p>

<p>replace it with:</p>

<pre><code>int array[SIZE] = {};
</code></pre>

<p>if you were trying to do:</p>

<pre><code>array[SIZE] = {}; 
</code></pre>

<p>later on, it wouldn't work the same.
in that case, it would fail (accessing [10] when there's only [0]-[9]).</p>

<p>You could also use a static array.</p>

<p>See:</p>

<p><a href=""https://stackoverflow.com/questions/201101/how-to-initialize-an-array-in-c"">How to initialize all members of an array to the same value?</a></p>

<p>Or if you want to use the STL Array type,, you can look at:</p>

<p><a href=""http://www.cplusplus.com/reference/array/array/?kw=array"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/array/array/?kw=array</a></p>

<p>you might even need to just make the SIZE var const.</p>
",1
19868776,19868667,6,"<p>I'm taking a guess here.</p>

<pre><code>int array[10] = {0};
</code></pre>

<p>is perfectly legal and should work on any compiler, but I think you tried</p>

<pre><code>int SIZE = 10;
int array[SIZE] = {0};
</code></pre>

<p>which is entirely different, and not legal. Array bounds must be constants, not variables.</p>

<p>Some compilers accept variable bounds, but that doesn't make it legal.</p>
",1
19868808,19868667,3,"<p>Change <code>int SIZE = 10;</code> to <code>const int SIZE=10;</code> or <code>enum{SIZE=10};</code>, and your <code>{}</code> based initialization should work.</p>

<p>You have accidentally used a gcc extension allowing for variable sized arrays.</p>
",0
19887152,19887024,0,"<p>You can just use another array</p>

<pre><code>const char *myargv[] = { ""pgmname"",
                         ""my_first_filename.dat"",
                         ""my_second_filename.dat"",
                         NULL };
argv = myargv;
argc = 3;
</code></pre>

<p>If this is just to be able to run the program from an IDE note however that there is for sure a GUI option for setting the command line arguments for the program.</p>
",2
19887039,19887024,2,"<p>The value of a <code>const char</code>can not be changed. What is it you want to do?</p>

<p>If you want a value of the argv array in the main function to be set you need to execute the program with a command line argument like:</p>

<pre><code>program argument argument etc
</code></pre>

<p>Edit from comment info:</p>

<p>If you want to run the <code>pf</code>function on program start you could add </p>

<pre><code>pf(""C:\Games\World_of_Tanks\res\packages\gui.pkg""); // this might need to be escaped...
</code></pre>

<p>in the main function.</p>
",5
19018854,19018820,3,"<p>The problem is that the <code>c_str</code> return a pointer that is temporary. So when the loop continue it's iteration the object you got the pointer from is destructed and the pointer is no longer valid, leading to undefined behavior when you later dereference that pointer.</p>

<p>If you want an array of strings, why not declare it as an array of strings?</p>

<hr>

<p>There are also other problems with your code, like you only allocating four bytes for a string that can be 12 (with sign and string terminator) characters.</p>

<hr>

<p>I would suggest you remake your program like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;array&gt;
#include &lt;sstream&gt;

const size_t ATTR_SIZE = 3;

int main()
{
    std::array&lt;std::string, ATTR_SIZE&gt; attr;

    for (int i = 0; i &lt; ATTR_SIZE; ++i)
    {
        std::istringstream is;
        is &lt;&lt; ""attr"" &lt;&lt; i;
        attr[i] = is.str();
    }

    for (const std::string&amp; s : attr)
        std::cout &lt;&lt; s &lt;&lt; '\n';
}
</code></pre>

<p>The above uses some C++11 features like <a href=""http://en.cppreference.com/w/cpp/container/array"" rel=""nofollow""><code>std::array</code></a> (you can use <a href=""http://en.cppreference.com/w/cpp/container/vector"" rel=""nofollow""><code>std::vector</code></a> instead) and <a href=""http://en.cppreference.com/w/cpp/language/range-for"" rel=""nofollow"">range-base <code>for</code> loop</a> (you can use normal iteration instead).</p>
",4
18655197,18655168,2,"<p>If you're using C++, the correct header name is <code>&lt;cstdio&gt;</code> (not <code>cstdio.h</code>).</p>
",7
18655206,18655168,9,"<p>Make sure your code says <code>#include &lt;cstdio&gt;</code> and not <code>#include &lt;cstdio.h&gt;</code>.</p>

<p>If your code says <code>#include &lt;cstdio&gt;</code> and your compiler is looking for <code>cstdio.h</code>, then you urgently need to find a better compiler.</p>
",2
18978662,18978530,0,"<p>In the second block you're reading k but using y...</p>

<pre><code>std::cin &gt;&gt;k;
if(k == 'y' || k=='n'){
    if (f =='y'){
        this-&gt;decisionvector[1] = 2;
    }else 
        this-&gt;decisionvector[1] = 0;
    f= 0;
}
</code></pre>
",0
18978852,18978530,3,"<p>You should change <code>int f</code> to <code>char f</code></p>
",2
18981242,18978530,2,"<pre><code>int f =0;
std::cin &gt;&gt;f;
</code></pre>

<p><a href=""http://en.cppreference.com/w/cpp/io/cin"" rel=""nofollow""><code>std::cin</code></a> reads and <em>interprets</em> the sequence of character. </p>

<p>If <code>f</code> is an <code>int</code>, it will use the <code>int</code> overload of the extraction operator <code>operator&gt;&gt;</code>. This operator will try to format the input as an integer. </p>

<p>If the user pass the character <code>'y'</code>, the operator will fail to interpret it as a integer and will store <code>0</code> in <code>f</code>. You can check the error state of the stream with <code>cin.fail()</code>.</p>

<p>if you want to read a character, you have to use a <code>char</code>.</p>
",0
19267752,19267623,0,"<p>Your code:</p>

<pre><code>CPolygon CPoint::operator + (CPoint pointToAdd) {
    CPolygon polygon;


    polygon.addPoint(this);
    polygon.addPoint(pointToAdd);

    cout &lt;&lt; polygon.toString();

    return polygon;
}
</code></pre>

<p>I see strange that for
<code>polygon.addPoint(this)</code> you are adding a pointer to <code>CPolygon</code>, since <code>this</code> is a pointer. Should you use <code>polygon.addPoint(*this)</code> instead?
In <code>polygon.addPoint(pointToAdd)</code> you are adding by value or reference.</p>

<p>If you need further help, please, add all the prototypes for function <code>CPolygon::addPoint</code>.</p>
",1
19268111,19267623,-1,"<p>Your polygon object is declared on stack, you will lose reference to it after the operator scope!</p>

<p>Try to declare it:</p>

<pre><code>CPolygon* polygon = new Polygon(...);
</code></pre>

<p>and your signature should look like:</p>

<pre><code>CPolygon* CPoint::operator + (CPoint pointToAdd) 
</code></pre>

<p>Indeed using raw pointers it's a bad idea and you have to take care of it outside the scope, a better solution will be to user smart pointers:</p>

<pre><code>std::auto_ptr&lt;CPolygon&gt; CPoint::operator + (CPoint pointToAdd) 
{
    std::auto_ptr&lt;CPolygon&gt; polygon(new CPolygon);
    // do stuff here
    return polygon;
}
</code></pre>

<p>// ...</p>

<pre><code>{
  std::auto_ptr&lt;CPolygon&gt; polygon = firstPoint + secondPoint;
  // working with CPolygon

  // auto_ptr frees polygon 
}
</code></pre>
",14
19268955,19267623,1,"<p>I did as PlasmaHH and urzeit suggested above and implemented the copy constructor for the polygon class, and guess what, it solved the problem! :) Thanks to everyone who has been helping me out!</p>

<p>The copy constructor for the polygon class looks like this:</p>

<pre><code>CPolygon::CPolygon(const CPolygon &amp; polygon) :
    nrOfPoints(polygon.nrOfPoints)
{
    points = new CPoint[nrOfPoints];

    // Add all the points from the polygon to be copied
    for(int i = 0; i &lt; nrOfPoints; i++) {
        points[i] = polygon.points[i];
    }
}
</code></pre>
",1
19802025,19801681,-1,"<p>Your best bet similar to above like what JBarberU said is a linked list. However if you would like it to be indexed you could create a dynamic array class that has a size and a capacity, every time you add a string to the array increment the size and if you are going to add to the array and it would exceed the size then create a new array, twice as large and copy all of the values over.</p>
",1
19801927,19801681,1,"<p>If you only need a stack-like container (where the only useful operations are pushing, poping and possibly iterating) you might want to use a linked list instead of an indexed one.</p>

<p>More on linked lists <a href=""http://www.cplusplus.com/articles/Lw6AC542"" rel=""nofollow"">here</a></p>

<p>Otherwise you'll have to expand the list and copy all objects from the old list to the new one whenever you ""grow out"" of the current list.</p>
",1
19801755,19801681,1,"<p><code>str container[10];</code> is a fixed size array of ten strings. This means your class will have 10 strings in it even if you haven't added any yet.</p>

<p>You might want consider using a <code>std::vector</code> to store your strings in, inside your class. This will allow you to grow and shrink the container as you see fit.</p>

<p>However if you're going to use a stl container inside your class, I don't see why you wouldn't just using a <code>std::list</code> to start with.</p>
",1
19802101,19801681,0,"<p>Arrays are static data structures, meaning they have fixed data size. You can either allocate dynamically memory by creating &amp; using the appropriate data structure for your cause, OR (recommended) you can use STL's Generic classes, such as <em>vector, list, map</em>, etc.</p>
",0
19802655,19801681,0,"<blockquote>
  <p>It seems that if I change the value of the data member N, the size of the array reallocates to that size. I thought that since the array was created when the object was created the array won't change sizes but after writing and running some functions it is doing exactly that.</p>
</blockquote>

<p>Unless I'm misunderstanding you, it sounds like you mean that you get the desired behavior simply by increasing N.</p>

<p>If you don't reallocate the array to the new size you'll end up with undefined behavior, sometimes working and sometimes crashing. Should another object be assigned the space right behind your array it'll be overwritten if you keep adding elements to your list.</p>
",1
18337234,18337127,0,"<p>you can do </p>

<pre><code>float quo=(float)num/num2;
printf(""%f\n"", quo);
</code></pre>

<p>and print the exact result</p>

<p>if you want random numbers that are divideable between themselves then you want something else. </p>

<p>also you don't initiate <code>num</code> before <code>num/num2;</code> and you don't check if num2 is zero so you might get thrown.</p>

<p>finaaly you can do something like</p>

<pre><code>num2=rand()%10;
num=rand();
while((float)num/num2 != (float)(num/num2))
    num=rand();
int quo=num/num2;
</code></pre>

<p>if absolutly can accept only divideable couples</p>
",0
18337410,18337127,0,"<p>Test with the modulus operator:</p>

<pre><code>int test, result;

test = 6%3;  //test == 0
if(test == 0) result = 6/3; //test passes, assignment made

test = 7%3; //test == 1
if(test == 0) result = 7/3; //test fails, assignment not made
</code></pre>

<p>This will guarantee ratios resulting in integer values .  </p>

<p><em><strong>Also</em></strong>, a random generator function may make things easier, something like this:</p>

<pre><code>int randGenerator(int min, int max)
{
    int random, trying;

    trying = 1;         
    while(trying)
    {
        srand(clock());
        random = (rand()/32767.0)*(max+1);
        (random &gt;= min) ? (trying = 0) : (trying = 1);
    }
    return random;
}
</code></pre>
",1
18337594,18337127,3,"<p>You can just pick a random result and create the question</p>

<pre><code>denominator = 14 (randomly chosen)
result = 21 (randomly chosen)

numerator = denominator * result
</code></pre>

<p>you then ask how much is <code>numerator / denominator</code></p>
",0
18337629,18337127,1,"<p>Simply:</p>

<pre><code>num2=rand()%9+1;
quo=rand()%10;
num = quo * num2;
printf(""\n%d / %d = "",num,num2);
</code></pre>

<p>Also, you should move the <code>srand()</code> call to <em>before</em> of the loop.  Otherwise if somebody answers a question too quickly they'll get the same question again.</p>
",0
19795685,19795449,3,"<p>From C++ ISO/IEC 2011</p>

<blockquote>
  <p>An enumerator declared in class scope can be referred to using the
  class member access operators (::, . (dot) and -> (arrow)),</p>
</blockquote>
",5
19796190,19795449,2,"<p>The enum values are treated much as if they were static members
of the class, and can be accessed in two ways: via the class
name followed by the scope resolution operator
(<code>MyClass::MY_VALUE0</code>), or like any other member
(<code>instance.MY_VALUE0</code> or <code>pointer-&gt;MY_VALUE0</code>).</p>

<p>Note that in the latter case, the operand on the left is still
evaluated, even though the results of the evaluation is not
used.  In other words, if I write <code>f()-&gt;MY_VALUE0</code> (where <code>f()</code>
returns a <code>MyClass*</code>), the function will be called, despite the
fact that its return value is not used.</p>
",0
19796200,19795449,6,"<p>The <code>-&gt;</code> operator is (mostly) an abbreviation for <code>dereference</code> (<kbd>*</kbd>) and <code>selection</code> (<kbd>.</kbd>). In other words, <code>a-&gt;b</code> is the same as <code>(*(a)).b</code>. (&sect;5.2.5/2; See notes below).</p>

<p>The <kbd>.</kbd> syntax is class member access, as defined by &sect;5.2.5 [expr.ref]; the identifier on the right-hand side of the <kbd>.</kbd> can be a static or non-static data member, function, or <em>member enumerator</em> (paragraph 4 of the cited section). It cannot be a nested type. In this sense, member enumerators are syntactically similar to <code>static const</code> data members.</p>

<p>Notes: </p>

<ol>
<li><p>As &sect;13.5.6 clarifies, <code>a-&gt;b</code> is is subject to operator overloading. If <code>a</code> is not a pointer type, then <code>-&gt;</code> may be overloaded, in which case the expression is interpreted as <code>(a.operator-&gt;())-&gt;b</code>. Eventually, the sequence of overloaded <code>-&gt;</code> calls must result in a pointer type, at which point the interpretation of &sect;5.2.5/2 is applied.</p></li>
<li><p>An important difference between <code>Class::member</code> and <code>value.member</code> is that in the second case, <code>value</code> will be evaluated <em>even if that is unnecessary to resolve the value of <code>member</code></em>.</p></li>
</ol>
",2
20655618,20655341,6,"<p>It is probably so most of the time. However the C standard only requires <code>int</code> to be a signed integer at least 16 bits in size and <code>unsigned int</code> to be an unsigned integer at least 16 bits in size.</p>

<p>See: <a href=""http://en.wikipedia.org/wiki/C_data_types"">http://en.wikipedia.org/wiki/C_data_types</a></p>

<p>Especially:</p>

<blockquote>
  <p>The type int should be the integer type that the target processor is most efficient working with. This allows great flexibility: for example, all types can be 64-bit. However, several different integer width schemes (data models) are popular. This is because the data model defines how different programs communicate, a uniform data model is used within a given operating system application interface.</p>
</blockquote>
",0
18430309,18430245,9,"<p>C++ doesn't have general arbitrary-precision rational numbers implemented. The available numbers are size-limited integers and floating point numbers.</p>

<p>A floating point number (in the common IEEE format) is however an integer multiplied by an exact power of two (positive or negative).</p>

<p>Even numbers like <code>0.1 = 1/10</code> are impossible to represent exactly because the denominator is not a power of two.</p>

<p>So the answer is simple :-) ... any number you will face with C++ is rational, more than that is an integer multiplied by a (possibly negative) power of two.</p>

<p>There are libraries implementing arbitrary precision integers and rational numbers, but they're not part of standard C++.</p>

<p>C++, by default, can only manage rational numbers. Moreover it's a very specific subset of the rationals where</p>

<ol>
<li>The numerator is not too big in absolute value</li>
<li>The denominator is a power of two and it's not too big</li>
</ol>

<p>When you write</p>

<pre><code>double x = 1.0;
x = x / 10.0;
</code></pre>

<p>you get a result that is already outside of the capability of the C++ language because the denominator is not a power of two.
What the computer will do is storing into <code>x</code> a close approximation because <code>0.1</code> it's a number that cannot be stored exactly in IEEE double format.</p>
",3
18430341,18430245,0,"<p>Floating point numbers are an approximation of the number. It is accurate as best that it can do with the limited amount of room to play in.</p>

<p>So the best bet is to limit the effect of both. It is called algebra. Also enables one to reduce round errors.</p>
",0
18414141,18413516,0,"<p>Nothing gets 'deleted'. The stack is popped. Period. As the struct doesn't have a destructor, nothing else happens.</p>
",0
19966646,19966625,2,"<p>In C and C++, <code>char</code>s or <code>char*</code> don't have member functions. Instead, you'd use <code>std::replace()</code> in C++:</p>

<pre><code>std::replace(string, string + strlen(string), ' ', '-');
</code></pre>

<p>Following the comment below: In case you can't use <code>std::replace()</code>, here is code which has the same effect:</p>

<pre><code>while (*space == ' '? (*space++ = '-'): *space++);
</code></pre>
",1
19966933,19966625,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;string.h&gt;

int main()
{
    char string[100], *space;
    {
    printf(""Enter a string here: \n""); //Enter a string in command prompt
    gets(string); //scans it and places it into a string
    space = string;

    while (*space == ' '? (*space = '-'): *space++);
    printf(""%s\n"", space);
    }
    getchar();
}
</code></pre>

<p>Did what you suggested but It still doesn't work. It does compile though</p>
",1
19803031,19802971,2,"<p>If you reach the end of the file, <code>eofbit</code> is set.  If <code>eofbit</code> is set, and a read operation is attempted, <code>failbit</code> is set. Therefore, if a read operation is attempted after reaching the end of the file, <code>failbit</code> is set, which explains why the ""read until end of file"" idiom works.</p>
",2
18680510,18680479,2,"<p>The problem is the <code>return</code>. The first time the <code>if</code> statement is true, the <code>return</code> statement executes, returning from the current function. Presumably, you intended it to just be <code>array[i] = ""open"";</code></p>

<p>As far as the <code>else</code> goes, from your description you want something like:</p>

<pre><code>else if (array[i] == ""open"")
    array[i] = ""close"";
</code></pre>

<p>Personally, I think I'd change it to use numbers instead, with the associated strings stored separately:</p>

<pre><code>enum { OPEN, CLOSE };
static const int names[] = {""open"", ""close""};
</code></pre>

<p>Then you can convert <code>OPEN</code> to <code>CLOSE</code> and vice versa with something like:</p>

<pre><code>for (int &amp;i : arr)
    i = 1 - i;
</code></pre>
",1
18680520,18680479,1,"<p>Try:</p>

<pre><code>void getValue(vector&lt;string&gt; &amp;arr)
{
    for(int i=0; i &lt;arr.size(); i++)
    {
        if(arr[i]==""close"")
        {
          arr[i]=""open"";
        }
        else if(arr[i]==""open"")
        {
          arr[i]=""close"";
        }
    }
}
</code></pre>
",6
18628705,18628613,1,"<p><code>cin &gt;&gt; d1 &gt;&gt; d2;</code> reads the input as decimal. <code>scanf(""%lx %lx"", &amp;d1, &amp;d2);</code> reads the input as hexadecimal.</p>

<p>If you want to read the input as hexadecimal with <code>iostream</code>, you probably want to use the <code>std::hex</code> manipulator, something like: <code>cin &gt;&gt; hex &gt;&gt; d1 &gt;&gt; d2;</code></p>

<p>Note that the <code>hex</code> bit is ""sticky"", so it'll remain set until you specify another base. That means the one <code>hex</code> affects both when you read <code>d1</code> and <code>d2</code> above -- but it also means if you read something else afterwards, it'll still read it as hex.</p>
",1
18630018,18628613,2,"<p>You need the two additional conditions because a six-sided die (cube) can be oriented one of 24 different ways. Your original algorithm was only checking 16 orientations (4 positions in <code>main</code> times 4 positions in <code>E</code> = 16) , and would therefore sometimes fail to detect equality. With the two new conditions you have 6 positions in <code>main</code> times 4 positions in <code>E</code>, for a total of 24. Note, however, that it isn't immediately obvious that the 24 orientations you generate are all distinct. (I think they probably are, but I didn't take the time to verify it.)</p>
",0
18861800,18861676,3,"<p>@ausairman Boost Serialization very much <strong><em>does</em></strong> work with smart pointers:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/9944274/boost-serialize-and-stdshared-ptr/9944617#9944617"">boost serialize and std::shared_ptr</a></li>
</ul>



<pre><code>#include &lt;boost/serialization/shared_ptr.hpp&gt;
</code></pre>

<p>The samples (<a href=""http://www.boost.org/doc/libs/1_49_0/libs/serialization/doc/tutorial.html#examples"" rel=""nofollow noreferrer"">http://www.boost.org/doc/libs/1_49_0/libs/serialization/doc/tutorial.html#examples</a>) show this. Also, the example makes it look like aliasing and cycles are taken care of by default.</p>

<p>Since you mention straightup that endianness and other portability concerns confuse you, I very heartily suggest you do not write this yourself (unless it is purely with the goal of learning).</p>
",1
18861813,18861676,3,"<p>If you are interested in something that is not platform dependent and will store your values in memory with the same format that you wish to serialize, consider Cap'n Proto, which is written by the same author as Google's Protobuffers 2.0.</p>

<p>I am not sure whether smart pointers are used, and you might have to rewrite your objects to be backed by the Cap'n proto structs instead of primitive values, but this seems closest to what you want.</p>

<p><a href=""http://kentonv.github.io/capnproto/"" rel=""nofollow"">http://kentonv.github.io/capnproto/</a></p>
",5
18606146,18605916,2,"<p>I spotted a bug here</p>

<pre><code>hour_degree = hour * 30 + float(minute / 2);
</code></pre>

<p>You are doing integer division, and it goes wrong if <code>minute</code> is odd number. It should be</p>

<pre><code>hour_degree = hour * 30 + float(minute / 2.0);
</code></pre>
",2
19372700,19372635,0,"<p>The third note line spells out the problem:</p>

<blockquote>
  <p><code>DynamicArray.h:150:10: note:   no known conversion for argument 1 from const char [5] to std::basic_string&lt;char&gt;&amp;</code></p>
</blockquote>

<p>So, your <code>DynamicArray&lt;string&gt;</code> is trying to convert a string literal into a <code>std::string &amp;</code>, and there is no way to do that.</p>

<p>You can do as you tried, create the <code>string</code> before hand, or you can modify your <code>add()</code> method to not take a reference.</p>

<pre><code> template&lt;class T&gt;
 bool DynamicArray&lt;T&gt;::add(T element)
 {
     //...
</code></pre>

<p>This way, a copy is made for you on the stack, initialized by the string literal that will be passed to its constructor.</p>
",3
19372946,19372635,1,"<p>In the example below:</p>

<pre><code>#include &lt;type_traits&gt;

template &lt;class T&gt;
void foo( T&amp; arg )
{
  static_assert( std::is_same&lt;T&amp;, const char(&amp;)[6]&gt;::value, ""Must be same"" );
}

int main()
{
  foo( ""Hallo world"" );
  return 0;
}
</code></pre>

<p>the type is deduced as const char[6].  then becomes a reference to an array, and therefore has type:</p>

<p>const char (&amp;array)[6]</p>

<p>The name of an array (without qualification by operator []) decays to type char*, or in this case const char*:</p>

<pre><code>_array[_size] = &amp;element;
</code></pre>

<p>therefore taking its address, the type of the rhs here above becomes const char*<em>, and it is not possible to assign a variable of type const char</em>* to a variable of type char&amp; (which is returned by _array[size].</p>

<p>You could remedy this as follows:</p>

<pre><code>template&lt;class T&gt;
void DynamicArray&lt;T&gt;::add( const T&amp; element )
{
  if(_size == _capacity)
  {
    increaseCapacity(_capacity * 2);
  }
  _array[_size] = element;
  _size++;
}

//------ Added code --------
template&lt;class T&gt;
  template &lt;int N&gt; 
void DynamicArray&lt;T&gt;::add( const T (&amp;array) [N] )
{
  for( std::size_t i = 0; i &lt; N; ++i )
  {
    //Calls your add per element...
    add( array[i] );
  }
}
</code></pre>

<p>Note that you will not be able to use std::string in the code here above. For this another overload would be required. Also note that my functions have no return type (as yours did). The return type had no purpose in your code, as any errors (as result of e.g dynamic allocation) would have thrown.</p>

<p>Lastly, as mentioned elsewhere, the code here above are merely written to understand concepts. In reality one would use a std::vector, which is of course already a dynamic array.</p>
",9
20626412,20626109,2,"<p>The class definition lacks a semicolon at the end.</p>

<hr>

<p>Other comments:</p>

<ul>
<li><p>To avoid name collisions (e.g. with <code>std::distance</code>), do not put a <code>using namespace std;</code> in the global namespace in a header.</p></li>
<li><p><code>&lt;stdafx.h&gt;</code> is a non-standard header, defined in your Visual Studio project, which makes that code dependent on Visual Studio. You can avoid it by turning off ""precompiled headers"" in the project settings.</p></li>
</ul>
",0
19507196,19503161,0,"<p>It is possible to prevent this newline behavior by inputting two EOFs instead of Carriage Return from the keyboard. After entering your string at the console prompt, hit</p>

<blockquote>
  <p>CTRL-D, CTRL-D</p>
</blockquote>

<p>Note, this is a platform specific answer. This works on my Mac, but on Windows OS the EOF sequence may be CTRL-Z, RETURN. I would appreciate an answer edit &lt;-- HERE.</p>

<p>Alternately, you can ditch the >> operator and use something like std::getline and specify an exact string termination delimiter. For example:</p>

<pre><code>std::string myString;
std::getline(std::cin, myString, ';');
std::cout &lt;&lt; myString;
</code></pre>

<p>This will read from standard input to <code>myString</code>, and put the string terminating NULL character where it finds the first semicolon <code>';'</code>. Then you'll only have to hit CTRL-D (input EOF) once.</p>
",0
19507338,19503161,0,"<p>You can enter the values or input by pressing space every time. But at the end you must press enter key.<br>
Let's say: you want to enter ""5,4,3,2,1""<br>
You can do:  <code>5 [enter] 4 [enter] 3[enter] 2[enter] 1[enter]</code><br>
Also: <code>5[space]4[space]3[space]2[space]1[enter]</code><br>
But if you want to print the output near input, you can simply print the input first and than you can print the what you want.<br>
Example:<br>
Input: <code>3</code> Output: <code>input+1</code><br>
So you will do:  </p>

<pre><code>cout&lt;&lt;input;
cout&lt;&lt;"" ""&lt;&lt;input+1&lt;&lt;endl;
</code></pre>

<p>Good luck :)</p>
",0
19507368,19503161,0,"<p>You cannot prevent <code>newline</code> character, because when you use <code>cin</code>, you are communicating with <code>system core</code>, which is not under control by users. <code>console</code> will return, when you enter <code>\n</code> or <code>EOF</code> or other exception situation.
So the better way is to use <code>getchar()</code> to capture the '\n', and do not leave it in <code>buffer</code>.</p>
",0
19259016,19258685,1,"<p>Look at this line in your main.cpp:</p>

<p><code>Employee.ReadFile(**MyinFile, FirstName, LastName, Salary**); //undeclared identifier error</code></p>

<p>Where did <code>FirstName</code>, <code>LastName</code>, and <code>Salary</code> come from? They were never declared in the scope of <code>int main()</code>. This is why you have undeclared identifier errors. </p>

<p>I'm not sure why your <code>Employee::ReadFile</code> member function takes those last three arguments. It should read in from a file and set <code>this.FirstName</code>, etc, not the arguments that have been passed into the function. </p>

<p>This should get you more on the right track:</p>

<pre><code>// In header file, replace ReadFile prototype with:
void ReadFile(ifstream&amp; MyinFile);

// In implementation file, replace ReadFile with:

void ReadFile(ifstream&amp; MyinFile)
{
    char exit_char;
    int MaxSize;
    int count = 0;

    MyinFile.open(""employee.dat""); 
        if (!MyinFile)
        {    //no
            cout &lt;&lt; ""Can't open input file."" &lt;&lt; endl; //Tests the right file.
            char exit_char;                         //End Program
            cout &lt;&lt; ""Press any key to exit"" &lt;&lt; endl;
            cin &gt;&gt; exit_char;
        }
        for(count = 0; count &lt; MaxSize; count++)
        {
            MyinFile &gt;&gt; this-&gt;LastName;
            MyinFile &gt;&gt; this-&gt;FirstName;
            MyinFile &gt;&gt; this-&gt;Salary;
        }
    MyinFile.close();
    }

// In main.cpp, replace the current call to Employee.ReadFile with:
Employee.ReadFile(MyinFile);
</code></pre>

<p>This probably will not solve all of your issues but it is a start. </p>
",8
19260417,19258685,2,"<ul>
<li>It looks like you need to do a lot of work to improve your code. First, you should put all your header files on Employee.h. This will be useful wherever you decide to include Employee.h, all of its header files will also be included, so you do not have to included them again.  </li>
<li>In C++ you can define your variables as pointers or reference. Please learn the difference between pointers (*pointer), double pointers <em>(</em>**doublepointer) also known as array pointer, reference (&amp;reference) and variables (variable). You should also learn about making a dereference to a pointer such as pointer (**pointer).</li>
<li>Learn the deference between a class, a function or a variable <strong>Definition</strong> and its <strong>Declaration.</strong> This is important especially with your current assignment problem. </li>
<li>You have an Employee class and if you are a starter; Header files are used for constructor, destructor, member variables and member functions definition. Whereas the .cpp files are used for constructor, member functions and non-member functions declaration. Most of the time a declaration for destructor does not include anything much, however this is where you delete pointers. </li>
<li>In C++ you have to manage memory, otherwise you will have memory leaks with your pointers. So whenever you define a pointer (*pointer) you should delete it on your destructor. You are missing a destructor in your header file. You need to define one. </li>
<li><p>You should define and/or declare the constructor in your header file like this. There is really no point of calling SetFirstName(), setLastName(), setSalary() in your constructor. These methods should be used only in the MAIN class. And to set class member variables, do this.</p>

<pre><code>Employee( string FirstName, string LastName, float Salary )
this.FirstName = FirstName;
this.LastName = LastName;
this.Salary = Salary;
</code></pre>

<p>}</p></li>
<li><p>Include a class destructor</p>

<pre><code>~Employee(){
}
</code></pre></li>
<li><p>Your SET functions are meant to set member variables only and should not return anything. Instead of returning a string they should be void. Like this.</p></li>
<li><p>Set functions definition.</p>

<p>void setFirstName(string FirstName);<br>
void setLastName(string LastName);<br>
void setSalary(float Salary);</p></li>
<li><p>Define and declare GET functions.  </p>

<p>string getFirstName() { return FirstName;}<br>
string getLastName() { return LastName;}<br>
float getSalary() { return Salary;}     </p></li>
<li><p>In your .cpp files you should declare your set functions among other member functions you have defined so far in your Employee class. Like this.    </p>

<p>void Employee::setFirstName(string FirstName){<br>
FirstName = FirstName;<br>
}<br>
void Employee::setLastName(string LastName){<br>
LastName = LastName;<br>
}<br>
void Employee::setSalary(float Salary){<br>
Salary = Salary;<br>
}  </p></li>
<li><p>This Readfile function reads a file of this format example; first line; John Garry 100.50, next line; Michael Shawn 250.80 etc. And stores it in a vector of Employees.     </p>

<p>typedef std::vector &lt; Employee > EmployeeType<br>
EmployeeType account;</p>

<p>void ReadFile(ifstream&amp; MyinFile, string FirstName, string LastName, float Salary) {<br>
string st;<br>
float n;</p>

<p>while(MyinFile >> st) {<br>
this.setFirstName(st);<br>
this.setLastName(MyinFile >> st);<br>
this.setSalary(MyinFile >> n);<br>
account.push_back(this);<br>
}</p></li>
<li><p>Search employee function. It searches by the First Name only.</p></li>
<li><p>You should also learn about arrays and array pointers in C++. </p>

<p>string Employee::EmployeeSearch(string LastName, string FirstName) {      </p>

<p>cout &lt;&lt; ""Please enter the name of the employee you would like to search."" &lt;&lt;  endl;<br>
cin >> SearchName;<br>
string st = ""No Such Employee"";<br>
string s = "" "";</p>

<p>Employee *employ;</p>

<p>for(int i = 0; i &lt; account.size(); i++){<br>
employ = account.at(i);<br>
if(SearchName == employ->getFirstName()){<br>
std::cout &lt;&lt; employ->getFirstName() &lt;&lt; "" "" &lt;&lt; employ->getLastName() &lt;&lt; "" "" &lt;&lt; employ->getSalary() &lt;&lt; endl;<br>
st = """";</p>

<p>st.append(employ.getFirstName());<br>
st.append(s);<br>
st.append(employ.getLastName());<br>
st.append(s);             </p>

<p>std::ostringstream ss;<br>
ss &lt;&lt; employ.getSalary();<br>
string so(ss.str());<br>
st.append(so);<br>
return st;<br>
}<br>
}
return st;</p>

<p>}</p></li>
</ul>
",0
19259441,19259418,1,"<p><code>atoi()</code> wants a <code>char *</code>, not a <code>string</code>:</p>

<pre><code>result = atoi(line.c_str());
</code></pre>
",0
19259448,19259418,1,"<p>You can use </p>

<pre><code>result = atoi(line.c_str());
</code></pre>
",0
19259465,19259418,7,"<p><code>atoi</code> is a C function that accepts a C-string, not a C++ <code>std::string</code>. You need to obtain the raw <code>char*</code> from the string object to use as the argument. The method for this is <code>.c_str()</code>:</p>

<blockquote>
<pre><code>atoi(line.c_str());
</code></pre>
</blockquote>

<p>The C++ equivalent of <code>atoi</code> is <a href=""http://en.cppreference.com/w/cpp/string/basic_string/stol"" rel=""nofollow""><code>std::stoi</code></a> (C++11):</p>

<blockquote>
<pre><code>std::stoi(line);
</code></pre>
</blockquote>

<p>Moreover, <code>while (!file.eof())</code> is considered a bad practice. It's better to do the I/O operation inside the expression so the stream object is returned and valid file conditions are assessed thereafter:</p>

<blockquote>
<pre><code>while (std::getline(myfile, line))
</code></pre>
</blockquote>

<p>Your code can be improved further, however. Here is how I would do it:</p>

<blockquote>
<pre><code>#include &lt;vector&gt;

void readf1()
{
    std::vector&lt;int&gt; myintArray;

    std::string line;
    std::ifstream myfile(""f1.txt"");

    for (int result; std::getline(myfile, line); result = std::stoi(line))
    {
        myintArray.push_back(result);

        std::cout &lt;&lt; ""Read in the number: "" &lt;&lt; result &lt;&lt; ""\n\n"";
    }
}
</code></pre>
</blockquote>
",1
18604097,18600010,2,"<p>The only time you would manually call a destructor is when you've got grounds to use <a href=""http://www.parashift.com/c++-faq/placement-new.html"" rel=""nofollow"">placement new</a></p>
",0
18604464,18600010,0,"<p>i would like to answer my own question.</p>

<p>after a lot of reading, Here is my summary.</p>

<pre><code>1. destructor doesnt destroy  it's object.  the object stays at stack
until out of scope.
2. nothing can destroy a stack object. 
3. the destructor did destroy RESOURCE inside the object.
</code></pre>

<p>sample code:</p>

<pre><code> struct B {
   B() {happy=""today is a good day""; hour = 7;}
  ~B() {puts(""BBBB"");}
   std::string happy;
   int hour;
   };

int main()
{
    B b;
    std::cout &lt;&lt; b.happy &lt;&lt; b.hour &lt;&lt;std::endl;
    b.~B();
    std::cout &lt;&lt; b.happy &lt;&lt; b.hour &lt;&lt;std::endl;

}
</code></pre>

<p>output:</p>

<pre><code>today is a good day7
BBBB
7
BBBB
</code></pre>

<p>we can see a resource b.happy is gone after b.~B() is called. this is a proof of my point 3.</p>

<p>you see the b.hour(int type is not a resource) is still here. this is a proof of my point 1.  </p>
",1
18864991,18864944,0,"<p>Yes you are correct in your assumption, the variable int *n itself has a unique address which you can get with &amp;n</p>
",1
19874600,19864099,3,"<p>It looks like your Debug build is set as Ansi and your release build as Unicode.</p>

<p>The <code>_tmain</code> declaration is a Visual Studio specific macro which changes the entry point of your application depending on the used charset.</p>

<p>For ANSI it maps to <code>int main(int argc, char *argv[])</code> .<br>
For Unicode it maps to <code>int wmain(int argc, wchar_t *argv[])</code>.</p>

<p>By using the <code>char</code> type as parameter to _tmain, you cause the compiler to use the wrong type when using an Unicode build, and so end up with a <code>'\0'</code> character as first byte, which std::string can't handle.</p>

<p>In your case, I recommend sticking to <code>int main(int argc, char *argv[])</code> as it will work in all cases, especially with std::string which use chars.</p>

<p>Also, it is more portable across compilers and operating systems.</p>
",0
18769152,18768840,3,"<p>The two candidate loops could be written (are equivalent to):</p>

<pre><code>while (number-- != 0)
while (--number != 0)
</code></pre>

<p>Consider what happens when <code>number == 1</code> at loop entry:</p>

<ol>
<li>The value of <code>number</code> is compared to zero and then decremented; since <code>1</code> is not <code>0</code>, the loop body is executed.</li>
<li>The value of <code>number</code> is decremented and then compared to zero; since <code>0</code> is <code>0</code>, the loop body is <em>not</em> executed.</li>
</ol>

<p>That's the difference!</p>
",0
18769190,18768840,1,"<p>This is a horrible way to write code, but...</p>

<p>An expression has two characteristics: a return value, and side
effects.  The decrementation is the side effect; it is the same
for <code>--number</code> and <code>number--</code>.  The condition in the <code>while</code>,
however, depends on the return value; <code>--number</code> returns the
value after the decrementation; <code>number--</code> the value <em>before</em>
the decrementation.  When the decrementation actually takes
place on the variable is not really specified (for either): some
time after the preceding sequence point and before the following
one. </p>

<p>In other words: <code>--number</code> is the equivalent of:</p>

<pre><code>int
decr( int&amp; number )
{
    number -= 1;
    int results = number;
    return results;
}
</code></pre>

<p>and <code>number--</code> is the equivalent of:</p>

<pre><code>int
decr( int&amp; number )
{
    int results = number;
    number -= 1;
    return return;
}
</code></pre>

<p>In both cases, you're testing the return value of the function.</p>
",0
18769197,18768840,2,"<p><code>while (number--)</code> does the following:</p>

<ol>
<li>evaluate <code>while (number)</code></li>
<li>then <code>number--</code></li>
</ol>

<p>On the other hand <code>while (--number)</code> does this:</p>

<ol>
<li>calculate <code>--number</code></li>
<li>then evaluate <code>while (number)</code> <strong>with the new value</strong></li>
</ol>

<p>And that's the difference.</p>
",0
18861472,18861423,3,"<ol>
<li><p><code>if(v == ""word"")</code> - you are trying to compare your vector <code>v</code> with a ""word"" string. The input is stored in a <code>word</code> variable. If your word to count is ""word"", then it should be <code>if(word == ""word"")</code>.</p></li>
<li><p>You don't need to <code>push_back</code> your words - you know perfectly well they are all the same, right? Instead make a counter variable and increment it each time the desired word is encountered.</p></li>
</ol>

<p>These ideas should get you started.</p>
",2
18861511,18861423,1,"<p>The v == ""word"" doesn't make sense to me. v is a vector, correct? If so, v == ""word"" is comparing a vector of Strings to a string, which doesn't work.</p>

<p>I would personally suggest using a map or dictionary.
Here's documentation on c++ maps. Amazing data structures 0.0</p>

<p><a href=""http://en.cppreference.com/w/cpp/container/map"" rel=""nofollow"">http://en.cppreference.com/w/cpp/container/map</a></p>

<p>The way I did a similar exercise when in University was like so:</p>

<pre><code>//Pseudocode activate
Map&lt;string, int&gt; my_map = new Map();
String word;
while(there is input){
    my_map.at(word)++;
}

for all entries in my_map{
    print my_map keys: my_map values
}
</code></pre>
",0
18861691,18861423,0,"<p>If you just need to count the number of ""word"", you can use something like:</p>

<pre><code>int count = -1;
do
{
cout &lt;&lt; ""Word: "";
cin &gt;&gt; word;
count++;
system(""cls"");
}while(condition)
printf(""Result:%d"", cout);
</code></pre>

<p>and a count to get the number of condition == true</p>
",0
20526267,20526140,4,"<p>You're returning a pointer to a local array, which is destroyed when the function returns. The best solution is to return a string object:</p>

<pre><code>std::string read_word() {
    std::string input;
    std::cin &gt;&gt; input;
    return input;
}
</code></pre>

<p>Note that I also changed the function name to match what it does. If you actually want a line, then you want</p>

<pre><code>std::string read_line() {
    std::string input;
    std::get_line(std::cin, input);
    return input;
}
</code></pre>

<p>If you really think you want to return a pointer, then think again. You almost certainly don't.</p>

<p>If you still really think you do, then you could return a pointer to a static variable, which lasts as long as the program:</p>

<pre><code>// Danger: the returned pointer is only valid until the next call.
// Danger: do not call from multiple threads.
// Danger: any line longer than 255 characters will cause dreadful calamity.
char const * read_line() {
    static char input[256];
    std::cin.getline(input);
    return input;
}
</code></pre>

<p>or dynamically allocate an array, and hope the caller remembers to delete it:</p>

<pre><code>// Danger: the returned pointer must be deleted (with `delete[]`) after use
// Danger: any line longer than 255 characters will cause dreadful calamity.
char const * read_line() {
    char * input = new char[256];
    std::cin.getline(input);
    return input;
}
</code></pre>
",0
18937926,18937877,2,"<p><code>Securtiy</code> is a misspelling in your Security.cpp file.</p>
",1
18937951,18937877,2,"<p>You should compile both files, because the definition of Security::Driver is in Security.cpp.</p>

<p>The easiest way would be to invoke a single command:</p>

<p><code>g++ Main.cpp Security.cpp</code></p>

<p>However, if you want to compile the files separately, you must compile them into an intermediate ('object') format using <code>-c</code> flag:</p>

<pre><code>g++ -c Main.cpp
g++ -c Security.cpp
</code></pre>

<p>This will give you two object files. Now link them:</p>

<pre><code>g++ Main.o Security.o
</code></pre>
",0
20415446,20415400,1,"<p>Don't define the member function in the class. Define it after the two classes have been defined.</p>
",6
20415497,20415400,1,"<p>In this specific case, just put the implementations of class <code>object</code> in a separate cpp file, leave only declarations in the header.</p>
",2
20415746,20415400,0,"<p>Do you need the exception class to inherit from the object class?  You can define the exception class before the object class in your header file if you don't want separate cpp files.</p>

<pre><code>    class exception {  
        private:
        public:
            exception();
            // rest of your code
    };

    class object {
        public:
            virtual ~object() {}
            virtual bool equals() { throw exception(); }
            // rest of your code
    };
</code></pre>
",1
19786460,19786329,4,"<p>Your <code>#undef</code> makes me suspicious that this header is being included elsewhere (e.g by <code>ChallengeManager.cpp</code>, meaning you'll end up with your <code>_correctAnswers</code> having a size of <code>500</code> in some places and <code>1</code> in others, which would certainly explain your crash.</p>

<p>(edit): Are your tests a separate project in the solution, with the main code in its own project, or is your code all compiled directly in the test project?</p>

<p>To be safe, set your <code>#define</code> in the VS build configuration (for all projects being linked into the tests - you'll need to add a Tests build config for this, and use it instead of Debug/Release for the test build) rather than defining it in code, and remove the <code>#undef</code></p>
",9
19787162,19786329,1,"<p>I tend not to have <code>if defined</code> sections within code, especially class code.  I would tend to use a variable, and branch based on its value:</p>

<p>in the test class remove the <code>#define RedefChallangesCount</code> and replace with a global variable of <code>bool RedefChallangesCount</code></p>

<p>Then your code becomes much simpler and can be as follows (simplified version for demonstration purposes):</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;
bool RedefChallangesCount = false;
int main()
{
    int ChallangesCount;
    cout &lt;&lt; RedefChallangesCount &lt;&lt; endl;
    if (RedefChallangesCount)
        ChallangesCount = 500;
    else
        ChallangesCount = 1;

   cout &lt;&lt; ChallangesCount &lt;&lt; endl; 

   return 0;
}
</code></pre>

<p>as opposed to:</p>

<pre><code>#if defined(RedefChallangesCount)
    static const mainDataType ChallangesCount = 500;
    #undef RedefChallangesCount
#else
    static const mainDataType ChallangesCount = 1;
#endif
</code></pre>

<p>However, let me know if using preprocessor is a requirement and then I can try and sort you out a solution using that methodology, though as I said, I don't use preprocessor directives for actual program flow (have to add <em>normally</em>, as guaranteed I have done it once for a valid reason, and cant remember).</p>
",2
19215059,19215027,85,"<p>In C++ you would use <code>std::find</code>, and check if the resultant pointer points to the end of the range, like this:</p>

<pre><code>Foo array[10];
... // Init the array here
Foo *foo = std::find(std::begin(array), std::end(array), someObject);
// When the element is not found, std::find returns the end of the range
if (foo != std::end(array)) {
    cerr &lt;&lt; ""Found at position "" &lt;&lt; std::distance(array, foo) &lt;&lt; endl;
} else {
    cerr &lt;&lt; ""Not found"" &lt;&lt; endl;
}
</code></pre>
",5
19215061,19215027,-6,"<p>C++ has NULL as well, often the same as 0 (pointer to address 0x00000000).</p>

<p><a href=""https://stackoverflow.com/questions/176989/do-you-use-null-or-0-zero-for-pointers-in-c"">Do you use NULL or 0 (zero) for pointers in C++?</a></p>

<p>So in C++ that null check would be:</p>

<pre><code> if (!foo)
    cout &lt;&lt; ""not found"";
</code></pre>
",2
19215070,19215027,12,"<p>You would just do the same thing, looping through the array to search for the term you want. Of course if it's a sorted array this would be much faster, so something similar to prehaps:</p>

<pre><code>for(int i = 0; i &lt; arraySize; i++){
     if(array[i] == itemToFind){
         break;
     }
}
</code></pre>
",1
19215096,19215027,10,"<p>There are many ways...one is to use the <code>std::find()</code> algorithm, e.g.</p>

<pre><code>#include &lt;algorithm&gt;

int myArray[] = { 3, 2, 1, 0, 1, 2, 3 };
size_t myArraySize = sizeof(myArray) / sizeof(int);
int *end = myArray + myArraySize;
// find the value 0:
int *result = std::find(myArray, end, 0);
if (result != end) {
  // found value at ""result"" pointer location...
}
</code></pre>
",0
19215729,19215625,0,"<p>It isn't 'necessary', but it's a very good idea, for several reasons:</p>

<ol>
<li>Efficiency. Not creating or destroying new strings is more efficient than creating and destroying them, especially as strings are arbitrary in length and therefore require dynamically allocated memory.</li>
<li>A <code>string</code> can be constructed from a string literal. If you specify <code>const</code> you allow the compiler to construct a temporary <code>string</code> from a literal so that the caller can just provide the literal rather than the <code>string</code> object. If you don't specify <code>const</code> the compiler can't do that, so the caller can't do that either.</li>
</ol>
",1
19215645,19215625,3,"<p>When you pass a variable by value, it makes a copy. Passing by reference avoids that copy. You want to mark it <code>const</code> for the same reason: Since you're not making a copy, you don't want to accidentally mess with the original. I think this could also potentially allow for compiler optimizations.</p>

<p>The reason you don't usually see this for <code>int</code>, <code>char</code>, <code>float</code>, and other primitive types is that they're relatively cheap to copy, and in some cases, passing by reference is more expensive (for example, passing a <code>char</code> by reference could involve passing 64-bits of data (the pointer) instead of 8-bits. Passing by reference also adds some indirection, which isn't a big deal with a big type like a string, but is wasteful for something like an <code>int</code>.</p>
",0
19215662,19215625,6,"<p>There are two alternatives to passing by reference - passing by pointer, and passing by value.</p>

<p>Passing by pointer is similar to passing by reference: the same argument of ""why pass a pointer if you do not want to modify it"" could be made for it.</p>

<p>Passing by value requires making a copy. Copying a string is usually more expensive, because dynamic memory needs to be allocated and de-allocated under the cover. That is why it is often a better idea to pass a <code>const</code> reference / pointer than passing a copy that you are not planning to change.</p>
",1
19215682,19215625,0,"<p>in other words, you would get the speed of passing by reference ( not making extra copies ).
and the integrity of passing by value ( the original variable value is not changed)</p>
",0
19217390,19215625,1,"<p>It is not ""necessary,"" but the common answer is ""for performance reasons, to prevent copying,"" however that is a naive answer and the truth is a bit more complex.</p>

<p>In your example, assuming <code>s</code> really is immutable and something you don't ""own or can't change,"" then the <code>const</code> decorator is appropriate for <code>s</code>. If the reference of <code>s</code> wasn't taken, then that would guarantee a copied (excluding compiler optimizations).</p>

<p>If <code>f()</code> is not going to use the copy of <code>s</code> after <code>f()</code> returns, then the effort of copying <code>s</code> was wasted. So, passing by reference prevents the copying and <code>f()</code> retains the ability to inspect the string <code>s</code>. Great. And again, that's the naive answer and pre-C++11, would be the mostly correct answer.</p>

<p>There are more scenarios worth considering in order to answer ""is it necessary?"" but I'll focus on just one:</p>

<blockquote>
  <p>If the caller of <code>f()</code> doesn't need the string <code>s</code> after invoking
  <code>f()</code>, but <code>f()</code> needs to retain a copy of the data.</p>
</blockquote>

<p>Suppose the code is:</p>

<pre><code>void f(const std::string&amp; arg1);   // f()'s signature
void g(const std::string&amp; arg1) {
   std::string s(arg1);
   s.append("" mutate s"");
   f(s);
}
</code></pre>

<p>In this case, you would have constructed the string <code>s</code>, passed it by <code>const</code> reference to <code>f()</code>, and everything is fine from a performance perspective if you assume <code>f()</code> is opaque and there are no further optimizations available.</p>

<p>Now, suppose <code>f()</code> needs a copy of the data in <code>s</code>, then what? Well, <code>f()</code> will call a copy constructor and copy <code>s</code> in to a local variable:</p>

<pre><code> // Hypothetical f()
 void f(const std::string&amp; s) {
   this-&gt;someString_ = s;
 }
</code></pre>

<p>In this case, by the time the data is stored in <code>someString_</code>, the normal constructor will have been called in <code>g()</code>, and the copy ctor will have been called in <code>f()</code>, however the work done in <code>g()</code> will have been wasted. To improve performance, there are two things that can be done, pass by value and/or use move constructors.</p>

<pre><code>// Explicitly move arg1 in to someString_
void f(std::string&amp;&amp; arg1) {
  this-&gt;somestring_ = std::move(arg1);
}

void g(const std::string&amp; arg1) {
   std::string s(arg1);
   s.append("" mutate s"");
   f(s);
}
</code></pre>

<p>Which is explicitly doing what the compiler will automatically do starting with <code>C++11</code>, which means the more correct version is to pass by value and let the compiler do the right thing:</p>

<pre><code>void f(std::string arg1) {
  this-&gt;somestring_ = arg1; // Implicit move, let the compiler do the right thing
}

void g(const std::string&amp; arg1) {
   std::string s(arg1);
   s.append("" mutate s"");
   f(s);
}
</code></pre>

<p>And in this case, the string is constructed in <code>g()</code> and no additional work was done anywhere. So in this case, the answer to,</p>

<blockquote>
  <p>Why is it necessary to pass this by reference if you are not actually
  changing the string (since it is constant)?</p>
</blockquote>

<p>The string wasn't changed, but it was copied, and therefore <strong>const reference was not necessary</strong>.</p>

<p>It's an exercise for the reader to list the optimizations the compiler can take when <code>s</code> is or isn't mutated after the call to <code>f()</code>.</p>

<p>I can't recommend enough that people look in to David Abrams's post, '<a href=""http://webcache.googleusercontent.com/search?q=cache:GLdM1_YvqhEJ:cpp-next.com/archive/2009/08/want-speed-pass-by-value/%20&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=us"" rel=""nofollow noreferrer"">Want Speed? Pass by value</a>' or <a href=""https://stackoverflow.com/questions/270408/is-it-better-in-c-to-pass-by-value-or-pass-by-constant-reference"">Is it better in C++ to pass by value or pass by constant reference?</a> and post <a href=""https://stackoverflow.com/a/2139254/736571"">How to pass objects to functions in C++?</a>.</p>
",1
18980362,18974853,3,"<p><strong>Update</strong> Okay, my original answer here (see below) was somewhat joking. </p>

<p>So, here's a simple approach with just <code>vector</code>, <code>iostream</code> and <code>find_if</code>:</p>

<p>See it <strong><a href=""http://ideone.com/HMsaVl"" rel=""nofollow"">Live On IdeOne</a></strong></p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;

using namespace std;

struct entry {
    string name;
    unsigned quantity;
};

vector&lt;entry&gt; readData()
{
    vector&lt;entry&gt; data;

    string line, name;
    unsigned quantity;

    while (getline(cin, line) &amp;&amp; 
            istringstream(line) &gt;&gt; name &gt;&gt; quantity)
    {
        auto found = find_if(begin(data), end(data), [&amp;](entry const&amp; a) { return a.name == name; });
        if (end(data) == found)
            data.push_back({name, quantity});
        else
            found-&gt;quantity += quantity;
    }
    return data;
}

int main()
{
    vector&lt;entry&gt; const data = readData();
    for (auto it = data.begin(); it != data.end(); ++it)
        cout &lt;&lt; it-&gt;name &lt;&lt; "" "" &lt;&lt; it-&gt;quantity &lt;&lt; ""\n"";
}
</code></pre>

<hr>

<p>OLD ANSWER:</p>

<p>Because it's been ridiculously long since the last question was posted in the <a href=""/questions/tagged/boost-spirit"" class=""post-tag"" title=""show questions tagged 'boost-spirit'"" rel=""tag"">boost-spirit</a> tag, lemme just take this opportunity to <em>over-kill</em> this answer:</p>

<pre><code>#include &lt;boost/fusion/adapted/std_pair.hpp&gt;
#include &lt;boost/spirit/include/qi.hpp&gt;
#include &lt;boost/spirit/include/karma.hpp&gt;
#include &lt;boost/spirit/include/phoenix.hpp&gt;

namespace qi    = boost::spirit::qi;
namespace karma = boost::spirit::karma;
namespace phx   = boost::phoenix;

int main()
{
    std::map&lt;std::string, unsigned&gt; data;
    std::cin.unsetf(std::ios::skipws);

    {
        using namespace boost::spirit::qi;
        phrase_parse(
                boost::spirit::istream_iterator(std::cin), {},
                (as_string[+alpha] &gt;&gt; uint_) [ phx::ref(data)[_1] += _2 ] 
                % eol,
                blank);
    }

    std::cout &lt;&lt; ""Got #"" &lt;&lt; data.size() &lt;&lt; "" unique fruits\n"";

    {
        using namespace boost::spirit::karma;
        std::cout &lt;&lt; format(delimit(' ') [auto_] % eol, data);
    }
}
</code></pre>

<p>With input</p>

<pre><code>apple 5
pear 2
grape 6
mangoes 3
apple 2
mangoes 9
</code></pre>

<p>Prints</p>

<pre><code>Got #4 unique fruits
apple 7 
grape 6 
mangoes 12 
pear 2 
</code></pre>
",10
18984105,18983995,1,"<p>Here's an example of get/set methods:</p>

<pre><code>class account

{  public            
       int getA() const { return a; }
       void setA(int new_value) { a = new_value; }
       int getB() const { return b; }
       void setB(int new_value) { b = new_value; }
       int getC() const { return c; }
       void setC(int new_value) { c = new_value; }
       int getD() const { return d; }
       void setD(int new_value) { d = new_value; }

   private:
       int a;
       char b;
       int c;
       int d;
};
</code></pre>

<p>From the main you would use:</p>

<pre><code>int main()
{
  vector &lt;account&gt; data1 (0);
  account temp;
  int a,b,c,d;

  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
  temp.setA(a);
  temp.setB(b);
  temp.setC(c);
  temp.setD(d);
  data1.push_back(temp);

  return 0;
}
</code></pre>

<p>NOTE: Whether having get/set methods in a case like this is a good idea is another issue.</p>
",12
18984132,18983995,4,"<p>You should have a friend operator overload:</p>

<pre><code>class account
{
    friend std::istream&amp; operator&gt;&gt; (std::istream &amp;, account &amp;);
public:
    // ...
};

std::istream&amp; operator&gt;&gt; (std::istream&amp; is, account&amp; ac)
{
    return is &gt;&gt; ac.a &gt;&gt; ac.b &gt;&gt; ac.c &gt;&gt; ac.d;
}

int main()
{
    account temp;

    std::cin &gt;&gt; temp;
}
</code></pre>
",9
19217907,19217813,26,"<p>The solution is to use a &quot;proxy&quot; object that will delay the actual operation:</p>
<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;

template&lt;typename T&gt;
struct MyArray {
    std::vector&lt;T&gt; data;
    MyArray(int size) : data(size) {}

    struct Deref {
        MyArray&amp; a;
        int index;
        Deref(MyArray&amp; a, int index) : a(a), index(index) {}

        operator T() {
            std::cout &lt;&lt; &quot;reading\n&quot;; return a.data[index];
        }

        T&amp; operator=(const T&amp; other) {
            std::cout &lt;&lt; &quot;writing\n&quot;; return a.data[index] = other;
        }
   };

   Deref operator[](int index) {
       return Deref(*this, index);
   }
};

int main(int argc, const char *argv[]) {
    MyArray&lt;int&gt; foo(3);
    foo[1] = 42;
    std::cout &lt;&lt; &quot;Value is &quot; &lt;&lt; foo[1] &lt;&lt; &quot;\n&quot;;
    return 0;
}
</code></pre>
<p>Simple <code>const</code>-ness cannot be used because you may need to read from a non-const instance, that is the reason for which you must delay the operation: the assignment happens &quot;after&quot; the access and the compiler doesn't tell you if the access will be later used as a target for assignment or not.</p>
<p>The idea is therefore that on access you just store away the index that has been requested and wait to know if a reading or a writing operation is happening. By providing an implicit conversion operator from the proxy to <code>T</code> you know when a reading operation occurs, by providing an assignment operator to the proxy from <code>T</code> you know when writing occurs.</p>
",0
19217918,19217813,4,"<p>The <code>const</code> version means that if the object on which it is called is <code>const</code>, you are allowed to call that version of the <code>[]</code> operator, and only that version.</p>

<p>But if the object is not <code>const</code>, then both versions of the <code>[]</code> operator can be called, but the compiler will select the non-const version. In other words, for a non-const object, the non-const version of the operator can act as either the ""setter"" or ""getter"". This is why the same version is called in both cases in your example, because your <code>data</code> object is not const.</p>

<p>You would have to do something like this:</p>

<pre><code>const Data&amp; data_cref = data;
cout &lt;&lt; data_cref[5];  // calls the const version of operator[]

Data&amp; data_ref = data;
data_ref[5] = 1;       // calls the non-const version of operator[]
</code></pre>
",0
19217953,19217813,1,"<p>To be compatible with the ordinary meaning of subscript, the subscript operator usually returns a reference to the element that is fetched. <strong>By returning a reference, subscript can be used on either side of an assignment.</strong> </p>

<p>Consequently, it is also usually a good idea to define both const and nonconst versions of this operator. When applied to a object, subscript should return a reference to const so that it is assign to the returned object.</p>

<p>----C++ Primer, Fifth Edition</p>
",0
19217863,19217813,0,"<p><code>const</code> version of your <code>operator[]</code> will be called for <code>const</code> data object:</p>

<pre><code>const Data data;
cout &lt;&lt; data[5];
</code></pre>
",0
19215626,19215609,1,"<p>The return types of your <code>add</code> method differ in the declaration (<code>int</code>) and in the definition (<code>void</code>). I think the definition's type should be changed to <code>int</code> and make it return the result.</p>
",0
19215944,19215609,1,"<p>I'm not entirely sure, but I think the problem is in the beginning.
When you define your add function, you write it as <code>int add(int,int,string,char);</code>
However, you don't define the variables properly like you do when you actually write the function. Also, in the beginning you define it as int, but you write it as void. The compiler doesn't know what you are trying to do because it thinks there are 2 add functions, one of int type and another void function, which is probably the 18 5[Error] ambiguates old declaration 'int add(int, int, std::string, char)'</p>
",0
19215727,19215677,1,"<p>The quickest way i can think of is to try to cast it with ""strtol"" or similar functions and see whether it can convert the entire string:</p>

<pre><code>char* numberString = ""100"";
char* endptr;
long number = strtol(numberString, &amp;endptr, 10);
if (*endptr) {
    // Cast failed
} else {
    // Cast succeeded
}
</code></pre>

<p>This topic is also discussed in this thread: <a href=""https://stackoverflow.com/questions/4654636/how-to-determine-if-a-string-is-a-number-with-c"">How to determine if a string is a number with C++?</a></p>

<p>Hope this helps :)</p>
",0
19215840,19215677,1,"<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;locale&gt;
#include &lt;algorithm&gt;

bool is_numeric(std::string str, std::locale loc = std::locale())
{
    return std::all_of(str.begin(), str.end(), std::isdigit);
}

int main()
{
    std::string str;
    std::cin &gt;&gt; str;

    std::cout &lt;&lt; std::boolalpha &lt;&lt; is_numeric(str); // true
}
</code></pre>
",3
19215713,19215677,0,"<p>You can use the <em>isdigit</em> function in the <em>ctype</em> library:</p>

<pre><code>  #include &lt;stdio.h&gt;
  #include &lt;stdlib.h&gt;
  #include &lt;ctype.h&gt;
  int main ()
  {
    char mystr[]=""56203"";
    int the_number;
    if (isdigit(mystr[0]))
    {
      the_number = atoi (mystr);
      printf (""The following is an integer\n"",the_number);
    }
   return 0;
  }
</code></pre>

<p>This example checks the first character only.  If you want to check the whole string then you can use a loop, or if its a fixed length and small just combine <em>isdigit()</em> with &amp;&amp;.</p>
",0
18629404,18629184,6,"<p>Your program has UB (Undefined Behaviour), because it violates ODR (One Definition Rule) by providing two different definitions of <code>f()</code>. There is therefore next to no way of reasoning why it behaves one way or the other. In the best tradition of UB, any behaviour is possible (including ordering pizza over the Internet).</p>

<p><strong>EDIT</strong></p>

<p>These quotes from the standard (ISO/IEC 14882:2011) prove it's UB:</p>

<p>[basic.def.odr]3:</p>

<blockquote>
  <p>Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required. ... An inline function shall be defined in every translation unit in which it is odr-used.</p>
</blockquote>

<p>[basic.def.odr]5:</p>

<blockquote>
  <p>There can be more than one definition of ... inline function with
  external linkage ... in a program provided that each definition
  appears in a different translation unit, and provided the definitions
  satisfy the following requirements. Given such an entity named D
  defined in more than one translation unit, then</p>
  
  <ul>
  <li>each definition of D shall consist of the same sequence of tokens; and</li>
  <li>...</li>
  </ul>
</blockquote>

<p>[dcl.fct.spec]4</p>

<blockquote>
  <p>An inline function shall be defined in every translation unit in which it is odr-used and shall have exactly the same definition in every case (3.2). [ <em>Note:</em> A call to the inline function may be encountered before its definition appears in the translation unit. <em>-end note</em> ] If the definition of a function appears in a translation unit before its first declaration as inline, the program is ill-formed. <strong>If a function with external linkage is declared inline in one translation unit, it shall be declared inline in all translation units in which it appears; no diagnostic is required.</strong> ...</p>
</blockquote>

<p>(Emphasis mine)</p>
",15
18629454,18629184,6,"<p>Your program violate the <a href=""http://en.wikipedia.org/wiki/One_Definition_Rule"" rel=""noreferrer""><strong>One definition Rule</strong></a> then it is <a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""noreferrer""><em>Undefined behavior</em></a>.</p>
<p>When you have an <em>Undefined behaviour</em>, anything is possible but you have to know that the worst case will come during the most important demo ;)</p>
<p>The standard says:</p>
<blockquote>
<p><strong>3.2 One definition rule [basic.def.odr]</strong></p>
<p>1/ No translation unit shall contain more than one definition of any variable, function, class type, enumeration type, or template.</p>
<p><strong>[...]</strong></p>
<p>4/ Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required. The definition can appear explicitly in the program, it can be found in the standard or a user-defined library, or (when appropriate) it is implicitly defined (see 12.1, 12.4 and 12.8). <strong>An inline function shall be defined in every translation unit in which it is odr-used.</strong></p>
<p>5/ There can be more than one definition of [...] inline function with external linkage (7.1.2) [...] in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named D defined in more than one translation unit, then</p>
<ul>
<li><p>each definition of D shall consist of the same sequence of tokens; and</p>
</li>
<li><p>[...]</p>
</li>
</ul>
<p>If the definitions of D satisfy all these requirements, then the program shall behave as if there were a single definition of D. If the definitions of D do not satisfy these requirements, <strong>then the behavior is undefined.</strong></p>
</blockquote>
<p>And later:</p>
<blockquote>
<p><strong>7.1.2 Function specifiers [dcl.fct.spec]</strong></p>
<p>4/ <strong>An inline function shall be defined in every translation unit in which it is odr-used and shall have exactly the same definition in every case</strong> (3.2). [ <em>Note</em>: A call to the inline function may be encountered before its definition appears in the translation unit. <em>endnote</em>] <strong>If the definition of a function appears in a translation unit before its first declaration as inline, the program is ill-formed.</strong> If a function with external linkage is declared inline in one translation unit, it shall be declared inline in all translation units in which it appears; no diagnostic is required.</p>
</blockquote>
",5
20099026,20098930,2,"<p><code>std::less</code> and <code>std::less_equal</code> is not functions, but <em>function objects</em>. You need to create an instance, e.g. :</p>

<pre><code>std::binary_function&lt;double, double, bool&gt; checks[] = { less&lt;double&gt;() };
</code></pre>

<p>Also bear in mind that <code>std::binary_function</code> is deprecated since C++11. Instead you should use <code>std::function</code>, e.g. :</p>

<pre><code>std::function&lt;bool(double, double)&gt; checks[] = { less&lt;double&gt;() };
</code></pre>
",0
20099075,20098930,3,"<p>Both <code>less</code> and <code>less_equal</code> have one template argument not two. They are types not objects, you should pass objects, see how I have used <code>()</code> to make objects from these types. Also, you should use <code>using</code> instead of <code>typedef</code> for template types.</p>

<pre><code>using BF = std::binary_function &lt;double, double, bool&gt;;

BF checks[] = { less&lt;double&gt;(), less_equal&lt;double&gt;() };
                            ^^                    ^^
</code></pre>

<p>&nbsp;</p>

<p>The <code>std::binary_function</code> is deprecated, you can use <code>std::function</code> instead:</p>

<pre><code>using BF = std::function &lt;bool(double, double)&gt;;

BF checks[] = { less&lt;double&gt;(), less_equal&lt;double&gt;() };
</code></pre>
",0
20099301,20098930,0,"<p><code>std::binary_function</code> and <code>less&lt;double&gt;</code> all are  objects. So if you create an array of <code>std::binary_function</code> you should store objects.</p>

<p><code>less&lt;double&gt;</code> is a type. so <code>&amp;less&lt;double&gt;</code> means nothing</p>
",0
19261863,19261738,1,"<p>Your problem is storing the input in a <code>char</code>.</p>

<p>Since you store <code>day</code> as a char, it is only big enough to store the first character of whatever the input is. When you input <code>1</code> (or <code>2</code>, or <code>3</code>, etc) that's fine, since there <em>is</em> only one character of input. When you input a number with more than one digit, only the first character can be stored - for example, if you enter <code>10</code>, then there's only room to store the <code>1</code>.</p>

<p>To fix this, you should use a more appropriate data type for <code>day</code>. Using an <code>int</code> or something similar is probably best, as that will give you plenty of room for large values. So, in other words, change <code>char day;</code> to <code>int day;</code>.</p>

<p>If you do so though, you'll need to change the values in your <code>case</code> statements to match - since you're no longer comparing characters, you'll need to change them to ints too (e.g. change <code>'0'</code> to just <code>0</code>).</p>
",0
19261815,19261738,0,"<pre><code> char day;
    cout &lt;&lt; "" Enter day of the week "" &lt;&lt; endl;
    cin &gt;&gt; day;
</code></pre>

<p>Your code says to read one character from standard input. If that's not what you want do, change the code.</p>
",0
19261816,19261738,1,"<p>When you write</p>

<pre><code>char day;
cin&gt;&gt;day;
</code></pre>

<p>It will accept only one character from input. You should declare day as integer and your problem will be solved.</p>
",0
19261843,19261738,1,"<p>You're only storing one character in your <code>day</code> variable because it's declared as a <code>char</code>.  Change it to an <code>int</code>, and change the cases in your switch statements to <code>int</code> values.</p>

<pre><code>#include &lt;iostream&gt; 
#include &lt;string&gt;
using namespace std;

int main ()
{
    int day;
    cout &lt;&lt; "" Enter day of the week "" &lt;&lt; endl;
    cin &gt;&gt; day;

    switch (day)
    {  
        case 1:
        case 6:
        case 7:
            cout &lt;&lt; ""weekend"";
            break;
        case 2:
        case 4:
            cout &lt;&lt; ""going to C++ Class"";
            break;
        case 3:
        case 5:
            cout &lt;&lt; ""studying for C++ Class"";
            break;
        default :
            cout &lt;&lt; ""invalid day number"";
    }

    system(""pause"");
    return 0;
}
</code></pre>
",0
19264434,19261738,0,"<p>You need to be very careful while you decide on the data type of the variable, since every data type comes with its inherent properties. Like everyone pointed out here, you need to change data type from 'char' to 'int'.</p>
",0
20635872,20635379,2,"<p>The first option is more sophisticated:</p>

<pre><code>Window&amp; Application::getWindow() {
   // check for NULL dereference of App object:
   ASSERT(this != NULL);

   // add trace:
   TRACE(__FUNCTION__ "" was called!"");

   // other debug/probing code
#ifdef DEBUG
   static int count = 0;
   ++count
#endif
   return window;
}
</code></pre>
",4
20636666,20635379,1,"<p>In my opinion the first one is the only good way. </p>

<p>Be careful though to return a Window reference and not a Window object. If you return an object a copy of the object will be constructed and you no longer manipulate the original object.</p>

<p>The reason why I would prefer only the first way (and usually why in textbooks you find ""do not access data members from extern""): Before returning the value (in this case the object reference) you can manipulate it as you want. For example you need to implement your own window class. If you return it with a getter function you still can cast it to the original window class thus the rest of the code (that only needs the setTitle, etc...) will be unchanged. </p>

<p>==> Only the application class needs to know how its data members are organized, noone else.</p>
",0
19442580,19442558,5,"<p>A chain of <code>&lt;&lt;</code> operators, like <code>a &lt;&lt; b &lt;&lt; c &lt;&lt; d</code>, is parsed by C/C++ into <code>(((a &lt;&lt; b) &lt;&lt; c) &lt;&lt; d)</code>, which is the same as</p>

<pre><code>a.operator&lt;&lt;(b).operator&lt;&lt;(c).operator&lt;&lt;(d)
</code></pre>

<p>The ""result"" of each <code>&lt;&lt;</code> is the LHS of the next <code>&lt;&lt;</code>; thus, to make this chaining work, the <code>ostream</code> must be returned from each <code>operator&lt;&lt;</code>.</p>
",3
19212928,19212903,3,"<p>The reason for this is that you are not initializing the <code>objB</code> data member, but <em>assigning</em> to it after it has been default constructed. </p>

<pre><code>ClassA(int option)
{
  // By the time you get here, objB has already been constructed
  // This requires that ClassB be default constructable.

    objB = ClassB(option); // this is an assignment, not an initialization
}
</code></pre>

<p>To initialize it, use the constructor member initialization list:</p>

<pre><code>ClassA(int option) : objB(option) {}
</code></pre>

<p>This initializes <code>objB</code> with the right constructor, and does not require <code>ClassB</code> to be default constructable. Note that the same applies to <code>ClassB</code>, whose constructors should be</p>

<pre><code>ClassB() : option() {} // initializes option with value 0
ClassB(int option) : option(option) {}
</code></pre>
",3
20642007,20641771,4,"<p>No. There's nothing to delete, because the object never got constructed. The compiler will take care of freeing the memory that was allocated.</p>
",0
20182200,20182180,1,"<p>It's undefined behaviour to evaluate <code>a[-1]</code>. Since the logical-AND operator <code>&amp;&amp;</code> has short-circuited semantics, <code>a[j - 1]</code> is never evaluated if <code>j == 0</code> in the original code.</p>
",3
20182211,20182180,3,"<p>Because due to the <a href=""http://en.wikipedia.org/wiki/Short-circuit_evaluation"" rel=""nofollow"">short-circuiting</a> property of the <code>&amp;&amp;</code> operator, the modified code (your ""working"" version, that doesn't really work) would most likely invoke undefined behavior by accessing the -1th element in the array.</p>
",0
19573224,19573147,4,"<p>You can use function pointers.</p>

<p>There's a <a href=""http://www.cprogramming.com/tutorial/function-pointers.html"" rel=""nofollow"">tutorial here</a> but basically what you do is declare it like this:</p>

<pre><code>void (*foo)(int);
</code></pre>

<p>where the function has one integer argument.</p>

<p>Then you call it like this:</p>

<pre><code>void my_int_func(int x)
{
    printf( ""%d\n"", x );
}


int main()
{
    void (*foo)(int);
    foo = &amp;my_int_func;

    /* call my_int_func (note that you do not need to write (*foo)(2) ) */
    foo( 2 );
    /* but if you want to, you may */
    (*foo)( 2 );

    return 0;
}
</code></pre>

<p>So as long as your functions have the same number and type of argument you should be able to do what you want.</p>
",0
19573272,19573147,5,"<p>It is possible, assuming two things:</p>

<ol>
<li>Both <code>function2D()</code> and <code>function3D()</code> have the same signature and return type.</li>
<li><code>function</code> is a function pointer, with the same return type and parameters as both <code>function2D</code> and <code>function3D</code>.</li>
</ol>

<p>The technique you are exploring is very similar to the one used in constructing a <a href=""https://stackoverflow.com/questions/48017/what-is-a-jump-table"">jump table</a>.  You have a function pointer, which you assign (and call through) at run-time based on run-time conditions.</p>

<p>Here is an example:</p>

<pre><code>int function2D()
{
  // ...
}

int function3D()
{ 
  // ...
}

int main()
{
  int (*function)();  // Declaration of a pointer named 'function', which is a function pointer.  The pointer points to a function returning an 'int' and takes no parameters.

  // ...
  if(dimension==2)
    function = function2D;  // note no parens here.  We want the address of the function -- not to call the function
  else if(dimension==3)
    function = function3D;

  for (...)
  {
    function();
  }
}
</code></pre>
",2
19573283,19573147,2,"<p>Since this is also tagged C++, you can use <code>std::function</code> if you have access to <code>C++11</code>, or <code>std::tr1::function</code> if your compiler supports C++98/03 and TR1.</p>

<pre><code>int function2d();
int function3D(); 

int main() {
    std::function&lt;int (void)&gt; f; // replace this with the signature you require.
    if (dimension == 2)
        f = function2D;
    else if (dimension == 3)
        f = function3D;
    int result = f(); // Call the function.
}
</code></pre>

<p>As mentioned in the other answers, make sure your functions have the same signature and all will be well.</p>

<p>If your compiler doesn't offer <code>std::function</code> or <code>std::tr1::function</code>, there's always the <a href=""http://www.boost.org/doc/libs/1_54_0/doc/html/function.html"" rel=""nofollow"">boost library</a>.</p>
",0
19573350,19573147,1,"<p>Since you choose C++</p>

<p>Here's with <a href=""http://en.cppreference.com/w/cpp/utility/functional/function"" rel=""nofollow""><em><code>std::function</code></em></a> example in C++11</p>

<pre><code>#include &lt;functional&gt;
#include &lt;iostream&gt;

int function2D( void )
{
  // ...
}

int function3D( void ) 
{ 
  // ...
}

int main()
{

    std::function&lt;int(void)&gt; fun = function2D;

    fun();

}
</code></pre>
",1
18864668,18864253,1,"<p>Something like this could work but I would recommend using std::list since remove can be done in constant time. Remove on arrays can only be done in linear time if you want to preserve order (like I have). The other option is to just swap the empty place with the element at the size-1 position in the array and then subtract 1 from size.</p>

<p>Note: You have to change your function header, list[] can't be const if you want to modify it and since you're removing elements size should be pass-by-reference so it can be changed.</p>

<pre><code>void remData(InventoryRecord list[], int &amp;size) {
    system(""cls"");
    cout &lt;&lt;""Enter Item you wish to remove from your inventory: "" &lt;&lt; endl;// This is being displayed so user can see items in the inventory

    // the name we query for
    string qname;
    bool found = false;
    int index;

    if(size &lt; 1) {
        cout &lt;&lt; ""Nothing to display"" &lt;&lt; endl;
    } else {
        // display the inventory for reference
        dispData(list, size);

        // prompt for name
        cout &lt;&lt; ""Name      : "";
        getline(cin, qname);
        for ( int i = 0; i &lt; size; ++i )
            if ( qname == list[i].name )
            {
                found = true;
                index = i;
                // assuming only removing first item with this name
                break;
            }

        if (!found) {
            // you could re-prompt using a loop instead of just ending here
            cout &lt;&lt; ""Could not find item "" &lt;&lt; qname &lt;&lt; ""!"" &lt;&lt; endl;
        } else {
            // remove item from list and shift other items over the one we want to remove
            for ( int i = index; i &lt; size-1; ++i )
            {
                // modifying list (this is why it can't be const)
                list[i].name = list[i+1].name;
                list[i].qty = list[i+1].qty;
                list[i].value = list[i+1].value;
            }
            // decrement the size (this is why it was pass-by-reference)
            size--;
        }
    }
}
</code></pre>
",4
19787231,19787186,2,"<p>This is a <a href=""http://en.wikipedia.org/wiki/Endianness"" rel=""nofollow"">byte ordering issue</a> - the stream on disk contains the bytes in the opposite order (<a href=""http://www.w3.org/TR/2003/REC-PNG-20031110/#7Integers-and-byte-order"" rel=""nofollow"">big endian as specified in the PNG spec</a>) than your architecture mandates for integers (likely little-endian). You have to manually reverse the order of bytes to solve this.</p>
",0
20528119,20528102,7,"<p>Because 60 / 120 is 0 considering the constants are integral. (Inferring 120 from x / 60 = 2.) You will need to use 60.0 / x for example to get a floating point number as a result.</p>
",0
19208704,19208689,2,"<pre><code>m_string = m_pstring.operator std::string();
</code></pre>
",1
18903163,18903141,2,"<p>I/O is <a href=""http://en.wikipedia.org/wiki/Data_buffer"" rel=""nofollow noreferrer"">buffered</a> and you need to flush it.</p>

<p>With <code>&lt;stdio.h&gt;</code> call e.g. <code>fflush(NULL)</code> or <code>fflush(stdout)</code>. Read the <a href=""http://man7.org/linux/man-pages/man3/fflush.3.html"" rel=""nofollow noreferrer"">fflush(3)</a> and related man pages.</p>

<p>With C++ iostream do a <code>cout &lt;&lt; std::flush</code> or <code>cout.flush</code>
(or, as commented by <a href=""https://stackoverflow.com/users/2790047/jodag"">jodag</a> do a <code>cout &lt;&lt; std::endl</code> which output a newline then flush). Read about <a href=""http://www.cplusplus.com/reference/ostream/flush-free/"" rel=""nofollow noreferrer"">std::flush</a> etc..</p>

<p>And with <code>scanf(""%d "",&amp;a)</code> the reader has to get the non-digit character just after the number (perhaps space, or getting end-of-line or end-of-file). Read <a href=""http://man7.org/linux/man-pages/man3/scanf.3.html"" rel=""nofollow noreferrer"">scanf(3)</a> man page.</p>

<p>I do advise flushing the stdout before your <code>scanf</code> (that is sometimes, but not always, done automatically)</p>

<p>BTW, the prefered C++ way of inputting a number is probably</p>

<pre><code> std::cin &gt;&gt; a;
</code></pre>
",2
18903263,18903141,2,"<p>The answer to your question is in the description of the format specifier (the Whitespace section):  <a href=""http://www.cplusplus.com/reference/cstdio/scanf/"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdio/scanf/</a></p>

<blockquote>
  <p>the function will read and ignore any whitespace characters
  encountered before the next non-whitespace character (whitespace
  characters include spaces, newline and tab characters -- see isspace).
  A single whitespace in the format string validates any quantity of
  whitespace characters extracted from the stream (including none).</p>
</blockquote>
",0
19502148,19501991,2,"<p>When the integer value is read the [Enter] introduced to finish the line is still in the stream, and <code>getline(cin,name)</code> reads that [Enter].</p>

<p>To solve the problem, first <a href=""https://stackoverflow.com/questions/257091/how-do-i-flush-the-cin-buffer/257182#257182"">flush cin before getting the string</a>:</p>

<pre><code>string name;
int age;
cout&lt;&lt;""Enter age"";
cin&gt;&gt;age;
cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n'); // ignores all enters
cout&lt;&lt;""Enter name"";
getline(cin,name);

cout&lt;&lt;name;
cout&lt;&lt;age;

getch();
</code></pre>
",1
19502152,19501991,2,"<p>I'll answer for C++ only, as only C++ code is present.</p>

<p><code>std::getline</code> will consumes the newline character left over the  input stream by previous <code>operator &gt;&gt;</code>, and hence it returns. </p>

<p>A simple work around is to ignore all leftover characters on the line of input with 
<code>cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');</code></p>

<p>before using <code>std::getline</code></p>

<pre><code>#include&lt;limits&gt;
// ....
string name;
int age;
cout&lt;&lt;""Enter age"";
cin&gt;&gt;age;

cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');

cout&lt;&lt;""Enter name"";
getline(cin,name);
</code></pre>
",1
19502231,19501991,0,"<pre><code>std::cin &gt;&gt; age;
std::getline(std::cin, name);
</code></pre>

<p>Let's say the user enters the integer 5. This is what the input stream will look like:</p>

<blockquote>
<pre><code>5\n
...
</code></pre>
</blockquote>

<p><sub>Note that the above could vary. The user could enter an integer and subsequently a space character. Both are equally valid situations.</sub></p>

<p>That is, the user enters the value and hits return to submit. <code>operator &gt;&gt;</code> is formatted so that the integer will be consumed, but once it finds a new line or whitespace extraction will cease. After the input operation, the new line should still be in the stream.</p>

<blockquote>
<pre><code>\n
...
</code></pre>
</blockquote>

<p>Now, let's see the content for <code>name</code>:</p>

<blockquote>
<pre><code>\n
""Bruce Wayne""\n
</code></pre>
</blockquote>

<p>When <code>getline</code> executes, once it finds a new line in the stream it will stop searching for new input. The new line from the previous extraction was still in the stream, so the input was stopped immediately. Nothing was extracted!</p>

<p>Fortunately, we can use the <code>ignore</code> method to discard the new line from the stream:</p>

<pre><code>std::cin &gt;&gt; age;
std::cin.ignore(); // ignore the next character

std::getline(std::cin, age);
</code></pre>

<p>By default, <code>std::cin.ignore</code> will discard the next character from the stream when given 0 arguments.</p>

<p>Here is a <strong><a href=""http://ideone.com/jmjzWy"" rel=""nofollow"">live example</a></strong>.</p>
",1
18401080,18400993,0,"<p>Variable <code>double&amp; pScore</code> is not updated by function <code>computePG</code>.</p>
",0
18401049,18400993,5,"<p>You are passing <code>pScore</code> as a reference, but you are not assigning any value to it, instead you are storing your result into local variable <code>cpScore</code>:</p>

<pre><code>  void computePG(double&amp; pScore)
  {   
    double q1, q2, q3, pe, cpScore = 0;

    cout &lt;&lt; ""\n\n\tPlease enter your score in quiz 1: "";
    cin &gt;&gt; q1;
    cout &lt;&lt; ""\tPlease enter your score in quiz 2: "";
    cin &gt;&gt; q2;
    cout &lt;&lt; ""\tPlease enter your score in quiz 3: "";
    cin &gt;&gt; q3;
    cout &lt;&lt; ""\tPlease enter your score in prelim exam: "";
    cin &gt;&gt; pe;
    pScore = ((q1/30) * 20) + ((q2/50) * 20) + ((q3/40) * 20) + ((pe/100) * 40);
    cout &lt;&lt; ""\n\n\tThe computed PG is: "" &lt;&lt; pScore;
  }
</code></pre>
",1
19796895,19796780,0,"<p>I believe you want </p>

<pre><code>struct Car{
    int year;
    double cost;
};
</code></pre>

<p>also your function signatures aren't right. update_cost returns void (nothing) or Car but not both. You have to chose one</p>
",0
19797017,19796780,1,"<p>My best guess at your chaos:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

struct Car
{
  int year;
  double cost;
};

void read_car_record(Car&amp; new_car);
void update_cost(Car&amp; old_car);

int main()
{
    Car myCar;

    cout &lt;&lt; ""enter the year of the car: ""&lt;&lt;endl;
    cin &gt;&gt; myCar.year;

    cout &lt;&lt; ""Enter the cost of the car: ""&lt;&lt;endl;
    cin  &gt;&gt; myCar.cost;
}
</code></pre>
",6
19974651,19974350,0,"<p>There's a lot wong in the code. Let me concentrate on the <code>convertWeight</code> function.</p>

<p>First of all, write the <strong>types</strong> of the parameters in front of the parameter names, like you did with the <code>output</code> function.</p>

<p>Secondly, the function parameters are all ""in"" parameters, meaning they are used to pass in values which are copied to be used in the function. The function itself is allowed to modify them, but modifications are done locally and thrown away when returning from the function. You wanted to return two values which is not possible in C++ unless you wrap them into a single container type like <code>std::pair</code>. If you don't want to do this, you need to make two of your parameters ""out"" parameters, which can be done in C++ using <strong>references</strong>.</p>

<p>Finally, the conversion is wrong. Your assignment of the converted kilograms is stored in an int, which means that the decimal part is <strong>truncated</strong>. When multiplying by 1000 afterwards, you get a number divisible by 1000 which doesn't help much; even if it still was a double, your grams variable would not only have the grams but the full weight. I'm almost sure you only wanted to have the ""remainder"" of the kilograms expressed in grams. So use a temporary double variable to fix the first problem and subtract the kilograms before multiplying by 1000 to fix the second problem.</p>

<pre><code>void convertWeight(double ounces, double &amp;grams, int pounds, int &amp;kilograms)
{
    double temp = (pounds + ounces/16)/2.2046;
    kilograms = temp;                  // will automatically truncate to full kilograms
    grams = (temp - kilograms) * 1000; // Will use the remainder
}
</code></pre>

<p>Also I don't like the <strong>parameter order</strong>, but that's a personal choice of preference. Typically you want to keep ins and outs separate. Also it makes more sense to put the ""larger"" unit before the ""smaller"" unit, resulting in this signature:</p>

<pre><code>void convertWeight(int pounds, double ounces, int &amp;kilograms, double &amp;grams)
</code></pre>
",0
19974497,19974350,0,"<p>You need to append parameter types in function implementation: void convertWeight(ounces, grams, pounds, kilograms)</p>
",0
19974520,19974350,0,"<p>I can't read all the error messages there, but I can tell you at least part of what's wrong with your programme :-)</p>

<pre><code>void convertWeight(ounces, grams, pounds, kilograms)
{ 
    kilograms = (pounds + ounces/16)/2.2046;
    grams = kilograms * 1000;

    return(kilograms, grams);
}
</code></pre>

<p>Here, you've said that the function return type is <code>void</code>, i.e it doesn't return a value -- but then you've tried to return a value anyway! (In a way that isn't valid C++.) Furthermore, you've forgotten to specify the parameter types in the function definition, which is also not allowed in C++.</p>

<p>Rather than outputting a pair of values (which is possible, but in a different way to how you've tried to do it here), it would be easier to pass the <code>grams</code> and <code>kilograms</code> variables <em>by reference</em> -- this means that the function you call will change the variables you pass to them. You need to change your <code>convertWeight</code> function signature to</p>

<pre><code>// Note the '&amp;' on the reference variables
void convertWeight(int pounds, double ounces, int&amp; kilograms, double&amp; grams)
{
    kilograms = // whatever
    grams = // whatever
} 
</code></pre>

<p>Now you can call <code>convertWeight()</code> like this:</p>

<pre><code>int pounds = 3;
int ounces = 12;
int kilograms;
double grams;

convertWeight(pounds, ounces, kilograms, grams);
</code></pre>

<p>and your function will fill in the values of <code>kilograms</code> and <code>grams</code> for you.</p>
",0
18373154,18372956,1,"<p>Due to template argument deduction and reference collapsing rules you cannot know if <code>a</code> is a rvalue reference or a lvalue reference. <code>std::forward</code> passes the argument to the TT contrustor exactly as it was passed to make_unique. Scott Meyers calls <code>A&amp;&amp;</code> a <a href=""http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers"" rel=""nofollow"">universal reference</a>, because it can be a lvalue ref or an rvalue ref, depended on what is passed to make_unique. </p>

<p>If you pass an rvalue <code>Foo</code> to <code>make_unique</code>, <code>std::forward</code> passes an rvalue reference.</p>

<p>If you pass an lvalue <code>Foo</code> to <code>make_unique</code>, <code>std::forward</code> passes an lvalue reference.</p>

<pre><code> make_unique(1, Foo());         // make_unique(int, A&amp;&amp;) -&gt; rvalue ref
 Foo f;
 make_unique(1, f);             // make_unique(int, A&amp;&amp;&amp;) -&gt; make_unique(int, A&amp;) -&gt; lvalue ref
 make_unique(1, std::move(f));  // make_unique(int, A&amp;&amp;&amp;&amp;) -&gt; make_unique(int, A&amp;&amp;) -&gt; rvalue ref
</code></pre>
",0
18373380,18372956,2,"<p>Hmmm... I'm pretty sure this isn't given as a work-around implementation of the future <code>std::make_unique</code>, but anyway, what the function does is pretty easy to understand, though it requires you to have prior knowledge of new C++11 features.</p>

<pre><code>template &lt;typename TT, typename A&gt;
unique_ptr&lt;TT&gt; make_unique(int i, A &amp;&amp; a)
{
      return unique_ptr&lt;TT&gt;{new TT{ i, std::forward&lt;A&gt;(a) }};
}
</code></pre>

<p>First of all <code>make_unique</code> is a <em>function template</em>, I really hope you already know that, as the following would <em>require</em> that you have at least the most basic knowledge on what templates does and how templates work.</p>

<p>Now to the non-trivial parts. <code>A &amp;&amp; a</code> there is a function parameter. Specifically, <code>a</code> is the function parameter whose type is <code>A&amp;&amp;</code> which is an <a href=""https://stackoverflow.com/q/5481539/1619294""><em>r-value reference</em></a>. With its type being a template type parameter, we can deduce its type from whatever the caller passes as an argument to <code>a</code>. Whenever we have r-value reference and argument type deduction, special deduction rules and reference collapsing kicks-in and we have a so-called <em>""universal reference""</em> which is particularly useful for perfect forwarding functions.</p>

<p>Whenever we have a universal reference (<code>a</code> in our case), we will almost always want to preserve its original ""l-valueness"" or ""r-valueness"" whenever we want to use them. To have this kind of behavior, we should almost always use <a href=""https://stackoverflow.com/questions/7257144/when-to-use-stdforward-to-forward-arguments""><code>std::forward</code></a> (<code>std::forward&lt;A&gt;(a)</code>). By using <code>std::forward</code>, a variable originally passed as an l-value remains an l-value and a variable originally passed as an r-value remains an r-value.</p>

<p>After that, things are just simple</p>

<pre><code>return unique_ptr&lt;TT&gt;{new TT{ i, std::forward&lt;A&gt;(a) }};
</code></pre>

<p>Notice the use of the braces. Instead of using parentheses, it is using C++11's <a href=""https://en.wikipedia.org/wiki/C%2B%2B11#Uniform_initialization"" rel=""nofollow noreferrer""><em>uniform initialization</em></a> syntax of calling constructors. With <code>new TT{ i, std::forward&lt;A&gt;(a) }</code>, you are dynamically allocating an object of type <code>TT</code> with the given parameters inside the braces. With <code>unique_ptr&lt;TT&gt;{new TT{ i, std::forward&lt;A&gt;(a) }};</code>, you are creating a <code>unique_ptr&lt;TT&gt;</code> whose parameter is the one returned by the dynamic allocation. The <code>unique_ptr&lt;TT&gt;</code> object now then returned from the function.</p>
",0
20526521,20525835,0,"<p>I've used this as a C++ reference all the way through College, and never really needed much more than this.
   <a href=""http://www.cplusplus.com/reference/stl/?kw=stl"" rel=""nofollow"">http://www.cplusplus.com/reference/stl/?kw=stl</a>
I've primarily used vectors and maps. A multimap is basically a map, but it will allow you to have multiple entries under the same key which definitely comes in handy. It stores a vector of the specified type instead of a single instance.
Also, it's good practice to store pointers to user defined objects instead of storing the objects themselves. This will prevent memory fragmentation. The reason for this is that a vector is just a managed array. Once that array is filled up, the whole vector gets copied to another malloc space twice that size. This can be a costly operation at run-time. Also if you're looking for more flexibility with the new operator, or you want to create your own memory pooling, check out <a href=""http://www.cplusplus.com/reference/new/operator%20new/"" rel=""nofollow"">http://www.cplusplus.com/reference/new/operator%20new/</a></p>
",6
20526615,20525835,1,"<p>I realize that it isn't online and I may be biased but you may still find Nicolai Josuttis's ""The C++ Standard Library"" (Addison-Wesley) useful. It goes over all of the standard C++ library.</p>
",0
20526739,20525835,0,"<p>I think the best way to learn frameworks is use them and find out the answers to the questions that will arise (thankfully we have Google).</p>

<p>If you want anything other than that I'd assume you want to be very thorough and skilled then I only have one suggestion to that, and that's a book.<br />
(<strong>Personally</strong> I don't ""believe"" in any other kind of learning.)</p>

<p>In which case I suggest <a href=""https://stackoverflow.com/a/20526615/825637"">Dietmar Khl</a>'s answer as I intended to recommend the same book. I have not read it but it's top on Amazon so should be good enough.</p>

<p>Best of luck.</p>
",0
19883165,19883092,6,"<p>As <a href=""https://stackoverflow.com/users/701092/0x499602d2"">0x499602d2</a> correctly pointed out, <code>fill</code> needs to copy-assign from the third argument. As your type implicitly is noncopyable, you cannot use <code>fill</code>.</p>

<p>You could, however, use <code>generate</code> to fill your vector:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;

struct noncopyable
{
    noncopyable() = default;

    // make it noncopyable
    noncopyable(noncopyable const&amp;) = delete;
    noncopyable&amp; operator=(noncopyable const&amp;) = delete;

    // make it movable (thanks, gx_)
    noncopyable(noncopyable&amp;&amp;) = default;
    noncopyable&amp; operator=(noncopyable&amp;&amp;) = default;
};

int main()
{
    std::vector&lt;noncopyable&gt; vec(10);
    std::generate(begin(vec), end(vec), []()-&gt;noncopyable{return {};});
}
</code></pre>

<p>Note: this only works if <code>noncopyable</code> has a non-deleted, accessible move constructor. However, if it <em>does not</em> have such a ctor, you won't be able to use much of the vector (<code>resize</code> requires <code>MoveInsertable</code>, which requires either a copy- or move-ctor).</p>

<hr>

<p>For g++4.8, to use <code>generate</code>, you'll need a free function. I think that's a bug.</p>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;

struct noncopyable
{
    noncopyable() = default;
    noncopyable(noncopyable const&amp;) = delete;
};

noncopyable free_func()
{  return {};  }

int main()
{
    std::vector&lt;noncopyable&gt; vec;
    std::generate(begin(vec), end(vec), free_func);
}
</code></pre>

<hr>

<p>Yet another question is if you can <em>initialize</em> your vector like that. I'd say NO. <code>fill</code> and <code>generate</code> do not <em>construct</em> elements, but overwrite (assign). That is, you'll already need to have a vector with multiple elements before you can use them.</p>

<p>The easiest version to <em>initialize</em> a vector with N default-constructed elements is to use the constructor:</p>

<pre><code>std::vector&lt;noncopyable&gt; vec(10);
</code></pre>

<p>Creates a <code>vector</code> with 10 default-constructed elements. The only requirement is that <code>noncopyable</code> is DefaultConstructible (essentially, it must have a default constructor).</p>

<hr>

<p>If your type is noncopyable AND nonmovable, you cannot use it directly (or as a data member) to store it inside a <code>vector</code>(*). To make a class <code>C</code> movable, which contains a noncopyable, nonmovable type <code>X</code>, you need to store <code>X</code> as a pointer:</p>

<p><sub>(*) Well, you can, but you cannot resize the vector, you cannot insert etc.</sub></p>

<pre><code>struct nocopies_nomoves
{
    nocopies_nomoves() = default;

    nocopies_nomoves(nocopies_nomoves const&amp;) = delete;
    nocopies_nomoves&amp; operator=(nocopies_nomoves const&amp;) = delete;

    // not required to be explicitly deleted:
    nocopies_nomoves(nocopies_nomoves&amp;&amp;) = delete;
    nocopies_nomoves&amp; operator=(nocopies_nomoves&amp;&amp;) = delete;
};

#include &lt;utility&gt;
#include &lt;memory&gt;
class C
{
public:
    C() : ptr( new nocopies_nomoves() ) {} // make_unique in C++1y

    // I don't think you need to explicitly define those as defaulted;
    // at least not if you don't declare ANY of the copy/move ctors, assignment ops
    // and dtor
    C(C&amp;&amp; rhs) = default;
    C&amp; operator=(C&amp;&amp; rhs) = default;
    ~C() = default;

    // not required to be explicitly deleted:
    C(C const&amp;) = delete;
    C&amp; operator=(C const&amp;) = delete;
private:
    std::unique_ptr&lt;nocopies_nomoves&gt; ptr;
};
</code></pre>

<p>Now you can create a <code>vector&lt;C&gt;</code> and use it (e.g. <code>resize</code>, <code>insert</code>, ...)</p>

<pre><code>#include &lt;vector&gt;
#include &lt;algorithm&gt;

static C generate_C()
{
    return {};
}

int main()
{
    std::vector&lt;C&gt; vec(10);
    // note: futile statement below; overwrites the 10 default-constructed
    //       elements
    std::generate(begin(vec), end(vec), generate_C);
}
</code></pre>
",14
19216100,19216014,3,"<p>A <code>goto</code> command will do what you want but it's generally frowned on in polite circles :-)</p>

<p>It has its place but you would be possibly better off learning structured programming techniques since the <em>overuse</em> of <code>goto</code> tends to lead to what we call spaghetti code, hard to understand, follow and debug.</p>

<p>If your mandate is to make minimal changes to code which sounds like it may already be badly written, <code>goto</code> may be the best solution:</p>

<pre><code>try_again:
n = try_something();
if (n &gt; 1)
    goto try_again;
</code></pre>

<p>With structured programming, you would have something like:</p>

<pre><code>n = try_something();
while (n &gt; 1)
    n = try_something();
</code></pre>

<p>You may not see <em>much</em> of a difference between those two cases but that's because it's simple. If you end up with your labels and <code>goto</code> statements widely separated, or forty-two different labels, you'll beg for the structured version.</p>
",4
19216173,19216014,0,"<p>I'm not entirely certain what you mean by ""redirect"", but consider the following:</p>

<pre><code>if (N &gt; 1) {
   speak();
} else {
   do_something_else();
}
</code></pre>

<p>as paxdiablo has already stated the <code>goto</code> method isn't good practice. It would be better to use functions that do a specific thing, this way debugging is easier and someone can actually follow what your code is doing (or at least what it is supposed to do).</p>
",0
19216122,19216014,2,"<p>Use functions, loops etc to control the ""flow"" of your application. Think about code as reusable pieces, anything that is going to be reused should be placed in a function or looped through.</p>

<p>Here is an example:</p>

<pre><code>void main()
{
    int i = 0;

    SayHello();       

    if (i &lt; 1)
    {
         SayHello();
         i++;
    }
    else
    {
         SayGoodbye();
    }
}

void SayHello()
{
    cout &lt;&lt; ""Hello"" &lt;&lt; endl;
}

void SayGoodbye()
{
    cout &lt;&lt; ""Goodbye"" &lt;&lt; endl;
}
</code></pre>
",0
20104594,20104495,1,"<p>You don't need to bind anything.</p>

<pre><code>if (checks[i](value, 0))
</code></pre>

<p>You also don't need an array of functor objects.  Function pointers are just fine for the logic you showed.</p>

<pre><code>bool (*(checks[]))(double, double) = { /* ... */ };
</code></pre>
",0
19437314,19437258,3,"<p>You can't copy or assign an <code>std::ofstream</code>, which means you can't do this:</p>

<pre><code>file = openedFile;
</code></pre>

<p>You need to either initialize it correctly, or move-copy-assign.</p>

<p>Initialization (preferred option):</p>

<pre><code>FileWriter(string fileName) : file(""data.bin"", ios::out | ios::binary)
{ 
  ...
}
</code></pre>

<p>Move-copy assignment:</p>

<pre><code>file = std::move(openedFile);
</code></pre>

<p>Alternatively, you can use the <code>std::ofstream::open</code> method:</p>

<pre><code>file.open(""data.bin"", ios::out | ios::binary);
</code></pre>
",4
19437338,19437258,2,"<p>You can just open the existing object:</p>

<pre><code>file.open(""data.bin"", ios::out | ios::binary);
</code></pre>

<p>And you need to avoid calling (or at least requiring) the copy-ctor of your class. Change</p>

<pre><code>FileWriter writer = FileWriter(""C:\\Users\\Owner\\Desktop\\Test.bin"");
</code></pre>

<p>to:</p>

<pre><code>FileWriter writer(""C:\\Users\\Owner\\Desktop\\Test.bin"");
</code></pre>
",0
19437339,19437258,1,"<pre><code>file = openedFile;
</code></pre>

<p>There is only one <code>operator=</code> defined for <code>basic_ofstream</code>, the move-assignment operator. The copy-assignment operator is implicitly deleted, and so this code will not work.</p>

<p>You need to use the member-initializer list to initialize <code>file</code> with the path:</p>

<pre><code>FileWriter(std::string fileName)
    : file(fileName, ios::out | ios::binary)
{
    ...
}
</code></pre>
",4
19804020,19803971,5,"<p>Just because you derive from a <code>Base</code> doesn't mean you should be allowed to access protected member of any other class deriving from <code>Base</code>. Imagine a class <code>Derived2</code> provided by a library which inherits from <code>Base</code>. This way you'll be able to get a base object of <code>Derived2</code> and do whatever you want with it in the code of <code>Derived</code>. </p>

<p>So basically the standard ensures that you only modify protected members that you inherited and not mess with the integrity of unrelated siblings classes.</p>
",1
19801240,19801220,7,"<p>You have a missing semi-colon ';'</p>

<pre><code>int largest = arr[0]
                    ^
</code></pre>
",0
19801253,19801220,3,"<p>You should add ; at the end of the previous line:</p>

<pre><code>int largest = arr[0];
</code></pre>
",0
18862540,18862448,1,"<pre><code>             arrayCapacity *= 2;
        }
        Element* newArray = new Element[arrayCapacity*2];
</code></pre>

<p>This causes your array to be much larger than your <code>arrayCapacity</code> this could be causing issues elsewhere.</p>

<p>It should just be </p>

<pre><code> Element* newArray = new Element[arrayCapacity];
</code></pre>

<p>p.s. If this isnt causing <em>the</em> issue, let me know and ill make this a comment, but it is a bug to fix nonetheless</p>
",0
18862548,18862448,0,"<p>You allocate 2x elements:</p>

<pre><code>Element* newArray = new Element[arrayCapacity*2]; // Make a new array
</code></pre>

<p>I assume, need:</p>

<pre><code>Element* newArray = new Element[arrayCapacity]; // Make a new array
</code></pre>
",0
18676652,18676615,1,"<p>Call c_str on the string:</p>

<pre><code>word[i] = (const char *)strdup(t.c_str());
</code></pre>

<p>For reference:
<a href=""http://en.cppreference.com/w/cpp/string/basic_string/c_str"" rel=""nofollow"">http://en.cppreference.com/w/cpp/string/basic_string/c_str</a></p>
",5
18677167,18676615,1,"<p>This may help:</p>

<pre><code>int main()
{
    string text = ""token test string"";
    char_separator&lt;char&gt; sep("" "");
    tokenizer&lt;char_separator&lt;char&gt;&gt; tokens(text, sep);
    std::vector&lt;std::string&gt; &gt; words;
    for (const auto&amp; t : tokens) {
        cout &lt;&lt; t &lt;&lt; ""."" &lt;&lt; endl;
        words.push_back(t);
    }
    return 0;
}
</code></pre>
",0
18677448,18676615,1,"<p><em>""My purpose is to get each word of string text in char array word[], each word into word[0] to word[last]. Then I want to pass word into some function as a argument ""</em></p>

<p>You can do something like this:</p>

<pre><code>   std::istringstream iss(text);

   std::copy(std::istream_iterator&lt;std::string&gt;(iss),
         std::istream_iterator&lt;std::string&gt;(),
         std::back_inserter&lt;std::vector&lt;std::string&gt; &gt;(strs));

   char **word = new char*[strs.size()];
   for(size_t i=0;i&lt;strs.size();++i)
   {
       word[i] = new char[strs[i].size()+1];
       strcpy(word[i],strs[i].c_str());
   }     

    /* Clean up*/
    for(size_t i = 0; i &lt; strs.size(); ++i) {
    delete [] word[i];
   }
   delete [] word;
</code></pre>

<p>See <strong><a href=""http://ideone.com/Ek8Irg"" rel=""nofollow"">HERE</a></strong></p>
",2
18680320,18676615,0,"<p>This may help!</p>

<pre><code>word = strtok(&amp; text[0],"" "");
    while (word!= NULL) {
    printf(""\n Word %s \n"",word);
       //    ch[i] = strdup(word);
        strcpy(ch[i],word);
            excluded_string[j]= strdup(word);
            skp = BoyerMoore_skip(word, strlen(word) );
            if(skp != NULL)
        {
            i++;
            continue;
        }
        bfr &lt;&lt; excluded_string[j] &lt;&lt; "" "";
        result_string = bfr.str();
        j++; 
        }    
</code></pre>
",0
18681395,18676615,1,"<p>Pass word directly here:</p>

<pre><code>std::ostringstream bfr; 
    word = strtok(&amp; text[0],"" "");
        while (word!= NULL) {
                printf(""\n Word %s \n"",word);
            bfr &lt;&lt; word &lt;&lt; "" "";
            word = strtok(NULL, "" "");
            j++; 
            }    
</code></pre>
",1
19801878,19801677,0,"<p>You should know that there are preferred C++ methods for manipulation of files over C stdio methods:</p>

<ul>
<li>Using standard predefined streams: <code>std::ofstream</code> for output and <code>std::ifstream</code> for input.</li>
<li>Formatted/Unformatted I/O such as <code>operator&lt;&lt;()</code>, <code>operator&gt;&gt;()</code>, <code>read()</code> and <code>write()</code>.</li>
<li>In-memory I/O for manipulation of extracted data.</li>
</ul>

<p>What you need for this particular case is input stream functionality along with formatted input. The formatted input will be done through <code>operator&gt;&gt;()</code>.</p>

<p>But before you get to that, you have to instantiate a file stream. Since you're using input, <code>std::ifstream</code> will be used:</p>

<pre><code>std::ifstream in(""your/path.txt"");
</code></pre>

<p>The next thing to do is to create the three variables whose values you will extract into the stream. Since you know the types beforehand, the types you will need is an integer, character, and string respectively:</p>

<pre><code>int  num;
char letter;
std::string address;
</code></pre>

<p>The next thing to do is to use <code>operator&gt;&gt;()</code> to obtain the first valid value from the stream. The way it works is that the function analyses the type of the righthand operand and determines if the characters extracted from the file stream will create a valid value after parsing. When the stream hits whitespace, the new line character or the EOF (end-of-file) character (or a character that doesn't match that of the operand's type), extraction will stop.</p>

<p>What makes IOStreams powerful is that it allows chaining of expressions. So you are able to do this:</p>

<pre><code>in &gt;&gt; num &gt;&gt; letter &gt;&gt; address;
</code></pre>

<p>which is equivalent to:</p>

<pre><code>in &gt;&gt; num;
in &gt;&gt; letter;
in &gt;&gt; address;
</code></pre>

<p>This is all that is needed for this simple case. In more complex situations, loops and in-memory I/O might be needed for successful extractions.</p>
",1
19506921,19506896,4,"<p>I think the issue is here, in <code>resetBoard</code>:</p>

<pre><code>int used[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};
</code></pre>

<p>This creates a local variable called <code>used</code> that's equal to the array of -1's, rather than changing the <code>used</code> data member to hold all -1's.  To fix this, try replacing this code with the following:</p>

<pre><code>for (int i = 0; i &lt; 9; i++) {
    used[i] = -1;
}
</code></pre>

<p>There might be other issues there, but this is certainly suspicious.</p>

<p>Hope this helps!</p>
",0
19507002,19506896,0,"<p><code>number</code> is not being changed to some large value in <code>project1::found</code> it is your output from this <code>std::cout</code> that is confusing you:</p>

<pre><code>while(i &lt; 9 &amp;&amp; found == false){
    cout &lt;&lt; used[i];
</code></pre>

<p>if you change it to this, it will be obvious what is going on:</p>

<pre><code>while(i &lt; 9 &amp;&amp; found == false){
    cout &lt;&lt; std::endl &lt;&lt; used[i];
            ^^^^^^^^^
</code></pre>

<p>of you could add an <code>std::endl</code> here as well:</p>

<pre><code>cout &lt;&lt; "" your number after pass: "" &lt;&lt; number &lt;&lt; std::endl ;
</code></pre>
",0
18386595,18386433,1,"<p>The result of a <code>static_cast&lt;T&gt;(x)</code> where <code>T</code> is not a reference type is an <em>rvalue</em> of the given type. You cannot bind a non-const reference to an <em>rvalue</em>, and thus the error.</p>

<p>You could do <code>reinterpret_cast&lt;uf&amp;&gt;</code> to make the compiler happy, but you are probably trying to do something the wrong way, and chances are that you will hit undefined behavior in that piece of code somewhere.</p>

<p>The interesting question would be, how do you think that casting to the union type is going to help you? (that is, what is the original problem that you are trying to solve)</p>
",0
19957872,19952289,0,"<p><code>'=='</code> is highly suspect. String literals in C++ are written as <code>""==""</code>. <code>'c'</code> is the numerical value of the single character 'c'. Enums are a name-to-number mapping, not name-to-string. You probably want <code>namespace TType { const std::string SIGN_DOUBLEEQUALS  = ""==""</code>.</p>

<p>This change means all your other error messages are impacted and may well disappear.</p>

<p>The root cause is that for historical reasons, <code>'ab'</code> is allowed but doesn't have a well-defined meaning. Those reasons really don't matter to you; they're just there to keep
ancient code working.</p>
",0
19957989,19952289,0,"<p>In addition to the errors already addressed by the others, here are some ideas for improvement:</p>

<pre><code>#ifndef TOKEN_H_
#define TOKEN_H_

class Token {
public:
    enum TokenType {
        INTEGER,
        IDENTIFIER,
        PRINT,
        READ,
        SIGN_PLUS           ='+',
        SIGN_MINUS          ='-',
        SIGN_DIV            ='/',
        SIGN_MUL            ='*',
        SIGN_LESSTHAN       ='&lt;',
        SIGN_GREATERTHAN    ='&gt;',
        SIGN_EQUALS         ='=',
        // SIGN_DOUBLEEQUALS   ='==',
        // SIGN_NOTEQUALS      ='=!=',
        SIGN_NOT            ='!',
    };
private:
    int const line;
    int const column;
    TokenType const tokenType;
    int valueInt; //bei Integern muss Value gespeichert werden
    int const infoKey; //der Key aus der Symtableh
public:
    Token (int const line, int const column, TokenType const tokenType, int const infoKey) :
        line(line), column(column), tokenType(tokenType), infoKey(infoKey) {}
    void setValue (int const value) { valueInt = value; }
    void testPrint () const;
    virtual ~Token ();
};

#endif /* TOKEN_H_ */
</code></pre>

<ul>
<li>The <code>enum</code> should be defined within the <code>Token</code> class. The way you did it you can not have a variable of type <code>TokenType</code> (you could have one of type <code>TokenType::TType</code>).</li>
<li>There is no need for <code>TokenType.h</code>. You will never use the <code>enum</code> values without <code>Token.h</code>.</li>
<li>Put very simple methods into the hearder, as long as you do not have to <code>#include</code> anything for that. Here I did it for the constructor and for <code>setValue</code>.</li>
<li>Use always <code>const</code> if possible.</li>
</ul>

<p>Now here is the <code>Token.cpp</code> file:</p>

<pre><code>#include &lt;iostream&gt;

#include ""Token.h""

using namespace std;

void Token::testPrint() const {
    cout &lt;&lt; ""Token: Line: "" &lt;&lt; line &lt;&lt; "" Column: "" &lt;&lt; column &lt;&lt; "" TokenType: "" &lt;&lt; tokenType &lt;&lt; "" Infokey: "" &lt;&lt; infoKey &lt;&lt; endl;
}

Token::~Token() {
    // TODO Auto-generated destructor stub
}

int main () {
        Token (1, 1, Token::SIGN_LESSTHAN, 77) . testPrint ();
}
</code></pre>

<ul>
<li>You have to use <code>Token::SIGN_LESSTHAN</code> because the <code>enum</code> is now a member.</li>
<li>the <code>main</code> is for illustration only.</li>
<li>You should not put <code>using namespace</code> into any header or before any <code>#include</code>.</li>
</ul>
",0
18800834,18800732,1,"<p>If your call stack looks like:</p>

<pre><code>node::empprint
node::bfsprint
node::bfsprint
</code></pre>

<p>then returning from the final call will result in </p>

<pre><code>node::empprint
node::bfsprint
</code></pre>

<p>So your still N calls deep away from getting back to node::empprint.</p>

<p>You could set a bool in the class to return back out, but thats a bit hacky..</p>

<pre><code>void node::bfsprint(Linklist&lt;node*&gt; noddy)
{
   if ( something ) { m_unwindstack = true; }

   // setting the bool to force returning early/stop recursion once m_unwindstack  is true to get back to empprint
   if ( m_unwindstack ) { return; }
}
</code></pre>

<p>Edit: By the way if you're doing anything with Linklist you'll never seen the changes since your passing a copy of the data. You should pass a reference Linklist&amp;.</p>

<p>Also Linklist seems like your own class? So if you don't use a reference then be sure its copyable otherwise bad things will happen.</p>
",2
20750968,20750817,0,"<p>One error lies here:</p>

<pre><code>while (isdigit(eq[--num1begin])) 
  num1.insert(0, 1, eq[num1begin]);
</code></pre>

<p>If the string starts with a digit immediately followed by a <code>*</code>, this will test <code>eq[-1]</code> and that's not defined.</p>

<p>You may replace the <code>[]</code> operator call with <code>.at()</code> to explicit the error in a reliable manner (but that wouldn't fix anything - it is just for the exercise).</p>

<p>Also the next <code>while</code> probably has the same/mirrored problem with the end of the array (even though I would expect most implementations of <code>std::string</code> to be secretely zero terminated - but don't assume this, <strong>never</strong>).</p>
",2
19878328,19878260,0,"<p>You have to recursively call your <code>CompleteScan</code> function for every directory found.</p>
",0
19879513,19878260,0,"<p>Recursion! Pardon if I've dropped any punctuation; I don't have a Windows box to compile/test on.</p>

<pre><code>/**
 * @brief Accumulates the files and directories under the given root directory
 * into the output vectors allfiles and alldirs that you provide.
**/
void CompleteScan(const char root[],
                  WCHAR *Extension,
                  std::vector&lt;FileStruct&gt; &amp;allfiles,
                  std::vector&lt;WIN32_FIND_DATA&gt; &amp;alldirs)
{
    std::vector&lt;WIN32_FIND_DATA&gt; subdirs;

    // Assuming your Scan function does what needs to be done with the allfiles
    // vector. If not, more code needed somewhere here to handle that.
    Scan(root, Extension, allfiles, subdirs);

    if(dir.size() &gt; 0){
        for(int i = 0; i &lt; dir.size(); i++){
            // Visit this directory
            alldirs.push_back(dir);
            // Visit all descendant directories
            CompleteScan(dir.cFileName, Extension, allfiles, alldirs);
        }
    }
}
</code></pre>
",0
19316311,19316298,9,"<pre><code>test tob();
</code></pre>

<p>This <strong>declares</strong> a function which return type is <code>test</code>. <strong>It does not create an object.</strong> It's also know as <a href=""http://en.wikipedia.org/wiki/Most_vexing_parse"" rel=""nofollow"">most vexing parse</a>.</p>

<p>To create a <code>test</code> object:</p>

<pre><code>test tob;
</code></pre>

<p>Also, the way you define a function(include constuctor) with default argument is incorrect.</p>

<pre><code>test::test (int x=0) {  // incorrect. You should put it in function when it's first declared
 cout&lt;&lt;""default x=0"";
}
</code></pre>

<p>Below code should work:</p>

<pre><code>class test {
  int a;
  int b;

 public:
  explicit test (int = 0);    // default value goes here
};

test::test (int x) {          
 cout&lt;&lt;""default x=0"";
}

int main() {
 test tob;    // define tob object
}
</code></pre>
",5
19216820,19216799,2,"<p>In the three-parameter overload of <code>basic_istream::get</code>, the last parameter is a single character, not a string. Replace <code>""|""</code> with <code>'|'</code>.</p>
",1
19216056,19216026,3,"<p>I don't believe it's technically legal (per the standard) to call <code>main</code>. Even if it were, you'd be passing the wrong parameters (<code>argc == 1</code> and <code>argv == ${DEITY}_ONLY_KNOWS</code>).</p>

<p>This is a problem I would perhaps solve with a cmd script. Just make sure that your program is compiled, then run something like:</p>

<pre><code>@echo off
cd \path\to\debug\dir
rem this bit can be as complex as cmd.exe allows:
for /l %%a in (0,1,50) do (
    for /l %%b in (0,1,10) do (
        echo data.txt result.txt %%a %%b
    )
)
</code></pre>

<p>This will run a command (<code>echo</code> in my case so you can see it working but you should replace that with your actual executable name, and modify the cd command to select the proper directory) 561 times (51 x 11) with the first two arguments fixed and the last two running 0-50 and 0-10, the output of which finishes:</p>

<pre><code>: : : : : : : : : :
data.txt result.txt 49 7
data.txt result.txt 49 8
data.txt result.txt 49 9
data.txt result.txt 49 10
data.txt result.txt 50 0
data.txt result.txt 50 1
data.txt result.txt 50 2
data.txt result.txt 50 3
data.txt result.txt 50 4
data.txt result.txt 50 5
data.txt result.txt 50 6
data.txt result.txt 50 7
data.txt result.txt 50 8
data.txt result.txt 50 9
data.txt result.txt 50 10
</code></pre>

<p>There <em>may</em> be a way to get VS to do this automatically as part of a build/run sequence but I'm not aware of any (and I tend to opt for the simplest solutions most of the time).</p>

<hr>

<p>You could, of course, refactor your code so that you rename <code>main</code> to something else then have a filter <code>main</code> as follows:</p>

<pre><code>int main (int argc, char *argv[]) {
    // Do this normally:
    return worker (argc, argv);

    // Or do this for debugging:
    // int stat = 0;
    // for (int i = 0; i &lt; 10; i++) {
    //     // construct argv-lookalike based on i.
    //     stat = worker (myargc, myargv);
    //     if (stat != 0) break;
    // }
    // return stat;
</code></pre>

<p>However, the construction of an argv-array is not trivial since you have to follow the same rules as laid out in the standard, specifically that <code>argc</code> and <code>argv</code> must agree, <code>argv</code> must an array of character pointers (one more than is indicated by <code>argc</code>) so that each argument is a C-style string, <code>argv[0]</code> must represent the program name, <code>argv[argc]</code> must be NULL, and so on.</p>

<p>It's probably easiest to use the <code>cmd</code> script solution and let the startup code take care of all that argument preparation for you.</p>
",8
19216099,19216026,4,"<p>In C++ it is illegal to call <code>main</code> within a program (C++11 3.6.1/3). However, <em>any</em> work that is done inside <code>main</code> can easily be done in another function.</p>

<pre><code>int main( int argc, char** argv ) {
    foo( argc, argv );
}

int foo( int argc, char** argv ) {
    // do something
}
</code></pre>

<p>At this point, feel free to call <code>foo(...)</code> as many times from within your program (or Visual Studio debugger) as you want.</p>
",0
19216142,19216026,2,"<p>Let's say you have this hypothetical program:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
using namespace std;

int main(int argc, char* argv[])
{
    if(argc != 2)
    {
        cerr &lt;&lt; ""bad input"" &lt;&lt; endl;
        exit(1);
    }
    auto arg = atoi(argv[1]);
    cout &lt;&lt; (2*arg) &lt;&lt; endl;
}
</code></pre>

<p>You could use a batch script.  Save the following as <code>test.bat</code> in the same directory as your program executable. Type <code>help</code> or specifically <code>help for</code> in a command prompt for more information about batch file commands:</p>

<pre><code>@echo off
for /L %%i in (0,1,9) do prog.exe %%i
</code></pre>

<p>Output:</p>

<pre><code>0
2
4
6
8
10
12
14
16
18
</code></pre>

<p>Or you could refactor main to loop and call a function:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

void func(int arg)
{
    cout &lt;&lt; (2*arg) &lt;&lt; endl;
}

int main()
{
    for(auto i = 0; i &lt; 10; ++i)
        func(i);
}
</code></pre>

<p>Output:</p>

<pre><code>0
2
4
6
8
10
12
14
16
18
</code></pre>
",2
19968711,19968646,0,"<pre><code>void binRead(zipType *zip, fstream *input)
{
    input-&gt;read((char*)( &amp;zip-&gt;postalCode ),  sizeof(int   ));
    input-&gt;read((char*)( &amp;zip-&gt;longitude  ),  sizeof(double));
    input-&gt;read((char*)( &amp;zip-&gt;latitude   ),  sizeof(double));
    zipToCout(*zip);
}
</code></pre>

<p>Also, depending on the architecture (ie. 32-bit x86), the following <em>may</em> work:</p>

<pre><code>void binRead(zipType *zip, fstream *input)
{
    input-&gt;read((char*) zip, sizeof(zipType));
    zipToCout(*zip);
}
</code></pre>

<p>That will only work on architectures where <code>double</code> only requires 4-byte alignment.  I believe 32-bit x86 fits that.  A quick test I wrote locally suggests that's the case.</p>

<p>A quick note on portable, maintainable code that goes beyond the immediate need above:  Code such as the above works well enough when the machine saving the data is the same as the machine that later reads the data.  It does, however, result in portability problems.  If you really want to design a file format that's portable across machines and preserves data, the above techniques aren't really conducive to that.  </p>
",10
19968933,19968646,0,"<p>I think the problem lies in while printing the values.
if you see the value is read in string and printed as other datatypes. I guess proper conversion function should work for you. and use see my comments below.</p>

<pre><code>void binRead(zipType &amp;zip, fstream &amp;input){
    char* temp = NULL
    char* temp2 = NULL;
    zipType tempZip;
    tempZip = zip; 
    //cout &lt;&lt; ""Reader at location "" &lt;&lt; input.tellg() &lt;&lt; endl;
    input.read(temp,sizeof(int));
    tempZip.postalCode=(atoi)temp; //use for proper conversion, or other function
    input.read(temp2,sizeof(double));
    tempZip.longitude=static_cast&lt;double*&gt;temp2; //use for proper conversion, or other function
    input.read(temp2,sizeof(double));
    tempZip.latitude=static_cast&lt;double*&gt;temp2; 
    zipToCout(tempZip);
    }
</code></pre>

<p>Few comments on above code, </p>

<pre><code>tempZip = zip; //why this, since you havn't declared any proper assignment 
operator. Use memcpy instead.  
</code></pre>

<p><code>tempZip.postalCode=(atoi)temp; //use for proper conversion, or other function</code></p>

<pre><code>tempZip.longitude=static_cast&lt;double*&gt;temp2; //use for proper conversion, or other function
</code></pre>

<p>Let me know if this solves your problem.</p>
",7
18766244,18766159,6,"<p><code>clrscr()</code> didn't get deprecated because it was never part of any standard. It was a vendor-specific function provided as an extension by Borland in the (also non-standard) <code>&lt;conio.h&gt;</code> header. Modern compilers no longer provide this function.</p>

<p>There's a couple of ways to emulate it, and I'm sure you can find it here - just look at the links in the Related section on the right side.</p>
",1
18766319,18766159,1,"<p>The <code>Conio.h</code> header is not a part of C Standard Libary. According to wikipedia:</p>

<blockquote>
  <p>conio.h is a C header file used mostly by MS-DOS compilers to provide console input/output.<a href=""https://stackoverflow.com/questions/6486289/how-can-i-clear-console"">1</a> It is not described in The C Programming Language book, and it is not part of the C standard library, ISO C nor is it defined by POSIX.</p>
</blockquote>

<p>So you just don't have this header.</p>

<p>The errors you are getting are linker errors reporting that it can't find the <code>clrscr()</code> function in any of the headers that hare available for it.</p>

<p>Also, check <a href=""https://stackoverflow.com/questions/6486289/how-can-i-clear-console"">this question.</a></p>
",2
19884605,19884536,19,"<p>The <code>roundf()</code> function is defined by C99, but MSVC implements very little of C99, so it is not available with the Microsoft compilers. </p>

<p>You can use this one:</p>

<pre><code>float roundf(float x)
{
   return x &gt;= 0.0f ? floorf(x + 0.5f) : ceilf(x - 0.5f);
}
</code></pre>
",4
19791128,19790754,0,"<p>Change the way you declared your shape in Driver class. In the header, declare it as :</p>

<pre><code>Shape* d;
</code></pre>

<p>and in your CPP initialize it:</p>

<pre><code>d = new Shape[MAX];
</code></pre>

<p>Also, since you are doing inheritance and arrays and pointers, you should manage your own destructors. Because if the chil object gets destroyed, it will take parent destructor. Therefore, your destructors should be:</p>

<pre><code>virtual ~Shape();
</code></pre>

<p>And square:</p>

<pre><code>virtual ~Square();
</code></pre>

<p>In them, delete the pointers:</p>

<pre><code>delete x; // in case of square
delete y;
</code></pre>

<p>And when you have arrays:</p>

<pre><code>delete [] d; // in case of driver class
</code></pre>

<p>Otherwise it will not free memory properly. That would probably fix your problems.</p>
",2
18465147,18465048,3,"<p>The problem here is that you create two instances of the <code>points</code> class. One temporary with <code>points()</code> and of course one with the declaration of <code>x1</code>.</p>

<p>When you do <code>x1 = points()</code> you create a temporary object with the <code>points()</code> construct, this is then copy-assigned to <code>x1</code>, and then the temporary object is destroyed. Since you do not provide a copy-assignment operator, the compiler will create one for you, but it simply copies the pointer, and don't allocate new memory. This means you for a while have two objects containing a pointer to the same memory. When the temporary object is destroyed you free the memory in the destructor, leaving the pointer in <code>x1</code> dangling. When <code>x1</code> is destroyed you try to delete this dangling pointer, leading to the double-free error.</p>

<p>The best way to solve this, is to implement a copy-assignment operator, and preferably a copy-constructor as well, and in those allocate new memory and copy the data.</p>
",0
19508836,19508757,0,"<p>I just tried running your code. It works fine only  need to input one time. This is what I ran on my compiler.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

int main(void)
{
int n0,n1,n2;
int move = 0;
long unsigned int arr[3][3];
string  str;
char color[4]={'B','G','C','\0'};
char col[40];
    while( getline(cin,str) )
      {
        cout&lt;&lt;""hello"";
  }
return 0;

}
</code></pre>

<p>OUTPUT</p>

<p><img src=""https://i.stack.imgur.com/uqbBO.png"" alt=""Output""></p>

<p>OUTPUT 2</p>

<p><img src=""https://i.stack.imgur.com/4rp8D.png"" alt=""enter image description here""></p>

<p>OUTPUT 3</p>

<p><img src=""https://i.stack.imgur.com/5j6uk.png"" alt=""enter image description here""></p>
",3
18827072,18827051,9,"<pre><code>A b();
</code></pre>

<p>it does not define an object, it declares a function which returns type <code>A</code>, It's also well known as <a href=""http://en.wikipedia.org/wiki/Most_vexing_parse"" rel=""noreferrer"">most vexing parse</a>.</p>
",1
18827104,18827051,2,"<pre><code>A b(); // Case2: Calling implicit default constructor
</code></pre>

<p>The comment is <strong>incorrect</strong>. <code>A b();</code> is a function declaration (The function is called <code>b</code> and returns an object of type <code>A</code> and you intend to <em>define</em> the function later) <strong>not</strong> an object definition.</p>
",4
18827378,18827051,0,"<p>Case 1: </p>

<pre><code>    A a; // Case1: calling explicit Default constructor
</code></pre>

<p>Calls the implicit default constructor, since you hadn't provided one in the class.</p>

<p>Case 2:</p>

<pre><code>   A b(); // Case2: Calling implicit default constructor
</code></pre>

<p>It is the function decleration say ""b"" is the function name and it takes no argument and returns A object.</p>

<p>Hope it helps.</p>
",0
18865835,18865756,37,"<p>Two approaches come to mind:</p>

<ol>
<li><p>Add an explicit conversion for the 'signed' types.</p>

<pre><code>#include &lt;cassert&gt;

class A {
    unsigned int x;
    public:
    A(unsigned int X) : x(X) {}
    explicit A(int X) : x(static_cast&lt;unsigned&gt;(X)) {
        assert(X&gt;=0); // note X, not x!
    }
};

int main()
{
    A ok(5);
    A bad(-5);
}
</code></pre></li>
<li><p>Prohibit implicit conversions by deleting better overloads:</p>

<pre><code>A(int X) = delete;
A(long X) = delete;
A(char X) = delete;
</code></pre>

<p>This will require all users to cast to unsigned <em>before</em> constructing the A instance. It's safe but clumsy. </p></li>
</ol>

<p>Note that this does <strong>not</strong> prohibit implicit conversions from <strong>all</strong> integral types (e.g. <code>enum</code>s) so you'd need to do more to make this fool proof. </p>

<p>Here is a rudimentary SFINAE-based example that accepts all implicit conversions <strong>except</strong> if they involve signed values: <strong><a href=""http://coliru.stacked-crooked.com/a/72ef5c7b19533eed"" rel=""nofollow"">Live on Coliru</a></strong></p>

<pre><code>#include &lt;type_traits&gt;
#include &lt;limits&gt;

class A {
    unsigned int x;
    public:
    template&lt;typename T, typename = typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, void&gt;::type&gt;
    A(T X) : x(X)
    {
        static_assert(!std::numeric_limits&lt;T&gt;::is_signed, ""Signed types cannot be accepted"");
    }
};

int main()
{
    A ok(5u);
    A bad(-5);
}
</code></pre>
",8
18867875,18865756,1,"<p>I probably agree with <em>DanielKO</em> about <code>pattern will pop up everywhere</code>. And note that <em>sehe</em> SFINAE-based solution don't work for uint64 -> uint32 <a href=""http://coliru.stacked-crooked.com/a/f9e779bde312efe2"" rel=""nofollow"">truncation</a>. So my answer:</p>

<pre><code>class A {
 public:
  using value_type = unsigned int;

  template &lt;class T&gt;
  explicit A(T x): x_(boost::numeric_cast&lt;value_type&gt;(x)) { // can be check in debug only
    static_assert(std::is_integral&lt;T&gt;::value, ""T must be integral"");
  }

 private:
  value_type x_;
};
</code></pre>

<p>And <a href=""http://coliru.stacked-crooked.com/a/d493050830bae329"" rel=""nofollow"">live example</a>.</p>
",0
18868417,18865756,7,"<blockquote>
  <p>And lets say someone accidentally creates an A object with the value -5</p>
</blockquote>

<p>While it may be good practice to make your program robust enough to accept such errors, the root cause of the bug is a sloppy programmer who does not have sufficient warnings enabled.</p>

<p>To get to the bottom of the problem, you need to ensure that the code is compiled with all warnings enabled, and perhaps also consider using an external static analysis tool. </p>
",0
18901407,18900125,2,"<p>As @BenjaminLindley mentioned, there are many places that allocators may be used inside containers.  One example is <code>push_back</code>, <strong>which uses allocator traits to construct a copy of its argument inside the container</strong>.</p>

<p>The standard (23.2.3) describes <code>push_back</code> as:</p>

<blockquote>
<pre><code>a.push_back(t)
</code></pre>
  
  <p>Appends a copy of t. Requires: T shall be CopyInsertable into X.</p>
</blockquote>

<p>Later, the term CopyInsertable is defined as:</p>

<blockquote>
  <p>T is CopyInsertable into X means that, in addition to T being
  MoveInsertable into X, the following expression is well-formed:</p>

<pre><code>allocator_traits&lt;A&gt;::construct(a, p, t)
</code></pre>
</blockquote>

<p>...which can be turned into:</p>

<blockquote>
<pre><code>a.construct(p, t)
</code></pre>
</blockquote>

<p>...which effectively uses the allocator <code>a</code> to construct a copy of <code>t</code> at location <code>p</code>.</p>
",0
18901952,18900125,2,"<p>Different compilers use different implementations of the STL, and it is up to these implementations to determine how they use the Allocators. This can lead to some unfortunate results.</p>

<p>For example, I work primarily with embedded systems based on the ARM architecture, and at one point, I tried to implement my own Allocator based on fixed-size memory blocks for use with <code>list</code>, <code>map</code>, and <code>set</code> (I wasn't expecting it to work for <code>vector</code>, since a large-enough vector would exceed the size of the blocks). In the process, I discovered that the ARM compiler v3.1 uses a version of the RogueWave implementation of the STL in which some containers made certain assumptions about the behavior of Allocators. In the case of <code>map</code> and <code>set</code>, for instance:</p>

<ul>
<li>It never called <code>Allocator::max_size()</code> - it assumed that it returned something big enough that it didn't have to worry about it.</li>
<li>It assumed that <code>allocate()</code> was slow, and tried to optimize it by allocating several objects at once (<code>vector</code> is designed to do this, but I wasn't expecting the same behavior to apply to containers like <code>map</code> and <code>set</code> that don't use contiguous memory). Basically, instead of calling <code>allocate(sizeof(T))</code>, it called <code>allocate(sizeof(T) * 20)</code> to get a pool of memory that it could then re-allocate internally as new objects were created.</li>
</ul>

<p>These assumptions pretty much torpedoed my attempts to use the STL in that project - I eventually wound up using <code>boost::intrusive</code> containers instead.</p>
",0
18902829,18900125,0,"<p>Regarding ""Knowing that, why one needs a custom allocator, what does it change ?""</p>

<ul>
<li>A custom allocator may optimize allocations of small objects</li>
<li>optimize allocations of objects having a common size </li>
<li>squeeze the last bit out of memory </li>
<li>...</li>
</ul>

<p>The default one has one strategy, only (likely).</p>
",0
19446626,19446585,3,"<p>If you just call </p>

<pre><code>&gt; print
</code></pre>

<p>you are actually executing <code>/usr/bin/print</code>, that from the man page is </p>

<blockquote>
  <p>NAME<br>
        run-mailcap, view, see, edit, compose, print - execute programs via entries in the mailcap file</p>
</blockquote>

<p>Tu run your code you should do one of these three things:</p>

<ol>
<li><p>If from the same directory </p>

<pre><code>&gt; ./print
</code></pre></li>
<li><p>From an other directory</p>

<pre><code>&gt; /path/to/exe/print
</code></pre></li>
<li><p>Add the directory where the exe live (<code>/path/to/exe/</code>) in the <code>PATH</code> before <code>/usr/bin</code></p>

<pre><code>&gt; export PATH=/path/to/exe:$PATH
&gt; print
</code></pre>

<p>If you want to add it permanently, just add <code>export PATH=/path/to/exe:$PATH</code> to you <code>~/.profile</code> file</p></li>
</ol>
",0
19446635,19446585,1,"<p><code>print</code> is the name of a program from mailcap package. Typing <code>print</code> into the shell and hitting the Return key will execute it (from <code>/usr/bin/print</code>). Start your program by typing <code>./print</code>.</p>
",0
19446674,19446585,4,"<p>By typing <code>print</code> in your shell you are executing the <code>print</code> command, which is a built-in of your shell that prints nothing without any arguments.</p>

<p>To launch your binary, type <code>./print</code>. This solves the confusion between the <code>print</code> command and the binary <code>print</code> in the current directory.</p>
",0
19788379,19788273,2,"<p>You forgot about the newline.
cin reads <em>every</em> character, which includes the newline you type after typing your character.
If you don't want this behaviour, you have to specifically check for newline.</p>

<pre><code>while (letter!= 'X')
{
      if (letter == '\n')
      {
          letter = cin.get();
          continue;
      }
      cout&lt;&lt;letter&lt;&lt;endl;
      cout&lt;&lt;""this will be written twice for ununderstandable reasons"";
      letter= cin.get();
}
</code></pre>
",6
19788480,19788273,2,"<p>When you type in a character the new-line character (from pressing enter) is also in your input buffer.</p>

<p><a href=""http://www.cplusplus.com/reference/istream/istream/get/"" rel=""nofollow"">From the C-Reference:</a></p>

<blockquote>
  <p>The delimiting character is not extracted from the input sequence if found, and remains there as the next character to be extracted from the stream (see getline for an alternative that does discard the delimiting character).</p>
</blockquote>

<p>Just use a <code>cin.sync()</code> after every <code>cin.get()</code> to clear the buffer and you should be good to go.</p>
",0
19788417,19788273,2,"<p>You are reading every character with the unformatted <code>get()</code> function, including the newline character each time you hit return.</p>

<p>Depending on what you're trying to do, you could use formatted input (<code>cin &gt;&gt; c</code>) to skip all whitespace; or you could test each character and ignore things like newline that don't interest you; or you could use <code>getline(cin, some_string)</code> to read a whole line, and then process that.</p>
",1
19788532,19788273,2,"<p>as everyone already mentioned, <code>cin</code> will append the newline marker <code>\n</code> every time you hit enter. another solution is to place <code>cin.ignore();</code> after every <code>cin.get();</code>.</p>

<pre><code>#include &lt;iostream&gt;

using std::cin;
using std::cout;
using std::endl;

int main()
{
    char letter;

    letter = cin.get();
    cin.ignore();
    while (letter!= 'X')
    {
          cout&lt;&lt;letter&lt;&lt;endl;
          cout&lt;&lt;""this will be written twice for ununderstandable reasons"";
          letter= cin.get();
          cin.ignore();
          }
}
</code></pre>
",3
19788695,19788273,2,"<p>The text 'this will be written twice..' will not necessarily print twice.</p>

<p>Type 'qwerty' + ENTER and your stream will have ""qwerty\n"" within and you'll see this output:</p>

<pre><code>this will be written twice for ununderstandable reasons
this will be written twice for ununderstandable reasons
this will be written twice for ununderstandable reasons
this will be written twice for ununderstandable reasons
this will be written twice for ununderstandable reasons
this will be written twice for ununderstandable reasons
this will be written twice for ununderstandable reasons
</code></pre>

<p>Exactly that many as string ""qwerty\n"" has characters.
The problem is that </p>

<blockquote>
  <p>cin.get()</p>
</blockquote>

<p>Puts all chars that you type into a stream/buffer (not your letter char) but handles <strong>one</strong> char every cin.get() invocation.</p>

<p>When you type 'abcXd' + enter - the program will print above line 3 times and stop on X.</p>
",0
19788619,19788273,1,"<p>It happens because cin.get() reads <code>new-line</code> character too. Try to press <code>Enter</code> without any symbols or type some string, like <code>abc</code>.
You need to handle it, e.g.:</p>

<pre><code>while (letter = cin.get()) {
    if (!isalpha(letter)) { continue; }
    // handling user inputted alpha
}
</code></pre>
",0
18832661,18832543,1,"<p>Yes, it's possible, using <code>enable_if</code>. But it's horrible. I'll be writing this in C++11.</p>

<pre><code>template &lt;typename T&gt; struct is_holder {
  static constexpr bool value = false;
};
template &lt;typename T&gt; struct is_holder&lt;Holder&lt;T&gt;&gt; {
  static constexpr bool value = true;
};

template &lt;typename T,
          typename = typename std::enable_if&lt;is_holder&lt;T&gt;::value&gt;::type&gt;
T f1() {
  // T is Holder&lt;U&gt;
}

template &lt;typename T,
          typename = typename std::enable_if&lt;!is_holder&lt;T&gt;::value&gt;::type&gt;
T f1() {
  // T is not Holder&lt;U&gt;
}
</code></pre>

<p>You still have to explicitly specify the template argument when you call it, of course.</p>
",0
18832767,18832543,3,"<p>Aside from the approach using SFINAE (<code>std::enable_if</code>), you can use partial specialization. Since partial specialization isn't possible with function template, it requires a bit of jumping through hoops, though:</p>

<pre><code>template &lt;typename T&gt;
struct f1_specialization {
    static T f1() { ... }
};
template &lt;typename T&gt;
struct f1_specialization&lt;Holder&lt;T&gt;&gt; {
    static Holder&lt;T&gt; f1() { ... }
};
template &lt;typename T&gt;
T f1() { return f1_specialization&lt;T&gt;::f1(); }
</code></pre>

<p>Either approach may be more or less clear and they should both work.</p>
",1
18833557,18832543,0,"<p>Checkout <a href=""http://en.cppreference.com/w/cpp/language/decltype"" rel=""nofollow"">decltype</a>.</p>

<pre><code>    template &lt;class T, class U&gt;
    auto add(T t, U u) -&gt; decltype(t + u);
</code></pre>
",2
19885996,19885859,1,"<p>Everything about <code>#pragma</code> is specific to the compiler.</p>

<p>Most compilers do not provide a catch-all command line modification facility because it is difficult in general to change parameters without violating internal invariants and expectations. It would make the compiler unstable.</p>

<p>A more typical solution would be something like this:</p>

<pre><code>#ifndef _OPENMP
#   error Please pass the -openmp or equivalent compiler flag for my library.
#endif
</code></pre>
",1
20200381,20200309,3,"<p>The problem is that <code>0.1</code> isn't exactly representable as a binary floating-point number. Each <code>float</code> value is slightly less than you expect, and conversion to <code>int</code> rounds down, giving a value one less than you expect.</p>

<p>You can get the expected values by rounding to the nearest integer:</p>

<pre><code>int wtf = std::round(offset);
</code></pre>
",0
20200428,20200309,1,"<p>when <code>i = 40.1f</code> offset will be <code>3.99993896</code> which is not exactly 4. For your example you can use <code>std::round(offset)</code> if you use c++11 standard or if round is not available <code>std::floor(offset + 0.5f);</code></p>

<p>Floating points can't represent all the values in the universe and when in some cases the math  on papers is correct on floating points it might not be.</p>
",0
20202605,20200309,0,"<p>0.1 expressed in base 2 is</p>

<pre><code>0.0001100110011001100110011001100110011...
</code></pre>

<p>The <code>0011</code> in the fraction repeats infinitely, just as <code>3</code> does in 1/3=0.3333333... base 10. Since actual float values can only hold a finite number of digits, there will necessarily be an error in the approximation.</p>

<p>The only fractional numbers that can be precisely expressed with a finite number of digits in base 2 are those rational numbers whose denominator is a whole power of 2. So for example, replacing 0.1f with 0.125f (=1/8)</p>

<pre><code>for(float i = 40; i &lt;= 42; i+=0.125f)
{
    float offset = (i-40) * 10 * sizeof(float);
    int wtf = offset;
    printf(""%.1f =?= %d\n"", offset, wtf);
}
</code></pre>

<p>results in values with no truncation error:</p>

<pre><code>0.0 =?= 0
5.0 =?= 5
10.0 =?= 10
15.0 =?= 15
20.0 =?= 20
25.0 =?= 25
30.0 =?= 30
35.0 =?= 35
40.0 =?= 40
45.0 =?= 45
50.0 =?= 50
55.0 =?= 55
60.0 =?= 60
65.0 =?= 65
70.0 =?= 70
75.0 =?= 75
80.0 =?= 80
</code></pre>

<p>This is because <code>0.125</code> base 10 is precisely equal to <code>0.001</code> base 2.</p>
",0
20626300,20626202,1,"<p>On the iteration that <code>while(input.find(' ', pos1) != string::npos)</code> fails to find a space character, <code>input[pos1]</code> points to the last non-space character.</p>

<p>That's because spaces are between the characters, not after them.  This is what is sometimes called a ""fencepost error"".  It comes from a logic puzzle:  ""Suppose you want to put a fence along a 10m stretch, with one fencepost every 1m.  How many fenceposts do you need?"" 10 might seem the obvious answer, but 11 is the better answer, as 10 gaps need 11 fenceposts.  Same idea here.</p>

<p>A more obvious way to write the logic would be to search for the characters, not the spaces between them.  For example:</p>

<pre><code>    while( (pos2 = input.find_first_of(""ABCDEFGHIJKLMNOPQRSTUVWXYZ"", pos1)) != string::npos)
    {
        char vertex = input[pos2];
        listOrder.push_back(vertex);
        Vertex* newVertex = new Vertex(vertex);
        adjacencyList.insert(make_pair(vertex, newVertex));
        pos1 = pos2 + 1;
    }
</code></pre>

<p>Note that you will have to change the declaration for <code>pos1</code> and <code>pos2</code> to <code>std::string::size_type pos1, pos2;</code>.  And actually, you don't need two separate <code>pos</code> variables:</p>

<pre><code>    std::string::size_type pos = 0;

    while( (pos = input.find_first_of(""ABCDEFGHIJKLMNOPQRSTUVWXYZ"", pos)) != string::npos)
    {
        char vertex = input[pos];
        listOrder.push_back(vertex);
        Vertex* newVertex = new Vertex(vertex);
        adjacencyList.insert(make_pair(vertex, newVertex));
        ++pos;
    }
</code></pre>
",3
19323696,19323641,-1,"<p>You <em>re-create</em> your <code>Point</code> object with the final coords every time you enter ""no"". This is why you only keep the last pair.</p>

<p>On an unrelated note, you should probably simplify the code significantly. There is no reason for <code>Point</code> object to keep a vector of <code>Point</code> objects in the first place. You probably want to keep a history/sequence of raw coordinates there and have something like:</p>

<pre><code>Point mypt;

while (options == ""yes"") {
    mypt.AddCoords(x, y);
    // read more coords/options
}

// do stuff on filled mypt object
</code></pre>
",0
19324163,19323641,2,"<pre><code>int main()
{
    // don't need global variables, just define local ones here
    int x,y;
    Point point;
    string options;

    // You shouldn't store the vector of Points in the Point class itself.
    // It doesn't have anything to do with a Point. classes should generally
    // only contain relevant information (ex. Point contains only x and y coords).
    vector&lt;Point&gt; pointsVector;

    // do-while will do the contents of the loop at least once
    // it will stop when the while condition is no longer met
    do
    {
        cout &lt;&lt; ""Please Enter x-Cordinate""&lt;&lt; endl;
        cin &gt;&gt; x;
        cout &lt;&lt; ""Please Enter y-Cordinate"" &lt;&lt; endl;
        cin &gt;&gt; y;

        pointsVector.push_back(Point(x, y));

        cout &lt;&lt; ""Enter cords again? yes/no""&lt;&lt; endl;
        cin &gt;&gt; options;
    } while (options == ""yes"")

    // don't really need to check if options is ""no""
    // if you have exited the do/while loop above, the assumption is that you don't 
    // want to enter more coordinates.
    doSomethingWithTheVectorOfPoints(pointsVector);

    return 0;
}
</code></pre>

<p>In the function <em>doSomethingWithTheVectorOfPoints</em>, you can place the code for outputting the X and Y coordinates. (You can also just loop through the vector in the main function directly instead.)</p>

<p>Also, you could add a member function to your Point class called ToString or Print to do the work for you.</p>

<p><strong>Edit</strong>: I didn't actually compile this, it's just to give you an idea of how you could rewrite your code.</p>
",0
19324793,19323641,0,"<p>You should have:</p>

<ul>
<li>No global variables</li>
<li>A point class supporting stream input (output)</li>
<li>The stored data out of the point class (why should a poor point manage that?)</li>
<li>Stream input with validation.</li>
</ul>

<p>Example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;

struct Point {
    int x;
    int y;
};

std::istream&amp; operator &gt;&gt; (std::istream&amp; in, Point&amp; point) {
    return in &gt;&gt; point.x &gt;&gt; point.y;
}

typedef std::vector&lt;Point&gt; PointStorage;

int main()
{
    PointStorage point_storage;
    Point point;
    while(true) {
        std::cout &lt;&lt; ""Please enter X and Y xordinates or 'no' to stop input"" &lt;&lt; std::endl;
        std::string line;
        if( ! std::getline(std::cin, line))
            throw std::invalid_argument(line);
        else {
            std::istringstream point_input(line);
            // Skip leading white spaces, read a point, skip trailing white apace
            // and ensure no additional character is left.
            if(point_input &gt;&gt; point &gt;&gt; std::ws &amp;&amp; point_input.eof()) {
                point_storage.push_back(point);
            }
            else {
                std::string no;
                std::istringstream no_input(line);
                // Skip leading white spaces, read ""no"", skip trailing white apace
                // and ensure no additional character is left.
                if(no_input &gt;&gt; no &gt;&gt; std::ws &amp;&amp; no_input.eof() &amp;&amp; no == ""no"") {
                    break;
                }
                throw std::invalid_argument(line);
            }
        }
    }
    for(PointStorage::const_iterator pos = point_storage.begin();
        pos != point_storage.end();
        ++pos)
    {
        std::cout &lt;&lt; pos-&gt;x &lt;&lt; "", "" &lt;&lt; pos-&gt;y &lt;&lt; '\n';
    }
    return 0;
}
</code></pre>

<p>Note: Throwing exceptions is likely a bad decision, but it simplifies the example.</p>
",0
19445008,19444880,0,"<p>We'll need a structure to capture your data first:</p>

<pre><code>struct Data {
   unsigned int id;
   string name;
   unsigned int age;
   time_t time; // might be a C++ data type for this
}
</code></pre>

<p>You'll essentially have a <code>vector&lt;Data&gt;</code></p>

<p>You can overload <code>operator &lt;&lt;</code> to read in a string line and populate these fields. 
Most important thing is NOT to have 4 arrays for this task, but instead one array (please use vector instead) and encapsulate the fields into a bigger type.</p>
",2
19799218,19799134,3,"<p>Working with <code>std::list</code> to access items, you can use iterators. For example:</p>

<p>C++11:</p>

<pre><code>auto itr = eventlist.begin();

for (auto x : itr-&gt;P)
    cout &lt;&lt; x &lt;&lt; endl;
</code></pre>

<p>Before C++11:</p>

<pre><code>list&lt;nodepoint&gt;::iterator itr = eventlist.begin();

for (list&lt;float&gt;::iterator itr2 = itr-&gt;P.begin(); itr2 != itr-&gt;P.end(); itr2++)
   cout &lt;&lt; *itr2 &lt;&lt; endl;
</code></pre>

<p>I assumed the lists are not empty.</p>
",0
19799309,19799134,0,"<p>For example</p>

<pre><code>eventlist.back().P.back();
</code></pre>

<p>or</p>

<pre><code>eventlist.back().P.front();
</code></pre>

<p>or</p>

<pre><code>eventlist.front().P.front();
</code></pre>

<p>or</p>

<pre><code>eventlist.front().P.back();
</code></pre>

<p>or</p>

<pre><code>for ( nodepoint &amp;nd : eventlist )
{
   for ( float x : nd.P ) std::cout &lt;&lt; x &lt;&lt; ' ';
   std::cout &lt;&lt; std::endl;
}
</code></pre>

<p>Or you can use iterators that to get access to an element in the middle of a list.</p>
",0
18360138,18359989,1,"<p>You may try:</p>

<pre><code>cout &lt;&lt;  ""\n\n-----------------\n"";
cout &lt;&lt; setw(8) &lt;&lt; left &lt;&lt; ""F\t\t|"";   // insert more tab here
cout &lt;&lt; setw(8) &lt;&lt; left &lt;&lt; ""x\t|"";
cout &lt;&lt;  ""\n-----------------\n"";
//...
cout.width(8);
cout.setf(ios::left);
cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; F &lt;&lt; ""\t|""; 

cout.width(8);
cout.setf(ios::left);
cout &lt;&lt; x &lt;&lt; ""\t|"";
cout &lt;&lt;  ""\n-----------------\n\n"";
</code></pre>
",0
18360179,18359989,1,"<p>The console screen looks suspiciously Windows like.
If you are using Windows, you can use the Win32 API to format output more precisely.
In particular, you can use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/ms686025%28v=vs.85%29.aspx"" rel=""nofollow"">SetConsoleCursorPosition</a>.</p>

<pre><code>COORD position = {x,y};
HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
SetConsoleCursorPosition(hOut, position);
std::cout&lt;&lt;""This will be printed starting at position x, y""&lt;&lt;std::endl;
</code></pre>
",6
18360330,18359989,4,"<p>I used the same code as you did and got the same output until I removed the \t at the end of the line. See the new code:</p>

<pre><code>cout &lt;&lt;  ""\n\n-----------------\n"";
cout &lt;&lt; setw(8) &lt;&lt; left &lt;&lt; ""F\t|"";
cout &lt;&lt; setw(8) &lt;&lt; left &lt;&lt; ""x\t|"";
cout &lt;&lt;  ""\n-----------------\n"";
//...
cout.width(8);
cout.setf(ios::left);
cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; F &lt;&lt; ""|"";

cout.width(8);
cout.setf(ios::left);
cout &lt;&lt; x &lt;&lt; ""|"";
cout &lt;&lt;  ""\n-----------------\n\n"";
</code></pre>
",1
18361091,18359989,3,"<p>As already noted, it's the tabs that are causing the problem.</p>

<p>I would <em>not</em> stop at just removing the tabs though. As it stands right now, your code is highly repetitive and next to impossible to maintain. I'd do a (nearly) complete rewrite, with a couple of functions to cut down on the repetition. My first cut would probably look something like this:</p>

<pre><code>// format a value in a field of specified width, followed by a separator
template &lt;class T&gt;
string field(T val, int w, char sep = '|') {
    stringstream b;
    b &lt;&lt; setw(w) &lt;&lt; left &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; val &lt;&lt; sep;
    return b.str();
}

// generate a separator for a specified number of fields,
// each of a specified width
string sep(int c, int w, char val = '-') {
    string s(c * (w + 1), val);
    return string(""\n"") + s + ""\n"";
}

int main() {
    static const int w = 8;
    double F = 1.234, x = 3.45;
    string s = sep(2, w);

    cout &lt;&lt; ""\n"" &lt;&lt; s;
    cout &lt;&lt; field(""F"", w) &lt;&lt; field(""x"", w) &lt;&lt; s;
    cout &lt;&lt; field(F, w) &lt;&lt; field(x, w) &lt;&lt; s;
}
</code></pre>

<p>Seems to me that this makes the code rather more readable and quite a bit more maintainable. For example, if we decided to display an <code>a</code> and <code>b</code> on the next line, it would seem fairly obvious to add something like:</p>

<pre><code>cout &lt;&lt; field(a, w) &lt;&lt; field(b, w) &lt;&lt; s;
</code></pre>

<p>...and we wouldn't have to look very hard to be pretty sure it was going to match up with the previous line. Likewise, if we wanted to change a column width, etc.</p>
",7
18362360,18359989,1,"<p>Try this: </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;map&gt;
#include &lt;string&gt;

using namespace std;


int main()
{
    map&lt; float, float &gt; table =
    {
        { 8232.0f, 89.0f },
        { 8232.1f, 89.0f },
        { 8232.2f, 89.0f },
        { 8232.3f, 89.0f },
        { 8232.4f, 89.0f },
        { 8232.5f, 89.0f },
        { 8232.6f, 89.0f },
        { 8232.7f, 89.0f },
        { 8232.8f, 89.0f },
    };

    const size_t CELL_WIDTH = 25;
    const string CELL_LINE( CELL_WIDTH, '=' );

    // print the header of table
    cout &lt;&lt; '|' &lt;&lt; CELL_LINE &lt;&lt; '|' &lt;&lt; CELL_LINE &lt;&lt; '|' &lt;&lt; endl
         &lt;&lt; '|'
         &lt;&lt; left &lt;&lt; setw( CELL_WIDTH ) &lt;&lt; ""F"" &lt;&lt; '|'
         &lt;&lt; setw( CELL_WIDTH ) &lt;&lt; ""R"" &lt;&lt; ""|\n|""
         &lt;&lt; CELL_LINE &lt;&lt; '|' &lt;&lt; CELL_LINE &lt;&lt; '|' &lt;&lt; endl;


    // print the body
    // change cout precision
    cout &lt;&lt; fixed &lt;&lt; setprecision( 3 );
    for ( auto it : table )
        cout &lt;&lt; ""| ""  &lt;&lt; setw( CELL_WIDTH - 1 ) &lt;&lt; it.first
             &lt;&lt; ""| "" &lt;&lt; setw( CELL_WIDTH - 1 ) &lt;&lt; it.second
             &lt;&lt; ""|\n"";

    // print the footer
    cout &lt;&lt; '|' &lt;&lt; CELL_LINE &lt;&lt; '|' &lt;&lt; CELL_LINE &lt;&lt; '|' &lt;&lt; endl;


    return 0;
}
</code></pre>

<p>this is the result:
<img src=""https://i.stack.imgur.com/0w6iS.png"" alt=""enter image description here""></p>
",0
18625311,18625223,2,"<p>You want something like this:</p>

<pre><code>std::vector&lt;unsigned int&gt; second(
    boost::counting_iterator&lt;unsigned int&gt;(0U),
    boost::counting_iterator&lt;unsigned int&gt;(99U));
</code></pre>
",4
18625317,18625223,0,"<pre><code>const int num_seconds = 100;
vector&lt;int&gt; second( num_seconds );
for( int n = 0 ; n &lt; num_seconds ; ++n ) {
    second[ n ] = n;
}
</code></pre>
",2
18625373,18625223,1,"<p>Using the generate algorithm : </p>

<pre><code>#include &lt;iostream&gt;     // std::cout
#include &lt;algorithm&gt;    // std::generate
#include &lt;vector&gt;       // std::vector
#include &lt;iterator&gt;

// function generator:
struct one_more { 
  int _count;
  one_more() : _count(0) {}
  int operator()() {
      return _count++;
  }
};

int main () {
  std::vector&lt;int&gt; myvector (100);
  std::generate (myvector.begin(), myvector.end(), one_more());

  std::copy(myvector.begin(), myvector.end(), std::ostream_iterator&lt;int&gt;(std::cout, "" ""));
  return 0;
}
</code></pre>
",0
18625374,18625223,16,"<p>Here is a version not using a visible loop and only the standard C++ library. It nicely demonstrates the use of a lambda as generator, too. The use of <code>reserve()</code> is optional and just intended to avoid more than one memory allocation.</p>

<pre><code>std::vector&lt;int&gt; v;
v.reserve(100);
int n(0);
std::generate_n(std::back_inserter(v), 100, [n]()mutable { return n++; });
</code></pre>
",2
18626013,18625223,22,"<p>Here's another way...</p>

<pre><code>int start = 27;
std::vector&lt;int&gt; v(100);
std::iota(v.begin(), v.end(), start);
</code></pre>
",0
19501459,19501318,4,"<p>Access specifiers only restrict direct use of a name; they do not restrict indirect access to a member via a pointer. So your code does indeed allow <code>main</code> to modify a private member, since the member's name is only used with a member function.</p>

<p><sub>(Or at least it would, if all the syntax errors were fixed)</sub></p>

<p>This is the case whether or not the object is dynamically allocated (i.e. whether or not it's on the heap). In C++, you should get into the habit of avoiding <code>new</code> except where it's genuinely needed.</p>
",0
20409205,20408973,0,"<p>Change:</p>

<pre><code>example &gt;&gt; word;
while (example.good())
{
     // ...
     example &gt;&gt; word;
}
</code></pre>

<p>to</p>

<pre><code>while (example &gt;&gt; word)                                                        /*
       ^^^^^^^^^^^^^^^                                                         */
{
    // ...
}
</code></pre>

<p>You need to do the extraction before the stream is checked. If you do the opposite, the loop will run even when the stream has not checked if the extraction worked (it only checks if the <em>previous</em> extraction worked).</p>
",0
20409259,20408973,0,"<p>You indeed output the last word twice. Consider the following code snippet</p>

<pre><code>        while (example.good()) 
        { 
            if (std::strcmp(word, ""a"") != 0 &amp;&amp;std::strcmp(word, ""able"") != 0 &amp;&amp;std::strcmp(word, ""about"") != 0 &amp;&amp;std::strcmp(word, ""across"") != 0 &amp;&amp;std::strcmp(word, ""after"") != 0 &amp;&amp;std::strcmp(word, ""all"") != 0 &amp;&amp;std::strcmp(word, ""almost"") != 0 &amp;&amp;std::strcmp(word, ""also"") != 0 &amp;&amp;std::strcmp(word, ""am"") != 0 &amp;&amp;std::strcmp(word, ""among"") != 0 &amp;&amp;std::strcmp(word, ""an"") != 0 &amp;&amp;std::strcmp(word, ""and"") != 0 &amp;&amp;std::strcmp(word, ""any"") != 0 &amp;&amp;std::strcmp(word, ""are"") != 0 &amp;&amp;std::strcmp(word, ""as"") != 0 &amp;&amp;std::strcmp(word, ""at"") != 0 &amp;&amp;std::strcmp(word, ""be"") != 0 &amp;&amp;std::strcmp(word, ""because"") != 0 &amp;&amp;std::strcmp(word, ""been"") != 0 &amp;&amp;std::strcmp(word, ""but"") != 0 &amp;&amp;std::strcmp(word, ""by"") != 0 &amp;&amp;std::strcmp(word, ""can"") != 0 &amp;&amp;std::strcmp(word, ""cannot"") != 0 &amp;&amp;std::strcmp(word, ""could"") != 0 &amp;&amp;std::strcmp(word, ""dear"") != 0 &amp;&amp;std::strcmp(word, ""did"") != 0 &amp;&amp;std::strcmp(word, ""do"") != 0 &amp;&amp;std::strcmp(word, ""dose"") != 0 &amp;&amp;std::strcmp(word, ""either"") != 0 &amp;&amp;std::strcmp(word, ""else"") != 0 &amp;&amp;std::strcmp(word, ""ever"") != 0 &amp;&amp;std::strcmp(word, ""every"") != 0 &amp;&amp;std::strcmp(word, ""for"") != 0 &amp;&amp;std::strcmp(word, ""from"") != 0 &amp;&amp;std::strcmp(word, ""get"") != 0 &amp;&amp;std::strcmp(word, ""got"") != 0 &amp;&amp;std::strcmp(word, ""had"") != 0 &amp;&amp;std::strcmp(word, ""has"") != 0 &amp;&amp;std::strcmp(word, ""have"") != 0 &amp;&amp;std::strcmp(word, ""he"") != 0 &amp;&amp;std::strcmp(word, ""her"") != 0 &amp;&amp;std::strcmp(word, ""hers"") != 0 &amp;&amp;std::strcmp(word, ""him"") != 0 &amp;&amp;std::strcmp(word, ""his"") != 0 &amp;&amp;std::strcmp(word, ""how"") != 0 &amp;&amp;std::strcmp(word, ""however"") != 0 &amp;&amp;std::strcmp(word, ""i"") != 0 &amp;&amp;std::strcmp(word, ""if"") != 0 &amp;&amp;std::strcmp(word, ""into"") != 0 &amp;&amp;std::strcmp(word, ""is"") != 0 &amp;&amp;std::strcmp(word, ""it"") != 0 &amp;&amp;std::strcmp(word, ""its"") != 0 &amp;&amp;std::strcmp(word, ""just"") != 0 &amp;&amp;std::strcmp(word, ""least"") != 0 &amp;&amp;std::strcmp(word, ""let"") != 0 
&amp;&amp;std::strcmp(word, ""like"") != 0 &amp;&amp;std::strcmp(word, ""likely"") != 0 &amp;&amp;std::strcmp(word, ""may"") != 0 &amp;&amp;std::strcmp(word, ""me"") != 0 &amp;&amp;std::strcmp(word, ""might"") != 0 &amp;&amp;std::strcmp(word, ""most"") != 0 &amp;&amp;std::strcmp(word, ""must"") != 0 &amp;&amp;std::strcmp(word, ""my"") != 0 &amp;&amp;std::strcmp(word, "" neither "") != 0 &amp;&amp;std::strcmp(word, ""no"") != 0 &amp;&amp;std::strcmp(word, ""nor"") != 0 &amp;&amp;std::strcmp(word, ""not"") != 0 &amp;&amp;std::strcmp(word, ""of"") != 0 &amp;&amp;std::strcmp(word,""off"") != 0 &amp;&amp;std::strcmp(word, ""often"") != 0 &amp;&amp;std::strcmp(word, ""since"") != 0 &amp;&amp;std::strcmp(word, ""so"") != 0 &amp;&amp;std::strcmp(word, ""some"") != 0 &amp;&amp;std::strcmp(word, ""than"") != 0 &amp;&amp;std::strcmp(word, ""that"") != 0 &amp;&amp;std::strcmp(word, ""the"") != 0 &amp;&amp;std::strcmp(word, ""their"") != 0 &amp;&amp;std::strcmp(word, ""them"") != 0 &amp;&amp;std::strcmp(word, ""then"") != 0 &amp;&amp;std::strcmp(word, ""the"") != 0 &amp;&amp;std::strcmp(word, ""there"") != 0 &amp;&amp;std::strcmp(word, ""these"") != 0 &amp;&amp;std::strcmp(word, ""they"") != 0 &amp;&amp;std::strcmp(word, ""this"") != 0 &amp;&amp;std::strcmp(word, ""tis"") != 0 &amp;&amp;std::strcmp(word, ""to"") != 0 &amp;&amp;std::strcmp(word, ""too"") != 0 &amp;&amp;std::strcmp(word, ""twas"") != 0 &amp;&amp;std::strcmp(word, ""us"") != 0 &amp;&amp;std::strcmp(word, ""wants"") != 0 &amp;&amp;std::strcmp(word, ""was"") != 0 &amp;&amp;std::strcmp(word, ""we"") != 0 &amp;&amp;std::strcmp(word, ""were"") != 0 &amp;&amp;std::strcmp(word, ""what"") != 0 &amp;&amp;std::strcmp(word, ""when"") != 0 &amp;&amp;std::strcmp(word, ""where"") != 0 &amp;&amp;std::strcmp(word, ""which"") != 0 &amp;&amp;std::strcmp(word, ""while"") != 0 &amp;&amp;std::strcmp(word, ""who"") != 0 &amp;&amp;std::strcmp(word, ""whom"") != 0 &amp;&amp;std::strcmp(word, ""why"") != 0 &amp;&amp;std::strcmp(word, ""will"") != 0 &amp;&amp;std::strcmp(word, ""with"") != 0 &amp;&amp;std::strcmp(word, ""would"") != 0 &amp;&amp;std::strcmp(word, ""yet"") != 0 &amp;&amp;std::strcmp(word, ""you"") != 0 &amp;&amp;std::strcmp(word, ""your"") != 0 &amp;&amp;std::strcmp(word, ""on"") != 0 &amp;&amp;std::strcmp(word, ""only"") != 0 &amp;&amp;std::strcmp(word, ""or"") != 0 &amp;&amp;std::strcmp(word, ""other"") != 0 &amp;&amp;std::strcmp(word, ""our"") != 0 &amp;&amp;std::strcmp(word, ""own"") != 0 &amp;&amp;std::strcmp(word, ""rether"") != 0 &amp;&amp;std::strcmp(word, ""said"") != 0 &amp;&amp;std::strcmp(word, ""say"") != 0 &amp;&amp;std::strcmp(word, ""says"") != 0 &amp;&amp;std::strcmp(word, ""she"") != 0 &amp;&amp;std::strcmp(word, ""should"") != 0 &amp;&amp;std::strcmp(word, ""whom"") != 0 &amp;&amp;std::strcmp(word, ""why"") != 0 &amp;&amp;std::strcmp(word, ""will"") != 0 
&amp;&amp;std::strcmp(word, ""with"") != 0 &amp;&amp;std::strcmp(word, ""would"") != 0 &amp;&amp;std::strcmp(word, ""yet"") != 0 &amp;&amp;std::strcmp(word, ""you"") != 0 &amp;&amp;std::strcmp(word, ""your"") != 0 ) 
cout&lt;&lt;word&lt;&lt;"" "";
example&gt;&gt;word; 
ChangeCase(word); 
} ChangeCase(word); 
cout &lt;&lt; word; 
</code></pre>

<p>The first time you output the last word in the while loop in the if statement. Here it is</p>

<pre><code>if (std::strcmp(word, ""a"") != 0 /*...other conditions */ ) cout&lt;&lt;word&lt;&lt;"" "";
</code></pre>

<p>And the second time you output the last word after the loop</p>

<pre><code>...
    } ChangeCase(word); 
    cout &lt;&lt; word; 
</code></pre>

<p>The problem is that when the input failed the contents of variable word was not changed. It is still equal to ""BLUE""</p>
",0
20409552,20408973,0,"<p>I think that the problem that you put the function </p>

<pre><code>ChangeCase(word);
</code></pre>

<p>Twice </p>

<pre><code>example&gt;&gt;word; 
ChangeCase(word); 
} ChangeCase(word); 
cout &lt;&lt; word; 
</code></pre>

<p>you must remove the second one</p>

<p>the code will be as follow</p>

<pre><code>#include &lt;iostream&gt; 
#include &lt;cmath&gt;
#include &lt;fstream&gt; 
#include &lt;cstdlib&gt; 
#include &lt;cstring&gt; 
using namespace std; 
void ChangeCase(char word[]) 
{ 
    for(size_t i = 0; i &lt; strlen(word); i++) 
    { if( isupper(word[i])) word[i] = tolower(word[i]); 
    } }
    int main()
    { char filename[50]; 
    ifstream example; 
    cin.getline(filename , 50); 
    example.open(""example.txt""); 
    if(!example.is_open())
    { 
        exit(EXIT_FAILURE); 
        } char word[50]; 
        example&gt;&gt;word; 
        while (example.good()) 
        { 
            if (std::strcmp(word, ""a"") != 0 &amp;&amp;std::strcmp(word, ""able"") != 0 &amp;&amp;std::strcmp(word, ""about"") != 0 &amp;&amp;std::strcmp(word, ""across"") != 0 &amp;&amp;std::strcmp(word, ""after"") != 0 &amp;&amp;std::strcmp(word, ""all"") != 0 &amp;&amp;std::strcmp(word, ""almost"") != 0 &amp;&amp;std::strcmp(word, ""also"") != 0 &amp;&amp;std::strcmp(word, ""am"") != 0 &amp;&amp;std::strcmp(word, ""among"") != 0 &amp;&amp;std::strcmp(word, ""an"") != 0 &amp;&amp;std::strcmp(word, ""and"") != 0 &amp;&amp;std::strcmp(word, ""any"") != 0 &amp;&amp;std::strcmp(word, ""are"") != 0 &amp;&amp;std::strcmp(word, ""as"") != 0 &amp;&amp;std::strcmp(word, ""at"") != 0 &amp;&amp;std::strcmp(word, ""be"") != 0 &amp;&amp;std::strcmp(word, ""because"") != 0 &amp;&amp;std::strcmp(word, ""been"") != 0 &amp;&amp;std::strcmp(word, ""but"") != 0 &amp;&amp;std::strcmp(word, ""by"") != 0 &amp;&amp;std::strcmp(word, ""can"") != 0 &amp;&amp;std::strcmp(word, ""cannot"") != 0 &amp;&amp;std::strcmp(word, ""could"") != 0 &amp;&amp;std::strcmp(word, ""dear"") != 0 &amp;&amp;std::strcmp(word, ""did"") != 0 &amp;&amp;std::strcmp(word, ""do"") != 0 &amp;&amp;std::strcmp(word, ""dose"") != 0 &amp;&amp;std::strcmp(word, ""either"") != 0 &amp;&amp;std::strcmp(word, ""else"") != 0 &amp;&amp;std::strcmp(word, ""ever"") != 0 &amp;&amp;std::strcmp(word, ""every"") != 0 &amp;&amp;std::strcmp(word, ""for"") != 0 &amp;&amp;std::strcmp(word, ""from"") != 0 &amp;&amp;std::strcmp(word, ""get"") != 0 &amp;&amp;std::strcmp(word, ""got"") != 0 &amp;&amp;std::strcmp(word, ""had"") != 0 &amp;&amp;std::strcmp(word, ""has"") != 0 &amp;&amp;std::strcmp(word, ""have"") != 0 &amp;&amp;std::strcmp(word, ""he"") != 0 &amp;&amp;std::strcmp(word, ""her"") != 0 &amp;&amp;std::strcmp(word, ""hers"") != 0 &amp;&amp;std::strcmp(word, ""him"") != 0 &amp;&amp;std::strcmp(word, ""his"") != 0 &amp;&amp;std::strcmp(word, ""how"") != 0 &amp;&amp;std::strcmp(word, ""however"") != 0 &amp;&amp;std::strcmp(word, ""i"") != 0 &amp;&amp;std::strcmp(word, ""if"") != 0 &amp;&amp;std::strcmp(word, ""into"") != 0 &amp;&amp;std::strcmp(word, ""is"") != 0 &amp;&amp;std::strcmp(word, ""it"") != 0 &amp;&amp;std::strcmp(word, ""its"") != 0 &amp;&amp;std::strcmp(word, ""just"") != 0 &amp;&amp;std::strcmp(word, ""least"") != 0 &amp;&amp;std::strcmp(word, ""let"") != 0 
&amp;&amp;std::strcmp(word, ""like"") != 0 &amp;&amp;std::strcmp(word, ""likely"") != 0 &amp;&amp;std::strcmp(word, ""may"") != 0 &amp;&amp;std::strcmp(word, ""me"") != 0 &amp;&amp;std::strcmp(word, ""might"") != 0 &amp;&amp;std::strcmp(word, ""most"") != 0 &amp;&amp;std::strcmp(word, ""must"") != 0 &amp;&amp;std::strcmp(word, ""my"") != 0 &amp;&amp;std::strcmp(word, "" neither "") != 0 &amp;&amp;std::strcmp(word, ""no"") != 0 &amp;&amp;std::strcmp(word, ""nor"") != 0 &amp;&amp;std::strcmp(word, ""not"") != 0 &amp;&amp;std::strcmp(word, ""of"") != 0 &amp;&amp;std::strcmp(word,""off"") != 0 &amp;&amp;std::strcmp(word, ""often"") != 0 &amp;&amp;std::strcmp(word, ""since"") != 0 &amp;&amp;std::strcmp(word, ""so"") != 0 &amp;&amp;std::strcmp(word, ""some"") != 0 &amp;&amp;std::strcmp(word, ""than"") != 0 &amp;&amp;std::strcmp(word, ""that"") != 0 &amp;&amp;std::strcmp(word, ""the"") != 0 &amp;&amp;std::strcmp(word, ""their"") != 0 &amp;&amp;std::strcmp(word, ""them"") != 0 &amp;&amp;std::strcmp(word, ""then"") != 0 &amp;&amp;std::strcmp(word, ""the"") != 0 &amp;&amp;std::strcmp(word, ""there"") != 0 &amp;&amp;std::strcmp(word, ""these"") != 0 &amp;&amp;std::strcmp(word, ""they"") != 0 &amp;&amp;std::strcmp(word, ""this"") != 0 &amp;&amp;std::strcmp(word, ""tis"") != 0 &amp;&amp;std::strcmp(word, ""to"") != 0 &amp;&amp;std::strcmp(word, ""too"") != 0 &amp;&amp;std::strcmp(word, ""twas"") != 0 &amp;&amp;std::strcmp(word, ""us"") != 0 &amp;&amp;std::strcmp(word, ""wants"") != 0 &amp;&amp;std::strcmp(word, ""was"") != 0 &amp;&amp;std::strcmp(word, ""we"") != 0 &amp;&amp;std::strcmp(word, ""were"") != 0 &amp;&amp;std::strcmp(word, ""what"") != 0 &amp;&amp;std::strcmp(word, ""when"") != 0 &amp;&amp;std::strcmp(word, ""where"") != 0 &amp;&amp;std::strcmp(word, ""which"") != 0 &amp;&amp;std::strcmp(word, ""while"") != 0 &amp;&amp;std::strcmp(word, ""who"") != 0 &amp;&amp;std::strcmp(word, ""whom"") != 0 &amp;&amp;std::strcmp(word, ""why"") != 0 &amp;&amp;std::strcmp(word, ""will"") != 0 &amp;&amp;std::strcmp(word, ""with"") != 0 &amp;&amp;std::strcmp(word, ""would"") != 0 &amp;&amp;std::strcmp(word, ""yet"") != 0 &amp;&amp;std::strcmp(word, ""you"") != 0 &amp;&amp;std::strcmp(word, ""your"") != 0 &amp;&amp;std::strcmp(word, ""on"") != 0 &amp;&amp;std::strcmp(word, ""only"") != 0 &amp;&amp;std::strcmp(word, ""or"") != 0 &amp;&amp;std::strcmp(word, ""other"") != 0 &amp;&amp;std::strcmp(word, ""our"") != 0 &amp;&amp;std::strcmp(word, ""own"") != 0 &amp;&amp;std::strcmp(word, ""rether"") != 0 &amp;&amp;std::strcmp(word, ""said"") != 0 &amp;&amp;std::strcmp(word, ""say"") != 0 &amp;&amp;std::strcmp(word, ""says"") != 0 &amp;&amp;std::strcmp(word, ""she"") != 0 &amp;&amp;std::strcmp(word, ""should"") != 0 &amp;&amp;std::strcmp(word, ""whom"") != 0 &amp;&amp;std::strcmp(word, ""why"") != 0 &amp;&amp;std::strcmp(word, ""will"") != 0 
&amp;&amp;std::strcmp(word, ""with"") != 0 &amp;&amp;std::strcmp(word, ""would"") != 0 &amp;&amp;std::strcmp(word, ""yet"") != 0 &amp;&amp;std::strcmp(word, ""you"") != 0 &amp;&amp;std::strcmp(word, ""your"") != 0 ) 
cout&lt;&lt;word&lt;&lt;"" "";
example&gt;&gt;word; 
ChangeCase(word); 
} 
cout&lt;&lt;word&lt;&lt;""   "";


system(""PAUSE"");
return 0; }
</code></pre>

<p>and the result will be </p>

<pre><code>I love c++ car blue
</code></pre>
",0
20196136,20196052,6,"<p>Since iterators are non-numeric, they are not well-suited to this problem.</p>

<p>You can write complex, confusing and possibly costly code with <code>std::distance</code> and <code>std::advance</code>, performing ""pointer arithmetic"" on your iterators... or you can stick with your numeric loop counters approach, which is precisely what I'd do. Especially seeing as you're using <code>vector</code>s, which have constant-time (and, let's face it, <em>immediate</em>) access to arbitrary elements in arbitrary positions.</p>

<p>If you're wondering why, in this case, iterators are suddenly not the ""better"" mechanism for iteration that you've been taught they are: it's because <em>one must use the correct tool for the job</em>, and no technology is the correct tool for <em>all</em> jobs.</p>
",0
20196249,20196052,0,"<p>to get the position of you vector from the iterator with <code>std::distance</code>:</p>

<pre><code>for( auto i = graphMatrix.begin();i != graphMatrix.end();i++ )
{
    for( auto j = i-&gt;begin();j != i-&gt;end();j++ )
    {
        int x = std::distance(graphMatrix.begin(),i);
        int y = std::distance(i-&gt;begin(),j);

        graphMatrix[x][y] = 'x';


    }
}
</code></pre>
",2
18388140,18388138,1,"<p>This can easily be solved by creating a window of size K and then traversing the file till the right end of the window reaches the end of the file. The basic steps being:</p>

<ol>
<li><p>Traverse the first K lines of the file without printing it.</p></li>
<li><p>Open the same file using another stream object.</p></li>
<li><p>Now simultaneously traverse both the streams so that fisrt stream is always K lines ahead of the second stream.</p></li>
<li><p>Run a loop while the second first stream is valid. In the loop, read through the first stream as well and keep print the lines.</p></li>
</ol>

<p>The code would be</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;fstream&gt;
#include&lt;string&gt;
int main()
{
    fstream fs;
    fs.open(""abc.txt"",ios::in);
    string str;
    int K = 2;
    while(getline(fs,str) &amp;&amp; K&gt;1)
    {
        K--;
    }
    if(K==1)
    {
        fstream fsNew;
        fsNew.open(""abc.txt"",ios::in);
        while(getline(fs,str))
        {
            getline(fsNew,str);
            cout&lt;&lt;str;
        }
    }
    cin.ignore();
}
</code></pre>
",2
18361483,18361261,2,"<p>Decimal values can, in general, not be represented exactly using binary floating points like <code>double</code>. Thus, the value <code>20.40</code> is represented as an approximation which can be used to restore the original value (<code>20.4</code>; the precision cannot be retained), e.g., when formatting the value. Doing computations with these approximated values will typically amplify the error.</p>

<p>As already mentioned in one of the comments, the relevant reference is the <a href=""http://www.validlab.com/goldberg/paper.pdf"" rel=""nofollow"">paper</a> ""What Every Computer Scientist Should Know About Floating-Point Arithmetic"". One potential way out of your trouble is to use decimal floating points which are, however, not <a href=""http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2012/n3407.html"" rel=""nofollow"">yet</a> part of the C++ standard.</p>
",0
18361486,18361261,1,"<p>Single and double presicion floating point numbers are not stored the same way as integers, so whole numbers (e.g. 5, 10) may actually look like long decimals (e.g. 4.9999001, 10.000000001).  When you cast to an <code>int</code>, all it does is truncate the whole number.  So, if the number is currently represented as <code>4.999999999</code>, casting it to an <code>int</code> will give you <code>4</code>.  <code>std::round</code> will provide you with a better result most of the time (if the number is 4.6 and you just want the whole number portion, round will not work well).  The bigger question is then:  what are you hoping to accomplish by casting a <code>double</code> to an <code>int</code>?</p>

<p>In general, when dealing with floating point numbers, you will want to use some <em>epsilon</em> value that is your minimum significant digits.  So if you wanted to compare 4.9999999 to 5, you would do (pseudo-code): <code>if abs(5 - 4.9999999) &lt; epsilon, return 5</code>.</p>

<p><strong>Example</strong></p>

<pre><code>int main()
{
    double d;
    std::cin &gt;&gt; d;

    while (std::fabs(d - 0.0) &gt; DBL_EPSILON)
    {
        std::cout &lt;&lt; d &lt;&lt; std::endl;
        double m = 100 * d;
        int n = static_cast&lt;int&gt;(m);
        if (std::fabs(static_cast&lt;double&gt;(n) - m) &gt; DBL_EPSILON)
        {
            n++;
        }
        std::cout &lt;&lt; n &lt;&lt; std::endl;
        std::cin &gt;&gt; d;
    }

    return 0;
}
</code></pre>
",0
18361398,18361261,3,"<p>Your code truncates m but you need rounding. Include <code>cmath</code> and use <code>int n = round(m)</code>.</p>
",2
18361515,18361261,0,"<p>Casting double to int truncates value so 20.40 is probably 20.399999 * 100 is 2039.99 because double is not base 10. You can use round() function that will not truncate but will get you nearest int.</p>

<pre><code>int n = round(m);
</code></pre>
",0
18361584,18361261,0,"<p>Floating point numbers can't exactly represent all decimal numbers, sometimes an approximation is used. In your example the closest possible exact number is 20.39999999999999857891452847979962825775146484375. See <a href=""http://babbage.cs.qc.cuny.edu/IEEE-754/"" rel=""nofollow"">IEEE-754 Analysis</a> for a quick way to see exact values.</p>

<p>You can use rounding, but presumably you're really looking for the first two digits truncated.  Just add a really small value, e.g. 0.0000000001 before or after you multiply.</p>
",0
20416969,20416894,0,"<p>You should convert string to float by extracting float from string stream. At present you are using string stream but you are extracting string from it instead of float. </p>

<p>Try something like this:</p>

<pre><code>stringstream ss;
while ( getline( InputFile, DummyLine, ',' ) )
{
  ss &lt;&lt; DummyLine;
}
float dummyFloat;
while ( ss &gt;&gt; dummyFloat )
{
  Data.push_back( dummyFloat );
}
</code></pre>
",2
18374567,18374522,10,"<p>You are not using arrays right:</p>

<p><code>i,j</code> will always return <code>j</code>, as that is the result of comma operator.</p>

<pre><code>Tile** tiles = new Tile*[4096];
for(int i = 0; i &lt; 4096; i++)
    tiles[i] = new Tile[4096];

    for(int i = 0; i&lt; 4096;i++)
    {
        for(int j = 0;j&lt; 4096;j++)
        {
            tiles[i][j].x = i;
            tiles[i][j].y = j;
        }
    }

    for(int i = 0; i&lt; 4096;i++)
    {
        for(int j = 0;j&lt; 4096;j++)
        {
                cout &lt;&lt; ""X (Should be "" &lt;&lt;i&lt;&lt;""): ""&lt;&lt; tiles[i][j].x &lt;&lt; "" "" &lt;&lt; ""Y (Should be "" &lt;&lt;j&lt;&lt;""): ""&lt;&lt; tiles[i][j].y &lt;&lt; ""\n"";
        }
    }


   // Destruction! DON'T FORGET!
   for(int i = 0; i &lt; 4096; i++)
       delete[] tiles[i];
   delete[] tiles; 
</code></pre>

<p>If you calculate values from comma operator, your original code would be:</p>

<pre><code>Tile * tiles = new Tile[4096]; // returned last 4096
    for(int i = 0; i&lt; 4096;i++)
    {
        for(int j = 0;j&lt; 4096;j++)
        {
            tiles[i,j].x = i; // the same as tiles[j].x = i;
            tiles[i,j].y = j; // the same as tiles[j].y = j;
        }
    }

///...
</code></pre>
",2
18362494,18362324,4,"<p>Your code tries to access non-existing array elements, which causes segfault. You should stop your loop before the array index gets larger than the length of the array minus 1:</p>

<pre><code>int a[20];

for (i = 1; i &lt; 20 &amp;&amp; a[i - 1] != 42; i++)
{
  // ...
}
</code></pre>
",0
18362651,18362324,0,"<p>Apart from limit problem, your printing elements without initializing them </p>

<pre><code>//for i = 1, a[i] is uninitialized
cout&lt;&lt;a[i]&lt;&lt;""\n""; 
</code></pre>

<p>On accessing a local variable (like this), you're likely to get garbage value.</p>

<p>This might be better substitute for what you are trying to do:</p>

<pre><code>int a[20],i;
for(i=0;i &lt; 20;i++)
{
    cin&gt;&gt;a[i];
    if (a[i] == 42)
        break;
    cout&lt;&lt;a[i]&lt;&lt;""\n"";
}
</code></pre>
",0
18496580,18496371,0,"<p>Since c only takes a character, the enter key that the user presses is given to s so anything other than that is not recorded. Only press a single key and no enter for the character. Or else just use a string anyway.</p>
",0
18496595,18496371,3,"<p>When ever you write a character and press enter, actually 2 char are send to the buffer: the character itself and <code>\n</code> as the result of the enter key press. Your <code>cin &gt;&gt; c;</code> reads the first character only while <code>\n</code> still remains in the buffer. Since <code>std::getline()</code> reads everything before it encounters a <code>\n</code> character and since <code>\n</code> is the first character it encounters it doesn't read anything and the program terminates. Add a <code>std::cin.ignore();</code> (to ignore the <code>\n</code>) before <code>std::getline</code> and the code will work.</p>
",2
20507902,20507566,0,"<pre><code>#include &lt;stdio.h&gt;

int get_value();
int display(int values[], int n);
void total(int values[], int n);

int main()
{
    int n;
    n = 10;
    int values[n];
    int i;

    for(i=0;i&lt;=n;i++){
            printf(""Enter The value of get_value[%d]\n"",i);
        values[i] = get_value();
    }

    printf("" D to display all non-zero values in the array \n choose T to display the  total \n choose R to display all the number in reverse order \n choose Q to quit the program\n"");


    char c;
    scanf("" %c"", &amp;c);

    if(c == 'D') {
            display(values, n);
    }
    else if(c == 'T') {
            total(values, n);
    }
    else if (c == 'R') {

    }
    return 0;
}

int get_value()
{
        int usersChoice;
    scanf(""%d"", &amp;usersChoice);
    return usersChoice;
}

int display(int values[], int n)
{
    int i;
    for(i=0;i&lt;=n;i++){
        if(values[i]!=0)
            printf(""%d"", values[i]);
    }
    return 0;
}

void total(int values[], int n)
{
    int i,sum=0;
    for(i=0;i&lt;=n;i++){
        sum+=values[i];
    }
    printf(""%d"",sum);
}
</code></pre>

<p>I think this will answer all your questions.</p>
",1
18348445,18348253,5,"<p>The issue is actually the use of magic numbers. If you remove the magic numbers, the problem is resolved nicely.</p>

<pre><code>enum DefaultA { DefaultA_v2 = 0, DefaultA_v3 = 1 };

void a(int v1, int v2=DefaultA_v2, int v3=DefaultA_v3);

void b(int m1, int m2, int v1, int v2=DefaultA_v2, int v3=DefaultA_v3) {
    // ...
    a(v1, v2, v3);
    // ...
}
</code></pre>
",1
18348843,18348253,0,"<p>""But this is the violation of the DRY principle. It can leads a subtile bug, when default parameter of 'a' was changed, but not changed in 'b'""</p>

<p>Frankly, I'd say that if you get this ""bug"", then your functions are too tightly-coupled. Standalone functions are supposed to, well, stand alone. If changing a default parameter for one function causes another function to break, I think you have a design problem there.</p>
",0
18937443,18937251,0,"<p>Consider the following code:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

// Exchanges two values in array arr, specified by indices i and j
void exchange(int arr[], int i, int j)
{
    int t = arr[i];
    arr[i] = arr[j];
    arr[j] = t;
}

// Prints an array arr of length len
void print_array(int arr[], int len)
{
    for(int i=0; i&lt;len; i++)
    {
        cout &lt;&lt; arr[i] &lt;&lt; ""  "";
    }
    cout &lt;&lt; endl;
}

// Finds the index of the minimum value in array arr of length len between indices
//    init and the last element (len-1)
int find_min(int arr[], int len, int init)
{
    int index = init;

    for(int i = init; i &lt; len; i++)
    {
        if(arr[index] &gt; arr[i])
        {
            index = i;
        }
    }

    return index;
}

// Sort the array using the selection sort algorithm
void selection_sort(int arr[], int len)
{
    int loc;
    // We don't need the last iteration when there is only a single element left
    for(int pos = 0; pos &lt; (len-1); pos++)
    {
        cout &lt;&lt; ""Before iteration "" &lt;&lt; pos &lt;&lt; "" array is: "";
        print_array(arr, len);

        loc = find_min(arr, len, pos);
        cout &lt;&lt; ""  Minimum between indices "" &lt;&lt; pos &lt;&lt; "" and "" &lt;&lt; (len-1) &lt;&lt; "" is: "";
        cout &lt;&lt; arr[loc] &lt;&lt; "" at index "" &lt;&lt; loc &lt;&lt; endl;

        if (loc != pos)
        {
            cout &lt;&lt; ""  Exchanging indices "" &lt;&lt; loc &lt;&lt; "" and "" &lt;&lt; pos &lt;&lt; endl;
            exchange(arr, pos, loc);
        }
        else
        {
            cout &lt;&lt; ""  No exchange necessary this iteration. "" &lt;&lt; endl;
        }

        cout &lt;&lt; ""After iteration "" &lt;&lt; pos &lt;&lt; "" array is: "";
        print_array(arr, len);

        // Print an extra line newline, space things out a bit
        cout &lt;&lt; endl;
    }
}


int main(void)
{
    int arr[] = {2,6,7,3,1,8};

    selection_sort(arr, 6);
}
</code></pre>

<p>Output:</p>

<pre>
Before iteration 0 array is: 2  6  7  3  1  8
  Minimum between indices 0 and 5 is: 1 at index 4
  Exchanging indices 4 and 0
After iteration 0 array is: 1  6  7  3  2  8

Before iteration 1 array is: 1  6  7  3  2  8
  Minimum between indices 1 and 5 is: 2 at index 4
  Exchanging indices 4 and 1
After iteration 1 array is: 1  2  7  3  6  8

Before iteration 2 array is: 1  2  7  3  6  8
  Minimum between indices 2 and 5 is: 3 at index 3
  Exchanging indices 3 and 2
After iteration 2 array is: 1  2  3  7  6  8

Before iteration 3 array is: 1  2  3  7  6  8
  Minimum between indices 3 and 5 is: 6 at index 4
  Exchanging indices 4 and 3
After iteration 3 array is: 1  2  3  6  7  8

Before iteration 4 array is: 1  2  3  6  7  8
  Minimum between indices 4 and 5 is: 7 at index 4
  No exchange necessary this iteration.
After iteration 4 array is: 1  2  3  6  7  8
</pre>
",0
18937447,18937251,0,"<p>Fix your <code>find_min</code> function</p>

<pre><code>int find_min(int ar[],int s, int size) // s denotes the start index
{
    int index = s-1; //take min pos as start
    bool found = false;
    for(int i = s; i &lt; size; i++)
    {
        if(ar[index] &gt; ar[i])
        {
            index = i;
            found = true;
        }
    }

    if (found)
    {
        return index;
    }
    else
        return -1;
}
</code></pre>

<p>Now use:
<code>loc = find_min(arr, count+1,size);</code></p>

<p>as till <code>count</code> arr is already sorted</p>

<p>See <a href=""http://ideone.com/AzrG9A"" rel=""nofollow""><strong>HERE</strong></a></p>
",0
18430886,18430701,0,"<p>The idea behind selection sort is to find the smallest/largest element and position it to a proper index</p>

<p>Clearly your first algo's inner for loop</p>

<pre><code>for(int nCurrentIndex=nStartIndex+1;nCurrentIndex&lt;nSize;nCurrentIndex++)
    {
        if(anArray[nCurrentIndex]&lt;anArray[nStartIndex])
            nSmallestIndex=nCurrentIndex;
    }
</code></pre>

<p>Never compares with new smaller index, it just compares the iterating number with original smaller value.</p>

<p>Whereas in 2nd algo's inner loop</p>

<pre><code>for(int nCurrentIndex=nStartIndex+1;nCurrentIndex&lt;nSize;nCurrentIndex++)
    {
        if(anArray[nCurrentIndex]&lt;anArray[nSmallestIndex])
            nSmallestIndex=nCurrentIndex;
    }
</code></pre>

<p>It updates the <code>smallestIndex</code> and hence correctly find the smallest value for a swap.</p>
",4
18430900,18430701,5,"<p>The logic in code sampe 1 is wrong and that's why it gives the wrong answer. In your second loop, you want to find the smallest element from [nStartIndex, nSize). But you only compare the current one with anArray[nStartIndex]. At the end you get nSmallestIndex equal to the last element smaller than anArray[nStartIndex].</p>

<p>For code sample two, the logic is right. You save the current smallest index in nSmallestIndex and use the updated version to compare in the if statement,</p>

<pre><code>   if(anArray[nCurrentIndex]&lt;anArray[nSmallestIndex])
</code></pre>

<p>btw, the sorting method in this code is O(N^2) which is not good generally. It is also noted by others here C++ STL has facilities to do this better and portable.</p>
",1
18430753,18430701,0,"<p>Because nSmallestIndex equals to nStartIndex only at the begining of the second for, after some iteration nSmallestIndex can change but nSmallestIndex won't change because there are not the same variable</p>
",1
18430779,18430701,1,"<p>There is a wrong condition inside your inner loop in the first example: <code>if(anArray[nCurrentIndex]&lt;anArray[nStartIndex])</code>. Use <code>nSmallestIndex</code> instead of <code>nStartIndex</code>.</p>

<p>But in <code>C++</code> you can do it in one line:</p>

<pre><code>std::sort( anArray, anArray + nSize, std::less&lt;int&gt;() ); 
</code></pre>

<p>If you want to do it in <code>C</code> just use this code:</p>

<pre><code>const int nSize=6;
int anArray[nSize]={ 30, 60, 20, 50, 40, 10 };

int Compare(const void* a ,const void* b)
{
    return ( *(int*)a &gt; *(int*)b ) ? 1 : ( ( *(int*)a &lt; *(int*)b ) ? -1 : 0 );
}

...

qsort( anArray, nSize, sizeof( int ), &amp;Compare );
</code></pre>
",5
18431069,18430701,0,"<blockquote>
  <p>why do they give different results although nSmallestIndex equals to nStartIndex?</p>
</blockquote>

<p>The only difference betweent the two pieces of code:</p>

<pre><code>&lt;         if(anArray[nCurrentIndex]&lt;anArray[nStartIndex])
---
&gt;         if(anArray[nCurrentIndex]&lt;anArray[nSmallestIndex])
</code></pre>

<p>So the conditional is different on <code>nSmallestIndex</code> and <code>nStartIndex</code>. But these values are not the same in the two pieces of code:</p>

<p>See the lines:</p>

<pre><code>    if(anArray[nCurrentIndex]&lt;anArray[&lt;VALUE&gt;])
        nSmallestIndex=nCurrentIndex;
     // ^^^^^^^^^^^^^^^   Assignment changes the value.
</code></pre>
",0
18678321,18678290,1,"<p>Try it like this:</p>

<pre><code>printf(""After %c tests, testing arrays up to a size of %c, \n""
       ""the average time difference between the brute force \n ""
       ""method and binary tree method to find the mode of \n""
       ""an integer array is %f seconds"", 
       tests_per_size, max_array_test_size, avgTimeDiff);
</code></pre>
",1
18678352,18678290,0,"<p>The main problem is that string literals don't span across multiple lines. You can quote each line like Maciej suggested. Another way to fix this issue is to use <code>\</code> at the end of each line:</p>

<pre><code> printf(""After %c tests, testing arrays up to a size of %c, \n \
         the average time difference between the brute force \n \
         method and binary tree method to find the mode of \n \
         an integer array is %f seconds"",
         tests_per_size, max_array_test_size, avgTimeDiff);
</code></pre>

<p>Note that this method preserves the whitespace in the string which could be handy depending on your use-case.</p>
",1
20404770,20404596,3,"<p>At the first glance, the problem might be this line:</p>

<pre><code>dbStack.push(&amp;d);
</code></pre>

<p>You're pushing the value by it's reference, which means, that all the values in your stack will be the same as the last value held by the variable <code>d</code></p>
",1
20404713,20404596,-3,"<p>This isn't the answer you're looking for, but as a commenter said:</p>

<p><strong>Step through your code.</strong></p>

<p>That's what I was about to do for you, then I remembered: teach a man to fish...</p>

<p>If you're not using an IDE (<em>but you should be</em>), you can add print statements to show the changing values of variables as the program progresses.</p>
",4
18655784,18655739,4,"<blockquote>
  <p>Is my best option to just add these new smaller functions as public
  members? I don't think that I want a user to be using these functions.
  What is the best way to go about this?</p>
</blockquote>

<p>Add them as private members.</p>
",0
18655830,18655739,1,"<p>If those methods you are talking about are going to be called outside the class, they will need to be defined as <code>public</code>, and due the fact you are not going to change the private members, also you can define them as <code>public static</code>.</p>

<p>If the methods are going to be called only from other methods of the class, then you should declare them as <code>private</code>.</p>
",0
20401844,20394549,-1,"<p>i think both are possible... but i think it will be better if you use 3-node structure for the whole tree.. you could use flag (with bool or int or anything) to determine its kind (3-node or 2-node) </p>
",0
19503928,19503847,4,"<p>Second one is <em>""the more specialized template""</em> and needs less ""substituting"" and compiler selects it as the best choice in overload resolution phase.</p>

<p>Per 14.5.6.2 (Partial ordering of function templates):</p>

<blockquote>
  <p>Partial ordering selects which of two function templates is more
  specialized than the other by transforming each template in turn (see
  next paragraph) and performing template argument deduction using the
  function type. The deduction process determines whether one of the
  templates is more specialized than the other. If so, the more
  specialized template is the one chosen by the partial ordering
  process.</p>
</blockquote>
",1
18938970,18938934,7,"<p>All you need is to forward-declare the <code>Edge</code> class before it's used within the <code>Vertex</code>:</p>



<pre><code>class Edge;

class Vertex {
    string name;
    int distance;
    ...
};

class Edge { ... };
</code></pre>

<p>You can't put members of type <code>Vertex</code> instead of the declaration of <code>Vertex</code> itself, since C++ doesn't allow recursive types. Within the semantics of C++, the size of such type would need to be infinite.</p>

<p>You can, of course, put pointers to <code>Vertex</code> within <code>Vertex</code>.</p>

<p>What you want, in fact, within <code>Vertex</code>'s edge and adjacency lists, is pointers, not copies of objects. Thus, your code should be fixed like below (assuming you use C++11, which you in fact should be using now):</p>

<pre><code>class Edge;

class Vertex {
    string name;
    int distance;
    int weight;
    bool known;
    list&lt;shared_ptr&lt;Edge&gt;&gt; edgeList;
    list&lt;shared_ptr&lt;Vertex&gt;&gt; adjVertexList;

public:
    Vertex();
    Vertex(const string &amp; nm);
    virtual ~Vertex();
};

class Edge {
    Vertex target;
    int weight;

public:
    Edge();
    Edge(const Vertex &amp; v, int w);
    virtual ~Edge();

    Vertex getTarget();
    void setTarget(const Vertex &amp; target);
    int getWeight();
    void setWeight(int weight);
};
</code></pre>
",2
18939012,18938934,2,"<p>If you think about it, instantiating a single <code>Vertex</code> or <code>Edge</code> object would instantiate an infinite amount of more <code>Vertex</code> and <code>Edge</code> objects because each of them contain instances of each other.</p>

<p>To fix this you need to forward declare a class, which one depends on the one you use first.
Forward declaring classes allows you to use pointers and references to them without actually <em>using</em> the class, only pointing to it.</p>

<p>This snippet should be compilable but it will require some extra memory management.</p>

<pre><code>class Edge; // This is a forward declaration

class Vertex {
    string name;
    int distance;
    //Vertex path;
    int weight;
    bool known;
    list&lt;Edge*&gt; edgeList;
    list&lt;Vertex*&gt; adjVertexList;

public:
    Vertex();
    Vertex(string nm);
    virtual ~Vertex();
};

class Edge {
    Vertex* target;
    int weight;

public:
    Edge();
    Edge(Vertex* v, int w);
    virtual ~Edge();

    Vertex* getTarget();
    void setTarget(Vertex* target);
    int getWeight();
    void setWeight(int weight);
};
</code></pre>

<p>This piece of code compiles because the classes now contain pointers to objects instead of the objects themselves.</p>

<p>As BartoszKP suggests you should read up on <a href=""https://stackoverflow.com/questions/553682/when-to-use-forward-declaration"">forward declarations</a> and you might need to learn a bit more about pointers and references as well.</p>

<hr>

<p>Since you are still having trouble I will update my answer with some more details. I read that you have actually split your classes into two header files now, I assume they are <code>Vertex.h</code> and <code>Edge.h</code>. They should look something like this</p>

<p><strong>Vertex.h</strong></p>

<pre><code>class Edge;
class Vertex
{
    Edge* CreateEdge(); // Declaration of a class function
    // ...
};
</code></pre>

<p><strong>Edge.h</strong></p>

<pre><code>class Vertex
class Edge
{
    // ...
};
</code></pre>

<p>You will need to include the complete definition of <code>Edge</code> when you want to use it for accessing its members or creating an instance. Basically you need to put the implementations of each function after all classes and structs have been defined. The easiest way to do this is by putting the function implementations in their respective <code>.cpp</code> file. It seems you want to create an <code>Edge</code> object from within the <code>Vertex</code> class, so you need to do that in your <code>Vertex</code>'s <code>.cpp</code> file.</p>

<p><strong>Vertex.cpp</strong></p>

<pre><code>#include ""Vertex.h""
#include ""Edge.h""

Edge* Vertex::CreateEdge()
{
    return new Edge();
}
</code></pre>

<p>Because the first thing done in this <code>.cpp</code> file is including the <code>Vertex</code> and <code>Edge</code> header files, that have their respective class definitions, you can completely use the <code>Vertex</code> and <code>Edge</code> classes as you want.</p>

<p>You will need a certain order in how you organize your declarations and definitions which goes like this</p>

<pre><code>// Regarding global functions
Declaration    // void MyFunction();
Definition     // void MyFunction() { ... }

// Regarding classes and structs
Declaration    // class MyClass; - Forward declaration in another header file
Definition     // class MyClass { ... } - Definition in actual header file

// Regarding class functions
Declaration    // class MyClass { void MyFunction(); }
Definition     // void MyClass::MyFunction() { ... }
</code></pre>
",1
20193323,20192640,0,"<p>You may use boost::property_tree to parse the decision tree from a xml, ini or json representation.</p>

<p><a href=""http://www.boost.org/doc/libs/1_55_0/doc/html/property_tree.html"" rel=""nofollow"">http://www.boost.org/doc/libs/1_55_0/doc/html/property_tree.html</a></p>
",0
18898723,18898298,0,"<p>This is a really generic question, but the assuming the HP35 is an RPN calculator then the addition code would simply pop two values off the stack, add them together, and then push the result back onto the stack. The subtraction function would be similar, just make sure that you subtract them in the correct order.</p>

<p>You obviously need to finish implementing your stack also. If you are using C++ and you don't plan to add extra functionality, then just use <code>std::stack&lt;double&gt;</code> instead.</p>

<p>From looking at wikipedia, it doesn't appear that it is RPN calculator. I think you must be trying to handle operator precedence perhaps?</p>
",3
18899637,18898298,0,"<p>This might not fully answer your question but might give you the rough outline, by working through an example.</p>

<p><strong>original expression</strong> :</p>

<pre><code>( ( 1 + 2) * 3 ) + 4 )
</code></pre>

<p><strong>tree representation</strong> : </p>

<pre><code>      +
     / \
    *   4
   / \
  +   3
 / \
1   2
</code></pre>

<p><strong>stack representation</strong> (pushing / popping from the top) :</p>

<pre><code>1
2
+
3
*
4
+
</code></pre>

<p><strong>Processing the stack</strong> :</p>

<p>you can process this stack step by step.  The aim is to reduce the stack to a single value which is the answer.  On each step you inspect the three values from the top of the stack - top two should be numerical values, the third should be an operator to apply to the two.</p>

<p>Step 1 : replace 1,2,+ with 3, which leaves stack as :</p>

<pre><code>3
3
*
4
+
</code></pre>

<p>Step 2 : replace 3,3,* with 9, which leaves stack as :</p>

<pre><code>9
4
+
</code></pre>

<p>Step 3 : replace 9.,4,+ with 13.  Since the stack has just one value on it, that is the answer.</p>

<p>So, that shows how the stack representation should look, and how to process the stack to get an answer.  It doesn't show how to parse the text expression in order to set up the stack initially (I don't know that bit!).</p>
",1
18797758,18797739,5,"<p>Storing an array like this in a <code>map</code> is not going to work, even if you could do it syntactically: the array is going to stay in the map even after the real array goes out of scope. Storing vectors of <code>bool</code> instead should work:</p>

<pre><code>map&lt;int, vector&lt;bool&gt; &gt; myMap;
vector&lt;bool&gt; one {true, true, false}; // C++11 syntax
myMap[1] = one;
cout &lt;&lt; myMap[1][0] &lt;&lt; endl;
cout &lt;&lt; myMap[1][1] &lt;&lt; endl;
cout &lt;&lt; myMap[1][2] &lt;&lt; endl;
</code></pre>

<p>Here is a <a href=""http://ideone.com/N0kvue"">demo on ideone</a>.</p>
",0
18797827,18797739,2,"<p>With C++0x, you may write like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;array&gt;

int main() {
    std::map&lt;int, std::array&lt;bool, 3&gt;&gt; maparr {
        {1, {true, false, true}}, 
        {2, {false, false, true}}};

    for(auto&amp; item: maparr) {
        for (auto&amp; val : item.second) {
            std::cout &lt;&lt; val &lt;&lt; ' ';
        }
        std::cout &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>

<p>The output:</p>

<blockquote>
  <p>1 0 1</p>
  
  <p>0 0 1</p>
</blockquote>

<p>Since C++0x, we get a fixed size <a href=""http://en.cppreference.com/w/cpp/container/array"" rel=""nofollow"">array</a>.It may be what you are looking for.</p>
",0
18415936,18415865,0,"<blockquote>
  <p>Why we are we using ""."". instead of ""->"" ? Is the answer is that it became array?</p>
</blockquote>

<p>Because p2[i] is actually an instance of loc instead of a pointer to loc; <code>""loc *p2""</code> p2 is a pointer to loc, not an array, and it won't become an array.</p>

<blockquote>
  <p>can we make pointer say p3 to the pointer p2?</p>
</blockquote>

<p>Yes, It is legal. But make p2 is initialized first (instead of being a dangling pointer) in your real world project.</p>
",0
18415977,18415865,1,"<blockquote>
  <p>should we display like <code>p3[i]-&gt;show()</code>?</p>
</blockquote>

<p>No. In this line you're trying to access <code>p3 + i</code> memory address. This causes Undefined Behavior. You should use</p>

<pre><code>(*p3)[i].show()
</code></pre>

<p>You should use <code>p3[i]-&gt;show()</code> in case if <code>p3[i]</code> holds pointer.</p>
",1
18416025,18415865,1,"<p>Not exactly. An array is a sequence of identically typed objects stored one after the other. A pointer in an ""address of an object"".</p>

<p>The coincidence you observe is the consequence of two fact:</p>

<ul>
<li>An array decays into a ""pointer to the first element"" when given to functions, and ...</li>
<li>The pseudo <code>T&amp; operator[](T* p, int i)</code> is implemented intrinsically by the compiler as <code>return *(p+i);</code></li>
</ul>

<p>As a consequence wherever you store a sequence of identical objects, and you have a starting address, the [] operator will lead you to the i-th object. And since the starting address of an array is the address of the first element and is obtained by the implicit array to pointer conversion, you observe a substantial coincidence of the two expression.</p>

<p>But the coincidence stops just there.</p>

<p>About pointing to a pointer, make sure you fully understand the concept: by the way you asked it is not clear if:</p>

<ul>
<li>you want another pointer to point to the same array (just assign the array address to another pointer or the first pointer to another one</li>
<li>you want a pointer to point to the pointer that points to the array: this is a double indirection. You need a ""pointer to pointer"" and assign it to it the address of the first pointer (not of the array)</li>
</ul>

<p>Jut to be more clear:</p>

<pre><code>int a[5] = { 10,11,12,13,14 }; //5 integer named ""a""
int* p = a; // p points to a[0], hence *p and p[0] gives 10, p[1] give 11
int* q = p+1; // q points to one after p (hence to 11), *q and q[0] are 11, q[1] 12 ...
int** d = &amp;p; // d points to p, hence **d is 10 (*d)[1] 11 etc.
</code></pre>

<p>The hang you observed is due to the fact <code>d[3]</code> is not the integer 13, but the third <code>int*</code> after <code>p</code> (what <code>d</code> points to). But being <code>p</code> just a single variable, there is not such object, hence the result is undefined. (You had been lucky it hanged: in the worst case you get a random result that can be even look correct, thus hiding the error!).</p>

<p>In your specific case, <code>p3[i]-&gt;show</code> takes the value incidentally stored in the memory <code>i</code> pointers  after <code>p2</code> (what p3 points to) treat it as a <code>pointer to loc</code> and try to execute the <code>show</code> method of the supposed <code>loc</code> object at that random address, most likely not belonging to your program memory space, so that <code>show</code> fails to access the <code>longitude</code> local variable.</p>

<p>The result -substantially- all depends on the random data present in p3[i].</p>
",3
18445468,18445369,4,"<p>You need an output stream operator:</p>

<pre><code>std::ostream&amp; operator &lt;&lt;(std::ostream&amp; o, const T&amp; t)
{
  return o &lt;&lt; t.A;
}
</code></pre>

<p>Note that, since <code>A</code> is private, it would have to be a <code>friend</code> of <code>T</code>.</p>
",0
18445792,18445369,0,"<p>One method is to add a function to the public part of your class definition that returns the value of A:</p>

<pre><code>class T{
...
public:
...
int retA(){
    return A;
}
};

int main{
T B;
cout &lt;&lt; B.retA();
return 0;   //This is what chris said in his comment!
}
</code></pre>

<p>Hope this helps!</p>
",4
19261718,19261635,0,"<p>I think the way you call <code>ifstream::read()</code> is wrong. <code>read()</code> doesnot  add the null character at the end for you and you need to check the <code>eofbit</code> and <code>failbit</code>.</p>

<p>Quote from the manual,</p>

<blockquote>
  <p>The number of characters successfully read and stored by this function
  can be accessed by calling member gcount.</p>
</blockquote>
",2
19261768,19261635,0,"<p>I also think the run-time error is caused by the reason about read() function just as above, Also I don't think it's necessary to re-new 1024 bytes space at each iteration, why not reuse the buffer~</p>

<p>By the way, I try to repro your problem, I am not sure if the code below is the same with yours, and I don't get any run-time error</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;fstream&gt;
using namespace std;
int bufsize = 1024;
int main(){
    char sendbuff[1024];
    char * mybuff = new char[];
    std::ifstream ifs;
    ifs.open (""test.txt"", std::ifstream::in);
    while(1){
        mybuff = new char [1024];
        ifs.read(mybuff ,bufsize);
        sprintf(sendbuff,mybuff );
        int ibytessent=0;    
        int tmpCount = strlen(sendbuff);
        int ibufferlen = strlen(sendbuff);
        //ibytessent = send(s,sendbuff,ibufferlen,0);
        delete [] mybuff ;
    }
    return 0;
}
</code></pre>
",1
18798767,18798644,1,"<p>Do:</p>

<pre><code>ifstream infile(argv[i] + std::string("".csv""));
</code></pre>

<p>If you don't have C++11 features, do:</p>

<pre><code>std::string filename = argv[i] + std::string("".csv"");
ifstream infile(filename.c_str());
</code></pre>
",0
18767300,18765912,2,"<p>As twalberg points out, the most important bit of the compiler error message is the ""loses qualifiers"" bit. It also tells you that it can't convert from <code>const std::wstring</code> to <code>std::wstring&amp;</code>, except that it expanded the first <code>std::wstring</code> into its full template instantiation form.</p>

<p>The issue is that your <code>DeleteCtl</code> takes the argument by non-const reference, as if it wants to modify the string there (bad idea), but it can't do that, because you're iterating over a set, and you cannot change the members of a set once they're in there (<code>std::set</code> doesn't make a difference between <code>const_iterator</code> and <code>iterator</code>, essentially). The reason is that <code>std::set</code> bases its internal structure on the values of its elements, and if you change those values, the internal structure becomes invalid, and horrible things happen.</p>
",4
18935481,18935465,3,"<p>changing the pointer to the shared object to contain a <code>shared_ptr</code> would be a simple solution.</p>
",5
18935496,18935465,3,"<p>This is because you have violated the <a href=""http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29"" rel=""nofollow"">rule of three</a>: if you have a destructor, you almost certainly need to have a copy constructor and an assignment operator as well.</p>

<p>Of course the best way of dealing with pointers is to find a way of not having pointers at all (""the rule of zero""): in situations like that compiler-generated destructors, constructors, and assignment operators would take care of managing the resources automatically for you.</p>
",2
18935562,18935465,0,"<p>If the entity class has a destructor, it should also define a copy and copy assignment operator by the <a href=""http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29"" rel=""nofollow"">rule of three</a>.</p>

<p>Unfortunately, this presumably means you would have to copy the item pointed to in the object, so that when destroyed the copy of the object does not delete an item that will be later deleted by some other copy.  ""Unfortunately"" because creating a duplicate of the pointed to item is often undesirable; in this case, you have a design conundrum -- although Tom Kerr's suggestion WRT <code>shared_ptr</code> is a nice option.</p>

<p>Another solution would be to forbid copies, by making the copy constructor private, or (C++11) by using <code>= delete</code>, and making <code>entity</code> an array of pointers instead (and <code>push_back(&amp;e)</code>).</p>
",0
18935573,18935465,5,"<p>C++ is a ""copy-based"" language and for example a container of <code>Entity</code> will indeed put <strong>copies</strong> of the entities you give it inside the container.</p>

<p>Copies are made in C++ in many places so it's better that either your class supports them correctly or that you forbid them completely.</p>

<p>Your class contains a pointer to other data: what should happen when you make a copy of an instance of that class? If copying the pointer is ok, then clearly it cannot be ok to delete the pointed object in the destructor because still existing copies would be pointing to a deleted object.</p>

<p>There is a simple rule that helps avoiding this kind of mistake and is known as ""the rule of three"". If you have coded explicitly either</p>

<ul>
<li>a copy constructor</li>
<li>a destructor</li>
<li>an assignment operator</li>
</ul>

<p>in your class then most probably you need all of three of them.</p>

<p>In this case you've a destructor that is not the default one (because deletes the pointed object) so you also need to tell what to do in case of copy construction or assignment.</p>

<p>If you prefer that class to be non-copyable then just ensure that</p>

<pre><code>struct Entity {
    Object *o;

    Entity(Object *o) : o(o) {
        ...
    }

    ~Entity() {
        delete o;
    }

private:
    // Taboo... this should just never happen!!!
    // Here is a declaration, but no implementation will be written
    Entity(const Entity&amp; other);      // Copy constructor
    Entity&amp; operator=(const Entity&amp;); // Assignment
};
</code></pre>

<p>declaring forbidden operations <code>private</code> will ensure that user code will never call them (it would be a compile-time error), and just declaring them without providing an implementation will ensure that even the class code itself will not call them by mistake (you'd get a link-time error).</p>

<p>In this specific case however this would forbid your code to put <code>Entity</code> instances inside containers (elements inside containers must be copied around). You could put <code>Entity</code> <strong>pointers</strong> inside a container (pointers can be copied so an <code>std::vector&lt;Entity *&gt;</code> for <code>entities</code> would be legal) but you would be in charge to handle the correct lifetime for the objects (who should call the destructor and when should that happen?).</p>

<p>If on the other hand you have a pointer to data inside the class and you want to <strong>allow</strong> making a copy of an instance of the class you can either:</p>

<ul>
<li>Copy also the pointed data</li>
<li>Share pointed data between different instances</li>
</ul>

<p>for the second solution a common approach is using ""reference-counted"" pointers, i.e. the pointed data ""knows"" how many pointers are referencing it and is destroyed only when this count reaches 0.</p>
",3
20531983,20531936,4,"<p>When <code>j==0</code> you're going to get a division by zero error here:</p>

<pre><code>if(i/j == 2){
</code></pre>

<p>As Ben suggested, a fix would be:</p>

<pre><code>if( i == 2*j ) {
</code></pre>
",3
18862512,18862458,1,"<pre><code>for(int i = 1; i &lt;= 100; i++)
{
    isPrime(i);
    while(isPrime(i) == true)
    {
        myfile &lt;&lt;  i &lt;&lt;endl;
        break;

    }
    myfile.close();
    return 0;
}
</code></pre>

<p>The return 0; will make you quit the program after the first prime...</p>

<p>Correct would be</p>

<pre><code>for(int i = 1; i &lt;= 100; i++)
{
    if(isPrime(i)) {
        myfile &lt;&lt;  i &lt;&lt;endl;
    }
}
myfile.close();
return 0;
</code></pre>
",5
18862484,18862458,6,"<p>Your braces seem to be misplaced</p>

<pre><code>        break;

    }
    myfile.close();
return 0;
    }
 }
</code></pre>

<p>should be </p>

<pre><code>        break;

      }

    }
    myfile.close();
return 0;
 }
</code></pre>

<p>p.s. and <code>if</code> instead of <code>while</code> as ThinTim found, and the other issues he mentions. But in light of the <code>break</code> statement, this is the one causing the prime (pun intended) issue.</p>

<p>Your set of braces causes your program to exit after 1 number, if it isnt prime, and hang, if it is.</p>
",0
18862487,18862458,3,"<p>Your <code>while</code> should be an <code>if</code>.</p>

<p>You don't need that <code>break</code> statement.</p>

<p>The first call to <code>isPrime</code> inside the loop does nothing.</p>

<p>You should be converting your numbers to characters when you write them.</p>

<p>As Karthik mentioned, your brackets are not closed correctly.</p>

<p>You should do a lot more review before you post questions to StackOverflow.</p>
",8
20020569,20020495,-1,"<pre><code>#include&lt;iostream&gt;
#include&lt;conio.h&gt;

using namespace std;

int main()
{
    int Number=1,line=1,i=0;
while(Number &lt; 56)
    for(int i=0;i&lt;=Number;i++)
    {
    cout&lt;&lt;Number;
    Number+=2;
    }
    line++;
    cout&lt;&lt;""\n"";  
return 0;
}
</code></pre>
",0
20020581,20020495,2,"<p>You are printing a newline every time you <code>cout</code> a number. So the correct way is something like this:</p>

<pre><code>#include&lt;iostream&gt;
#include&lt;conio.h&gt;

using namespace std;

int main()
{
    int Number=1,line=1;
    while(Number &lt; 56)
    {
        for(int i=0;i&lt;line;i++)
        {
            cout&lt;&lt;Number &lt;&lt; ' ';
            Number = Number+2;

        }
        cout &lt;&lt; endl;
        line++;
    }   
    return 0;
}
</code></pre>
",0
20020583,20020495,1,"<p>You are printing a new line after every number. Here's a way to write it that works:</p>

<pre><code>int main()
{
    int number = 1;
    int lineLength = 1;
    while (number &lt; 56)
    {
        for (int i = 0; i &lt; lineLength; i++)
        {
            cout &lt;&lt; number &lt;&lt; "" "";
            number += 2;
        }
        cout &lt;&lt; endl;
        lineLength++;
    }
    return 0;
}
</code></pre>
",0
20020784,20020495,0,"<p>first, count the lines, and second: count the number index in the line:)</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;conio.h&gt;

using namespace std;

int main()
{
    int number = 1, line = 1, i = 1;
    while (number &lt; 56)
    {
        cout &lt;&lt; number &lt;&lt; ' ';
        number += 2;
        if (i &lt; line) ++i;
        else
        {
            i = 1;
            ++line;
            cout &lt;&lt; endl;
        }
    }
    return 0;
}
</code></pre>
",0
18499609,18499593,3,"<p>LL stands for LongLong, which means at least 64-bit</p>
",5
18499749,18499593,5,"<p>The purpose of the macro appears to be to produce an integer with the <code>G</code> least significant bits set.  <code>All_In(1)==1</code>, <code>All_In(2)==3</code>, <code>All_In(3)==7</code>, and so on.</p>

<p>In psuedo-code, the macro is saying this:</p>

<pre><code>if G == 64
    produce -1
else
    produce (1 bitshifted left by G) - 1
</code></pre>

<p><a href=""http://en.wikipedia.org/wiki/Bitwise_operation#Arithmetic_shift"" rel=""nofollow"">bit shifting, if you don't know what that is</a></p>
",1
18499772,18499593,2,"<p>The line of code is a macro that produces from a positive integer less than or equal to 64 a <code>long long</code> with that many <code>1</code>s in its binary expansion.  <code>AllIn(G)</code> equals $2^G - 1$.  Darn it, no TeX.  So, </p>

<pre><code>AllIn(1)  == 0x0000000000000001LL
AllIn(2)  == 0x0000000000000003LL
AllIn(3)  == 0x0000000000000007LL
AllIn(4)  == 0x000000000000000FLL
AllIn(5)  == 0x0000000000000011LL
...
AllIn(64) == 0xFFFFFFFFFFFFFFFFLL
</code></pre>
",6
18500229,18499593,3,"<p><code>LL</code> suffix of a constant literal means that the literal's type need to be interpreted as long long (signed). To answer exactly the question title: <code>1LL</code> is a constant literal, which value is <code>1</code> and it's type is long long. Similarly, <code>-1LL</code> is <code>-1</code> with the type long long.</p>

<p>You cannot pass <code>1LL</code> literal simply into functions which accept integer values of smaller types like long, short. Probably where the All_In macro is used the expected parameter is long long.</p>

<pre><code>All_In(1)  == 0b00000000...00000001LL
All_In(2)  == 0b00000000...00000011LL
All_In(3)  == 0b00000000...00000111LL
All_In(4)  == 0b00000000...00001111LL
All_In(5)  == 0b00000000...00011111LL
All_In(6)  == 0b00000000...00111111LL
All_In(7)  == 0b00000000...01111111LL
All_In(8)  == 0b00000000...11111111LL
...
All_In(57) == 0b00000001...11111111LL
All_In(58) == 0b00000011...11111111LL
All_In(59) == 0b00000111...11111111LL
All_In(60) == 0b00001111...11111111LL
All_In(61) == 0b00011111...11111111LL
All_In(62) == 0b00111111...11111111LL
All_In(63) == 0b01111111...11111111LL
All_In(64) == 0b11111111...11111111LL
</code></pre>

<p>The macro works this way:</p>

<ol>
<li>If the input parameter is 64 (<code>(G) == 64)</code> ? see ternary operator <code>?:</code>), then it yields a number which binary representation is 64 <code>1</code> (<code>(W64)(-1LL)</code>, where <code>W64</code> specifies that the width of the number is 64 in bits). For this you need to know, that in case of signed integers and in 2 complement number representation the -1 means all bits set to 1. For example in case of a signed char, the values range from -128 to 127. The binary representation of the -128 is <code>11111111</code>. Extend this to 64 bit length.</li>
<li>If the input is not 64, then it yields a number which has as many 1s in the binary representation as it is specified: <code>1LL &lt;&lt; (G))-1LL</code>. This goes the following way, let's do it for input 3 and if the bit length is 8.</li>
</ol>

<p>a. First it shifts the 1 by 3.</p>

<pre><code>0b00000001 (2^0)
0b00000010 (2^1 after shifting by 1)
0b00000100 (2^2 after shifting by 1 again)
0b00001000 (2^3 after shifting by 1 again, 3 times all together)
</code></pre>

<p>b. Then it subtracts 1 from that number. This results in a number we wanted. 2^n-1 always consists of bits of ones without a zero in between them. So 2^3-1=7. Which representation is:</p>

<pre><code>0b00000111
</code></pre>

<p>Probably this can be used to mask some flags or something.</p>

<p><em>Note, that (<code>0b</code> prefix for representing binary literals in my example doesn't work with all C compilers).</em></p>
",0
18400563,18400475,1,"<p>Try a loop:</p>

<pre><code>std::string ss;

for (int i=0; i &lt; 50; i++)
    ss += std::string(excluded_string[i]) + "" "";
</code></pre>

<p>You're code in the best situation will put first string in <code>ss</code>.</p>
",1
18400853,18400475,3,"<h2>Possible solution</h2>

<p>Since you took care to initialize your array of pointers to c_str to 0, we can use that knowledge to only add actually allocated words :</p>

<p>Also, you need to first build a std::string based on the original c_str before you can use the concatenation <code>operator+</code>.</p>

<pre><code>std::string stringResult;

for (int i=0; i!=50; ++i)
    if(excluded_string[i])
    {
        stringResult.append(std::string(excluded_string[i]) + "" "");
    }
</code></pre>

<h2>Details about the original error</h2>

<p>The type of your <code>excluded_string</code> object is <em>a static array of 50 pointers to char</em>. All pointers to char being initialized to 0 by your code.
A pointer to char can be referred as a <em>C string</em>, or more concisely <em>c_str</em>.</p>

<p>C++ STL gives you the <code>std::string</code> class, for which <a href=""http://www.cplusplus.com/reference/string/string/string/"" rel=""nofollow"">several constructors are defined</a>. One of them taking a <em>c_str</em> (i.e. a pointer to char) to initialize the string (pedantically, converting it to a pointer to const char, which is an implicit conversion in this expression).<br/>
This constructor is the one we use in the solution when we write:</p>

<pre><code>std::string(excluded_string[i])
</code></pre>

<p>But as you can see, there is no constructor taking an array of <em>c_str</em>, which is exactly what you compiler error's tells you.</p>

<p><em>EDIT</em> : Wording, thanks to <strong>Lightness Races in Orbit</strong> comment. (<em>cast</em> meaning in fact <em>explicit conversion</em>).</p>
",2
18400873,18400475,12,"<blockquote>
  <p>I declared char * array char *excluded_string[50] = { 0 };</p>
  
  <p>Later each element of ex_str array gets one word. Now I want to convert it into string so that I can have all words seperated by space.</p>
</blockquote>

<p>To convert it into a single string:</p>

<pre><code>char *excluded_string[50] = { 0 };
// excluded_string filled in the meantime
std::ostringstream buffer;  // add #include &lt;sstream&gt; at the top of 
                            // the file for this
for(int i = 0; i &lt; 50; ++i)
    buffer &lt;&lt; excluded_string[i] &lt;&lt; "" "";
std::string result = buffer.str();
</code></pre>

<p><strong>Edit:</strong> A few notes:</p>

<ul>
<li><p>if possible, do not concatenate strings directly: that will create and destroy a lot of objects and perform lots of unnecessary allocations.</p></li>
<li><p>if your code has stringent efficiency requirements, consider allocating/reserving the result beforehand to ensure a single allocation instead of repeated allocations.</p></li>
<li><p>if you concatenate strings, consider using operator += instead of + and =.</p></li>
</ul>

<p><strong>Edit 2:</strong> (answering comments)</p>

<blockquote>
  <p>What if + and = instead of +=?</p>
</blockquote>

<p>Here's the resolution of the two alternatives for concatenating strings (s += s1 + s2 vs s += s1; s += s2):</p>

<ul>
<li>Using = and +:</li>
</ul>

<p>code:</p>

<pre><code>std::string ss;
for (int i=0; i&lt;50; i++)
    ss += std::string(excluded_string[i]) + "" "";
</code></pre>

<p>Equivalent code (in terms of objects constructed and allocations):</p>

<pre><code>std::string ss;
for (int i=0; i&lt;50; i++)
{
    // ss += std::string(excluded_string[i]) + "" "";
    std::string temp1(excluded_string[i]); // ""std::string(excluded_string[i])""
    std::string temp2 = temp1 + "" ""; // call std::string operator+(std::string, char*)
    ss += temp2; // call std::string::operator +=(std::string)
}
</code></pre>

<ul>
<li>temp1 is created once per iteration;</li>
<li>temp2 is created for the concatenation operator</li>
<li>the second temporary is appended to ss.</li>
</ul>

<p>Both temporaries create a copy of the data (allocate buffer, copy data, deallocate buffer).</p>

<ul>
<li>Using += twice:</li>
</ul>

<p>code:</p>

<pre><code>std::string ss;
for (int i=0; i&lt;50; i++)
{
    ss += excluded_string[i]; // call std::string::operator +=(char*)
    ss += "" ""; // same as above
}
</code></pre>

<ul>
<li><p>std::string::operator += is called twice; It allocates space (if necessary), copies current contents of the string to newly allocated space, then copies new data at the end of the allocated buffer.</p></li>
<li><p>single pre-allocated space:</p></li>
</ul>

<p>allocating/reserving the result beforehand to ensure a single allocation</p>

<pre><code>std::size_t total_length = 0;
for(int i = 0; i &lt; 50; ++i)
    total_length += std::strlen(excluded_strings[i]); // assumes argument is not null
std::string ss;
ss.reserve(total_length + 51); // reserve space for the strings and spaces between
for (int i=0; i&lt;50; i++)
{
    ss += excluded_string[i]; // calls std::string::operator +=
    ss += "" ""; // same as above
}
</code></pre>

<p>In this case, operator+= doesn't allocate space internally, just at the beginning (a single operation). This is still a bit slow, because you iterate over the strings twice (0->49) and over each string twice (once to compute length, once to copy it to ss).</p>

<p>If your excluded_string were a std::vector instead, it would be more efficient because computing the strings lengths would not iterate each string, just the vector).</p>
",2
20638301,20638240,5,"<pre><code>word1 =word2;
</code></pre>

<p>You shouldn't use this because it is an assignment, not a comparison. The idiomatic way to compare two <code>std::strings</code> for <em>equality</em> is</p>

<pre><code>bool eq = word1 == word2;
</code></pre>

<p>If you want to know if one of the strings is less-than the other, then use the <a href=""http://en.cppreference.com/w/cpp/string/basic_string/compare"" rel=""nofollow""><code>std::string::compare</code></a> method:</p>

<pre><code>int cmp = word1.compare(word2); // beware: 0 means equality
</code></pre>
",0
20638304,20638240,3,"<p>If you declared your variables as <code>std::string</code> you must use:</p>

<pre><code>word1 == word2
</code></pre>

<p>But if you declared them as <code>char*</code> you must use:</p>

<pre><code>strcmp(word1, word2)
</code></pre>
",8
20638364,20638240,1,"<p>strcmp does more than simply check if both strings are equal. From the cplusplus.com reference I got that it </p>

<blockquote>
  <p>Returns an integral value indicating the relationship between the
  strings: A zero value indicates that both strings are equal. A value
  greater than zero indicates that the first character that does not
  match has a greater value in str1 than in str2; And a value less than
  zero indicates the opposite.</p>
</blockquote>

<p>That's why it should be more efficient to use <code>if (str1==str2)</code></p>
",1
20638366,20638240,1,"<p>The idiomatic way in C++ to use and process strings is to use the standard <code>std::string</code> one.</p>

<p>This class has comparison operators for your convenience:</p>

<pre><code>#include &lt;string&gt;

int main () {
    std::string foo = ""foo"", bar = ""bar"";
    if (foo == bar) {
        ....
    }
}
</code></pre>

<p>If you instead go the rough and errorful road of using <code>char*</code>, then the following is wrong:</p>

<pre><code>const char *foo = ""foo"", *bar = ""bar"";

if (foo == bar) {
}
</code></pre>

<p>This just compares the addresses of the <code>foo</code>- and <code>bar</code>-strings as the variables are pointers really. As a beginner, both pointers and raw string processing are rather tough, so better start with the standard containers (if which <code>std::string</code> is one).</p>
",0
20638383,20638240,1,"<p><code>std::string</code> is the more OOP way of doing strings in c++.  A ""string"" as in a c string is actually an array of characters.  Using <code>==</code> with that will not work as you might think, as it will compare the address of the first character (not the content of the string).  For more info look up pointers.  Here you use <code>strcmp</code>.</p>

<p>If you are using <code>std::string</code> (characterized by <code>#include &lt;string&gt;</code> and the declaration <code>string myvar;</code> instead of <code>char* myvar</code>) use <code>==</code>.</p>
",0
19565278,19565193,1,"<p>The compiler does not know where the definition is found.</p>

<p>The linker is the tool that looks at compiled objects and links together the object which included the header with the object/library that inculdes the implementation of the function or external variable. The linker takes as imput a list of object files and libraries that it should bring together and also a list of those it should look in.</p>
",0
19565309,19565193,-1,"<p>Due to the terminology of the original question, I misunderstood the question, so this answer doesn't actually answer the question. However, I'll leave it here for future reference about the preprocessor.</p>

<hr>

<p>The preprocessor's <code>#include</code> directive can be seen as creating a temporary file which contains the contents of <em>all</em> headers included, in the place where the <code>#include</code> directive was in the source file.</p>

<p>If you are using GCC you can use the <code>-E</code> option when compiling a file, to tell GCC to stop after the preprocessign stage, so you can see this file for yourself.</p>

<p>For the compiler to know which file and source line a specific declaration is on, the preprocessor outputs so called ""line"" directives. These are special directives (and much similar to preprocessor directives) that the compiler recognizes and uses to set the current filename and line number. See e.g. <a href=""http://gcc.gnu.org/onlinedocs/cpp/Line-Control.html"" rel=""nofollow"">this part from the GCC manual</a>.</p>
",2
18708821,18708691,0,"<p>I wanted to write this as a comment but I don't have enough reputations to do so.</p>

<p>You should definitely not compare address of string but compare the string itself (at least in your case). Also beware of the string case comparison and make sure that you specify if you want to do case sensitive or insensitive comparison.</p>

<p>Besides that you don't need to create a temporary string object and you can use the formal parameter itself that is passed to the function.
Even if you ever wanted to create temporary variables then you should consider using shared_ptr or unique_ptr to avoid memory leaks.</p>

<p>Stephan T Lavavej has an excellent talk recently on Going Native and I would recommend you to watch it. Right now the website is down and I can add link to it when the site comes back again.</p>

<p>I would also make the formal parameter as const to make sure that you don't accidentally modify the input parameter.</p>
",1
18708702,18708691,3,"<p>Besides the fact that you have a memory leak, you seem to be comparing pointers here:</p>

<pre><code>if(tempNode-&gt;data == theSong) { .... }
</code></pre>

<p>You probably need something like</p>

<pre><code>if(*(tempNode-&gt;data) == s) { .... }
</code></pre>

<p>You really do not need the dynamically allocated pointer bound to <code>theSong</code>. Also, the parameter to <code>find</code> should be a <code>const</code> reference:</p>

<pre><code>bool DoublyLinkedList::find(const string&amp; s)
//                          ^^^^^
</code></pre>

<p>In general, you should decouple traversing a linked list from finding an element in it. Otherwise you will find yourself replicating the traversal code bugs and all in many places.</p>
",7
18708706,18708691,1,"<p>You are comparing the addresses of two different string objects. Use <a href=""http://www.cplusplus.com/reference/string/string/compare/"" rel=""nofollow""><code>string::compare</code></a> instead or compare the values.</p>

<p>Also, why do you create a new string from the already existing string?</p>

<p><code>if (s.compare(tempNode-&gt;data) == 0)</code> or <code>s == *(tempNode-&gt;data)</code> is probably what you want to do.</p>
",0
18709641,18709604,2,"<p>The function can be written either as a member, or as a free function.  The member function signature would look like this:</p>

<pre><code>TimeDuration Date::operator-(Date const &amp; rhs) const
</code></pre>

<p>The free function would look like this:</p>

<pre><code>TimeDuration operator-(Date const &amp; lhs, Date const &amp; rhs)
</code></pre>

<p><code>TimeDuration</code> here is a completely seperate type representing a length of time.  If you want, you could just make it an <code>int</code> signifying the number of days, but it would be better, in my opinion, to have a more expressive type for this purpose. Whatever you decide regarding the return type, it doesn't make any sense for the type to be <code>Date</code> (and certainly not <code>Date&amp;</code>).</p>

<p>A possible (albeit not incredibly efficient) implementation, given that you've already written a function to add a day to a date, would be something like this:</p>

<pre><code>if lhs_date comes before rhs_date
    add days to (a copy of) lhs_date until lhs_date == rhs_date
    return the negative of number of days added
if rhs_date comes before lhs_date
    add days to (a copy of) rhs_date until rhs_date == lhs_date
    return the number of days added
else
    return 0
</code></pre>

<p>Another function you might want (or maybe this is what you actually wanted originally, but your wording doesn't indicate it) is a function which can subtract a length of time from a <code>Date</code>.  In that case, the return value would be another <code>Date</code> object (but not <code>Date&amp;</code>), and the possible signatures would look something like this:</p>

<pre><code>Date Date::operator-(TimeDuration rhs) const // member version
Date operator-(Date const &amp; lhs, TimeDuration const &amp; rhs) // non-member version
</code></pre>
",11
19876541,19876467,3,"<p>You don't have a list. You have a array with 51 elements of a list to pcks.
So to print those you need to iterate over the array and print the list elements.<br>
E.g:</p>

<pre><code>for(int i=0; i &lt; 51; ++i)
{
    std::for_each(nodelist[i].begin(), nodelist[i].end(), 
        [](const pckt&amp; e){
            std::cout &lt;&lt; e.node_id &lt;&lt; std::endl;
        });
}
</code></pre>
",0
19320878,19320532,3,"<pre><code>int k, l, m, n; 

cin &gt;&gt; k &gt;&gt; l &gt;&gt; m &gt;&gt; n;
</code></pre>
",0
18675425,18675407,1,"<p>Forward declare <code>employee</code> before <code>emp</code> class definition.</p>

<pre><code>struct employee;

class emp
{
  //....
</code></pre>
",0
18675456,18675407,0,"<p>I personally would say that you should use a <code>vector&lt;employee&gt;</code> or `list rather than building your own linked list. </p>

<p>Note also that using a linked list will add a fair amount of extra memory usage, because each node till have an overhead of, typically, 32-64 bytes. </p>
",0
18681560,18681518,0,"<p>if the file wouldn't be really big, you may first get the whole file in a string and use <code>string::find_last_of</code> to find the last index of semicolon. Then print the line from that index till end of file. </p>
",1
18681562,18681518,5,"<p>You did not explain what is your problem but I guess it doesn't check every line because the getline() inside the loop points to next element, so you lose half of your elements. </p>

<pre><code>while(getline(finlocal, chuy, ';'))
{

}
std::cout&lt;&lt;chuy;
</code></pre>

<p>should work</p>

<p>Let's say this is your lines:</p>

<p>1.; &lt;--</p>

<p>2.;</p>

<p>3.;</p>

<p>4.;</p>

<p>...</p>

<p>after the first iteration it goes to:</p>

<p>1.; &lt;--</p>

<p>2.; <em>&lt;--(by while)</em></p>

<p>3.; &lt;--(by inside getline)</p>

<p>4.;</p>

<p>...</p>

<p>So you lose the 2nd element. Loop goes on and in the end</p>

<p>5.; &lt;-- (by inside loop)</p>

<p>end.; &lt;-- (by while): this assignes the right line to chuy and points to next element </p>

<p>which does not exist and so inside getline() doesn't work</p>
",0
18681578,18681518,0,"<p>use </p>

<pre><code>while(getline(finlocal, lastLine, ';'));
cout&lt;&lt;lastLine;
</code></pre>

<p>or otherwise you will might not get the last line.</p>

<p>you can use </p>

<pre><code>    while(getline(finlocal, lastLine, ';'))
    {
       getline(finlocal,lastLine, ';');
    }
    cout&lt;&lt;lastLine;
</code></pre>

<p>but there is no point in doing <code>getline</code> twice</p>

<p>for a better delimiter in your case i would have used a special sign, say do:</p>

<pre><code>char delimiter = 251;
</code></pre>

<p>that char is the sign for square root, and most probably won't be used in chat. still, for each chat message that arrives you need to check if the sign is in use there and if so delete it. now for each message you send, send with the sign at the end of it, and when receiving, split at that character with the <code>getline</code>.</p>

<p>that way you split easily in a place you know the user won't mess.</p>
",15
19791777,19791693,3,"<p>I am not sure what you try to do, but in your function <code>tranches_max</code> you access the element <code>y[0]</code> which is out of bounds for the vector <code>y</code>. You construct y with the empty constructor making the vector empty. Maybe you need to create y with some initial size? </p>
",0
19791824,19791693,0,"<ol>
<li>Y is empty </li>
<li>This code should not compile as there is no space between >> which makes it stream operator</li>
</ol>
",3
18446198,18445953,1,"<p>It is not avoided at all in C++. <code>std::iostream</code> uses multiple inheritance and is part of the standard classes. It's pretty hard to write a non trivial program without using it (think about std::fstream or std::stringstream).</p>

<p><a href=""http://www.cplusplus.com/reference/istream/basic_iostream/"" rel=""nofollow"">http://www.cplusplus.com/reference/istream/basic_iostream/</a>
<a href=""http://www.cplusplus.com/reference/fstream/basic_fstream/"" rel=""nofollow"">http://www.cplusplus.com/reference/fstream/basic_fstream/</a>
<a href=""http://www.cplusplus.com/reference/sstream/basic_stringstream/"" rel=""nofollow"">http://www.cplusplus.com/reference/sstream/basic_stringstream/</a></p>
",4
18446299,18445953,1,"<blockquote>
  <p>Why is Multiple Inheritance in Classes avoided? Is it because it is very confusing and sometimes fields get intermixed or some other reason? </p>
</blockquote>

<p>Multiple inheritance is often avoided because it leads to several problems which can be difficult to fix for a novice programmer. Possible problems:</p>

<ol>
<li><a href=""http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem"" rel=""nofollow"">Diamond inheritance.</a></li>
<li>Carelessly Inheriting multiple interfaces (which weren't carefully designed) can pollute object's ""public"" or ""protected"" section with methods that aren't that useful for this particular object.</li>
<li>You have to be aware of construction/destruction order when object inherits several other objects, otherwise you might get crashes due to undefined behavior caused by things like double-delete. In other words, If object C inherits objects A and B, and <code>~A</code> somehow uses something provided by object B, then <code>~A</code> should be called before <code>~B</code>. I.e. in this scenario <code>class C: public B, public A{}:</code> will work, but <code>class C: public A, public B{};</code> will crash when destroyed. Bug like this can be hard to find.</li>
</ol>

<blockquote>
  <p>but not in Java??</p>
</blockquote>

<p>Ask java question for that.</p>

<blockquote>
  <p>Its allowed is C++ </p>
</blockquote>

<p>Multiple inheritance is available in C++ because it is useful.</p>

<p>Typical scenario - there are couple of abstract interfaces your class has to support. Let's say ""IReader"", ""IWriter"" and ""IUglyObject"". Which have no common ancestor.
To support several interfaces without multiple inheritance, you'll either have to make sure all your interfaces have common ancestor (which isn't always possible) or you'll have to define extra classes (derived from interfaces you want to support), write a lot of glue code that forward calls from your class to derived classes, which is too much typing. With multiple inheritance you can simply protected inherit all your interfaces and add few methods that return pointer to required interface.</p>

<pre><code>class MyClass: protected ISomething, protected ISomethingElse{
public:
    ISomething* getSomethingInterface(){ return this;}
    ISomethingElse* getSomethingEkseInterface(){ return this;}
protected:
};
</code></pre>

<blockquote>
  <p>herbivore and carnivore are derived from animal and omnivore is derived from both herbivore and carnivore. So won't some fields get mixed up.</p>
</blockquote>

<p>There are many ways to design hierarchy of classes, and the method you used in this example is not perfect. I could, for example, abstract ""eating behavior"" class and store it in ""animal"". That would allow me to change animal behavior on the fly and temporarily turn rabbits carnivores. Or I could create virtual method that either returns list of food types the animal accepts (or tests if the food is acceptable by this animal), that would allow me to make an animel that wants to eat only fried eggs and nothing else. There are other ways. </p>

<p>Class hierarchy doesn't have to mimic real world, you know...</p>

<blockquote>
  <p>when I was still learning C++, MI would often blow my mind and result in bad things when experimenting.</p>
</blockquote>

<p>If you're new, then avoid it for now. Multiple Inheritance is useful in the scenario I listed - class supporting multiple different interfaces without writing glue code. In all other cases it can be avoided and probably isn't necessary.</p>

<p>If language has a feature, it doesn't mean you have to use this feature.
If language has a feature with bad reputation, doesn't mean you should never use it.
Choose your tools based on situation.</p>
",5
18498376,18497658,7,"<p>So here's what's happening:</p>

<p>In your copy constructor, you check whether the list is empty. The result of this check is undefined because <code>m_pFront</code> is uninitialized, but in a debug build, chances are that this check is always true. Either way, since you're not actually copying any nodes, but only <code>_pData</code>, the resulting list will be empty (with the exception of <code>_pData</code> maybe being set).</p>

<p>In your assignment operator, before the line <code>_pData = new char[strlen(str._pData) + 1];</code> you fail to check if <code>str._pData</code> actually points to anything. If it doesn't and you're essentially doing <code>strlen(0)</code>, that is where it crashes and burns.</p>

<p>My advice would be to get a proper implementation of your copy constructor. One that actually does a deep copy, and then implement the <a href=""https://stackoverflow.com/a/3279550/2700399"">copy and swap idiom</a> for your assignment operator.</p>

<p><strong>EDIT: Example</strong></p>

<p>The source code below implements a small subset of the list class from the question to demonstrate a deep copy constructor and an assignment operator using the copy and swap idiom mentioned in the paragraph above.</p>

<p>Before I show the source code, it is important to realize that deep copying a list is not easy. A number of things have to be considered. You have to make copies of the nodes. You probably want to make copies of the data. But maybe not deep copies. Or maybe your specific needs don't require a copy of the data at all.</p>

<p>In your case, the list is doubly linked. If <code>Node</code> had a copy constructor that does a naive deep copy you would probably end up with a stack overflow due to endless chaining of the copy constructor.</p>

<p>Here's an example of such a naive implementation.</p>

<pre><code>Node(const Node &amp;other) 
{
    if (other.next) 
        next = new Node(*other.next);
    if (other.prev) 
        prev = new Node(*other.prev);
}
</code></pre>

<p>In my example, I choose to not implement a copy constructor for Node for clarity. I choose to make copies of the data, which is in the form of <code>std::string</code> to match the question.</p>

<p><strong>list.h</strong></p>

<pre><code>#ifndef LIST_EXAMPLE_H_
#define LIST_EXAMPLE_H_

#include &lt;string&gt;

struct Node
{
    std::string data;
    Node *next, *prev;
    Node(const std::string &amp;d) 
        : next(0), prev(0), data(d)
    {
    }
};

class List
{
    Node *front;
    Node *back;
    std::string data;

public:
    List();
    List(const std::string &amp;);
    List(const List &amp;);
    ~List();

    List&amp; operator=(List);

    void Clear();
    void PushBack(const std::string&amp;);

    bool Empty() const { return front == 0; }

    friend void swap(List &amp;, List &amp;);

    void Print();
};

#endif // LIST_EXAMPLE_H_
</code></pre>

<p><strong>list.cc</strong></p>

<pre><code>#include ""list.h""
#include &lt;iostream&gt;

List::List()
    : front(0), back(0), data()
{
}

List::List(const std::string &amp;in)
    : front(0), back(0), data(in)
{
}

List::~List()
{
    Clear();
}

List::List(const List &amp;other)
    : front(0), back(0), data(other.data)
{
    if (!other.Empty())
        for (Node *node = other.front; node; node = node-&gt;next) 
            PushBack(node-&gt;data);
}

List&amp; List::operator=(List other)
{
    swap(*this, other);
    return *this;
}

void List::Clear()
{
    Node *node = front;
    while (node) {
        Node *to_delete = node;
        node = node-&gt;next;
        delete to_delete;
    }
    front = back = 0;
}

void List::PushBack(const std::string &amp;data)
{
    Node *node = new Node(data);
    if (Empty()) {
        front = back = node;
    } else {
        back-&gt;next = node;
        node-&gt;prev = back;
        back = node;
    }
}

void List::Print()
{
    std::cout &lt;&lt; data &lt;&lt; std::endl;
    for (Node *node = front; node; node = node-&gt;next)
        std::cout &lt;&lt; node-&gt;data &lt;&lt; std::endl;
    std::cout &lt;&lt; std::endl;
}

void swap(List &amp;first, List &amp;second)
{
    using std::swap;
    swap(first.front, second.front);
    swap(first.back, second.back);
    swap(first.data, second.data);
}

int main()
{
    List a(""foo"");
    a.PushBack(""a"");
    a.PushBack(""b"");
    a.PushBack(""c"");
    a.Print();

    List b(""bar"");
    b.PushBack(""d"");
    b.PushBack(""e"");
    b.PushBack(""f"");

    List c(b);
    c.Print();

    c = a;
    c.Print();
    a.Print();

    return 0;
}
</code></pre>

<p>Why the assignment operator and the swap function are the way they are is explained much better than I can in the aforementioned answer that describes the <a href=""https://stackoverflow.com/a/3279550/2700399"">copy and swap idiom</a>. That leaves us with the implementation of the copy constructor. Let's look at it line by line.</p>

<pre><code>1. List::List(const List &amp;other)
2.     : front(0), back(0), data(other.data)
3. {
4.     if (!other.Empty())
5.         for (Node *node = other.front; node; node = node-&gt;next) 
6.             PushBack(node-&gt;data);
7. }
</code></pre>

<ol>
<li>Our copy constructor takes a reference to a const list. We promise not to change it.</li>
<li>We initialize our own members. Since <code>data</code> is not a pointer we might as well copy it in the initializer.</li>
<li>Yeah, I have to add this line for proper markdown numbering.</li>
<li>If the other list is empty, we're done here. There is no reason to check whether the list we just constructed is empty. It obviously is.</li>
<li>For each node in the other list... (sorry, markdown syntax again, doesn't let me combine 5 and 6 nicely).</li>
<li>...we create a new one. As explained above, there's no copy constructor for <code>Node</code> in this example, so we just use our <code>PushBack</code> method.</li>
<li>For completeness sake, but this line is totally obvious.</li>
</ol>

<p>Looping over the nodes in the other list this way is not the nicest. You should prefer using an iterator and calling <code>PushBack(*iter)</code>.</p>
",2
19208236,19208184,0,"<p>I would say the error is here</p>

<pre><code>cout&lt;&lt;""Input-file name and output-file name are not the same! Good job on reading!""&lt;&lt;endl;
ifstream infile(inputfile.c_str());
</code></pre>

<p>should be</p>

<pre><code>cout&lt;&lt;""Input-file name and output-file name are not the same! Good job on reading!""&lt;&lt;endl;
infile.open(inputfile.c_str());
</code></pre>

<p>You make the same mistake with outfile.</p>

<pre><code>ofstream outfile(outputfile.c_str());
</code></pre>

<p>should be</p>

<pre><code>outfile.open(outputfile.c_str());
</code></pre>

<p>You pass infile and outfile as parameters to your <code>open_input_and_output_file</code> function, but then you declare them <em>again</em> inside the function. So when you open the files you aren't using the streams that were passed to <code>open_input_and_output_file</code>, instead you are using streams that are local to that function. The streams passed to <code>open_input_and_output_file</code> stay closed.</p>
",0
19216757,19216723,0,"<blockquote>
  <p>I have a macro A initially set to 0. Can I increment it with my particular method like A++ ?</p>
</blockquote>

<p>No ++ needs a lvalue, you cannot do 0++, as <code>A</code> will be replaced as its value after per-processing.</p>

<p>Why not simply make it as global, or use call by reference ?</p>
",2
19216759,19216723,0,"<p>A macro is only processed by the preprocessor, which is only run at compilation and has no knowledge of how many times a function is actually called. As Beta said, you can use a variable to store this count, but even that needs to be done carefully if you have multiple threads calling the method.</p>
",0
19212625,19212576,1,"<p>If any call to <code>operator&gt;&gt;</code> reaches end of file, <code>eofbit</code> will be set and the stream will convert to false in boolean context. At which point the program will drop out of the loop. If the execution made it into the loop, then <code>(bool)viofile</code> is still true, and so <code>viofile.eof()</code> can't possibly return true.</p>

<p>Use a boolean flag - set it to false before the loop, set it to true when you print a violation. After the loop, if this flag still isn't set, then you haven't printed and violations, which you can report accordingly.</p>
",0
19212680,19212576,0,"<p>You cannot read into a string literal, i.e.,</p>

<pre><code>std::cin &gt;&gt; ""&lt;some string&gt;""
</code></pre>

<p>is illegal. If you need to decode a corresponding string, you'll need to create a suitable parsing routine.</p>

<p>Since you only read one set of inputs before breaking out of the loop, I'd guess I would check that not failure occurred, though, as there is no need to have reached the end of file at the point, i.e., I would use</p>

<pre><code>if (in) {
    ...
}
</code></pre>

<p>Given that input generally stops when a space character, e.g., a newline is encountered, you would need to skip, at least, trailing whitespaces to hope that the end of the file was reached:</p>

<pre><code>if ((in &gt;&gt; std::ws).eof()) {
    ...
}
</code></pre>
",5
19500394,19499650,2,"<p>The issue, as others stated, is that you are <code>return</code>ing from your <code>main</code> which terminates the program. My suggestion:</p>

<ol>
<li>Move your game logic into a separate method(s)</li>
<li>Place the logic call inside a while loop in the <code>main</code> that checks if the player wants to play again</li>
<li>Only return from <code>main</code> when the player wants to stop</li>
</ol>

<p>Example partial code (you should get the idea):</p>

<pre><code>void printWelcome( )
{
    std::cout &lt;&lt; ""Welcome to the One-Armed Bandit!"" &lt;&lt; std::endl;
    // etc.
}

int getBet( )
{
    int betAmount;

    std::cout &lt;&lt; ""To play start by betting some money!\n""
              &lt;&lt; ""Insert 50/ 100/ 500 kr to your account!"" &lt;&lt; std::endl;

    std::cin &gt;&gt; betAmount;

    return betAmount;
}

void playGame( )
{
    // All of your game logic in here
}

bool wantsToPlay( )
{
    std::cout &lt;&lt; ""Do you want to play again? (y/n)"" &lt;&lt; std::endl;

    char response;

    std::cin &gt;&gt; response;

    if( response == 'y' )
    {
        return true;
    }
    else
    {
        return false;
    }
}

int main( int argc, char** argv )
{
    int betAmount = 0;

    printWelcome( );

    do
    {
        betAmount = getBet( );

        if( betAmount != 50 &amp;&amp; betAmount != 100 &amp;&amp; betAmount != 150 )
        {
            // Restart the game loop (ask for bet again)
            continue;
        }

        playGame( );

    } while( wantsToPlay( ) );

    std::cout &lt;&lt; ""Thank you for playing!"" &lt;&lt; std::endl;

    return 0;
}
</code></pre>
",0
19500098,19499650,0,"<p>Run your program by yourself instead of computer and you will see why its closing so fast.<br/> Remember that <code>return</code> in <code>main()</code> means ""close program now"".</p>
",0
19499758,19499650,1,"<p>Your console is closing because the program is terminated when the main function hits a return , put a cin before each return. That will ""pause"" the application just before it terminates letting you see your traces.</p>
",2
20509587,20509564,3,"<p>You're accessing uninitialized memory -</p>

<pre><code>for(int i = 0; i &lt;= numElements; i++) { // &lt;-- no, stop at &lt; -- see above.
  for(int j = 0; j &lt; numElements; j++) // &lt;-- you use j+1 below
</code></pre>

<p>Should be</p>

<pre><code>for (int i = 0; i &lt; numElements; i++) { // &lt;-- also not initialized.
  for (int j = 0; j &lt; numElements - 1; j++) // &lt;-- like so.
</code></pre>
",5
20509608,20509564,2,"<p>Your issue is in your sorting implementation.  You have an array of size 100 and you add 3 elements.    By going to &lt;= numElements, you are accessing array locations 0, 1, 2, and 3 and thus you are accessing an extra element. Change it to &lt; and you'll be ok.</p>
",0
20181514,20017522,0,"<p>While you return a reference, what users of the code do with it later is entirely out of your control.  The fact that they can use your reference to create a copy is valid in the language.</p>
",0
19215584,19215523,0,"<p>You can use the C++ algorithm library to find if a string contains an uppercase value in it by using a predicate (using a wrapper version of std::isupper):</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cctype&gt;

bool IsUpper (char c) {
    return std::isupper(c);
}

bool hasUpperCase (std::string str) {
    std::string::iterator it = std::find_if(str.begin(), str.end(), IsUpper);
    if (it != str.end()) {
        return true;
    }
    else {
        return false;
    }
}

int main() {
    std::string s = ""This contains an uppercase character in it..."";
    if (hasUpperCase(s)) {
        std::cout &lt;&lt; ""String s contains a least one uppercase character."" &lt;&lt; std::endl; 
    }
    else {
        std::cout &lt;&lt; ""String s does not contain any uppercase character."" &lt;&lt; std::endl; 
    }
}
</code></pre>

<p>From <a href=""https://stackoverflow.com/a/5921826/866930"">here</a> a predicate is:</p>

<blockquote>
  <p>is a C++ function returning boolean or instance of object having bool
  operator() member. Unary predicate take one agrument, binary - two,
  etc. Examples of questions predicate can answer for particular
  algorithm are:</p>
  
  <ul>
  <li>Is this element is what we are looking for?</li>
  <li>Is the first of two arguments is ordered first in our order?</li>
  <li>Are the two arguments equal?</li>
  </ul>
  
  <p>Almost all STL algorithms take predicate as last argument.</p>
</blockquote>

<p>So, in summary, this works by each character in the string against the predicate function: <code>IsUpper</code> which itself uses <code>std::isupper</code> to do the checking to see if the character in question is uppercase or not. If it is, it returns true, and that character is stored in the iterator.</p>

<p>REFERENCES:</p>

<p><a href=""http://en.cppreference.com/w/cpp/algorithm/find"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/algorithm/find</a>
<a href=""https://stackoverflow.com/a/5921826/866930"">https://stackoverflow.com/a/5921826/866930</a></p>
",5
19786197,19785381,0,"<p>Depending on your projects/requirements, your class designs change. I have no comment on your class hierarchy but true your question is all about theories of friend usage.  If you don't use friend, you will not be able to call B members from A. It is there for...cross-mating :D</p>
",0
19789798,19785381,0,"<p>It almost certainly means that there is a serious design problem. One of the basic rules of thumb for inheritance is that base classes should not need any information about derived classes. Making <code>a</code> a friend of <code>b</code> makes it possible for member functions of <code>a</code> to get at the internals of <code>b</code> objects.</p>
",0
19967230,19967181,-1,"<p>Right now the method <code>fill_array</code> is creating a local copy of <code>array_to_fill</code>, so any changes that you make to <code>array_to_fill</code> only happen in the local method. To change this, pass by pointer. This way the pointer gets copied instead of the whole array object. I didn't test this but it should look more like this:</p>

<pre><code>void fill_array(char* array_to_fill){
    ...
}
</code></pre>

<p>You don't need to change anything in the main method.</p>

<p>To actually access the elements you can use <code>[]</code> notation. I.e. <code>cout &lt;&lt; array_to_fill[0]</code> in the main method.</p>

<p>Edit: I think that change should work.</p>
",3
19967294,19967181,0,"<p>Your class does not store the array at all. It is simply a holder for a method. You probably want something like this, where each instance of the class holds the array. (I changed it to <code>std::string</code> since they are nicer to work with.)</p>

<pre><code>class Something
{
    private:
        std::string data;

    public:
        void fill_data( const std::string&amp; filename )
        {
             ifstream file( filename );
             file &gt;&gt; data;
             file.close();
        }

        std::string get_data() const
        {
             return data;
        }
}

int main()
{
    std::vector&lt;Something&gt; my_things;

    my_things.push_back( Something() );
    my_things[0].fill_data( ""chars.txt"" );
    cout &lt;&lt; my_things[0].get_data() &lt;&lt; std::endl;

    my_things.push_back( Something() );
    my_things[1].fill_data( ""another_file.txt"" );
    cout &lt;&lt; my_things[1].get_data() &lt;&lt; std::endl;
}
</code></pre>

<p>Since you are using C++, not C, get used to writing C++ code instead of C. (<code>std::vector</code> instead of C arrays (for unknown length arrays), <code>std::string</code> instead of <code>char*</code>, etc).</p>
",1
19967248,19967181,0,"<p>I think your question is too general for the format of stack overflow, but what you want in this case is to either create a public member, or create a private member with setters and getters.</p>

<pre><code>class Something
{
public:
    std::string m_string;
}

int main()
{
    Something A;
    A.m_string = ""toto"";
    cout &lt;&lt; A.m_string;
    return 0;
}
</code></pre>

<p>Put a string for convenience (you could use a <code>const char*</code> but you will have to understand what is the scope to know when it will not be accessible anymore and you are not quite there yet) and there may be typos since I typed this from a phone.</p>

<p>If you really want to access the chars themselves, pass a char* with a size_t for the length of the array or use std::array if possible.</p>
",5
18944983,18944938,0,"<p>You must save the user list (or here array) as member of loginscreen.</p>

<p>except that, for style: when calling a function prefer <code>const string &amp;</code>(setUN) and getters should be <code>const</code> here</p>
",0
18945185,18944938,0,"<p>See it yourself :</p>

<pre><code>void LoginScreen(){

//you still want to use addUser from main, so what is this ?
UserInfo addUser[100];             -----------+
 ...                                          |
}                                             |
                                              |
void main()                                   |
{                                             |
                                              |
    UserInfo addUser[100];        ------------+
...
}
</code></pre>

<p>You can do something like this :</p>

<p><code>void LoginScreen(UserInfo addUser[] ){ ... }</code></p>

<p>Obviously you need to remove <code>UserInfo addUser[100];</code> from <code>LoginScreen</code> too</p>

<p>and then call it from <code>main</code></p>

<p><code>LoginScreen(addUser) ;</code></p>

<p>Also, <code>void main</code> is not legal c++ use <code>int main</code></p>
",0
19790939,19790796,2,"<p>I would refer you to this cheat sheet, and the conclusion would be the list.</p>

<p><img src=""https://i.stack.imgur.com/kQnCS.png"" alt=""enter image description here""></p>
",2
19790957,19790796,1,"<p>List is better in this case most probably. The advantage of a <code>list</code> over <code>vector</code> is that it supports deletion at arbitrary position with constant complexity. A <code>vector</code> would only be better choice if you require constant index operation of elements of the container. Still you have to take into consideration how is the element you would like to delete passed to your function for deletion. If you only pass an index, vector will be able to find the element in constant time, while in list you will have to iterate. In this case I would benchmark the two solution, but still I would bet on list performing better. </p>
",4
19791099,19790796,1,"<p>A list supports deletion at an arbitrary but <em>known</em> position in constant time. </p>

<p><em>Finding</em> that position takes linear time, just like modifying a vector. </p>

<p>The only advantage of the list is if you repeatedly erase (or insert) at (approximately) the same position. </p>

<p>If you're erasing more or less at random, chances are that the better memory locality of the vector could win out in the end.</p>

<p>The only way to be sure is to measure and compare. </p>
",0
19791347,19790796,4,"<p>One key reason to use <code>std::vector</code> over <code>std::list</code> is <a href=""https://stackoverflow.com/questions/16699247/what-is-cache-friendly-code/16699282#16699282"">cache locality</a>. A list is terrible in this regard, because its elements can be (and usually are) fragmented in your memory. This will degrade performance significantly.</p>

<p>Some would recommend using <code>std::vector</code> almost always. In terms of performance, cache locality is often more important than the complexity of insertion or deletion.</p>

<p><a href=""http://www.youtube.com/watch?v=YQs6IC-vgmo"" rel=""nofollow noreferrer"">Here's a video about Bjarne Stroustrup's opinion regarding subject</a>.</p>
",0
19791235,19790796,0,"<p>It depends on many factors and how are you using your data.</p>

<p>One factor: do you need an erase that maintains the order of the collection? or you can live with changing order?</p>

<p>Other factor: what kind of data is in the collection? (numbers: ints/floats) || pointers || objects</p>

<p><strong>Not keeping order</strong></p>

<p>You could continue using <code>vector</code> if the data is basic numbers or pointers, to delete one element you could copy the last element of the vector over the deleted position, then <code>pop_back()</code>. This way you avoid moving all the data.</p>

<p>If using objects, you could still use the same method if the object you need to copy is small.</p>

<p><strong>Keeping order</strong></p>

<p>Maybe List would be your friend here, still, some tests would be advised, depends on size of data, size of list, etc</p>
",2
19217194,19217174,3,"<p>You cannot declare or define functions inside another function. Move your definitions outside of <code>int main(){ ... }</code>.</p>
",1
19217340,19217174,1,"<p>This is what you want.</p>
<ol>
<li>Declare functions outside the main method.</li>
<li>Declare functions before the main method or use forward declarations</li>
<li>Pass the 'value' to each function as a argument.</li>
<li>Remove unnecessary variable declaration.</li>
<li>Use some validation for user inputs.</li>
<li>Use meaningful variable names.</li>
</ol>
<h1>include </h1>
<pre><code>using namespace std;


double C2F(double f)
{       
    return f * 9 / 5 + 32;    
}

double K2F(double f)
{   
    return ((f - 273.15) * 1.8 + 32.0);   
}

double N2F(double f)
{           
    return (f * 60 / 11 + 32);

}

int main()
{
    char function;
    double value;
    cout &lt;&lt; &quot;This temperature Conversion program converts other temperatures to farenheit&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;The temperature types are&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;C - Celcius&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;K - Kelvin&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;N - Newton&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;X - eXit&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;&quot; &lt;&lt; endl;
    cout &lt;&lt; &quot;To use the converter you must input a value and one of the temperature types.&quot; &lt;&lt;         endl;
    cout &lt;&lt; &quot;For example 32 C converts 32 degrees from Celsius to Fahrenheit&quot; &lt;&lt; endl;
    cin &gt;&gt; value &gt;&gt; function;

    function = toupper(function);

    while (function != 'X')
    {
        switch (function)
        {
        case 'C':       
            cout &lt;&lt; value &lt;&lt; &quot;C is &quot; &lt;&lt; C2F(value) &lt;&lt; &quot; in Farenheit&quot; &lt;&lt; endl;
            break;
        case 'K':       
            cout &lt;&lt; value &lt;&lt; &quot;K is &quot; &lt;&lt; K2F(value) &lt;&lt; &quot; in Farenheit&quot; &lt;&lt; endl;
            break;
        case 'N':
            cout &lt;&lt; value &lt;&lt; &quot;N is &quot; &lt;&lt; N2F(value) &lt;&lt; &quot; in Farenheit&quot; &lt;&lt; endl;
            break;
        default:
            cout &lt;&lt; &quot;Correct choices are C, K, N, X&quot; &lt;&lt; endl;
        }
        cout &lt;&lt; &quot;Please enter a value and it's type to be converted&quot; &lt;&lt; endl;
        cin &gt;&gt; value &gt;&gt; function;
        function = toupper(function);
    }
    return 0;
}
</code></pre>
",2
19217241,19217174,1,"<p>First of all you cant declare another function in the <strong><em>main()</em></strong> function.</p>

<p>secondly all of your function have a return type, but surprisingly you are calling them as they are void. Make the function void instead of a return type. As for example....</p>

<pre><code>void C2F()
{
    f = value * 9 / 5 + 32;
}
</code></pre>

<p>and then </p>

<pre><code>case 'C':
        C2F();
        cout &lt;&lt; value &lt;&lt; ""C is "" &lt;&lt; f &lt;&lt; "" in Farenheit"" &lt;&lt; endl;
        break;
</code></pre>

<p>OR.
You can receive the return value in a double type variable and and print the value.</p>

<pre><code>case 'C':
    cout &lt;&lt; value &lt;&lt; ""C is "" &lt;&lt; C2F() &lt;&lt; "" in Farenheit"" &lt;&lt; endl;
    break;
</code></pre>
",3
19501203,19500529,1,"<p>I wouldn't put error handling logic inside a tokenizer class - it's supposed to be a pretty dumb text muncher that just splits it on whitespaces and returns tokens to the caller.</p>

<p>So lets say you start parsing a statement and your tokeninizer returns <code>let</code>. Now you know that what follows is supposed to be a declaration. The next token should be a unique name of a variable that doesn't exists yet. So you call <code>Token_stream::get()</code> again and see what you get. On success, you get the next token and see if you get a <code>=</code>. Etc.</p>

<p>Similarly - you get a name of a variable as a first token of a statement. You check whether it has been declared yet and report an error if it hasn't. You check another token. It's supposed be an operator of some sort (that probably includes <code>=</code>). If you get it, you start looking for a valid term (a value, another variable, an expression...). Etc.</p>
",0
18338765,18338061,5,"<h3>Your problem</h3>

<pre><code>extern int const ITEMS = 9;
</code></pre>

<p>Marking this <code>extern</code> is correct, but then you went ahead and gave it a definition, undoing all that lovely correctness.</p>

<p>When you define symbols in headers, whether you're using include guards <em>or not</em>, when your translation units are linked together you will get multiple definition errors.</p>

<p>You must define the symbol <code>ITEMS</code> in precisely <em>one</em> translation unit &mdash; this generally means defining it in a ""source"" file, <em>not</em> a header.</p>

<hr>

<h3>Naive fix</h3>

<p>So, in your header:</p>

<pre><code>extern int const ITEMS;  // definition found elsewhere
</code></pre>

<p>And then, in <em>one</em> .cpp file:</p>

<pre><code>int const ITEMS = 9;
</code></pre>

<hr>

<h3>Real fix</h3>

<p>But, <strong>oops!</strong> You need this constant in your headers, because some array sizes rely on it.</p>

<p>So, instead of making one symbol <code>ITEMS</code> that is shared between all translation units in your program, you will have to have a definition local to <em>each</em> translation unit. To do this, we use the <code>static</code> keyword to make the symbol file-static.</p>

<p>So, in your header:</p>

<pre><code>static int const ITEMS = 9;  // visible only in this TU
</code></pre>

<p>Now, multiple translation units (loosely speaking, this means each .cpp that uses this header) will have their own version of <code>ITEMS</code>, just as before... but this time, because they're marked <code>static</code>, each is <em>local</em> to that translation unit, so they will not conflict at link-time.</p>
",0
18338847,18338061,5,"<p>First, in your header <code>Vending Machine.h</code> (by the way, it's a bad idea to have spaces in file names, why don't you just name it <code>VendingMachine.h</code>?), the following line:</p>

<pre><code>  extern int const ITEMS = 9;
</code></pre>

<p>is a <em>definition</em>, not a declaration, despite the <code>extern</code>, because of the initializer part (the ""<code>= 9</code>"").</p>

<p>Now, this header is included by multiple source (<code>.cpp</code>) files, and <code>ITEMS</code> has <em>external linkage</em> (explicitly because of <code>extern</code>), resulting in each source file (re)defining <em>the same</em> <code>ITEMS</code>, hence the multiple definition error you get.</p>

<p>If you change the line to</p>

<pre><code>  static int const ITEMS = 9;
</code></pre>

<p>or simply</p>

<pre><code>  int const ITEMS = 9;
</code></pre>

<p>(which is actually equivalent because of the particular rules for <code>const</code> globals), then each <code>ITEMS</code> (in each source file) will have <em>internal linkage</em> and that will be all fine.</p>

<hr>

<p><strong>Edit:</strong> Additionally, the following answer is a nice explanation of the two meanings of <code>extern</code> (""external linkage"" and ""declare, not define""): <a href=""https://stackoverflow.com/a/2840401"">https://stackoverflow.com/a/2840401</a></p>

<p><strong>Edit:</strong> Two other good answers about <code>extern</code> (which add the meaning of ""static storage duration""): <a href=""https://stackoverflow.com/a/3994572"">https://stackoverflow.com/a/3994572</a> and <a href=""https://stackoverflow.com/a/18450398"">https://stackoverflow.com/a/18450398</a></p>
",0
18338912,18338061,3,"<pre><code>  extern int const ITEMS = 9;
</code></pre>

<p>Since you include an initializer, this declaration is also a definition.  And since you declare it <code>extern</code>, there is only one object <code>ITEMS</code>.  But with that line in the header file, everything that includes the header makes its own definition.</p>

<p>You could leave off the <code>extern</code>, in which case the <code>const</code> will imply <code>static</code>.</p>

<pre><code>  int const ITEMS = 9;
</code></pre>

<p>Then <code>ITEMS</code> is a different object in each compilation unit, but that doesn't matter much if you always use it as a value, and never do anything with its address.</p>

<p>Or if you have C++11 support enabled, you could have:</p>

<pre><code>  constexpr int ITEMS = 9;
</code></pre>

<p>... which tells the compiler to treat the one <code>ITEMS</code> object similarly to an <code>inline</code> function, and it can be defined more than once.</p>
",0
18649890,18649854,5,"<pre><code>int fun (int n)
{
    if (n &lt;= 3) { fail(); /* Does not return. */ }
    return n;
}
</code></pre>
",0
18649896,18649854,6,"<p>If you're just trying to squelch a warning about ""control reaches end of non-void function"" or something along those lines, you can decorate <code>fail()</code> with some compiler-specific directives that indicate it doesn't return.  In GCC &amp; Clang, that would be <code>__attribute__((noreturn))</code>, for example.</p>

<p>Example:</p>

<pre><code>$ cat example.cpp 
void fail(void);

int fun(int n)
{
  if (n &gt; 3)
    return n;
  else
    fail();
}
$ clang++ -c example.cpp 
example.cpp:9:1: warning: control may reach end of non-void function
      [-Wreturn-type]
}
^
1 warning generated.
$ cat example2.cpp 
void fail(void) __attribute__((noreturn));

int fun(int n)
{
  if (n &gt; 3)
    return n;
  else
    fail();
}
$ clang++ -c example2.cpp
$
</code></pre>
",4
18649901,18649854,-1,"<p>Building on Aesthete's answer:</p>

<pre><code>int fun (int n)
{
    if (n &lt;= 3) { fail(); return -1; } //-1 to indicate failure
    return n;
}
</code></pre>
",5
18649918,18649854,1,"<p>One possible idiom is to define <code>fail</code> as returning an int and then write:</p>

<pre><code>int fun(int n){
    if (n &gt; 3)
        return n;
    else
        return fail();                            

}
</code></pre>
",4
18649954,18649854,0,"<p>You could declare an error code that will indicate that something is wrong with the function.</p>

<p>For example:</p>

<pre><code>const int error_code = -1;

int fun (int n) {

    if (n &gt; 3) 
        return n;

    fail();
    return error_code;

}
</code></pre>
",1
18650621,18649854,0,"<p>Another neat way is to use <a href=""http://www.boost.org/doc/libs/1_41_0/libs/optional/doc/html/boost_optional/examples.html#boost_optional.examples.optional_return_values"" rel=""nofollow"">boost::optional</a> as the return value. This would indicate the return value many not be set in failure cases and this can be further checked by caller to take subsequent action.</p>
",0
18899748,18899670,2,"<p>You could set the default value for the <code>cnt</code> argument:</p>

<pre><code>std::vector&lt;int&gt;::size_type random_search(std::vector&lt;int&gt; A, int x, int cnt = 0)
{
  // ...
}
</code></pre>

<p>Now you can call it from your main without passing 0 for the <code>cnt</code>:</p>

<pre><code>int index = random_search(B, 80);
</code></pre>
",0
18604242,18604191,1,"<p>Pass it as a parameter. (Arrays, unlike other parameters, are not copied when passed by value. Modifying the parameter will alter the external array).</p>

<pre><code>int main()
{
    Tile map[50][50];

    ///// Generate Map \\\\\
    buildRoom(map, 10, 10, 10, 10, 1);
}

void buildRoom(Tile map[50][50], int startX, int startY, int sizeX, int sizeY, int direction)
{
    if (direction == 1)
    {
        for (int x; x++; x &gt; sizeX)
             map[startX + x][startY].type = 1;
    }
}
</code></pre>

<p>Or put it in a class.</p>

<pre><code>#include &lt;cassert&gt;

class Map
{
public:
    static const int MapSizeX = 50;
    static const int MapSizeY = 50;

    void buildRoom(int startX, int startY, int sizeX, int sizeY, int direction)
    {
        if (direction == 1)
        {
            for (int x; x++; x &gt; sizeX)
                 GetTile(startX + x, startY).type = 1;
        }
    }

    const Tile&amp; GetTile(int x, int y) const
    {
        assert(x &gt; 0 &amp;&amp; x &lt; MapSizeX &amp;&amp; y &gt; 0 &amp;&amp; y &lt; MapSizeY);
        return data[x][y];
    }

    Tile&amp; GetTile(int x, int y)
    {
        assert(x &gt; 0 &amp;&amp; x &lt; MapSizeX &amp;&amp; y &gt; 0 &amp;&amp; y &lt; MapSizeY);
        return data[x][y];
    }

private:
    Tile data[MapSizeX][MapSizeY];
}

int main()
{
    Map mymap;

    ///// Generate Map \\\\\
    mymap.buildRoom(10, 10, 10, 10, 1);
}
</code></pre>
",2
18606352,18606246,0,"<p>Remove the semicolon on line 36</p>

<pre><code>&lt;&lt;ctime (&amp;nowIsTheMoment); &lt;&lt; endl;
                         ^
                         |
</code></pre>
",0
18606354,18606246,0,"<p>You forgot to <code>#include &lt;string&gt;</code> and qualify <code>string</code> and <code>cout</code> with <code>std::</code>.</p>
",1
18628193,18610218,0,"<p>You have to overload QwtPlotZoomer reimplementing trackerTextF(). If you also have a use case of a standalone QwtPlotPicker - not being a QwtPlotZoomer - you have to do it twice:</p>

<p>class YourPicker: public QwtPlotPicker ...
class YourZoomer: public QwtPlotZoomer ...</p>

<p>As your implementation is a one-liner I don't see a problem in writing it twice, but if you want to avoid that, you have to put the code to some other class, that is called in both overloaded methods.</p>
",0
19501376,19501087,0,"<p><strong>Edited for vector use:</strong></p>

<pre><code>std::vector&lt;int&gt; getIndexOfString(string *arr, int size, string check)
{
  std::vector&lt;int&gt; iVect;
  for (int i = 0; i &lt;= size - 1; i++)
  {
    if (arr[i] == check)
    {
      iVect.push_back (i);
      cout &lt;&lt; ""Found at "" &lt;&lt; i &lt;&lt; endl;
    }
  }

  if (iVect.empty)
     cout &lt;&lt; ""not found"" &lt;&lt; endl;

  return iVect;
}
</code></pre>

<p>Your function has too many un-initialized pointers. Are you really wanting to return an index or a pointer? You are also missing the return value for the failed case.</p>
",3
19501379,19501087,4,"<p>First of all, you are accessing to uninitialized memory. The weird thing is, that your first code works. However, it's probably compiler-specific (these things happens in C++ a lot).</p>

<p>Local variables are usually allocated on stack and C++ doesn't guarantee you any default value. Therefore, one possible explanation is that there was (on the same memory address, where your pointer is saved) another, valid, pointer. Now, when you created this local variable, it just got this ""old"" address and so it's accessing to some previously allocated memory. Just don't care about it at the moment and even if it works, believe us - you shouldn't rely on this. :-)</p>

<p>Another problem is with that returned value. How you'd use that, when you don't know size of that array? You should return something like std::vector&lt;>, some structure or something like that. Not just pointer to an array of unknown length!</p>

<p>Result: Your code is way too complicated than it could be. See better solution:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

std::vector&lt;int&gt; getIndexes(std::vector&lt;std::string&gt; &amp;input, std::string searched) {
    std::vector&lt;int&gt; result;

    for (int i = 0; i &lt; input.size(); i++) {
        if (input[i] == searched) {
            result.push_back(i);
        }
    }

    return result;
}

int main(int argc, char *argv[]) {
    std::vector&lt;std::string&gt; greetings;
    greetings.push_back(""hello"");
    greetings.push_back(""hi"");
    greetings.push_back(""bye"");
    greetings.push_back(""hi"");
    greetings.push_back(""hello"");
    greetings.push_back(""bye"");

    std::vector&lt;int&gt; indexes = getIndexes(greetings, ""hi"");

    for (int i = 0; i &lt; indexes.size(); i++) {
        std::cout &lt;&lt; indexes[i] &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>
",1
19501480,19501087,1,"<p>Your main problem is that you're not initializing your result pointer to a valid array. Really though you should return a vector of indices rather than a pointer, this way the caller knows the size and doesn't have to manage the memory manually. Something like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

using namespace std;

vector&lt;int&gt; getIndicesOfString(const vector&lt;string&gt;&amp; in, const string&amp; check) {
    vector&lt;int&gt; ret;
    for (auto it = cbegin(in); it != cend(in); ++it) {
        if (*it == check) ret.push_back(distance(cbegin(in), it));
    }
    return ret;
}

int main() {
    auto v = vector&lt;string&gt;{""red"", ""orange"", ""yellow"", ""green"", ""blue"", ""indigo"", ""violet"", ""red""};
    auto indices = getIndicesOfString(v, ""red"");
    copy(cbegin(indices), cend(indices), ostream_iterator&lt;int&gt;(cout, "", ""));
}
</code></pre>
",0
19501912,19501087,2,"<p>Others have suggested it, and here I place it for reference.</p>

<p>You can use the Standard Library. In particular the algorithm <code>std::find</code>:</p>

<pre><code>#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;

int main() {
  std::vector&lt;std::string&gt; words = {""one"", ""two"", ""three"", ""four"", ""five""};
  size_t index = std::distance(words.begin(),
                               std::find(words.begin(), words.end(), ""three""));
  std::cout&lt;&lt;""Index: ""&lt;&lt;index&lt;&lt;std::endl;
}
</code></pre>

<p>compiled as (GCC 4.8.1 OS X 10.7.4):</p>

<pre><code>g++ indices-in-array.cpp -std=c++11
</code></pre>

<p>output:</p>

<pre><code>Index: 2
</code></pre>
",2
19321445,19321150,0,"<p>Don't do it.
But if you really want, you can:</p>

<pre><code>std::string&amp; operator+(std::string&amp; lhs, int rhs)
{
    throw std::runtime_error(""That's really stupid."");
    return lhs;
}
</code></pre>
",2
19321715,19321150,0,"<p>I'm not sure if this is what you are looking for, but for
anything like what you describe in your comment to work, you
need inheritance.  All of your template classes must derive from
a common base, where the comparison takes place: </p>

<pre><code>private:
    virtual void doBinaryFunction( Base const&amp; other ) const = 0;
public:
    void binaryFunction( Base const&amp; other ) const
    {
        if ( typeid( *this ) != typeid( other ) ) {
            throw std::runtime_error( ""Type mismatch"" );
        }
        doBinaryFunction( other );
    }
</code></pre>

<p>In each of the derived classes, you <code>static_cast</code> the <code>Base
const&amp;</code> to <code>Derived const&amp;</code>, and then do whatever has to be
done.</p>

<p>If you want to handle mixed types, you'll need some form of
double dispatch.</p>

<p>You also mention implementing ""addition"", where the types to be
added are different.  The problem here is that addition has
a return type which depends on the types being added.  The usual
way of handling this is by deciding on a canonical type (say
double).  In this case, the best solution is probably to provide
some sort of virtual function which returns the value as the
canonical type, do the addition with the canonical type, and
return it.</p>

<p>Never the less, this smacks of very bad design.  First, of
course, you don't ""add"" <code>ford</code> and <code>chevy</code> and expect to get the
sum of their speeds.  That just doesn't make sense.  You might
add <code>ford.speed()</code> and <code>chevy.speed()</code> (although I don't think
that adding the speed of two unrelated cars makes sense either),
but then regardless of the implementations, the <code>speed</code> function
has to return the canonical type for speed; <em>if</em> <code>ford</code> and
<code>chevy</code> have different concrete types, you will be calling
through the interface defined in the base class.</p>
",0
20651717,20651640,3,"<p><code>#include &lt;VECTOR&gt;</code></p>

<p>I'm assuming you meant to include <code>#include &lt;vector&gt;</code>.</p>

<p>Unresolved external ? You did not implement <code>~Vec(void);</code> only a declaration exists. Please implement the destructor or simply do not declare it.</p>

<p>Also for a better style I would recommend deleting the <code>using namespace std;</code> and use <code>std::vector&lt;T&gt;</code> instead.</p>

<p>Another style issue is your <code>return 0;</code> in the main function. Please use <code>EXIT_SUCCESS</code> instead.<br>
<br>
<br>
To your edit:
Told you a implementation is needed. Also you include your headers very strange.<br>
<code>#include &lt;IOSTREAM&gt;</code><br>
What's this ? Please use the usual style form: <code>#include &lt;iostream&gt;</code>. The include may work, but it looks very strange.</p>
",0
18478506,18478474,2,"<p>I see no code where you initialise <code>a</code> to 1 so it may be it has some arbitrary value. If that arbitrary value is greater than <code>num</code>, the outer loop will never start.</p>

<p>For what it's worth, I would be using <code>for</code> loops in this case since you know in advance what the limits are, something like the following pseudo-code:</p>

<pre><code># Top line
for i = 1 to num (inclusive):
    output ""*""
output newline

# Middle lines
for i = 2 to num-1:
    output ""*""               # Left char
    for j = 2 to num-1:      # Middle chars
        output "" ""
    output ""*"" and newline   # Right char

# Bottom line
for i = 1 to num (inclusive):
    output ""*""
output newline
</code></pre>

<p>Then you don't have to worry about condition checking within the loop body.</p>

<p>A good rule of thumb is to use <code>for</code> for a known-before-the-start count of iterations, <code>while</code> for a loop where you don't know in advance how often you'll iterate.</p>

<p>Another likely problem is your condition:</p>

<pre><code>while ( num &gt; 1 || num &lt; 20 )
</code></pre>

<p>Regardless of the value of <code>num</code>, that is always true, since you're using logical-or <code>||</code>. Think of the possibilities:</p>

<pre><code>num &lt;= 1     : false or true  -&gt; true
num == 2..19 : true  or true  -&gt; true
num &gt;= 20    : true  or false -&gt; true
</code></pre>

<p>If you want to continue looping while you have a value <em>outside</em> of the range 1..20, you should use:</p>

<pre><code>while ( num &lt; 1 || num &gt; 20 )
</code></pre>

<p>and you then end up with the following:</p>

<pre><code>num &lt; ?1 ? ? : true  or false?-&gt; true
num == 1..20 : false or false?-&gt; false
num &gt; ?20 ? ?: false?or true  -&gt; true
</code></pre>

<hr>

<p>There are quite a few other potential problems with your code, to wit:</p>

<ul>
<li>You appear to have the outer loop in there twice.</li>
<li>You don't appear to define <code>b</code> or <code>num</code>.</li>
<li>You don't appear to set <code>num</code> before the outer loop (which checks it).</li>
<li>I suspect you meant to close the <code>while ( num &gt; 1 || num &lt; 20 )</code> loop immediately after the <code>cin.ignore()</code> call since it's meant to keep going until you get a value from 1 to 20 and <em>then</em> draw the square. As it stands, a square will be drawn even if you enter 99.</li>
</ul>
",2
18479412,18478474,0,"<p>Probably not the best code - but it can be done in six lines. Here goes.</p>

<pre><code>   for (int y = o; y &lt; height; ++ y) {
       for (int x = 0; x &lt; width; ++x) {
          cout &lt;&lt; (y == 0 || y == (height - 1) || x == 0 || x == (width - 1) ? '*' : ' ' );
       }
       cout &lt;&lt; endl;
    }
</code></pre>
",0
18731902,18731862,0,"<p><code>istringstream</code> copies the string you pass it in the constructor, so changes you make to the string following that won't have any effect on the stream. You should construct a new stream, or call the <code>istringstream:str()</code> method to supply a new string, every time the string changes.</p>

<pre><code>getline (myfile, s, ',');  //read to comma
iss.str(s);                // supply new string to stream
iss &gt;&gt; d.qtr;              //use stringstream to store into d.qtr
</code></pre>
",0
18797803,18797657,2,"<p>The argument to a <code>virtual</code> base class is provided by the most derived class, not by an intermediate class. If you want to pass the argument you received for <code>Child</code> to the <code>Base</code>, you need to implement your <code>Child</code> constructor like this:</p>

<pre><code>Child::Child(Base const&amp; other)
    : Base(other)
    , Center(other)
{
}
</code></pre>

<p>BTW, it is unusual to use <code>(void)</code> instead of <code>()</code> to indicate that the function doesn't take any arguments in C++: the <code>void</code> was at some point necessary in C to distinguish between a variable argument list function and a function taking no argument (I don't know if this is still the case in C11). In C++ an empty pair of parenthesis always indicated an empty argument list.</p>
",3
19321168,19320474,1,"<p>There are a number of things that I would do differently. Without going into details, here is what I propose; it requires C++11 (pass the <code>-std=c++11</code> also to the compiler if you are using gcc or clang):</p>

<pre><code>#include &lt;algorithm&gt; 
#include &lt;cctype&gt;
#include &lt;fstream&gt;
#include &lt;functional&gt; 
#include &lt;iostream&gt;
#include &lt;locale&gt;

using namespace std;

// trim from left
static string ltrim(string s) {
        s.erase(s.begin(), find_if(s.begin(), s.end(), [](char c) { return !isblank(c); } ));
        return s;
}

int main() {

  string file_name;

  cout &lt;&lt; ""Please enter the file name: "" &lt;&lt; flush;
  cin &gt;&gt; file_name;

  ifstream in(file_name);

  if (!in.good()) {

    cout &lt;&lt; ""Failed to open file \"""" &lt;&lt; file_name &lt;&lt; ""\"""" &lt;&lt; endl;

    return 1;
  }

  string buffer;

  while (getline(in, buffer)) {

    buffer = ltrim(buffer);

    if (!buffer.empty()) {

      cout &lt;&lt; buffer &lt;&lt; '\n'; // &lt;-- or write into a file as you need
    }
  }

  return 0;
}
</code></pre>

<p>Now the title says you want to remove only the leading spaces but to my question you answered that you want to remove the trailing spaces as well from the end of the lines. If it is like that, use <code>trim()</code> instead of <code>ltrim()</code>. The necessary functions are:</p>

<pre><code>// trim from left
static string ltrim(string s) {
        s.erase(s.begin(), find_if(s.begin(), s.end(), [](char c) { return !isblank(c); } ));
        return s;
}

// trim from right
static string rtrim(string s) {
        s.erase(find_if(s.rbegin(), s.rend(), [](char c) { return !isblank(c); }).base(), s.end());
        return s;
}

// trim from both left and right
static string trim(string s) {
        return ltrim(rtrim(s));
}
</code></pre>

<p>There are other, most likely faster trim implementations. See, for example: <a href=""https://stackoverflow.com/q/216823/341970"">What's the best way to trim std::string</a>?</p>
",1
19321034,19320474,0,"<p>The standard library already has most of the functionality you want, so I'd do my best to rely on that to do most of the job.</p>

<p>Copying some data with a specified subset removed is what <code>std::remove_copy_if</code> is supposed to do, so I'd use it for the main loop:</p>

<pre><code>std::remove_copy_if(std::istream_iterator&lt;line&gt;(std::cin), 
        std::istream_iterator&lt;line&gt;(),
        std::ostream_iterator&lt;std::string&gt;(std::cout, ""\n""),
        [](std::string const &amp;s){return s.empty(); });
</code></pre>

<p>So, given an appropriate definition of a <code>line</code>, that will copy lines with any empty ones removed.</p>

<p>Our next step is to define a <code>line</code> class that removes leading white-space when we extract one from a stream, and can be converted to a <code>string</code>. For that, I'd ""cheat"" a little. When we extract a character from a stream like <code>mystream &gt;&gt; mychar;</code>, it automatically skips any leading white-space. I'd use that by reading a char, then putting it back into the stream<sup>1</sup>, so I had the stream starting from the first non-whitespace character. Then I'd use <code>getline</code> to read the rest of the line. </p>

<hr>

<p><sup>1. Reading a character, then immediately putting it back into the stream is probably unusual enough to merit either a comment, or being put into a function with a descriptive name like <code>skip_leading_blanks</code>:</p>

<pre><code>void skip_leading_blanks(std::istream &amp;is){
    char ch;
    is &gt;&gt; ch;
    is.putback(ch);
}
</code></pre>

<p></sup></p>
",0
18736590,18736331,1,"<p>Cross platform solution:
<code>rlutil.h</code>
<a href=""http://tapiov.net/rlutil/docs/HTML/files/rlutil-h.html#rlutil.locate"" rel=""nofollow"">http://tapiov.net/rlutil/docs/HTML/files/rlutil-h.html#rlutil.locate</a></p>

<p>void locate(    int?    x,
int?    y   )</p>
",4
18898639,18898608,7,"<p>You forgot some semicolons:</p>

<pre><code>struct Entry { 
    char* word; 
    char* def;
};                //C++ structs need a semicolon after the curly brace.


class Dictionary { 
    public:
    Dictionary(); 
    ~Dictionary();
    void addEntry(Entry*);
    char* getDef(const char*); 

    private:
    std::vector&lt;Entry&gt; dict;    

};
</code></pre>
",2
18981920,18981724,3,"<p>If you ever enter anything ""invalid"", such that reading from cin will cause an error, you have to call <code>cin.clear()</code> to be able to read further input, otherwise the stream in operator will just return immediately.</p>

<p>Typically, when reading user input, you check the state of cin and exit or do some error handling when it is invalid. In addition, on a failed input attempt, the characters that caused the error will still be sitting in cin, and need to be ignored (e.g., up to the next newline):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;limits&gt;

int main() {
    int userOption;
    while(1) {
        while(!(std::cin &gt;&gt; userOption)) {
            std::cout &lt;&lt; ""Invalid input."" &lt;&lt; std::endl;
            std::cin.clear();
            std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
        }
        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
        std::cout &lt;&lt; userOption &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>
",5
18981963,18981724,0,"<p>The problem is with the following line of code,</p>

<pre><code>cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');
</code></pre>

<p>When you are entering a single number, you don't have to ignore any other character. So simply remove the above line of code to correct your program.</p>
",1
18479220,18479137,1,"<p>There are a few issues here:</p>

<ol>
<li><p>Don't prematurely optimise. Don't be afraid to use variables no matter how little they are used. Many modern compilers will be able to recognise when and where (and sometimes how) they are used and in many cases variables are ""optimised out"".</p></li>
<li><p>Signed integer types do not wrap around (or rather, they are not guaranteed to &ldquo;wrap&rdquo; as unsigned types do). The underlying architecture may support wrapping of signed integer types and so it may appear to work, but GCC is known to optimise based on the assumption that signed types don't wrap (see <a href=""http://thiemonagel.de/2010/01/signed-integer-overflow/"" rel=""nofollow"">here</a>).</p></li>
<li><p>If you are using C++, you should just use the built-in <a href=""http://en.cppreference.com/w/cpp/algorithm/reverse"" rel=""nofollow""><code>std::reverse</code></a>.</p></li>
</ol>
",2
18479163,18479137,2,"<p>To codify <code>chris</code>' comment above, I would write this:</p>

<pre><code>#include &lt;algorithm&gt;

void rev_string(std::string&amp; s) { 
    std::reverse(s.begin(), s.end());
}
</code></pre>
",1
18479411,18479137,0,"<p>I can think of three options right now (from most to least desirable):</p>

<ol>
<li><p>Use <code>std::reverse</code></p></li>
<li><p>If you refuse to use <code>std::reverse</code>, you can define your own <code>reverse</code> that uses <code>std::swap</code>.</p></li>
<li><p>If you refuse to use <code>std::swap</code>, you can define your own. But <em>please</em> have mercy and use a <code>temp</code>. Don't make it harder to read your code!</p></li>
</ol>

<hr>

<p>Here's are some examples:</p>

<p><code>std::reverse(s.begin(), s.end());</code></p>

<p>OR</p>

<pre><code>std::string reverse(std::string str) {

    int size = str.size();

    for (int i = 0; i &lt; size / 2; i++) 
        std::swap(str[i], str[size-i-1]);

    return str;

}
</code></pre>

<p>OR If you refuse to use <code>std::swap</code></p>

<pre><code>void swap(std::string&amp; str, int index1, int index2) {

    char temp = str[index1];
    str[index1] = str[index2];
    str[index2] = temp;

}

std::string reverse(std::string str) {

    int size = str.size();

    for (int i = 0; i &lt; size / 2; i++) 
        swap (str, i, size - i - 1);

    return str;

}
</code></pre>
",0
19796531,19795785,0,"<p>I think some input operation failed in <code>person.record(std::cin);</code> and <code>cin</code> is in a bad state.
In this case
""<a href=""https://stackoverflow.com/questions/257091/how-do-i-flush-the-cin-buffer"">How do I flush the cin buffer?</a>"" should help.
Especially, note the <strong>call to <code>ignore(...)</code></strong> to get ride of the bad input!</p>

<p>Running code for demo:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;limits&gt;

int main() {
    int i;

    std::cout &lt;&lt; ""Input: "";

    std::cin &gt;&gt; i;

    std::cout &lt;&lt; ""Received: "" &lt;&lt; i &lt;&lt; ""\nInput next:"";

    std::cin.clear();
    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');

    std::cin &gt;&gt; i;

    std::cout &lt;&lt; ""Received: "" &lt;&lt; i &lt;&lt; ""\n"";

    return 0;
}
</code></pre>
",1
18898046,18897931,2,"<p>replace </p>

<pre><code>    if(dest &gt; last)
        dest -= last;
</code></pre>

<p>with:  </p>

<pre><code>    if(dest &gt; last)
        dest -= size;
</code></pre>

<p>You should use the <code>modulo</code> operator to manage cyclic access. My preferred version would be :</p>

<pre><code>for(int i = 0; i &lt; size; i++) {
    C[(i+offset)%size] = A[i];
}
</code></pre>

<p>This way, you can delete <code>dest</code> and all associated error-prone lines :)</p>
",0
19883801,19883737,0,"<p>The <code>std::list&lt;T&gt;::iterator</code> objects internally point to a node but have operators which appropriately follow the pointers to next or previoys node. That is, they are not pointers as incrementing a pointer just adds one rather than follow a link. You can inagine a list iterator looks somewhat like this:</p>

<pre><code>template &lt;typename T&gt;
class list_iterator {
    friend list&lt;T&gt;
    Node* node; 
    list_iterator(T* node):node(node) {}
    list_iterator&amp; operator++() {
        node = node-&gt;next;
        return *this;
    }
    T&amp; operator*() { return *node; }
     // ...
};
</code></pre>
",2
19883805,19883737,0,"<p>The iterator on lists should behave similar to the iterators on other sequence containers like <code>vector</code>. I.e. it should behave like a pointer to the list::value_type as if it were in an array or similar (with ++ and -- doing the expected operation going to next and previous). The internals of the holding structure aren't really exposed through the iterator. The iterator abstraction generally frees the programmer from thinking about how the data is stored. In the future, you could theoretically swap your <code>std::list</code> for a <code>std::vector</code> without changing your code, so long as you're only using operations available to both.</p>
",0
18462845,18462717,0,"<p>Take a look to the documentation of your compiler, for example the MS C++ compiler will check system includes after local with quotes (so <code>#include ""io.h""</code> will get the system include if there are no <code>io.h</code> local header files), but it won't look locally for angled brackets:</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/36k2cdd4.aspx"" rel=""nofollow"">http://msdn.microsoft.com/en-us/library/36k2cdd4.aspx</a></p>

<p>I guess that you will have to manually check for project files if there are names collisions for include files.</p>
",0
18462957,18462717,2,"<p>Aside from ""asking the compiler"", there is no trivial way to determine if <code>""io.h""</code> or <code>&lt;io.h&gt;</code> is taken from a local directory or somewhere in the standard headers. For example, a program will compile perfectly happily with <code>#include ""iostream""</code>. </p>

<p>The main difference is that the compiler will look FIRST in the local directory for the file ""io.h"" when using <code>""io.h""</code>, where if you use <code>&lt;io.h&gt;</code> it will look in the include directories specified as ""system include directories"". However, there is nothing saying that system include directories does not include ""current directory"" in one way or another. </p>

<p>You can use <code>g++ -M myfile.cpp</code> to list what include files are used in the file ""myfile.cpp"". <strike>Unfortunately, as far as I can tell, there is no such option for Visual Studio.</strike></p>

<p><strong>Edit</strong>: The MS compiler does indeed support a similar feature using the <a href=""http://msdn.microsoft.com/en-us/library/hdkef6tk.aspx"" rel=""nofollow""><code>/showinclude</code></a> option.</p>
",1
19877276,19877243,0,"<ul>
<li>A header files says - We can do this.</li>
<li>A .cpp file says - This is how we do it - ie. compile it to an object.</li>
</ul>

<p>The .cpp files use header files to know what is available.</p>

<p>Compile the .cpp files. Generate object files. Link them together and that will do the tie up the loose ends. Bang - Got an executable.</p>
",0
19877605,19877243,2,"<p>The best (and standard) thing to do would probably be to:</p>

<ol>
<li>write a class Stud, not a struct (private members of the class would be <code>name</code>, <code>vorname</code> etc.)</li>
<li>make a header file, where you would write the definition of the class with prototypes of all the functions</li>
<li>define those functions in a separate .cpp file</li>
<li>and finally, you would just make another .cpp file for the implementation (main).</li>
</ol>

<p>Of course, you need to include your header file in the .cpp files.</p>
",0
19259846,19259829,8,"<p>Because sometimes you need to create an overloaded operator where your class type is on the right-hand-side. This must be implemented as a free function. Classic example:</p>

<pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; str, my_type const&amp; my)
{
    // print out `my` into `str`---requires `friend` if using
    // private members of `my_type`
    return str;
}
</code></pre>
",1
19376904,19376771,3,"<p>See it <strong><a href=""http://coliru.stacked-crooked.com/a/1681a5b03485e91a"" rel=""nofollow"">Live on Coliru</a></strong></p>

<pre><code>#include &lt;string&gt;
#include &lt;cassert&gt;

template &lt;typename Out&gt;
void hex2bin(std::string const&amp; s, Out out) {
    assert(s.length() % 2 == 0);

    std::string extract;
    for (std::string::const_iterator pos = s.begin(); pos&lt;s.end(); pos += 2)
    {
        extract.assign(pos, pos+2);
        *out++ = std::stoi(extract, nullptr, 16);
    }
}

#include &lt;iostream&gt;
#include &lt;vector&gt;

int main()
{
    std::vector&lt;unsigned char&gt; v;

    hex2bin(""1023456789ABCD"", back_inserter(v));

    for (auto byte : v)
        std::cout &lt;&lt; std::hex &lt;&lt; (int) byte &lt;&lt; ""\n"";
}
</code></pre>

<p>Outputs</p>

<pre><code>10
23
45
67
89
ab
cd
</code></pre>
",0
19376911,19376771,-1,"<p>when you say 'byte' it looks like you're meaning each character represented in hexidecimal.</p>

<p>in that case you could simply use <code>string.c_str()</code>, as this is just a c-style string (<code>char*</code>).</p>

<pre><code>byte[2] = 0x45
</code></pre>

<p>is the same as</p>

<pre><code>byte[2] = 69; //this is 0x45 in decimal
</code></pre>

<p>you could assign the output of <code>string.c_str()</code> to another <code>char*</code> if you wanted to store the array seperately.</p>
",3
18798791,18798732,2,"<p>As one of the comments has mentioned, the correct syntax to compare a <code>pointer to string object</code> and a <code>string object</code> is by dereferencing the pointer.</p>

<p>Therefore in your code, it should be:</p>

<pre><code>if( *thePointer-&gt;theVar == s )
</code></pre>
",2
19882599,19882561,4,"<p>Not</p>

<pre><code>std::touppper
</code></pre>

<p>but </p>

<pre><code>std::toupper
</code></pre>

<p>You need to pass a locale to the function, see for example: <a href=""http://www.cplusplus.com/reference/locale/toupper/"" rel=""nofollow"">http://www.cplusplus.com/reference/locale/toupper/</a> </p>
",0
19882647,19882561,1,"<p><code>std::touppper</code> does not exist, as it is spelled with two <code>p</code>'s, not with three :). <code>std::erase</code> is not a standard function, check this: <a href=""https://stackoverflow.com/questions/1821703/help-me-understand-stderase"">Help me understand std::erase</a></p>
",2
19882700,19882561,0,"<p>You probaly want to use <code>std::toupper()</code> as the basis of your implementation. Note, however, that <code>std::toupper()</code> takes its argument as <code>int</code> and requires that the argument is a positive value of <code>EOF</code>. Passing negative values to the one argument version of <code>std::toupper()</code> will result in undefined behavior. On platforms where <code>char</code> is signed you will easily get negative values, e.g., when using ISO-Latin-1 encoding with my second name. The canonical approach is to use <code>std::toupper()</code> with the <code>char</code> convert to an <code>unsigned char</code>:</p>

<pre><code>tekstr[0] = std::toupper(static_cast&lt;unsigned char&gt;(tekstr[0]));
</code></pre>

<p>With respect to <code>erase()</code> you are probably looking for <code>std::string::erase()</code>:</p>

<pre><code>tekstr.erase(i);
</code></pre>

<p>Note that if the string ends in a space, you don't want to access the character at index <code>i</code> after blowing the last space away!</p>
",0
19889307,19889250,0,"<p>The error is that your assignment of <code>value1</code> is effectively <code>value = value1++;</code>... so you want to read the current value of value1, 6, and then increment it but also store that 6 somewhere else (that overwrites where the incrementation occurred).</p>

<p>Use <code>value1 = (value1 &gt; 5) ? value1 + 1 : value1;</code> instead.</p>
",0
19574781,19574696,1,"<blockquote>
  <p>A constructor that supplies default arguments for all its parameters also defines the default constructor</p>
</blockquote>

<p>This means using default parameters. In your example this means:</p>

<pre><code>Book( int n = 5, double p = 46, std::string f = ""Times New Roman"" ) :
    pages( n ),
    price( p ),
    font( f ) {}
</code></pre>
",0
19574790,19574696,3,"<p>If you can construct your object without calling a constructor explicitly<sup>*</sup>, then you have a <em>default</em> constructor. A class has a default constructor:</p>

<ul>
<li><p>If you don't create any constructor. ( <code>= default</code>)</p></li>
<li><p>If you create a constructor without any argument.</p></li>
<li><p>If you create a constructor which all its arguments have default values.</p></li>
</ul>

<hr>

<p><sup>*</sup> To clear the statement, you must have the ability to make an object like below:</p>

<pre><code>Book book;
</code></pre>
",5
19574870,19574696,4,"<p>The funny thing is that your class <em>can</em> have multiple constructor overload which could work with no arguments and are therefore valid default constructors:</p>

<pre><code>struct A
{
    A() {}
    A( int i = 0 ) {}
};
</code></pre>

<p>This is perfectly legal to write. The answer to the question from the title is therefore: <strong>Yes.</strong> The only problem is that you can not use them - they are ambiguous. When you write:</p>

<pre><code>A a;
</code></pre>

<p>you get an error as both would match.</p>
",0
19575153,19574696,0,"<p>you are taking about types of constructor. So there are three,  default constructor by complier, default constructor by programmer with default arguments, and default constructor by programmer without dafault arguments. So you are talking about about 2nd type. Yes, it is a type of default construct</p>
",0
18982069,18981752,6,"<p>To get a compile time error you would need a template:</p>

<pre><code>template &lt;int width, int height&gt;
class MatrixTemplate : public Matrix
{
    static_assert(0 &lt; width, ""Invalid Width"");
    static_assert(0 &lt; height, ""Invalid Height"");
    public:
    MatrixTemplate()
    : Matrix(width, height)
    {}
};
</code></pre>

<p>(Btw.: I suggest unsigned types for indices)</p>

<p>If you do not have static_assert (here I switch to unsigned):</p>

<pre><code>template &lt;unsigned width, unsigned height&gt;
class MatrixTemplate : public Matrix
{
    public:
    MatrixTemplate()
    : Matrix(width, height)
    {}
};

template &lt;&gt; class MatrixTemplate&lt;0, 0&gt; {};
template &lt;unsigned height&gt; class MatrixTemplate&lt;0, height&gt; {};   
template &lt;unsigned width&gt; class MatrixTemplate&lt;width, 0&gt; {};
</code></pre>

<p>There is no support for empty matrices (MatrixTemplate&lt;0, 0>), here. But it should be an easy task to adjust the static_asserts or class MatrixTemplate&lt;0. 0>.</p>
",7
18982082,18981752,1,"<p>The way that linear algebra packages tend to do this is to use templates for fixed size matrices, as in:</p>

<p><code>template&lt;int x, int y&gt; class Matrix { ... }</code></p>

<p>and an extra class for matrices that can change size at runtime</p>

<p><code>class DynamicMatrix {...}</code></p>

<p>You still have to rely on the programmer actually using the first option when they want fixed size matrices, but the template version makes it easy to generate a compiler error when <code>x</code> or <code>y</code> are zero.</p>
",0
18982260,18981752,0,"<p>Run-time:</p>

<pre><code>Matrix(int width, int height):
    x_size{width},
    y_size{height}
{
        assert(x_size&gt;0);
        assert(y_size&gt;0);
}
</code></pre>

<p>Compile-time (Actually you couldn't do it with function arguments. You can use template ways):</p>

<pre><code>template &lt;size_t WIDTH, size_t HEIGHT&gt;
class Matrix
{
    const size_t x_size = WIDTH;
    const size_t y_size = HEIGHT;

    static_assert(WIDTH &gt; 0, ""Width must &gt; 0"");
    static_assert(HEIGHT &gt; 0, ""Height must &gt; 0"");
};
</code></pre>
",0
18983462,18981752,3,"<p>You may add a method like this:</p>

<pre><code>template &lt;int WIDTH, int HEIGHT&gt;
Matrix CreateMatrix()
{
    static_assert(WIDTH &gt; 0, ""WIDTH &gt; 0 failed"");
    static_assert(HEIGHT &gt; 0, ""HEIGHT &gt; 0 failed"");

    return Matrix(WIDTH, HEIGHT);
}

int main() {
    Matrix m(0, 2);     // no static check
    Matrix m2 = CreateMatrix&lt;0,2&gt;(); // static check

    return 0;
}
</code></pre>
",1
18832183,18831658,0,"<p>If your goal is just to bitwise count <code>1</code> and <code>0</code> bits in a file, you can simplify things greatly by using C++ file streams and not using lookup tables:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;

int main(int argc, char** argv)
{
  std::ifstream fpInput(""Input.txt"");
  unsigned unOnes = 0;
  unsigned unZeros = 0;
  char chTemp;

  chTemp = fpInput.get();
  while (fpInput.good())
  {
    for (unsigned i = 0; i &lt; 8; ++i)
    {
      if (chTemp &amp; 0x1&lt;&lt;i) unOnes++;
      else unZeros++;
    }

    chTemp = fpInput.get();
  }

  fpInput.close();

  std::cout &lt;&lt; ""Found "" &lt;&lt; unOnes &lt;&lt; "" ones."" &lt;&lt; std::endl;
  std::cout &lt;&lt; ""Found "" &lt;&lt; unZeros &lt;&lt; "" zeros."" &lt;&lt; std::endl;

  return 0;
}
</code></pre>

<p>A good compiler should expand the middle loop out if you pass it the right optimisation flags.</p>
",5
18831795,18831658,1,"<p>The loop that counts zeros and ones destroys the value of <code>c</code> by doing</p>

<pre><code>c &gt;&gt;= 1;
</code></pre>

<p>After all eight shifts are complete, <code>c</code> is always zero, so the following code increments wrong counts:</p>

<pre><code>// The value of c is always zero
tzero[c]=z;
tone[c]=o;
one[c]+=tzero[c];
zero[c]+=tzero[c];
</code></pre>

<p>You should save the value of <code>c</code> before the bit-counting loop, and restore it after the loop is over.</p>

<p>Better yet, compute the values of <code>tzero[]</code> and <code>tone[]</code> upfront, without waiting for them to occur in the file. This would make the body of your main loop very short and clean:</p>

<pre><code>while((c=fgetc(input))!=EOF) {
    one[c] += tzero[c];
    zero[c] += tzero[c];
}
</code></pre>
",1
19208154,19208000,0,"<p>This may help:</p>

<pre><code>template &lt;class T, class Comparator = std::less&lt;T&gt;&gt;
class MyClass
{
  bool compare(const T&amp; lhs, const T&amp; rhs) const { return Comparator()(lhs, rhs); }
  // stuff
};

class A
{
public:
    bool operator &lt; (const A&amp; rhs) const;
};

MyClass&lt;A&gt; myClass;
</code></pre>
",0
19208022,19208000,0,"<pre><code>template &lt;class T, class Comparator = std::less&lt;T&gt;&gt;
class MyClass
{
  //...
}
</code></pre>

<p>In member function, something like :-</p>

<pre><code>void MyClass::Myfun(X x, Comparator mycomp = Comparator())
{

  if (mycomp(data1,data2)) 
    //...

}
</code></pre>
",1
19208403,19208000,0,"<p>The STL containers actually store an instance of the comparator, so what you want is closer to this:</p>

<pre><code>template &lt;class T, class Comparator = std::less&lt;T&gt;&gt;
class MyClass : private Comparator
{
public:
    MyClass() {}
    MyClass( const Comparator&amp; compare ) : Comparator( compare ) {}

    bool compare(const T&amp; lhs, const T&amp; rhs) const
    {
        return static_cast&lt;Comparator&gt;(*this)(lhs, rhs);
    }

    // stuff
};

class A
{
public:
    bool operator &lt; (const A&amp; rhs) const;
};

MyClass&lt;A&gt; myClass;
</code></pre>

<p>Note that you should use private inheritance to allow the empty base optimization to remove overhead in case the <code>Comparator</code> does not contain any state.</p>
",0
18866362,18866318,3,"<p>You need to use a proper editor. You are using <code></code> and not <code>&quot;</code>. The former is a character which is not allowed in C++ source code, the latter is a regular double-quote.</p>
<p>If I see your code, it seems you are using a <strong>word processor</strong> suitable for writing regular text (like letters, articles, etc.). Note that source code is different and you need to use an <strong>editor</strong>. I, for example, use <a href=""http://de.wikipedia.org/wiki/Emacs"" rel=""nofollow noreferrer""><code>emacs</code></a>, other alternatives are available. A (source code) editor would not try to replace the character you typed by something more appealing or capitalize words (which is I think happened for <code>Void</code>, <code>Int</code>, etc. - these need to be <code>void</code>, <code>int</code>, ...)</p>
<p>The C++ standard defines the allowed characters in 2.3:</p>
<blockquote>
<h3>2.3 Character sets [lex.charset]</h3>
<p><sup>1</sup> The basic source character set consists of 96 characters: the space character, the control characters repre- senting horizontal tab, vertical tab, form feed, and new-line, plus the following 91 graphical characters:<sup>14</sup></p>
<p><code>a b c d e f g h i j k l m n o p q r s t u v w x y z</code></p>
<p><code>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</code></p>
<p><code>0 1 2 3 4 5 6 7 8 9</code></p>
<p><code>_ { } [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; |  ! = , \ &quot; </code></p>
<p><sup>14) The glyphs for the members of the basic source character set are intended to identify characters from the subset of ISO/IEC 10646 which corresponds to the ASCII character set. However, because the mapping from source file characters to the source character set (described in translation phase 1) is specified as implementation-defined, an implementation is required to document how the basic source characters are represented in source files.</sup></p>
</blockquote>
",11
18940780,18940684,3,"<p>Change:</p>

<pre><code>  char c = word[i];
</code></pre>

<p>To:</p>

<pre><code>  unsigned char c = word[i];
</code></pre>
",3
18941041,18940684,0,"<p>In C and C++ you should always pay attention to numeric overflow because the language assumption is that a programmer will never make such a mistake.</p>

<p>A <code>char</code> is a kind of integer and is quite often 8 bits and signed, giving it an acceptable range of -128...127. This means that when you store a value in a <code>char</code> variable you should never exceed those bounds.</p>

<p><code>char</code> is also a ""storage type"" meaning that computations are never done using <code>char</code>s and for example</p>

<pre><code>char a = 'z';    // numeric value is 122 in ASCII
int x = a + 20;  // 122 + 20 = 142
</code></pre>

<p><code>x</code> will actually get the value 142 because the computation did not ""overflow"" (all <code>char</code> values are first converted to integers in an expression)</p>

<p>However storing a value bigger that the allowable range in a variable is undefined behaviour and code like</p>

<pre><code>char a = 'z';     // numeric value is 122 in ASCII
char x = a + 20;  // 122 + 20 = 142 (too big, won't fit)
</code></pre>

<p>is not acceptable: the computation is fine but the result doesn't fit into <code>x</code>.</p>

<p>Storing a value outside the valid range for signed chars in a signed char variable is exactly what your code did and that's the reason for the strange observed behaviour.
A simple solution is to use an integer to store the intermediate results instead of a char.</p>

<p>A few more notes:</p>

<ul>
<li>A few functions about chars are indeed handling integers because they must be able to handle the special value <code>EOF</code> in addition to all valid chars. For example <code>fgetc</code> returns an <code>int</code> and <code>isspace</code> accepts an <code>int</code> (they return/accept either the code of the char converted to unsigned or <code>EOF</code>).</li>
<li><code>char</code> could be signed or not depending on the compiler/options; if unsigned and 8-bit wide the allowable range is 0...255</li>
<li>Most often when storing a value outside bounds into a variable you simply get a ""wrapping"" behavior, but this is not guaranteed and doesn't always happen. For example a compiler is allowed to optimize <code>(char(x + 20) &lt; char(y + 20))</code> to <code>(x &lt; y)</code> because the assumption is that the programmer will never ever overflow with signed numeric values.</li>
</ul>
",0
18939978,18939896,1,"<p>In C++ there are mainly two different ways with file operations.<br> One is using Fstream functions, that is mainly used in Turbo C and the other one is FILE as a data type.<br></p>

<p>Now what you can do is create a file pointer.</p>

<pre><code>fstream fp;
fp.open(""Your_file_path.txt"",""w""); 
</code></pre>

<p>The above code will help you to open ur file.
Next you need to get this file in a string or a char array.
For that you can use the get() function.
To get it, you can add this<br></p>

<pre><code>yourarray=fp.get();
</code></pre>

<p><br>
in a loop till (EOF) which means the end of file also called as \0.<br>
Now you have all the contents of ur file copied into a char array. All u need to do is search the array for what u want, edit it and replace the entire file contents with the char array.</p>
",0
18939970,18939896,5,"<p>Read the content of your file into string and use <code>replace()</code>. Then write the string back to the file. Something like this:</p>
<pre><code>#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;

using namespace std;

int main()
{
    ostringstream text;
    ifstream in_file(&quot;Text.txt&quot;);

    text &lt;&lt; in_file.rdbuf();
    string str = text.str();
    string str_search = &quot;Fortunato&quot;;
    string str_replace = &quot;NotFortunato&quot;;
    size_t pos = str.find(str_search);
    str.replace(pos, string(str_search).length(), str_replace);
    in_file.close();

    ofstream out_file(&quot;Text.txt&quot;);
    out_file &lt;&lt; str;     
}
</code></pre>
<p>Use <code>regex_replace</code> (C++11) or <code>boost:regex</code> for more advanced find &amp; replace operations.</p>
",2
18605257,18605161,0,"<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;
using namespace std;

void sortArray (int [ ], int ) ;
void showArray (int [ ], int ) ;
int count = 0;

int main ()
{
const int SIZE = 6;
int values[SIZE] = {7, 2, 3, 8, 9, 1} ;

cout &lt;&lt; ""The unsorted values are: \n"";
showArray (values, SIZE) ;

sortArray (values, SIZE) ;

cout&lt;&lt; ""The sorted values are: \n"" ;
showArray (values, SIZE) ;

return 0;
}

void sortArray (int array [ ], int SIZE)
{
int temp;
bool swap;

do
{ swap = false;
for (int count = 0 ; count &lt; (size - 1 ) ; count ++)
{
if (array [count] &gt; array [count + 1] )
{
temp = array [count] ;
array [count] = array [count + 1] ;
array [count + 1] = temp ;
swap = true ;
count++;
dispCount();
}
}
} while (swap) ;
}

void dispCount(){
cout &lt;&lt; ""The current amount of swaps is "" &lt;&lt; count &lt;&lt; endl;
}

void showArray (int array [ ], int size)
{
for (int count = 0 ; count &lt; size ; count ++)
cout &lt;&lt; array [count] &lt;&lt; "" "" ;
cout &lt;&lt; endl ;
}
</code></pre>

<p>Reference Links </p>

<p><a href=""http://www.dreamincode.net/forums/topic/227402-help-finding-number-of-swaps-and-comparisons-of-sorting-algorithm/"" rel=""nofollow""><strong>Link 1</strong></a></p>

<p><a href=""http://www.learncpp.com/cpp-tutorial/64-sorting-an-array-using-selection-sort/"" rel=""nofollow""><strong>Link 2</strong></a></p>

<p><strong><a href=""http://answers.yahoo.com/question/index?qid=20110604121845AA3nqR3"" rel=""nofollow"">Link 3</a></strong></p>
",0
18605266,18605161,0,"<pre><code>static int count = 0; in the head of function bubbleSort;
</code></pre>

<p>put the <code>count++</code> after the code where you switch 2 numbers.</p>

<pre><code>printf(""%d"", count); in the end.
</code></pre>
",0
18605357,18605161,0,"<h1>The C Code I've written for you returns this output</h1>

<p>You have provided this data 
    1   2   3   4   5   9   8   7   6
    11  12</p>

<p><code>Selection sort</code> on this array took <strong>14</strong> swap operation</p>

<p><code>Bubble sort</code> on this array took <strong>48</strong> swap operation</p>

<hr>

<p>You are asking for a <code>counter</code> variable that holds the number of swapping operations in bubble sort as well as in your selection sort program.</p>

<p>I've written a <strong><code>C</code></strong> code for your both problems.</p>

<h1>Bubble sort</h1>

<pre><code>#include&lt;stdio.h&gt;
#define size 20
int Arr[size],i,j,counter=0;    
void bubble();
int main()
{
    printf(""Enter your elements now\n"");
    for(i=0;i&lt;size;i++)
    scanf(""%d"",&amp;Arr[i]);
    printf(""You have provided\n"");
    for(i=0;i&lt;size;i++)
    printf(""\t%d"",Arr[i]);
    printf(""\nPress any key to perform Bubble sort\n"");
    bubble();
    printf(""Result after Bubble sort\n"");
    for(i=0;i&lt;size;i++)
    printf(""\t%d"",Arr[i]);
    printf(""Bubble sort on this array took %d swap operation"",counter);
    return 0;
}
void bubble()
{

    for(i=0;i&lt;size;i++)
    {
        for(j=0;j&lt;(size-1)-i;j++)
        {
            if(Arr[j]&gt;Arr[j+1])
            {
                Arr[j] = Arr[j] + Arr[j+1];
                Arr[j+1] = Arr[j] - Arr[j+1];
                Arr[j] = Arr[j] - Arr[j+1];
                counter++;
            }
            printf(""\r"");
        }
    }
}
</code></pre>

<h1>Selection sort</h1>

<pre><code>#include&lt;stdio.h&gt;
#define size 20
void selection();
int findmin(int []);
int i,j,Arr[size],min,counter;
int main()
{
    printf("" Enter your elements now \n"");
    for(i=0;i&lt;size;i++)
        scanf(""%d"",&amp;Arr[i]);
    printf(""You have provided this data \n"");
    for(i=0;i&lt;size;i++)
        printf(""\t%d"",Arr[i]);
    printf(""\nPress any key to perform selection sort\n"");
    selection();
    printf(""Result after selection sort\n"");
    for(i=0;i&lt;size;i++)
        printf(""\t%d"",Arr[i]);
    printf(""Selection sort on this array took %d swap operation"",counter);
}
void selection()
{
    for(i=0;i&lt;(size-1);i++)
    {
        j = findmin(Arr);
        if(Arr[i]&gt;Arr[j])
        {   
            Arr[i] = Arr[i] + Arr[j];
            Arr[j] = Arr[i] - Arr[j];
            Arr[i] = Arr[i] - Arr[j];
            counter++;
        }
    }
}
int findmin(int a[])
{
    min = i;
    for(j=i+1;j&lt;size;j++)
    {   
        if(a[j]&lt;a[min])
            min = j;
    }   
    return(min);
}
</code></pre>
",0
18940081,18940009,3,"<p><code>.4*88+.3*(92.7+54.3)</code> does not fit in a <code>float</code>. You must read it as a string a parse the expression yourself.</p>

<p>When you use <code>input &gt;&gt; ... &gt;&gt; s[i]-&gt;score</code> it reads the <code>.4</code> but leaves the rest (<code>*88+.3*(92.7+54.3)</code>) in the buffer and screws up subsequent reads.</p>

<p><strong>Quickfix:</strong> replace <code>float score;</code> by <code>std::string score;</code></p>
",0
18627556,18627529,1,"<p><code>findLowest</code> prototype inside <code>calcAverage</code> is missing <code>&amp;</code>:</p>

<pre><code>void calcAverage (int score1, int score2, int score3, int score4, int score5)
{
    int findLowest(int, int, int, int, int, int&amp;);
    //                                         ^
    ....
}
</code></pre>

<p>Actually, you don't need that prototype, because there's already same prototype before the <code>main</code> function.</p>
",2
20534687,20534155,0,"<p>How <code>std::ifstream</code> finds a file given a path is platform-specific, but on a Unix-like system the string should simply be passed to <code>open</code>.</p>

<p>You might try debugging a direct call to <code>open</code> (from <code>&lt;fcntl.h&gt;</code>), and/or check <code>errno</code> (from <code>&lt;cerrno&gt;</code>) after the <code>ifstream</code> constructor returns.</p>

<p>In any case, the problem is almost certainly either insufficient permissions or a spelling error.</p>
",0
20409410,20409358,1,"<p><code>increase</code> expects two <code>emp</code>s as parameters, yet you pass in two <code>int</code>s.</p>

<p>Change</p>

<pre><code>increase(fst.salary,scnd.salary);
</code></pre>

<p>to</p>

<pre><code>increase(fst,scnd);
</code></pre>

<p>Your next question is going to be why the values don't change, so to save you the trouble - it's because you're passing by value, effectively changing copies of your original objects. You'll need to pass by reference:</p>

<pre><code>void increase(emp&amp; x,emp&amp; y)
</code></pre>
",1
20409452,20409358,0,"<p><code>increase(fst.salary,scnd.salary);</code> should be <code>increase(fst,scnd);</code>, <code>void increase(emp x,emp y) ...</code> should be <code>void increase(emp&amp; x,emp&amp; y) ...</code></p>
",0
20409483,20409358,0,"<p>You need to pass <code>emp</code> not <code>int</code>. Further, you are passing parameters by value. Use this instead:</p>

<pre><code>void increase(emp &amp;x,emp &amp;y)
</code></pre>

<p>And pass the struct variables; i.e. fst and scnd instead of fst.salary and scnd.salary. Refer <a href=""https://stackoverflow.com/questions/2207179/difference-between-value-parameter-and-reference-parameter"">this</a> question for better understanding.</p>
",0
19496174,19490661,1,"<p>There are two main improvement areas in your understanding of object oriented design with C++.</p>

<ul>
<li>Your first choice to provide access to a private member should be a public method, not <code>friend</code>.</li>
<li>To access an object of another type in a method, you should pass an object of that type. Do not start thinking of static or global objects, unless that is what you really want.</li>
</ul>

<p>I have posted some code snippets below. Put them together to solve your problem.</p>

<pre><code>class TestAPI {
public:
    // method to modify _hRequest
    void set_hRequest(HINTERNET&amp; in_hRequest) {
        _hRequest = in_hRequest;
    }

    // method to access _hRequest
    HINTERNET&amp; get_hRequest() {
        return _hRequest;
    }

private:
    HINTERNET _hRequest;
};
</code></pre>

<p>.</p>

<pre><code>UserAPI::SomeExampleToChangeRequest(TestAPI&amp; t) {
    // use 't' to access TestAPI here, like so ...
    HINTERNET h = t.get_hRequest();  
}
</code></pre>

<p>Once your user creates the <code>TestAPI</code> object, have them pass it by reference to the <code>UserAPI::SomeExampleToChangeRequest()</code> method. Additionally, use a forward declaration as mentioned by gbjbaanb, to aid the compiler. </p>
",0
19495745,19490661,0,"<p>You can create a <a href=""http://www.learncpp.com/cpp-tutorial/17-forward-declarations/"" rel=""nofollow"">forward declaration</a>, which is a way to say ""this definition will be provided later"" so your code will syntax check correctly, and the compiler will sort things out for you later (which it knows the full definitions for both classes).</p>

<p>However, there are limitations. Because the compiler doesn't know anything about the forwardly-declared class, you can't refer to its methods, or its size. This means you pretty much have to refer to it via a pointer, which you hopefully wrap in a smart pointer.</p>
",0
18800190,18800069,3,"<p>As you say this in not homework then just use STL - i.e. <a href=""http://www.cplusplus.com/reference/queue/queue/"" rel=""nofollow"">http://www.cplusplus.com/reference/queue/queue/</a></p>

<p>All the bits'n'bobs are done for you</p>
",2
18800096,18800069,2,"<p>Don't use <code>malloc</code> in a C++ program, it doesn't construct C++ objects correctly, use <code>new</code> instead.</p>

<pre><code>clnc_hrs *newnode = new clnc_hrs();
</code></pre>

<p>You might have other errors but this is the first one.</p>

<hr>

<pre><code>cout&lt;&lt;""enter name of the patient:"";
std::getline(cin, N);
newnode-&gt;name = N;
</code></pre>

<p>is not wrong, but just a bit wasteful. This is simpler</p>

<pre><code>cout&lt;&lt;""enter name of the patient:"";
std::getline(cin, newnode-&gt;name);
</code></pre>

<p>same for all you other inputs.</p>

<hr>

<pre><code>fflush(stdin);
</code></pre>

<p>is implementation defined behaviour. <code>fflush</code> only has defined behaviour on output streams not input streams. You seem to be using <code>fllush(stdin);</code> as some sort of magic incantation that you hope will solve your problems. Avoid that kind of thinking. Learn what the code you write really does. In this case you should remove all calls to <code>fflush(stdin);</code>.</p>
",10
18703853,18702804,3,"<p>The simple answer is yes, you can do <code>file &gt;&gt; myWord;</code>, as long
as you've defined the <code>&gt;&gt;</code> operator for your class:</p>

<pre><code>std::ostream&amp;
operator&gt;&gt;( std::ostream&amp; source, Word&amp; word )
{
    //  ...
    return source;
}
</code></pre>

<p>Several considerations:</p>

<ul>
<li><p>This operator cannot be a member; it must be a free function.
(If it were a member, your class would be the left hand
argument.)  If it needs to access private data, you might have
to make it a <code>friend</code>.  </p></li>
<li><p>Don't forget about error checking, and the conventions of
<code>istream</code> for errors.  If you encounter input you cannot parse
into your class, you need to set <code>std::ios::failbit</code>.  (Of
course, a lot of the time, you'll be delegating to previously
defined <code>&gt;&gt;</code>, and if they fail, <code>std::ios::failbit</code> will already
have been set.)</p></li>
</ul>

<h2>EDIT:</h2>

<p>As for what you should do inside the newly overloaded operator,
there are several possibilities (which can, with care, be
mixed):</p>

<ul>
<li><p>You can invoke existing <code>&gt;&gt;</code>, for example, for strings or
built-in types.  This is by far the easiest, but it supposes
that your input can easily be parsed uniquely in terms of
existing <code>&gt;&gt;</code>, which is rarely the case.</p></li>
<li><p>You can also use unformatted input, like <code>istream::get()</code>,
this is most often used in parallel with the previous solution,
to input things like separators, or other syntactical elements
of your format.</p></li>
<li><p>Or you can do revert to reading the bytes directly from the
<code>streambuf</code>, and parse them.  This is appropriate if you have
some totally new type, for example.  If you go this route, do
<em>not</em> forget to set <code>eofbit</code> if you read an end of file, even if
you can successfully parse otherwise.  If you do this, you'll
also have to create a <code>sentry</code> object at the top of your <code>&gt;&gt;</code>,
and only proceed if it is good.  (It is only in such
<code>operator&gt;&gt;</code> that <code>std::ios::good</code> makes sense.  You must never
try to read a character from the streambuf if <code>std::ios::good()</code>
returns false, and you must set <code>std::ios::eofbit</code> anytime you
read an EOF (which will cause all future calls to
<code>std::ios::good()</code> to return false).  This is so essential that
I tend to use a small wrapper object for it, and read through
it.</p></li>
</ul>

<p>In all cases, you may have to play around with the formatting
information: as a simple example, if you don't want to allow
white space within your input, but you are still using <code>&gt;&gt;</code>, you
should set <code>nows</code> (and restore it at the end).  Thus, most such
<code>&gt;&gt;</code> operators will start by saving the formatting status, and
restore it at the end.  (This is usually done by means of an
<code>IOSave</code> class, which you should have in your toolkit anyway.)
And again, if something in the input format is incorrect, you
should set <code>failbit</code>.</p>

<p>As a simple example, consider a <code>&gt;&gt;</code> for a simple <code>Complex</code>
class:</p>

<pre><code>std::istream&amp;
operator&gt;&gt;( std::istream&amp; source, Complex&amp; dest )
{
    IOSave state( source );
    //      Skip leading whitespace, depending on formatting options.
    if ( (source.flags() &amp; std::ios_base::skipws) != 0 ) {
        source &gt;&gt; std::ws;
    }
    source.unsetf( std::ios_base::skipws );
    std::streamsize totalWidth
        = std::max( source.width() - 3, std::streamsize(0) ); ;
    std::streamsize imagWidth = totalWidth / 2;
    std::streamsize realWidth = totalWidth - imagWidth;
    if ( source.get() != '(' ) {
        source.unget();
        source.setstate( std::ios::failbit );
    }
    double real = 0.0;
    source &gt;&gt; std::setw( realWidth ) &gt;&gt; real;
    std::numpunct&lt;char&gt; const&amp; np
        = std::use_facet&lt;std::numpunct&lt;char&gt;&gt;( source.getloc() );
    if ( std::get() != (np.decimal_point() != ',' ? ',' : ';') ) {
        source.unget();
        source.setstate( std::ios::failbit );
    }
    double imag = 0.0;
    source &gt;&gt; std::setw( imagWidth ) &gt;&gt; imag;
    if ( std::peek() != ')' ) {
        source.unget();
        source.setstate( std::ios::failbit );
    }
    if ( source ) {
        dest = Complex( real, imag );
    }
    return source;
}
</code></pre>

<p>This is an extremely simplistic example.  A real <code>Complex</code>
class would, for example, also accept input in the form a+ib.
But it should give you an idea of the sort of things you have to
consider when writing such an operator.</p>
",2
19259600,19259561,3,"<p>Member <code>FirstName</code> is an instance of <code>std::string</code> (object) thus trying to assign <code>NULL</code> to it makes no sense.</p>

<p>Also note that to define a member function in other place (not where it was declared), you must use<br>
a class's name as a prefix:</p>

<pre><code>string Employee::setFirstName(string FirstName)
{
    ...
}
</code></pre>

<p>And also note that your constructor might be simplified to this (using initialization list):</p>

<pre><code>Employee (string FirstName, string LastName, float Salary)
  : FirstName(FirstName), LastName(LastName), Salary(Salary) { }
</code></pre>
",5
19259614,19259561,2,"<p>Class declaration:</p>

<pre><code>class Employee {
public:
    string FirstName;
    string LastName;
...
    string EmployeeSearch(string LastName[], string SearchName);
    void DisplayEmployee (string DisplayFirstName, string DisplayLastName, string DisplaySalary);
    Employee();
};
</code></pre>

<p>Class implementation:</p>

<pre><code>string 
Employee::EmployeeSearch(string LastName[], string FirstName[], float Salary, string SearchName, string DisplayFirstName, string DisplayLastName, string DisplaySalary)
{
    cout &lt;&lt; ""Please enter the name of the employee you would like to search."" &lt;&lt;  endl;
    cin &gt;&gt; SearchName;
    ...
</code></pre>

<p>Without the ""Employee::"" syntax, ""EmployeeSearch() is just a standalone function, having nothing to do with your Employee class.</p>

<p>ALSO:</p>

<p><code>**FirstName = NULL</code> and <code>**this-&gt;LastName**</code> are wrong.</p>

<p>If ""Firstname"" is a string member, you can just refer to it by name.  Similarly, if ReadFile() is a member function (Employee::ReadFile), then you don't need ""this->"".</p>
",2
19260313,19259561,0,"<p>
    <ul>
        <li>Put all the data members in private, that will provide encapsulation and that's what OOP is about.</li>
        <li>Build a Get and Set function for each private member, so you can access to it</li>
        <li>When you declare a string, its default value will be an empty string, so you don't need to set it equal to null </li>
        <li>For the set function, it does not return any value back, so it needs to be void function.</li>
        <li></li>For the get function, since it only returns and does not change the value, you should put the keyword const behind it.
        <li>For the construction, you can set the parameters equal to private members, and don't need to call the set functions.</li>
        <li>Read, Search and Display functions should be put in the main, and not the Employee class. It will be easier to maintain.</li>
    </ul>
</p>

<p><strong>Employee.h</strong></p>

<pre><code>class Employee
{
    private:
    std::string FirstName;
    std::string LastName;
    float Salary;
    public:
    Employee() {}
    Employee(std::string newFirstName, std::string newLastName, float newSalary);
    std::string GetFirstName() const {return FirstName;}
    std::string GetLastName() const {return LastName;}
    float GetSalary() const {return Salary;}
    void SetFirstName(string val) {FirstName = val;}
    void SetLastName (string val) {LastName = val;}
    void SetSalary(float val) {Salary = val;}
};
</code></pre>

<p><strong>Employee.cpp</strong></p>

<pre><code>Employee::Employee(std::string newFirstName, std::string newLastName, float newSalary)
{
    FirstName = newFirstName;
    LastName = newLastName;
    Salary = newSalary;
}
</code></pre>
",0
20422841,20422211,1,"<p>This code is structured slightly wrong</p>

<pre><code>    if(c!=',')
    {
        switch(t)
        {
        case 0: dt.id[i++]=c;break;
        case 1: number[k++]=c;break;
        case 2: number[k]=c;number[k+1]='\0';dt.year=atof(number);t++;break;            
        }
    }
    else
    {
        switch(t)
        {
        case 0:dt.id[i]='\0';break;
        case 1:number[k]='\0';strcpy(dt.name,number); k=0;break;        
        }           
        t++;        
    }         
</code></pre>

<p>it should be</p>

<pre><code>    if(c!=',')
    {
        switch(t)
        {
        case 0: dt.id[i++]=c;break;
        case 1: number[k++]=c;break;
        case 2: number[k++]=c;break;            
        }
    }
    else
    {
        switch(t)
        {
        case 0:dt.id[i]='\0';break;
        case 1:number[k]='\0';strcpy(dt.name,number); k=0;break;        
        case 2: number[k]='\0';dt.year=atof(number); k=0;break;            
        }           
        t++;        
    }         
</code></pre>

<p>But I must admit I don't immediately see why your code would lead to stack corruption.</p>
",0
19883582,19883532,3,"<pre><code>(rand() % 2001 - 1000)/2000
</code></pre>

<p>It's always <code>0</code>. You can divide it by <code>2000.0</code> have values between <code>[0.0, 1.0)</code></p>

<hr>

<p>You can use C++11 random utilities, for example <a href=""http://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution"" rel=""nofollow""><code>std::uniform_real_distribution</code></a>:</p>

<pre><code>std::default_random_engine generator(time(0));
std::uniform_real_distribution&lt;double&gt; distribution(0.0, 1.0);

double x = distribution(generator);
</code></pre>
",3
19883625,19883532,-1,"<p>You are correct that when using <code>rand()</code> one must have a call to <code>srand()</code> at some point in the beginning of their program to ensure different pseudo-random numbers each run. However, the correct usage is: </p>

<pre><code>srand(time(NULL)); 
</code></pre>

<p><code>time(0)</code> returns 0, which seeds <code>rand()</code> the same way each run, causing your issue. <code>time(NULL)</code> returns whatever is stored in the memory where time points and will properly seed the generator.</p>
",2
19883658,19883532,0,"<p>I ran the following in XCode and it produced a different random number each time (using C++ static cast)</p>

<pre><code>#include &lt;iostream&gt;

int main(int argc, const char * argv[])
{
    srand(static_cast&lt;unsigned int&gt;(time(0)));

    int r = rand();

    std::cout &lt;&lt; ""Random number: "" &lt;&lt; r &lt;&lt; std::endl;
    return 0;
}

// Random numbers:
// 2064544746
// 2064897693
// 2065132991
// 2065250640
</code></pre>

<p>Using Apple LLVM 4.2 compiler on i386 x86_64 architecture</p>
",0
20407477,20407314,3,"<p>The ""things"" you're talking about aren't called <em>modules</em>, but <em>functions</em>. That's a pretty big difference and I think you <em>should</em> know it, since you won't understand nearly any article without that knowledge.</p>

<p>That being cleared, the problem in your code is, that you pass the variable by <strong>value</strong> (<code>int menu(int Mystring)</code>), while - in order to change it inside the function - you need to pass it by <strong>reference</strong> or <strong>pointer</strong>:</p>

<pre><code>int menu(int &amp;Mystring)
</code></pre>

<p>There are plenty of <a href=""http://www.eng.cam.ac.uk/help/tpl/languages/C++/argsC++.html"" rel=""nofollow"">articles</a> about functions in C++. You should check them out probably.</p>
",4
19377005,19376674,1,"<p>This will convert the hexadecimal input to characters, and print them out (though the numbers 80 and greater won't actually be ASCII, since they're outside the range defined by ASCII):</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;

int main() { 
     std::transform(std::istream_iterator&lt;std::string&gt;(std::cin), 
                    std::istream_iterator&lt;std::string&gt;(),
                    std::ostream_iterator&lt;char&gt;(std::cout),
                    [](std::string const &amp;in) {
                        return (char) strtol(in.c_str(), NULL, 16); 
                    });
}
</code></pre>

<p>I'm not sure how much good that'll do for you, but it seems to be what you're asking, and without more information on what you really want, it's about as good as I think anybody can probably do.</p>
",3
19436402,19436125,0,"<p>Your syntax for allocating an array is wrong - instead of</p>

<pre><code>int* tmp = new int(size+16);
</code></pre>

<p>(which creates a new int and initializes it with the <em>value</em> size+16), you need</p>

<pre><code>int* tmp = new int[size+16];
</code></pre>

<p>which creates a new int array with size+16 elements.</p>
",1
18832087,18831759,1,"<p>You aren't resetting col to 0 each time.</p>

<p>Try this:</p>

<pre><code>    int number;
    int row = 0;
    int col = 0;
    cout &lt;&lt; ""Enter number:  ""
    cin &gt;&gt; number;
    while (row &lt; number)
    {
        col = 0;
        while (col &lt; number)
        {
            cout &lt;&lt; ""*"";
            col++;
        }
        cout &lt;&lt; endl;
        row++;
    }
    cout &lt;&lt; endl;
    row++;
</code></pre>
",2
18832266,18831759,0,"<p>Here is the loop:</p>

<pre><code>while (row&lt;number)
{ 
  while(column&lt;number)
  {
    cout&lt;&lt;""*"";
    column++;
  }
  column=0;
  cout&lt;&lt;endl;
  row=row+1;
}
</code></pre>
",0
18832588,18831759,0,"<p>Since rows = column we don't need to take a separate variable for rows <br>
<strong>EDIT:</strong> looks like we need to take a variable for rows after all as _gx pointed out subtracting from n itself decreases the no. of columns. Sorry for the rough mistake</p>

<pre><code>n = input (Enter a positive integer)
r = n
while r &gt; 0 
c = 0
while c &lt; n
    print ""*""
    c = c + 1
end
r = r - 1
print end l
</code></pre>

<p>end</p>

<p>Reference, <a href=""https://stackoverflow.com/questions/18812543/write-pseudocode-of-a-program-that-prints-such-a-pattern"">Write pseudocode of a program that prints such a pattern</a></p>
",2
18862213,18862108,1,"<p>Three immediate things (among others):</p>

<p>First, declare (and initialize) <code>n</code> before <code>relative_error_per_cent</code> initialization.</p>

<p>Second, add <code>;</code> in the end of <code>relative_error_per_cent</code> initialization.</p>

<p>Third, change <code>C</code> to <code>-</code> in <code>relative_error_per_cent</code> initialization.</p>

<pre><code>double n=3.14159 * pow(10.0,k);
double relative_error_per_cent = 100*((my_sqrt_1(n) - sqrt(n)) / sqrt(n));
</code></pre>

<p><a href=""http://ideone.com/AFuwUx"" rel=""nofollow"">Code on ideone.com</a>.</p>
",0
18862226,18862108,3,"<pre><code>                                                    +----its a minus*
                                                    |
double n = pow (10.0,k)*3.14159;         &lt;----------|-------------------------+
double relative_error_per_cent = 100*((my_sqrt_1(n) - sqrt(n)) / sqrt(n));    |
//double n = pow (10.0,k)*3.14159;                                    ---|----+
cout &lt;&lt; n &lt;&lt; sqrt(n) &lt;&lt;  my_sqrt_1(n) &lt;&lt; relative_error_per_cent;        |
                                                                     semi-colon 
</code></pre>

<p>Use following to compile:</p>

<p><code>g++ -o file file.cpp  -std=c++0x</code></p>

<p>OR</p>

<p><code>g++ -o file file.cpp  -std=c++11</code></p>

<p>*minus not stray character <code>\226</code>, this happens when you copy-paste codes from web pages, doc or pdf files.</p>
",1
18867241,18864442,1,"<p>This is untested because I don't have the declarations of Hand, Deck, and presumably Card, but it should give you an idea of a way to test for different hands.</p>

<p>As noted above, there were several issues in your code like not using <code>==</code> to test equality and using commas instead of logical operators (<code>&amp;&amp;</code>, <code>||</code>) in your if checks.</p>

<p>In general it is better to just have a single Score function that returns a different value for each type of hand (high_card, one_pair, two_pair, three_of_a_kind, flush, etc.) rather than having to test each hand multiple times.  It lets you compare hands easily by their score and greatly reduces the amount of duplicate work you need to do like counting the ranks and suits.  Sorting the hand is also a good idea since it simplifies testing for straights as you can just test for the spread between the ranks of first and last cards once you've eliminated the rest of the scoring hands.</p>

<pre><code>bool Hand::isFlush()
{
    for(int i = 1; i &lt; 5; ++i)
    {
        if(cardVector[i].suit != cardVector[0].suit)
        {
            return false;
        }
    }
    return true;
}

bool Hand::isThreeOfKind() 
{
    //This is 16 because I don't know if your ranks start at 0 or 2
    int counts[16] = {0};
    for(int i = 0; i &lt; 5; ++i)
    {
        ++counts[cardVector[i].rank];
    }
    //This is just to give you an idea of how having single score function
    //can eliminate work.  If you only want to test for 3 of a kind then
    //you don't need the pairs and fours tests and counts
    int num_pairs = 0;
    int num_threes = 0;
    int num_fours = 0;
    for(int i = 0; i &lt; 16; ++i)
    {
        if(counts[i] == 2)
        {
            ++num_pairs;
        }
        else if(counts[i] == 3)
        {
            ++num_threes;
        }
        else if(counts[i] == 4)
        {
            ++num_fours;
        }
    }
    if(num_threes == 1)
    {
        return true;
    }
    return false;
}
</code></pre>
",1
18944468,18944451,15,"<p>Derived class can not access the private members of it's base class. No type of inheritance allows access to private members.</p>

<p>However if you use <code>friend</code> declaration you can do that.</p>
",2
18945057,18944451,12,"<p>There is no other way to access other class's private data then friendship. What you can do with inheritance, however, is to access protected data of the base class. But it doesn't mean you can access protected data of another object of the base type. You can only access protected data of the <em>base part</em> of the derived class:  </p>

<pre><code>class base{
protected:  //protected instead of private
     base *ptr1;
     int data;
public:
     base(){}
     base(int d) { data=d; }
};

class derived:private base{
public:
     void member();
};

void derived::member()
{
    base *temp=new base(3); 
    //temp-&gt;ptr1 = 0; //you need friendship to access ptr1 in temp

    this-&gt;ptr1 = 0; // but you can access base::ptr1 while it is protected
}

int main(){}
</code></pre>
",0
18898772,18898588,2,"<p>This happens because int numbers in C++ have limits - see <a href=""http://www.cplusplus.com/reference/climits/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/climits/</a>. In most cases, standard types should satisfy your needs.</p>

<p>If no standard type is big enough, see <a href=""https://stackoverflow.com/questions/4486882/whats-the-best-for-speed-arbitrary-precision-library-for-c"">What&#39;s the best (for speed) arbitrary-precision library for C++?</a></p>

<p>Here is a simpler version of your code, what do you think?</p>

<pre><code>unsigned long int solution( int currentPosition, int positionToGetTo , int stepsJumpedEachTime) {

    if (currentPosition &gt;= positionToGetTo)
        return 0; 

    return 1 + solution(currentPosition + stepsJumpedEachTime, positionToGetTo, stepsJumpedEachTime);

}

int main(){

    int x = 10;
    int y = 85;
    int d = 30;

    unsigned long int stepsTaken = solution(x, y, d);

    cout &lt;&lt; ""Total Steps Taken: "" &lt;&lt; stepsTaken &lt;&lt; endl;
}
</code></pre>
",4
18939047,18938984,2,"<p>Two errors. </p>

<p>Firstly Security.h should have </p>

<pre><code>#include &lt;string&gt;
</code></pre>

<p>Secondly</p>

<pre><code>void EncFileUsingCrypto(string file);
</code></pre>

<p>should be</p>

<pre><code>void EncFileUsingCrypto(std::string file);
</code></pre>

<p>and</p>

<pre><code>void DecFileUsingCrypto(string file);
</code></pre>

<p>should be</p>

<pre><code>void DecFileUsingCrypto(std::string file);
</code></pre>
",7
18906655,18906642,5,"<p>The semicolon immediately after terminates the <code>while</code> block.</p>
",0
18906750,18906642,2,"<p>The while loop will apply to the next statement or statement block following the expression <code>while(number &lt;= 10)</code></p>

<p>In this case you have a semi-colon <code>;</code> following it, this is known as the empty statement and is a valid statement. It is the only statement that will execute in this while loop.</p>

<p>The block defined in curly braces after the empty statement is independent of the while loop. You can place blocks of code in curly braces without having to attach them to a function definition or a loop, for instance.</p>
",0
18906584,18906557,3,"<p>This is because your copy constructor is private and you did not implement it. you make it public and implement it. You also forget the <code>const</code>.</p>

<pre><code>class MyClass
{ 
private:
    int i;
public:
    MyClass():i(0){}
    MyClass(MyClass const &amp; o){ i = o.i; }
};

int main(){
    MyClass obj = MyClass();
    return 0;
}
</code></pre>
",5
18906700,18906557,0,"<p>A private unimplemented copy constructor is used when by a programmer wants to let you know future programmers that they do no intend this object to be copied. Although this is more common to also include a copy constructor in the private section also not implemented like this</p>

<pre><code>private:
    obj(const obj&amp; o);
    obj&amp; operator=(const obj&amp; o);
public:
    obj(...) 
    {
        ...
    }
</code></pre>

<p>If you are getting errors because you are using a library class that has a private copy constructor, and you are trying to copy the object, causing a compiler error</p>

<pre><code>error C2248: 'obj::obj' : cannot access private member declared in class 'obj'
error C2248: 'obj::operator =' : cannot access private member declared in class 'obj'
</code></pre>

<p>then you are not using the class as intended.</p>

<p>If you are making an object yourself and you do want it to be copied, then you need to implement a public constructor, copy constructor and an assignment operator, and then provide the code to implement all three functions.</p>
",0
18945259,18945224,1,"<p>The problem is that empty lines are lines as well. For the first person <code>name</code> and <code>age</code> are read correctly, but in the next iteration of the loop, <code>name</code> will be empty because <code>getline(search_sample, name)</code> reads the empty line.</p>
",5
18945324,18945224,1,"<pre><code>getline(search_sample, name);
getline(search_sample, age);
getline(search_sample, blank_line);
</code></pre>

<p>seems like an improvement.</p>
",2
20400206,20400128,-5,"<p>you can use write function or ostream .
Use c++ function is ostream.</p>
",0
20400269,20400128,6,"<p>One option, using standard C++ library:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;assert.h&gt;

void main()
{
    unsigned short array[2]={ox20ac,0x20bc};

    std::ofstream file;
    file.open(""C:/1.dat"", std::ios_base::binary);
    assert(file.is_open());

    for(int i = 0; i &lt; sizeof(array) / sizeof(array[0]); ++i)
       file.write((char*)(array + i * sizeof(array[0])), sizeof(array[0]));
    file.close();
}
</code></pre>

<p>Alternatively, you can easily write your whole data in one go (without a loop):</p>

<p><code>file.write((const char*)array, sizeof(array));</code></p>
",9
20401556,20400128,8,"<p>You can try something like this:</p>

<pre><code>#include &lt;fstream&gt;
...

ofstream fout;
fout.open(""file.bin"", ios::binary | ios::out);

int a[4] = {100023, 23, 42, 13};
fout.write((char*) &amp;a, sizeof(a));

fout.close();
</code></pre>
",2
20401466,20400128,0,"<p>To open an output file, use ofstream (output file stream, a subclass of ostream). Use the ios_base::binary mode (as second argument in the constructor or the open() member function) if you're not sure whether your output is human-readable text (ASCII).</p>

<p>To write a single byte, use the ostream member function ""put"". To write more than one byte at a time, use the ostream member function ""write"".</p>

<p>There are ways of taking data types (int, for example) longer than one byte and using them as arrays of bytes. This is sometimes called type-punning and is described in other answers, but beware of endianness and different sizes of data types (int can be 2-8 bytes), which can be different on different machines and compilers.</p>

<p>To test your output, reopen it as an input file and print the bytes.</p>

<pre><code>ifstream in(""myfile.txt"", ios_base::binary);
while(!in.eof()) printf(""%02X "", in.get()); //print next byte as a zero-padded width-2 capitalized hexadecimal).
in.close();
</code></pre>

<p>Or just use a hex editor like normal people.</p>
",0
19439327,19439013,0,"<p>I am assuming dictionarylist is vector you cannot print a vector like that in C++. 
You can print it this way</p>

<pre><code>for(int i = 0; i &lt; dictionarylist.size(); ++i) {
    cout &lt;&lt; dictionarylist[i] &lt;&lt; endl;
}
</code></pre>
",0
19439026,19439013,3,"<p><code>&amp;dictionarylist</code> takes the address of your list and prints <em>that</em>.</p>

<p>Instead, do something like</p>

<pre><code>std::copy(dictionarylist.begin(), dictionarylist.end(), 
      std::ostream_iterator&lt;std::string&gt;(std::cout, ""\n""));
</code></pre>

<p>Or a loop</p>

<pre><code>for (std::string const&amp; s: dictionarylist)
    std::cout &lt;&lt; s &lt;&lt; ""\n"";
</code></pre>

<p>PS: No need to resize your list (assuming <strike><code>std::list</code>, <code>std::deque</code>,</strike> <code>std::vector</code> etc. was used). Standard library containers do memory management themselves, and <code>push_back</code> will grow the allocated memory as required.</p>

<p>A slightly cleaned-up take:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

struct Words {
    void readdictionary();
    void printdictionary();
  private:
    std::vector&lt;std::string&gt; dictionarylist;
};

void Words::readdictionary(){
    using namespace std;

    ifstream file(""fruitdictionary.txt"");
    dictionarylist.insert(
            dictionarylist.end(),
            istream_iterator&lt;string&gt;(file), {}
        );
}

void Words::printdictionary(){
    using namespace std;

    copy(begin(dictionarylist), end(dictionarylist), 
            ostream_iterator&lt;string&gt;(cout, ""\n""));
}

int main()
{
    Words words;
    words.readdictionary();
    words.printdictionary();
}
</code></pre>
",1
19019510,19018952,1,"<p>Don't use <code>pow()</code> when doing integer arithmetic. <code>pow</code> returns values as <code>double</code> which is inexact, and may result in the value being off by one when converting it to an <code>int</code>. </p>

<p>Theoretically doubles may be exact when working with numbers being powers of two. But that assumes that you know what you are doing, which at the moment, you don't :-)</p>

<p>Better use bit-shifting when possible:</p>

<p><code>pow(2,n)</code> -->  <code>1 &lt;&lt; n</code></p>

<p>How to implement <code>pow(16, n)</code> using bitshifting is left as excercise for the reader.</p>

<p>Hint:  ((i^n)^m) = i ^ (n*m)</p>
",0
18939163,18939132,2,"<p>Just add an infinite loop outside all your code in the <code>main</code> function, and at the end ask the user if he/she wants to continue. If not then <code>break</code> out of the loop.</p>
",0
18939164,18939132,1,"<p>You could do both in one go if you like.</p>

<p>First rename your main function, call it something like do_calculation.</p>

<p>Now write a new main function. This one will contain a loop to ask if the users wants to try again, and it will call the do_calculation function you've just created. Something like this</p>

<pre><code>int main()
{
    char try_again;
    do
    {
        do_calculation();
        cout &lt;&lt; ""Do you want to try again (answer Y or N) "";
        cin &gt;&gt; try_again;
    }
    while (try_again == 'y' || try_again == 'Y');
}
</code></pre>
",2
18797503,18797495,2,"<p><code>v</code> is a pointer, should call <code>operator-&gt;</code> and should be <code>*this</code></p>

<pre><code>void File::accept(Visitor* v) {
    v-&gt;visitFile(*this);
//   ^^          ^
}
</code></pre>
",2
20413179,20413131,1,"<p><code>all_2.array2[i]</code> is <code>NULL[i]</code> because you didn't initialize the array for negative numbers. </p>

<p>You forgot to initialize <code>all_2.number2</code> to 0 in the constructor for negative inputs.</p>
",2
20413259,20413131,0,"<p>The problem is that yyou do not initialize data member number2 if the first argument of the constructor is negative. So number2 can hold any arbitrary value. This is the reason of the abend.</p>
",0
20509439,20509416,3,"<p>There's obviously a lot to fix there.</p>

<p>The first problem, </p>

<blockquote>
  <p>Player.h:14: error: cootie does not name a type</p>
</blockquote>

<p>indicates that <code>cootie.h</code> should be included from <code>Player.h</code> so the declaration of <code>class cootie</code> is visible when it is used.</p>
",0
20509445,20509416,1,"<p>Judging from the errors, you forgot to import some header files. </p>

<p>It also seems like there is another error later on down the road involving an else statement. I'd say this is probably a syntax error you've made. Your compiler should make it reasonably easy for you to isolate this one. </p>
",0
19206421,19206412,2,"<p>Storage duration and linkage are unrelated concepts.</p>

<p>Functions do not have ""storage duration"", since functions do not reside in storage. Only objects have storage duration. Types do not reside in storage either, which is why types do not have storage duration.</p>

<p>It is not correct to say that classes have no linkage in general. Named classes declared in namespace scope have external linkage. Member functions of classes with external linkage also have external linkage. Classes declared locally and nameless classes have no linkage.</p>
",19
19206497,19206412,0,"<p>Functions don't officially have a storage duration, but in essence they're static (i.e., every function exists for the entire duration of the program). They have internal linkage if you define them <code>static</code> or inside of an anonymous namespace, otherwise external linkage.</p>

<p>Storage class applies to an object, not a type definition like a class, struct or union. It's fairly common to have two objects of the same class, one with static storage duration, and another with auto storage duration.</p>

<p>Likewise, you could create one object with internal linkage and another with external linkage:</p>

<pre><code>T x;
static T y;
</code></pre>

<p>The same goes for linkage of classes:</p>

<pre><code>class X { }; // external linkage

namespace { 
   class Y {}; // internal linkage
};
</code></pre>
",0
19266101,19266018,4,"<p>One major problem is here:</p>

<pre><code>if(input = 100)
</code></pre>

<p>I think you mean</p>

<pre><code>if(input == 100)
</code></pre>

<p>You would have found this <em>very easy</em> if you stepped through your code in a debugger. Remember that a debugger is a programmers best friend, and the first tool to use if things doesn't work as intended.</p>
",4
19266707,19266018,1,"<p>I think this can actually be solved much more simply than your attempt, where frankly I fail to understand what you are trying to do (but that's me).</p>

<p>Anyway, it can just be a sequence of if/else, not even nested.
All you need to do is to check what is the ""largest"" literal contained in the input number, note it and then subtract the value if represents from the input number. Continue in such a way until you get to 0.</p>

<p>e.g. (I'm not sure this is C++ syntax, but you can adjust it of course):</p>

<pre><code>string roman = """"
if(input == 100)
{
    roman += ""C"";
    input -= 100;
}

if(input &gt;= 50)
{
    roman += ""L"";
    input -= 50;
}
</code></pre>

<p>And so on, you can figure the rest out on your own (it's your test after all).</p>

<p>Two things:</p>

<ul>
<li>some literals can be repeated (3: III, 20: XX).</li>
<li>writing e.g. ""XXXX"" for 40 instead of ""XL"" is still a valid roman number (although less common), so if I were evaluating your test I would accept it, but that depends on the assignment. (<a href=""http://en.wikipedia.org/wiki/Roman_numerals"" rel=""nofollow"">http://en.wikipedia.org/wiki/Roman_numerals</a>)</li>
</ul>
",1
19269226,19266018,11,"<p>From <a href=""http://rosettacode.org/wiki/Roman_numerals/Encode#C.2B.2B"" rel=""noreferrer"">http://rosettacode.org/wiki/Roman_numerals/Encode#C.2B.2B</a></p>

<pre><code>std::string to_roman(unsigned int value)
{
    struct romandata_t { unsigned int value; char const* numeral; };
    const struct romandata_t romandata[] =
    {
        {1000, ""M""}, {900, ""CM""},
        {500, ""D""}, {400, ""CD""},
        {100, ""C""}, { 90, ""XC""},
        { 50, ""L""}, { 40, ""XL""},
        { 10, ""X""}, { 9, ""IX""},
        { 5, ""V""}, { 4, ""IV""},
        { 1, ""I""},
        { 0, NULL} // end marker
    };

    std::string result;
    for (const romandata_t* current = romandata; current-&gt;value &gt; 0; ++current)
    {
        while (value &gt;= current-&gt;value)
        {
            result += current-&gt;numeral;
            value -= current-&gt;value;
        }
    }
    return result;
}
</code></pre>
",0
19270530,19266018,0,"<p>Joachim found the first problem, this code is always executed and overwrite input with 100.</p>

<pre><code>    if(input = 100)
    {
        romnum + 'C';

    }
</code></pre>

<p>Now, why don't you see anything? That's because you miss <em>another</em> <code>=</code>. All other code correctly uses <code>+=</code> but this uses <code>+</code>. As a result, this doesn't assign the resulting string back to <code>romnum</code>. </p>

<p>BTW, since <code>romnum</code> is still empty, you can use <code>romnum = 'C'</code> or <code>romnum += 'C'</code> interchangeably. </p>
",0
20509182,20509133,2,"<ul>
<li><code>sizeof</code> knows nothing about the data you read, it just tells you the size of buffer in bytes, which is <code>30000*sizeof(int)</code>, which in your case (32 bit <code>int</code>) it's 120000 bytes;</li>
<li>since <code>sizeof</code> tells the size in bytes of the array (and not in number of elements), the condition of your <code>for</code> is wrong, it should be <code>i&lt;totElems</code>, where <code>totElems</code> contain the total number of elements;</li>
<li>buffer should be of type <code>unsigned int</code> or, better, of type <code>uint32_t</code> (<code>unsigned int</code> is not guaranteed to be 4 byte);</li>
<li>if you want to store a floating-point value in <code>volts</code>, you have to make that array of type <code>float</code> or <code>double</code>; but actually, you don't need the <code>volts</code> array at all - you can just write the output of the calculation to <code>outFile</code>, without storing it anywhere;</li>
<li><code>endl</code> will uselessly slow down your program by performing unnecessary buffer flushes; just do <code>&lt;&lt;'\n'</code>;</li>
<li><code>free(buffer)</code> is completely wrong; <code>free</code> is used only for memory that has been dynamically allocated using <code>malloc</code> &amp; friends, a local array like <code>buffer</code> or <code>volts</code> is freed automatically at the end of the function;</li>
<li>you are intermixing C (<code>fopen</code> &amp; co.) and C++ (<code>fstream</code> &amp; co.) stuff (also, you are including several POSIX headers that aren't actually used); avoid this, either write in C or C++.</li>
</ul>

<p>All this if you know in advance that the number of elements is 30000; if this is not the case, you have different ways to approach the problem:</p>

<ul>
<li>determine the number of elements (go at the end of the file with <code>fseek</code>, get the position with <code>ftell</code>, divide by element size, get back to the beginning of the file), allocate enough memory for them all, read them all as you did and proceed as you already did; typically a bad idea, you waste a lot of memory for nothing;</li>
<li>on the other side, the easiest way is actually to get rid of the array; read a <em>single</em> value from the input file, calculate the converted value, write it to the output file; go on with the next; terminate the loop when there's no more data (<code>feof(pFile)</code> returns a nonzero value);</li>
<li>you may obtain some performance improvements by reading data in big chunks, but, unless you are chumping very big files, if your knowledge of C and C++ is limited I would avoid it.</li>
</ul>

<p>So, my tip is: stick with the second method.</p>

<p>Summing it all up, you could end up with something like this:</p>

<pre><code>#include &lt;fstream&gt;
#include &lt;stdint.h&gt;

int main()
{
    std::ifstream is(""inputfile.dat"", std::ios::binary);
    std::ofstream os(""output.csv"");
    uint32_t i;
    while(is.read((char *)&amp;i, sizeof(i))) 
        os&lt;&lt;1.6*(i-0x7fffff)/0x7fffff&lt;&lt;"";\n"";
    return 0;
}
</code></pre>

<p>Remarks:</p>

<ul>
<li>if your compiler doesn't supply <code>uint32_t</code> you should remove the <code>&lt;stdint.h&gt;</code> row and use <code>unsigned int</code> instead of <code>uint32_t</code>, maybe adding an <code>assert(sizeof(unsigned int)==4)</code>;</li>
<li>if you have to process more than one file, you should probably make the input and output file command line parameters; use <code>argv</code> for that.</li>
</ul>
",5
20522630,20522503,3,"<p>This is a problem with the logic of your code: once you do this</p>

<pre><code>A[I] = A[N-I-1];
</code></pre>

<p>in the first iteration, the <code>1</code> is gone for good. Your array now looks like this:</p>

<pre><code>5 2 3 4 5
</code></pre>

<p>and there is no way to put the <code>1</code> back where it was. The array should have looked like this</p>

<pre><code>5 2 3 4 1
</code></pre>

<p>which means that you needed to swap the two elements.</p>

<p>A proper way to do what you are trying to do is to loop up to the middle of the array, and use the swap instead of the assignment (either through a function <code>std::swap</code> or by writing a swap yourself).</p>

<p>The fix that keeps most of your code is as follows</p>

<pre><code>for (int I = 0; I &lt; 2 /*stop at the middle*/; I++) {
    std::swap(A[I], A[N-I-1]);
}
</code></pre>

<p>The fix that uses the standard C++ library to its full potential is</p>

<pre><code>std::reverse(std::begin(A), std::end(A));
</code></pre>
",0
20522556,20522503,10,"<blockquote>
  <p>How is this 54345 and not 54321? I thought if N is 5 - I which is 3 its 2 minus 1 should be one I dont get how it can increase at all?</p>
</blockquote>

<p>As that first loop progresses, you're not operating on its original values but on the values that you've already processed in earlier iterations of the loop:</p>

<pre><code>for (int I = 0; I &lt; 5; I++) {
   A[I] = A[N-I-1];
}
</code></pre>

<ul>
<li>Iteration 1: set <code>A[0]</code> to <code>A[4]</code> = <code>5</code></li>
<li>Iteration 2: set <code>A[1]</code> to <code>A[3]</code> = <code>4</code></li>
<li>Iteration 3: set <code>A[2]</code> to <code>A[2]</code> = <code>3</code></li>
<li>Iteration 4: set <code>A[3]</code> to <code>A[1]</code> = <code>4</code>
(used to be <code>2</code>, but you changed it in iteration 2!)</li>
<li>Iteration 5: set <code>A[4]</code> to <code>A[0]</code> = <code>5</code>
(used to be <code>1</code>, but you changed it in iteration 1!)</li>
</ul>

<hr>

<p>You'd need two arrays &mdash; a <em>source</em> and a <em>destination</em> &mdash; to do this properly, or, to be more efficient, <code>swap</code> these elements (instead of overwriting them) over a loop that iterates to the midpoint of your input array:</p>

<pre><code>for (int i = 0; i &lt; N/2; i++) {
   std::swap(A[i], A[N-i-1]);
}
</code></pre>

<h2><a href=""http://ideone.com/xPzOEw"" rel=""nofollow noreferrer"">Live demo</a></h2>

<hr>

<p>Of course, you can avoid <em>all</em> of this by simply asking the C++ standard library to do the work for you:</p>

<pre><code>std::reverse(std::begin(A), std::end(A));
</code></pre>

<p><sup>(thanks to @dasblinkenlight for <a href=""https://stackoverflow.com/a/20522630/560648"">this last suggestion</a>)</sup></p>
",2
19380127,19380033,6,"<p>Your function says it will return a <code>istream</code> reference:</p>

<pre><code>istream&amp; operator&gt;&gt; (istream &amp;in, vector &lt;Customer&gt;&amp; cvect)
</code></pre>

<p>Your compiler believes you.
You then say</p>

<pre><code>return cvect;
</code></pre>

<p>This is not an istream, it's a vector.
Try returning the istream as you promised you would:</p>

<pre><code>return in;
</code></pre>
",0
19264364,19264313,1,"<p>if g is > 10, then </p>

<p><code>(g &gt; 0 &amp;&amp; g&lt;=10)</code> is false.</p>
",0
19264375,19264313,3,"<p>Did you do any debugging?</p>

<p>What value of g do you think will make this condition true ?</p>

<pre><code>(g &gt; 0 &amp;&amp; g &lt;= 10) 
</code></pre>

<p>This should be enough for you to figure out the problem.</p>
",0
19264383,19264313,0,"<p>This code will reproduce the number of digits.</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;
int main()
{
    int g, count=0;
    cout &lt;&lt; ""Enter the number"" &lt;&lt; endl;
    cin &gt;&gt; g;
    while (g &gt; 0)
    {
        count = count +1;
        g /= 10;
    }
    cout &lt;&lt; count &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>Beside this, there's another way to solve this problem</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;
int main()
{
    int g, count=0;
    cout &lt;&lt; ""Enter the number"" &lt;&lt; endl;
    cin &gt;&gt; g;
    count = (int)(log10((double)g));
    if (g == 0)
        count = 0;
    cout &lt;&lt; count + 1 &lt;&lt; endl;
    return 0;
}
</code></pre>
",4
19264415,19264313,0,"<p>If you really want to use a loop for this (a log10-call can do the job), use something like this (not tested):</p>

<pre><code>for (count=0;g&gt;0;g/=10,count++) {}
</code></pre>

<p>Which is almost the same you wrote, but without the <code>g&lt;10</code>-condition.</p>
",0
19264581,19264313,0,"<p>It's a bit cumbersome to first convert a string to an int and then try to find its length. Why don't you just look at the string?</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
  std::cout &lt;&lt; ""Enter the number"" &lt;&lt; std::endl;

  std::string g;
  std::cin &gt;&gt; g;

  std::cout &lt;&lt; g.size() &lt;&lt; ""\n"";
}
</code></pre>

<p>Note: This will not trim leading zeroes; I leave this to you.</p>
",0
19372401,19372174,2,"<p>Suggestion 1: You can use an <code>ostringstream</code> to build up your string.</p>

<pre><code>string bitsetfn(unsigned x, int nbits){
  ostringstream oss;
  for(int j=0; j&lt;nbits; j++) {    
    oss &lt;&lt; isSet(x,j);
  }
  return oss.str();
}
</code></pre>

<p>Suggestion 2: You can convert the integer value of the binary digit into its equivalent character encoding. The decimal digits in the character encoding are required to be sequential and contiguous starting from <code>'0'</code>, so:</p>

<pre><code>  s+=isSet(x,j) + '0';
</code></pre>

<p>will append either a <code>'0'</code> or a <code>'1'</code>.</p>

<p>Suggestion 3: Use a <code>bitset</code>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;bitset&gt;
using namespace std;

int main() {
  for (int counter = 0; counter &lt;=130; counter++){
    cout &lt;&lt; counter &lt;&lt; "" is: "" &lt;&lt; bitset&lt;16&gt;(counter)&lt;&lt;endl;
  }
  return 0;
}
</code></pre>
",0
19385790,19385761,3,"<p>Read the first two digits and form an integer:</p>

<pre><code>int digit1 = std::cin.get() - '0';
int digit2 = std::cin.get() - '0';
int input = digit1 * 10 + digit2;
</code></pre>

<p>Then discard the rest of the input:</p>

<pre><code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
</code></pre>

<p>To handle a negative sign, you could do something like this:</p>

<pre><code>int input = 1;

int digit1 = std::cin.get();
if (digit1 == '-') {
    input = -1;
    digit1 = std::cin.get();
}

digit1 -= '0';
int digit2 = std::cin.get() - '0';
input *= (digit1 * 10) + digit2;
</code></pre>

<p>As commented below, this does not work if the user enters anything except two numbers as the first two characters. This is easy enough to check by reading and using <code>std::isdigit</code> to test. It's up to you to keep going or throw an error of some sort.</p>

<p>This also doesn't work if the user enters one digit only. If you need that to work as well, you can either read a whole string and use its size or check for EOF.</p>

<p>There is also no error checking on the input operations themselves, but there should be in real code. </p>
",4
19386082,19385761,0,"<p>Read a string and extract the first 2 chars:</p>

<pre><code>std::string input;
cout &lt;&lt; ""Please enter how many burgers you'd like"" &lt;&lt; endl;
cin &gt;&gt; input;
int first2;
if (input.size()&gt;=1)
{
    if (input[0] == '-')
       std::cerr &lt;&lt; ""Negative num of burgers"";
    else
       first2 = atoi(input.substr(0,2).c_str());
}
else
    std::cout &lt;&lt; ""Null number"";
</code></pre>
",0
19386108,19385761,0,"<p>I think this method will be easy to understand.</p>

<pre><code>int input;
cout &lt;&lt; ""Please enter how many burgers you'd like"" &lt;&lt; endl;
cin &gt;&gt; input;

char cTemp[50];

itoa(input, cTemp, 10);

char cResult[3] = {cTemp[0], cTemp[1], '\0'};

int output = atoi(cResult);
</code></pre>
",4
19385936,19385761,0,"<p>Take <code>input</code> as string and convert the 1st two character as <code>int</code></p>

<pre><code>#include &lt;sstream&gt;
#include &lt;string&gt;
#include&lt;iostream&gt;

int main()
{
   std::string input ;

   std::cin&gt;&gt;input;
   std::stringstream iss(input.substr(0,2));
   int num;

   iss &gt;&gt; num;

   std::cout&lt;&lt;num;

}
</code></pre>
",0
19385978,19385761,5,"<p>I think <code>std::string</code> operations can get you home.</p>

<pre><code>std::string inputstr;
cout &lt;&lt; ""Please enter how many burgers you'd like"" &lt;&lt; endl;
cin &gt;&gt; inputstr;
inputstr = inputstr.substr(0, 2);

int input    
input = std::stoi(inputstr);      // C++11
input = atoi(inputstr.cstr());    // pre-C++11
</code></pre>

<p>Documentation:<br>
<a href=""http://en.cppreference.com/w/cpp/string/basic_string/stol"" rel=""noreferrer"">http://en.cppreference.com/w/cpp/string/basic_string/stol</a><br>
<a href=""http://en.cppreference.com/w/cpp/string/byte/atoi"" rel=""noreferrer"">http://en.cppreference.com/w/cpp/string/byte/atoi</a></p>
",1
19386009,19385761,0,"<pre><code>int i;
cin &gt;&gt; i;
while (i &gt;= 100 || i &lt;= -100) {
   i = i / 10;  // remove and ignore the last digit
}
</code></pre>

<p>This won't work for really large numbers, due to overflow in the integer.  I'm just including this as a very simple algorithm.</p>
",0
19386021,19385761,-3,"<p>Let me answer the question by rewriting it for you:</p>

<blockquote>
  <p>How do I read a string from the standard input and write the first 2 characters to the standard output?</p>
</blockquote>
",4
18680369,18680338,0,"<p><strong>malloc</strong> allocates uninitialized memory. Malloc is not <code>type safe</code></p>

<p><strong>new</strong> initializes the allocated memory by calling the constructor. Also new keyword is <code>type safe</code></p>

<p><strong>delete</strong> is used to deallocate memory from the heap.</p>

<p><strong>NOTE:-</strong> <code>new</code> and <code>delete</code> are C++ specific features. </p>

<p>Besides many other point which you may want to see. Here is one point which is <a href=""http://yosefk.com/c++fqa/heap.html#fqa-16.4"" rel=""nofollow"">worth reading</a></p>

<blockquote>
  <p>[16.4] Why should I use new instead of trustworthy old malloc()?</p>
  
  <p>FAQ: new/delete call the constructor/destructor; new is type safe,
  malloc is not; new can be overridden by a class.</p>
  
  <p>FQA: The virtues of new mentioned by the FAQ are not virtues, because
  constructors, destructors, and operator overloading are garbage (see
  what happens when you have no garbage collection?), and the type
  safety issue is really tiny here (normally you have to cast the void*
  returned by malloc to the right pointer type to assign it to a typed
  pointer variable, which may be annoying, but far from ""unsafe"").</p>
  
  <p>Oh, and using trustworthy old malloc makes it possible to use the
  equally trustworthy &amp; old realloc. Too bad we don't have a shiny new
  operator renew or something.</p>
  
  <p>Still, new is not bad enough to justify a deviation from the common
  style used throughout a language, even when the language is C++. In
  particular, classes with non-trivial constructors will misbehave in
  fatal ways if you simply malloc the objects. So why not use new
  throughout the code? People rarely overload operator new, so it
  probably won't get in your way too much. And if they do overload new,
  you can always ask them to stop.</p>
</blockquote>
",2
19571065,19570187,3,"<p>Here's a hint to get you started on the right track: don't even <em>consider</em> using <code>std::next_permutation</code> unless this is something you'll only ever use once or twice (and probably not even then, because it's actually more complicated than doing the job right).</p>

<p>Using <code>std::next_permutation</code>, your function will be approximately N! times slower than necessary<sup>1</sup> -- in the case of 5 letters, that'll be 120 times slower, and if you ever use longer words, it'll get worse <em>very</em> quickly (e.g., for 10 letters it's over 3.5 million).</p>

<p>Instead, start by pre-processing your dictionary. Instead of a <code>std::set&lt;std::string&gt;</code> of words, create an <code>std::map&lt;std::string, std::vector&lt;string&gt;&gt;</code> (or <code>std::unordered_map</code>, though English has few enough words that this probably won't make a huge difference). As you read in a word from the dictionary, create a sorted version of that string. Use that as the key, and push the original version of the word onto the vector for that key.</p>

<p>Then when you get a word from the user, sort it, look that up in the map, and the associated vector will contain every word (from your dictionary) that can be created from those letters.</p>

<hr>

<p><sub>
1. If you use <code>std::map</code> instead of <code>std::unordered_map</code>, that should be something like <code>N!/(log N)</code>, but <code>N!</code> grows so fast and <code>log N</code> grows so slowly that it the difference is negligible (if you get N large enough that log N = 3, N! will be so large that N!/log N computation steps...well, you start to get into questions of cosmology, like whether the universe will have died of heat death before then (to which the answer seems to be ""yes, probably"").
</sub></p>
",2
19570633,19570187,1,"<p>This solution uses an associative array to map from sorted letters of the word to the words having such sorted letters. It's thus possible to get an answer with one lookup in the map, which takes asymptotically <code>O(log N)</code> time, where N is a size of your dictionary.</p>

<p>Create a file named <code>dic.txt</code>. In case you're using <code>Visual Studio</code> it should be in the same directory as your <code>*.cpp</code> files. Put several words inside in a ""word in a row"" format. Try the following code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;fstream&gt;
#include &lt;algorithm&gt;
using namespace std;

int main() {
    // Dictionary file is in a ""word in a row"" format
    map&lt; string, vector&lt;string&gt; &gt; dictionary;
    ifstream dictionary_file(""dic.txt"");
    if (!dictionary_file.good()) {
        cout &lt;&lt; ""File doesn't exist"" &lt;&lt; endl;
        return 0;
    }
    string word;
    while (dictionary_file &gt;&gt; word) {
        string key = word;
        sort(key.begin(), key.end());
        dictionary[key].push_back(word);
    }

    // Read the letters
    string letters;
    cin &gt;&gt; letters;
    if (letters.size() &gt; 5) {
        cout &lt;&lt; ""Too much letters"" &lt;&lt; endl;
        return 0;
    }

    // Sort the letters
    sort(letters.begin(), letters.end());

    // Output the answers
    vector&lt;string&gt; &amp; ret = dictionary[letters];
    for (size_t i = 0, ilen = ret.size(); i &lt; ilen; ++i) {
        cout &lt;&lt; ret[i] &lt;&lt; endl;
    }
}
</code></pre>

<p>Mention that such a solution cares for a case your letters are in. In case you don't need it, you can add calls to <code>strtolower</code> function (got that name from PHP) before you add a word to your dictionary and before you sort your letters.</p>

<pre><code>string strtolowers(string const &amp; word) {
    string ret = word;
    transform(ret.begin(), ret.end(), ret.begin(), tolower);
    return ret;
}
</code></pre>

<p>You'll need to add <code>&lt;cctype&gt;</code> header for this function to work.</p>
",10
19570351,19570187,2,"<p>Here's a hint to get you started. There's a function in the standard library called <code>std::next_permutation</code>. Assuming you have a dictionary of words to check against, a possible solution could look like this:</p>

<pre><code>std::sort(array, array + row);
do {
    // Check if array is a word.
} while (std::next_permutation(array, array + row));
</code></pre>

<p>This will cycle through every permutation of letters. It's now up to you to verify that it is a valid word.</p>
",8
19372275,19372170,3,"<p><code>=</code> designates <em>assignment</em> operator in C++. Which means that what you have here</p>

<pre><code>            if(fishGrid[m][n] = FISH)
                fishAmount++;
            else if(fishGrid[m][n] = SHARK)
                sharkAmount++;
</code></pre>

<p>uses <em>assignment</em> operator inside <code>if</code> conditions. By the above you override your entire grid with <code>FISH</code> values.</p>

<p>Equality comparison in C++ is performed by <code>==</code> operator. But you already know that, since you already use <code>==</code> in your <code>num</code> comparisons. Why are you using <code>=</code> in these grid comparisons then?</p>
",1
19210571,19210543,2,"<p>Just write your member functions so that they do not allow the caller to modify the object. As long as the pointer is private, whatever it points to can only be seen by other member functions. If you don't expose a member function which changes the pointed-to object, then it can't be changed by users of your class.</p>

<p>Note that you can declare the member as a ""pointer to const"" (which is not the same as a const pointer).</p>

<p><code>int const* p</code> is a pointer to a const int (the pointer can be changed, but the int it points to cannot), whereas <code>int* const</code> is a const pointer to int (the pointer cannot be changed -- it always points to the same int, but the value of that int can be changed). And of course, a <code>int const* const</code> is a const pointer to a const int. Neither the pointer nor the int can be modified.</p>

<p>However, this won't really help you with enforcing that ""const member functions should not modify the pointed-to object, but non-const member functions can"" (because a pointer to a const int will <em>always</em> point to a const int, even if used from a non-const member function)</p>
",3
19210609,19210543,2,"<p>just declare a pointer to constant:</p>

<pre><code>const int * p;


void fun_2()const{ *p = 1; } // main.cpp:36: error: assignment of read-only  
                                // location *(const int*)((const B*)this)-&gt;B::p
</code></pre>

<p>In this case the integer pointed to by <code>p</code> <strong>cannot be changed at all</strong>, regardless if it is done ifrom  a <code>const</code> or <code>non-const</code> function body. If you want still to be able to change the value of int from <code>non-const</code> member function you must not expose a pointer outside the class, make pointer private and use it accordingly.</p>
",1
19210765,19210543,2,"<p>An easy and general solution is your own smart pointer class with deep-const semantics. Just wrap a plain pointer in <code>deepconst&lt;T&gt;</code>, add <code>const T* operator-&gt;() const</code> and <code>const T&amp; operator*() const</code> to the usual non-const versions, and you sre done.</p>
",0
19210801,19210543,3,"<p>It's relatively straightforward to cause the compiler to protect the pointed-to object, but this is not done automatically because it isn't always the correct thing to do.</p>

<pre><code>template&lt;typename T&gt;
class constinator_ptr
{
    T* p;
public:
    explicit constinator_ptr( T* p_init ) : p (p_init) {}

    T*&amp; ptr() { return p; } // use this to reassign, or also define operator=(T*)

    T* operator-&gt;() { return p; }
    const T* operator-&gt;() const { return p; }
    T&amp; operator*() { return *p; }
    const T&amp; operator*() const { return *p; }
};
</code></pre>

<p>Just use this in place of your raw pointer, like this:</p>

<pre><code>class A
{
public:
    A() : val{0}, p{new int(0)} {}
    //void fun_1()const{ val = 1; }  not allowed
    void fun_2()const{ *p = 1; } // now causes error
    void display()const{ cout&lt;&lt; val &lt;&lt;' '&lt;&lt; *p &lt;&lt;endl; }
private:
    int val;
    constinator_ptr&lt;int&gt; p;
};
</code></pre>
",0
19442718,19442472,0,"<p>How about this?</p>

<pre><code>const char *string_list[] = {
  ""qq"",
  ""qa"",
  ""qz"",
  ...
};

for (int i = 0; i &lt; sizeof(string_list)/sizeof(*string_list); i++) {
    if (word1.find(string_list[i]) != std::string::npos) {
        cout &lt;&lt; word1 &lt;&lt; endl
    }
</code></pre>
",0
19442528,19442472,2,"<p>The limitation with this is I don't think it will catch 'quqa'.</p>

<pre><code> if (word1.find('q') != std::string::npos 
       &amp;&amp; word1.find(""qu"") == std::string::npos)
            cout &lt;&lt; word1 &lt;&lt; endl;
</code></pre>

<p>edit: this will count the number of ""q""'s and make sure the number of ""qu""'s is the same.  I think it's probably more efficient than searching for every literal combination.</p>

<pre><code>size_t stringCount(const std::string&amp; referenceString,
                   const std::string&amp; subString) {

  const size_t step = subString.size();

  size_t count(0);
  size_t pos(0) ;

  while( (pos=referenceString.find(subString, pos)) !=std::string::npos) {
    pos +=step;
    ++count ;
  }

  return count;

}

bool check_qu(const std::string &amp;word1)
{
    int num_q = stringCount(word1, ""q"");
    return (num_q &gt; 0) ? 
         (stringCount(word1, ""qu"") == num_q) : true;
}
</code></pre>
",0
19442589,19442472,0,"<p>I would store all search strings in a container and then loop over it:</p>

<pre><code>#include &lt;vector&gt;
#include &lt;iostream&gt;

int main(int, char**) {
  std::string word1 = ""this is the string to search"";
  std::vector&lt;std::string&gt; patterns;
  patterns.push_back(""qq"");
  patterns.push_back(""qa"");
  // etc.

  std::vector&lt;std::string&gt;::size_type i; // for better readability
  for (i = 0; i &lt; patterns.size(); i++) {
    if (word1.find(patterns[i]) != std::string::npos) {
      std::cout &lt;&lt; word1 &lt;&lt; std::endl;
    }
  }
}
</code></pre>
",1
19442105,19442088,0,"<p>Just do this and the errors will go:</p>

<pre><code>double bisPrice = 0;
double foodPrice = 0;
</code></pre>

<p>I think it should have been obvious to you that you did not provide any value on declaration :)</p>

<p>And yes do not forget these as well:</p>

<pre><code>string name = """";
double numBis = 0;
string bis = """";
string dryFood = """";
double foodNum = 0;
</code></pre>

<p>Variables in functions have automatic storage hence they are not initialized to a value by default.</p>
",0
19442112,19442088,0,"<p>You did not define their initial values.</p>

<pre><code>double bisPrice; 
double foodPrice;
</code></pre>

<p>Change to:</p>

<pre><code>double bisPrice = 0;
double foodPrice = 0;
</code></pre>
",0
19442165,19442088,0,"<p>To fix your compiler warnings, initialize the variables:</p>

<pre><code>double bisPrice = 0; 
double foodPrice = 0;
</code></pre>

<p>In C and C++ fundamental value types do not have an <a href=""http://www.cplusplus.com/doc/tutorial/variables/"" rel=""nofollow"">initial value</a>.</p>

<blockquote>
  <p>When declaring a regular local variable, its value is by default undetermined. But you may want a variable to store a concrete value at the same moment that it is declared. In order to do that, you can initialize the variable.</p>
</blockquote>

<p>Objects will be initialized using their default constructor, which is why you don't have the same error for the <code>string</code> variables.  </p>
",0
20756297,20756085,2,"<p>I think you're getting a number that will be too big, and also it is confusing to call a variable which is not usually prime ""smallest prime"".</p>

<p>Trace through the loop by hand:</p>

<pre><code>i=1; smallestprime = 1
i=2; smallestprime = 1 * 2
i=3; smallestprime = 2 * 3
i=4; smallestprime = 6 * 4
</code></pre>

<p>But in the last step you only needed to multiply by 2 in order to ensure your answer was divisible by 4. (12 is the smallest number divisible 1, 2, 3, 4, not 24).</p>

<p>I think it you try a few examples by hand, such as manually calculating the 2520 number, it will become clearer what to do. Basically as you loop through integers k accumulating the answer N, you need to multiply by some subset of the prime factors of k - just enough to make N divisible by k, but no more.</p>

<p>Probably the most efficient way to do this is to use the relationship between LCM and GCD, and calculate the LCM using the Euclidean algorithm.</p>
",0
20757457,20756085,0,"<p>I would break your code into multiple methods, each solving it's own problem. As it's already mentioned the greatest common divisor is the basis for calculation of least common multiple, so</p>

<pre><code>int greatestCommonDivisor(int a, int b)
{
}
</code></pre>

<p>LCM of two numbers is</p>

<pre><code>int greatestCommonDivisor(int a, int b)
{
}
</code></pre>

<p>And LCM of array of numbers seems to be solved by just calling greatestCommonDivisor(int a, int b) in a loop:</p>

<pre><code>int leastCommonMultiple(int[] nums, int len)
{
    int curr = 1;
    for(int i = len-1; i &gt;= 0; --i) {
        curr = leastCommonMultiple(curr, nums[i]);
    }
    return curr;
}
</code></pre>
",0
20757466,20756085,0,"<p>When you multiply all the numbers from 1 to 20 you will get an overflow for the standard 32-bit int, which maximum value is only 2 147 483 647. So, it's impossible to store such a multiplication result in the int variable and that's the reason for ""strange"" effects you have discovered in the output. </p>

<p>But you don't really need to multiply all the numbers from 1 to 20 to get the answer. Finding out all the prime factors that appear in given range and their multiplicity will be enough to solve the problem.   </p>
",2
20761188,20756085,0,"<p>i think you should try this.<br>
this is just a pseudocode</p>

<pre><code>var n=1
while(1){
    if (n%1==0 &amp;&amp; n%2==0 &amp;&amp; .....n%20==0){
        print n
        break
    }
    n++
}
</code></pre>

<p>it will give your answer as fast as you can think</p>
",0
19442654,19442273,2,"<p>After ""pro"" file change, it is necessary to launch <strong>qmake</strong>. After that it is possible to compile application.</p>
",1
20420943,20420696,0,"<p>Remove this line of code to see if it's fixed,</p>

<pre><code>fin.ignore(10,'\n');
</code></pre>

<p>And, there is one problem with the input you provided. There is a redundant string in this line, </p>

<pre><code>Willy Smith Jr.
</code></pre>

<p>That will cause error in subsequent <code>cin</code> readings.</p>
",1
20421424,20420696,1,"<p>You have a few problems, I'll start with one and work my way down. Here...</p>

<pre><code>for (int i = 0 ; i &lt; 6 ; i++)
    fin &gt;&gt; Temp.Test[6];
</code></pre>

<p>...you are always operating on the seventh element (zero-based) of the array, however that's no good, you know that b/c you've used the fact as the <code>for</code> control. What you need is <code>Temp.Test[i]</code>. That's not all though, because you didn't pass <code>Temp</code> as a reference, so you do all that hard work for nothing, as the changes don't persist. What you need is <code>void Read_Student(Student &amp;Temp , ifstream &amp;fin)</code>.</p>

<p>Unless I'm missing something this...</p>

<pre><code>while(!fin.eof())
{
    i++ ;
    if (i == Max_Size){
        cout &lt;&lt; ""\nArray is full.\n"" ;
        break;
    }
}
Read_Student(List[i],fin);
</code></pre>

<p>...doesn't seem to be doing what you want it to. It basically increments <code>i</code> until it reaches the <code>MAX_SIZE</code>, breaks and then attempts to read an element that is outside of your bounds. I'm sure you intended, based on your sample file, to read the rest of the students until the <code>eof</code> is reached, but as you can see you really only read one additional one. You probably meant that to be <em>inside</em> the <code>while</code>.</p>

<p>In terms of reading those students, I agree with another answer which suggests removing your <code>ignore()</code>. There's probably a better way of dealing with it like just reading a line and parse it out, <em>IMHO</em> of course.</p>

<p>You'd also be well served to make a <code>Course</code> class. The way you've designed your <code>struct</code>, each student has all the course info but you only extract it once as it is only in the file once.</p>

<p>I know you asked about printing problems, I just can't see anyway to deal with that until these issues are addressed.</p>
",2
19262036,19262023,4,"<p>Change</p>

<pre><code>if ( day == 1 || 6 || 7)
</code></pre>

<p>to</p>

<pre><code>if ( day == 1 || day == 6 || day == 7)
</code></pre>

<p>And the same for some similar <code>if</code> conditions.</p>

<hr>

<p>Your original test condition <code>if (day == 1 || 6 || 7)</code> is equivalent to <code>if ((day == 1)||6||7)</code>, always evaluates as true, because all non-zero numbers(in this case, <code>6</code> and <code>7</code>) are evaluated as true. </p>
",1
19262045,19262023,0,"<p>C and C++ can interpret any numerical value as a logical value. Zero is false, and anything else is true. Therefore syntax like this:</p>

<pre><code>if ( day == 1 || 6 || 7)
</code></pre>

<p>is interpreted as ""if (day is one) or (6 is not zero) or (seven is not zero) then...""</p>

<p>A correct way to write this is</p>

<pre><code>if ( day == 1 || day == 6 || day == 7)
</code></pre>
",0
19262048,19262023,1,"<p>The logical OR operator <code>||</code> only operates on <em>boolean</em> values, which literal values such as <code>6</code> and <code>7</code> don't qualify as. You need to separate your conditions into <em>valid</em> boolean statements using the relational operators available in C++ <code>&lt;,&gt;,&lt;=,&gt;=,==,!,etc</code>. Try using: </p>

<pre><code>if (day == 1 || day == 6 || day == 7)
</code></pre>

<p><code>6</code> and <code>7</code> are actually <em>truthy</em> values in C++ and will make your condition always true, your current statement is equivalent to:</p>

<pre><code>if(day == 1 || true || true)
</code></pre>

<p>which is <em>always</em> true.</p>
",0
19262080,19262023,0,"<p>With your <code>if ( day == 1 || 6 || 7)</code> it will execute day==1 first which will return either 0 or 1. Then it will go on oring it with non zero(i.e. true) numbers and always gives 1 result i.e. true.</p>

<p>change it to <code>if ( day == 1 || day == 6 || day == 7)</code>
                <code>if (day == 2 || day== 4)</code> and
                 <code>if (day == 2 || day == 5)</code></p>
",0
19503101,19503083,5,"<p>Use <a href=""http://en.cppreference.com/w/cpp/numeric/math/fmod"" rel=""noreferrer""><code>std::fmod</code></a>. It has an overload for doubles:</p>

<pre><code>#include &lt;cmath&gt;

std::fmod(num1, num2);
</code></pre>
",5
19503108,19503083,1,"<p>The modulus operator <code>%</code> is an integral function.</p>

<p>You need to use <code>fmod</code> for floating-point.</p>
",0
19503115,19503083,1,"<p><code>%</code> is only allowed for integral types or unscoped enums, you can use <a href=""http://en.cppreference.com/w/cpp/numeric/math/fmodstd"" rel=""nofollow"">std::fmod</a> for <em>double</em>:</p>

<pre><code>#include &lt;cmath&gt;
#include &lt;iostream&gt;

int main() {
    double num1 = 5.5;
    double num2 = 3.0;
    double z = std::fmod(num1,num2);

    std::cout &lt;&lt; z &lt;&lt; std::endl ;
    return 0;
}
</code></pre>
",0
19503175,19503083,0,"<p>Of course, you could overload the '%' operator to perform the modulus operation on any type you like. There is no build-in support in the language for doubles, however.</p>
",2
19503191,19503083,0,"<p>i think you can rather replace your doubles with 'long int' , that will help you overcome  the error and this will also work with all integer based operations.</p>

<p>i made this change in one of my codes and got it right, with a warning though. But it did work just fine, so try that, it should work pretty well.</p>
",0
20535491,20535464,1,"<p>You need to pass <code>buffer</code> to <code>setRating</code>:</p>

<pre><code>void Book::setRating(const char *buffer){
    isbn = std::strtoul(buffer, NULL, 0);
}
</code></pre>

<p>I'm not quite sure what you're doing with <code>buffer</code> in your <code>app.cpp</code>, but if you want to set the rating based on the contents of a C-style string, the above version of <code>setRating</code> will do that.</p>
",0
19383600,19383487,3,"<p>You don't want <code>cin &gt;&gt; userOption</code> both in the <code>while</code> condition and inside the loop, as that makes two inputs per loop.</p>

<p>The one in the <code>while</code> condition should be enough.</p>
",2
19383662,19383487,0,"<p>Try this to break out of the loop if result is OK:</p>

<pre><code>    while (true) {
       if (!(cin &gt;&gt; userOption) || (userOption_tmp &lt; 1) || (userOption_tmp &gt; 12)) {
        cout &lt;&lt; ""Invalid Input, please try again."" &lt;&lt; endl;
        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
        std::cin.clear();
       }
       else {
             break;
       }

        //this is looping when letter inputed
    }
</code></pre>
",2
19383837,19383487,0,"<p>First of all initialize <code>userOption</code>:</p>

<pre><code>unsigned int userOption = 0;
</code></pre>

<p>Then go like this:</p>

<pre><code>while ( userOption &lt; 1 || userOption &gt; 12 /* or even true, like Atle suggested */) 
{
     cin &gt;&gt; userOption;
     if( !cin || userOption &lt; 1 || userOption &gt; 12 )
     {
         cout &lt;&lt; ""Invalid Input, please try again."" &lt;&lt; endl;
         std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
         std::cin.clear();
         continue;
      }
      else
         break;  //this is looping when letter inputed
 }
</code></pre>
",1
19439038,19438907,0,"<pre><code> class IMatriz {
 protected:
  int **m;
  int numRows;
  int numColumns;
 public:
 IMatriz() {
    numRows = 0;
    numColumns = 0;
    m = NULL;
 }
 IMatriz(int r, int c) {
    numRows = r;
    numColumns = c;
    m = new int* [numRows];
    for(int i=0; i&lt;numRows; i++)
      m[i] = new int [numColumns];
  }

virtual void setSize(int r, int c) = 0;
virtual void setValue(int row, int col, int val) { m[row][col] = val; }
virtual int getValue(int row, int col){ return m[row][col]; }
        int getNumRows(){ return numRows;}
        int getNumColumns(){ return numColumns; }
virtual void mult(IMatriz* a, IMatriz* b) = 0;
virtual void print(void) = 0;
};

class Child: public IMatriz{
 public:
   Child():IMatriz(){}
   Child(int row, int col):IMatriz(row, col){}
 };
</code></pre>

<ol>
<li>Compilation error is because any class with pure virtual function cannot be instantiated directly. it must be through the pointer. so mult() definition is changed now.</li>
<li>In the derived class you should provide definition for the pure virtual functions otherwise although a child class it will still be an abstract class just like IMatriz i.e. cannot hav a regular variable, only pointer to it</li>
</ol>
",9
19569916,19569498,1,"<p>The code should look like this:</p>

<pre><code>void histogram(const int MaxPages, istream&amp; input, ostream&amp; output) {
    if (!input.good()) {
        cerr &lt;&lt; ""File doesn't exist"" &lt;&lt; endl;
        return;
    }

    string line;
    for (int line_no = 0; getline(input, line); ++line_no) {
        output &lt;&lt; '""' &lt;&lt; line &lt;&lt; '""' &lt;&lt; endl;
    }
}
</code></pre>

<p>Mention those quotes put to console. They're to show that in case your file has an empty last line, <code>getline</code> will return an error, and <code>work_with_that_line</code> won't get called. It's a wide known problem with <code>getline</code>-style file input. In case you care, consider using char-by-char or binary input.</p>
",8
19569661,19569498,1,"<p>Not sure what your <code>isAGet</code> and <code>extractTheRequest</code> does but to answer <em>""how do I read the text file line by line, and then store each line into a string""</em></p>

<p>Why not simply this ? </p>

<pre><code>std::vector&lt;std::string&gt; vec;
while ( std::getline(input, linestring) &amp;&amp; (linenum &lt; MaxPages ) )
{
  //...
  //Store into std::vector, if required
  vec.push_back(linestring); 

  //.. use other calls 
  output &lt;&lt; linestring ;
  linenum++;
}
</code></pre>
",9
20421474,20421270,0,"<p>The second thing is valid, but you cannot access the member <strong>i</strong> since it will be private. It is valid only because You have created an object A of that class type. </p>

<p>To have a constructor, <em>I think</em> you have to give the class a name. Use this:</p>

<pre><code>class myclass
{ 
  int i;
  public:
     myclass(int a) //This is the constructor
     {
           i = a;
     }
     ~myclass()  //This is the destructor
     {
           //Whatever you want to do on destroying the object
     }

};
</code></pre>

<p>and instantiate that class as follows:</p>

<pre><code>myclass A(10);
</code></pre>

<p>or similarly.</p>

<p><strong>Note</strong>: This is just <em>my interpretation</em>, it can be done in many other ways.</p>
",4
20421363,20421270,0,"<p>You are doomed using the class locally and accessing it through the local object A, only.</p>

<p>You can use it in a template, though:</p>

<pre><code>template &lt;typename T&gt;
inline void print(const T&amp; a) {
    std::cout &lt;&lt; a.x &lt;&lt; std::endl;
}

int main()
{
    class {
        public: int x;
    } a;
    a.x = 1;
    print(a);
}
</code></pre>
",0
20421383,20421270,5,"<p>If the class is unnamed then it can't have a custom constructor/destructor (although the compiler will generate the usual default ones for you). That means you can't pass an argument to it at construction. However, there's probably nothing stopping you from either (1) adding one or methods to the class to pass data to it after construction, or (2) giving the class a name in the first place.</p>
",0
18899151,18898254,0,"<p><a href=""http://www.oodesign.com/observer-pattern.htm"" rel=""nofollow"">http://www.oodesign.com/observer-pattern.htm</a></p>

<p>Look into the observer pattern. If you have problems applying it to your problem let me know and I'll guide you on the right path.</p>
",1
18899536,18898254,0,"<p>Boost.Signals2 solution:   </p>

<pre><code>#include &lt;boost/signals2/signal.hpp&gt;
#include &lt;boost/bind.hpp&gt;
#include &lt;iostream&gt;

using namespace boost;
using namespace std;

class Manager{
public:
    signals2::signal&lt;void ()&gt;    *Msg;
    void Foo() { cout &lt;&lt; ""Foo"" &lt;&lt; endl;}    
};

class Director{
public:
    Manager CreateManager() { return Manager();}
};

int main()
{
    Director dir;
    Manager m1 = dir.CreateManager();
    Manager m2 = dir.CreateManager();

    m1.Msg = new signals2::signal&lt;void ()&gt;();
    m1.Msg-&gt;connect(bind(&amp;Manager::Foo, &amp;m2));
    (*m1.Msg)();
}
</code></pre>
",2
20199060,20198965,3,"<p>Use wide-character strings for everything. <code>std::wstringstream</code> instead of <code>std::stringstream</code> and  <code>std::wstring</code> instead of <code>std::string</code>.</p>

<p>To see what's going on with your code, try printing out <code>d</code> after <code>std::string d = st.str();</code>.</p>
",0
19378258,19371688,0,"<p>Looking at the line</p>

<pre><code>while(inCisDegree &gt;&gt; studNum &gt;&gt; GPA &gt;&gt; nameL &gt;&gt; nameF &gt;&gt; initM &gt;&gt; GPA &gt;&gt; majorCode);
</code></pre>

<p>because you have a semicolon at the end, this won't be a loop (presuming it's just this way for testing but thought i'd mention it anyway).</p>

<p>However the main problem with this line is that you've specified your text file to be of the format</p>

<pre><code>studNum, nameL, nameF, initM, GPA, majorCode
</code></pre>

<p>where here you are trying to read in</p>

<pre><code>studNum, GPA, nameL, nameF, initM, GPA, majorCode
</code></pre>

<p>apart from reading a value twice, the first read in for GPA is trying to read a <code>string</code> into a <code>float</code>, and this is probably throwing an exception somewhere inside <code>&lt;iostream&gt;</code> (i don't know exactly what the behaviour is but it won't work). this is breaking your read and the rest of the variables won't read in from the file.</p>

<p>this code should do what you're trying to accomplish.</p>

<p>I've changed <code>studNum</code> from a <code>double</code> to a <code>long</code> as you don't seem to have any reason for it to use <code>double</code>, and in all likelyhood you could probably use <code>unsigned int</code> as an 8 digit number won't overflow <code>2^32</code> anyway.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;cstdlib&gt;

using namespace std;

int main() {
    long studNum;
    float GPA;
    string nameL;
    string nameF;
    char initM;
    char majorCode;

    cout.setf(ios::fixed);
    cout.setf(ios::showpoint);
    cout.precision(2);

    ifstream inCisDegree;
    ofstream outAppmajor;
    ofstream outNetmajor;
    ofstream outProgmajor;
    ofstream outWebmajor;

    inCisDegree.open(""cisdegree.txt"");
    if (inCisDegree.fail()) {
        cout &lt;&lt; ""Error opening input file.\n"";
        exit(1);
    }

    outAppmajor.open(""appmajors.txt"");
    outNetmajor.open(""netmajors.txt"");
    outProgmajor.open(""progmajors.txt"");
    outWebmajor.open(""webmajors.txt"");

    while (inCisDegree.good()) {
        string line;
        getline(inCisDegree, line);
        istringstream sLine(line);

        sLine &gt;&gt; studNum &gt;&gt; nameL &gt;&gt; nameF &gt;&gt; initM &gt;&gt; GPA &gt;&gt; majorCode;

        cout &lt;&lt; studNum &lt;&lt; "" "" &lt;&lt; nameL &lt;&lt; "" "" &lt;&lt; nameF &lt;&lt; "" "" &lt;&lt; initM &lt;&lt; "" "" &lt;&lt; GPA &lt;&lt; "" "" &lt;&lt; majorCode &lt;&lt; endl;
        // this line is just so we can see what we've read in to the variables
    }
}
</code></pre>
",0
19564372,19563910,0,"<p>I can see a few problems with your code:</p>

<ul>
<li><p>you attempt to use sizeof on a std::string (as pointed out by the other answers)</p></li>
<li><p>you use memcpy in C++ (consider std::copy with iterators as an alternative); You also attempt to copy the size of the read data into a <code>char[20]</code>. If data in your file contains a string longer than 20 before your first ',' character, you will create a buffer overflow.</p></li>
<li><p>you do not check the result of the read operation, before copying the value.</p></li>
</ul>

<p>Your code should/could be:</p>

<pre><code>while ( getline(file, transferstring, ',') ) // check the state of 
                                             // the stream after getline
{
    cout &lt;&lt; transferString &lt;&lt; endl;
}
</code></pre>

<p>If you want to copy into the name, use one of these:</p>

<pre><code>char *name = nullptr;
while ( getline(file, transferstring, ',') )
{
    name = new char[transferstring.size() + 1];
    std::copy(transferstring.begin(), transferstring.end(), name);
    name[transferstring.size()] = 0;
}
// somewhere later:
delete []name;
</code></pre>

<p>or:</p>

<pre><code>char name[20];
while ( getline(file, transferstring, ',') )
{
    std::size_t size = std::min(transferstring.size(), 19);
    std::copy_n(transferstring.begin(), size, name); // copy at most 19 characters
    name[size] = 0;
}
</code></pre>

<p>My choice though would be to not use char array at all and keep the value in a std::string.</p>
",1
19563949,19563910,2,"<p>The use of <code>sizeof</code> is incorrect. That just tells you the size of the object that holds the string. But you need the length of the string, plus one for the null-terminator. You should instead write:</p>

<pre><code>memcpy(Name, transferString.c_str(), transferString.size()+1);
</code></pre>

<p>whilst noting that your code is a buffer overrun just waiting to happen. You'll want to defend against that in your real code.</p>

<p>I'd also add the usual comment that, since this is C++, you would expect to use <code>std::copy</code> rather than <code>memcpy</code>.</p>
",0
19563951,19563910,1,"<p>I'm assuming <code>transferString</code> is a <code>std::string</code> - in that case, instead of <code>sizeof</code>, use <code>transferString.size()</code>.</p>

<p>You might also need to add another <code>\0</code> character at the end then.</p>

<p>Anyway, what you are doing here is rather dangerous, and I would avoid using C arrays at all if possible.</p>
",1
19564652,19563910,0,"<pre><code>//an alternative way when stl isn't working
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;fstream&gt;

    using namespace std;

    int main()
    {
        char Name[20];

        string transferfile;
        ifstream in(""file.txt"");

        while (!(in.eof()))//read till the end of the file
        {
            in&gt;&gt;transferfile;
                if(!in.eof())
                {
                    for(int i=0;i&lt;transferfile.length();i++)//copy al the letters from the string
                {
                    Name[i] = transferfile[i];
                }
                for(int i=0;i&lt;transferfile.length();i++)//print the array 
                {
                    cout&lt;&lt;Name[i];
                }
            }
        }

    }
</code></pre>
",1
19377916,19377829,0,"<p>This question is asking about (not necessarily in this order):</p>

<ol>
<li>Real-world modeling </li>
<li>Garbage collection</li>
<li>Encapsulation</li>
<li>Interfaces</li>
</ol>
",0
19377933,19377829,1,"<blockquote>
  <p>Could anyone explain me about meaning of that question?</p>
</blockquote>

<p>The question gives four ""properties"" (or traits) of things:</p>

<ul>
<li>a) are removed from memory when not in use.</li>
<li>b) permit data to be hidden from other classes.</li>
<li>c) bring together all aspects of an entity in one place.</li>
<li>d) can closely model objects in the real world.</li>
</ul>

<p>Your task is to identify at least one of those four choices which does not apply to the programming concept called a <code>class</code>.</p>
",0
19377971,19377829,3,"<p>In order: No. Yes. Maybe. Hopefully.</p>
",2
19384791,19384759,1,"<p>Get rid of all of the </p>

<pre><code>}
{
</code></pre>

<p>and you'll be able to proceed to fixing your next error.</p>

<hr>

<p>When you write braces like the following: <code>}</code></p>

<p>you're closing your block of code, which in this case is your main function.  </p>

<p>and when you write the following: <code>{</code></p>

<p>The compiler thinks that you're trying to start a new function, but there's not function signature and you get an error.</p>

<hr>

<p>It looks to me like you intend all of this code to be inside of your main function, so you want something like the following:</p>

<pre><code>int main()
{ 
    //insert all of your code here
    return 0;
}
</code></pre>
",6
19384819,19384759,3,"<p>You can't say stuff like</p>

<pre><code>else(value1 = +)
</code></pre>

<p>in C++. You must mean something else, but it is hard to guess what because there are so many errors in your code. In general, you cannot just type random characters and expect a functioning program.</p>
",0
19385096,19384759,2,"<p>The error stems from the additional <code>{ ... }</code> blocks following the <code>main</code> function, since the compiler does not know what to do with code outside of declarations . But that is not the only problem with your code:</p>

<ul>
<li>Putting a semicolon directly after an <code>if</code> statement means ""if the condition is true do nothing anyway"", and the next statement is executed either way.</li>
<li><code>if(value = +)</code> should be <code>if(value == '+')</code> etc - you mixed the association <code>=</code> with comparison <code>==</code>, plus you try using an operator <code>+</code> instead of a character <code>'+'</code>* what is <code>else(something)</code> supposed to do? Code blocks are put in <code>{}</code>s, not <code>()</code>s</li>
</ul>

<p>May I suggest you start programming in an easier language like Python? Its meaningful indentation and the lack of semicolons makes life a lot easier...</p>
",0
19799126,19799083,2,"<p>You will have to make a compare guard for all three values.</p>

<pre><code>if (a == 200 || b == 200 || c == 200) {
    /* Do something */
}
</code></pre>
",0
19799186,19799083,4,"<p>I think you're trying to write something like</p>

<pre><code>void ratescore(int value)
{
  if (value  == 200)   {
    cout &lt;&lt; ""200 is exactly 200"" &lt;&lt; endl;
  }
 // and so on
}

void ratescore (int a, int b, int c)   {
   ratescore(a);
   ratescore(b);
   ratescore(c);
}
</code></pre>
",0
19802706,19802625,2,"<p>If <code>a</code> is <code>true</code>, then <code>y</code> never exists -- it only comes into existence after execution enters the block in which it's defined, and if that never happens it never exists at all.</p>

<p>Whichever leg of the <code>if</code> statement is executed, the variable(s) defined in that scope are destroyed when execution leaves that scope, so after the end of this code, neither <code>x</code> nor <code>y</code> exists, so neither can be used at all.</p>
",0
19577830,19577756,-1,"<p>what error do you get?</p>

<p>try</p>

<pre><code>RegOpenKeyEx  
</code></pre>

<p>instead of RegOpenKey, since that's for 16 bit windows.</p>
",13
18649838,18649785,1,"<p>Your program has an infinite loop because of the <code>;</code> at the end of this line:</p>

<pre><code>                  if (array[count] &gt; array[count + 1]);
</code></pre>

<p>Take that out.  Note that your program still has other bugs (your swap is broken).</p>

<p>You might think about switching compilers.  Clang warned on your code even without any special flags:</p>

<pre><code>example.cpp:43:59: warning: if statement has empty body [-Wempty-body]
                      if (array[count] &gt; array[count + 1]);
                                                          ^
example.cpp:43:59: note: put the semicolon on a separate line to silence this
      warning
</code></pre>
",4
18649840,18649785,1,"<p>I think your error is this line:</p>

<pre><code>          if (array[count] &gt; array[count + 1]);
</code></pre>

<p>You probably don't want that semicolon at the end.</p>
",0
19573627,19573451,0,"<p>The issue is you try to use <code>mdmg</code> without initializing it as the error tells you.</p>

<p><code>cout &lt;&lt; ""You did "" &lt;&lt; mdmg &lt;&lt; ""damage to the zombie!\n"";</code> </p>

<p>You assign values to <code>mdmg</code> in your various <code>if</code> statements, but since there is not a default value for <code>mdmg</code> (there is the chance you may not enter one of the <code>if</code> blocks that assigns a value to <code>mdmg</code>), you get an error when trying to print it out.</p>

<p>Either intialize it when you declare it (<code>int mdmg = 0;</code>) or have some other means not inside one of the <code>if</code> statements to assign a default value. </p>
",0
19573495,19573451,4,"<p>I'm guessing your issue is here:</p>

<pre><code>if(choice == 3)
{
dmg = ((0.06 * def) / (1 + 0.06 * def)) * 100;
    rhp = rhp - mdmg;
}
</code></pre>

<p>If you call that before any other choices, mdmg won't be initialized before being subtracted from rhp.</p>

<p>EDIT:</p>

<p>Although taking the second statement out is a good idea, you still have the same issue that mdmg is not initialized in the <code>if(choice ==3)</code> block.  Did you mean to write </p>

<pre><code>if(choice == 3)
{
    mdmg = ((0.06 * def) / (1 + 0.06 * def)) * 100;
}
</code></pre>

<p>(dmg is changed to mdmg)</p>
",3
18448353,18448295,7,"<p><code>sizeof</code> gives you the size of the struct, not the sum of the sizes of its members. Due to alignment requirements (<code>int</code>s generally like to be aligned on natural boundaries; 4 bytes on most platforms), the compiler will pad the struct to 12 bytes, so that when you have multiple instances of the struct adjacent to each other (e.g. in an array), they stay correctly aligned.</p>

<p>Most compilers have some custom extension to control padding, e.g. <code>#pragma pack</code> in Microsoft's compiler.</p>
",0
18736056,18735933,4,"<p>It seems you want something like</p>

<pre><code>while (std::getline(...))
{
    // ...

    while (ss &gt;&gt; tmp)
        cmd.push_back(tmp);

    // ...

    summary(...);
}
</code></pre>
",0
18736568,18735933,2,"<p><strong>stringstream.clear()</strong> is used to reset error flags and not clear the stream, although it might be giving you results but it's meaning shouldn't be changed.</p>

<pre><code>#include&lt;cstdlib&gt;

 char ch;
 string line;
 string buf;
 bool check=true;

 cout&lt;&lt;""Enter input\n"";

 while(1)
 {
   if(check == true)
   {
     cin&gt;&gt;line;
   }
   else break;
   istringstream is(line);

   // This will split the line based on whitespace
   while(std::getline(is, buf, ' '))
   {
     cmd.push_back(buf);

     // Checking if vector has 5 elements

     if(cmd.size() == 5)
     {
       // Call function summary
       summary(cmd[0], cmd[1], atoi(cmd[2].c_str()), atoi(cmd[3].c_str()),   
       atoi(cmd[4].c_str()), TeamData);

       // Clear the vector list now
       cmd.clear();

       cout&lt;&lt;""Do you want to continue, enter y then""&lt;&lt;endl;
       cin&gt;&gt;ch;
       if(ch == 'y')
       { 
         cout&lt;&lt;""Enter input""&lt;&lt;endl;
       }
       else
       {
         check=false;
         break;
       }
     }
   }
 }
</code></pre>

<p><strong>atoi</strong> function would convert your string to integer type. </p>
",3
19790626,19790163,2,"<p>@Lightness explained it perfectly. here's another demo (-1 prints the current middle value, -2 exits)</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;float&gt; values;
    float value;

    while(std::cin &gt;&gt; value) {
        if(value == -1 &amp;&amp; values.size() &gt; 0)
            std::cout &lt;&lt; ""mid = "" &lt;&lt; values.at(values.size() / 2) &lt;&lt; std::endl;
        else if (value == -2)
            break;
        else
            values.push_back(value);
    }
}
</code></pre>
",4
19790259,19790163,6,"<p>If you're trying to find the middle value in a container, it's pretty easy:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;float&gt; v{1,2,3,4,5};

    // Output:     (1,2,3,4,5)
    //          3       ^ 
    std::cout &lt;&lt; v.at(v.size()/2) &lt;&lt; std::endl;

    // Now a user provides another value, maybe
    v.push_back(6);

    // Output:     (1,2,3,4,5,6)
    //          4         ^
    std::cout &lt;&lt; v.at(v.size()/2) &lt;&lt; std::endl;
}
</code></pre>

<h3><a href=""http://ideone.com/D04FxO"" rel=""noreferrer"">Demo</a></h3>

<p>Your code has... a lot of problems with pointers.</p>
",6
19961656,19961583,1,"<p>Go to Project Settings -> Configuration Properties -> General and make sure that you set ""Using MFC in a Shared DLL"" for both debug and release versions.</p>

<p>Also if you include windows.h somewhere - remove that line since MFC projects should include only afxwin.h</p>
",0
20420427,20420161,1,"<p>Print a <code>'\n'</code> after the last column of a row has been printed.</p>
",0
20519659,20519576,3,"<p>Your ""digits"" stored in <code>hexDecOne</code> and <code>hexDecTwo</code> aren't hexadecimal digits, they are characters equal to <code>'0'</code>, <code>'1'</code>, etc until <code>'F'</code>. Your <code>convert</code> function needs to convert characters <code>'0'</code> to <code>'9'</code> as well, and after that you need to convert your result the other way around for your digits to appear as characters. </p>

<p>By the way,your code creates a buffer overflow when the addition of the most significant digits of the two <code>hexDec</code> implies a non-nul carry.</p>
",0
20519999,20519576,1,"<p>You need to change your <code>convert</code> function to handle <code>0</code>..<code>9</code> as well as <code>A</code>..<code>F</code>:</p>

<pre><code>unsigned short convert(char item) {
    if (item &gt;= 'A' &amp;&amp; item &lt;= 'F') 
        return static_cast&lt;unsigned short&gt;('A' - item + 10);
    else if (item &gt;= '0' &amp;&amp; item &lt;= '9')
        return static_cast&lt;unsigned short&gt;('0' - item);
    else // handle error
}
</code></pre>
",0
20520981,20519576,2,"<p>I am seeing various ways of doing this and so far no-one mentioned the obvious, inbuilt functionality:: I have included a <code>stringstream</code> way of manipulating hex character arrays and use of <code>std::dec</code> and <code>std::hex</code> to convert between hex and decimal.  Using the code below I think you could alter your code easily to incorporate the inbuilt functionality available.</p>

<p>I have changed the code a little to further illustrate usage:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;sstream&gt;

int main()
{
    const char* test = ""deadbeef""; // or indeed you could pass in any array of char
    unsigned int x;
    std::stringstream ss;          // set up a stringstream object to use for conversions 
    ss &lt;&lt; std::hex &lt;&lt; test;        // put the value held by test into the stringstream, telling the stringstream its a hex value
    ss &gt;&gt; x;                       // put the value held by the stringstream into x (now a decimal)
    std::cout &lt;&lt; ""as an unsigned value: ""&lt;&lt; x&lt;&lt;std::endl;    // output it as an usigned int
    std::cout &lt;&lt; ""as a signed value"" &lt;&lt;static_cast&lt;int&gt;(x) &lt;&lt; std::endl; // output it as signed int
    // now we can use similar functionality with inputs from the user
    int input ;
    std::cout &lt;&lt; ""Enter decimal number: "" ;
    std::cin &gt;&gt; input ;
    std::cout &lt;&lt; ""0x"" &lt;&lt; std::hex &lt;&lt; input &lt;&lt; std::endl ;
    std::string inpStr;
    std::cout &lt;&lt; ""Please input a hex string without the preceding 0x:"";
    std::cin &gt;&gt; inpStr;
    std::stringstream ss2;
    ss2 &lt;&lt; std::hex &lt;&lt;inpStr;
    ss2 &gt;&gt; x;
    std::cout &lt;&lt; ""The value of 0x"" &lt;&lt;inpStr&lt;&lt;"" in hex is actually: ""&lt;&lt; std::dec &lt;&lt; x &lt;&lt; "" in decimal\n"";
    // to do additions try the following:
    int firstInt = 0xab;
    int secInt = 0xff;
    std::cout &lt;&lt; ""the values 0xab + 0xff = 0x"" &lt;&lt;std::hex &lt;&lt; (firstInt+secInt);
    std::cout &lt;&lt; "" and in decimal: ""&lt;&lt; std::dec &lt;&lt; firstInt &lt;&lt; ""+"" &lt;&lt; secInt &lt;&lt; ""= ""&lt;&lt; (firstInt+secInt);

    return x;
}
</code></pre>

<p>This code outputs the following when 256 and ff are entered as the values at the command line:</p>

<pre><code>as an unsigned value: 3735928559
as a signed value-559038737
Enter decimal number: 256
0x100
Please input a hex string without the preceding 0x: ff
The value of 0xff in hex is actually: 255 in decimal
the values 0xab + 0xff = 0x1aa and in decimal: 171+255= 426
</code></pre>

<p>That should allow you to easily carry out mathematical operations on hex values:)</p>

<p>Let me know if you need more information.:)</p>
",1
20521640,20519576,0,"<pre><code> #include &lt;iostream&gt;
 #include &lt;string&gt;
 #include &lt;map&gt;
 #include &lt;cctype&gt;
 #include &lt;algorithm&gt;

 using namespace std;

 int convert2i(char item) {
     static bool isFirst = true;
     static map&lt;char, int&gt;lookup;
     if(isFirst){
         for(int i=0;i&lt;16;++i)
             lookup[""0123456789ABCDEF""[i]]=i;
         isFirst = false;
     }
     return lookup[::toupper(item)];
 }

 char convert2C(int num){
     static bool isFirst = true;
     static map&lt;int, char&gt;lookup;
     if(isFirst){
         for(int i=0;i&lt;16;++i)
             lookup[i]=""0123456789ABCDEF""[i];
         isFirst = false;
     }
     return 0 &lt;= num &amp;&amp; num &lt;= 15 ? lookup[num] : -1;
 }

 void addition(char hexDecOne[10], char hexDecTwo[10], char (&amp;hexDecSum)[10]) {
     int carry = 0;
     for (int i = 0; i &lt; 9; i++) {// 9 : 10-1 (-1 for EOS)
         int wk = convert2i(hexDecOne[i]) + convert2i(hexDecTwo[i]) + carry;
         if(wk &lt; 16){
             carry = 0;
         } else {
             carry = 1;
             wk -= 16;
         }
         hexDecSum[i] = convert2C(wk);
     }
     if(carry)
         cerr &lt;&lt; ""overflow in addition"" &lt;&lt; endl;
 }

 int main(void){
     char hex1[10] = ""ABC000000"";
     char hex2[10] = ""FED000000"";
     char sum[10];

     addition(hex1, hex2, sum);
     reverse(sum, sum+sizeof(sum)-1);//reverse(&amp;sum[0], &amp;sum[9]);//[0,9)
     cout &lt;&lt; string(sum) &lt;&lt; endl;//000001AA9
 }
</code></pre>
",4
20522825,20519576,0,"<p>Here is example solution of 'manual' hex addition:</p>

<pre><code>char hexOne[8];
char hexTwo[8];
char hexSum[9];

int char2dec(char hex_char)
{
    // assume 0-9A-F input - no error handling

    if ((hex_char &gt;= '0') &amp;&amp; (hex_char &lt;= '9'))
    {
        return hex_char - '0';
    }
    else
    {
        return hex_char - 'A' + 10;
    }
}

char dec2char(int dec)
{
    // assume 0-15 input - no error handling
    return ""0123456789ABCDEF""[dec];
}

void addHex(char hexOne[8], char hexTwo[8], char hexSum[9])
{
    char carry = '0';
    int i;

    for (i = 0; i &lt; 8; i++)
    {
        char sum = char2dec(hexOne[i]) + char2dec(hexTwo[i]) + char2dec(carry);
        carry = dec2char(sum / 16);
        sum  = sum % 16;

        hexSum[i] = dec2char(sum);
    }

    if (carry != '0') hexSum[i] = carry;
}

void printHexWithoutCarry(char hex[])
{
    char print = 0;
    printf(""0x"");

    for(int digit = 7; digit &gt;= 0; digit--)
    {
        // skip 0s
        if (digit)
        {
            if ( hex[digit] != '0' ) print = 1;
        } 
        else
        {
            print = 1;
        }

        if (print)
        {
            printf(""%c"", hex[digit]);
        }
    }
}

void encodeAsHexArray(int val, char dst[])
{
    for(int digit = 0; digit &lt; 8; digit++)
    {
        char tmp = val &amp; 0xF;
        dst[digit] = dec2char(tmp);
        val &gt;&gt;= 4;
    }
}

void main(void)
{
    encodeAsHexArray(0xFF, hexOne);
    encodeAsHexArray(0x1, hexTwo);

    printHexWithoutCarry(hexOne); printf(""\n"");
    printHexWithoutCarry(hexTwo); printf(""\n"");
    addHex(hexOne, hexTwo, hexSum);
    printHexWithoutCarry(hexSum);
}
</code></pre>

<p>result:</p>

<pre><code>0xFF
0x1
0x100
</code></pre>
",0
20754744,20754724,5,"<p>Anything that has side effects in your conditions should be avoided, because it forces person reading this code to check validity few times.</p>

<p>In other words, it is very prone to errors and is hard to debug. If you increase your variable before or inside your <code>if</code> or <code>while</code>, it will work the same, but is much easier to understand.</p>
",1
20755107,20754724,2,"<blockquote>
  <p>while (++num1begin >= 0 &amp;&amp; isdigit(eq[num1begin]))</p>
</blockquote>

<p>All personal preference - there's nothing wrong with that IMHO.  I personally like the concision - and getting an extra line of context on screen - more than having <code>++num1begin</code> on the line before....</p>

<p>For me, I instinctively want to check the <code>++num1begin &gt;= 0</code> logic - that takes a little mental effort but has to be done whether the increment is in the same line or on a line before.  The order of evaluation and safety with usage on the other side of the <code>&amp;&amp;</code> takes no thought/effort, but that will vary with the reader.  You should always think about your ""audience"" though... if the other programmers are professional C++  developers they should be very comfortable with this.  If they're not, and might have to stop and wonder about short-circuit evaluation and sequence points, then you might want to split it out.  Sinking to the lowest-common-denominator of code maintainer is not always best... people should learn the language... but different code bases are naturally encountered by different groups of people.</p>

<p>""I instinctively want to check..."" - <code>num1begin</code> is used to index into <code>eq</code>, which <code>isdigit()</code> implies is a character array, so my concerns with this code include:</p>

<ul>
<li>whether <code>num1begin</code> is a signed type (so the first condition may ever be false),</li>
<li>that <code>num1begin</code> of <code>-1</code> is not the actual sentinel value that the code's trying to avoid searching from (given sentinels of -1 and a type's most-negative value being common),</li>
<li>that <code>num1begin &gt;= 0</code> is tested on every loop iteration, but presumably only needed the first time,</li>
<li>that there's no check for searching past the end of <code>eq</code>....</li>
</ul>

<p>It may be that a correction for any of the above may warrant abandoning the current code, but if the code's functionally correct and efficient then that's fine by me.</p>
",0
19876293,19876230,4,"<p>Your operator is a member of <code>alfa</code>, so it could not accept two <code>alfa</code> pointers, but rather, an <code>alpha</code> instance on the LHS and a pointer to <code>alpha</code> on the RHS.</p>

<p>If you wanted an operator to accept two <code>alpha</code> pointers, you would have to make it a non-member:</p>

<pre><code>class alfa
{
public:
    int x;
};

bool operator == (const alpha* lhs, const alfa* rhs)
{
    return true;
}   
</code></pre>

<p>However you are not allowed to overload comparison operators for built-in types such as pointers. You would have to provide an operator that can act on two instances:</p>

<pre><code>bool operator == (const alpha&amp; lhs, const alfa&amp; rhs)
{
    return true;
}   
</code></pre>

<p>Then, given two <code>alpha</code> pointers <code>a</code> and <code>b</code>, you can compare them like this:</p>

<pre><code>*a == *b;
</code></pre>
",3
19887730,19887648,0,"<p>Your logic is confused, you're trying to do too much at once. Separate out the different things you are trying to do. Like this</p>

<pre><code>void generator(){
    // set the whole area to ""+""
    for(int rows=0; rows&lt;10; rows++)
        for(int cols=0; cols&lt;10;cols++)
            gameArea[rows][cols] = ""+"";
    // set the position of the hero
    gameArea[x][y] = hero;
    // print the area
    for(int rows=0; rows&lt;10; rows++)
    {
        for(int cols=0; cols&lt;10;cols++)
            cout &lt;&lt; gameArea[rows][cols];
        cout &lt;&lt; endl;
    }
}
</code></pre>
",0
20183867,20183800,1,"<p>Just change it to :</p>

<pre><code>private:

ForwardStrategy* forwardStrategy;

ForwardToStrategy* forwardToStrategy;
</code></pre>

<p>because the way it's written in your question means you are trying to access a member (which is the constructor function) of this class not defining an instance of it.</p>
",3
20200757,20200667,3,"<p>The error message is clear:</p>

<blockquote>
  <p>error: usleep was not declared in this scope</p>
</blockquote>

<p>If you search for ""usleep"" on google you will find this <a href=""http://linux.die.net/man/3/usleep"" rel=""nofollow"">man page</a> which tells you:</p>

<pre><code>#include &lt;unistd.h&gt;
</code></pre>
",9
20202958,20202616,2,"<p>As stated in my comment, you can solve this using the <a href=""http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern"" rel=""nofollow"">curiously recurring template pattern</a>.  The code below uses your original example, templated on the type actually being stored:</p>

<pre><code>#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

using namespace std;

template&lt;class T&gt;
class NamedObject
{
public:

     static NamedObject *object_by_name(const string &amp;name) {
      return m_object_by_name[name];
     }

     NamedObject(const string &amp;name) : m_name(name) {
      m_object_by_name[m_name] = this;
     }

     virtual ~NamedObject() {
      m_object_by_name.erase(this-&gt;m_name);
     }

     const string &amp;name() const{
      return m_name;
     }

private:
     string m_name;

     static map&lt;string, NamedObject *&gt; m_object_by_name;
};

template &lt;class T&gt;
map&lt;string, NamedObject&lt;T&gt; *&gt; NamedObject&lt;T&gt;::m_object_by_name;

class A : public NamedObject&lt;A&gt;
{
public:
   A(const std::string&amp; name) : NamedObject(name)
   {}
};

class B : public NamedObject&lt;B&gt;
{
public:
   B(const std::string&amp; name) : NamedObject(name)
   {}
};

int main()
{
   new A(""Test"");
   new B(""Test"");

   auto one = A::object_by_name(""Test"");
   auto two = B::object_by_name(""Test"");

   cout &lt;&lt; one &lt;&lt; "" - "" &lt;&lt; one-&gt;name() &lt;&lt; ""\n"";
   cout &lt;&lt; two &lt;&lt; "" - "" &lt;&lt; two-&gt;name()  &lt;&lt; ""\n"";

   delete two;
   delete one;
}
</code></pre>
",0
19805078,19804592,1,"<p>According to your link and this one: <a href=""http://www.faqs.org/faqs/graphics/algorithms-faq/"" rel=""nofollow"">http://www.faqs.org/faqs/graphics/algorithms-faq/</a> (see section 2.03) the algorithm you've used will only work for points in the inside/outside of the polygon. Points on the border may return a 1 or a 0</p>

<blockquote>
  <p>If you want to know when a point is exactly on the boundary, you need another program. This is only one of many functions that PNPOLY lacks; it also doesn't predict tomorrow's weather. You are free to extend PNPOLY's source code.</p>
</blockquote>
",0
19805218,19804592,3,"<p>the PNPOLY code as written is really meant for floats not ints. If you defined your arrays and vertices as floats it would give you the expected results.   </p>

<p>1.0f and 2.0f are not adjacent in float math, but 1 and 2 are in int math.</p>

<p>what should tip you off is the function prototype</p>

<pre><code>int pnpoly(int nvert, float *vertx, float *verty, float testx, float testy)
</code></pre>

<p>furthermore the line:</p>

<pre><code>(testx &lt; (vertx[j]-vertx[i]) * (testy-verty[i]) / (verty[j]-verty[i]) + vertx[i]) )
</code></pre>

<p>is going to truncate your ints to the nearest int after those divides.</p>

<p>If you really want to use ints you would have to define your shapes with a more room, say 100x100 instead of 2x2. </p>
",0
20398434,20398000,0,"<p>Apart from defining a static local variable in the function as it was already shown you can define a static class member function that will increment a static data member of the same class. For example</p>

<pre><code>#include &lt;iostream&gt;

class Counter
{
public:
    static int Count() { return ( ++cnt ); }
    static int Reset() { return ( cnt = 0 ); }
private:
    static int cnt;
};

int Counter::cnt = 0;

int main()
{
   for ( int i = 0; i &lt; 10; i++ ) std::cout &lt;&lt; Counter::Count() &lt;&lt; ' ';
   std::cout &lt;&lt; std::endl;

   std::cout &lt;&lt; ""\nResetting the counter to "" &lt;&lt; Counter::Reset() &lt;&lt; std::endl;

   for ( int i = 0; i &lt; 10; i++ ) std::cout &lt;&lt; Counter::Count() &lt;&lt; ' ';
   std::cout &lt;&lt; std::endl;
}
</code></pre>
",0
20398065,20398000,2,"<p>Sounds like you want a <a href=""http://en.wikipedia.org/wiki/Static_variable"" rel=""nofollow"">static variable</a>:</p>

<pre><code>int counter()
{
   static int count = 0;   // initialized only once across all calls
   return ++count;
}
</code></pre>
",0
20398070,20398000,2,"<p>You can use <code>static</code>.</p>

<pre><code>int counter()
{
   static int counter = 0;
   return ++counter;
}
</code></pre>

<p>Static (in the function body context) is just a nice keyword that makes a variable essentially global, but not semantic-wise. So you cannot use it outside of the function, but it gets initialized with all the globals (it means once near the start point) and it is stored where other global variables are.</p>

<p>Just for the record, since <code>c++</code> label. You could write a functor class, with a private <code>count</code> variable and overload <code>operator()</code>. Or even probably a template that would be able to wrap any function and count its calls.</p>

<p>Also note that in your try, you call <code>counter</code> recursively with no exit point with a fixed value. It will never finish (unless you count stack overflowing as end).</p>
",0
20405705,20398000,0,"<p>If using C++11, use a <code>std::function</code> and a mutable lambda expression:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;functional&gt;

using namespace std;


int main()
{
    function&lt;int()&gt; func = [&amp;]()
    {
        static int i = 1;
        return i++;
    };

    for(int i = 0; i &lt; 10; i++)
        cout &lt;&lt; func() &lt;&lt; endl;
    return 0;
}
</code></pre>
",0
18797957,18797922,3,"<p>You wont' find anything before type your in console and <code>sbustr</code> should read from index <code>0</code></p>

<pre><code>string name;
int index;
//index = name.find(' '); // comment out, name is empty, you won't find anything

cin &gt;&gt; name;
index = name.find(' '); // now you can find first space

cout &lt;&lt; ""Middle Name: "" &lt;&lt; name.substr(0, index) &lt;&lt; endl;
//                                     ^
</code></pre>

<p>Or just use <code>std::stringstream</code></p>

<pre><code>  #include &lt;sstream&gt;

  std::stringstream ss(name);
  std::string token;
  int i = 0;
  while(ss &gt;&gt; token)
  {
    switch(i)
    {
      case 0: 
        std::cout &lt;&lt; ""First name: "" &lt;&lt; token &lt;&lt; std::endl;
        break;
      case 1: 
        std::cout &lt;&lt; ""Middle name: "" &lt;&lt; token &lt;&lt; std::endl; 
        break;
      case 2: 
        std::cout &lt;&lt; ""Last name: "" &lt;&lt; token &lt;&lt; std::endl; 
        break;
      default:
        break;
      i++;
    }
  }
</code></pre>
",2
18797967,18797922,2,"<p>You clearly can't search for something in <code>name</code> before you assign it a value, which is what you're doing now:</p>

<pre><code>string name;
int index;

index = name.find(' ');  // No value assigned to name yet - nothing to search
cin &gt;&gt; name;             // Now you're giving it a value (too late)
</code></pre>

<p>Instead, assign and <em>then</em> try to find a value:</p>

<pre><code>string name;
int index;

cin &gt;&gt; name;            // Assign a value first
index = name.find(' '); // Now try to find something in it
</code></pre>
",2
18798036,18797922,0,"<p>The extraction operator <code>&gt;&gt;</code> for istream will grab all non-whitespace characters in the buffer until it encounters a whispace.</p>

<p>So your input here:</p>

<pre><code>Teenage Wonder Land
</code></pre>

<p>contains 3 whitespaces including the invisible newline at the end when you hit <kbd>enter</kbd>. From this you should be able to figure out what the following does:</p>

<pre><code>cin &gt;&gt; name;
</code></pre>

<p>Hint: <code>name</code> doesn't contain the entire line you just entered.</p>
",2
18798584,18797922,0,"<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

string getnext(const string &amp;full, const string &amp;delim, size_t &amp;beg) {
    size_t prev = beg;
    beg = full.find(delim, beg);
    if (beg != string::npos)
        return full.substr(prev, beg-prev);
    return full.substr(prev, full.length()-prev);
}

int main()
{
    string name, temp, error = ""NameError: Enter first, middle, last"";
    size_t index = 0;
    getline(cin, name); //Get the full name

    temp = getnext(name, "" "", index); //Get first name
    if (index == string::npos) {
        cout &lt;&lt; error;
        return -1;
    }
    cout &lt;&lt; ""First name: "" &lt;&lt; temp &lt;&lt; endl;

    temp = getnext(name, "" "", ++index); //Get middle name
    if (index == string::npos) {
        cout &lt;&lt; error;
        return -1;
    }
    cout &lt;&lt; ""Middle Name: "" &lt;&lt; temp &lt;&lt; endl;

    temp = getnext(name, "" "", ++index); //Get last name
    cout &lt;&lt; ""Last name: "" &lt;&lt; temp &lt;&lt; endl;
    return 0;
}
</code></pre>
",0
18798187,18797922,0,"<p>I think you should use <code>std::getline</code> to get the entire line of text at once. Currently you are only reading in the first word (<code>&gt;&gt;</code> operator will only extract text up to the next whitespace character).</p>

<pre><code>std::string name;
if (std::getline(cin, name))
{
    // extraction successful, ""name"" should contain entire line
}
</code></pre>

<p>Then, you can use one of the other answers in this question or continue with your own approach.</p>
",2
19801204,19801103,1,"<p>Let's play compiler!</p>

<p>You cannot name a variable <code>file1.txt</code>, call it <code>file1</code></p>

<p>Also, you forgot the semi-colon <code>;</code> at the end of the line, so</p>

<pre><code>cin.get(file1.txt)
</code></pre>

<p>should be </p>

<pre><code>cin.get(file1);
</code></pre>

<p>I don't quite know where you are defining this variable, so you may be missing a declaration like</p>

<pre><code>const char* file1=""file1.txt"";
</code></pre>

<p>Furthermore, you start trying to access some variable <code>count</code> after your for-loop here:</p>

<pre><code>count[i]
</code></pre>

<p>Did you mean to use <code>char_count</code>?</p>
",4
19801293,19801103,1,"<p>The first problem is that you haven't declared <code>file1</code>. It is somewhat unclear what <code>file1.txt</code> really is meant to be: The way it is written, it seems to be an object of type with a member called, <code>txt</code> of type <code>char*</code> or <code>char[N]</code> (with a constant <code>N</code>). From the looks of it, you actually wanted to open a file named <code>file1.txt</code>. This would look like so:</p>

<pre><code>std::ifstream in(""file1.txt"");
</code></pre>

<p>After that you would, of course, use <code>in</code> instead of <code>std::cin</code> to read from the file. For example you could use</p>

<pre><code>for (char c; in.get(c); ) {
    // ...
}
</code></pre>

<p>to read each individual character of the file and process it appropriately.</p>
",1
19972587,19972041,4,"<p>IO manipulators are not magic, but they can be odd to think about. There are several ways to do this, this being just one of them, mimicking the behavior it appears you're looking for..</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

class myAlign
{
public:
    explicit myAlign(const std::string&amp; s)
        : fmt((s == ""left"") ? std::ios::left : std::ios::right)
    {}

private:
    std::ios::fmtflags fmt;

    friend std::ostream&amp; operator &lt;&lt;(std::ostream&amp; os, const myAlign&amp; arg)
    {
        os.setf(arg.fmt);
        return os;
    }
};

int main(int argc, char *argv[])
{
    std::cout &lt;&lt; myAlign(""left"") &lt;&lt; std::setw(10) &lt;&lt; ""12345"" &lt;&lt; std::endl;
    std::cout &lt;&lt; myAlign(""right"") &lt;&lt; std::setw(10) &lt;&lt; ""67890"" &lt;&lt; std::endl;
    return 0;
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>12345     
     67890
</code></pre>

<p>Note: A similar but considerably more complex related question <a href=""https://stackoverflow.com/questions/6478745/custom-stream-manipulator-for-streaming-integers-in-any-base"">can be found here</a>.</p>
",1
20645429,20645274,0,"<p><code>cout</code> is a specific <code>ostream</code> where the function <code>PrintStats</code> is printing to.  What you are looking for instead is overloading <code>operator&lt;&lt;</code> for your type.</p>

<pre><code>    std::ostream &amp; operator&lt;&lt;(std::ostream &amp; s, const Employee&amp; m)
    {
        m.Stream(s);
        return s;
    }
</code></pre>

<p>And then this can be used as:</p>

<pre><code>    outfile &lt;&lt; *i;
</code></pre>

<p>And then declare a function <code>virtual Stream() const</code> in <code>Employee</code> and override it in <code>Manager</code></p>
",2
20645457,20645274,2,"<p>First, <code>printStats</code> should be told where to put the data, and not just always write it to <code>cout</code>.</p>

<pre><code>void Manager::printStats(std::ostream&amp; out) const //function doesn't modify, so const
{
    out &lt;&lt; ""\nManager."" &lt;&lt; endl;
    out &lt;&lt; ""First name: "" &lt;&lt; mFirstName &lt;&lt; endl; // data member of base class
    out &lt;&lt; ""Last name: "" &lt;&lt; mLastName &lt;&lt; endl; // data member of base class
    out &lt;&lt; ""Salary: "" &lt;&lt; mSalary &lt;&lt; endl; // data member of base class
    out &lt;&lt; ""Meetings per week: "" &lt;&lt; mNumberOfMeetingsPerWeek &lt;&lt; endl; // data member of derived class
    out &lt;&lt; ""Vacation Days per year: "" &lt;&lt; mNumberOfVacationDaysPerYear &lt;&lt; endl; //data member of derived class
    out &lt;&lt; endl;
}
</code></pre>

<p>Then tell C++ how to insert your class into a stream:</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Employees&amp; employee) 
{
   employee.printStats(out);
   return out; //return ostreams by reference when done
}
</code></pre>

<p>If you'd like, you can add another for the vector , that does almost exactly what your old loop did</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const vector&lt;Employees*&gt;&amp; midzer) 
{
   for (vector&lt;Employees*&gt;::const_iterator i = midzer.begin(); i != midzer.end(); ++i)
   {
       out &lt;&lt; *(*i);
   }
   //or if you have a newer compiler:
   //for (Employees* i : midzer) out &lt;&lt; *i;
   return out; //return ostreams by reference when done
}
</code></pre>

<p>finally, output the vector</p>

<pre><code>ofstream outfile;
outfile.open(""/users/mundt/desktop/EmployeeDatabase.txt"");
outfile &lt;&lt; midzer; //well that's easy
outfile.close();
</code></pre>

<p>Working demo here: <a href=""http://coliru.stacked-crooked.com/a/03fd3b4e23dc7ee2"" rel=""nofollow"">http://coliru.stacked-crooked.com/a/03fd3b4e23dc7ee2</a></p>
",17
20645631,20645274,2,"<p>There are many options for doing this, I will describe 3:</p>

<ol>
<li>Returning a string from the function</li>
<li>Outputting to a stream that is passed to the function</li>
<li>Overloading <code>operator&lt;&lt;</code> (this is used in conjunction with one of the above 2)</li>
</ol>

<p>More detail:</p>

<ol>
<li><p>If you return a string from the <code>printStats()</code> function then you can write that to your <code>ofstream</code>:</p>

<pre><code>std::string Manager::printStats()
{
    std::stringstream ss;
    ss &lt;&lt; ""\nManager."" &lt;&lt; endl;
    ss &lt;&lt; ""First name: "" &lt;&lt; mFirstName &lt;&lt; endl; // data member of base class
    ss &lt;&lt; ""Last name: "" &lt;&lt; mLastName &lt;&lt; endl; // data member of base class
    ss &lt;&lt; ""Salary: "" &lt;&lt; mSalary &lt;&lt; endl; // data member of base class
    ss &lt;&lt; ""Meetings per week: "" &lt;&lt; mNumberOfMeetingsPerWeek &lt;&lt; endl; // data member of derived class
    ss &lt;&lt; ""Vacation Days per year: "" &lt;&lt; mNumberOfVacationDaysPerYear &lt;&lt; endl; //data member of derived class
    ss &lt;&lt; endl;

    return ss.str();
}
</code></pre></li>
<li><p>If you pass in an <code>ostream</code> to the function, you can output directly to it. (You may want to define the function as <code>void printStats( std::ostream&amp; os = std::cout );</code> so if you call it with no parameters, it will default to <code>cout</code>:</p>

<pre><code>void Manager::printStats( std::ostream&amp; os )
{
    os &lt;&lt; ""\nManager."" &lt;&lt; endl;
    //...
}
</code></pre>

<p>This would be called like this in your example:</p>

<pre><code>(*i)-&gt;printStats( outFile );
</code></pre></li>
<li><p>If you overload the <code>operator&lt;&lt;</code> then you can directly pass it to the <code>outFile</code>. </p>

<pre><code>std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, const Employee&amp; e )
{
    os &lt;&lt; e.printStats(); 
    // or
    e.printStats( os );

    // for both cases
    return os;
}
</code></pre>

<p>Then this could be called:</p>

<pre><code>outFile &lt;&lt; *(*i);
</code></pre></li>
</ol>
",8
20020478,20020333,2,"<p>Solution without using bit operators...</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt; 
#include &lt;math.h&gt; 
using namespace std;

string digits[2] = {""0"",""1""};

// return an integer in binary format
string num2bin(int n){ return n&lt;2 ? digits[n] : num2bin(n/2) + digits[n%2]; }

// get the b-th byte of an integer
int getByte(long n, int b){ return (long)(n/pow(256,b)) % 256; }

int main() {
    long n = 987654321; // or whatever

    // loop through the bytes in order
    for (int b=0;b&lt;4;b++) {
        cout &lt;&lt; ""byte "" &lt;&lt; b &lt;&lt; "" = "" &lt;&lt; num2bin(getByte(n,b)) &lt;&lt; endl;
    }
 }
</code></pre>

<p>Output:</p>

<pre><code>byte 0 = 10110001
byte 1 = 1101000
byte 2 = 11011110
byte 3 = 111010
</code></pre>
",1
19018335,19018294,8,"<p>Here's a snippet I like to keep around for using in these sorts of situations.</p>

<pre><code>int validInput()
{
    int x;
    std::cin &gt;&gt; x;
    while(std::cin.fail())
    {
        std::cin.clear();
        std::cin.ignore(std:numeric_limits&lt;std::streamsize&gt;::max(),'\n');
        std::cout &lt;&lt; ""Bad entry.  Enter a NUMBER: "";
        std::cin &gt;&gt; x;
    }
    return x;
}
</code></pre>

<p>Then any place you want to use <code>cin&gt;&gt;guess</code>, instead, use <code>guess = validInput();</code></p>
",7
19018433,19018294,3,"<p>Since spreading around code similar to what <em>@nhgrif</em> suggests for every acquisition is tedious and error-prone, I usually keep around the following header:</p>

<pre><code>#ifndef ACQUIREINPUT_HPP_INCLUDED
#define ACQUIREINPUT_HPP_INCLUDED

#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;string&gt;

template&lt;typename InType&gt; void AcquireInput(std::ostream &amp; Os, std::istream &amp; Is, const std::string &amp; Prompt, const std::string &amp; FailString, InType &amp; Result)
{
    do
    {
        Os&lt;&lt;Prompt.c_str();
        if(Is.fail())
        {
            Is.clear();
            Is.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\n');
        }
        Is&gt;&gt;Result;
        if(Is.fail())
            Os&lt;&lt;FailString.c_str();
    } while(Is.fail());
}

template&lt;typename InType&gt; InType AcquireInput(std::ostream &amp; Os, std::istream &amp; Is, const std::string &amp; Prompt, const std::string &amp; FailString)
{
    InType temp;
    AcquireInput(Os,Is,Prompt,FailString,temp);
    return temp;
}

#endif
</code></pre>

<p>Usage example:</p>

<pre><code>//1st overload
int AnInteger;
AcquireInput(cout,cin,""Please insert an integer: "",""Invalid value.\n"",AnInteger);

//2nd overload (more convenient, in this case)
int AnInteger=AcquireInput(cout,cin, ""Please insert an integer: "",""Invalid value.\n"");
</code></pre>

<p>The <code>AcquireInput</code> function allows to read any type for which there's an <code>operator&gt;&gt;</code> available and automatically retries (cleaning up the input buffer) if the user inserts invalid data. It also prints the given prompt before asking the data and the error message in case of invalid data.</p>
",0
19798476,19798325,1,"<p>When you create a function and compile it, the compiler generates code for it.  Many compilers will not generate code for static functions that are not used.</p>

<p>If you create a templated function and nothing uses the template (such as std::sort), the code for the function will not be generated.  </p>

<p>Remember, templates are like stencils.  The templates tell how to generate a class or function using the given template parameters.  If the stencil is not used, nothing is generated.  </p>

<p>Consider also that the compiler doesn't know how to implement or use the template until it sees all the template parameters resolved.  </p>
",0
19798503,19798325,3,"<p>The main point here is that compiler does not <strong>treat</strong> a template definition until it meets a certain instance of the template. (Then it can proceed, I guess, like it have a usual class, which is a specific case of the template class, with fixed template parameters.)</p>

<p>The direct answer to your question is: Compiler generates machine code from users c++ code, I think this is wat is meant here by word ""generate code"".</p>

<p>The template declaration must be in header file because when compiler compiles some source, which use template it HAVE only header file (included in source with #include macro), but it NEED whole template definition. So logical conclusion is that template definition must be in header.</p>
",0
19798414,19798325,25,"<p>The compiler <em><strong>generates</strong></em> the code for the specific types given in the template class instantiation.</p>
<p>If you have for instance a template class declaration as</p>
<pre><code>template&lt;typename T&gt;
class Foo
{
public:
     T&amp; bar()
     {
         return subject; 
     }
private:
     T subject;
};
</code></pre>
<p>as soon you have for example the following instantiations</p>
<pre><code>Foo&lt;int&gt; fooInt;
Foo&lt;double&gt; fooDouble;
</code></pre>
<p>these will <em><strong>effectively generate</strong></em> the same linkable code as you would have defined classes like</p>
<pre><code>class FooInt
{
public:
     int&amp; bar()
     {
         return subject; 
     }
private:
     int subject;
}
</code></pre>
<p>and</p>
<pre><code>class FooDouble
{
public:
     double&amp; bar()
     {
         return subject; 
     }
private:
     double subject;
}
</code></pre>
<p>and instantiate the variables like</p>
<pre><code>FooInt fooInt;
FooDouble fooDouble;
</code></pre>
<p>Regarding the point that template <a href=""https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration""><strong>definitions</strong></a> (don't confuse with <a href=""https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration"">declarations</a> regardless of templates) need to be seen with the header (included) files, it's pretty clear why:<br />
The compiler can't generate this code without seeing the <a href=""https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration""><strong>definition</strong></a>. It can refer to a matching instantiation that appeared first at linking stage though.</p>
<blockquote>
<p>What does a non-template member function have that allows for it to
be defined outside of the header that a template function doesn't
have?</p>
</blockquote>
<p>The declaration of a non-template class/member/function gives a predefined entry point for the linker. The definition can be drawn from a single implementation seen in a compiled object file (== .cpp == <a href=""https://stackoverflow.com/questions/1106149/what-is-a-translation-unit-in-c"">compilation unit</a>).<br />
In contrast the declaration of a templated class/member/function might be instantiated from arbitrary compilation units given the same or varying template parameters. The definition for these template parameters need's to be seen at least once. It can be either generic or specialized.</p>
<p>Note that you can specialize template implementations for particular types anyway (included with the header or at a specific <a href=""https://stackoverflow.com/questions/1106149/what-is-a-translation-unit-in-c"">compilation unit</a>).
If you would provide a specialization for your template class in one of your <a href=""https://stackoverflow.com/questions/1106149/what-is-a-translation-unit-in-c"">compilation units</a>, and don't use your template class with types other than specialized, that also should suffice for linking it all together.</p>
<p>I hope this sample helps clarifying what's the difference and efforts done from the compiler.</p>
",17
19798427,19798325,0,"<p>It won't straight away generate code. Only generates the class or template code when it comes across an instantiation of that template. That is, if you are actually creating an object of that template definition.</p>
<p>In essence, templates allow you abstract away from types. If you need two instantiations of the template class for example for an int and a double the compiler will literally create two of these classes for you when you need them. That is what makes templates so powerful.</p>
",0
19798428,19798325,-1,"<p>Your C++ is read by the compiler and turned into assembly code, before being turned in machine code.</p>

<p>Templates are designed to allow generic programming. If your code doesn't use your template at all, the compiler won't generate the assembly code associated. The more data types you associate your template with in your program, the more assembly code it will generate. </p>
",0
19798572,19798325,5,"<p>What is the compiler suppose to do when it sees a template? Generate all the machine code for all possible data types - ints, doubles, float, strings, ... Could take a lot of time. Or just be a little lazy and generate the machine code for what it requires.</p>

<p>I guess the latter option is the better solution and gets the job done.</p>
",2
19798693,19798325,17,"<p>A template is a <strong>pattern</strong> for creating code. When the compiler sees the definition of a template it makes notes about that pattern. When it sees a <strong>use</strong> of that template it digs out its notes, figures out how to apply the pattern at the point where it's being used, and generates code according to the pattern.</p>
",1
19874459,19874436,0,"<p>A constructor is always executed for every base class. This includes compiler-generated default constructors. If it's not possible to call a base class constructor, you will always get an error message.</p>
",0
19874462,19874436,0,"<p>Yes, by default, the default constructor of the base class is executed.</p>

<p>Note that this applies for all derived class constructors - they all call the default constructor unless you specify a different one. This means that a copy constructor in a derived class (user-defined or compiler generated) will, by default, call the default base class constructor.</p>
",2
19874463,19874436,0,"<p>Generally speaking, the base class's constructor will get called before the derived class's constructor.</p>

<p>Here's a good SO thread explaining it: <a href=""https://stackoverflow.com/questions/1640414/does-a-base-classs-constructor-and-destructor-get-called-with-the-derived-ones"">Does a base class&#39;s constructor and destructor get called with the derived ones?</a></p>
",0
19874471,19874436,0,"<p>yes Sure , The base class constructor get executed even if your derived class has no constructor </p>
",0
19874478,19874436,0,"<p>Yes. If not defined the compiler conjures up one for you and uses that</p>
",0
19874840,19874436,0,"<p>Even if you do not define a constructor by yourselves, default constructor will be added by the compiler.</p>

<p>By default, derived class constructor will call the default constructor of the base class before the execution of the body of the derived class constructor.</p>

<p>If you want, you can call the constructor of the base class in the initialization list of the constructor of the derived class. </p>

<p>Here is an example.</p>

<pre><code>class Base
{
public:
    Base(int nValue)
    {
        //body of the constructor
    }
};

class Derived: public Base
{
public:

    Derived(int mnValue) :Base(mnValue)
    {
        //body of the constructor
    }
};
</code></pre>

<p>In the above example, derived class call the constructor of the Base class explicitly in the initialization list of the constructor of the derived class.</p>

<p>For more information, please refer to </p>

<p><a href=""http://www.learncpp.com/cpp-tutorial/113-order-of-construction-of-derived-classes/"" rel=""nofollow"">http://www.learncpp.com/cpp-tutorial/113-order-of-construction-of-derived-classes/</a></p>

<p><a href=""http://www.learncpp.com/cpp-tutorial/114-constructors-and-initialization-of-derived-classes/"" rel=""nofollow"">http://www.learncpp.com/cpp-tutorial/114-constructors-and-initialization-of-derived-classes/</a></p>
",0
19875687,19874436,0,"<p>Whenever you create an object its constructor runs. Whenever you destroy an object its destructor runs. Regardless of whether the object is a member, a base, or anything else. That's fundamental to object-oriented programming.</p>
",0
19886083,19886071,0,"<p>Change main to look like this:</p>

<pre><code>int main()
{
    menu();

    return 0;
}
</code></pre>

<hr>

<p>Change <code>menu</code> to look like this: </p>

<pre><code>void menu() {
    int a;
    int b;
    // remove int r; and return r; from menu function
    // then everything else stays the same
</code></pre>

<hr>

<p>In your <code>switch</code> statement, change this:</p>

<pre><code>add (int a, int b);
</code></pre>

<p>To this:</p>

<pre><code>add(a,b);
</code></pre>

<p>And do the same in every other place where you've included <code>int</code> in your function calls.</p>
",0
19886091,19886071,0,"<pre><code>add (int a, int b);
</code></pre>

<p>You can't have the <code>int</code> tokens here - you want to use the values of existing variables <code>a</code> and <code>b</code>, not declare them.  They were already declared in the function introduction <code>int menu(int a, int b)</code>.</p>

<p>You need just:</p>

<pre><code>add(a, b);
</code></pre>
",0
19886103,19886071,0,"<p>When you call your functions you should just use the variable names you're passing into it without adding it's type before it:</p>

<p>...</p>

<pre><code>cout &lt;&lt;""Give a value for b""&lt;&lt;endl;
cin&gt;&gt;b;
add (int a, int b); //aqu y en otras lneas me sale: expected primary expression before int.
break;
</code></pre>

<p>...</p>

<p>Should be:
...</p>

<pre><code>cout &lt;&lt;""Give a value for b""&lt;&lt;endl;
cin&gt;&gt;b;
add (a, b); //aqu y en otras lneas me sale: expected primary expression before int.
break;
</code></pre>

<p>...</p>

<p>By adding the int keywords before a and b I think you might be redeclaring those variables. </p>
",0
20510791,20510721,1,"<p>Add a virtual member function in <code>Base</code>, that is implemented differently for each derived class.</p>

<p>If doesn't feel right to have it in <code>Base</code>, perhaps add an intermediate class derived from <code>Base</code>, which <code>A</code> and <code>B</code> then derive from.</p>

<p>More generally the solution to such a problem is not to downcast at each caller site, but to centralize that downcasting in the classes themselves by way of the visitor pattern, but for the case at hand using visitor pattern seems like a too heavy-weight solution: just an ordinary virtual function will probably do.</p>
",0
20418931,20418653,1,"<p>In c++ or any language == operator is not recommended for double or float type because the variable stores approx value not the exact value with very slight error. Lets say you are using double variable t to compare equality with 0.05 you can use the following code:</p>

<pre><code>if( t-0.00000000001&lt;=0.05 &amp;&amp; t+0.00000000001&gt;=0.05 )
</code></pre>

<p>It will work fine in this case</p>
",2
20508834,20508796,1,"<p>Declare day? You will need a <code>std::string</code>. I think you want something like this:</p>

<pre><code>#include &lt;string&gt;
....
std::string day = ""SUNDAY"";
....
if ((temperature &gt; 40 ) &amp;&amp; (day == ""SUNDAY""))
</code></pre>
",3
20520644,20520496,0,"<p>Your code is invalid in whole because this loop</p>

<pre><code>    while(true)
    {
        display(letter[i]);
        swapLetter(letter[i]);
    }
</code></pre>

<p>is infinite unless either display or swapLetter does not have call to exit.</p>

<p>As for error then it is obvious from the error message that the function expects to get some string instead of on character. So its parameter is declared something as char s[] or char *s, or const char s[], or const char *s and so on.
And even if you would pass to it your array letter it would be a mistake because your array has no the terminating zero. I think you should declare your array as</p>

<pre><code>char letter[] = {'H','E','L','L','O','!', '\0'};
</code></pre>

<p>Or function display should be declared as</p>

<pre><code>void display( char c );
</code></pre>
",1
20520526,20520496,0,"<p>It means that you are passing a <code>char</code> as a parameter to a function that expects <code>char*</code>.</p>

<p>Your functions actually expect you to pass the entire string rather than a single character. So your code should be:</p>

<pre><code>display(letter);
swapLetter(letter);
</code></pre>

<p>Of course, I suspect that renders the outer loop in <code>passChar</code> meaningless. And the infinite <code>while(true)</code> loop seems odd, although you claim in the question that it is intentional. In which case the code should read:</p>

<pre><code>void passChar()
{
    char letter[] = {'H','E','L','L','O','!'};
    while(true)
    {
        display(letter);
        swapLetter(letter);
    }
} 
</code></pre>

<p>Personally I think I would code <code>display</code> and <code>swapLetter</code> to accept <code>char*</code> and use the null-terminator to detect length.</p>

<pre><code>void passChar()
{
    char letter[] = ""HELLO!"";
    while(true)
    {
        display(letter);
        swapLetter(letter);
    }
} 
</code></pre>

<p>and then modify <code>display</code> and <code>swapLetter</code> to use the null-terminator to locate the end of the string.</p>
",0
20520530,20520496,0,"<p>Presumably because your <code>display()</code> function looks like the following:</p>

<pre><code>void display(char* value)
{ }
</code></pre>

<p><code>letter[i]</code> is of type <code>char</code>, the above function expects <code>char*</code>...</p>
",1
20521197,20521037,1,"<p>You've only allocated 5 bytes for the password, but read an arbitary number of bytes, which will lead to illegal accesses and basically all sorts of (potentially) random stuff happening, including odd corruptions like you have seen.</p>

<p>Also, you fail to null terminate your char array, so you might get random stuff printed after the password - a <code>pass[++i]='\0';</code> placed after the loop will fix that.</p>

<p>Try increasing it to a much larger value and see if that fixes the issue.
If not, can you paste the entire output - do the * get messed up? is it just the </p>
",0
20522057,20522013,2,"<p>In C++, an abstract class is any class that has at least 1 <em>pure</em> virtual function.</p>

<p>C++ does not have direct support for interfaces, but you can make one by making all of the functions public, virtual, and abstract, and have no data members in the class.</p>
",0
20522061,20522013,2,"<p>In C++, an interface is defined as follows:</p>

<pre><code>class Interface {
public:
    virtual ~Interface();
    virtual void aMethod() = 0;
};
</code></pre>

<p>Note the virtual destructor.</p>
",0
20194691,20194607,3,"<p>First of all this is not an error while running your program - it is an error while <strong>linking</strong>. Linking is a phase that happens after compilation but before running the program. Most often you see this error if visual studio can not open the executable for writing and this usually happens because you have the executable running while linking. Check if there is an instance of your program running and if there is, terminate it and try again. </p>
",0
18940208,18940164,2,"<p>Make it</p>

<pre><code>template &lt;class T&gt;
SimpleStack&lt;T&gt;&amp; SimpleStack&lt;T&gt;::push(T value) {...}
</code></pre>
",2
20521745,20521570,2,"<ul>
<li>case 1: I dont really understand how 10 gets assigned to _n as the value expected in the first argument of func is an object reference. Can someone help me how this is actually working with some example.</li>
</ul>

<p>First argument is <code>const reference</code>, which will be bound to temporary constructed by <code>A(int)</code> with arg <code>10</code>. Compiler attempts to convert argument types passed to argument types expected, either by constructor or cast operator. If such constructor or cast operator exists and not marked <code>explicit</code>, a temporary will be constructed and passed as argument.</p>

<ul>
<li>case 2: As the compiler evaluates from right to left, a) It calls the constructor (secord argument) and assigns 20 to _n. b) As the object 'a' is already constructed, it just assigns a to i1.</li>
</ul>

<p>Who said compiler evaluates from right to left in function arguments?! Order is undefined.</p>

<p>Also, it does not assign <code>a</code> to <code>i1</code>, it passes constant reference (address of) <code>a</code>.</p>

<ul>
<li>case 3: a) It calls the default constructor for i2. b) It calls copy constructor for c and assigns to i1.</li>
</ul>

<p>Correct, with respect to remark above about assignment.</p>

<ul>
<li>case 4: calls the assignment operator of class A.</li>
</ul>

<p>Correct.</p>
",3
20521534,20521478,4,"<p>Here is <code>connect()</code> declaration:</p>

<pre><code>Status connect (const IpAddress &amp;remoteAddress, unsigned short remotePort, Time timeout=Time::Zero)
</code></pre>

<p>Just supply third argument and it <em>should</em> stop connecting itself.</p>
",1
18976525,18976343,-1,"<p>Using std::map the index has to be unique, if you try and insert multiple pairs it does nothing.</p>

<p>For your question something like this should work:</p>

<pre><code>std::map&lt;string, int&gt; fruits;
for(int i = 0; i&lt;arraylenth; ++i) {
    fruits[overallfruit[i].name] += overallfruit[i].quantity; // add quantity to previous quantity if exists, or insert new map entry
}
</code></pre>
",1
18976564,18976343,-2,"<p>I may not understand your question, but what I see is something like this:</p>

<pre><code>std::map&lt;std::string, unsigned int&gt; fruitsMap;
for(std::size_t i = 0 ; i &lt; NUM ; ++i) {
    std::map&lt;std::string, unsigned int&gt;::iterator it = fruitsMap.find(overallfruit[i].name);
    if(it == fruitsMap.end())
        fruitsMap[overallfruit[i].name] = overallfruit[i].quantity;
    else
        vIt-&gt;second += overallfruit[i].quantity;
}
</code></pre>

<p>It will traverse your array and fill the map according to your need.</p>
",2
18976648,18976343,3,"<p>There's the subtle issue of preserving ordering, which others have missed.</p>

<p>I present three approaches:</p>

<hr>

<h3>1. Creating a new container</h3>

<p>If you want to keep the order, you could do with a 'consolidate' function, e.g.</p>

<p><a href=""http://coliru.stacked-crooked.com/a/fc66943d8d4c5af8"" rel=""nofollow"">Live on Coliru</a></p>

<pre><code>vector&lt;entry&gt; consolidate(vector&lt;entry&gt; const&amp; in)
{
    vector&lt;entry&gt; result;

    for (auto&amp; e : in)
    {
        auto found = find_if(begin(result), end(result), [&amp;e](entry const&amp; a) { return a.name == e.name; });
        if (end(result) == found)
            result.push_back(e);
        else
            found-&gt;quantity += e.quantity;
    }

    return result;
}
</code></pre>

<hr>

<h3>2. <em>In-place consolidation</em> algorithm:</h3>

<p><strong><a href=""http://ideone.com/pa1Ycy"" rel=""nofollow"">Live on Coliru</a></strong></p>

<pre><code>void consolidate(vector&lt;entry&gt;&amp; data)
{
    auto f = data.begin(), l = data.end();
    while (f!=l)
    {
        auto match = find_if(begin(data), f, [&amp;](entry const&amp; a) { return a.name == f-&gt;name; });
        if (match != f)
        {
            match-&gt;quantity += f-&gt;quantity;
            f = data.erase(f);
            l = data.end();
        } else
        {
            f++;
        }
    }
}
</code></pre>

<hr>

<h3>3. Using <code>map</code></h3>

<p>If you don't mind the order changing, use that map that was suggested in other answers:</p>

<p><a href=""http://coliru.stacked-crooked.com/a/74505e2a85018279"" rel=""nofollow"">Live on Coliru</a></p>

<pre><code>#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

using namespace std;

struct entry {
    string name;
    unsigned quantity;
};

int main()
{
    const entry array[] = {
        { ""apple"", 5 },
        { ""pear"",  2 },
        { ""grape"", 6 },
        { ""mango"", 3 },
        { ""apple"", 2 },
        { ""mango"", 9 },
    };

    map&lt;string, unsigned&gt; m;
    for (auto&amp; e : array)
        m[e.name] += e.quantity;

    for (auto&amp; e : m)
        cout &lt;&lt; e.first &lt;&lt; "" "" &lt;&lt; e.second &lt;&lt; ""\n"";
}
</code></pre>
",2
18976473,18976343,2,"<p>First create the map with <code>std::string</code> as key (the name), and <code>int</code> as data (the quantity). Then loop over the array, and for every entry add the quantity to the map as indexed by the name.</p>
",3
20521539,20521440,4,"<p>When you instantiate <code>d</code>, you do not initialize the data members of the base class. Their value is undetermined (no initialization is performed on default initialized built-in types or PODs), and reading from them is actually undefined behaviour. </p>

<p>You must make sure that you initialize the base class data members before you read from them. There are many ways to do that, depending on your needs. At the very least, you could make sure they get zero-initialized by value initializing them in the constructor:</p>

<pre><code>class base
{
 public:
  base() : a(), b(), c() {} // default constructor
  ...
</code></pre>

<p>This will result in your call to <code>d.read()</code> setting <code>d.x</code>, <code>d.y</code>, <code>d.z</code> to <code>0</code>, since all it does is assign from <code>a</code>, <code>b</code>, and <code>c</code> respectively.</p>
",0
20521777,20521440,2,"<p>A method of a derived class does not automatically call the same method of the base class - it <em>replaces</em> the base implementation, it doesn't <em>add to</em> it. If you want to use the base class implementation too you have to do that yourself.</p>

<pre><code>void derived :: read()
{
    base::read();
    x=a;
    y=b;
    z=c;
}
</code></pre>
",0
20521846,20521440,2,"<p>When you create the instance of <code>Derived</code> it DOES NOT get the values of <code>a</code> <code>b</code> and <code>c</code> you assigned from console to the instance of <code>Base</code>: it's another, independend, object!</p>

<pre><code> void derived :: read() {
     x=a;
     y=b;
     z=c;
 }
</code></pre>

<p>This actually puts garbage inside <code>x</code> <code>y</code> and <code>z</code>.
You can call <code>base::read()</code> inside <code>derived::read()</code> to initialize <code>a</code> <code>b</code> and <code>c</code></p>
",0
20521850,20521440,2,"<p>I am guessing that you tried to do something like the following: </p>

<pre><code>   #include&lt;iostream.h&gt;
    #include&lt;conio.h&gt;
    class base
    {
     public:
         int a;
         int b;
         virtual void read();
         virtual void display();
     protected:
         int c;
     };
    void base :: read()
    {
        cout&lt;&lt;""\nEnter values of a , b and c :"";
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
    }
    void base :: display()
    {    
        cout&lt;&lt;""\nValues of a,b and c :""&lt;&lt;a&lt;&lt;"" ""&lt;&lt;b&lt;&lt;"" ""&lt;&lt;c;
    }

    class derived : public base
    {
         int x;
     public:
         int y;
         virtual void read();
         virtual void display();
     protected:
         int z;
     };

     void derived :: read()
     {
         base::read()
         x=a;
         y=b;
         z=c;
     }

     void derived :: display()
     {
         base::display()
         cout&lt;&lt;""\nValue of A :""&lt;&lt;a&lt;&lt;"" ""&lt;&lt;x;
         cout&lt;&lt;""\nValue of B :""&lt;&lt;b&lt;&lt;"" ""&lt;&lt;y;
         cout&lt;&lt;""\nValue of C :""&lt;&lt;c&lt;&lt;"" ""&lt;&lt;z;
     }

     void main()
     {
         clrscr();
         base b; 

         cout&lt;&lt;""\nBase Class :"";

         b.read();
         b.display();
         derived d;
         cout&lt;&lt;""\nDerived Class :"";
         d.read();
         d.display();       

         getch();
     }   
</code></pre>

<p>Please note that to use polymorphism you should use the virtual keyword in order not to mask the function completly, however, that would be relevant in case of pointer and allocating to some base pointer an object of the derived type(s).</p>

<p>Also note that the way you implemented read will actually put garbage to xyz as abc are not read throug the read function of the base object, since no one ever calls it. So that is why you are getting random values there, instead of values entered in the console.</p>

<p>I suggest reading a bit about c++ polymorphism.
I find the resource below a good tutorial: <a href=""http://www.cplusplus.com/doc/tutorial/polymorphism/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/polymorphism/</a></p>

<p>I hope that this helps.</p>
",0
19316033,19315931,0,"<p>you can create a base class <code>Shape</code>, make both <code>Rectangle</code> and <code>Circle</code> inherit from that class,and make your array of type <code>Shape *</code>.</p>

<p>this array can hold pointers to  <code>Rectangle</code> and <code>Circle</code> objects because both are <code>Shape</code> objects.</p>
",3
19316066,19315931,-1,"<p>You can use inheritance for this purpose.</p>

<p>Have a base class Shape(preferably an abstract class with pure virtual methods like draw() etc.). Inherit Rectangle, Circle and other shapes from the Shape.</p>

<p>An array or a vector of Shape can hold instances of any objects that are inherited from the Shape class.</p>

<p>We need to use an array of pointer to Shape to have the polymorphism work properly.</p>
",1
19316129,19315931,2,"<p>You could return a vector of pointer which points to base objects out from <code>inst_obj</code> and pass it to <code>check_symbols()</code> function. Like this:</p>

<pre><code>// assume Shape is base type of Rectangle and Circle

 std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; inst_obj (int symbols)
 {
    std::vector&lt;std::shared_ptr&lt;Shape&gt;&gt; v;

   for (int i=0; i&lt;symbols ; i++) 
   {
     if (i&lt;10) 
     {
      v.push_back(std::unique_ptr&lt;Shape&gt;(new Rectangle (1,2,3)));
     }
     else 
     {
       v.push_back(std::unique_ptr&lt;Shape&gt;(new Circle (1,2,3,4)));
     }
     return v;
  }

void check_symbols(std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt;&amp; v) 
{
    for(auto it = v.begin(), it != v.end(); ++it)
    {
      // Check symbol objects, like symb_array[i].return_something
    }
} 
</code></pre>

<p>Usage:</p>

<pre><code>std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; v = inst_obj(43);
check_symbols(v);
</code></pre>
",0
20627003,20626927,1,"<p><code>LPCSTR</code> is not the string, it is just the pointer to the char array. When you set new version, the char array itself is changing. That's why you observer the change in <code>test2</code> variable immediately. If you want this string not to be changed, copy and save it in your internal buffer.</p>
",0
20627006,20626927,2,"<p>It's pretty easy, actually.  <code>toString</code> invokes undefined behavior by returning an array (<code>str</code>) that's allocated locally to the function and goes out of scope with the <code>return</code>:</p>

<pre><code>LPCSTR Neat::NCore::NApplicationVersion::toString()
{
    char str[16];
    memset(&amp;str, 0, sizeof(str));
    sprintf_s(str, sizeof(str), ""%i.%i.%i"", this-&gt;major, this-&gt;minor, this-&gt;build);
    return str;
}
</code></pre>

<p>In most common C++ implementations, <code>str</code> will be on the stack.  (The C++ standard does not require a unified concept of ""stack"" where all automatic variables live, but most common implementations work that way.)</p>

<p>So, subsequent functions that modify the stack will also modify the C-style string pointed to by the call to <code>toString()</code>.  The subsequent call to <code>n.ApplicationVersion()</code>, for example, would likely trash <code>str</code>.  Your second message box won't show as long as the string changed to anything other than ""0.0.0"", and it won't take much to corrupt the stack in that way.</p>

<hr>

<p>Based on your subsequent edit:  Making the string a member of your class will <em>somewhat</em> work.  Any call to <code>toString</code> will rewrite this string, affecting all callers that saved a pointer to this buffer. </p>

<p>Still, this is certainly much safer than saving the string on the stack.  Furthermore, as long as only <code>toString</code> writes to this buffer, you have well defined rules for when that string is valid.</p>
",5
20650440,20649390,17,"<pre><code>char *output = NULL;
output = strstr (a,b);
if(output) {
    printf(""String Found"");
}
</code></pre>
",2
20650524,20649390,4,"<p>This should work:</p>

<pre><code>char a[]=""hello world!"";
char b[]=""el"";
//find substring b[] in a[]
string str(a);
string substr(b);

found = str.find(substr);
</code></pre>
",0
20182027,20182001,5,"<p><a href=""http://en.cppreference.com/w/cpp/container/map/find"" rel=""noreferrer""><code>find</code></a> give you a <code>std::map&lt;&gt;::iterator</code> that holds/point to <code>std::pair&lt;&gt;</code>. The iterator can be saved and reused (given that you did not do anything to invalidate it such as <code>erase</code>).</p>

<pre><code>// i don't know the type of rtstructure so i use auto
// you can replace it to the correct type if C++11 is not available
auto it = rtstructure.find(varName); 
if(it != rtstructure.end()) {
    rtdef = it-&gt;second;
}
</code></pre>
",0
20192005,20190727,4,"<p>It's strongly compiler depended and you should measure it in your code. A quick and simple observation in my machine (32-bit MinGW/gcc 4.9) shows the <code>+</code> itself is equal for both cases, however the integral operation seems a little better.</p>

<p>Adding two <code>double</code>:</p>

<pre><code>!        double d = 0.2;
fldl   0x409070
fstpl  -0x10(%ebp)

!        double y = 1.0;
fld1   
fstpl  -0x18(%ebp)

!        double z = d + y;
fldl   -0x10(%ebp)
faddl  -0x18(%ebp)
fstpl  -0x20(%ebp)
</code></pre>

<p>Adding two <code>int</code>:</p>

<pre><code>!        double d = 0.2;
fldl   0x409070
fstpl  -0x28(%ebp)

!        int y = 1;
movl   $0x1,-0x2c(%ebp)

!        double z = d + y;
fildl  -0x2c(%ebp)
faddl  -0x28(%ebp)
fstpl  -0x38(%ebp)
</code></pre>

<p>Both use <code>faddl</code> to add, but compiler uses better instruction to load the integer before adding. So, there is no penalty to add an integer to a double (and it may be even better rather than adding two doubles).</p>

<p>In your application, profiling is the best way to find out that which one is better.</p>
",0
20192093,20190727,2,"<p>Another thing to consider is compiler optimizations.</p>

<p>Floating point units tend to have their own registers.  These in some cases may even have greater precision than typical operands (for instance, 80-bit temporary reals;) however, see the comments as this can vary a lot.</p>

<p>I would expect it is cheaper to operate on values already loaded into the FPU, and the compiler should know this.  As such, it may hoist the promotion of your constant value out of the loop and keep the value loaded in the FPU, in which case the difference would be negligible on large vectors.</p>

<p>In any event, I would hope that if the <code>int</code> to <code>double</code> conversion is expensive on a given platform, a respectable compiler would not perform it redundantly.  As such, what I'd probably do is make it a template method so you can accept whatever type &amp; precision the constant data naturally comes from; this permits the compiler to ""do the right thing"" for the particular platform in any given situation.</p>

<p>With that said, compilers do vary quite a bit in their optimization strategies and platforms vary in their features &amp; performance characteristics, so if you're trying to squeeze out every last microsecond, you should do profiling for your platform(s) of interest.</p>
",4
20411937,20361867,0,"<p>Here's some updated code. Since you never really use <code>strPath</code> except as <code>strPath.c_str()</code>, there's not really any reason to wrap it in a <code>string</code>. Sure <code>string</code> is better for general use if you are going to be parsing or splitting or adding to it or whatever, but in this case, it's really not necessary. Also got rid of <code>argument</code>, since it doesn't seem necessary. Furthermore, you were calling <code>access()</code> questionably, with a second argument of zero. <code>F_OK</code> happens to be defined as zero on Linux systems, but I'm not sure it's guaranteed to be so everywhere. In addition, since you're using <code>_tmain()</code>, it's probably wise to use <code>_TCHAR* argv[]</code> as well, especially if you're building a Unicode or other wide-char project (although I'm far from authoritative on that, having ditched M$ long ago...). And if that's the case, I don't know if <code>access()</code>, <code>stat()</code>, etc. are appropriately defined for non-<code>char</code> types, but I would hope they are... Otherwise you need to convert the strings first...</p>

<pre><code>#include ""stdafx.h""
#include &lt;io.h&gt;   //For access
#include &lt;sys/types.h&gt;  //For stat().
#include &lt;sys/stat.h&gt;  //For stat(). 
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;direct.h&gt;
#include &lt;fstream&gt;
#include &lt;stdio.h&gt;

using namespace std;

int _tmain(int argc, _TCHAR* argv[]){

    // make sure we have at least argv[1] and that it is not NULL
    // (shouldn't happen in theory, but paranoia is good sometimes),
    // and that it does not point to an empty string
    if ( (argc &lt; 2) || (argv[1] == NULL) || (*(argv[1]) == '\0') )
      return -1;            // probably should print an error message here

    if ( !access( argv[1], F_OK ) ){

        struct stat status;
        stat( argv[1], &amp;status );

        if ( status.st_mode &amp; S_IFDIR ){
            cout &lt;&lt; argv[1] &lt;&lt; ""can be accessed and is a directory."" &lt;&lt; endl;  
            getc(stdin);
        }
    }
    else{
        mkdir( ""C:\\Program Files\\EZshred\\"" );      
        getc( stdin );
    }

    return 0;
}
</code></pre>
",1
20422891,20422848,3,"<p>Don't forget to close your <code>Knight</code> class declaration with a semicolon!</p>

<p>(Out of interest this is required in C++, not in Java).</p>
",0
20422911,20422848,2,"<p>In <code>Knight.h</code> the class definition is missing a <code>;</code>:</p>

<pre><code>class Knight {
    ...
};
</code></pre>

<p>Without the <code>;</code> the following token is interpreted as a symbol. In your code (<code>Knight.cpp</code>) it is the code immediately following the include directive. <code>void</code> is not a legal symbol, and this triggers the error.</p>
",0
20422916,20422848,3,"<p>You do need include guards.</p>

<p><strong>Edit</strong></p>

<p>Assuming the edit to the question, which gives include guards actually uses <code>armor</code> as follows,</p>

<pre><code>#ifdenf armor //&lt;&lt;--- ARE YOU POSTING THE ACTUAL CODE... try #ifndef
#define armor
//...
#endif
</code></pre>

<p>You then try to use <code>armor</code> as a variable name. Try</p>

<pre><code>#ifndef ARMOR_INCLUDED
#define ARMOR_INCLUDED
//...
#endif
</code></pre>

<p>instead</p>

<p><strong>End Edit</strong></p>

<p>Also, class <code>Knight</code> needs a trailing semicolon.</p>

<pre><code>class Knight {
private:
    Armor* m_armor;
    string m_name;
    int m_strength;

public:
    Knight(string name, int strength);

    void setArmor(Armor* armor);
}; //&lt;----------
</code></pre>

<p>As a general rule, if you get a compile error about syntax on one line, which looks OK, work backwards to see if something earlier is causing it.</p>
",3
20423100,20422848,4,"<pre><code>#define armor
</code></pre>

<p>Now you can't use the name <code>armor</code> in any source file that includes this header. The preprocessor will remove it.</p>

<pre><code>m_armor = armor; // error occurred
</code></pre>

<p>Whoops! The preprocessor turns that into</p>

<pre><code>m_armor = ;
</code></pre>

<p>I suggest using the convention of <code>ALL_CAPS</code> for macros, and not for anything else, so that they can't stomp over regular code. You might also consider <code>#pragma once</code> rather than a macro-based include guard, although that's not guaranteed to be portable.</p>
",3
20525486,20525423,4,"<p>You have not allocated space to write into -- that's why you're having a problem.</p>

<p>You've created <code>s1</code> and pointed it at some read-only memory, and when you try to append, you're then writing into that region.</p>

<p>You could instead set <code>p</code> to point to some memory that a) you own (have the right to write into, not just the physical ability) and b) is large enough for the full allocation.</p>

<p>Your easiest way to do this will be instead to use <code>std::string</code> -- after all, you say you're using C++.</p>
",0
20525488,20525423,0,"<pre><code>char *s1 = ""Hello"";
char *s2 = ""World"";
</code></pre>

<p>When you create s1 and s2 like this, you can't write:</p>

<pre><code>*s2 = anything;
</code></pre>

<p>Because of string pooling <code>s1</code> and <code>s2</code> are immutable by default.</p>
",0
20525800,20525423,0,"<pre><code>char *s1 = ""Hello"";
</code></pre>

<p>Here, <code>""Hello""</code> is a string literal, which is by definition <code>const</code>.  <code>s1</code> is a pointer to the first element of that string literal, and so points to read-only memory.  You cannot change read-only memory, and so you can't change what is pointed to by<code>s1</code>.  It would have been much more accrate and better if you had declared this as:</p>

<pre><code>const char *s1 = ""Hello"";
</code></pre>

<p>In C++03, there is a special rule which allows assigning the pointer to a string literal to a non-<code>const</code> pointer.  However that rule was removed in C++11, and your code is actually illegal now.</p>

<p>This is a good thing because even in C++03 there is nothing you can (legally) do with <code>s1</code> that you couldn't do if it was <code>const</code>.</p>

<p>Later, you do something patently wrong:</p>

<pre><code> while(*s2 != '\0')
       {
           *s1 = *s2;  // this line creating problem
           s1++;
           s2++;
       }
</code></pre>

<p>I'm not surprised that line of code is causing a problem for you -- it evokes Undefined Behavior because you are modifying read-only memory.</p>

<p>It looks like what you're really trying to do is create a string which is initialized with some known (unchanging) value, and then later modify the string.  In order to do that, you must make a copy of the string literal.  Easiest way to do that is to use <code>std::string</code>:</p>

<pre><code>std::string s1 = ""Hello"";
</code></pre>

<p>Here <code>""Hello""</code> is still a string literal, but <code>s1</code> is being constructed off of it.  <code>s1</code> is completely separate from the string literal, and now you can modify it however you wish.</p>
",0
19209559,19209535,2,"<p>Yes, the posted code invokes undefined behavior.  Don't do that.</p>

<p>If you want to see a really insane way that some people accomplish this unsavory goal, here you go: <a href=""https://stackoverflow.com/questions/12993219/access-private-member-using-template-trick"">access private member using template trick</a></p>

<p>But really, don't do that.</p>

<p>P.S.: never use C-style casts in C++.  Use static_cast, dynamic_cast, reinterpret_cast, and const_cast, as appropriate.  C-style casts are needlessly unsafe.</p>
",3
19209874,19209535,5,"<p>Despite your classes being layout compatible (see below), your code exhibits undefined behavior due to the fact that such pointer casts are prohibited by <a href=""https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule"">the C++ strict aliasing rules</a><sup>1</sup>.</p>

<p>But: replacing the casts with a <code>union</code> makes the code standard-compliant; this is actually guaranteed to work in C++11:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

class Point {

private:

    int x;
    int y;

public:

    Point(int x, int y) {
        this-&gt;x = x;
        this-&gt;y = y;
    }

    void Print() {
        cout &lt;&lt; ""("" &lt;&lt; x &lt;&lt; "", "" &lt;&lt; y &lt;&lt; "")"" &lt;&lt; endl;
    }

};

struct PointHack {
    int x;
    int y;
};

union pu
{
    Point p;
    PointHack ph;
    pu(int x, int y) : p(x, y) {}
};

int main() {
    pu u(4,5);
    u.p.Print();
    u.ph.x=1;
    u.ph.y=2;
    u.p.Print();
    return 0;
}
</code></pre>

<p>This comes from the fact that <code>Point</code> and <code>PointHack</code> are standard-layout classes<sup>2</sup> (C++11, 9 ?7), and share a ""common initial subsequence"" (9.2, ?20); as such, if they both are stored in the same union (here <code>pu</code>) it's permitted to ""inspect the common initial part of any of them""<sup>3</sup>.</p>

<p>Still, this answer is mostly an exercise of style; don't exploit such tricks unless you are really forced to. C++ provides better means to access private members if necessary without brutally breaking the encapsulation - you have getters/setters, protected inheritance, friend classes, ... And in general, if you access private class members in ways not intended by your target class, you are potentially violating the assumptions of that class about how its data is modified, which can lead to erratic behavior of the code of its methods.</p>

<hr>

<p><em>Notes:</em></p>

<ol>
<li>In C++ you can't have two pointers of unrelated types pointing to the same object; this restriction is mostly used to help optimizers with assumptions about aliasing.</li>
<li>Notice that the requirements for this are quite stringent; typically most classes that aren't basically C structs don't qualify for this. Even having different access qualifiers can break the magic.</li>
<li>The idea is that assigning to <code>ph</code> makes it the ""active object"" of the <code>union</code>, and then <code>p.Print()</code> is the one ""inspecting"" the ""inactive"" object.</li>
</ol>
",0
20418041,20417797,2,"<p>Your code is structured wrongly, you are using for loops for something they are not designed for.</p>

<p>Use a switch statement inside a do ... while loop and a boolean variable that tells you when to quit. Like this</p>

<pre><code>bool quit = false;
do
{
    // menu code
    cin&gt;&gt;opt;
    switch (opt)
    {
    case 'a':
        // adding code
        break;
    case 's':
        // substracting code
        break;
    ...
    case 'q':
        quit = true;
        break;
    default:
        cout&lt;&lt;""The option is incorrect. PLEASE enter the correct option"";
        cout&lt;&lt;endl;
        break;
    }
} while (!quit);
out &lt;&lt;""Press any key to QUIT"" &lt;&lt; endl;
getch ();
return 0;
</code></pre>

<p>You should understand that certain C++ contructs are designed for certain situations. A switch statement is designed for when you have a choice between multiple alternatives, that's what your program needs so that's what you should use. A for loop is designed mainly for when you want to repleat something a fixed number of times, that's <strong>not</strong> what your program needs so you shouldn't use a for loop. A do ... while loop is designed for situations when you want to loop a varying number of times (but at least once). That's exactly what your program needs so you should use a do ... while loop.</p>

<p><strong>EDIT</strong></p>

<p>Apparently you are not allowed to use a switch statement. Here's the above code using if ... else if ... else instead of switch</p>

<pre><code>bool quit = false;
do
{
    // menu code
    cin&gt;&gt;opt;
    if (opt == 'a')
    {
        // adding code
    }
    else if (opt == 's')
    {
        // substracting code
    }
    ...
    else if (opt == 'q')
    {
        quit = true;
    }
    else
    {
        cout&lt;&lt;""The option is incorrect. PLEASE enter the correct option"";
        cout&lt;&lt;endl;
    }
} while (!quit);
out &lt;&lt;""Press any key to QUIT"" &lt;&lt; endl;
getch ();
return 0;
</code></pre>
",2
19315993,19315645,0,"<p>Out of bounds reached when i=blocks.size()-1 for : 
code2 = blocks[  i+1 ].substr(0,3); </p>

<p>Also this is an endless loop :
 while(code2 == ""*11"" ) {</p>

<pre><code>                section.push_back( blocks[ index ] );
                index++; }
</code></pre>
",0
19315680,19315645,2,"<p>Out of bound indexing where <code>0 &lt;= i &lt; size</code>:</p>

<pre><code> blocks [i+1]
</code></pre>

<p><code>i+1</code> exceeds the valid index where <code>i=blocks.size()-1</code>.</p>

<p>Moreover, this loop never finishes:</p>

<pre><code>while(code2 == ""*11"" ) {
   section.push_back( blocks[ index ] );
   index++;
}
</code></pre>
",2
19315720,19315645,3,"<pre><code>&gt; while(code2 == ""*11"" ) {
&gt;     section.push_back( blocks[ index ] );
&gt;     index++; }
</code></pre>

<p>that can never be passed ...</p>

<pre><code>i = index - 1;
</code></pre>

<p>could end in endless loop</p>
",2
19959274,19959081,0,"<p>There are two possibilities. Either to write a recursive function or rebuild your list in the reverse order. That is before printing the list you either create a new list on the base pf existent or rebuild the original list itself.</p>
",1
19959169,19959081,0,"<p>If you can write a recursive function to traverse the list in proper order, printing it in reverse order is a snap.</p>
",5
19959304,19959081,0,"<p>You already have a loop that decrements i  from length to 0.  Based on i, you can traverse the list and print the node that you reached.  Fine tune for off by 1 errors so that you actually print from last to first and don't print when the list is empty.</p>
",3
19959224,19959081,3,"<pre><code>void nodeType::PrintListReverse()
{
  if (next)
     next-&gt;PrintListReverse();
  std::cout &lt;&lt; info &lt;&lt; std::endl;
}
</code></pre>

<p>Recursively find the end of the list, printing on return.</p>

<p>(I'm only enabling you because I'm bored)</p>

<p>Alternatively:</p>

<pre><code>void linkedListType::PrintList()
{
    std::vector&lt;int&gt; info(length);
    nodeType* curNode = first;
    for (int i = 0; curNode != NULL; i++, curNode = curNode-&gt;next)
    {
        info[i] = curNode-&gt;info;
    }
    for (int i = length-1; i &gt;=0; i--)
    {
        std::cout &lt;&lt; info[i] &lt;&lt; std::endl;
    }
}
</code></pre>
",1
19498853,19497917,0,"<p>I think you need to flush the screen. Once you have flushed and closed the stream. The next time you run an application it should open the file. </p>

<pre><code>e.g.
inFile.flush();
inFile.close();
</code></pre>
",0
19498017,19497917,0,"<p>Check that your file exist. If it does, check whether you have the correct path when you open it (check if your .txt files are in the same directory as your .exe file, or specify the full path in your code). If yes, check if the files are read-only.</p>
",4
19498072,19497917,2,"<p>When declaring an input file use 
            ifstream inFile;
Also make sure the input file is in the same folder as your .exe</p>

<p>Edit: <a href=""http://www.cplusplus.com/doc/tutorial/files/"" rel=""nofollow"">http://www.cplusplus.com/doc/tutorial/files/</a> also, this link should help with working with files.</p>

<p>Edit 2: I already posted this in a comment, but I'll just add it to the official answer: ""Change your while loop as well. Instead of the if test, use while(inFile.is_open()) and then use your getline statement inside the loop. Because right now your code reads like while get this line from the file is true cout line. So it might not even be doing the while loop.""</p>
",2
19498090,19497917,1,"<p>I don't think you should close the file inside the while loop. Otherwise, your file gets closed after only the first line is read in. Move the close statement outside the loop. Same for the second block.</p>

<pre><code>if (inFile.is_open())
{
    //Read lines from file to console
    while (getline(inFile, line))
    {
        cout &lt;&lt; line &lt;&lt; endl;        
    }
    inFile.close();
}    
else 
    cout &lt;&lt; ""joke.txt file cannot be open.\n"";
</code></pre>
",2
19498110,19497917,0,"<p>use</p>

<pre><code>if(!infile)
{
cout&lt;&lt;""cannot open file"";
}
</code></pre>
",1
20756180,20755661,1,"<p>The code is perfectly fine. The issue is with the compiler. This generally happens because of the misconfiguration of linking files (DLL's). It is recommended that you uninstall the current installation and re-install the software by following the installation instructions. If you are looking for bundled alternatives then you can try Code::Blocks - <a href=""http://www.codeblocks.org/"" rel=""nofollow"">http://www.codeblocks.org/</a>. </p>
",1
19319571,19319075,1,"<p>As Angew said, the return statements are incorrect and causing you to exit your main. You want to replace this by a <strong>break;</strong> to exit the loop but not the function.</p>
",5
19321090,19319075,0,"<p>I have not spent effort in trying to understand your algorithm, but at first glance it looks more complicated than it should be.</p>

<p>From my understanding of the problem, there are 3 possibilities:</p>

<ul>
<li>the totals of the upper halves and the lower halves are already even (so nothing needs to be done)</li>
<li>the totals of the upper halves and the lower halves cannot be made even (so no solution exists)</li>
<li>just one Domino needs to be rotated to get the totals of the upper halves and the lower halves to be even (so the time needed is 1 second)</li>
</ul>

<p>I base this on the fact that adding only even numbers always gives an even result, and adding an even number of odd numbers also always gives an even result.</p>

<p>Based on this, instead of having a 2-dimensional array like in your code, I would maintain 2 distinct arrays - one for the upper half numbers and the other for the lower half numbers. In addition, I would write the following two helper functions:</p>

<ol>
<li>oddNumCount - takes an array as input; simply returns the number of odd numbers in the array.</li>
<li>oddAndEvenTileExists - takes 2 arrays as input; returns the index of the first tile with an odd+even number combination, -1 if no such tile exists.</li>
</ol>

<p>Then the meat of my algorithm would be:</p>

<pre><code>if (((oddNumCount(upper_half_array) % 2) == 0) &amp;&amp; ((oddNumCount(lower_half_array) % 2) == 0))
{
    // nothing needs to be done

    result = 0;
}
else if (((oddNumCount(upper_half_array) - oddNumCount(lower_half_array)) % 2) == 0)
{
    // The difference between the number of odd numbers in the two halves is even, which means a solution may exist.
    // A solution really exists only if there exists a tile in which one number is even and the other is odd.

    result = (oddAndEvenTileExists(upper_half_array, lower_half_array) &gt;= 0) ? 1 : -1;
}
else
{
    // no solution exists.

    result = -1;
}
</code></pre>

<p>If you wanted to point out exactly which tile needs to be rotated, then you can save the index that ""oddAndEvenTileExists"" function returns.</p>

<p>You can write the actual code yourself to test if this works. Even if it doesn't, you would have written some code that hopefully takes you a little above ""total beginner"".</p>
",2
19375227,19375018,0,"<p>Try the articles found at: </p>

<ul>
<li><p><a href=""http://www.codeguru.com/cpp/g-m/gdi/article.php/c3693/Rotate-a-Bitmap-at-Any-Angle-Without-GetPixelSetPixel.htm"" rel=""nofollow"">http://www.codeguru.com/cpp/g-m/gdi/article.php/c3693/Rotate-a-Bitmap-at-Any-Angle-Without-GetPixelSetPixel.htm</a> </p></li>
<li><p><a href=""http://www.codeguru.com/cpp/g-m/bitmap/specialeffects/article.php/c1743/Rotate-a-bitmap-image.htm"" rel=""nofollow"">http://www.codeguru.com/cpp/g-m/bitmap/specialeffects/article.php/c1743/Rotate-a-bitmap-image.htm</a></p></li>
</ul>

<p>and also a little more googleing might help.</p>
",0
19375345,19375048,0,"<p>It may not be the optimal program out there, but this should work:</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main()
{
int n;
int i;
int x;

cout &lt;&lt; ""Enter a number greater then 2: \n"";
cin &gt;&gt; n;

while (n&lt;=2)
{
 cout &lt;&lt; ""Enter a number greater then 2: \n"";
 cin &gt;&gt; n;
}

for (x=n; x&gt;=2; --x)
{
  for (i=2; i&lt;x; ++i)
  { 
    bool prime = true;
    for (j=2; j&lt;i/2; ++j)
    { 
       if (i%j==0)
       {
         prime = false;
         break;
       } 
    }
    if (prime)
    {
       cout &lt;&lt; j &lt;&lt; "" Prime.\n"";
    }
  }
}
return 0;
}
</code></pre>
",0
19375352,19375048,0,"<p>There are two easy means to go faster: first there is no need to test potential divisors that are too big (as pointed out by arne), and second, there is no need to test even numbers except 2.</p>

<p>Something like this:</p>

<pre><code>#include &lt;cassert&gt;
bool is_prime(unsigned n)
{
  if (n == 2)
    return true;
  if (n &lt;= 1
      || n % 2 == 0)
    return false;
  for (int d = 3; d * d &lt; n; ++d)
    if (n % d == 0)
      return false;
  return true;
}

int main()
{
  assert(!is_prime(0));
  assert(!is_prime(1));
  assert(is_prime(2));
  assert(is_prime(3));
  assert(!is_prime(4));
  assert(is_prime(5));
  assert(!is_prime(6));

  assert(!is_prime(256));
  assert(is_prime(257));
}
</code></pre>

<p>Of course, even faster is building a table of primes, and using this table as potential divisors, instead of every odd number.  Makes sense if you have several numbers to check.</p>
",0
19375407,19375048,0,"<p>Please, say, why it let say you it does not work? Among others I get this output.</p>

<pre><code>Enter a number greater then 2: 
100
97 Prime.
89 Prime.
83 Prime.
79 Prime.
73 Prime.
71 Prime.
67 Prime.
61 Prime.
59 Prime.
53 Prime.
47 Prime.
43 Prime.
41 Prime.
37 Prime.
31 Prime.
29 Prime.
23 Prime.
19 Prime.
17 Prime.
13 Prime.
11 Prime.
7 Prime.
5 Prime.
3 Prime.
2 Prime.
</code></pre>

<p>But as <code>int n;</code> leaves n uninitialized, the while loop might not be entered.</p>
",0
19375423,19375048,-1,"<p>I think the Answer 1 function checkprime(int number) can improved but purely on preformance basis, consider the fact that prime numbers cannot be even.So if add an extra check to see if (number % 2 == 0) will reduce a lot of iteration of the for loop, and for the remaining i think iterating the loop from 2 to 9 is enough rather than 2 to n. Too many iterations will slow you down on larger numbers.</p>
",0
19375145,19375048,0,"<p>I didn't actually used your code because of indentication it was little bit of hard to read. But I wrote a new method for you. I suggest always divide your code into methods to make it more managable. You can call this in your main method</p>

<pre><code>bool checkPrime(int number)
{   // input:   num an integer &gt; 1
    // Returns: true if num is prime
    //          false otherwise.

    int i;

    for (i=2; i&lt;number; i++)
    {
        if (number % i == 0)
        {
            return false;
        }
    }

    return true;    
}
</code></pre>

<p>And here is how can you call this method in the main:</p>

<p>int main()
{   </p>

<pre><code>int number;

cout &lt;&lt; ""Enter an integer (&gt;1): "";
cin &gt;&gt; number;

if (checkPrime(number))
{
    cout &lt;&lt; number &lt;&lt; "" is prime."" &lt;&lt; endl;
}
else
{
    cout &lt;&lt; number &lt;&lt; "" is not prime."" &lt;&lt; endl;
}

// I think this is more convention than anything.
return 0;
</code></pre>

<p>}</p>
",1
20518901,20518871,2,"<p>You can use <code>realloc()</code>, if your array is allocated dynamically(via <code>malloc/calloc/realloc</code>). If you have static array, you can't resize it.If you have allocated with new:</p>

<pre><code>int* Copy = new int[newSize];
std::copy(oldCopy,oldCopy+size,Copy);
</code></pre>

<p>But the best way would be to use <code>std::vector&lt;type&gt;</code> from c++ standard library</p>
",2
20518930,20518871,4,"<p>In C++ it is best to use the STL <a href=""http://www.cplusplus.com/reference/vector/vector/"" rel=""nofollow""><code>std::vector</code></a> class for this kind of thing.  Either that, or a <a href=""http://www.cplusplus.com/reference/string/string/"" rel=""nofollow""><code>std::string</code></a>.</p>
",0
20518943,20518871,5,"<p>No, you can't... <a href=""http://www.cplusplus.com/reference/cstdlib/realloc/"" rel=""nofollow""><code>realloc()</code></a> can only be used with <code>malloc()</code>/<code>free()</code></p>

<p>Best call for a <code>new[]</code> allocated array is to create a new one and then <code>memcpy()</code> the data from one to another.</p>

<p>Better way - use an <a href=""http://www.cplusplus.com/reference/vector/vector/"" rel=""nofollow""><code>std::vector</code></a> or <a href=""http://www.cplusplus.com/reference/string/string/"" rel=""nofollow""><code>std::string</code></a> instead of array if you know you'll need resizing. Internally they're pretty much the same array.</p>
",6
20518975,20518871,2,"<blockquote>
  <p>I have an array of characters allocated with new and i want to modify the size of the array.</p>
</blockquote>

<p>You can't resize an array, you can only allocate a new, larger one, move the contents to the new array, and delete the old one.</p>

<blockquote>
  <p>Can i use <code>realloc</code> function for that?</p>
</blockquote>

<p>If you used <code>malloc</code> to allocate the original array, yes. But that's usually a bad idea in C++, where you usually want to deal with arrays of non-trivial objects not raw memory.</p>

<blockquote>
  <p>What is the best way to do so?</p>
</blockquote>

<p>Use <code>std::string</code> (or perhaps <code>std::vector&lt;char&gt;</code>) to manage a dynamic array of characters automatically. These also have the advantage of using <a href=""http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization"" rel=""nofollow"">RAII</a> to reduce the risk of memory leaks and other memory management errors.</p>
",0
20519193,20518871,0,"<p>As was said by others, you cannot resize the array that was allocated per se, but you can create a larger one, copy the content of the first array to the second and delete the first one.</p>

<p>Here's an example, using std::copy().</p>

<pre><code>int main(int argc, char** argv) {
    int* arr = new int[5];
    arr[0] = 1;
    arr[1] = 2;
    arr[2] = 3;
    arr[3] = 4;
    arr[4] = 5;
    int* tmp = new int[10];
    std::copy(arr, arr + 5, tmp);
    std::copy(arr, arr, tmp + 5);
    delete[] arr;
    arr = tmp;

    for(int i = 0; i &lt; 10; i++) {
        std::cout &lt;&lt; arr[i] &lt;&lt; ""\n"";
    }
    delete[] arr;
    std::cin.get();
    return 0;
}
</code></pre>

<p>This first creates an integer array and fills it. It then creates a larger array and fills it with the content of the first array twice and display that new larger array.</p>

<p>The principle is the same for an array of characters.</p>

<p>As the others have mentionned, your best bet in C++ is to use the standard library. For a resizable array of characters, you should probably use std::string or a vector of strings, but it's a bit overkill in some situations.</p>
",0
19441229,19441151,0,"<p>You can't use <code>p</code> because <code>p</code> is not in scope at the point you call the function - in your code, <code>p</code> is local to <code>a()</code>. </p>

<p>You could use <code>p</code> if you did something like:</p>

<pre><code>int a(int p){
    return ++p;
};

int main(void) {
    int p = 4;
    int p_plus_one = a(p);
    return 0;
};
</code></pre>

<p>because they're both local to their own scopes, and don't collide.</p>
",8
19441266,19441151,0,"<p>there is nothing like you need to use a new name for passing the parameters into the function</p>

<p>you can pass any <code>integer</code> variable of your choice into the function <code>a()</code></p>

<p><strong>Example:</strong></p>

<p>if you have a variable <code>p</code> declared this way , you can pass it also :</p>

<pre><code>int main(){
int p = 50 ; //some integer value (it's necessary that the variable should be assigned a value)
a(p);
return 0;
};
</code></pre>

<p>or else if you have a variable <code>time</code> declared this way , you can pass it also :</p>

<pre><code>int main(){
int time = 60 ; //some integer value (it's necessary that the variable should be assigned a value)
a(time);
return 0;
};
</code></pre>
",3
20754313,20754285,2,"<p>If you're looking for a way to map a two dimensional array onto a one dimensional space, then try...</p>

<pre><code>int sizes[width*height];
void setPoint(int x, int y, int val) {
  sizes[x*width + y] = val;
}
</code></pre>

<p>Notably the <code>x*width + y</code> indexing will give you the appropriate element in the one dimensional array.</p>
",2
20754470,20754285,1,"<p>Unless it is homework just download boost and use <a href=""http://www.boost.org/doc/libs/1_55_0/libs/numeric/ublas/doc/matrix.htm"" rel=""nofollow"">Boost.Matrix</a>.</p>
",0
20754665,20754285,2,"<p>I assume that if you want to access your ""2D array"" as a one D matrix, you expect that as you increment your index by 1, you access the next element in the array (and will automatically go to the next line when you run off the edge). The right way to do this is by changing the way you allocate the array.  I'll try to show how this is done - this is just C, not C++. It's probably more appropriate since you were using <code>malloc</code> anyway. I am also thinking that you have a pretty serious error in your code, in that you are creating a <code>char *</code> pointer <code>p</code>, yet expect to use it in </p>

<pre><code>p[x][y];
</code></pre>

<p>for which you would need a <code>char **</code>, obviously.  Let's try to make code that would do what you want:</p>

<pre><code>int sizes[100];
//init sizes

unsigned char *p[100];  // without the == sign we create an array of 100 pointers
unsigned char *bigP;   // the master pointer

int totalLength = 0;

int ii;
for(ii=0; ii&lt;100; ii++) totalLength += sizes[ii];

bigP = malloc(sizeof(char) * totalLength);

int offset = 0;

// make pointers p point to places along this big memory block:
for(ii = 0; ii &lt; 100; ii++) {
  p[ii] = bigP + offset;
  offset += sizes[ii];
}
</code></pre>

<p>Now you can either address your array with</p>

<pre><code>p[x][y];
</code></pre>

<p>or with</p>

<pre><code>bigP[z];
</code></pre>

<p>where <code>z</code> can go from 0 to the maximum number of elements. Of course, in the process you don't know (when you are using the ""1D"" paradigm) in what row/column of the jagged array you are - you can't know that if you are truly in one dimension.</p>

<p>The key here is that the memory is allocated as a single contiguous block, and the pointers <code>p</code> are pointing to places in that block. This means you MUST NOT FREE <code>p</code>. You must only ever free <code>bigP</code>.</p>

<p>I hope this makes sense.</p>
",1
20628026,20625553,1,"<p>Well your main problem is to understand the difference between ++i (preincrement) and i++ (postincrement). ++i means that it quickly adds the value 1 in the next coming variable or lvalue. And the meaning of the i++ is that it will not add 1 to the previous lvalue or variable untill a sequence point comes. And remember that sequence points are ;  { }  &amp;&amp;  || etc.
e. if you have a code like this.</p>

<pre><code>int test=6;
cout&lt;&lt;(test++)&lt;&lt;endl;
cout&lt;&lt;test&lt;&lt;endl;
</code></pre>

<p>You will be thinking that it will print like this</p>

<pre><code>7
7
</code></pre>

<p>But it will not because it is a post increment. It will not add 1 to test untill a sequence point comes and the next sequence point is   ; . so it will print like this.</p>

<pre><code>6
7
</code></pre>

<p>Opposite is the case for preincrement. It will quickly add 1 to the variable (i.e lvalue otherwise it will give error ) and then display 7 without waiting for the sequence point.</p>
",0
20653483,20652939,0,"<p>I would suggest you read a book, or at least some documentation about this. Also, to understand how this kind of input works, it is required knowledge of oop concepts. As far as I noticed you do not have such a knowledge, I would suggest you stick for a while with procedural i/o functions from C, like fprintf. A google search will show many resources about them and they are pretty easy to understand, at least compared with those from C++, like the ones you are using. </p>

<p>To answer to your question, I will try to explain how to achive what you want. Note that this is a very simplified explanation and not 100% accurate.</p>

<p>Firstly, you need to open the file and create a i/o stream, using <code>ifstream</code> for input files or <code>ofstrsam</code> for output files:</p>

<p>ifstream f(""input_filename"");</p>

<p>ofstream g(""output_filename);</p>

<p>After you created f and/or g (they are not both requied. Also, f and g are just random names) you can use them in the same way you use cin and cout, in this case, as f is for input, it should be used like cin. </p>
",2
19498877,19497781,0,"<p>You forgot an opening brace to the <code>if()</code> statement. And as the comments pointed out, you should improve your formatting:</p>

<pre><code>for (int i = 0; i &lt; stockVector.size(); i++)
{
    if (stockVector[i].getItemID() == itemID)
    {
        stockVector[i].setItemID(input);
        duplicate = true;
        writeStockDatabase();
        //  cout &lt;&lt; ""Returning to main menu..."" &lt;&lt; endl &lt;&lt; endl;
    }
    if (!duplicate)
        break;
}
</code></pre>
",0
20753232,20753196,1,"<pre><code>string YN[100];
</code></pre>

<p>Here you are declaring an <em>array of 100 strings</em>. That's probably not what you wanted. Try:</p>

<pre><code>string YN;
</code></pre>

<p>The error message you got is referring to the line</p>

<pre><code>cin &gt;&gt; YN;
</code></pre>

<p>where, if <code>YN</code> is an array of 100 strings, the <code>&gt;&gt;</code> operator has no idea what you want to do. However, <code>&gt;&gt;</code> knows how to read <em>one</em> string.</p>
",1
19805538,19805505,1,"<p>I'm guessing it's this line</p>

<pre><code>this-&gt;_customBuffer = LE::CreateCustomBuffer((byte*)this-&gt;GetSize,(byte*)this-&gt;MakeCurrent);
</code></pre>

<p>The problem is that you pass <em>the member functions</em> as arguments, you don't actually <em>call</em> the <code>GetSize</code> or the <code>MakeCurrent</code> functions.</p>

<p>But it wouldn't work anyway, as neither of those functins return anything, but the arguments expected are of type <code>byte*</code>.</p>
",2
19886929,19886684,0,"<p>There are a few errors I found and corrected:</p>

<pre><code>bool BitPack::getVal(int indx) {
    assert (indx &gt;= 0);                 // Use &gt;=
    usi bA_indx_val = _booArr[indx/USI_BITS];
    bA_indx_val &gt;&gt;= (indx % USI_BITS);  // use indx here instead of bA_indx_val
    return ((bA_indx_val &amp; 1) ? true : false);
}
</code></pre>

<p>BitPack::setVal() also had some problems:</p>

<pre><code>void BitPack::setVal(int indx, bool valset) {
    assert (indx &gt;= 0);           // Use &gt;= 
    bool curval = getVal(indx);
    if ((curval == true) &amp;&amp; (valset == false)) {
        _booArr[indx/USI_BITS] &amp;= ~(1 &lt;&lt; (indx % USI_BITS));  // Use bitwise operators
    } else if ((curval == false) &amp;&amp; (valset == true)) {       // corrected this expression
        _booArr[indx/USI_BITS] |= (1 &lt;&lt; (indx % USI_BITS));   // Use bitwise operators
    }
}
</code></pre>

<p>Using -= and += to manipulate bits is a lot more difficult to get right than &amp;= and |= bitwise operators.</p>

<p>It seems to work with a few basic tests, but I didn't verify if it works for all bit positions.</p>
",2
19890334,19877468,0,"<p>Code::Blocks is an IDE that invokes the compiler, linker and other tools like the resource compiler. The output of these tools is catched and displayed in the output window. </p>

<p>When you don't get any output from one of these tools you should take the build log and start the tools with the parameter you found in the build log. This might help to isolate the problem.</p>

<p>Additionally you could change the parameters. e.g tell the compiler to stop after preprocessing to look at the preprocessed output. Similar options may exist for the resorce compiler.</p>
",0
19886877,19886771,0,"<p>My first idea is to find position of the first space and substring your string.</p>

<pre><code>std::string s(""1234 asdf zxcv 0987"");
std::cout &lt;&lt; s &lt;&lt; std::endl; // ""1234 asdf zxcv 0987""

size_t space_pos = s.find("" "");    
if (space_pos != std::string::npos) {
  s = s.substr(space_pos + 1);
}

std::cout &lt;&lt; s &lt;&lt; std::endl; // ""asdf zxcv 0987""
</code></pre>
",6
20527219,20527125,1,"<p>You <em>could</em>, but that serves a whole other purpose and in general is not a good thing to use anyway. What the book probably meant is to have shared data possibly of unknown size between some or all of the objects. If nothing, at least it probably wanted to discourage you from using <code>static</code> member variables.</p>
",0
20527246,20527125,0,"<p>The difference lies between whether you want to share the (member) object between <strong>all</strong> or <strong>some</strong> instances of your class.</p>

<p>Static members are shared between <strong>all</strong> instances, i.e. they are not coupled to instances at all. They exist once and only once (even if there is no instance at all).</p>

<p>But there are cases where you want to share the same member object between <strong>some</strong> instances. Think of a tree data structure. The parent node reference is a perfect example: All siblings share the same parent. The parent is not allocated <em>within</em> each sibling; that would mean it exists multiple times which would be wrong. We typically use pointers or references to point to the parent node indirectly; in C++11 (or for previous standards by using a library) we have weak or shared smart pointers for this.</p>
",0
20396910,20396883,4,"<p>Both <code>a[3][4]</code> and <code>a[4]</code> are <em>undefined behaviour</em>, since they attempt to access the respective array out of bounds.</p>
",0
20396969,20396883,3,"<p>You are accessing data out of your array-boundaries. </p>

<p>Your array has the size of 4*4 (16 elements) because of this declaration:</p>

<pre><code>a[4][4]={0};
</code></pre>

<p>When you want to access them, you have to regard the fact, that the lowest element in an array is <code>[0]</code> and not <code>[1]</code>. Therefor an array with the size of <code>[4]</code> has to be accessed over the indexes <code>0-3</code>.</p>

<p>The index 4 is out of your array range and will therefore lead towards <em>undefined behaviour</em>.</p>
",0
20402223,20396883,1,"<p>to reach the amount of a[4][4] you should call a[3][3]. numbers in computer are started from 0. [the number you you want] -1 = [the number you call]
&amp; you haven't define any amount for a[4][4] that you have called, so it's an amount of other parts of your memory...</p>
",0
20406318,20405614,2,"<p>The problem is that the elements in your <code>allNotPlayedLeagueMatches</code> vector might get moved around as you add additional elements.</p>

<p>Imagine the following scenario: You push an element to a vector. A fixed amount of memory is allocated for the vector storage and the object is placed there. You now take a pointer to that location in memory and store it somewhere.</p>

<p>Now you push additional elements into the vector until it runs out of capacity. So the vector allocates a bigger portion of memory, copies all the elements to that new memory location and then deallocates the original storage.</p>

<p>Problem is that your pointer still points to the old location and is now dangling. Dereferencing the pointer might still work as long as no one touches that memory, but you still have a bug here (dereferencing a dangling pointer is undefined behavior).</p>

<p>One way to get around this is to only take pointers to vector elements <em>after</em> all elements have been inserted. Of course that means your vector has to be 'frozen' at a certain moment in your program and no more changes are allowed to it. If that is not an option, consider using a different container that does not move objects around upon insertion (like a <code>std::list</code>).</p>
",0
20518057,20517800,2,"<p><a href=""http://ideone.com/uaTU3t"" rel=""nofollow"">Your code compiles and runs fine.</a></p>

<p>You are getting this error because your compiler is not compliant with <a href=""http://isocpp.org/std/the-standard"" rel=""nofollow"">the C++ standard</a>.</p>

<p><a href=""http://en.wikipedia.org/wiki/Turbo_C++"" rel=""nofollow"">Turbo C++</a> is horrendously outdated. </p>

<p>It is time to get a new, free, standard compliant compiler. <a href=""http://clang.llvm.org/"" rel=""nofollow"">Clang</a> for example.</p>

<hr>

<p>In answer to your second question, in the comments, <code>Gateway::foo</code> <em>hides</em> <code>Computer::foo</code>, which is why <code>Gateway::foo</code> is invoked for both <code>int</code> and <code>double</code> arguments. If this is not what you intended, you could alter your <code>struct</code> like so:</p>

<pre><code>struct Gateway : public Computer
{
    using Computer::foo;

    double foo(double d)
    {
        return 16.0;
    }
};
</code></pre>

<p><a href=""http://ideone.com/qVlIAq"" rel=""nofollow"">See it run!</a></p>
",0
20638470,20637921,0,"<p>You should be able to find the errors quite easily by looking at the code lines in the error messages. I'm having to guess, since the line numbers in the pile of code you've posted don't match, but:</p>

<p>First:</p>

<pre><code>main.cpp|33|error: expected primary-expression before 'char'
</code></pre>

<p><code>cVisitor&lt;char&gt;.visit</code> is gibberish. It should just be <code>cVisitor</code>.</p>

<p>Second:</p>

<pre><code>RootNode.cpp|27|error: conflicting return type specified 
</code></pre>

<p>You declared the virtual function with no return type:</p>

<pre><code>virtual void insert(KEY key, DATA data)=0;
</code></pre>

<p>then tried to override it with a function returning <code>bool</code>:</p>

<pre><code>bool insert(KEY key,DATA data)
</code></pre>

<p>Decide what the return type should be, and change all the declarations to match.</p>

<p>Third:</p>

<pre><code>BinaryNode.cpp|16|error: 'int BinaryNode::m_tKey' is private
</code></pre>

<p>You can only access private members of <code>BinaryNode</code> within that class and its friends. To access it from <code>RootNode</code>, either make it public, or provide a public accessor, or make <code>RootNode</code> a friend, depending on your views on encapsulation.</p>
",0
18941559,18941331,3,"<p>Members of a 'struct' are public by default, whereas members of a 'class' are private by default. If you do not specify public/private, all members in the 'struct' become private when you change it to 'class'.</p>

<p>Also did you inherit by private or public?</p>

<pre><code>class Subclass : public SuperClass {
public:
    // ...
};
</code></pre>
",2
20644961,20644798,1,"<p>Something like...</p>

<pre><code>/* parses 's' looking for a string between : and ] . If found, copies that
string into ipv4 and returns 1 */
int extract_ip4 (char *s, char *ipv4)
{
  char *p,*q;
  int i;

  q = strchr (s, ']');  /* search for ']' */
  if (!q)
    return 0;
  for (p=q;p!=s &amp;&amp; *p!=':';p--);  /* search for ':' backwards from ']' */
  if (p==s)
    return 0;
  strncpy (ipv4,p+1,q-p-1);  /* copy portion of string to ipv4 */
  ipv4[q-p-1]='\0';
  return 1;             /* address found and copied */
}
</code></pre>
",1
19967602,19967439,2,"<p>You can't construct your <code>std::vector&lt;std::string&gt;</code> at compile- or link-time. However, you can build it during static initialization. You can have a constructor of a global object call something on another global object. For example, you can do something like this:</p>

<pre><code>std::vector&lt;std::string&gt; mClassNameVector;
static bool dummy = []{ mClassNameVector.push_back(""some string""); return true; };
</code></pre>

<p>Once you move the registration to a different translation unit there are, however, two problems:</p>

<ol>
<li><p>The order of construction of global objects is undefined across translation units (within a translation unit it is simply top to bottom). To avoid issues with calling <code>push_back()</code> on the not, yet, constructed vector, you'd just wrap the object into a function:</p>

<pre><code>std::vector&lt;std::string&gt;&amp; mClassNameVector() {
    static std::vector&lt;std::string&gt; rc;
    return rc;
}
static bool dummy = []{ mClassNameVector().push_back(""some string""); return true; };
</code></pre>

<p>Since <code>static</code> function local variables are constructed when the function is called for the first time, this approach guarantees that the <code>mClassNameVector()</code> is constructed before it is accessed. Note, that the construction is not thread-safe in C++03. However, it is thread-safe in C++ (as of the 2011 revision): Only one thread will initialize <code>rc</code>. Any other thread entering the function while <code>rc</code> is being constructed will block.</p></li>
<li>The other potential problem is that your classes may not be referenced from anywhere and, as a result, the file containing the registration variable(s) may not be included into the final executable. Especially when implementing classes in a library and hoping that they would register themselves that tends to fail. Also, when the object files are build in a way which puts different entities into separate sections, there is a chance that the registration variables are not linked into the executable. Normally, it works explicitly linking the object files, however. Putting the object files into a library generally doesn't work unless each file contains a symbol which is referenced from somewhere.</li>
</ol>
",0
20193792,20193464,8,"<p>Quoting <code>man system</code>:</p>

<pre class=""lang-none prettyprint-override""><code>The value returned is -1 on  error  (e.g.   fork(2)  failed),  and  the
return  status  of the command otherwise.  This latter return status is
in the format specified in wait(2).  Thus, the exit code of the command
will  be  WEXITSTATUS(status).   In case /bin/sh could not be executed,
the exit status will be that of a command that does exit(127).
</code></pre>

<p>You need to use <code>WEXITSTATUS</code> to determine the exit code of the command.  Your <code>b.c</code> needs to look something like:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/wait.h&gt;
int main()
{
    int ret = system(""./a.out"");
    if (WEXITSTATUS(ret) == 0x10)
      return 0;
    else
      return 1;
}
</code></pre>
",2
20193729,20193464,2,"<p>If you're on a unix system, you should use fork execve and wait.</p>
<p>Here a sample code of your case:</p>
<pre><code>Program b.out:

int main()
{
    return 0x10;
}

pRogram a.out:

int main()
{
 int pbPid = 0;
 int returnValue;
 if ((pbPid = fork()) == 0) // Fork create a child process
 {
  // Only executed in child process
  char* arg[]; //argument to program b
  execv(&quot;pathto program b&quot;, arg);
  exit(34);
 }
 else
 {
  // Only executed in parent(original) process
  waitpid(pbPid, &amp;returnValue, 0);
 }
 returnValue = WEXITSTATUS(returnValue);
 // returnValue will be 34 if exeve failed
 return 0;
}
</code></pre>
",2
18447900,18447864,5,"<pre><code>Foo (int foo) : m_foo (foo) 
</code></pre>

<p>This is an <a href=""http://en.cppreference.com/w/cpp/language/initializer_list"" rel=""noreferrer"">initializer list</a>. It initialises <code>m_foo</code> to have the value <code>foo</code>.</p>
",0
18447907,18447864,-1,"<p><sup>I'm not sure that basic questions about C++ have their place here, however:</sup></p>

<pre><code>Foo (int foo) : m_foo (foo) 
</code></pre>

<p>means: define a constructor, and initialize the member variable <code>m_foo</code> with the <code>foo</code> formal argument.</p>
",0
18447919,18447864,2,"<p>You are initializing a integer variable using initializer list. Essentially before you enter the body of the constructor <code>m_foo</code> is assinged to <code>foo</code>.</p>
",0
18447936,18447864,1,"<p>It is an intializer.  It sets the value of the <code>m_foo</code> item by calling it's copy-constructor (instead of creating a temporary object and then calling the copy-constructor if you were to set it in the constructor like <code>m_foo = foo</code>).</p>
",0
20635275,20635182,1,"<p>Because the type T is only known when you instantiate the line class with some tipe, it's impossible for the compiler to know in the cpp file the generic type T that will be used later on so it can't compile those functions. That's why you first need to move the implementation of those function in the header file:</p>

<pre><code>template &lt;class T&gt;
class line {

public:
    T p1;

    void printPoint(void)
    {
        cout&lt;&lt;p1.z1&lt;&lt;endl;
    }
};
</code></pre>

<p>Now, the above implementation is for a generic type T, and now if you want it for special type , say <code>point1</code>:</p>

<pre><code> template &lt;&gt;
class line &lt;point1&gt; /*note this line changed*/ {

public:
    point1 p1;

    void printPoint(void)
    {
        cout&lt;&lt;p1.z0&lt;&lt;endl;
    }
};
</code></pre>
",0
18902929,18902855,1,"<p>You should make the overloaded operator return a reference. Then it should work.</p>

<pre><code>overload&amp; operator=(const overload&amp; o) {
  //do my assignment
  return *this;
}
</code></pre>
",0
18902930,18902855,9,"<p>You're modifying a local object and returning it by value. You need to modify <code>this</code> object
and return a reference to it:</p>

<pre><code>overload&amp; overload::operator=(const overload&amp; ov)
{
    this-&gt;x = ov.x;
    this-&gt;y = ov.y;
    return *this;
}
</code></pre>

<p>The error you get is because a temporary returned by a function cannot bind to a reference to non-const (hence the <code>const</code> in my example).</p>
",5
18903008,18902855,3,"<p>The issue is that your assignment operator take a reference to non-const and returns by value. Since the value returned from the first assignment is treated as a temporary, the compiler won't bind a reference to it, so the second assignment fails. The usual form of an overloaded assignment operator is:</p>

<pre><code>T &amp;T::operator=(T const &amp;other)
{
    ...
    return *this;
}
</code></pre>
",0
18762743,18761444,1,"<p>An enum might be the better idea.</p>

<pre><code>enum fields { title, aaa, bbb, ccc };

struct ANY {
  virtual int get(field f);
}; 

struct A1 : public ANY {
  virtual int get(field f) {
    switch (f) {
      case title : return 71;
      //
    }
  }
}; 
</code></pre>
",6
19882151,19882104,0,"<p>This is to avoid the inconsistent state or in more better word we would say to make exception safety.</p>

<p>You may also check this related Thread:- <a href=""https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom"">What is the copy-and-swap idiom?</a></p>

<p>As mentioned by GManNickG in the above thread:-</p>

<blockquote>
  <p>It works by using the copy-constructor's functionality to create a
  local copy of the data, then takes the copied data with a swap
  function, swapping the old data with the new data. The temporary copy
  then destructs, taking the old data with it. We are left with a copy
  of the new data.</p>
  
  <p>In order to use the copy-and-swap idiom, we need three things: a
  working copy-constructor, a working destructor (both are the basis of
  any wrapper, so should be complete anyway), and a swap function.</p>
  
  <p>A swap function is a non-throwing function that swaps two objects of a
  class, member for member. We might be tempted to use std::swap instead
  of providing our own, but this would be impossible; std::swap uses the
  copy-constructor and copy-assignment operator within its
  implementation, and we'd ultimately be trying to define the assignment
  operator in terms of itself!</p>
</blockquote>

<p>Also check <a href=""https://stackoverflow.com/questions/6687388/why-do-some-people-use-swap-for-move-assignments"">Why do some people use swap for move assignments?</a></p>
",0
19882212,19882104,1,"<p>In addition, to enable copy elision and (c++11) move semantics:</p>

<pre><code>Foo&amp; operator= (Foo other) { 
  std::swap(data, other.data); 
  return *this;
}
</code></pre>
",2
19882117,19882104,5,"<p>The swap trick is a fairly easy way to ensure <a href=""http://en.wikipedia.org/wiki/Exception_safety"" rel=""nofollow"">exception safety</a>.</p>

<p>If you do a field-by-field copy, and get exception in the middle, your object could end up in an inconsistent state (unless you take steps to address this, which could complicate things considerably).</p>

<p>With the swap-based implementation, if the <code>Foo temporary (other)</code> throws, your object remains unaltered from its original state.</p>
",2
20183740,20183650,0,"<p>If you're working under <strong>Windows</strong>, calling <code>system(""cls"")</code> before your output, should do what you need. If you're using <strong>Linux</strong>, calling <code>system(""clear"")</code> works.</p>

<p>Note that in order to use those functions, you need to <code>#include &lt;stdlib.h&gt;</code> (or <code>&lt;iostream&gt;</code> under most Windows IDE's).</p>
",0
20184414,20183650,0,"<p>A tricky method is use more than 25 NewLine(endl) to clear screen manually, before you print your data.</p>
",1
20508617,20508534,39,"<p>Just write it as you want it:</p>

<pre><code>std::string text = R""(part 1
part 2
part 3
part 4)"";
</code></pre>

<p>The other thing you didn't put in was the required pair of parentheses around the entire string.</p>

<p>Also keep in mind any leading spaces on the part 2-4 lines that you might put in to keep the code formatted are included, as well as a leading newline to get part 1 with the others, so it does make it rather ugly to see in the code sometimes.</p>

<p>An option that might be plausible for keeping things tidy, but still using raw string literals is to concatenate newlines:</p>

<pre><code>R""(part 1)"" ""\n"" 
R""(part 2)"" ""\n"" 
R""(part 3)"" ""\n"" 
R""(part 4)""
</code></pre>
",2
20508836,20508534,40,"<p>Note that raw string literals are delimited by <code>R""(</code> and <code>)""</code> (or you can add to the delimiter by adding characters between the quote and the parens if you need additional 'uniqueness').</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;ostream&gt;
#include &lt;string&gt;

int main () 
{
    // raw-string literal example with the literal made up of separate, concatenated literals
    std::string s = R""(abc)"" 
                    R""( followed by not a newline: \n)""
                    "" which is then followed by a non-raw literal that's concatenated \n with""
                    "" an embedded non-raw newline"";

    std::cout &lt;&lt; s &lt;&lt; std::endl;

    return 0;
}
</code></pre>
",3
20529508,20529369,2,"<p>At run-time it shouldn't perform any worse than a fully written-out version. That's because the preprocessor macro gets expanded before compilation takes place, so it has no effect on what the compiler sees.</p>

<p>The main argument against it would probably be readability. You have to know exactly what <code>FOR</code> is going to expand to, and be certain that it does what you expect. For a throwaway project or a prototype, that may not be an issue. In bigger or longer-term projects, you'd probably find it becoming a burden, especially when you're trying to debug the loop.</p>
",0
20529428,20529369,0,"<p>It is not more efficient. It does guarantee the same thing is being done the same way every time. Usually a function is used for this but the macro may be saving the function call and in some cases this would be more efficient.</p>

<p>Why not always use the macro? Because you probably do not always need the i64 cast which is why the for loop as a general construct exists.</p>
",0
20529737,20529369,0,"<p>I personally avoid macros, unless I really can't do without them.</p>

<p>From <em>Google C++ Style Guide</em> <br> <a href=""http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Preprocessor_Macros"" rel=""nofollow"">http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Preprocessor_Macros</a> : </p>

<blockquote>
  <p>Macros mean that the code you see is not the same as the code the compiler sees. This can introduce unexpected behavior, especially since macros have global scope.</p>
</blockquote>
",0
20529840,20529369,0,"<p>In coding contests people use every trick in the book to reduce things.</p>

<p>Is that good practice.</p>

<p>I think not for the simple reason - maintenance.</p>

<p>Also IMHO macros are a very bad idea.</p>
",0
20198827,20198799,6,"<p>You're changing your <code>p</code> pointer, and then you're trying to delete memory after the original allocated memory:</p>

<pre><code>delete [] p;
</code></pre>

<p>Save the the original pointer to some temporary iterator pointer and increment it, and not the original one:</p>

<pre><code>    int *t = p;
    for(int i=0 ; i&lt;20 ;i++ )
    {
        printf(""%d "",*t );
        t++;
    }
</code></pre>
",0
20198848,20198799,2,"<p>You are deleting a pointer pointing to the next element after your memory block.</p>
",0
20198850,20198799,2,"<p>Save starting pointer of array in another pointer and delete that old pointer on the end.</p>
",0
19888977,19888963,0,"<p>No part of your program is correct. The memory that contains string literals <em>must not be modified</em>, so you must never copy to the location <code>p</code>.</p>

<p>You must only access memory that you personally obtained for your own use, like so:</p>

<pre><code>char p[500];
strncpy(p, ""+\0"", 2);    // OK, *p is yours
</code></pre>
",0
19889169,19888963,0,"<p>I believe you actually mean when <code>p == NULL</code> (from your comment)</p>

<p><code>*p == NULL</code> just means <code>p</code> points to some address which holds the value <code>0</code>.</p>

<p>In other words <code>*p == NULL</code> and <code>p == NULL</code> are two completely different things.</p>

<p>So if you tried to edit the memory where <code>p</code> points to, and that memory is address <code>0x0000</code> (also known as <code>NULL</code>) that is pretty much guaranteed to fail, because you likely do not own this memory.</p>

<p>When I say own, I mean your program has allocated memory at this location. If you write <code>char *p = new char;</code> then your program allocates some <code>sizeof(char)</code> bytes of memory. And now if you modify the value of <code>*p</code> that is okay because you have been <strong>given</strong> the memory (by the operating system or whatever).</p>
",0
19263190,19263079,1,"<p>Because what you are doing is undefined behavior.  Don't shift a 64 bit integer by 64 places.</p>

<p>Edited to add:
<a href=""https://stackoverflow.com/questions/3784996/why-does-left-shift-operation-invoke-undefined-behaviour-when-the-left-side-oper"">Why does left shift operation invoke Undefined Behaviour when the left side operand has negative value?</a></p>
",0
19263256,19263079,2,"<p>Shifting by a value greater than or equal to the size of the value is undefined behaviour.</p>

<p>This is probably in the standard to keep the shift operation fast enough and just mapping underlying hardware operations.</p>

<p>For reasons that are not entirely clear to me for example even in x86 assembly shifting is done modulo the size of the register. I'm no hardware engineer but probably that was the most efficient thing to do.</p>

<p>Another unfortunate limitation is that shifting by a negative count is not the same as shifting by a positive count in the opposite direction and is instead just UB. This sometimes requires adding extra conditionals in computations.</p>
",1
18336881,18336822,1,"<p>Your do..while loop condition should be</p>

<p><code>while(ratio &lt;= 0.95 || ratio =&gt;1.05)</code></p>
",7
18337310,18336822,2,"<p>The condition should be:</p>

<pre><code>while (ratio &lt;= 0.95 || ratio &gt;= 1.05);
</code></pre>

<p>You got the ""&lt;"" and "">"" mixed up. <em>ratio</em> is <strong>not</strong> between 0.95 and 1.05 if it's less or equal than 0.95 or greater or equal than 1.05.</p>

<p>It's easy to avoid such mistakes if you remember how you negate a conjunction:</p>

<blockquote>
  <p><strong>NOT</strong> (0.95 &lt; ratio &lt; 1.05) === <strong>NOT</strong> (0.95 &lt; ratio <strong>AND</strong> ratio &lt; 1.05) ====
  [...]</p>
</blockquote>

<p>The rule is: change every <strong>AND</strong> to <strong>OR</strong> and negate all sub-expressions:</p>

<blockquote>
  <p>[...] === (<strong>NOT</strong> (0.95 &lt; ratio) <strong>OR NOT</strong> (ratio &lt; 1.05)) ====
  (0.95 >= ratio <strong>OR</strong> ratio >= 1.05) === (ratio &lt;= 0.95 <strong>OR</strong> ratio >= 1.05)</p>
</blockquote>
",0
18337189,18336822,0,"<p>Well the problem is you're increasing A and never changing B</p>

<p>and still expect ratio to be in (0.95,1.05) . This depends on initial value of A and B to break the loop.</p>

<p>Try:</p>

<pre><code>    B=rand()%RAND_MAX;

    do {
    A=rand()%RAND_MAX;
    ratio = A/B;
    cout&lt;&lt;""lets see ""&lt;&lt; A  &lt;&lt;""  ""&lt;&lt; B &lt;&lt;""  ""&lt;&lt;ratio&lt;&lt;endl;        

   }while(ratio &lt;0.95 || ratio&gt;1.05);
</code></pre>

<p>Then can divide A and B by power of ten as per your needs.</p>

<p>Also use <code>srand(time(0))</code> for different random values on successive runs</p>
",2
18793118,18792952,9,"<p>The best way is to always use an enum. But if you must stick with std::string, then I would recommend something like this:</p>

<pre><code>#include &lt;unordered_set&gt;

static void setState(const std::string &amp;state)
{
    static std::unordered_set&lt;std::string&gt; states {{ ""IDLE"", ""STARTED"", ""STOPPED"", ""PAUSED"" }};
    if (states.find(state) == states.end())
        throw std::invalid_argument(""Invalid state"");

    // Continue...
}
</code></pre>
",3
18793119,18792952,3,"<p>Try:</p>

<pre><code>std::string tmp[] = {""IDLE"", ""STARTED"", ""STOPPED"", ""PAUSED""};
std::set&lt;std::string&gt; allowedStates(tmp, tmp + sizeof(tmp) / sizeof(tmp[0]));
</code></pre>

<p>(maybe in a static variable or something)</p>

<p>and then:</p>

<pre><code>if (allowedStates.find(state) == allowedStates.end())
{
  //state is invalid
}
</code></pre>
",2
18794033,18792952,1,"<p>BartoszKP's solution with an STL set is probably the best simple solution.</p>

<p>If you are really keen, you can simulate a poor-man's hash with something like this:</p>

<pre><code>const unsigned nIdle('ELDI');    // ""IDLE"" with byte order reversed
const unsigned nStarted('RATS'); // ""STAR"" with byte order reversed
const unsigned nStopped('POTS'); // ""STOP"" with byte order reversed
const unsigned nPaused('SUAP');  // ""PAUS"" with byte order reversed

bool Verify(const char *szState)
{
    unsigned nState = *reinterpret_cast&lt;const unsigned *&gt;(szState);

    switch (nState)
    {
        case nIdle:
        case nStarted:
        case nStopped:
        case nPaused:
            return true;

        default:
            return false;
    }
}

int main()
{
    const std::string s[] = {""IDLE"", ""STARTED"", ""STOPPED"", ""PAUSED"", ""INVALID""};
    for (auto itr=std::begin(s); itr!=std::end(s); ++itr)
    {
        std::cout &lt;&lt; *itr &lt;&lt; '\t';
        if (Verify(itr-&gt;c_str()))
            std::cout &lt;&lt; ""OK"";
        else
            std::cout &lt;&lt; ""Fail"";
        std::cout &lt;&lt; std::endl;
    }
    return 0;
}
</code></pre>

<p>You need to be sure of your data.  Any string shorter than sizeof(unsigned) might be risky and you need to be sure that the string is unique with its first 4 bytes.  e.g. ""STOPPED"" and ""STOPPING"" are identical for 4 bytes.</p>

<p>You could do a proper hash, but that may not be faster than comparing strings.</p>
",0
18625312,18623688,1,"<p>It's a flawed design in general. And there are different ways you can change your design to achieve what you need. <em>Mark's answer is a straightforward way to go about it, for example</em>.</p>

<p>That being said, here is a possible solution using your design. Once again, <strong>I do not recommend it</strong> as it relies on internals of how compilers build stack, and is not portable across compilers/platforms.</p>

<p>Basically, in <code>~element()</code> you can check if the address stored in <code>value</code> is on stack or on heap by comparing it to the current stack pointer. If the address stored in <code>value</code> is higher than the stack pointer then it's on stack and should not be deleted (provided usual location of the stack at top of address space). If it's less than stack pointer - it's on heap.</p>

<p>Code to illustrate the relations of the addresses (GCC, x64 linux):</p>

<pre><code>#include &lt;iostream&gt;

int main()
{
 int * heap_(new int(0));
 int stack_(0);
 void * rsp_(nullptr);

 asm(""mov %%rsp, %0"" : ""=m"" (rsp_));

 std::cout &lt;&lt; ""heap address\t: "" &lt;&lt; heap_ 
           &lt;&lt; ""\nstack address\t: "" &lt;&lt; &amp;stack_ 
           &lt;&lt; ""\nstack pointer\t: "" &lt;&lt; rsp_ &lt;&lt; std::endl;

 delete (heap_);

 return (0);
}
</code></pre>

<p>Program output:</p>

<pre><code>heap address    : 0xc52010
stack address   : 0x7fff528ffee4
stack pointer   : 0x7fff528ffee0
</code></pre>

<p>ideone.com gives access to GCC, but uses x86 version - <code>esp</code> register instead of <code>rsp</code>. <a href=""http://ideone.com/fPqPDH"" rel=""nofollow"">The code has to be changed</a> (non-portability).</p>
",0
19384845,19384775,1,"<p>You can, for whatever reason you want to, join them together. You just have to remove the redundant <code>template&lt;class U&gt;</code>.</p>

<pre><code>template&lt;class T&gt;
class LinkedList {
private:
    struct Node {
        T data;
        Node* link;
    }* head;
};
</code></pre>
",0
19384849,19384775,1,"<p>I prefer your first example, but you don't need two template parameters like you have there.</p>

<pre><code>template&lt;class T&gt;
class LinkedList {
private:
    struct Node {
        T data;
        Node *link;
    };

    Node *head;
};
</code></pre>

<p>I think this is much cleaner than your second example. For instance you can now write <code>search</code> and <code>insert</code> functions on your <code>LinkedList</code> class. With your other example they would have to be external functions.</p>
",0
19384854,19384775,2,"<p>Just keep placeholder <code>T</code> and remove unnecessary <code>U</code>:</p>

<pre><code>template&lt;class T&gt;
class LinkedList {
private:

    struct Node {
        T data;
        Node *link;
    };

    Node *head;
};
</code></pre>
",1
20408277,20408240,2,"<p>An alternative for constants is <code>static const</code>.</p>

<pre><code>static const char category_path[] = ""properties/event/classifications/classification/@category"" ;
</code></pre>

<p>This way there is at least a little bit of type information decorated with it.</p>
",0
19319263,19318452,1,"<pre><code>    vector&lt;Student&gt; students(n);
    .. populate students
    sort(students.begin(), students.end(), [](const Student&amp; left, const Student&amp; right){ return left.groupNumber &lt; right.groupNumber; });
</code></pre>
",0
19319208,19318452,3,"<p>A possibility is to use <code>std::sort</code> with a comparator method on your array.  </p>

<p>Example:  </p>

<pre><code>bool Compare_By_Group(const Student&amp; a, const Student&amp; b)
{
  return a.groupNumber /* insert comparison operator here */ b.groupNumber;
}

// The sort function call
    std::sort(&amp;Group[0],
              &amp;Group[/* last index + 1*/],
              Compare_By_Group);
</code></pre>
",1
19787603,19787411,0,"<pre><code>// B.h 
#ifndef _B_H
#define _B_H
#include &lt;string&gt; 
class B {
public:
   B();
   ~B();
   static void showfunc();
   static std::string b;
};
#endif

//B.cpp #include &lt;iostream&gt; 
#include &lt;string&gt;
#include ""MyHeader1.h""
using namespace std; 
B::B(){} 
B::~B(){}

void B::showfunc(){
   cout&lt;&lt;b&lt;&lt;endl;
}

// main.cpp 
#include &lt;iostream&gt; 
#include ""MyHeader1.h"" 
using namespace std; 
std::string B::b = ""BBB""; 

int main(){
   B b_obj;    
   b_obj.showfunc();
   return 0; 
}
</code></pre>

<p>here your solution</p>
",0
19787487,19787411,5,"<p>You have defined an static variable in your header file. That works only if the static file is included exactly once! But you included it twice (main.cpp and B.cpp).
Move the following line to B.cpp and it works:</p>

<pre><code>std::string B::b = ""BBB"";
</code></pre>
",1
19787523,19787411,3,"<p>You need to move definition of <code>b</code> to the <code>.cpp</code> file.</p>
",0
19787530,19787411,0,"<p>If you wrote the definition in a hader file then this definition will be duplicated in each object module that includes this header. So the linker will not know which definition to use and whether these definitions are equivalent. </p>
",1
19787973,19787411,1,"<blockquote>
  <p>I defined this static data member out of class B in header file. But when i built it, errors occur.</p>
</blockquote>

<p>Then simply don't do that!</p>

<p>Don't define static members in a header. You'll introduce the definition into each TU that <code>#include</code>s the header.</p>

<p>Define them in <em>one</em> TU instead; the easiest way to do this is in a <em>.cpp</em> file.</p>
",0
20415714,20415470,0,"<p>You can just follow the instruction in <a href=""http://www.cplusplus.com/reference/ctime/time/"" rel=""nofollow"">time</a> and <a href=""http://www.cplusplus.com/reference/ctime/clock/"" rel=""nofollow"">clock</a> as Joe Z mentioned.</p>

<p>A quick demo for printing current time:</p>

<pre><code>#include &lt;ctime&gt;
time_t start = time(0);
const char* tstart = ctime(&amp;start);
// std::cout &lt;&lt; tstart; will give you local time Fri Dec 06 11:53:46 2013
</code></pre>

<p>For time difference:</p>

<pre><code>#include &lt;ctime&gt;
clock_t t = clock();
do_something();
t = clock() - t;
// std::cout &lt;&lt; (float)t / CLOCKS_PER_SEC; will give you elapsed time in seconds
</code></pre>

<p>You can simply replace <code>do_something();</code> with the operations to be measured.</p>
",0
18733683,18733601,1,"<p>Yes:</p>

<pre><code>// Last name Astari  =&gt;initial of your last name is ""A""

std::cout &lt;&lt;  ""   **   \n"";
std::cout &lt;&lt;  ""  *  *  \n"";
std::cout &lt;&lt;  ""  ****  \n"";
std::cout &lt;&lt;  ""  ****  \n"";
std::cout &lt;&lt;  ""  *  *  \n"";
</code></pre>
",1
19378260,19378225,0,"<p>You can make it shorter.</p>

<pre><code>    do 
    {
    } while (!func());
</code></pre>
",0
19378276,19378225,2,"<p>Why not use</p>

<pre><code>while (!func());
</code></pre>

<p>instead? Some folk don't like to see an empty <code>while</code> and may therefore prefer @dwxw's solution.</p>
",1
19378292,19378225,4,"<p>You could do that, but why not just:</p>

<pre><code>while(!func())
{
    // do what you want to do...
}
</code></pre>
",0
19378298,19378225,4,"<p>How about getting rid of the <code>break</code> and <code>continue</code>. It is not considered very nice to use them (especially when not required):</p>

<pre><code>bool result;
do
{
   result = func();

   if(result == false) {
      // Supposedly you want to do something here...?
   }
} while(result == false);
</code></pre>

<p>Of course you can use <code>!</code> instead of <code>false</code> to save some bytes in your source code. But I suppose that does not really matter at this point.</p>
",1
20750430,20750365,6,"<p>Just use a loop:</p>

<pre><code>auto const keys = { 2, 5, 7, 9, 10, 15,  };
for (auto&amp;&amp; key : keys) {
    m[key] = 5;
}
</code></pre>
",5
20750458,20750365,0,"<p>A more efficient way would avoid the default construction of the element, like so:</p>

<pre><code>m.emplace(2, 5);
m.emplace(3, 5);
// ...
</code></pre>
",0
19261438,19261422,3,"<p>You code causes undefined behaviour.  The expression <code>a[i]</code> will evaluate as true if non-zero and as false if zero.  When you run it, you're getting lucky that there is a <code>0</code> word immediately following your array in memory, so the loop stops.</p>
",0
19261441,19261422,0,"<p>It's reading past the array and the memory there just happens to be zero, by sheer luck. Reading past the end of that array is undefined behavior and the outcome might change at any time, so never rely on it.</p>
",0
19261590,19261422,0,"<p>You can think of <code>a[i]</code> as being compared to <code>0</code>, it simply fetches the number retrieved from the location in memory and if <code>0</code> is the value that lives at that memory, then the loop exits, if it is any other number the loop continues.</p>

<p>Suppose an <code>int</code> is 4 bytes on the system. <code>a</code> is given an address, lets pretend it is <code>0xFF00</code> when we try to evaluate <code>a[0]</code> we retrieve the data value stored at memory <code>0xFF00</code>. <code>a[1]</code> would retrieve data from memory <code>0xFF04</code>, etc. Your program only assigns values to the first 5 memory locations, so when we retrieve the data at beyond these locations they could be anything from <code>0</code> to <code>INT_MAX</code>. If it happens to be <code>0</code> then the loop exits, however if it happens to be something else the loop continues.</p>

<p>Your could adjust your program like so to see it better:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() {
    int a[5] = {1,2,3,4,5};
    int i;
    for (i = 0; a[i]; i++)
    {
        cout &lt;&lt; ""At memory address: "" &lt;&lt; &amp;a[i]
             &lt;&lt; "" lives the value: "" &lt;&lt; a[i] &lt;&lt; endl;
    }
    cout &lt;&lt; ""At memory address: "" &lt;&lt; &amp;a[i]
         &lt;&lt; "" lives the value: "" &lt;&lt; a[i]
         &lt;&lt; "", and this is why the loop ended."" &lt;&lt; endl;
    return 0;
}
</code></pre>
",4
19805032,19804747,0,"<p>I guess, I figured out the problem. You have a <code>Win32</code> application, and although the <code>main</code> in it is called implicitly, if none defined, the control usually passes to <code>WinMain()</code> function, which executes your windows app.</p>

<p>Here is the solution, and a patched <code>WinMain()</code> function:</p>

<pre><code>int __stdcall 
WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR lpCmdLine, INT nCmdShow) {
        LPWSTR *szArgList;
        int argc;
        szArgList = CommandLineToArgvW(GetCommandLine(), &amp;argc);
         if(argc &lt; 1){
            MessageBox(0, ""Do not run this program directly, use the Game Launcher!"", ""Error"", MB_ICONEXCLAMATION);
            exit(1);
         }
         if(wcscmp(szArgList[1],L""somesecretargument"") != 0){
             MessageBox(0, ""Do not run this program directly, use the Game Launcher!"", ""Error"", MB_ICONEXCLAMATION);
             exit(1);
         }
    DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_DIALOG1), NULL, DLGPROC(DialogProc), NULL);
    return 0; 
}
</code></pre>
",6
18388709,18388573,0,"<p>It's most probably because when closing the window, something gets destroyed while draw is called - most probably the system pointer. </p>

<p>In your case, draw should never be called when the user wants to close its window (unless the x calls another function to start a closing process of some sort). The best would be to first validate that system is not NULL or even better, use a shared pointer to ensure it is still valid when being used. Afterwwards, you shoiuld ensure that draw is not called when the window is closing - that should be done when calling the draw function (or above depending on how you've designed your application.</p>

<p>On a side note, unless you have a caching mechanism (and even that is not the best way to do it), you're recreating your sprite everytime it's being drawn. I suggest you keep a member variable and initialize the sprite in the construtor.</p>
",0
20414162,20414094,1,"<p>It is guaranteed that the program will behave as though the methods are called in the order written.</p>
",0
20414226,20414094,1,"<p>The methods will <em>have</em> to be called in that order so that a reference to the class can be returned so a subsequent (chained) call can be made. Optimizations have no effect on this. So yes, the <code>_state</code> of the object is updated through each consecutive call.</p>
",1
18516453,18516401,1,"<pre><code>TCHAR szPath[MAX_PATH];
SHGetFolderPath(NULL, CSIDL_COMMON_APPDATA, NULL, 0, szPath);
std::wstring applicationdatafolder(szPath);
MessageBox(NULL, applicationdatafolder.c_str(), NULL, MB_OK); 
</code></pre>
",5
18516506,18516401,3,"<p>the <code>SHGetFolderPath</code> function do return a <code>HRESULT</code> to show if everything went right. The actual ""string"" will be stored where last parameter points to: ergo into <code>szPath</code>.
Now what you want is to construct the string from this char array via <code>std::wstring applicationdatafolder (szPath)</code> and use it</p>

<p><strong>addendum for Qs emerged in comments</strong></p>

<p><code>wstring foo(bar)</code> vs <code>wstring foo = bar</code>
afaik (feel free to edit if im wrong) the usage of the copy constructor is more efficient:</p>

<p><code>wstring foo(bar)</code></p>

<ol>
<li>creates a new wstring but knows what will be stored</li>
<li>allocates enough memory for content from <code>bar</code></li>
<li>copies content from <code>bar</code></li>
</ol>

<p><code>wstring foo = bar</code> is essentialy <code>wstring foo(); foo = bar;</code></p>

<ol>
<li>creates a new <strong>empty</strong> wstring (<code>wstring foo</code> calls the default constructor without params)</li>
<li>allocates 1 byte (only line ending symbol will be stored)</li>
<li>places the line ending there</li>
<li>calls <code>operator=</code></li>
<li>frees the memory allocated in 2.</li>
<li>allocates enough place to store content from <code>bar</code></li>
<li>copies the content from <code>bar</code></li>
</ol>

<p>of course the compiler will probably recognize the redundant steps and optimize the code, but by using the former version we write efficient code in first place and don't rely on compiler optimiziation</p>

<p>also the former version is somewhat clearer as it reads as ""make a <code>wstring</code> named <code>foo</code> from <code>bar</code>"" and latter is ""make a <code>wstring</code> named <code>foo</code> and assign <code>bar</code> to it"". Pay attention to the fakt <code>bar</code> can be of some arbitrary type and though compiler understands what you want, it may seem look strange to have a <code>string</code> and some <code>mywierdtype</code> in an assignment.</p>
",5
18678431,18678404,1,"<pre><code>if (Down = *itrdown) 
</code></pre>

<p>Come on, the oldest trick in the book :)</p>

<pre><code>if (Down == *itrdown)
</code></pre>

<p>will be correct.</p>
",5
18678434,18678404,0,"<p><code>if (Down = *itrdown)</code></p>

<p>should be</p>

<p><code>if (Down == *itrdown)</code></p>

<p>The former is not a comparison, just an assignment, meanwhile you meant second: comparison.</p>

<p>However, there is a more important lesson in here: turn the warnings on when building. If you had done, you could not have missed this one unless you disregard warnings without evaluating them which is not a good idea.</p>

<p>That is probably a more important lesson to learn out of this situation because you would not need to debug issues like this at all then. ;-)</p>
",0
19379403,19379296,2,"<p>That doesn't look right at all. When reading from a file using C++ streams the file is the first parameter (the <code>istream&amp; in</code>) and the second parameter is the object which you intend to populate using data from the file.</p>

<p>The <code>File is not declared</code> error indicates that the 'File' datatype you've specified for the second parameter doesn't exist.</p>
",0
18603904,18603785,0,"<p>Move printing the ""Gross Pay is = $"" outside as it is common for both conditions. Use begin curly braces instead of the semicolon, use end curly braces at the end of the code block that you want to execute for the code block. The code should be:</p>

<pre><code>std::cout &lt;&lt; ""Gross Pay is = $"" ;

//Qualifier for RegularPay

if (Hours &lt;= 40){
    RegularPay = Hours * PayRate;
    OvertimePay = 0;
    GrossPay = RegularPay + OvertimePay;
}

//Qualifier for OverTime

if (Hours &gt; 40){
    RegularPay = Hours * PayRate;
    OvertimePay = 1.5 * (Hours - 40) * PayRate;
    GrossPay = RegularPay + OvertimePay;
}
std::cout &lt;&lt; RegularPay + OvertimePay &lt;&lt; std::endl;
</code></pre>
",0
18603832,18603785,7,"<p>Regarding your code snippet:</p>

<pre><code>if (Hours &lt;= 40);
    RegularPay = Hours * PayRate;
    OvertimePay = 0;
</code></pre>

<p>This doesn't do what you think. The <code>;</code> at the end of the <code>if</code> statement means ""if hours is less than 40, do nothing"", then it sets regular and overtime regardless. What you probably wanted was:</p>

<pre><code>if (Hours &lt;= 40) {
    RegularPay = Hours * PayRate;
    OvertimePay = 0;
}
</code></pre>

<p>The whole calculation of regular and overtime pay can probably be better written as:</p>

<pre><code>if (Hours &lt;= 40) {
    RegularPay = Hours * PayRate;
    OvertimePay = 0;
} else {
    RegularPay = 40.0 * PayRate;
    OvertimePay = 1.5 * (Hours - 40) * PayRate;
}

GrossPay = RegularPay + OvertimePay;
std::cout &lt;&lt; ""Gross Pay is = $""  &lt;&lt; GrossPay &lt;&lt; '\n';
</code></pre>

<p>You can see that the correct values are set for regular and overtime pay for the two situations, after which you can add them and print them in any way you want.</p>

<p>Keep in mind this (the use of <code>RegularPay = 40.0 * PayRate</code> in the <code>else</code> clause) is for overtime being time-and-a-half as that's often the case.</p>

<p>If you work in an industry where it's double-time-and-a-half (i.e., you're very lucky), change the calculation to <code>RegularPay = Hours * PayRate</code> as per your original. That seems to be the way your description specifies it but you may want to check with your tutor or at least comment the reasoning.</p>

<p>If it <em>is</em> double-time-and-a-half, you can simplify the code to be something like:</p>

<pre><code>RegularPay = Hours * PayRate;
OvertimePay = 0;
if (Hours &gt; 40)
    OvertimePay = 1.5 * (Hours - 40) * PayRate;

GrossPay = RegularPay + OvertimePay;
std::cout &lt;&lt; ""Gross Pay is = $""  &lt;&lt; GrossPay &lt;&lt; '\n';
</code></pre>
",0
18603862,18603785,2,"<p>First things first, you shouldn't write: </p>

<pre><code>     if(Hours &lt;= 40);
</code></pre>

<p>because a semicolon after an <code>if</code> statement doesn't allow for the rest of the code (that you want to execute after the statement) to be executed. And you should put the rest of the code after <code>if</code> in curly braces</p>
",0
19271586,19271449,2,"<p>You argument is <code>FF</code>. <code>'F'</code> is 70 in ASCII, and 70 is 0x46 (0100 0110). You have ""0110 0010"" which is 0x46 written in reverse.</p>

<p>So first, you need to convert the argument (FF) into a number. Because currently, it's only a string. You can use <code>strtol</code> or <code>std::stringstream</code> (with <code>std::hex</code>) for that for instance.</p>

<p>With strtol:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdlib.h&gt;

using namespace std;

void writeToScreen(char *data);

int main(int argc, char *argv[]){
    writeToScreen(argv[1]);
    return 0;
}

void writeToScreen(char *data){
    unsigned char dat = strtol(data, NULL, 16);
    for (unsigned int i=0;i&lt;8;i++)
    {
        if (dat &amp; 1) 
            cout&lt;&lt;""1"";
        else
            cout&lt;&lt;""0"";
        dat&gt;&gt;=1;
    }
    cout&lt;&lt;endl;
}
</code></pre>

<p>Beware that the byte is still printed from LSB to MSB.</p>
",2
18941827,18941757,0,"<p>isdigit is for char. if you are expecting non-digits characters as input. you must use string to get those then to validate. as follow:</p>

<pre><code>string cardnumber;
cout &lt;&lt; ""Please Enter Patron's Library Card Number: \n"";
cin &gt;&gt; cardnumber;
//Validate card number
while (cardnumber.find_first_not_of(""0123456789"") != -1)
{
    cout &lt;&lt; ""You have entered an invalid card number \n"";
    cout &lt;&lt; ""Enter a valid card number \n"";
    cin &gt;&gt; cardnumber;
}
</code></pre>

<p>Good Luck,</p>
",2
18941870,18941757,0,"<p>Use the return value of <code>std::cin &gt;&gt; cardnumber</code> expression:</p>

<pre><code>int cardnumber;
if (std::cin &gt;&gt; cardnumber &amp;&amp; (cardnumber &gt; 0 &amp;&amp; cardnumber  &lt; 9999)) {
    // success
}
</code></pre>

<p>where ""success"" means that <code>int</code> has been successfully retrieved from <code>std::cin</code>and it is within the interval &lt;0; 9999)</p>
",0
18941912,18941757,0,"<pre><code>#include &lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

int toNumber(string s)
{
    int num=0;
    for (int i=0;i&lt;s.size();i++)
        if (s[i]&gt;='0'&amp;&amp;s[i]&lt;='9')
            num = num*10 + s[i]-'0';
        else
            return -1;
    return num;
}

int main(int argc, const char * argv[])
{
    int number;
    string cardnumber;
    cout &lt;&lt; ""Please Enter Patron's Library Card Number: \n"";
    cin &gt;&gt; cardnumber;

    while ( (number = toNumber(cardnumber)) == -1 || number &gt; 9999) // no need to check if less than zero. cause it will return -1.
    {

        cout &lt;&lt; ""You have entered an invalid card number \n"";
        cout &lt;&lt; ""Enter a valid card number \n"";
        cin &gt;&gt; cardnumber;
    }

    // use card number here as string (cardnumber) and int (number).
    cout &lt;&lt; cardnumber &lt;&lt; "" "" &lt;&lt; number &lt;&lt; endl;
    return 0;
}
</code></pre>
",0
18941930,18941757,0,"<p>i guess you are looking for a validation in which no <code>char</code> should be entered,if i am correct then there is a function made <code>is_int</code> <a href=""https://stackoverflow.com/questions/11523569/how-can-i-avoid-char-input-for-an-int-variable"">read this</a> ,  </p>
",0
18942823,18941757,1,"<pre><code>bool isnum(const std::string&amp; arg){
  for(std::string::iterator it=arg.begin();it!=arg.end();it++)
     if(!isdigit(*it))
         return false;
  return true;
}
</code></pre>
",0
19271739,19262556,5,"<p>Number the character positions on screen like this:</p>

<pre><code>+----+----+----+----+----+----+----+
| 0 0| 0 1| 0 2| 0 3| 0 4| 0 5| 0 6|
+----+----+----+----+----+----+----+
| 1 0| 1 1| 1 2| 1 3| 1 4| 1 5| 1 6|
+----+----+----+----+----+----+----+
| 2 0| 2 1| 2 2| 2 3| 2 4| 2 5| 2 6|
+----+----+----+----+----+----+----+
| 3 0| 3 1| 3 2| 3 3| 3 4| 3 5| 3 6|
+----+----+----+----+----+----+----+
</code></pre>

<p>and check what goes in there</p>

<pre><code>+----+----+----+----+----+----+----+
|  7 |  6 |  5 |  4 |  3 |  2 |  1 |
+----+----+----+----+----+----+----+
|    |  6 |  5 |  4 |  3 |  2 |    |
+----+----+----+----+----+----+----+
|    |    |  5 |  4 |  3 |    |    |
+----+----+----+----+----+----+----+
|    |    |    |  4 |    |    |    |
+----+----+----+----+----+----+----+
</code></pre>

<p>Now find the relation between x, y, the value to print, and the initial number.</p>
",0
19213997,19213970,0,"<p>This part is placed within global scope:</p>

<pre><code>bool testPassword (char password[]);   // &lt;-- declaration of function
bool lower;                            // &lt;-- global variables
bool upper;
bool digit;
bool length;
{               // &lt;-- start of the scope? what does it belong to?
    ...
</code></pre>

<p>and it is invalid, you can not place program's logic in global scope... functions can not be just called ""out of nowhere""... if it was supposed to be the body of <code>testPassword</code> function already, it should be:</p>

<pre><code>bool testPassword (char password[])
{
    bool lower;
    bool upper;
    bool digit;
    bool length;
    ...
}
</code></pre>
",0
19214037,19213970,0,"<p>It sounds like you actually want this:</p>

<pre><code>bool testPassword (char password[])
{
   bool lower;
   bool upper;
   bool digit;
   bool length;

if (strlen(password) &lt; 6) {
    length = true;
}
else {
    length = false;
    cout &lt;&lt; ""Password must be at least 6 characters long.\n"";
}
...
</code></pre>

<p>NOTES:</p>

<ol>
<li><p>""testPassword()"" with a "";"" is a FUNCTION PROTOTYPE (not an actual function definition)</p></li>
<li><p>Unlike Python, just indenting doesn't make a conditional block.  If you want more than one line in the block, you need curly braces.</p></li>
</ol>
",0
19213994,19213970,0,"<p>testPassword: has a "";"" and the end of line that it shouldn't have.</p>

<p>The bool variables need to be inside the first ""{"", not before it.</p>
",3
19961172,19961132,2,"<p>Move need the <code>#include &lt;string&gt;</code> from the .cpp to the .h file so that the file <code>countedLocs.h</code> knows about <code>std::string</code> definition. In your case with one cpp you can switch the order of includes but it would be better to have it in the header there (countedLocs.h) if you plan to use it in other places also.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include ""countedLocs.h""
</code></pre>
",3
19961377,19961132,1,"<p>In your cpp file (not your header file), you should have this:</p>

<pre><code>CountedLocations::CountedLocations(std::string url, int counter)
{

}
</code></pre>

<p>not this:</p>

<pre><code>CountedLocations(std::string url, int counter)
{

}
</code></pre>

<blockquote>
  <p>But that gave me the error ""Extra qualification 'CountedLocations::'
  on member 'CountedLocations' [-fpermissive], so I elected not to use
  it.</p>
</blockquote>

<p>That's the error you would get if you put the qualification on the declaration of the constructor in your class body.</p>
",1
19961217,19961132,2,"<p>If this is really all of your code then you don't have a definition of std::string (ie #include ) before your struct is defined.</p>

<p>.h files should be able to be compiled all by themselves.  put #include  in the .h file (and some include guards too!)</p>
",0
19375676,19375520,0,"<p>It can't find the object file where those missing functions are defined. Make sure you are adding the generated object file for linking. Something like that (main is the exec name and main.o is the object with the main function, change them as needed):</p>

<pre><code>g++ -o main main.o skyhigh.o utility1.o flight.o scenic.o aerobatic.o
</code></pre>
",0
19375589,19375559,2,"<p>The linker complains that you have not added a <strong>definition</strong> for the constructor of <code>Noun</code>. Add it and this error will be fixed. I believe you only mean to call the parent's constructor in it so maybe this will do the job:</p>

<pre><code>Noun(string word, string definition) : Word(word, definition) {}
</code></pre>
",2
19375717,19375559,0,"<p>You can define the constructor </p>

<pre><code>Noun(string word, string definition)
</code></pre>

<p>exactly the way as you did it with the constructor of the class <code>Word</code>.
But you need to make sure that the definition of Noun is known when you use it. Normaly, one uses a separate header file for this. The content of the header-file for class <code>Noun</code> is already contained in the code you gave: It starts with </p>

<pre><code>class Noun : public virtual Word {
</code></pre>

<p>and ends with</p>

<pre><code>};
</code></pre>

<p>Move that to a header-file named noun.h and include that in your cpp-file via</p>

<pre><code>#include ""noun.h""
</code></pre>
",0
19385292,19385193,3,"<pre><code>#include&lt;iostream&gt;

int main()
{
  int a;
  std::cin&gt;&gt;a;
  for(int i=1;i&lt;=a;i++)
  {
    for(int j=0;j&lt;i;j++)
      std::cout&lt;&lt;i;
    std::cout&lt;&lt;""  "";
  }
}
</code></pre>
",8
19385309,19385193,2,"<pre><code>#include &lt;iostream&gt;


int main()
{
    int n;
    cout &lt;&lt; ""Please enter a number"";
    cin &gt;&gt; n;

    for(int i=1;i&lt;=n;i++)
    {
        for(int j=1;j&lt;=i;j++)
        {
        cout&lt;&lt;i;
        }


    }

}
</code></pre>
",0
19437362,19437169,1,"<p>fopen opens file and then can be read then token by token via fscanf.
Finally call fclose  to close file.</p>

<p>Those functions are originated from C but them are part of C++ too...</p>

<p>Alternatively use IO templates from STL like ifstream class.</p>
",0
19441838,19441770,1,"<p><code>string.c_str()</code> returns the internal <code>char*</code> buffer used by the <code>string</code>.</p>

<p>When you first get a pointer to the internal buffer via <code>c_str()</code> and store it in <code>hello[1]</code>, the buffer contains <code>""val1""</code>. On the next line you overwrite the string with the value <code>""val2""</code>. Since <code>""val1""</code> and <code>""val2""</code> are the same length, the new value fits in the original buffer, so it's overwritten.</p>

<p>In contrast, when you append <code>""val2""</code> to <code>val</code>, the original internal buffer must be too small to hold the result, so it allocates a new one. Hence, <code>hello[1]</code> and <code>hello[3]</code> point to two different <code>char*</code>s, and they hold different values.</p>

<p>You can see that the two printers are not equal by adding a couple of lines to the end of your program:</p>

<pre><code>printf(""Pointer in hello[1]: %p\n"", hello[1]);
printf(""Pointer in hello[3]: %p\n"", hello[3]);
</code></pre>

<p>I got these results on a test run:</p>

<pre><code>Pointer in hello[1]: 0x10ca00a68
Pointer in hello[3]: 0x10ca00a88
</code></pre>

<p>Calling <code>append</code> obviously forced the string to allocate a new, larger buffer. However, you're not guaranteed that the buffer in <code>hello[1]</code> will maintain its current value, because the <code>string</code> implementation might decide to reuse that buffer later if you make another call to a string methodmaybe even on another string.</p>
",0
19441844,19441770,1,"<p>In first case you are assigning the values to the std::string explicitely, wiping the previous value stored there, but in second case with std::string::append you are adding new value ""val2"" to previously existed one ""val1"".</p>

<p>Here is some specs: <a href=""http://en.cppreference.com/w/cpp/string/basic_string/append"" rel=""nofollow"">http://en.cppreference.com/w/cpp/string/basic_string/append</a>
""Extends the string by appending additional characters at the end of its current value""</p>
",0
19441871,19441770,0,"<p>An array of type char* with all NULLs will be treated by c++ as an empty string. </p>

<p>What happens: printf receives a pointer in memory and starts to 'print' characters one by one until it encounters NULL. So NULL terminates string. Everything after NULL is never taken into account</p>

<p>append() in this case will start placing characters at the end of previous character. Which is the first NULL after the ""val1""</p>

<p>Hope it helps</p>
",0
19498890,19498833,1,"<p>Your problem is this line</p>

<pre><code>missing=missingDays(daysMissing);
</code></pre>

<p>for some reason you have two variables for ""daysMissing"" (I'm not sure why you pass it in to your missingDays function in the first place)</p>

<p>After that line, <code>missing</code> will contain the value input, not <code>daysMissing</code> (since it's not passed by reference)</p>

<p>Your getAvg function, presumably, is crashing with a division by zero error.</p>
",0
19498976,19498833,0,"<p>So depending on compiler the value of <code>daysMissing</code> is either undefined or initialized with <code>0</code>.</p>

<p>In your function <code>getAvg</code> you divide <code>employeeNum/daysMissing;</code></p>

<p>But you are not allowed to divide by zero, thats's it :)</p>
",0
19498984,19498833,2,"<p>This looks like homework, so you should only expect nudges.  So, some nudges: why do your functions <code>employee()</code> and <code>missingDays()</code> take arguments?  And why does <code>getAvg()</code> take 3?  In which variables do your input values end up?  Where are they used next (if at all)?</p>
",0
19500710,19498833,0,"<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

int employee(int employeeNum);
int missingDays(int daysMissing);
double getAvg(int employeeNum,int daysMissing,double average);

int employee(int employeeNum)
{
  cout&lt;&lt;""Enter the number of employee in the company: "";
  cin&gt;&gt;employeeNum;
  return employeeNum;
}

int missingDays(int daysMissing)
{
  cout&lt;&lt;""Enter the amount of days employees missed during the past year: "";
  cin&gt;&gt;daysMissing;
  return daysMissing;
}

double getAvg(int employeeNum,int daysMissing)
{
    if(daysMissing == 0)
    {
        return 0;
    }
  return (double)employeeNum/daysMissing;;
}

int main()
{
  int employeeNum,people,missing,daysMissing;
  double avg,average;

  people=employee(employeeNum);
  cout&lt;&lt;""The number of employees in the company is: ""&lt;&lt;people&lt;&lt;""\n"";

  missing=missingDays(daysMissing);
  cout&lt;&lt;""The number of days employees missed during the past year is: ""&lt;&lt;missing&lt;&lt;""\n"";

  avg=getAvg(people,missing);
  cout&lt;&lt;avg;
}
</code></pre>
",0
19576344,19576058,0,"<p>Just by debugging your code, one can notice that you didn't initialize the variable ""chDigit"". Because of that, the code might break in line 83, where you have this:</p>

<pre><code>int ReadNumbersReturningValue( int base )
{
    int numberValue;
    char chDigit; // &lt;------- SHOULDN'T HAVE BEEN INITIALIZED?
    int sum = 0;
    int basePOW = 1;
    bool valid = IsValid(chDigit, base); // &lt;------ HERE
. . .
</code></pre>

<p>Did you check that? It might be your problem.</p>
",0
20513390,20513342,0,"<p>you were missing the <code>include</code> statement, from the child .h file to the father.h file, something like:</p>

<pre><code>#include ""father.h""
</code></pre>
",2
20520555,20513342,2,"<p>You have a ciruclar dependency, <code>home.h</code> includes <code>child.h</code> which includes <code>father.h</code> which includes <code>home.h</code></p>

<p>You need a forward declaration in one of your header file.</p>

<p><a href=""http://www.parashift.com/c++-faq/forward-decl.html"" rel=""nofollow"">http://www.parashift.com/c++-faq/forward-decl.html</a></p>
",2
20203431,20203405,1,"<p>You can use the conditional operator for this kind of situation:</p>

<pre><code>int aa = a == 72 ? 1 : 2;
</code></pre>

<p>This allows you to initialize a variable based on a condition, something which cannot be done with an <code>if-else</code> statement. You will have to deal with writing to <code>stdout</code> separately though.</p>
",0
20203465,20203405,1,"<p>It's likely telling you this when you're outside of your if/else statement.  In the example you give, you're creating local variables inside the scope of the <code>if</code> and the <code>else</code>.  They go out of scope and ""cease to exist"" after the <code>if</code> / <code>else</code> stuff.</p>

<p>Here's the way you should do it:</p>

<pre><code>int aa = -1;
if (a = 72)
{
    cout &lt;&lt; ""You are CORRECT1"" &lt;&lt; endl;
    aa = 1;
}
else
{
    cout &lt;&lt; ""No.  The answer is "" &lt;&lt; 12 * 6 &lt;&lt; endl;
    aa = 2;
}
cout &lt;&lt; aa &lt;&lt; endl;
</code></pre>

<p>By doing it this way, you declare the int outside of the scope of the <code>if/else</code> code block, so the variable continues to survive, and can be accessed outside of that code block.</p>
",2
20203466,20203405,2,"<p>Declare the variable before like so.</p>

<pre><code>int aa;
if (a == 72)
   {
     cout &lt;&lt;""You Are CORRECT1""&lt;&lt;endl;
     aa = 1;
   }
   else{
    cout &lt;&lt;""No. The answer is ""&lt;&lt;12*6&lt;&lt;endl;
    aa = 2;
    }
</code></pre>
",0
20203489,20203405,2,"<p>Your variable declaration is correct, the problem s that the lifetime of your variable is only valid inside the block in which it was declared. Any attempts to use it outside this block is invalid.</p>
",0
20508707,20508563,0,"<p>Look closely at this:</p>

<pre><code>    for (int index = 0; index == i; index++){
        ptr = ptr-&gt;next;
    }
</code></pre>

<p>Shouldn't that be...</p>

<pre><code>    for (int index = 0; index != i; index++){
        ptr = ptr-&gt;next;
    }
</code></pre>

<p>?</p>
",0
19876760,19875731,0,"<p>Probably your teacher told you that <code>double</code> numbers are great for large numbers. They are, but they have a big disadvantage: They cannot represent large numbers exactly, since they (roughly speaking) only store the first few digits of the number, together with the position of the decimal point, like your pocket calculator shows (for example, <code>123456E13</code>).</p>

<p>So you should not use <code>double</code> numbers here at all, since you need <em>precise</em> results, no matter how large your numbers are. A better idea is process both strings simultaneously and store the result digit by digit in another string, called <code>result</code>.</p>

<p>By the way: Since <code>double</code> numbers can usually store 53 binary digits precisely, it's good that your tested the program with even more digits.</p>
",0
19969311,19969043,1,"<p>A proper way to code is to eliminate the <code>system</code> function calls.  Use platform specific API for the functionality.  </p>

<p><strong>Do you really need to clear the screen after each question?</strong><br>
Doesn't seem very proper.  Some people like to look back at the previous output.  Also, doesn't work with windowing systems.  </p>

<p><strong>Can age be negative?</strong><br>
C++ has <code>int</code> type to handle negative numbers and <code>unsigned int</code> if the value will always be zero or positive.  </p>

<p><strong>Check your input before calculating.</strong><br>
For example, if the year born is greater than present year, you will present a negative age.  </p>

<p><strong>Read year from OS.</strong><br>
You don't need the User to input the present year.  Most platforms have clocks and functions to get the present time.  </p>
",3
19960492,19960384,0,"<pre><code>a==b
</code></pre>

<p>This is an important Boolean condition that checks whether a is equal to b and returns true if it is and returns false if it is not. This can be changed (casted) to an <code>int</code> of value 1 or 0.</p>

<pre><code>c-=--d;
</code></pre>

<p>I wouldn't prefer writing such code. </p>

<pre><code>However c -= k statement is equivalent to c = c-k
and --d; is same as decrement d by 1.
</code></pre>

<p>The code does these two things in one statement. But order is important. Since -- comes before d, first this decrement is evaluated and then the -= operator is considered.</p>

<p>Similarly for +=</p>

<p>I would suggest looking up a good C++ learning resource such as www.cplusplus.com or www.learncpp.com</p>
",0
19960565,19960384,1,"<pre><code>c -= --d;
</code></pre>

<p>mean</p>

<pre><code>c = c - (--d);
</code></pre>

<p>The same goes for</p>

<pre><code>b += a%10
</code></pre>

<p>which mean</p>

<pre><code>b = b + (a%10)
</code></pre>

<p>You can do the same with *, / and % operator</p>

<p>--d mean that d is decreased before the instruction get executed, ++d would mean d will be increased before the instruction got executed</p>

<pre><code>if(a==b)c++;else c--;
</code></pre>

<p>is the same as the more readable</p>

<pre><code>if (a==b)
{
    c = c + 1;
}
else
{
    c = c - 1;
}
</code></pre>
",0
19960858,19960384,1,"<pre><code>int a=3,b=4, c=5,d=6;
if(a==b) c++;
else c--;
while(d&gt;2){
    c-=--d; b-=a;
}
</code></pre>

<p>The <code>==</code> operator means comparasion if a and b are the same. In this case a and b are different, so it goes to the else and decrements the c variable for 1.</p>

<p>The -- after c means that the value is decreased before the instruction gets executed.</p>

<p>So, that means c will become 4.</p>

<p>While <code>d &gt; 2</code>, means it will loop as long as <code>d &gt; 2</code>.</p>

<p><code>c -= --d; b-=a;</code></p>

<p>That means:</p>

<p><code>c = c - --d</code></p>

<p><code>b = b - a</code></p>

<p>So, that means the value of d will decrease by 1 each time the loop is executed and will keep looping until it's >2.</p>

<pre><code>int a=3,b=0, c=7,d=5;
if(a=b)d++;
else c--;
while(d&gt;2){
    c+=a;a+=--d;
}
</code></pre>

<p>The <code>=</code> operator means to assign a value, so when it executed <code>a=b</code>, it will assign the value of <code>b</code> to <code>a</code> but since it's <code>0</code>, which means <code>false</code> it will go to else and decrease the value of c by 1.</p>

<p>So c will become 6.</p>

<p>The while loop is similar to the first one.</p>

<pre><code>int a=3,b=11, c=15,d=5;
if(a&gt;b)d--;else c--;
for(;d&gt;3;c/=a){
    b=--d;
}
</code></pre>

<p>This one is quite simple if-statement. It checks whether a is bigger than b. If so, it executes d--, else c--.</p>

<p>As for the for-loop, it goes until <code>d &gt; 3</code> and it executes <code>c /= a</code> each time as well.</p>

<p><code>c /= a</code> also can be written as <code>c = c / a</code>.</p>

<pre><code>int a=31,b=14, c=95,d=56;
if(a&lt;b)d++;else c--;
while(d&gt;53){
    b+=a%10;d--; a/=10;
}
</code></pre>

<p>The last one if statement is simple as well and similar to the above one.</p>

<p>The while loop will be executed until <code>d &gt; 53</code>.</p>

<p>The command inside <code>b+=a%10;d--; a/=10;</code> can be also written as:</p>

<p><code>b = b + a % 10</code></p>

<p><code>d--</code></p>

<p><code>a = a / 10</code></p>
",1
20400315,20400247,10,"<p>You can't. At least not that way. You should be able to solve it by putting the code in a class constructor and destructor, then declaring a global variable:</p>

<pre><code>struct myStruct
{
    myStruct() { std::cout &lt;&lt; ""Before main?\n""; }
    ~myStruct() { std::cout &lt;&lt; ""After main?\n""; }
};

namespace
{
    // Put in anonymous namespace, because this variable should not be accessed
    // from other translation units
    myStruct myStructVariable;
}

int main()
{
    std::cout &lt;&lt; ""In main\n"";
}
</code></pre>
",5
20420618,20420393,0,"<p>How about validating the user's input each time they enter something new? This might help you get started:</p>

<pre><code>bool isValidUserInput(string s, vector&lt;string&gt; saved) {
  for (int i = 0; i &lt; saved.size(); ++i) {
    // compare every element in the collection (saved) against your new input (s).
    // if duplicate found, return false. Otherwise, return true.
  }
}
</code></pre>
",1
20420955,20420393,0,"<p>Without testing:</p>

<pre><code>const size_t N = 10;
char s[N];

size_t i = 0;
char c;

while ( i &lt; N &amp;&amp; std::cout &lt;&lt; ""Enter a character: "" &amp;&amp; std::cin &gt;&gt; c )
{
    size_t j = 0;
    while ( j &lt; i &amp;&amp; s[j] != c ) j++;

    if ( j == i )
    {
        s[i] = c;
        i++;
    }
    else
    {
        std::cout &lt;&lt; ""Array already contains character "" &lt;&lt; c &lt;&lt; std::endl;
        std::cout &lt;&lt; ""Try again."" &lt;&lt; std::endl;
    }
}
</code></pre>
",1
20524305,20524202,4,"<p>You are reading into <code>stocks[index + 1]</code> which overflows the array dimensions. You loop from <code>0</code> to <code>2</code> including, which is correct, but <code>stocks[index + 1]</code> tries to access <code>stocks[3]</code> when <code>i == 2</code>, which is an ""index out of bounds"" error.</p>

<p>I guess this is a copy &amp; paste problem, since you want to instruct the user to enter data for ""#1"", ""#2"" and ""#3"".</p>

<p>Try this:</p>

<pre><code>for(int index = 0; index &lt; 3; index++){
    cout&lt;&lt; ""Company name #""&lt;&lt; index + 1&lt;&lt; "": "";
    cin.ignore();
    cin.clear();
    cin&gt;&gt; stocks[index].compName;
    cout&lt;&lt; ""Company symbol #""&lt;&lt; index + 1&lt;&lt; "": "";
    cin.ignore();
    cin.clear();
    cin&gt;&gt; stocks[index].compSymbol;
    cout&lt;&lt; ""Price per share #""&lt;&lt; index + 1&lt;&lt; ""$ "";
    cin.ignore();
    cin.clear();
    cin&gt;&gt; stocks[index].pricePer;
    cout&lt;&lt; ""Shares purchased #""&lt;&lt; index + 1&lt;&lt; "": "";
    cin.ignore();
    cin.clear();
    cin&gt;&gt; stocks[index].shares;
}
</code></pre>
",1
20524875,20524202,0,"<p>The main error in your code is because you were trying to access an element in the array that was not there.</p>

<pre><code>stocks[index + 1]
</code></pre>

<p>Remember that an array starts from [0] and on. In your case, when you entered the for loop in the getData function, you were accessing the ""second"" element in the array, not the ""first"" by doing [index+1]. 
This means that the 1st element ([0]) was initialized to a garbage value and when the loop entered the final loop, you were essentially trying to access an element of the array that does not exist.</p>

<p>Here is your example working:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
#include &lt;iomanip&gt;

using namespace std;

struct StockInfo
{
    string compName;
    string compSymbol;
    double pricePer;
    int shares;
};


void getData(StockInfo *stocks)
{
    cout&lt;&lt; ""Enter your stock information.""&lt;&lt; endl;

    for(int index = 0; index &lt; 3; index++)
    {
        cout&lt;&lt; ""Company name #""&lt;&lt; index + 1&lt;&lt; "": "";
        cin.clear();
        cin&gt;&gt; stocks[index].compName;
        cout&lt;&lt; ""Company symbol #""&lt;&lt; index + 1&lt;&lt; "": "";
        cin.clear();
        cin&gt;&gt; stocks[index].compSymbol;
        cout&lt;&lt; ""Price per share #""&lt;&lt; index + 1&lt;&lt; ""$ "";
        cin.clear();
        cin&gt;&gt; stocks[index].pricePer;
        cout&lt;&lt; ""Shares purchased #""&lt;&lt; index + 1&lt;&lt; "": "";
        cin.clear();
        cin&gt;&gt; stocks[index].shares;
    }
}

void displayData(StockInfo *stocks)
{
    cout&lt;&lt; ""***********************************************\n"";
    cout&lt;&lt; ""*************My Stock Information**************\n"";

    for(int count = 0; count &lt; 3; count++)
    {
        double tot = 0.00;

        tot = stocks[count].pricePer * stocks[count].shares;

        cout&lt;&lt; setprecision(2)&lt;&lt; endl;
        cout&lt;&lt; setw(20)&lt;&lt; left&lt;&lt; ""Company Name:""    &lt;&lt; setw(20) &lt;&lt; right    &lt;&lt; stocks[count].compName   &lt;&lt; endl;
        cout&lt;&lt; setw(20)&lt;&lt; left&lt;&lt; ""Company Symbol:""  &lt;&lt; setw(20) &lt;&lt; right    &lt;&lt; stocks[count].compSymbol &lt;&lt; endl;
        cout&lt;&lt; setw(20)&lt;&lt; left&lt;&lt; ""Share Price:""     &lt;&lt; "" $""     &lt;&lt; setw(20) &lt;&lt; right                    &lt;&lt; stocks[count].pricePer&lt;&lt; endl;
        cout&lt;&lt; setw(20)&lt;&lt; left&lt;&lt; ""Shares:""          &lt;&lt; setw(20) &lt;&lt; right    &lt;&lt; stocks[count].shares     &lt;&lt; endl;
        cout&lt;&lt; setw(20)&lt;&lt; left&lt;&lt; ""Total:""           &lt;&lt;"" $""      &lt;&lt; setw(20) &lt;&lt; right&lt;&lt; tot              &lt;&lt; endl;
    }
}

int main() 
{
    StockInfo *stocks = new StockInfo[3];

    getData(stocks);

    displayData(stocks);

    delete [] stocks;
}
</code></pre>

<p>Be aware that when using namespaces can and WILL create collision errors with other functions with a similar name, if you are not careful. I would advise you used std::string,
std::cout and so on. It's safer!</p>

<p>Also, have you considered using template containers? Your example is simple enough for you to use arrays, but still won't harm you to know better ways. (std::vector&lt; > is essentially a dynamic array but also clears the memory for you. It will also compute the size of your array and you won't have to hard-code the size in every function ex.3 )</p>

<p>Hope this helps!</p>
",0
20643814,20643758,0,"<p>Where are those function definitions located? The <code>friend</code> declaration injects the names into <code>namespace project</code>. If the functions aren't defined in that namespace, they're different functions and not friends.</p>
",2
20643891,20643758,1,"<p>Your function implementation should also reside in the <code>project</code> namespace - just declaring that you are using it is not enough, the function itself is 'global' if you don't specify it as such and then won't be able to access the members since it is friended in the wrong namespace scope.</p>

<p><a href=""https://eval.in/80434"" rel=""nofollow"">Compiles fine with this fix</a>.</p>

<p><a href=""https://eval.in/80433"" rel=""nofollow"">Does not compile otherwise</a>.</p>
",0
20643896,20643758,0,"<p>Try to define your two friend functions outside your Matrix class.</p>

<p>Like : </p>

<pre><code>#include &lt;iostream&gt;
using namespace std;
namespace project
{
#ifndef MATRIX_H
#define MATRIX_H

typedef int* IntArrayPtr;
class Matrix
{
public:
    //Default Constructor
    Matrix();

    Matrix(int max_number_rows, int max_number_cols, int intial_value);

    //Destructor
    ~Matrix();
    //Copy Constructor
    Matrix(const Matrix&amp; right_side);
    //Assignment Operator
    Matrix&amp; operator=(const Matrix&amp; right_side);

    void Clear();
    int Rows();
    int Columns();
    bool GetCell(int x,int y, int&amp; val);
    bool SetCell(int x,int y, int val);
    //void Debug(ostream&amp; out);
private:
    int initialVal;
    int rows;
    int cols;
    IntArrayPtr *m;
};
 ostream&amp; operator&lt;&lt;(ostream&amp; out, const Matrix&amp; object);
 istream&amp; operator&gt;&gt;(istream&amp; in, Matrix&amp; theArray);

#endif
}
</code></pre>
",0
20645838,20645738,2,"<p>You are allocating <code>rows</code> number of rows, but deallocating <code>rows+1</code> number of rows.
Check the destructor.  &lt;= must be &lt;.</p>

<p>Besides this there are a lot of other [potential] errors in your code:</p>

<ul>
<li>you are setting the local <code>m</code> variable instead of setting the <code>m</code> data member of your class (that's why I have the convention to always precede data members by m_ to prevent this kind of confusion).  This error appears both in the constructor and the assignment operator.</li>
<li>you use <code>rows</code> to allocate the matrix, but <code>max_number_rows</code> to initialize the matrix.  Although it works correctly now, it may lead to errors if <code>row</code> is initialized differently later (e.g. if <code>row</code> is initialized with <code>std::max(max_number_rows,1000)</code>.  Your code in the assignment operator is better.</li>
<li>your if-test in GetCell and SetCell is incorrect.  It should probably be <code>&gt;=</code> instead of <code>&lt;</code></li>
<li>the assignment operator copies the size of the matrix, but assigns all cells an initialValue.  This is not an assignment.  This implementation might/will confuse the rest of the code.</li>
<li>the typedef of IntArrayPtr is unnecessary</li>
</ul>
",0
20645925,20645738,1,"<p>two issues:</p>

<ol>
<li>You are not allocating any value into the ""m"" member of your object, you are allocating into local variables named ""m""</li>
<li>you are over deallocating by looping from i=0 to i &lt;= rows, you want i=0 to i &lt; rows</li>
</ol>
",0
20750433,20750254,0,"<p>It looks like you intended to do:</p>

<pre><code> for (i = 0; i &lt;= 9; ++i)
     for (j = 0; j &lt;= 9; ++j)
</code></pre>

<p>You were missing the &lt;.
i &lt; 10 would be the more standard usage.</p>
",0
20750525,20750254,0,"<p>Following may help you to understand how initialize array.</p>

<pre><code>double createValueFromIndices(int x, int y)
{
    return 10. * x + y; // or any wanted value;
}

void initArray(double (&amp;a)[10][10])
{
     for (int x = 0; x != 10; ++x) {
         for (int y = 0; y != 10; ++y) {
             a[x][y] = createValueFromIndices(x, y);
         }
     }
}


int main(int argc, char** argv)
{
    double a[10][10];

    initArray(a);

    return 0;
}
</code></pre>
",1
18898967,18898920,1,"<p>There are several ways to arrange the elements of <code>input</code> in <code>output</code>. Here is one way:</p>

<pre><code>output[i*10 + j] = input[i][j]
</code></pre>
",3
18899081,18898920,0,"<p>Aside from NPEs suggestion, you have a memory leak here:</p>

<pre><code>float *output = new float[HighRange]; // allocate contiguous block HighRange * sizeof(float) bytes
output = new float[10 * 10]; // allocate contiguous block 100 * sizeof(float) bytes
</code></pre>

<p>Aside from this being unnecessary, you leak memory, i.e. you allocate storage in the first statement that you never free before assigning a new value to the pointer that hold the first address to the previously allocated storage.</p>

<p>When allocating memory dynamically using <code>new</code>, you need to make sure you <code>delete</code> it accordingly. For arrays, you need to do the following:</p>

<pre><code>float *output = new float[HighRange]; // allocate 
delete [] output; // deallocate, note the delete[] operator
output = new float[10 * 10]; // allocate anew
</code></pre>

<p><strong>Note:</strong> This is just to display correct usage of new/delete[]. By no means do I suggest your code would be any better if you handled deallocation in your example. :)</p>
",2
