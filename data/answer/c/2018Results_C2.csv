52605518,14627818,0,"<p>To answer my own question : using C++17, it's now easy.</p>

<pre><code>template &lt;int A, int B&gt; void f(X) {
if constexpr (A &gt;= B)
// ^^^^^^^^^
{
  SetValue(X &lt;&lt; (A-B));
}
else // (A &lt; B)
{
  SetValue(X &gt;&gt; (B-A));
}
</code></pre>

<p>The branch where the shift is negative will be <em>discarded</em>. </p>
",1
58329001,7478459,0,"<p>C++ doesn't define the order in which two global constructors or destructors are called if the objects are defined in separate files. However, if objects are defined in the same file, then there is an order: file scope objects are constructed in lexical order (the order in which they appear in the file) and destroyed in the reverse order.</p>

<p>This can be exploited in combination with header file dependencies to bring order into C++ global construction and destruction, like this:</p>

<pre><code>// header file A.h
#ifndef A_H_INCLUDED
#define A_H_INCLUDED
class A { /* ... */ };

#ifdef DEFINE_GLOBALS
A a_singleton;
#endif
#endif

// header file B.h
#ifndef B_H_INCLUDED
#define B_H_INCLUDED
#include ""A.h""
class B : { A *pa_memb; /* ... */ }

#ifdef DEFINE_GLOBALS
B b_singleton;
#endif
#endif

// header file C.h
#ifndef C_H_INCLUDED
#define C_H_INCLUDED
#include ""B.h""
#include ""A.h""
class C : { A *pa_memb, B *pb_memb; /* ... */ }

#ifdef DEFINE_GLOBALS
C c_singleton;
#endif
#endif
</code></pre>

<p>Then, we have a file called <code>globals.cc</code> where we do this:</p>

<pre><code>// globals.cc
#define DEFINE_GLOBALS
#include ""C.h""
#include ""A.h""
#include ""B.h""
</code></pre>

<p>The <code>#include</code> guards in the headers will ensure that the inclusions in <code>global.cc</code> are in the proper dependency order (and that missing ones will probably be picked up: in the above example, if we just include <code>""C.h""</code>, we are good). Now all of the global objects are defined in a single translation unit and are constructed in the correct order: used objects are constructed before their users, and destroyed after their users.</p>
",0
49037913,295120,12,"<p>Here is a more complete answer for 2018.</p>

<p>These days, a lot of tools allow you to not just mark something as deprecated, but also provide a message. This allows you to tell people when something was deprecated, and maybe point them toward a replacement.</p>

<p>There is still a lot of variety in compiler support:</p>

<ul>
<li>C++14 supports <code>[[deprecated]]</code>/<code>[[deprecated(message)]]</code>.</li>
<li><code>__attribute__((deprecated))</code> is supported by GCC 4.0+ and ARM 4.1+</li>
<li><code>__attribute__((deprecated))</code> and <code>__attribute__((deprecated(message)))</code> is supported for:

<ul>
<li>GCC 4.5+</li>
<li>Several compilers which masquerade as GCC 4.5+ (by setting <code>__GNUC__</code>/<code>__GNUC_MINOR__</code>/<code>__GNUC_PATCHLEVEL__</code>)</li>
<li>Intel C/C++ Compiler going back to at least 16 (you can't trust <code>__GNUC__</code>/<code>__GNUC_MINOR__</code>, they just set it to whatever version of GCC is installed)</li>
<li>ARM 5.6+</li>
</ul></li>
<li>MSVC supports <code>__declspec(deprecated)</code> since 13.10 (Visual Studio 2003)</li>
<li>MSVC supports <code>__declspec(deprecated(message))</code> since 14.0 (Visual Studio 2005)</li>
</ul>

<p>You can also use <code>[[gnu::deprecated]]</code> in recent versions of clang in C++11, based on <code>__has_cpp_attribute(gnu::deprecated)</code>.</p>

<p>I have some macros in <a href=""https://github.com/nemequ/hedley"" rel=""noreferrer"">Hedley</a> to handle all of this automatically which I keep up to date, but the current version (v2) looks like this:</p>

<pre><code>#if defined(__cplusplus) &amp;&amp; (__cplusplus &gt;= 201402L)
#  define HEDLEY_DEPRECATED(since) [[deprecated(""Since "" #since)]]
#  define HEDLEY_DEPRECATED_FOR(since, replacement) [[deprecated(""Since "" #since ""; use "" #replacement)]]
#elif \
  HEDLEY_GCC_HAS_EXTENSION(attribute_deprecated_with_message,4,5,0) || \
  HEDLEY_INTEL_VERSION_CHECK(16,0,0) || \
  HEDLEY_ARM_VERSION_CHECK(5,6,0)
#  define HEDLEY_DEPRECATED(since) __attribute__((__deprecated__(""Since "" #since)))
#  define HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__(""Since "" #since ""; use "" #replacement)))
#elif \
  HEDLEY_GCC_HAS_ATTRIBUTE(deprcated,4,0,0) || \
  HEDLEY_ARM_VERSION_CHECK(4,1,0)
#  define HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))
#  define HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__))
#elif HEDLEY_MSVC_VERSION_CHECK(14,0,0)
#  define HEDLEY_DEPRECATED(since) __declspec(deprecated(""Since "" # since))
#  define HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated(""Since "" #since ""; use "" #replacement))
#elif HEDLEY_MSVC_VERSION_CHECK(13,10,0)
#  define HEDLEY_DEPRECATED(since) _declspec(deprecated)
#  define HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)
#else
#  define HEDLEY_DEPRECATED(since)
#  define HEDLEY_DEPRECATED_FOR(since, replacement)
#endif
</code></pre>

<p>I'll leave it as an exercise to figure out how to get rid of the <code>*_VERSION_CHECK</code> and <code>*_HAS_ATTRIBUTE</code> macros if you don't want to use Hedley (I wrote Hedley largely so I wouldn't have to think about that on a regular basis).</p>

<p>If you use GLib, you can use the <a href=""https://developer.gnome.org/glib/stable/glib-Miscellaneous-Macros.html#G-DEPRECATED:CAPS"" rel=""noreferrer""><code>G_DEPRECATED</code></a> and <a href=""https://developer.gnome.org/glib/stable/glib-Miscellaneous-Macros.html#G-GNUC-DEPRECATED-FOR:CAPS"" rel=""noreferrer""><code>G_DEPRECATED_FOR</code></a> macros. They're not as robust as the ones from Hedley, but if you already use GLib there is nothing to add.</p>
",0
52794563,3261596,-3,"<p>Because they're unnecessary when we're working smartly. We can always commit our code before we build it and checkout to a separate folder then build in-source in the second location.</p>

<p>We can then check in our build to another branch and check it out to another location to run our tests.</p>
",3
53245211,683059,0,"<p>No, you cant.</p>

<p>However, if you can create an auxiliary data structure to store locations and ensure you remove them from that auxiliary data structure when they get deleted (maybe add it to the destructor) you can check whether the pointers are in that structure before de-referencing them.</p>
",0
49700391,8706589,0,"<p>There's a clang-tidy check for this: <a href=""https://reviews.llvm.org/rCTE329448"" rel=""nofollow noreferrer"">https://reviews.llvm.org/rCTE329448</a> (made by me, so you may address me any questions on it)</p>
",0
55715607,3019977,3,"<p>Here's another way of doing it, remember to use free() on the result.</p>

<pre><code>char* wchar_to_char(const wchar_t* pwchar)
{
    // get the number of characters in the string.
    int currentCharIndex = 0;
    char currentChar = pwchar[currentCharIndex];

    while (currentChar != '\0')
    {
        currentCharIndex++;
        currentChar = pwchar[currentCharIndex];
    }

    const int charCount = currentCharIndex + 1;

    // allocate a new block of memory size char (1 byte) instead of wide char (2 bytes)
    char* filePathC = (char*)malloc(sizeof(char) * charCount);

    for (int i = 0; i &lt; charCount; i++)
    {
        // convert to char (1 byte)
        char character = pwchar[i];

        *filePathC = character;

        filePathC += sizeof(char);

    }
    filePathC += '\0';

    filePathC -= (sizeof(char) * charCount);

    return filePathC;
}
</code></pre>
",0
50169368,6185020,1,"<p>As others have already answered: Yes, this is legal. And yes, this is guaranteed by the Standard to work.</p>

<p>And I find it horrible every time I see it, forcing me to pause: ""<code>vec(vec)</code>? WTF? Ah yes, <code>vec</code> is a member variable...""</p>

<p>This is one of the reasons why many, including myself, like to use a naming convention which makes it clear that a member variable is a member variable. Conventions I have seen include adding an underscore suffix (<code>vec_</code>) or an <code>m_</code> prefix (<code>m_vec</code>). Then, the initializer reads: <code>vec_(vec)</code> / <code>m_vec(vec)</code>, which is a no-brainer.</p>
",1
49479996,943267,0,"<p>Keep in mind that the C++11 standard says that usage is undefined behavior, see <a href=""https://stackoverflow.com/a/31488191/343721"">M.M's answer</a> (which is IMHO the best answer here). Future standards might define it, but still multibyte number can be stored in big or little endian way. <strong>So you should not use unions neither type casting for type puning if portability is an issue.</strong></p>

<p>If it is not an issue, let me try to upgrade your code a bit to show how the unions might find their place under the C++ sun.</p>

<pre><code>class Color {
    union {
        uint32_t value;
        struct {
            uint8_t b, g, r; // LSB value expected
        } part;
    } data;
public:
    uint32_t &amp;value;
    uint8_t &amp;r, &amp;g, &amp;b;
    Color()
        : value(data.value)
        , r(data.part.r)
        , g(data.part.g)
        , b(data.part.b)
    { value = 0; }
    Color(Color const&amp; c) : Color() { value = c.value; }
    Color(uint32_t _value) : Color() { value = _value; }
    Color&amp; operator=(Color const&amp; c) { value = c.value;}
    Color&amp; operator=(uint32_t _value) { value = _value;}
};
</code></pre>

<p><strong>Explanation</strong></p>

<ul>
<li>struct inside union should have name: ISO C++ prohibits anonymous structs, however g++ would compile them</li>
<li>other constructors delegates to default constructor to copy values, not references (C++11)</li>
<li>the third constructor is here for comfortable implicit call</li>
<li>the construct assumes that multibyte numbers are stored in LSB order </li>
</ul>

<p><strong>Usage</strong></p>

<pre><code>Color c1 = 0xAABBCC; // implicit call
std::cout &lt;&lt; hex &lt;&lt; +c1.r &lt;&lt; endl; // AA
Color c2 = c1; // copy constructor
c2.g = 127;
std::cout &lt;&lt; hex &lt;&lt; +c1.g &lt;&lt; "" "" &lt;&lt; +c2.g &lt;&lt; endl; // BB 7F
c1 = 0xDEADCD; // assignment operator
std::cout &lt;&lt; hex &lt;&lt; +c1.g &lt;&lt; "" "" &lt;&lt; +c2.g &lt;&lt; endl; // AD 7F
</code></pre>
",0
50282077,1830158,17,"<p>Funny that there is no correct solution on this page yet. So, the following is the correct one:</p>
<p>In case of the forward iterator the solution is straight forward:</p>
<pre><code>std::list&lt; int &gt;::iterator i = myList.begin();
while ( i != myList.end() ) {
  if ( *i == to_delete ) {
    i = myList.erase( i );
  } else {
    ++i;
  } 
}
</code></pre>
<p>In case of reverse iterator you need to do the same:</p>
<pre><code>std::list&lt; int &gt;::reverse_iterator i = myList.rbegin();
while ( i != myList.rend() ) {
  if ( *i == to_delete ) {
    i = decltype(i)(myList.erase( std::next(i).base() ));
  } else {
    ++i;
  } 
}
</code></pre>
<p>Notes:</p>
<ul>
<li>You can construct a <code>reverse_iterator</code> from an iterator</li>
<li>You can use the return value of <code>std::list::erase</code></li>
</ul>
",2
48669400,1830158,3,"<p>And here is the piece of code to convert the result of erase back to a reverse iterator in order to erase an element in a container while iterating in the reverse. A bit strange, but it works even when erasing the first or last element:</p>

<pre><code>std::set&lt;int&gt; set{1,2,3,4,5};

for (auto itr = set.rbegin(); itr != set.rend(); )
{    
    if (*itr == 3)
    {
        auto it = set.erase(--itr.base());
        itr = std::reverse_iterator(it);            
    }
    else
        ++itr;
}
</code></pre>
",0
48329393,1826159,1,"<p>Of course, the C++ answer should be <code>std::swap</code>.</p>

<p>However, there is also no third variable in the following implementation of <code>swap</code>:</p>

<pre><code>template &lt;typename T&gt;
void swap (T &amp;a, T &amp;b) {
    std::pair&lt;T &amp;, T &amp;&gt;(a, b) = std::make_pair(b, a);
}
</code></pre>

<p>Or, as a one-liner:</p>

<pre><code>std::make_pair(std::ref(a), std::ref(b)) = std::make_pair(b, a);
</code></pre>
",0
48530715,5803953,0,"<p>See <a href=""https://stackoverflow.com/a/48530698/603828"">my answer</a> to a similar question. C#'s static-constructor metaphor can be done in C++.</p>
",0
57863251,4937180,1,"<p>This is because, ""the type of a pointer is the type of object the pointer points to"". So, </p>

<ol>
<li>If we have base type pointer (*B): </li>
</ol>

<p>then we expect a base type object (and would like to access its functionalities) at the address pointed by B, and if we get a derived type object at that address then also we are able to access the required functionalities. This is because derived type is-a base type.</p>

<ol start=""2"">
<li>If we have derived type pointer (*D):</li>
</ol>

<p>then we expect a derived type object at the address pointed by D and if we get base type object there then we will not be able to access derived class info from the base type object since base type is-not-a derived type.</p>
",0
51909977,9123022,2,"<p>Following how <a href=""https://en.cppreference.com/w/cpp/utility/optional"" rel=""nofollow noreferrer"" title=""std::optional"">std::optional</a> operates, you can create your own simpler object wrapper template:</p>

<pre><code>#include &lt;iostream&gt;

template &lt;typename T_&gt;
struct Wrapper
{
    union {
        char dummy_;
        T_ value_;
    };
    bool shouldDestroy_ {true};

    template&lt;typename ...Args&gt;
    Wrapper(Args &amp;&amp;... args) :
        value_(std::forward&lt;Args&gt;(args)...)
    {
    }

    const T_ &amp;value() const { return value_; }
    T_ &amp;value() { return value_; }

    const T_ *get() const { return &amp;value_; }
    T_ *get() { return &amp;value_; }

    const T_ *operator-&gt;() const { return get(); }
    T_ *operator-&gt;() { return get(); }

    void destroy(bool destroy) { shouldDestroy_ = destroy; }

    ~Wrapper()
    {
        if (shouldDestroy_) {
            value_.~T_();
        }
    }

};

int main()
{
    struct Foo
    {
        Foo() { std::cout &lt;&lt; ""Foo()\n""; }
        Foo(int value) { std::cout &lt;&lt; ""Foo("" &lt;&lt; value &lt;&lt; "")\n""; }
        ~Foo() { std::cout &lt;&lt; ""~Foo()\n""; }

        void display(const char *str) { std::cout &lt;&lt; str &lt;&lt; ""\n""; }
    };

    std::cout &lt;&lt; ""Running...\n"";

    // example 1 construct/destructed    
    {
        Wrapper&lt;Foo&gt; a;
        a.value().display(""via value 1"");
        a-&gt;display(""via operator 1"");
    }

    // example 2 construct/destructed    
    {
        Wrapper&lt;Foo&gt; a(2);
        a.value().display(""via value 2"");
        a-&gt;display(""via operator 2"");
    }

    // example 3 construct NOT destructed    
    {
        Wrapper&lt;Foo&gt; a(3);
        a.value().display(""via value 3"");
        a-&gt;display(""via operator 3"");

        // do not allow destroy
        a.destroy(false);
    }

    return 0;
}
</code></pre>

<p>And the output will be as follows:</p>

<pre><code>Running...
Foo()
via value 1
via operator 1
~Foo()
Foo(2)
via value 2
via operator 2
~Foo()
Foo(3)
via value 3
via operator 3
</code></pre>
",0
48440461,2528995,0,"<p>copy_if is useful if you want to leave the original string untouched and also if you want to want remove multiple characters like CR &amp; LF in this example.</p>

<pre><code>const std::string input = ""Hello\r\nWorld\r\n"";
std::string output;
output.reserve(input.length());

std::copy_if(input.begin(), input.end(),
           std::back_inserter(output),
           [] (char c) { return c != '\r' &amp;&amp; c != '\n'; });
</code></pre>
",0
54558032,2201012,1,"<p>Here is my solution for single threaded reentry prevention using RAII:</p>

<pre><code>    struct NestingTracker
    {
        NestingTracker(uint32_t &amp;cnt) : _cnt(cnt) { ++_cnt; }
        ~NestingTracker()                         { assert(_cnt); --_cnt; }
        uint32_t&amp; _cnt;
    };

#define NO_REENTRY(x)                        \
    static uint32_t cur_nesting = 0;         \
    if (cur_nesting)                         \
        return (x);                             \
    NestingTracker nesting_track(cur_nesting)
</code></pre>

<p>use as</p>

<pre><code>void f(...)
{
    NO_REENTRY(void());
    ...
}
</code></pre>
",0
52172329,2706129,3,"<p>Use a pointer, <em>&amp; better initialized</em>:</p>
<pre><code>class Node {
    char * cargo = nullptr;
    Node * left = nullptr;
    Node * right = nullptr;
};
</code></pre>
<p><strong>Modern C++</strong></p>
<p>It is a better practice to use <strong>smart-pointers</strong> (unique_ptr, shared_ptr, etc.), instead of memory allocations by 'new':</p>
<pre><code>#include &lt;string&gt;
#include &lt;memory&gt; // For 'std::unique_ptr' 

class Node {
public:
    std::string cargo;
    std::unique_ptr&lt;Node&gt; left;
    std::unique_ptr&lt;Node&gt; right;
};

int main()
{
    auto bt = std::make_unique&lt;Node&gt;();

    (*bt).cargo = &quot;Coffee&quot;;
    (*bt).left = std::make_unique&lt;Node&gt;();
}
</code></pre>
",1
56485075,1696086,1,"<p>Since the goal is to be fast, this is a improvement on <a href=""https://youtu.be/vrfYLlR8X8k?t=3839"" rel=""nofollow noreferrer"">andrei alexandrescu's improvement</a>. His version was already faster than the naive way (dividing by 10 at every digit). The version below is faster at least on x86-64 and ARM for most sizes.</p>

<p>Benchmarks for this version vs alexandrescu's version on my <a href=""https://github.com/facebook/folly/pull/1158"" rel=""nofollow noreferrer"">PR on facebook folly</a>.</p>

<pre><code>inline uint32_t digits10(uint64_t v)
{
  std::uint32_t result = 0;
  for (;;)
  {
    result += 1
            + (std::uint32_t)(v&gt;=10)
            + (std::uint32_t)(v&gt;=100)
            + (std::uint32_t)(v&gt;=1000)
            + (std::uint32_t)(v&gt;=10000)
            + (std::uint32_t)(v&gt;=100000);
    if (v &lt; 1000000) return result;
    v /= 1000000U;
  }
}
</code></pre>
",0
52194446,1802334,0,"<p>I'd recommend to adapt the code from glib C function <a href=""https://developer.gnome.org/glib/stable/glib-String-Utility-Functions.html#g-str-to-ascii"" rel=""nofollow noreferrer""><code>g_str_to_ascii()</code></a> to C++:</p>

<p><a href=""https://github.com/GNOME/glib/blob/master/glib/gtranslit.c#L330"" rel=""nofollow noreferrer"">Link to <code>g_str_to_ascii()</code> code</a></p>
",0
51317931,2249108,2,"<p>Yes, sometimes you may wish to return void() instead of just nothing.</p>

<p>Consider a void function that wants to call some pass-through void functions without a bunch of if-else.</p>

<pre><code>return 
  InputEvent == E_Pressed ? Controller-&gt;Grip() :
  InputEvent == E_Released ? Controller-&gt;Release() :
  InputEvent == E_Touched ? Controller-&gt;Touch() : void();
</code></pre>
",0
52788941,2865036,0,"<p>There is no good reason for that, I think Stepanov proposed that there should be a free <code>operator=</code> and many good stuff can be done with that (even more than what can be done with the move assignment). I can't find the citation but Stepanov went as a far as to suggest that the constructors could be free functions <a href=""http://www.stlport.org/resources/StepanovUSA.html"" rel=""nofollow noreferrer"">http://www.stlport.org/resources/StepanovUSA.html</a>.</p>

<p>There is a way around it, which is to systematically <em>declare</em> a <code>template&lt;class Other&gt; A&amp; operator=(Other const&amp; t);</code> in inside all your classes, in this way you leave the option to anyone to define a custom assignment operator. </p>

<p>Of course you can't do this with a class you don't have control over.</p>

<p>Having said that it is nowadays not <em>that</em> bad since we have move assignment. And in some sense conversion operators <code>B::operator A() const{...}</code> are almost like a custom copy assignment. Conversion operators are now usable because of <code>explicit</code>. However you have to have control over the second type (<code>B</code>), the right-hand type in assignment. </p>

<p>Next question is why conversion operator need to be members them selves? Again, I don't think there is a good reason.</p>
",0
59228793,3593687,0,"<p>I had the same question (<a href=""https://stackoverflow.com/questions/59226791/why-am-i-not-able-to-modify-the-contents-of-const-int-even-with-const-castint/59226823#59226823"">Why am I not able to modify the contents of const int even with const_cast&lt;int*&gt;?</a>) . I think answered here wonderfully by everyone. Just adding the assembly output from compiler</p>

<p>This is my original code</p>

<pre><code>const int y = 7;
int* a = new int;
a = const_cast&lt;int*&gt;(&amp;y); 
*a = 8;
std::cout &lt;&lt; (int)*(&amp;y) &lt;&lt; std::endl;
</code></pre>

<p>This is the assembly output</p>

<pre><code>std::cout &lt;&lt; (int)*(&amp;y) &lt;&lt; std::endl;
00381CB6  push        offset std::endl&lt;char,std::char_traits&lt;char&gt; &gt; (03813C5h)  
**00381CBB  push        7**  
00381CBD  mov         ecx,dword ptr [_imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A (03900ACh)]  
00381CC3  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (03900B8h)]  
00381CC9  mov         ecx,eax  
00381CCB  call        dword ptr [__imp_std::basic_ostream&lt;char,std::char_traits&lt;char&gt; &gt;::operator&lt;&lt; (03900BCh)]  
</code></pre>

<p>So the compiler will just replace the const variables with its actual value during compile time. </p>
",0
55841012,3157098,0,"<p>I found a new way to do it. It is non-standard and this is an entirely new way to do it.
So consider using this approach cautiously.</p>

<p>Use the following header file: </p>

<p>SetError.h:</p>

<pre><code>#include &lt;string&gt; // for string class 



#ifndef SET_ERROR_IS_DEFINED
#define SET_ERROR_IS_DEFINED

class Error {

public:
    int code = 0;
    std::string errorMessage;
    std::string fileName;
    std::string functionName;

    Error() {}

    Error(int _errorCode, std::string _functionName = """", std::string _errorMessage = """", std::string _fileName = """")
    {
        code = _errorCode;
        functionName = _functionName;
        errorMessage = _errorMessage;
        fileName = _fileName;
    }
};

#if defined(_DEBUG) || !defined(NDEBUG) 
#define ___try { _ERROR.code = 0; bool __valid_try_mode_declared; 
#define ___success }
#define SetError(pErrorData) __valid_try_mode_declared = true; _ERROR = *pErrorData; delete pErrorData;
#else
#define ___try { _ERROR.code = 0;
#define ___success }
#define SetError(pErrorData) _ERROR = *pErrorData; delete pErrorData; 
#endif

#endif

inline Error _ERROR;
</code></pre>

<p>Include it everyware.</p>

<p>Example of how to use:</p>

<p>Main.cpp:</p>

<pre><code>#include ""SetError.h""
#include &lt;iostream&gt;


bool SomeFunction(int value) ___try; 
{ 


    if (value &lt; 0) {
        SetError(new Error(10, ""SomeFunction"", ""Some error"", ""File main.cpp""));
        return false;
    }

    return true;
} ___success; // You mast to warp the function with both ___try and ___success
// These keywords must be at the start and the end of the function!




int main()
{
    using namespace std;

    bool output = SomeFunction(-1);

    if (_ERROR.code != 0) { // This is how you check the error code. using the global _ERROR object
        cout &lt;&lt; ""error code: "" &lt;&lt; _ERROR.code &lt;&lt; "", from function: "" 
            &lt;&lt; _ERROR.functionName &lt;&lt; "", from file: "" &lt;&lt; _ERROR.fileName;
    }

    cout &lt;&lt; endl &lt;&lt; ""Founction returned: "" &lt;&lt; output &lt;&lt; endl;

    return 1;
}
</code></pre>

<p>If you have some functions that run in another thread, these functions need to be inside namespace and then you can do this:</p>

<pre><code>namespace FunctionsInSomeThread
{
    #include ""SetError.h""

    bool SomeFunc1() ___try;
    {
        SetError(new Error(5, ""SomeFunction2"", ""Some error from another thread"", ""File main.cpp""))
        return true;
    } ___success;

    bool SomeFunc2() ___try;
    {
        SetError(new Error(5, ""SomeFunction2"", ""Some error from another thread"", ""File main.cpp""))
            return true;
    } ___success;

}
</code></pre>

<p>And to access <code>_Error</code>, you need to add the namespace of the thread</p>

<pre><code>if (FunctionsInSomeThread::_ERROR.code != 0)
{
    // Error handling
}
</code></pre>

<p>Or in case it is inside the same namespace then no need to add FunctionsInSomeThread:: before.</p>

<p>The idea behind this is that you can't warp the function only with <code>___success;</code> keyword. You will get compile error. So the developer will never return old error code from another function.</p>

<p>If you wrote <code>___success;</code> at the end of the codeblock, you must write also <code>___try;</code> at the start!
You also can't use <code>SetError</code> macro if it is not wrapped in <code>___try;</code> and <code>___success;</code>.</p>

<p>The idea come from the AutoIt language where you have this consept:
<a href=""https://www.autoitscript.com/autoit3/docs/functions/SetError.htm"" rel=""nofollow noreferrer"">https://www.autoitscript.com/autoit3/docs/functions/SetError.htm</a></p>

<p>So this is almost the same in C if you use this header. </p>
",8
48274516,3157098,5,"<p>You can return a <code>std::pair</code> holding both an error code (or error object) and the desired return object. The object of interest needs a default constructor or value so you can return something even when an error is encountered.</p>
",0
52005540,4873493,1,"<p>New answer for a very old question.  Rationale:  Better tools.</p>

<p>Starting in C++11, one can easily store this quantity in a <code>std::chrono::system_clock::time_point</code>:</p>

<pre><code>#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;

int
main()
{
    using namespace std;
    using namespace std::chrono;
    istringstream in{""1296575549:573352""};
    long si, usi;
    char sep;
    in &gt;&gt; si &gt;&gt; sep &gt;&gt; usi;
    system_clock::time_point tp{seconds{si} + microseconds{usi}};
}
</code></pre>

<p>Though the epoch of <code>system_clock</code> is unspecified in C++11, every implementation is tracking <a href=""https://en.wikipedia.org/wiki/Unix_time"" rel=""nofollow noreferrer"">Unix Time</a> (time since 1970-01-01 00:00:00 UTC, excluding leap seconds).  Different implementations will have different precisions for <code>system_clock::time_point</code>, but you don't really have to care about that when converting into <code>system_clock::time_point</code> as shown above.  The <code>&lt;chrono&gt;</code> library will just do the right thing.</p>

<p>Starting in C++20 the <a href=""https://en.wikipedia.org/wiki/Unix_time"" rel=""nofollow noreferrer"">Unix Time</a> measure of <code>system_clock::time_point</code> will be specified, and you will be able to stream it out in a human readable form:</p>

<pre><code>cout &lt;&lt; tp &lt;&lt; '\n';
</code></pre>

<p>For this example that will output:</p>

<pre><code>2011-02-01 15:52:29.573352
</code></pre>

<p>On some platforms there may be a few trailing zeroes on this output, depending on the precision of <code>system_clock::time_point</code> on that platform.  This is a UTC date/time.  There will also be ways to convert this to a particular time zone if desired (in C++20).</p>

<p>You can experiment with this part of C++20 today by using <a href=""https://github.com/HowardHinnant/date"" rel=""nofollow noreferrer"">Howard Hinnant's date/time library</a>.  This will require an additional <code>#include ""date/date.h""</code> (<code>""date/tz.h""</code> for time zone functionality), and a <code>using namespace date;</code> to enable the <code>system_clock::time_point</code> streaming operator.</p>

<p>If it is known that your count of seconds includes leap seconds (Unix Time stamps don't), C++20 also provides a way to deal with that:</p>

<p>Just change <code>system_clock</code> to <code>utc_clock</code> in the above example and the new output will be:</p>

<pre><code>2011-02-01 15:52:05.573352
</code></pre>

<p>which accounts for the 24 leap seconds inserted prior to this date.</p>
",2
52917808,3099095,3,"<p>Since this question is tagged C++ (and I had the same question), I presume that the OP wanted an example that uses the Windows API. I've done this using the <code>GetTcpTable2</code> and <code>SetTcpEntry</code> APIs. You'll need to call <code>GetTcpTable2</code> and filter the results to the connection you want to terminate, then pass it to <code>SetTcpEntry</code>. Note that I took a bit of a shortcut with allocating memory for <code>GetTcpTable2</code>, so if you're writing production code, you'll want to read the Microsoft documentation on how best to correctly use the API.</p>

<p>Feel free to use the code I wrote and published under the MIT licence on Github:</p>

<ul>
<li><a href=""https://github.com/nzbart/TcpConnectionKiller/blob/master/TcpConnectionKiller/TcpConnectionKiller.cpp"" rel=""nofollow noreferrer"">TcpConnectionKiller.cpp</a></li>
</ul>
",2
57961846,11725413,9,"<p>Since C++11, you can also use <a href=""https://en.cppreference.com/w/cpp/language/list_initialization"" rel=""nofollow noreferrer"">list-initialization</a> of a non-static member directly inside the class declaration:</p>
<pre class=""lang-cpp prettyprint-override""><code>class ClassName
{
public:
    ClassName() {}

private:
    std::vector&lt;int&gt; m_vecInts {1, 2, 3}; // or = {1, 2, 3}
}
</code></pre>
",1
53333864,3665257,2,"<p>C++11 provides the <a href=""http://www.cplusplus.com/reference/random/"" rel=""nofollow noreferrer""><code>&lt;random&gt;</code></a> library. To generate a <code>long</code>, you would use code like:</p>

<pre><code>#include &lt;random&gt;
#include &lt;climits&gt;

...

std::default_random_engine generator;
std::uniform_int_distribution&lt;long&gt; distribution(LONG_MIN,LONG_MAX);
long result = distribution(generator);
</code></pre>
",0
53310871,3608305,1,"<p>The solution to my problem today was slightly different that the other answers here.  </p>

<p>In my case, the problem was caused by a missing close bracket (<code>}</code>) at the end of one of the header files in the include chain.  </p>

<p>Essentially, what was happening was that <code>A</code> was including <code>B</code>. Because <code>B</code> was missing a <code>}</code> somewhere in the file, the definitions in <code>B</code> were not correctly found in <code>A</code>. </p>

<p>At first I thought I have circular dependency and added the forward declaration <code>B</code>. But then it started complaining about the fact that something in <code>B</code> was an incomplete type. That's how I thought of double checking the files for syntax errors.</p>
",1
58588005,11428147,-2,"<p>// This worked with g++ compiler.
//Calc.h</p>

<pre><code>class Calc
{
    int Sum(int x, int y);
};
</code></pre>

<p>//Calc.cpp</p>

<pre><code>inline int Calc::Sum(int x, int y)
{
    return (x+y);
}
</code></pre>
",0
54021926,5579641,3,"<p>Although in C++11 the constants in <code>std::numeric_limits</code> are <code>constexpr</code> so that you can use them in templates etc., there's still at least one scenario when you <em>must</em> use macros from <code>&lt;climits&gt;</code>/<code>&lt;cstdint&gt;</code> instead. It's preprocessor. In C++, preprocessor is as limited as it is in C, so it can't use normal variables, be it a <code>const</code> or <code>constexpr</code> one. Much less so members of structures, and even less so templated structures. Thus you can't do the following:</p>

<pre><code>#include &lt;cstddef&gt;
#include &lt;limits&gt;

// Won't work!
#if std::numeric_limits&lt;std::size_t&gt;::max() &gt; std::numeric_limits&lt;unsigned&gt;::max()
// ...
#endif
</code></pre>

<p>Instead, you should resort to the following working (and more readable!) variant:</p>

<pre><code>#include &lt;cstdint&gt;
#include &lt;climits&gt;

// Works fine
#if SIZE_MAX &gt; UINT_MAX
// ...
#endif
</code></pre>
",0
54021926,5579641,3,"<p>Although in C++11 the constants in <code>std::numeric_limits</code> are <code>constexpr</code> so that you can use them in templates etc., there's still at least one scenario when you <em>must</em> use macros from <code>&lt;climits&gt;</code>/<code>&lt;cstdint&gt;</code> instead. It's preprocessor. In C++, preprocessor is as limited as it is in C, so it can't use normal variables, be it a <code>const</code> or <code>constexpr</code> one. Much less so members of structures, and even less so templated structures. Thus you can't do the following:</p>

<pre><code>#include &lt;cstddef&gt;
#include &lt;limits&gt;

// Won't work!
#if std::numeric_limits&lt;std::size_t&gt;::max() &gt; std::numeric_limits&lt;unsigned&gt;::max()
// ...
#endif
</code></pre>

<p>Instead, you should resort to the following working (and more readable!) variant:</p>

<pre><code>#include &lt;cstdint&gt;
#include &lt;climits&gt;

// Works fine
#if SIZE_MAX &gt; UINT_MAX
// ...
#endif
</code></pre>
",0
56182809,7616867,3,"<p><code>C++11</code> approach using <a href=""https://en.cppreference.com/w/cpp/algorithm/all_any_none_of"" rel=""nofollow noreferrer"">std::all_of</a>:</p>

<pre><code>std::all_of(std::begin(name), std::end(name),
    [](char c){ return std::isalpha(c); });
</code></pre>

<p><a href=""https://en.cppreference.com/w/cpp/algorithm/all_any_none_of"" rel=""nofollow noreferrer"">std::all_of</a> will only return true if <em>all of</em> the elements are true according to the supplied <em>predicate</em> function.</p>
",0
50835105,6938219,3,"<p>I have tested some solutions proposed here and checked <code>memcmp</code> <a href=""https://github.com/gcc-mirror/gcc/blob/master/libiberty/memcmp.c"" rel=""nofollow noreferrer"">source code</a> which is not optimized for the OP needs since it has an additional requirement to perform sorting, leading it to compare <code>unsigned char</code> one by one.</p>

<p>In the following, I propose an optimized function <code>check_memory_zeroed</code> which performs most of the check on the biggest aligned int available, making it portable, and I compare it with the other solutions proposed in this thread. Time measurement is performed and results printed.</p>

<p>It shows that the proposed solution is near twice better than wallyk's <em>obvious portable high efficiency method</em> and does not need to create an additional array, and six times better than char by char comparison or mihaif's shifted array which saves RAM compared to wallyk's one.</p>

<p>I have also tested my solution without aligning the words <code>check_memory_zeroed_bigestint_not_aligned</code> and surprisingly, it performs even better. If someone has an explanation, he is welcome.</p>

<p>Here is the code with functional and performance tests on a 1Gb table (the proposed optimized function is the fisrt one : check_memory_zeroed):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;assert.h&gt;
#include &lt;time.h&gt;

#define BIG_TAB_SIZE 1000000000

typedef intmax_t biggestint;

int check_memory_zeroed (void* ptr, size_t size)
{
    if (ptr == NULL) return -1;
    int bis = sizeof(biggestint);
    char* pc = (char*) ptr;
    biggestint* pbi0 = (biggestint*) pc;
    if ((size_t) pc % bis) /* is aligned ? */
        pbi0 = (biggestint*) (pc + (bis - ((size_t) pc % bis))); /* minimal pointer larger than ptr but aligned */
    assert ((size_t) pbi0 % bis == 0); /* check that pbi0 is aligned */
    for (char* p = pc; p &lt; (char*) pbi0; p++)
        if(*p) return 0; /* check beginning of non aligned array */
    biggestint* pbi = pbi0;
    biggestint* pbiUpper = ((biggestint*) (pc + size)) - 1;
    for (;pbi &lt;= pbiUpper; pbi++)
        if(*pbi) return 0; /* check with the biggest int available most of the array : its aligned part */
    for (char* p = (char*) pbi; p &lt; pc + size; p++)
        if(*p) return 0; /* check end of non aligned array */
    return 1;
}

int check_memory_zeroed_bigestint_not_aligned (void* ptr, size_t size)
{
    if (ptr == NULL) return -1;
    biggestint* pbi = (biggestint*) ptr;
    biggestint* pbiUpper = ((biggestint*) (((char*) ptr) + size)) - 1;
    for (;pbi &lt;= pbiUpper; pbi++)
        if(*pbi) return 0; /* check with the biggest int available most of the array, but without aligning it */
    for (char* p = (char*) pbi; p &lt; ((char*) ptr) + size; p++)
        if(*p) return 0; /* check end of non aligned array */
    return 1;
}

int check_memory_zeroed_by_char (void* ptr, size_t size)
{
    if (ptr == NULL) return -1;
    for (char* p = (char*) ptr; p &lt; ((char*) ptr) + size; p++)
        if(*p) return 0;
    return 1;
}

/* variant of wallyk solution */
int check_memory_zeroed_by_memcmp_and_testblock (void* ptr, size_t size)
{
    void* testblock = malloc(size);
    if (ptr == NULL || testblock == NULL) return -1;
    memset (testblock, 0, sizeof(testblock));
    int res = ! memcmp (testblock, ptr, size);
    free (testblock);
    return res;
}

/* variant of mihaif solution */
int check_memory_zeroed_by_memcmp_with_shifted_array (void* ptr, size_t size)
{
    if (ptr == NULL) return -1;
    char* pc = (char*) ptr;
    return (*pc) || memcmp(pc, pc + 1, size - 1);
}

int test() {
    /* check_memory_zeroed (void* ptr, size_t size) */
    char tab[16];
    for (int i = 0; i &lt; 8; i++)
        for (int j = 0; j &lt; 8; j++) {
            for (int k = 0; k &lt; 16; k++) tab[k] = (k &gt;= i &amp;&amp; k &lt; 16 - j) ? 0 : 100 + k;
            assert(check_memory_zeroed(tab + i, 16 - j - i));
            if (i &gt; 0) assert(tab[i-1] == 100 + i - 1);
            if (j &gt; 0) assert(tab[16 - j] == 100 + 16 - j);
            for (int k = i; k &lt; 16 - j; k++) {
                tab[k] = 200+k;
                assert(check_memory_zeroed(tab + i, 16 - j - i) == 0);
                tab[k] = 0;
            }
        }
    char* bigtab = malloc(BIG_TAB_SIZE);
    clock_t t = clock();
    printf (""Comparison of different solutions execution time for checking an array has all its values null\n"");
    assert(check_memory_zeroed(bigtab, BIG_TAB_SIZE) != -1);
    t = clock() - t;
    printf (""check_memory_zeroed optimized : %f seconds\n"",((float)t)/CLOCKS_PER_SEC);
    assert(check_memory_zeroed_bigestint_not_aligned(bigtab, BIG_TAB_SIZE) != -1);
    t = clock() - t;
    printf (""check_memory_zeroed_bigestint_not_aligned : %f seconds\n"",((float)t)/CLOCKS_PER_SEC);
    assert(check_memory_zeroed_by_char(bigtab, BIG_TAB_SIZE) != -1);
    t = clock() - t;
    printf (""check_memory_zeroed_by_char : %f seconds\n"",((float)t)/CLOCKS_PER_SEC);
    assert(check_memory_zeroed_by_memcmp_and_testblock(bigtab, BIG_TAB_SIZE) != -1);
    t = clock() - t;
    printf (""check_memory_zeroed_by_memcmp_and_testblock by wallyk : %f seconds\n"",((float)t)/CLOCKS_PER_SEC);
    assert(check_memory_zeroed_by_memcmp_with_shifted_array(bigtab, BIG_TAB_SIZE) != -1);
    t = clock() - t;
    printf (""check_memory_zeroed_by_memcmp_with_shifted_array by mihaif : %f seconds\n"",((float)t)/CLOCKS_PER_SEC);
    free (bigtab);

    return 0;
}

int main(void) {
    printf(""Size of intmax_t = %lu\n"", sizeof(intmax_t));
    test();
    return 0;
}
</code></pre>

<p>And the results for comparison of different solutions execution time for checking an array has all its values null:</p>

<ul>
<li>Size of intmax_t = 8 </li>
<li>check_memory_zeroed optimized : 0.331238 seconds </li>
<li>check_memory_zeroed_bigestint_not_aligned : 0.260504 seconds</li>
<li>check_memory_zeroed_by_char : 1.958392 seconds </li>
<li>check_memory_zeroed_by_memcmp_and_testblock by wallyk : 0.503189 seconds </li>
<li>check_memory_zeroed_by_memcmp_with_shifted_array by mihaif : 2.012257 seconds</li>
</ul>
",1
56513070,5496491,0,"<p>We can cast returned reference to pointer, so theoretically it makes more info available (address and value) than returning a copy (value).</p>

<p>And it's possible to hack const ref to mutable with const_cast.</p>

<p>Compiler will try to use value from original register, address or literal anyway.</p>

<p>Alternative ways for which goal? To make sure that staying constantly correct wouldn't add extra work. For const reference and const I find CR &amp; CN macros handy.</p>

<pre><code>#define CN  const
#define CR  const&amp;         // Constant reference
#define CDa const*         // mutable pointer to constant data
#define CPD const * const  // constant pointer to constant data
const int&amp;  verbose() const;
int CR      shorter() CN;
</code></pre>

<p>Side-effect is that declarations get shorter and as lines get shorter, the number of lines also decreases. Matter of taste tho... But when combined with DMAP macro, it seems to have an advantage.</p>

<pre><code>typedef std::map&lt;size_t, float&gt;     TypeMap_Of_size_t_vs_float;
TypeMap_Of_size_t_vs_float          m_Map;
const TypeMap_Of_size_t_vs_float&amp;   verboseIsNice() const
{
    return m_MyMap;
}
for each (auto myElement in verboseIsNice()) 
{
    myElement.foo();
}
</code></pre>

<p>vs</p>

<pre><code>DMAP(SZ, Flo)  m_Map;                    // typedefs MSZFlo=std::map&lt;size_t, float&gt;
MSZFlo CR      tldr()                 CN { return m_Map; }
fe(el, tldr()) el.foo();
</code></pre>

<p><em>Without auto and with using iterators the example would show more than 333% of difference.</em></p>
",0
48980086,5183203,-1,"<p>Modern C++, with a bit of <a href=""https://isocpp.org/wiki/faq/const-correctness"" rel=""nofollow noreferrer""><code>const</code> correctness</a>...</p>

<pre><code>/*BINFMTCXX: -Wall -Werror -std=c++17
*/

   #include &lt;iostream&gt;
   #include &lt;string&gt;
   #include &lt;vector&gt;
   using std::string; using std::vector; using std::cerr;

int main( int argc, char * const argv[] )
   {
   assert( argc &gt;= 1 ); // exploratory -- could fail in principle, but not really
   const vector&lt;string&gt; args(argv+1,argv+argc); // convert C-style to modern C++
   for ( auto a : args ) cerr&lt;&lt;(a==""yes"")&lt;&lt;""\n""; // operator '==' works as expected
   }
</code></pre>

<hr>

<p>Note: The standard doesn't guarantee that you can use <code>const</code> in the signature of <code>main</code>, <em>nor does it forbid it</em>.</p>

<p>As used here, <code>const</code> ensures that we won't change things we don't intend to change -- which is the purpose of <code>const</code> in the C++ language.</p>

<p>See also...</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/25386698/passing-argv-as-const"">Passing argv as const</a></li>
<li><a href=""https://stackoverflow.com/q/4207134/86967"">What is the proper declaration of main?</a></li>
<li><a href=""http://www.manpages.info/linux/getopt.3.html"" rel=""nofollow noreferrer"">int getopt(int argc, char * const argv[],
      const char *optstring)</a> -- notice signature</li>
<li><a href=""https://stackoverflow.com/q/3024197"">What does int argc, char *argv[] mean?</a> -- min value of <code>argc</code></li>
</ul>
",14
53823518,14350886,0,"<p>The easiest way to do it, in my opinion, would be to use a <a href=""https://stackoverflow.com/questions/45723819/what-is-a-span-and-when-should-i-use-one"">span</a>. </p>

<pre><code>#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;gsl/span&gt;

int main() {
    int numbers[] = {2, 4, 6, 8};
    for(auto&amp; num : gsl::span(numbers)) {
            cout &lt;&lt; ""the current number is "" &lt;&lt; num;
    }

    system(""pause"");
}
</code></pre>

<p>Notes:</p>

<ul>
<li>Spans are part of the GSL library. To use them, download the library from <a href=""https://github.com/microsoft/gsl"" rel=""nofollow noreferrer"">here</a>, and add the download path to the compilation command, e.g. <code>g++ -o foo foo.cpp -I/path/to/gsl</code></li>
<li>In C++20, <code>span</code> will be part of the standard, so you would just use <code>std::span</code> and <code>#include &lt;span&gt;</code>.</li>
</ul>
",0
59483012,7213839,10,"<p><a href=""https://en.cppreference.com/w/cpp/language/coroutines"" rel=""nofollow noreferrer"">Coroutines are in the standard library since C++20</a> and uses <code>co_yield</code> instead of <code>yield</code>.</p>
<p>See also: <a href=""https://stackoverflow.com/questions/43503656/what-are-coroutines-in-c20"">What are coroutines in C++20?</a></p>
<p>There are some example usages in the first link: (the second one is probably what you're looking for)</p>
<blockquote>
<ul>
<li><p>uses the <code>co_await</code> operator to suspend execution until resumed</p>
<pre><code>task&lt;&gt; tcp_echo_server() {
   char data[1024];
   while (true) {
      size_t n = co_await socket.async_read_some(buffer(data));
      co_await async_write(socket, buffer(data, n));
   }
}
</code></pre>
</li>
<li><p>uses the keyword <code>co_yield</code> to suspend execution returning a value</p>
<pre><code>generator&lt;int&gt; iota(int n = 0) {
   while (true)
      co_yield n++;
}
</code></pre>
</li>
<li><p>uses the keyword <code>co_return</code> to complete execution returning a value</p>
<pre><code>lazy&lt;int&gt; f() {
   co_return 7;
}
</code></pre>
</li>
</ul>
</blockquote>
",0
55973507,12958451,0,"<p>As mentionned before, there is no such thing as operator[][].
However, here is an an implementation using nested classes similar to what ""jalf"" proposed.  For sake of simplicity, I hardcoded a 3x3 raw array.</p>

<pre><code>    class Array2D final{
    public:
        class PartialArr final{
    private:
        friend Array2D;
        PartialArr(Array2D* ptr, int index) :original(ptr), firstIndex(index) {}
        int firstIndex;
        Array2D* original;
    public:
        int&amp; operator[](int index) { return this-&gt;original-&gt;data[firstIndex][index];  }
    };

        PartialArr operator[](int index) { return PartialArr(this, index); }
    private:
        int data[3][3];
    };

</code></pre>

<p>This solution prevents the user of Array2D to manipulate the data directly when indexing only the first dimension of the array.</p>

<p>const versions of both operator[] could also be added to make the class complete.</p>
",0
55973507,12958451,0,"<p>As mentionned before, there is no such thing as operator[][].
However, here is an an implementation using nested classes similar to what ""jalf"" proposed.  For sake of simplicity, I hardcoded a 3x3 raw array.</p>

<pre><code>    class Array2D final{
    public:
        class PartialArr final{
    private:
        friend Array2D;
        PartialArr(Array2D* ptr, int index) :original(ptr), firstIndex(index) {}
        int firstIndex;
        Array2D* original;
    public:
        int&amp; operator[](int index) { return this-&gt;original-&gt;data[firstIndex][index];  }
    };

        PartialArr operator[](int index) { return PartialArr(this, index); }
    private:
        int data[3][3];
    };

</code></pre>

<p>This solution prevents the user of Array2D to manipulate the data directly when indexing only the first dimension of the array.</p>

<p>const versions of both operator[] could also be added to make the class complete.</p>
",0
51077426,10737644,0,"<p>An addition to the <a href=""https://stackoverflow.com/a/32697209/634821"">answer</a> from @anhoppe. Here's how to convert <code>char*</code>:</p>

<pre><code>#include &lt;codecvt&gt;
#include &lt;locale&gt; 

// ...

std::wstring stringToWstring(const char* utf8Bytes)
{
    //setup converter
    using convert_type = std::codecvt_utf8&lt;typename std::wstring::value_type&gt;;
    std::wstring_convert&lt;convert_type, typename std::wstring::value_type&gt; converter;

    //use converter (.to_bytes: wstr-&gt;str, .from_bytes: str-&gt;wstr)
    return converter.from_bytes(utf8Bytes);
}
</code></pre>

<p>And here's how to convert <code>char*</code> if you also already know the length of the buffer:</p>

<pre><code>#include &lt;codecvt&gt;

// ...

std::wstring stringToWstring(const char* utf8Bytes, const size_t numBytes)
{
    //setup converter
    using convert_type = std::codecvt_utf8&lt;typename std::wstring::value_type&gt;;
    std::wstring_convert&lt;convert_type, typename std::wstring::value_type&gt; converter;

    //use converter (.to_bytes: wstr-&gt;str, .from_bytes: str-&gt;wstr)
    return converter.from_bytes(utf8Bytes, utf8Bytes + numBytes);
}
</code></pre>
",1
54381972,7411515,4,"<p>I was watching Timur Doumler's talk at Meeting C++ 2018 and I finally realised why the standard requires a user-provided constructor here, not merely a user-declared one. It has to do with the rules for value initialisation.</p>

<p>Consider two classes: <code>A</code> has a <strong>user-declared</strong> constructor, <code>B</code> has a <strong>user-provided</strong> constructor:</p>

<pre><code>struct A {
    int x;
    A() = default;
};
struct B {
    int x;
    B() {}
};
</code></pre>

<p>At first glance, you might think these two constructors will behave the same. But see how value initialisation behaves differently, while only default initialisation behaves the same:</p>

<ul>
<li><code>A a;</code> is default initialisation: the member <code>int x</code> is uninitialised.</li>
<li><code>B b;</code> is default initialisation: the member <code>int x</code> is uninitialised.</li>
<li><code>A a{};</code> is value initialisation: the member <code>int x</code> is <strong>zero-initialised</strong>.</li>
<li><code>B b{};</code> is value initialisation: the member <code>int x</code> is uninitialised.</li>
</ul>

<p>Now see what happens when we add <code>const</code>:</p>

<ul>
<li><code>const A a;</code> is default initialisation: this is <strong>ill-formed</strong> due to the rule quoted in the question.</li>
<li><code>const B b;</code> is default initialisation: the member <code>int x</code> is uninitialised.</li>
<li><code>const A a{};</code> is value initialisation: the member <code>int x</code> is <strong>zero-initialised</strong>.</li>
<li><code>const B b{};</code> is value initialisation: the member <code>int x</code> is uninitialised.</li>
</ul>

<p>An uninitialised <code>const</code> scalar (e.g. the <code>int x</code> member) would be useless: writing to it is ill-formed (because it's <code>const</code>) and reading from it is UB (because it holds an indeterminate value). So this rule prevents you from creating such a thing, by forcing you to <em>either</em> add an initialiser <em>or</em> opt-in to the dangerous behaviour by adding a user-provided constructor.</p>

<p>I think it would be nice to have an attribute like <code>[[uninitialized]]</code> to tell the compiler when you're intentionally not initialising an object. Then we wouldn't be forced to make our class not trivially default constructible to get around this corner case. This attribute has actually been <a href=""https://wg21.link/p0632"" rel=""nofollow noreferrer"">proposed</a>, but just like all the other standard attributes, it does not mandate any normative behaviour, being merely a hint to the compiler.</p>
",0
55319496,13661074,0,"<p>There is a proposal to compile linux kernel with zero initialized local variables, see the presentation from linux.conf this year <a href=""https://youtu.be/FY9SbqTO5GQ?t=742"" rel=""nofollow noreferrer"">https://youtu.be/FY9SbqTO5GQ?t=742</a></p>

<p>To accomplish this the presenter team used an experimental gcc switch <code>finit-local-vars</code>, patch is here <a href=""https://gcc.gnu.org/ml/gcc-patches/2014-06/msg00615.html"" rel=""nofollow noreferrer"">https://gcc.gnu.org/ml/gcc-patches/2014-06/msg00615.html</a></p>

<p>I hope this will be eventually merged to gcc main branch and adopted widely. Literally every code style guide I've seen demanded C/C++ coders to make an explicit zero assignment <code>= 0</code> wherever they defined a variable. This is error prone and meaningless monkey work.</p>
",0
55118637,6417817,18,"<p>Since C++17 you can use <a href=""https://en.cppreference.com/w/cpp/filesystem/path/replace_extension"" rel=""noreferrer"">std::filesystem::path::replace_extension</a> with a parameter to replace the extension or without to remove it:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;filesystem&gt;
 
int main()
{
    std::filesystem::path p = &quot;/foo/bar.txt&quot;;
    std::cout &lt;&lt; &quot;Was: &quot; &lt;&lt; p &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Now: &quot; &lt;&lt; p.replace_extension() &lt;&lt; std::endl;
}
</code></pre>
<p><a href=""https://coliru.stacked-crooked.com/view?id=4efe5ae0bd74859e"" rel=""noreferrer"">Compile</a> it with:</p>
<pre><code>g++ -std=c++17 -O2 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out
</code></pre>
<p>Running the resulting binary leaves you with:</p>
<pre><code>Was: &quot;/foo/bar.txt&quot;
Now: &quot;/foo/bar&quot;
</code></pre>
<p>However this does only remove the last file extension:</p>
<pre><code>Was: &quot;/foo/bar.tar.gz&quot;
Now: &quot;/foo/bar.tar&quot;
</code></pre>
",0
48201962,8049834,1,"<p><strong><code>std::map</code> + C++11 lambdas workaround</strong></p>

<p>This method allows for non constants, should give us <code>O(1)</code> amortized <a href=""https://stackoverflow.com/questions/3578083/what-is-the-best-way-to-use-a-hashmap-in-c"">What is the best way to use a HashMap in C++?</a> :</p>

<pre><code>#include &lt;ctime&gt;
#include &lt;functional&gt;
#include &lt;unordered_map&gt;
#include &lt;iostream&gt;

int main() {
    int result;
    int key0 = std::time(NULL) % 3;
    int key1 = (key0 + 1) % 3;
    int key2 = (key0 + 2) % 3;
    std::unordered_map&lt;int,std::function&lt;void()&gt;&gt; m{
        {key0, [&amp;](){ result = 0; }},
        {key1, [&amp;](){ result = 1; }},
        {key2, [&amp;](){ result = 2; }},
    };
    m[key0]();
    std::cout &lt;&lt; key0 &lt;&lt; "" "" &lt;&lt; result &lt;&lt; std::endl;
    m[key1]();
    std::cout &lt;&lt; key1 &lt;&lt; "" "" &lt;&lt; result &lt;&lt; std::endl;
    m[key2]();
    std::cout &lt;&lt; key2 &lt;&lt; "" "" &lt;&lt; result &lt;&lt; std::endl;
}
</code></pre>

<p>Possible output:</p>

<pre><code>1 0
2 1
0 2
</code></pre>

<p>For usage from inside a class, don't forget to build the map statically as shown at: <a href=""https://stackoverflow.com/questions/650162/why-switch-statement-cannot-be-applied-on-strings/42462552#42462552"">Why switch statement cannot be applied on strings?</a></p>
",0
58674894,10839747,1,"<p>Abstractly speaking, reading a file sequentially will not be sped up by using memory mapped files or by first reading it into memory. Memory mapped files make sense if reading the file sequentially is not feasible. Pre-caching the file like in the other answer or just by copying the file to a large string which you could then process by other means - again - only makes sense if reading the file once in sequence is not feasible and you have the RAM for it. This is because the slowest part of the operation is actually getting the data off the disk. And this has to be done regardless, whether you copy the file to RAM or you let the operating system map the data before you can access it or when you let std::iostream read it line by line and let it cache from the file just enough to make this work smoothly.</p>

<p>In practice you could potentially eliminate some copying from ram to ram with the mapped or cached versions, by making shallow copies of the buffer ranges. Still this will not change much because this is RAM->RAM and therefore negligible in comparison to disk->RAM.</p>

<p>The best advice in a situation like yours is therefore not to worry too much and just use std::iostream.</p>

<p>[Ths answer is for archival purposes, because the correct answer is buried in the comments]</p>
",0
51989805,6838408,15,"<p>As of C++17, you can use <a href=""https://en.cppreference.com/w/cpp/language/structured_binding"" rel=""noreferrer"">Structured Bindings</a>:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;tuple&gt;

int main () 
{
    auto [hello, world] = std::make_tuple(&quot;Hello &quot;, &quot;world!&quot;);
    std::cout &lt;&lt; hello &lt;&lt; world &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p><kbd><a href=""http://coliru.stacked-crooked.com/a/0931d2fa513fa9ca"" rel=""noreferrer"">Demo</a></kbd></p>
",0
48798777,16841952,3,"<p>A little prettier than casting -- assigning to a const reference doesn't require an explicit cast :</p>

<pre><code>A foo;
const auto&amp; cfoo = foo;
double b = cfoo.Value(); // will use Value()const
</code></pre>

<p>In practice, if you use <code>const</code> religiously in all your function arguments when you can, it is likely you are going to pass <code>foo</code> to <code>bar(const A&amp; x)</code> at some point.</p>
",1
52413963,7809623,0,"<p>I ""cross posted"" this on comp.lang.c++ where Alf P. Steinbach made me realize that TU's compiled against 'Declaration 2' is leaking memory (which is rather embarrassing). Based on this we will revert to 'Declaration 1' and recompile every domain that is compiled against 'Declaration 2', hence we do not have header or ABI decoupling :) but we are in a valid state. We'll fix this in the next release cycle.</p>
",0
54514494,11516657,3,"<p>In GNUC++ (seems to be obsolete since 2.5, a long time ago :) See the answers here: <a href=""https://stackoverflow.com/questions/1601201/c-struct-initialization-using-labels-it-works-but-how"">C struct initialization using labels. It works, but how?</a>), it is possible to initialize a struct like this:</p>

<pre><code>struct inventory_item {
    int bananas;
    int apples;
    int pineapples;
};

inventory_item first_item = {
    bananas: 2,
    apples: 49,
    pineapples: 4
};
</code></pre>
",0
50900650,13794171,6,"<p>The quick &amp; dirty way is to write</p>

<pre><code>((x % divisor) + divisor) % divisor
</code></pre>

<p>For example, <code>((-3 % 5) + 5) % 5 == 2</code>. However this performs two separate divisions, and since divisions are one of the slowest arithmetic operations you might like one of these alternatives:</p>

<p>(1) General <code>mod</code> for integer or floating point</p>

<pre><code>int mod(int x, int divisor)
{
    int m = x % divisor;
    return m + (m &lt; 0 ? divisor : 0);
}

template&lt;class Num&gt; Num mod(Num x, Num divisor)
{
    Num m = x % divisor;
    return m + (m &lt; 0 ? divisor : 0);
}
</code></pre>

<p>(2) Non-branching <code>mod</code> for 32-bit integers</p>

<pre><code>int mod(int x, int divisor)
{
    int m = x % divisor;
    return m + ((m &gt;&gt; 31) &amp; divisor);
}
</code></pre>

<p>All this assumes that the <code>divisor</code> is always positive.</p>
",0
56403303,10135244,0,"<p>For what it's worth, I had the same problem but it wasn't because of an <strong>extra</strong> semicolon, it was because I'd forgotten a semicolon on the previous statement. </p>

<p>My situation was something like </p>

<pre><code>mynamespace::MyObject otherObject

for (const auto&amp; element: otherObject.myVector) {
  // execute arbitrary code on element
  //...
  //...
} 
</code></pre>

<p>From this code, my compiler kept telling me: </p>

<p><code>error: expected unqualified-id before for (const auto&amp; element: otherObject.myVector) {
etc...
</code>
which I'd taken to mean I'd writtten the for loop wrong. Nope! I'd simply forgotten a <code>;</code> after declaring <code>otherObject</code>. </p>
",0
55556888,13680065,0,"<p>An updated answer for <a href=""/questions/tagged/c%2b%2b17"" class=""post-tag"" title=""show questions tagged &#39;c++17&#39;"" rel=""tag"">c++17</a>. With the introduction of <code>inline</code> variables, one no longer needs to worry about the exact translation unit where non-const namespace scoped variables need to be placed. Putting aside the discussion about use of global variables in general, another way to fix the OP in modern C++ is to declare the variables as follows:</p>

<pre><code>inline bool x; // Can add an initializer here too
inline int y;
</code></pre>

<p>So long as this is in a header and all TU's see the same exact definition, the implementation will resolve it and make sure those TU's all refer to the exact same unique object.</p>
",0
49214662,14309136,19,"<p>The question has already been answered, but I thought I'd add an answer with more precise terminology and references to the C++ standard.</p>

<p>Two things are going on here, <em>array parameters being adjusted to pointer parameters</em>, and <em>array arguments being converted to pointer arguments</em>. These are two quite different mechanisms, the first is an adjustment to the actual type of the parameter, whereas the other is a standard conversion which introduces a temporary pointer to the first element.</p>

<p><strong>Adjustments to your function declaration:</strong></p>

<p><a href=""http://eel.is/c++draft/dcl.fct#5"" rel=""noreferrer"">dcl.fct#5</a>:</p>

<blockquote>
  <p>After determining the type of each parameter, any parameter of type array of T (...) is adjusted to be pointer to T.</p>
</blockquote>

<p>So <code>int arg[]</code> is adjusted to be <code>int* arg</code>.</p>

<p><strong>Conversion of your function argument:</strong></p>

<p><a href=""http://eel.is/c++draft/conv.array#1"" rel=""noreferrer"">conv.array#1</a></p>

<blockquote>
  <p>An lvalue or rvalue of type array of N T or array of unknown bound of T can be converted to a prvalue of type pointer to T. The temporary materialization conversion is applied. The result is a pointer to the first element of the array.</p>
</blockquote>

<p>So in <code>printarray(firstarray, 3);</code>, the lvalue <code>firstarray</code> of type ""array of 3 int"" is converted to a prvalue (temporary) of type ""pointer to int"", pointing to the first element.</p>
",1
50306014,16422883,1,"<p><a href=""https://social.msdn.microsoft.com/Forums/vstudio/en-US/961ef1a9-2d09-42f7-9550-536bbb6156dd/c1xx-fatal-error-c1083-cannot-open-source-file-even-though-the-file-exists?forum=vclanguage"" rel=""nofollow noreferrer"">This</a> helped in my case. To sum it up, my path to the project was too long, so I moved my project to something shorter i.e. <code>D:\my_project</code> and everything worked in a blink of an eye.</p>
",1
53898196,16465573,0,"<p>Yet another way I managed to get this error, by defining a <code>static std::vector</code> of objects whose type was defined internal to the class:</p>

<pre><code>template&lt;typename Ty&gt;
class MyTemplatedClass
{
public:
   struct AStructThatBelongsToMyTemplatedClass
   {
      uint32_t aU32ThatsPartOfTheStructThatBelongsToMyTemplatedClass;
   };

   static uint32_t u32;
   static AStructThatBelongsToMyTemplatedClass aStructInstance;
   static std::vector&lt;uint32_t&gt; vectOfu32;
   static std::vector&lt;AStructThatBelongsToMyTemplatedClass&gt; vectOfStructInstances;
};

template&lt;typename Ty&gt; uint32_t MyTemplatedClass&lt;Ty&gt;::u32;
template&lt;typename Ty&gt; std::vector&lt;uint32_t&gt; MyTemplatedClass&lt;Ty&gt;::vectOfu32;

// This produces error: need 'typename' before 'MyTemplatedClass&lt;Ty&gt;::AStructThatBelongsToMyTemplatedClass' because 'MyTemplatedClass&lt;Ty&gt;' is a dependent scope
//template&lt;typename Ty&gt; MyTemplatedClass&lt;Ty&gt;::AStructThatBelongsToMyTemplatedClass MyTemplatedClass&lt;Ty&gt;::aStructInstance;
// ...but this works ok:
template&lt;typename Ty&gt; typename MyTemplatedClass&lt;Ty&gt;::AStructThatBelongsToMyTemplatedClass MyTemplatedClass&lt;Ty&gt;::aStructInstance;

// This produces error: declaration of 'std::vector&lt;MyTemplatedClass&lt;Ty&gt;::AStructThatBelongsToMyTemplatedClass&gt; MyTemplatedClass&lt;Ty&gt;::vectOfStructInstances' outside of class is not definition
//template&lt;typename Ty&gt; std::vector&lt;MyTemplatedClass&lt;Ty&gt;::AStructThatBelongsToMyTemplatedClass&gt; MyTemplatedClass&lt;Ty&gt;::vectOfStructInstances;
// ...but this works ok (the only thing I added was 'typename'):
template&lt;typename Ty&gt; std::vector&lt;typename MyTemplatedClass&lt;Ty&gt;::AStructThatBelongsToMyTemplatedClass&gt; MyTemplatedClass&lt;Ty&gt;::vectOfStructInstances;
</code></pre>
",0
54256587,17813423,4,"<p><code>std::cout</code> is defined as <code>std::ostream</code> with <a href=""https://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt2"" rel=""nofollow noreferrer"">this</a> definition of <code>operator&lt;&lt;</code>.</p>

<p>Notably this line:</p>

<pre><code>template&lt; class CharT, class Traits &gt;
basic_ostream&lt;CharT,Traits&gt;&amp; operator&lt;&lt;( basic_ostream&lt;CharT,Traits&gt;&amp; os,
                                     const char* s );
</code></pre>

<p>This gets selected when you use <code>&lt;&lt;</code> with an argument of type <code>char*</code>.</p>

<p>The case of any other non-char pointer type goes <a href=""https://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt"" rel=""nofollow noreferrer"">here</a>:</p>

<pre><code>basic_ostream&amp; operator&lt;&lt;( const void* value );
</code></pre>

<p>This continues to <a href=""https://en.cppreference.com/w/cpp/locale/num_put/put"" rel=""nofollow noreferrer""><code>std::num_put</code></a> which is made for formatting numeric values. Therefore, the pointer is interepreted numerically like <code>%p</code> in C formatting functions.</p>
",0
