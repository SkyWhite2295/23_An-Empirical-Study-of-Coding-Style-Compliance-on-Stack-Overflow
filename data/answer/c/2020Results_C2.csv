63457000,373142,3,"<p>First of all, we have to understand what so different about C++ that sets it apart from other languages.</p>
<p>Some people say it's that C++ has many too features. But hey, there are languages that have a lot more features and they are nowhere near that slow.</p>
<p>Some people say it's the size of a file that matters. Nope, source lines of code don't correlate with compile times.</p>
<p>But wait, how can it be? More lines of code should mean longer compile times, what's the sorcery?</p>
<p>The trick is that a lot of lines of code is hidden in preprocessor directives. Yes. Just one <code>#include</code> can ruin your module's compilation performance.</p>
<p>You see, C++ doesn't have a module system. All <code>*.cpp</code> files are compiled from scratch. So having 1000 *.cpp files means compiling your project a thousand times. You have more than that? Too bad.</p>
<p>That's why C++ developers hesitate to split classes into multiple files. All those headers are tedious to maintain.</p>
<p>So what can we do other than using precompiled headers, merging all the cpp files into one, and keeping the number of headers minimal?</p>
<p>C++20 brings us preliminary support of <strong>modules</strong>! Eventually, you'll be able to forget about <code>#include</code> and the horrible compile performance that header files bring with them. Touched one file? Recompile only that file! Need to compile a fresh checkout? Compile in seconds rather than minutes and hours.</p>
<p>The C++ community should move to C++20 as soon as possible. C++ compiler developers should put more focus on this, C++ developers should start testing preliminary support in various compilers and use those compilers that support modules. This is the most important moment in C++ history!</p>
",0,99024,28742,535,99
59823120,334882,0,"<p><code>David RodrÃ­guez - dribeas</code> answear is great, but doesn't provide a solution.<br>
It may look like there is no solution.</p>

<p>Solution is quite simple: repalce default parameter with <strong>function/method overload</strong>.</p>

<pre><code>void some_func(int param);
void some_func() {
    some_func(get_default_param_value());
}
</code></pre>
",0,1387438,27225,2562,204
63765760,530519,2,"<p>As other answers note, <code>mktime()</code> (infuriatingly) assumes the <code>tm</code> struct is in the local timezone (even on platforms where <code>tm</code> has a <code>tm_gmtoff</code> field), and there is no <em>standard</em>, cross platform way to interpret your <code>tm</code> as GMT.</p>
<p>The following, though, is reasonably cross platformâ€”it works on macOS, Windows (at least under MSVC), Linux, iOS, and Android.</p>
<pre><code>tm some_time{};
... // Fill my_time

const time_t utc_timestamp =
    #if defined(_WIN32)
        _mkgmtime(&amp;some_time)
    #else // Assume POSIX
        timegm(&amp;some_time)
    #endif
;
</code></pre>
",0,1417451,2207,2190,3
71605585,1574976,0,"<p>People say linear probing is terrible, but it's not.</p>
<p>If you want a <em>fast</em> hash table, linear probing may be for you.  For example, if you keep the load factor below, say 2/3, then you have to examine 3.5 elements on average for a successful search.  If your equals comparison operation can be done without chasing another pointer, then that can be fast, because those 3.5 elements cost you only one cache miss.  (So if your key is an integer, or a short std::string it can be fast).</p>
<p>Compare to a chained table, which has two cache misses before you even compare your lookup against the first stored key.</p>
",1,3149805,1,0,0
69169505,4655206,0,"<p>it is better to use std::vector or std::vector  (where byte is typedef to uint8 ) to express nature of data. You will no longer have string specific functions available , which is what you want for binary data</p>
",0,2177888,159,0,0
66344033,3215015,1,"<pre class=""lang-cpp prettyprint-override""><code>#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;functional&gt;

struct A {
    ~A() {
        std::cout &lt;&lt; &quot;~A()&quot; &lt;&lt; std::endl;
    }
};

using DeleterCb = std::function&lt;void(A* p)&gt;;

struct ADeleter {
 public:
    explicit ADeleter(DeleterCb cb) :
        mDeleterCb(cb) {}
    ADeleter() = delete;
    ~ADeleter() = default;

    void operator()(A *a) {
        mDeleterCb(a);
    }
    
    void setDeleterCb(DeleterCb cb) {
        mDeleterCb = cb;
    }

 private:
    DeleterCb mDeleterCb;
};

int main() {
    auto sp = std::shared_ptr&lt;A&gt;(new A{},
        ADeleter([](A *p){
            delete p;
            std::cout &lt;&lt; &quot;deleter_1&quot; &lt;&lt; std::endl;
        })
    );
    
    std::get_deleter&lt;ADeleter&gt;(sp)-&gt;setDeleterCb(
        [](A *p){
            delete p;
            std::cout &lt;&lt; &quot;deleter_2&quot; &lt;&lt; std::endl;
        }
    );
}
</code></pre>
",0,5698157,171,4,0
70425836,1709562,0,"<p>Neither!</p>
<p>The first makes no sense with a loop (see *) and multiple ifs are inefficient.</p>
<p>The second returns bool for an indication that something went wrong instead of throwing an exception.</p>
<p>(*) If you have a dynamic list of conditions to check (e.g. depending on inputs), then a loop <strong>per condition in list</strong> makes sense, however, use a for or the condition of the loop to step, not a 1 iteration loop!?</p>
",0,38368,16417,684,427
66774292,6350882,1,"<p>It's ok for a function to &quot;return a local object&quot;, because the compiler will transform the function to <em>not</em> really return a value. Instead, it will accept a reference <code>MyObject&amp; __result</code>, and use the local object which will be assigned the return value, i.e. <code>obj</code>, to copy construct the <code>__result</code>. In your case, the function will be rewritten to:</p>
<pre><code>static void createMyObject(MyObject&amp; __result) {
    MyObject obj;

    // .. process obj
    // compiler generated invocation of copy constructor
    __result.MyObject::Myobject( obj );

    return;
}
</code></pre>
<p>and every invocation of <code>createMyObject</code> will also be transformed to bind the reference to an existing object. For example, an invocation of the form:</p>
<pre><code>MyObject a = createMyObject();
</code></pre>
<p>will be transformed to:</p>
<pre><code>MyObject a;  // no default constructor called here
createMyObject(a);
</code></pre>
<p>However, if you return a reference or pointer to a local object, the compiler cannot fulfill the transform. You will be returning a reference or pointer to a already-destroyed object.</p>
",0,6913597,49,43,0
68581395,599321,0,"<p>You can use the solution with std::chrono described here: <a href=""https://stackoverflow.com/questions/21856025/getting-an-accurate-execution-time-in-c-micro-seconds"">Getting an accurate execution time in C++ (micro seconds)</a> you will have much better accuracy in your measurement. Usually we measure code execution in the round of the milliseconds (ms) or even microseconds (us).</p>
<pre><code>#include &lt;chrono&gt;
#include &lt;iostream&gt;
        
...
[YOUR METHOD/FUNCTION STARTING HERE]
        
auto start = std::chrono::high_resolution_clock::now();
    
[YOUR TEST CODE HERE]
        
auto elapsed = std::chrono::high_resolution_clock::now() - start;
        
long long microseconds = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(elapsed).count();
    
std::cout &lt;&lt; &quot;Elapsed time: &quot; &lt;&lt; microseconds &lt;&lt; &quot; ms;
</code></pre>
",0,3015031,751,50,2
66214164,1830158,-1,"<p>If <code>m_CursorStack</code> is a vector, you can erase by taking index:</p>
<pre><code>m_CursorStack.erase(m_CursorStack.begin() + m_CursorStack.size() + int(m_CursorStack.rbegin() - i) - 1);
</code></pre>
",0,1306244,158,204,6
59698830,1830158,0,"<p>reverse iterator is quite hard to use. So just used general iterator. 'r' It start from last element. When find something to erase. erase it and return next iterator. eg when delete 3rd element it will pointing current 4th element. and new 3rd. So it should be decreased 1 to move left</p>

<pre><code>void remchar(string&amp; s,char c)
{      
    auto r = s.end() - 1;
    while (r &gt;= s.begin() &amp;&amp; *r == c)
    {
        r = s.erase(r);
        r -= 1;
    }
}
</code></pre>
",0,1461744,210,37,3
68557896,4225087,0,"<p>I realize it's this question is probably too old to add another answer but to expand on Moo-Juice's answer, I've come up with a pretty neat and simple solution:</p>
<pre><code>/// Utility for functions get, set &amp; ptr.
template&lt;typename TVal&gt;
using GetFn = std::function&lt;const TVal&amp; (void)&gt;;

template&lt;typename TVal&gt;
using SetFn = std::function&lt;void(const TVal&amp;)&gt;;

template&lt;typename TVal&gt;
using PtrFn = std::function&lt;TVal* (void)&gt;;

/// The property class and each specialization utility.
template&lt;typename TVal, bool Delegate, bool ReadOnly&gt;
class Property;

template&lt;typename TVal&gt;
using PropertyGetSet = Property&lt;TVal, false, false&gt;;

template&lt;typename TVal&gt;
using PropertyDelGetSet = Property&lt;TVal, true, false&gt;;

template&lt;typename TVal&gt;
using PropertyGet = Property&lt;TVal, false, true&gt;;

template&lt;typename TVal&gt;
using PropertyDelGet = Property&lt;TVal, true, true&gt;;

/// &lt;summary&gt;
/// Property get-set.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;TVal&quot;&gt;Value type.&lt;/typeparam&gt;
template&lt;typename TVal&gt;
class Property&lt;TVal, false, false&gt;
{
public:
    typedef TVal Value;

    Property(const TVal&amp; val)
        : m_value(val)
    {}

    inline const TVal&amp; Get() const { return m_value; }
    inline void Set(const TVal&amp; val) { m_value = val; }
    inline TVal* Ptr() { return &amp;m_value; }

private:
    TVal m_value;
};

/// &lt;summary&gt;
/// Property delegate get-set.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;TVal&quot;&gt;Value type.&lt;/typeparam&gt;
template&lt;typename TVal&gt;
class Property&lt;TVal, true, false&gt;
{
public:
    typedef TVal Value;

    Property(GetFn&lt;TVal&gt; getFn, SetFn&lt;TVal&gt; setFn, PtrFn&lt;TVal&gt; ptrFn)
        : m_getFn(getFn)
        , m_setFn(setFn)
        , m_ptrFn(ptrFn)
    {}

    inline const TVal&amp; Get() const { return m_getFn(); }
    inline void Set(const TVal&amp; val) { m_setFn(val); }
    inline TVal* Ptr() { return m_ptrFn(); }

private:
    GetFn&lt;TVal&gt; m_getFn;
    SetFn&lt;TVal&gt; m_setFn;
    PtrFn&lt;TVal&gt; m_ptrFn;
};

/// &lt;summary&gt;
/// Property get.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;TVal&quot;&gt;Value type.&lt;/typeparam&gt;
template&lt;typename TVal&gt;
class Property&lt;TVal, false, true&gt;
{
public:
    typedef TVal Value;

    Property(const TVal&amp; val)
        : m_value(val)
    {}

    inline const TVal&amp; Get() const { return m_value; }
    inline TVal* Ptr() { return &amp;m_value; }

private:
    TVal m_value;
};

/// &lt;summary&gt;
/// Property delegate get.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;TVal&quot;&gt;Value type.&lt;/typeparam&gt;
template&lt;typename TVal&gt;
class Property&lt;TVal, true, true&gt;
{
public:
    typedef TVal Value;

    Property(GetFn&lt;TVal&gt; getFn, PtrFn&lt;TVal&gt; ptrFn)
        : m_getFn(getFn)
        , m_ptrFn(ptrFn)
    {}

    inline const TVal&amp; Get() const { return m_getFn(); }
    inline TVal* Ptr() { return m_ptrFn(); }

private:
    GetFn&lt;TVal&gt; m_getFn;
    PtrFn&lt;TVal&gt; m_ptrFn;
};
</code></pre>
<p>And then to use it:</p>
<pre><code>PropertyGetSet&lt;std::string&gt; strGetSet = PropertyGetSet&lt;std::string&gt;(&quot;GetSet&quot;);

std::string m_strGetSet = &quot;DelGetSet&quot;;
PropertyDelGetSet&lt;std::string&gt; strDelGetSet =
    PropertyDelGetSet&lt;std::string&gt;(
        [&amp;]() -&gt; const std::string&amp; { return m_strGetSet; },
        [&amp;](const std::string&amp; val) { m_strGetSet = val; },
        [&amp;]() { return &amp;m_strGetSet; /* throw? */ });

// The get (read-only) version is the same but without the set function
</code></pre>
<p>Some caveats:</p>
<ul>
<li><p>The get function returns a const&amp; so you are not able to use it for changing the value, this is by design as it would allow people to use the reference to set the value instead of the explicit Set which gives the advantage of knowing when the value is set.</p>
</li>
<li><p>There is no syntactic sugar for the get-set-ptr functions, personally, I didn't like using operators cause it made the underlying system more obtuse, so using explicit functions lets the user know that it's a property and not something else. But if you may, you could sprinkle some operator overloads.</p>
</li>
<li><p>All specializations have a Ptr function which will be the pointer of the data. However, when using the delegate version, you can choose to throw so anyone trying to use it will have to work around it. The reason it's there is that in the worst-case scenario you may try to use the pointer for a very particular situation, I would highly advise not to use this tho, so feel free to remove it or make an extra specialization for it.</p>
</li>
<li><p>Lastly, it's a bit verbose, you could wrap the usage in a macro to make the syntax a bit shorter, but personally, I like it the way it is as it's more explicit that way.</p>
</li>
</ul>
<p><strong>EDIT:</strong>
You may run into the same issue I had with this design, have a look at the following link for the issue and the solution I've come up with: <a href=""https://stackoverflow.com/a/68563492/3339838"">https://stackoverflow.com/a/68563492/3339838</a></p>
",0,3339838,341,23,2
69413177,9123022,0,"<p>You can call new operator with preallocated memory and give pointer to local variable which is on stack so it will be living on stack allocated area:</p>
<pre><code> void myfunc() {
    char stackMemoryForMyClass[sizeof(Type)];
    Type* t = new (stackMemoryForMyClass) Type;
    // destructor will not be called
 }
</code></pre>
",0,2187015,1909,110,10
65094435,3845353,0,"<p>As many already said, in this case, the value of <code>bool</code> will be <strong>undefined</strong>.</p>
<p>On top of that <code>bool</code> being <em>implementation dependant</em> you can hardly guess what might be the outcome knowing that on top of that the <code>bool</code> will take the value on the stack.</p>
<p>If we assume that we have 1 byte to store the  <code>bool</code> and that we have 0 for false and otherwise for true, you will have:</p>
<ul>
<li>probability of 254/255 of getting a true</li>
<li>probability of 1/255 of getting a false</li>
</ul>
<p>So with <strong>that specific implementation</strong>, even though you won't know for certain, you will <strong>probably</strong> get a true (of course it also depends on what was on that position in the stack).</p>
<p>But it's just conjecture at this point: the answer is <strong>undefined</strong> as said by everyone else.</p>
<p>You will have either <code>true</code>or <code> false</code>.</p>
",0,1949365,88,52,0
62998701,2781899,0,"<p>This does not answer the question but it might be good to know. You can know if it exists by erasing it.</p>
<pre><code>bool existed = cars.erase( name );
</code></pre>
",0,637142,31500,3205,11
62415153,3475152,0,"<p>I'm quite happy with this C plus C++ solution for a <code>for</code> loop incrementing an enum.</p>

<pre><code>for (Dwg_Version_Type v = R_INVALID; v &lt;= R_AFTER; v++)
</code></pre>

<p>=></p>

<pre><code>int vi;
for (Dwg_Version_Type v = R_INVALID; 
     v &lt;= R_AFTER; 
     vi = (int)v, vi++, v = (Dwg_Version_Type)vi)
</code></pre>

<p>The other solutions here are not C backcompat, and quite large.</p>
",0,414279,3820,147,39
68033506,3475152,2,"<p>Very Simple:</p>
<p>nextAvail = (StackID)(nextAvail + 1);</p>
",1,3159398,21,2,0
67940853,2247188,0,"<p>no reputation here yet so I'm not allowed to reply to @t0mm13b 's answer, but wanted to point out that there's a problem with the code:</p>
<pre><code>int countbits(char ch){
    int n = 0;
    if (ch){
        do n++;
        while (0 != (ch = ch&amp;(ch-1)));
    }
    return n;
}
</code></pre>
<p>The above won't count the number of bits in a character, it will count the number of set bits (1 bits).</p>
<p>For example, the following call will return 4:</p>
<pre><code>char c = 'U';
countbits(c);
</code></pre>
<p>The code:</p>
<pre><code>ch = ch &amp; (ch - 1)
</code></pre>
<p>Is a trick to strip off the right most (least significant) bit that's set to 1. So, it glosses over any bits set to 0 and doesn't count them.</p>
",0,2565510,26,1,0
70587093,2894957,0,"<p>My use-case:</p>
<ul>
<li>I had multiple header files <code>a.hpp</code>, <code>b.hpp</code>, and, <code>c.hpp</code> which contained some utility methods.</li>
<li>I had a file <code>util.hpp</code> which acted as an aggregator for the above files.</li>
</ul>
<p>In my case, the <code>extern</code> did not work but <code>static</code> worked.</p>
<p>I had to use:</p>
<ul>
<li><code>header guards</code> to avoid errors in Visual Studio code.</li>
<li><code>static</code> with functions to avoid compile-time errors.</li>
</ul>
<p>Check out this <a href=""https://chunminchang.github.io/blog/post/how-to-avoid-duplicate-symbols-when-compiling"" rel=""nofollow noreferrer"">article</a> too.</p>
",0,1206052,6416,1603,7
65415583,14379328,0,"<pre class=""lang-c prettyprint-override""><code>const char* mychar_readonly() {
    // each time it returns the same pointer to char array in Read-Only memory
    return &quot;Hello Read-Only&quot;;
}

int main() {
    const char* s1 = mychar_readonly();
    const char* s2 = mychar_readonly();
    // it will print the same addresses
    // e.g s1: 0x100000f87, s2: 0x100000f87
    printf(&quot;s1: %p, s2: %p\n&quot;, s1, s2);
    return 0;
}
</code></pre>
",0,895676,1973,8,0
62789235,7005713,2,"<p>For simple test project, <code>g++</code> or <code>make</code> standalone are good options as already answered:</p>
<pre><code>g++ -o hi hi.cpp
</code></pre>
<p>or</p>
<pre><code>make hi
</code></pre>
<hr />
<p>For real projects, however, the usage of a project manager is required. At the time I write this answer, the most used and open-source is <code>cmake</code> (an alternative could be QT qmake ).</p>
<p><strong>Following is a simple CMake example:</strong></p>
<p>Make sure you installed <code>cmake</code> on your linux distribution <code>apt-get install cmake</code> or <code>yum install cmake</code>.</p>
<p>Create a file <code>CMakeLists.txt</code> (the name is important) together with your source <code>hi.cpp</code></p>
<pre><code>project(&quot;hi&quot;)

add_executable( hi hi.cpp )
</code></pre>
<p>Then compile and run as:</p>
<pre><code>cmake .
make
./hi
</code></pre>
<p>This allows the project to <strong>scale</strong> easily with libraries, sources, and much more. It also <strong>makes most IDEs to understand the project</strong> properly (Most IDEs accept CMake natively, like kdevelop, qtCreator, etc..)</p>
<p><a href=""https://i.stack.imgur.com/vMVeF.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/vMVeF.png"" alt=""Example of CMake integration with Qt-Creator"" /></a></p>
<p>You could also generate Visual-Studio or XCode projects from CMake, in case you decide to port the software to other platforms in the future.</p>
<pre><code>cmake -G Xcode . #will generate `hi.xcodeproj` you can load on macOS
</code></pre>
",0,903651,12798,996,180
60204907,7601533,0,"<blockquote>
  <p>I'm interested in writing a tool for teaching purposes that evaluates C++ expressions and prints their types. Essentially, my thinking is that my students could type in any expression, and the program would echo back the type of the expression. Is there an existing tool that already does this? </p>
</blockquote>

<p>These days, there sort of is such a tool - online. It only does what you want as an unintended by product though. I'm talking about Matt Godbolt's <a href=""https://godbolt.org/"" rel=""nofollow noreferrer"">Compiler Explorer</a>.</p>

<p>Your ""program"" will look like this:</p>

<pre><code>#define EXPRESSION 123

template &lt;typename T&gt; class the_type_of_EXPRESSION_IS_ { };
using bar = typename the_type_of_EXPRESSION_IS_&lt;decltype(EXPRESSION)&gt;::_;
</code></pre>

<p>Now, if you replace <code>123</code> with a C++ expression, you'll <a href=""https://godbolt.org/z/SyQocg"" rel=""nofollow noreferrer"">get</a>, in the compiler error messages section, the following:</p>

<pre><code>&lt;source&gt;:4:72: error: '_' in 'class the_type_of_EXPRESSION_is_&lt;int&gt;' does not name a type

    4 | using bar = typename the_type_of_EXPRESSION_IS_&lt;decltype(EXPRESSION)&gt;::_;

      |                                                                        ^

Compiler returned: 1
</code></pre>

<p>The first line has your desired type, within the angle brackets.</p>
",0,1593077,100017,4396,389
66077028,2682725,2,"<p>I know I'm ten years late, but what do you think about a bitset solution ?</p>
<pre class=""lang-cpp prettyprint-override""><code>class i24
{
    std::bitset&lt;24&gt; m_value;

public:
    constexpr i24(int value) noexcept: m_value {static_cast&lt;unsigned long long&gt;(value)} {}

    operator int() const
    {
        constexpr std::uint32_t negative_mask = (0xff &lt;&lt; 24);
        return (m_value[23] ? negative_mask : 0) | m_value.to_ulong();
    }
};
</code></pre>
",0,5890806,128,220,2
71003224,5655142,0,"<p>Something that can be done is read text input and then try to convert that to a number:</p>
<pre><code>try 
{
    std::string str;
    std::getline(std::cin, str)
    age = std::stoi(str)
}
catch(...)
{
    // ...
}
</code></pre>
<p>Then you can handle the errors by catching the exceptions.</p>
<p><a href=""https://en.cppreference.com/w/cpp/string/basic_string/stol"" rel=""nofollow noreferrer"">https://en.cppreference.com/w/cpp/string/basic_string/stol</a></p>
",0,2504757,4893,316,91
67662535,3173462,1,"<p>This causes undefined behavior because you read from <code>i</code> before its lifetime starts.</p>
<p>Firstly:</p>
<blockquote>
<h3><a href=""http://eel.is/c++draft/basic.life#1.2"" rel=""nofollow noreferrer""><code>[basic.life]/1.2</code></a></h3>
<p>... The lifetime of an object ... begins when:</p>
<p>â€?its initialization (if any) is complete</p>
</blockquote>
<p>The initialization of <code>i</code> is not complete when you read from <code>i</code>, because you need to know the value to finish the initialization.</p>
<p>Next:</p>
<blockquote>
<h3><a href=""http://eel.is/c++draft/basic.life#7.1"" rel=""nofollow noreferrer""><code>[basic.life]/7.1</code></a></h3>
<p>... before the lifetime of an object has started but after the storage which the object will occupy has been allocated ... any glvalue that refers to the original object may be used but only in limited ways. ... The program has undefined behavior if:</p>
<p>â€?the glvalue is used to access the object</p>
</blockquote>
<p>Reading from <code>i</code> does &quot;access the object&quot;, hence UB.</p>
",0,2752075,60317,8976,4865
64851639,6935406,1,"<p>As of the adoption of the C++17 standard there exists a <code>&lt;filesystem&gt;</code> header included in the language that does exactly this. See your compiler's documentation to determine if it's supported.</p>
",0,421178,9301,894,76
60650693,10230545,5,"<p>Yes we can.</p>

<pre><code>points.push_back(vector&lt;int&gt;{1, 2, 3, ....});

</code></pre>

<p>I'm initialising the vector like array and not giving it a name. Pretty simple for single or multiple elements.</p>
",0,1096194,6059,383,37
63071424,4781852,1,"<p>This is sample program to validate input datetime and parse</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;comutil.h&gt;
#include &lt;iomanip&gt;

bool ValidateAndParseDateTime(const std::wstring &amp; strInputDate, std::tm &amp; date)
{
    bool bSuccess = false;
    if (!strInputDate.empty())
    {
        _variant_t varIn = strInputDate.c_str();
        if (SUCCEEDED(VariantChangeTypeEx(&amp;varIn, &amp;varIn, GetThreadLocale(), 0, VT_DATE)))
        {
            std::get_time(&amp;date, strInputDate.c_str());
            bSuccess = true;
        }
    }
}

int main()
{
    std::tm date;
    std::wstring strInputDate = L&quot;7/20/2020 1:29:37 PM&quot;;
    if (!ValidateAndParseDateTime(strInputDate, date))
    {
        //Invalid date and time
    }

    return 0;
}
</code></pre>
",0,1614497,21,3,0
63626980,3949471,0,"<p>Since C++20, the answer (for initialized variables) is no.</p>
<p>As proposal <a href=""http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0907r4.html"" rel=""nofollow noreferrer"">P0907</a> explains, signed integers previously allowed various value representations, including &quot;the existence of an extraordinary value which traps, extra padding bits, [and] integral negative zero.&quot; (Hence Potatoswatter's answer that, in theory, NaN values for ints were possible.) In practice, though, every machine running C++ uses a &quot;normal&quot; two's complement representation for signed integers.</p>
<p>Supporting that proposal, the C++ standards committee decided to standardize two's complement and to disallow extraordinary values. Now, the value representation of signed integers is fixed, and while integers can also have padding bits, the standard stops them from doing anything unusual: (<a href=""http://eel.is/c++draft/basic.fundamental"" rel=""nofollow noreferrer"">basic.fundamental</a>)</p>
<blockquote>
<p>Each set of values for any padding bits (<a href=""http://eel.is/c++draft/basic.types"" rel=""nofollow noreferrer"">[basic.types]</a>) in the object representation are alternative representations of the value specified by the value representation.
[Note: Padding bits have unspecified value, but cannot cause traps.
In contrast, see ISO C 6.2.6.2.
â€?end note]</p>
</blockquote>
<p>Therefore, ints have no extraordinary values that could produce NaN-like behavior.</p>
",0,431033,1387,180,21
60695532,3084005,0,"<p>What happens is implied by the meaning of the code you wrote. That meaning is defined by the C++ standard.</p>

<p>The standard guarantees that by the time <code>main()</code> starts running, all global objects are available for use, i.e. they have been constructed. Thus, if an object's construction has side effects observable from ""outside"" the program - like I/O - those side effect must happen before <code>main()</code> gets called.</p>

<p>C++ guarantees more, though. All objects that are in scope must be available, i.e. constructed. No matter what the scope is. Since global variables are in scope of <code>main()</code>, they must be constructed before <code>main()</code> is called. But this applies to all other scopes.</p>

<p>You can <a href=""https://onlinegdb.com/Sk8ObJ3rI"" rel=""nofollow noreferrer"">try running the code below interactively in a debugger online</a> and see exactly what happens.</p>

<pre><code>#include &lt;iostream&gt;

struct Hello {
  static int counter;
  int this_counter = counter++;
  Hello() { std::cout &lt;&lt; ""Hello "" &lt;&lt; this_counter &lt;&lt; std::endl; }
  ~Hello() { std::cout &lt;&lt; ""Goodbye "" &lt;&lt; this_counter &lt;&lt; std::endl; }
  static void say_hello() {
    int this_counter = counter++;
    std::cout &lt;&lt; ""Hello and goodbye "" &lt;&lt; this_counter &lt;&lt; std::endl;
  }
};

int Hello::counter = 1;

const Hello hello1;

void hello4() { // scope 4
  Hello hello4;
  // scope 4+ - hello4 is in that scope
}

int main()
{ // entering scope 2
  Hello hello2;
  // scope 2+ - hello2 is in that scope
  Hello::say_hello(); // hello3
  hello4();
}
</code></pre>
",0,1329652,92179,7790,847
65784221,17005364,3,"<h1>Benchmarks</h1>
<p>Since a lot of different methods are shown in the answers and none of the answers actually prove any advantages in terms of performance I tried to benchmark them myself. My plan was to write an answer that contains a <em>short</em> table and a definite answer which method is the fastest.</p>
<p>Unfortunately it wasn't that simple. (It never is.) It seems that the performance of the rounding formulas depend on the used data type, compiler <strong>and</strong> optimization level.</p>
<p>In one case there is an increase of speed by 7.5Ã— from one method to another. So the impact can be significant for some people.</p>
<h2>TL;DR</h2>
<p>For <code>long</code> integers the naive version using a type cast to <code>float</code> and <code>std::ceil</code> was actually the fastest. This was interesting for me personally since I intended to use it with <code>size_t</code> which is <em>usually</em> defined as <code>unsigned long</code>.</p>
<p>For ordinary <code>int</code>s it depends on your optimization level. For lower levels @Jwodder's solution performs best. For the highest levels <code>std::ceil</code> was the optimal one. With one exception: For the clang/<code>unsigned int</code> combination @Jwodder's was still better.</p>
<p>The solutions from the accepted answer never really outperformed the other two. You should keep in mind however that @Jwodder's solution doesn't work with negatives.</p>
<p>Results are at the bottom.</p>
<h1>Implementations</h1>
<p>To recap here are the four methods I benchmarked and compared:</p>
<h2><a href=""https://stackoverflow.com/a/17005390/3139807"">@Jwodder's version</a> (Jwodder)</h2>
<pre><code>template&lt;typename T&gt;
inline T divCeilJwodder(const T&amp; numerator, const T&amp; denominator)
{
    return (numerator + denominator - 1) / denominator;
}
</code></pre>
<h2><a href=""https://stackoverflow.com/a/17005764/3139807"">@Ben Voigt's version</a> using modulo (VoigtModulo)</h2>
<pre><code>template&lt;typename T&gt;
inline T divCeilVoigtModulo(const T&amp; numerator, const T&amp; denominator)
{
    return numerator / denominator + (((numerator &lt; 0) ^ (denominator &gt; 0))
        &amp;&amp; (numerator%denominator));
}
</code></pre>
<h2><a href=""https://stackoverflow.com/a/17005764/3139807"">@Ben Voigt's version</a> without using modulo (VoigtNoModulo)</h2>
<pre><code>inline T divCeilVoigtNoModulo(const T&amp; numerator, const T&amp; denominator)
{
    T truncated = numerator / denominator;
    return truncated + (((numerator &lt; 0) ^ (denominator &gt; 0))
        &amp;&amp; (numerator - truncated*denominator));
}
</code></pre>
<h2><a href=""https://stackoverflow.com/q/17005364/3139807"">OP's implementation</a> (TypeCast)</h2>
<pre><code>template&lt;typename T&gt;
inline T divCeilTypeCast(const T&amp; numerator, const T&amp; denominator)
{
    return (int)std::ceil((double)numerator / denominator);
}
</code></pre>
<h1>Methodology</h1>
<p>In a single batch the division is performed 100 million times. Ten batches are calculated for each combination of Compiler/Optimization level, used data type and used implementation. The values shown below are the averages of all 10 batches in milliseconds. The errors that are given are <a href=""https://en.wikipedia.org/wiki/Standard_deviation"" rel=""nofollow noreferrer"">standard deviations</a>.</p>
<p>The whole source code that was used can be found <a href=""https://gist.github.com/Scindix/9a5ff2ec107f5f300e08b72c97b841f6"" rel=""nofollow noreferrer"">here</a>. Also you might find <a href=""https://gist.github.com/Scindix/ba5a404ee0affac825a8981db078b043"" rel=""nofollow noreferrer"">this</a> script useful which compiles and executes the source with different compiler flags.</p>
<p>The whole benchmark was performed on a i7-7700K. The used compiler versions were GCC 10.2.0 and clang 11.0.1.</p>
<h1>Results</h1>
<p>Now without further ado here are the results:</p>
<div class=""s-table-container"">
<table class=""s-table"">
<thead>
<tr>
<th><code>DataType</code><br>Algorithm</th>
<th>GCC<br>-O0</th>
<th>-O1</th>
<th>-O2</th>
<th>-O3</th>
<th>-Os</th>
<th>-Ofast</th>
<th>-Og</th>
<th>clang<br>-O0</th>
<th>-O1</th>
<th>-O2</th>
<th>-O3</th>
<th>-Ofast</th>
<th>-Os</th>
<th>-Oz</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>unsigned</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Jwodder</strong></td>
<td><strong>264.1Â Â±Â 0.9</strong>Â ğŸ†</td>
<td><strong>175.2Â Â±Â 0.9</strong>Â ğŸ†</td>
<td><strong>153.5Â Â±Â 0.7</strong>Â ğŸ†</td>
<td><strong>175.2Â Â±Â 0.5</strong>Â ğŸ†</td>
<td>153.3Â Â±Â 0.5</td>
<td>153.4Â Â±Â 0.8</td>
<td><strong>175.5Â Â±Â 0.6</strong>Â ğŸ†</td>
<td><strong>329.4Â Â±Â 1.3</strong>Â ğŸ†</td>
<td><strong>220.0Â Â±Â 1.3</strong>Â ğŸ†</td>
<td><strong>146.2Â Â±Â 0.6</strong>Â ğŸ†</td>
<td><strong>146.2Â Â±Â 0.6</strong>Â ğŸ†</td>
<td><strong>146.0Â Â±Â 0.5</strong>Â ğŸ†</td>
<td><strong>153.2Â Â±Â 0.3</strong>Â ğŸ†</td>
<td><strong>153.5Â Â±Â 0.6</strong>Â ğŸ†</td>
</tr>
<tr>
<td>VoigtModulo</td>
<td>528.5Â Â±Â 2.5</td>
<td>306.5Â Â±Â 1.0</td>
<td>175.8Â Â±Â 0.7</td>
<td><strong>175.2Â Â±Â 0.5</strong>Â ğŸ†</td>
<td>175.6Â Â±Â 0.7</td>
<td>175.4Â Â±Â 0.6</td>
<td>352.0Â Â±Â 1.0</td>
<td>588.9Â Â±Â 6.4</td>
<td>408.7Â Â±Â 1.5</td>
<td>164.8Â Â±Â 1.0</td>
<td>164.0Â Â±Â 0.4</td>
<td>164.1Â Â±Â 0.4</td>
<td>175.2Â Â±Â 0.5</td>
<td>175.8Â Â±Â 0.9</td>
</tr>
<tr>
<td>VoigtNoModulo</td>
<td>375.3Â Â±Â 1.5</td>
<td><strong>175.7Â Â±Â 1.3</strong>Â ğŸ†</td>
<td>192.5Â Â±Â 1.4</td>
<td>197.6Â Â±Â 1.9</td>
<td>200.6Â Â±Â 7.2</td>
<td>176.1Â Â±Â 1.5</td>
<td>197.9Â Â±Â 0.5</td>
<td>541.0Â Â±Â 1.8</td>
<td>263.1Â Â±Â 0.9</td>
<td>186.4Â Â±Â 0.6</td>
<td>186.4Â Â±Â 1.2</td>
<td>187.2Â Â±Â 1.1</td>
<td>197.2Â Â±Â 0.8</td>
<td>197.1Â Â±Â 0.7</td>
</tr>
<tr>
<td><strong>TypeCast</strong></td>
<td>348.5Â Â±Â 2.7</td>
<td>231.9Â Â±Â 3.9</td>
<td>234.4Â Â±Â 1.3</td>
<td>226.6Â Â±Â 1.0</td>
<td><strong>137.5Â Â±Â 0.8</strong>Â ğŸ†</td>
<td><strong>138.7Â Â±Â 1.7</strong>Â ğŸ†</td>
<td>243.8Â Â±Â 1.4</td>
<td>591.2Â Â±Â 2.4</td>
<td>591.3Â Â±Â 2.6</td>
<td>155.8Â Â±Â 1.9</td>
<td>155.9Â Â±Â 1.6</td>
<td>155.9Â Â±Â 2.4</td>
<td>214.6Â Â±Â 1.9</td>
<td>213.6Â Â±Â 1.1</td>
</tr>
<tr>
<td><code>unsigned long</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Jwodder</td>
<td>658.6Â Â±Â 2.5</td>
<td>546.3Â Â±Â 0.9</td>
<td>549.3Â Â±Â 1.8</td>
<td>549.1Â Â±Â 2.8</td>
<td>540.6Â Â±Â 3.4</td>
<td>548.8Â Â±Â 1.3</td>
<td>486.1Â Â±Â 1.1</td>
<td>638.1Â Â±Â 1.8</td>
<td>613.3Â Â±Â 2.1</td>
<td><strong>190.0Â Â±Â 0.8</strong>Â ğŸ†</td>
<td>182.7Â Â±Â 0.5</td>
<td>182.4Â Â±Â 0.5</td>
<td>496.2Â Â±Â 1.3</td>
<td>554.1Â Â±Â 1.0</td>
</tr>
<tr>
<td>VoigtModulo</td>
<td>1,169.0Â Â±Â 2.9</td>
<td>1,015.9Â Â±Â 4.4</td>
<td>550.8Â Â±Â 2.0</td>
<td>504.0Â Â±Â 1.4</td>
<td>550.3Â Â±Â 1.2</td>
<td>550.5Â Â±Â 1.3</td>
<td>1,020.1Â Â±Â 2.9</td>
<td>1,259.0Â Â±Â 9.0</td>
<td>1,136.5Â Â±Â 4.2</td>
<td><strong>187.0Â Â±Â 3.4</strong>Â ğŸ†</td>
<td>199.7Â Â±Â 6.1</td>
<td>197.6Â Â±Â 1.0</td>
<td>549.4Â Â±Â 1.7</td>
<td>506.8Â Â±Â 4.4</td>
</tr>
<tr>
<td>VoigtNoModulo</td>
<td>768.1Â Â±Â 1.7</td>
<td>559.1Â Â±Â 1.8</td>
<td>534.4Â Â±Â 1.6</td>
<td>533.7Â Â±Â 1.5</td>
<td>559.5Â Â±Â 1.7</td>
<td>534.3Â Â±Â 1.5</td>
<td>571.5Â Â±Â 1.3</td>
<td>879.5Â Â±Â 10.8</td>
<td>617.8Â Â±Â 2.1</td>
<td>223.4Â Â±Â 1.3</td>
<td>231.3Â Â±Â 1.3</td>
<td>231.4Â Â±Â 1.1</td>
<td>594.6Â Â±Â 1.9</td>
<td>572.2Â Â±Â 0.8</td>
</tr>
<tr>
<td><strong>TypeCast</strong></td>
<td><strong>353.3Â Â±Â 2.5</strong>Â ğŸ†</td>
<td><strong>267.5Â Â±Â 1.7</strong>Â ğŸ†</td>
<td><strong>248.0Â Â±Â 1.6</strong>Â ğŸ†</td>
<td><strong>243.8Â Â±Â 1.2</strong>Â ğŸ†</td>
<td><strong>154.2Â Â±Â 0.8</strong>Â ğŸ†</td>
<td><strong>154.1Â Â±Â 1.0</strong>Â ğŸ†</td>
<td><strong>263.8Â Â±Â 1.8</strong>Â ğŸ†</td>
<td><strong>365.5Â Â±Â 1.6</strong>Â ğŸ†</td>
<td><strong>316.9Â Â±Â 1.8</strong>Â ğŸ†</td>
<td><strong>189.7Â Â±Â 2.1</strong>Â ğŸ†</td>
<td><strong>156.3Â Â±Â 1.8</strong>Â ğŸ†</td>
<td><strong>157.0Â Â±Â 2.2</strong>Â ğŸ†</td>
<td><strong>155.1Â Â±Â 0.9</strong>Â ğŸ†</td>
<td><strong>176.5Â Â±Â 1.2</strong>Â ğŸ†</td>
</tr>
<tr>
<td><code>int</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Jwodder</strong></td>
<td><strong>307.9Â Â±Â 1.3</strong>Â ğŸ†</td>
<td><strong>175.4Â Â±Â 0.9</strong>Â ğŸ†</td>
<td><strong>175.3Â Â±Â 0.5</strong>Â ğŸ†</td>
<td><strong>175.4Â Â±Â 0.6</strong>Â ğŸ†</td>
<td>175.2Â Â±Â 0.5</td>
<td>175.1Â Â±Â 0.6</td>
<td><strong>175.1Â Â±Â 0.5</strong>Â ğŸ†</td>
<td><strong>307.4Â Â±Â 1.2</strong>Â ğŸ†</td>
<td><strong>219.6Â Â±Â 0.6</strong>Â ğŸ†</td>
<td><strong>146.0Â Â±Â 0.3</strong>Â ğŸ†</td>
<td>153.5Â Â±Â 0.5</td>
<td>153.6Â Â±Â 0.8</td>
<td><strong>175.4Â Â±Â 0.7</strong>Â ğŸ†</td>
<td><strong>175.2Â Â±Â 0.5</strong>Â ğŸ†</td>
</tr>
<tr>
<td>VoigtModulo</td>
<td>528.5Â Â±Â 1.9</td>
<td>351.9Â Â±Â 4.6</td>
<td><strong>175.3Â Â±Â 0.6</strong>Â ğŸ†</td>
<td><strong>175.2Â Â±Â 0.4</strong>Â ğŸ†</td>
<td>197.1Â Â±Â 0.6</td>
<td>175.2Â Â±Â 0.8</td>
<td>373.5Â Â±Â 1.1</td>
<td>598.7Â Â±Â 5.1</td>
<td>460.6Â Â±Â 1.3</td>
<td>175.4Â Â±Â 0.4</td>
<td>164.3Â Â±Â 0.9</td>
<td>164.0Â Â±Â 0.4</td>
<td><strong>176.3Â Â±Â 1.6</strong>Â ğŸ†</td>
<td>460.0Â Â±Â 0.8</td>
</tr>
<tr>
<td>VoigtNoModulo</td>
<td>398.0Â Â±Â 2.5</td>
<td>241.0Â Â±Â 0.7</td>
<td>199.4Â Â±Â 5.1</td>
<td>219.2Â Â±Â 1.0</td>
<td>175.9Â Â±Â 1.2</td>
<td>197.7Â Â±Â 1.2</td>
<td>242.9Â Â±Â 3.0</td>
<td>543.5Â Â±Â 2.3</td>
<td>350.6Â Â±Â 1.0</td>
<td>186.6Â Â±Â 1.2</td>
<td>185.7Â Â±Â 0.3</td>
<td>186.3Â Â±Â 1.1</td>
<td>197.1Â Â±Â 0.6</td>
<td>373.3Â Â±Â 1.6</td>
</tr>
<tr>
<td><strong>TypeCast</strong></td>
<td>338.8Â Â±Â 4.9</td>
<td>228.1Â Â±Â 0.9</td>
<td>230.3Â Â±Â 0.8</td>
<td>229.5Â Â±Â 9.4</td>
<td><strong>153.8Â Â±Â 0.4</strong>Â ğŸ†</td>
<td><strong>138.3Â Â±Â 1.0</strong>Â ğŸ†</td>
<td>241.1Â Â±Â 1.1</td>
<td>590.0Â Â±Â 2.1</td>
<td>589.9Â Â±Â 0.8</td>
<td>155.2Â Â±Â 2.4</td>
<td><strong>149.4Â Â±Â 1.6</strong>Â ğŸ†</td>
<td><strong>148.4Â Â±Â 1.2</strong>Â ğŸ†</td>
<td>214.6Â Â±Â 2.2</td>
<td>211.7Â Â±Â 1.6</td>
</tr>
<tr>
<td><code>long</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Jwodder</td>
<td>758.1Â Â±Â 1.8</td>
<td>600.6Â Â±Â 0.9</td>
<td>601.5Â Â±Â 2.2</td>
<td>601.5Â Â±Â 2.8</td>
<td>581.2Â Â±Â 1.9</td>
<td>600.6Â Â±Â 1.8</td>
<td>586.3Â Â±Â 3.6</td>
<td>745.9Â Â±Â 3.6</td>
<td>685.8Â Â±Â 2.2</td>
<td>183.1Â Â±Â 1.0</td>
<td>182.5Â Â±Â 0.5</td>
<td>182.6Â Â±Â 0.6</td>
<td>553.2Â Â±Â 1.5</td>
<td>488.0Â Â±Â 0.8</td>
</tr>
<tr>
<td>VoigtModulo</td>
<td>1,360.8Â Â±Â 6.1</td>
<td>1,202.0Â Â±Â 2.1</td>
<td>600.0Â Â±Â 2.4</td>
<td>600.0Â Â±Â 3.0</td>
<td>607.0Â Â±Â 6.8</td>
<td>599.0Â Â±Â 1.6</td>
<td>1,187.2Â Â±Â 2.6</td>
<td>1,439.6Â Â±Â 6.7</td>
<td>1,346.5Â Â±Â 2.9</td>
<td>197.9Â Â±Â 0.7</td>
<td>208.2Â Â±Â 0.6</td>
<td>208.0Â Â±Â 0.4</td>
<td>548.9Â Â±Â 1.4</td>
<td>1,326.4Â Â±Â 3.0</td>
</tr>
<tr>
<td>VoigtNoModulo</td>
<td>844.5Â Â±Â 6.9</td>
<td>647.3Â Â±Â 1.3</td>
<td>628.9Â Â±Â 1.8</td>
<td>627.9Â Â±Â 1.6</td>
<td>629.1Â Â±Â 2.4</td>
<td>629.6Â Â±Â 4.4</td>
<td>668.2Â Â±Â 2.7</td>
<td>1,019.5Â Â±Â 3.2</td>
<td>715.1Â Â±Â 8.2</td>
<td>224.3Â Â±Â 4.8</td>
<td>219.0Â Â±Â 1.0</td>
<td>219.0Â Â±Â 0.6</td>
<td>561.7Â Â±Â 2.5</td>
<td>769.4Â Â±Â 9.3</td>
</tr>
<tr>
<td><strong>TypeCast</strong></td>
<td><strong>366.1Â Â±Â 0.8</strong>Â ğŸ†</td>
<td><strong>246.2Â Â±Â 1.1</strong>Â ğŸ†</td>
<td><strong>245.3Â Â±Â 1.8</strong>Â ğŸ†</td>
<td><strong>244.6Â Â±Â 1.1</strong>Â ğŸ†</td>
<td><strong>154.6Â Â±Â 1.6</strong>Â ğŸ†</td>
<td><strong>154.3Â Â±Â 0.5</strong>Â ğŸ†</td>
<td><strong>257.4Â Â±Â 1.5</strong>Â ğŸ†</td>
<td><strong>591.8Â Â±Â 4.1</strong>Â ğŸ†</td>
<td><strong>590.4Â Â±Â 1.3</strong>Â ğŸ†</td>
<td><strong>154.5Â Â±Â 1.3</strong>Â ğŸ†</td>
<td><strong>135.4Â Â±Â 8.3</strong>Â ğŸ†</td>
<td><strong>132.9Â Â±Â 0.7</strong>Â ğŸ†</td>
<td><strong>132.8Â Â±Â 1.2</strong>Â ğŸ†</td>
<td><strong>177.4Â Â±Â 2.3</strong>Â ğŸ†</td>
</tr>
</tbody>
</table>
</div>
<p>Now I can finally get on with my life :P</p>
",1,3139807,1142,87,1
65265258,6547922,3,"<p>A <code>std::vector&lt;char&gt;</code> can be used as if it were a <code>std::string</code>, but the reverse is not true.</p>
<p>A <code>std::vector&lt;char&gt;</code> just stores sequences of characters, but not all sequences of characters are strings. Consider binary data, which would be correctly stored in a <code>std::vector&lt;char&gt;</code> (or <code>std::vector&lt;unsigned char&gt;</code>); it wouldn't make sense to store this in a string.</p>
<p>Internally, <code>std::string</code> <em>could</em> be implemented in much the same way as <code>std::vector&lt;char&gt;</code>â€”and, indeed, you can think of it as being the same conceptuallyâ€”but, in practice, there are a few important differences:</p>
<ol>
<li><p><a href=""https://stackoverflow.com/questions/6077189/will-stdstring-always-be-null-terminated-in-c11"">C++11 introduced the requirement that a <code>std::string</code> is required to store a NUL-terminated sequence of characters internally</a>. That brings it into compliance and makes interoperating with C-style strings easier. Obviously, <code>std::vector&lt;char&gt;</code> would not have that requirement associated with it, and you wouldn't want it to.</p>
</li>
<li><p><code>std::string</code> offers a very different and much expanded interface compared to <code>std::vector&lt;&gt;</code>. While the latter is just a boring old sequence of elements, the former is actually designed to represent a string and therefore offers an assortment of string-related convenience functions. (Some would argue <a href=""https://stackoverflow.com/a/10319672""><em>too many</em></a>, preferring instead if these had been implemented as standalone, &quot;free&quot; functions, rather than member functions of a special &quot;string&quot; class.)</p>
</li>
<li><p>Common implementations of <code>std::string</code> will use an optimization called the <a href=""https://stackoverflow.com/a/10319672"">&quot;small string optimization (SSO)&quot;</a>, which avoids dynamic memory allocation when you are storing a string that will fit directly within the <code>std::string</code> object instance. You won't find this optimization in <code>std::vector&lt;&gt;</code> (although <a href=""https://stackoverflow.com/questions/2178281/small-string-optimization-for-vector"">it could actually be implemented in a custom vector type</a>).</p>
<p>And, in order to enable the small-string optimization, the standard requires that swapping a <code>std::string</code> invalidate its iterators. That requirement does not apply to <code>std::vector&lt;&gt;</code>.</p>
</li>
<li><p>Although perhaps only a historical curiosity now (especially since almost no implementations of the standard library worked this way in practice), in C++03 and previous versions of the language standard, <code>std::string</code> was <em>not</em> required to store the characters in the string in contiguous memory. In other words, it didn't actually have to be implemented as a wrapper around an array. This allowed something like the <a href=""https://en.wikipedia.org/wiki/Rope_(data_structure)"" rel=""nofollow noreferrer"">rope data structure</a> and/or a copy-on-write strategy to be used under the hood. <code>std::vector&lt;&gt;</code> has <em>always</em> required contiguous storage of its elements. (C++11 introduced the same requirement for <code>std::string</code>.)</p>
</li>
</ol>
",0,366904,229525,19416,46821
63081848,5537818,0,"<p>Spell check first 3 words of your text in all languages (the more words to spell check, the better). The spelling with least number of spelling errors &quot;wins&quot;. With only 3 words it is technically possible to have same spelling in a few languages but with each additional word it becomes less probable. It is not a perfect method, but I figure it would work in most cases.</p>
<p>Otherwise if there is equal number of errors in all languages, use the default language. Or randomly pick another 3 words until you have more clear result. Or expand the number of spell checked words to more than 3, until you get a more clear result as well.</p>
<p>As for the spell checking libraries, there are many, I personally prefer <a href=""http://hunspell.github.io/"" rel=""nofollow noreferrer"">Hunspell</a>. <a href=""https://nuspell.github.io/"" rel=""nofollow noreferrer"">Nuspell</a> is probably also good. It is a matter of personal opinion and/or technical capabilities which one to use.</p>
",0,974700,3254,241,3
67927611,6464404,0,"<p>Basically, what happens when you declare a function with a default argument like this is that you're (implicitly) declaring and defining an inline overload with one fewer argument that just calls the full function with that argument value.  The thing is, this extra overloaded function is <em>not</em> virtual, even if the function is.  So the function you've defined in B is equivalent to:</p>
<pre><code>        virtual void print(int data)
        {
              cout &lt;&lt; endl &lt;&lt; &quot;B--data=&quot; &lt;&lt; data;
        }
        void print() { print(10); }
</code></pre>
<p>what this means is that when you call <code>print()</code> (with no argument) the function you get is based on the static type (B in the case you find confusing).  That then calls <code>print(int)</code> which is virtual, so uses the dynamic type.</p>
<p>If you want this default argument to be virtual, you need to explicitly define the overloaded function (as virtual) to make it work.</p>
",0,16406,109149,1237,321
66151963,7278347,4,"<p>If using C++11, you could use a <code>std::vector&lt;std::reference_wrapper&lt;double&gt;&gt;</code>.</p>
<pre class=""lang-cpp prettyprint-override""><code>#include &lt;functional&gt; // std::reference_wrapper
#include &lt;vector&gt;

#include &lt;iostream&gt;
#include &lt;numeric&gt; // std::iota
#include &lt;random&gt; // std::mt19937
#include &lt;algorithm&gt; // std::shuffle

int main() {
const int N = 10; // Number of elements in your array
double values[N];
std::iota(values, values+N, -4.0);

std::vector&lt;std::reference_wrapper&lt;double&gt;&gt; v(values, values + N);
std::shuffle(v.begin(), v.end(), std::mt19937{std::random_device{}()});

std::cout &lt;&lt; &quot;Contents of the array: &quot;;
for(auto i=0; i &lt; N; ++i) std::cout &lt;&lt; values[i] &lt;&lt; ' ';
std::cout &lt;&lt; '\n';

std::cout &lt;&lt; &quot;Contents of the array, shuffled: &quot;;
for(auto i: v) std::cout &lt;&lt; i &lt;&lt; ' ';
std::cout &lt;&lt; '\n';

std::cout &lt;&lt; &quot;Change values using the vector shuffled\n&quot;;
auto j = 44.;
for(double&amp; i: v) i = ++j;

std::cout &lt;&lt; &quot;Contents of the array, shuffled: &quot;;
for(auto i: v) std::cout &lt;&lt; i &lt;&lt; ' ';
std::cout &lt;&lt; '\n';
    
std::cout &lt;&lt; &quot;Contents of the array: &quot;;
for(auto i=0; i &lt; N; ++i) std::cout &lt;&lt; values[i] &lt;&lt; ' ';
std::cout &lt;&lt; '\n';
}
</code></pre>
<p>Possible output:</p>
<pre><code>Contents of the array: -4 -3 -2 -1 0 1 2 3 4 5 
Contents of the array, shuffled: 1 3 -2 0 -3 5 -4 4 -1 2 
Change values using the vector shuffled
Contents of the array, shuffled: 45 46 47 48 49 50 51 52 53 54 
Contents of the array: 51 49 47 53 48 45 54 46 52 50
</code></pre>
<p>pro: zero copy</p>
<p>ref: <a href=""https://en.cppreference.com/w/cpp/utility/functional/reference_wrapper"" rel=""nofollow noreferrer"">https://en.cppreference.com/w/cpp/utility/functional/reference_wrapper</a></p>
",1,5710233,5141,1043,11
68081088,5183203,0,"<p>If you don't know exactly where the argument will appear, you might consider using <code>find_if</code> (C++17):</p>
<pre class=""lang-cpp prettyprint-override""><code>#include &lt;algorithm&gt;
#include &lt;string&gt;

int main(int argc, char * argv[])
{
    auto const begin = argv;
    auto const end = argv + argc;

    auto is_yes = [](std::string const &amp; s) { return s == &quot;yes&quot;; };
    auto const it = std::find_if(begin, end, is_yes);

    // do stuff with `it`
    // ....
}
</code></pre>
",0,4661269,5228,435,8
65749445,10088661,0,"<p>In C++11 you can use a lambda to do the initialization, like so:</p>
<pre><code>bool test = true;
/*const*/ char a[10] = { //Aggregate initialization
                        [=] //capture by value
                           ()//no parameters
                             { //start lambda
    switch (test) {
        case true: return *&quot;test=true&quot;; //*&quot;xxx&quot; don't return a pointer, but the 'string' itself
        case false: return *&quot;test=false&quot;; 
    } //switch
}()};  //}, close the lambda, (), call it, }; close aggregate initialization
</code></pre>
<p>This comes in handy when your environment does not support <code>std::string</code>, like NVidia's CUDA or some strange embedded environment.
The lambda gets to be inlined, so internally it translates to <code>char a[10] = test?&quot;xxx&quot;:&quot;yyy&quot;;</code></p>
<p>If you have the option to do so, you obviously want to always use <code>std::string</code>, because fixed sized char buffers are fundamentally a bad idea.</p>
<p>If you use <code>std::string</code> you can convert that to a char array using: <code>chararray = mystring.c_str();</code>. Which is useful if you insist on using <code>printf</code>: <code>printf(&quot;s = %s&quot;, mystring.c_str());</code>.</p>
",0,650492,72853,4836,1203
68328443,5730135,0,"<p>Probably not relevant for the code in this question, but you can also get this error if you forget to export a function declaration in a library and then try to use that function from outside that library. For example, this code</p>
<pre><code>bool operator==(const Foo &amp;a, const Foo &amp;b);
</code></pre>
<p>should become</p>
<pre><code>MY_EXPORT_MACRO bool operator==(const Foo &amp;a, const Foo &amp;b);
</code></pre>
",0,904422,22273,1366,155
70508141,8966903,1,"<p>We can define a <code>stringTo()</code> function,</p>
<pre><code>#include &lt;string&gt;
#include &lt;sstream&gt;

template &lt;typename T&gt;
T stringTo(const std::string&amp; s) {
  T x;
  std::istringstream in(s);
  in &gt;&gt; x;
  return x;
}
</code></pre>
<p>Then, use it like</p>
<pre><code>std::cout &lt;&lt; stringTo&lt;double&gt;(&quot;-3.1e3&quot;) &lt;&lt; &quot; &quot; &lt;&lt; stringTo&lt;int&gt;(&quot;4&quot;);
</code></pre>
",0,3326606,225,2201,0
63802083,11671282,4,"<p>There is very informative and concise table at the end of this page by Howard Hinnant <a href=""https://howardhinnant.github.io/classdecl.html"" rel=""nofollow noreferrer"">https://howardhinnant.github.io/classdecl.html</a></p>
<p><a href=""https://i.stack.imgur.com/142BI.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/142BI.jpg"" alt=""enter image description here"" /></a></p>
",1,1599752,363,545,1
67556013,6143824,2,"<p>If you want to modify the original string instead of creating a copy, you can use <code>std::string::insert()</code>.</p>
<pre><code>std::string s = &quot;123&quot;;
unsigned int number_of_zeros = 5 - s.length(); // add 2 zeros

s.insert(0, number_of_zeros, '0');
</code></pre>
<p>Result:</p>
<pre><code>00123
</code></pre>
",0,4581323,1441,1166,267
66752797,7853686,1,"<p>The method from 'AndersK' is quite good. But what if you have empty characters at the end of the string: <code>string text{&quot; my big and long string  &quot;};</code> ?
The code doesn't return any last word.</p>
<p>So I was thinnking... -  why not to check the last character with the same means it is already used. And then to go character by character backwards until you find the character of the last word. And then go backwards with already written code by someone. So I fulfilled this code block and made a function:</p>
<pre class=""lang-cpp prettyprint-override""><code>string Last_str_word(const string&amp; text)
{
    int i = text.length() - 1;
    
    if (isspace(text[i]))
        while (isspace(text[i])) i--;
    
    while (i != 0 &amp;&amp; !isspace(text[i])) --i;
    
    string lastword = text.substr(i + 1);
    return lastword;
}
</code></pre>
<p>It works and you don't have to worry if there are empty characters at the end. It will still return the last word.</p>
",0,6608061,11,0,0
71306811,8716293,0,"<p>I know this answer is not answering OP's question, but it helps if your source of <code>char*</code> is a <code>char</code> array with known size.</p>
<p><a href=""https://godbolt.org/z/rdrohWsx6"" rel=""nofollow noreferrer"">Live demo</a></p>
<pre><code>#include &lt;fmt/core.h&gt;
#include &lt;type_traits&gt;
#include &lt;iostream&gt;

// SFINAE fallback  
template&lt;typename T, typename =
    std::enable_if&lt; std::is_pointer&lt;T&gt;::value &gt;
&gt;
int charArrayToInt(const T arr){  // Fall back for user friendly compiler errors
    static_assert(false == std::is_pointer&lt;T&gt;::value, &quot;`charArrayToInt()` dosen't allow conversion from pointer!&quot;);
    return -1;
}

// Valid for both null or non-null-terminated char array
template&lt;size_t sz&gt;
int charArrayToInt(const char(&amp;arr)[sz]){
    // It doesn't matter whether it's null terminated or not
    std::string str(arr, sz);
    return std::stof(str);
}


int main() {
    char number[2] = {'4','2'};
    int ret = charArrayToInt(number);
    fmt::print(&quot;The answer is {}. &quot;, ret);
    return 0;
}
</code></pre>
",0,4123703,1927,2656,11
70381849,11516657,2,"<p>You have</p>
<ol>
<li><p>The standard initialization list</p>
<pre><code>address temp_address {
    /* street_no */,
    /* street_name */,
    ...
    /* postal_code */
};

address temp_address2 = {
    /* street_no */,
    /* street_name */,
    ...
    /* postal_code */
}
</code></pre>
</li>
<li><p>The dot notation</p>
<pre><code>address temp_address;
temp_address.street_no = ...;
temp_address.street_name = ...;
...
temp_address.postal_code = ...;
</code></pre>
</li>
<li><p>The designated aggregate initialization, where the initialization list contains that labels of each member of the structure (see <a href=""https://en.cppreference.com/w/cpp/language/aggregate_initialization"" rel=""nofollow noreferrer"">documentation</a>) available from C++20 onward.</p>
</li>
<li><p>Treating a <code>struct</code> like a C++ class - in C++ structures are actually special types of classes, where all members are <code>public</code> (unlike a standard C++ class where all members are <code>private</code> if not specified otherwise explicitly) as well as that when using inheritance they default to <code>public</code>:</p>
<pre><code>struct Address {
    int street_no;
    ...
    char* postal_code;

    Address (int _street_no, ... , char* _postal_code)
     : street_no(_street_no),
       ...
       postal_code(_postal_code)
    {}
}

...

 Address temp_address ( /* street_no */, ..., /* postal_code */);
</code></pre>
</li>
</ol>
<p>When it comes to the way you initialize your structure you should consider the following aspects:</p>
<ul>
<li><strong>Portability</strong> - different compilers, different degree of C++ standard completeness and different C++ standards altogether do limit your options. If you have to work with let's say a C++11 compiler but want to use the C++20 designated aggregate initialization you are out of luck</li>
<li><strong>Readability</strong> - what is more readable: <code>temp_address.city = &quot;Toronto&quot;</code> or <code>temp_address { ..., &quot;Toronto&quot;, ... }</code>? Readability of your code is very important. Especially when you have large structures (worse - nested ones), having unlabeled values all over the place is just asking for trouble</li>
<li><strong>Scalability</strong> - anything that depends on a specific order is not a good idea. The same goes for lack of labels. You want to move a member up or down the address space of the structure? Good luck with an unlabeled initialization list (hunting down swapped values in structure initialization is a nightmare)... You want to add a new member? Again good luck with anything that depends on a specific order.</li>
</ul>
<p>While the dot notation means you type more the benefits you get from using it outweigh this issue and as such I can recommend it unless you have a small structure that is future-proof in terms of lack of changes in its structure, in which case you can afford to go with an initialization list. Remember: whenever working with other people writing code that is easy to follow is essential.</p>
",0,1559401,7662,544,16
65781056,9744977,0,"<p>One other thing to watch out for; make sure your .cpp files are actually showing up in your project files; I could not figure out a stupid linker error last night, and I just checked my project and apparently I never added the necessary .cpp files (they existed on disk but were missing from the project). It can be easy to overlook this, so heads-up.</p>
",0,2476204,541,18,0
63068039,13566785,0,"<p>Converts binary string to integer and binary string (up to 64 bits) to long.  Uses bit-shifting so slightly more efficient than pow().</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string&gt;

using namespace std;

string getBinaryString(int value, unsigned int length, bool reverse) {
    string output = string(length, '0');
    if (!reverse) {
        for (unsigned int i = 0; i &lt; length; i++) {
            if ((value &amp; (1 &lt;&lt; i)) != 0) {
                output[i] = '1';
            }
        }
    }
    else {
        for (unsigned int i = 0; i &lt; length; i++) {
            if ((value &amp; (1 &lt;&lt; (length - i - 1))) != 0) {
                output[i] = '1';
            }
        }
    }
    return output;
}

unsigned long getInteger(const string&amp; input, size_t lsbindex, size_t msbindex) {
    unsigned long val = 0;
    unsigned int offset = 0;
    if (lsbindex &gt; msbindex) {
        size_t length = lsbindex - msbindex;
        for (size_t i = msbindex; i &lt;= lsbindex; i++, offset++) {
            if (input[i] == '1') {
                val |= (1 &lt;&lt; (length - offset));
            }
        }
    }
    else { //lsbindex &lt; msbindex
        for (size_t i = lsbindex; i &lt;= msbindex; i++, offset++) {
            if (input[i] == '1') {
                val |= (1 &lt;&lt; offset);
            }
        }
    }
    return val;
}

int main() {
    int value = 23;
    cout &lt;&lt; value &lt;&lt; &quot;: &quot; &lt;&lt; getBinaryString(value, 5, false) &lt;&lt; endl;
    string str = &quot;01011&quot;;
    cout &lt;&lt; str &lt;&lt; &quot;: &quot; &lt;&lt; getInteger(str, 1, 3) &lt;&lt; endl;
}
</code></pre>
",0,3100538,619,93,0
65017020,11420497,6,"<p>C++ does not have the requirement, found in C# and Java, that every piece of code belong to a class of some description. C++ allows for standalone functions amd <code>main</code> falls into that category.</p>
<p>Hence <code>main</code> belongs to <em>no</em> class.</p>
<p>Of course, you can <em>create</em> a class that contains a <code>main</code> function, but that won't be <em>the</em> main function that gets called automagically on program start:</p>
<pre class=""lang-cpp prettyprint-override""><code>#include &lt;iostream&gt;

class SomeClass {
public:
    SomeClass() {
        std::cout &lt;&lt; &quot;In SomeClass constructor\n&quot;;
    }
    ~SomeClass() {
        std::cout &lt;&lt; &quot;In SomeClass destructor\n&quot;;
    }
    static int main() {
        std::cout &lt;&lt; &quot;In SomeClass main\n&quot;;
        return 0;
    }
};

int main() {
    std::cout &lt;&lt; &quot;In real main\n&quot;;
    { SomeClass xyzzy; } // Just to ensure destructor called before main exit.
    std::cout &lt;&lt; &quot;Exit real main\n&quot;;
}
</code></pre>
<p>The output of that shows that the class variant of <code>main</code> is not called:</p>
<pre class=""lang-none prettyprint-override""><code>In real main
In SomeClass constructor
In SomeClass destructor
Exit real main
</code></pre>
",0,14860,808674,4612,1592
65017014,11420497,1,"<p>main has nothing to do with classes in C++. It's a reserved function name that the linker knows that is the entrypoint (address) of the application</p>
<p><a href=""http://www.cplusplus.com/doc/tutorial/program_structure/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/doc/tutorial/program_structure/</a></p>
",0,1866300,8897,1964,19
61971784,9280921,2,"<p>In DEVC++, I faced same issue and i got solution.
I used single quote instead of double quote.</p>
",0,10829391,81,1,0
59865544,10266637,1,"<p>on c++ 11</p>

<p><code>constexpr</code> tells the compiler that this is a <strong>compile</strong> time constant, not allocated, used by value when needed and subject to optimizations, expressions involving <code>constexpr</code> and/or <code>const</code> values are calculated at compile time.
Compilers can do otherwise, but i see no need for even large <code>constexpr</code> objects to be allocated whatsoever.</p>

<p><code>const</code> allocated at <strong>compile</strong> time can be optimized by using value when needed if no pointer taken</p>

<p>global variables and static variables inside functions are allocated at <strong>compile</strong> time</p>

<p>variables inside functions are usually put into <strong>stack</strong> memory, same as passing arguments, but they can reside on memory (compiler is free i guess)</p>

<p>things allocated with <code>new</code> operator (or old C style <code>malloc</code>) will reside on <strong>heap</strong> until freed</p>
",0,1329075,1661,393,5
59598795,10896915,0,"<pre><code>template &lt;size_t upper_limit&gt; class prime_table final {
public:
  static_assert(upper_limit &gt;= 2, ""upper_limit too tiny"");
  prime_table() {
    table_.set();
    table_.reset(0);
    table_.reset(1);

    size_t root = size_t(std::sqrt(upper_limit)) + 1;
    for (size_t pos = 2; pos &lt;= root; ++pos) {
      for (size_t multiplier = 2; pos * multiplier &lt;= upper_limit;
           ++multiplier) {
        table_.reset(pos * multiplier);
      }
    }
  }

  inline bool is_prime(size_t value) { return table_.test(value); }

protected:
  std::bitset&lt;upper_limit + 1&gt; table_;
};
</code></pre>

<p>It generates a prime number table then you can use is_prime() to test against a number in range [0, upper_limit]  </p>
",0,2951377,357,100,4
64054360,13509733,0,"<p><code>wchar_t</code> is specified in the C++ language in <a href=""http://basic.fundamental#5"" rel=""nofollow noreferrer"">[basic.fundamental]/p5</a> as:</p>
<blockquote>
<p>Type <code>wchar_t</code> is a distinct type whose values can represent distinct codes for all members of the largest extended character set specified among the supported locales (<a href=""https://timsong-cpp.github.io/cppwp/n3337/locale"" rel=""nofollow noreferrer"">[locale]</a>).</p>
</blockquote>
<p>In other words, <code>wchar_t</code> is a data type which makes it possible to work with text containing characters from <em>any</em> language without worrying about character encoding.</p>
<p>On platforms that support Unicode above the <a href=""https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane"" rel=""nofollow noreferrer"">basic multilingual plane</a>, <code>wchar_t</code> is usually 4 bytes (Linux, BSD, macOS).</p>
<p>Only on Windows <code>wchar_t</code> is 2 bytes and encoded with UTF-16LE, due to <a href=""https://en.wikipedia.org/wiki/Unicode_in_Microsoft_Windows"" rel=""nofollow noreferrer"">historical reasons</a> (Windows initially supported UCS2 only).</p>
<p>In practice, the &quot;1 <code>wchar_t</code> = 1 character&quot; concept becomes even more complicated, due to Unicode supporting combining characters and graphemes (characters represented by sequences of code points).</p>
",0,485343,72236,3427,980
66959654,10442404,1,"<p>I don't know why no one else mentioned this, but from the functionality described in your comments, <strong>it sounds like what you want is a namespace, not a class</strong>. It's perfectly fine for you to have 100 functions with the same name defined in 100 differently named namespaces. It should behave exactly as you are describing, and is the entire purpose behind namespaces.</p>
",1,2502718,595,127,1
70076282,15109469,0,"<p>If using wstring, might consider the below:</p>
<pre><code>  int ValInt = 20;
  TCHAR szSize[20];

_stprintf(szSize, _T(&quot;%d&quot;), ValInt);

wstring myWchar;
myWchar = (wstring)szSize;
</code></pre>
",0,575281,10806,574,27
70159798,16432959,0,"<blockquote>
<p>But at throw c how is copy constructor being called? Can someone explain?</p>
</blockquote>
<p>C++ exceptions must be copy/move constructable if you want to do <code>throw ex;</code> as what's happening behind the scene is that the C++ ABI will allocate an exception object (via __cxa_allocate_exception) <em>somewhere</em> and copy/move your exception object, either it's on the heap or stack, before it actually starts the stack unwinding process.</p>
<p>Reference <a href=""https://blog.the-pans.com/cpp-exception-2/"" rel=""nofollow noreferrer"">https://blog.the-pans.com/cpp-exception-2/</a></p>
",0,860020,83,25,0
68673193,14521972,1,"<p>I have a similar use case, a difference being that I only need to populate the 'queue' once, then I need to consume <em>all</em> the elements <em>in the same order they were added</em>, after which I discard the queue.</p>
<p>Anyone having a similar case can simply</p>
<ul>
<li>use a vector</li>
<li>fill it with a series of push_back() calls</li>
<li>then use the entries in normal order (from <em>begin()</em> to <em>end()</em>)</li>
<li>then just <em>clear()</em> the vector</li>
</ul>
<p>I've not tested it yet, but will try it soon.</p>
",0,7409029,399,322,10
64377973,15088309,0,"<pre><code>Already answered above, but if anyone is looking for a working example to copy and try quickly:

int main()
{
std::vector&lt;int&gt; v1;

int randNum1 = rand()%(97) + 1;
int randNum2 = rand()%(98-randNum1) +1;
int randNum3 = rand()%(99 - (randNum1+randNum2)) +1;
int randNum4 = 100 -(randNum1+randNum2+randNum);

v1.push_back(randNum1);
v1.push_back(randNum2);
v1.push_back(randNum3);
v1.push_back(randNum4);

int sum = 0;
for(const auto &amp;itr : v1)
{
    cout &lt;&lt; itr &lt;&lt;endl;
    sum =sum+itr;
}
cout &lt;&lt; &quot;sum is : &quot; &lt;&lt; sum &lt;&lt;endl;

return 0;
</code></pre>
<p>}</p>
",0,2739018,83,23,0
66316007,13203999,0,"<p>if you want to access member variables in static member function just create a static pointer of the member variable and use it in the function !!!!!</p>
",0,6570287,99,0,0
69554425,13129340,2,"<p>It uses standard c++ functionality. No need to include any third party library in code.</p>
<p>Only send directory path as parameter. It will revert you every files path present in that folder and its sub folder.</p>
<p>Further that, if you need to sort any specific type file (i.e. .txt or .jpg), pass extension, it will print all the files path which having respective extension.</p>
<pre><code>#include &lt;Windows.h&gt;
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
using namespace std;

vector&lt;string&gt; files;

std::string Recursive(std::string folder) {
    std::string search_path = folder + &quot;/*.*&quot;;
    WIN32_FIND_DATA fd;
    HANDLE hFind = ::FindFirstFile(search_path.c_str(), &amp;fd);
    std::string tmp;
    if (hFind != INVALID_HANDLE_VALUE) {
        do {
            if (fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {
                if (!(!strcmp(fd.cFileName, &quot;.&quot;) || !strcmp(fd.cFileName, &quot;..&quot;))) {
                    tmp = folder + &quot;\\&quot;;
                    tmp = tmp + fd.cFileName;
                    Recursive(tmp);
                }
            }
            else {
                std::string FinalFilePath = folder + &quot;\\&quot; + fd.cFileName;
                files.push_back(FinalFilePath);
            }

        } while (::FindNextFile(hFind, &amp;fd));
        ::FindClose(hFind);
    }
    return folder;
}

bool has_suffix(const std::string&amp; str, const std::string&amp; suffix) {
    return str.size() &gt;= suffix.size() &amp;&amp;
        str.compare(str.size() - suffix.size(), suffix.size(), suffix) == 0;
}

int main(){
std::string folder = &quot;C:\\Users\\Omkar\\Desktop\\Test&quot;;
    Recursive(folder);
    std::string t;
    const auto needle = std::string(&quot;.txt&quot;);
    while (!files.empty()) {
        t = files.back();
        if (has_suffix(t, &quot;.mmt&quot;)) {
            cout &lt;&lt; &quot;FINAL PATH : &quot; &lt;&lt; t &lt;&lt; endl;
            t.clear();
        }
        files.pop_back();
    }
return 0;
}
</code></pre>
",0,12214121,313,39,0
63663870,13347466,0,"<p>Here is the complete solution for this problem:</p>
<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
using namespace std;

// we gonna read each line to map&lt;string, int&gt;
// which will be ordered by its strings by default nature, not line numbers
// then read this map to the vector and sort it by line numbers as it should be for output.txt

typedef pair&lt;string, int&gt; vecpair;

int main(int argc, char* argv[])
{
    if(argc &lt; 2)
    {
        cout &lt;&lt; &quot;Missing input filename&quot; &lt;&lt; endl;
        exit(1);
    }
    else
    {
        ifstream infile(argv[1], ios::in);
        ofstream outfile(&quot;output.txt&quot;, ios::out);

        if(!infile)
        {
            cout &lt;&lt; &quot;File &quot; &lt;&lt; argv[1] &lt;&lt; &quot;could not be opened&quot; &lt;&lt; endl;
            exit(1);
        }

        // map of input file string lines
        map&lt;string, int&gt; records;
        int line_number{0};

        for(string line{}; getline(infile, line); line_number++)
        {
            auto entry = make_pair(line, line_number);
            auto pair = records.insert(entry);
        }

        infile.close();

        /*
        // map to the outfile sample as part of debugging
        if(records.empty())
        {
            outfile &lt;&lt; &quot;Empty records&quot; &lt;&lt; endl;
        }
        else
        {
            for(auto iter = records.begin(); iter != records.end(); iter++)
            {
                outfile &lt;&lt; iter-&gt;first &lt;&lt; &quot;\t&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;
            }
        }
        */

        // create an empty vector of pairs
        vector&lt;vecpair&gt; vec;

        // copy key-value pairs from the map to the vector
        copy(records.begin(), records.end(), back_inserter&lt;vector&lt;vecpair&gt;&gt;(vec));

        // sort the vector by increasing order of its pair's second value
        // if second value are equal, order by the pair's first value
        sort(vec.begin(), vec.end(), [](const vecpair&amp; l, const vecpair&amp; r)
        {
            if(l.second != r.second)
                return l.second &lt; r.second;
            return l.first &lt; r.first;
        });


        // output vector to outfile.txt
        if(vec.empty())
        {
            outfile &lt;&lt; &quot;Empty records&quot; &lt;&lt; endl;
        }
        else
        {
            for(auto const &amp;vecpair : vec)
            {
                //outfile &lt;&lt; vecpair.first &lt;&lt; &quot;\t&quot; &lt;&lt; vecpair.second &lt;&lt; endl;
                outfile &lt;&lt; vecpair.first &lt;&lt; endl;
            }
        }

        outfile.close();
        return 0;
    }
}
</code></pre>
",0,522564,3052,191,6
63960288,14090043,0,"<p>I was looking for the same thing in STL but could not find it.
Ended up writing my own (handles NULL)</p>
<pre><code>class DeRefPtrLess {

public:

template&lt;typename T&gt;
    bool operator()(const T *l, const T *r) const {
        if (l == NULL
                &amp;&amp; r == NULL) {
            return false;
        }
        if (l == NULL) {
            return true;
        }

        return *l &lt; *r;
    }
</code></pre>
<p>};</p>
",0,192030,832,433,3
62759560,16169025,0,"<p>This question can only be truly answered by running tests on the computer that you're going to run on.</p>
<p>On my modern Intel Ubuntu (2017), speed differences are down in the noise.  Pushing shorts onto the stack seems to be just a hair 1% faster than pushing ints onto the stack, +/- about 1%.</p>
<p>Most of the speedup is going to come from cutting your memory in half, which will save page-swapping on those big-data / neural-net munging programs.</p>
",0,841457,5803,975,2
