1244415,1180708,1,"<p>If you can understand french, there is a good tutorial right <a href=""http://www.siteduzero.com/tutoriel-3-14189-apprenez-a-programmer-en-c.html"" rel=""nofollow noreferrer"">here</a>.</p>

<p>It explains the basics, but also the more complex stuff.</p>
",0
1244436,1180708,3,"<p>Why don't you use something that's more lightweight and simpler to use than visual Studio for your C Projects?</p>

<p>I reccommend <a href=""http://www.codeblocks.org/"" rel=""nofollow noreferrer"">Code::Blocks</a>.  Believe me, it's a lot more lightweight than Visual Studio, and in my opinion it's a lot better to work with it whilst learning to develop in C.</p>

<hr>

<p>As regards books, I would go for both <a href=""https://rads.stackoverflow.com/amzn/click/com/0131103628"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">K&amp;R's C Programming Language</a>, but I also reccomend another one : <a href=""https://rads.stackoverflow.com/amzn/click/com/0672326965"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">C Primer Plus</a> and I think the latter one is more appropriate as a beginner's book.</p>
",0
51038,50525,2,"<p>A test confirms that GCC 4.2.3 will simply compare with the overflowed result:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int a, b, c;

    a = 2000000000;
    b = 2000000000;
    c = 2100000000;

    printf(""%d + %d = %d\n"", a, b, a+b);
    if ((a + b) &gt; c)
    {
        printf(""%d + %d &gt; %d\n"", a, b, c);
    }
    else
    {
        printf(""%d + %d &lt; %d\n"", a, b, c);
    }
    return 0;
}
</code></pre>

<p>Displays the following:</p>

<pre><code>2000000000 + 2000000000 = -294967296
2000000000 + 2000000000 &lt; 2100000000
</code></pre>
",0
50530,50525,7,"<p>C will do no such thing. It will silently overflow and lead to a possibly incorrect comparison. You can up-cast yourself, but it will not be done automatically.</p>
",2
50531,50525,0,"<p>I believe this might be platform specific. Check the C documentation on how overflows are handled...</p>

<p>Ah, yes, and the upcast will not happen automatically...</p>
",0
50611,50525,0,"<p>See section 2.7, <em>Type Conversions</em> in the K&amp;R book</p>
",0
992633,50525,0,"<p>If upcasting doesn't gain you any bits (there's no guarantee that sizeof(long)>sizeof(int) in C), you can use conditions like the ones below to compare and check for overflow¡ªupcasting is almost certainly faster if you can use it, though.</p>

<pre><code>#if !defined(__GNUC__) || __GNUC__&lt;2 || (__GNUC__==2 &amp;&amp; __GNUC_MINOR__&lt;96)
#   define unlikely(x) (x)
#else
#   define unlikely(x)     (__extension__ (__builtin_expect(!!(x), 0)))
#endif

/* ----------
 * Signed comparison (signed char, short, int, long, long long)
 * Checks for overflow off the top end of the range, in which case a+b must
 * be &gt;c.  If it overflows off the bottom, a+b &lt; everything in the range. */
if(a+b&gt;c || unlikely(a&gt;=0 &amp;&amp; b&gt;=0 &amp;&amp; unlikely(a+b&lt;0)))
    ...

/* ----------
 * Unsigned comparison (unsigned char, unsigned short, unsigned, etc.)
 * Checks to see if the sum wrapped around, since the sum of any two natural
 * numbers must be &gt;= both numbers. */
if(a+b&gt;c || unlikely(a+b&lt;a))
    ...

/* ----------
 * To generate code for the above only when necessary: */
if(sizeof(long)&gt;sizeof(int) ? ((long)a+b&gt;c)
       : (a+b&gt;c || unlikely(a&gt;=0 &amp;&amp; b&gt;=0 &amp;&amp; unlikely(a+b&lt;0)))
    ...
</code></pre>

<p>Great candidates for macros or inline functions.  You can pull the ""unlikely""s if you want, but they can help shrink and speed up the code GCC generates.</p>
",0
822854,822815,0,"<p>lothar summed pretty well advantages for first idiom -- quite probably it's the best for general solutions.</p>

<p>However, there are times when 3rd option (modified) is better -- if you have a lot to output. To avoid memory stress you can add pools to the mix.</p>
",0
822824,822815,3,"<p>There's no one best way - all the options you propose are used at some time or another. The important thing is to document it well, and keep it consistent across all functions in a library, where practical.</p>
",0
822828,822815,1,"<p>You could use the first idiom (user allocates) and if the space for the string is not sufficient you reallocate. This will work if you and the user agree to use the same allocation (like malloc/free). This will give you optimum performance (no allocation for every iteration) and is still convenient for the user.</p>

<p>With this idiom the allocated storage grows as needed, but the user can at any time choose to ""shrink"" it by reallocating a smaller storage (which will start growing again if necessary).</p>
",1
1244415,1180708,1,"<p>If you can understand french, there is a good tutorial right <a href=""http://www.siteduzero.com/tutoriel-3-14189-apprenez-a-programmer-en-c.html"" rel=""nofollow noreferrer"">here</a>.</p>

<p>It explains the basics, but also the more complex stuff.</p>
",0
1244436,1180708,3,"<p>Why don't you use something that's more lightweight and simpler to use than visual Studio for your C Projects?</p>

<p>I reccommend <a href=""http://www.codeblocks.org/"" rel=""nofollow noreferrer"">Code::Blocks</a>.  Believe me, it's a lot more lightweight than Visual Studio, and in my opinion it's a lot better to work with it whilst learning to develop in C.</p>

<hr>

<p>As regards books, I would go for both <a href=""https://rads.stackoverflow.com/amzn/click/com/0131103628"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">K&amp;R's C Programming Language</a>, but I also reccomend another one : <a href=""https://rads.stackoverflow.com/amzn/click/com/0672326965"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">C Primer Plus</a> and I think the latter one is more appropriate as a beginner's book.</p>
",0
51038,50525,2,"<p>A test confirms that GCC 4.2.3 will simply compare with the overflowed result:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int a, b, c;

    a = 2000000000;
    b = 2000000000;
    c = 2100000000;

    printf(""%d + %d = %d\n"", a, b, a+b);
    if ((a + b) &gt; c)
    {
        printf(""%d + %d &gt; %d\n"", a, b, c);
    }
    else
    {
        printf(""%d + %d &lt; %d\n"", a, b, c);
    }
    return 0;
}
</code></pre>

<p>Displays the following:</p>

<pre><code>2000000000 + 2000000000 = -294967296
2000000000 + 2000000000 &lt; 2100000000
</code></pre>
",0
50530,50525,7,"<p>C will do no such thing. It will silently overflow and lead to a possibly incorrect comparison. You can up-cast yourself, but it will not be done automatically.</p>
",2
50531,50525,0,"<p>I believe this might be platform specific. Check the C documentation on how overflows are handled...</p>

<p>Ah, yes, and the upcast will not happen automatically...</p>
",0
50611,50525,0,"<p>See section 2.7, <em>Type Conversions</em> in the K&amp;R book</p>
",0
992633,50525,0,"<p>If upcasting doesn't gain you any bits (there's no guarantee that sizeof(long)>sizeof(int) in C), you can use conditions like the ones below to compare and check for overflow¡ªupcasting is almost certainly faster if you can use it, though.</p>

<pre><code>#if !defined(__GNUC__) || __GNUC__&lt;2 || (__GNUC__==2 &amp;&amp; __GNUC_MINOR__&lt;96)
#   define unlikely(x) (x)
#else
#   define unlikely(x)     (__extension__ (__builtin_expect(!!(x), 0)))
#endif

/* ----------
 * Signed comparison (signed char, short, int, long, long long)
 * Checks for overflow off the top end of the range, in which case a+b must
 * be &gt;c.  If it overflows off the bottom, a+b &lt; everything in the range. */
if(a+b&gt;c || unlikely(a&gt;=0 &amp;&amp; b&gt;=0 &amp;&amp; unlikely(a+b&lt;0)))
    ...

/* ----------
 * Unsigned comparison (unsigned char, unsigned short, unsigned, etc.)
 * Checks to see if the sum wrapped around, since the sum of any two natural
 * numbers must be &gt;= both numbers. */
if(a+b&gt;c || unlikely(a+b&lt;a))
    ...

/* ----------
 * To generate code for the above only when necessary: */
if(sizeof(long)&gt;sizeof(int) ? ((long)a+b&gt;c)
       : (a+b&gt;c || unlikely(a&gt;=0 &amp;&amp; b&gt;=0 &amp;&amp; unlikely(a+b&lt;0)))
    ...
</code></pre>

<p>Great candidates for macros or inline functions.  You can pull the ""unlikely""s if you want, but they can help shrink and speed up the code GCC generates.</p>
",0
822854,822815,0,"<p>lothar summed pretty well advantages for first idiom -- quite probably it's the best for general solutions.</p>

<p>However, there are times when 3rd option (modified) is better -- if you have a lot to output. To avoid memory stress you can add pools to the mix.</p>
",0
822824,822815,3,"<p>There's no one best way - all the options you propose are used at some time or another. The important thing is to document it well, and keep it consistent across all functions in a library, where practical.</p>
",0
822828,822815,1,"<p>You could use the first idiom (user allocates) and if the space for the string is not sufficient you reallocate. This will work if you and the user agree to use the same allocation (like malloc/free). This will give you optimum performance (no allocation for every iteration) and is still convenient for the user.</p>

<p>With this idiom the allocated storage grows as needed, but the user can at any time choose to ""shrink"" it by reallocating a smaller storage (which will start growing again if necessary).</p>
",1
496458,496448,0,"<p>When you have that function defined on a different dll or lib, so that the compiler defers to the linker to find it. Typical case is when you are calling functions from the OS API.</p>
",0
496474,496448,6,"<p>If each file in your program is first compiled to an object file, then the object files are linked together, you need <code>extern</code>. It tells the compiler ""This function exists, but the code for it is somewhere else. Don't panic.""</p>
",2
496476,496448,330,"<p><code>extern</code> changes the linkage. With the keyword, the function / variable is assumed to be available somewhere else and the resolving is deferred to the linker.</p>
<p>There's a difference between <code>extern</code> on functions and on variables.</p>
<p>For <strong>variables</strong> it doesn't instantiate the variable itself, i.e. doesn't allocate any memory. This needs to be done somewhere else. Thus it's important if you want to import the variable from somewhere else.</p>
<p>For <strong>functions</strong>, this only tells the compiler that linkage is extern. As this is the default (you use the keyword  <code>static</code> to indicate that a function is not bound using extern linkage) you don't need to use it explicitly.</p>
",4
496489,496448,2,"<p>Functions actually <em>defined</em> in other source files should only be <em>declared</em> in headers. In this case, you should use <em>extern</em> when <em>declaring</em> the prototype in a header.</p>

<p>Most of the time, your functions will be one of the following (more like a best practice):</p>

<ul>
<li>static (normal functions that aren't
visible outside that .c file)</li>
<li>static inline (inlines from .c or .h
files)</li>
<li>extern (declaration in headers of the
next kind (see below))</li>
<li>[no keyword whatsoever] (normal
functions meant to be accessed using
extern declarations)</li>
</ul>
",2
1302880,1302859,3,"<p>This is completely anecdotal, but I've heard that the <a href=""http://sqlite.org/"" rel=""nofollow noreferrer"">SQLite</a> project is considered good code.</p>
",0
1302896,1302859,6,"<p>Check out git source code: <a href=""http://github.com/git/git/tree/master"" rel=""noreferrer"">http://github.com/git/git/tree/master</a></p>
",2
1302909,1302859,6,"<p>I consider Steve Dekorte's <a href=""http://iolanguage.com/"" rel=""noreferrer"">IO language</a> implementation to be a good example for clean and pragmatic modern-day C.</p>
",1
1303850,1302859,16,"<p>Dave Hanson's <a href=""http://www.cs.princeton.edu/software/cii/"" rel=""noreferrer"">C Interfaces and Implementations</a> is a <em>very</em> well-crafted library of about 7000 lines of code.  The book is great if you can afford it.</p>

<p>The implementation of the <a href=""http://www.lua.org/"" rel=""noreferrer"">Lua</a> programming language and libraries is about 17,000 lines of C code and is very well done but quite sophisticated in places&mdash;compilers and garbage collectors are not so easy to understand without background in those fields.  But the code is beautifully engineered.</p>

<p>Git is over 125,000 lines of code.  I can't recommend that anyone study it as an example of how to engineer C code.  Just the design and public interfaces, let alone the implementations, are hard to understand&mdash;which is why there are so many git tutorials.</p>
",5
1305047,1302859,1,"<p>How about:</p>

<p>""The C Programming Language"", 2nd edition, Kernighan and Ritchie</p>

<p>Answers to Exercises</p>

<p><a href=""http://users.powernet.co.uk/eton/kandr2/"" rel=""nofollow noreferrer"">http://users.powernet.co.uk/eton/kandr2/</a></p>
",0
1306093,1302859,1,"<p>The following book (with code examples) could ease your paradigm shift a bit:</p>

<p>Stephen Kochan</p>

<p>Programming in C, Third Edition</p>

<p><a href=""http://www.kochan-wood.com"" rel=""nofollow noreferrer"">http://www.kochan-wood.com</a></p>
",0
1317203,1302859,1,"<p><a href=""https://i.stack.imgur.com/J8d41.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/J8d41.jpg"" alt=""C: A reference Manual By Harbison and Steele""></a>
</p>

<p><a href=""https://rads.stackoverflow.com/amzn/click/com/013089592X"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">C: A Reference Manual</a> contains a variety of example code usage, with implementations centric to Standard C; A definite document to look into, perhaps along with the C Std.</p>
",0
1317208,1302859,1,"<p>The SVN project is written entirely in C and it is well maintained: consistently styled, good comments, low code smell.  I recommend <a href=""http://subversion.tigris.org/getting.html#source-release"" rel=""nofollow noreferrer"">perusing</a> it.</p>
",0
249516,249468,2,"<p>Ah, the link Patrick posted includes this ""The typedef name uint_leastN_t designates an unsigned integer type with a width of at least N, such that no unsigned integer type with lesser size has at least the specified width.""</p>

<p>So my current understanding is:</p>

<p>uint_least16_t the smallest thing that is capable of holding a uint16</p>

<p>uint_fast16_t the fastest thing that is capable of holding a uint16</p>

<p>uint16_t exactly a uint16, unfortunately may not be available on all platforms, on any platform where is is available uint_least16_t will refer to it. So if it were guaranteed to exist on all platforms we wouldn't need uint_least16_t at all.</p>
",2
249478,249468,0,"<p>It's part of the c standard. It doesn't need a good use case. :P</p>

<p>See <a href=""http://www.opengroup.org/onlinepubs/009695399/basedefs/stdint.h.html"" rel=""nofollow noreferrer"">this</a> page and look for the section titled ""Minimum-width integer types"".</p>
",1
249482,249468,12,"<p>Say you're working on a compiler with:</p>

<ul>
<li><code>unsigned char</code> is 8 bits</li>
<li><code>unsigned short</code> is 32 bits</li>
<li><code>unsigned int</code> is 64 bits</li>
</ul>

<p>And unsigned int is the 'fastest'.  On that platform:</p>

<ul>
<li><code>uint16_t</code> would <em>not</em> be available</li>
<li><code>uint_least16_t</code> would be a 32 bit value</li>
<li><code>uint_fast16_t</code> would be a 64 bit value</li>
</ul>

<p>A bit arcane, but that's what it's for.</p>

<p>How useful they are is another story - I see the exact size variants all the time.  That's what people want.  The 'least' and 'fast' versions I've seen used pretty close to never (it's possible that it was only in example code - I'm really not sure).</p>
",1
210953,210943,5,"<p>there is no ""centralized"" source for C libraries... at least nothing along the lines of CPAN for Perl or the Python Package Index for Python.</p>

<p>Since C is sort of the ""default"" language for systems programming, it's often unstated that libraries are written for C.  You may want to try Freshmeat.net's <a href=""http://freshmeat.net/search/set-advanced/?q=%2Bgraph&amp;section=projects&amp;orderby="" rel=""nofollow noreferrer"">Advanced Search</a>, since it's centered on Unix software, and there are a lot of C libraries posted there.  For example, here's what I come up with searching for ""graph library"": <a href=""http://freshmeat.net/search/?section=projects&amp;q=%2Bgraph+%2Blibrary"" rel=""nofollow noreferrer"">http://freshmeat.net/search/?section=projects&amp;q=%2Bgraph+%2Blibrary</a>, and you can filter those results by language, license, etc.</p>

<p>(And your English is quite fine!  Which I can't say about all the posters on here :-p)</p>
",0
210958,210943,2,"<p>I don't know of any C specific collections of modules. If I were looking for C modules, I'd check <a href=""http://sourceforge.net/"" rel=""nofollow noreferrer"">sourceforge</a> and <a href=""http://freshmeat.net/"" rel=""nofollow noreferrer"">freshmeat</a>. <a href=""http://library.gnome.org/devel/glib/"" rel=""nofollow noreferrer"">Glib</a> is a fantastic library, too.</p>
",0
210962,210943,3,"<p>If you're looking for a good repository of C code to examine and learn from then I recommend the <a href=""http://directory.fsf.org/GNU/"" rel=""nofollow noreferrer"">GNU</a> stuff. You can find anything from small programs like <a href=""http://directory.fsf.org/project/coreutils/"" rel=""nofollow noreferrer"">cat</a> to extremely large projects like <a href=""http://directory.fsf.org/project/emacs/"" rel=""nofollow noreferrer"">Emacs</a> and <a href=""http://directory.fsf.org/project/gnome/"" rel=""nofollow noreferrer"">Gnome</a>. All the code is released under the GPL and can be freely incorporated into GPL'd free software.</p>
",0
210971,210943,1,"<p>You might also consider the book <a href=""http://www.nr.com/"" rel=""nofollow noreferrer"">Numerical Recipes in C++</a> or the older Numerical Recipes in C (it might be out of print, though), depending on your algorithmic needs.</p>

<p>[EDIT] I didn't originally see this, but I found a link to the older book <a href=""http://www.nrbook.com/a/bookcpdf.php"" rel=""nofollow noreferrer"">here</a>.</p>
",0
803582,803522,12,"<p><a href=""https://rads.stackoverflow.com/amzn/click/com/013089592X"" rel=""noreferrer"" rel=""nofollow noreferrer"">C: A Reference Manual by Harbison and Steele</a></p>

<p>It's not a tutorial book, but it's hands-down the best book on C (even over K&amp;R in my opinion).  Used in conjunction with K&amp;R (or any other tutorial), you'll get a great foundation in C.</p>
",1
803535,803522,22,"<p>Peter van der Linden's <a href=""https://rads.stackoverflow.com/amzn/click/com/0131774298"" rel=""noreferrer"" rel=""nofollow noreferrer"">Expert C Programming: Deep C Secrets</a></p>
",1
803539,803522,6,"<p>I'd say to eschew the books entirely.  Pick a project, any project (although not too large), and implement it in C.  There's no substitute for simply jumping in and doing it.  K&amp;R gives enough knowledge that you can begin stumbling along and gaining the experience that makes for true good learning.</p>
",1
803554,803522,8,"<p><a href=""http://www.lysator.liu.se/c/schildt.html"" rel=""noreferrer"">This</a> explains why Schildt is bad. Some more criticism <a href=""http://www.seebs.net/c/c_tcr.html"" rel=""noreferrer"">here</a>.</p>

<p>Search SO for C resources.</p>
",1
803614,803522,0,"<p>I might also recommend reading C programs.  Sadly I haven't done enough of this myself to recommend particular ones.</p>
",2
803654,803522,4,"<p>I like <a href=""https://rads.stackoverflow.com/amzn/click/com/0673999866"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Pointers on C</a> by Kenneth A. Reek.  I won't do so far as to say it's better than K&amp;R but I certainly found it more friendly and easier to learn from.  I started with K&amp;R, but didn't really get a hang of C until I picked up this book.  </p>

<p><strong>Edit</strong>: I also just found out that the price of this book has skyrocketed since I bought it.  So while my recommendation still stands as such, I cannot really recommend it at the current asking price.  So if you can find a used copy or a copy at a library then it's worth getting, but at its current price there are other books that are basically just as good for a lot less money.</p>

<p>Expert C Programming is book I consider worth at least looking through once you've gotten the hang of C, although I'm hesitant to outright recommend it.  On the plus side it contains a number of good tips and tricks and some very useful advice.  On the minus side those tricks and pieces of advice are badly organize, buried among not so useful advice and half the book seems filled with lame jokes, asides and irrelevant (but occasionally amusing) stories.  So I'd borrow it from the library, but not pay money for it.</p>

<p>But as you no doubt realize, you'll never really learn C until you write C.  </p>
",6
803681,803522,8,"<p>I would be tempted to read <a href=""http://www.amazon.co.uk/Practice-Programming-Addison-Wesley-Professional-Computing/dp/020161586X/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1241030211&amp;sr=8-1"" rel=""noreferrer"">Practice of Programming</a> and <a href=""http://www.amazon.co.uk/Programming-Pearls-ACM-Press-Bentley/dp/0201657880/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1241030262&amp;sr=1-1"" rel=""noreferrer"">Programming Pearls</a>. Both are quite terse books and C orientated</p>
",1
803708,803522,1,"<p>Beginning C by Ivor Horton (3rd edition) from APress is a great introductory book on C programming.  This book is very thorough and is not a reference book but a good tutorial from start to end on everything in the C language.</p>

<p><a href=""https://rads.stackoverflow.com/amzn/click/com/1590592530"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Beginning C by Ivor Horton (3rd Edition)</a></p>
",2
806023,803522,0,"<p>There are some brief but helpful reviews at (the Russian mirror of) the <a href=""http://accu.org/"" rel=""nofollow noreferrer"">ACCU</a>, for <a href=""http://www.accu.informika.ru/accu/bookreviews/public/reviews/0sb/beginner_s_c.htm"" rel=""nofollow noreferrer"">beginner's C</a> and for <a href=""http://www.accu.informika.ru/accu/bookreviews/public/reviews/0sb/advanced_c.htm"" rel=""nofollow noreferrer"">advanced C</a>.</p>
",0
807609,803522,7,"<p>K&amp;R essentially covers everything you need to know about C, and even implements a few data structures that are commonly used. If you're using *nix and want to learn how to take advantage of the operating system, <a href=""https://rads.stackoverflow.com/amzn/click/com/0321637739"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Advanced Programming in the UNIX Environment, Third Edition</a> is a good reference/guide to common uses such as reading a file, creating threads, etc. Sample code is in C.</p>
",2
809300,803522,3,"<p><a href=""http://users.powernet.co.uk/eton/unleashed/"" rel=""nofollow noreferrer"">C unleashed</a>.</p>
",0
809213,803522,1,"<p>A great book to learn C is:
<a href=""https://rads.stackoverflow.com/amzn/click/com/0201713748"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer""><b>C BY DISSECTION</b> The Essentials of C Programming by Al Kelley &amp; Ira Pohl</a></p>

<p>Very easy to read wth lots of great programming examples.</p>
",0
809241,803522,3,"<p>Pick up your K&amp;R book again, and this time do the exercises. Then compare your code with the code in K&amp;R and see if it has similar elegance in the function interfaces and data structures. This isn't a book to read through quickly and go to the next book. It contains a lot of valuable information, and the exercises will help you to realize some of them that you probably missed on the first reading.</p>
",0
815273,803522,1,"<p>The best textbook on C I have is <a href=""https://rads.stackoverflow.com/amzn/click/com/0387946756"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">C: A Software Engineering Approach</a> by Peter A. Darnell and Philip E. Margolis. While it is (undeservedly) not as famous as other books, I found it very readable and it handles all the details K&amp;R skips over.</p>

<p>It has two disadvantages though:</p>

<ol>
<li>It is from 1996, so it does not cover C99. (This should be fine with you since you are interested in C89.)</li>
<li>It is quite expensive.</li>
</ol>

<p><strong>Edit:</strong>
Another book of interest is <a href=""https://rads.stackoverflow.com/amzn/click/com/0201845199"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">C Programming FAQs</a> by Steve Summit. While I don't have this book in print, the accompanying <a href=""http://www.eskimo.com/~scs/c-faq.com/index.html"" rel=""nofollow noreferrer"">web site</a> helped me a lot in understanding the less obvious features of C.</p>
",0
491096,491086,16,"<p>No, you don't have to know C. But knowledge of C (or any other ""close to the machine but not assembler"" language) greatly enhances your potential as a programmer. Because you will understand a lot more of the inner workings.</p>

<p>And of course knowledge of assembler is also valuable. But in the above paragraph, I wanted to target the low end of computer language. Just because in modern languages, we take so much for granted (OO, extensive libraries, garbage collection to name a few). And yes it helps us programmers to work more efficiently. But it hides some of the machine aspects that we sometimes need to see and that's why it is so important that we need to know the inner workings.</p>
",3
491104,491086,3,"<p>You don't necessarily have to know C, but imo every programmer should know about basic machine architecture and how applications interact with the OS and the hardware. </p>

<p>Obviously if you're going to study this, C is a good choice for a language, but not the only option. </p>

<p>Another good reason to know C is that a lot of code is written in C so if you want to learn from others code, it will be very helpful. </p>
",0
491108,491086,8,"<p>This is a quite discussable topic. I personally think that knowing C enhances your ability to work with other languages too when you understand what's going on <em>under the hood</em>. But you don't <strong>have</strong> to know C to be able to produce high quality code.</p>

<p>Eric Sink has also once thought of <a href=""http://www.ericsink.com/entries/c_morse_code.html"" rel=""noreferrer"">that question</a>.</p>
",0
491112,491086,3,"<p>In addition to Gamecats answer, in my experience working with people in other languages, there is a difference in skill between the guys that know C and the guys that don't.  I work primarily in Java and certainly appreciate having spent a few years working with C before I did.  On top of that I also did quite a bit of Perl work as well.  I would say knowing as many languages as possible helps to give you different views on your work and applying different paradigms</p>
",0
491125,491086,11,"<p>While I think it is important to understand memory allocation, pointers, registers, ... I would say that too much experience in C can also be a barrier to grasp higher level languages, or OO languages. C tends to make you think procedurally and that can be a bad thing in some cases ...</p>

<p>I would definitely not recommend C as a first language, but it can be of great help to do some C at some point...</p>

<p>As a side note, I think that assembly can be much more useful to help you understand basic principle. At the same time assembly is far enough from any language that you would use (unless you work in a very specialized field). That will help you keep a different mindset when doing assembly than when using a higher level language.</p>
",0
491131,491086,2,"<p>C is not my language of choice, but even to this day, C is everywhere.</p>

<p>When I do some small code in Lua using LuaCurl, I use a C library. Lua itself is written in C.</p>

<p>When I do some Seaside Web application in Squeak Smalltalk, I use a VM generated in C (the Squeak VM is written in Smalltalk, and then it generates C code as a portable assembler).</p>

<p>So I would not start learning programming with C (see <a href=""https://stackoverflow.com/questions/4769/what-is-the-easiest-language-to-start-with"">this thread</a> for other choices), but as a programmer, knowing C is very handy even if it is not your language of choice.</p>
",0
491137,491086,1,"<p><strong>Memory allocation and pointers.</strong></p>

<p>After getting to handle C and C++, even if only in school, you have a better understanding of what needs to happen in memory in order for you to throw objects and references around and you get a better appreciation of what, for instance, garbage collection implies.</p>

<p>Also, in school, starting with Pascal and then C allowed us to learn ""programming"" first, the old way, and then move to more advanced languages (OOP, etc) <strong>on top</strong> of that.</p>
",3
491143,491086,0,"<p>Have to know/learn C? Probably not, although it might make learning some concepts easier. Understanding something about memory allocation, structures and pointers of all kinds is worthwhile and C is a good language to use to gain that understanding. Plus, to be honest, ""straight"" C is really not complex. Tricky to get right, sure, but not in itself complex. I'd advise getting hold of a compiler that wasn't a C++ one too, that way can lie madness. (Fond memories of Quick C For Windows)</p>

<p>Have to know/learn C++? Definitely not.</p>
",0
491156,491086,1,"<p>I share the same sentiments as the others in this thread, however, to answer the question that was asked:</p>

<p>The only programmers that <em>have</em> to know C are C programmers.</p>
",0
491188,491086,1,"<p>All knowledge is useful, so yes, you should envy their knowledge. You should also envy people who are AI nerds and know LISP, etc. The best mix would be a dynamic language, a functional language, SQL, a low level language and an object oriented language.</p>

<p>If you want some stranger to make some recommendations, I would go Python, OCaml, SQL, C and Java/C#. But, find your own path :-)</p>
",0
491218,491086,1,"<p>I think you have. </p>

<p>Languages have their own evolution. They developed within a very intriguing and fast evolution of computer systems. CPU power grew, features grew, Assembler got more complex... everything got more powerful. </p>

<p>Thing is: if you never saw the low level and ""easy"" beginnings, and you start with some high-level languages like C#, C++, or Java, you won't understand the elegance or backend perspective of these very powerful languages.</p>

<p>I think you don't need to learn LISP, because if differs a lot from common C-like languages. But some C is a must-know. It's for developers from developers, very near to machine code. Know what the machine does when you program it.</p>
",1
491252,491086,0,"<p>I would use a metaphor: Knowing C for programmers is like knowing latin for (western languages) writers. It is not something you need, especially if you just write sports columns or cooking recipe books, but if you want to refine your craft it is something that I would consider nearly mandatory. But it will not be useful for daily work on ordinary software.
Or knowing mechanics for a car pilot, or how to build sails for a sailor. At some level of expertise, you need to know how the things you use are working internally.</p>

<p>If you learn C, try to master the pointer concept, and the way they map to the hardware. That's really the point of learning C.   Do not spend time on the rest of the language.</p>
",2
491743,491086,2,"<p>In the same way that not every mechanic needs to know the inner workings of an engine to fix a car, not every programmer needs to learn C to produce code.
however, the ones who do, acquire a better understanding of the craft and ultimately achieve a higher level of success.</p>
",0
491978,491086,0,"<p>Maybe it was just my particular educational experience, but I hated C/C++ in college and haven't touched it since.  I'm thankful for learning about the concepts involved, like pointers and memory allocation, but trying to accomplish anything with the tools that were available to me was too cumbersome for me to want to bother.  I hope your experience is better.</p>
",0
492013,491086,0,"<p>(""slightly"" tongue-in-check) You should learn it if, for no other reason, than it will make you <strong>love</strong> whatever language you're working in at that moment.</p>
",0
492026,491086,4,"<p>Something I find missing from most of these answers is that C is a very easy language to learn.  Everything you'll ever need to know about the syntax is contained in one thin, concise book (K&amp;R), and that includes all the standard libraries.  So I'd encourage you to at least skim a book and see what it's all about, even if you don't intend to use it.</p>

<p>That simple C syntax only gets <em>expanded</em> for most modern C-based languages (C++, C#, Java).  You can't say you really know those languages until you've mastered at least a subset of the hundreds of libraries that come with them, and that can take months or years of experience.</p>

<p>What's tough about C is that it can expose you to the true nature of the machine underneath.  If you really want to grok how a computer works, you need to understand things like pointers, memory allocation, and stack vs. heap vs. executable code.  You can learn basic C syntax in a few hours, and that puts you on the road to understanding much more.  Saying ""I'm a C expert"" is just a proxy for saying, ""I really understand how a computer works.""</p>
",0
492037,491086,0,"<p>I don't call myself a C programmer, but I can write code in C. It has helped me a number of times in my career. I've spent a lot of time working with Visual Basic, and there are some things you just can't do with VB. It's been very handy to drop down to C to do things like windows hooks. It's made me the ""hero"" a time or two.</p>
",0
577348,577081,4,"<p>Dan Olson had the right idea, and Slartibartfast explained where the values com from:</p>

<p>The definition of <code>mean_K_and_R()</code> is treated as if it were defined like this</p>

<pre><code>int mean_K_and_R();
</code></pre>

<p>ie the function takes any arguments and doesn't do any conversion aside from the default argument promotion.</p>

<p>If the cdecl calling convention is used, this means <code>mean_K_and_R(f, i)</code> will first push <code>i</code> to the stack, then the higher bits of <code>f</code> and then the lower bits of <code>f</code>.</p>

<p>But the function thinks it took two integer arguments, meaning <code>num1</code> will now refer to the lower bits of <code>f</code> and <code>num2</code> to the higher bits of <code>f</code>.</p>
",3
577207,577081,2,"<p>My guess is that in the first case, there wan an implicit conversion of <code>double</code> to <code>int</code>. In a second one, 64 bits representing 1.0 were interpreted as two integers. Number 1072693248 is represented binnary as </p>

<pre><code>00111111111100000000000000000000 
</code></pre>

<p>but if you take a look at <a href=""http://steve.hollasch.net/cgindex/coding/ieeefloat.html"" rel=""nofollow noreferrer"">this page</a>, you'll see that this is actually an upper half of double representation of number 1. The first 0 is sign, 01111111111 is exponent and rest of zeros are an upper bits of fraction. Only thing I don't get is where the 1 for fraction went? Having said all this I would expect the output to be 1,1072693248.</p>
",1
577099,577081,2,"<p>I did some digging and found a <a href=""http://bytes.com/groups/c/215340-k-r-style-function-declarations-good-bad"" rel=""nofollow noreferrer"">thread</a> indicating that K&amp;R style function declarations don't create a prototype, so without a separate prototype the compiler is free to treat the arguments incorrectly if it desires.</p>

<p>I'm not sure how true this is, you could probably verify it by inserting a prototype quickly and seeing if the functions generate the same values.</p>

<p>In any case K&amp;R style declarations are very outdated, as I'm sure you know, and should probably be avoided.  If anything your problem is an example of that.</p>
",0
328221,328215,2,"<p>I get warnings, but no errors (gcc).  Seems to compile and operate fine.  <strong>May not work for big-endian systems, though!</strong></p>

<p>I wouldn't suggest this method, though.  Perhaps you can xor instead of or-shift, to create a single byte.  Then use the case statement on a byte (or, faster, use a LUT of the first N bits).</p>
",5
328222,328215,4,"<p>There are at least 3 things that keep this program from being portable:</p>

<ol>
<li>Multi-character constants are implementation-defined so different compilers may handle them differently.</li>
<li>A byte can be more than 8 bits, there is plenty of hardware where the smallest addressable unit of memory is 16 or even 32 bits, you often find this in DSPs for example. If a byte is more than 8 bits then so will <code>char</code> since <code>char</code> is by definition one byte long; your program will not function properly on such systems.</li>
<li>Lastly, there are many machines where <code>int</code> is only 16-bits (which is the smallest size allowed for int) including embedded devices and legacy machines, your program will fail on these machines as well.</li>
</ol>
",8
328228,328215,10,"<p>I only know what the C Standard says about this (C99):</p>

<blockquote>
  <p>The value of an integer character
  constant containing more than one
  character (e.g., 'ab'), or containing
  a character or escape sequence that
  does not map to a single-byte
  execution character, is
  implementation-de?ned. If an integer
  character constant contains a single
  character or escape sequence, its
  value is the one that results when an
  object with type char whose value is
  that of the single character or escape
  sequence is converted to type int.</p>
</blockquote>

<p>(6.4.4.4/10 taken from a draft)</p>

<p>So it's implementation defined. Meaning it is not guaranteed it works the same everywhere, but the behavior must be documented by the implementation. For example if <code>int</code> is only 16 bits wide in a particular implementation, then <code>'Jan/'</code> can't be represented anymore like you intend it (<code>char</code> must be at least 8 bits, while a character literal is always of type <code>int</code>).</p>
",7
328236,328215,1,"<p>The fact that a four character constant is equivalent to an particular 32-bit integer is a <strong>non-standard</strong> feature often seen on compilers for MS Windows and Mac computers (and PalmOS, AFAICR).</p>

<p>On theses systems a four character string is commonly used as a tag for identifying chunks of data files, or as an application / data-type identifier (e.g. ""APPL"").</p>

<p>It's a convenience then for the developer that they can store such a string into various data-structures without worrying about zero-byte termination, pointers, etc.</p>
",0
328237,328215,0,"<p>Machine word size issues aside, your compiler may promote input[i] to a negative integer which will just set the upper bits of inputInt with or operation, so I suggest you to be explicit about signedness of char variables.</p>

<p>But since in US, no one cares about the 8th bit, it is probably a non-issue for you.</p>
",1
328240,328215,13,"<pre><code>if ( !input[0] || !input[1] || !input[2] || input[3] != '/' )
    return -1;

switch ( input[0] )
{
    case 'F': return 1; // Feb
    case 'S': return 8; // Sep
    case 'O': return 9; // Oct
    case 'N': return 10; // Nov
    case 'D': return 11; // Dec;
    case 'A': return input[1] == 'p' ? 3 : 7; // Apr, Aug
    case 'M': return input[2] == 'r' ? 2 : 4; // Mar, May
    default: return input[1] == 'a' ? 0 : (input[2] == 'n' ? 5 : 6); // Jan, Jun, Jul
}
</code></pre>

<p>Slightly less readable and not so much validating, but perhaps even faster, no?</p>
",7
328261,328215,11,"<p>You're just computing a hash of those four characters.  Why not predefine some integer constants that compute the hash in the same way and use those?  Same readability and you're not depending on any implementation specific idiosyncrasies of the compiler.</p>

<pre><code>uint32_t MONTH_JAN = 'J' &lt;&lt; 24 + 'a' &lt;&lt; 16 + 'n' &lt;&lt; 8 + '/';
uint32_t MONTH_FEB = 'F' &lt;&lt; 24 + 'e' &lt;&lt; 16 + 'b' &lt;&lt; 8 + '/';

...

static uint32_t parseMonth(const char *input) {
    uint32_t rv=-1;
    uint32_t inputInt=0;
    int i=0;

    for(i=0; i&lt;4 &amp;&amp; input[i]; i++) {
        inputInt = (inputInt &lt;&lt; 8) | (input[i] &amp; 0x7f); // clear top bit
    }

    switch(inputInt) {
        case MONTH_JAN: rv=0; break;
        case MONTH_FEB: rv=1; break;

        ...
    }

    return rv;
}
</code></pre>
",2
328298,328215,23,"<p>Solaris 10 - SPARC - SUN Compiler.</p>

<p>Test code:</p>

<pre><code>#include &lt;stdio.h&gt;

static int parseMonth(const char *input) {
    int rv=-1;
    int inputInt=0;
    int i=0;

    for(i=0; i&lt;4 &amp;&amp; input[i]; i++) {
        inputInt = (inputInt &lt;&lt; 8) | input[i];
    }

    switch(inputInt) {
        case 'Jan/': rv=0; break;
        case 'Feb/': rv=1; break;
        case 'Mar/': rv=2; break;
        case 'Apr/': rv=3; break;
        case 'May/': rv=4; break;
        case 'Jun/': rv=5; break;
        case 'Jul/': rv=6; break;
        case 'Aug/': rv=7; break;
        case 'Sep/': rv=8; break;
        case 'Oct/': rv=9; break;
        case 'Nov/': rv=10; break;
        case 'Dec/': rv=11; break;
    }

    return rv;
}

static const struct
{
    char *data;
    int   result;
} test_case[] =
{
    { ""Jan/"", 0 },
    { ""Feb/"", 1 },
    { ""Mar/"", 2 },
    { ""Apr/"", 3 },
    { ""May/"", 4 },
    { ""Jun/"", 5 },
    { ""Jul/"", 6 },
    { ""Aug/"", 7 },
    { ""Sep/"", 8 },
    { ""Oct/"", 9 },
    { ""Nov/"", 10 },
    { ""Dec/"", 11 },
    { ""aJ/n"", -1 },
};

#define DIM(x) (sizeof(x)/sizeof(*(x)))

int main(void)
{
    size_t i;
    int    result;

    for (i = 0; i &lt; DIM(test_case); i++)
    {
        result = parseMonth(test_case[i].data);
        if (result != test_case[i].result)
            printf(""!! FAIL !! %s (got %d, wanted %d)\n"",
                   test_case[i].data, result, test_case[i].result);
    }
    return(0);
}
</code></pre>

<p>Results (GCC 3.4.2 and Sun):</p>

<pre><code>$ gcc -O xx.c -o xx
xx.c:14:14: warning: multi-character character constant
xx.c:15:14: warning: multi-character character constant
xx.c:16:14: warning: multi-character character constant
xx.c:17:14: warning: multi-character character constant
xx.c:18:14: warning: multi-character character constant
xx.c:19:14: warning: multi-character character constant
xx.c:20:14: warning: multi-character character constant
xx.c:21:14: warning: multi-character character constant
xx.c:22:14: warning: multi-character character constant
xx.c:23:14: warning: multi-character character constant
xx.c:24:14: warning: multi-character character constant
xx.c:25:14: warning: multi-character character constant
$ ./xx
$ cc -o xx xx.c
$ ./xx
!! FAIL !! Jan/ (got -1, wanted 0)
!! FAIL !! Feb/ (got -1, wanted 1)
!! FAIL !! Mar/ (got -1, wanted 2)
!! FAIL !! Apr/ (got -1, wanted 3)
!! FAIL !! May/ (got -1, wanted 4)
!! FAIL !! Jun/ (got -1, wanted 5)
!! FAIL !! Jul/ (got -1, wanted 6)
!! FAIL !! Aug/ (got -1, wanted 7)
!! FAIL !! Sep/ (got -1, wanted 8)
!! FAIL !! Oct/ (got -1, wanted 9)
!! FAIL !! Nov/ (got -1, wanted 10)
!! FAIL !! Dec/ (got -1, wanted 11)
$
</code></pre>

<p>Note that the last test case still passed - that is, it generated a -1.</p>

<p>Here's a revised - more verbose - version of parseMonth() which does work the same under both GCC and Sun C compiler:</p>

<pre><code>#include &lt;stdio.h&gt;

/* MONTH_CODE(""Jan/"") does not reduce to an integer constant */
#define MONTH_CODE(x)   ((((((x[0]&lt;&lt;8)|x[1])&lt;&lt;8)|x[2])&lt;&lt;8)|x[3])

#define MONTH_JAN       (((((('J'&lt;&lt;8)|'a')&lt;&lt;8)|'n')&lt;&lt;8)|'/')
#define MONTH_FEB       (((((('F'&lt;&lt;8)|'e')&lt;&lt;8)|'b')&lt;&lt;8)|'/')
#define MONTH_MAR       (((((('M'&lt;&lt;8)|'a')&lt;&lt;8)|'r')&lt;&lt;8)|'/')
#define MONTH_APR       (((((('A'&lt;&lt;8)|'p')&lt;&lt;8)|'r')&lt;&lt;8)|'/')
#define MONTH_MAY       (((((('M'&lt;&lt;8)|'a')&lt;&lt;8)|'y')&lt;&lt;8)|'/')
#define MONTH_JUN       (((((('J'&lt;&lt;8)|'u')&lt;&lt;8)|'n')&lt;&lt;8)|'/')
#define MONTH_JUL       (((((('J'&lt;&lt;8)|'u')&lt;&lt;8)|'l')&lt;&lt;8)|'/')
#define MONTH_AUG       (((((('A'&lt;&lt;8)|'u')&lt;&lt;8)|'g')&lt;&lt;8)|'/')
#define MONTH_SEP       (((((('S'&lt;&lt;8)|'e')&lt;&lt;8)|'p')&lt;&lt;8)|'/')
#define MONTH_OCT       (((((('O'&lt;&lt;8)|'c')&lt;&lt;8)|'t')&lt;&lt;8)|'/')
#define MONTH_NOV       (((((('N'&lt;&lt;8)|'o')&lt;&lt;8)|'v')&lt;&lt;8)|'/')
#define MONTH_DEC       (((((('D'&lt;&lt;8)|'e')&lt;&lt;8)|'c')&lt;&lt;8)|'/')

static int parseMonth(const char *input) {
    int rv=-1;
    int inputInt=0;
    int i=0;

    for(i=0; i&lt;4 &amp;&amp; input[i]; i++) {
        inputInt = (inputInt &lt;&lt; 8) | input[i];
    }

    switch(inputInt) {
        case MONTH_JAN: rv=0; break;
        case MONTH_FEB: rv=1; break;
        case MONTH_MAR: rv=2; break;
        case MONTH_APR: rv=3; break;
        case MONTH_MAY: rv=4; break;
        case MONTH_JUN: rv=5; break;
        case MONTH_JUL: rv=6; break;
        case MONTH_AUG: rv=7; break;
        case MONTH_SEP: rv=8; break;
        case MONTH_OCT: rv=9; break;
        case MONTH_NOV: rv=10; break;
        case MONTH_DEC: rv=11; break;
    }

    return rv;
}

static const struct
{
    char *data;
    int   result;
} test_case[] =
{
    { ""Jan/"", 0 },
    { ""Feb/"", 1 },
    { ""Mar/"", 2 },
    { ""Apr/"", 3 },
    { ""May/"", 4 },
    { ""Jun/"", 5 },
    { ""Jul/"", 6 },
    { ""Aug/"", 7 },
    { ""Sep/"", 8 },
    { ""Oct/"", 9 },
    { ""Nov/"", 10 },
    { ""Dec/"", 11 },
    { ""aJ/n"", -1 },
    { ""/naJ"", -1 },
};

#define DIM(x) (sizeof(x)/sizeof(*(x)))

int main(void)
{
    size_t i;
    int    result;

    for (i = 0; i &lt; DIM(test_case); i++)
    {
        result = parseMonth(test_case[i].data);
        if (result != test_case[i].result)
            printf(""!! FAIL !! %s (got %d, wanted %d)\n"",
                   test_case[i].data, result, test_case[i].result);
    }
    return(0);
}
</code></pre>

<p>I wanted to use MONTH_CODE() but the compilers did not cooperate.</p>
",10
328312,328215,0,"<p>I'd sure love to see the profiling that shows <em>this</em> is your most significant bottleneck, but in any case if you're going to pull something like this, use a union instead of 50 instructions looping and shifting.  Here's a little example program, I'll leave it to you to fit it into your program.</p>

<pre><code>/* union -- demonstrate union for characters */

#include &lt;stdio.h&gt;

union c4_i {
    char c4[5];
    int  i ;
} ;

union c4_i ex;

int main (){
    ex.c4[0] = 'a';
    ex.c4[1] = 'b';
    ex.c4[2] = 'c';
    ex.c4[3] = 'd';
    ex.c4[4] = '\0';
    printf(""%s 0x%08x\n"", ex.c4, ex.i );
    return 0;
}
</code></pre>

<p>Here's example output:</p>

<pre><code>bash $ ./union
abcd 0x64636261
bash $ 
</code></pre>
",2
328331,328215,6,"<pre><code>char *months = ""Jan/Feb/Mar/Apr/May/Jun/Jul/Aug/Sep/Oct/Nov/Dec/"";
char *p = strnstr(months, input, 4);
return p ? (p - months) / 4 : -1;
</code></pre>
",7
328724,328215,1,"<p><a href=""http://www.comeaucomputing.com/tryitout/"" rel=""nofollow noreferrer"">Comeau compiler</a></p>

<pre><code>Comeau C/C++ 4.3.10.1 (Oct  6 2008 11:28:09) for ONLINE_EVALUATION_BETA2
Copyright 1988-2008 Comeau Computing.  All rights reserved.
MODE:strict errors C99 

""ComeauTest.c"", line 11: warning: multicharacter character literal (potential
          portability problem)
          case 'Jan/': rv=0; break;
               ^

""ComeauTest.c"", line 12: warning: multicharacter character literal (potential
          portability problem)
          case 'Feb/': rv=1; break;
               ^

""ComeauTest.c"", line 13: warning: multicharacter character literal (potential
          portability problem)
          case 'Mar/': rv=2; break;
               ^

""ComeauTest.c"", line 14: warning: multicharacter character literal (potential
          portability problem)
          case 'Apr/': rv=3; break;
               ^

""ComeauTest.c"", line 15: warning: multicharacter character literal (potential
          portability problem)
          case 'May/': rv=4; break;
               ^

""ComeauTest.c"", line 16: warning: multicharacter character literal (potential
          portability problem)
          case 'Jun/': rv=5; break;
               ^

""ComeauTest.c"", line 17: warning: multicharacter character literal (potential
          portability problem)
          case 'Jul/': rv=6; break;
               ^

""ComeauTest.c"", line 18: warning: multicharacter character literal (potential
          portability problem)
          case 'Aug/': rv=7; break;
               ^

""ComeauTest.c"", line 19: warning: multicharacter character literal (potential
          portability problem)
          case 'Sep/': rv=8; break;
               ^

""ComeauTest.c"", line 20: warning: multicharacter character literal (potential
          portability problem)
          case 'Oct/': rv=9; break;
               ^

""ComeauTest.c"", line 21: warning: multicharacter character literal (potential
          portability problem)
          case 'Nov/': rv=10; break;
               ^

""ComeauTest.c"", line 22: warning: multicharacter character literal (potential
          portability problem)
          case 'Dec/': rv=11; break;
               ^

""ComeauTest.c"", line 1: warning: function ""parseMonth"" was declared but never
          referenced
  static int parseMonth(const char *input) {
             ^
</code></pre>
",1
329172,328215,0,"<p>As mentioned by others, that code throws a bunch of warnings and is probably not endian-safe.</p>

<p>Was your original date parser hand-written as well?  Have you tried strptime(3)?</p>
",0
332873,328215,4,"<p><a href=""http://www.ni.com/lwcvi/"" rel=""nofollow noreferrer"">National Instrument's CVI 8.5 for Windows</a> compiler fails on your original code with multiple warnings:</p>

<pre><code>  Warning: Excess characters in multibyte character literal ignored.
</code></pre>

<p>and errors of the form:</p>

<pre><code>  Duplicate case label '77'.
</code></pre>

<p>It succeeds on Jonathan's code.</p>
",0
922430,807013,0,"<p>Maybe you can use system() do run utilities like <strong>expect</strong> to control the process</p>
",0
922877,807013,1,"<p>This is certainly possible with, for instance <a href=""http://expect.nist.gov/"" rel=""nofollow noreferrer"">libexpect</a> but I never tried it (but Google found what seems to be a <a href=""http://www.developerweb.net/forum/showthread.php?t=3816"" rel=""nofollow noreferrer"">good example</a>). On my Debian machine, <code>man libexpect</code> says:</p>

<pre><code>    libexpect - programmed dialogue library with interactive programs

    This  library  contains functions that allow Expect to be used as a Tcl
    extension or to be used directly from C or C++ (without  Tcl).
</code></pre>
",0
807133,807013,-1,"<p>fortunately, There is nothing you can do. :)</p>
",1
810112,807013,0,"<p>Depending on your operating system (windows can do it for instance) you can have the stdin for the programmed redirected to come from an output of your program.</p>
",0
581268,388602,2,"<p>In addition to Swill, I would look at <a href=""http://www.gnu.org/software/libmicrohttpd/"" rel=""nofollow noreferrer"">GNU libmicrohttpd</a> and <a href=""http://www.hughes.com.au/products/libhttpd/"" rel=""nofollow noreferrer"">Hughes libhttpd</a>.
Both are intended to embed web servers in programs. I was nearly deciding on <a href=""http://www.hughes.com.au/products/libhttpd/"" rel=""nofollow noreferrer"">Hughes</a> for a web frontend of sorts for <a href=""http://www.oracle.com/technology/products/berkeley-db/index.html"" rel=""nofollow noreferrer"">Berkeley DB</a> but may go the Python route instead.</p>
",0
581294,388602,-1,"<p>Why not convert your legacy C code into a php / apache plugin? Then you've got the best of both worlds, modern web based language / server but utilising all the existing code in your legacy application.</p>
",2
388768,388602,0,"<p>Unless you have a very specific requirement to use C, you should probably rethink your language choice. Even with a framework (which as you've noticed, are hard to come by these days), a webapp in C is likely to be very error-prone, especially to buffer overlows related to untrusted user input.</p>

<p>If you have some SDK or legacy code in C that you need to access, and no alternative but to use it, you can still get at this in various ways from another language. </p>

<p>For example in Java there is JNI. And you can always wrap the SDK in a CLI program that does what you need, and run it from your webapp (which can then be written in any language). The same caveats about buffer overflows etc will apply, but at least you can program defensively in the CLI program (i.e. don't trust your arguments and sanitize them before using).</p>

<p>Another alternative may be to use IPC to a process which provides access to the 'C' SDK or legacy code functions. Same arguments about defensive programming apply.</p>
",0
388644,388602,0,"<p>I am not sure of a library, but if you could visit this site
<a href=""http://www.vijaymukhi.com/"" rel=""nofollow noreferrer"">vijaymukhi.com</a>  you could find some learning projects developed using C.</p>

<p>You can specifically check the ""Air Ticket Reservation"" and ""Ecommerce Modules"".</p>

<p>NOTE:  This is only a learning projects with c and cgi.</p>

<p>Please check the ""Projects(with source)"" section on the treemenu.</p>

<p>P.S:  I don't recommend this for production/live sites.</p>
",0
388787,388602,5,"<p>As others have noted C is not the best language for developing a web application.  However, if the application's core is already written in C, AND you are ok with only a single user accessing the application at the time, AND you can trust that user (for instance, because the application will only be made available behind a firewall), then the <a href=""http://sourceforge.net/projects/swill/"" rel=""nofollow noreferrer"">swill library</a> is an interesting choice.  It is an embedded web server, which with a handful of lines can provide a web interface to any C application.  I've used it twice, for the <a href=""http://www.spinellis.gr/cscout"" rel=""nofollow noreferrer"">CScout refactoring browser</a> and for providing a user interface to legacy production line optimization code, and it worked like a charm.</p>
",0
388847,388602,0,"<p>It is hard to think of any situation where C is the best language to develop a web app. Just as you wouldn't want to write a GUI app in FORTRAN or a device driver in COBOL. </p>

<p>Why not try PHP? The syntax is fairly similar to C.</p>
",3
388853,388602,0,"<p>Well, years ago I wrote a ""CSP"" compiler, a very basic equivalent to JSP, but in C. It generated CGI C code. I guess you could use THAT as a base or for simple experimentation. I never did anything with it so you can have it if you want (and if I can find it)... just drop me a line.</p>
",0
388871,388602,4,"<p>clearsilver should do the  job fine
<a href=""http://www.clearsilver.net/docs/"" rel=""nofollow noreferrer"">http://www.clearsilver.net/docs/</a></p>

<p>and if you need some GC stuff you always can use the boehm weisser gc. </p>

<p>Regards
Friedrich</p>
",1
650638,388602,1,"<p>I haven't tried it, maybe someone would find it usefull: <a href=""http://www.koanlogic.com/klone/"" rel=""nofollow noreferrer"">klone</a>.
It is a framework for building standalone web serververs and html templating with
embedded C. </p>
",0
710521,388602,2,"<p>You could try <a href=""http://www.monkey.org/~provos/libevent/"" rel=""nofollow noreferrer"">libevent</a>. It has a <a href=""http://www.monkey.org/~provos/libevent/doxygen-1.4.9/evhttp_8h.html"" rel=""nofollow noreferrer"">HTTP server</a>.</p>
",2
703112,388602,5,"<p>I've used <a href=""http://www.gnu.org/software/libmicrohttpd/"" rel=""nofollow noreferrer"">GNU libmicrohttpd</a> and it is excellent: clear API; lightweight; open source and still actively developed; and it embedded nicely into our existing C application. Importantly, it is licensed under the LGPL, but <a href=""http://www.hughes.com.au/products/libhttpd/"" rel=""nofollow noreferrer"">Hughes libhttpd</a> has a dual license, which may be an issue for commercial projects. (Credit to Jakob Eriksson's answer for getting there first.)</p>

<p>Edit: Also mentioned <a href=""https://stackoverflow.com/questions/298113/how-can-i-implement-a-restful-webservice-using-c/604745#604745"">here</a>.</p>
",0
1624494,1624480,2,"<p>You could fix the terminal window to not go away.</p>
",2
1624503,1624480,1,"<p><code>getchar()</code> is standard but due to line buffering you will still need to press <code>Enter</code> before <code>getchar</code> returns.</p>
",0
1624507,1624480,0,"<p>Are you using Turbo C compiler? <code>getch()</code> is widely used there.</p>

<p>OTOH if you want the program to wait, run the binary inside the shell/terminal/prompt. Navigate to that directory and invoke</p>

<p><strong>Windows:</strong></p>

<pre><code>C:&gt; executable.exe
</code></pre>

<p><strong>Linux:</strong></p>

<pre><code>~$ ./exec
</code></pre>

<p>You can use <code>getchar()</code>, the only problem being that it is buffered. <code>getch()</code> isnt buffered. You can make <code>getchar()</code> also to be non-buffered, but the code for that is not worth it. I tried it once, but due to it's sheer complexity never bothered to try it again.</p>
",0
1624508,1624480,1,"<p>I prefer running program from command line.</p>
",2
1624521,1624480,8,"<p><code>getc(stdin);</code> 
is portable in this sense</p>
",3
1624538,1624480,0,"<p>In addition to other answers, you can also use this in windows, especially if your intention is to wait for key press to finish the program:</p>

<pre><code>system(""pause"");
</code></pre>
",2
1624562,1624480,1,"<p>I think using getch() is the most common by far is keeping a console window from closing , but in C++ most experienced programmers will recommend that you use cin.get</p>

<pre><code> std::cin.get();
</code></pre>

<p>instead of:</p>

<pre><code>getch();
</code></pre>
",0
1624910,1624480,0,"<p>Just trying to answer something different, you can use </p>

<p><code>while(1) 
    sleep(10);</code> </p>

<p>at the end of main function (before <code>return 0;</code>) and then you can press ctrl-c to terminate the program. I think you should not face portability issue and I hope this is not bad programming practice either :)</p>
",1
1625045,1624480,4,"<p>Using a non-standard I/O function isn't bad practice <em>per se</em>; it becomes an issue if you intend to port this code to a different platform that doesn't support <code>getch()</code>.  </p>

<p>The problem is, there are <em>no</em> standard library functions that detect individual keystrokes (<code>getchar()</code> and <code>fgetc()</code> are buffered and require you to hit Enter before they return); you're going to have to use something non-standard to do that.  If you only intend for this code to run on this specific platform, use <code>getch()</code> if that's what you need and just remember that this solution won't necessarily apply to other platforms.  If you intend to port this code to platforms that don't support <code>getch()</code>, isolate the system-specific call behind a wrapper function so that when you port the code, only the code inside the wrapper function needs to change.  </p>

<pre><code>int getKeystroke(void)
{
  /**
   * Put platform-specific call here
   */
  return getch();
}

int main(void)
{
  ... // do stuff here
  getKeystroke();
  return 0;
}
</code></pre>
",0
1208266,1015533,2,"<p>You have forgotten to initialize your variables,</p>
",3
1015547,1015533,2,"<p>You haven't said what the program is supposed to do, or what your problem is.  That makes it hard to offer help.</p>

<p>At a guess, you really ought to initialize start and sum to zero, and perhaps the printf should be outside the loop.</p>
",1
1015549,1015533,6,"<p>You would be much better served by a for loop, and combining your conditionals.</p>

<p>Not tested:</p>

<pre><code>int main()
{
  int x;
  int sum = 0;

  for (x = 1; x &lt;= 1000; x++)
    if (x % 3 == 0 || x % 5 == 0)
      sum += x;

  printf(""%d\n"", sum);
  return 0;
}
</code></pre>
",3
1015550,1015533,17,"<p>You could change your ifs:</p>

<pre><code> if  ((start % 3 == 0) || (start % 5 == 0)) 
     sum += start;
 start ++;
</code></pre>

<p>and don¡ät forget to initialize your sum with zero and start with one. 
 Also, change the while condition to &lt; 1000.</p>
",1
1015591,1015533,3,"<p>Eh right, well i can see roughly where you are going, I'm thinking the only thing wrong with it has been previously mentioned. I did this problem before on there, obviously you need to step through every multiple of 3 and 5 and sum them. I did it this way and it does work:</p>

<pre><code>int accumulator = 0;
int i;

for (i = 0; i &lt; 1000; i += 3)
    accumulator += i;

for (i = 0; i &lt; 1000; i +=5) {
    if (!(i%3==0)) {
        accumulator += i;
    }
}
printf(""%d"", accumulator);
</code></pre>

<p>EDIT: Also note its not 0 to 1000 inclusive, &lt; 1000 stops at 999 since it is the last number below 1000, you have countered that by &lt; 1001 which means you go all the way to 1000 which is a multiple of 5 meaning your answer will be 1000 higher than it should be.</p>
",0
1016035,1015533,2,"<p>Really you need a debugger, and to single-step through the code so that you can see what it's actually doing. Your basic problem is that the flow of control isn't going where you think it is, and rather than provide correct code as others have done, I'll try to explain what your code does. Here's what happens, step-by-step (I've numbered the lines):</p>

<pre><code>1:    while (start &lt; 1001) {
2:        if  (start % 3 == 0) {
3:            sum = sum + start;
4:            start += 1;
5:        }
6:        else {
7:            start += 1;
8:        }
9:
10:       if (start % 5 == 0) {
11:           sum = sum + start;
12:           start += 1;
13:       }
14:       else {
15:           start += 1;
16:       }
17:       printf(""%d\n"", sum);
18:    }
</code></pre>

<ul>
<li>line 1. sum is 0, start is 0. Loop condition true.</li>
<li>line 2. sum is 0, start is 0. If condition true.</li>
<li>line 3. sum is 0, start is 0. sum &lt;- 0.</li>
<li>line 4. sum is 0, start is 0. start &lt;- 1.</li>
<li>line 5. sum is 0, start is 1. jump over ""else"" clause</li>
<li>line 10. sum is 0, start is 1. If condition false, jump into ""else"" clause.</li>
<li>line 15. sum is 0, start is 1. start &lt;- 2.</li>
<li>line 16 (skipped)</li>
<li>line 17. sum is 0, start is 2. Print ""0\n"".</li>
<li>line 18. sum is 0, start is 2. Jump to the top of the loop.</li>
<li>line 1. sum is 0, start is 2. Loop condition true.</li>
<li>line 2. sum is 0, start is 2. If condtion false, jump into ""else"" clause.</li>
<li>line 7. sum is 0, start is 2. start &lt;- 3.</li>
<li>line 10. sum is 0, start is 3. If condition false, jump into ""else"" clause.</li>
<li>line 15. sum is 0, start is 3. start &lt;- 4.</li>
<li>line 17. sum is 0, start is 4. Print ""0\n"".</li>
</ul>

<p>You see how this is going? You seem to think that at line 4, after doing <code>sum += 1</code>, control goes back to the top of the loop. It doesn't, it goes to the next thing after the ""if/else"" construct.</p>
",2
1016181,1015533,50,"<p>You've gotten some great answers so far, mainly suggesting something like:</p>
<pre><code>#include &lt;stdio.h&gt;
int main(int argc, char * argv[])
{
  int i;
  int soln = 0;
  for (i = 1; i &lt; 1000; i++)
  {
    if ((i % 3 == 0) || (i % 5 == 0))
    {
      soln += i;
    }
  }
  printf(&quot;%d\n&quot;, soln);
  return 0;
}
</code></pre>
<p>So I'm going to take a different tack.  I know you're doing this to learn C, so this may be a bit of a tangent.</p>
<p>Really, you're making the computer work too hard for this :).  If we figured some things out ahead of time, it could make the task easier.</p>
<p>Well, how many multiples of 3 are less than 1000? There's one for each time that 3 goes into 1000 - 1.</p>
<blockquote>
<p>mult<sub>3</sub> = ? (1000 - 1) / 3 ? = 333</p>
</blockquote>
<p>(the ? and ? mean that this is <em>floor</em> division, or, in programming terms, <em>integer</em> division, where the remainder is dropped).</p>
<p>And how many multiples of 5 are less than 1000?</p>
<blockquote>
<p>mult<sub>5</sub> = ? (1000 - 1) / 5 ? = 199</p>
</blockquote>
<p>Now what is the sum of all the multiples of 3 less than 1000?</p>
<blockquote>
<p>sum<sub>3</sub> = 3 + 6 + 9 + ... + 996 + 999 = 3¡Á(1 + 2 + 3 + ... + 332 + 333) = 3¡Á¡Æ<sub>i=1 to mult<sub>3</sub></sub> i</p>
</blockquote>
<p>And the sum of all the multiples of 5 less than 1000?</p>
<blockquote>
<p>sum<sub>5</sub> = 5 + 10 + 15 + ... + 990 + 995 = 5¡Á(1 + 2 + 3 + ... + 198 + 199) = 5¡Á¡Æ<sub>i = 1 to mult<sub>5</sub></sub> i</p>
</blockquote>
<p>Some multiples of 3 are also multiples of 5.  Those are the multiples of 15.
Since those count towards mult<sub>3</sub> and mult<sub>5</sub> (and therefore sum<sub>3</sub> and sum<sub>5</sub>) we need to know mult<sub>15</sub> and sum<sub>15</sub> to avoid counting them twice.</p>
<blockquote>
<p>mult<sub>15</sub> = ? (1000 - 1) /15 ? = 66</p>
<p>sum<sub>15</sub> = 15 + 30 + 45 + ... + 975 + 990 = 15¡Á(1 + 2 + 3 + ... + 65 + 66) = 15¡Á¡Æ<sub>i = 1 to mult<sub>15</sub></sub> i</p>
</blockquote>
<p>So the solution to the problem &quot;<a href=""http://projecteuler.net/index.php?section=problems&amp;id=1"" rel=""noreferrer"">find the sum of all the multiples of 3 or 5 below 1000</a>&quot; is then</p>
<blockquote>
<p>soln = sum<sub>3</sub> + sum<sub>5</sub> - sum<sub>15</sub></p>
</blockquote>
<p>So, if we wanted to, we could implement this directly:</p>
<pre><code>#include &lt;stdio.h&gt;
int main(int argc, char * argv[])
{
  int i;
  int const mult3 = (1000 - 1) / 3;
  int const mult5 = (1000 - 1) / 5;
  int const mult15 = (1000 - 1) / 15;
  int sum3 = 0;
  int sum5 = 0;
  int sum15 = 0;
  int soln;

  for (i = 1; i &lt;= mult3; i++) { sum3 += 3*i; }
  for (i = 1; i &lt;= mult5; i++) { sum5 += 5*i; }
  for (i = 1; i &lt;= mult15; i++) { sum15 += 15*i; }

  soln = sum3 + sum5 - sum15;
  printf(&quot;%d\n&quot;, soln);
  return 0;
}
</code></pre>
<p>But we can do better.  For calculating individual sums, we have <a href=""http://mathforum.org/library/drmath/view/57919.html"" rel=""noreferrer"">Gauss's identity</a> which says the sum from 1 to n (aka ¡Æ<sub>i = 1 to n</sub> i) is n¡Á(n+1)/2, so:</p>
<blockquote>
<p>sum<sub>3</sub> = 3¡Ámult<sub>3</sub>¡Á(mult<sub>3</sub>+1) / 2</p>
<p>sum<sub>5</sub> = 5¡Ámult<sub>5</sub>¡Á(mult<sub>5</sub>+1) / 2</p>
<p>sum<sub>15</sub> = 15¡Ámult<sub>15</sub>¡Á(mult<sub>15</sub>+1) / 2</p>
</blockquote>
<p>(Note that we can use normal division or integer division here - it doesn't matter since one of n or n+1 must be divisible by 2)</p>
<p>Now this is kind of neat, since it means we can find the solution without using a loop:</p>
<pre><code>#include &lt;stdio.h&gt;
int main(int argc, char *argv[])
{
  int const mult3 = (1000 - 1) / 3;
  int const mult5 = (1000 - 1) / 5;
  int const mult15 = (1000 - 1) / 15;
  int const sum3 = (3 * mult3 * (mult3 + 1)) / 2;
  int const sum5 = (5 * mult5 * (mult5 + 1)) / 2;
  int const sum15 = (15 * mult15 * (mult15 + 1)) / 2;

  int const soln = sum3 + sum5 - sum15;
  printf(&quot;%d\n&quot;, soln);
  return 0;
}
</code></pre>
<p>Of course, since we've gone this far we could crank out the entire thing by hand:</p>
<blockquote>
<p>sum<sub>3</sub> = 3¡Á333¡Á(333+1) / 2 = 999¡Á334 / 2 = 999¡Á117 = 117000 - 117 = 116883</p>
<p>sum<sub>5</sub> = 5¡Á199¡Á(199+1) / 2 = 995¡Á200 / 2 = 995¡Á100 = 99500</p>
<p>sum<sub>15</sub> = 15¡Á66¡Á(66+1) / 2 = 990¡Á67 / 2 = 495 ¡Á 67 = 33165</p>
<p>soln = 116883 + 99500 - 33165 = 233168</p>
</blockquote>
<p>And write a much simpler program:</p>
<pre><code>#include &lt;stdio.h&gt;
int main(int argc, char *argv[])
{
  printf(&quot;233168\n&quot;);
  return 0;
}
</code></pre>
",8
1017418,1015533,1,"<p>The problem with your code is that your incrementing the 'start' variable twice. This is due to having two if..else statements. What you need is an if..else if..else statement as so:</p>

<pre><code>           if  (start % 3 == 0) {
                    sum = sum + start;
                    start += 1;
            }
            else if (start % 5 == 0) {
                    sum = sum + start;
                    start += 1;
            }
            else {
                    start += 1;
            }
</code></pre>

<p>Or you could be more concise and write it as follows:</p>

<pre><code>if(start % 3 == 0)
    sum += start;
else if(start % 5 == 0)
    sum += start;
start++;
</code></pre>

<p>Either of those two ways should work for you.</p>

<p>Good luck!</p>
",0
1017454,1015533,3,"<p>The answers are all good, but won't help you learn C.</p>

<p>What you really need to understand is how to find your own errors. A debugger could help you, and the most powerful debugger in C is called ""printf"". You want to know what your program is doing, and your program is not a ""black box"".</p>

<p>Your program already prints the sum, it's probably wrong, and you want to know why. For example:</p>

<pre><code>printf(""sum:%d start:%d\n"", sum, start);
</code></pre>

<p>instead of</p>

<pre><code>printf(""%d\n"", sum);
</code></pre>

<p>and save it into a text file, then try to understand what's going wrong.</p>

<ul>
<li>does the count start with 1 and end with 999?</li>
<li>does it really go from 1 to 999 without skipping numbers?</li>
<li>does it work on a smaller range?</li>
</ul>
",0
1018864,1015533,0,"<p>Here's a general solution which works with an arbitrary number of factors:</p>

<pre><code>#include &lt;stdio.h&gt;

#define sum_multiples(BOUND, ...) \
    _sum_multiples(BOUND, (unsigned []){ __VA_ARGS__, 0 })

static inline unsigned sum_single(unsigned bound, unsigned base)
{
    unsigned n = bound / base;
    return base * (n * (n + 1)) / 2;
}

unsigned _sum_multiples(unsigned bound, unsigned bases[])
{
    unsigned sum = 0;

    for(unsigned i = 0; bases[i]; ++i)
    {
        sum += sum_single(bound, bases[i]);

        for(unsigned j = i + 1; bases[j]; ++j)
            sum -= sum_single(bound, bases[i] * bases[j]);
    }

    return sum;
}

int main(void)
{
    printf(""%u\n"", sum_multiples(999, 3, 5));
    return 0;
}
</code></pre>
",0
436492,436446,3,"<p><a href=""http://www.cs.princeton.edu/software/cii/"" rel=""nofollow noreferrer"">C Interfaces and Implementations</a> by David Hanson explains a nice usable organization scheme in the first chapter (if I recall correctly) and shows it in use in the remaining ones developing substantial libraries.</p>
",0
436495,436446,2,"<p>the old ""<a href=""http://en.wikipedia.org/wiki/Structured_programming"" rel=""nofollow noreferrer"">structured programming</a>"" way of coding C programs is to modularise them into files. Instead of having code in objects, make sure you put all related code into individual files.</p>

<p>If you think of a file as a poor man's object, you'll be mostly there to organising your C apps like you do with your C# ones.</p>
",0
436499,436446,7,"<p>Here is an analogy that might help you:</p>

<p>A class is a data structure of some kind and a set of functions to access and manipulate that data. The <code>c</code> language doesn't provide any syntatic sugar to organize this relationship for you, but you can still build your code around this idea. So, just do it: design you project around a bunch of ""classes"".</p>

<p>Code organization generally takes on one of two forms:</p>

<ul>
<li>Each function gets one header (interface) file with a <code>.h</code> extension and one implementation  file with a <code>.c</code> extension</li>
<li>Each ""class"" (i.e. set of related functions) gets one header file and one implementation file.</li>
</ul>

<p>So, you already know how to do this...</p>
",0
437235,436446,2,"<p>Since have experience in C#, you may be interested in the responses to my SO question: ""<a href=""https://stackoverflow.com/questions/415452/object-orientation-in-c"" title=""Object-Orientation in C"">Object-Orientation in C</a>"". If they interest you, it may be useful to take a look at the responses to the related question: ""<a href=""https://stackoverflow.com/questions/351733/can-you-write-object-oriented-code-in-c"" title=""Can you write object oriented code in c?"">Can you write object oriented code in c?</a>"". If you plan to use a scheme like any of the ones mentioned in the responses to the aforementioned questions, please keep in mind that the most important thing is your design, <strong>not</strong> the syntactic sugar which may/may not make it look pretty.</p>
",0
1973368,1973365,2,"<p>There's nothing in standard C that could help you. You need to use some library or platform-dependent features. Don't forget that many platforms simply don't have threads - only full-weight processes.</p>

<p>On Windows use <a href=""http://msdn.microsoft.com/en-us/library/ms682453(VS.85).aspx"" rel=""nofollow noreferrer"">CreateThread()</a>. You'll need Microsoft SDK to compile your code using this and other Win32 functions.</p>
",3
1973370,1973365,2,"<p>C doesn't have built in threading facilities; you will have to use your OS services to create a thread.</p>

<p>For windows use <a href=""http://msdn.microsoft.com/en-us/library/ms682453%28VS.85%29.aspx"" rel=""nofollow noreferrer"">CreateThread</a> function.</p>
",0
1973378,1973365,19,"<p>You are going to need to use OS specific libraries to do threading.  On Posix, you will want to look into <a href=""https://computing.llnl.gov/tutorials/pthreads/"" rel=""noreferrer"">pthreads</a> (and specifically <a href=""http://linux.die.net/man/3/pthread_create"" rel=""noreferrer"">pthread_create</a>).  On Windows, you'll want <a href=""http://msdn.microsoft.com/en-us/library/ms682453%28VS.85%29.aspx"" rel=""noreferrer"">CreateThread</a> or _<a href=""http://msdn.microsoft.com/en-us/library/kdzttdcb.aspx"" rel=""noreferrer"">beginthreadex</a>.</p>
",1
1973382,1973365,4,"<p>Multithreading in C is platform dependent. You need to use external libraries corresponding to different platforms.</p>

<p>Read about:</p>

<p><a href=""http://softpixel.com/~cwright/programming/threads/threads.c.php"" rel=""nofollow noreferrer"">Multithreading in C, POSIX style </a> and <a href=""http://msdn.microsoft.com/en-us/library/y6h8hye8(VS.80).aspx"" rel=""nofollow noreferrer"">Multithreading with C and Win32 </a></p>
",0
1973388,1973365,2,"<p>You can check this link for different ways to do it:
<a href=""https://stackoverflow.com/questions/331536/windows-threading-beginthread-vs-beginthreadex-vs-createthread-c"">Windows threading: _beginthread vs _beginthreadex vs CreateThread C++</a></p>

<p>For cross-platform code, you can also check the <a href=""http://www.boost.org/doc/libs/1_37_0/doc/html/thread.html"" rel=""nofollow noreferrer"">Boost library</a> or <a href=""http://www.threadingbuildingblocks.org/"" rel=""nofollow noreferrer"">Intel Threading Building Blocks</a>. </p>
",0
1975886,1973365,1,"<p>Please refer to MSDN for VC8. Refer to the createThread() help there. That should give you sufficient information.</p>

<p>For checking online, please go the link below:</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/ms682453(VS.85).aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/ms682453(VS.85).aspx</a></p>
",0
1714255,1714245,220,"<p>If you use #ifdef syntax, remove the parenthesis.</p>
<p>The difference between the two is that <code>#ifdef</code> can only use a single condition,<br />
while <code>#if defined(NAME)</code> can do compound conditionals.</p>
<p>For example in your case:</p>
<pre><code>#if defined(WIN32) &amp;&amp; !defined(UNIX)
/* Do windows stuff */
#elif defined(UNIX) &amp;&amp; !defined(WIN32)
/* Do linux stuff */
#else
/* Error, both can't be defined or undefined same time */
#endif
</code></pre>
",3
1714299,1714245,33,"<p><code>#ifdef</code> checks whether a macro by that name has been defined, <code>#if</code> evaluates the expression and checks for a true value</p>

<pre><code>#define FOO 1
#define BAR 0

#ifdef FOO
#ifdef BAR
/* this will be compiled */
#endif
#endif

#if BAR
/* this won't */
#endif

#if FOO || BAR
/* this will */
#endif
</code></pre>
",3
1679146,1679117,3,"<p>Check out <a href=""http://log4c.sourceforge.net/index.html"" rel=""nofollow noreferrer"">log4c</a> for some ideas how to implement logging.</p>

<p>Here is some advice: Don't just print ""there was an error"". Give as much information as possible: Which IP address? Error-Code? What did your code try to achieve?</p>

<p>When you need to write an error message, ask yourself this question: What will I need to know when I see this error message? What will help me to <em>fix</em> the issue?</p>
",1
1679162,1679117,2,"<p>You can also do something like this:</p>

<pre><code>//Enum for the error codes
typedef enum
{
    SOCKET_ERR = 0,
    BIND_ERR,
    LISTEN_ERR,
    LAST_ENTRY //This SHOULD be the last entry
} ErrorCode;

//Error descriptions..number of entries should match the number of entries in Enum
const char* errorDesc[] =
{
    ""Socket failure"",
    ""Bind failure"",
    ""Listen failure"",
    ""Dummy""
};


void printError(ErrorCode c)
{
    //Validate..
    if( c &lt; LAST_ENTRY)
    {
        printf(errorDesc[c]);
    }
}
</code></pre>
",1
1679219,1679117,3,"<p>You might consider using <a href=""http://en.wikipedia.org/wiki/Variadic_function"" rel=""nofollow noreferrer"">variadic functions</a> for error reporting, they become so much more versatile.</p>

<p>For instance</p>

<pre><code>#include &lt;stdarg.h&gt;
void my_error(FILE *out, const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    vfprintf(out, fmt, ap);
    va_end(ap);
}
</code></pre>

<p>Which could be invoked like this (note, I'm assuming a c99 compiler):</p>

<pre><code>my_error(stderr,
    ""%s: Invalid range of %ld near line %d"", __func__, range, __LINE__);
</code></pre>

<p>This could easily tie in with other answers suggesting that error codes could be defined in enumerated lists, with a constant array of strings to translate them. I'll leave that as an exercise for the reader. Its very easy to make the example above accept more arguments.</p>

<p>NB: If you use something like char buffer[LEN] to custom format the printed string, change it from void to unsigned int, have it return the number of bytes that vsnprintf() could not print, that might be useful to the caller. The above example is 'safe', wherein you don't have to worry about over flowing some stack allocated buffer with a formatted error message of undefined length. Or, leave it as void and have it print what it can (while noting it could not print everything), up to you. The draw back to this approach is not quite knowing the length of the variadic arguments once expanded. After all, you're reporting unexpected results :)</p>

<p>This approach lets you help yourself more by conveying meaningful and informative error messages, as well as simply logging them to any open file.</p>

<p>I know that this example basically describes printf() itself. I'm posting it to show how easy it is to adapt and expand.</p>
",3
268065,267949,3,"<p>Do you really need the cast? gcc is compiling the following example without any complains:</p>

<pre><code>
typedef struct int64 int64;

struct int64
{
    unsigned int hi, lo;
};

typedef int64 mytime;

int64
add_int64(int64 a, int64 b)
{
    int64 c;
    /* I know that is wrong */
    c.hi = a.hi + b.hi;
    c.lo = a.lo + b.lo;

    return c;
}

int
main(void)
{
    mytime a = {1, 2};
    mytime b = {3, 4};
    mytime c;

    c = add_int64(a, b);

    return 0;
}
</code></pre>
",0
267965,267949,1,"<p>You could try:</p>

<pre><code>#define mytime int64
</code></pre>

<p>Instead of the typedef.</p>

<p>That looks like it will net you both the transparent conversion and the maintainability you're looking for.</p>
",0
267989,267949,1,"<p>Take a look at stdint.h header file. It contains int64_t, uint64_t, etc'. This is standard and portable way, and you will avoid the need to implement math functions :).</p>
",1
268309,267949,4,"<p>Because you're using typedef's, you don't need the casts at all. Typedef's in C do not create a distinct type, only an alias to another type. The compiler does not distinguish between them. Just write the mytime_add function as:</p>

<pre><code>#define mytime_add(x, y) int64_add((x), (y))
</code></pre>

<p>or if your C compiler is good enough to do inlining:</p>

<pre><code>mytime mytime_add(mytime x, mytime y) { return int64_add(x, y); }
</code></pre>
",1
271671,267949,0,"<p>Right, so I'm using typedefs and no casting. Works fine. Seems strange though that an explicit cast doesn't compile while an implicit one does. If the implicit cast really isn't a cast at all since the compiler sees the two types as being the same type, one would think the same reasoning would work when doing an explicit cast...</p>
",1
1899452,1899445,6,"<p>The <code>##</code> is a concatenation operator.  Using <code>RES_API(name1, func1)</code> in your code would be replaced with <code>name1_func1</code>.  More information <a href=""http://gcc.gnu.org/onlinedocs/gcc-3.2.3/cpp/Concatenation.html"" rel=""nofollow noreferrer"">here</a>.</p>
",0
1899454,1899445,1,"<p>Instead of doing <code>OBJ_DoSomething</code>, with this macro you can do <code>RES_API(OBJ, DoSomething)</code>.  Personally I think its silly.</p>
",1
1899458,1899445,4,"<p>The <code>##</code> operator concatenates two tokens. In your case, <code>name</code> is appended with an underscore, and that is appended with <code>func</code>.</p>

<p>So <code>RES_API(aName, aFunc)</code> results in <code>aName_aFunc</code>.</p>

<p>By itself, it seems rather annoying. I could see a use when mixing C and C++ code, as C libraries tend to prefix their functions, while C++ libraries would place them in a namespace.</p>

<p>Given an alternate definition, such as:</p>

<pre><code>#define RES_API(name, func) name##::##func
</code></pre>

<p>You suddenly have a generic way to switch between a C interface, or C++.</p>
",1
1899539,1899445,4,"<p>I know you've already got your answer, but there is some great info on the C-FAQ which explains allot of the <a href=""http://c-faq.com/~scs/cgi-bin/faqcat.cgi?sec=cpp"" rel=""nofollow noreferrer"">C Preprocessor magic</a>.</p>
",1
599384,599365,3,"<p>Rusty actually produced a whole set of build conditionals in <a href=""http://ccan.ozlabs.org/list.html"" rel=""nofollow noreferrer"">ccan</a>, check out the build assert module:</p>

<pre><code>#include &lt;stddef.h&gt;
#include &lt;ccan/build_assert/build_assert.h&gt;

struct foo {
        char string[5];
        int x;
};

char *foo_string(struct foo *foo)
{
        // This trick requires that the string be first in the structure
        BUILD_ASSERT(offsetof(struct foo, string) == 0);
        return (char *)foo;
}
</code></pre>

<p>There are lots of other helpful macros in the actual header, which are easy to drop into place.</p>

<p>I try, with all of my might to resist the pull of the dark side (and preprocessor abuse) by sticking mostly to inline functions, but I do enjoy clever, useful macros like the ones you described.</p>
",3
599395,599365,7,"<p>Another nice pre-processor ""trick"" is to use the ""#"" character to print debugging expressions. For example:</p>

<pre><code>#define MY_ASSERT(cond) \
  do { \
    if( !(cond) ) { \
      printf(""MY_ASSERT(%s) failed\n"", #cond); \
      exit(-1); \
    } \
  } while( 0 )
</code></pre>

<p><strong>edit:</strong> the code below only works on C++. Thanks to smcameron and Evan Teran.</p>

<p>Yes, the compile time assert is always great. It can also be written as:</p>

<pre><code>#define COMPILE_ASSERT(cond)\
     typedef char __compile_time_assert[ (cond) ? 0 : -1]
</code></pre>
",8
599417,599365,3,"<p>Two good source books for this sort of stuff are <a href=""http://cm.bell-labs.com/cm/cs/tpop/"" rel=""nofollow noreferrer"">The Practice of Programming</a> and <a href=""https://rads.stackoverflow.com/amzn/click/com/1556155514"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Writing Solid Code</a>. One of them (I don't remember which) says: Prefer enum to #define where you can, because enum gets checked by the compiler.</p>
",2
599529,599365,2,"<p>See <a href=""https://stackoverflow.com/questions/132241/hidden-features-of-c"">""Hidden features of C""</a> question.</p>
",0
599432,599365,45,"<p>If we are talking about c tricks my favourite has to be <a href=""http://www.lysator.liu.se/c/duffs-device.html"" rel=""nofollow noreferrer"">Duff's Device</a> for loop unrolling! I'm just waiting for the right opportunity to come along for me to actually use it in anger...</p>
",12
599441,599365,22,"<p>I like the ""struct hack"" for having a dynamically sized object. <a href=""http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=288"" rel=""nofollow noreferrer"">This site</a> explains it pretty well too (though they refer to the C99 version where you can write ""str[]"" as the last member of a struct). you could make a string ""object"" like this:</p>

<pre><code>struct X {
    int len;
    char str[1];
};

int n = strlen(""hello world"");
struct X *string = malloc(sizeof(struct X) + n);
strcpy(string-&gt;str, ""hello world"");
string-&gt;len = n;
</code></pre>

<p>here, we've allocated a structure of type X on the heap that is the size of an int (for len), plus the length of ""hello world"", plus 1 (since str<a href=""http://www.informit.com/guides/content.aspx?g=cplusplus&amp;seqNum=288"" rel=""nofollow noreferrer"">1</a> is included in the sizeof(X).</p>

<p>It is generally useful when you want to have a ""header"" right before some variable length data in the same block.</p>
",9
599555,599365,28,"<p>Once a mate of mine and I redefined return to find a tricky stack corruption bug.</p>

<p>Something like:</p>

<pre><code>#define return DoSomeStackCheckStuff, return
</code></pre>
",6
599751,599365,17,"<p>Object oriented code with C, by emulating classes.  </p>

<p>Simply  create a struct and a set of functions that take a pointer to that struct as a first parameter.  </p>
",4
599480,599365,6,"<p>I wouldn't really call it a favorite trick, since I've never used it, but the mention of Duff's Device reminded me of <a href=""http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html"" rel=""nofollow noreferrer"">this article</a> about implementing Coroutines in C.  It always gives me a chuckle, but I'm sure it could be useful some time.</p>
",1
599595,599365,6,"<pre><code>#if TESTMODE == 1    
    debug=1;
    while(0);     // Get attention
#endif
</code></pre>

<p>The while(0); has no effect on the program, but the compiler will issue a warning about ""this does nothing"", which is enough to get me to go look at the offending line and then see the real reason I wanted to call attention to it.</p>
",2
599622,599365,5,"<p>This one comes from the book 'Enough rope to shoot yourself in the foot':</p>

<p>In the header declare</p>

<pre><code>#ifndef RELEASE
#  define D(x) do { x; } while (0)
#else
#  define D(x)
#endif
</code></pre>

<p>In your code place testing statements eg:</p>

<pre><code>D(printf(""Test statement\n""));
</code></pre>

<p>The do/while helps in case the contents of the macro expand to multiple statements. </p>

<p>The statement will only be printed if '-D RELEASE' flag for compiler is not used.</p>

<p>You can then eg. pass the flag to your makefile etc. </p>

<p>Not sure how this works in windows but in *nix it works well</p>
",4
599522,599365,-1,"<p>I don't know if it's a trick.  But when I was a junior in university a friend of mine and I were completing a lab in our intro C++ course.  We had to take a person's name and capitalize it, display it back, and then give them the option of displaying their name ""last, first"".  For this lab we were prohibited from using array notation. </p>

<p>He showed me this code, I thought it was the coolest thing I'd seen at the time.</p>

<pre><code>char * ptr = ""first name"";

//flies to the end of the array, regardless of length
while( *ptr++ );
</code></pre>
",3
599639,599365,50,"<p>I'm fond of using <code>= {0};</code> to initialize structures without needing to call memset.</p>

<pre><code>struct something X = {0};
</code></pre>

<p>This will initialize all of the members of the struct (or array) to zero (but not any padding bytes - use memset if you need to zero those as well).</p>

<p>But you should be aware there are <a href=""https://stackoverflow.com/questions/177393/initializing-a-large-structure-in-c"">some issues with this for large, dynamically allocated structures</a>.</p>
",3
599916,599365,8,"<p>Bit-shifts are only defined up to a shift-amount of 31 (on a 32 bit integer).. </p>

<p>What do you do if you want to have a computed shift that need to work with higher shift-values as well? Here is how the Theora vide-codec does it:</p>

<pre><code>unsigned int shiftmystuff (unsigned int a, unsigned int v)
{
  return (a&gt;&gt;(v&gt;&gt;1))&gt;&gt;((v+1)&gt;&gt;1);
}
</code></pre>

<p>Or much more readable: </p>

<pre><code>unsigned int shiftmystuff (unsigned int a, unsigned int v)
{
  unsigned int halfshift = v&gt;&gt;1;
  unsigned int otherhalf = (v+1)&gt;&gt;1;

  return (a &gt;&gt; halfshift) &gt;&gt; otherhalf; 
}
</code></pre>

<p>Performing the task the way shown above is a good deal faster than using a branch like this: </p>

<pre><code>unsigned int shiftmystuff (unsigned int a, unsigned int v)
{
  if (v&lt;=31)
    return a&gt;&gt;v;
  else
    return 0;
}
</code></pre>
",3
600627,599365,31,"<p>In C99</p>

<pre><code>typedef struct{
    int value;
    int otherValue;
} s;

s test = {.value = 15, .otherValue = 16};

/* or */
int a[100] = {1,2,[50]=3,4,5,[23]=6,7};
</code></pre>
",0
600454,599365,42,"<p>using  <code>__FILE__</code> and <code>__LINE__</code> for debugging</p>

<pre><code>#define WHERE fprintf(stderr,""[LOG]%s:%d\n"",__FILE__,__LINE__);
</code></pre>
",3
600473,599365,14,"<p>Using a stupid macro trick to make record definitions easier to maintain.</p>

<pre><code>#define COLUMNS(S,E) [(E) - (S) + 1]

typedef struct
{
    char studentNumber COLUMNS( 1,  9);
    char firstName     COLUMNS(10, 30);
    char lastName      COLUMNS(31, 51);

} StudentRecord;
</code></pre>
",0
600690,599365,11,"<p>For creating a variable which is read-only in all modules except the one it's declared in:</p>

<pre><code>// Header1.h:

#ifndef SOURCE1_C
   extern const int MyVar;
#endif
</code></pre>

<hr>

<pre><code>// Source1.c:

#define SOURCE1_C
#include Header1.h // MyVar isn't seen in the header

int MyVar; // Declared in this file, and is writeable
</code></pre>

<hr>

<pre><code>// Source2.c

#include Header1.h // MyVar is seen as a constant, declared elsewhere
</code></pre>
",2
600523,599365,1,"<p>I think the use of <em>userdata</em> pointers is pretty neat. A fashion losing ground nowdays. It's not so much a C feature but is pretty easy to use in C.</p>
",4
622671,599365,0,"<p>Here is an example how to make C code completly unaware about what is actually used of HW for running the app. The main.c does the setup and then the free layer can be implemented on any compiler/arch. I think it is quite neat for abstracting C code a bit, so it does not get to be to spesific.</p>

<p>Adding a complete compilable example here.</p>

<pre><code>/* free.h */
#ifndef _FREE_H_
#define _FREE_H_
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
typedef unsigned char ubyte;

typedef void (*F_ParameterlessFunction)() ;
typedef void (*F_CommandFunction)(ubyte byte) ;

void F_SetupLowerLayer (
F_ParameterlessFunction initRequest,
F_CommandFunction sending_command,
F_CommandFunction *receiving_command);
#endif

/* free.c */
static F_ParameterlessFunction Init_Lower_Layer = NULL;
static F_CommandFunction Send_Command = NULL;
static ubyte init = 0;
void recieve_value(ubyte my_input)
{
    if(init == 0)
    {
        Init_Lower_Layer();
        init = 1;
    }
    printf(""Receiving 0x%02x\n"",my_input);
    Send_Command(++my_input);
}

void F_SetupLowerLayer (
    F_ParameterlessFunction initRequest,
    F_CommandFunction sending_command,
    F_CommandFunction *receiving_command)
{
    Init_Lower_Layer = initRequest;
    Send_Command = sending_command;
    *receiving_command = &amp;recieve_value;
}

/* main.c */
int my_hw_do_init()
{
    printf(""Doing HW init\n"");
    return 0;
}
int my_hw_do_sending(ubyte send_this)
{
    printf(""doing HW sending 0x%02x\n"",send_this);
    return 0;
}
F_CommandFunction my_hw_send_to_read = NULL;

int main (void)
{
    ubyte rx = 0x40;
    F_SetupLowerLayer(my_hw_do_init,my_hw_do_sending,&amp;my_hw_send_to_read);

    my_hw_send_to_read(rx);
    getchar();
    return 0;
}
</code></pre>
",2
627861,599365,1,"<p>Our codebase has a trick similar to</p>

<pre><code>#ifdef DEBUG

#define my_malloc(amt) my_malloc_debug(amt, __FILE__, __LINE__)
void * my_malloc_debug(int amt, char* file, int line)
#else
void * my_malloc(int amt)
#endif
{
    //remember file and line no. for this malloc in debug mode
}
</code></pre>

<p>which allows for the tracking of memory leaks in debug mode.  I always thought this was cool.</p>
",0
745158,745152,12,"<p>This is entirely implementation dependent.</p>

<p>This depends on the hardware as much as anything, but also on the age of the compiler.  For anyone with a reasonably modern compiler (meaning anything based on a standard from the early 90's or later), the size argument is a <code>size_t</code>.  This can reasonably be the largest 16 bit unsigned, the largest 32 bit unsigned, or the largest 64 bit unsigned, depending on the memory model the compiler compiles to.  In this case, you just have to find out what size a <code>size_t</code> is in your implementation.  However, for <strong>very</strong> old compilers (that is, before ANSI-C and <a href=""http://www.csse.uwa.edu.au/programming/ansic-library.html#string"" rel=""noreferrer"">perhaps for some early versions of ANSI C</a>), all bets are off.</p>

<p>On the standards side, looking at cygwin and Solaris 7, for example, the size argument is a <code>size_t</code>. Looking at an embedded system that I have available, the size argument is an <code>unsigned</code> (meaning 16-bit unsigned).  (The compiler for this embedded system was written in the 80's.)  I found a web reference to some ANSI C <a href=""http://www.csse.uwa.edu.au/programming/ansic-library.html#string"" rel=""noreferrer"">where the size parameter is an <code>int</code></a>.</p>

<p>You may want to see <a href=""http://www.embedded.com/columns/programmingpointers/200900195"" rel=""noreferrer"">this article</a> on <code>size_t</code> as well as the <a href=""http://www.embedded.com/columns/programmingpointers/201803576"" rel=""noreferrer"">follow-up article</a> about a mis-feature of some early GCC versions where <code>size_t</code> was erroneously signed.</p>

<p>In summary, for <em>almost everyone</em>, <code>size_t</code> will be the correct reference to use.  For those few using embedded systems or legacy systems with very old compilers, however, you need to check your man page.</p>
",7
745234,745152,1,"<p>Functions normally use a <code>size_t</code> to pass a size as parameter. I say normally because <code>fgets()</code> uses an <code>int</code> parameter, which in my opinion is a flaw in the C standard.</p>

<p><code>size_t</code> is defined as a type which can contain the size (in bytes) of any object you could access. Generally it's a typedef of <code>unsigned int</code> or <code>unsigned long</code>.<br>
That's why the values returnes by the <code>sizeof</code> operator are of <code>size_t</code> type.</p>

<p>So 2 ** (<code>sizeof(size_t)</code> * <code>CHAR_BIT</code>) gives you a maximum amount of memory that your program could handle, but it's certainly not the most precise one.<br>
(<code>CHAR_BIT</code> is defined in <code>limits.h</code> and yields the number of bits contained in a <code>char</code>).</p>
",4
745166,745152,0,"<p>They take a size_t argument; so the it's platform dependent.</p>
",0
745171,745152,0,"<p>Implementation dependent, but you can look in the header (.h) file that you need to include before you can use memcpy.  The declaration will tell you (look for size_t or other).</p>

<p>And then you ask what size_t is, well, that's the implementation dependent part.</p>
",0
745349,745152,0,"<p>Right, you cannot copy areas that are greater then 2^(sizeof(size_t)*8) bytes. But that is nothing to worry about, because you cannot allocate more space either, because <code>malloc</code> also takes the size as a size_t parameter.</p>
",3
746982,745152,0,"<p>There is also an issue related to what <code>size_t</code> can represent verses what your platform will allow a process to actually address. </p>

<p>Even with virtual memory on a 64-bit platform, you are unlikely to be able to call <code>memcpy()</code> with sizes of more than a few TB or so this week, and even then that is a pretty hot machine.... it is hard to imagine what a machine on which it would be possible to install a fully covered 64-bit address space would look like.</p>

<p>Never mind the embedded systems with only a few KB of total writable memory, where it can't make sense to attempt to <code>memcpy()</code> more information than the RAM regardless of the definition of <code>size_t</code>. Do think about what just happened to the stack holding the return address from that call if you did?</p>

<p>Or systems where the virtual address space seen by a process is smaller than the physical memory installed. This is actually the case with a Win32 process running on a Win64 platform, for example. (I first encountered this under the time sharing OS TSX-11 running on a PDP-11 with 4MB of physical memory, and 64KB virtual address in each process. 4MB of RAM was a lot of memory then, and the IBM PC didn't exist yet.) </p>
",0
1505114,1505101,7,"<p>You are only guaranteed that variables with static storage duration (global variables, static variables in functions) are initialized to 0. No other guarantees.</p>
",0
1505120,1505101,-1,"<p>No.</p>

<p>For example, the MS VC++ compiler will initialize struct members to zero for debug builds, and will not initialize members to zero for release builds.</p>
",1
1505133,1505101,-1,"<p>No. There is no such guarantee. If you want them to be initialized to zero, it pretty much needs to be done manually, unless the structure variable is declared as global.</p>

<p>EDIT: Yes, I forgot to mention static variables within a function.</p>
",1
1505184,1505101,1,"<p>From the <a href=""http://flash-gordon.me.uk/ansi.c.txt"" rel=""nofollow noreferrer"">ANSI C standard</a>: If an object that has static storage duration is not initialized explicitly, it is initialized implicitly as if every member that has
arithmetic type were assigned 0 and every member that has pointer type
were assigned a null pointer constant.  If an object that has
automatic storage duration is not initialized explicitly, its value is
indeterminate</p>
",0
1505247,1505101,7,"<p>Relevant parts of the C99 standard:</p>
<p>section 6.2.4, ¡ì3:</p>
<blockquote>
<p>An object whose identifier is declared
with external or internal linkage, or
with the storage-class specifier
static has static storage duration.
Its lifetime is the entire execution
of the program and its stored value is
initialized only once, prior to
program startup.</p>
</blockquote>
<p>section 6.2.4, ¡ì4:</p>
<blockquote>
<p>An object whose identifier is declared
with no linkage and without the
storage-class specifier static has
automatic storage duration.</p>
</blockquote>
<p>section 6.2.4, ¡ì5 (regarding objects with automatic storage duration):</p>
<blockquote>
<p>The initial value of the object is
indeterminate. If an initialization is
specified for the object, it is
performed each time the declaration is
reached in the execution of the block;
otherwise, the value becomes
indeterminate each time the
declaration is reached.</p>
</blockquote>
<p>section 6.7.8, ¡ì10:</p>
<blockquote>
<p>If an object that has automatic
storage duration is not initialized
explicitly, its value is
indeterminate. If an object that has
static storage duration is not
initialized explicitly, then:</p>
<p>¡ª if it
has pointer type, it is initialized to
a null pointer;</p>
<p>¡ª if it has arithmetic
type, it is initialized to (positive
or unsigned) zero;</p>
<p>¡ª if it is an
aggregate, every member is initialized
(recursively) according to these
rules;</p>
<p>¡ª if it is a union, the first
named member is initialized
(recursively) according to these
rules.</p>
</blockquote>
",0
1505364,1505101,0,"<p>In C++ a struct can have a constructor with an initialiser list to perform automatic initialisation.</p>

<p>A struct is a data type, and type does not determine initialisation. Storage class determines initialisation. So a statically allocated object of the struct type will. like any other static object, be initialised to zero. Any object declared with the <em>static</em> keyword or declared outside of a function scope is statically allocated.</p>
",0
1406704,1406679,4,"<p>I don't believe there's any portable way, but e.g. on Linux you can call <code>readlink</code> on <code>""/proc/self/fd/</code><em>fileno</em><code>""</code> and the kernel will give you a path if it can, or one of various kinds of funny-looking strings if not.</p>
",5
1406751,1406679,-1,"<p>There can be one or many names for a file, so no std way. 
I am not sure if there can be something OS specific.</p>
",0
951754,951746,8,"<p>The compiler aligns the struct members by a boundary (which is different in your compilation attempts).</p>

<p>Add a </p>

<pre><code>#pragma pack (1)
</code></pre>

<p>directive at the beginning of source file and retry.</p>
",7
951759,951746,1,"<p>Because of the padding between the elements.</p>
",0
951766,951746,0,"<p>sizeof(b) is 48 because the last uint32 takes up a full 64-bits (because the subsequent  uint64s are aligned to 64-bit blocks. sizeof(a)  takes up more because the first 3 unit32s take up 2 blocks, the next 3 take up 2 blocks, and the final uint32 takes a full 64-bit block</p>
",0
951769,951746,2,"<p>64-bit integers have to be placed on a 64-bit memory boundary.  Thus, when creating a struct A on a 64-bit machine, the compiler sticks a 4-byte padding space after i3  and i7 - thus putting an extra 8 bytes in there.</p>
",2
951771,951746,0,"<p>This is because of aligning.</p>

<p>It is possible that 64bit integers on your platform are required to be 64bit aligned.</p>

<p>So In the mixed structure you have 3 32 bit integer, after them there must be inserted an other 32bit padding to have the 64bit integer correctly aligned.</p>

<p>The size difference should vanish if you insert and even number of 32bit field before your 64 bit field.</p>
",0
951784,951746,1,"<p>This is caused due to structure aligning: <code>struct A</code> has 3 32 bit values followed by a 64bit one. Regardless of the packing of the first 3 elements the 64bit element definitely won't start between boundaries (i.e. taking up half of two separate 64bit values) on 64bit, so there is at least a 32bit padding between the 3rd and 4th element.</p>
",0
951821,951746,22,"<p>Some diagrams to help you see:</p>

<p>32-bit:</p>

<pre><code>+----+----+----+----+----+----+----+----+----+----+----+
| i1 | i2 | i3 |   i4    | i5 | i6 | i7 |   i8    | i9 | Struct A
+----+----+----+----+----+----+----+----+----+----+----+

+----+----+----+----+----+----+----+----+----+----+----+
| i1 | i2 | i3 | i4 | i5 | i6 | i7 |   i8    |   i9    | Struct B
+----+----+----+----+----+----+----+----+----+----+----+
</code></pre>

<p>64-bit:</p>

<pre><code>+---------+---------+---------+---------+---------+---------+---------+
| i1 | i2 | i3 |~~~~|    i4   | i5 | i6 | i7 |~~~~|   i8    | i9 |~~~~| Struct A
+---------+---------+---------+---------+---------+---------+---------+

+---------+---------+---------+---------+---------+---------+
| i1 | i2 | i3 | i4 | i5 | i6 | i7 |~~~~|   i8    |   i9    | Struct B
+---------+---------+---------+---------+---------+---------+
</code></pre>

<ul>
<li><strong>+</strong> : address boundaries</li>
<li><strong>~</strong> : padding</li>
</ul>
",0
951886,951746,3,"<p>Because it can. The compiler isn't required to use the same layout between 32 and 64-bit mode. It can insert padding when it wants to. You shouldn't rely on the precise layout of the struct in the first place.</p>

<p>In principle, it could even change the padding each time you compile. (It's hard to imagine why the compiler would do this, but it's allowed to)</p>
",2
755758,755741,3,"<p>Octal is base 8 (using digits 0-7) so each digit is 3 bits:</p>

<p>\0354 = 11 101 100</p>

<p>Hexadecimal is base 16 (using digits 0-9,A-F) and each digit is 4 bits:</p>

<p>\x23 = 0010 0011</p>

<p>Inside C strings (char arrays/pointers), they are generally used to encode bytes that can't be easily represented.</p>

<p>So, if you want a string which uses ASCII codes like STX and ETX, you can do:</p>

<pre><code>char *msg = ""\x02Here's my message\x03"";
</code></pre>
",0
755761,755741,5,"<p>In C, strings are terminated by a character with the value zero (0). This could be written like this:</p>

<pre><code>char zero = 0;
</code></pre>

<p>but this doesn't work inside strings. There is a special syntax used in string literals, where the backslash works as an escape sequence introduction, and is followed by various things.</p>

<p>One such sequence is ""backslash zero"", that simply means a character with the value zero. Thus, you can write things like this:</p>

<pre><code>char hard[] = ""this\0has embedded\0zero\0characters"";
</code></pre>

<p>Another sequence uses a backslash followed by the letter <code>'x'</code> and one or two hexadecimal digits, to represent the character with the indicated code. Using this syntax, you could write the zero byte as <code>'\x0'</code> for instance.</p>

<p><strong>EDIT</strong>: Re-reading the question, there's also support for such constants in base eight, i.e. octal. They use a backslash followed by the digit zero, just as octal literal integer constants. <code>'\00'</code> is thus a synonym for <code>'\0'</code>.</p>

<p>This is sometimes useful when you need to construct a string containing non-printing characters, or special control characters.</p>

<p>There's also a set of one-character ""named"" special characters, such as <code>'\n'</code> for newline, <code>'\t'</code> for TAB, and so on.</p>
",3
755763,755741,5,"<p>Those would be used to write otherwise nonprintable characters in the editor. For standard chars, that would be the various control characters, for wchar it could be characters not represented in the editor font.</p>

<p>For instance, this compiles in Visual Studio 2005:</p>

<pre><code>    const wchar_t bom = L'\xfffe';     /* Unicode byte-order marker */
    const wchar_t hamza = L'\x0621';   /* Arabic Letter Hamza */
    const char start_of_text = '\002'; /* Start-of-text */
    const char end_of_text = '\003';   /* End-of-text */
</code></pre>

<p>Edit: Using octal character literals has an interesting caveat. Octal numbers can apparantly not be more than three digits long, which artificially restricts the characters we can enter.</p>

<p>For instance:</p>

<pre><code>        /* Letter schwa; capital unicode code point 0x018f (octal 0617)
         *               small unicode code point   0x0259 (octal 1131) 
         */
    const wchar_t Schwa2 = L'\x18f';    /* capital letter Schwa, correct */
    const wchar_t Schwa1 = L'\617';     /* capital letter Schwa, correct */
    const wchar_t schwa1 = L'\x259';    /* small letter schwa, correct */
    const wchar_t schwa2 = L'\1131';    /* letter K (octal 113), incorrect */
</code></pre>
",0
739599,739596,2,"<p>You are counting \n as a word even for a blank line.</p>
",1
739600,739596,3,"<p>Your algorithm is wrong. If you have in the test file 2 blank characters in succession the counter for words will be incremented twice, but it should be incremented only once.</p>

<p>A solution will be to remember last character read. If the character read is a special character (blank, new line, ...) and the previous character is an alphanumeric then you increment the counter for words.</p>
",0
1901014,1900997,26,"<p>The C grammar says that the things after the '?' and the ':' must be expressions - return is not an expression, it is a statement.</p>
",0
1901018,1900997,6,"<p>The second and third parts of the ternary expression are expected to yield values, not be return statements as in your example.</p>
",0
1901019,1900997,10,"<p>The operands of ternary ?: are expressions. A return statement is a statement, not an expression.</p>
",0
1901927,1900997,7,"<p><code>?:</code> is an operator not a control flow construct, so the whole thing with operands must be an expression, and return statements (or any statement) are not valid sub-expressions.  </p>

<p><code>?:</code> is not simply a shorthand for <code>if-else</code> (which is a control flow construct); it is semantically different.</p>

<pre><code>if( a &gt; b ) return a; else return b;
</code></pre>

<p>on the other hand is what you were trying to do, and entirely valid (if perhaps ill-advised stylistically).</p>
",0
1905760,1900997,1,"<p>Ternary operator needs expression,return is a statement.</p>

<p>More about conditional operator <a href=""http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V40F_HTML/AQTLTBTE/DOCU_063.HTM"" rel=""nofollow noreferrer"">here</a>.</p>
",0
1482536,1482521,1,"<p>You're adding to decValue before you ever assign anything to it.  I didn't look too closely at   your logic but that stood out immediately.  Depending on platform that may cause you issues.</p>
",1
1482538,1482521,3,"<p>Since <code>i &lt; LENGTH</code>, <code>i - LENGTH + 1</code> is negative and the <code>pow</code> is therefore 0.</p>

<p>So, you should use <code>pow( base , LENGTH - i - 1 )</code> -- that one's the biggie. Other big bugs: you should use strlen(input) wherever you're using LENGTH; <strong>and</strong> you should initialize decValue to 0. There may be others, I stopped looking after the first three (this IS after all California, land of the ""Three Strikes, You're Out"" law;-).</p>
",1
1482541,1482521,1,"<p>A few comments:</p>

<ol>
<li>As written, your code doesn't support ""any base"", only bases up to 17 (an odd place to stop).</li>
<li><code>strchr()</code> can return <code>NULL</code>. You should never assume that it won't, especially when you're feeding it direct user input.</li>
<li>Lowercase letters are nice, and you should support them. Simply convert the relevant character to uppercase with <code>toupper()</code>, and then you can recognize both <code>a</code> and <code>A</code> as hexidecimal 10.</li>
<li>In the interest of coding practices, I would suggest creating a function to perform the relevant conversion, rather than doing all the dirty work in <code>main()</code>.</li>
</ol>

<p>If you're doing this as a learning exercise, ignore this paragraph, but you appear to essentially be rewriting the standard library function <a href=""http://opengroup.org/onlinepubs/007908775/xsh/strtol.html"" rel=""nofollow noreferrer""><code>strtol()</code></a>, which converts a string to a <code>long</code> for arbitrary bases. It's pretty nice, actually, and has some functionality that you could incorporate into your code if you wanted.</p>
",0
1482554,1482521,3,"<p>The thing that troubles me here the most is your mixture of floating point arithmetic into an integer problem.  Not only is it less efficient, but when the result is converted back to an int, there's the possibility it might get rounded down or something silly.  Hypothetical example:</p>

<pre><code>double n = pow(2,3); //becomes 7.99999999999999999999999 for some silly reason
int in = n; //rounds down to 7
</code></pre>

<p>Although this might not even be happening in your case, be wary of integer &lt;-> floating point conversions, and avoid them when they are unnecessary.</p>

<p>A better solution is to build up the power incrementally.  If I were you, I'd iterate from beginning to end of the number.  Pseudocode:</p>

<pre><code>let s be the input string's digits;
let r be the radix;
let n be the resulting number;
n=0;
for (i=0; i&lt;s.size(); i++) {
    n *= radix;
    n += s[i];
}
</code></pre>

<p>The concept is that you are picking up digits and shifting them into the number.  E.g. 123 in decimal:</p>

<pre><code>1
(shift 1 left, then add 2)
12
(shift 12 left, then add 3)
123
</code></pre>

<p>Shifting left, in the context of integers in a given base, is simply multiplying by the radix.</p>
",0
1482568,1482521,0,"<p>Couple things: don't take the address of <code>input</code> (<code>input</code>, an array, already degrades to the pointer you want; taking a pointer of it will result in a pointer to an array, not what you want); and you need to make sure not to overflow the <code>input</code> buffer when reading into it.</p>

<p>If this is not homework, you should just use <code>strtol()</code>:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define Str(x) #x
#define Xstr(x) Str(x)

int main()
{
    char input[LENGTH+1] ;
    int base;
    long decValue;
    char *endptr;

    puts( ""Enter a value, and its base: "" );
    scanf( ""%"" Xstr(LENGTH) ""s"", input ); /* reads at most LENGTH characters */
    scanf( ""%i"", &amp;base );

    decValue = strtol( input, &amp;endptr, base );
    assert( *endptr == '\0' ); /* if there are any characters left, then string contained invalid characters */

    printf( ""%s (base-%u) equals %ld\n"", input, base, decValue );

    return 0;
}
</code></pre>
",0
1482577,1482521,3,"<p>My suggestion: Dont reinvent the wheel.</p>

<p>See <a href=""http://www.cplusplus.com/reference/clibrary/cstdlib/strtoul/"" rel=""nofollow noreferrer"">strtoul</a> function:</p>

<pre><code>#include &lt;stdlib.h&gt;                                                             
#include &lt;stdio.h&gt;
int main(){

        /* first arg: number in base n to convert to base 10
         * third arg: base n
         */
        long int b10= strtoul(""111"",NULL,2);
        printf(""%ld\n"",b10);
        return 0;

}
</code></pre>
",0
297501,297487,1,"<p>Are you using a regex library?  If so does it support accessing grouped parts of the regex, something like:</p>

<pre><code>(""$""?)({letter})({1,2})(""$""?)({digit}{1,3})
</code></pre>

<p>(This <a href=""http://www.developer.com/net/net/article.php/3490231"" rel=""nofollow noreferrer"">article</a> shows the technique using the .NET regex library)</p>

<p>If that isn't an option, then building a simple state machine would work well, and be easy to maintain and test.</p>
",0
645426,645423,8,"<p>Perhaps you should escape the <code>\n</code> again, as in</p>

<pre><code>system(""awk '{ printf \""%d \\n\"", $12 }' results.dat | sort -n"");
//                         ^ note the extra \
</code></pre>

<p>as I think the <code>\n</code> is meant to be part of the <code>printf</code>.</p>

<p>Your current construction calls <code>system</code> with an argument of</p>

<pre><code>awk '{ printf ""%d 
"", $12 }' results.dat | sort -n
</code></pre>
",2
213043,213042,103,"<p>use the <code>pow</code> function (it takes <code>float</code>s/<code>double</code>s though).</p>

<p><code>man pow</code>:</p>

<pre><code>   #include &lt;math.h&gt;

   double pow(double x, double y);
   float powf(float x, float y);
   long double powl(long double x, long double y);
</code></pre>

<p><strong>EDIT</strong>: For the special case of positive integer powers of <code>2</code>, you can use bit shifting: <code>(1 &lt;&lt; x)</code> will equal <code>2</code> to the power <code>x</code>. There are some potential gotchas with this, but generally, it would be correct.</p>
",4
213064,213042,39,"<p>To add to what <a href=""https://stackoverflow.com/questions/213042/how-do-you-do-exponentiation-in-c#213043"">Evan</a> said: C does not have a built-in operator for exponentiation, because it is not a primitive operation for most CPUs.  Thus, it's implemented as a library function.</p>

<p>Also, for computing the function e^x, you can use the <code>exp(double)</code>, <code>expf(float)</code>, and <code>expl(long double)</code> functions.</p>

<p>Note that you do <strong>not</strong> want to use the <code>^</code> operator, which is the <em>bitwise exclusive OR</em> operator.</p>
",3
213260,213042,2,"<p>or you could just write the power function, with recursion as a added bonus</p>

<pre><code>int power(int x, int y){
      if(y == 0)
        return 1;
     return (x * power(x,y-1) );
    }
</code></pre>

<p>yes,yes i know this is less effecient space and time complexity but recursion is just more fun!!</p>
",0
213322,213042,26,"<p><code>pow</code> only works on floating-point numbers (<code>double</code>s, actually).  If you want to take powers of integers, and the base isn't known to be an exponent of <code>2</code>, you'll have to roll your own.</p>

<p>Usually the dumb way is good enough.</p>

<pre><code>int power(int base, unsigned int exp) {
    int i, result = 1;
    for (i = 0; i &lt; exp; i++)
        result *= base;
    return result;
 }
</code></pre>

<p>Here's a recursive solution which takes <code>O(log n)</code> space and time instead of the easy <code>O(1)</code> space <code>O(n)</code> time:</p>

<pre><code>int power(int base, int exp) {
    if (exp == 0)
        return 1;
    else if (exp % 2)
        return base * power(base, exp - 1);
    else {
        int temp = power(base, exp / 2);
        return temp * temp;
    }
}
</code></pre>
",2
213897,213042,5,"<p>The non-recursive version of the function is not too hard - here it is for integers:</p>

<pre><code>long powi(long x, unsigned n)
{
    long p = x;
    long r = 1;

    while (n &gt; 0)
    {
        if (n % 2 == 1)
            r *= p;
        p *= p;
        n /= 2;
    }

    return(r);
}
</code></pre>

<p>(Hacked out of code for raising a double value to an integer power - had to remove the code to deal with reciprocals, for example.)</p>
",1
562377,562303,547,"
<p><em><strong>Warning</strong></em>!</p>
<p>This is a list of random books of diverse quality. In the view of some people (with some justification), it is no longer a list of recommended books. Some of the listed books contain blatantly incorrect statements or teach wrong/harmful practices.  People who are aware of such books can edit this answer to help improve it.
See <a href=""https://meta.stackoverflow.com/questions/355588/the-c-book-list-has-gone-haywire-what-to-do-with-it"">The C book list has gone haywire. What to do with it?</a>, and also <a href=""https://meta.stackoverflow.com/questions/378437/deleted-question-audit-2018"">Deleted question audit 2018</a>.</p>
<h1>Reference (All Levels)</h1>
<ul>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0131103628"" rel=""noreferrer"" rel=""nofollow noreferrer"">The C Programming Language (2nd Edition)</a> - Brian W. Kernighan and Dennis M. Ritchie (1988). Still a good, short but complete introduction to C (C90, not C99 or later versions), written by the inventor of C.  However, the language has changed and good C style has developed in the last 25 years, and there are parts of the book that show its age.</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/013089592X"" rel=""noreferrer"" rel=""nofollow noreferrer"">C: A Reference Manual (5th Edition)</a> - Samuel P. Harbison and Guy R. Steele (2002).  An excellent reference book on C, up to and including C99. It is not a tutorial, and probably unfit for beginners. It's great if you need to write a compiler for C, as the authors had to do when they started.</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0596004362"" rel=""noreferrer"" rel=""nofollow noreferrer"">C Pocket Reference (O'Reilly)</a> - Peter Prinz and Ulla Kirch-Prinz (2002).</p>
</li>
<li><p><a href=""http://c-faq.com/"" rel=""noreferrer"">The comp.lang.c FAQ</a> - Steve Summit. Web site with answers to many questions about C.</p>
</li>
<li><p>Various versions of the C language standards can be found <a href=""http://www.iso-9899.info/wiki/The_Standard"" rel=""noreferrer"">here</a>.  There is an online version of the <a href=""http://port70.net/%7Ensz/c/c11/n1570.html"" rel=""noreferrer"">draft C11 standard</a>.</p>
</li>
<li><p><a href=""http://www.knosof.co.uk/cbook/cbook.html"" rel=""noreferrer"">The new C standard - an annotated reference</a> (Free PDF) - Derek M. Jones (2009).  The &quot;new standard&quot; referred to is the old C99 standard rather than C11.</p>
</li>
<li><p><a href=""http://www.open-std.org/JTC1/SC22/WG14/www/C99RationaleV5.10.pdf"" rel=""noreferrer"">Rationale for C99 Standard</a>.</p>
</li>
</ul>
<hr />
<h1>Beginner</h1>
<ul>
<li><p><a href=""http://knking.com/books/c2/index.html"" rel=""noreferrer"">C Programming: A Modern Approach (2nd Edition)</a> - K. N. King (2008).  A good book for learning C.</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0321776410"" rel=""noreferrer"" rel=""nofollow noreferrer"">Programming in C (4th Edition)</a> - Stephen Kochan (2014). A good general introduction and tutorial.</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0672326965"" rel=""noreferrer"" rel=""nofollow noreferrer"">C Primer Plus (5th Edition)</a> - Stephen Prata (2004)</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0201183994"" rel=""noreferrer"" rel=""nofollow noreferrer"">A Book on C</a> - Al Kelley/Ira Pohl (1998).</p>
</li>
<li><p><a href=""http://publications.gbdirect.co.uk/c_book/"" rel=""noreferrer"">The C Book</a> (Free Online) - Mike Banahan, Declan Brady, and Mark Doran (1991).</p>
</li>
<li><p><a href=""https://www.amazon.com//dp/0133976890"" rel=""noreferrer"">C: How to Program (8th Edition)</a> - Paul Deitel and Harvey M. Deitel (2015). Lots of good tips and best practices for beginners. The index is very good and serves as a decent reference (just not fully comprehensive, and very shallow).</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/1449399916"" rel=""noreferrer"" rel=""nofollow noreferrer"">Head First C</a> - David Griffiths and Dawn Griffiths (2012).</p>
</li>
<li><p><a href=""https://www.apress.com/book/9781430248811"" rel=""noreferrer"">Beginning C (5th Edition)</a> - Ivor Horton (2013). Very good explanation of pointers, using lots of small but complete programs.</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0672324482"" rel=""noreferrer"" rel=""nofollow noreferrer"">Sams Teach Yourself C in 21 Days</a> - Bradley L. Jones and Peter Aitken (2002). Very good introductory stuff.</p>
</li>
</ul>



<ul>
<li><p><a href=""https://smile.amazon.com/Programming-easy-steps-5th-Compiler/dp/1840788402/"" rel=""noreferrer"">C In Easy Steps (5th Edition)</a> - Mike McGrath (2018). It is a good book for learning and referencing C.</p>
</li>
<li><p><a href=""https://smile.amazon.com/dp/1718501048"" rel=""noreferrer"">Effective C</a> - Robert C Seacord (2020).  A good introduction to modern C, including chapters on dynamic memory allocation, on program structure, and on debugging, testing and analysis.  It has some pointers toward probable C2x features.</p>
</li>
</ul>
<h1>Intermediate</h1>
<ul>
<li><p><a href=""https://modernc.gforge.inria.fr/"" rel=""noreferrer"">Modern C</a> ¡ª Jens Gustedt (2017 1st Edn; 2020 2nd Edn).  Covers C in 5 levels (encounter, acquaintance, cognition, experience, ambition) from beginning C to advanced C.  It covers C11 and C17, including threads and atomic access, which few other books do. Not all compilers recognize these features in all environments.</p>
</li>
<li><p><a href=""http://www.cs.princeton.edu/software/cii/"" rel=""noreferrer"">C Interfaces and Implementations</a> - David R. Hanson (1997). Provides information on how to define a boundary between an interface and implementation in C in a generic and reusable fashion. It also demonstrates this principle by applying it to the implementation of common mechanisms and data structures in C, such as lists, sets, exceptions, string manipulation, memory allocators, and more. Basically, Hanson took all the code he'd written as part of building <a href=""http://www.cs.arizona.edu/icon"" rel=""noreferrer"">Icon</a> and <a href=""http://www.cs.princeton.edu/software/lcc/"" rel=""noreferrer"">lcc</a> and pulled out the best bits in a form that other people could reuse for their own projects. It's a model of good C programming using modern design techniques (including Liskov's data abstraction), showing how to organize a big C project as a bunch of useful libraries.</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0201604612"" rel=""noreferrer"" rel=""nofollow noreferrer"">The C Puzzle Book</a> - Alan R. Feuer (1998)</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0131315099"" rel=""noreferrer"" rel=""nofollow noreferrer"">The Standard C Library</a> - P.J. Plauger (1992). It contains the complete source code to an implementation of the C89 standard library, along with extensive discussions about the design and why the code is designed as shown.</p>

</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/1449327141"" rel=""noreferrer"" rel=""nofollow noreferrer"">21st Century C: C Tips from the New School</a> - Ben Klemens (2012). In addition to the C language, the book explains gdb, valgrind, autotools, and git. The comments on style are found in the last part (Chapter 6 and beyond).</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0201314525"" rel=""noreferrer"" rel=""nofollow noreferrer"">Algorithms in C</a> - Robert Sedgewick (1997). Gives you a real grasp of implementing algorithms in C. Very lucid and clear; will probably make you want to throw away all of your other algorithms books and keep this one.</p>
</li>
</ul>

<ul>
<li><a href=""https://rads.stackoverflow.com/amzn/click/com/0673999866"" rel=""noreferrer"" rel=""nofollow noreferrer"">Pointers on C</a> - Kenneth Reek (1997).</li>
</ul>

<ul>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0321535421"" rel=""noreferrer"" rel=""nofollow noreferrer"">Problem Solving and Program Design in C (6th Edition)</a> - Jeri R. Hanly and Elliot B. Koffman (2009).</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/B00101Y58Q"" rel=""noreferrer"" rel=""nofollow noreferrer"">Data Structures - An Advanced Approach Using C</a> - Jeffrey Esakov and Tom Weiss (1989).</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0672318962"" rel=""noreferrer"" rel=""nofollow noreferrer"">C Unleashed</a> - Richard Heathfield, Lawrence Kirby, et al. (2000). Not ideal, but it is worth intermediate programmers practicing problems written in this book. This is a good cookbook-like approach suggested by comp.lang.c contributors.</p>
</li>
</ul>

<ul>
<li><a href=""http://www.planetpdf.com/codecuts/pdfs/ooc.pdf"" rel=""noreferrer"">Object-oriented Programming with ANSI-C</a> (Free PDF) - Axel-Tobias Schreiner (1993).
The code gets a bit convoluted.  If you want C++, use C++.  It only uses C90, of course.</li>
</ul>



<h1>Expert</h1>
<ul>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0131774298"" rel=""noreferrer"" rel=""nofollow noreferrer"">Expert C Programming: Deep C Secrets</a> - Peter van der Linden (1994). Lots of interesting information and war stories from the Sun compiler team, but a little dated in places.</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0534951406"" rel=""noreferrer"" rel=""nofollow noreferrer"">Advanced C Programming by Example</a> - John W. Perry (1998).</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0321637739"" rel=""noreferrer"" rel=""nofollow noreferrer"">Advanced Programming in the UNIX Environment</a> - Richard W. Stevens and Stephen A. Rago (2013).  Comprehensive description of how to use the Unix APIs from C code, but not so much about the mechanics of C coding.</p>
</li>
</ul>



<hr />
<h1>Uncategorized</h1>
<ul>
<li><p><a href=""http://cslibrary.stanford.edu/101/EssentialC.pdf"" rel=""noreferrer"">Essential C</a> (Free PDF) - Nick Parlante (2003). Note that this describes the C90 language at several points (<em>e.g.</em>, in discussing <code>//</code> comments and placement of variable declarations at arbitrary points in the code), so it should be treated with some caution.</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0201845199"" rel=""noreferrer"" rel=""nofollow noreferrer"">C Programming FAQs: Frequently Asked Questions</a> - Steve Summit (1995).  This is the book of the web site listed earlier.  It doesn't cover C99 or the later standards.</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0596006977"" rel=""noreferrer"" rel=""nofollow noreferrer"">C in a Nutshell</a> - Peter Prinz and Tony Crawford (2005). Excellent book if you need a reference for C99.</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0201419505"" rel=""noreferrer"" rel=""nofollow noreferrer"">Functional C</a> - Pieter Hartel and Henk Muller (1997). Teaches modern practices that are invaluable for low-level programming, with concurrency and modularity in mind.</p>
</li>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/020161586X"" rel=""noreferrer"" rel=""nofollow noreferrer"">The Practice of Programming</a> - Brian W. Kernighan and Rob Pike (1999). A very good book to accompany K&amp;R. It uses C++ and Java too.</p>
</li>
</ul>

<ul>
<li><p><a href=""https://rads.stackoverflow.com/amzn/click/com/0201179288"" rel=""noreferrer"" rel=""nofollow noreferrer"">C Traps and Pitfalls</a> by A. Koenig (1989). Very good, but the C style pre-dates standard C, which makes it less recommendable these days.</p>
<p><sup>Some have argued for the removal of 'Traps and Pitfalls' from this list because it has trapped some people into making mistakes; others continue to argue for its inclusion.  Perhaps it should be regarded as an 'expert' book because it requires moderately extensive knowledge of C to understand what's changed since it was published.</sup></p>
</li>
</ul>




<ul>
<li><p><a href=""http://www.misra-c.com/Activities/MISRAC/tabid/160/Default.aspx"" rel=""noreferrer"">MISRA-C</a> - industry standard published and maintained by the Motor Industry Software Reliability Association. Covers C89 and C99.</p>
<p><sup>Although this isn't a book as such, many programmers recommend reading and implementing as much of it as possible. MISRA-C was originally intended as guidelines for safety-critical applications in particular, but it applies to any area of application where stable, bug-free C code is desired (who doesn't want fewer bugs?). MISRA-C is becoming the de facto standard in the whole embedded industry and is getting increasingly popular even in other programming branches. There are (at least) three publications of the standard (1998, 2004, and the current version from 2012). There is also a MISRA Compliance Guidelines document from 2016, and MISRA C:2012 Amendment 1 ¡ª Additional Security Guidelines for MISRA C:2012 (published in April 2016).</sup></p>
<p><sup>Note that some of the strictures in the MISRA rules are not appropriate to every context. For example, directive 4.12 states &quot;Dynamic memory allocation shall not be used&quot;. This is appropriate in the embedded systems for which the MISRA rules are designed; it is not appropriate everywhere. (Compilers, for instance, generally use dynamic memory allocation for things like symbol tables, and to do without dynamic memory allocation would be difficult, if not preposterous.)</sup></p>
</li>
<li><p>Archived lists of ACCU-reviewed books on <a href=""https://web.archive.org/web/20071105015557/http://www.accu.informika.ru/bookreviews/public/reviews/0sb/beginner_s_c.htm"" rel=""noreferrer"">Beginner's C</a> (116 titles) from 2007 and <a href=""https://web.archive.org/web/20081020081215/http://www.accu.informika.ru/bookreviews/public/reviews/0sb/advanced_c.htm"" rel=""noreferrer"">Advanced C</a> (76 titles) from 2008. Most of these don't look to be on the main site anymore, and you can't browse that by subject anyway.</p>
</li>
</ul>
<hr />
<h1>Warnings</h1>
<p>There is a list of books and tutorials to be cautious about at the <a href=""http://iso-9899.info/wiki/Main_Page#Stuff_that_should_be_avoided"" rel=""noreferrer"">ISO 9899 Wiki</a>, which is not itself formally associated with ISO or the C standard, but contains information about the C standard (though it hails the release of ISO 9899:2011 and does not mention the release of ISO 9899:2018).</p>
<p>Be wary of books written by <a href=""http://catb.org/%7Eesr/jargon/html/B/bullschildt.html"" rel=""noreferrer"">Herbert Schildt</a>. In particular, you should stay away from <a href=""https://rads.stackoverflow.com/amzn/click/com/0072121246"" rel=""noreferrer"" rel=""nofollow noreferrer"">C: The Complete Reference</a> (4th Edition, 2000), known in some circles as C: The Complete Nonsense.</p>
<p>Also do not use the book <a href=""https://smile.amazon.com/dp/9387284492/"" rel=""noreferrer"">Let Us C</a> (16<sup>th</sup> Edition, 2017) by Yashwant Kanetkar. Many people view it as an outdated book that teaches Turbo C and has lots of obsolete, misleading and incorrect material. For example, page 137 discusses the expected output from <code>printf(&quot;%d %d %d\n&quot;, a, ++a, a++)</code> and does not categorize it as <a href=""https://stackoverflow.com/questions/949433/why-are-these-constructs-using-pre-and-post-increment-undefined-behavior"">undefined behaviour</a> as it should. It also consistently promotes unportable and buggy coding practices, such as using <code>gets</code>, <code>%[\n]s</code> in <code>scanf</code>, storing return value of <code>getchar</code> in a variable of type <code>char</code> or using <code>fflush</code> on <code>stdin</code>.</p>

<p><a href=""https://learncodethehardway.org/c/"" rel=""noreferrer"">Learn C The Hard Way</a> (2015) by Zed Shaw. A book with mixed reviews.
<a href=""http://hentenaar.com/dont-learn-c-the-wrong-way"" rel=""noreferrer"">A critique of this book</a> by Tim Hentenaar:</p>
<blockquote>
<p>To summarize my views, which are laid out below, the author presents the material in a greatly oversimplified and misleading way, the whole corpus is a bundled mess, and some of the opinions and analyses he offers are just plain wrong. I've tried to view this book through the eyes of a novice, but unfortunately I am biased by years of experience writing code in C. It's obvious to me that either the author has a flawed understanding of C, or he's deliberately oversimplifying to the point where he's actually misleading the reader (intentionally or otherwise).</p>
</blockquote>
<p>&quot;Learn C The Hard Way&quot; is not a book that I could recommend to someone who is both learning to program and learning C.  If you're already a competent programmer in some other related language, then it represents an interesting and unusual exposition on C, though I have reservations about parts of the book.  <sub><em>Jonathan Leffler</em></sub></p>
<hr />
<h1>Outdated</h1>
<ul>
<li><a href=""https://rads.stackoverflow.com/amzn/click/com/1565923065"" rel=""noreferrer"" rel=""nofollow noreferrer"">Practical C Programming (3rd Edition)</a> - Steve Oualline (1997)(Beginner)</li>
</ul>
<hr />
<p><sub><strong>Other contributors</strong>, not necessarily credited in the revision history, include:<br />
<a href=""https://stackoverflow.com/users/844882/alex-lockwood"">Alex Lockwood</a>,
<a href=""https://stackoverflow.com/users/479989/ben-jackson"">Ben Jackson</a>,
<a href=""https://stackoverflow.com/users/631423/bubbles"">Bubbles</a>,
<a href=""https://stackoverflow.com/users/193653/claws"">claws</a>,
<a href=""https://stackoverflow.com/users/14463/coledot"">coledot</a>,
<a href=""https://stackoverflow.com/users/3161/dana-robinson"">Dana Robinson</a>,
<a href=""https://stackoverflow.com/users/1322636/daniel-holden"">Daniel Holden</a>,
<a href=""https://stackoverflow.com/users/337306/desbest"">desbest</a>,
<a href=""https://stackoverflow.com/users/50305/dervin-thunk"">Dervin Thunk</a>,
<a href=""https://stackoverflow.com/users/57301/dwc"">dwc</a>,
<a href=""https://stackoverflow.com/users/2226524/eric-hou"">Erci Hou</a>,
<a href=""https://stackoverflow.com/users/102600/garen"">Garen</a>,
<a href=""https://stackoverflow.com/users/714232/haziz"">haziz</a>,
<a href=""https://stackoverflow.com/users/1029106/johan-bezem"">Johan Bezem</a>,
<a href=""https://stackoverflow.com/users/15168/jonathan-leffler"">Jonathan Leffler</a>,
<a href=""https://stackoverflow.com/users/141186/joshua-partogi"">Joshua Partogi</a>,
<a href=""https://stackoverflow.com/users/74660/lucas"">Lucas</a>,
<a href=""https://stackoverflow.com/users/584518/lundin"">Lundin</a>,
<a href=""https://stackoverflow.com/users/52734/mattk"">Matt K.</a>,
<a href=""https://stackoverflow.com/users/487623/mossplix"">mossplix</a>,
<a href=""https://stackoverflow.com/users/147192/matthieu-m"">Matthieu M.</a>,
<a href=""https://stackoverflow.com/users/3991400/midor"">midor</a>,
<a href=""https://stackoverflow.com/users/39892/nietzche-jou"">Nietzche-jou</a>,
<a href=""https://stackoverflow.com/users/41661/norman-ramsey"">Norman Ramsey</a>,
<a href=""https://stackoverflow.com/users/416623/r3st0r3"">r3st0r3</a>,
<a href=""https://stackoverflow.com/users/2395058/ridthyself"">ridthyself</a>,
<a href=""https://stackoverflow.com/users/71074/robert-s-barnes"">Robert S. Barnes</a>,
<a href=""https://stackoverflow.com/users/5688267/smalinux"">smalinux</a>,
<a href=""https://stackoverflow.com/users/3923896/steve-summit"">Steve Summit</a>,
<a href=""https://stackoverflow.com/users/3685/tim-ring"">Tim Ring</a>,
<a href=""https://stackoverflow.com/users/207003/tony-bai"">Tony Bai</a>,
<a href=""https://stackoverflow.com/users/213550/vmatm"">VMAtm</a>
</sub></p>
",2
61229,61227,29,"<p>The value <code>0xFF</code> is a signed int value. C will promote the <code>*p</code> to an <code>int</code> when doing the comparison, so the first if statement is equivalent to:</p>

<pre><code>if( -1 == 255 ) break;
</code></pre>

<p>which is of course false. By using <code>(signed char)0xFF</code> the statement is equivalent to:</p>

<pre><code>if( -1 == -1 ) break;
</code></pre>

<p>which works as you expect. The key point here is that the comparison is done with <code>int</code> types instead of <code>signed char</code> types.</p>
",1
61230,61227,2,"<p>It casts to an int for the first comparison since 0xFF is still considered an int, meaning your char is -128 to 127, but the 0xFF is still 255.</p>

<p>In the second case your telling it that 0xFF is really an signed char, not an int</p>
",0
61232,61227,4,"<p>Integer literals have signed int type. Since 0xFF is a signed int, the compiler converts *p to a signed int and then does the comparison.</p>

<p>When *p is -1, which is then converted from a signed char to a signed int, it is still -1 which has a representation of 0xFFFFFFFF, which is not equal to 0xFF.</p>
",0
61234,61227,1,"<p>0xff will be seen as an integer constant, with the value of 255. You should always pay attention to these kind of comparison between different types. If you want to be sure that the compiler will generate the right code, you should use the typecast:</p>

<pre>
if( *p == (signed char)0xFF ) break;
</pre>

<p>Anyway, <b>beware</b> that the next statement will <b>not</b> work the same way:</p>

<pre>
if( (int)*p == 0xFF ) break;
</pre>

<p>Also, maybe it would be a better idea to avoid signed chars, or, it you must use signed chars, to compare them with signed values such as -1 in this case:</p>

<pre>
if( *p == -1 ) break;
</pre>

<p>0xff==-1 only if those values would be assigned to some char (or unsigned char) variables:</p>

<pre>
char a=0xff;
char b=-1;
if(a==b) break;
</pre>
",0
676744,674575,0,"<p>Also you can try <code>iconv()</code>. On some platform it's part of the C runtime.</p>
",1
720000,719997,3,"<p>It's hard to quantify exactly, but having an understanding of C will give your more insight into how higher-level language constructs are implemented, and as a consequence you'll be better able to use the constructs in an intelligent manner.</p>
",1
720010,719997,3,"<p>To give you a specific reason: having to write my own Garbage Collection routines has helped my write better code.</p>

<p>I don't think I have ever found a problem that I haven't been able to solve with a higher-level language; but started by learning C, it has instilled in me quite a number of excellent development practices.  Knowing how the rudimentary parts of the flow of an application work will enable to you be able to look at your own code and get a good visual of how the data flows, and where it is stored.  This then leads to a better understand of how to track down leaking memory, slow disk reads, poorly constructed caches, etc.</p>

<p>Keeping track of Pointers... that's another one that comes to mind.</p>
",2
720013,719997,2,"<p>Classic examples are things involving lower level memory management, such as the implementation of a linked list class:</p>

<pre><code>struct Node
{
    Data *data;
    Node *next;
}
</code></pre>

<p>Understanding how the pointers are used to iterate the list, and what they signify in terms of the machine architecture will allow you to better understand your high level code.</p>

<p>Another example which Joel was referring to was the implementation of string concatenation, and the right way to create a string from a set of data.</p>

<pre><code>// this is efficient
for (int i=0; i&lt; n; i++)
{
    strcat(str, data(i));
}

// this could be too, but you'd need to look at the implementation to be sure
std::string str;
for (int i=0; i&lt;n; i++)
{
  str+=data(i);
}
</code></pre>
",2
720020,719997,0,"<p>I see it like this , everything boils down to C in a crossplatform level, and assembly in a platform specific way. So it's like being a crosscountry Rally racer, and C is basic automotive mechanics, you can be a great driver but when you get into trouble knowing C means you can probably get yourself back in the race, if not you're stuck calling the mechanics. And assembly is what the mechanics and manufacturers know, it's a worthy investment if that's what you want to do, otherwise you can just trust the mechanics. </p>

<p>For specifics think about memory management, hardwar drivers, physics engines, high performance 3d graphics, TCP stacks, binary protocols, embedded software, creating high level languages like Perl</p>
",0
720031,719997,1,"<p>Do you use arrays much ? and do you come across situations where you need items to be stored in memory without knowing how many of them (i.e. based on a query from the database?) then I suppose C would teach you great things like stacks, structs and link lists which might help you. Regards, Andy</p>
",0
720032,719997,23,"<p>The classic example that Joel Spolsky uses is on <a href=""http://www.joelonsoftware.com/articles/fog0000000319.html"" rel=""nofollow noreferrer"">misuse of strcat and strlen</a>, and spotting ""Shlemiel the painter"" algorithms in general.</p>

<p>It's not that you need C to solve problems that higher-level languages can't solve, it's that knowing C well gives you a perspective on what's going on underneath all those levels of languages that allows you to write better software. Because just such a perspective helps you avoid writing code which is, unknown to you, actually O(n^2), for example.</p>

<p><strong>Edit:</strong> Some clarification based on comments.</p>

<p>Knowing C is not a prerequisite for such knowledge, there are many ways to acquire the same knowledge.</p>

<p>Knowing C is also not a guarantee of these skills. You may be proficient in C and yet still write horrible, grotty, kludgy code in every other language you touch.</p>

<p>C is a low-level language, yet it still has modern control structures and functions so you aren't always getting caught up in the fiddly details. It's very difficult to become proficient at C without gaining a mastery of certain fundamentals (such as the details of memory management and pointers), mastery of which often pays rich dividends when working in any language.</p>

<p><strong>It's always about the fundamentals.</strong></p>

<p>This is true in many pursuits as well as software engineering. It is not secret incantations that make the best programmers the best, rather it is a greater mastery of the fundamentals. Experience has shown that knowledge of C tends to have a higher correlation to mastery of certain of those fundamentals, and that learning C tends to be one of the easier and more common routes to acquiring such knowledge.</p>
",6
720053,719997,1,"<p>Knowing C is really not worth much.  Many of us who know C deeply like to think that all that deep insight is valuable and important.</p>

<p>Some of us who know C can't think of a single specific feature of C that's helpful to know about.</p>

<p>Knowing how pointers work in C (especially with C's syntax) isn't all that helpful.  In a high-level language your statements create objects and manage their interaction.  Pointers and references are -- perhaps -- interesting from a hypothetical point of view.  But the knowledge has no practical impact on how you use Java or Python.  </p>

<p>The higher-level languages are the way they are.  Knowing <em>how</em> doesn't change those languages; it doesn't change how you use them, debug or test them.</p>

<p>Knowing how to create or manipulate a linked list has no earthly impact on Python list class definition.  None. </p>

<p>Knowing the difference between Linked List and Array List might help you write a Java program.  But the C implementation doesn't help you choose between Linked List and Array List.  The decision is independent of knowing C.</p>

<p>A bad algorithm is bad  in every language.  Knowing inner mysteries of C doesn't make a bad algorithm any less bad.  Knowing C doesn't help you know the Java collections or the Python built-in types.  </p>

<p>I can't see any value in learning C.  Learning Fortran is just as valuable.</p>
",6
720891,719997,2,"<p>Knowing C helps you to write better code in C. I guess that the example of Joel Spolsky is of little use in C++ or Objective-C where specific classes for manipulating strings exist and have been crafted with performance in mind. Moreover, using C tricks in other languages may be couter productive.</p>

<p>Nevertheless, C knowledge is very helpful to understand general concepts in other languages and what is behind the hood in many situations.</p>
",0
720897,719997,8,"<p>It's a mistake to assume that learning C will somehow automatically give you a better understanding of low-level programming concerns.  In a lot of cases even C is too high level to give you a good understanding of efficiency concerns.</p>

<p>A classic is i++ versus ++i.  It's over-cited, so perhaps most people know the implications about performance between these two operations.  But learning C wouldn't magically teach you this by itself.</p>

<p>I guess I understand arguments about strings.  When string operations are made deceptively simple, people often use them in inefficient ways.  But again, knowing that strncat exists doesn't give you a full appreciation for the efficiency concerns.  A lot of C programmers probably haven't even thought about the fact that strncat has to do a strlen operation internally.</p>

<p>Even using C, it's important to understand what's going on behind the scenes if efficiency is a concern.  People who know C tend to view things in a progression.  Assembly and machine code are the building blocks of C, while C is a building block of higher level languages.</p>

<p>This isn't specifically true, but it's obvious that C is ""closer to the metal"" than many higher level languages.  This has at least two effects: efficiency concerns aren't as hidden behind implicit behavior, and it's easier to screw up.</p>

<p>So you want a specific example of how knowing C gives you an advantage.  I don't think there is one.  I think what people <em>mean</em> when they say this is that knowing what's going on behind the scenes in whatever language you're happening to write for helps you make more intelligent decisions about how to write code.  However, it's a mistake to assume that C is ""what's going on behind the scenes"" in Java, for instance.</p>
",1
720999,719997,0,"<p>You cannot write an OS kernel in Perl; C would be a much better choice for that, because it is low-level enough to express everything the kernel should do, and portable enough to let you port your kernel to different architectures</p>
",1
722011,719997,0,"<p>Not knowing Perl well, I am wondering if it is now possible to distribute processor load to more than one physical core with several threads created in a single program in Perl, without spawning additional processes</p>
",0
722790,719997,0,"<p>I don't think there can be any specific example.</p>

<p>What learning C does for you is give you an insight, a broadening of the mind, into how computers (and software) work. It's a very abstract thing .. </p>

<p>It doesn't make you write better code in python, it just makes you more of a computer scientist.</p>

<p>The reference that Wedge made to Joel's article mentioning Shlemiel the painter is an interesting one but has no relevance here. That algorithm is not tied to C in any particular way (although it manifests itself in null-terminated strings).</p>

<p>Python's strings are immutable anyway, and completely different from C's model of strings, so I don't quite see the relationship.</p>

<p>I suppose one concrete example is optimizing a parser or a lexer or a program that keeps writing to a string buffer all the time. If you use normal strings instead of a string buffer, you'll run across a problem when you build very large strings.</p>

<p>Consider that:</p>

<pre><code>a = a + b 
</code></pre>

<p>makes a copy of both <code>a</code> and <code>b</code>. It doesn't change the string that was referenced by a, it creates a new string, allocating more memory, etc.</p>

<p>If <code>a</code> becomes considerably large, and you keep adding small things to it, then Shlemiel the painter will manifest himself.</p>

<p>But then again, knowing this has nothing to do with knowing C, just knowing how your language implements things at the low level. (This is where having an experiece in C will help you).</p>
",0
723579,719997,1,"<p>Technically, all of the deficiencies of C would force you to code around them; making you write more code -> making you more experienced in general. Lacking any portable integer bigger than 32-bits, for example, C has, in the past, made me write my own bignum library.</p>

<p>The lack of implicit memory, resource and error management (garbage collection, RAII, automatically-called constructors/destructors, maybe exceptions) force C users to write a lot of initialization, error-handling and cleanup code. It may just be me, but I'm never tired of writing such code. I go and read the documentation of every external function I call, return to my code and check for every return value and other failure-indicative stuff. It even makes me feel safe!</p>

<p>This last point is probably the biggest one to be made in favor of the argument. You can only write so many malloc()/free() pairs before you start to analyze the lifetime of every single variable you come across in every single language! C++'s automatic-storage objects don't help this disorder, either.</p>

<p>Writing truly portable C code often requires the programmer to be free of a lot assumptions about the host system - think sizeof(), CHAR___BITS, unsigned long, UINT_MAX. While this hasn't helped me write better code in other languages, it has helped me think about possible alternate implementations: how a tiny microprocessor could still run my C code, generating a gazillion RISC instructions for my simple one-line statement. (That is another thing; not many other languages map to and from a given assembly language so easily in my head. Then again, that may just be me.)</p>

<p>Of course, none of these arguments go only for C. @S.Lott has a valid point - Fortran might be an equally good alternative. But there is so much C code around! A whole personal computer system from top to bottom -applications to libraries to drivers to kernel- is available in source code in C. It would be such a waste if you could not read it.</p>
",0
723602,719997,0,"<p>In Python, say you have a function </p>

<pre><code>def foo(l=[])
  l.append(""bar"")
  return l;
</code></pre>

<p>On some version of Python, available about a year ago, running foo() for times, you'd get a really interesting result (i.e. <code>[""bar"",""bar"",""bar"",""bar]</code>).</p>

<p>It seems that someone implemented the default parameters as a static variable (and without resetting it), so unexpected results happen.</p>

<p>Perhaps my example was contrived - a friend of mine who actually likes Python found this peculiar bug, but the fact of the matter is all of these languages are implemented in C or C++. Not knowing and not understanding concepts that are fundamental to the base language means that you won't have an in-depth understanding of languages that are built on top of that.</p>

<p>I find all the ""why bother with C/C++/ASM question silly"". If you're inclined enough to learn a language, that means that you're curious enough to get into it the first place. Why stop at just before C?</p>
",0
723628,719997,0,"<p>Knowing C is great because it does nothing behind your back (GC, bounds checking, etc.). It only does exactly what you tell it too. Nothing is implied. Even C++ does things you don't tell it too with RAII (of course, it is implied that the object is destructed when it goes out of scope, but you don't actually write that). C is a great way to learn what goes on 'under the hood' of the computer, without having to write assembly.</p>
",0
723633,719997,2,"<p><b>As someone who knows a little C, but loves to write code in perl and other high-level languages, I have never once come across a problem that I was able to solve by writing C.</p>

<p>I am looking for examples of real-world situations where knowing C would be useful while writing a project in a high-level/dynamic language like perl or python.</b></p>

<p>It's easy to start writing high level code and then wonder we it's running slow. The truth is there are many ways to write perl or python code, and some are better (as in more efficient) than the others. If you know the low level details of how your code is executed in perl or python (both of which are written in C) you can code around several inefficiencies --like knowing which looping construct is faster, how memory is retained/released, etc.</p>

<p>Also, when writing a project in perl or python you sometimes hit a performance wall. The creators of the language (Guido, at least) advocate that you implement that part in C, as a language extension. To do that, well, you'll have to know C.</p>

<p>So, there.</p>
",0
723662,719997,0,"<p>inefficient code (eg loops of string+=) are typically inefficient in any language.  what difference does it make if someone explains why it is inefficient in one language or the other?  knowing C, but not realizing that a method is inefficient, is no different than knowing python and not realizing the same.</p>
",0
723692,719997,2,"<p>For the purposes of argument, suppose you wanted to concatenate the string representations of all the integers from 1 to <em>n</em> (e.g. <em>n</em> = 5 would produce the string ""12345""). Here's how one might do that na?vely in, say, Java.</p>

<pre><code>String result = """";
for (int i = 1; i &lt;= n; i++) {
    result = result + Integer.toString(i);
}
</code></pre>

<p>If you were to rewrite that code segment (which is quite good-looking in Java) in C as literally as possible, you would get something to make most C programmers cringe in fear:</p>

<pre><code>char *result = malloc(1);
*result = '\0';
for (int i = 1; i &lt;=  n; i++) {
    char *intStr = malloc(11);
    itoa(i, intStr, 10);
    char *tempStr = malloc(/* some large size */);
    strcpy(tempStr, result);
    strcat(tempStr, intStr);
    free(result);
    free(intStr);
    result = tempStr;
}
</code></pre>

<p>Because strings in Java are immutable, <code>Integer.toString</code> creates a dummy string and string concatenation creates a new string instance instead of altering the old one. That's not easy to see from just looking at the Java code. Knowing how said code translates into C is <em>one way</em> of learning exactly how inefficient said code is.</p>
",0
721788,719997,0,"<p>Knowing C is not a requirement to being able to effectively use higher-level languages, but it certainly can help ones general understanding of how computers and software work - I think it's similar to an assertion that knowing some assembly language or computer architecture/hardware logic (and/or/nand gates, etc) can help a C programmer be a better programmer.</p>

<p>Sometimes in order to solve a problem it helps to know how things are working 'underneath' what you're doing.</p>

<p>I don't think this means a programmer <em>must</em> know C in order to be a good programmer, but I think that knowing C can be helpful to almost any programmer.</p>
",0
735637,719997,1,"<p>I think it is worth knowing <em>some</em> low-level language, and there are <em>pragmatic</em> reasons to choose C:</p>

<ul>
<li>It's low-level, close to assembler</li>
<li>It's widespread</li>
</ul>

<p>Understanding the whole stack is valuable.  Sometimes you need to debug something's guts.  Sometimes you cannot fix a performance problem without low-level knowledge (this is often <em>not</em> the case, e.g., when the performance problem is purely algorithmic, but <em>sometimes</em> it is).</p>

<p>Why is <em>C</em> widely considered the quintessential ""bottom of the stack"", and not some other language(s)?  I think this because C is a low-level programming language, <em>and</em> <strong>C won</strong>.  It has been a while now, but C was not always as dominant.  To take just one famous example, the proponents of Common Lisp (which had its own ways of writing low-level code) were hoping their language would be popular, too, and eventually <a href=""http://www.jwz.org/doc/worse-is-better.html"" rel=""nofollow noreferrer"">lost</a>.</p>

<p>The following are usually implemented in C:</p>

<ul>
<li>operating systems (Unix variants, Windows, many embedded operating systems)</li>
<li>higher-level programming languages (many popular implementations of Java, Python, etc)</li>
<li>(obviously) reams of popular open source projects</li>
</ul>

<p>I'm not a hardware person, but I gather that C has influenced CPU design heavily, too.</p>

<p>So if you believe in understanding the whole stack, learning C is, from a pragmatic perspective, the best choice.</p>

<p>As a caveat, I think it's worth learning assembler, as well.  Although C is close to the metal, I didn't fully understand C until I had to do some assembler.  It is occasionally helpful to understand how functions calls are actually performed, how <code>for</code> loops are implemented, etc.  Less important, but also useful, is having to (at least once) deal with a system without virtual memory.  When using C on Windows, Unix, and certain other operating systems, even humble <code>malloc</code> does a lot of work under the covers that is easier to appreciate, debug and/or tune if you've ever had to deal with manually locking and unlocking memory regions (not that I would recommend doing so on a regular basis!)</p>
",0
952865,952850,3,"<p>You can use a width (i.e. ""%9s"") to restrict the size of the string. For example, see <a href=""http://msdn.microsoft.com/en-us/library/kwwtf9ch(VS.80).aspx"" rel=""nofollow noreferrer"">Microsoft's documentation</a>.</p>

<p>Using a pointer without initializing it to anything is a sure way to get your program to crash, or otherwise behave badly.</p>
",3
952873,952850,1,"<p>When the first string is too long, you run into a problem of a <a href=""http://en.wikipedia.org/wiki/Buffer_overrun"" rel=""nofollow noreferrer"">buffer overflow.</a></p>

<p>As for the second part of your question, if you do not use malloc, then then it will be pointing to garbage memory.  Its possible that the string will stay there for a while, but its not guaranteed, and if that memory segment is used by something else you will lose your string.</p>
",0
953198,952850,2,"<p>If you are using glibc, you can solve both issues in one shot - use <code>%as</code> format specifier.</p>

<p>It will automatically allocate string big enough to hold the content.</p>

<p>Like this:</p>

<pre><code>char *first, *second;

scanf(fp, ""%as %as\n"", first, second);
</code></pre>

<p><strong>Note: This is GNU extension!</strong></p>
",0
1918940,1918934,4,"<p>It's not present in any older header files (except certain specific areas, like Kerberos and networking headers), and not a built-in type in any compiler I know of.</p>
",0
1918960,1918934,15,"<p>The string <code>u_char</code> does not appear in this draft of the C standard:</p>

<p><a href=""http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf"" rel=""noreferrer"">http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1256.pdf</a></p>

<p>It's not required by POSIX either, as far as I know.</p>

<p>I think it's in BSD (sys/types.h), and Windows (winsock.h). I would not consider either one to be ""a standard"" - they aren't formal standards, and they certainly aren't part of standard C, but they are clearly defined and documented.</p>
",3
1921519,1918934,9,"<p>No, <code>u_char</code> is non-standard.  If you need to use a standard type that's equivalent to <code>u_char</code>, you can use <code>uint8_t</code> which is part of the C99 standard library (check your specific platforms/compilers for C99-compliance).  <code>stdint.h</code> defines this type (along with many other specific integral types).  <a href=""http://en.wikipedia.org/wiki/Stdint.h"" rel=""noreferrer"">This Wikipedia article contains more information about <code>stdint.h</code>.</a></p>
",0
1779223,1779189,3,"<p>Well, you cannot really <em>implement</em> exceptions in C since they are not supported by the language.  The best you can do is <em>emulate</em> them using <code>setjmp</code> and <code>longjmp</code> and some diabolically clever macros.</p>

<p>A quick search turns up these links that may be useful to you:</p>

<ul>
<li><a href=""http://adomas.org/excc/"" rel=""nofollow noreferrer"">Exceptions in C</a></li>
<li><a href=""http://www.swig.org/Doc1.1/HTML/Exceptions.html#n3"" rel=""nofollow noreferrer"">Exception handling with longjmp()</a></li>
</ul>
",9
1779232,1779189,4,"<p>For nesting: a stack-frame of current try/catch blocks.</p>

<p>Your try will be using setjmp to save to a jmpbuffer (I guess). If you've done a try, and hence are now in the scope of a try block and hit another try then you want to preserve the existing jmpbuffer and also create a new one - Push - and when catching you are longjmp-ing back to the point of the most recent try hence you Pop the latest jmpbuffer. So I think a stack-like model make sense for nested try/catch.</p>

<p>For implementation, I guess the simplest apporach is to reserve an array of jmpbuffers, hence limiting your try catch depth - but keeping it simple; Push and Pop just require you to track the index in that array.</p>

<p>For messages and other exception contents, a reserved area for ""currentException"".</p>

<p>Exception content. Keep it simple, define an Exception struct. A char array and an int. Keeping it simple, but not too simple, reserve an array of them so that you can support chaining.</p>

<p>For a throw you allow</p>

<pre><code> throw  ( ""string"", errcode )
</code></pre>

<p>Which simply zeros the array structure and makes one entry. And </p>

<pre><code> catch ( exception )
</code></pre>

<p>Now can look in the array and finds the first entry, and then</p>

<pre><code> throwChain ( ""string"", errcode)
</code></pre>

<p>Which adds the new exception to the array (if there is room, and if not can shuffle the array according some rule such as FIFO)</p>

<p>But, I've got to ask, why not just use C++?</p>
",2
1779912,1779189,5,"<p>Dave Hanson has already done a <a href=""http://code.google.com/p/cii/source/browse/trunk/include/except.h"" rel=""noreferrer"">really nice package of exception macros</a> as part of his excellent book <a href=""http://www.cs.princeton.edu/software/cii"" rel=""noreferrer""><em>C Interfaces and Implementations</em></a>.  You could either use the code wholesale or learn from his techniques.  For anyone who does a fair amount of C programming, the book is worth buying&mdash;it will change the way you change about C&nbsp;programming, and it will show you how to do object-oriented design in&nbsp;C.</p>
",0
1313689,1313485,2,"<p>If you can't use a debugger I would suggest adding print statements inside both functions showing what size equals and then after running the program examine the output. Usually when looking at the print log the problem is pretty obvious.</p>
",0
1313840,1313485,0,"<p>There's nothing obviously wrong with the code you posted, so this suggests there's something wrong with the code you snipped, or in the way you're calling the code. You'll have to debug this for yourself. There are two main debugging techniques that would help you at this point:</p>

<p>As @KPexEA suggested, debugging using printf() or other logging statements. Put a printf() at the beginning and end of both functions, printing out as much state as you think might possibly be useful.</p>

<pre><code>int enqueue()
{
     printf(""enqueue(): Enter: size=%d\n"", size);
     if( size == MAX ) {
         printf(""enqueue(): Exit: QUEUE_FULL\n"");
         return QUEUE_FULL;
     }
     /* snip the actual queue handling */
     size++;
     printf(""enqueue(): Exit: size=%d\n"", size);
     return 0;
}

int dequeue()
{
     printf(""dequeue(): Enter: size=%d\n"", size);
     if(!size) {
     printf(""dequeue(): QUEUE_EMPTY\n"");
         return QUEUE_EMPTY;
     }

     /* snip actual queue handling */
     if(size)
         size--;
     printf(""dequeue(): Exit: size=%d\n"", size);
     return 0;
}
</code></pre>

<p>By examining the output, it should become apparent what's happening with the size of your queue. (You could also count the actual number of elements in your queue and print that when you enter and exit your functions.)</p>

<p>The other technique is interactive debugging. This is especially useful to determine exactly how your code is flowing, but you have to sit there every time you run your program to watch how it's running. (If your bug occurs every time, that's easy; if it occurs every once and a while, it's hard to go back and recreate your program's flow after the fact.) Set a breakpoint at the beginning of each of your functions and use the debugger to display the value <code>size</code>. Set another breakpoint at the end of each function and make sure (1) the breakpoint actually gets hit, and (2) your expectations of any changes made to <code>size</code> are met.</p>
",0
1313549,1313485,0,"<p>The easiest solution is not to call ""enqueue"" if size==MAX.</p>

<p>But if that's not possible try this:</p>

<pre><code>int size=0;
int overflow=0;

int enqueue()
{
     if( size &lt; MAX )
         size++;
     else
         overflow++;
     return 0;
}

int dequeue()
{
     if(overflow)
         overflow--;
     else if(size)
         size--;
     return 0;
}
</code></pre>
",0
1703771,1703741,10,"<p>Return codes are interpreted as unsigned integers with the range 0-255 by the shell.</p>
",3
1703784,1703741,0,"<p>I assume xcode treat the exit status as 00-FF (0-255) and -6 = 250 in that case</p>
",0
1703787,1703741,2,"<p>In Unix, the return value from a program is limited to the range 0-255 (yes, the return type from main is int, but that's a historical anomaly).  Check out this GNU documentation on <a href=""http://www.gnu.org/s/libc/manual/html_node/Exit-Status.html"" rel=""nofollow noreferrer"">exit status</a>.</p>

<p>As for the message ""The Debugger has exited with status 250"" being displayed twice, that is coming from the process that is running your command and so you have no control over it.</p>
",0
1703818,1703741,0,"<p>Check the <a href=""http://developer.apple.com/mac/library/documentation/Darwin/Reference/ManPages/man3/exit.3.html"" rel=""nofollow noreferrer"">man page</a> on <code>exit()</code> and <code>_Exit()</code>:</p>

<blockquote>
  <p>Both functions make the low-order eight
  bits of the status argument available
  to a parent process [...]</p>
</blockquote>
",0
1703927,1703741,0,"<p>The wrap under (as you describe it) is a result of failing to output a LF (line feed) character as part of your call to printf().  You can fix that by adding <strong>\n</strong> to the print format string.  Change your code to this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (int argc, const char * argv[]) { 
    int myInt;
    myInt = 2; 
    myInt *= ( (3*4) / 2 ) - 9; 
    printf(""myInt = %d\n"", myInt);
    return myInt; 
}
</code></pre>

<p>As for doubling 'The Debugger has exited with status 250.' that's a function of your IDE / debugger, and not the result of your code.  As others explained, -6 = 0xFFFFFFFA, which when truncated to 8 bits and treated as unsigned, equals 250 in decimal.</p>
",0
1703945,1703741,0,"<p>Your return code for main should be 0 unless in error. This is a common convention in unix and doesn't hurt anything in windows. <a href=""http://en.wikipedia.org/wiki/Main_function_%28programming%29"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Main_function_%28programming%29</a></p>
",0
1707308,1703741,0,"<p>-6 is represented as 2's compliment of 6 in binary in order to store it into memory.</p>
",0
68003,67790,0,"<p>Short answer: no. You can, however, create your own method for doing so, i.e. providing a specification for how to create such a struct. However, it's generally not necessary and is not worth the effort; just pass by reference. (<code>callFuncWithInputThenOutput(input, &amp;struct.output);</code>)</p>
",0
67809,67790,0,"<p>One way to do this is to have a type field as the first byte of the structure.  Your receiving function looks at this byte and then casts the pointer to the correct type based on what it discovers.  Another approach is to pass the type information as a separate parameter to each function that needs it. </p>
",0
67824,67790,3,"<p>Since structures are nothing more than predefined blocks of memory, you can do this.  You could pass a void * to the structure, and an integer or something to define the type.</p>

<p>From there, the <em>safest</em> thing to do would be to recast the void * into a pointer of the appropriate type before accessing the data.</p>

<p>You'll need to be very, very careful, as you lose type-safety when you cast to a void * and you can likely end up with a difficult to debug runtime error when doing something like this.</p>
",0
67838,67790,-1,"<p>I'm a little rusty on c, but try using a void* pointer as the variable type in the function parameter.  Then pass the address of the structure to the function, and then use it he way that you would.</p>

<pre><code>void foo(void* obj);

void main()
{
  struct bla obj;
  ...
  foo(&amp;obj);
  ...
}

void foo(void* obj)
{
  printf(obj -&gt; x, ""%s"")
}
</code></pre>
",2
67842,67790,7,"<p>If you ensure that the field is placed in the same place in each such structure, you can simply cast a pointer to get at the field. This technique is used in lots of low level system libraries e.g. BSD sockets.</p>

<pre><code>struct person {
  int index;
};

struct clown {
  int index;
  char *hat;
};

/* we're not going to define a firetruck here */
struct firetruck;


struct fireman {
  int index;
  struct firetruck *truck;
};

int getindexof(struct person *who)
{
  return who-&gt;index;
}

int main(int argc, char *argv[])
{
  struct fireman sam;
  /* somehow sam gets initialised */
  sam.index = 5;

  int index = getindexof((struct person *) &amp;sam);
  printf(""Sam's index is %d\n"", index);

  return 0;
}
</code></pre>

<p>You lose type safety by doing this, but it's a valuable technique.</p>

<p>[ I have now actually tested the above code and fixed the various minor errors. It's much easier when you have a compiler. ]</p>
",3
67903,67790,0,"<p>You can do this with a parameterized macro but most coding policies will frown on that.</p>

<pre><code>
#include 
#define getfield(s, name) ((s).name)

typedef struct{
  int x;
}Bob;

typedef struct{
  int y;
}Fred;

int main(int argc, char**argv){
    Bob b;
    b.x=6;

    Fred f;
    f.y=7;

    printf(""%d, %d\n"", getfield(b, x), getfield(f, y));
}
</code></pre>
",0
81113,67790,1,"<p>I think you should look at the C standard functions qsort() and bsearch() for inspiration.  These are general purpose code to sort arrays and to search for data in a pre-sorted array.  They work on any type of data structure - but you pass them a pointer to a helper function that does the comparisons.  The helper function knows the details of the structure, and therefore does the comparison correctly.</p>

<p>In fact, since you are wanting to do searches, it may be that all you need is bsearch(), though if you are building the data structures on the fly, you may decide you need a different structure than a sorted list.  (You can use sorted lists -- it just tends to slow things down compared with, say, a heap.  However, you'd need a general heap_search() function, and a heap_insert() function, to do the job properly, and such functions are not standardized in C.   Searching the web shows such functions exist - not by that name; just do not try ""c heap search"" since it is assumed you meant ""cheap search"" and you get tons of junk!)</p>
",0
96369,67790,1,"<p>If the ID field you test is part of a common initial sequence of fields shared by all the structs, then using a union guarantees that the access will work:</p>

<pre><code>#include &lt;stdio.h&gt;

typedef struct
{
    int id;
    int junk1;
} Foo;

typedef struct
{
    int id;
    long junk2;
} Bar;

typedef union
{
    struct
    {
        int id;
    } common;

    Foo foo;
    Bar bar;
} U;

int matches(const U *candidate, int wanted)
{
    return candidate-&gt;common.id == wanted;
}

int main(void)
{
    Foo f = { 23, 0 };
    Bar b = { 42, 0 };

    U fu;
    U bu;

    fu.foo = f;
    bu.bar = b;

    puts(matches(&amp;fu, 23) ? ""true"" : ""false"");
    puts(matches(&amp;bu, 42) ? ""true"" : ""false"");

    return 0;
}
</code></pre>

<p>If you're unlucky, and the field appears at different offsets in the various structs, you can add an offset parameter to your function.  Then, offsetof and a wrapper macro simulate what the OP asked for - passing the type of struct at the call site:</p>

<pre><code>#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;

typedef struct
{
    int id;
    int junk1;
} Foo;

typedef struct
{
    int junk2;
    int id;
} Bar;

int matches(const void* candidate, size_t idOffset, int wanted)
{
    return *(int*)((const unsigned char*)candidate + idOffset) == wanted;
}

#define MATCHES(type, candidate, wanted) matches(candidate, offsetof(type, id), wanted)

int main(void)
{
    Foo f = { 23, 0 };
    Bar b = { 0, 42 };
    puts(MATCHES(Foo, &amp;f, 23) ? ""true"" : ""false"");
    puts(MATCHES(Bar, &amp;b, 42) ? ""true"" : ""false"");

    return 0;
}
</code></pre>
",0
743655,743647,0,"<p>You can use system() to run command line instructions. So something like</p>

<pre><code>system(""ping 127.0.0.1"") 
</code></pre>

<p>should work.</p>
",2
743716,743647,2,"<p>Highly useful and open source - <a href=""http://fping.sourceforge.net/"" rel=""nofollow noreferrer"">fping</a>.</p>
<blockquote>
<p>fping is a ping(1) like program which uses the Internet Control Message Protocol (ICMP) echo request to determine if a host is up. fping is different from ping in that you can specify any number of hosts on the command line, or specify a file containing the lists of hosts to ping. Instead of trying one host until it timeouts or replies, fping will send out a ping packet and move on to the next host in a round-robin fashion. If a host replies, it is noted and removed from the list of hosts to check. If a host does not respond within a certain time limit and/or retry limit it will be considered unreachable.</p>
<p>Unlike ping, fping is meant to be used in scripts and its output is easy to parse.</p>
</blockquote>
",0
1306825,1306789,0,"<p>Some code:</p>

<pre><code>signed int first, second;
unsigned int result;

first = obtain(); // happens to be 1
second = obtain(); // happens to be -5
result = first + second; // unexpected result here - very large number - and it's too late to check that there's a problem
</code></pre>

<p>Say you obtained those values from keyboard. You need to check before addition that the result can be represented in unsigned int. That's what the article talks about.</p>
",2
1306798,1306789,5,"<p>Try assigning it to a unsigned int, not an int.</p>

<p>The term <code>unsigned int</code> is the key - by default an int datatype will hold negative and positive numbers; however, unsigned ints are <strong>always</strong> positive. They provide this option because uints can technically hold greater positive values than regular signed ints because they do not need to use a bit to keep track of whether or not its negative or positive.</p>

<p>Please see:</p>

<p><a href=""https://stackoverflow.com/questions/247873/signed-versus-unsigned-integers"">Signed versus Unsigned Integers</a></p>
",0
1306801,1306789,0,"<p><strong><em>By definition</em></strong> the number <code>-4</code> cannot be represented in an <code>unsigned int</code>.  <code>-4</code> is a signed integer.  The same goes for any negative number.</p>

<p>When you assign a negative integer to an <code>unsigned int</code> the actual bits of the number do not change, but they are merely <em>represented</em> differently.  You'll get some ridiculously-large number due to the way integers are represented in binary <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow noreferrer"">(two's complement)</a>.</p>

<p>In two's complement, <code>-4</code> is represented as <code>0xfffffffc</code>.  When <code>0xfffffffc</code> is represented as an <code>unsigned int</code> you'll get the number <code>4,294,967,292</code>.</p>
",4
1306803,1306789,2,"<p>The problem is that you're storing -4 in an <em>unsigned</em> int.  Unsigned ints can only contain zero and positive values. If you assign -4 to one, you'll actually end up getting a very large positive number (the actual value depends on how wide an int you're using).</p>
",0
1306808,1306789,0,"<p>Unsigned variables, like unsigned int, cannot hold negative values. So assigning 1 - 5 to an unsigned int won't give you -4. I'm not sure what it'll give you, it's probably compiler specific.</p>
",0
1306810,1306789,2,"<p>The problem is that the sizes of storage such as <code>unsigned int</code> can only hold so much. With 1 and -5 it does not matter, but with 1 and -500000000 you might end up with a confusing result.  Also, <code>unsigned</code> storage will interpret anything stored in it as positive, so you cannot put a negative value in an <code>unsigned</code> variable.</p>

<p>Two big things to watch out for:<br />
1. Overflow in the operation itself: <code>1 + -500000000</code><br />
2. Issues in casting: <code>(unsigned int)(1 + -500)</code></p>
",0
1307603,1306789,6,"<p>The binary representation of -4, in a 32-bit word, is as follows (hex notation)</p>

<pre><code>0xfffffffc
</code></pre>

<p>When interpreted as an <em>unsigned</em> integer, this bit pattern represents the number <i>2**32-4</i>, or 18446744073709551612.  I'm not sure I would call this phenomenon ""overflow"", but it is a <b>common mistake</b> to assign a small negative integer to a variable of unsigned type and wind up with a really big positive integer.</p>

<p>This trick is actually exploited for bounds checking: if you have a signed integer <code>i</code> and want to know if it is in the range 0 &lt;= i &lt; n, you can test</p>

<pre><code>if ((unsigned)i &lt; n) { ... }
</code></pre>

<p>which gives you the answer using one comparison instead of two.  The cast to unsigned has no run-time cost; it just tells the compiler to generate an unsigned comparison instead of a signed comparison.</p>
",0
1308715,1306789,0,"<p>You have to remember that fundamentally you're working with bits.  So you can assign a value of -4 to an unsigned integer and this will place a series of bits into that memory location.  Those bits can be interpreted as -4 <em>in certain circumstances</em>.  One such circumstance is the obvious one: you've told the compiler/system that the bits in that memory location should be interpreted as a two's compliment signed number.  So if you do printf(""%s"",i) prtinf does its magic and converts the two's compliment number to a magnitude and sign.  The magnitude will be 4 and the sign will be negative, so it displays '-4'.  </p>

<p>However, if you tell the compiler that the data at that memory location is not signed then <em>the bits don't change</em> but instead <em>their interpretation</em> does.  So when you do your addition, store the result in an unsigned integer memory location and then call printf on the result it doesn't bother looking for the sign because by definition it is always positive.  It calculates the magnitude and prints it.  The magnitude will be off because the sign information is still encoded in the bits but it's treated as magnitude information.  </p>
",0
1319455,1319443,3,"<p>Here's the answers:</p>

<ol>
<li><p>Java has had a bad reputation among some hardcore C programmers mainly because they think:</p>

<ul>
<li>it's ""too easy"" (no memory-management, segfaults)</li>
<li>""can't be used for serious work""</li>
<li>""just for the web"" or,</li>
<li>""slow"".</li>
</ul>

<p>Java is hardly the easiest language in the world these days, compared to some lanmguages like Python, etc. </p>

<p>It is used in many desktop apps - applets aren't even used that often. Finally, Java will <em>always</em> be slower than C, because it is not compiled directly to machine code. Sometimes, though, extreme speed isn't needed. Anyway, the JVM isn't the slowest language VM ever.</p></li>
<li><p>When you're working in C, there aren't abstract classes. </p>

<p>All a header file does is contain code which is pasted into other files. The main reason you put it in a header file is so that it is at the top of the file - this way, you don't need to care where you put your functions in the actual implementation file. </p>

<p>While you can kind-of use OO concepts in C, it doesn't have built-in support for classes and similar fundamentals of OO. It is nigh-impossible to implement inheritance in plain C, therefore there can never <em>actually</em> have OO, or abstract classes for that matter. I would suggest sticking to plain old <code>struct</code>s. </p>

<p>If it makes it easier for you to learn, by all means think of them as abstract classes (with the implementation file being the inheriting class) - but IMHO it is a difficult mindset to use when for working in a language without explicit support of said features. </p>

<p>I'm not sure if Java has them, but I think a closer analogue could be partial classes in C#.</p></li>
</ol>
",12
1319456,1319443,2,"<p>If you forward declare something, you have to actually deliver and implement it, else the compiler will complain. The header allows you to display a ""module""'s public API and make the declarations available (for type checking and so) to other parts of the program.</p>
",3
1319460,1319443,4,"<ol>
<li><p>IMO it's mainly because many C programmers seem to think that Java programmers don't know how to program ¡°for real¡±, e.g. handling pointers, memory and so on.</p></li>
<li><p>I would rather compare headers to Java interfaces, in the sense that they generally define how the API must be used.
Headers are basically just a way to avoid copy-pasting: the preprocessor simply includes the content of the header in the source file when encounters an <code>#include</code> directive.
You put in a header every declaration that the user will commonly use.</p></li>
</ol>
",1
1319466,1319443,1,"<ol>
<li><p>I think that there is much derision (mockery, laughter, contempt, ridicule) for Java simply because it's popular.</p></li>
<li><p>Abstract classes and interfaces specify a contract or a set of functions that can be invoked on an object of a certain type. Function prototypes in C only really do compile time type checking of function arguments/return values.</p></li>
</ol>
",0
1319467,1319443,1,"<p>While your first question seems subjective to me, I will answer to the second one:</p>

<p>A header file contains the declarations which are then made available to other files via #inclusion by the preprocessor.
For instance you will declare in a header a function, and you will implement in a .c file. Other files will be able to use the function so long they can see the declaration (by including the header file).
At linking time the linker will look among the object files, or the various libraries linked, for some object which provides the code for the function.</p>

<p>A typical pattern is: you distribute the header files for your library, and a dll (for instance) which contains the object code. Then in your application you include the header, and the compiler will be able to compile because it will find the declaration in the header. No need to provide the actual implementation of the code, which will be available for the linker through the dll.</p>
",0
1319474,1319443,1,"<ol>
<li><p>C programs run directy, while Java programs run inside the JVM, so a common belief is that Java programs are slow. Also in Java you are hidden from some low level constructs (pointer, direct memory access), memory management, etc...</p>
</li>
<li><p>In C the declaration and definition of a function is separated. Declaration &quot;declares&quot; that there exists a function that called by those arguments returns something. Definition &quot;defines&quot; what the function actually does. The former is done in header files, the latter in the actual code. When you are compiling your code, you must use the header files to tell your compiler that there is such a function, and link in a binary that contains the binary code for the function.</p>
<p>In Java, the binary code itself also contains the declaration of the functions, so it is enough for the compiler to look at the class files to get both the definition and declaration of the available functions.</p>
</li>
</ol>
",0
1319486,1319443,2,"<p>Comprehensive reading: <a href=""http://www.comp.lancs.ac.uk/~ss/java2c/diffs.html"" rel=""nofollow noreferrer"">Learning C from Java</a>. Recommended reading for developers who are coming from Java to C.</p>
",0
1319570,1319443,6,"<p>The short answer:</p>

<p>Abstract classes are a concept of object oriented programming. Header files are a necessity due to the way that the C language is constructed. It cannot be compared in any way</p>

<p>The long answer</p>

<p>To understand the header file, and the need for header files, you must understand the concepts of ""declaration"" and ""definition"". In C and C++, a declaration means, that you declare that something exists somewhere, for example a function.</p>

<pre><code>void Test(int i);
</code></pre>

<p>We have now declared, that somewhere in the program, there exists a function Test, that takes a single int parameter. When you have a definition, you define what it is:</p>

<pre><code>void Test(int i)
{
    ...
}
</code></pre>

<p>Here we have defined what the function void Test(int) actually is. </p>

<p>Global variables are declared using the extern keyword</p>

<pre><code>extern int i;
</code></pre>

<p>They are defined without the extern keyword</p>

<pre><code>int i;
</code></pre>

<p>When you compile a C program, you compile each source file (.c file) into an .obj file. Definitions will be compiled into the .obj file as actual code. When all these have been compiled, they are linked to the final executable. Therefore, a function should only be defined on one .c file, otherwise, the same function will end up multiple times in the executable. This is not really critical if the function definitions are identical. It is more problematic if a global variable is linked into the same executable twice. That will leave half the code to use the one instance, and the other half of the code to use the other instance.</p>

<p>But functions defined in one .c file cannot see functions defined in another .c files. So if from file1.c file you need to access function Test(int) defined in file2.c, you need to have a declaration of Test(int) present when compiling file1.c. When file1.c is compiled into file1.obj, the resulting .obj file will contain information that it needs Test(int) to be defined somewhere. When the program is linked, the linker will identify that file2.obj contains the function that file1.obj depends on. 
If there is no .obj file containing the definition for this function, you will get a linker error, not a compiler error (linker errors are considerably more difficult to find and correct that compiler errors because you get no filename and line number for the resulting file)</p>

<p>So you use the header file to store declarations for the definitions stored in the corresponding source file.</p>
",0
1301665,1301586,5,"<p>I think the short explanation for what you're asking is that using ""&amp;"" essentially means ""a pointer to this""</p>

<pre><code>int value = 0;
int *pointer = &amp;value;
int **doublePointer = &amp;pointer;
</code></pre>
",2
1301614,1301586,15,"<p>Most likely, <code>sqlite3_open</code> is allocating memory for the database handle.  For this reason the function needs a <strong><em>pointer to a pointer</em></strong> to the database handle (<code>sqlite3</code>) so that it can modify the <strong><em>pointer</em></strong> to the database handle.  For example:</p>

<pre><code>typedef struct { /*...*/ } sqlite3;

int sqlite3_open(const char *filename, sqlite3 **ppDb) {
    /* ... */

    // Allocate memory for the database handle.
    *ppDb = (sqlite3 *)malloc(sizeof(sqlite3));

    /* ... */
    return 0;
}
</code></pre>

<p>However, <code>sqlite3_close</code> only needs a single pointer to <code>free</code> the memory:</p>

<pre><code>int sqlite3_close(sqlite3 *pDb) {
    /* ... Cleanup stuff ... */

    free(pDb);

    return 0;
}
</code></pre>
",4
1301617,1301586,4,"<p>A pointer is the address of a variable.</p>

<p>Assuming that <code>database</code> is declared as <code>sqlite3* database;</code>, <code>&amp;database</code> is the address of (or, a pointer to) the <code>database</code> pointer.</p>

<p><code>sqlite3_open</code> takes a pointer to a pointer so that it can set the value that the pointer points to.  It makes a <code>sqlite</code> value, and changes your pointer to point to it.  <code>sqlite3_close</code> doesn't change what the pointer points to, so all it needs is the pointer itself.</p>
",0
1303652,1301586,0,"<p>As usual, the C FAQ List contains relevant information. See <a href=""http://c-faq.com/ptrs/passptrinit.html"" rel=""nofollow noreferrer"">I have a function which accepts, and is supposed to initialize, a pointer:</a> and <a href=""http://c-faq.com/ptrs/passbyref.html"" rel=""nofollow noreferrer"">Does C even have ""pass by reference""?</a>.</p>
",0
1310863,1301586,0,"<p>i don't know what you want to do with sqlite function. But using pointers makes you to keep changes in functions. </p>

<p>When you pass a variable to a function, the variable will be duplicated.</p>

<p>for example</p>

<pre><code>int var1=0;
in *ptr1=&amp;var1;
func(var1, ptr1);
</code></pre>

<p>the value of var1=5</p>

<p>the adress of var1 = 0xff2200 (something like that)</p>

<p>the value of  ptr1 = 0xff2200 (the adress of var1)</p>

<p>the adress of ptr1 = 0xff0022 (something different)</p>

<p>Lets write a function which uses these two var as arg</p>

<pre><code>void func1(int x, int *p){
    x+=5;
    (*p)-=5;
}
</code></pre>

<p>after u use this function;</p>

<pre><code>func(var1, ptr1);
</code></pre>

<p>var1 will not equal to 0!!! ?t will be -5</p>

<p>Because;
in function func1</p>

<p>the value of  x = 0 (the value of var1)</p>

<p>the adress of x = 0xaabbcc (something different then var1!!! this is why x+=5 is not effective on var1. It happens in another part of memory! When u return, this memory will be free again. And you'll lose your changes...)</p>

<p>the adress of p = 0xcccccc (something different too)</p>

<p>the value of  p = 0xff2200 (the value of ptr1 and the adress of var1! This operation will be done in the var1's adress so you will not lose your changes)</p>

<p>?f we have to keep our changes of variables -in functions-, we have to use pointers for those var.
?f our variable keep an adress, it means; it is a pointer. And if we want to keep changes of pointer -in functions- then we have to use pointer to pointer.</p>

<p>This is my first message and i hope this will be helpfull...</p>

<p>And ""pass by reference"" means ""pass by pointer"" other languages don't use pointers. so you have to pass by reference sometimes. But in C, pointers will do its job...</p>
",0
280993,280940,2,"<p>There is no portable way to build up an argument list for a variable argument function in C at run time.  There are a few implementation-dependent <a href=""http://c-faq.com/varargs/wacky.html"" rel=""nofollow noreferrer"">tricks</a> out there, the dyncall library you found looks like a good one and probably more portable than most.</p>
",1
281029,280940,1,"<p>Note: the code is already compiler-dependent (though perhaps not processor-dependent), because the invocation of <code>web_submit_data</code> assumes there that the argument subexpressions in a procedure call are evaluated from left-to-right order, but the C language leaves the order of argument evaluation unspecified.</p>

<p>See for reference: <a href=""http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value</a> </p>

<p>So perhaps the non-portable solution is not going to make things significantly worse for you.</p>
",1
281055,280940,1,"<p>Can you restructure your code so that this isn't necessary?  Perhaps you could take the incoming buffer and make it more deterministic:</p>

<pre><code>struct form_field
{
  char[FIELD_NAME_MAX] name;
  char[FIELD_VALUE_MAX] val;
};

web_submit_data_buffer_gazillion_items( const char *bufferName, const char *bufferValue)
{
    /*
      loop over bufferName somehow, either with a known size or terminating record,
      and build an array of form_field records
    */
    //loop
    {
      // build array of records
    }


    web_submit_data(record_array, array_len);

}
</code></pre>

<p>Sorry this couldn't be more fleshed out - my wife called me in for breakfast. :-)</p>
",0
281603,280940,1,"<p>Note that the code sample you posted has undefined behavior - the commas that separate function parameters are not sequence points (those commas are not the comma operator), so modifying <code>i</code> and or <code>j</code> multiple times in the function call argument list results in undefined behavior.  </p>

<p>This is not to mention that the evaluation order of function call arguments is not specified by the standard - so even if you did the modification of <code>i</code> and <code>j</code> using functions to evaluate the arguments (function calls themselves are sequence points), you would be pretty much passing the pointers in an indeterminate order.</p>

<p>Also, I don't see how <code>web_submit_data()</code> knows how many arguments it's been passed - I don't see a count or a definitive sentinel argument at the end. But I guess your example may be just that - an example that might not have complete, accurate details. On the other hand, it's <code>web_submit_data()</code>'s problem anyway, right? </p>
",0
281153,280940,1,"<p>Write it once with the preprocessor and never look back.</p>

<pre><code>#define WEB_SUBMIT_BUFFER(name, val)         \
    do {                                     \
        const int size = 129;                \
        int i = 0;                           \
        int j = 11;                          \
        web_submit_data(&amp;(name)[i++ * size], \
                        &amp;(name)[i++ * size], \
        /* etc ad nauseum */                 \
    } while (0)
</code></pre>

<p>Or if the number of arguments is fixed for each specific call, write a script to generate preprocessor defines to hide how heinous that call is.</p>

<pre><code>#define WEB_SUBMIT_BUFFER_32(name, val)      \
    do {                                     \
        const int size = 129;                \
        int i = 0;                           \
        int j = 11;                          \
        web_submit_data(&amp;(name)[i++ * size], \
                        &amp;(name)[i++ * size], \
        /* 32 times */                       \
    } while (0)
#define WEB_SUBMIT_BUFFER_33(name, val) ...
#define WEB_SUBMIT_BUFFER_34(name, val) /* etc */
</code></pre>
",1
281731,280940,3,"<p>Since it's generally not a problem to pass <em>more</em> arguments to a function taking variable arguments than the function expects (see footnote #1), you can do something like the following:</p>

<pre><code>// you didn't give a clear specification of what you want/need, so this 
// example may not be quite what you want as I've had to guess at
// some of the specifications. Hopefully the comments will make clear
// what I may have assumed.
//
// NOTE:  while I have compiled this example, I have not tested it,
//        so there is a distinct possiblity of bugs (particularly
//        off-by-one errors). Check me on this stuff, please.

// I made these up so I could compile the example
#define ITEMDATA ((char const*) NULL)
#define ENDITEM  ((char const*) 0xffffffff)

void web_submit_data_wrapper( const char*bufferName, 
                              const char* bufferValue, 
                              size_t headerCount,       // number of header pointers to pass (8 in your example)
                              size_t itemStartIndex,    // index where items start in the buffers (11 in your example)
                              size_t itemCount,         // number of items to pass (unspecified in your example)
                              size_t dataSize )         // size of each header or item (129 in your example)
{
    // kMaxVarArgs would be 3000 or a gazillion in your case

    // size_t const kMaxVarArgs = 20;  // I'd prefer to use this in C++
    #define kMaxVarArgs (20)

    typedef char const* char_ptr_t;
    typedef char_ptr_t char_ptr_array_t[kMaxVarArgs];

    char_ptr_array_t varargs = {0};

    size_t idx = 0;

    // build up the array of pararmeters we'll pass to the variable arg list

    // first the headers
    while (headerCount--) {
        varargs[idx++] = &amp;bufferName[idx * dataSize];
    }

    // mark the end of the header data
    varargs[idx++] = ITEMDATA;

    // now the ""items""
    while (itemCount--) {
        varargs[idx++] = &amp;bufferName[itemStartIndex * dataSize];
        varargs[idx++] = &amp;bufferValue[itemStartIndex * dataSize];
        varargs[idx++] = ENDITEM;

        ++itemStartIndex;
    }

    // the thing after the last item 
    // (I'm not sure what this is from your example)
    varargs[idx] = &amp;bufferName[itemStartIndex * dataSize];

    // now call the target function - the fact that we're passing more arguments
    //  than necessary should not matter due to the way VA_ARGS are handled 
    //  but see the Footnote in the SO answer for a disclaimer

    web_submit_data( 
        varargs[0],
        varargs[1],
        varargs[2],

        //... ad nasuem until

        varargs[kMaxVarArgs-1]
        );

}
</code></pre>

<hr>

<p>Footnote #1:  If you think about how the macros in <code>stdargs.h</code> act this becomes clear.  However, I do not claim that this technique would be standards compliant.  In fact, in recent history the stackoverflow answers I've posted where I;ve made this disclaimer have in fact been found to be non-standards compliant (usually by the ever vigilant <a href=""https://stackoverflow.com/users/34509/litb"">litb</a>).  So use this technique at your own risk, and verify, verify, verify).</p>
",2
283436,280940,9,"<p>In CamelBones I use <a href=""http://sourceware.org/libffi/"" rel=""noreferrer"">libffi</a> to call objc_msgSend(), which is a varargs function. Works a treat.</p>
",2
283458,280940,9,"<p>Variable length arguments are basically just a pointer to a bunch of packed data that is passed to the required function.  It is the responsibility of the called function to interpret this packed data.</p>

<p>The architecture safe way to do this is to use the va_list macros (that n-alexander mentioned), otherwise you may run into issues with how various data types are padded in memory.</p>

<p>The proper way to design varargs functions is to actually have two versions, one that accepts the '...', which in turn extracts the va_list and passes it to a function that takes a va_list.  This way you can dynamically construct the arguments if you need to and can instead call the va_list version of the function.</p>

<p>Most standard IO functions have varargs versions: vprintf for printf, vsprintf for sprintf... you get the idea.  See if your library implements a function named ""vweb_submit_data"" or something to that effect.  If they don't, email them and tell them to fix their library.</p>

<p>3000 lines of the same thing (even if it is preprocessor induced) makes me cringe</p>
",0
283358,280940,1,"<p>There are two way to pass a variable number of arguments: to a function that accepts ""..."" or to a function that accepts va_list.</p>

<p>You can not dynamically define the number of arguments for the ""..."" interface, but you should be able to do so for the va_list one. Google for va_start, va_end, and va_list.</p>
",0
49805,49596,2,"<p>As others have pointed out, """" implies one terminating '\0' character, so ""\0"" actually initializes the array with two null characters.</p>

<p>Some other answerers have implied that this is ""the same"", but that isn't quite right.  There may be no practical difference -- as long the only way the array is used is to reference it as a C string beginning with the first character.  But note that they do indeed result in two different memory initalizations, in particular they differ in whether Str[1] is definitely zero, or is uninitialized (and could be anything, depending on compiler, OS, and other random factors).  There are some uses of the array (perhaps not useful, but still) that would have different behaviors.</p>
",1
49620,49596,23,"<p>Since you already declared the sizes, the two declarations are exactly equal. However, if you do not specify the sizes, you can see that the first declaration makes a larger string:</p>

<pre><code>char a[] = ""a\0"";
char b[] = ""a"";

printf(""%i %i\n"", sizeof(a), sizeof(b));
</code></pre>

<p>prints</p>

<pre><code>3 2
</code></pre>

<p>This is because a ends with two nulls (the explicit one and the implicit one) while b ends only with the implicit one.</p>
",0
49622,49596,0,"<p>Unless I'm mistaken, the first will initialize 2 chars to 0 (the '\0' and the terminator that's always there, and leave the rest untouched, and the last will initialize only 1 char (the terminator).</p>
",1
59445,49596,17,"<p>Well, assuming the two cases are as follows (to avoid compiler errors):</p>

<pre><code>char str1[32] = ""\0"";
char str2[32] = """";
</code></pre>

<p>As people have stated, str1 is initialized with two null characters:</p>

<pre><code>char str1[32] = {'\0','\0'};
char str2[32] = {'\0'};
</code></pre>

<p>However, according to both the C and C++ standard, if part of an array is initialized, then remaining elements of the array are default initialized.  For a character array, the remaining characters are all zero initialized (i.e. null characters), so the arrays are <em>really</em> initialized as:</p>

<pre><code>char str1[32] = {'\0','\0','\0','\0','\0','\0','\0','\0',
                 '\0','\0','\0','\0','\0','\0','\0','\0',
                 '\0','\0','\0','\0','\0','\0','\0','\0',
                 '\0','\0','\0','\0','\0','\0','\0','\0'};
char str2[32] = {'\0','\0','\0','\0','\0','\0','\0','\0',
                 '\0','\0','\0','\0','\0','\0','\0','\0',
                 '\0','\0','\0','\0','\0','\0','\0','\0',
                 '\0','\0','\0','\0','\0','\0','\0','\0'};
</code></pre>

<p>So, in the end, there really is no difference between the two.</p>
",3
821614,821602,2,"<p>I take this is a code snipet, consequently, i guess that you are alredy including string.h</p>

<p>strcpy is defined as:  </p>

<pre><code>  char * strcpy ( char * destination, const char * source );
</code></pre>

<p>In</p>

<pre><code> strcpy(lines[num_righe-1], line);
</code></pre>

<p>lines [num_righe-1] is a char, not a char*</p>

<p>So it should be </p>

<pre><code>strcpy(lines + (num_righe-1), line);
</code></pre>

<p>As munificent wrote, it looks like you are trying to make lines an array of strings. If so, your definition of lines is wrong.</p>

<p>Also, dont forget, you should check that realloc doesn't return NULL.</p>

<pre><code>lines = realloc(lines, (sizeof(char)*LINE_SIZE)*num_righe);

if (!lines) //MUST HANDLE NULL POINTER!!

/* string copy code here*/
</code></pre>
",4
821617,821602,1,"<p><code>lines</code> is a pointer to a character, i.e. a single string. You want it to be an array of strings. For that, it should be <code>char **lines;</code></p>
",0
821619,821602,1,"<p>You can use fscanf instead to do what you want.</p>

<pre><code>fscanf(f, ""%s\n"", line[index]);
index++;
</code></pre>
",0
821645,821602,5,"<p>Try:</p>

<pre><code>FILE *f;
char line[LINE_SIZE];
char **lines = NULL;
int num_righe = 0;

f = fopen(""spese.dat"", ""r"");

if(f == NULL) {
        f = fopen(""spese.dat"", ""w"");
}

while(fgets(line, LINE_SIZE, f)) {              
        num_righe++;
        lines = (char**)realloc(lines, sizeof(char*)*num_righe);
        lines[num_righe-1] = strdup(line);
}

fclose(f);
</code></pre>
",5
51566,51561,4,"<p>You can use <a href=""http://www.gimpel.com/"" rel=""nofollow noreferrer"">PC-Lint/FlexeLint</a> to do that.</p>

<p>Unusually there isn't a free OS version of the tool available.</p>

<p>You can remove #includes by passing by reference instead of passing by value and forward declaring. This is because the compiler doesn't need to know the size of the object at compile time. This will require a large amount of manual work on your behalf however. The good thing is it will reduce your compile times.</p>
",3
51639,51561,3,"<p>You could just write a 'brute force' command line tool that comments out the #includes one by one and tests whether the compile still works. Let me know when you've got it to work. ;0)</p>
",0
51677,51561,2,"<p><a href=""http://gamesfromwithin.com/physical-structure-and-c-part-1-a-first-look"" rel=""nofollow noreferrer"">This article</a> explains a technique of #include removing by using the parsing of Doxygen. That's just a perl script, so it's quite easy to use.</p>
",0
1622217,1622210,17,"<p>You are initialising the array with <em>characters</em>, and what is stored in the array are the ASCII values of those characters.</p>

<p>You can print the character values using something like this:</p>

<pre><code>for (int i = 0; i &lt; sizeof(testArray)/sizeof(testArray[0]); i++) {
    printf(""character '%c', ASCII value %d\n"", testArray[i], testArray[i]);
}
</code></pre>

<p>The first value printed with <code>%c</code> interprets the number as the ASCII value of the <em>character</em> to print. The same value printed with <code>%d</code> prints the number itself.</p>
",0
1622218,1622210,4,"<p>Because those are the ASCII codes for the number characters. To have a string array you have to do something like this:</p>

<pre><code>char *testArray[] = { ""1"", ""2"", ""3"", ""4"", ""5"" };
</code></pre>
",0
1622222,1622210,1,"<p>because 49, 50, 51 are the <a href=""http://www.asciitable.com/"" rel=""nofollow noreferrer"">ASCII codes</a> for 1,2,3...
You're initializing an array of characters, not strings</p>
",0
1622225,1622210,1,"<p>Because chars are actually stored as their corresponding value in ASCII.</p>

<p>You can declare your string as follows:</p>

<pre><code>char * myString = ""String"";
</code></pre>
",1
1622226,1622210,2,"<p>If you wanted an array of numeric values, it should have been initialized as <code>{1,2,3,4,5}</code>. Putting the numerals in single quotes means they are characters, and the 49, 50, 51,... you are seeing are the ASCII codes for the characters '1', '2', '3', '4'.  </p>
",0
1482384,1482378,6,"<p>How does your variable contain a number that is greater than 2^32 - 1? Short answer: It'll probably be a specific data-structure and assorted functions (oh, a class?) that deal with this.</p>

<p>Given this data structure, how do we print it? With <code>BigInteger_Print(BigInteger*)</code> of course :)</p>

<p>Really though, there is no correct answer to this, as printing a number larger than 2^32-1 depends entirely upon how you're storing that number.</p>
",0
1482386,1482378,1,"<p>If you are talking about int64 types, you can try %I64u, %I64d, %I64x, %llu, %lld</p>
",1
1482409,1482378,1,"<p>On common hardware, the largest <code>float</code> is (2^128 - 2^104), so if it's smaller than that, you just use <code>%f</code> (or <code>%g</code> or <code>%a</code>) with printf( ).</p>

<p>For <code>int64</code> types, JustJeff's answer is spot on.</p>

<p>The range of <code>double</code> (<code>%f</code>) extends to nearly 2^1024, which is really quite huge; on Intel hardware, when the <code>long double</code> (<code>%Lf</code>) type corresponds to 80-bit float, the range of that type goes up to 2^16384.</p>

<p>If you need larger numbers than that, you need to use a library (which will likely have its own print routines) or roll your own representation and provide your own printing support.</p>
",5
1482447,1482378,2,"<p>More theoretically: suppose you have a very very very large number stored somewhere somehow; if so, I suppose that you are somehow able to do math on that number, otherwise it would be quite pointless storing it.</p>

<p>If you can do math on it, just divide the bignumber by ten (10); store the remainder somewhere. Repeat until the result is smaller than 10. When it's smaller than ten, print it, then print the remainders, from the last to the first. Finish.</p>

<p>You can speed up things by dividing for the largest power of 10 that you are able to print without effort (on 32 bit, 1'000'000'000).</p>

<p><strong>Edit:</strong> pseudo code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;math_with_very_very_big_num.h&gt;

int main(int argc, char **argv) {
  very_very_big_num bignum = someveryverybignum;
  very_very_big_num quot;
  int size = (int) floor(vvbn_log10(bignum)) + 1;
  char *result = calloc(size, sizeof(char));

  int i = 0;
  do {
    quot = vvbn_divide(bignum, 10);
    result[i++] = (char) vvbn_remainder(bignum, 10) + '0';
    bignum = quot;
  } while (vvbn_greater(bignum,  9));
  result[i] = (char) vvbn_to_i(bignum) + '0';
  while(i &gt;= 0)
    printf(""%c"", result[i--]);
  printf(""\n"");
}
</code></pre>

<p>(I wrote this using long, than translating it with veryverybignum stuff; it worked with long, unluckily I cannot try this version, so please forgive me if I made transation errors...)</p>
",1
53184,53161,92,"<p>From Hacker's Delight:</p>

<pre><code>int hibit(unsigned int n) {
    n |= (n &gt;&gt;  1);
    n |= (n &gt;&gt;  2);
    n |= (n &gt;&gt;  4);
    n |= (n &gt;&gt;  8);
    n |= (n &gt;&gt; 16);
    return n - (n &gt;&gt; 1);
}
</code></pre>

<p>This version is for 32-bit ints, but the logic can be extended for 64-bits or higher.</p>
",10
53174,53161,7,"<p>Continually remove the low order bit comes to mind...</p>

<pre><code>int highest_order_bit( int x )
{
    int y = x;
    do { 
        x = y;
        y = x &amp; (x-1); //remove low order bit
    }
    while( y != 0 );
    return x;
}
</code></pre>
",0
53175,53161,34,"<p>This should do the trick.</p>

<pre><code>int hob (int num)
{
    if (!num)
        return 0;

    int ret = 1;

    while (num &gt;&gt;= 1)
        ret &lt;&lt;= 1;

    return ret;
}
</code></pre>

<p>hob(1234) returns 1024<br>
hob(1024) returns 1024<br>
hob(1023) returns 512</p>
",5
53229,53161,5,"<p>The linux kernel has a number of handy bitops like this, coded in the most efficient way for a number of architectures.  You can find generic versions in <a href=""http://lxr.linux.no/linux+v2.6.26.5/include/asm-generic/bitops/fls.h"" rel=""nofollow noreferrer"">include/asm-generic/bitops/fls.h</a> (and friends), but see also <a href=""http://lxr.linux.no/linux+v2.6.26.5/include/asm-x86/bitops.h"" rel=""nofollow noreferrer"">include/asm-x86/bitops.h</a> for a definition using inline assembly if speed is of the essence, and portability is not.</p>
",1
53298,53161,4,"<p>A fast way to do this is via a look-up table. For a 32-bit input, and an 8-bit look-up table, in only requires 4 iterations:</p>

<pre><code>int highest_order_bit(int x)
{
    static const int msb_lut[256] =
        {
            0, 0, 1, 1, 2, 2, 2, 2, // 0000_0000 - 0000_0111
            3, 3, 3, 3, 3, 3, 3, 3, // 0000_1000 - 0000_1111
            4, 4, 4, 4, 4, 4, 4, 4, // 0001_0000 - 0001_0111
            4, 4, 4, 4, 4, 4, 4, 4, // 0001_1000 - 0001_1111
            5, 5, 5, 5, 5, 5, 5, 5, // 0010_0000 - 0010_0111
            5, 5, 5, 5, 5, 5, 5, 5, // 0010_1000 - 0010_1111
            5, 5, 5, 5, 5, 5, 5, 5, // 0011_0000 - 0011_0111
            5, 5, 5, 5, 5, 5, 5, 5, // 0011_1000 - 0011_1111

            6, 6, 6, 6, 6, 6, 6, 6, // 0100_0000 - 0100_0111
            6, 6, 6, 6, 6, 6, 6, 6, // 0100_1000 - 0100_1111
            6, 6, 6, 6, 6, 6, 6, 6, // 0101_0000 - 0101_0111
            6, 6, 6, 6, 6, 6, 6, 6, // 0101_1000 - 0101_1111
            6, 6, 6, 6, 6, 6, 6, 6, // 0110_0000 - 0110_0111
            6, 6, 6, 6, 6, 6, 6, 6, // 0110_1000 - 0110_1111
            6, 6, 6, 6, 6, 6, 6, 6, // 0111_0000 - 0111_0111
            6, 6, 6, 6, 6, 6, 6, 6, // 0111_1000 - 0111_1111

            7, 7, 7, 7, 7, 7, 7, 7, // 1000_0000 - 1000_0111
            7, 7, 7, 7, 7, 7, 7, 7, // 1000_1000 - 1000_1111
            7, 7, 7, 7, 7, 7, 7, 7, // 1001_0000 - 1001_0111
            7, 7, 7, 7, 7, 7, 7, 7, // 1001_1000 - 1001_1111
            7, 7, 7, 7, 7, 7, 7, 7, // 1010_0000 - 1010_0111
            7, 7, 7, 7, 7, 7, 7, 7, // 1010_1000 - 1010_1111
            7, 7, 7, 7, 7, 7, 7, 7, // 1011_0000 - 1011_0111
            7, 7, 7, 7, 7, 7, 7, 7, // 1011_1000 - 1011_1111

            7, 7, 7, 7, 7, 7, 7, 7, // 1100_0000 - 1100_0111
            7, 7, 7, 7, 7, 7, 7, 7, // 1100_1000 - 1100_1111
            7, 7, 7, 7, 7, 7, 7, 7, // 1101_0000 - 1101_0111
            7, 7, 7, 7, 7, 7, 7, 7, // 1101_1000 - 1101_1111
            7, 7, 7, 7, 7, 7, 7, 7, // 1110_0000 - 1110_0111
            7, 7, 7, 7, 7, 7, 7, 7, // 1110_1000 - 1110_1111
            7, 7, 7, 7, 7, 7, 7, 7, // 1111_0000 - 1111_0111
            7, 7, 7, 7, 7, 7, 7, 7, // 1111_1000 - 1111_1111
        };

    int byte;
    int byte_cnt;

    for (byte_cnt = 3; byte_cnt &gt;= 0; byte_cnt--)
    {
        byte = (x &gt;&gt; (byte_cnt * 8)) &amp; 0xff;
        if (byte != 0)
        {
            return msb_lut[byte] + (byte_cnt * 8);
        }
    }

    return -1;
}
</code></pre>
",2
53509,53161,27,"<p>like obfuscated code? Try this:</p>

<p>1 &lt;&lt; ( int) log2( x)</p>
",9
1413651,1413644,0,"<p>Well, you'd probably have a bunch of printf statements at the top for your headers to give some meaning to the data. Then maybe a line of dashes or equals or something to work as a separator.</p>

<p>Then below that, loop through an array with the values you wish to plot. One on each line.</p>
",0
1413668,1413644,8,"<p>How to structure and fill a histogram?</p>

<p>Trivial case is just a count per bin:</p>

<pre><code>/* needs error checking, badly */
int *buildHist(int bins, double min, double max, int n, double *data){
   double *hist=malloc(bins*sizeof(int));
   if (hist == NULL) return hist;
   for (int i=0; i&lt;n; ++i){
      int bin=int( (data[i]-min)/((max-min)/(bins)) );
      if ( (bin&gt;=0) &amp;&amp; (bin&lt;n) ) hist[bin]++;
   }
   return hist;
}
</code></pre>

<p>For a weighted histogram, the array must be of floating point type.</p>

<p>With more data (over- and under-flow counts, accumulated statistics...or even to keep the limits in the same place as the count), use a structure that includes the array.</p>

<p>Incremental filling is often desired, but should be obvious from here.</p>

<p>Output depends a great deal on what display technology you have at hand.</p>
",4
1124274,1124265,22,"<p>It's a <a href=""http://linuxprograms.wordpress.com/2008/03/07/c-variable-argument-list-access/"" rel=""noreferrer"">variable argument list.</a></p>
",0
1124275,1124265,8,"<p>No, that's the ""ellipsis"" you're seeing there, assuming you're referring to the <code>...</code> part of the declaration.</p>

<p>Basically it says that this function takes an unknown number of arguments after the first two that are specified there.</p>

<p>The function has to be written in such a way that it knows what to expect, otherwise strange results will ensue.</p>

<p>For other functions that support this, look at the <code>printf</code> function and its variants.</p>
",1
1124277,1124265,2,"<p>I assume you are referring to the ellipsis (...)?  If so this indicates that 0 or more parameters will follow.  It is called varargs, defined in stdarg.h</p>

<p><a href=""http://msdn.microsoft.com/en-us/library/kb57fad8.aspx"" rel=""nofollow noreferrer"">http://msdn.microsoft.com/en-us/library/kb57fad8.aspx</a></p>

<p>printf uses this functionality.  Without it you wouldn't be able to keep adding parameters to the end of the function.</p>
",1
1124280,1124265,0,"<p>No, it is a function that is taking variable number of arguments.</p>
",0
1124283,1124265,0,"<p>That is not technically polymorphism. fcntl takes variable number of arguments &amp; that is the reason for the ... similar to printf function.</p>
",0
1124290,1124265,16,"<p>That is a <a href=""http://en.wikipedia.org/wiki/Varargs"" rel=""noreferrer"">variadic function</a>. See <a href=""http://en.wikipedia.org/wiki/Stdarg.h"" rel=""noreferrer"">stdarg.h</a> for more details.</p>
",0
1124396,1124265,12,"<p>The <code>...</code> means that you can pass any number of arguments to this function, as other commenters have already mentioned. Since the optional arguments are not typed, the compiler cannot check the types and you can technically pass in any argument of any type.</p>

<p>So does this mean you can use this to implement some kind of polymorphic function? (I.e., a function that performs some operation based on the type of its arguments.)</p>

<p>No.</p>

<p>The reason you cannot do this, is because you cannot at runtime inspect the types of the arguments passed in. The function reading in the variable argument list is expected to  already know the types of the optional arguments it is going to receive.</p>

<p>In case of a function that really is supposed to be able to take any number of arguments of any type (i.e., <code>printf</code>), the types of the arguments are passed in via the format string. This means that the caller has to specify the types it is going to pass in at every invocation, removing the benefit of polymorphic functions (that the caller doesn't have to know the types either).</p>

<p>Compare:</p>

<pre><code>// Ideal invocation
x = multiply(number_a, number_b)
y = multiply(matrix_a, matrix_b)

// Standard C invocation
x = multiply_number(number_a, number_b)
y = multiply_matrix(matrix_a, matrix_b)

// Simulated ""polymorphism"" with varargs
x = multiply(T_NUMBER, number_a, number_b)
y = multiply(T_MATRIX, matrix_a, matrix_b)
</code></pre>

<p>You have to specify the type before the varargs function can do the right thing, so this gains you nothing.</p>
",0
1124439,1124265,6,"<blockquote>
  <p>Does C support polymorphism?
  No, it doesn't. </p>
</blockquote>

<p>However there are several libraries, such as Python C API, that implements a rough variant of polymorphism using structs and pointers. Beware that compiler cannot perform appropriate type checking in most cases.</p>

<p>The tecnhique is simple:</p>

<pre><code>typedef struct {
    char * (*to_string)();
} Type;

#define OBJ_HEADER Type *ob_type

typedef struct {
    OBJ_HEADER;
}  Object; 

typedef struct {
    OBJ_HEADER;
    long ival;        
} Integer;

typedef struct {
    OBJ_HEADER;
    char *name;
    char *surname;
} Person;
</code></pre>

<p>Integer and Person get a Type object with appropriate function pointers (e.g. to functions like integer_to_string and person_to_string).</p>

<p>Now just declare a function accepting an Object *:</p>

<pre><code>void print(Object *obj) {
    printf(""%s"", obj-&gt;type-&gt;to_string());
}
</code></pre>

<p>now you can call this function with both an Integer and a Person:</p>

<pre><code>Integer *i = make_int(10);
print((Object *) i);

Person *p = make_person(""dfa"");
print((Object *) p);
</code></pre>

<p>EDIT</p>

<p>alternatively you can declare i and p as Object *; of course make_int and make_person will allocate space for Integer and Person and do the appropriate cast:</p>

<pre><code>Object * 
make_integer(long i) {
     Integer *ob = malloc(sizeof(Integer));
     ob-&gt;ob_type = &amp;integer_type;
     ob-&gt;ival = i;
     return (Object *) ob;
}
</code></pre>

<p>NB: I cannot compile these examples rigth now, please doublecheck them.</p>

<blockquote>
  <p>I came across the following function signature and I wondered if this (the ellipsis, or ""..."") is some kind of polymorphism?</p>
</blockquote>

<p>yes, it is a <strong>primitive form of polymorphism</strong>. With only one function signature you are able to pass various structures. However the compiler cannot help you with detecting type errors.</p>
",2
1124867,1124265,1,"<p>C supports a crude form of Polymorphism. I.e. a type being able to appear and behave as another type. It works in a similar was as in C++ under the hood (relying on memory being aligned) but you have to help the compiler out by casting. E.g. you can define a struct:</p>

<pre><code>typedef struct {
     char forename[20];
     char surname[20];
     } Person;
</code></pre>

<p>And then another struct:</p>

<pre><code>    typedef struct {
             char forename[20];
             char surname[20];
             float salary;
             char managername[20];
             } Employee;
</code></pre>

<p>Then</p>

<pre><code>int main (int argc, int *argv)
{
    Employee Ben;
    setpersonname((Person *) &amp;Ben);
}

void setpersonname(Person *person)
{
   strcpy((*person).Name,""Ben"");
}
</code></pre>

<p>The above example shows Employee being used as a Person.</p>
",3
1124464,1124265,0,"<p>C neither supports function overloading - which is a type of <em>ad-hoc polymorphism</em> based on compile-time types - nor multiple dispatch (ie overloading based on runtime types).</p>

<p>To simulate function overloading in C, you have to create multiple differently named functions. The functions' names often contain the type information, eg <code>fputc()</code> for characters and <code>fputs()</code> for strings.</p>

<p>Multiple dispatch can be implemented by using variadic macros. Again, it's the programmer's job to provide the type information, but this time via an extra argument, which will be evaluated at runtime - in contrast to the compile-time function name in case of the approach given above. The <code>printf()</code> family of functions might not be the best example for multiple dispatch, but I can't think of a better one right now.</p>

<p>Other approaches to multiple dispatch using pointers instead of variadic functions or wrapping values in structures to provide type annotations exist.</p>
",0
1124473,1124265,4,"<p>Adding to what's been said: C supports polymorphism through other means. For example, take the standard library <code>qsort</code> function which sorts data of arbitrary type.</p>

<p>It is able to do so by means of untyped (<code>void</code>) pointers to the data. It also needs to know the size of the data to sort (provided via <code>sizeof</code>) and the logic that compares the objects' order. This is accomplished by passing a function pointer to the <code>qsort</code> function.</p>

<p>This is a prime example of runtime polymorphism.</p>

<p>There are other ways to implement object-oriented behaviour (in particular, virtual function calls) by managing the virtual function tables manually. This can be done by storing function pointers in structures and passing them around. Many APIs do so, e.g. the WinAPI, which even uses advanced aspects of object orientation, e.g. base class call dispatch (<code>DefWindowProc</code>, to simulate calling the virtual method of the base class).</p>
",3
1124678,1124265,0,"<p>The printf declaration in the standard library is </p>

<pre><code>int printf(const char*, ...); 
</code></pre>

<p>Think about that.</p>
",0
1124705,1124265,0,"<p>You can write code that supports Polymorphic behavior in C, but the ... (ellipsis) is not going to be much help.  That is for variable arguments to a function.  </p>

<p>If you want polymorphic behavior you can use, unions and structures to construct a data structure that has a ""type"" section and variable fields depending on type.  You can also include tables of function pointers in the structures.  Poof! You've invented C++.  </p>
",0
1127056,1124265,-5,"<p>Yes C Do support the polymorphism </p>

<p>the Code which we write in the C++ using virtual to implement the polymorphism
if first converted to a C code by Compiler (one can find details <a href=""http://www.eventhelix.com/RealtimeMantra/basics/object_oriented_programming_in_c.htm"" rel=""nofollow noreferrer"">here</a>).</p>

<p>It's well known that virtual functionality in C++ is implemented using function pointers. </p>
",0
24138,17980,-1,"<p>One issue that hasn't been raised by others is whether <strong>double</strong> is the same as a <strong>float</strong>.  On some systems a different format specifier was needed for a double compared to a float.  Not least because the parameters passed could be of different sizes.
<PRE>
 %f - float
 %lf - double
 %g - double
</PRE></p>
",1
17987,17980,7,"<pre><code>man 3 printf
</code></pre>

<p>on a Linux system will give you all the information you need.  You can also find these manual pages online, for example at <a href=""http://linux.die.net/man/3/printf"" rel=""nofollow noreferrer"">http://linux.die.net/man/3/printf</a></p>
",0
17989,17980,15,"<p><a href=""http://en.wikipedia.org/wiki/Printf#printf_format_placeholders"" rel=""noreferrer"">http://en.wikipedia.org/wiki/Printf#printf_format_placeholders</a> is Wikipedia's reference for format placeholders in printf. <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/printf.html"" rel=""noreferrer"">http://www.cplusplus.com/reference/clibrary/cstdio/printf.html</a> is also helpful</p>

<p>Basically in a simple form it's %[width].[precision][type]. Width allows you to make sure that the variable which is being printed is at least a certain length (useful for tables etc). Precision allows you to specify the precision a number is printed to (eg. decimal places etc) and the informs C/C++ what the variable you've given it is (character, integer, double etc).</p>

<p>Hope this helps</p>

<p><strong>UPDATE:</strong></p>

<p>To clarify using your examples:</p>

<pre><code>printf( ""%10.1f     %10.2\n"", radius, area );
</code></pre>

<p>%10.1f (referring to the first argument: radius) means make it 10 characters long (ie. pad with spaces), and print it as a float with one decimal place.</p>

<p>%10.2 (referring to the second argument: area) means make it 10 character long (as above) and print with two decimal places.</p>
",0
17992,17980,0,"<p><strong>10.1f</strong> means you want to display a <strong>f</strong>loat with <strong>1</strong> decimal and the displayed number should be <strong>10</strong> characters long.</p>
",0
17995,17980,1,"<p>In short, those values after the % tell <code>printf</code> how to interpret (or output) all of the variables coming later.  In your example, <code>radius</code> is interpreted as a float (this the 'f'), and the <code>10.1</code> gives information about how many decimal places to use when printing it out.</p>

<p>See <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/printf.html"" rel=""nofollow noreferrer"">this link</a> for more details about all of the modifiers you can use with printf.</p>
",0
17999,17980,0,"<p>Man pages contain the information you want. To read what you have above:</p>

<pre><code>printf( ""%10.2f"", 1.5 )
</code></pre>

<p>This will print:</p>

<pre><code>         1.50
</code></pre>

<p>Whereas:</p>

<pre><code>printf(""%.2f"", 1.5 )
</code></pre>

<p>Prints:</p>

<pre><code>1.50
</code></pre>

<p>Note the justification of both.
Similarly:</p>

<pre><code>printf(""%10.1f"", 1.5 )
</code></pre>

<p>Would print:</p>

<pre><code>        1.5
</code></pre>

<p>Any number after the . is the precision you want printed. Any number before the . is the distance from the left margin.</p>
",0
18004,17980,2,"<p>10.1f means floating point with 10 characters  wide with 1 place after the decimal point.
If the number has less than 10 digits, it's padded with spaces.
10.2f is the same, but with 2 places after the decimal point.</p>

<p>You have these basic types:</p>

<pre><code>%d   - integer
%x   - hex integer
%s   - string
%c   - char (only one)
%f   - floating point (float)
%d   - signed int (decimal)
%i   - signed int (integer) (same as decimal).
%u   - unsigned int
%ld  - long (signed) int
%lu  - long unsigned int
%lld - long long (signed) int
%llu - long long unsigned int
</code></pre>

<p>Edit: there are several others listed in @Eli's response (man 3 printf).</p>
",0
18202,17980,2,"<blockquote>
  <p>10.1f means floating point with 1 place after the decimal point and the 10 places before the decimal point. If the number has less than 10 digits, it's padded with spaces. 10.2f is the same, but with 2 places after the decimal point.</p>
</blockquote>

<p>On every system I've seen, from Unix to Rails Migrations, this is not the case.  @robintw expresses it best:</p>

<blockquote>
  <p>Basically in a simple form it's %[width].[precision][type].</p>
</blockquote>

<p>That is, not ""10 places <em>before</em> the decimal point,"" but ""10 places, <em>both before and after, and including</em> the decimal point.""</p>
",1
575981,575936,12,"<p>You can fail if you compile the code without telling gcc to compile with C99 mode (<code>-std=c99</code>) and tell it not to know about ""special builtin"" functions (using <code>-fno-builtin</code>). Then it assumes that your round/roundf function is defined as </p>

<pre><code>int round();
int roundf();
</code></pre>

<p>Because in pre-C99 times there were no such functions yet, so it does not have a declaration and implicitly declares them then. And this will obviously fail, because the call-side treats the return value as an int, while the callee side (in the definition of those functions in the linked library) returns a float. I get these results for example:</p>

<pre><code>[js@HOST2 cpp]$ ./a.out
1065353216.000000
-1048576.000000
[js@HOST2 cpp]$
</code></pre>

<p>Not that you think now that you could cast the return value to a float and be OK. Well, it's worse. The return value is not even guaranteed to have anything to do with the float returned. The call-side reads from a place that it knows where integers are returned. But your compiler may return floats in another place (say, in a floating pointer register) from the callee side. The above could actually have done anything, including aborting the program because it behaves in an undefined manner.</p>

<p>So, what can you do to make it work? Pass the compiler the <code>std=c99</code> flag or use other ways to round (floor is one of them) which do not require those functions</p>

<pre><code>gcc -std=c99 test.c -lm
</code></pre>

<p>See the manpage of <code>man 3 round</code>. However, if you have a very old GCC - i'm not sure whether it supports enough of C99 to have that switch. Look into the feature test macros described in the manpage of round then. </p>
",4
575953,575936,3,"<p>When I compile and run this exact code (under gcc on cygwin) I get:</p>

<pre><code>$ ./a.exe
1.000000
1.000000
</code></pre>

<p>How new is your compiler? A compiler bug is all I can think of, as <code>gcc -Wall</code> gives no warnings either.</p>

<p>To add some further information <a href=""http://www.dreamincode.net/forums/showtopic14415.htm"" rel=""nofollow noreferrer"">this forum thread</a> seems to show changing compiler to a newer version fixes it. If this doesn't work for you you'll need to give more details of compiler and OS, but given this seems to work for other people on three different platforms looks like your compiler is at fault.</p>
",1
575954,575936,0,"<p>This obviously doesn't help but the code looks and runs as expected for me. Everything seems fine.</p>
",0
575955,575936,2,"<p>To add to the chorus of approvals, this works fine for me (OS X Leopard using gcc).</p>

<p>Out of curiosity, do you need to use the <code>-lm</code> flag? I didn't the first time, and I did the second time, and there was no difference, but that's because libm.dylib and libc.dylib are symbolic links to the same library on OS X. Perhaps your libm is broken or something? Do you need to link to libm or not? I would think that the math.h functions would be part of libc...?</p>

<p>EDIT:</p>

<p>Before you do any of that, try using this instead:</p>

<pre><code>float f = 0;
double d = 0;
</code></pre>

<p>I don't think that should change anything, but if it does, I win.</p>
",2
575973,575936,2,"<p>One more ""works on my machine"" on Ubuntu with gcc version 4.3.2.</p>

<pre><code>$ ./a.out
1.000000
1.000000
</code></pre>

<p>I do get a couple of warnings when I compile, though.</p>

<pre><code>$ gcc -lm round.c
round.c: In function ¡®main¡¯:
round.c:11: warning: incompatible implicit declaration of built-in function ¡®roundf¡¯
round.c:12: warning: incompatible implicit declaration of built-in function ¡®round¡¯
</code></pre>
",2
575978,575936,-1,"<p>Looks like you're using it right, describe your environment some?</p>
",0
576725,575936,2,"<p>litb was on the right track.  <code>-std=c99</code> didn't work but adding <code>#define _ISOC99_SOURCE</code> worked.  So the code looks like:</p>

<pre><code>#define _ISOC99_SOURCE
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main(void)
{
...
</code></pre>
",0
1704239,1704195,0,"<p><code>scanf()</code> may be a bit tricky in this situation, assuming that different commands with different parameters can be used.  I would probably use <code>fgets()</code> to read in the string first, followed by the use of <code>strtok()</code> to read the first token (the command).  At that point you can either continue to use <code>strtok()</code> with "","" as the delimiter to read the rest of the tokens in the string, or you could use a <code>sscanf()</code> on the rest of the string (now that you know the format that the rest of the input will be in). <code>sscanf()</code> is still going to be a pain due to the fact that it appears that an unspecified number of spaces would be allowed in the address and possibly town fields.</p>
",1
1704256,1704195,4,"<p>Fast easy method:</p>

<p>Use <a href=""http://linux.die.net/man/3/fgets"" rel=""nofollow noreferrer""><code>fgets()</code></a> to get the string from the user;<br>
and <a href=""http://linux.die.net/man/3/strtok"" rel=""nofollow noreferrer""><code>strtok()</code></a> to tokenize it.</p>

<p><em>Edit</em><br>
After reading your comment:</p>

<p>Use <code>strtok()</code> with only the comma, and then remove trailing and leading spaces from the result.</p>

<p><em>Edit2</em><br>
After a test run, I noticed you will get ""INSERT Alice"" as the first token. So, <strong>after all tokens have been extracted</strong>, run <code>strtok()</code> again, this time with a space, on the first token extracted. Or, find the space and <em>somehow</em> identify the command and the name from there.</p>
",1
1704613,1704195,1,"<p>If your input data format is fixed you can use something quick and dirty using [s]scanf().</p>

<p>With input of:</p>

<pre><code>INSERT Alice, 25 Norway Drive, Fitzerald, GA, 40204, 6000.60
</code></pre>

<p>You might try, if reading from stdin:</p>

<pre><code>char name[80], addr[80], city[80], state[80];
int zip;
double amt;

int res = scanf(""INSERT %[^,], %[^,], %[^,], %[^,], %d, %f\n"",
    &amp;name, &amp;addr, &amp;city, &amp;state, &amp;zip, &amp;amt);
</code></pre>

<p>Should return the number of items matched (i.e. 6).</p>
",2
1330124,1330114,3,"<p>No.  The #include is a preprocessor command that says ""put all of the text from this other file right here"".  So, all of the functions and variables in the included file are defined in the current file.</p>
",0
1330125,1330114,26,"<p><code>extern</code> is needed because it declares that the symbol exists and is of a certain type, and does not allocate storage for it.</p>

<p>If you do:</p>

<pre><code>int foo;
</code></pre>

<p>In a header file that is shared between several source files, you will get a linker error because each source would have its own copy of foo created and the linker will be unable to resolve the symbol.</p>

<p>Instead, if you have:</p>

<pre><code>extern int foo;
</code></pre>

<p>In the header, it would declare a symbol that is defined elsewhere in each source file.</p>

<p>One (and only one) source file would contain</p>

<pre><code>int foo;
</code></pre>

<p>which creates a single instance of foo for the linker to resolve.</p>
",5
1987964,1987957,14,"<p><code>LPVOID</code> is simply a Windows API <code>typedef</code> for <code>void*</code>. </p>
",10
1988006,1987957,108,"<p>There is no <code>LPVOID</code> type in C, it's a Windows thing.</p>

<p>And the reason those sort of things exists is so that the underlying types can change from release to release without affecting your source code.</p>

<p>For example, let's say early versions of Microsoft's C compiler had a 16-bit <code>int</code> and a 32-bit <code>long</code>. They could simply use:</p>

<pre><code>typedef long INT32
</code></pre>

<p>and, voila, you have your 32-bit integer type.</p>

<p>Now let's go forward a few years to a time where Microsoft C uses a 32-bit <code>int</code> and a 64-bit <code>long</code>. In order to still have your source code function correctly, they simply change the <code>typedef</code> line to read:</p>

<pre><code>typedef int INT32
</code></pre>

<p>This is in contrast to what you'd have to do if you were using <code>long</code> for your 32-bit integer types. You'd have to go through <em>all</em> your source code and ensure that you changed your own definitions.</p>

<p>It's much cleaner from a compatibility viewpoint (compatibility between different versions of Windows) to use Microsoft's data types.</p>

<p>In answer to your specific question, it's probably okay to use <code>void*</code> instead of <code>LPVOID</code> <em>provided the definition of</em> <code>LPVOID</code> <em>is not expected to change.</em></p>

<p>But I wouldn't, just in case. You never know if Microsoft may introduce some different way of handling generic pointers in future that would change the definition of <code>LPVOID</code>. You don't really lose anything by using Microsoft's type but you <em>could</em> be required to do some work in future if they change the definition and you've decided to use the underlying type.</p>

<p>You may not think pointers would be immune to this sort of change but, in the original 8088 days when Windows was created, there were all sorts of weirdness with pointers and memory models (tiny, small, large, huge et al) which allowed pointers to be of varying sizes even within the same environment.</p>
",1
558044,558009,0,"<p>There isn't one; neither ANSI C nor ISO C++ have such a thing.</p>
",0
558071,558009,10,"<p>For UNIX-like systems you want to play with the ECHO flag...</p>

<pre><code>#include &lt;termios.h&gt;
...
struct termios t;
tcgetattr(fd, &amp;t);
t.c_lflag &amp;= ~ECHO;
tcsetattr(fd, TCSANOW, &amp;t);
...
</code></pre>
",3
558074,558009,0,"<p>This will depend on your environment, it is not something that the language provides. If you intend to do extensive character mode I/O, you might look into a library like curses. Otherwise, you will have to manipulate the terminal or the windows console manually.</p>
",0
558079,558009,3,"<p>You can't do it in a cross-platform manner using ANSI C.  You'll have to use some OS-specific code, or use a library such as <a href=""http://www.gnu.org/software/ncurses/"" rel=""nofollow noreferrer"">ncurses</a>.</p>
",0
558082,558009,-2,"<p>ANSI and ISO C do not define this functionality, however most C compilers have getch() or a close variation.</p>

<p>You'll need to do a preprocessor define for each compiler you're using that has a different library and function for this.  It's not difficult, though you might consider it annoying.</p>

<p>-Adam</p>
",3
558190,558009,2,"<p>Since your task is fairly basic, if you're lucky your system will have the <a href=""http://pubs.opengroup.org/onlinepubs/7908799/xsh/getpass.html"" rel=""nofollow noreferrer""><code>getpass()</code></a> function:</p>

<pre><code>char * getpass(const char *prompt);
</code></pre>

<p>If you don't want a prompt, just do:</p>

<pre><code>char *s = getpass("""");
if (s != NULL)
    printf(""Your password was %s!\n"", s);
</code></pre>

<p><a href=""http://pubs.opengroup.org/onlinepubs/7908799/xsh/getpass.html"" rel=""nofollow noreferrer""><code>getpass()</code></a>, like all C functions related to echo and buffering, is non-standard, but present on Mac OS X, probably Linux, and is listed in the GNU C library, so it's probably present on any system using glibc.</p>

<p>The ANSI and ISO standards, as stated previously, do <em>not</em> specify a standard way to read input without echoing, or to read unbuffered input (i.e. on character at a time).</p>
",3
1479972,1476892,42,"<p>ASCII art for the win:</p>

<pre><code>                       ANSI C translation phases
                       =========================

          +-------------------------------------------------+
          | map physical characters to source character set |
          |     replace line terminators with newlines      |
          |           decode trigraph sequences             |
          +-------------------------------------------------+
                                   |
                                   V
               +---------------------------------------+
               | join lines along trailing backslashes |
               +---------------------------------------+
                                   |
                                   V
     +-------------------------------------------------------------+
     | decompose into preprocessing tokens and whitespace/comments |
     |                      strip comments                         |
     |                      retain newlines                        |
     +-------------------------------------------------------------+        
                                   |
                                   V
          +------------------------------------------------+
          | execute preprocessing directives/invoke macros |
          |              process included files            |
          +------------------------------------------------+
                                   |
                                   V
   +----------------------------------------------------------------+
   | decode escape sequences in character constants/string literals |
   +----------------------------------------------------------------+
                                   |
                                   V
                +--------------------------------------+
                | concatenate adjacent string literals |
                +--------------------------------------+
                                   |
                                   V
              +------------------------------------------+
              | convert preprocessing tokens to C tokens |
              |       analyze and translate tokens       |
              +------------------------------------------+
                                   |
                                   V
                    +-----------------------------+
                    | resolve external references |
                    |        link libraries       |
                    |      build program image    |
                    +-----------------------------+
</code></pre>
",2
1477446,1476892,14,"<p>Almost direct from <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/projects#9899"" rel=""noreferrer"">the most current draft of the revised C99 standard</a>; I did some reformatting.<br>
Do a Print-Screen and you're set.</p>

<pre><code>5.1.1.2 Translation phases

1 The precedence among the syntax rules of translation is specified by the following
phases. (*5)
    1. Physical source file multibyte characters are mapped, in an implementation
       defined manner, to the source character set (introducing new-line characters for
       end-of-line indicators) if necessary. Trigraph sequences are replaced by
       corresponding single-character internal representations.
    2. Each instance of a backslash character (\) immediately followed by a new-line
       character is deleted, splicing physical source lines to form logical source lines.
       Only the last backslash on any physical source line shall be eligible for being part
       of such a splice. A source file that is not empty shall end in a new-line character,
       which shall not be immediately preceded by a backslash character before any such
       splicing takes place.
    3. The source file is decomposed into preprocessing tokens (*6) and sequences of
       white-space characters (including comments). A source file shall not end in a
       partial preprocessing token or in a partial comment. Each comment is replaced by
       one space character. New-line characters are retained. Whether each nonempty
       sequence of white-space characters other than new-line is retained or replaced by
       one space character is implementation-defined.
    4. Preprocessing directives are executed, macro invocations are expanded, and
       _Pragma unary operator expressions are executed. If a character sequence that
       matches the syntax of a universal character name is produced by token
       concatenation (6.10.3.3), the behavior is undefined. A #include preprocessing
       directive causes the named header or source file to be processed from phase 1
       through phase 4, recursively. All preprocessing directives are then deleted.
    5. Each source character set member and escape sequence in character constants and
       string literals is converted to the corresponding member of the execution character
       set; if there is no corresponding member, it is converted to an implementation-defined
       member other than the null (wide) character. (*7)
    6. Adjacent string literal tokens are concatenated.
    7. White-space characters separating tokens are no longer significant. Each
       preprocessing token is converted into a token. The resulting tokens are
       syntactically and semantically analyzed and translated as a translation unit.
    8. All external object and function references are resolved. Library components are
       linked to satisfy external references to functions and objects not defined in the
       current translation. All such translator output is collected into a program image
       which contains information needed for execution in its execution environment.

(*5) Implementations shall behave as if these separate phases occur, even though many are typically folded
     together in practice. Source files, translation units, and translated translation units need not
     necessarily be stored as files, nor need there be any one-to-one correspondence between these entities
     and any external representation. The description is conceptual only, and does not specify any
     particular implementation.
(*6) Adjacent string literal tokens are concatenated.
(*7) White-space characters separating tokens are no longer significant. Each
     preprocessing token is converted into a token. The resulting tokens are
     syntactically and semantically analyzed and translated as a translation unit.
</code></pre>
",0
526537,526229,11,"<p>It's possible (at least for IEEE 754 <code>float</code> and <code>double</code> values) to compute the greatest floating-point value via (pseudo-code):</p>

<pre><code>~(-1.0) | 0.5
</code></pre>

<p>Before we can do our bit-twiddling, we'll have to convert the floating-point values to integers and then back again. This can be done in the following way:</p>

<pre><code>uint64_t m_one, half;
double max;

*(double *)(void *)&amp;m_one = -1.0;
*(double *)(void *)&amp;half = 0.5;
*(uint64_t *)(void *)&amp;max = ~m_one | half;
</code></pre>

<p>So how does it work? For that, we have to know how the floating-point values will be encoded.</p>

<p>The highest bit encodes the sign, the next <code>k</code> bits encode the exponent and the lowest bits will hold the fractional part. For powers of <code>2</code>, the fractional part is <code>0</code>.</p>

<p>The exponent will be stored with a bias (offset) of <code>2**(k-1) - 1</code>, which means an exponent of <code>0</code> corresponds to a pattern with all but the highest bit set.</p>

<p>There are two exponent bit patterns with special meaning:</p>

<ul>
<li>if no bit is set, the value will be <code>0</code> if the fractional part is zero; otherwise, the value is a subnormal</li>
<li>if all bits are set, the value is either <code>infinity</code> or <code>NaN</code></li>
</ul>

<p>This means the greatest regular exponent will be encoded via setting all bits except the lowest one, which corresponds to a value of <code>2**k - 2</code> or <code>2**(k-1) - 1</code> if you substract the bias.</p>

<p>For <code>double</code> values, <code>k = 11</code>, ie the highest exponent will be <code>1023</code>, so the greatest floating point value is of order <code>2**1023</code> which is about <code>1E+308</code>.</p>

<p>The greatest value will have</p>

<ul>
<li>the sign bit set to <code>0</code></li>
<li>all but the lowest exponent bit set to <code>1</code></li>
<li>all fractional bits set to <code>1</code></li>
</ul>

<p>Now, it's possible to understand how our magic numbers work:</p>

<ul>
<li><code>-1.0</code> has its sign bit set, the exponent is the bias - ie all bits but the highest one are present - and the fractional part is <code>0</code></li>
<li><code>~(-1.0)</code> has only the highest exponent bit and all fractional bits set</li>
<li><code>0.5</code> has a sign bit and fractional part of <code>0</code>; the exponent will be the bias minus <code>1</code>, ie all but the highest and lowest exponent bits will be present</li>
</ul>

<p>When we combine these two values via logical or, we'll get the bit pattern we wanted.</p>

<hr>

<p>The computation works for x86 80-bit extended precision values (aka <code>long double</code>) as well, but the bit-twiddling must be done byte-wise as there's no integer type large enough to hold the values on 32-bit hardware.</p>

<p>The bias isn't actually required to be <code>2**(k-1) - 1</code> - it'll work for an arbitrary bias as long as it is odd. The bias must be odd because otherwise the bit-patterns for the exponent of <code>1.0</code> and <code>0.5</code> will differ in other places than the lowest bit.</p>

<p>If the base <code>b</code> (aka radix) of the floating-point type is not <code>2</code>, you have to use <code>b**(-1)</code> instead of <code>0.5 = 2**(-1)</code>.</p>

<p>If the greatest exponent value is not reserverd, use <code>1.0</code> instead of <code>0.5</code>. This will work regardless of base or bias (meaning it's no longer restricted to odd values). The difference in using <code>1.0</code> is that the lowest exponent bit won't be cleared.</p>

<hr>

<p>To summarize:</p>

<pre><code>~(-1.0) | 0.5
</code></pre>

<p>works as long as the radix is <code>2</code>, the bias is odd and the highest exponent is reserved.</p>

<pre><code>~(-1.0) | 1.0
</code></pre>

<p>works for any radix or bias as long as the highest exponent is not reserved.</p>
",3
526234,526229,2,"<p>You could try making a float bigger until it overflows.</p>
",2
526237,526229,4,"<p>For 99.99% of all applications, you should assume IEEE 754 and use the constants defined in <code>&lt;float.h&gt;</code>.  In the other 0.01%, you'll be working with very specialized hardware, and in that case, you should know what to use based on the hardware.</p>
",0
527205,526229,3,"<p>At the risk of a superfluous answer:</p>

<p>No.  There isn't a portable way to calculate the ranges.  That's why the <code>&lt;float.h&gt;</code> header is provided - because there isn't a portable way to derive the information contained in it.</p>
",1
845145,845127,3,"<pre><code>#include &lt;stdio.h&gt; /* standard header, use the angle brackets */

int main(void)
{
    char somechar = 'x'; /* one-byte data */
    FILE* fp = fopen(""so-data.txt"", ""r+"");
    if (fp) {
      fseek(fp, 5, SEEK_SET);
      fwrite(&amp;somechar, 1, 1, fp);
      fclose(fp);
    }
    return 0; /* if you are on non-C99 systems */
}
</code></pre>
",0
845134,845127,5,"<pre><code>FILE* fileHandle = fopen(""filename"", ""r+b""); // r+ if you need char mode
fseek(fileHandle, position_of_byte, SEEK_SET);
fwrite(""R"" /* the value to replace with */, 1, 1, fileHandle);
</code></pre>
",3
845136,845127,8,"<pre><code>#include ""stdio.h""

int main(void)
{
    FILE* f = fopen(""so-data.dat"", ""r+b""); // Error checking omitted
    fseek(f, 5, SEEK_SET);
    fwrite(""x"", 1, 1, f);
    fclose(f);
}
</code></pre>
",7
718338,667362,0,"<p><a href=""http://en.wikipedia.org/wiki/Lint_programming_tool"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Lint_programming_tool</a></p>

<p>Edit:
<a href=""https://stackoverflow.com/questions/632057/c-c-free-alternative-to-lint"">C/C++ Free alternative to Lint?</a></p>

<p>HTH</p>
",0
1144942,1144913,10,"<blockquote>
  <p>The most likely change to the struct is for more fields to be added to the structure in the future and if this happens then a default value for the new field will be available.</p>
</blockquote>

<p>From version 1, always include <code>sizeof(myStruct)</code> as a field in the beginning of each struct. Then, when you need to add new fields, always do so in the end of each struct, never in the middle. Now when receiving (or reading from a file), first read the size field only, so that you know how many bytes will be coming after it. If the size is less than <code>sizeof(myStruct)</code> as determined by the receiver/reader, then you know that something is missing, and default values are needed.</p>
",0
1144958,1144913,7,"<p>I'd recommend using something like Google's <a href=""http://code.google.com/p/protobuf/"" rel=""nofollow noreferrer"">protocol buffers</a>, which automatically handle versioning.  If you add new fields to your messages, it's very easy to handle.</p>
",0
755672,755665,15,"<p>Because the typical I/O functions that write, take a pointer to <code>char</code>. This is because someone considered that the most representative way of talking about the data stored in a binary file; it's just a bunch of the machine's smallest adressable word, in sequence. The C type name for that is <code>char</code>.</p>
",0
755679,755665,7,"<p><code>char*</code> merely represents a pointer to the beginning of a sequence of bytes, which is exactly what one expects a binary file to contain.</p>
",0
755775,755665,2,"<p>Are you talking about <code>fread()</code> and <code>fwrite()</code>? The data they read or write are passed as <code>void*</code> (or <code>const void*</code>), so you don't have to convert.</p>

<p>But in C++ when you use, say, <a href=""http://cplusplus.com/reference/iostream/istream/read/"" rel=""nofollow noreferrer""><code>istream::read()</code></a>, then the pointer to the reception buffer must be passed as a <code>char*</code>, so there is no implicit conversion.</p>
",0
755718,755665,2,"<p>Unwind and vezult have already answered your question, and I assume you know what a pointer is. But just in case you think of *converting something to a char** as an operation that actually somehow changes your data in memory (and, for example, may take more time if there's a lot of data) then note that such is <em>not</em> the behavior of getting a pointer.</p>
",0
872308,868759,1,"<p>Here's an opinion from someone who used C for years in biomedical research:  image processing, data crunching.  IMHO, C is a major intellectual achievement, probably the finest distillation of intent into syntax.  I would learn C again now, if I were starting out, even if just for the purpose of learning to think.</p>

<p>That said, I have never even attempted to program in C on MS.  (All my work was on Suns and SGIs.)  To avoid the overhead mentioned in other answers, I have switched to Python on MS XP/cygwin.  However, I miss C's terse, expressive syntax rather often, and I miss mucking about with bits and values as stored in memory.  Note that even with Python, the back-end is C, and custom extensions are coded in C.  Thus, if I wanted to redo my image processing code for Python, I probably would wind up writing C after all.</p>

<p>Sorry that MS imposes such a burden on writing in about the leanest language ever invented.  (BTW, as for editors, my personal choice is vim (as gvim), not IDEs.)  (Have you thought of setting up a Linux box?  Lots to be said for that these days:  UNIX without the cost of workstations.)</p>
",0
872709,868759,2,"<p>If you copy the code out of K&amp;R you need to add a <code>system(&quot;pause&quot;)</code>; before you end <code>main()</code> and make sure you save the file with <code>.c</code></p>
<pre><code>int main()
{
   printf(&quot;Hello, world\n&quot;);
   
   system(&quot;pause&quot;);
   return 0;   
}
</code></pre>
",0
274648,273560,0,"<p>The <a href=""http://www.w3.org/TR/REC-PICSRules"" rel=""nofollow noreferrer"">PICSRules spec</a> defines what PICS rules should look like. I don't think your file is one of those.</p>

<p>Is that the <em>entire</em> file contents above?</p>

<p>Are you sure that it's definitely a PICS rules file? There are many file types which use the .prf extension, perhaps it's one of those.</p>
",1
594024,594006,0,"<p>Not bad. If you worked with me and you wrote that code, I wouldn't ask you to change it.</p>

<p>You could decrement <code>count</code> until it reaches zero, instead of incrementing <code>i</code> until it reaches <code>count</code>, but it's arguable whether that would be an improvement or not.</p>
",0
594027,594006,1,"<p>There's nothing seriously wrong with this code.  But to make this more robust, I would:</p>

<ol>
<li><p>Save the value of <code>fgetc(stdin)</code> to an <code>int</code> variable, then test it to make sure it's a blank using <code>isspace()</code>, reporting an error if not.  Use an <code>int</code> not a <code>char</code> because <code>fgetc()</code> returns <code>EOF</code> at end of file, which cannot fit inside a <code>char</code>.</p></li>
<li><p>Another minor concern is that on modern filesystems, file sizes can be larger than <code>INT_MAX</code>.  Instead of ""faking"" a <code>count</code> value of <code>INT_MAX</code> when <code>k</code> &lt; 0, I would change the loop test to test it explicitly.</p></li>
</ol>

<p>In summary, the main loop becomes:</p>

<pre><code>int ch;
for (i = 0; k &lt; 0 || i &lt; k; ++i) {
    ch = fgetc(stdin);
    if (ch == '\n') {
        return 1;
    } else if (ch == EOF) {
        return -1;        /* Or some error code of your choice */
    } else if (!isspace(ch)) {
        return -2;        /* Or some error code of your choice */
    }
}
</code></pre>
",2
594036,594006,0,"<p>I would prefer</p>

<pre><code>if (k &lt; 0) count = 0
else       count = k;

do {
  if(fgetc(stdin) == '\n') return 1;
  count--;
} while (count != 0);

return 0;
</code></pre>

<p>to avoid INT_MAX usage. Note that the first two lines also simply could be changed to ""count = k;"" and that you could change the count variable to a 64-bit type for handling inputs > 2 GB.</p>

<p>If you're having large inputs, you could also try to read whole lines or even the whole file into a buffer and passing a pointer to the skip function to increase performance.</p>
",0
594041,594006,0,"<p>Personally, I wouldn't use the comparison with <code>INT_MAX</code> and the separate count variable, and I'd decrement the supplied value rather than use a <code>for</code> loop.</p>

<p>I might even do:</p>

<pre><code>while (k &lt; 0 || k--) {
    ...
}
</code></pre>

<p>Note that if <code>(k &lt; 0)</code> the decrement never happens due to the <code>||</code> operator's short-circuit behaviour, so you get an infinite loop unless you break out of the loop per your example for <code>\n</code></p>

<p>if <code>(k == 0)</code> the loop will terminate immediately (nb: post-decrement rather than pre-decrement)</p>
",0
594058,594006,0,"<p>critic: you formatting:</p>

<p>"") {"" with a space between is more readable</p>

<p>sometimes you use ""if(expression) statement;"" and sometimes ""if(expression){statement;}"". i would always use the ""{"".</p>

<p>""while ("", ""if ("" on also with a space after the keyword. </p>
",2
470180,470167,1,"<p>I doubt there is a performance issue, at least if you use a 64 bit processor, since the variable is almost always in the cache.</p>
",0
470184,470167,1,"<p>Within broad limits, the change is harmless.  You will need to be sure that any code accessing the value is prepared to handle a 64-bit quantity, and any code that formats its value will need to be changed, but otherwise, it should be safe enough -- in the absence of any information about other code that would be broken by the change.</p>
",0
471774,470167,0,"<p>You should be fine. </p>

<p>I assume (from the pSOS) that you're coding to a Moto 68000, which is a 32-bit processor; working with 64-bit numbers is slightly slower there because it needs a few more instructions (eg, add, check carry, branch or add to high word) but I doubt you're worried much about a four cycle cost. If you are on a 64-bit processor, then 64-bit ops are exactly as fast as 32-bit ones.</p>

<p>Doing this will increase your memory storage overhead of course, but again that's only a concern if you've a great many structures containing these counters. </p>
",0
472146,470167,2,"<p>Is your code assuming that incrementing a 32-bit variable is an atomic operation? Incrementing a 64-bit variable on a 32-bit CPU probably won't be atomic unless you go out of your way to make it so. </p>

<p>Example:</p>

<ol>
<li><code>call_count</code> equals <code>0x00000005FFFFFFFF</code> when a call comes in.</li>
<li>The lower half of <code>call_count</code> is incremented: <code>call_count</code> gets set to <code>0x000000500000000</code> and the CPU's carry bit gets set to 1.</li>
<li>The upper half of <code>call_count</code> is incremented by the carry bit: <code>call_count</code> gets set to <code>0x0000000600000000</code>.</li>
</ol>

<p>If another thread or an interrupt handler reads the value of <code>call_count</code> between steps 2 and 3, it will get the wrong result (<code>0x000000500000000</code> instead of <code>0x000000600000000</code>). The solution is to synchronize access to <code>call_count</code>. A few possibilities:</p>

<ul>
<li>Disable interrupts (if appropriate)</li>
<li>Serialize access using a lock</li>
<li>Read and write using atomic/interlocked functions (example: <code>InterlockedIncrement()</code> on Windows)</li>
</ul>
",0
1313132,1312718,2,"<p>You could use <a href=""http://www.doxygen.nll"" rel=""nofollow noreferrer"">doxygen</a> with <a href=""http://www.graphviz.org"" rel=""nofollow noreferrer"">dot</a> to create a call graph -- it should work fine even without doxygen annotations in the comments.</p>

<p>See some samples of it <a href=""http://images.google.com/images?q=doxygen+call+graph"" rel=""nofollow noreferrer"">here</a>.</p>
",0
1312978,1312718,0,"<p>Source Navigator is a free tool that includes this functionality:</p>

<p><a href=""http://sourcenav.sourceforge.net/"" rel=""nofollow noreferrer"">http://sourcenav.sourceforge.net/</a></p>
",0
1312723,1312718,0,"<p>I don't know of a standalone tool that will do this.  However it is a supported feature of certain IDE's such as Source Insight</p>

<ul>
<li><a href=""http://www.sourceinsight.com/"" rel=""nofollow noreferrer"">http://www.sourceinsight.com/</a></li>
</ul>
",0
1312854,1312718,1,"<p>See <a href=""https://stackoverflow.com/questions/1245979/c-c-call-graph-utility-for-windows-platform"">this discussion</a>.</p>
",0
1313419,1312718,0,"<p><a href=""http://www.gedanken.demon.co.uk/cxref/"" rel=""nofollow noreferrer"">cxref</a> should do what you ask for.</p>
",0
1508800,859943,1,"<p>one option would be the additional flag ""-Wno-sign-compare"" :)</p>
",3
1621375,984866,2,"<p>""C compiles down to machine code and doesn't require any runtime support for the language itself.""</p>

<p>This is the best feature of C</p>
",2
984874,984866,13,"<p>""why we are using C language for writing drivers and OS codes.?""</p>

<p>So that programmers won't have to learn new syntax of each new assembly language for each new kind of machine.</p>

<p>""Is there any drivers written in any other languages?""</p>

<p>Historically, assembly languages. I don't remember if PL/S or BLISS could be used for drivers. Maybe B. In modern times, a few brave people use C++ but they have to be very careful. C++ can be used a bit more easily in user mode drivers in some situations.</p>
",0
984876,984866,14,"<p>Because C has the best combination of speed, low memory use, low-level access to the hardware, and popularity.</p>

<p>Most operating systems have a kernel written in C, and applications on top of that written in either C, C++, C# or Obj-C</p>
",2
984886,984866,8,"<p>C was one of the very first languages (that wasn't assembly) that was suitable for writing operating systems, so it caught on early.  While other languages have appeared since that are also suitable for writing operating systems in, C has remained popular perhaps due to its long history and the familiarity programmers have with its structure and syntax.</p>
",1
984887,984866,24,"<p>C compiles down to machine code and doesn't require any runtime support for the language itself. This means that it's possible to write code that can run before things like filesystems, virtual memory, processes, and anything else but registers and RAM exist.</p>
",8
984915,984866,14,"<p>C is by far the easiest language(other than assembly) to ""get going"" on bare bones hardware. With C, (assuming you have a 32bit bootloader such as GRUB to do the hard mode switching) all you must do is make a little crt0.asm file that sets up the stack and that's it(you get the language, not including libc). With C++ you must worry about dynamic casts, exceptions, global constructors, overriding new, etc etc.. With C# you must port the .Net runtime(which on it's own basically requires a kernel) and I'm not sure about Obj-C, but Im sure it has some requirements also... </p>

<p>C is simply the easiest language to use for drivers. Not only is it easy to get started with, but also it's easy to know exactly what happens at the machine level. Their is no operator overloading to confuse you and such. Sure it's handy in a ""good"" environment, but in Ring 0 where a bad pointer not only crashes your application, but usually results in a triple fault(reboot), blue screen, or kernel panic. You really like knowing what goes on in your machine.. </p>
",0
985013,984866,11,"<p><a href=""http://en.wikipedia.org/wiki/Lisp_machine"" rel=""noreferrer"">Lisp machines</a> had their operating systems written in Lisp, which shows that you don't <em>have</em> to use C or assembly. The Lisp machine business was destroyed by the availability of cheap PCs, whose operating systems were of course written in C and assembly.</p>
",0
985039,984866,0,"<p>As another note for machines that have drivers in other languages, there is the <a href=""http://www.sunspotworld.com/"" rel=""nofollow noreferrer"">SunSpot</a> robotics platform.  Drivers for devices that are connected (sensors, motors, and everything else that can communicate via the I/O pins) are written in Java by the user.</p>
",0
988366,984866,23,"<p>In safety-critical environments (think avionics, spacecraft, medical devices, transportation, control software for process control), systems (as well as drivers) are often written using <a href=""http://en.wikipedia.org/wiki/Ada_(programming_language)"" rel=""noreferrer"">Ada</a> or even <a href=""http://en.wikipedia.org/wiki/SPARK_(programming_language)"" rel=""noreferrer"">SPARK/Ada</a>.</p>

<p>To clarify: C is usually understood to be fairly low level, and pretty much like a ""macro language"" for assembly itself, that's also where its power is coming from (speed, size, portability). </p>

<p>Ada, on the other, hand has been specifically designed for safety-critical applications with verifiability in mind, to quote <a href=""http://www.adacore.com/wp-content/uploads/2006/02/Ada05_mission_critical.pdf"" rel=""noreferrer"">Ada 2005 for Mission-Critical Systems</a>:</p>

<blockquote>
  <p>Ada [9] is the language of choice for many critical systems due to its careful design and the existence of clear guidelines for building high integrity systems [10]</p>
</blockquote>

<p>That's also where Ada's support for strong typing comes in, as well as a number of other important features (quoting <a href=""http://www.eng.warwick.ac.uk/staff/ns/papers/design%20for%20safety.pdf"" rel=""noreferrer"">design for safety</a>):</p>

<blockquote>
  <p>Programming languages differ wildly in
  their appropriateness for use in
  safetyrelated systems. Carr¨¦ et al.
  identified six factors that influence
  the suitability of a language for
  high-integrity applications [Carr¨¦
  1990]. These are: </p>
  
  <ul>
  <li>Logical soundness</li>
  <li>Complexity of definition </li>
  <li>Expressive power </li>
  <li>Security </li>
  <li>Verifiability</li>
  <li>Bounded time and space constraints </li>
  </ul>
  
  <p>No standard programming language performs
  well in all these areas although some
  (such as Pascal and Ada) perform much
  better than languages such as C or
  C++. In highly critical applications
  ¡®verifiability¡¯ is of great
  importance. Certain languages allow
  powerful software verification tools
  to be used to perform a wide range of
  static tests on the code to detect a
  range of programming errors.
  [...] An
  important issue in the selection of a
  programming language is the quality of
  the available compilers and other
  tools. For certain languages validated
  compilers are available. While not
  guaranteeing perfection, validation
  greatly increasing our confidence in a
  tool. Unfortunately, validated
  compilers are only available for a
  limited number of languages, such as
  Ada and Pascal. In addition to
  compilers, developers of critical
  systems will make use of a range of
  other tools such as static code
  analysis packages. The static tests
  that can be performed on a piece of
  code vary greatly depending on the
  language used. To aid this process it
  is common to restrict the features
  that are used within certain languages
  to a ¡®safe subset¡¯ of the language.
  Well structured and defined languages
  such as subsets of Ada, Pascal and
  Modula-2 allow a great many tests to
  be performed such as data flow
  analysis, data use analysis,
  information flow analysis and range
  checking. Unfortunately many of these
  tests cannot be performed on languages
  such as C and C++ .</p>
</blockquote>

<p>It would be really beyond the scope of this question to go into even more detail, but you may want to check out some of the following pointers:</p>

<ul>
<li><a href=""http://www.adaic.org/whyada/ada-vs-c.html"" rel=""noreferrer"">Ada compared to C and C++</a></li>
<li><a href=""http://www.adaic.org/whyada/ada-vs-c/ada-vs-c.html"" rel=""noreferrer"">Ada vs. C</a></li>
<li><a href=""http://www.stsc.hill.af.mil/crosstalk/1996/07/quantify.asp"" rel=""noreferrer"">Quantifying the Debate: Ada vs. C++</a></li>
<li><a href=""http://ftp.cs.kuleuven.be/~dirk/ada-why2.html"" rel=""noreferrer"">Why choosing Ada as a teaching language? (Ada vs. C in University)</a></li>
<li><a href=""http://www.adaic.com/whyada/ada-vs-c/cada_art.html"" rel=""noreferrer"">Comparing Development Costs of C and Ada</a> (<a href=""http://c2.com/cgi/wiki?CeeVsAdaStudy"" rel=""noreferrer"">summary</a>)</li>
<li><a href=""http://th.informatik.uni-mannheim.de/teach/SichSyst-04/SichSyst04-00b.pdf"" rel=""noreferrer"">C / C++ / Java Pitfalls
&amp; Ada Benefits</a></li>
<li><a href=""http://www.beesknees.freeserve.co.uk/articles/ada-vs-cpp.html"" rel=""noreferrer"">Is Ada a better C?</a></li>
<li><a href=""http://www.dwheeler.com/steelman/steeltab.htm"" rel=""noreferrer"">Ada, C, C++, and Java vs. The Steelman</a></li>
<li><a href=""http://www.stsc.hill.af.mil/crosstalk/frames.asp?uri=1995/11/Despelli.asp"" rel=""noreferrer"">Ada: Dispelling the Myths</a></li>
<li><a href=""http://www.cs.aau.dk/~bt/DAT5E07/boegholm2.pdf"" rel=""noreferrer"">Real-time programming safety in Java and Ada</a></li>
</ul>

<p>If anyone wants to look into Ada some more, check out this: <a href=""http://en.wikibooks.org/wiki/Ada_Programming"" rel=""noreferrer"">Ada Programming (wikibooks)</a></p>

<p>There are even programming languages that are specifically developed for highly critical applications, such as <a href=""http://en.wikipedia.org/wiki/JOVIAL"" rel=""noreferrer"">JOVIAL</a> or <a href=""http://en.wikipedia.org/wiki/HAL/S"" rel=""noreferrer"">HAL/S</a>, the latter of which is used by the space shuttle program.</p>

<blockquote>
  <p>Is there any drivers written in any other languages?</p>
</blockquote>

<p>I have seen some Linux drivers for special hardware being written in Ada, don't know about other operating systems though. However, such drivers usually end up wrapping the the C API.</p>
",2
988445,984866,3,"<p>Remember that C was originally developed for writing operating systems (in this case - Unix) and similar low-level stuff. It is wery close to the system architecture and does not contain any extra features that we want to control, how they exactly work. However, please note that the rest of the operating system, including the programming libraries, does not have to be written in the same language, as the kernel. The kernel functions are provided through a system of interrupts and in fact such programming libraries can be written in any language that supports assembler snippets.</p>

<p>The most popular operating system nowadays are written in C: Windows, Linux and many other Unix clones, however this is not the rule. There are some object-oriented operating systems, where both the kernel and the programming interface are written in an objective language, such as:</p>

<ul>
<li>NeXTSTEP - Objective-C</li>
<li>BeOS - C++</li>
<li>Syllable - C++</li>
</ul>

<p>See: <a href=""http://en.wikipedia.org/wiki/Object-oriented_operating_system"" rel=""nofollow noreferrer"">Object-oriented operating system on Wikipedia</a></p>

<p>Note that in Linux, it is possible to write kernel drivers in the languages other than C (however, it is not recommended). Anyway, everything becomes a machine code when it comes to running it.</p>
",1
988452,984866,4,"<p>C is also a language that teaches a lot about memory management and is low-level enough to show the barrier between hardware and software. This is something that is rare among many methodologies today, that have grown more towards abstraction way above anything at the hardware level. I find C is a great way to learn these things, while being able to write speedy code at the same time.</p>
",0
52565,52445,5,"<p>I've never seen anything. Really, C++ templates are the enabling technology for STL and much of boost, and C doesn't have them. I've seen many C-interface libraries for things like image processing, 3D graphics, networking, etc., but never a real general-purpose library like boost. You can find pieces though - threading libraries, string libraries, etc. - that are similar to sections of boost.</p>
",0
1849913,1849895,8,"<p>So that you can create variables of the enumeration type:</p>

<pre><code>enum boolean read_file = NO;
</code></pre>
",0
1849914,1849895,1,"<p>Well, you might want to define a function like this:</p>

<pre><code>void here_is_my_answer(boolean v)
{
   if (v == YES) { 
   } else {
   {
}
</code></pre>
",0
1849917,1849895,6,"<p>If you want to create a type that is 'of the enum', such as:</p>

<pre><code>enum boolean x;
x = NO;
</code></pre>

<p>The easier way to do this is with a typedef:</p>

<pre><code>typedef enum {NO, YES} boolean;
</code></pre>

<p>And then all you have to do is use boolean as the type:</p>

<pre><code>boolean x;
x = NO;
</code></pre>
",0
1849943,1849895,2,"<p>If I'm understanding you right you're simply using an example that is too basic.</p>

<p><a href=""http://users.csc.calpoly.edu/~jdalbey/101/Lectures/EnumeratedTypes.html"" rel=""nofollow noreferrer"">Days of the week</a> is a good example of enums.</p>
",0
766837,766830,4,"<p>I am not sure the author would like you copying their work.  So my answer does not apply to your question about managing the manual locally.  One thing you can do is to use <a href=""http://www.makeuseof.com/tag/web-annotation-tools-research-annotate-collaborate/"" rel=""nofollow noreferrer"">web annotation tools</a> to manage your own notes.  Take note of that little pesky notice at the top ""<strong>? Copyright 1997 Eric Huss</strong>"" and please respect it.</p>
",13
766838,766830,0,"<p>You could save the web page (""Save Webpage Complete"") to your local drive.</p>

<p>There are also a lot of PDF versions of C manuals.  Search google for ""c manual pdf"" - the first result is one by Dennis Ritchie.</p>

<p>(Beware copyright violations though, I'm not really clear on when you can make personal copies under ""fair use"".)</p>

<p>If you're on Unix, a lot of the C library is available as man pages.  E.g. ""man memcpy"", ""man malloc"", etc.</p>
",2
766839,766830,2,"<p>Look at <a href=""http://www.acm.uiuc.edu/webmonkeys/book/"" rel=""nofollow noreferrer"">http://www.acm.uiuc.edu/webmonkeys/book/</a> and you will see a c guide tar file.  I suspect you could download that file, expand it on your local system, and then annotate at will.</p>
",0
766840,766830,1,"<p>Well, first, you could buy <a href=""http://www.careferencemanual.com/"" rel=""nofollow noreferrer"">Harbison and Steele</a>.</p>

<p>The one you link is marked copyright 1997, so I'd suggest you write the author at e-huss@uiuc.edu and ask permission.  But there's nothing preventing you from using <a href=""http://linuxreviews.org/man/wget/"" rel=""nofollow noreferrer"">wget</a> to download a copy.</p>
",4
766841,766830,4,"<p>You could use something like wget to grab the site and store it locally. </p>

<p>You could then edit the pages yourself, adding/removing content you see fit. </p>

<p>This worked for me:</p>

<pre><code>  wget --mirror -w 2 -p --convert-links http://www.acm.uiuc.edu/webmonkeys/book/c_guide/
</code></pre>
",1
766845,766830,2,"<p>Yes, to do this download the entire manual using your browser, wget or whichever tool you have available. Next create a bookmark to the files on your hard drive or optionally install a local webserver to link to. Finally, you can add notes by editing the files, or by using annotations as ojblass suggests.</p>

<p>Also, here's another I find handy, an archive of some <a href=""http://c-faq.com/index.html"" rel=""nofollow noreferrer"">comp.lang.c</a> posts.</p>
",0
766848,766830,0,"<p>Most C functions are already described on your system in the manpages.  For instance, <code>man floor</code> will give you the documentation for the floor function.  Sometimes there is a conflict between a function and commandline program.  A good example of this is <code>man printf</code> which gives you the manpage for the <code>printf</code> command (<code>printf(1)</code>).  At the end of the page you will normally find a <code>SEE ALSO</code> section that lists other places to look.  In this case you should see <code>printf(3)</code>.  You can display that page by saying <code>man 3 printf</code>.</p>
",0
767097,766830,3,"<p>Most answers bring up the legality of the thing or lack thereof.</p>

<p>Actually, I am not so sure making a local copy of a website strictly for personal use constitutes copyright infringement. </p>

<p>First of all, there is no mention of where the person is located, so we don't even know what copyright laws apply. For instance, Canada and Australia have some explicit positions regarding personal use of lawfully acquired properties, and I believe there are a few rulings in the US along the same line.</p>

<p>Second, by visiting a website, you are automatically making a personal copy using a software called a browser. This is not, I believe, a copyright violation. </p>

<p>Should the user use an offline browser of some kind (like wget) to visit the website and store it on his hard drive, I do not see why this would be prohibited in anyway.</p>

<p>Antecedents and context are also important. If you consider that most websites are archived and made publicly available by the wayback machine (see <a href=""http://web.archive.org/web/"" rel=""nofollow noreferrer"">http://web.archive.org/web/</a>*/<a href=""http://www.acm.uiuc.edu/webmonkeys/book/c_guide"" rel=""nofollow noreferrer"">http://www.acm.uiuc.edu/webmonkeys/book/c_guide</a>), an usage which is not challenged (archive.org is based in the US), it is pretty difficult to make a valid argument against a private copy intented as a personal reference. </p>

<p>In short, I don't think making a personal copy of a website for strictly private use is a violation of current copyright laws in most countries.</p>

<p>On the other end, distributing the said copy would be a different matter entirely.</p>
",2
43527,42693,0,"<p>Little addition,</p>

<p>instead of using</p>

<pre><code>switch(input)
</code></pre>

<p>use...</p>

<pre><code>switch (toupper(input))
{
    case 'A':
</code></pre>

<p>This will allow the user to  enter 'a' or 'A' and saves you having to check for upper and lower case </p>
",0
48627,42693,1,"<p><code>getchar()</code>, or <code>cgetc()</code>, depending on the platform</p>
",0
435841,435834,28,"<p>Low level functions such as OS kernel and drivers. For those, C is unbeatable.</p>
",10
435844,435834,11,"<p>Small apps that don't have a UI, especially when you're trying to learn.</p>

<p><strong>Edit:</strong> After thinking a little more on this, I'd add the following: if you already know a higher-level language and you're trying to learn more about C, a good route may be to not create a whole new C app, but instead create a C DLL and add functions to it that you can call from the higher language.  In this way you can replace simple functions that your high language already has to ensure that you C function does what it should (gives you pre-built testing), lets you code mostly in what you're familiar with, uses the language in a problem you're already familiar with, and teaches you about interop.</p>
",3
435852,435834,45,"<p>Code where you need absolute control over memory management.  Code where you need to be utterly in control of speed versus memory trade-offs.  Very low-level file manipulation (such as access to the raw devices).</p>

<p>Examples include OS kernel, and embedded apps.</p>

<p>In the late 1980s, I was head of the maintenance team on a C system that was more than a million lines of code.  It did database access (Oracle), X Windows graphics, interprocess communications, all sorts of good stuff.  It ran on VMS and several varieties of Unix.  But if I were to recreate that system today, I sure wouldn't use C, I'd use Java.  Others would probably use C#.</p>
",3
435854,435834,15,"<p>Those 100 lines of python code that were accounting for 80% of your execution time.</p>
",1
435867,435834,7,"<ul>
<li>Number crunching (for example, libraries to be used at a higher level from some other language like Python).</li>
<li>Embedded systems programming.</li>
</ul>
",0
435883,435834,8,"<p>Anything where you think of using assembly.</p>
",1
435884,435834,0,"<p>Don't treat C as a beefed up assembler. I've done some serious app's in it when it was the natural language (e.g., the target machine was a Solaris box with X11). </p>

<p>Write something with some meat on it. Write  a client server chess program, where the AI is on a server and the UI is displaying in X11; once you've done that you will really know C.</p>
",2
435895,435834,1,"<p>Implicit in your question is the assumption that a 'high-level' language like Python or Perl (or Java or ...) is fast enough, small enough, ... enough for most applications. This is of course true for most apps and some choice X of language. Given that, your language of choice almost <em>certainly</em> has a foreign function interface (FFI). Since you're looking to <em>learn</em> C, create a module in the FFI built in C.</p>

<p>For example, let's assume that your tool of choice is Python. Reimplement a subset of <a href=""http://numpy.scipy.org/"" rel=""nofollow noreferrer"">Numpy</a> in C. Since C is a pretty fast language, and has, in C99, a clear numeric library interface, you'll get the opportunity to experience the power of C in an appropriate setting.</p>
",0
435904,435834,0,"<p>ISAPI filters for Internet Information Server.</p>
",0
435910,435834,6,"<p>A bootloader.  Some assembly also required, which is actually very nice..</p>
",0
436032,435834,2,"<p>Embedded stuff, where memory-usage and cpu-speed matters.
<br>The interrupt handler part of an OS (and maybe two or three more functions in it).</p>

<p>Even if some of you will now start to bash heavily on me now: 
<br>I dont think that any decent app should be written in C - it is way too error prone.
(and yes, I do know what I am talking about, having written an awful lot of code in C myself (OSes, compilers, VMs, network protocols, RT-control stuff etc.).</p>

<p>Using a high level language makes you so much more productive. Speed is typically gained by keeping the 10-90 rule in mind: 90% of CPU time is spent in 10% of your code (which you should optimize first).
Also, using the right algorithm might give more performance than optimizing bits in C. And doing things right in C is so much more trouble.</p>

<p>PS: I do really mean what I wrote in the second sentence above; you can write a complete high performance OS in a high level language like Lisp or Smalltalk, with only a few minor parts in C. Think how the 70's Lisp machines would fly on todays hardware...</p>
",0
435938,435834,20,"<p>You can use C to write anything.  It is a very general purpose language.  After doing so for a little while you will understand why there are other ""higher level"" languages available.  </p>

<p>""Learn C"", by all means, but don't don't stick with it for too long.  Other languages are far more productive.</p>

<p>I think the gist of the people who say you need to learn C is so that you understand the relationship between high level code and the machine internals and what exaclty happens with bits, bytes, program execution, etc.  </p>

<p>Learn that, and then move on.  </p>
",5
435952,435834,0,"<p>Before actually write C code, i would suggest first read good C code.<br>
Choose subject you want to concentrate on, basically any application can be written in C, but i assume GUI application will be not your first choice, and find few open source projects to look into.   </p>

<p>Not any open source project is best code to look. I assume that after you will select a subject there is a place for another question, ask for best open source project in the field.<br>
Play with it, understand how it's working modify some functionality...<br>
Best way to learn is learn from somebody good. </p>
",0
435955,435834,0,"<p>Photoshop plugin filters.  Lots and lots of interesting graphical manipulation you can do with those and you'll need pure C to do it in.</p>

<p>For instance that's a gateway to fractal generation, fourier transforms, fuzzy algorithms etc etc.  Really anything that can manipulate image/color data and give interesting results</p>
",2
435981,435834,2,"<p>Anything where you need a minimum of ""magic"" and need the computer to do <strong>exactly</strong> what you tell it to, no more and no less.  Anything where you don't trust the ""magic"" of garbage collection to handle your memory because it might not be as efficient as what you can hand-code.  Anything where you don't trust the ""magic"" of built-in arrays, strings, etc. not to waste too much space.  Anything where you want to be able to reason about exactly what ASM instructions the compiler will emit for a given piece of code.</p>

<p>In other words, not too much in the real world.  Most things would benefit more from higher level abstraction than from this kind of control.  However, OS code, device drivers, and a few things that have to be near optimal in <strong>both</strong> space and speed might make sense to write in C.  Higher level languages can do pretty well competing with C on speed, but not necessarily on space.</p>
",3
436591,435834,0,"<p>I wonder why nobody stated the obvious:</p>

<p>Web applications.</p>
",2
436641,435834,-2,"<p>The short answer is <em>none</em>. The slightly longer answer would be any time you have a system's programming task, and don't have access to any compiler for a better language.</p>

<p>For system's programming tasks, you are far better served by using something as powerful but safer and less error-prone like Ada. For general purpose OO programming, languages like C++, Java, and Ada again are far better choices. For a lot of specific tasks, like string manipulation or website generation, there are domain-specific languages that will make your job much easier for you.</p>
",0
436652,435834,7,"<p>A lot of people are saying OS kernel and device drivers which are, of course, good applications for C.  But C is also useful for writing any performance critical applications that need to use every bit of performance the hardware is capable of.</p>

<p>I'm thinking of applications like database management systems (mySQL, Oracle, SQL Server), web servers (apache, IIS), or even we browsers (look at the way chrome was written).</p>

<p>You can do so many optimizations in C that are just impossible in languages that run in virtual machines like Java or .NET.  For instance, databases and servers support many simultaneous users and need to scale very well.  A database may need to share data structures between multiple users (threads/processes), but do so in a way that efficiently uses CPU caches.  In C, you can use an operating system call to determine the size of the cache, and then align a data structure appropriately to the cache line so that the line does not ""ping pong"" between caches when multiple threads access adjacent, but unrelated data (so called ""false sharing).  This is one example.  There are many others.</p>
",0
436684,435834,1,"<p>A few kinds that I can think of:</p>

<ul>
<li>Systems programming that directly uses Unix/Linux or Win32 system calls</li>
<li>Performance-critical code that doesn't have much string manipulation in it (e.g., number crunching)</li>
<li>Embedded programming or other applications that are severely resource-constrained</li>
</ul>

<p>Basically, C gives you portable, efficient access to the native capabilities of the machine;  everything else is your responsibility.  In particular, string manipulation in C is tedious, error-prone, and generally nasty;  the most effective way to do extensive string operations with C may be to use it to implement a language that handles strings better...</p>
",0
436993,435834,5,"<ol>
<li><p>Where you feel the need for 100% control over your program.
This is often the case in lower layer OS stuff like device drivers, 
or real embedded devices based on MCU:s etc etc (all this and other is already mentioned above)</p></li>
<li><p>But please note that C is a mature language that has been around for many years 
and will be around for many more years, 
it has many really good debugging tools and still a huge number off developers that use it.
(It probably has lost a lot to more trendy languages, but it is still huge)
All its strengths and weaknesses are well know, the language will probably not change any more.
So there are not much room for surprises... </p></li>
</ol>

<p>This also means that it would probably be a good choice if you have a application with a long expected life cycle.</p>

<p>/Johan</p>
",0
437314,435834,1,"<p>examples are: embedded apps, kernel code, drivers, raw sockets.  </p>

<p>However if you find yourself more productive in C then go ahead and build whatever you wish.  Use the language as a tool to get your problem solved.</p>
",0
437031,435834,0,"<p>Any place where the underlying libraries are entirely in C is a good candidate for staying in C - openGL, Lua extensions, PHP extensions, old-school windows.h, etc. </p>
",1
437348,435834,0,"<p>I prefer C for anything like parsing, code generation - anything that doesn't need a lot of data structure (read OOP). It's library footprint is very light, because class libraries are non-existent. I realize I'm unusual in this, but just as lots of things are ""considered harmful"", I try to have/use as little data structure as possible.</p>
",0
437501,435834,0,"<p>Well, if you want to learn C and have some fun at the same time, might I suggest obtaining NXC and a Lego Mindstorms set? NXC is a C compiler for the Lego Mindstorms.</p>

<p>Another advantage of this approach is that you can compare the effort to program the Mindstorms ""brick"" with C and then try LEJOS and see how it goes with Java.</p>

<p>All great fun.</p>
",1
438090,435834,2,"<p>Garbage collectors!</p>

<p>Also, simply programs whose primary job is to make operating-system calls.  For example, I need to write a short C program called <code>timeout</code> that </p>

<ul>
<li>Takes a command line as argument, with a number of seconds for that command to run</li>
<li>Forks two child processes, one to run the command and one to sleep for N seconds</li>
<li>When the first of the child processes exits, kills the other, then exits</li>
</ul>

<p>The effect will be to run a command with a limit on wall-clock time.</p>

<p>I and others on this forum have tried several different solutions using shells and/or perl.  All are convoluted and none quite do the right thing.  In C the solution will be easy, because all the OS facilities are right where you can get at them.</p>
",0
441521,435834,0,"<p>I'd say that with the minuscule runtime environment and it's self-contained nature, you might start by creating some CLI utilities such as grep or tail (or half the commands in Unix).  Anything that uses only STDOUT, STDIN and file manipulation is a good candidate.</p>

<p>This isn't exactly answering your question because I wouldn't actually CHOOSE to use C in such an app, but I hope it's answering the question you meant to ask--""what would be a good type of app to use learn C on?""</p>

<p>C isn't actually that bad a language--it's pretty easily to understand your code at an assembly language level which is quite useful, and the language constructs are few, leaving a very sparse language.</p>

<p>To answer your actual question, the very best use of C is the one for which it was created--porting itself (and UNIX) to other CPU architectures.  This explains the lack of language features very well; it also explains the existence of Pointers which are really just a construct to make the compiler work less--any code created with pointers could be created without it (just as well optimized), but it becomes much harder to create a compiler to do so.</p>
",0
441494,435834,0,"<p>Following on from what someone else said. C seems a good language to implement the language in which you write the rest of your software. </p>

<p>And (mutatis mutandis) the virtual machine which runs the rest of your software. </p>
",0
443071,435834,1,"<p>c compiler</p>
",0
451359,435834,1,"<p>Researches in maths and physics. There are probably two alternatives: C and C++, but such features of the latter as encapsulation and inheritance are not very useful there. One could prefer to use C++ ""as a better C"" or just stay with C.</p>
",0
579744,579734,14,"<p>Initialization and assignment are two distinct operations that happen to use the same operator (""="") here.</p>
",0
579754,579734,62,"<p>There is no such thing as a ""string"" in C. In C, strings are one-dimensional array of <code>char</code>, terminated by a null character <code>\0</code>. Since you can't assign arrays in C, you can't assign strings either. The literal ""hello"" is syntactic sugar for <code>const char x[] = {'h','e','l','l','o','\0'};</code></p>

<p>The correct way would be:</p>

<pre><code>char s[100];
strncpy(s, ""hello"", 100);
</code></pre>

<p>or better yet:</p>

<pre><code>#define STRMAX 100
char    s[STRMAX];
size_t  len;
len = strncpy(s, ""hello"", STRMAX);
</code></pre>
",2
579758,579734,75,"<p>When initializing an array, C allows you to fill it with values. So</p>

<pre><code>char s[100] = ""abcd"";
</code></pre>

<p>is basically the same as</p>

<pre><code>int s[3] = { 1, 2, 3 };
</code></pre>

<p>but it doesn't allow you to do the assignment since <code>s</code> is an array and not a free pointer. The meaning of </p>

<pre><code>s = ""abcd"" 
</code></pre>

<p>is to assign the pointer value of <code>abcd</code> to <code>s</code> but you can't change <code>s</code> since then nothing will be pointing to the array.<br>
This can and does work if <code>s</code> is a <code>char*</code> - a pointer that can point to anything.</p>

<p>If you want to copy the string simple use <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_strcpy.htm"" rel=""noreferrer""><code>strcpy</code></a>.</p>
",8
579767,579734,3,"<pre><code>1    char s[100];
2    s = &quot;hello&quot;;
</code></pre>
<p>In the example you provided, s is actually initialized at line 1, not line 2.  Even though you didn't assign it a value explicitly at this point, the compiler did.</p>
<p>At line 2, you're performing an assignment operation, and you cannot assign one array of characters to another array of characters like this.  You'll have to use <code>strcpy()</code> or some kind of loop to assign each element of the array.</p>
",2
579768,579734,2,"<p>To expand on <a href=""https://stackoverflow.com/questions/579734/assigning-strings-to-arrays-of-characters/579744#579744"">Sparr's answer</a></p>

<blockquote>
  <p>Initialization and assignment are two distinct operations that happen to use the same operator (""="") here.</p>
</blockquote>

<p>Think of it like this:</p>

<p>Imagine that there are 2 functions, called <code>InitializeObject</code>, and <code>AssignObject</code>. When the compiler sees <code>thing = value</code>, it looks at the context and calls one <code>InitializeObject</code> if you're making a new <code>thing</code>. If you're not, it instead calls <code>AssignObject</code>.</p>

<p>Normally this is fine as <code>InitializeObject</code> and <code>AssignObject</code> usually behave the same way. Except when dealing with char arrays (and a few other edge cases) in which case they behave differently. Why do this? Well that's a whole other post involving the stack vs the heap and so on and so forth.</p>

<p>PS: As an aside, thinking of it in this way will also help you understand copy constructors and other such things if you ever venture into C++</p>
",0
581915,579734,1,"<p>Note that you can still do:</p>

<pre><code>s[0] = 'h';
s[1] = 'e';
s[2] = 'l';
s[3] = 'l';
s[4] = 'o';
s[5] = '\0';
</code></pre>
",3
103764,103669,35,"<p>I think the trouble with this question is that the answer is kind of meaningless.  I see people talking about experience, and that's good, and I see people talking about understanding the intricacies of the language, and that's good.  However, if I were hiring someone to work on my C project, and I had a magic 8-ball that would give me an accurate answer to any one (and only one) question, I would never ask it, ""Are they a C expert"".</p>

<p>Why?</p>

<p>Just because someone is a C expert doesn't mean that they're a good software developer.  Experience and language familiarity are good, but I think they are both trumped by that intangible, un-quantifiable property that makes someone a ""good software developer"".  What I'm trying to say is, ""What makes you a C programming expert?"" is not a useful question, because there are more important questions.  If someone is a <strong>G</strong>ood <strong>P</strong>rogrammer, they will rise to the occasion.</p>

<p>As an example: You can be a C programming expert and be horrible on a team.  You can be a C programming expert and refuse to use version control.  You can be a C programming expert without knowing how to actually <strong>DO</strong> anything with C.  </p>

<p>The ""without"" clauses in those sentences are equally important questions:  What makes you a good team programmer?  What's the best way to use SCM <em>x</em> or <em>y</em>?  How do you approach programming a client/server game, or billing application, or web browser, or operating system, or compiler, in C?  If a candidate told me ""No, I am not a C expert"", but gave me great answers to these other questions, I would hire them in a heartbeat over the guy who the magic 8-ball said was a C expert, but doesn't know how to check his code into subversion and hasn't learned a new language in 12 years.</p>
",5
103786,103669,3,"<p>You're an expert in C when you can write your own C compiler.</p>
",0
103684,103669,6,"<p>You're an expert in c if you can answer all the questions tagged ""c"" on stackoverflow.com without blinking.</p>
",4
103687,103669,8,"<p>Everyone is an expert at a job fair</p>
",0
103697,103669,4,"<p>Some may disagree but I think experience is key to being an expert in any language. I know plenty of people who've past the certification test but couldn't apply their knowledge to anything practical in the real world.</p>

<p>So I think overall being an expert is a product of having enough knowledge on a given subject (C) and then having applied it to enough real world scenarios to make the mistakes that we all do and learn from them.</p>
",0
103900,103669,6,"<p>This doesn't directly answer your question (sorry), but it might help you decide how you classify yourself.</p>

<p>Instead of just ""expert"" and ""clueless newbie"" I prefer the three-level system of expertise used by the medieval guilds:</p>

<h3>Apprentice</h3>

<ul>
<li>Still needs to RTFM.</li>
<li>Getting to grips with the tools and techniques of his craft.</li>
<li>Needs supervision.</li>
</ul>

<h3>Journeyman</h3>

<ul>
<li>Has Read The Effin' Manual.</li>
<li>Competent with all the standard tools and techniques of his craft.</li>
<li>Can work alone, and can supervise apprentices on routine jobs.</li>
</ul>

<h3>Master</h3>

<ul>
<li>Could have Written The Effin' Manual.</li>
<li>Is developing or adopting new tools and techniques.</li>
<li>Can oversee a major project that might never have been attempted before.</li>
</ul>

<p>At a job fair?  There are no experts: everybody's an expert.  :)</p>
",0
103705,103669,1,"<p>Mastery of pointers.</p>
",4
103706,103669,19,"<p>To someone less skilled than you, you're an expert.</p>

<p>To someone more skilled than you, you're a newbie.</p>
",0
103710,103669,1,"<p>I would say that for any given language, experience is the key thing. It just takes time to learn a language and learn the APIs and 'idioms' that the language uses. Whether someone is an expert in anything or not is something that should be asked of ones peers. To paraphrase Jeff Foxworthy, ""If you answer more questions than you ask, you <em>might</em> be an expert.""</p>
",0
103714,103669,21,"<p>When I interviewed with Google, the interviewer told me to think about it this way.  On a scale of 1-10 for C proficiency, to say you're a ""10"" means you've written papers and/or books or been a speaker in a conference on programming in C.  Based on this, very few people are 10s.</p>

<p>FWIW, I have been programming in C for 15 years.  I consider myself very proficient.  I'd perhaps give myself a solid 8 or 8.5.</p>
",7
103716,103669,1,"<p>I think a fair answer would be understanding all of the intracies of ISO C.</p>

<p>The reality, as any comp.lang.c regular will tell you, is that almost nothing that people need to do can be done in pure ISO C, as you generally need to interact with your environment in a more well defined way.  That's where POSIX comes about.</p>

<p>I would not blink at anyone who self-ranked themselves as an ""Expert"" who had a solid understanding of the language of C, a decent understanding of what ISO C promises, and a working understanding of the POSIX functions.</p>
",0
103726,103669,2,"<p>Interview questions like this are always tough. You want to blow your own horn a little, but not sound like a blowhard.</p>

<p>If you have done a lot with C (say, worked on open source projects in C), then I'd respond with that, but not just by pointing to the list of accomplishments on your resume, but by talking about one or more of them and what was particularly interesting or challenging about it (in regards to its use of C).</p>
",0
103730,103669,2,"<p>How about having read ""Expert C Programming"" by Peter van der Linden and remembering everything he covered? </p>
",1
103745,103669,16,"<p>Experience is key, knowing the ""rules"" and syntax of the of the language is of course a must, but it is only a base. Learning the common pitfalls and idioms for doing things right is key.</p>

<p>Knowing what if any resources exist to get help from while your programing, and of course, knowing you're tool chain. I've known many C++ ""experts"" who had never used a debugger, or a memory tracker. If you ask me, being an expert in something is different from being proficient in something in you knowing all aspects of it.</p>
",1
103757,103669,2,"<p>Lacking a standard test there's really no way to decide what expert level is but here are a few of my litmus tests, everyone's list is different, I'm sure.</p>

<p>Without looking at documentation:</p>

<ul>
<li><p>Know the precedence of the main operators so you don't have to litter your code with parens to avoid getting the wrong order of evaluation</p></li>
<li><p>Be able to write a prototype for a simple function pointer</p></li>
<li><p>Be comfortable with passing a pointer to a pointer</p></li>
<li><p>Understand block, function, module scope</p></li>
</ul>

<p>There are more items like this.</p>

<p>On the other hand, I don't think you have to be able to understand or be able to write out Duff's device or figure out obfuscated C contests in your head to consider yourself an expert.</p>

<p>Even if I considered myself an expert (not sure I do) I probably would never claim it in a job interview.</p>

<p>Andrew</p>
",2
576041,457129,1,"<p>If you want some good source code to read, I can heartily suggest Simon Tatham's Puzzle Collection (<a href=""http://www.chiark.greenend.org.uk/~sgtatham/puzzles/"" rel=""nofollow noreferrer"">http://www.chiark.greenend.org.uk/~sgtatham/puzzles/</a>, scroll down to the bottom for developer documentation).  From it, you can learn:</p>

<ul>
<li>How to do object-oriented-like programming in C (each game is in a sense a class that implements the ""game"" interface).</li>
<li>How to write portable C (hide all the unportable stuff behind your own interface).</li>
<li>How to comment and document your code.</li>
<li>How to do GUI programming in C.</li>
<li>How to implement data structures in C (I recall the union find and 2-4 trees being done).</li>
</ul>
",1
578661,457129,5,"<p>Well, if you want to ""start from level zero"" i recommend learning assembly. yes assembly. I learned 6502, you can learn x86 if you like or arm or mips. Find a emulator or an interrupter and read some tutorials. You'll understand exactly how a CPU works and code will make much more sense (like why does getkeys not update until you do pollkeys and etc).</p>

<p>After that i recommend C# because it isnt as nasty as c/c++ (i primarily use c++). You'll understand how a C# line could be represented in assembly. C# allows you to do more things you want to do unlike c and c++ (heres a list of things that we can do in c++ that we will be able to do in the next standard <a href=""http://en.wikipedia.org/wiki/C%2B%2B0x"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/C%2B%2B0x</a>, C# has a few of these).</p>

<p>If you want to learn a lot you can try learning the language i recommend here <a href=""https://stackoverflow.com/questions/498964/the-difficulty-in-learning-new-languages-by-yourself/578618#578618"">https://stackoverflow.com/questions/498964/the-difficulty-in-learning-new-languages-by-yourself/578618#578618</a> which i think is a good idea after assembly.</p>
",1
457407,457129,1,"<p>After reading the ""The C Programming Language"" like many suggested i would start looking into open source projects and learn from practical examples. There is a lot and it's not easy to find the right one, but learning from reading good code is the best alternative for learning from good coder :)<br>
If you have one around: pair programming or just mutual code reviews is the best way to learn. </p>
",0
457439,457129,1,"<p>1) The C programming Language K&amp;R
2) Read a lot of C source code. <a href=""http://www.google.com/codesearch"" rel=""nofollow noreferrer"">Google code search</a></p>

<p>That is all.</p>
",0
457136,457129,7,"<p>My first step in picking up C was a copy of ""The C Programming Language"" - it's a simple book, but the language is itself pretty simple.</p>
",6
457137,457129,28,"<p>Read <a href=""http://en.wikipedia.org/wiki/The_C_Programming_Language_(book)"" rel=""noreferrer"">Kernighan and Ritchie</a> ""The C Programming Language"". It is the classic.</p>

<p>It is the book written by the original creators of the language. It is short, and very readable and well written.</p>
",11
457147,457129,1,"<p>C is a good choice for mainstream education. However before going through books, I'd follow some IDE tutorials, so you get a hang of building projects, and makefiles, those two will be the biggest challenges you'll face initially, and they are rarely covered in any book.</p>
",1
457150,457129,2,"<p>Another option if you want to learn programming fundamentals is to read Knuth's <a href=""http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming"" rel=""nofollow noreferrer"">The Art of Computer Programming</a>. This will introduce you to fundamentals from the very beginning of time. For extra understanding implement the algorithms yourself in C.</p>
",0
457152,457129,-2,"<p>Let us C by Yeshvant P Kanitkar</p>
",1
457154,457129,3,"<p>If you speek German I'd suggest you an <a href=""http://openbook.galileocomputing.de/c_von_a_bis_z/"" rel=""nofollow noreferrer"">open book from Galileo Computing</a>.</p>
",0
457158,457129,13,"<p>I have to disagree with the previous two answers who recommend the famous ""K&amp;R"" guide. I was completely unable to learn anything from that book; I simply gave up after reading the first third of the book about three times. Maybe I'm just dumb.</p>

<p>I suggest, instead, this wonderful book: <a href=""https://rads.stackoverflow.com/amzn/click/com/0393979504"" rel=""noreferrer"" rel=""nofollow noreferrer"">C Programming: A Modern Approach</a> (disclaimer: amazon link)</p>

<p>I've learned everything I need to know about C from that book, and it covers the history as much as needs to be done, while still keeping a ""modern"" point of view.</p>

<p>Caveat: I didn't come to C ""for C"", I passed through it on the way to my eventual goal, Objective-C and Cocoa programming for desktop applications on Apple's Mac OS X. If you really want a very deep knoweldge of C, it may not hurt to get both of the above-mentioned books, and read the K&amp;R guide after reading Modern C</p>
",2
457159,457129,2,"<p>There is a university course at Indiana and Purdue Universities on C-programming. The course has video lectures that you can find at <a href=""http://wally.cs.iupui.edu/n305/"" rel=""nofollow noreferrer"">here</a>.</p>

<p>If you are also interested in looking at C++, there are a bunch of lectures at the <a href=""http://www.wlap.org/"" rel=""nofollow noreferrer"">Web Lecture Archive Project</a> called ""C++ for Particle Physicists"". You find those lectures <a href=""http://www.wlap.org/cern/lectures/tech/c/"" rel=""nofollow noreferrer"">here</a>. The lectures are held by Paul Kunz from Stanford University.</p>

<p>For more C++ lectures, you can also check out <a href=""http://www.youtube.com/user/reconnetworks"" rel=""nofollow noreferrer"">these lectures</a> from Reconnect Networks.</p>
",0
457161,457129,1,"<p>Read ""The C Programming Language"". Write short exercises (some are in the book). Use a compiler, such as <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">gcc</a>. </p>
",0
457165,457129,1,"<p><em>The C programming language</em> is a good starting point.</p>

<p>Moreover, C itself is a good starting point for learning programming fundamentals: you can find C software and C developpers almost everywhere and many other languages take roots in C, such as C++, C#, Objective-C, ...</p>
",0
1587505,457129,-1,"<p><strong>About learning C</strong></p>

<p>If you really want to learn C, [Kernighan and Ritchie ""The C Programming Language"" book](<a href=""http://en.wikipedia.org/wiki/The_C_Programming_Language_(book))"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/The_C_Programming_Language_(book))</a> is good start.</p>

<p>However nowadays, in my opinion, learning C is just mind exercise -- you can learn a lot important details like, for example:</p>

<ol>
<li>Difference between equal operator (<code>==</code>) and assignment instruction (<code>=</code>),</li>
<li>Expression can have value (i.e. <code>a = 1</code> has value 1),</li>
<li>Pointers arithmetic,</li>
<li>Direct memory operations (i.e. <code>memset()</code>, <code>memcpy()</code>).</li>
</ol>

<p>These things are interesting for developers, but most of them is not in use in today mainstream application development (except two first points above).</p>

<p>However if you try to take part in some computer since competitions, C language can be useful.</p>

<p><strong>My recommendation</strong></p>

<p>I would learn C# because it's modern, well designed (in my opinion) object oriented programming language with good, free of charge IDE -- <a href=""http://www.microsoft.com/exPress/"" rel=""nofollow noreferrer"">Visual Studio Express Edition</a>, good support (wide community, a lot of source code to study, a lot of tutorials and examples). With C# you can write console application, desktop application or Web Apps, which makes easy to learn by solving wide range of real problems.</p>

<p>Also, on .NET platform there are some other interesting choices -- <a href=""http://www.codeplex.com/wikipage?ProjectName=IronPython"" rel=""nofollow noreferrer"">IronPyton</a> or functional <a href=""http://research.microsoft.com/en-us/um/cambridge/projects/fsharp/"" rel=""nofollow noreferrer"">F#</a>.</p>
",0
1587549,457129,0,"<p>1) <a href=""http://cm.bell-labs.com/cm/cs/cbook/"" rel=""nofollow noreferrer"">Kernighan &amp; Ritchie</a></p>

<p>2) <a href=""https://rads.stackoverflow.com/amzn/click/com/1556155514"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">Writing Solid Code</a></p>

<p>3) <a href=""http://cc2e.com/"" rel=""nofollow noreferrer"">Code Complete</a></p>
",0
1433014,1432989,23,"<p>He is waiting for user input so that you can see the output to the program, otherwise it will just complete and the output will not be visible (depending on the OS). Take it out and give it a try. </p>
",1
1433015,1432989,0,"<p><code>getchar();</code> at the end of the program creates a ""Press any key to continue"" situation. I'm guessing that he likes hitting any key twice.</p>
",1
1433016,1432989,1,"<p>Probably to keep the output window open when you run the program from the IDE.</p>

<p>...why there are two there is beyond me though.</p>
",0
1433018,1432989,3,"<p>to pause the (probably) commandline program. he is using two, because using only one didn't work and he probably doesn't know why..</p>

<p>find him a better solution to do this (and not std::cin) and you'll be the hero of the day.</p>
",2
1433026,1432989,0,"<p>To fetch a remaining ""\n"" from the buffer so that the app closes.</p>
",2
1433033,1432989,16,"<p>He wants the console to stay open and wait for the user to press a key. I think to remember that depending on what happens in your professors program above the ""getchar()"". There might still be something in the buffer, so he added a second ""getchar()"". Not exactly the most elegant way to solve the problem.</p>

<p>Edit: Here is a little example. There is still a remaining ""\n"" in the buffer from the ""scanf()"" If you add a second ""getchar()"", you get the expected result. You have to flush the buffer before the ""getchar()"".</p>

<pre><code>#include &lt;stdio.h&gt;

main()
{
int input;
scanf(""%d"", &amp;input);
printf(""The input is %d\n"", input);
getchar();
return 0;
}
</code></pre>

<p>Edit 2: Here is a solution taken from <a href=""http://www.cplusplus.com/forum/articles/7312/"" rel=""noreferrer"">here</a>.</p>

<pre><code>int c;
printf( ""Press ENTER to continue... "" );
fflush( stdout );
do c = getchar(); while ((c != '\n') &amp;&amp; (c != EOF));
</code></pre>
",5
1433090,1432989,-3,"<p>Because one hit of the ""enter"" button generates <b>two</b> characters on Windows, see <a href=""http://en.wikipedia.org/wiki/Newline"" rel=""nofollow noreferrer"">wikipedia</a>. At least it used too, long time ago in a galaxy far far away ...</p>
",4
1433144,1432989,5,"<p>The reason a lot of beginners feel it necessary to put <em>two</em> <code>getch</code> calls in their code is that one single call often doesn¡¯t work.</p>

<p>The reason for that is that <code>getch</code> fetches the next keyboard input from the input queue. Unfortunately, this queue gets filled whenever the user presses keys on the keyboard, even if the application isn¡¯t waiting for input at that moment (of if it isn¡¯t reading the whole input ¨C see Lulu¡¯s answer for an example). As a consequence, <code>getch</code> will fetch a character from the input queue <em>without</em> waiting for the <em>next</em> key press ¨C which is really what the programmer wants.</p>

<p>Of course, this ¡°solution¡± will still fail in a lot of cases, when there¡¯s more than just one character in the keyboard queue. A better solution is to <em>flush</em> that queue and <em>then</em> request the next character. Unfortunately, there¡¯s no platform-independent way to do this in C/C++ to my knowledge. The conventional way to do this in C++ (sorry, my C is limited) looks like this:</p>

<pre><code>std::cin.ignore(std::cin.rdbuf()-&gt;in_avail());
</code></pre>

<p>This simply ignores all available input, effectively clearing the input queue. Unfortunately, this code doesn¡¯t always work, either (for very arcane reasons).</p>
",4
1433166,1432989,15,"<p>The best better way is not to add any code to try and keep the console window open: start your program right from the console window.</p>

<p>If you must start your program from the IDE and want the program to not terminate before the user presses Enter, one single <code>getchar()</code> should do it.</p>

<p>The second best better way to make the program terminate after the user presses a key, is to always make sure there are no inputs pending and use one single <code>getchar()</code>.</p>

<p>The reason your teacher uses 2 <code>getchar()</code>, I guess, is that there is already a character in the input buffer from previous inputs. To consume all characters from the inputs, up to and including the ENTER, this is usual:</p>

<pre><code>int ch;
/* ... */
printf(""Press Enter""); fflush(stdout);
while ((ch = getchar()) != '\n' &amp;&amp; ch != EOF) /* void */;
</code></pre>
",3
1433568,1432989,5,"<blockquote>
  <p>Why is my prof using two getchar(); at the end of our C program tutorials?</p>
</blockquote>

<p>Assuming you have something like </p>

<pre><code>int main ( void )
{
    int     input;

    scanf ( ""%d"", &amp;input );

    printf ( ""The input is %d.\n"", input );

    getchar();
    getchar();

    return 0;
}
</code></pre>

<p>Two because <code>scanf</code> won't return until after an enter is pressed, but there will be the '\n' from the enter and any other characters you have entered in the input buffer.</p>

<p>So if you run the above and input <code>1234</code><kbd>Enter</kbd>, the program will pause after printing <code>The input is 1234.</code> until you then press <kbd>Enter</kbd> again. The first <code>getchar</code> reads the <code>'\n'</code> associated with the first <kbd>Enter</kbd>. If you input something else, such as <code>1234</code><kbd>Space</kbd><kbd>Enter</kbd>, the program will not pause, as first <code>getchar</code> will read the space. Two <code>getchar</code>s might not be enough, and you've interspersed the code for printing the response into the code for handling the input.</p>

<blockquote>
  <p>And what is the ""better way"" for this?</p>
</blockquote>

<p>There are various standard ways of reading input in C. There are also platform specific ways of ignoring text in the input buffer, but you shouldn't need to do that if you use <code>fgets</code> to read a line of input instead of <code>scanf</code> to read some input from the last line entered. </p>

<p><code>fgets</code> ( read input until '\n' or end of file ) followed by <code>sscanf</code> ( parse a string for input ) is safe from buffer overruns, and will absorb any extra input and line terminating '\n':</p>

<pre><code>#include &lt;stdio.h&gt;

int main ( void )
{
    int     input;
    char    buf[16] = """";

    fgets ( buf, sizeof buf, stdin );

    sscanf ( buf, ""%d"", &amp;input );

    printf ( ""The input is %d.\n"", input );

    fflush ( stdout );

    getchar();

    return 0;
}
</code></pre>

<p>Flushing <code>stdout</code> after the <code>printf</code> isn't normally needed for terminal IO, but can be if you're piping it to a disk ( typically when you're logging a crashing program it will lose the most interesting bit just before the crash if you don't flush ). </p>

<p>Because <code>fgets</code> reads up to and including the end of the line, there are no characters left in the buffer so you only need one <code>getchar</code>, and slightly awkward input such as <code>1234</code><kbd>Space</kbd><kbd>Enter</kbd> doesn't cause the program to terminate without pausing. </p>

<p>However, most of the time you don't need to wait after running a console application - on Linux or other Unix systems you typically have a console open and run the program there, after which control returns to the shell. On Windows, IDEs such as Visual Studio typically <a href=""https://stackoverflow.com/questions/1103402/how-does-vs-compile-console-applications-to-show-press-any-key-to-continue/1103445#1103445"">run the program and pause</a> it using something like:</p>

<pre><code> ""C:\WINDOWS\system32\cmd.exe"" /c """"...\ConsoleApplication1.exe""  &amp; pause""
</code></pre>

<p>Or you can open cmd.exe and run it from there, or you can run it with a .pif shortcut and set the checkbox it not to close the console on exit, or you can create a batch file which runs it and pauses.</p>

<p>You really only need to make the program pause itself if you're on Windows and you're using a debugger to run it and you haven't set any breakpoints. </p>
",0
729099,729088,3,"<p>Since as you say the array is just an array of pointers, you do not need to perform any reallocations. You just need to copy the pointers themselves. A simple call to memmove or something similar in the portion of the array is all that is required.</p>

<p>Something approximating this.</p>

<pre><code>void shift_frags(char **frags, int frag_len, int cur)
{
  free(frags[frag_len]);
  memmove(frags+cur+1, frags+cur, (frag_len-cur) * sizeof(char*));
}
</code></pre>
",5
729108,729088,2,"<p>There's no need to <code>free()</code> / <code>realloc()</code> at all.</p>

<p>Your <code>char **frags</code> is a pointer to a list of pointers so you can just shuffle the pointer values around without creating new strings.</p>

<p>Just make sure you start at the far end of the list, and count backwards, or use <code>memmove()</code>:</p>

<pre><code>void shift_frags(char **frags, int frag_len, int cur)
{
    int i;

    free(frags[frag_len]); /* because otherwise this is left dangling */

    for(i = frag_len; i &gt; cur; i--)
    {
        frags[i] = frags[i - 1];
    }
}
</code></pre>

<p>or:</p>

<pre><code>void shift_frags(char **frags, int frag_len, int cur)
{
    int n = frag_len - cur;
    frags += cur;
    free(frags[n]);
    memmove(frags + 1, frags, n * sizeof(*frags)); /* nb: memmove(dst, src, n) */
}
</code></pre>

<p>NB: there's a possible off-by-one error here, it depends on the semantics of your frag_len value, and whether you know that the <code>frag</code> block of memory is already large enough to hold another pointer.</p>
",0
729163,729088,1,"<p>Your realloc is likely failing because you're not reserving a byte for the trailing NUL ('\0') character in strings -- adding a +1 to your realloc size:</p>

<pre><code>    if(strlen(frags[i+1]) &gt; strlen(frags[i]))
        frags[i] = realloc(frags[i], (strlen(frags[i+1]) + 1)*sizeof(char));
    strcpy(frags[i], frags[i+1]);
</code></pre>

<p>will fix that bug. The specific error you're getting is likely because one of your strings is length 0, and realloc(foo, 0) simply gives you that error on your system, or because you're writing the trailing '\0' in unallocated memory and overwriting something else important, causing corruption.</p>

<p>Simply rearranging pointers (frags[i] = frags[i+1], or using memmove()) is easier, quicker and stops you wasting memory, though.</p>
",0
72069,71913,0,"<p>Not answering your question, but I'll write some comments anyway:</p>

<p>I don't remember all K&amp;R rules, but the function you've listed will fail if lim is equal to one. Then you won't run the loop which leaves c unintialised, but you'll still use the variable in the if (c == '\n') check.</p>

<p>Also the while (--lm > 0; ...) thing will not go through the compiler. Remove the ';' and it does.</p>
",0
71935,71913,0,"<p>You do that just to exit the while loop on new line. Else you would have to check it in while body and use break.</p>
",1
71952,71913,1,"<p>The comparison is to ensure readline terminates when it encounters a newline character (the '\n'). On the iteration where it does, it terminates without adding the newline to the string, so the statement after that ensures that the string is always newline terminated, even if one of the other termination conditions was reached.</p>
",0
71954,71913,0,"<p>That ensures that you stop at the end of the line even if it's not the end of the input. Then if there is a newline the \n is added to the end of the line and i incremented one more time to avoid overwriting it with the \0.</p>
",0
71988,71913,0,"<pre><code>int getline(char s[], int lim)
{
   int c, i;
   i=0;
   /* While staying withing limit and there is a char in stdin and it's not new line sign */
   while (--lim &gt; 0; &amp;&amp; (c=getchar()) !=EOF &amp;&amp; c !='\n')
   /* Store char at the current position in array, advance current pos by one */
      s[i++] = c;
   /* If While loop stopped on new-line, store it in array, advance current pos by one */
   if (c =='\n') 
      s[i++] = c;
   /* finally terminate string with \0 */
   s[i] = '\0';
   return i;
}
</code></pre>
",0
71999,71913,3,"<p>The functions reads characters from the standard input until either EOF or a newline characters is found. </p>

<p>The second check ensures that the only newline character is put into the char array. EOF shouldn't occur in a proper c-string. Also, if the character isn't newline that means that we might have filled up our c-string, in which case we shouldn't put any more characters into it. </p>

<p>Notice we still append the '\0'. We've ensured that theres still room for one more character in our c-string, as we use the pre-fix decrementor, which evaluates before the comparison.</p>
",1
72017,71913,0,"<p>I'm not sure whether I understand the question. <code>c !='\n'</code> is used to stop reading the line when the end of line (linefeed) occurs. Otherwise we would always read it until the limit even if it ends before. The first <code>s[i++] = c;</code> in the while-loop doesn't occur if a linefeed has been reached. That's why there is the special test afterwards and the other <code>s[i++] = c;</code> in case it was a linefeed which broke the loop.</p>
",0
83291,71913,1,"<p>There is a bug in the code.</p>

<p>If the size of s is N bytes and the user types a newline as the (N-1)th character, the Nth character will become a '\n' and the (N+1)th character (which is not allocated) will become a '\0'.</p>
",0
530155,530116,2,"<p>fgets and fprintf deal with strings (which in C are char-arrays ending with the special character \0).</p>

<p>Use fread and fwrite for binary data. qsort is good, except your compare function needs to compare byte by byte for entry_size bytes, not just cast from void to int, which is unsafe and probably incorrect.</p>
",0
530160,530116,2,"<p>A couple of points that might help (I'm assuming that this is homework, so this has a pedagogical structure):</p>

<ul>
<li><p>You are going to need to stick the data somewhere while you're accumulating it. And since you don't know how much is coming, dynamic allocation is going to be necessary. Lots of choices here: dynamic arrays, linked lists, hash tables, etc. <em>ad nauseum</em>... Pick one that will work for you (see below).</p></li>
<li><p>Once you've got it, you're going to need to sort it. <em>Or</em>, you could store it sorted in the first place. Do you happen to know a data structure that can manage that?</p></li>
<li><p>Once it is sorted, you just spit it out the other end.</p></li>
</ul>

<p>Easy, no?</p>

<hr>

<p>Apropos the comment:</p>

<ul>
<li><p>Do you have K&amp;R? Or some other basic text on <code>c</code> or <code>c++</code>? You'll want one. And you want to pick one language or the other and stick with it. If you are used to OO programing in another context use <code>c++</code>. If you don't know either, use <code>c++</code>.</p></li>
<li><p>If you're using c++, the STL container will take care of the dynamic storage for you. The simplest thing would be to use a <code>std::vector&lt;char[2]&gt;</code> (using the size from the command line argument), and invoke the <code>&lt;algorithm&gt;</code> sort on it. </p></li>
<li><p>Other people have pointed out that you need to do binary IO. This is important, because neither your input nor your output are structured like text IO.</p></li>
</ul>
",1
530182,530116,2,"<p><code>printf</code> interprets <code>\0</code> in your stream as terminating character.</p>

<p>Use <code>read()</code> and <code>write()</code> instead:</p>

<pre><code>    int res;
    int count;
    while (1) {
            count = 0;
            while(count &lt; entry_size) {
                    res = read(STDIN_FILENO, input + count, entry_size - count);
                    if (res &lt;= 0)
                            exit(errno);
                    count += res;
            }
            count = 0;
            while(res) {
                    res = write(STDOUT_FILENO, input + count, entry_size - count);
                    if (res &lt; 0)
                            exit(errno);
                    count += res;
            }
    }
</code></pre>
",0
530242,530116,5,"<p>Don't use <code>scanf()</code> and <code>printf()</code>.  Those are supposed to be used with text data.  Since you're dealing with binary data, you instead want to use the lower-level <code>fread()</code> and <code>fwrite()</code> functions.  Since you don't know how much total data there is, you'll have to use a dynamic data structure (such as a resizeable array) to store the input.  You can't process the data on-line -- you have to read it all in, sort it, then write it back out.  Your sort function is also wrong -- you're only comparing the first 4 bytes of each record, which is wrong if the record size is anything other than 4 bytes.  Use <code>memcmp()</code> instead.</p>

<p>This should work:</p>

<pre><code>char *input = NULL;
size_t input_size = 0;
int num_items = 0;
int entry_size;

int compare_func(const void *e1, const void *e2)
{
  return memcmp(e1, e2, entry_size);
}

int main(int argc, char **argv)
{
   // ...
  char *datum = malloc(entry_size);  // check for NULL
  input_size = 4096;
  input = malloc(input_size);  // check for NULL

  while(1)
  {
    if(fread(datum, 1, entry_size, stdin) &lt; entry_size)
      break;
    size_t new_size = (num_items + 1) * entry_size;
    if(new_size &gt; input_size)
    {
      input = realloc(input, input_size * 2);  // check for NULL
      input_size *= 2;
    }
    memcpy(input + num_items * entry_size, datum, entry_size);
    num_items++;
  }

  qsort(input, num_items, entry_size, compare_func);

  fwrite(input, entry_size, num_items, stdout);

  return 0;
}
</code></pre>
",4
530368,530116,3,"<p><strong><em>P.S. People asked if this is a homework assignment... It's not - developers at my company want to use this to debug output of their project.</em></strong></p>

<p>If it's not homework, and this is under Linux, why not use the included <strong>""sort""</strong> program?</p>

<p>E.g.:</p>

<pre><code>% printf 'D\x00C\x00\x00B\x00A' | sort -z | od -c
0000000  \0   A  \0   B  \0   C  \0   D  \0
0000011
</code></pre>

<p>FSF/GNU sort offers the -z option:</p>

<pre><code>-z, --zero-terminated
        end lines with 0 byte, not newline
</code></pre>

<hr>

<hr>

<h2>Amended to add:</h2>

<p>Okay, seeing as of how you still want your own code...</p>

<p>And seeing as of how no one else has yet posted an STL-based approach. </p>

<p>Note the use of struct FUNCTOR for the comparison (via stl::sort()).   And, if you want, you could always use ostream_iterator&lt;string&gt;(cout, ""\n"") instead to make things a little more human-readable..</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

using namespace std;

   /* ifstream won't set EOF-state until we try to read past the end-of-file.*/
   /* (Makes for lots of grief trying to read in files...)                   */
inline bool
IsStreamStillGood( istream &amp; theStream )
{
  return theStream &amp;&amp; (theStream . peek() != EOF);
}

template&lt;class TYPE&gt; inline void DELETE( TYPE * x)
{
  delete x;
  x = (TYPE *) NULL;
}

struct FUNCTOR
{
  bool operator()(const string &amp; x, const string &amp; y) { return x &lt; y; }
};


int
main(int argc, char **argv)
{
  istream *       stream;
  vector&lt;string&gt;  v;

  UASSERT( argc, &gt;, 1 );

  const int recordSize = atoi( argv[1] );
  char      buffer [ recordSize + 1 ];

  UASSERT( recordSize, &gt;, 0 );


  if ( argc &gt; 2 )
    stream = new ifstream( argv[2] );
  else
    stream = &amp; cin;


  while ( IsStreamStillGood( * stream ) )
  {
    stream-&gt; read( buffer, recordSize );
    v.push_back( string( buffer, stream-&gt;gcount() ) );
  }

  UASSERT( v.back().size(), ==, size_t(recordSize) );


  FUNCTOR functor;
  sort( v.begin(), v.end(), functor );

  copy( v.begin(), v.end(), ostream_iterator&lt;string&gt;(cout) );


  if ( argc &gt; 2 )
    DELETE(stream);
}
</code></pre>

<hr>

<hr>

<h2>Amended (again) to add:</h2>

<blockquote>
  <p><strong><em>Question regarding usage of strings in your STL approach: since there are potentially null characters ('\0') in the input, wouldn't strings get confused because of that? Someone suggested using char[] but I suspect the same problem would arise</em></strong></p>
</blockquote>

<p>If I have  <strong>char c[10];</strong>, I'm free to say <strong>c[0] = '\0';</strong>.  Same for <strong>c[1]</strong> or <strong>c[9]</strong>.  I can have as many null characters in that array as I want.  (Subject to the size of the array, of course.)</p>

<p>Now, when using <strong>c</strong> as a c-string, the question arises as to how long it is.  Is it 1 character long or 9?  Normally, in C, this is decided by where the first NULL character appears.</p>

<p>So things like <em>printf(%s)</em>, <em>scanf(%s)</em>, <em>strncat()</em>, <em>strncpy()</em>, <em>strncmp()</em>, etc aren't really happy with NULL ('\0') characters embedded within our binary data array.</p>

<p>But C++ <em>std::string</em> keeps track of the length independently.  At least it seems to, and it permits things like:  <strong>myString.append( 10, '\0' );</strong></p>

<p>So, by using <strong>stream-&gt;read(buffer,recordSize)</strong> we read in a set number of chars (bytes).  We don't really care whether they are nulls ('\0') or not.  It's all good.  Just give me recordSize number of bytes.</p>

<p>By creating with <strong>v.push_back(string(buffer, stream-&gt;gcount()))</strong>, we push back a new string containing <strong>stream-&gt;gcount()</strong> chars (bytes).  And again we don't care whether they are nulls ('\0') or not.  We just need all <strong>stream-&gt;gcount()</strong> bytes.</p>

<p>Sort uses functor, which uses operator&lt;(const string &amp;, const string &amp;), which uses string::compare(), which again will use the string's length and doesn't care about what data is actually contained in the string.  Nulls ('\0') are just fine.</p>

<p>Now if we tried to use v.back().c_str(), well, then we have no length so the nulls would confuse us.  But as long as we use the string object (e.g. v.back()) containing both data and length, we're good.</p>

<p>Which brings us to output.  And again we are outputting the string, not myString.c_str(), so all the chars in the string are printed.  Nulls ('\0') included.</p>
",4
530414,530116,1,"<p>Thanks to all for great suggestions! Just for the record, here's completed <code>binsort.c</code> that does what is expected.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;cstring&gt;
#include &lt;limits.h&gt;

using namespace std;


int num_items = 0;
size_t input_size = 0;
int entry_size = 0;


void print_usage()
{
        printf(""%s\n"", ""Usage: &lt;binary data&gt; | ./binsort [RECORD_LENGTH]"");
        printf(""%s\n"", ""For example: printf 'D\\x00C\\x00\\x00B\\x00A' | ./binsort 2 | od -c"");
}


int compare (const void * a, const void * b)
{
        return memcmp(a, b, entry_size);
}


int main(int argc, char *argv[])
{
        if (argc != 2 || stdin == NULL)
        {
                print_usage();
                exit(EXIT_FAILURE);
        }

        entry_size = atoi(argv[1]);

        if (entry_size &lt;= 0 || entry_size &gt;= INT_MAX)
        {
                print_usage();
                exit(EXIT_FAILURE);
        }

        char *input = NULL;
        char *datum = (char*) malloc(entry_size);
        if (datum == NULL)
                exit(EXIT_FAILURE);

        while(1)
        {
                int read_size = fread(datum, 1, entry_size, stdin);

                if (read_size == 0)
                        break;

                if(read_size &lt; entry_size)
                {
                        while(read_size &lt; entry_size)
                        {
                                memcpy(datum, '\0', 1);
                                read_size++;
                        }
                        break;
                }

                size_t new_size = (num_items + 1) * entry_size;
                if(new_size &gt; input_size)
                {
                        input = (char*) realloc(input, new_size);
                        if (input == NULL)
                                exit(EXIT_FAILURE);
                        input_size = new_size;
                }
                memcpy(input + num_items * entry_size, datum, entry_size);
                num_items++;
        }

        qsort(input, num_items, entry_size, compare);

        fwrite(input, entry_size, num_items, stdout);

        exit(EXIT_SUCCESS);
}
</code></pre>
",3
263125,260962,0,"<p>There is one big difference between strncpy and strlcpy at least in the version of Theo de Raadt, that you missed in your implementation. If the length of the given string is less than the buffer size, then strncpy pads the rest of the buffer with null bytes. This might be only a minor difference in many cases, but since many c programmer tend to use extra large buffers to be on the safe site, it can make a difference.
<pre><code>
strncpy(buffer, ""bla"", 1024);
</pre></code></p>

<p>will write 1021 '\0' into the buffer although one would be enough. strlcpy only writes one '\0'.</p>
",1
263680,260962,0,"<p>As Chris said, the functions you are using currently are non-std. ... even worse is that they are still highly inefficient and are still prone to errors. You chould be able to easily create a couple of APIs that use memcpy/memmove and take (char *)s which will work everywhere and likely be faster than the non-std. varients you are currently using.</p>

<p>However if you want someone else to do the heavy lifting, and get safety/usability for free, you could look at something like <a href=""http://www.and.org/ustr"" rel=""nofollow noreferrer"">ustr</a> ... which is meant to be easy to integrate, is std. C, safe, fast, and can deal with constant/automatic/utf8/dynamic strings. There are also other options.</p>
",0
260972,260962,4,"<p>strmove, strlmove, strlcpy, strlcat are all <strong>not</strong> standard C functions, so I can't comment on what they do without knowing which specific non-standard library you're using. Standard C provides strcpy, strcat, strncat, strncpy, memmove, memcpy, etc.</p>

<p>It makes sense to use strncpy over strcpy for safety if you don't know the source string will fit inside the destination buffer. However, strncpy has a major performance issue in that it <strong>always</strong> writes the amount of bytes specified for the size. That is:</p>

<pre><code>char buf[4096];
strncpy(buf, ""Hello"", sizeof buf);
</code></pre>

<p>will write 'H', 'e', 'l', 'l', 'o' and fill the remaining 4091 bytes of buf with '\0'. Another thing to be aware of with strncpy is that it will not null-terminate the string if the size parameter is smaller than the source string length plus its null. For example:</p>

<pre><code>char buf[5];
strncpy(buf, ""Hello"", sizeof buf);
</code></pre>

<p>will write 'H', 'e', 'l', 'l', 'o' into buf and it will not be null-terminated.</p>
",0
260998,260962,2,"<p>As <a href=""https://stackoverflow.com/questions/260962/what-is-the-advantage-of-strlmove-vs-strmove-in-c#260972"">Chris Young mentions</a>, these routines are not standard (or as far as I known in wide, common use) so I can't be 100% certain with more specifics, but:</p>

<p>Typically the <code>strl()</code> variations of <code>str()</code> routines take an additional parameter that indicates the size of the destination buffer.  The routine guarantees that it will not write data past the end of the buffer (since it knows the size).  Usually <code>strl()</code> functions will also guarantee that they will place a terminating null character at the end of the string or at the end of the buffer (potentially truncating any string created there) so that you are also guaranteed to have a terminated string that will be generally OK to pass to other <code>str()</code> functions.  Note that if the length of the buffer is specified as 0 (zero) the function will <em>not</em> place a terminating null character (as there's no room in the buffer for anything).</p>

<p>In my opinion, it's nearly always better to use a <code>strl()</code> (or <code>strn()</code>) function in preference to the corresponding <code>str()</code> routine to prevent buffer overruns.</p>
",0
261174,260962,1,"<p>Quick Google search reveals that the only mentions of strlmove function  is in stackoverflow :). So it's probably not very common function.<br>
But if we assume that this function is close by nature to <a href=""http://www.manpagez.com/man/3/strlcpy/"" rel=""nofollow noreferrer"">strlcpy</a>, this function is differ from <a href=""http://sancho.ccd.uniroma2.it/cgi-bin/man/man2html?strmove+3"" rel=""nofollow noreferrer"">strmove</a> by using size parameter to move limited amount of bytes and <strong>make the destination string NULL terminated</strong>. </p>
",1
1485811,1485805,16,"<p>You never want to use <code>vprintf()</code> directly, but it's incredibly handy when you need to e.g. wrap <code>printf()</code>. For these cases, you will define the top-level function with variable arguments (...). Then you'll collect those into a <code>va_list</code>, do your processing, and finally call <code>vprintf()</code> on the <code>va_list</code> to get the printout happening.</p>
",1
1485819,1485805,83,"<p><code>printf()</code> and friends are for normal use. <code>vprintf()</code> and friends are for when you want to write your own <code>printf()</code>-like function. Say you want to write a function to print errors:</p>

<pre><code>int error(char *fmt, ...)
{
    int result;
    va_list args;
    va_start(args, fmt);
    // what here?
    va_end(args);
    return result;
}
</code></pre>

<p>You'll notice that you can't pass <code>args</code> to <code>printf()</code>, since <code>printf()</code> takes many arguments, rather than one <code>va_list</code> argument. The <code>vprintf()</code> functions, however, <em>do</em> take a <code>va_list</code> argument instead of a variable number of arguments, so here is the completed version:</p>

<pre><code>int error(char *fmt, ...)
{
    int result;
    va_list args;
    va_start(args, fmt);
    fputs(""Error: "", stderr);
    result = vfprintf(stderr, fmt, args);
    va_end(args);
    return result;
}
</code></pre>
",3
1068187,1068161,1,"<p>Volatile basically tells the compiler not to perform any optimizations on the ""object"" that you're applying it to.</p>

<p>This is useful when the object can be changed outside the scope of the program.</p>

<p>One example (and there are others) is with embedded systems. Let's say you have a device with a memory mapped keyboard. Whenever the user presses a key, the ASCII code for that key shows up in memory location <code>0xff00</code> (for example).</p>

<p>So you start with the code:</p>

<pre><code>char *kbdata = 0xff00;
</code></pre>

<p>then, whenever you want to wait for a key to be pressed, you can poll:</p>

<pre><code>char key = *kbdata;
while (key == 0)
    key = *kbdata;
</code></pre>

<p>The only problem here is that the compiler may figure out that nothing in the code is changing <code>*kbdata</code> so it may optimize the accesses so that the code no longer works. Most likely it will load <code>*kbdata</code> into key once then enter an infinite loop.</p>

<p>By specifying <code>kbdata</code> as volatile, the compiler will make sure it doesn't try to optimize accesses to it and the code should work as expected.</p>
",0
188559,188532,13,"<pre><code>/* define a typedef for function_t - functions that return void */
/*      and take an  int and char parameter */

typedef void function_t( int param1, char param2);

/* declare some functions that use that signature */

function_t foo;
function_t bar;
</code></pre>

<p>Now when you define the functions there will be an error if they do not use the same signature as in the typedef.</p>

<pre><code>void foo( int x, char c)
{
    /* do some stuff */

    return;
}

/* this will result in a compiler error */
int bar( int x, char c)
{
    /* do some stuff */

    return 1;
}
</code></pre>

<hr>

<p>As for your new question (added 20 Oct 08): ""Additionally, is there a way to specify default values for the arguments to this function typedef?""</p>

<p>No, there's no way to add default parameters to the typedef. Certainly not in C, which doesn't support default parameters at all.  Even in C++ you can't do this because the default value of a parameter is not part of the type.  In fact, a class that overrides a virtual method from a base class can specify a different value for a default parameter (or even remove the default altogether) - however, this is something that should not be done in general as it will simply cause confusion (<a href=""http://www.gotw.ca/gotw/005.htm"" rel=""nofollow noreferrer"">http://www.gotw.ca/gotw/005.htm</a>).</p>

<p>If you're using C++ you might be able to get the behavior you want using one of (or a combination of) the following:</p>

<ul>
<li>abstract base classes</li>
<li>overloading</li>
<li>template functions</li>
<li>macros</li>
</ul>

<p>But it would be difficult to suggest something without knowing more specifics about exactly what you're trying to accomplish. And I think it's likely that the result might well be pretty hacky.</p>
",3
188567,188532,0,"<p>This is similar to how a function pointer works:</p>

<pre><code> // Declaration of function with int arg returning int
 typedef int (*CALLBACK)(int);

 //Definition
 int myFunc(int arg)
 {
     return 0;
 }

 // Function pointer usage
 CALLBACK pFunc = myFunc;
</code></pre>
",0
188572,188532,0,"<p>I don't think you can do this directly, but you could declare a function pointer type and then collect all your functions into an array.  The compiler will let you know which ones don't match.</p>

<pre><code>typedef void (*MethodSig)(int, int);

static MethodSig x[] = { fnA, fnB, ... };
</code></pre>

<p>Or use a macro to declare the function signature</p>

<pre><code>#define MyFunc(X)  void X(int a, int b)
</code></pre>

<p>That way they will all be the same.</p>
",0
188595,188532,0,"<p>You cannot really prevent anyone from making a function have any signature. But you can control what you will call. So I assume that is what you want.</p>

<p>Have the function that will call the arbitrary functions take a pointer to a function as a parameter. Since you mentioned typedef, you can define a typedef earlier in the program, like so:</p>

<p><strong>Assume you only want functions of the signature ""unsigned short id_for_allowed_functions (int x, char* y)"":</strong></p>

<pre><code>typedef unsigned short (*id_for_allowed_functions)(int, char*);
</code></pre>

<p>Then, your calling function:</p>

<pre><code>void calling_function (id_for_allowed_function x) { (*x)(3, ""bla""); }
</code></pre>

<p>And to supply function foo to it:</p>

<pre><code>unsigned short foo(int x, char* y) { /* ... */ }
calling_function(&amp;foo);
</code></pre>
",0
1421128,1420982,1,"<p>And what do you do to denote that an <code>int</code> is invalid? -1 is a valid value for an int. These types don't have designated ""invalid"" values. You can decide to choose a certain value (that can never normally be the value of what your variable represents) to represent an illegal value, but that is your own definition, and not something that people generally use.</p>

<p>Personally, I don't like this way. I prefer to create another variable, <code>bool IsValid</code>, which will say, whether the value of that size_t variable is valid. Sometimes, it may even be better to create a class to encapsulate them.</p>
",0
1421155,1420982,4,"<p>If you're talking about std::string, then size_t's invalid value is std::string::npos.
Normally you shouldn't use -1 because a size_t is unsigned, and you can get failed comparisons on a compiler doing implicit conversions between types.</p>

<p>That being said, std::strings's npos is set to 0XFFFFFFFFFFFFFFFF... which is the binary equivallent of -1.  It also evaluates to the maximum allowed value for an unsigned size_t field.</p>
",4
1420991,1420982,3,"<p>Basically you can not. Whatever value you use might be a valid one. Better pass a flag saying that it is invalid.</p>
",0
1421003,1420982,10,"<p>Perhaps <code>((size_t)-1)</code>?</p>

<p>Strictly speaking, it <em>is</em> a valid size, but once you have this one you're not likely to need any other ;-)</p>
",6
760695,760668,0,"<p><strike>Looks like a hashing function.</strike> On second thought this would make a pretty poor hash function.</p>

<p>They are shifting every frame by the remainder of the size and then ORing that with a static value. This value is then returned.</p>
",2
760696,760668,0,"<p>I guess you don't understand the <code>tmp |=</code> because this is probably the only part in the code that is ""Hard"" to understand. If you try search for C operators you will find a list <a href=""http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B"" rel=""nofollow noreferrer"">here</a>, now <code>|=</code> means ""Bitwise or"", you can read more about them <a href=""http://irc.essex.ac.uk/www.iota-six.co.uk/c/e4_bitwise_operators_and_or_xor.asp"" rel=""nofollow noreferrer"">here</a>. </p>

<p>So what this code really does is that it takes some input, you tell the functon where to start reading in the ""buffer""/""frame"" and you do bitwise or on as many positions as the ""size"" parameter says.</p>
",2
760703,760668,15,"<p>I'm guessing you're referring to the following line as the one with the confusing syntax.  </p>

<pre><code>tmp |= (frame[from + i]) &lt;&lt; (size - 1 - i);
</code></pre>

<p>Lets break this down</p>

<ul>
<li>frame[from+i]: ""from"" represents an initial index into the array and i is simply the current offset.  So this is effectively iterating the array starting at index ""from""</li>
<li>size - 1 - i: This is calculating the number of bits to shift by and is doing so based on the current index.  This number will start at size -1 and will decrease as the loop progresses</li>
<li>(frame[from+i] &lt;&lt; (size - 1 - i): This shifts the value at from+i by the specified number of bits</li>
<li>tpm |= ... : Dos a bitwise Or expression on the bytes that are still available once the iterated value has been shifted.  </li>
</ul>
",2
761106,760668,-3,"<p>This overall code is just copying a range of data into the tmp variable.  In fact, it is simply doing a memcpy the hard way.</p>

<p>Why not just do: memcpy(&amp;tmp, frame+from, size)</p>
",0
760760,760668,7,"<p>Others already described each line, so I'll just add what the function <em>does</em>. You can imagine bytes in <code>frame</code> between positions (<code>from</code>) and (<code>from+size</code>) on a ""stack"" with different position. First byte will be placed on the left.</p>

<pre><code>bits from:      tmp: |    +  +     |(LSB-side of tmp)
frame[from]:           ---+----
frame[from+1]:          -----+--
frame[from+2]:           -+------
...
</code></pre>

<p>Now tmp has a bit set if any of the bytes ""below"" has a bit set in the related position.</p>
",0
760779,760668,0,"<p>Due to the bitwise OR, this function makes sense only if all values in <code>frame</code> are 0 or 1. </p>

<p>In this case, it will put <code>size</code> consecutive values (i.e. bits) of <code>frame</code> starting at index <code>from</code> into a single <code>unsigned long</code>. The last bit (at index <code>from+size-1</code>) will be inserted as least significant bit.</p>
",0
761186,760668,2,"<p>Looks like a bit-packer.  If, as Eric suggested, all chars in <code>frame</code> are either zero or one, then this will take <code>size</code> characters and pack their values into <code>tmp</code>.  For example, if <code>frame</code> (at offset <code>start</code>) contains the values <code>00 01 00 00 01 01 01 00</code>, then <code>protodec_henten(0,8,frame)</code> would return (leading zeroes omitted) 0x4E (or <code>01001110</code> in binary).  There are better ways to do this, so it may be doing something else, but it's hard to tell what.</p>
",0
779118,779012,3,"<blockquote>
  <p>Is using the PRIxx macros the best approach?</p>
</blockquote>

<p>As far as I know, yes.</p>

<p>Edit: another solution is to cast to a type that is at least as wide as the one you want to print. For example <code>int</code> is at least 2 bytes wide, to can print a <code>int16_t</code> with <code>printf(""%d\n"", (int)some_var)</code>.</p>
",0
446669,446589,0,"<p>The option you're going to want to go with for a compiler is gcc if you'll be working with K&amp;R C (which you should).  You can do this through <a href=""http://www.cygwin.com//"" rel=""nofollow noreferrer"">Cygwin</a>, which will also help you brush up on your Unix skills if you don't already have a basic level of familiarity with *nix.</p>

<p>For a beginner, an IDE is definitely overkill here.  Therefore I'd suggest learning to work with vi, emacs, pico, or joe.  All are available with Cygwin as well, and which one you choose should be a matter of personal preference.  Each comes with its own learning curve.  Later on, you may find you prefer one of these editors to Visual Studio (or any other IDE for that matter.)</p>

<p>It is a good exercise to learn to do all of this without an IDE first.</p>

<p>In the end, however, the most important thing is not that you worry about the platform, but simply that you pick up the tools and begin using them.  There's no other way to learn.</p>
",0
446711,446589,1,"<p>After K&amp;R (aka The Bible in my CS class), I would recommend this book: <a href=""https://rads.stackoverflow.com/amzn/click/com/0131774298"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"" title=""Expert C Programming"">link text</a>
It covers some of the tricky parts of C and is very well written. And you even get a certificate of completion. How could you beat that!</p>
",0
446596,446589,4,"<p>See <a href=""https://stackoverflow.com/questions/257416/what-are-some-good-resources-for-learning-c-beyond-kr"">this stackoverflow post</a> for a list of books and online resources on C programming, plus, of course, <a href=""http://en.wikipedia.org/wiki/The_C_Programming_Language_(book)"" rel=""nofollow noreferrer"">K&amp;R.</a> - which is actually quite a good book and mercifully short.  The classic C on Win32 work is Petzold's <a href=""http://www.charlespetzold.com/pw5/"" rel=""nofollow noreferrer"">Programming Windows</a>.</p>

<p><strong>EDIT:</strong> Per my addition to tvanoffsson's post, the <a href=""http://www.mingw.org/"" rel=""nofollow noreferrer"">MinGW</a> suite is good for console apps.  Also, a friend of mine wrote a <a href=""http://web.ift.uib.no/Fysisk/Teori/KURS/OTHER/newzealand.html"" rel=""nofollow noreferrer"">C programming tutorial</a> a few years ago which was quite well known at the time and still pops up on occasion.</p>
",3
446610,446589,7,"<p>You might try using the <a href=""http://www.microsoft.com/express/vc/"" rel=""nofollow noreferrer"">Visual Studio Express C++ Edition</a>.  You can easily write C code and compile it with a C++ compiler.  I'd buy a copy of K &amp; R C and work through it.</p>

<p>EDIT: As an alternative to Visual Studio, you could look at <a href=""http://www.mingw.org/"" rel=""nofollow noreferrer"">MinGW.</a>  This is a Win32 development system based on GCC.  The main claim to fame of this over Visual Studio is that unix-centric C resources will work better on this than on Win32 as it has ports or clones of many of the main Unix libraries, which may or may not be available with Visual Studio or may not be totally compatible without some porting work.  </p>
",2
446619,446589,0,"<p>MicroSofts Visual Studio Express (Now part of some .net package) is an excellent IDE/Compiler toolset and more or less free to dowload!</p>

<p>I would also recommend Kernigen and Ritchies ""The C programming language"" the definitive book on C before C++, and, one of the best pieces of technical writing ever.</p>

<p>Avoid Bjarne Soustrups ""C++"" book, its a very hard read and more about how/why to define programming syntax than how to use the langauge.   </p>
",0
446623,446589,0,"<p>The only problem with <a href=""https://stackoverflow.com/questions/446589/getting-started-in-c-programming#446610"">using the C++ compiler</a> is it isn't straight up C, but I would suggest learning C++ is just a good to learn as C. I would suggest learning C++ no matter what Joel says....since he probably thinks of them as the same. Pointers, pointers, pointers....</p>

<p>I would suggest <a href=""https://stackoverflow.com/questions/257416/what-are-some-good-resources-for-learning-c-beyond-kr#258003"">this C book</a> if you are bent on straight C.</p>
",3
446636,446589,2,"<p>I'd start MinGW (or Cygwin) on Windows or just Gcc on *nix.  IF you want to learn C programming and IDE shields you from the important process of compilation.</p>

<p>Learning a language like C is like every other language.  Start with a few simple ""Hello, World"" programs and understand them.  Move onto something small that you need achieve.  You'll be fluent in the core language in no time; it's quite small and there are only a few things you need to be really aware of as you're starting out (pointer&lt;=>array duality is one).</p>

<p>Understand the pre-processing, compilation and linking phases of development too.  For hello world it's as simple as</p>

<pre><code>gcc hello_world.c
</code></pre>

<p>But in any large program you will do separate compile/link phases.  The IDE like MSVC will handle this for you, but you still need to be aware of it.</p>

<p>By all means, find a good IDE with good syntax hilighting but start out only using the editor features for a bit.</p>
",0
446651,446589,13,"<p>I'll answer your questions in order:</p>

<ul>
<li><strong>What compiler could I use and why?</strong> - Generally, gcc on the Unix world, and since you said you don't mind Windows, the latest version of MSVC (2008). though it doesn't support C99. (Remember to change the project settings to compile as C.)</li>
<li><strong>What IDE could I use and why?</strong> - I've heard good things about Eclipse, but I never got much into it since I'm on Windows, and gcc options for Windows are... not stellar. MSVC 2008 is good, but Intellisense doesn't quite live up to C#, though it isn't as important in C as in C++. I've heard they're fixing this for 2010.</li>
<li><strong>What other tools are useful for a beginner C programmer?</strong> - Turn up your warning level to the maximium supported by the compiler. (To a reasonable standard.) This will help you mantain good coding practices.</li>
<li><strong>Are there free online guides?</strong> - Yes. I don't know of any very good ones though. Get <a href=""https://rads.stackoverflow.com/amzn/click/com/0131103628"" rel=""noreferrer"" rel=""nofollow noreferrer"">K&amp;R 2nd Ed.</a> It's an awesome book, and short too, by the creators of the language.</li>
</ul>

<p>And another bit of advice: Try to stick to, and learn, standard ANSI C first, stay away from proprietary extensions.</p>
",1
447599,446589,2,"<blockquote>
  <ul>
  <li>What compiler could I use and why?</li>
  </ul>
</blockquote>

<p>I have to agree that creating and running programs manually at first (without the help of a IDE) will be beneficially, even if it's only for your first few small programs. As mentioned above GCC is very standard.</p>

<blockquote>
  <ul>
  <li>What IDE could I use and why?</li>
  </ul>
</blockquote>

<p>I started out using DevC++ (it is easy to use). Then, depending on your direction you will then want to choose a more sophisticated IDE (such as Visual Studio).</p>

<blockquote>
  <ul>
  <li>What other tools are useful for a beginner C programmer?</li>
  </ul>
</blockquote>

<p><strong>Your IDE's debugger!</strong> Instead of placing ""printf"" statements everywhere (like many beginning c-programmers do) learn how to use your IDE's debugger. It will save you quite a bit of time in the long run :)</p>

<blockquote>
  <ul>
  <li>Are there free online guides?</li>
  </ul>
</blockquote>

<p>Tons. A quick google search for ""c programming"" will return massive amounts. <strong>But, if you really want dive in, I recommend searching for common C Programming college course prefixes (such as COP3223).</strong> If you snoop around a bit with that you will be able to find some great lecture notes that will be very beneficial!</p>
",1
231083,231069,2,"<p>The only way to do this with a single fwrite is to replicate the foo_struct N times in RAM, then do a single fwrite of all that RAM.</p>

<p>I doubt that doing a malloc, N copies, and then an fwrite would be quicker than just doing N fwrites (this is the only reason I can think of for wanting to do this!), but if you really care, you should try it.</p>
",0
231084,231069,11,"<p>You can't with a single fwrite(). You'd have to use a loop:</p>

<pre><code>int i;
for (i = 0; i &lt; N; ++i)
    fwrite(&amp;foo_struct, sizeof(foo_struct), 1, fp);
</code></pre>

<p>The third parameter of fwrite() is the number of objects to write, not the number of times to write a single object.</p>
",0
545027,545018,8,"<p>if your MACRO_SIZE is const at compile time, you can try this:</p>

<pre><code>#define MACRO_SIZE ""5""
snprintf(fmt_str, 100, ""%"" MACRO_SIZE ""s"", buf);
</code></pre>
",1
545046,545018,10,"<p>Like Stefan said, but for <code>sscanf()</code> to more properly answer the question, and with a bit more macro trickery:</p>

<pre><code>#define MACRO_SIZE 5

#define FORMAT(S) ""%"" #S ""s""
#define RESOLVE(S) FORMAT(S)

char buf[MACRO_SIZE + 1];
sscanf(input_str, RESOLVE(MACRO_SIZE), buf);
</code></pre>

<p>This uses C's automatic joining together of adjacent string literals, to form the required formatting string at compile-time. This only works if <code>MACRO_SIZE</code> is a preprocessor macro, not if it's a normal runtime variable.</p>

<p>The extra macro call through <code>RESOLVE()</code> is needed since otherwise the argument would not be resolved to its <code>#define</code>d value, and we'd end up with a formatting string of <code>""%MACRO_SIZEs""</code>, which is not what we want.</p>
",2
545141,545018,3,"<p>The ""correct"" solution is what you call the trivial one. All these clever macros(I'd use m4 myself) are just going to make your code less manageable then if you just left it as a constant.</p>

<p>The problem you have here is strings are not a first class data structure in C. They are an array of bytes. Therefor you have to build the array you want to get the meaning you want, and you build that array with sprintf. It's not pretty, but it's correct. </p>

<p>If you're having performance issues and you've tracked it down to here then yes, eliminate the function calls. But unless the value for MACRO_SIZE is repeated a hundred times or spread out over multiple files I'd just change the literal. A macro is just faking having more flexibility, using sprintf actually gives you flexibility.</p>
",0
1488581,1488569,-3,"<p>it means that at one point in time atoi will not be available anymore. So start changing your code now</p>
",2
1488584,1488569,8,"<p>It does say on Apple's <a href=""https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man3/atoi.3.html"" rel=""nofollow noreferrer"">Mac OS X Manual Page for atoi(3)</a> (and in the BSD man pages too) that <code>atoi</code> has been deprecated.</p>

<blockquote>
  <p>The atoi() function has been deprecated by strtol() and should not be
  used in new code.</p>
</blockquote>

<p>I would use the <code>strtol()</code> equivalent just for that reason, but i doubt you have to worry about <code>atoi()</code> being removed.</p>

<p><strike>
from <a href=""http://www.codecogs.com/library/computing/c/stdlib.h/atoi.php"" rel=""nofollow noreferrer"">http://www.codecogs.com/library/computing/c/stdlib.h/atoi.php</a>
Implementation Notes</p>

<pre><code>* The atoi function is not thread-safe and also not async-cancel safe.
* The atoi function has been deprecated by strtol and should not be used in new code.
</code></pre>

<p></strike></p>
",6
1488664,1488569,4,"<p>The <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/atoi.html"" rel=""nofollow noreferrer"">description of <code>atoi()</code></a> has one very important point in relation to the similarities/differences to <code>strtol()</code></p>

<p><code>&gt; ... The call atoi(str) shall be equivalent to:</code><br>
<code>&gt; (int) strtol(str, (char **)NULL, 10)</code><br>
<b><code>&gt; except that the handling of errors may differ.</code></b></p>

<p><s>Try this for fun:</p>

<pre><code>const char *buf = ""forty two"";
int t1 = atoi(buf);             /* detect errors? */
int t2 = strtol(buf, NULL, 10); /* detect errors? */
</code></pre>

<p></s></p>
",3
198980,198970,15,"<p>You can, if the pointers point to global objects:</p>

<pre><code>// In global scope
int x, y;
const struct {int *px, *py; } s = {&amp;x, &amp;y};
</code></pre>
",0
198983,198970,5,"<pre><code>const struct mytype  foo = {&amp;var1, &amp;var2};
</code></pre>
",0
202461,198970,1,"<p>A const struct can <em>only</em> be initialized statically.</p>
",0
682881,682719,7,"<p>Here are the minimum number of significant characters in an external identifier that must be supported by C/C++ compilers under various standards:</p>

<ul>
<li>C90 -  6 characters</li>
<li>C99 - 31 characters</li>
<li>C++98 - 1024 characters</li>
</ul>

<p>Here's an example of the kinds of problems that you can run into if your toolset skimps on these limits (from <a href=""http://www.comeaucomputing.com/libcomo/"" rel=""noreferrer"">http://www.comeaucomputing.com/libcomo/</a>):</p>

<blockquote>
  <p>Note to users with Borland and
  MetroWerks CodeWarrior as backend C:</p>
  
  <p>==================================================================</p>
  
  <p>Note that the Borland compiler and linker, and the Metrowerks compiler,
  seem to have a maximum external id length of 250 characters.   It turns
  out that some of the generated mangled template names are unable to
  fit within that space.  Therefore, when Borland or Metrowerks is used
  as the backend C compiler, we have remapped some of the names libcomo
  uses to shorter names.  So short in fact we could not get away with
  names beginning with underscores.  In fact, it was necessary to map most
  to 2 character id names.</p>
</blockquote>
",0
682733,682719,27,"<p>Old linkers only used a limited number of characters of the symbol - I seem to recall that the old IBM mainframes I started programming in only used 8 characters.  The C standards people settled on 6 characters as a ""lowest common denominator"", but would allow a linker to resolve longer names if they wanted to.  </p>

<p>If you really hit one of these lowest common denominator linkers, external symbols (function names, external variables, etc) ABCDEFG and ABCDEFH would appear the same to them.  Unless you're programming on really old hardware, you can safely ignore this ""commandment"".</p>

<p>Note that any linker that can't handle more than 6 characters can't do C++ either because of the name mangling.</p>
",3
682738,682719,3,"<p>According to <a href=""http://everything2.com/title/The%2520Ten%2520Commandments%2520for%2520C%2520Programmers"" rel=""nofollow noreferrer"">this site</a>:</p>

<p><em>What does this mean? Your globals should be ""Unique to the first six letters"", not ""limited to six letters"". This is in ANSI, I hear, because of utterly painful ""obsolescence"" of some linkers. Hopefully ANSI will some day say ""linkers will have to do longer names, or they'll cry and do longer names"". (And all rational people will just ignore this commandment and tell people to upgrade their 2-penny linker - this may not get you friends, or make warnings happy...)</em></p>
",1
682740,682719,9,"<p>External identifier = something that might have to be called from another system</p>

<p>The reason for the first six characters being unique is that an ancient system may have a six-character limitation on its' identifiers.  If, one day, such a system tries to call your code, it needs to be able to tell the difference between all of your functions.</p>

<p>These days, this seems overly conservative to me, unless you are working with a lot of legacy systems.</p>
",1
682741,682719,5,"<p>A lot of old compilers and linkers had limitations on how long an identifier could be. Six characters was a common limit. Actually, they could be longer than that, but the compiler or linker would throw away everything after the sixth character.</p>

<p>This was usually done to conserve symbol table memory.</p>
",0
682785,682719,4,"<p>It means you're looking at a piece of ancient history. Those commandments are mostly true, but that 9th one may as well actually be carved into a stone tablet, it's so old.</p>

<p>The remaining mystery is: <code>creat</code>. What was wrong with <code>create</code>? It's only six letters!</p>
",2
682968,682719,6,"<p>In response to:</p>

<ul>
<li>C++98 - 1024 characters</li>
</ul>

<p>'begin humor'</p>

<p>Addendum to 9th commandment:</p>

<blockquote>
  <p>If thy external identifiers approach'th to be anywhere
  near as long as one-thousand-and-
  twenty-four thou shouldst surely be
  quickly brought outside and shot.</p>
</blockquote>

<p>'/end humor'</p>
",3
1969312,1969242,0,"<p>It seems that you are re-inventing the wheel. Parsing text char-by-char is something you shouldn't do unless you are doing some thing very low-level.</p>

<p>I think it is better to use some text parsing libs (<a href=""http://www.gnu.org/s/libc/manual/html_node/Regular-Expressions.html"" rel=""nofollow noreferrer"">GNU regex</a>?)</p>

<p>From what I understand is that you are searching for comments in C code. If you want to parse C code there is <a href=""http://www.nobugs.org/developer/parsingcpp/"" rel=""nofollow noreferrer"">many ways</a> to do it better than parsing it by char-char parsing.</p>
",0
1969258,1969242,1,"<p><a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fread/"" rel=""nofollow noreferrer"">fread()</a> will allow you to fetch multiple bytes in a single operation.</p>
",0
1969262,1969242,0,"<p>Take the else{} out of the if() (and, of course, convert it to if(j==1))</p>
",0
1969272,1969242,0,"<p>use </p>

<pre><code>size_t fread ( void * ptr, size_t size, size_t count, FILE * stream );
</code></pre>

<p>ptr - Pointer to a block of memory with a minimum size of (size*count) bytes. 
size - Size in bytes of each element to be read. 
count - Number of elements, each one with a size of size bytes. 
stream - Pointer to a FILE object that specifies an input stream.
size_t - The total number of elements successfully read.</p>
",0
1969273,1969242,1,"<p>Use ungetc(readChar,fp) if the next character is wrong:</p>

<pre><code>char get_token(){
    readChar = fgetc(fp);
    if(readChar==EOF) return END_OF_FILE;
    if(readChar=='/'){
        nextChar=fgetc(fp);
        if(nextChar==EOF) return readChar;
        if(nextChar=='*') return OPEN_COMMENT;
        ungetc(nextChar,fp);
    }
}
</code></pre>
",0
949739,949709,4,"<p>You have numerous errors, but the main one is that you are passing aNULL pointer to display_names:</p>

<pre><code>char **new_output = 0;   // null pointer
...
display_names(my_names, new_output);
</code></pre>

<p>display_names then dereferences it:</p>

<pre><code>*output = (char*) malloc(sizeof(""FullName: "") 
             + strlen(*names_to_display)); // Allocate memory
</code></pre>

<p>resulting in the creash.</p>

<p>In addition, the above allocation is not big enough - you want to add 1 for the end of string marker, and you never seem to initialise the allocated memory. Also, it is a bad habit to get into using sizeof on character strings - it will work in this instance, but you should always use strlen.</p>
",2
949776,949709,1,"<p>You can't evaluate <strong>*output</strong> because you've passed on a <strong>output = null</strong> (in the main, *******newoutput=0*).</p>

<p>You can fix it by testing how many strings you have and the greatest strlen of them and start by allocating chunk to <strong>output</strong>, before you enter your sprintf loop.</p>

<p>As a side comment, where do you free that chunk? Don't answer ""but I'm exiting right after""... </p>
",0
348415,283205,1,"<p>I was dealing with dynamically allocated 2D arrays and I instead of free()'ing N rows, I decided to free M columns. This was fine for smaller inputs where N == M but on large inputs, I only free()'d 50% of what I allocated.</p>

<p><em>shrug</em></p>

<p>Live and learn.</p>
",0
321393,283205,1,"<p>Having been a Lisp programmer, I was used to indenting closing braces, as in:</p>

<pre><code>(cond
    ((eq a foo)(bar ...
        ....
        ))
    )
</code></pre>

<p>and I carried this into C programming:</p>

<pre><code>if (a == foo){
    bar(...);
    ....
    }
</code></pre>

<p>Then I got on a good-size project in C, and another programmer had to make changes in the vicinity of my code. He mis-read my closing brackets, and freed some memory too early. This caused an extremely subtle bug that happened at crunch time. When it was found, he got blamed, badly. But you could say it was my fault. That was not fun, to say the least.</p>
",1
321476,283205,1,"<p>Forgetting architecture constraints and happily memcpy()ing into the memory mapped I/O area on a microcontroller. The magic smoke was released from the test rig.</p>
",0
283212,283205,26,"<pre><code>if (c = 1) // insert code here
</code></pre>
",11
283215,283205,7,"<pre><code>for(int i = 0; i&lt;10; ++i)
  //code here
  //code added later
</code></pre>

<p>Note that the later added code is not in the for loop.</p>
",5
283242,283205,0,"<p>One thing to look after are array bounds. If you go out of bounds, with bad luck you may end up overwriting memory that is used for other data.</p>

<p>One nasty bug related to this was going out of bounds for a static array variable in a function. That ended up as a function changing values of the local variables of the calling function. That wasn't so straight-forward to debug..</p>
",0
283388,283205,3,"<p>I take the definition of dangerous as ""we may ship with that bug and discover only years later when it's to late"":</p>

<pre><code>char* c = malloc(...);
.
.
.
free(c);  
.
.
.
c[...] = ...; 
</code></pre>

<p>or</p>

<pre><code>// char* s is an input string
char* c = malloc(strlen(s));
strcpy(c, s);
</code></pre>

<p>But if you write multiplatform (not limited to x86/x64) this is also great:</p>

<pre><code>char* c = ...;
int i = *((int*)c); // &lt;-- alignment fault
</code></pre>

<p>And if your buffer comes from an untrusted source.. basically most code around is dangerous.</p>

<p>But, anyway, in C it's so easy to shoot yourself in the foot, that a topic about shot feet could go around the thousands of pages.</p>
",0
283248,283205,13,"<p>Few years ago I've got a call from my ex-colleague telling me about the problem he had to fix with my code, which was a router for credit card transactions.</p>
<p>Card number prefix consists of 6-digit BIN (Bank Identification Number) and extra few digits that banks use at own discretion, e.g. bank has BIN for Visa Classic card 456789, and reserve 2 extra digits to indicate sub-product, like 01 for student's card, 02 for co-branded card with local department store and so on. In this case card prefix, which is basically product identifier, becomes 8 digits long. When I coded this part, I decided that 9 digits &quot;ought to be enough for everyone&quot;. It was running ok for 2 years until one day bank make a new card products with 10-digit-long prefix (have no idea why they needed it). Not too hard to imagine what has happened - router segfaulted, the whole system halted because it cannot function without transaction router, all ATMs of that bank (one of the biggest in the country) became non-operational for few hours, until problem was found and fixed.</p>
<p>I cannot post the code here firstly because I don't have it and secondly it is copyrighted by the company, but it is not hard to imagine the <code>strcpy()</code> without checking size of target buffer.</p>
<p>Just like <code>man strcpy</code> says:</p>
<blockquote>
<p>If the destination string of a
strcpy() is not large enough  (that
is, if  the  programmer  was  stupid
or lazy, and failed to check the size
before copying) then anything might
happen.  Overflowing  fixed  length
strings is a favorite cracker
technique.</p>
</blockquote>
<p>I was very embarrassed. But I've learned the lesson and do not forget (usually :) ) to check size of target buffer. I wouldn't recommend you to learn it the hard way - just develop a habit to check target buffer before <code>strcpy()</code> and <code>strcat()</code>.</p>
<p>Edit: good suggestion from Healthcarel - use <code>strncpy()</code> rather than <code>strcpy()</code>. It doesn't add trailing 0 but I usually use following macro to get around it:</p>
<p><code>#define STRNCPY(A,B,C) do {strncpy(A,B,C); A[C] = 0; } while (0)</code></p>
",4
283401,283205,2,"<pre><code>while(a)
{ 
   // code - where 'a' never reaches 0 :( 
}
</code></pre>
",2
283264,283205,13,"<p>It has been a long time, but some things you never forget ;-).</p>

<ul>
<li>forget the <code>\0</code> at the end of a string.</li>
<li>allocate n characters for a string with n characters.</li>
<li>forgetting the break in a switch statement.</li>
<li>'creative' macro use.</li>
</ul>
",2
283278,283205,1,"<p>Using non-limited string functions such as strcpy() or strcmp(), instead of safe versions like strncpy() and strncmp().</p>
",5
283289,283205,1,"<p>Passing virtual address to the DMA engine was a worst one, not exactly C related, but i assume that 99% of DMA related stuff written in C so it's kind of match. 
This small error lead to memory corruption that took me 1.5 month to find. </p>
",0
283293,283205,3,"<p>You should worry more about little mistakes. Big/spectacular mistakes are usually documented in books (with reasons why they are bad, alternative approaches etc.).</p>

<p>It's the little design/coding mistakes that get to you, because they tend to add up.</p>

<p>So my advice is to try and read the books Kernighan wrote or co-authored (""The C Programming Language"", ""Practice of Programming"" etc.) because they are full of common-sense (common for experienced C programmers) advice and list principles that are very useful in avoiding both small and big mistakes.</p>

<p>They also list many potential big mistakes, so they answer your initial question.</p>
",0
283296,283205,21,"<pre><code>if(a == true);
{
  //Do sth when it is true. But it is allways executed.
}
</code></pre>

<p><strong>Edit</strong>: Another variant of the same mistake.</p>

<pre><code>for(i=0; i&lt;max_iterations;i++);
{
  //Do sth but unexpectedly only once
}
</code></pre>
",7
283307,283205,4,"<p>The most dangerous thing I ever did in C was trying to write code which managed my own memory.  Effectively, this means the <strong>most dangerous thing I ever did in C was write C code</strong>.  (I hear that you can get around it these days.  Hip hip for sanity.  Use those approaches whenever appropriate!)</p>

<ul>
<li>I don't write paging algorithms -- OS geeks do that for me.</li>
<li>I don't write database caching schemes -- database geeks do that for me.</li>
<li>I don't build L2 processor caches -- hardware geeks do that for me.</li>
</ul>

<p>And I do <em>not</em> manage memory.  </p>

<p>Someone else manages my memory for me -- someone who can design better than I can, and test better than I can, and code better than I can, and patch when they make critical security-compromising mistakes which only get noticed 10 years later because <strong>absolutely everyone</strong> who attempts to allocate memory fails some of the time.</p>
",0
283621,283205,1,"<p>switch case with no break.</p>
",1
283352,283205,2,"<p><p>When a pointer is first allocated, it does not have a pointee. 
<p>The pointer is ""uninitialized""
<p>A dereference operation on a bad pointer is a serious runtime error.
<p>If you are lucky, the dereference operation will crash or halt immediately (Java behaves this
way).<p> If you are unlucky, the bad pointer dereference will corrupt a random area of
memory, slightly altering the operation of the program so that it goes wrong some
indefinite time later. Each pointer must be assigned a pointee before it can support
dereference operations.</p>
",0
283691,283205,0,"<p>I remember two blunders:</p>

<ol>
<li>returning address of an auto variable from within a function in which it was created;</li>
<li>copying string to an uninitialised and unallocated pointer to char.</li>
</ol>
",0
283995,283205,5,"<p>Uninitialized data.</p>
",2
284012,283205,4,"<p>system() with some user-supplied string in the argument.  Same goes for popen().</p>

<p>Use exec*() instead.</p>

<p>Of course, this is not unique to C.</p>
",3
284252,283205,3,"<p>I'm in agreement with Pat Mac here (despite his downvoting). The most dangerous thing you can do in C is simply to use it for something important.</p>

<p>For example, a sensible language would by default check array bounds and stop your program immediately (raise an exception or something) if you try to wander outside of it. Ada does this. Java does this. Tons of other languages do this. Not C. There are entire hacking industries built around this flaw in the language.</p>

<p>One personal experience with this. I worked with a company that ran a network of flight simulators, tied together with reflective (shared) memory hardware. They were having a nasty crash bug they couldn't track down, so our two best engineers got sent up there to track it down. It took them 2 months.</p>

<p>It turned out that there was an off-by-one error in a C loop on one of the machines. A competent language would have stopped things right there of course, but C let it go ahead and write a piece of data in the next location past the end of the array. This memory location happened to be used by another machine on the network which passed it to a <em>third</em> machine, which used the (garbage) value as an array index. Since this system was also coded in C, it didn't care either that it was indexing way outside of its array, and trashing semi-random memory locations in its program.</p>

<p>So, due to a lack of array bounds checking, a simple easy to make off-by-one bug caused random crashes in a computer two entire hops away from the source of the bug! Cost to the company: 4 man-months of their best engineers' time, plus however much was spent by other engineers and support personnel, plus all the downtime from the simulators in question not working right.</p>
",4
284291,283205,0,"<pre><code>#include &lt;string&gt;
</code></pre>

<p>Me thinking C supports string natively (using Metroworks codewarrior, about 8 years ago).</p>

<p>I did this, for a final project of about 15,000 lines of code. I used this library to do everything relating to strings(appending, splitting, etc.) Only to have the TA's not able to compile any bit of my assignment(using GCC.) </p>

<p>Little did i learn that metroworks had created their own string library. I failed that class.</p>
",0
288494,283205,2,"<p>Two things comes to mind.
Ths first was a function in embedded C (MCU) i tried to have some restrictions on an timer value as a entered a function. so I wrote</p>

<pre><code>if(55000 &lt; my_var &lt; 65000)
</code></pre>

<p>My ida was to check like this:</p>

<pre><code>if( (55000&lt;my_var) &lt; 65000)
</code></pre>

<p>But this is the equivilant or the result</p>

<pre><code>if( (55000&lt;my_var) || (my_var&lt;65000))
</code></pre>

<p>and the result ended up that the if test was always true.</p>

<p>The secound was a pointer mistake. (simplyfied presented here)</p>

<pre><code>get_data(BYTE **dataptr)
{ 
  ubyte* data = malloc(10);
  ... code ...
  *dataptr = &amp;data[1];
}

 main()
 {
   BYTE *data
   get_data(&amp;data);
   free(data);
 }
</code></pre>

<p>Thus resulting in a loss of 1 byte of memory for each time the <code>get_data()</code> function was called</p>
",3
289411,283205,0,"<pre><code>if (importantvar = importantfunction() == VALID_CODE)
</code></pre>

<p>This is when I meant this:</p>

<pre><code>if ((important var = importantfunction()) == VALID_CODE)
</code></pre>

<p>This led to many hours of debugging troubles when I assumed it worked like the latter.</p>
",0
880517,880388,1,"<p>Here are some observation about the code as presented:</p>

<ul>
<li><p>Don't use floating point for money. It will only cause grief later. Ideally, take advice from an accounting professional. In the mean time, do arithmetic in cents, and scale to and from dollars for display.</p></li>
<li><p>Calculations like sales tax <em>might</em> be correctly done with a floating point multiply, but make sure you comply with the accepted practices for rounding back to whole cents. Again, seek advice from an accounting professional.</p></li>
<li><p><code>fflush()</code> doesn't do what you think it does. For a file descriptor opened for writing (such as <code>stdout</code>) it guarantees that all output on that descriptor has been completed. It is used <em>after</em> printing a prompt and <em>before</em> calling something like <code>scanf()</code> to read the input. An example is: <code>printf(""What is your favorite color? ""); fflush(stdout); fgets(color, sizeof(color), stdin);</code></p></li>
<li><p>Always check the return value of <code>scanf()</code>. It returns the number of conversions that succeeded. If it doesn't match the number of format specifiers, then only those that succeeded had values written to the named variables.</p></li>
<li><p>Be wary of literal characters other than whitespace appearing in a <code>scanf()</code> format string. These must be matched exactly by the input text, or the conversion fails. So a format like <code>""$%f""</code> is only matched by input that includes a literal dollar sign. This is probably not what your user expects. The format <code>""%f""</code> is easier on the user. If you want to allow an optional dollar sign, then <code>scanf()</code> may not be the best choice.</p></li>
</ul>
",1
880476,880388,2,"<p>This line has bug:</p>

<p>scanf(""<strong>$</strong>%f"", &amp;fsaPurchaseAmount); //user enters variable amount </p>

<p>it supposed to be:</p>

<p>scanf(""%f"", &amp;fsaPurchaseAmount); //user enters variable amount </p>
",1
961790,961781,12,"<p>What you are suggesting is the way I always wrote C programs back in the days when I did such a  thing. I don't think it is ""poor mans OO"", I think it is sensible procedural programming practice.</p>

<p>I would observe a couple of things about your C code:</p>

<ul>
<li>use typedefs with struct definitions so you don't need to scatter the 'struct' keyword throughout the code</li>
<li>only use casts when they are actually needed - the cast on the return value from malloc() is unecessary</li>
</ul>
",2
961792,961781,1,"<p>C has been a low-level language and in the respect it would be very useful to organize your data structures in accordance with your code functions and modules. </p>

<p>I would suggest that you use typedefs and enumerations wherever you would like to create data objects. Use macros or static functions to initialize, allocate and 'destroy' as required.</p>
",0
961794,961781,18,"<p>This is quite a normal and sensible practice. But try not to expose the struct layout in header files, so that you have some flexibility in how it's implemented and manage your dependencies better.</p>

<p>See <a href=""http://en.wikipedia.org/wiki/Opaque_pointer"" rel=""noreferrer"">Opaque pointer</a> for more details.</p>
",0
961801,961781,4,"<p>Hmmm... We used to just use naming conventions... Ergo: str* does stuff with what common datastructure? So maybe just take the C# syntax and s/./_/g?</p>

<ul>
<li>foo_constructor</li>
<li>foo_destructor</li>
<li>foo_someMethod</li>
<li>foo_someMethod2 // ain't no overloading in ANSI C</li>
<li>foo_otherMethod</li>
</ul>

<p>... and there ain't no inheritance ...</p>

<ul>
<li>foo2_constructor</li>
<li>foo2_destructor</li>
<li>foo2_someMethod // and there ain't no polymorphism</li>
</ul>

<p>But look on the bright side... you can use pointer-to-pointer-to-pointer-to-function-returning-a-pointer-to-pointer-int! Oh the joy!</p>

<p>My bestest advise is to learn the lessons of Java (and by inference C#) and structure your libraries to NOT have side-effects... more typdefs == less headaches... and if your work-out how to follow this sage advise please let me know ;-)</p>

<p>Cheers. Keith.</p>
",2
962162,961781,3,"<p>That's a pretty reasonable way to write a C program. There is another large application out there, which does pretty much the same stuff - called the Linux kernel. Some nearly OO-features used in there:</p>

<ul>
<li>structs and operations on structs for encapsulation just like in your example</li>
<li>pointers to base structs as a form of poor man's inheritance -- you'll find loads of
references to struct kobject in there</li>
<li>macros to generate functions as a replacement for template programming</li>
</ul>
",0
962261,961781,1,"<p>I agree with the suggestions above. You are doing it the best way .. if you want to program in C.</p>

<p>Of course, you could write a pre-processor to automatically generate these declarations and things for you .. maybe use a ""Class"" declaration ... put the functions you want to be member functions inside the class .. etc.</p>

<p>But what we've got here is a simple C++ to C compiler. Why not just program in C++, use a real C++ compiler,  use clean interfaces, and just link the C++ code with the C code? What is the reason that you need to code in C vs. C++ anyways? Or if you need to, generate C code from the compiler and compile the output C code together with whatever else you need.</p>
",3
962297,961781,0,"<p>I have been working on a project for a little while where the library needs to be in C, but I want to have some form of OO functionality. I am doing something similar to this with a little more detail.</p>

<pre><code>struct klass {
  char * value;

  void (*set_value) (struct klass *, const char *);
  void (*destroy) (struct klass *);
};

static void
klass_method_set_value (struct klass * k, const char * value) {
  if (k->value == NULL) {
  }
}

static void 
klass_object_desetroy (struct klass * k) {
  free (k);
  k = NULL;
}

static void
klass_method_destroy (struct klass * k) {
  klass_object_destroy (k);
}

static struct klass *
klass_object_init (void) {
  struct klass * obj = (struct klass *) malloc (sizeof (struct klass*) );

  /* members */
  obj->value = NULL;

  /* methods */
  obj->set_value = klass_method_set_value;
  obj->destroy = klass_method_destroy;
  return obj;
}

struct klass * 
klass_new (void) {
  return klass_object_init ();
}
</code></pre>

<p>Forgive me if something is wrong; wrote it a little quick.</p>
",1
1057753,1057743,9,"<p>The syntax is  actually:</p>

<pre><code>#define MONTHS 12
</code></pre>

<p>No = sign allowed. And no memory is allocated in the compiled code for MONTHS, and it has no data type.</p>
",4
1057755,1057743,3,"<p>No memory is allocated for preprocessor symbols on their own. If you ever use it as a value somewhere it can cause relevant allocation.</p>

<p>For example:</p>

<pre><code>char something[1024*MONTHS];// 1024*12 bytes
</code></pre>

<p>otherwise the constant never outlives the compilation time. And it has no datatype.</p>
",0
1057756,1057743,3,"<p>Isn't #define - simply find n replace by the preprocessor before it hits the compilation stage..   It replaces all instances of the symbol with the value throughout the source. Then the compiler takes over.<br>
So don't think memory is allocated.</p>
",0
1057757,1057743,3,"<p>The whole point about the C pre-processor is that it makes it's replacements before any code is compiled. so #-defined constants aren't stored at the point they are defined, only when they are used.</p>
",3
1057759,1057743,20,"<p>You most likely want your define as such:</p>

<pre>
#define MONTHS 12

/* some code here... */

int payAnnual = payMonthly * MONTHS;
</pre>

<p>To answer your question, no memory will be used.  The pre-processor is unaware of such concepts as variables and memory.  It is essentially an automated text editor.  It will replace any occurrence of the symbol MONTHS with 12.</p>

<p>Since the pre-processor is so dumb, it is generally preferable to use a const variable.  This gives you the benefit of type-checking, and can make compiler errors easier to read.  And so long as you declare it static, the variable will be optimized away.  (If you don't declare a global variable static in C, by default, it will be exported, so the compiler can't optimize it away entirely.)</p>

<pre>
static const int MONTHS = 12;
</pre>
",9
1057767,1057743,2,"<p>They are used just like an actual integer, and the normal literal type for an integer is used in calculations where the macro name appears in the program.</p>

<p>Just as if you were to declare</p>

<pre><code>#define FOO ""bar""
</code></pre>

<p>Then occurences of FOO would be replaced with the typical usage of ""bar"" being a pointer to some location of the string constant in the program's object file mapped to memory.</p>

<p>There isn't really a difference.</p>
",0
1057770,1057743,6,"<p>The preprocessor simply makes symbolic changes to the source code. Hence the code would behave the same as if you had simply replaced all occurrences of MONTHS with 12 yourself. And consequently there is no memory impact in using it.</p>

<p>The use of pre compiler definitions is a great way of raising the level of abstraction of your code without memory of performance impact.</p>

<p>Regards </p>
",0
1057801,1057743,0,"<p>No,</p>

<pre><code>weeks = 12 * 4;
</code></pre>

<p>Is exactly the same as:</p>

<pre><code>weeks = MONTHS * 4;
</code></pre>

<p>Does <em>12</em> take memory? No, Therefore neither does <em>MONTHS</em>.</p>
",0
1057882,1057743,0,"<p>if 12 is allocated depends of the usage and got nothing to do with the preprocessor at all</p>

<pre><code>Somefunction(MONTH);
</code></pre>

<p>would expand to</p>

<pre><code>Somefunction(12);
</code></pre>

<p>12 here must ofc be stored somewhere, in <strong>this</strong> case it will be staticaly stored in the executable. The type will likely depend on what Somefunction take as an argument (or whatever the compiler decides fits best for this usage). There is no know label to '12'.</p>

<p>The preprocessoring is done before the actual compilation, as someone already wrote, it is like a automated texteditor. So the compilation stage is fully unaware of what the preprocessor did.</p>
",0
1150632,1150625,0,"<p>Why not use mmap? You can map a file to memory and use a FILE* pointer.</p>

<p>Update: It does not work. Sorry.</p>
",1
1150640,1150625,0,"<p><code>MemoryStream</code> is not a feature of C#, the language. It's simply a class in the BCL. You could write it yourself in C#.</p>

<p>And so it is in C - you'd write some functions that work similarly in use to <code>fopen</code>, <code>fprintf</code>, <code>fwrite</code>, <code>fclose</code>, etc., but give them names like <code>mopen</code>, <code>mwrite</code>, etc. (presumably) and write them so they operate on a memory buffer.</p>
",0
1150643,1150625,5,"<p>If you are using the GNU C Library, you can use <a href=""http://www.delorie.com/gnu/docs/glibc/libc_228.html"" rel=""nofollow noreferrer"">fmemopen()</a>. There may be other non-portable extensions for other environments, but there's no portable way using FILE*s.</p>

<p>You could also, however, wrap snprintf, if you don't insist on actually using FILE*s. For example, glib (note: not the same as the GNU C Library, and portable) has a <a href=""http://library.gnome.org/devel/glib/stable/glib-Strings.html#g-string-append-printf"" rel=""nofollow noreferrer"">g_string_append_printf</a> that does what you want.</p>
",1
1150679,1150625,3,"<p>There's also an ugly hack which works with plain ISO-C: You can use <code>fopen()</code> to open a null file (<code>/dev/null</code> on *nix, <code>NUL</code> on Windows) and set the array as the file's buffer via    </p>

<pre><code>setvbuf(file, buffer, _IOFBF, buffer_size)
</code></pre>

<p>This should work fine as long as <code>fflush()</code> isn't called anywhere in the code. Also, the programmer has to explicitly take care of the string delimiter.</p>

<p>I don't really see a need to do this, though: As <code>snprintf()</code> returns the number of characters written, it's trivial to keep track of a buffer's position.</p>

<p>One can even write a function to automagically resize the buffer on overflow: <a href=""http://mercurial.intuxication.org/hg/cstuff/file/tip/bufprintf.c"" rel=""nofollow noreferrer"">bufprintf.c</a></p>

<p>The function's prototype is</p>

<pre><code>int bufprintf(char **buffer, size_t *size, size_t *offset,
    const char *format, ...);
</code></pre>

<p>An example program could look like this:</p>

<pre><code>#include &lt;stdio.h&gt;

extern int bufprintf(char **buffer, size_t *size, size_t *offset,
    const char *format, ...);

int main(void)
{
    size_t size = 0; // must be set!
    size_t offset;
    char * buffer;

    for(int i = 0; i &lt; 100; ++i)
        bufprintf(&amp;buffer, &amp;size, &amp;offset, ""we rock %i\n"", i);

    puts(buffer);
    printf(""size:\t%u\noffset:\t%u\n"", (unsigned)size, (unsigned)offset);
}
</code></pre>
",3
1150683,1150625,0,"<p>How about just manually managing your pointers.  I don't have a compiler in front me but hopefully the code below gets the idea across:  </p>

<pre><code>char huge_buffer[REALLY_BIG_SIZE];
char *write_pos = huge_buffer;

//...

void fprintf_to_mem(char **mem_ptr, const char *fmt, ...)
{
  va_list args;
  int num_written;

  va_start(args, mem_ptr);
  num_written = vsprintf(*write_pos, fmt, args);
  *write_pos += num_written;

  va_end(args);
}

//...

fprintf_to_mem(&amp;write_pos, ""Testing %d %d %d"", 1, 2, 3);
fprintf_to_mem(&amp;write_pos, ""Hello world!\r\n"");  
</code></pre>

<p>I would expect that to output ""Testing 1 2 3Hello world!\r\n"" to huge_buffer.</p>
",3
1150693,1150625,2,"<p>sprintf returns the number of characters that were printed into the string. You can use that value to increment the pointer of your buffer.</p>

<pre><code>buffer += sprintf(buffer, ""%d"", i);
</code></pre>

<p>Make sure that you keep around a copy of the original pointer, as that is what you will be using when passing the buffer somewhere else.</p>
",0
1777857,1777843,1,"<p>As Don suggested, memmove() will allow moving part of this array, in order to make room for the new element.</p>

<p>Depending on the size of the elements in the array, you may also consider storing only pointers, in the array, allowing easier/faster re-shuffling of the array, at the cost of a extra indirection when accessing individual elements.  (and also at the cost of having to manage individual element-sized memory blocks).  Deciding on this type of approach depends on the amount of reorganization of the array elements, as well as their size.</p>

<p><strong>Alert</strong>: in view of the added ""picture"" in the question, memmove(), or indeed any operation, may be impossible, if the memory move implies writing past the size of memory originally allocated!<br>
If this is really what is desired, the idea of an array of pointers may be more appropriate as this allows allocating an over-sized memory block initially (for the array proper) and to allocate (or dispose of) individual elements as needed.</p>

<p><strong>Edit</strong>: ""We're not allowed to use memmove()"" indicates some form of homework.  (BTW do tag it as such !!!)<br>
To better help you we need to understand the particular premise of the question.  Here's what appears to be the situtation:</p>

<pre>
1) we readily have an array, containing say N elements.
2) the array on the heap, i.e. it was allocated using malloc() (or related
   functions)
3) the effective size of the malloc-ated block of memory is bigger than that of
   the array.  
  Is #3  true ?
4) Depending on #3 we need to either allocate a new memory block (a bigger one)
   and copy the array.  We expect this copy would be done in 3 steps
       - copy the elements that precede the new element
       - copy the new element
       - copy the elements that are after the new element
   or...  (if we have enough room), we'd require two steps
       - ""shift"" the elements that are supposed to be after the new element
         This can be done one element at a time, if we wish to avoid memcopy
       - copy the new element.
</pre>
",1
1777883,1777843,4,"<p>Yes, if you need to do this without <code>memmove</code>, you can do it with a simple loop.  Note that you might also need to use <code>realloc</code> first, to expand the size of the allocated array so that it can fit the new element.</p>

<p>The trick to this is having the loop move each element one forward, <em>starting from the last one</em>.  A moment's reflection should tell you why this is necessary.</p>
",0
1777897,1777843,3,"<p>The basic principle is the same whether the array is dynamically allocated, statically allocated or automatically allocated.  The main difference is that if there is insufficient room in a dynamically allocated array, you can reallocate it with more space (subject to some system-imposed limits.  Assuming there is enough space in the array, you could use <code>memmove()</code> to copy the section of the array after target location up one space, and then set the target location to the inserted value.  Or you could write a loop to do the job.</p>

<pre><code>int *dynarr = malloc(24 * sizeof(*dynarr));
int  idx = 0;
dynarr[idx++] = 0;
dynarr[idx++] = 23;
dynarr[idx++] = 34;
dynarr[idx++] = 9;
dynarr[idx++] = 15;
</code></pre>

<p>Now insert at position n = 2:</p>

<pre><code>memmove(&amp;dynarr[n+1], &amp;dynarr[n], (idx - n) * sizeof(int));
dynarr[n] = 19;
idx++;
</code></pre>

<p>That's a bulk move, an assignment, and increment the counter because there's one more element in the array.</p>

<hr>

<p>Since the question was edited to disallow <code>memmove()</code>, here is a solution with simple array indexing, assuming that the same initialization sequence is used:</p>

<pre><code>int i;
int n = 2;

for (i = idx; i &gt; n; i--)
{
    dynarr[i] = dynarr[i-1];
}
dynarr[n] = 19;
idx++;
</code></pre>

<hr>

<p>Complete example code:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

static void print_array(int *a, int n)
{
    int i;
    for (i = 0; i &lt; n; i++)
    {
        printf(""a[%d] = %d\n"", i, a[i]);
    }
}

int main()
{
    {
        int *dynarr = malloc(24 * sizeof(*dynarr));
        int  idx = 0;
        dynarr[idx++] = 0;
        dynarr[idx++] = 23;
        dynarr[idx++] = 34;
        dynarr[idx++] = 9;
        dynarr[idx++] = 15;

        printf(""Before insert\n"");
        print_array(dynarr, idx);
        int n = 2;
        memmove(&amp;dynarr[n+1], &amp;dynarr[n], (idx - n) * sizeof(int));
        dynarr[n] = 19;
        idx++;
        printf(""After insert\n"");
        print_array(dynarr, idx);
        free(dynarr);
    }

    {
        int *dynarr = malloc(24 * sizeof(*dynarr));
        int  idx = 0;
        dynarr[idx++] = 0;
        dynarr[idx++] = 23;
        dynarr[idx++] = 34;
        dynarr[idx++] = 9;
        dynarr[idx++] = 15;

        printf(""Before insert\n"");
        print_array(dynarr, idx);

        int n = 2;
        int i;

        for (i = idx; i &gt; n; i--)
        {
            dynarr[i] = dynarr[i-1];
        }
        dynarr[n] = 19;
        idx++;
        printf(""After insert\n"");
        print_array(dynarr, idx);
        free(dynarr);
    }

    return(0);
}
</code></pre>
",2
1014731,1014719,2,"<p>Because it looks like a homework I'll just give you a clue.</p>

<p>Your <code>boo</code> is not an array of strings - preprocessor glues all adjacent string literals into one string so you got one string ""<code>abcdefghijklmnop</code>""</p>

<p>You need to declare it as</p>

<pre><code>char *boo[] = {""abcd"", ""efgh"", ...};
</code></pre>
",4
1014796,1014719,1,"<pre><code>#include &lt;stdio.h&gt;

int main (int argc, char* argv[])
{
    char *boo[] = {""abcd"", ""efgh"", ""ijkl"", ""mnop""};
    int i, j;

    for(i = 0; i &lt; 4; i++) {
        for(j = 0; j &lt; 4; j++)
            printf(""%c"", boo[j][i]);

        printf(""\n"");
    }
}
</code></pre>

<p>-m</p>
",5
1014891,1014719,2,"<p>The other solutions involved modifying boo, which you said was against the rules, here a simple solution. Just use an inner loop which prints every 4th character relative to the outer loop.</p>

<pre><code>int main() {
    int i, j;
    for(i = 0; i &lt; 4; ++i) {
        for(j = 0; j &lt; 4; ++j) {
            putchar(boo[i + j * 4]);
        }
        putchar('\n');
    }
}
</code></pre>

<p>think of it this way, this is effectivly manually treating boo as if it were a 2d array of characters. Since the formula for indexing a 1d array with 2d is (x + y * width), you can imagine that i is the x-coord and j is the y-coord.</p>
",1
1480634,1480540,1,"<p>The test() function has two parameters: a pointer p1 (point to an array of 10 integers) and an integer p2. On the stack p2 is on a higher address and p1 is on a lower. The difference between the starting addresses of p2 and p1 is the size of p2 (==4).</p>

<p>The function has two local variables on the stack: an integer l1 on a higher address, and an array l2 (of 10 integers) on a lower address. The difference between the starting addresses of l1 and l2 is the size of the l2 array (==4*10).</p>

<p>When You call 'test(5, 10)' in main(), the literal '5' will not be interpreted inside the test() function as an integer but as a pointer (so the compiler sad: ""makes pointer from integer without a cast"").</p>
",0
1480552,1480540,4,"<ol>
<li><code>5</code> is implicitly converted to a pointer to int (i.e. <code>0x00000005</code>).</li>
<li>First array argument is actually equivalent to a pointer to int, because you can't pass arrays by value in C. Therefore you are taking <em>addresses</em> of two local variables on the stack (a pointer to int and an int). Each one is 4 bytes, hence 4 byte difference between their addresses. </li>
</ol>
",2
1480555,1480540,0,"<p>You are not passing in an array as a value, you are just passing an int, 0x0000005 or whatever.</p>

<p>You are passing two variables which you have just allocated, i.e. on the stack. So you have allocated room for two integers, each 4 bytes. Thus when you find their addresses, they should be 4 apart.</p>
",0
1480562,1480540,3,"<p>GCC sayeth (with no arguments to encourage error reporting):</p>

<pre><code>$ gcc -c z.c
z.c: In function ¡®main¡¯:
z.c:13: warning: passing argument 1 of ¡®test¡¯ makes pointer from integer
without a cast
$
</code></pre>

<p>The code in z.c is the code in the question preceded by '<code>#include &lt;stdio.h&gt;</code>' and a blank line.</p>

<p>GCC is telling truth - the code is bust on C - indulging in undefined behaviour (converting an integer, 5, into a pointer to integer, without a cast to tell the compiler that the programmer has any clue what they are up to).</p>

<p>Because p1 is equivalent to 'int *p1', the distance apart of p1 and p2 (4) is correct for a 32-bit compilation.</p>
",2
1480782,1480540,0,"<h3>Welcome to a world where the code is not <a href=""http://en.wikipedia.org/wiki/Type-safe"" rel=""nofollow noreferrer"">type-safe</a> and not <a href=""http://en.wikipedia.org/wiki/Memory_safety"" rel=""nofollow noreferrer"">memory-safe</a></h3>

<hr>

<p>And remember what they say about <em>""where angels fear to tread""</em>.  Array parameters in C are rewritten automatically to be <em>""pointer to array""</em>. The pointer of <code>5</code> is certainly incorrect but C will run with it**...**for a while.</p>

<p>You can't get a program like this through MS C++, as I recall, so I'm thinking you are using gnu. I would recommend <code>-Wall -Werror</code> in that case.</p>
",0
1480862,1480540,0,"<p>As others have noted you are passing a literal <code>int</code> (5) which is being converted to a pointer type on being passed to the <code>test</code> function. In function parameters, all top level array declarations are converted to pointers, so test can be equivalently written</p>

<pre><code>void test( int* p1, int p2 )
</code></pre>

<p>There are issues with your <code>printf</code> calls. <code>%d</code> is the format specifier for an <code>int</code> and not a pointer type. To correctly pass a pointer to <code>printf</code> you should explicitly cast to a <code>void*</code> and use the %p format specifier.</p>

<pre><code>printf(""params are at %p and %p\n"", (void*)&amp;p1, (void*)&amp;p2);
printf(""locals are at %p and %p\n"", (void*)&amp;l1, (void*)&amp;l2[0]);
</code></pre>

<p>You need to do this before you can make a call about whether the displayed addresses look 'strange'.</p>
",0
963916,963911,7,"<p>Simply</p>

<pre><code>const char S[] = ""ABCD"";
</code></pre>

<p>should work.</p>

<p>What's your compiler?</p>
",6
963920,963911,0,"<p>This compiles fine on gcc version 4.3.3 (Ubuntu 4.3.3-5ubuntu4).</p>

<pre><code>const char s[] = ""cheese"";

int main()
{
    return 0;
}
</code></pre>
",4
963935,963911,-1,"<p>Perhaps your character array needs to be constant.  Since you're initializing your array with characters from a constant string, your array needs to be constant.  Try this:</p>

<pre><code>#define S ""ABCD""
const char a[] = { S[0], S[1], S[2], S[3] };
</code></pre>
",3
963953,963911,0,"<pre><code>const char S[] = ""ABCD"";
</code></pre>

<p>This should work. i use this notation only and it works perfectly fine for me. I don't know how you are using.</p>
",2
964011,963911,0,"<p>Here is obscure solution: define macro function:</p>

<pre><code>#define Z(x) \
        (x==0 ? 'A' : \
        (x==1 ? 'B' : \
        (x==2 ? 'C' : '\0')))

char x[] = { Z(0), Z(1), Z(2) };
</code></pre>
",5
964034,963911,0,"<p>Weird error.</p>

<p>Can you test this?</p>

<pre><code>const char* const S = ""ABCD"";
char t[] = { S[0], S[1], S[2], S[3] };
char u[] = { S[3], S[2], S[1], S[0] };
</code></pre>
",0
964054,963911,0,"<p>I'm not sure what your problem is, but the following seems to work OK:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    const char s0[] = ""ABCD"";
    const char s1[] = { s0[3], s0[2], s0[1], s0[0], 0 };

    puts(s0);
    puts(s1);
    return 0;
}


Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 13.10.3077 for 80x86
Copyright (C) Microsoft Corporation 1984-2002. All rights reserved.
cl /Od /D ""WIN32"" /D ""_CONSOLE"" /Gm /EHsc /RTC1 /MLd /W3 /c /ZI /TC
   .\Tmp.c
Tmp.c
Linking...

Build Time 0:02


C:\Tmp&gt;tmp.exe
ABCD
DCBA

C:\Tmp&gt;
</code></pre>

<p>Edit 9 June 2009</p>

<p>If you need global access, you might need something ugly like this:</p>

<pre><code>#include &lt;stdio.h&gt;

const char *GetString(int bMunged)
{
    static char s0[5] = ""ABCD"";
    static char s1[5];

    if (bMunged) {
        if (!s1[0])  {
            s1[0] = s0[3]; 
            s1[1] = s0[2];
            s1[2] = s0[1];
            s1[3] = s0[0];
            s1[4] = 0;
        }
        return s1;
    } else {
        return s0;
    }
}

#define S0 GetString(0)
#define S1 GetString(1)

int main()
{
    puts(S0);
    puts(S1);
    return 0;
}
</code></pre>
",1
964680,963911,0,"<p>The compilation problem only occurs for me (gcc 4.3, ubuntu 8.10) if the three variables are global. The problem is that C doesn't work like a script languages, so you cannot take for granted that the initialization of u and t occur after the one of s. That's why you get a compilation error. Now, you cannot initialize t and y they way you did it before, that's why you will need a char*. The code that do the work is the following:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define STR ""ABCD""

const char s[] = STR;
char* t;
char* u;

void init(){
    t = malloc(sizeof(STR)-1);
    t[0] = s[0];
    t[1] = s[1];
    t[2] = s[2];
    t[3] = s[3];


    u = malloc(sizeof(STR)-1);
    u[0] = s[3];
    u[1] = s[2];
    u[2] = s[1];
    u[3] = s[0];
}

int main(void) {
    init();
    puts(t);
    puts(u);

    return EXIT_SUCCESS;
}
</code></pre>
",0
965851,963911,20,"<p>You can't - in C. In C initializing of global and local static variables are designed such that the compiler can put the values statically into the executable. It can't handle non-constant expressions as initializers. And only in C99, you can use non-constant expression in aggregate initializers - not so in C89! </p>

<p>In your case, since your array is an array containing characters, each element has to be an arithmetic constant expression. Look what it says about those</p>

<blockquote>
  <p>An arithmetic constant expression shall have arithmetic type and shall only have
  operands that are integer constants, ?oating constants, enumeration constants, character
  constants, and sizeof expressions.</p>
</blockquote>

<p>Surely this is not satisfied by your initializer, which uses an operand of pointer type. Surely, the other way is to initialize your array using a string literal, as it explains too</p>

<blockquote>
  <p>All the expressions in an initializer for an object that has static storage duration shall be constant expressions or string literals.</p>
</blockquote>

<p>All quotes are taken out of the C99 TC3 committee draft. So to conclude, what you want to do - using non-constant expression - can't be done with C. You have several options: </p>

<ul>
<li>Write your stuff multiple times - one time reversed, and the other time not reversed. </li>
<li>Change the language - C++ can do that all.</li>
<li>If you <em>really</em> want to do that stuff, use an array of <code>char const*</code> instead</li>
</ul>

<p>Here is what i mean by the last option</p>

<pre><code>char const c[] = ""ABCD"";
char const *f[] = { &amp;c[0], &amp;c[1], &amp;c[2], &amp;c[3] };
char const *g[] = { &amp;c[3], &amp;c[2], &amp;c[1], &amp;c[0] };
</code></pre>

<p>That works fine, as an address constant expression is used to initialize the pointers</p>

<blockquote>
  <p>An address constant is a null pointer, a pointer to an lvalue designating an object of static storage duration, or a pointer to a function designator; it shall be created explicitly using the unary &amp; operator or an integer constant cast to pointer type, or implicitly by the use of an expression of array or function type. The array-subscript [] and member-access . and -> operators, the address &amp; and indirection * unary operators, and pointer casts may be used in the creation of an address constant, but the value of an object shall not be accessed by use of these operators.</p>
</blockquote>

<p>You may have luck tweaking your compiler options - another quote:</p>

<blockquote>
  <p>An implementation may accept other forms of constant expressions.</p>
</blockquote>
",0
965882,963911,0,"<p>That's one of the cases a script to generate the appropriate code might help.</p>
",0
1385748,1385695,0,"<p>Given an integar array, it will sum up all of its elements and return that value.</p>
",0
1385763,1385695,0,"<p>The preprocessor here uses variable number of arguments <a href=""http://www.delorie.com/gnu/docs/gcc/cpp_19.html"" rel=""nofollow noreferrer"">variadic macro</a>.
Rest it simply creates an array from argument list and manipulates it</p>
",0
1386555,1385695,4,"<p>Let's look at the expansion of the sample invocation <code>sum(1, 2, 3)</code> of the macro</p>

<pre><code>#define sum(...) \
    _sum(sizeof((int []){ __VA_ARGS__ }) / sizeof(int), (int []){ __VA_ARGS__ })
</code></pre>

<p>The <code>...</code> mean it's a variadic macro, ie it takes any number of comma-seperated arguments. On expansion, the special preprocessor token <code>__VA_ARGS__</code> will be replaced with these arguments, ie</p>

<pre><code>(int []){ __VA_ARGS__ }
</code></pre>

<p>expands to</p>

<pre><code>(int []){ 1, 2, 3 }
</code></pre>

<p>This is a compound literal: C99 allows to create objects with automatic storage duration on-the-fly via such a typed initialization list.</p>

<p>It's important that the size of the array will be inferred: It won't have incomplete type <code>int []</code> but will be of type <code>int [3]</code>, ie</p>

<pre><code>sizeof((int []){ 1, 2, 3 }) = sizeof(int [3]) = 3 * sizeof(int)
</code></pre>

<p>To get the number of elements, divide by <code>sizeof(int)</code>.</p>

<p>The macro invocation <code>sum(1, 2, 3)</code> is therefore equivalent to the C90 code</p>

<pre><code>int tmp[3] = { 1, 2, 3 };
_sum(3, tmp);
</code></pre>
",0
1385719,1385695,21,"<p>With the pre-processor macro</p>

<pre><code>#define sum(...) \
    _sum(sizeof((int []){ __VA_ARGS__ }) / sizeof(int), (int []){ __VA_ARGS__ })
</code></pre>

<p>being called with <code>sum(1,2,3)</code>, the line is translated (a simple string substitution, replacing <code>""__VA_ARGS__""</code> with <code>""1,2,3""</code>) into:</p>

<pre><code>_sum(sizeof((int []){1,2,3}) / sizeof(int), (int []){1,2,3})
</code></pre>

<p>which is a function call to <code>_sum()</code> passing two things:</p>

<ul>
<li>the number of integers in the array {1,2,3} which is 3 (it gets this by dividing the size of the three-integer array by the size of a single integer).</li>
<li>the pointer to the array itself (or a totally different array containing the same values, depending on how smart your compiler is).</li>
</ul>

<p>All the <code>_sum()</code> function does is add each of the integers to <code>s</code> (which is initially zero) until the count runs out.</p>

<hr>

<p>That first bullet point above bears some explanation. When you have an array of <code>N</code> elements defined as follows:</p>

<pre><code>tType x[22];
</code></pre>

<p>the size of the <em>array</em> is <code>sizeof(x)</code>, the size of all elements. The size of a single element of that array is <code>sizeof(x[0])</code>, the size of the first element, although I often prefer the <code>sizeof(*x)</code> variant.</p>

<p>So, to count the number of elements, you simply divide the total size by the size of an element, using one of the following:</p>

<pre><code>sizeof(x) / sizeof(x[0])
sizeof(x) / sizeof(*x)
</code></pre>

<p>And, since you've asked for a detailed analysis of the code, here we go:</p>

<pre><code>// Needed for printf().

#include &lt;stdio.h&gt;

// Macro to convert sum(n1,n2,...,nN) to _sum(N,n1,n2,...,nN).
// This calculates the length of the array by dividing its size by the size
//   of an int and passes both the length and array through to the new
//   function.
// __VA_ARGS__ is replaced with the entire marcro argument list, '1,2,3' in
//   this case.

#define sum(...) \
    _sum(sizeof((int []){ __VA_ARGS__ }) / sizeof(int), (int []){ __VA_ARGS__ })

// Function to take size and pointer to int array, and return sum.

int _sum (size_t count, int values[]) {
    int s = 0;                // Initial sum of zero.
    while(count--)            // Until elements exhausted (count down).
        s += values[count];   // Add each array element to accumulator.
    return s;                 // Return sum.
}

int main (void) {
    printf (""%i"", sum(1, 2, 3));   // Test it with 1, 2 and 3 (should print 6).
}
</code></pre>
",2
1385721,1385695,0,"<p>In this code the <code>sum</code> macro converts the <code>sum(1,2,3)</code> call in main into a call to <code>_sum</code> by using <code>sizeof</code> to calculate the number of elements <code>sum</code> is called with.  The size of an <code>int</code> array with three values is going to be <code>3 * sizeof(int)</code>, so dividing by <code>sizeof(int)</code> yields three again.</p>
",0
1908351,1908024,1,"<p>""The struct is larger than the single align member"".</p>

<p>First, says who? What if, on your implementation, <code>unsigned</code> and <code>unsigned*</code> are each 32 bits, and <code>long</code> is 128 bits (or more realistically, 16 bits and 64 bits)?</p>

<p>Second, so what? Even if the struct is at least as big as <code>long</code>, it doesn't mean that it must have at least as big an alignment as <code>long</code>. If <code>unsigned</code> and <code>unsigned*</code> have no alignment requirements, then the struct has no alignment requirements. But perhaps <code>long</code> does.</p>
",0
1908127,1908024,0,"<p>The size of these datatypes is platform dependent. I guess that the two unsigned members of the struct are 16 bits and the long align is 32 bits or two 32 bit members in the struct and 64 bits for the long.</p>

<p>Alignment boundaries would be either 32 or 64 bits</p>
",0
1908598,1908024,5,"<p>The data type in K&amp;R is:</p>

<pre><code>union header
{
  struct 
  {
     union header *ptr; 
     unsigned size;
  } s;

  Align x;
};
</code></pre>

<p>Let's say we had this instead:</p>

<pre><code>union header_t
{
  struct 
  {
     union header_t *next; 
     unsigned size;
  } s;
};
</code></pre>

<p>(By the way, you need a name for the <code>struct</code> variable and also change the
pointer inside the <code>struct</code> to type <code>union header_t *</code>, because the
data structure is a linked list.)</p>

<p>K&amp;R's <code>malloc()</code> implementation reserves a chunk of space, and then
uses this to maintain free store.  When this <code>malloc</code> is called, it
finds on the free list a place that has enough space, and returns a
pointer to that tail end of it.</p>

<p>In particular, the relevant part of the code is:</p>

<pre><code>typedef union header Header;
static Header base;
Header *p = &amp;base;
...
p += p-&gt;s.size;
return (void *)(p+1);
</code></pre>

<p>Note that we are returning <code>p+1</code> (cast to <code>void *</code>), so we have to make sure that this pointer is aligned <em>for any data type</em>.  Since <code>p</code> itself is pointing to a <code>Header *</code>, we have to make sure that when we add <code>sizeof(Header)</code> to an aligned pointer, we get another aligned pointer back (remember, <code>p+1</code> points to <code>sizeof(Header)</code> bytes from <code>p</code>).  This requirement means that <code>Header</code> <em>has</em> to be aligned for all types of data.</p>

<p><em>The <code>struct</code> inside <code>Header</code> might not be aligned for the widest type possible</em>.  To make sure that our <code>Header</code> type is so aligned, we add a member to the <code>union</code> that we know to be maximally aligned, i.e., is the widest type on a given machine.  K&amp;R assume that this type is <code>long</code>.  Also, note that it does not matter if the size of <code>Header</code> is greater than the size of <code>Align</code> type.  <strong>The assumption here is that <code>Align</code> type here is a type with the <em>strictest</em> alignment requirements, not that it be huge.</strong></p>

<p>Interestingly, we need to assume a 'maximally aligned' type because the C standard requires alignment for any type from pointers returned by <code>malloc</code>, but does not specify a portable way to find out what that alignment is going to be. If the standard <em>did</em> specify such a type, one could have used that type instead of <code>long</code> for <code>Align</code>.</p>
",10
1713191,1713183,0,"<p>When you create a pointer you use </p>

<p><code>int *pA;</code></p>

<p>Afterwards, using <code>*pA</code> means you're accessing the <strong>value pointed to by the pointer</strong>.</p>

<p>When you use <code>&amp;a</code> you are using the <a href=""http://msdn.microsoft.com/en-us/library/64sa8b1e(VS.71).aspx"" rel=""nofollow noreferrer"">Address-of Operator</a> which returns the address of the memory location in which the data stored of the variable <code>a</code> (which is a integer) is stored.</p>

<p>So, the correct assignment is <code>pA = &amp;a</code> since you're copying the address of <code>a</code> to <code>pA</code> which is supposed to hold addresses of memory locations.</p>

<p>But <code>*pA</code> represents the value in that memory location (an integer) so it is incorrect to assign an address to <code>*pA</code> - this is why the right syntax is <code>pA = &amp;a</code>.</p>
",0
1713198,1713183,0,"<p>Yeah, when you first declare a pointer, you can specify the memory address. Because you are declaring it as a pointer, you use the <code>*</code> operator. But everywhere else, the <code>*pA</code> means to take the value referenced by that pointer (not the actual address). It is a little odd but you get used to it.</p>

<p>So, you can do this:</p>

<pre><code>int a; 
int *pA = &amp;a;
</code></pre>

<p>and you can do this:</p>

<pre><code>pA = &amp;a;
</code></pre>

<p>But you cannot do:</p>

<pre><code>*pA = &amp;a;
</code></pre>

<p>Because that says, ""make the value pointed by <code>pA</code> = to the value of a.""</p>

<p>However, you can do this:</p>

<pre><code>*pA = a;
</code></pre>

<p>And that is just how you set the value pointed to by pA. Hope this is somewhat clear.</p>
",0
1713202,1713183,3,"<pre><code>int a;
</code></pre>

<p>This allocates an integer on the stack</p>

<pre><code>int* pA = &amp;a;
</code></pre>

<p>This allocates an int pointer on the stack and sets its value to point to a.  The '*' is part of the declaration.</p>

<pre><code>*pA = &amp;a;
</code></pre>

<p>In this case the '*' is an operator that says ""look where pA points"", which is to an int.  You are then trying to set that int to the address of a, which is not allowed.</p>

<pre><code>pA = &amp;a;
</code></pre>

<p>Now this is the same as the second statement.  It sets the value of pA to point to a.</p>
",2
1713940,1713183,1,"<p>In C, <strong>""declaration mimics use""</strong>.</p>

<p>When you declare a pointer to <code>int</code></p>

<pre><code>int *pa;
</code></pre>

<p>you can see that <code>pa</code> is a <code>int *</code> or that <code>*pa</code> is a <code>int</code>.</p>

<p>You can assign pointers to int to <code>pa</code>, or you can assign ints to <code>*pa</code>.<br>
That's why, after the above declaration, the following statements ""work"".</p>

<pre><code>*pa = 42;
pa = &amp;a;
</code></pre>

<p>In the declaration itself, you can ""transform"" it to a definition by supplying an initialization value. The definition is for the object <code>pa</code> of type <code>int*</code>, not for <code>*pa</code>.</p>

<pre><code>int *pa = &amp;a; /* initialize pa, which takes a `int*` */
pa = &amp;b;      /* change `pa` with a different `int*` */
*pa = 42;     /* change the value pointed to by `pa` */
</code></pre>
",0
1393473,1393443,16,"<p>Interpretation 1 is correct.  If the Interpretation 2 was intended, the original text would have used ""<strong>or</strong> which are changed"" instead of ""and"".</p>
",0
1393474,1393443,31,"<p>setjmp/longjmp is implemented by saving the registers (including stack and code pointers etc) when first passed, and restoring them when jumping.</p>

<p>Automatic (aka ""local"", stack-allocated) variables that are not 'volatile' <strong><em>may</em></strong> be stored in registers rather than on the stack.</p>

<p>In these circumstances, the longjmp will restore these registers variables to their value at the point when the setjmp() was first called.</p>

<p>Additionally, a particularly clever compiler might avoid variables that can be inferred from the state of another variable, and calculating them on demand.</p>

<p>However, if the variable is automatic but not been assigned a register, it may be changed by code between the setjmp and the longjmp..</p>

<p>Volatile is explicitly telling the compiler not to store the variable in a register.</p>

<p>So unless you explicitly say a variable is volatile, if you changed the variable between the setjmp/longjmp, its value will depend upon the choices the compiler makes, and is therefore nothing you should rely upon ('indeterminate').</p>
",2
806140,805894,1,"<p>Which commands would you execute at the shell?</p>

<p>Superficially, you could use some variant on this:</p>

<pre><code>#include &lt;stdlib.h&gt;

static const char *cmds[] =
{
    ""command 1 with options"",
    ""command 2 with different options"",
    0,
};

int main(void)
{
    int i;

    for (i = 0; cmds[i] != 0; i++)
        if (system(cmds[i]) != 0)
            exit(EXIT_FAILURE);
    return(EXIT_SUCCESS);
}
</code></pre>

<p>I assume that the commands will provide appropriate diagnosis of any problems.
If you need to control the arguments, then you have more work to do.</p>

<p>The main caveat is ""is this the disk that the o/s is running on"", because if so, the chances are that the formatting of that disk will stop the programs from running successfully.</p>
",0
1921036,1921022,3,"<p>These tools are called ""profilers"".  See this <A href=""http://stackoverflow.com/questions/1794816/recommendations-for-c-profilers"">previous question</a>.</p>

<p>The output from these can be difficult to interpret, so it might be wise to consider simpler options first.  For example, you could write performance tests for particular areas of code you are concerned and simply timing them and seeing how they scale).</p>
",0
1921051,1921022,2,"<p>In general, it is impossible for any tool to find that out through statical analysis. Because if we could, we could also solve the <a href=""http://en.wikipedia.org/wiki/Halting_problem"" rel=""nofollow noreferrer"">halting problem</a>.</p>

<p>Profilers allow you to analyse how the program behaves when run (against the input used then). This should be good enough for any real-world scenarios.</p>
",0
1921058,1921022,4,"<p>The gprof profiler comes with the <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a> compiler suite. Theres a manual for it <a href=""http://www.cs.utah.edu/dept/old/texinfo/as/gprof_toc.html"" rel=""nofollow noreferrer"">here</a>.</p>
",0
538487,538485,4,"<p>This is an example of a preprocessor directive that allows you to test an expression at compilation time. <a href=""http://developer.apple.com/DOCUMENTATION/DeveloperTools/gcc-4.0.1/cpp/If.html"" rel=""nofollow noreferrer"">Here is a good explanation.</a></p>
",0
538488,538485,10,"<p>it is testing if some constant named cpp that is visible to the preprocessor (is likely a macro) is non-zero.</p>

<p>Usual convention is that macros should be all uppercase so that they are more obvious, but they don't have to be (as is apparently the case here).</p>

<p>My guess is that it stands for c++ and one of the included headers (perhaps pth_p.h?) defines it if a c++ compiler is being used. If this is the case, there are more standard things to use which are preferred such as this:</p>

<pre><code>#ifdef __cplusplus
</code></pre>
",0
538520,538485,2,"<p>I suspect that this is checking whether the code is being compiled by a c++ compiler or a c compiler.  If C++, the macros are defined if there is also the PTH_DEBUG flag set.  I suspect that this flag would be set in a call to the compiler.  If C, the macros are not defined.  Why that is the case depends on what pth_debug macros are intended to do.</p>
",0
810141,810129,0,"<p>Yes, it does have to do with pointers.</p>

<p>The way to read the code is this:  ""the value that is pointed to by the pointer ""s"" (which gets incremented after this operation) gets the value which is pointed to by the pointer ""t"" (which gets incremented after this operation; the entire value of this operation evaluates to the value of the character copied; iterate across this operation until that value equals zero"".  Since the value of the string null terminator is the character value of zero ('/0'), the loop will iterate until a string is copied from the location pointed to by t to the location pointed to by s.</p>
",0
810145,810129,0,"<p>it copies a string because arrays are always passed by reference, and string is just a char array. Basically what is happening is (if i remember the term correctly) pointer arithmetic. Here's <a href=""http://en.wikipedia.org/wiki/Pointer_(computing)#C_arrays"" rel=""nofollow noreferrer"">a bit more information from wikipedia on c arrays</a>.</p>

<p>You are storing the value that was dereferenced from t in s and then moving to the next index via the ++.</p>
",0
810147,810129,1,"<p>It works by copying characters from the string pointed to by '<code>t</code>' into the string pointed to by '<code>s</code>'. For each character copies, both pointers are incremented. The loop terminates when it finds a <code>NUL</code> character (equal to zero, hence the exit).</p>
",0
810151,810129,46,"<p>It is equivalent to this:</p>

<pre><code>while (*t) {
    *s = *t;
    s++;
    t++;
}
*s = *t;
</code></pre>

<p>When the char that <code>t</code> points to is <code>'\0'</code>, the while loop will terminate. Until then, it will copy the char that <code>t</code> is pointing to to the char that <code>s</code> is pointing to, then increment <code>s</code> and <code>t</code> to point to the next char in their arrays.</p>
",0
810155,810129,-1,"<p>Yes this uses pointers, and also does all the work while evaluating the while condition. C allows conditional expressions to have side-effects.</p>

<p>The ""*"" operator derefereces pointers s and t.</p>

<p>The increment operator (""++"") increments pointers s and t after the assignment.</p>

<p>The loop terminates on condition of a null character, which evaluates as false in C.</p>

<p>One additional comment.... this is not safe code, as it does nothing to ensure s has enough memory allocated.</p>
",0
810160,810129,1,"<p>HINTS:</p>

<ul>
<li>What does the operator '=' do?</li>
<li>What is the value of the expression ""a = b""?  Eg: if you do ""c = a = b"" what value does c get?</li>
<li>What terminates a C string?  Does it evaluate true or false?</li>
<li>In ""*s++"", which operator has higher precedence?</li>
</ul>

<p>ADVICE:</p>

<ul>
<li>Use strncpy() instead.</li>
</ul>
",0
810162,810129,0,"<p>Say you have something like this:</p>

<pre><code>char *someString = ""Hello, World!"";
</code></pre>

<p><em>someString</em> points to the first character in the string - in this case 'H'.</p>

<p>Now, if you increment the pointer by one:</p>

<pre><code>someString++
</code></pre>

<p><em>someString</em> will now point to 'e'.</p>

<pre><code>while ( *someString++ );
</code></pre>

<p>will loop until whatever <em>someString</em> points at becomes NULL, which is what signals the end of a string (""NULL Terminated"").</p>

<p>And the code:</p>

<pre><code>while (*s++ = *t++);
</code></pre>

<p>is equal to:</p>

<pre><code>while ( *t != NULL ) { // While whatever t points to isn't NULL
    *s = *t;           // copy whatever t points to into s
    s++;
    t++;
}
</code></pre>
",0
810167,810129,34,"<p>This has so much going on under the covers:</p>

<pre><code>while (*s++ = *t++);
</code></pre>

<p>The <code>s</code> and <code>t</code> variables are pointers (almost certainly characters), <code>s</code> being the destination. The following steps illustrate what's happening:</p>

<ul>
<li>the contents of t (<code>*t</code>) are copied to s (<code>*s</code>), one character.</li>
<li><code>s</code> and <code>t</code> are both incremented (<code>++</code>).</li>
<li>the assignment (copy) returns the character that was copied (to the <code>while</code>).</li>
<li>the <code>while</code> continues until that character is zero (end of string in <code>C</code>).</li>
</ul>

<p>Effectively, it's:</p>

<pre><code>while (*t != 0) {
    *s = *t;
    s++;
    t++;
}
*s = *t;
s++;
t++;
</code></pre>

<p>but written out in a much more compact way.</p>
",0
810188,810129,3,"<p>The aspect that is mysterious about this is the order of operations. If you look up the C language spec, it states that in this context, the order of operations is as follows:</p>

<pre><code>1. * operator
2. = (assignment) operator
3. ++ operator
</code></pre>

<p>So the while loop then becomes, in english:</p>

<pre>
while (some condition):
  Take what is at address ""t"" and copy it over to location at address ""s"".
  Increment ""s"" by one address location.
  Increment ""t"" by one address location.
</pre>

<p>Now, what is ""some condition""? The C lang specification also says that the value of an assignment expression is the assigned value itself, which in this case is <code>*t</code>.</p>

<p>So ""some condition"" is ""<code>t</code> points to something that is non-zero"", or in a simpler way, ""while the data at location <code>t</code> is not <code>NULL</code>"".</p>
",1
810189,810129,-1,"<p>starts a while loop....</p>
<p>*s = *t  goes first,  this assigns to what t points at to what s points at.   ie, it copies a character from t string to s string.</p>
<p>what is being assigned is passed to the while condition... any non zero is &quot;true&quot; so it will continue, and 0 is false, it will stop.... and it just happens the end of a string is also zero.</p>
<p>s++ and t++ they increment the pointers</p>
<p>and it all starts again</p>
<p>so it keeps assigning looping, moving the pointers, until it hits a 0, which is the end of the string</p>
",0
810193,810129,19,"<p>Let's assume <code>s</code> and <code>t</code> are <code>char *</code>s that point to strings (and assume <code>s</code> is at least as large as <code>t</code>). In C, strings all end in <code>0</code> (ASCII ""NUL""), correct? So what does this do:</p>

<pre><code>*s++ = *t++;
</code></pre>

<p>First, it does <code>*s = *t</code>, copying the value at <code>*t</code> to <code>*s</code>. Then, it does <code>s++</code>, so <code>s</code> now points to the next character. And then it does <code>t++</code>, so <code>t</code> points to the next character. This has to do with <em>operator precedence</em> and <em>prefix vs. postfix increment/decrement</em>.</p>

<p>Operator precedence is the order in which operators are resolved. For a simple example, look:</p>

<pre><code>4 + 2 * 3
</code></pre>

<p>Is this <code>4 + (2 * 3)</code> or <code>(4 + 2) * 3</code>? Well, we know it is the first one because of <em>precedence</em> - the binary <code>*</code> (multiplication operator) has higher precedence than the binary <code>+</code> (addition operator), and is resolved first.</p>

<p>In <code>*s++</code>, we have unary <code>*</code> (pointer dereference operator) and unary <code>++</code> (postfix increment operator). In this case, <code>++</code> has higher precedence (also said to ""bind tighter"") than <code>*</code>. If we had said <code>++*s</code>, we would increment the <em>value at</em> <code>*s</code> rather than the <em>address pointed to by</em> <code>s</code> because <em>prefix</em> increment has lower precedence* as dereference, but we used <em>postfix</em> increment, which has higher precedence. If we had wanted to use prefix increment, we could have done <code>*(++s)</code>, since the parenthesis would have overridden all lower precedences and forced <code>++s</code> to come first, but this would have the undesirable side effect of leaving an empty character at the beginning of the string.</p>

<p>Note that just because it has higher precedence doesn't mean it happens first. Postfix increment specifically happens <em>after</em> the value has been used, which his why <code>*s = *t</code> happens before <code>s++</code>.</p>

<p>So now you understand <code>*s++ = *t++</code>. But they put it in a loop:</p>

<pre><code>while(*s++ = *t++);
</code></pre>

<p>This loop <em>does</em> nothing - the action is all in the condition. But check out that condition - it returns ""false"" if <code>*s</code> is ever 0, which means <code>*t</code> was 0, which means they were at the end of the string (yay for ASCII ""NUL""). So this loop loops as long as there are characters in <code>t</code>, and copies them dutifully into <code>s</code>, incrementing <code>s</code> and <code>t</code> all the way. When this loop exits, <code>s</code> has been NUL-terminated, and is a proper string. The only problem is, <code>s</code> points to the end. Keep another pointer handy that points to the beginning of <code>s</code> (i.e. <code>s</code> before the <code>while()</code> loop) - <em>that</em> will be your copied string:</p>

<pre><code>char *s, *string = s;
while(*s++ = *t++);
printf(""%s"", string); // prints the string that was in *t
</code></pre>

<p>Alternatively, check this out:</p>

<pre><code>size_t i = strlen(t);
while(*s++ = *t++);
s -= i + 1;
printf(""%s\n"", s); // prints the string that was in *t
</code></pre>

<p>We started by getting the length, so when we ended, we did more pointer arithmetic to put <code>s</code> back at the beginning, where it started.</p>

<p>Of course, this code fragment (and all my code fragments) ignore buffer issues for simplicity. The better version is this:</p>

<pre><code>size_t i = strlen(t);
char *c = malloc(i + 1);
while(*s++ = *t++);
s -= i + 1;
printf(""%s\n"", s); // prints the string that was in *t
free(c);
</code></pre>

<p>But you knew that already, or you'll soon ask a question on everyone's favorite website about it. ;)</p>

<p>* Actually, they have the same precedence, but that's resolved by different rules. They effectively have lower precedence in this situation.</p>
",1
1798408,1798307,1,"<p>File-scoped variables are <code>extern</code> by default; see C99 spec, 6.2.2 ¡ì5:</p>

<blockquote>
  <p>If the declaration of an identifier
  for a function has no storage-class
  specifier, its linkage is determined
  exactly as if it were declared with
  the storage-class specifier extern. If
  the declaration of an identifier for
  an object has file scope and no
  storage-class specifier, its linkage
  is external.</p>
</blockquote>

<p>If you want your variables to be distinct, add the specifier <code>static</code>.</p>
",0
1798329,1798307,3,"<p>Instead of defining it in two *.c files, you should use:</p>

<pre><code>extern int m_Test;
</code></pre>

<p>Use this in every *.c file except one, or, preferably, put this extern declaration into a header file (which you can then include into any number of *.c files).</p>

<p>Only one file should contain the non-extern definition:</p>

<pre><code>int m_Test = 0;
</code></pre>

<hr>

<p>The above is good advice, if (only if) you want the same variable to used in all *.c files: so that, for example, if you change its value in one file, then the changed value is visible when you read it from the same variable in another file.</p>

<p>If, alternatively, you want several independent instances of the variable (where each *.c file has its own independent copy of the variable), then define each of them as a 'static' variable, e.g. define the following in each of the several *.c files:</p>

<pre><code>static int m_Test = 0;
</code></pre>

<hr>

<blockquote>
  <p>The static approach is working, Can
  you explain what happens when I add =
  0 to the definition, maybe?</p>
</blockquote>

<p>Adding <code>= 0</code> to the definition would be harmless: it's permitted to initialize a variable when you define it, and when you do initialize a static variable the variable is still static (i.e. still has 'internal linkage' and isn't visible in other modules).</p>

<p>It's a slightly useless thing to do, because you can instead assume that the initial value of a static int variable is guaranteed to be zero (unless some other value is specified using an initializer); but it's quite possibly a good idea to specify it anyway, if only to document what the initial value is (instead of depending on a language rule that you're not very familiar with).</p>
",1
1798332,1798307,1,"<p>Are you accidentially including an external definition of the variable?  IE including something like this:</p>

<pre><code>extern int m_Test; 
</code></pre>

<p>From FileA in FileB or vica versa?</p>

<p>Check your header files and make sure none of them contain something like that.</p>
",2
1798380,1798307,5,"<p>If you want the variables to be independent, declare them <code>static</code>.</p>

<pre><code>static int m_Test;
</code></pre>

<p>Means that the variable m_Test is only visible in that file-scope, and is not available to other files or modules.</p>
",7
1798772,1798307,7,"<p>When you declare your variable as in your original post, the variable gets external linkage (with our without initializer - doesn't matter). This means that the variables are not independent. In both declarations the names refer to the same object. In fact, what you have is a multiple definitions of the same entity with external linkage. This is a violation of C language definition rules, i.e. it is what we usually call an <em>error</em>. Note, that this is an error in any case: with or without initializer.</p>

<p>The reason your code seems to compile fine without an initializer is just a quirk of your compiler.</p>

<p>I can actually guess the rationale behind that quirk. You see, C language has an interesting feature (not present in C++, BTW) called <strong><em>tentative definitions</em></strong>. This feature says that if you declare a variable like that, without initializer</p>

<pre><code>int m_Test; /* no initializer */
</code></pre>

<p>you create a <em>tentative definition</em> of that variable. You can declare it in the same way multiple times in the same translation unit</p>

<pre><code>int m_Test; 
int m_Test; /* OK in C */
int m_Test; /* OK in C */
</code></pre>

<p>(note, again, that this would be illegal in C++). If at some point you provide a non-tentative definition for that variable</p>

<pre><code>int m_Test = 0; /* non-tentative */
</code></pre>

<p>the compiler will ""merge"" all these previous tentative definitions with this one. But if you don't provide a non-tentative definition, the compiler will generate one for you implicitly, and it will be equivalent to</p>

<pre><code>int m_Test = 0; /* implicit definition generated by the compiler */
</code></pre>

<p>Note, however, that this only applies within the same translation unit. That means that once you wrote something like that</p>

<pre><code>int m_Test; /* tentative */
</code></pre>

<p>it already guarantees that this variable will eventually be non-tentatively <em>defined</em> in this translation unit (by you explicitly, or by the compiler implicitly). If you do the same thing in another translation unit, that variable will be defined there as well, which will violate the one definition rules of C language.</p>

<p>However, the compiler you are using must be treating the tentative definition rules more losely and allows something like ""tentative definitions across several translation units"". This is why you don't get an error in your first case. However, this is just a quirk of your compiler. It is still illegal in C.</p>

<p>P.S. As it has been noted in one of the linked posts, this behavior is a non-portable ""common extension"" of C compilers (even mentioned in the informative section of the language standard). I.e. some compilers are known to allow multiple declarations of external objects as long as no more than one of them includes an initializer.</p>

<p>P.P.S. Of course, if you <em>want</em> to have indepedent variables in different translation units, you have to declare them as <code>static</code>, as others already noted.</p>
",0
1315507,1315498,8,"<p>Are you using multiple threads? I've often found that the act of printing something out can be enough to effectively suppress a race condition (i.e. not remove the bug, just make it harder to spot).</p>

<p>As for how to diagnose/fix it... can you move the second print earlier and earlier until you can see where it's changing?</p>

<p>Do you <em>always</em> see 0x1 later on when you don't have the <code>printf</code> in there?</p>

<p>One way of avoiding the delay/synchronization of <code>printf</code> would be to copy the pointer value into another variable at the location of the first <code>printf</code> and then print out that value later on - so you can see what the value <em>was</em> at that point, but in a less time-critical spot. Of course, as you've got odd value ""corruption"" going on, that may not be as reliable as it sounds...</p>

<p>EDIT: The fact that you're always seeing 0x1 is encouraging. It should make it easier to track down. Not being multithreaded does make it slightly harder to explain, admittedly.</p>

<p>I wonder whether it's something to do with the extra <code>printf</code> call making a difference to the size of stack. What happens if you print the value of a <em>different</em> variable in the same place as the first printf call was?</p>

<p>EDIT: Okay, let's take the stack idea a bit further. Can you create another function with the same sort of signature as <code>printf</code> and with enough code to avoid it being inlined, but which doesn't actually print anything? Call that instead of printf, and see what happens. I suspect you'll still be okay.</p>

<p>Basically I suspect you're screwing with your stack memory somewhere, e.g. by writing past the end of an array on the stack; changing how the stack is used by calling a function may be disguising it.</p>
",5
1315513,1315498,4,"<p>If you're running on a processor that supports hardware data breakpoints (like x86), just set a breakpoint on writes to the pointer.</p>
",0
1315514,1315498,0,"<p>Have you tried setting a condition in your debugger which notifies you when that value is modified?  Or running it through Valgrind?  These are the two major things that I would try, especially Valgrind if you're using Linux.  There's no better way to figure out memory errors.</p>
",1
1315517,1315498,1,"<p>Do you have a debugger available to you? If so, what do the values look like in that? Can you set any kind of memory/hardware breakpoint on the value? Maybe there's something trampling over the memory elsewhere, and the printf moves things around enough to move or hide the bug?</p>

<p>Probably worth looking at the asm to see if there's anything obviously wrong there. Also, if you haven't already, do a full clean rebuild. If the definition of the struct has changed recently, there's a vague change that the compiler could be getting it wrong if the dependency checking failed to correctly rebuild everything it needed to.</p>
",7
1315526,1315498,0,"<p>Without code, it's a little hard to help, but I understand why you don't want to foist copious amounts on us.</p>

<p>Here's my first suggestion: use a debugger and set a watchpoint on that pointer location.</p>

<p>If that's not possible, or the bug disappears again, here's my second suggestion.</p>

<p>1/ Start with the buggy code, the one where you print the pointer value and you see 0x1.</p>

<p>2/ Insert another printf a little way back from there (in terms of code execution path).</p>

<p>3/ If it's still 0x1, go back to step 2, moving a little back through the execution path each time.</p>

<p>4/ If it's 0x0, you know where the problem lies.</p>

<p>If there's nothing obvious between the 0x0 printf and the 0x1 printf, it's likely to be corruption of some sort. Without a watchpoint, that'll be hard to track down - you need to check every single stack variable to ensure there's no possibility of overrun.</p>

<p>I'm assuming that pointer is a global since you set it and print it ""a million miles away"". If it is, lok at the variables you define on either side of it (in the source). They're the ones most likely to be causing overrun.</p>

<p>Another possibility is to turn off the optimization to see if the problem still occurs. We've occasionally had to ship code like that in cases where we couldn't fix the bug before deadlines (we'll always go back and fix it later, of course).</p>
",0
1776945,1776912,2,"<p>You should approach it from a ""cleanliness"" angle; don't ship headers which include functions you aren't intending people to call. Don't document functions which you aren't shipping headers for.</p>

<p>If someone really wants to call a function in your library, they can, but you should try to make it clear that that's an unsupported use case and it's their problem if it all goes wrong.</p>
",0
1277838,1277799,0,"<p>40000 in hexadecimal is 0x9C40.  Notice that the most significant bit of this value is a 1 (0x8000).  Assuming a <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow noreferrer"">two's complement</a> representation, that means that if you cram 0x9C40 into a signed representation, then, by subtracting the value at the sign bit from the rest, you will get 0x1C40 - 0x8000 = -0x63C0 = -25536 (base 10).</p>

<p>Have a look at <a href=""https://www.securecoding.cert.org/confluence/display/seccode/INT00-C.+Understand+the+data+model+used+by+your+implementation(s)"" rel=""nofollow noreferrer"">INT00-C. Understand the data model used by your implementation(s)</a> and <a href=""https://www.securecoding.cert.org/confluence/display/seccode/INT02-C.+Understand+integer+conversion+rules"" rel=""nofollow noreferrer"">INT02-C. Understand integer conversion rules</a> on the CERT C Secure Coding Standard Wiki for more information.</p>
",1
1277843,1277799,2,"<p>From <a href=""http://en.wikipedia.org/wiki/The_C_Programming_Language_(book)"" rel=""nofollow noreferrer"">Kernighan &amp; Ritchie</a>, Appendix A2.5.1 (Integer Constants), p 193:</p>

<blockquote>
  <p>The type of an integer constant
  depends on its form, value and
  suffix...If it is unsuffixed and
  decimal, it has the first of these
  types in which its value can be
  represented: int, long int, unsigned
  long int.</p>
</blockquote>

<p>Note that this answer is only relevant to C89, as the 2nd Edition of the ""C Programming Language"" predates the C99 standard.</p>
",0
1277857,1277799,2,"<p>Behaviour here differs between C89 and C99.</p>

<p>In C89, a decimal integer literal takes the first of these types in which it can be represented:</p>

<pre><code>int, long, unsigned long
</code></pre>

<p>In C99, a decimal integer literal takes the first of these types in which it can be represented:</p>

<pre><code>int, long, long long
</code></pre>

<p>For your particular code snippet it makes no difference, since 40000 is guaranteed to fit in a long, but there are a few significant differences between C89 and C99 literals.</p>

<p>Some of those consequences are described here:</p>

<p><a href=""http://www.hardtoc.com/archives/119"" rel=""nofollow noreferrer"">http://www.hardtoc.com/archives/119</a></p>
",0
1694932,1694912,1,"<p>You could return a pointer to the function that's going to treat the event, and then just execute it when it's the right time for it? You could even have a FIFO of function pointers awaiting to be executed in order, with interfaceMouse() feeding it, and you just execute the ones in front when you can. I also see that you are using a polling mechanism with interfaceMouse(), is this the best option? I assume you do this in the game loop or something like that.</p>
",3
1695285,1694912,2,"<p>From your description, I've made a couple of assumptions, but here is how I would handle it:</p>

<p>interfaceMouse() determines what needs to occur from the mouse interaction, but does not process that actual interaction (or, processes the interaction but wants to explicitly return what was done).  What I would do is have interfaceMouse() return a struct defined similar to:</p>

<pre><code>struct 
{
    int event_type; /* Enumerated type */
    void* element; /* Pointer to the element, however it's defined in the code */
    void* event_data; /* Pointer to the data about the event */
 } event_result;
</code></pre>

<p>You can define the calls by accessing the element based on type (say, another struct with function pointers, or have event_data hold the function pointer and element be passed to it, etc.).</p>

<p>C is one of those languages where it requires a lot more thought of your data modeling, but can end up being as elegant or convoluted as you'd like.</p>
",0
1695479,1694912,2,"<p>Use a correct programming model should work. for example below is a Staged Programming Model:</p>

<pre><code>     +-------------------------------+
     | Stage():                      |
     |    +-OnButtonAClick(Event)    |
     |    +-OnMenuSelect(Event)      |
     |    +-...                      |
     +------+-------------+----------+
            | Pop()       |
            |             |
          +-V-+         +-V-+ 
          | Q |         | Q |     ...           Logic-Half
   -------| 0 |         | 1 |-----------------------------
          |   |         |   |                     I/O-Half
          +-^-+         +-^-+
            | Push()      |
       +----+---+     +---+----+  
       |Event of|     |Event of|  ...
       |  Mouse |     |  Menu  |
       +--------+     +--------+     
</code></pre>

<p>All OnXXX() will be executed in Stage() sequentially; and your data was attached to each event accordingly from bottom and goes upwards. Every event was driven and handled asynchronously.</p>

<p>See my comments in another thread:<a href=""https://stackoverflow.com/questions/1606952/viewing-data-in-a-circular-buffer-in-real-time"">Viewing data in a circular buffer in real-time</a> for the details about Staged.</p>
",0
1479387,1479366,0,"<p>Mod is an integer operation, so it cannot be used on floats. Your case should read something like:</p>

<pre><code>result = (int)number1 % (int)number2;
</code></pre>

<p>which will convert both floats to integers, and perform the mod. However, note that you are losing precision by casting a floating point number to an integer, so it is likely the result may not be what you'd expect.</p>
",2
1479397,1479366,2,"<p>I recommend to use the <a href=""http://www.kernel.org/doc/man-pages/online/pages/man3/fmod.3.html"" rel=""nofollow noreferrer""><code>fmod</code></a> function of the standard C library.</p>
",0
1479398,1479366,0,"<p>change </p>

<pre><code>case '%':
     result = number1 % number2;
</code></pre>

<p>to</p>

<pre><code>case '%':
    result = (int)number1 % (int)number2;
</code></pre>

<p>?</p>

<p>modulo division is for integers. Cast each operand to an integer.</p>
",0
1479405,1479366,4,"<p>You can either use a statement like:</p>

<pre><code>result = (int)number1 % (int)number2;
</code></pre>

<p>to cast your floats to ints and perform the modulus operation, but you'll lose the decimal precision.</p>

<p>You could also include math.h and use fmod</p>

<pre><code>result = fmod(number1, number2);
</code></pre>
",0
1479407,1479366,2,"<p>The <code>%</code> operator only works on integer types. To perform the same task with floating points, you'd want to do something like:</p>

<pre><code>#include &lt;math.h&gt;
float modulus(float a, float b)
{
   return a - b * floor(a / b);
}
</code></pre>
",0
1592366,1592363,8,"<p><code>malloc</code> can give you a pointer from anywhere in the heap; it's entirely up to the implementation as to how it allocates memory.</p>

<p>The pointer values are limited to your address space range (so, in a 32-bit address space, you won't get a pointer value greater than 2^32 - 1).</p>
",7
1592376,1592363,4,"<p><code>malloc(3)</code> obtains memory from the OS, so the OS, and the way your program is linked, are what determine the addresses that <code>malloc(3)</code> can play with. Because malloc recycles memory, you may be reusing an older allocation, or it may simply decide to hand out the higher addresses first.</p>

<p>However, in your program, you overwrite the malloc address references with references to your string literals. These are allocated in static memory in your image; malloc is not involved.</p>
",0
1592373,1592363,12,"<p>You are not printing the addresses returned from malloc, but the addresses of the string literals (which are statically allocated). If you want to fill the blocks, use strcpy; doing so is not necessary to print the addresses, though.</p>

<p>Also, use %p to print pointers.</p>
",2
1592374,1592363,1,"<p>The OS will determine how to meet the malloc demands, as your program has allocations that went beyond just what you explicitly asked for, and there is no guarantee where it will be allocated at, as this is not physical memory but pointers to some virtual memory that will map to physical memory.</p>

<p>Also, two adjacent blocks won't be merged, as it would then be difficult to determine how to free them, which of the two pointers would free be called with?</p>
",2
1593455,1592363,1,"<p>""p1 will be less than p2"" falls in the realm of ""undefined"".  Something like <code>p1 &lt; p2</code> is defined only if p1 and p2 point to elements within the same array or struct.</p>
",0
699994,699985,1,"<p>It is the C standard library style. The return value is there to aid chaining of function calls.</p>

<p>Also, <code>DoStuff</code> is cleaner IMO. And you really should be using <code>snprintf</code>. And a change in the internals of buffer management do not affect your code. However, this is no longer true with <code>NewDoStuff</code>.</p>
",2
700000,699985,0,"<p>The code you presented is a little unclear (for example, why are you adding myOutPtr with the results of the sprintf.</p>

<p>However, in general what it seems that you're essentially describing is the breakdown of one function that does two things into a function that does one thing and a code that does something else (the concatenation).</p>

<p>Separating responsibilities into two functions is a good idea. However, you would want to have a separate function for this concatenation and formatting, it's really not clear.</p>

<p>In addition, every time you break a function call into multiple calls, you are creating code replication. Code replication is never a good idea, so you would need a function to do that, and you will end up (this being C) with something that looks like your original DoStuff.</p>

<p>So I am not sure that there is much you can do about this. One of the limitations of non-OOP languages is that you have to send huge amounts of parameters (unless you used structs). You might not be able to avoid the giant interface.</p>
",0
700005,699985,0,"<p>If you wind up having to do the sprintf call after every call to NewDoStuff, then you are repeating yourself (and therefore violating the DRY principle).  When you realize that you need to format it differently you will need to change it in every location instead of just the one.</p>
",0
700007,699985,1,"<p>One advantage is that if you have many, many calls to these functions in your code, it will quickly become tedious to have to repeat the <code>sprintf</code> calls over and over again.</p>

<p>Also, returning the out pointer makes it possible for you to do things like:</p>

<pre><code>DoOtherStuff(DoStuff(myInPtr, myOutPtr, myError, &amp;myAmount), &amp;myOther);
</code></pre>

<p>With your new approach, the equivalent code is quite a lot more verbose:</p>

<pre><code>myAmount = DoNewStuff(myInPtr, myError);
myOutPtr += sprintf(""%d"", myAmount);
myOther  = DoOtherStuff(myInPtr, myError);
myOutPtr += sprintf(""%d"", myOther);
</code></pre>
",0
700059,699985,0,"<p>As a rule of thumb, if the interface to one of my functions exceeds 110 columns, I look strongly at using a structure (and if I'm taking the best approach). What I don't (ever) want to do is take a function that does 5 things and break it into 5 functions, unless some functionality within the function is not only useful, but needed on its own.</p>

<p>I would favor the first function, but I'm also quite accustomed to the standard C style. </p>
",0
1592471,1592414,0,"<blockquote>
  <p>I tried using strcpy(tempArticle[i], dictionary); but it didn't seem to work?</p>
</blockquote>

<p>tempArticle[i] is an array position and dictionary is an array..</p>

<p>Use array for storing array.. hopefully that will solve the issue.. Right now  i guess only the 1st character in dictionary will be stored in temparticle..  </p>
",1
1592479,1592414,1,"<p>Your best bet will be to figure out your algorithm first, and <em>then</em> code it up.</p>

<p>In other words, get a whiteboard, a piece of paper or fire up a text editor and write down, in plain language, the steps you would go through to compare the article against the dictionary.  You might start with something very simple, like:</p>

<ul>
<li>Go through each word in the article, and see if it is in the dictionary.  If is it not, add it to a list of misspelled words.</li>
<li>Print the list of misspelled words.</li>
</ul>

<p>Then you have to break each of the complicated bits down further - for example, ""see if a single word is in the dictionary"" needs to be broken down.  (By the way, each of the self-contained ""complicated bits"" like this is a good candidate for a separate function in the resulting code).</p>

<p>At that point, you will find that converting what you've come up with into code will be a <em>lot</em> easier.</p>
",0
587063,587049,29,"<p>C, like many other languages, is <a href=""http://en.wikipedia.org/wiki/Turing_complete"" rel=""nofollow noreferrer"">Turing Complete</a>.</p>

<p>So simple answer is: none.</p>

<p>However, C++ Template Meta Programming meets the same criterion, so ""it is possible"" is not a good criterion to choose tools.</p>
",2
587069,587049,19,"<p>The very first C compiler?</p>
",9
587081,587049,0,"<p>There is not a single algorithm that cannot be written with C.  </p>
",2
587085,587049,2,"<p>There are none.</p>

<p>Different languages give you different ways to say things. For some classes of problems a given language may be more expressive and/or concise. Are there projects that you should pick something aside from C? Yes, of course. But to say you can't do it well in C is misleading. It would be better to ask which language is the best choice for the problem at hand, and are the gains worth using something unfamiliar?</p>
",0
587093,587049,0,"<p>Depends on how much you want to invest (time/money/energy) to make it happen.  Otherwise, I'd say there aren't any.  It is just easier sometimes to use something else.</p>
",0
587118,587049,4,"<p>Alright, here's one: you cannot write an x86 boot sector in C. This is one of those things that <strong>has to be written</strong> in ASM. </p>
",8
587135,587049,2,"<p>Anything can be done in virtually any language.</p>

<p>That said there is a level of practicality.  As your system's complexity increases, you need better tools to manage it.</p>

<p>The problems are still solvable, but you start to need more people and much more effort in design.  I'm not saying other languages don't benefit from design, I'm saying that the same level and attention to detail may not be required.</p>

<p>Since we programmers are Human (I am at least) we have troubles in one area or another.  My biggest is memory.  If I can visualize my code as objects, manipulating large modules in my head becomes easier, and my brain can handle larger projects.</p>

<p>Of course, it's even possible to write good OO code in C, the patterns were developed in C by manually managing dispatch tables (tables of pointers with some pointers updated to point to different methods), and this is true of all programming constructs from higher languages--they can be done in any language, but...</p>

<p>If you were to implement objects in C, every single class you wrote would have a large amount of boilerplate overhead.  If you made some form of exception handling, you would expose more boilerplate.</p>

<p>Higher level languages abstract this boilerplate out of your code and into the system, simplifying what you have to think about and debug (a dispatch table in C could take a lot of debugging, but in C++ it isn't going to fail because the code generated by a working compiler is going to be bug-free and hidden, you never see it).</p>

<p>I guess I'd say that's the biggest (only?) difference between low level and higher level languages, how much boilerplate do you hide.  In the latest batch of dynamic languages, they are really into hiding loop constructs within the language, so more things look like:</p>

<p>directory.forEachFile(print file.name);  // Not any real language</p>

<p>In C, even if you isolated part of the looping inside a function, setting up the function pointers and stuff would still take lines of un-obvious code that is not solving part of your primary problem.</p>
",0
587326,587049,0,"<p>OS kernel has been written in C and everything runs over it so you can write <em>everything</em> in C.</p>

<p>Boot sector that needs ASM :-) , I don't think you meant that.</p>
",3
587355,587049,10,"<p>A working solution to the <a href=""http://en.wikipedia.org/wiki/Halting_problem"" rel=""noreferrer"">halting problem</a></p>
",0
1678663,1671895,1,"<p>This is one way to do it:</p>

<pre><code>#include &lt;stdarg.h&gt;
#include &lt;limits.h&gt;

int max(int N, ...)
{
    int big = INT_MIN;
    int i;
    va_list args;

    va_start(args, N);
    for (i = 0; i &lt; N; i++)
    {
        int x = va_arg(args, int);
        if (big &lt; x)
            big = x;
    }
    va_end(args);
    return(big);
}

#include &lt;stdio.h&gt;
int main(void)
{
    printf(""%d\n"", max(6, 1, 3, 5, 7, 9, 8));
    printf(""%d\n"", max(5, 1, 3, 5, 7, 9, 8));
    printf(""%d\n"", max(4, 1, 3, 5, 7, 9, 8));
    printf(""%d\n"", max(3, 1, 3, 5, 7, 9, 8));
    printf(""%d\n"", max(2, 1, 3, 5, 7, 9, 8));
    printf(""%d\n"", max(1, 1, 3, 5, 7, 9, 8));
    printf(""%d\n"", max(0, 1, 3, 5, 7, 9, 8));
    return(0);
}
</code></pre>
",0
1783414,1783399,8,"<p>Use double quotes to pass the entire path as the executable / batch file:</p>

<pre><code>system(""\""%TESTCASES_PATH%SIP\\test.bat\"""");
</code></pre>

<p>Otherwise, what's after a space becomes the first command-line parameter.</p>

<p>EDIT: Perhaps on your setup, <code>%TESTCASES_PATH%</code> is not expanded by the <code>system()</code> function.  On most systems, you can retrieve the value of an environment variable with <code>getenv()</code>:</p>

<pre><code>char cmd[FILENAME_MAX];
snprintf(cmd, FILENAME_MAX, ""\""%s\\test.bat\"""", 
    getenv(""TESTCASES_PATH""));
system(cmd);
</code></pre>
",1
1783425,1783399,3,"<p>What about:</p>

<pre><code>system(""\""%TESTCASES_PATH%SIP\\test.bat\"""");
</code></pre>

<p>The additional double quotes in the string allow to pass file names with white space to the system call.</p>
",0
1783446,1783399,1,"<p>With one caveat to both solutions : test them with a string that contains NO space too.</p>

<p>It might fail on some windows shells.</p>
",0
1678822,1678799,1,"<p>If <code>size_in_bytes</code> is an integer multiple of <code>sizeof(int)</code>, like <code>2 * sizeof(int)</code>, it gives you that multiple, because (sizeof(int)-1)/sizeof(int) is less than one. If <code>size_in_bytes</code> is anything other than an integer multiple of <code>sizeof(int)</code>, the remainder when divided by <code>sizeof(int)</code> must be at least one. So (<code>sizeof(int)</code> + that remainder - one) is always >= sizeof(int). So it always rounds up.</p>
",9
1678829,1678799,7,"<p>Integer division truncates in C, yes. (i.e. it's round towards zero, not round down.)</p>

<p>By adding ""divisor - 1"" you make sure that any number which isn't an exact multiple of the divisor gets rounded up. So for example, dividing by 3:</p>

<pre><code> (0 + 2) / 3 == 0 (0 is an exact multiple)
 (1 + 2) / 3 == 1 (round up)
 (2 + 2) / 3 == 1 (round up)
 (3 + 2) / 3 == 2 (3 is an exact multple)
</code></pre>

<p>etc</p>
",4
1678843,1678799,1,"<p>When all the arguments are <em>int</em>, the / operator does integer division.  This means it will divide the top over the bottom, like one would expect of math, but it will just throw away the remainder.  Or, in other words, it will always round towards zero.</p>

<p>With integer division, <code>( sizeof(int) - 1 ) / sizeof(int)</code> will always be less than one.  It is, essentially, the largest not-quite-one value you can have.  So adding it to the equation will always add not-quite-one to the final answer, which, when rounded down, will be the same as rounding the original equation up.</p>

<p>Reading this answer back, I realize it makes a lot more sense in my head than it does in words.</p>
",1
1504908,1504901,2,"<p>It's an explicit cast.  You are casting the value of problem3 to an integer and then assigning that integer value to x.</p>

<p>Note that this does not actually change the value of problem3.</p>
",0
1504915,1504901,18,"<p>It's a typecast, and tells the compiler ""Ignore the type that problem3 really has, and deal with it as if it were typed as an int"".</p>

<p>In this example, problem3 has a function pointer type, so normally the compiler would reject the program (Using a function pointer when an integer is expected is normally a programmer error). The typecast forces a different interpretation - the programmer is stepping in and saying ""I know what I'm doing"".</p>
",3
1504916,1504901,0,"<p>It means that <code>problem3</code> is converted to type int before assigning to the int <code>x</code></p>
",4
1504926,1504901,0,"<p>It's a typecast ie. it converts the variable/constant following it into the specified type. Here, a void (*) (void) type is converted into an int (thing in the braces)</p>
",1
1504941,1504901,0,"<p>As others have noted this is just explicit cast. It just changes type of variable into <code>int</code> type.</p>

<p>But from code you posted it looks like this function is preparing for some kind of buffer overflow or something. What is the rest of this function ?</p>
",2
1504961,1504901,1,"<p>It's a type cast - it's a form of converting the type of the operand (<code>problem3</code> in your example) to another type.</p>

<p>In C (and in C++ when a 'C-style cast is used), the cast can perform one of several things:</p>

<ul>
<li>do nothing but change the type of something without changing the form of the data.  For example, when you cast a pointer to an int.</li>
<li>perform a conversion as part of the cast operation.  For example, when casting a float to an int, the data is actually transformed from the form used to represent floating point values (usually an exponent/mantissa form) to a plain old integer (with any fractional part lost)</li>
</ul>

<p>Because the different forms of casting can be confusing or unclear as to what's happening (or intended to happen), C++ added several specific casting operators:</p>

<ul>
<li><code>reinterpret_cast&lt;&gt;()</code> which corresponds to the first form described above</li>
<li><code>static_cast&lt;&gt;()</code> which corresponds to the second form (even if the conversion doesn't result in a change of the internal data format)</li>
<li><code>const_cast&lt;&gt;()</code> which is a special case of casting that is able to remove the <code>const</code> or <code>volatile</code> qualifiers that might be applied to an object</li>
<li><code>dynamic_cast&lt;&gt;()</code> which is entirely new to C++ and has no similar functionality in C.  This operator is used to safely 'downcast' a base object type to one of its derived types.</li>
</ul>

<p>Because they're inherently dangerous, casts are generally considered bad form.  When you perform a cast operation, you're subverting the compiler's ability to perform type checking.  However, there are times when it might be necessary or very useful, and you'll see it used often in C code.</p>

<p>In your example, <code>problem3</code> is a pointer to a function, and the cast is 'converting' the address for that function to an int.  It's then storing that address-as-int into the array, but actually one array element past the end of the array (which is a no-no).  On many platforms that invalid array element is where the return address for the the function is stored, so what will happen is when the <code>problem3()</code> function returns, it'll return to itself and run again (ad-infinitum - sort of).</p>

<p>It'll eventually underflow the stack because the new, 'hacked' run of <code>problem3()</code> won't have a function call that put a return address on the stack - it'll just trash whatever else was on the stack before it and <code>return</code> to itself again, repeating the process until the stack underflows which will likely cause a processor exception.</p>
",0
633372,633367,26,"<pre><code>int printf ( const char * format, ... );
</code></pre>

<p>They were probably asking this to see if you were familiar with the optional parameter syntax ""..."".  This allows you to pass an indeterminate list of variables that will fill in the format string.</p>

<p>For example, the same method can be used to print things like this:</p>

<pre><code>printf(""This is a string: %s"", myString);
printf(""This is a string: %s and an int: %d"", myString, myInt);
</code></pre>
",15
633374,633367,8,"<p>printf is a variadic function with the following signature:</p>

<pre><code>int printf(const char *format, ...);
</code></pre>

<p>this means that it has one <strong>required</strong> string parameter, followed by 0 or more parameters (which can be of various types). Finally, it returns an int which represents how many characters are in the result.</p>

<p>The number and type of the optional parameters is determined by the contents of the format string.</p>
",0
633380,633367,3,"<p><a href=""http://en.wikipedia.org/wiki/Method_signature"" rel=""nofollow noreferrer"">Method signature</a>, for some additional context.</p>
",0
524705,524698,9,"<p>In the printf, I believe %d is a signed decimal integer, try %u instead.</p>

<p>The max value of an unsigned int has the most significant bit set (it is all 1s). With a signed int, the most significant bit specifies negative numbers, so when you're printing an unsigned int as a signed int, printf thinks it is negative.</p>
",0
524709,524698,15,"<p>This is because UINT_MAX resolves to -1 if treated as a signed integer. The reason for this is, that integers are represented in <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""noreferrer"">two's-complement</a>. As a consequence, -1 and 4294967296 (i.e. UINT_MAX) have the same bit representation (0xFFFFFFFF, i.e. all bits set) and that's why you get a -1 here.</p>

<p><strong>Update:</strong><br>
If you use ""%u"" as the format string you will get the expected result.</p>
",4
1909852,1909825,7,"<p>You have to declare the variables to be of type enum boolean, not just boolean. Use typedef, if you find writing enum boolean b1 = foo(); cumbersome.</p>
",0
1909863,1909825,10,"<p>In C, there are two (actually more, but i keep it at this) kind of namespaces: Ordinary identifiers, and tag identifiers. A struct, union or enum declaration introduces a tag identifier:</p>

<pre><code>enum boolean { true, false };
enum boolean bl = false;
</code></pre>

<p>The namespace from which the identifier is chosen is specified by the syntax around. Here, it is prepended by a <code>enum</code>. If you want to introduce an ordinary identifier, put it inside a typedef declaration</p>

<pre><code>typedef enum { true, false } boolean;
boolean bl = false;
</code></pre>

<p>Ordinary identifiers don't need special syntax. You may declare a tag and ordinary one too, if you like. </p>
",2
1909875,1909825,3,"<p>You declare the enum, but not the type.  What you want is</p>

<pre><code>typedef enum{false, true} boolean;  // false = 0 is expected by most programmers
</code></pre>

<p>There are still multiple problems with this:<br>
* <code>true</code> and <code>false</code> are reserved words in many C compilers<br>
* explicitly using true and false goes against the general practice of Boolean expressions in C, where zero means false and anything non-zero means true.  For example:</p>

<pre><code>int found = (a == b);
</code></pre>

<p><hr/>
Edit:  This works with gcc 4.1.2:</p>

<pre><code>[wally@zf ~]$ ./a.out
This is the false value of boool
This is the true value of boool
[wally@zf ~]$ cat t2.c
#include&lt;stdio.h&gt;
int main()
{
        typedef enum {true,false} boolean;
        boolean bl=false;
        if(bl==false)
                printf(""This is the false value of boool\n"");
        boolean bl1=true;
        if(bl1==true)
        {
                printf(""This is the true value of boool\n"");
        }
        return 0;
}
</code></pre>
",3
1909897,1909825,7,"<p>It would really be a good idea to define your enum like this:</p>

<pre><code>typedef enum {
  False,
  True,
} boolean;
</code></pre>

<p>A couple of reasons:</p>

<ul>
<li><code>true</code> and <code>false</code> (lowercase) are likely reserved words</li>
<li>false being 1 and true being 0 can cause you logic problems later</li>
</ul>
",1
1909902,1909825,1,"<p>Like previous answers demonstrate, use typedef:</p>

<pre><code>typedef enum { true, false } boolean;
</code></pre>
",1
1909922,1909825,7,"<p>When you declare <code>enum boolean { true, false }</code>, you declare a type called <code>enum boolean</code>. That the name you'll have to use after that declaration: <code>enum boolean</code>, not just <code>boolean</code>.</p>

<p>If you want a shorter name (like just <code>boolean</code>), you'll have to define it as an alias for the original full name</p>

<pre><code>typedef enum boolean boolean;
</code></pre>

<p>If you wish, you can declare both the <code>enum boolean</code> type and the <code>boolean</code> alias on one declaration</p>

<pre><code>typedef enum boolean { true, false } boolean;
</code></pre>
",0
766399,766386,3,"<p>You're allowed to increase access restriction, you just can't decrease it. Going from a normal pointer to a const pointer is fine, going from a const pointer to a normal pointer is not.</p>

<p>The second example doesn't compile because you're not converting a pointer to a const pointer, you're converting from a pointer to one type (<code>char*</code>) to another (<code>const char*</code>). For example, you can change a <code>char**</code> to a <code>char* const*</code>, but not a <code>const char**</code>.</p>
",1
766406,766386,12,"<p><code>char** -&gt; const char **</code> is dangerous, since you might end up accidentally modifying the underlying <code>const</code> object.</p>

<p>The correct way to write what you want is:</p>

<pre><code>void processargs(const char * const *p)
{ 
}
</code></pre>
",1
766432,766386,0,"<p>The first example of yours works, because you're converting <em>rvalues</em> of <code>char*</code> to <code>const char*</code>, which is OK (basically because you cannot assign to rvalues). The second doesn't, because the target of a (non-const) pointer is always a lvalue.</p>

<p>Just try (maybe with the aid of the compiler) which operations you can do with <code>char**</code>, which work with <code>const char**</code>, and think if and what types are interchangeable.</p>
",0
766453,766386,2,"<p>Check if this clarifies for you:</p>

<pre><code>char * a_mutable = /*...*/;
const char * a_constant = /*...*/;

char **pointer_to_mutable = &amp;a_mutable;   /* ok */

const char **pointer_to_constant = &amp;a_constant;   /* ok */

pointer_to_constant = pointer_to_mutable;   /* oops, are you sure? */

*pointer_to_constant = a_mutable;   /* valid, but will screw things around */
</code></pre>

<p>The last line is valid, since <code>pointer_to_constant</code> is a mutable pointer to a mutable pointer to a constant character, but it would break things since you are making <code>a_constant</code> point to <code>a_mutable</code>. That is why you are not allowed to make <code>pointer_to_constant</code> receive the contents of <code>pointer_to_mutable</code>.</p>
",0
763778,763763,11,"<p>If you use a conventional initialiser list, the values for the elements are assigned in order, so if you have this struct:</p>

<pre><code>typedef struct _foo {
  int a;
  int b;
} foo_t;
</code></pre>

<p>then this initialiser explicitly assigns <code>a</code> and not <code>b</code>:</p>

<pre><code>foo_t value = { 7 };
</code></pre>

<p>without designated initialisers, the only elements which can be omitted are the ones declared at the end</p>

<p>using designated initialisers, you can omit elements that are declared anywhere:</p>

<pre><code>foo_t value = { .b = 8 };
</code></pre>

<p>so the initialiser for <code>value.a</code> is omitted, despite being the first value in the struct.</p>
",0
763767,763763,1,"<p>Try this <a href=""http://publib.boulder.ibm.com/infocenter/comphelp/v8v101/index.jsp?topic=/com.ibm.xlcpp8a.doc/language/ref/designators.htm"" rel=""nofollow noreferrer"">link</a>. </p>

<p>The idea is to be able to refer to members of a complex type like structure during initialization. E.g.</p>

<pre><code>struct s {
   int a, b;
};

int main() {
  struct s = { .b = 42, .a = -42 };
  return 0;
}
</code></pre>

<p>The flexibility is gained from being order independent when specifying values. Remember this was added to the C99 standard and may not be supported by compilers which do not support C99 fully (or support an earlier version of the standard).</p>
",0
755644,755639,7,"<p>It means only low value bits will be count and high order bits will be discarded.</p>

<p>For example:</p>

<pre><code>01111111 11111111 11110000 00001111
</code></pre>

<p>when converted to a 16 bit <code>unsigned short</code> will be: </p>

<pre><code>11110000 00001111
</code></pre>

<p>This is effectively mathematically expressed in:</p>

<pre><code>target_value = value % (target_type_max+1)           ( % = modulus operator )
</code></pre>
",0
755676,755639,6,"<blockquote>
  <p>any integer is converted to a given unsigned type by finding the smallest non negative value that is congruent to that integer,modulo one more than the largest value that can be represented in the unsigned type.</p>
</blockquote>

<p>Let's take this bit by bit and from backwards:</p>

<blockquote>
  <p>What is the largest value that can be represented in the unsigned type of width n bits? </p>
</blockquote>

<pre><code>2^(n) - 1.
</code></pre>

<blockquote>
  <p>What is one more than this value? </p>
</blockquote>

<pre><code>2^n. 
</code></pre>

<blockquote>
  <p>How does the conversion take place?</p>
</blockquote>

<pre><code>unsigned_val = signed_val % 2^n
</code></pre>

<p>Now, the why part: The standard does not mandate what bit representation is used. Hence the jargon. In a two's complement representation -- which is by far the most commonly used -- this conversion does not change the bit pattern (unless there is a a truncation, of course).</p>

<p>Refer to Integral Conversions from the Standard for further details.</p>
",0
616941,616906,2,"<p>The standard function pointer expected by <code>qsort()</code> or <code>bsearch()</code> has the prototype:</p>

<pre><code>int comparator(const void *v1, const void *v2);
</code></pre>

<p>The <code>qsort1()</code> defined in the code expects:</p>

<pre><code>int comparator(void *v1, void *v2);
</code></pre>

<p>The comparator functions defined in the code do not have that prototype, and there is no automatic conversion between different function pointer types.</p>

<p>So, fixes for <code>qsort1()</code> are either:</p>

<ol>
<li>Introduce a cast: <code>(int (*)(void *, void *))</code>, or</li>
<li><p>Rewrite the comparators:</p>

<pre><code>int numcmp(void *v1, void *v2)
{
    char *s1 = v1;
    char *s2 = v2;
    ...
}

int str_cmp(void *v1, void *v2)  // Note new function name!
{
    return(strcmp(v1, v2));
}
</code></pre></li>
</ol>

<p>Obviously, the call to <code>qsort1()</code> would reference <code>str_cmp</code> instead of <code>strcmp</code>. The authors sought to avoid an intermediate function, but run foul of the (legitimately) fussier compilers in use nowadays.</p>

<p>The standard version of <code>qsort()</code> would require a bunch of <code>const</code> qualifiers, as in the first version of this answer.</p>
",2
616944,616906,2,"<p>That's a common problem :)</p>

<p>The following line tells <code>qsort</code> to expect a pointer to a function with two void* parameters. Unfortunately, <code>strcmp</code> takes two non-modifiable strings hence it's signature is</p>

<pre><code>int (*comp)(const char*, const char*)
</code></pre>

<p>instead of what you have:</p>

<pre><code>int (*comp)(void *, void *)
</code></pre>

<p>Change the signature of both <code>qsort1</code> and <code>numeric</code>:</p>

<pre><code>qsort1(void *v[], int left, int right, int (*comp)(const void *, const void *))
</code></pre>

<p>and:</p>

<pre><code>int numcmp(const char*, const char*)
</code></pre>
",2
616946,616906,8,"<p>I think the error comes from the fact that old C did not know const yet: strcmp there took two pointers to non-const characters (<code>char *</code>) i think (which could be the reason why it compiled back then, but not with your compiler). However, nowadays strcmp takes <code>char const*</code> (<code>const char*</code> is the same thing). Change your function prototype to this:</p>

<pre><code>int numcmp(char const*, char const*);
</code></pre>
",2
616954,616906,1,"<p>Note that <code>strcmp</code> takes two <strong>const</strong> arguments, whereas your <code>numcmp</code> does not.  Therefore, the two functions' types do not match, and the <code>? :</code> operator will complain.</p>

<p>Do one of:</p>

<ol>
<li>change <code>numcmp</code> to match the <code>strcmp</code> prototype in terms of constness</li>
<li><p>push the <code>(int (*)(void*, void*))</code> cast inside the <code>? :</code>, e.g.</p>

<pre><code>numeric ? (int (*)(void*, void*))numcmp : (int (*)(void*, void*))strcmp
</code></pre></li>
</ol>
",0
616929,616906,0,"<p>Its been awhile since I have done any pure C programming, I'm not certain on the new standard.  </p>

<p>However casting to void ** creates a pointer to a pointer where the function requires a pointer to an array.  Sure, they are the same thing internally, but strong typechecking will catch that as an error.</p>

<p>rewrite the qsort to accept ** instead of *[] and you should be ok.</p>
",1
1323958,1323946,15,"<p>Are you asking about pointers in general? </p>

<p>On most operating systems, they are logical addresses.</p>

<p>The operating system is responsible for translating them into physical addresses through the virtual memory and paging mechanism. This is transparent to the program. That's why a misguided program ""hits the boundaries"" and GPFs.</p>

<p>On some old systems (e.g., DOS), they would be physical, allowing you to overwrite stuff in other parts of memory. </p>
",0
1323959,1323946,9,"<p>Depends on the OS and at what level your code is running.</p>

<p>For a normal user-land program on a modern OS, you will get the virtual address.</p>
",6
505395,505391,4,"<p>No.  5 is the number of integers you have to read into the list.</p>
",0
505398,505391,3,"<p>Jeebus, I'm not doing your homework for you, but...</p>

<p>Have you stopped to scratch this out on paper and work out how it should work?  Write some pseudo-code and then transcribe to real code.  I'd have thought:</p>

<ul>
<li>Read integer</li>
<li>Loop that many times
** Read more integers
** Add
** Find Smallest</li>
</ul>

<p>IF you're in C look at INT_MAX - that will help out finding the smallest integer.</p>
",0
505400,505391,11,"<p>Read: </p>

<blockquote>
  <p>Assume that the first integer read
  with scanf specifies the number of
  values remaining to be entered</p>
</blockquote>

<p>so it's not part of the sequence...</p>

<p>for the rest, it's your homework (and C...)</p>
",0
505401,505391,1,"<p>Since the list of integers is variable, I'd be tempted to use strtok to split the string up into individual strings (separate by space) and then atoi to convert each number and sum or find minimum on the fly.</p>

<p>-Adam</p>
",3
505491,505391,1,"<p>First you read the number of values (ie. 5), then create an array of int of 5 elements, read the rest of the input, split them and put them in the array (after converting them to integers).</p>

<p>Then do a loop on the array to get the sum of to find the smallest value.</p>

<p>Hope that helps</p>
",1
1889983,1889617,1,"<pre><code>(poll_fds[idx].revents &amp; ~POLLIN)
</code></pre>

<p>What the heck?  That returns true if any non-POLLIN bits are set.  Probably you want one of</p>

<pre><code>!(poll_fds[idx].revents &amp; POLLIN)
(~poll_fds[idx].revents &amp; POLLIN)
</code></pre>
",2
1531104,1493352,0,"<p>I think this has to do where a developer is in his career lifecycle. What I've seen from my self and other developers I talked to there are several distinct phases to developers lifecycle:</p>

<ol>
<li>I will everything my self, since this is the only way I will do it right</li>
<li>I will use done components if applicable, if not I will will write it my self</li>
<li>I will use done components if applicable, If not I will not do it since is a bother to write something from scratch</li>
</ol>
",0
1493399,1493352,0,"<p>I agree that looking for a solid proven solution first is a good approach, but some problems are trivial to solve with whats readily available in your language.</p>

<p><a href=""http://www.cplusplus.com/reference/clibrary/cstdio/sscanf/"" rel=""nofollow noreferrer"">sscanf</a> works nicely for parsing ini files in C.</p>
",1
1493451,1493352,1,"<p>I totally agree with your approach, with 1 difference:
2.5 - using the same criteria as in 2, try to find a commercial product that solves my problem.  Same criteria because a number of costly mistakes taught me that a huge price sticker in itself doesn't say a thing about the quality of the code.</p>
",0
1493468,1493352,-1,"<p>I'd rather use ready INI parser (for C - e.g. <a href=""http://ndevilla.free.fr/iniparser/"" rel=""nofollow noreferrer"">this one</a>, it's pretty small), than do it by hand, using <code>sscanf</code> or alike (it's good for simple <code>key=value</code> maybe, but INI files can be more complex than that).</p>

<p>About when to use third-party code - whenever possible. Stability is important, but that's exactly why you should try to find already-tested code, than to write same thing from scratch - e.g. you may hit some obscure edge case, which somebody else has already taken care of (and you won't lose time correcting bugs in utility code, instead of focusing on main program). </p>

<p>Learning the API of new library takes time, but so does writing code that does exactly the same thing. Reinventing is good for learning IMHO, but I always try to reuse as much code as possible when writing anything that should work as soon as possible (unless it's impossible; e.g. platform limitations).</p>
",0
1493481,1493352,9,"<p>I use third party code when I think the cost of using it is less than the cost of developing the code myself. Note that I'm not talking about just monetary cost, but overall cost in time, effort, money, limitations, etc.</p>
",0
1493518,1493352,0,"<p>It really depends, I put the situation into a scale. If writing it by myself will take less than 10mins and there is not much space for improvement I never lookup for some other solution. However, if the task is long I check availability of reliable libraries which does the job, and nothing else. Also, if this system will needed to be integrated to other systems I try to write by myself. I hate running into compatibility problems. </p>

<p>Sometimes there are really good solutions to some problems. They cannot be skipped. Most of the time I prefer solutions that stays by themselves which are isolated and does not require any additional dependencies. I try to prefer libraries which are both unit and field tested. I always try to avoid adding frameworks or libraries that add too much complexity to do a task. For instance I didn't used boost libraries for ""any"" implementation. That requires many files, boost headers to be in include path and there might be more dependencies.</p>

<p>I also agree that sometimes it takes more to learn than to write. In that case I prefer writing. Sometimes re-inventing wheel is not that bad if it will fit your systems better.</p>

<p>Sometimes I write a library by myself for the gain of knowledge. For instance I wrote an <a href=""http://sourceforge.net/projects/ckxml"" rel=""nofollow noreferrer"">XML parser</a> to be used within my graduation project. It was good learning.</p>
",0
1493608,1493352,4,"<p>It sounds like your colleague is suffering from <a href=""http://en.wikipedia.org/wiki/Not_Invented_Here#In_computing"" rel=""nofollow noreferrer"">Not-Invented-Here Syndrome</a>, which has generally been discredited. (On the other hand, <a href=""http://www.joelonsoftware.com/articles/fog0000000007.html"" rel=""nofollow noreferrer"">Joel has an interesting piece that takes the other side</a>.)</p>

<p>Developers often don't remember that they work for a business. Keys to business are value, cost, and risk. Certainly learning a complex API is a cost, as is dealing with bugs, but I see reinventing the wheel as a cost too. Either choice has associated risks. </p>

<p>As I see it, except for fairly trivial cases, it is a technical manager's job to decide from a business standpoint whether the cost and risk of finding and using a third-party component outweighs the cost and risk of writing the functionality in-house.</p>

<p>My own take is that I'll go third-party when the functionality has either been widely field-tested or when it's beyond the schedule and budget of my project. Reinventing the wheel is a cost that hurts my company's competitiveness. </p>
",1
1493527,1493352,3,"<p>In addition to the time and stability issues already discussed, if you're developing a commercial product, you have to be very careful about the license of the third party's code. Except for public domain code or stuff under a BSD-like license, you may find it's actually more productive to roll out your own code than opening up that can of worms.</p>
",0
1493677,1493352,0,"<p>My rule of thumb is that I like to fully understand as much of the code as possible.  A coworker that fully understands it is just as good.</p>

<p>If the library is simple enough to read and understand, then I'll use it.  If it's more complicated, the only reason I use it is if it's a very complex and commoditized problem.  </p>

<p>For example, I would use a third-party library for an html layout engine, regular expression engine, matrix solver, SQL server, etc.  I would only use a third-party library for parsing ini files if I could read it and understand it fully.</p>
",0
854060,854027,3,"<p>if you remove != 0.0 your program does dirty read until it reads a zero'ed memory block.</p>

<p>you have two choices:</p>

<ul>
<li>specify how many arguments you are passing i.e. avg(3, 4.3, 2.0, 3.0); </li>
<li>specify a terminator or sentinel i.e. avg(4.3, 2.0, 3.0, 0.0);</li>
</ul>

<p><strong>EDIT</strong></p>

<p>for the sake of curiosity I tried to alleviate the need of an esplicit terminator using
variadic macros:</p>

<pre><code>#define avg(v1, v2, ...) _avg((v1), (v2), __VA_ARGS__, 0.0)

double _avg(double v1,double v2,...) 
{ 
    /* same code, just prefixing function name with _ */
</code></pre>

<p>beware:</p>

<pre><code>avg(3.0, 3.0, 0.0, 100.0, 100.0) 
</code></pre>

<p>yields 3.0, since you are terminating the va_list prematurely. You can try use another ""weird"" sentinel value...</p>
",2
854063,854027,1,"<p>Ultimately this has to do with how arguments are passed to functions. On the stack the arguments are just all loaded up in order, but the function has no way of knowing when it's done reading arguments. There's still data on the stack, though.</p>

<p>That's what the test for != 0.0 does, it uses a sentinel value (0) to identify the end of the series. Another way to do this is to pass the number of items in as the first parameter to the function, and then use a for loop to loop over the variable args.</p>
",0
854064,854027,6,"<p>Because without any other external information, the function has no idea how many arguments were passed in.  There are several strategies to solve this problem: include an explicit argument which is the number of extra arguments, use a format string to define the arguments (such as with the <code>printf</code> and <code>scanf</code> family of functions), or use a sentinel value such as 0 to declare the end of the arguments.</p>

<p>In your case, if you omit the sentinel, the function just keeps walking down the stack until it hits a zero value, and depending on what data is on the stack, you could get wildly different results, all incorrect.</p>
",0
854072,854027,1,"<p>You need to have a guard value (0.0) and check for it, because the compiler does not necessarily count or delimit parameters when it constructs a stack frame.  Therefore you can continue reading (or writing) beyond the list of parameters and into data that holds your return pointer, your local variables, or just about anything else.  If you look at your compiler's implementation of va_arg, you will probably find that all it is doing is initializing a pointer just beyond the address of the your variable (v2) and then incrementing it by the size you specify (double).  It will happily do this until you get a read violation.</p>
",0
854449,854027,0,"<p>As everyone has mentioned your code relies on a sentinel value to know when it has reached the end of the list.  I personally think it is inappropriate to use a sentinel for a function such as avg().  I would change the function to explicitly state the number of arguments as the first argument (as dfa has suggested).</p>

<p>It's only OK to use a sentinel value if your domain has a value that is appropriate to use.  For example if you are dealing with only positive numbers, then you could use any negative number as the sentinel.  However, it makes more sense for avg() to accept the entire domain of floats.</p>
",0
1340165,1340147,0,"<p>You need to create a shared library, the standard library is a shared library that is implicitly linked in your program.</p>

<p>Once you have your shared library you can use the .h files and just compile the program with -lyourlib wich is implicit for the libc</p>

<p>Create one using:</p>

<pre><code>gcc -shared test.c -o libtest.so
</code></pre>

<p>And then compile your program like:</p>

<pre><code>gcc myprogram.c -ltest -o myprogram
</code></pre>

<p>For your second question I advise you to use Makefiles
<a href=""http://www.gnu.org/software/make/"" rel=""nofollow noreferrer"">http://www.gnu.org/software/make/</a></p>
",0
1340182,1340147,0,"<p>If you really want it to be as simple as just including a .h file, all of your ""library"" code needs to be in the .h file. However, in this scenario, someone can only include your .h file into one and only one .c file. That may be ok, depending on how someone will use your ""library"".</p>
",0
1340185,1340147,0,"<p>You can combine several .c files to a library. Those libraries can be linked with other .c files to become the executable.</p>

<p>You can use a makefile to create a big project. </p>

<p>The makefile has a set of rules. Each rule describes the steps needed to create one piece of the program and their dependencies with other pieces or source files.</p>
",0
1340204,1340147,0,"<p>The standard library is already compliled and placed on your machine ready to get dynamically linked. This means that the library is dynamically loaded when needed by a program. Compare this to a static library which gets compiled INTO your program when you run the compiler/linker.</p>

<p>This is why you need to compile your code and not the standard library code. You could build a dynamic (shared) library yourself.</p>

<p>For reference, <code>#include &lt;stdio.h&gt;</code> does not <strong>IMPORT</strong> the standard library. It just allows the compile and link to see the public interface of the library (To know what functions are used, what parameters they take, what types are defined, what sizes they are, etc). </p>

<p><a href=""http://en.wikipedia.org/wiki/Dynamic_loading"" rel=""nofollow noreferrer"">Dynamic Loading</a></p>

<p><a href=""http://en.wikipedia.org/wiki/Static_Library"" rel=""nofollow noreferrer"">Shared Library</a></p>

<p>You could split your files up into modules, and create shared libraries. But generally as projects get bigger you tend to need a better mechanism to build your program (and libraries). Rather than directly calling the compiler when you need to do a rebuild you should use a <a href=""http://en.wikipedia.org/wiki/Make_%28software%29"" rel=""nofollow noreferrer"">make</a> program or a complete build system like the <a href=""http://en.wikipedia.org/wiki/GNU_build_system"" rel=""nofollow noreferrer"">GNU Build System</a>.</p>
",0
1340233,1340147,14,"<p>First, you're a bit confused as to what happens with an #include. You never ""compile"" the standard library. The standard library is already compiled and is sitting in library files (.dll and .lib files on Windows, .a and .so on Linux). What the #include does is give you the <em>declarations</em> needed to <em>link</em> to the standard library. </p>

<p>The first thing to understand about #include directives is that they are very low-level. If you have programmed in Java or Python, #includes are much different from imports. Imports tell the compiler at a high level ""this source file requires the use of this package"" and the compiler figures out how to resolve that dependency. An #include in C directive says ""take the entire contents of this file and literally paste it in right here when compiling."" In particular, <code>#include &lt;stdio.h&gt;</code> brings in a file that has the forward declarations for all of the I/O functions in the standard library. Then, when you compile your code, the compiler knows how to make calls to those functions and check them for type-correctness.</p>

<p>Once your program is compiled, it is <em>linked</em> to the standard library. This means that your linker (which is automatically invoked by your compiler) will either cause your executable to make use of the shared standard library (.dll or .so), or will copy the needed parts of the static standard library (.lib or .a) into your executable. In neither case does your executable  ""contain"" any part of the standard library that you do not use.</p>

<p>As for creating a library, that is a bit of a complicated topic and I will leave that to others, particularly since I don't think that's what you really want to do based on the next part of your question.</p>

<p>A header file is not always part of a library. It seems that what you have is multiple source files, and you want to be able to use functions from one source file in another source file. You can do that without creating a library. All you need to do is put the <em>declarations</em> for things foo.c that you want accessible from elsewhere into foo.h. Declarations are things like function prototypes and ""extern"" variable declarations. For example, if foo.c contains</p>

<pre><code>int some_global;

void some_function(int a, char b)
 {
     /* Do some computation */
 }
</code></pre>

<p>Then in order to make these accessible from other source files, foo.h needs to contain</p>

<pre><code>extern int some_global;

void some_function(int, char);
</code></pre>

<p>Then, you <code>#include ""foo.h""</code> wherever you want to use some_global or some_function. Since headers can include other headers, it is usual to wrap headers in ""include guards"" so that  declarations are not duplicated. For example, foo.h should really read:</p>

<pre><code>#ifndef FOO_H
#define FOO_H

extern int some_global;

void some_function(int, char);

#endif
</code></pre>

<p>This means that the header will only be processed once per compilation unit (source file).</p>

<p>As for how to compile them, never put .h files on the compiler command line, since they should not contain any compile-able code (only declarations). In most cases it is perfectly fine to compile as</p>

<pre><code>cc main.c 1.c 2.c 3.c ... [etc]
</code></pre>

<p>However if you have 50 source files, it is probably a lot more convenient if you use a build system. On Linux, this is a Makefile. On windows, it depends what development environment you are using.  You can google for that, or ask another SO question once you specify your platform (as this question is pretty broad already).</p>

<p>One of the advantages of a build system is that they compile each source file independently, and then link them all together, so that when you change only one source file, only that file needs to be re-compiled (and the program re-linked) rather than having everything re-compiled including the stuff that didn't get changed. This makes a big time difference when your program gets large.</p>
",1
1313463,1313425,6,"<p>1) <code>char</code> is the size of a single byte in C, and is therefore used for storing any sort of data. For example, when loading an image into memory, the data is represented as an array of <code>char</code>. In modern code, typedefs such as <code>uint8_t</code> are used to indicate the purpose of a buffer more usefully than just <code>char</code>.</p>

<p>2 &amp; 3) Whether or not <code>char</code> is signed or unsigned is platform dependent, so if a program depends on this behavior then it's best to specify one or the other explicitly.</p>
",1
1313467,1313425,3,"<ol>
<li><p>The <code>char</code> type is defined to hold one byte, i.e. <code>sizeof(char)</code> is defined to be <code>1</code>.  This is useful for serializing data, for instance.</p></li>
<li><p><code>char</code> is implementation-defined as either <code>unsigned char</code> or <code>signed char</code>.  Now imagine that <code>char</code> means <code>smallint</code>.  You are simply converting a small integer to a larger integer when you go from <code>smallint</code> to <code>int</code>.  The problem is, you don't know whether that <code>smallint</code> is signed or unsigned.</p></li>
<li><p>I would say it's not really a portability issue as long as you follow The Bible (K&amp;R).</p></li>
</ol>
",0
1313483,1313425,1,"<p><code>unsigned char</code> is often used to process binary data one byte at a time.  A common example is UTF-8 strings, which are not strictly made up of ""chars.""</p>

<p>If a signed char is 8 bits and the top bit is set, that indicates that it's negative.  When this is converted to a larger type, the sign is kept by extending the high bit to the high bit of the new type.  This is called a ""sign-extended"" assignment.</p>
",0
1313504,1313425,1,"<p>1) Char is implemented as one byte across all systems so it is consistent.</p>

<p>2) The bit mentioned in you question is the one that is used in single byte integers for their singed-ness. When a int on a system is larger than one byte the signed flat is not affected when you convert char to int, other wise it is. ( there are also singed and unsigned chars) </p>

<p>3) Because of the consistence of the char implementation lots of libs use them like the Intel IPP (Intel Performance Primitives) libs and their cousins OpenCV.</p>
",0
1313515,1313425,1,"<p>Usually, in C, char to int conversion and vice versa is an issue because the stanard APIs for reading character input/writing character output use <code>int's</code> for the character arguments and return values.  See <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/getchar/"" rel=""nofollow noreferrer""><code>getchar()</code></a>, <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/getc/"" rel=""nofollow noreferrer""><code>getc()</code></a> and <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/putchar/"" rel=""nofollow noreferrer""><code>putchar()</code></a> for example. </p>

<p>Also, since the size of a char is 1 byte, it is a convenient way to deal with arbitrary data as a byte stream.</p>
",0
1313547,1313425,6,"<p>In regards to 1)</p>

<p>People often use char arrays when they really want a byte buffer for a data stream. Its not great practice, but plenty of projects do it, and if you're careful, no real harm is done. There are probably other times as well.</p>

<p>In regards to 2)</p>

<p>Signed integers are often sign extended when they are moved from a smaller data type. Thus
11111111b (-1 in base 10) becomes 11111111 11111111 11111111 11111111 when expanded to 32 bits. However, if the char was intended to be unsigned +255, then the signed integer may end up being -1.</p>

<p>About portability 3)</p>

<p>Some machines regard chars as signed integers, while others interpret them as unsigned. It could also vary based on compiler implementation. Most of the time you don't have to worry about it. Kernighan is just trying to help you understand the details.</p>

<hr>

<h2>Edit</h2>

<p>I know this is a dead issue, but you can use the following code to check if char's on your system are signed or unsigned:</p>

<pre><code>#include &lt;limits.h&gt; //Include implementation specific constants (MAX_INT, et c.)
#if CHAR_MAX == SCHAR_MAX 
// Plain ""char"" is signed
#else
// Plain ""char"" is unsigned
#endif
</code></pre>
",0
1128847,1128833,1,"<p>I believe that the size of the first element of your struct is always going to be equal to <code>sizeof(char)</code> and the size of the second element of your struct will be <code>sizeof(char[255])</code>. Any padding that the compiler decides to insert is up to the compiler, and that memory doesn't belong to you. In other words, that memory is off limits to your application, and any attempt to use it may result in undefined behavior. That said, you can still always find (and will often need) the total size of the structure using <code>sizeof(struct a)</code>. So the size of the fields are just what you would expect them to be, and the padding doesn't count toward the individual fields, even if it does increase the overall size of the struct.</p>
",0
1128850,1128833,4,"<p>How about:</p>

<pre><code>int lenS = sizeof(a) - offsetof(a, s);
</code></pre>
",1
1128893,1128833,3,"<p>Padding isn't part of a particular field, it's part of the struct itself. If I have a struct like</p>

<pre><code>struct foo {
   T1 v1;
         // &lt;--- some padding here (A)
   T2 v2;
         // &lt;--- some padding here (B)
   T3 v3;
};
</code></pre>

<p>Is the <em>A</em> padding part of v1? v2?. Is <em>B</em> part of v2? v3? If you are concerned about padding messing with doing things like persisting a struct to a file or similar, most (all?) compilers have a mechanism to disable structure padding, even on a struct by struct basis. To find out the size of the last member of your struct, in this case <code>s</code>, use <code>sizeof</code>, e.g.</p>

<pre><code> struct a tmp;
 size_t size = sizeof(tmp.s);
</code></pre>

<p>If you don't want to create a temporary you can take advantage of the fact that sizeof happens at compile time and doesn't do anything at runtime and do something like:</p>

<pre><code> namespace {
   const a&amp; dummy_func();
 }
 size_t size = sizeof(dummy_func().s);
</code></pre>

<p>Dummy func doesn't need to be implemented ever.</p>

<p>Another option is</p>

<pre><code>struct a {
   ...
   typedef char s_type[255];
   s_type s;
};
size_t size = sizeof(a::s_type);
</code></pre>
",0
1690647,1690630,3,"<p>You can do it by walking through the array, while keeping a tally.</p>

<p>The tally starts at 0, and every time you reach the number you want to track, add one to it. When you're done, the tally contains the number of times the number appeared.</p>

<p>Your function definition would probably look something like this:</p>

<pre><code>int count_elements(int pElement, int pArray[], size_t pSize);
</code></pre>
",1
1690657,1690630,0,"<p>If you have a plain C-array, you have to iterate over all elements in a loop and count yourself with a variable.</p>
",0
1690659,1690630,0,"<pre><code>int arr[20];
int twelves = 0;
int i;

/* fill here your array */


/* I assume your array is fully filled, otherwise change the sizeof to the real length */
for(i = 0; i &lt; sizeof(arr)/sizeof(int);++i) {
  if(arr[i] == 12) ++twelves;
}
</code></pre>

<p>After this, the variable twelves will contain the number of twelves in the array.</p>
",2
1690660,1690630,2,"<p>Simply create a counter variable, and examine each element in the array in a loop, incrementing the counter variable every time an element is equal to 12.</p>
",0
1402717,1402673,2,"<p>Move file writing into a procedure:</p>

<pre><code>void write_lines (FILE *fp) {
    fprintf (file, ""%s\n"", ""Line 1"");
    fprintf (file, ""%s %d\n"", ""Line"", 2);
    fprintf (file, ""Multiple\nlines\n%s"", ""in one call\n"");
}

int main () {
    FILE *file = fopen (""zach.txt"", ""a+"");
    assert (file != NULL); // Basic error checking
    write_lines (file);
    fclose (file);
    printf (""File has been written. Please review. \n"");
    return 0;
}
</code></pre>
",6
1402895,1402673,1,"<p>There are lots of ways to do this, here's one:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int appendToFile(char *text, char *fileName) {

    FILE *file;

    //no need to continue if the file can't be opened.
    if( ! (file = fopen(fileName, ""a+""))) return 0;

    fprintf(file, ""%s"", text);
    fclose(file);

    //returning 1 rather than 0 makes the if statement in
    //main make more sense.
    return 1;

}

int main() {

    char someText[256];

    //could use snprintf for formatted output, but we don't
    //really need that here. Note that strncpy is used first
    //and strncat used for the rest of the lines. This part
    //could just be one big string constant or it could be
    //abstracted to yet another function if you wanted.
    strncpy(someText, ""Here is some text!\n"", 256);
    strncat(someText, ""It is on multiple lines.\n"", 256);
    strncat(someText, ""Hooray!\n"", 256);

    if(appendToFile(someText, ""zach.txt"")) {
        printf(""Text file ./zach.txt has been written to."");
    } else {
        printf(""Could not write to ./zach.txt."");
    }

    return 0;

}
</code></pre>

<p>notice the <code>strncpy</code> and <code>strncat</code> functions since you aren't really utilizing the formatted input that comes with the <code>xprintf</code> functions.</p>
",0
1412907,1412898,0,"<p>Sure, but how would you get the user to run that script? Wouldn't it be simpler to have the user simply re-run the program?</p>
",1
1412912,1412898,3,"<p>Why not use loop (for, while) in the main itself: ( if the program is simple!)</p>

<pre><code>main()
{

 while( Exit condition)
 {
  //logic
 }
}
</code></pre>
",0
1412916,1412898,2,"<pre><code>char cont_prog = 'n';
do {
    /* main program in here */
    printf(""Do you want to start again? (y/n): "");
    cont_prog = getchar();
} while (cont_prog == 'y' || cont_prog == 'Y');
</code></pre>

<p>Essentially, you want to put you main prog in a loop, asking the user if they want to continue. You have to deal with the user entering in too much data (they type, 'yes', for example) and your buffer being full next time through the loop.</p>
",3
1412945,1412898,1,"<p>If you really want to re-launch the program without exiting (though I can't see why):</p>

<ol>
<li>Save <code>argv</code> (and I'll assume that <code>argv[0]</code> actually points to your executable, even though that is not guaranteed) if you want the same command line arguments.</li>
<li>Consider saving the environment, if you might change it, and also want it to be repeated.</li>
<li><code>man execv</code> or <code>execle</code>. Just replace the currently running image with a new one that has the same command line</li>
</ol>

<p>Frankly, looping would be easier, and can have the same semantics if you avoid global state, or arrange to be able to re-set it.</p>
",0
1413033,1412898,0,"<pre><code>#include &lt;stdlib.h&gt;
#ifdef WIN32
#define EXECUTABLE "".exe""
#else
#define EXECUTABLE
#endif
int main(void) {
    for (;;) system(""executable_in_c"" EXECUTABLE);
    return 0;
}
</code></pre>

<p>Compile this program, rename your old executable to ""executable_in_c[.exe]""; rename this one to the name of your old executable ... voila!</p>
",0
1059771,1059756,3,"<p>In order for malloc to work in your fill_in_x() function, you need to pass the pointer into the function, not the reference to the pointer. With respect to your question between pass by reference and pass by value, pass by value involves the function making a local copy of the variable, while pass by reference is a more specific type of passing by pointer, better explained through <a href=""http://www.tech-recipes.com/rx/1232/c-pointers-pass-by-value-pass-by-reference/"" rel=""nofollow noreferrer"">here</a>. Ignore that it's for C++ as it works the same way for C with respect to your question.</p>
",1
1059783,1059756,2,"<p>Most likely you are doing something in fill_in_x that isn't correct. Since the definition isn't in the post, I can't say what, but it should be something like:</p>

<pre><code>void fill_in_x(float** array) {
      *array = (float*) malloc(10*sizeof(float));
}
</code></pre>

<p>(though it is bad form to return allocated memory, because it often leads to a memory leaks, like the one in your code.)</p>

<hr>

<p><strong>(responding to fill_in_x)</strong>: Compiling and running this code on visual studio produces the expected output.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void fill_in_x(float** x, int num_vals)
{
    *x = (float*)malloc(num_vals * sizeof(float));

    for(int i = 0; i &lt; num_vals; ++i)
        (*x)[i] = (i*2)+3;
}

void function_using_a_and_b(float a, float b)
{
    printf(""%f\n"", a);
    printf(""%f\n"", b);
}

int main()
{
    float* x;
    float a, b;
    int num_vals = 10;

    fill_in_x(&amp;x, num_vals); // malloc is called and x is populated with values

    a = x[0];
    b = x[1] - x[0];

    printf(""%f\n"", a);
    printf(""%f\n"", b);

    function_using_a_and_b(a, b); // The values of a and b used in this function 
                                  // don't match those calculated in main 
}
</code></pre>

<p>Writes:</p>

<pre><code>3.000000
2.000000
3.000000
2.000000
</code></pre>

<p>So I'm still not sure what you mean. I suspect the problematic code is still missing from the post.</p>
",3
1059787,1059756,0,"<p>if a function needs to modify the values of a given parameter it needs to be given an address. otherwise it will make new local copies of the values in a and b and modify those.</p>
",0
1059803,1059756,1,"<p>You could try debugging your function fill_X, and watching the f address in main and inside the function.</p>

<p>An alternative could be changing your fill_x function to</p>

<pre><code>float* fill_x(){

  float* f = malloc(...);

  //do stuff with f.

  return f;

}
</code></pre>

<p>Then you'd have to free that memory</p>

<pre><code> float *f = fill_x();

  //do stuff with f.
  free(f);
</code></pre>
",0
1059882,1059756,0,"<p>What you're doing looks correct, if a little bizarre.</p>

<p>The only bit that concerns me is that you haven't shown enough of the code for fill_in_x to allow us to see how/what you're filling in.</p>

<pre><code> // Fill in values for x
</code></pre>

<p>There's a possibility here that you're doing that wrong - easy, because you have two dereferences to think about (float **x).</p>

<p>Make sure you're doing:-</p>

<pre><code>(*x)[0] = 0;
(*x)[1] = 100;
... etc...
</code></pre>

<p>... rather than </p>

<pre><code>x[0] = 0; // compiles, but overwrites the pointer with NULL...
</code></pre>

<p>..or</p>

<pre><code>*(x[0]) = 0;
</code></pre>

<p>..or</p>

<pre><code>*x[0] = 0;
</code></pre>

<p>As for a and b changing when you call function_using_a_and_b - that's bizarre. You <em>are</em> correctly passing them by value. What compiler are you using here?</p>
",2
1059886,1059756,0,"<p>why not malloc x in main, so you wouldn't forget to free x later, thus creating a memory leak. I would suggest avoid using float**, it's just too confusing. </p>
",0
1059897,1059756,0,"<p>Heh, nice riddle. :-)</p>

<p>My guess is your function declaration looks like this:</p>

<pre><code>void fill_in_x(float* x);
</code></pre>

<p>when it <em>should</em> look like this:</p>

<pre><code>void fill_in_x(float** x);
</code></pre>

<p>Using your declaration, the function expects to get a float pointer, but you pass it the <em>address</em> of the float pointer x - Which is just somewhere on the stack, since this is where local variables are allocated. </p>

<p>This means that you are allocating space on own calling stack, with apparently horrifying results. :)</p>
",0
1059963,1059756,2,"<p>This seems to work as I'd expect:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void fill_in_x(float** x, int num_vals)
{
    float* res = (float*)malloc(num_vals * sizeof(float));
    *x = res;

    // Fill in values for x
    res[0] = 1.0;
    res[1] = 4.0;
}

void function_using_a_and_b(float a, float b)
{
    printf(""%f\n"", a);
    printf(""%f\n"", b);
}

int main()
{
    float* x;
    float a, b;
    int num_vals = 10;

    fill_in_x(&amp;x, num_vals); // malloc is called and x is populated with values

    a = x[0];
    b = x[1] - x[0];

    function_using_a_and_b(a, b); // The values of a and b used in this function 
                                  // don't match those calculated in main 
}
</code></pre>
",0
1060038,1059756,0,"<p>You are probably using</p>

<p><code>*x[0] = 3.0;</code></p>

<p>in <code>fill_in_x()</code>, when you actually need to use</p>

<p><code>(*x)[0];</code></p>

<p>edit: by the way, C doesn't have pass by reference, it's just a pedagogical feature. You just pass variables ADDRESSES by value, and then dereference that value to get to the original variable.</p>
",0
1060074,1059756,0,"<pre><code>void fill_in_x(float** x, int num_vals)
{
    *x = (float*)malloc(num_vals * sizeof(float));

    for (int i = 0; i &lt; num_vals; ++i) {
        (*x)[i] = (float)i;
    }
}
</code></pre>

<p>This also works. Makes me wonder what your fill_in_x() looks like. There's nothing wrong with the code as it is.</p>
",0
1062225,1059756,0,"<p>As originally written, there is no prototype for the <code>function_using_a_and_b()</code> in scope when it is called, so the compiler has to promote the <code>float</code> values to <code>double</code> before passing them.  The function is then written in prototype notataion so the compiler might not notice that the function was already called with doubles, even though the prototype notation allows it to be passed floats.  This would lead to weird values when printed.</p>

<p>I'm not convinced a compiler would not spot the problem - but it might account for what you are seeing.  Of course, if the functions are in separate source files, then the compiler has no chance to spot the mismatches.</p>
",0
1714010,1713931,0,"<p>Move the printf out side the loop. That will fix it. </p>
",0
1714109,1713931,0,"<p>Try the following:</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int a,b,count ;
    count =0;
    printf(""enter the value for a "");
    scanf(""%d"",&amp;a);
    while(a&gt;0)
    {
        b=a%10;
        count=b+count;
        a=a/10; 
    } 
    printf (""hence the simplified result is %d"",count);
    return 0;
}
</code></pre>
",1
1713946,1713931,1,"<p>I think the printf statement should be outside the loop.</p>
",0
1713947,1713931,2,"<p>One issue is you print the count with every loop, rather than than after the loop.</p>

<p>Not an issue, but C has arithmetic assignment (aka <a href=""http://publib.boulder.ibm.com/infocenter/iadthelp/v7r0/topic/com.ibm.etools.iseries.langref.doc/as400clr131.htm"" rel=""nofollow noreferrer"">compound assignment</a>) operators that can be more readable. For example, <code>a /= 10</code> is equivalent to <code>a = a/10</code>.</p>
",0
1713976,1713931,3,"<p>You do not terminate your <code>printf()</code> with a ""\n"". The output stream (stdout) is, usually, line buffered. That means that incomplete lines need not be printed unless you force them with <code>fflush()</code>. But there's no need for that.</p>

<p>Simply add a ""\n"" to your <code>printf()</code></p>

<pre><code>        printf(""hence the simplified result is %d\n"", count);
</code></pre>
",2
1714367,1713931,4,"<p>There's a <a href=""http://www.codinghorror.com/blog/archives/001310.html"" rel=""nofollow noreferrer"">silent killer</a> in your code:</p>

<pre><code>scanf(""%d "",&amp;a);
</code></pre>

<p>The extra space in your scanf will make entering numbers harder: this will match <code>12&lt;space&gt;</code>, but not <code>12</code>. Replace the <code>""%d ""</code> with <code>""%d""</code>.</p>
",5
1539206,1539190,1,"<p>As long as there's a single member, I think you're safe with the assumption.</p>
",0
1539217,1539190,6,"<p>It depends on the architecture and the compiler. For this particular case you should be safe, but check out <a href=""http://en.wikipedia.org/wiki/Data%5Fstructure%5Falignment#Data_Structure_Padding"" rel=""nofollow noreferrer"">Data Structure Padding</a>. </p>

<p>Here's an <a href=""http://en.wikipedia.org/wiki/Data%5Fstructure%5Falignment#Typical_alignment_of_C_structs_on_x86"" rel=""nofollow noreferrer"">excerpt</a>:</p>

<blockquote>
  <p><strong>Typical alignment of C structs on x86</strong></p>
  
  <p>Data structure members are stored
  sequentially in a memory so that in
  the structure below the member Data1
  will always precede Data2 and Data2
  will always precede Data3:</p>

<pre><code>struct MyData
{
    short Data1;
    short Data2;
    short Data3;
};
</code></pre>
  
  <p>If the type ""short"" is stored in two
  bytes of memory then each member of
  the data structure depicted above
  would be 2-byte aligned. Data1 would
  be at offset 0, Data2 at offset 2 and
  Data3 at offset 4. The size of this
  structure would be 6 bytes.</p>
  
  <p>The type of each member of the
  structure usually has a default
  alignment, meaning that it will,
  unless otherwise requested by the
  programmer, be aligned on a
  pre-determined boundary. The following
  typical alignments are valid for
  compilers from Microsoft, Borland, and
  GNU when compiling for 32-bit x86:</p>
  
  <ul>
  <li>A char (one byte) will be 1-byte    aligned. </li>
  <li>A short (two bytes) will be    2-byte aligned. </li>
  <li>An int (four bytes)    will be 4-byte aligned.</li>
  <li>A float (four    bytes) will be    4-byte aligned.</li>
  <li>A    double (eight bytes) will be    8-byte    aligned on Windows and 4-byte aligned    on Linux.</li>
  </ul>
  
  <p>Here is a structure with members of
  various types, totaling 8 bytes before
  compilation:</p>

<pre><code>struct MixedData
{
    char Data1;
    short Data2;
    int Data3;
    char Data4;
};
</code></pre>
  
  <p>After compilation the data structure
  will be supplemented with padding
  bytes to ensure a proper alignment for
  each of its members:</p>

<pre><code>struct MixedData  /* after compilation */
{
    char Data1;
    char Padding0[1]; /* For the following 'short' to be aligned on a 2 byte boundary */
    short Data2;
    int Data3;  
    char Data4;
    char Padding1[3];
};
</code></pre>
  
  <p>The compiled size of the structure is
  now 12 bytes. It is important to note
  that the last member is padded with
  the number of bytes required to
  conform to the largest type of the
  structure. In this case 3 bytes are
  added to the last member to pad the
  structure to the size of a long word.</p>
  
  <p>It is possible to change the alignment
  of structures to reduce the memory
  they require (or to conform to an
  existing format) by changing the
  compiler¡¯s alignment (or ¡°packing¡±) of
  structure members.</p>
  
  <p>Requesting that the MixedData
  structure above be aligned to a one
  byte boundary will have the compiler
  discard the pre-determined alignment
  of the members and no padding bytes
  would be inserted.</p>
  
  <p>While there is no standard way of
  defining the alignment of structure
  members, some compilers use #pragma
  directives to specify packing inside
  source files. Here is an example:</p>

<pre><code>#pragma pack(push)  /* push current alignment to stack */
#pragma pack(1)     /* set alignment to 1 byte boundary */

struct MyPackedData
{
    char Data1;
    long Data2;
    char Data3;
};

#pragma pack(pop)   /* restore original alignment from stack */
</code></pre>
  
  <p>This structure would have a compiled
  size of 6 bytes. The above directives
  are available in compilers from
  Microsoft, Borland, GNU and many
  others.</p>
</blockquote>
",2
1539219,1539190,0,"<p>All <code>a</code>s will have the same size, no matter if they stand alone or are inside a structure.</p>

<p>What may happen inside a structure is that there is padding between members ... but that may also happen in ""stand alone"" variables.</p>
",1
1539226,1539190,0,"<p>When you take the size of a struct, it includes the padding bytes. But, if you have something like the following:</p>

<pre><code>void fun()
{
    char c;
    int n;
}
</code></pre>

<p>The compiler is free to insert padding for whatever reason it sees. So, the padding could be there in case of standalone variables, you just can't know about that like in the case of a struct.</p>
",0
1539244,1539190,1,"<p>The case you list will be packed as a 1-byte structure under all ABIs I am aware of.</p>

<p>But if you need to portably handle more complicated cases, best practice is to always use <code>sizeof(struct OneChar)</code> when computing memory sizes, and taking the offset of the field address when you need to compute addresses via a trick like:</p>

<pre><code>(char*)&amp;(((struct OneChar*)0)-&gt;a) - (char*)0
</code></pre>
",1
1539276,1539190,0,"<p>Various compilers will optimize to add padding between or at the end of the struct.  So, it's not safe on all compilers or platforms to assume the allocated size is what it seems.  Check your compiler options for setting struct padding.</p>

<p>For instance, Visual Studio uses the <a href=""http://msdn.microsoft.com/en-us/library/2e70t5y1%28VS.80%29.aspx"" rel=""nofollow noreferrer""><code>#pragma pack</code></a> directive to override default optimizations.</p>
",0
1720908,1720887,3,"<p>You need to link with the curses library. The functions are defined there.</p>

<p>Try</p>

<pre><code>gcc ... test.c ... -lcurses ...
</code></pre>

<p>or maybe</p>

<pre><code>gcc ... test.c ... -lncurses ...
</code></pre>
",0
846892,846804,0,"<p>I think that the author may have been going for something like:</p>

<pre><code>if(condition for tbd block)
    ;
else {
    //Some code here
}
</code></pre>

<p>which you might do if you were scaffolding code and still wanted it to compile. There's a good chance that it's just an error as Jon suggests though.</p>
",0
846901,846804,0,"<p>These semicolons are useless as others have pointed out already. The only thing I want to add is that IMO, these are optimized out anyway i.e., compiler doesn't generate any real code for these.</p>
",0
846819,846804,34,"<p>They do nothing. They're a sign of someone who doesn't understand the language terribly well, I suspect.</p>

<p>If this is source code you notionally ""own"", I would remove the code and try to have a gentle chat with the person who wrote it.</p>
",1
846820,846804,7,"<p>that's dummy statememt. You sample is identical to</p>

<pre><code>if (x == NULL) {
 // some code
 do_something_here();
}

/* empty (dummy statement) here */ ;

// more code
some_other_code_here();
</code></pre>
",2
846822,846804,5,"<p>You are right, the compiler considers them empty statements. They are not needed, I guess the programmer somehow thought they were.</p>
",0
846824,846804,1,"<p>These semicolons are not needed (as you said, they are empty statements). Your code compiles with gcc, providing that 'x' is defined (check <a href=""http://www.codepad.org"" rel=""nofollow noreferrer"">http://www.codepad.org</a>). There's no reason why a C compiler would refuse to compile your code.</p>
",0
846840,846804,2,"<p>The first semicolon (after the if-statement) is just an empty expression which does nothing. I fail to see any point of having it there.</p>

<p>The second semicolon (after the function) is an error since it is outside of any block of code. The compiler should give a warning.</p>
",7
1274167,1271064,14,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;dirent.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;

int main(int argc, char** argv)
{
 struct dirent *dp;
 DIR *dfd;

 char *dir ;
 dir = argv[1] ;

 if ( argc == 1 )
 {
  printf(""Usage: %s dirname\n"",argv[0]);
  return 0;
 }

 if ((dfd = opendir(dir)) == NULL)
 {
  fprintf(stderr, ""Can't open %s\n"", dir);
  return 0;
 }

 char filename_qfd[100] ;
 char new_name_qfd[100] ;

 while ((dp = readdir(dfd)) != NULL)
 {
  struct stat stbuf ;
  sprintf( filename_qfd , ""%s/%s"",dir,dp-&gt;d_name) ;
  if( stat(filename_qfd,&stbuf ) == -1 )
  {
   printf(""Unable to stat file: %s\n"",filename_qfd) ;
   continue ;
  }

  if ( ( stbuf.st_mode & S_IFMT ) == S_IFDIR )
  {
   continue;
   // Skip directories
  }
  else
  {
   char* new_name = get_new_name( dp-&gt;d_name ) ;// returns the new string
                                                   // after removing reqd part
   sprintf(new_name_qfd,""%s/%s"",dir,new_name) ;
   rename( filename_qfd , new_name_qfd ) ;
  }
 }
}

</code></pre>

<p>Although I would personally prefer a script to do this job like</p>

<pre><code>
#!/bin/bash -f
dir=$1
for file in `ls $dir`
do
 if [ -f $dir/$file ];then
  new_name=`echo ""$file"" | sed s:to_change::g`
  mv $dir/$file $dir/$new_name
 fi
done

</code></pre>
",0
1274987,1271064,2,"<p>I know this answer will get me down-voted, but your problem is perfect for a shell script, (or .cmd script), a PHP script, or PERL script. Doing it in C is more work than the problem is worth.</p>
",0
1274942,1271064,1,"<p><code>fts</code> has a nice interface, but it's 4.4BSD and is not portable.  (I recently got bitten in the rear by some software with an inherent dependency on fts.)  <code>opendir</code> and <code>readdir</code> are less fun but are POSIX standards and are portable.</p>
",0
1331916,1331895,7,"<ol>
<li>A function pointer</li>
<li>An array of function pointers</li>
<li>An array of pointers to function pointers</li>
</ol>
",1
1331925,1331895,21,"<p>Well, the first one is a pointer to a function.  In other words, it declares a variable ""x"" which points to a function of the following type:</p>

<pre><code>int function(int, char*, void*);
</code></pre>

<p>And could be used as follows:</p>

<pre><code>int myfunc(int a, char* b, void* c) {
    return a;
}

void acallingfunction() {
    int (*x)(int, char*, void*);
    x = myfunc;
    x(1, ""hello"", 0);
}
</code></pre>

<p>The second appears to be invalid syntax, but I may be wrong.  If it had an asterisk before the x (such as int (*x[10])(int, char*, void*) ), it would be an array of function pointers, and would be used like a normal array:</p>

<pre><code>x[3](1, ""Hi there"", 0);
</code></pre>

<p>The third is an array of pointers to function pointers, which doesn't seem practical, but is perfectly valid.  An example usage might be:</p>

<pre><code>void anothercaller() {
    int (*x)(int, char*, void*);
    int (**y)(int, char*, void*);
    x = myfunc;
    y = &amp;x;
    (*y)(1, ""hello"", 0);
}
</code></pre>

<p>Note that of these, the first two are relatively common.  Pointers to functions are used to accomplish callbacks and various Object-Oriented programming concepts in C.  An array of pointers to functions might be used for an event table, to find the appropriate callback.</p>

<p>Note that all of those are, in fact, valid C++ as well. ;)</p>

<p>Edit: I committed the atrocities of void main() apparently.</p>

<p>Edit 2: As Chris Lutz points out below, they really should be wrapped in typedefs.  Typedefs make code containing pointers to functions MUCH clearer.</p>
",0
1331935,1331895,6,"<p>They are function pointers, as said above, but written rather obnoxiously (in my opinion). The way I would write them is:</p>

<pre><code>typedef int (*funcptr)(int, char *, void *);

funcptr x;
funcptr x[10];
funcptr *x;
</code></pre>

<p>See <a href=""https://stackoverflow.com/questions/1331895/a-few-c-questions/1331925#1331925"">Walt W's excellent answer</a> for more about function pointers.</p>
",0
1331939,1331895,31,"<p>You need the <a href=""ftp://ibiblio.org/pub/Linux/devel/lang/c/cdecl-2.5.tar.gz"" rel=""noreferrer""><code>cdecl</code></a> program, which will give you a definite, correct answer to such questions. Learning to interpret such statements manually is doable and beneficial, but even so cdecl is extremely useful for checking if you have an correct answer.</p>

<pre><code>prompt&gt;cdecl
Type `help' or `?' for help
cdecl&gt; explain int (*x)(int, char *, void *);
declare x as pointer to function (int, pointer to char, pointer to void) returning int
cdecl&gt; explain int (*x[10])(int, char *, void *);
declare x as array 10 of pointer to function (int, pointer to char, pointer to void) returning int
cdecl&gt; explain int (**x[10])(int, char *, void *);
declare x as array 10 of pointer to pointer to function (int, pointer to char, pointer to void) returning int
cdecl&gt;
</code></pre>
",1
1338753,1331895,3,"<p>Since the syntax of C is like the one of C++ in this matter, <a href=""http://www.xs4all.nl/~weegen/eelis/geordi/"" rel=""nofollow noreferrer"">geordi</a> could be interesting to you. It is another good tool for teaching and learning those declarations (and other things related to C++ and sometimes, C too). </p>

<pre><code>geordi: &lt;&lt; ETYPE_DESC(x); int (*x)(int, char *, void *);
lvalue pointer to a function taking an integer, a pointer to a character, a pointer to anything, and returning an integer

geordi: &lt;&lt; ETYPE_DESC(x); int (*x[10])(int, char *, void *);
lvalue array of 10 pointers to functions taking an integer, a pointer to a character, a pointer to anything, and returning integers

geordi: &lt;&lt; ETYPE_DESC(x); int (**x[10])(int, char *, void *);
lvalue array of 10 pointers to pointers to functions taking an integer, a pointer to a character, a pointer to anything, and returning integers
</code></pre>

<p>As its page explains, it can do much more, including building a type for you</p>

<pre><code>geordi: make type array of 10 pointers to functions taking an integer and returning void
void(*[10])(int)
</code></pre>

<p>If you know in principle how to declare things, but are unsure about just one thing, you may use parentheses:</p>

<pre><code>geordi: make type ( void(int, bool) )*
void(*)(int, bool)
</code></pre>

<p>If you want to see how this looks like with an identifier in it, you may change the type of names, too</p>

<pre><code>geordi: -c int x;
Success
geordi: make x a ( void(int, bool) )* and show
-c void (* x)(int, bool) ;
</code></pre>

<p>If you build up a declaration, but you are unsure about the precedence of the operators, then geordi's precedence functions can help you out</p>

<pre><code>geordi: precedence *x(a, b)
*(x(a, b))
</code></pre>
",0
1714562,1714550,8,"<p>You need a separate version that works with explicit argument lists:</p>

<pre><code>void vfunc(int x, va_list args)
{
  /* do stuff */
}

void func2(int x, ...)
{
  va_list arg;

  va_start(arg, x);
  vfunc(x, arg);
  va_end(arg);
}
</code></pre>

<p>This is the reason there are standard functions like <code><a href=""http://linux.die.net/man/3/vfprintf"" rel=""noreferrer"">vprintf()</a></code>.</p>
",1
1716823,1714550,0,"<p>To be added to ""unwind"" answer:</p>

<p>va_start(3) man page has decent explanation how to work with va_list objects including good example.</p>

<p>Also printf(3) page contains even better example of va_list based call infrastructure around vsnprintf(3) (you can get to this page using any of printf() variants name).</p>
",0
1413751,1413725,0,"<p>I am curious if you mean getch() as being a problem.</p>

<p>4 mths ago there was a discussion regarding getch() that may be of use:
<a href=""https://stackoverflow.com/questions/814975/getch-is-deprecated"">getch is deprecated</a></p>

<p>In the second answer getchar() is suggested, so it shouldn't be returning an error, but that also depends on which compiler you are using.</p>
",0
1413752,1413725,1,"<p>getchar() is a macro function. Maybe you're missing the right include file.</p>

<p>In a pinch,</p>

<pre><code>#ifndef getchar
#define getchar() getc(stdin)
#endif
</code></pre>
",1
1413762,1413725,3,"<p>getchar is still an int by the <a href=""http://www.opengroup.org/onlinepubs/000095399/functions/getchar.html"" rel=""nofollow noreferrer"">POSIX and C standards</a>.  Did you forget to include stdio.h or include something that redefines it?  This example works for me:</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
  int c;
  c = getchar();
}
</code></pre>
",0
1413791,1413725,1,"<p><a href=""http://codepad.org/Fp8kmzbv"" rel=""nofollow noreferrer"">http://codepad.org/Fp8kmzbv</a></p>

<p>It compiles and runs fine @codepad. What is your compiler, your compile options, and how are you running it?</p>

<p>And running it on my home machine:</p>

<pre><code>$ gcc-trunk --version
gcc-trunk (GCC) 4.5.0 20090907 (experimental)

$ gcc-trunk -Wall -ansi -Wall -W -pedantic tt.c
tt.c: In function ¡®main¡¯:
tt.c:73:5: warning: format ¡®%4d¡¯ expects type ¡®int¡¯, but argument 2 has type ¡®long int¡¯

$ ./a.out
This is a test of your histogram program.
   3  |          *
   2  |    *     *
   1  | *  *     *           *  *
      +---------------------------------
        1  2  3  4  5  6  7  8  9 10 &gt;10
</code></pre>

<p>So it should still do what you want it to do, assuming you're running it correctly (as a console application within a console).</p>
",0
1413890,1413725,0,"<p>maybe you have to call fflush(stdout) at the end of your program to flush console output.</p>
",0
707810,704878,6,"<p>Just to extend on kgiannakakis post:</p>

<p>The shift operator <code>&lt;&lt;</code> works because it shifts at the binary level - effectively in base 2. Just as moving a number by one place to the left in decimal (base 10) is the same as multiplying by 10. For example:</p>

<pre><code>23 (move to left one digit) = 230 = 23 * 10
</code></pre>

<p>For the example (using the prefix 0b to represent binary numbers):</p>

<pre><code>    3 * 2 = 6
0b11 &lt;&lt; 1 = 0b110
</code></pre>

<p>Shifting by other numbers is equivalent to multiplying by 2 'n' times, or multiplying by 2 to the nth power (2^n)</p>

<pre><code>   3 * 8 =    3 * 2^3    = 24
0b11 * 8 =   0b11 &lt;&lt; 3   = 0b11000 (note the trailing zeros)
</code></pre>

<p>And an example in decimal to finish it off:</p>

<pre><code>23 (move to left 3 places) = 23 * 1000 = 23 * 10^3 = 23000
</code></pre>
",0
708356,704878,5,"<p><strong>Caution:</strong> Shifting might not work for signed variables,</p>

<pre><code>int x;
int tmp;

if (x &lt; 0) {

   tmp = -x;
   tmp = tmp &lt;&lt; 1;
   x = -tmp;
}
else {

   x = x &lt;&lt; 1;
}
</code></pre>
",2
704885,704878,19,"<p>Use bit wise &lt;&lt; operator:</p>

<pre><code>x = x &lt;&lt; 1;
</code></pre>

<p>This works for integer and long numbers (not floating point numbers).</p>

<p>It basically shifts the binary contents one position to the left, which is equivalent to multiplying by 2</p>
",3
704886,704878,7,"<p>Left shift. </p>

<p><a href=""http://c2.com/cgi/wiki?PrematureOptimization"" rel=""nofollow noreferrer"">But why would you want to do that</a>? Leave that kind of optimization to the compiler. </p>

<p>List of operators and plenty of examples on <a href=""http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B"" rel=""nofollow noreferrer"">wikipedia</a>. </p>
",1
784293,784285,13,"<p>K &amp; R. [Kernighan &amp; Ritchie]</p>

<p><a href=""https://rads.stackoverflow.com/amzn/click/com/0131103628"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">http://www.amazon.com/Programming-Language-Prentice-Hall-Software/dp/0131103628/ref=pd_bbs_1?ie=UTF8&amp;s=books&amp;qid=1240539543&amp;sr=8-1</a></p>
",8
784295,784285,0,"<p>This supposed to be <a href=""https://rads.stackoverflow.com/amzn/click/com/0131103628"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">C bible</a>.</p>
",1
784310,784285,5,"<p>You could try Thinking in C by Bruce Eckel.</p>

<p>It is completely free of charge, and is available for download from his website.</p>
",1
784321,784285,0,"<p>Problem Solving and Program Design in C</p>

<p>by</p>

<p>Jeri R. Hanly, Elliot B. Koffmon and Frank L. Friedman</p>
",0
784885,784285,0,"<p>Check out <a href=""https://rads.stackoverflow.com/amzn/click/com/0131315099"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">The Standard C Library</a> by P. J. Plauger, from 1991. It alternates quotes from the standard (C89, I believe) with discussion of how the library functions were intended to be used, along with a fully described <em>implementation</em> of the complete C standard library. Source code is included as well.</p>

<p>Yes, the book hasn't been updated for the latest standard, but it still has a lot of value from explaining at least some of the rationale behind some of the oddities of the standard library. Incidentally, Plauger was on the standards committee.</p>

<p>Plauger wrote a number of the classic books on both C and early Unix. Track down and read the oldest for a taste of pre-C history...</p>
",0
784902,784285,0,"<p>Given your previous (C#) programming experience I guess you don't need a book that teaches how to program but the intricacies and subtleties of C. I'd recommend the following:</p>

<ul>
<li>Prentice Hall - The ANSI C Programming Language 2nd ed. by Brian W. Kernighan and Dennis M. Ritchie. For basic questions.</li>
<li>Prentice Hall - Expert C Programming. Deep C Secrets.</li>
<li>ISO - C 99 Standard - final. Very useful for many doubts and questions</li>
</ul>
",0
784802,784285,3,"<p>As others have said, read K&amp;R.  </p>

<p>Pay special attention to pointers, structs, unions, bit fields, typedefs, and the C preprocessor.  Pointers and pointer arithmetic are very important.  </p>

<p>Read the C preprocessor manual.</p>

<p>Learn to write makefiles.  Read the manual for your version of make.</p>
",1
784964,784285,0,"<p>A source of problems to solve that have known answers is <a href=""http://projecteuler.net/"" rel=""nofollow noreferrer"">Project Euler</a>. </p>

<p>It isn't itself C specific since there is a decidedly mathematical orientation to the problems as presented. However, making an honest attempt to solve a significant number of them would require a growing proficiency with structures, pointers, the standard library, and thinking about things in ways that work well in C.</p>

<p>Another resource that often seems to be overlooked is that MIT has been putting a large percentage of their curriculum online. Their <a href=""http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/index.htm"" rel=""nofollow noreferrer"">EE/CS department</a> is no exception.
The class <a href=""http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/CourseHome/index.htm"" rel=""nofollow noreferrer"">Introduction to Algorithms</a> might be one suitable choice. The textbook is Introduction to Algorithms, Second Edition, by Cormen, Leiserson, Rivest, and Stein which is reasonably well written as text books go. I didn't exhaustively search the course list, so I'm sure there are other gems in there as well.</p>
",0
784822,784285,1,"<p>K&amp;R is outdated.</p>

<p>I prefer C Primer Plus 5th Ed by Stephen Prata
ISBN: 0-672-32696-5 </p>

<p>It covers C99.</p>
",2
883000,882926,3,"<p>This is to do with data alignment. Most compilers will align data on address boundaries that help with general performance. So, in the first case, the struct with the packed attribute, there is an extra byte between the char [3] and the int to align the int on a four byte boundary. In the packed version that padding byte is missing.</p>

<pre><code>byte  :      0       1         2         3      4   5   6   7
st1   : opcode[0] opcode[1] opcode[2] padding |----int------|
st2   : opcode[0] opcode[1] opcode[2] |-------int--------|
</code></pre>

<p>You allocate an unsigned int and pass that to the function:</p>

<pre><code>byte  :      0       1         2         3      4   5   6   7
alloc :   |-----------int------------------| |---unallocated---|
st1   : opcode[0] opcode[1] opcode[2] padding |----int------|
st2   : opcode[0] opcode[1] opcode[2] |-------int--------|
</code></pre>

<p>If you're using a little endian system then the lowest eight bits (right most) are stored at byte 0 (0x33), byte 1 has 0x44, byte 2 has 0x33 and byte 4 has 0x11. In the st1 structure the int value is mapped to memory beyond the end of the allocated amount and the st2 version the lowest byte of the int is mapped to the byte 4, 0x11. So st1 produces 0 and st2 produces 0x11. </p>

<p>You are lucky that the unallocated memory is zero and that you have no memory range checking going on. Writing to the ints in st1 and st2 in this case could corrupt memory at worst, generate memory guard errors or do nothing. It is undefined and dependant on the runtime implementation of the memory manager.</p>

<p>In general, avoid <code>void *</code>.</p>
",0
882964,882926,0,"<ul>
<li>%c interprets the argument as the ascii code of a character and prints the character</li>
<li>3's ascii code is 0x33</li>
<li>D's ascii code is 0x44</li>
<li>17 is  0x11</li>
</ul>

<p>an int is stored little endian or big endian depending on the processor architecture -- you can't depend on it going into your struct's fields in order.</p>

<p>The int target in the unpacked version is past the position of the int, so it stays 0.</p>
",0
882972,882926,1,"<p>Your bytes look like this:</p>

<p>00010001 00110011 01000100 00110011</p>

<p>Though obviously your endianness is wrong and in fact they're like this:</p>

<p>00110011 01000100 00110011 00010001</p>

<p>If your struct is packed then the first three bytes are associated with opcode, and the 4th is target - thats why the packed array has atarget of 17 - 0001001 in binary.</p>

<p>The unpacked array is padded with zeros, which is why target in varst2 is zero. </p>
",0
1227753,1227737,6,"<p>Strtok writes to the memory allocated to the string.</p>

<p>You cannot write to statically allocated string memory on most compilers/runtimes/hardware. You can write to the stack.</p>
",0
1227754,1227737,12,"<p><code>strtok()</code> basically modifies the input string. </p>

<pre><code>char *glob2 = ""/abc/def/ghi"";
</code></pre>

<p>In above case the <code>glob2</code> points to read-only data and hence it fails, whereas with '<code>char glob[] = ""/abc/def/ghi"";</code>' the data is not read-only, it's available in char array. Hence it allows the modifications.</p>
",1
1227781,1227737,7,"<p>char[] str1 = ""foo""  allocates an array of the chars on the stack (assuming this is inside a function). That array can be modified without a problem.</p>

<p>const char *str = ""foo""  gives you a pointer to the string foo, which will usually reside in read-only memory.</p>

<p>char *str = ""foo""  will do the same thing but implicitly remove the const (without actually changing the fact that the pointer likely points to read-only memory).</p>
",0
1230218,1227737,-1,"<p>The other comments are correct; you should use strtok_r() instead.</p>
",1
1581746,1581580,3,"<p>In C, <code>x[i]</code> is the same expression as <code>*(x + i)</code>, because adding an integer to a pointer is done by scaling the integer by the size of the pointed-to object, and because it's defined that way.</p>

<p>This means that despite its asymmetrical appearance, the indexing operator <code>[]</code> in C is commutative.</p>

<p>The traditional demonstration of this is something like:</p>

<pre><code>main() {
  int x[] = { 1, 2, 3, 4 };

        printf(""%d\n"", x[2]);
        printf(""%d\n"", 2[x]);
}
</code></pre>

<p>Both lines are equivalent and print the same thing.</p>
",1
1581584,1581580,12,"<p>It gets the value of whatever is pointed to by <code>a_mat + i</code>. It could have been written <code>a_mat[i]</code> instead.</p>
",5
1779856,1712546,1,"<p>For a ""cool"" application that goes beyond simple GUI's,  check out the <a href=""http://opencv.willowgarage.com/wiki/"" rel=""nofollow noreferrer"">OpenCV</a> computer vision library. It provides fast real-time image processing and face recognition. </p>

<p>Now you can access a webcam and start writing real-time computer vision games. For applications like these that are processor intensive, C is the ideal choice.</p>
",0
1780025,1712546,0,"<p>The fact that C is used by so many large and successful projects doesn't particularly make it ""good"". The reason C is so commonly used is because of a few factors, it's been around a long time, it's fast, it lets you access both low level and high level interfaces as needed, and it's better than the other old languages (FORTRAN etc). The ""cool"" thing about C is that you can make it do absolutely anything: inject itself into the kernel and add some new features or bug fixes that you couldn't convince Microsoft to do, etc.</p>

<p>Yes, C can be and is easily used for things beyond the command line, but it's extremely dangerous due to pointers... Not to mention development in other more modern languages is faster (and safer) by magnitudes. I never use C unless it's the last resort, ie: need to implement something low level or needs that extra performance.</p>

<p>By the way, when I say C, I really mean C++. I'd never choose C over C++ unless I was forced to.</p>
",0
1712571,1712546,5,"<p>Well, that depends. If you want to build desktop applications, a multiplatform GUI library whose main language is C is GTK+:</p>

<p><a href=""http://www.gtk.org/"" rel=""noreferrer"">http://www.gtk.org/</a></p>

<p>For games, check out SDL:</p>

<p><a href=""http://www.libsdl.org/"" rel=""noreferrer"">http://www.libsdl.org/</a></p>

<p>Which provides you with thinks like direct input from keyboard, 2D graphics, some audio and even threads and stuff like that. It can also open an OpenGL context if you want to get into the 3D world (however it's hard to do it in raw OpenGl). Did I mention that SDL is multiplatform?</p>

<p>However the real strength of C is in systems programming. For desktop applications/games maybe you are best suited with C++. Now that you have command of C, learning the basic C++ should be easy ;).</p>
",4
1712582,1712546,1,"<p><a href=""http://www.libsdl.org/"" rel=""nofollow noreferrer"">SDL</a> is a good library for graphics and sound, and I've seen some cool stuff done with it. If you do it in C, it'll take longer to make, but from a performance point of view, it'll be much better.</p>
",1
1712583,1712546,42,"<h3>C is the concrete and the steel of modern tech</h3>

<p>There was a time when almost everything was written in C, or in something much worse.</p>

<p>These days, many of the advanced languages and systems are actually implemented in C or C++, and then those things implement more systems. It is <em>standing on the shoulders of giants</em>, as the expression goes. Almost every OS kernel, browser, and heavy-duty-web-server is written in C/C++.</p>

<p>So sure, you don't see the steel in the high rise, you see the beautiful interior furnishings and the sleek glass windows. You don't want a steel or concrete desk, and if you did, it would be too expensive to build for you.</p>

<p>Back to your GUI question: your first C graphics program should probably use the original <a href=""http://en.wikipedia.org/wiki/X_Window_System"" rel=""nofollow noreferrer"">X Window System</a> directly. Don't spend too much time there, but then move on to one of the more advanced Widget toolkits <a href=""http://en.wikipedia.org/wiki/GTK%2B"" rel=""nofollow noreferrer"">such as GTK+</a> or <a href=""http://en.wikipedia.org/wiki/Qt_(toolkit)"" rel=""nofollow noreferrer"">(the C++) Qt</a>. Be sure to investigate your OS X system, as it has one of the most advanced of them all.</p>

<p>I <strike>try</strike> love to write things in Ruby these days, but I happen to know there are over <strike>100,000</strike> 200,000 lines of C code implementing that cool Ruby language system. :-)</p>
",6
1712613,1712546,2,"<p>Sure there are some impressive programs made in C ! </p>

<p>GNOME for example, <em>arguably</em> the most used desktop environment used in modern unix systems is written in C (the major parts at least) and is mostly based on <a href=""http://www.gtk.org"" rel=""nofollow noreferrer"">GTK+</a> gui toolkit, itself done in C.</p>

<p>For game, OpenGL is a C api and is the standard for 3D graphic programming in multi-platform development (not uniquely microsoft platform), and Quake 3, which the engine, Id Tech 3, is available in GPL, is also writen in C. There also is many 2D games written using <a href=""http://www.libsdl.org"" rel=""nofollow noreferrer"">SDL</a> library.</p>
",0
1712630,1712546,1,"<p>If your idea of cool is GUI apps and you want to write native GUI apps on the Mac, you'll want to look at
<a href=""http://developer.apple.com/Carbon/"" rel=""nofollow noreferrer"">Carbon</a>. This is the official C API into the Mac GUI and OS. They keep threatening to kill it, but it survives.</p>

<p>Personally I think GUI apps are a very narrow definition of cool. What I think is cool is implementing parallelized math algorithms using <a href=""http://developer.apple.com/mac/snowleopard/opencl.html"" rel=""nofollow noreferrer"">opencl</a>.</p>
",0
1712653,1712546,12,"<p><strong>Summary</strong></p>

<p>Ok, this post got <em>really</em> big, so here's a quick summary before you read it: to program GUIs, there are a number of good C/C++ libraries (for example, QT). What most people do, on Windows systems at least, is to use a .NET language (like C#) when they want GUIs, and C/C++ when they want more control/speed. It's also very common to use both in combination, i.e. make a GUI in C# and speed-critical parts in C.</p>

<p>I still encourage you to read the longer answer, it contains a lot more information on your options.</p>

<p><strong>Longer answer</strong></p>

<p>I'll start with the big question, then answer (as best I can) your specific question about creating a GUI. I think you're kind of suffering from the fact that C is used to teach programming, and it's much easier to do so only using command line programs (after all, they're much simpler to write). This doesn't mean that C can't do all of the stuff you want, like GUIs specifically. It does. I don't think there's any type of software that hasn't been done in C, usually before it was done in other languages.</p>

<p>All right, some answers:</p>

<p><strong>Is C Useful?</strong></p>

<p>C, and its very close relative C++, are responsible for a <strong>huge</strong> portion of the world's code. I don't know if more code is written in C than any other language, but I'm guessing it's not far off.</p>

<p>Most of the really important programs you use are actually written in C/C++. Just for one example, Windows.</p>

<p><strong>Where is C used today?</strong></p>

<p>C/C++ are still used a <strong>lot</strong>. They're especially useful for developing low-level stuff (i.e. stuff like Operating Systems, which need a lot of speed, a lot of ability to control exactly what your code does, etc.).</p>

<p>But don't think it's all low level for C programmers. Even today, with many other languages available (which are arguably much better, and certainly much easier to program), C is still used to create practically everything. GUI applications, which you specifically asked about, are very often made with C, even though nowadays, lots of people are switching to other languages. Note I say switching: C used to be the standard language for writing, well, everything, really.</p>

<p><strong>How do I develop GUIs with C</strong></p>

<p>Alright, you specifically wanted to know how to create a GUI with C (I'm hoping C++ is ok too).</p>

<p>First of all, it depends on a number of factors:</p>

<ol>
<li>What Operating System are you writing for? (Windows, Mac, and Linux are the most common).</li>
<li>Do you want the GUI to work on other systems as well? </li>
</ol>

<p>The most common case is writing software to work on Windows. In that case, the ""natural"" solution is to write things that work with the Win32 API. That's basically the library that ""comes"" with Windows, letting you do any GUI work you want to do.</p>

<p>The big problem with this is, it's kinda hard. As in, a lot hard. This is the reason most people don't do that kind of work anymore.</p>

<p>So what are your other options?</p>

<p>The most natural is going with what's called a .NET language. Those are a bunch of languages, together with libraries, that Microsoft created. They're probably the easiest way to get a GUI on Windows. The problem is, you can't really use them from C (since it's not a .NET language).</p>

<p>Assuming you want to stay in C/C++ land, you can use some kind of library which makes working with the Windows API easier (since it hides all the ugly details):</p>

<ol>
<li>One of the most common is what's called MFC (Microsoft Foundation Classes), which are a bunch of C++ classes which make it ""easier"" to create Windows stuff. Unfortunately, this library is very old, and is really not that easy to use.</li>
<li>The other way to go if you want to program in C++ is to use some kind of third-party library. This is a library that someone other than Microsoft created, which makes it easier to create a GUI.</li>
<li>Another option is to create <strong>only the GUI</strong> part of your software in a .NET language, and use C/C++ for the other parts (or use the .NET language to do almost everything, and use C/C++ only when you really need it, for example when you need things to go really fast). This is a very popular option.</li>
</ol>

<p>The advantage of a third party library is that, if you pick the right one, you can use the same code to create a GUI for all the Operating Systems at the same time.</p>

<p>I think the most famous of these libraries is QT, and also WxWidgets, but there are a bunch of other ones. I would personally pick QT since it seems to get the most fame, but I haven't worked with either.</p>
",1
1712556,1712546,4,"<p>Cool stuff do with C?<br>
Operating Systems, device drivers, and python modules for starters.</p>

<p>Games typically will use C++ if they're C-Based, in my experience / what I've seen.</p>
",2
1712558,1712546,3,"<p>There are many libraries for C under Unix, such as X lib, which accesses X11.</p>

<p>If you wanted to get into robotics you may find C to be very useful, as you will have to write low-level code with very small memory footprints, so even C++ may not be the best choice.</p>

<p>C and C++ are very good at writing small, fast code, but OOP is not always the best choice, so at times you will find that C is a better choice, for example if you are writing a compiler or OS.</p>
",0
1712565,1712546,7,"<p>Every major operating system has all of its low-level libraries implemented in C.  Mac OS X is a Unix-like system under the hood, which is a wonderful world if you're a C programmer.</p>

<p>Check out <a href=""http://www.faqs.org/docs/artu/"" rel=""noreferrer"">The Art of Unix Programming</a> for some great ideas.</p>

<p>As for GUI stuff, you'll probably want to use X11.  There is plenty of good documentation out there -- most Unix programming stuff and most deep system-level stuff just <em>assumes</em> you're working in C, since that's what everybody uses for it.</p>
",1
1715345,1712546,1,"<p><a href=""http://www.gtk-server.org/demo.c.txt"" rel=""nofollow noreferrer"">GTK-server</a> is REALLY easy to get started with, in C or any other language. Just click that link.</p>
",0
1675941,1675931,1,"<p>It's rounding up the size to a multiple of <code>sizeof(int)</code>.  <code>size</code> will be the smallest number of <code>int</code>s that are larger than or equal to the space required by <code>size_in_bytes</code>.</p>
",0
1675949,1675931,7,"<p>It rounds the size up to a multiple of <code>sizeof(int)</code>. This is normally done for alignment purposes since on some machines (for instance SPARC) you cannot access a 32-bit wide value that is aligned on an odd address (typical symptom is a SIGBUS). And even on processors that do support unaligned access, like x86 and PPC, it's often slower than an aligned access. It's also useful to help prevent cache splits, where half of the data is in one cache line and half is in another - this slows down access to the value by a factor of 2, which is pretty nasty.</p>

<p>Malloc has to assume the largest possible useful alignment because it does not know the size of the things it is allocating. Typically that is 4, 8, or 16 bytes, depending on the machine.</p>
",2
1677854,1677850,15,"<p>You have two problems here.</p>

<p>First, you are deleting the same heap variable twice:</p>

<pre><code>  free(p); 
  free(q);
</code></pre>

<p>Second, you have a memory-leak, because the variable created by <code>p</code> is no longer accessible.</p>

<hr>

<p>Notice that onebyone's comment is really important. If you change the line:</p>

<pre><code>p = q;
</code></pre>

<p>into:</p>

<pre><code>*p = *q;
</code></pre>

<p>There would be no problems at all in your code :) Hello Pointers!</p>
",0
1677855,1677850,4,"<p>You set <code>p</code> to <code>q</code>, so you are <code>free()</code>ing it twice.</p>
",0
1677856,1677850,2,"<p>Since <code>q</code> and <code>p</code> point to the same memory at the point you are <code>free</code>ing them, you're effectively <code>free</code>ing the memory twice.</p>
",0
1677857,1677850,2,"<p>Because here:</p>

<pre><code>p = q;
</code></pre>

<p>...you're throwing away the old value of <code>p</code>.  You now have <em>two</em> copies of the pointer that was returned by the second <code>malloc</code>, and <em>none</em> of the pointer that was returned by the first <code>malloc</code>.</p>

<p>So then here:</p>

<pre><code>free(p); 
free(q);
</code></pre>

<p>...the same pointer value gets passed to <code>free</code> twice: use-after-free error.  The <em>other</em> pointer value never gets passed to <code>free</code> at all: memory leak.</p>
",0
1695374,1695108,4,"<p>I use text mate and gcc in the terminal. I find Xcode too bulky for small commandline programs in C. It's great if you want to do cocoa GUI applications, need a quick Apple API reference or want a graphic frontend to gdb etc. 4 seconds sounds excessive for the program you have above, but it's probably due to Textmate cmd-R shortcut. I have never used that for anything else than scripts. But I agree that you should install Xcode, it's on your Mac OS install disk.</p>
",0
1695524,1695108,4,"<p>I disagree if you want to code ANSI C then this is what I'd suggest. Get familiar with a more powerful text editor, be it vim, emacs or whatever. I prefer vim.</p>

<p>See here:</p>

<p><a href=""http://macvim.org/OSX/index.php"" rel=""nofollow noreferrer"">http://macvim.org/OSX/index.php</a></p>

<p>Now, you should try to setup GNU Make for Mac OS X.</p>

<p>Doing this you will learn the methods most C programmers have used for ages. I think you'll get a lot more out of this than using Xcode straight out. With Xcode you want to make sure you are doing C and not Objective-C.</p>

<p>Now, with an editor like vim, you can do everything from a single terminal and waste fewer cycles switching around in your workflow.</p>

<p>So your workflow becomes:</p>

<p>$vim foo.c<br>
(save)<br>
$make<br>
$./a.out  </p>

<p>If you want to do any serious C programming that has any relevance to the UNIX envirnoment (and I suspect that Harvard course does), you will need to learn make at some point.</p>
",1
1695413,1695108,1,"<p>I think you should continue what you're doing. 4 seconds isn't <em>that</em> much time to wait, especially once your programs grow more extensive. Just using a basic text editor and gcc will let you master the basics of C. Once you're ready to start making GUI apps, then I would suggest to start using XCode to take advantage of the tools to make those kind of applications. I think an IDE is overkill at this point.</p>
",0
1695127,1695108,3,"<p>Install Apple's development tools, and use the XCode IDE.  It may or may not increase your compile time, but it will greatly decrease much of the pain of hand coding and compiling on the command line.</p>

<p>To create a simple command-line C program (like the one you're describing above) do this:</p>

<p>File->New Project
Choose <code>Command Line Tool</code> as the project type.
The template includes a ""hello world"" program with a main.c file.
Edit the main.c file to include the code you're working on.
Run the project by choosing the Build and Run button.</p>

<p>**be sure to open the Console to view the output of your program.  (Run->Console)</p>

<p>Good luck!</p>
",6
1695253,1695108,3,"<p>As mentioned before, XCode is the Mac way of doing it. </p>

<p>Just to give you an alternative solution, you can also use <a href=""http://developer.apple.com/mac/library/documentation/Darwin/Reference/ManPages/man1/vim.1.html"" rel=""nofollow noreferrer"">vi/vim</a> from within a terminal. You open the file for the first time by typing <code>vi filename.c</code>. Then you type <code>:w</code> to save the file, <code>:!gcc filename.c</code> to compile it and <code>:!./a.out</code> to run it. The exclamation point does the trick of calling a shell command, so the last two commands can be replaced by one <code>:!gcc filename.c; ./a.out</code> . You also have a command history (""arrow up"", ""arrow down"") from within <em>vi</em>, after pressing the colon.</p>

<p>Getting used to <em>vi</em> is a different story...</p>
",0
1695698,1695108,2,"<p>Try to build with <em>gcc -Wall -Werror</em>  and try to understand and fix your warnings. That is always good practice.</p>
",0
1697983,1695108,0,"<p>There should use Emacs or Vim with a Makefile. They can do anything.</p>

<p>For example, in Emacs, compiling is as simple as M-x Compile (But of course you could bind any key to it). Emacs is also cross-platform (Unlike XCode and TextMate).</p>

<p>Emacs also provides various other features useful for debugging (Built-in gdb support, ability to parse compile output, etc)</p>

<p>Using an IDE-Specific build tool is the exact wrong way to do things (Especially if that IDE happens to be platform specific, like XCode and TextMate)</p>
",0
1981791,1695108,2,"<p>I wouldn't recommended switching to XCode unless you need to use the debugger.  GDB integration with XCode is pretty nice, and non-existent with Textmate.</p>

<p>To improve your Textmate workflow for smallish projects, learn to use make and install the Makefile bundle for Textmate.  You can find it on <a href=""http://github.com/mattfoster/make.tmbundle"" rel=""nofollow noreferrer"">GitHub</a>.</p>

<p>This will give you a new Build (""Command-B"") option in Textmate that will run make, parse the output, and let you easily correct compile time errors.</p>
",0
1677925,1677918,11,"<p>Attempting to modify a string literal results in undefined behavior.  For example, some implementations will store that string in a read-only section of memory.  You cannot (and should not try) to overwrite that memory.</p>
",3
1677929,1677918,5,"<p>This line:</p>

<pre><code>*p = *q;
</code></pre>

<p>Will set the char (singular) pointed to by p to the char pointed to by q.</p>

<p>You want <code>strncpy</code> if you want to copy strings. (Although see Ed's comment about the read-only nature of the strings in your code).</p>
",2
1677931,1677918,11,"<p>You're just overwriting the first character of <code>hello</code>, i.e. <code>h</code> with the first character of <code>world</code>, i.e. <code>w</code>.</p>

<p>Also, if you want to stick with your original code,</p>

<pre><code>p = q;
printf(""%s"", p);
</code></pre>

<p>Also, with <code>p = q</code> you are <strong>not overwriting anything</strong>. <code>p</code> now points to the first character of <code>world</code>.</p>

<p>As <a href=""https://stackoverflow.com/questions/1677918/whats-wrong-with-this-code/1677925#1677925"">Ed</a> said, you cannot overwrite the data stored in <code>p</code> with the data in <code>q</code>.</p>
",0
1677936,1677918,0,"<p>char *p = ""hello"";
  char *q = ""world"";
the both variables are constant, unchangeable</p>
",4
1677947,1677918,2,"<p>Firstly, your code only tries to overwrite the first character of ""Hello"" with first character of ""World"", i.e. it attempts to turn ""Hello"" into ""Wello"".</p>

<p>Secondly, you are trying to modify a string literal. Sitring litrerals are not modifiable. You can't ""overwrite"" string literal. Your attempt to overwrite ""Hello"" with ""World"" is not much different from an attempt to overwrite <code>5</code> with <code>8</code> by doing <code>5 = 8</code>.</p>

<p>For further reading see <a href=""https://stackoverflow.com/questions/1614723/why-is-this-c-code-causing-a-segmentation-fault/1614739#1614739"">Why is this string reversal C code causing a segmentation fault?</a></p>

<p>Thirdly, in order to print a string with <code>printf</code> you have to pass a <em>pointer</em> to the first character, not the first character itself. Your <code>printf</code> should look as <code>printf(""%s"", p)</code></p>
",0
1250823,1250810,1,"<p>The toupper() function expects its input to be an integer in the range of unsigned char (0 - 255), while in some cases a char variable can be in the range of a signed char (-128 - 127).</p>
",0
1250827,1250810,1,"<p>The <code>toupper</code> function expects the argument to be repressentable as an <code>unsigned char</code> or the value <code>EOF</code>. A <code>signed char</code> above 127 would be treated as if it were a negative number if you did not cast it to <code>unsigned char</code> since the argument is an <code>int</code>.</p>
",0
1250829,1250810,3,"<p>The <code>toupper</code> function (with a lower case U) takes either the value of an unsigned char or EOF.  If char is signed, passing a char to toupper() without converting it to an unsigned char first can pass other values with undefined behaviour.  The implementation of toupper often look like this:</p>

<pre><code>int toupper(int c)
{
   return touppermap[c+1];
}
</code></pre>

<p>so the problem here is real. (This implementation assumes EOF is -1, which you can't formally do but nothing prevent the implementation to be knowledgeable about its own characteristics).</p>
",10
1250893,1250810,6,"<blockquote>
  <p>The first one seems simple; malloc
  could return null, and strcpy could
  try to copy data to memory address 0.
  Or s could be a pointer to a string
  (rather than an array), and malloc
  would only allocate enough space for a
  pointer, and would try and copy a
  string into it. (I think).</p>
</blockquote>

<p>Simple enough, right? You missed the most obvious thing wrong with this: you are not allocating enough space. <code>strcpy()</code> copies the string <em>plus the terminating null byte</em>, so the destination buffer must be size at least 1 bigger than the length of the string. </p>
",3
746936,746707,1,"<p>As every answer (so far) has said: to avoid the errors, declare the function before its use, and as Chris Jester-Young points out, use the standard mechanisms for accessing the variadic arguments or suffer the pains of Undefined Behavior.</p>

<p>In this example, it is not that the declaration before use in this case is required because of the function's return type, but rather because it does not match the default signature for an undeclared function: <code>int u()</code>; that is, a function taking unspecified arguments returning an <code>int</code>. Specifically, the actual definition <code>int maw(int,int,...)</code> is <strike>inconsistent with</strike> different from the assumed declaration <code>int maw()</code> which causes GCC to say ""conflicting types for ¡®maw¡¯"".</p>

<p>Your second example </p>

<pre><code>int main() {
  abc(); ..... return 0; 
}
abc() { ....... }
</code></pre>

<p>works because the later definition of <code>abc</code> doesn't contradict the default signature assumed when its first call was encountered. But just because it works doesn't make it good form because you get almost no type safety from the default signature.</p>

<p>Access to the variadic arguments (the ones matching the <code>...</code>) really should be done through the standard mechanisms of <code>stdarg.h</code>, unless you are implementing a compiler and are the author of that compiler's <code>stdarg.h</code>. For instance, on some architectures those arguments may not even be passed on the stack, but they can still be located by the macros from <code>stdarg.h</code>.</p>

<p><strong>Edit:</strong> I reworded the second paragraph to say what I meant in a different, and I hope clearer, way.</p>

<p>The compiler needs to know that the function is variadic <em>before</em> the first call because on some architectures, it might be required to pass the variadic parameters differently than normal parameters. That is especially true of certain register-window RISK architectures, and those that might pass the first 2 ints and first 2 floats in registers, but must put all variadics on the stack even if there is room in the regsisters.</p>

<p>A similar declare before use situation exists for functions that do not use the <code>cdecl</code> calling convention. You will usually run into this when linking modules written in Pascal or FORTRAN with modules written in C. However, many of the Windows API functions exported by the core DLLs assume a calling convention named <code>stdcall</code> and if the compiler were to use a <code>cdecl</code> style call, the program would crash (and the whole machine on Windows 9x or earlier).</p>
",4
746713,746707,4,"<p>Declare maw() before main(), or prototype it before main(). Functions return the types that you assign to them, regardless of arguments (variadic or not).</p>
",0
746715,746707,2,"<p>The problem is that you're calling the function before defining it, and not including a declaration. If you add a line like this:</p>

<pre><code>int maw(int a, int b, ...);
</code></pre>

<p>Before your <code>main()</code> function, you'll be fine. The default (""implcit"") is to assume a function returns <code>int</code>, and has an empty argument list. It's bad form to rely on the implicit declaration, you should declare all functions explicitly.</p>
",0
746716,746707,1,"<p>It's nothing to do with the return type - it's the fact that you declared it at all. Put a declaration:</p>

<pre><code>int maw(int a,int b,...);
</code></pre>

<p>before your use of the function in main()</p>
",0
746718,746707,0,"<p>Add the declaration</p>

<pre><code>int maw(int a,int b, ...);
</code></pre>

<p><em>before</em> your <code>main()</code> function.</p>

<p>Currently, the call you make within your <code>main()</code> function implicitly defines <code>maw()</code>, that is, the compiler ""guesses"" what <code>maw()</code>'s return type is based on the information it is given within <code>main()</code>. If you declare <code>maw()</code> before it is called, you will not have this problem.</p>
",0
746720,746707,11,"<p>The other answers are correct, about putting the function prototype first.</p>

<p>Additionally, to be portable, do not access the <code>...</code> arguments by using a direct pointer to the last (non-vararg) argument, because then you have to care about the alignment and stack direction of your target platform. Instead, use <code>&lt;stdarg.h&gt;</code> and the <code>va_*</code> macros for working with varargs.</p>
",2
1674741,1672131,2,"<p>An illustration might be helpful.  Given the following declarations:</p>

<pre><code>char *s = ""hello world"";
int   x = 45;
int  *p = &amp;x;
int **r = &amp;p;
char q[] = ""hello world"";
</code></pre>

<p>assume the following memory map (addresses and layout are completely arbitrary and aren't meant to represent any real-world architecture):</p>

<pre>
                 0x00  0x01  0x02  0x03 
    0x00008000:  'h'   'e'   'l'   'l'   
    0x00008004:  'o'   ' '   'w'   'o'
    0x00008008:  'r'   'l'   'd'   0x00  
    ...
s:  0x01000000:  0x00  0x00  0x80  0x00  
x:  0x01000004:  0x00  0x00  0x00  0x2D
p:  0x01000008:  0x01  0x00  0x00  0x04
r:  0x0100000C:  0x01  0x00  0x00  0x08
q:  0x01000010:  'h'   'e'   'l'   'l'
    0x01000014:  'o'   ' '   'w'   'o'
    0x01000018:  'r'   'l'   'd'   0x00
</pre>

<p>The string literal ""hello world"" is a 12-element array of <code>char</code> (<code>const char</code> in C++) with static extent, meaning that memory is allocated for it when the program starts and remains allocated until the program terminates.  Exactly where the string literal lives in memory depends on the platform, but it's best to assume that memory is unwritable (i.e., you can't change its contents with <code>strcpy()</code> or <code>strcat()</code> or <code>sprintf()</code>, etc.).  The language standard explicitly states that attempting to modify a string literal results in undefined behavior.  </p>

<p>The line</p>

<pre><code>char *s = ""hello world"";
</code></pre>

<p>defines <code>s</code> as a pointer to char initializes it with the <em>address</em> of the literal (0x00008000 in this example).</p>

<p>The line </p>

<pre><code>int x = 45;
</code></pre>

<p>defines <code>x</code> as an integer and initializes it with the value 45 (2D in hexadecimal notation).  </p>

<p>The line </p>

<pre><code>int *p = &amp;x;
</code></pre>

<p>defines <code>p</code> as a pointer to int and initializes it with the address of <code>x</code> (0x01000004).  </p>

<p>The line</p>

<pre><code>int **r = &amp;p;
</code></pre>

<p>defines <code>r</code> as a pointer to a pointer to int and initializes it with the address of <code>p</code> (0x01000008).  </p>

<p>Note that pointer types are distinct and not always compatible.  Even though <code>s</code>, <code>p</code>, and <code>r</code> all resolve to 32-bit address values in this particular hypothetical, they have different <em>types</em> and are not necessarily interchangable, even if they were all set to point to the same location.  Some platforms use different sizes and representations for different pointer types.  </p>

<p>And finally, as an added bonus, we have the line</p>

<pre><code>char q[] = ""hello world"";
</code></pre>

<p>which defines <code>q</code> as a 12-element array of char (size taken from the size of the string literal being used to initialize it) and initializes it with the <em>contents</em> of the string literal.  </p>
",0
1720104,1720079,2,"<p>It's not ""per line"", it's ""per sequence-point"" which is similar to ""per expression"" that the result from pre- and post- increment seem to occur.</p>

<p>In fact, the increment always occurs immediately.  The only variation is whether the value of the term will result in the initial or afterward value.</p>

<p>To fully understand that C is not line-oriented, please refer to the standard and read the parts about ""sequence points.""</p>

<p>Lines which begin with '#' are pre-processor input.  The pre-processor for C is line-oriented, but, otherwise, C itself considers the line-break characters the same as any other white space such as tab or space.</p>
",1
1720111,1720079,6,"<p>You're not supposed to do more than one increment in arguments to a function.. because the order they can be evaluated in is ambiguous. The result of such code is undefined.</p>

<p>Meaning: <code>printf(""%d,%d,%d,%d\n"",a++,a++,++a,++a);</code> Should be written as</p>

<pre><code>a++; a++;
++a; ++a;
printf(""%d, %d, %d, %d\n"", a, a, a, a);
</code></pre>

<p>Try and fix that first and see if the results are still confusing.</p>

<p>More generally, you should only have one increment between a pair of <a href=""http://en.wikipedia.org/wiki/Sequence_point"" rel=""nofollow noreferrer"">sequence points.</a></p>

<p><b>Edit:</b> Chris is right, there's no point writing four increments in the middle of nowhere. To better answer your question: For a function <code>void f(int)</code> and <code>void g(int)</code>, with <code>int a=0</code>,</p>

<pre><code>f(++a) = f(1);
f(a++) = f(0);
g(++a, ++a) = g(???); // undefined!
</code></pre>

<p>So, increment at most once in the argument to a function.</p>
",6
1720122,1720079,6,"<p><strong>Don't do this. The behavior is undefined.</strong></p>

<p>From the C spec (section 6.5)...</p>

<blockquote>
  <p>Between the previous and next
  sequence point an object shall have
  its stored value modified at most once
  by the evaluation of an expression. 
  Furthermore, the prior value shall be
  accessed only to determine the value
  to be stored.</p>
  
  <p>Except as indicated by the syntax
  or otherwise specified later (for
  the function-call operator () , &amp;&amp; ,
  || , ?: , and comma operators), the
  order of evaluation of subexpressions
  and the order in which side effects
  take place are both unspecified.</p>
</blockquote>

<p>In other words, if you update the value of a variable multiple times in the arguments for a function, you're not writing legal C code.</p>
",0
1720139,1720079,3,"<p>See 3.2 in the C FAQ:</p>

<p>3.2:    Under my compiler, the code</p>

<pre><code>    int i = 7;
    printf(""%d\n"", i++ * i++);
</code></pre>

<p>prints 49.  Regardless of the order of evaluation, shouldn't it
print 56?</p>

<p>A: Although the postincrement and postdecrement operators ++ and --
perform their operations after yielding the former value, the
implication of ""after"" is often misunderstood.  It is <em>not</em>
guaranteed that an increment or decrement is performed
immediately after giving up the previous value and before any
other part of the expression is evaluated.  It is merely
guaranteed that the update will be performed sometime before the
expression is considered ""finished"" (before the next ""sequence
point,"" in ANSI C's terminology; see question 3.8).  In the
example, the compiler chose to multiply the previous value by
itself and to perform both increments later.</p>

<p>The behavior of code which contains multiple, ambiguous side
effects has always been undefined.  (Loosely speaking, by
""multiple, ambiguous side effects"" we mean any combination of
increment, decrement, and assignment operators in a single
expression which causes the same object either to be modified
twice or modified and then inspected.  This is a rough
definition; see question 3.8 for a precise one, and question
11.33 for the meaning of ""undefined."")  Don't even try to find
out how your compiler implements such things (contrary to the
ill-advised exercises in many C textbooks); as K&amp;R wisely point
out, ""if you don't know <em>how</em> they are done on various machines,
that innocence may help to protect you.""</p>

<p>References: K&amp;R1 Sec. 2.12 p. 50; K&amp;R2 Sec. 2.12 p. 54; ISO
Sec. 6.3; H&amp;S Sec. 7.12 pp. 227-9; CT&amp;P Sec. 3.7 p. 47; PCS
    Sec. 9.5 pp. 120-1.</p>
",3
778560,778544,-2,"<p>MS Windows systems use carriage return-linefeed as a line ending, linux using just linefeed.</p>

<p>The ""unreadable character"" is Ctrl-M, the carriage return, character number 13.</p>
",6
778741,778544,0,"<p>You should check your send()s to see if they succeed. You may find that at some point the write buffer (that is, the socket's output buffer) is full and the send fails. This is normal behavior. Send returns the number of bytes sent. If you are not sending multibyte characters, this would probably manifest as missing data rather than corruted data. If you lose one byte of a two byte character, it could result in corruption.</p>
",0
778815,778544,1,"<p>In the first instance, don't use <code>strlen()</code>.  There's absolutely no guarantee that there'll be a NUL byte anywhere in the file stream, and in fact with a text file there never should be.</p>

<p>Each time around the loop you should output the actual number of bytes that were received, not how many <code>strlen()</code> thinks might be in the buffer:</p>

<pre><code>do
{
    bytes_received = recv(sock, recv_data, 100, 0);
    if (bytes_received &lt; 0) {
        perror(""read"");
        break;
    } else if (bytes_received == 0) {
        break;
    } else {
        count = write(t, recv_data, bytes_received);
        // in theory - add error check here too!
    }
} while (count &gt; 0);
</code></pre>
",2
782142,782136,1,"<p>A far better way to read a line of input is</p>

<pre><code>char line[128]; /* Or whatever. */

while(fgets(stdin, line, sizeof line) != NULL)
{
  /* Filter out whitespace before checking tokens. */
}
</code></pre>
",2
782192,782136,0,"<p>If all you are having trouble with is empty lines, use <code>strcmp(""\n"", buffer) == 0</code>.</p>

<p>The regexp you posted won't work very well because C will translate the <code>'\n'</code> char in <code>""%*[^\n]""</code> to a literal newline. To have it work better you need to scape the slash: <code>""%*[^</code><b><code>\</code></b><code>\n]""</code>.</p>

<p>However, it seems the trouble is also with the reading, i recommend you use a better function for that.</p>

<p>I have used the following code before to read sequential lines of arbitrary size from a file.</p>

<p>Couple of notes, though:</p>

<ol>
<li>The returned buffer needs to be <code>free()</code>d after you are done with it</li>
<li>The code wastes a couple of bytes every iteration, but this is not really noticeable unless <code>BUFFER_SIZE</code> very small in comparision to the length of the lines.</li>
</ol>

<p>The code, however, guarantees that one full line will be read from the <code>FILE *</code> and it will end in '\n'.</p>

<pre><code>/*
 * Initial size of the read buffer
 */
#define DEFAULT_BUFFER 1024

/*
 * Standard boolean type definition
 */
typedef enum{ false = 0, true = 1 }bool;

/*
 * Flags errors in pointer returning functions
 */
bool has_err = false;

/*
 * Reads the next line of text from file and returns it.
 * The line must be free()d afterwards.
 *
 * This function will segfault on binary data.
 */
char *readLine(FILE *file){
    char *buffer   = NULL;
    char *tmp_buf  = NULL;
    bool line_read = false;
    int  iteration = 0;
    int  offset    = 0;

    if(file == NULL){
        fprintf(stderr, ""readLine: NULL file pointer passed!\n"");
        has_err = true;

        return NULL;
    }

    while(!line_read){
        if((tmp_buf = malloc(DEFAULT_BUFFER)) == NULL){
            fprintf(stderr, ""readLine: Unable to allocate temporary buffer!\n"");
            if(buffer != NULL)
                free(buffer);
            has_err = true;

            return NULL;
        }

        if(fgets(tmp_buf, DEFAULT_BUFFER, file) == NULL){
            free(tmp_buf);

            break;
        }

        if(tmp_buf[strlen(tmp_buf) - 1] == '\n') /* we have an end of line */
            line_read = true;

        offset = DEFAULT_BUFFER * (iteration + 1);

        if((buffer = realloc(buffer, offset)) == NULL){
            fprintf(stderr, ""readLine: Unable to reallocate buffer!\n"");
            free(tmp_buf);
            has_err = true;

            return NULL;
        }

        offset = DEFAULT_BUFFER * iteration - iteration;

        if(memcpy(buffer + offset, tmp_buf, DEFAULT_BUFFER) == NULL){
            fprintf(stderr, ""readLine: Cannot copy to buffer\n"");
            free(tmp_buf);
            if(buffer != NULL)
                free(buffer);
            has_err = true;

            return NULL;
        }

        free(tmp_buf);
        iteration++;
    }

    return buffer;
}
</code></pre>
",3
782907,782136,0,"<p>You can also use <a href=""http://www.gnu.org/software/libc/manual/html_node/Line-Input.html#Line-Input"" rel=""nofollow noreferrer"">getline()</a> if your development environment supports it</p>
",0
784443,782136,0,"<p>There are two problems with <code>scanf(""%*[^\n]"",buf);</code>:</p>

<ol>
<li>The asterisk in the specifier causes value to be scanned, but not stored.</li>
<li>It scans up until the next newline character, but doesn't consume that character. That means every call after the first one will read nothing.</li>
</ol>
",1
784459,782136,0,"<p>I think the scanf you're looking for is:</p>

<p>scanf(""%[^\n]%*c"", buf);</p>

<p>The %[^\n] gets your string, the %*c ignores the newline.</p>

<p>But, this is literally what you get if you google ""how not to read a string in c""</p>

<p>Non-blocking input is something else entirely.  You might google ""cbreak mode.""  But, that's a unix-y terminal-y thing, and if you're on Windows, that probably doesn't make sense.   X/Gtk/Qt will have other ways of doing that sort of thing.</p>
",0
1622439,1622416,4,"<p>Heres a hint</p>

<pre><code>char* strdup(char *str)
{
        char* ret = (char*)malloc(strlen(str)+1);

        //copy characters here
        return ret;
}
</code></pre>
",0
1418652,1418645,0,"<p>The best advice I can give here is find a topic you're interested in, see if you can make a program to do what you want/assist in doing what you want/adding functionality to the interest of choice, and start coding.</p>

<p>This gives the bonus of doing something you're interested in, and at the same time making something that directly influences it. It should give the motivation to keep steaming onward with the learning process.</p>
",0
1418656,1418645,0,"<p>I'm working with C a lot at the moment with Linux Kernel modules and am relatively new to C. I've found this rewarding which I think is what's important for this sort of hobby <em>'temperature converter or a text-based rpg</em>' type programming.</p>

<p>I also struggle finding an application of programming skills. Balance of challenge and reward is important I think.</p>
",0
1418657,1418645,4,"<p>As rogeriopvl wrote in a comment, the compilation process is really simple. Just write up the code in somefile.c and</p>

<pre><code>gcc -o somefile somefile.c &amp;&amp; ./somefile
</code></pre>

<p>(if you're using GCC, and if not, your compiler of choice can probably be invoked similarly) Unless/until you start getting into more complicated projects, it's barely any more complicated than a scripting language. (Well... okay, you may need to link some libraries, once you get beyond the basics. But still, not a huge deal.)</p>

<p>In fact, I did write myself a little shell script that allows me to use C as a scripting language. But the process for setting it up is a little more complicated than what you may want to get into at this stage - it's simpler to just run the compiler each time. Still, if you're interested, I can look up the directions (for Linux) and put them here.</p>
",1
1418659,1418645,2,"<p>C code needs to be compiled before the program can be run. The exact process is different depending on which platform and compiler you are working on. </p>

<p>For the most part, using an IDE (such as <a href=""http://www.microsoft.com/express/"" rel=""nofollow noreferrer"">Visual studio</a>, <a href=""http://www.eclipse.org/cdt/"" rel=""nofollow noreferrer"">Eclipse</a>, <a href=""http://monodevelop.com/"" rel=""nofollow noreferrer"">MonoDevelop</a>, and a bunch of others) will do the nasty work for you so that you just have to press a button or click an icon. Download one of these</p>
",0
1418665,1418645,5,"<p>write w.c</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
    int i;
    for (i = 0; i &lt; argc; ++i) {
        printf(""Param %d is '%s'\n"", i, argv[i]);
    }
    return 0;
}
</code></pre>

<p>and compile with</p>

<pre><code>gcc -Wall -o w w.c
</code></pre>

<p>run</p>

<pre><code>./w
</code></pre>
",1
1418666,1418645,2,"<p>I asked myself this question when I was learning C. The problem here, if I can say this is a problem, is that C can be used in a broad range of applications and in a broad range of environments, which one with its own IDEs or compilers and libraries. Some examples where you can use C for real staff.</p>

<p>Embedded software. In this case you will probably use some lib.  </p>

<p>Network programming (take a look at <a href=""http://www.amazon.co.uk/Unix-Network-Programming-Addison-Wesley-Professional/dp/0131411551/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1252870956&amp;sr=8-1"" rel=""nofollow noreferrer"">this book</a>.   </p>

<p>Device driver development.  </p>

<p>Libraries (both for Linux/Windows and other OSs)</p>

<p>Well this list is endless. </p>

<p>O don't know if I help you with this question. If you give more details about what are you interested in, could be helpful</p>

<p>Good luck</p>
",0
895642,895628,1,"<p>Inside your first loop, you should be (but you aren't) writing each input into a different element of the num array; instead you're always writing to the same place, i.e. to <code>&amp;num</code>.</p>
",0
895645,895628,3,"<p>The upshot here is the line <code>array[i] = &amp;num;</code> you're setting the value of the <code>array[i]</code> element to the address of the <code>num</code> array; since <code>array</code> is a char array, I suspect it's truncating your <code>num</code> array address, and the low-order byte just happens to be a 3.</p>

<p>However.  That said, your char num[1000000] is hideous form, and you should not do that, at all.  Allocate on the heap, and choose a smaller number, for heaven's sake.  Also, the scanf(""%s"", &amp;num) won't actually give you what you want.  Here's a hint; use a getc() loop to read the numbers; this avoids needing to do any preallocation of an array for scanf().</p>
",3
895676,895628,0,"<p>char* array[cases];</p>

<p>This is allocated at compile-time, not run-time. And cases isn't initialized (although I think you want it to work dynamically anyway.) So you either need to preallocate the memory, or get familiar with the malloc family of library functions.</p>
",3
895716,895628,0,"<p>Thats your code that is fixed:</p>

<pre><code>#include &lt;stdio.h&gt;

main(void)
{
    int i, cases;

    scanf(""%d"", &amp;cases);
    char* array[cases];

    //store inputs in array
    for(i=0; i&lt;cases; i++)
    {
        char *num = malloc(100000);
        scanf(""%s"", num);
        array[i] = num;
    }

    //print out array items and their memory addresses
    for(i=0; i&lt;cases; i++)
    {
        printf(""%d %s\n"", i, array[i]);  //print (array index) (array value)
        printf(""%d %p\n"", i, (void*)&amp;array[i]); //print (array index) (array address)
    }
    return 1;
}
</code></pre>

<p>You can as well use </p>

<pre><code>char *num = calloc(100000, sizeof(char));
</code></pre>

<p>which is a little bit defensive. I don't know why you need 100000. You can do it dynamically using malloc. This will involve more work but is very robust.</p>

<p>What is hapenning in your code is that you store the string %s to the address of num which does not change, then you assign array[i] element to that address. Assigning in C is nothing else then storing the reference, you don't store the element itself- this would be waste of space. So as all of the array elements point to the address (only store the reference), the value in the adress change, thus so does the reference, that's why they all are changing to 2 (not 3 as you stated in your post).</p>
",4
895764,895628,2,"<p>It's because you are putting in every index of the array the same address (the address of  char num[1000000];).</p>

<p>It's an error that will lead you to dynamic allocation (calloc, malloc, new, etc).</p>

<p>Cheers!</p>
",0
895947,895628,0,"<p>Replace</p>

<pre><code>//store inputs in array
for(i=0; i&lt;cases; i++)
{
    scanf(""%s"", &amp;num);
    array[i] = &amp;num;
}
</code></pre>

<p>with</p>

<pre><code>array[0] = num;
//store inputs in array
for(i=0; i&lt;cases; i++)
{
    scanf(""%s"", array[i]);
    array[i+1] = array[i] + strlen(array[i]) + 1;
}
</code></pre>

<p>to scan each string into the first available space in <code>num[]</code>, and set the next element of <code>array[]</code> to point to the next available space.  Now your <code>printf()</code> of the strings will work.  The original was scanning every string into the start of <code>num[]</code>.</p>

<p>Note: <code>scanf()</code> with unadorned <code>%s</code> is as bad as <code>gets()</code>, because it puts no limit on the amount of data that will be slurped in.  Don't use it in real code.</p>

<p>Replace</p>

<pre><code>    printf(""%d %p\n"", i, &amp;array[i]); //print (array index) (array address) 
</code></pre>

<p>with</p>

<pre><code>    printf(""%d %p\n"", i, (void*)(array[i])); //print (array index) (array address) 
</code></pre>

<p>to actually print the addresses stored in <code>a[]</code>, rather than the addresses of the elements of <code>a[]</code>.  The cast is required because <code>%p</code> expects a pointer-to<code>void</code> so you must provide one.</p>
",0
898698,895628,0,"<p>It's for such things that C++ seems to be made. User input parsing and dynamic allocations are done more securely, and in a breeze.
I can't think of a system where you've got that kind of a user interface, where you couldn't switch to C++.</p>

<p>Of course, if this is only a testing excerpt from other code that suffers from the problem, then of course...</p>

<hr>

<p>Your code suffers from several common mistakes for C beginners and things that should not be done that way nowadays.</p>

<p>If I understand correctly, you want to save sereval user input strings (your example output is a bit misleading, because you show only numbers).</p>

<p>You are preparing the array to hold all (cases count) pointers to strings, but you are only reserving memory for one string. You need to do that for every string, so cases. To keep things simple in terms of the ""dynamic memory allocation"" lesson, I recommend to do it that way: <code>char* array[cases][10000];</code> That gives you cases strings of 10k characters.</p>

<p>You probably also do not want to have separate pointers to your array elements. This starts to make sense if you want to sort elements of an array when those elements are larger than the pointers itself. In that case, your gain in performance is not to have move (copy) large chunks, but only the pointers (usually 4 bytes). In your case, an int is also 4 bytes long. And you do not sort anyway :)</p>

<p><code>scanf()</code> is dangerous, to say the least. In your second application, you are instructing it to write a string to the address of the array. This seems to be a simple mistake, but can lead to many problems. You probably want to do it that way: <code>scanf(""%d"", &amp;array[i]);</code> (Unfortunately, I do not have a compiler at hand, so I am not 100% sure). drop the next line :)</p>

<hr>

<p>Question to Markdown specialists: Why is it so damn impossible to have LISTS combined with CODE-blocks ?</p>
",0
1213335,1213211,0,"<p>The code gives segmentation fault due to illegal memory access, fprintf looks for null character to terminate and in this process accesses invalid memory location.<br> Also file pointers must be checked for null and code should exit gracefully if any of them is null otherwise it will also cause a segfault.</p>
",0
1213231,1213211,10,"<p>Because character is not a string.</p>

<p>Try fputc.</p>

<p>BTW: The c should be int, otherwise you won't be able to detect EOF. EOF > 255.</p>
",1
1213240,1213211,5,"<p><code>c==""""</code> also won't work like you think it does.</p>
",0
1213256,1213211,3,"<p>Your problem is the fprintf(""%s"") of the variable c. c is not a string, it's a single character. Replace that line with</p>

<pre><code>fprintf(fp1,""%c"",c);
</code></pre>

<p>And it will work. There are better ways to actually copy the contents of one file to another.</p>
",2
1213273,1213211,6,"<p>There are a number of things wrong with the code that might cause problems.</p>

<p><code>fp</code> and <code>fp1</code> should be checked against <code>NULL</code> after being assigned the result of <code>fopen</code> to check for file open failures.</p>

<p>The type of <code>c</code> should be <code>int</code> so that you can properly distinguish <code>EOF</code> from a valid character read correctly.</p>

<p><code>c == """"</code> attempts to compare character value with the address of a literal zero-length string.</p>

<p><code>fprintf(fp1,""%s"",c)</code> interprets that character value c as the address of a constant string and attempts to follow this address to print a string. This is the most likely error to cause a segmentation fault.</p>

<hr>

<p>Less important style issues.</p>

<p>The return value of <code>main</code> should be an <code>int</code>. It's portably correct even if many implementations do allow <code>void main(void)</code>.</p>

<p>As the body of your <code>if</code> clause matches what would happen if the loop ran to the end and is followed by a <code>continue</code>, it would be probably be clearer to remove this clause and apply an if statement with the opposite of what you think <code>c==""""</code> should become, to what is currently the <code>else</code> statement.</p>
",0
1610059,1513090,0,"<p>I unrolled the beginning and the end of the cycles to eliminate min() and max() from the code:</p>

<pre><code>void smooth_B(int dim, struct pixel src[dim][dim], struct pixel dst[dim][dim]){
  dst[0][0].red  =(src[0][0].red  +src[1][0].red  +src[0][1].red  +src[1][1].red  )/4;
  dst[0][0].green=(src[0][0].green+src[1][0].green+src[0][1].green+src[1][1].green)/4;
  dst[0][0].blue =(src[0][0].blue +src[1][0].blue +src[0][1].blue +src[1][1].blue )/4;
  for( int j=1; j&lt;dim-1; j++){
    dst[0][j].red  =(src[0][j-1].red  +src[1][j-1].red  +src[0][j].red  +src[1][j].red  +src[0][j+1].red  +src[1][j+1].red  )/6;
    dst[0][j].green=(src[0][j-1].green+src[1][j-1].green+src[0][j].green+src[1][j].green+src[0][j+1].green+src[1][j+1].green)/6;
    dst[0][j].blue =(src[0][j-1].blue +src[1][j-1].blue +src[0][j].blue +src[1][j].blue +src[0][j+1].blue +src[1][j+1].blue )/6;
  }
  dst[0][dim-1].red  =(src[0][dim-2].red  +src[1][dim-2].red  +src[0][dim-1].red  +src[1][dim-1].red  )/4;
  dst[0][dim-1].green=(src[0][dim-2].green+src[1][dim-2].green+src[0][dim-1].green+src[1][dim-1].green)/4;
  dst[0][dim-1].blue =(src[0][dim-2].blue +src[1][dim-2].blue +src[0][dim-1].blue +src[1][dim-1].blue )/4;

  for( int i=1; i&lt;dim-1; i++){
    dst[i][0].red  =(src[i-1][0].red  +src[i-1][1].red  +src[i][0].red  +src[i][1].red  +src[i+1][0].red  +src[i+1][1].red  )/6;
    dst[i][0].green=(src[i-1][0].green+src[i-1][1].green+src[i][0].green+src[i][1].green+src[i+1][0].green+src[i+1][1].green)/6;
    dst[i][0].blue =(src[i-1][0].blue +src[i-1][1].blue +src[i][0].blue +src[i][1].blue +src[i+1][0].blue +src[i+1][1].blue )/6;
    for( int j=1; j&lt;dim; j++){
      dst[i][j].red  =(src[i-1][j-1].red  +src[i][j-1].red  +src[i+1][j-1].red  +src[i-1][j].red  +src[i][j].red  +src[i+1][j].red  +src[i-1][j+1].red  +src[i][j+1].red  +src[i+1][j+1].red  )/9;
      dst[i][j].green=(src[i-1][j-1].green+src[i][j-1].green+src[i+1][j-1].green+src[i-1][j].green+src[i][j].green+src[i+1][j].green+src[i-1][j+1].green+src[i][j+1].green+src[i+1][j+1].green)/9;
      dst[i][j].blue =(src[i-1][j-1].blue +src[i][j-1].blue +src[i+1][j-1].blue +src[i-1][j].blue +src[i][j].blue +src[i+1][j].blue +src[i-1][j+1].blue +src[i][j+1].blue +src[i+1][j+1].blue )/9;
    }
    dst[i][dim-1].red  =(src[i-1][dim-2].red  +src[i][dim-2].red  +src[i+1][dim-2].red  +src[i-1][dim-1].red  +src[i][dim-1].red  +src[i+1][dim-1].red  )/6;
    dst[i][dim-1].green=(src[i-1][dim-2].green+src[i][dim-2].green+src[i+1][dim-2].green+src[i-1][dim-1].green+src[i][dim-1].green+src[i+1][dim-1].green)/6;
    dst[i][dim-1].blue =(src[i-1][dim-2].blue +src[i][dim-2].blue +src[i+1][dim-2].blue +src[i-1][dim-1].blue +src[i][dim-1].blue +src[i+1][dim-1].blue )/6;
  }
  dst[dim-1][0].red  =(src[dim-2][0].red  +src[dim-2][1].red  +src[dim-1][0].red  +src[dim-1][1].red  )/4;
  dst[dim-1][0].green=(src[dim-2][0].green+src[dim-2][1].green+src[dim-1][0].green+src[dim-1][1].green)/4;
  dst[dim-1][0].blue =(src[dim-2][0].blue +src[dim-2][1].blue +src[dim-1][0].blue +src[dim-1][1].blue )/4;
  for( int j=1; j&lt;dim; j++){
    dst[dim-1][j].red  =(src[dim-2][j-1].red  +src[dim-1][j-1].red  +src[dim-2][j].red  +src[dim-1][j].red  +src[dim-2][j+1].red  +src[dim-1][j+1].red  )/6;
    dst[dim-1][j].green=(src[dim-2][j-1].green+src[dim-1][j-1].green+src[dim-2][j].green+src[dim-1][j].green+src[dim-2][j+1].green+src[dim-1][j+1].green)/6;
    dst[dim-1][j].blue =(src[dim-2][j-1].blue +src[dim-1][j-1].blue +src[dim-2][j].blue +src[dim-1][j].blue +src[dim-2][j+1].blue +src[dim-1][j+1].blue )/6;
  }
  dst[dim-1][dim-1].red  =(src[dim-2][dim-2].red  +src[dim-1][dim-2].red  +src[dim-2][dim-1].red  +src[dim-1][dim-1].red  )/4;
  dst[dim-1][dim-1].green=(src[dim-2][dim-2].green+src[dim-1][dim-2].green+src[dim-2][dim-1].green+src[dim-1][dim-1].green)/4;
  dst[dim-1][dim-1].blue =(src[dim-2][dim-2].blue +src[dim-1][dim-2].blue +src[dim-2][dim-1].blue +src[dim-1][dim-1].blue )/4;
}
</code></pre>

<p>As i measured it is faster by ~50% than the original code. The next step is the elimination of repeated calculations. </p>
",0
1502113,1502081,5,"<p>You can replace the inner loop with 8 explicit lines of code</p>

<pre><code>          dst[RIDX(dim-1-jj, i, dim)] = src[RIDX(i, jj, dim)];
          dst[RIDX(dim-1-(jj+1), i, dim)] = src[RIDX(i, (jj+1), dim)];
          ...
          dst[RIDX(dim-1-(jj+7), i, dim)] = src[RIDX(i, (jj+7), dim)];
</code></pre>

<p>so you are replacing the loop variable by explicitly writing a line for each value it takes.</p>

<p>Now you can repeat that for the 8 values of the next loop, you'll have 8 x 8 lines of code, and so on.</p>

<p>As anything other than an exercise in understanding, this seems pretty pointless to me, compilers do this kind of stuff really efficiently, they'll optimise where it makes sense. Hand-rolling rarely produces optimal code.</p>
",1
1502137,1502081,3,"<pre>
gcc -funrull-loops
</pre>

<p>You shouldn't unroll loops yourself unless GCC cannot do it (look at the assembly) and you've proven by using a profiler that you have to speed up this part of the code.</p>

<p>That example code you have looks like a perfect candidate for automatic loop unrolling.</p>

<p>Some other useful flags:</p>

<pre>
-O3                          // turns on a lot of optimizations (almost all)
-ftree-vectorize -msse2      // vectorizes automatically some loops
</pre>
",0
1504348,1502081,4,"<p>I wanted to say profile it - but then I did so myself.
The surprising part is - the inner loop performs fastest with exactly your
layout - unrolling it by hand is actually slower.</p>

<p>However - the real catch is the RIDX macro. Switching the memory layout and switching the
outer loops has a <em>significant</em> impact.</p>

<p>Here's my fastest version with indentation to show where it differs from your version.
The RIDX macro is assumed to be as defined.</p>

<pre><code>#define RIDX(x,y,d) (x+(y)*(d))
typedef unsigned char pixel;
void rotate8(int dim, pixel *src, pixel *dst)
{
    int i, j, ii, jj;
        for(jj = 0; jj &lt; dim; jj += 8)
    for(ii = 0; ii &lt; dim; ii += 8)
              for (i = ii; i &lt; ii + 8; i++)
                  for (j = jj; j &lt; jj + 8; j++)
                      dst[RIDX(dim-1-j, i, dim)] = src[RIDX(i, j, dim)];
}
</code></pre>

<p>... lesson learned: Always profile :-)</p>
",0
1507162,1502081,0,"<p><a href=""http://www.relisoft.com/book/lang/pointer/2ptrarr.html"" rel=""nofollow noreferrer"">http://www.relisoft.com/book/lang/pointer/2ptrarr.html</a></p>

<p>If your compiler is unable to optimize the human readable, maintainable version of the algorithm, and you have to double as a human compiler-- buy a new compiler! Nobody can afford human compilers any more. So, have mercy on yourself and your fellow programmers who will have to look at your code. </p>
",0
1525077,1525050,10,"<p>Example init for linux may look like this:</p>

<pre><code>int flags;
s = socket(PF_INET, SOCK_STREAM, IPPROTO_IP) // ret 5
setsockopt(s, SOL_TCP, TCP_NODELAY, [1], 4) 
setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, [1], 4) 
setsockopt(s, SOL_SOCKET, SO_REUSEADDR, [1], 4) 
flags = fcntl(s,F_GETFL,0);
assert(flags != -1);
fcntl(s, F_SETFL, flags | O_NONBLOCK);
connect(s, {sa_family=AF_INET, sin_port=htons(5001), sin_addr=inet_addr(""192.168.0.68"")}, 16)
</code></pre>

<p>Basic white paper from sun: </p>

<p><a href=""http://docs.oracle.com/cd/E23824_01/html/821-1602/sockets-22932.html#sockets-40"" rel=""noreferrer"" title=""Solaris 11 Programming Interfaces Guide: Asynchronous Socket I/O"">sun asych net</a></p>

<p>On windows You use Overlapped IO sockets to get non blocking networking.</p>

<p><a href=""http://en.wikipedia.org/wiki/Overlapped_I/O"" rel=""noreferrer"">Look here and in MSDN how to write code with OVERLAPPED structures</a></p>

<p>On Linux use epoll().</p>

<p>On solaris socket().</p>

<p>Be aware to read or write to a socket when it's not ready.
(select-output) Because You may receive EAGAIN error.</p>

<p>Great cross platform library (but C++ and new c++ standard candidate) is boost::asio.</p>

<p>It uses native system asynchronous methods.</p>

<p><a href=""http://www.boost.org/doc/libs/1_37_0/doc/html/boost_asio.html"" rel=""noreferrer"">boost::asio</a></p>
",1
1516379,1516358,1,"<p>How 'bout a way to do it that's not tied to the matrix size?  You have to rewrite the entire method for a 5x5, 6x6...nxn matrix.  A better way?  Why not nested looping over all rows and columns?  I definitely would not use the C-style printing, because I don't want to deal with creating the formating string.  Just use the cout stream.</p>

<p>I'd also recommend that you either pass in the matrix to be printed, to keep things generic, or make this a method on your Matrix class so it operates on its data members.  You do have a matrix class, don't you?  If I recall correctly, C++ is an object-oriented language.</p>
",2
1516390,1516358,2,"<p>This is a simple way, just replace <code>cout</code> with <code>printf</code>! Although I like C++ streams more because they are more elegant IMO:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;

template &lt;std::size_t rows, std::size_t columns&gt;
void printMatrix(double (&amp;matrix)[rows][columns], int dec)
{
    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(dec);
    for(std::size_t r = 0; r &lt; rows; r++)
    {
        for(std::size_t c = 0; c &lt; columns; c++)
        {
            std::cout &lt;&lt; matrix[r][c] &lt;&lt; '\t';
        }
        std::cout &lt;&lt; '\n';
    }
}

int main()
{
    double matrix[4][4];

    printMatrix(matrix, 2);
}
</code></pre>
",2
1516392,1516358,4,"<p>How about:</p>

<pre><code>void print( int decimals = 2 )
{
    int dimension = 4;
    for(int i = 0; i &lt; dimension; i++) {
        for(int j = 0; j &lt; dimension; j++) {
            printf(""%.*f"", decimals, matrix[i][j]);
            if(j == dimension - 1) printf(""\n"");
            else                   printf("" "");
        }
    }
}
</code></pre>
",3
1516421,1516358,1,"<p>In <strong>C</strong>, with no default arguments. I also don't like the global variable, so I made <code>m</code> a parameter.</p>

<pre><code>#include &lt;stdio.h&gt;
void print(double *m, int decs) {
  int k;
  for (k=0; k&lt;16; k++) {
    printf(""%.*f"", decs, *m++);
    if (k%4 == 3) puts("""");
    else putchar(' ');
  }
}

int main(void) {
  double m[4][4] = {{1/5,1/6,1/9,-1/4}, {0,1/4,-1/7,1/16},
                    {1/2,-1/2,1/3,-1/3}, {1/1,1/2,1/3,1/4}};
  print(&amp;m[0][0], 2);
  return 0;
}
</code></pre>

<hr>

<p>Edit: size passed in parameters</p>

<pre><code>#include &lt;stdio.h&gt;
void print(double *m, int cols, int rows, int decs) {
  int k, s = cols*rows;
  for (k = 0; k &lt; s; k++) {
    printf(""%.*f"", decs, *m++);
    if ((k + 1) % cols) putchar(' ');
    else                puts("""");
  }
}

int main(void) {
  double m[4][4] = {{1/5,1/6,1/9,-1/4}, {0,1/4,-1/7,1/16},
                    {1/2,-1/2,1/3,-1/3}, {1/1,1/2,1/3,1/4}};
  print(&amp;m[0][0], 4, 4, 2);
  return 0;
}
</code></pre>
",0
1516474,1516358,3,"<p>Super bonus points for a preprocessor based solution the (wo)man said.  Here we go, with big thanks to all people who helped me to get to this.</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define MADU(matrix,decimals,dimension) ({ \
    for(int i = 0; i &lt; dimension; i++) { \
        for(int j = 0; j &lt; dimension; j++) { \
            printf(""%.*f%c"", decimals, matrix[i][j],(j==dimension-1)?'\n':' '); \
        } \
    } \
})

/*
 * 
 */
int main(int argc, char** argv) {
    double a[4][4];

    MADU(a,2,4);

    return (EXIT_SUCCESS);
}
</code></pre>

<p>Please note that this does not really reflect what I would call a good solution.</p>
",0
1516653,1516358,1,"<p>Preprocessor ? This actually sounds like a challenge. Wonder if Boost.Preprocessor is compatible with C but I don't see any reason why it should not. Warning, I won't bother with the includes or the 'wrap-line' marks ;)</p>

<pre><code> // The formatting of sprintf
 #define PRINT_FORMAT_ELEM(z,n,data) // data is the nbColumns (or -1)
   BOOST_PP_EXPR_IF(
     BOOST_PP_EQUAL(
       BOOST_PP_ADD(n, 1),
       data
     ),
     ""%%.%%df\n"",
     ""%%.%%df ""
   )

 #define PRINT_FORMAT_LINE(z,n,data) // data is (nbRows, nbColumns)
   BOOST_PP_REPEAT(
     data,
     PRINT_FORMAT_ELEM,
     BOOST_PP_EXPR_IF(
       BOOST_PP_EQUAL(
         BOOST_PP_ADD(n, 1),
         BOOST_PP_TUPLE_ELEM(2,0,data)
       ),
       -1, // no \n on the last line
       BOOST_PP_TUPLE_ELEM(2,1,data)
     )
   )


 #define PRINT_FORMAT(nbRows, nbColumns)
   BOOST_PP_REPEAT(
     nbRows,
     PRINT_FORMAT_LINE,
     (nbRows, nbColumns)
   )


 // The decimals
 #define PRINT_MATRIX_ELEM(z,n,data) // data is (decimals, notLastRow, nbColumns)
   BOOST_PP_ELEM(3, 0, data)
   BOOST_PP_COMMA_IF(
     BOOST_PP_AND(
       BOOST_PP_TUPLE_ELEM(3, 1, data),
       BOOST_PP_NOT_EQUAL(
         BOOST_PP_ADD(n,1),
         BOOST_PP_TUPLE_ELEM(3, 2, data)
       )
     )
   )

 #define PRINT_DECIMAL_LINE(z, n, data) // data is (decimals, nbRows, nbColumns)
   BOOST_PP_REPEAT(
     BOOST_PP_TUPLE_ELEM(3, 2, data),
     PRINT_MATRIX_ELEM,
     (
       BOOST_PP_TUPLE_ELEM(3, 0, data),
       BOOST_PP_NOT_EQUAL(
         BOOST_PP_ADD(n,1),
         BOOST_PP_TUPLE_ELEM(3, 1, data)
       ),
       BOOST_PP_TUPLE_ELEM(3, 2, data)
     )
   )

 #define PRINT_DECIMALS(decimals, nbRows, nbColumns)
   BOOST_PP_REPEAT(
     nbRows,
     PRINT_DECIMAL_LINE,
     (decimals, nbRows, nbColumns)
   )


 // The matrix itself
 #define PRINT_MATRIX_LINE(z, n, data) // data is (name, nbRows, nbColumns)
   BOOST_PP_REPEAT(
     BOOST_PP_TUPLE_ELEM(3, 2, data),
     PRINT_MATRIX_ELEM,
     (
       BOOST_PP_TUPLE_ELEM(3, 0, data)[n],
       BOOST_PP_NOT_EQUAL(
         BOOST_PP_ADD(n,1),
         BOOST_PP_TUPLE_ELEM(3, 1, data)
       ),
       BOOST_PP_TUPLE_ELEM(3, 2, data)
     )
   )

 #define PRINT_MATRIX_IMPL(name, nbRows, nbColumns)
    BOOST_PP_REPEAT(
      nbRows,
      PRINT_MATRIX_LINE,
      (name, nbRows, nbColumns)
    )


 // And the whole thing
 #define PRINT_MATRIX(string, decimals, name, nbRows, nbColumns)
   sprintf(string,
     PRINT_FORMAT(nbRows, nbColumns),
     PRINT_DECIMALS(decimals, nbRows, nbColumns)
   );

   printf(string,
          PRINT_MATRIX_IMPL(name, nbRows, nbColumns)
   )


 // And now your code:
 void print(int decimals)
 {
   char fmtString[300];

   PRINT_MATRIX(fmtString, decimals, m, 4, 4);
 }
</code></pre>

<p>Anyone helps with the code review ;) ?</p>
",0
1021726,1021717,0,"<p>In the .h files you should place function prototypes. For example, in your code you should have:</p>

<pre><code>//file.h
void print(void);

//file.c
void
print(void)
{
   printf(""Hello world\n"");
}
//file main.c  
#include &lt;stdio.h&gt;
#include ""file.h""

int main(int argc, char *argv[]){

    print();

    return EXIT_SUCCESS;
}
</code></pre>
",2
1021727,1021717,6,"<p>You're going to have problems if you include file.c in more than one source code file which combine to make a library/executable, since you'll have duplicate method implementations. The above strikes me as a poor means of sharing/reusing code, and is not to be recommended.</p>
",0
1021729,1021717,9,"<p>Nothing prevents you from including .c files. However, separating declaration (in .h files) and implementation (and .c files) and then including only .h files has several advantages :</p>

<ul>
<li><p>Compile time. Your declaration usually changes less than your implementation. If you include only .h files, and makes a change in your implementation (in the .c file), then you only have to recompile one .c file, instead of all the files which include the modified file.</p></li>
<li><p>Readability and management of interfaces. All your declarations can be checked in a single glance at the (usually) small .h file whereas the .c file is filled with lines and lines of code. Moreover it helps you determine which file see which functions and variables. For example, to avoid having a global variable included where you don't want it.</p></li>
</ul>
",0
1021731,1021717,9,"<p>It's a common expectation that the compiler should compile <code>.c</code> files. <code>.h</code> files are not directly given to the compiler. They are usually only included within <code>.c</code> files. </p>

<p>Thus, your code is expected to compile by something like:</p>

<pre><code>gcc main.c file.c 
</code></pre>

<p>rather than only <code>gcc main.c</code>. That command would fail in the linking stage as it sees duplicate symbols.</p>
",0
1021732,1021717,0,"<p>There is nothing wrong from a C language perspective with including a .c file in a program.  The C language cares not about the extension of the file, C++ in fact often omits an extension on certain header files to avoid conflicts.</p>

<p>But from the perspective of a programmer, yeah this is odd.  Most programmers will operate on the assumption that a .c file will not be included and this can cause problems via incorrect assumptions.  It's best to avoid this practice.  If you find you must use it, it's a sign of poor design.</p>
",0
1021742,1021717,2,"<p>Yes, this is permitted.</p>

<p>Using this is an advanced topic.</p>

<ul>
<li>It slows down development compile time (cheaper to compile only what is necessary).</li>
<li>It speeds up deployment compile time (all files are out of date).</li>
<li>It allows the compiler to inline functions across module boundaries.</li>
<li>It allows a trick to control exported symbols from a library while keeping it modular.</li>
<li>It might confuse the debugger.</li>
</ul>
",0
1021757,1021717,2,"<p>It is not uncommon to include data in another file if it is more convenient to separate it from the code. For example, XPM or raw BMP data in a char array could be included to embed an image in the program in this way. If the data is generated from another build step then it makes sense to include the file.</p>

<p>I would suggest using a different file extension to avoid confusion (e.g. *.inc, *.dat, etc.).</p>
",0
1021784,1021717,0,"<p>There are only two reasons that I know of for including C files (and which make sense):</p>

<ul>
<li>inline functions which are non trivial, but that's really a matter of style</li>
<li>share implementation of private (static) functions by including the same file in several other files. That's actually the only way to do it in a purely platform independent way (but toolchain specific tricks like hidden attribute for gcc, etc... are much better if they are available)</li>
</ul>

<p>The flaws:</p>

<ul>
<li>you compile several times the same code</li>
<li>if not used sparingly, it quickly leads to multiple defined symbols for public symbols, in a way which is difficult to debug (include files which include other files...)</li>
</ul>
",0
1021805,1021717,0,"<p>It is bad style, but one other reason to do it is that it can be used a part of a trick using the <a href=""http://en.wikipedia.org/wiki/C_preprocessor#Token_concatenation"" rel=""nofollow noreferrer""><code>##</code> token concatenation operator</a> to do a kind of poor man's templating in C.</p>

<p>Note that this fairly evil, isn't recommended, and will produce code that's hard to debug and maintain, but you <em>can</em> do something like the following:</p>

<p>mytemplate.c:</p>

<pre><code>MyTemplateFunction_ ## MYTYPE(MYTYPE x)
{
  // function code that works with all used TYPEs
}
</code></pre>

<p>main.c:</p>

<pre><code>#define MYTYPE float
#include ""mytemplate.c""
#undef MYTYPE

#define MYTYPE int
#include ""mytemplate.c""
#undef MYTYPE

int main(int, char*)
{
  float f;
  int i;
  MyTemplateFunction_float(f);
  MyTemplateFunction_int(i);
  return 0;
}
</code></pre>
",0
1021922,1021717,0,"<p>The evils of macros can be exacerbated:</p>

<p>file1.c</p>

<pre><code>#define bottom arse
</code></pre>

<p>file2.c</p>

<pre><code>int f()
{
    int arse = 4;
    bottom = 3;
    printf(""%d"", arse);
}
</code></pre>

<p>main.c</p>

<pre><code>#include ""file1.c""
#include ""file2.c""

void main()
{
    f();
}
</code></pre>

<p>Indeed a convoluted example. But usually you wouldn't notice it because a macro's scope is the file it is in.</p>

<p>I did actually get this bug, I was importing some lib code into a new project and couldn't be bothered to write the Makefile, so I just generated an all.cpp which included all the sources from the library. And it didn't work as expected due to macro pollution. Took me a while to figure it out.</p>
",0
1852397,1852299,1,"<p>use <strong>%hx</strong> or %hd instead to indicate that you have a short variable, e.g:</p>

<pre><code>  printf(""short hex: %hx\n"", var);     /* tell printf that var is short and print out as hex */
</code></pre>

<p><strong>EDIT</strong>: Uups, I got the question wrong. It was not about printf() as I thought. So this answer might be a little bit OT.</p>

<p><strong>New</strong>: Because you are using <strong>var</strong> as an index to an array you should declare it as <strong>unsigned short</strong> (instead of short):</p>

<pre><code>unsigned short var = 0xFFFC;
printf(""%d\n"", b[var]);
</code></pre>

<p>The 'short var' could be interpreted as a negative number.</p>

<p>To be more precise:</p>

<p>You are ""underflowing"" into the negative value range: Values in the range from 0x0000 upto 0x7FFF will be OK. But values from 0x8000 upto 0xFFFF will be negative.</p>

<p>Here are some examples of <em>var</em> used as an index to array b[]:</p>

<pre><code>short var=0x0000;; // leads to b[0]        =&gt; OK
short var=0x0001;  // leads to b[1]        =&gt; OK
short var=0x7FFF;  // leads to b[32767]    =&gt; OK
short var=0x8000;  // leads to b[-32768]   =&gt; Wrong
short var=0xFFFC;  // leads to b[-4]       =&gt; Wrong

short var=32767;   // leads to the same as b[0x7FFF]   =&gt; OK
short var=32768;   // compile warning or error =&gt; overflow into 32bit range
</code></pre>
",2
1852429,1852299,1,"<p>As a refresher on the C's data types available, have a look <a href=""http://www.space.unibe.ch/comp_doc/c_manual/C/CONCEPT/data_types.html"" rel=""nofollow noreferrer"">here</a>.
There is a rule, and that concerns the usage of C, some datatypes are promoted to their integral type, for instance</p>

<pre>
char ch = '2';
int j = ch + 1;
</pre>

<p>Now look at the RHS (Right Hand Side) of the expression and notice that the <code>ch</code> will automatically get promoted as an <strong>int</strong> in order to produce the desired results on the LHS (LHS) of the expression. What would the value of <code>j</code> be? The ASCII code for '2' is 50 decimal or 0x32 hexadecimal, add 1 on to it and the value of <code>j</code> would be 51 decimal or 0x33 hexadecimal.</p>

<p>It is important to understand that rule and that explains why a data type would be 'promoted' to another data type.</p>

<p>What is the <code>b</code>? That is an array I presume that has 655532 elements correct? </p>

<p>Anyway, using a format specifier <code>%d</code> is for of type int, the value got promoted to an int, firstly, and secondly the array subscript is of type <code>int</code>, hence the usage of the <code>short var</code> got promoted and since the data size of an int is 4 bytes, it got promoted and hence you are seeing the rest of the value 0xFFFF 0xFFFC. </p>

<p>This is where the usage of <em>casting</em> comes in, to tell the compiler to <strong>cast</strong> a data type to another which explains in conjunction to Gregory Pakosz's answer above.</p>

<p>Hope this helps,
Best regards,
Tom.</p>
",3
1852436,1852299,7,"<p><code>short</code> is a signed type. It's 16 bits on your implementation. 0xFFFC represents the integer constant 65,532, but when converted to a 16 bit signed value, this is resulting in -4.</p>

<p>So, your line <code>short var = 0xFFFC;</code> sets var to -4 (on your implementation).</p>

<p>0xFFFFFFFC is a 32 bit representation of -4. All that's happening is that your value is being converted from one type to a larger type, in order to use it as an array index. It retains its value, which is -4.</p>

<p>If you actually want to access the 65,533rd element of your array, then you should either:</p>

<ul>
<li>use a larger type for <code>var</code>. <code>int</code> will suffice on 32 bit Windows, but in general <code>size_t</code> is an unsigned type which is guaranteed big enough for non-negative array indexes.</li>
<li>use an <code>unsigned short</code>, which <em>just</em> gives you enough room for this example, but will go wrong if you want to get another 4 steps forward.</li>
</ul>
",4
1852342,1852299,0,"<p>You were expecting to store JUST a 16bit variable in a 32bit-aligned memory... you see, each memory address holds a <strong>whole</strong> 32bit word (hardware).</p>

<p>The extra FFFF comes from the fact that short is a <strong>signed</strong> value, and when assigned to <strong>int</strong> (at the printf call), it got signed-extended. When extending two-complements from 16 to 32bit, the extension is done by replicating the last N bit to all other M-N on it's left. Of course, you did not intend that.</p>

<p>So, in this case, you're interested in absolute array positions, so you should declare your indexer as <strong>unsigned</strong>.</p>
",0
1852362,1852299,1,"<p>In current compilers we can't use <code>short</code> (16 bit) if write <code>short</code> use 32 bit . <br>
for example i compile same code with gcc4 in Ubuntu Linux 32 bit :</p>

<pre><code>int main(int argc, char** argv)
{
    short var = 0xFFFC;
    printf(""%x\n"", var);
    printf(""%d\n"", var);
    return (EXIT_SUCCESS);
}
</code></pre>

<p>and output is :</p>

<pre><code>fffffffc
-4
</code></pre>

<p>you can see cast short to 32bit normal and use sign extension in 2's complement </p>
",3
1602336,1602283,8,"<p>You need <a href=""http://opengroup.org/onlinepubs/007908799/xsh/vprintf.html"" rel=""noreferrer"">vfprintf</a>.  It will accept a variable list of arguments.</p>

<p>Like this:</p>

<pre><code>void writeToFDF(FILE *fp, char *filename, char *data, ...)
{
va_list pl;

/* independent method for writing to FDF file */

/* open file */
fp=fopen(filename,""a"");

va_start (pl, data);

vfprintf(fp,data,pl);

/* close file */
fclose(fp);
va_end(pl);
}
</code></pre>

<p>EDIT: while I tried to stay as close to your original code, ephemient's solution that omits the FILE *fp argument is in fact better: fp has only local significance (it's opened and closed in this function) so it should not be passed around.</p>
",3
1602344,1602283,2,"<p>You will need to use a Variadic function.  See <a href=""https://stackoverflow.com/questions/150543/forward-an-invocation-of-a-variadic-function-in-c/150616#150616"">Forward an invocation of a variadic function in C</a></p>
",0
1602350,1602283,5,"<p>This is what <code>vfprintf</code> is for.</p>

<pre><code>#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;

void writeToFDF(const char *filename, const char *format, ...) {
    va_list ap;
    FILE *fp = fopen(filename, ""a"");
    va_begin(ap, format);
    vfprintf(fp, format, ap);
    va_end(ap);
    fclose(fp);
}
</code></pre>
",3
1602354,1602283,1,"<pre><code>   #include &lt;stdio.h&gt;
   #include &lt;stdarg.h&gt;

   void foo(FILE *file, char *fmt, ...)
   {
       va_list ap;

       va_start(ap, fmt);
       vfprintf(file, fmt, ap);
       va_end(ap);
   }
</code></pre>
",0
1626582,1626573,31,"<p>The reason some people use method 2 is because you'll get a compiler error if you mistype a = in place of the ==.</p>

<p>However, you'll have people (like me) who will still use method 1 because they find it more readable and if there is an error, it will be detected during testing (or, in some cases, static analysis of the code).</p>
",11
1626590,1626573,10,"<p>The only difference is that ( CONST_VALUE == variable ) makes the common typo ( CONST_VALUE = variable ) impossible to compile.</p>

<p>By comparison, if ( variable = CONST_VALUE ) will result in the compiler thinking you meant to assign CONST_VALUE to 'variable'.</p>

<p>The =/== confusion is a pretty common source of bugs in C, which is why people are trying to work around the issue with coding conventions.</p>

<p>Of course, this won't save you if you're comparing two variables. </p>

<p>And the question seems to be a duplicate of <a href=""https://stackoverflow.com/questions/148298/how-to-check-for-equals-0-i-or-i-0"">How to check for equals? (0 == i) or (i == 0)</a></p>

<p>And here's some more information: <a href=""http://cwe.mitre.org/data/definitions/481.html"" rel=""nofollow noreferrer"">http://cwe.mitre.org/data/definitions/481.html</a></p>
",0
1626624,1626573,3,"<p>As others mentioned, CONST_VALUE == variable avoids the = typo. </p>

<p>I still do ""variable == CONST_VALUE"", because I think its more readable and when I see something like:</p>

<pre><code>if(false == somevariable)
</code></pre>

<p>my bloodpressure goes up. </p>
",1
1626819,1626573,2,"<p>The first variant</p>

<pre><code>if (variable == CONST_VALUE) 
</code></pre>

<p>is better, because it is more readable. It follows the convention (also used in mathematics) that the value that changes most comes first.</p>

<p>The second variant</p>

<pre><code>if (CONST_VALUE == variable)
</code></pre>

<p>is used by some people to prevent a mixup of equality checking with the assignment</p>

<pre><code>if (CONST_VALUE = variable)
</code></pre>

<p>There are better ways to achieve that, for example enabling and taking heed of compiler warnings.</p>
",0
1626824,1626573,1,"<p>Others already pointed out the reason. = / == confusion. I prefer the first version because it follows the thought process more closely. Some compiler alleviate the confusion of = and == by giving a warning when it encounters something like </p>

<pre><code>if(a=b)
</code></pre>

<p>in this case  if you really wanted to do the assignation you're forced to write </p>

<pre><code>if((a=b)) 
</code></pre>

<p>which I would write then as </p>

<pre><code>if( (a=b) != 0) 
</code></pre>

<p>to avoid the confusion.</p>

<p>This said, we had in our code 1 case where we had a =/== confusion and writing it the other way round wouldn't not have aided as it was a comparison between vars.</p>
",1
1621224,1621220,18,"<p>Same reason #define macros don't -- they are for the preprocessor, which expands things like includes and defines before the compiler proper takes over.</p>
",3
1621226,1621220,10,"<p>lines starting with a # aren't part of the C language itself, they are instructions for a pre-processor.  When it was first designed, semi-colons just wasn't required.</p>
",0
1621234,1621220,4,"<p><code>#include</code> is a pre-processing command like <code>#define</code>. <code>#include</code> tells the compiler to include the specified file in your source code before your code actually gets compiled.</p>
",1
1621727,1621220,7,"<p>""...while other statements do"".</p>

<p>Firstly, <em>preprocessor directives</em> are not <em>statements</em>. <em>Statement</em> is an entity that exists at the syntactical/semantical level only. Preprocessor directives are processed at relatively early stages of translation, before any syntax analysis begins, so at that stage there's no such thing as ""statement"" yet. And, for this reason, there's no meaningful rationale to demand ending the <code>#include</code> directive with a semicolon. If fact, preprocessor directives by definition occupy the entire line, meaning that they are already terminated by a new-line character. Any additional terminator would be redundant.</p>

<p>Secondly, not all ""other statements"" end with semicolon. A compound statement, for example, doesn't</p>

<pre><code>i = 5;

{ /* &lt;- compound statement begins here... */
  i = 10;
} /* &lt;- ... and ends here. Note: no semicolon */

i = 15;
</code></pre>
",0
1678329,1678312,5,"<p>If you just want to have a <code>fooV</code> function that returns a ""constructed"" <code>Value</code> struct, you can rewrite <code>fooV</code> as follows:</p>

<pre><code>Value fooV() {
    Value v;
    v.id = 10;
    v.type = 'L';
    v.a = 'R';
    return v;
}
</code></pre>

<p>and you would call this function like:</p>

<pre><code>Value v = fooV();
</code></pre>

<p>Otherwise, if you need a function that modifies a <code>Value</code> struct that you already have, you have two options:  you either need to change the return type of <code>fooV</code>:</p>

<pre><code>Value fooV(Value v){
    v.id = 10;
    v.type = 'L';
    v.a = 'R';
    return v;
}
</code></pre>

<p>in which case you would call it like:</p>

<pre><code>v = fooV(v);
</code></pre>

<p>or change fooV to accept a pointer to a <code>Value</code>:</p>

<pre><code>void fooV(Value* v){
    v-&gt;id = 10;
    v-&gt;type = 'L';
    v-&gt;a = 'R';
}
</code></pre>

<p>in which case you would call it like:</p>

<pre><code>fooV(&amp;v);
</code></pre>
",3
1678330,1678312,10,"<p>You need to pass v in <em>by reference</em>, which is done using pointers in C:</p>

<pre><code>void fooV(Value* v)
{
    (*v).id = 10;
    (*v).type = 'L';
    (*v).a = 'R';
}
</code></pre>

<p>Or use the -> shorthand operator:</p>

<pre><code>void fooV(Value* v)
{
    v-&gt;id = 10;
    v-&gt;type = 'L';
    v-&gt;a = 'R';
}
</code></pre>

<p>And don't forget to pass v's address:</p>

<pre><code>fooV(&amp;v);
</code></pre>
",3
1678335,1678312,1,"<p>And change the second printf to use the values of v, not the variable id, type, a.</p>

<pre><code>printf(""id: %d, type: %c, a: %c \n"",v.id,v.type,v.a);
</code></pre>
",0
1674211,1674117,0,"<p>Your question is tagged C++. In C++ you can just take a standrad implementation of associative array and prepare your data as follows</p>

<pre><code>#include &lt;string&gt;
#include &lt;map&gt;
...
std::map&lt;std::string, std::string&gt; name2address;
name2address[""Fred""] = ""1234 Evergreen Terrace"";
name2address[""Pete""] = ""4567 State Street"";
name2address[""Mark""] = ""123 North Street"";
</code></pre>

<p>Then, once you have the requested name</p>

<pre><code>char Name[32];
gets(Name);
// I leave it as is, but using `gets` is always nasty. And you might be much 
// better off with a 'std::string' instead in this case
</code></pre>

<p>you can find the addreess and print it</p>

<pre><code>std::string address = name2address[Name];
// Add a check for whether it actually exists

printf(""You live at %s\n"", address.c_str());
// Again, I leave `printf` as is
</code></pre>
",0
1674212,1674117,0,"<p>Depending on how complicated the rest of what you're dealing with is, you should consider putting these into a class.  A class can keep a name and address associated with each other as well.</p>

<pre><code>class person
{
  char[32] name;
  char[32] address;
  /* whatever else you need to know about the people */

  /* whatever functions you'd need to run on them */
}
</code></pre>

<p>then create a map of these classes, again using the name</p>

<pre><code>std::map&lt;string,person&gt; person_list;
</code></pre>
",0
1674218,1674117,0,"<p>You tagged your question C++, and in the C++ STL library you can use the map container to map names to addresses in your case.  Some example code for your problem below, using the STL string instead of char arrays, which you may find preferable:</p>

<pre><code>// Set up your map
#include &lt;map&gt;
#include &lt;string&gt;
using std;

map&lt;string, string&gt; myMap;

myMap[""Fred""] = ""1234 Evergreen Terrace"";
myMap[""Pete""] = ""4567 State Street"";
myMap[""Mark""] = ""123 North Street"";
</code></pre>

<p>And once you have your map set up, and you've read the user input into a string variable name, you would use something like:</p>

<pre><code>if(myMap.find(name) != myMap.end())
{
    printf(""You live at %s\n"", myMap[name].c_str());
}
else
{
    printf(""I don't know where you live"");
}
</code></pre>

<p>Hope that helps!</p>
",0
1674238,1674117,0,"<p>Casting is the direct, unambigous, conversion from one thing to another thing enforced (mostly) at compile time. There's: </p>

<ul>
<li><p>Casting of built-in types that can be legally converted to each-other (<strong>static_cast</strong>). An example to this is int->double conversion:</p>

<p>double d = 5.0;
int i = static_cast(d);</p></li>
<li><p>Telling the compiler to treat the data at address X like a different type (<strong>reinterpret_cast</strong>). This is similar to a union.</p>

<p>struct Message
{
    int header;
    int contents;
    //...
};</p>

<p>char* myDataBuffer;
Message* interpretedAsAMessage = reinterpret_cast(myDataBuffer).</p></li>
<li><p>There's legal casting up/down an inheritance hierarchy (<strong>dynamic_cast</strong>):</p>

<p>class Base
{
};</p>

<p>class Derrived : public Base
{
};</p>

<p>Derrived* d = new Derrived();
Base* b = dynamic_cast(d)
// b will be null if types aren't related.</p></li>
<li><p>There's removing constness from a variable to be able to manipulate it (<strong>const_cast</strong>)</p>

<p>const int size = 5;
int&amp; sizeRef = const_cast(size);
size++;</p></li>
<li><p>Then you'll also see the C-style cast, which is more ambigous, and doesn't tell you or the compiler explicitly what kind of cast is happening.</p>

<p>double d = 5.0;
int i = (int)(d);</p></li>
</ul>

<p>There' In your case ou expect the resultant type to be formatted a specific way. In the above examples, the result is unambigous and clear. There's no way to specify how a resultant string would be formatted in the above examples. You need to take an approach similar to what you have or what thers have posted.</p>
",0
1674153,1674117,11,"<ul>
<li>Use an std::map of string--> string.</li>
<li>Take a string from the input</li>
<li>if it is in the map, print it</li>
</ul>

<p>Sample:</p>

<pre><code>#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    typedef std::map&lt; std::string, std::string &gt; MapType;
    MapType names;

    names.insert(std::make_pair(""Fred"", ""1234 Evergreen Terrace""));
    names.insert(std::make_pair(""Pete"", ""4567 State Street""));
    names.insert(std::make_pair(""Mark"", ""123 North Street""));

    std::string input;
    std::cin &gt;&gt; input;
    MapType::iterator it = names.find(input);
    if(it != names.end())
        std::cout &lt;&lt; input  &lt;&lt; ""lives at: "" &lt;&lt; it-&gt;second &lt;&lt; std::endl;

    return 0;
}
</code></pre>
",2
1674158,1674117,3,"<p>Look <a href=""http://www.cplusplus.com/reference/stl/map/"" rel=""nofollow noreferrer"">maps in the STL</a></p>

<pre><code>using namespace std;
map&lt;string, string&gt; lookup( map&lt;string,string&gt; );
lookup[""Fred""] = string( ""1234 Evergreen Terrace"" );
...
string name( ""Fred"" ); // or other values 

cout &lt;&lt; ""You live at "" &lt;&lt; lookup[name];
//Alternative using find to deal with missing name

map&lt;string,string&gt;::iterator address( lookup.find( name ) );   //Edited to use find
if ( address != map.end() ) { 
  cout &lt;&lt; ""You live at "" &lt;&lt; lookup[name];
}
</code></pre>
",4
1674161,1674117,2,"<p>What you need is a map.  A data structure that will map your names -> addresses.  </p>

<p>Try making a structure like this:</p>

<pre><code>struct person {
    char name[32];
    char address[256];
}
</code></pre>

<p>Then create an array of person structures:</p>

<pre><code>struct person[] = {
    {""fred"", ""1234 Evergreen Terrace""},
    {""pete"", ""4567 State Street""},
    {""mark"", ""123 North Street""}
};

int numberOfPeople = 3;
</code></pre>

<p>Then when you need to find one you can search it this way:</p>

<pre><code>for(int index = 0; index &lt; numberOfPeople; index++) {
    if(!strcmp(person[index].name, name)) {
        printf(""You live at %s.\n"");
    }
}
</code></pre>

<p>Obviously there are many more advanced ways of doing this.  I'd suggest reading up on classes and hashmaps.  A class is a more advanced version of a structure that allows you to do all sorts of neat stuff.  A hash map is a data structure that uses something called a hash function to use your string as a key that finds the correct address.</p>

<p>Or rather than learning about exactly how maps work and making your own, you could always be lazy and just use std::map ;)</p>
",0
1674166,1674117,2,"<p>You could store the names and addresses in an associative container such as an STL map with the name being the key and the address being the value. </p>

<pre><code>std::map&lt;std::string, std::string&gt; people;

// ... Add the entries to the map here ...
people[""Fred""] = ""1234 Evergreen Terrace"";
people[""Pete""] = ""4567 State Street"";
people[""Mark""] = ""123 North Street"";
</code></pre>

<p>Then the single printf:</p>

<pre><code>std::map&lt;std::string, std::string&gt;::const_iterator iter = people.find(Name);
if(iter != people.end())
    printf(""You live at %s\n"", iter-&gt;second);
</code></pre>

<p>Note that you need to check for the case where the name does not already exist within the map - e.g. using find() as shown above.</p>
",4
1674174,1674117,1,"<blockquote>
  <p>Isn't there a way to skip all the <code>strcmp()</code>?</p>
</blockquote>

<p>In C++, this is spelled <code>std::map</code>: </p>

<pre><code>std::map&lt;string, string&gt; address_map;

address_map[Fred] = ""1234 Evergreen Terrace"";
address_map[Pete] = ""4567 State Street"";
address_map[Mark] = ""123 North Street"";

std::map&lt;string,string&gt;::const_iterator it = address_map.find(name);
if( it == address_map.end() ) doh();
std::cout &lt;&lt; ""You live at "" &lt;&lt; it-&gt;second &lt;&lt; '\n';
</code></pre>
",0
1674183,1674117,0,"<p>I suppose you'd want to implement some sort of dictionary (map) structure, where the name user inputs would be a key. You'd map it as string->string and if the key is in the map, then output the other string.</p>

<p>There are many ways of implementing this, you can do it by hand or you can look up std::map.</p>
",0
1085023,1085016,3,"<p>You're opening ReadMe.txt for writing:</p>

<pre><code>fopen_s( &amp;fptr2, filename, ""w"" )
</code></pre>

<p>but then passing it to <code>CharReadWrite</code>:</p>

<pre><code>CharReadWrite(fptr2);
</code></pre>

<p>which tries to read from it:</p>

<pre><code>c=fgetc(fin)
</code></pre>

<p>Did you mean to open it for reading, by passing <code>""r""</code> to <code>fopen_s</code>?</p>

<p>You also carry on and call <code>CharReadWrite</code> if opening ReadMe.txt fails.</p>
",0
1085029,1085016,1,"<p>One problem is that you are attempting to read from (and then close) <code>fptr2</code> even if you failed to open it.</p>

<p>Try:</p>

<pre><code>#include ""stdafx.h""
#include ""string.h""
#include ""stdio.h""
void CharReadWrite(FILE *fin);
FILE *fptr2;

int _tmain(int argc, _TCHAR* argv[])
{   

    char filename[]=""ReadMe.txt"";
    if (fopen_s( &amp;fptr2, filename, ""w"" ) != 0 )
    {
      printf( ""File stream %s was not opened\n"", filename );
    }
    else
    {
      printf( ""The file %s was opened\n"", filename );
      CharReadWrite(fptr2);
      fclose(fptr2);
    }
    return 0;
}
</code></pre>
",0
1085034,1085016,0,"<p>The problem is this line:</p>

<p>if (fopen_s( &amp;fptr2, filename, ""w"" ) != 0 )</p>

<p>When you pass the 'w' flag,  <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/fopen/"" rel=""nofollow noreferrer"">""Create an empty file for writing. If a file with the same name already exists its content is erased and the file is treated as a new empty file.""</a></p>

<p>Instead, use the ""r+"" flag.</p>
",0
1085036,1085016,0,"<p>You're opening file for writing and trying to read from it (fgetc) ... </p>
",0
1988789,1988786,30,"<p>Yes. There is no allocated memory to place the value <code>123</code>.</p>

<p>Like initializing a variable like <code>int</code> is not guaranteed to be <code>0</code>, an <code>int*</code> isn't guaranteed to be a safe address.</p>

<p>It also could potentially lead to data corruption.</p>
",1
1988796,1988786,29,"<p>It can, but there again it could do anything - it exhibits what the C Standard calls ""<a href=""http://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behaviour</a>"".</p>
",5
1988836,1988786,1,"<p><code>int *i;</code> This allocates a memory for pointer but this variable is not initialized so it's value is totally random. Then you dereference it so you have a random address and perform a write to this place in the memory but 1) you don't know where the place is 2) this place probably is not yours. You can fix it with initialization like <code>int * i = ( int* ) malloc( sizeof(int) )</code></p>
",3
1988845,1988786,2,"<p>Rough odds on a 32-bit operating system:</p>

<ul>
<li>Odds to trigger a hardware exception: 99.9995%</li>
<li>Odds to corrupt program state: 0.0005%</li>
<li>Odds to accidentally hit the right memory location: 1 in 2 billion</li>
</ul>

<p>Estimates only to demonstrate orders of magnitude.  Relevant only for a Release build.  If it does corrupt program state then the odds it will do so consistently climb to close to 100%.  A good compiler makes the hardware exception odds 100% in the Debug build.  Get a good compiler.</p>
",2
1988977,1988786,2,"<p>Yes, the code you posted can cause a segmentation fault.  You've got a pointer which is uninitialized (doesn't point to any known location) and you then use it to store something.  Where does the 'something' go?  Good question, to which there is no consistent answer.</p>

<p>You need to initialize that pointer.  For example:</p>

<pre><code>int target = 0;
int *i = &amp;target; 

printf(""target=%d\n"", target);
*i=123; 
printf(""target=%d\n"", target);
</code></pre>

<p>I hope this helps.</p>
",0
1989701,1988786,3,"<h1>Yes &nbsp; &nbsp;</h1>
",0
1718941,1718931,5,"<p>The problem is you're initializing a variable in a header file, so you're getting duplicate symbols.  You need to declare <code>double xxx</code> with the <code>extern</code> keyword, and then initialize it in either .c file.</p>

<p>Like so:</p>

<pre><code>#ifndef TMP1_H_1
#define TMP1_H_1

extern double xxx[3];

#endif
</code></pre>

<p>And then in one of the .c files:</p>

<pre><code>double xxx[3] = {1.0,2.0,3.0};
</code></pre>
",2
1718945,1718931,1,"<p>Don't put code in header files, it's a recipe for ""multiply-defined symbol"" linker errors.  Put an <code>extern</code> reference to your global variable in the header file, and then define the actual global in one of your C files (or even a new one).</p>
",0
1718947,1718931,0,"<p>put extern for xxx and define xxx in a .c file.</p>
",0
1408607,1408534,1,"<p>Here's one of a multitude of possible references: <a href=""http://en.wikipedia.org/wiki/C_standard_library"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/C_standard_library</a></p>
",0
1408536,1408534,4,"<p><a href=""http://en.wikipedia.org/wiki/List_of_C_functions"" rel=""nofollow noreferrer"">Okay, here you go.</a></p>
",0
1408544,1408534,4,"<p>Take a look at </p>

<p><a href=""http://www.cplusplus.com/reference/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/</a></p>

<p><a href=""http://www.gnu.org/s/libc/manual/html_node/index.html"" rel=""nofollow noreferrer"">http://www.gnu.org/s/libc/manual/html_node/index.html</a></p>

<p><a href=""http://www.cppreference.com/wiki/"" rel=""nofollow noreferrer"">http://www.cppreference.com/wiki/</a></p>
",0
1410624,1408534,4,"<p>The only <em>authoritative</em> place to look this stuff up is in the C standard.</p>

<p>The final versions of the standards cost money, but here's a copy of a post-standardisation modification of ISO C99 (that is, ISO/IEC 9899:1999), incorporating corrections published in 2001 and 2004:</p>

<p><a href=""http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1124.pdf"" rel=""nofollow noreferrer"">http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1124.pdf</a></p>

<p>If you want the C89 standard, then you may have to buy it, although you can get pre-standardisation drafts online that barely differ from the standard.</p>

<p>Do not look it up on cplusplus.com, which primarily defines the C++ versions of the functions, which are not what you want. Firstly they sometimes differ from any version of C (for example, <code>strchr</code>), and secondly C99 has introduced keyword restrict into a lot of standard function signatures.</p>

<p>Do not look it up on Wikipedia (which is incomplete). Do not even look it up in the GNU libc documentation (which in any case summarises the function descriptions), since that documents behaviour guaranteed by glibc (which you aren't even using), but not guaranteed by the standard (so other implementations will differ).</p>

<p>Actually, I confess, I often look this stuff up on opengroup.org. But that's because I'm (a) lazy, and (b) often working with POSIX systems, so the POSIX incorporation of the C standard is relevant. I would not recommend it as a reference to a beginner with C on a non-POSIX system.</p>

<p>However, since you're working on a Microsoft system, looking it up on MSDN would likewise be valid, provided you are not trying to write portable code. In fact, popular C compilers (including MS and GCC) currently implement something in between C89 and C99, so in practice you can't write ""standard C99"". You must instead consult your compiler's documentation in addition to the standard.</p>
",0
1304438,1304387,1,"<p>I am not an expert, but I think a ton of small <code>malloc</code>s can cause problems. First, you have to take care of freeing the memory after the use of the value. Then you also have to deal with the fragmentation of the free memory. Passing as pointer is more suitable for complex structures.</p>
",0
1304410,1304387,6,"<p>It is a bad idea because caller is responsible to <code>free</code> the index, otherwise you are leaking memory. Alternatively you can use <code>static int</code> and return its address every time - there will be no leaks, but function becomes non-reentrant, which is risky (but acceptable if you bear it in mind).</p>

<p>Much better would be to return pointer to char function finds, or NULL if it is not present. That's the way <code>strchr()</code> works, BTW.</p>

<p><strong>Edited</strong> to reflect changes in original post.</p>
",2
1304413,1304387,1,"<ol>
<li>The function needs to dereference the parameters, which takes more time than accessing the stack.</li>
<li>The pointers can be uninitialized, causing unexpected results.</li>
<li>There is no standard way to specify which pointer is for input, wich is for output and which is for both (there are extensions, and naming tricks, but it's still a matter).</li>
</ol>
",0
1304415,1304387,2,"<p>In the specific example, you should use <code>size_t</code> as the return type: this is the data type that adequately represents how large strings can get on any system. I.e. you can't possibly have a string that is longer than a size_t can represent. Then, you can fairly safely use <code>(size_t)-1</code> as an error indicator: realistically, you also cannot put a string with that size into memory, since you also need some address space for the code you are executing; it becomes a limitation of your API that such long strings would not be supported if they existed.</p>

<p>Your approach not only has the disadvantage using more memory, but also the disadvantage of being slower: the callee needs to malloc, the caller needs to free. Those are fairly expensive operations.</p>

<p>There is one other standard approach relevant here: errno. In case of an error indicator, you don't know what the error is. So in C, rather than using an out parameter, we typically put the error details into a global or thread-local variable.</p>
",2
1304418,1304387,1,"<p>The biggest downside is that it requires findChar()'s callers to free() the returned memory, or create a memory leak.  You've reinvented the strchr() wheel poorly.</p>

<p>I also don't see why you're thinking that returning a pointer to unsigned int is such a big step forward.  First, you could just return an unsigned int, if all you're after is the ability to return values up to 2^32 on a 32-bit machine instead of 2^31-1.  Second, your stated goal is to avoid a problem with large strings.  Well, what if you're on a 64-bit machine, where 'int' and 'unsigned int' remain 32 bits?  What you really want here is a long, but returning pointers doesn't actually help here.</p>

<p><em>ELIDED BOGUS CRITICISM</em></p>
",2
1304565,1304387,1,"<p>I'd say the most severe downside to your code is that you use one return value to represent both a general failure and the result if successful. </p>

<p>While this is a common practice, it can lead to wierd scenarios when requirements change, just like the one you described. An alternative practice would be to separate the return values, i.e. something like this</p>

<pre><code>int findChar(char ch, char const * const in, unsigned int * const index)
{
    if ( in != NULL &amp;&amp; index != NULL)
    {
        unsigned int i;
        for(i = 0; in[i]; i++)
        {
            if(in[i] == ch)
            {
                *index = i;
                return EXIT_SUCCESS;
            }
        }
    }
    return EXIT_FAILURE;
}
</code></pre>

<p>...where the function return value tells you whether the function was successful or not, separately from the value of 'index'.</p>

<p>Then again, as fortran noted, there is no way to enforce whether the pointers are input values, output values, or both (i.e. modified inside the function). </p>
",0
1304426,1304387,3,"<p>Without the malloc, the position can be still a stack variable and you can use it in an if statement:</p>

<pre><code>int findChar(char ch, char* in, int* pos)
{
    int i = 0;
    for(i = 0; in[i] != '\0'; i++) 
    {
        if(in[i] == ch) 
        {
            *pos = i;
            return 1;
        }
    }

    return 0;
}
</code></pre>
",2
1496353,1496313,12,"<p>Note this new function:</p>

<pre><code>const char* myFunction()
{
    static char array[] = ""my string"";
    return array;
}
</code></pre>

<p>I defined ""array"" as static. Otherwise when the function ends, the variable (and the pointer you are returning) gets out of scope. Since that memory is allocated on the stack, and it <strong>will</strong> get corrupted. The downside of this implementation is that the code is not reentrant and not threadsafe.</p>

<p>Another alternative would be to use <em>malloc</em> to allocate the string in the heap, and then free on the correct locations of your code. This code will be reentrant and threadsafe.</p>

<p>As noted in the comment, this is a very bad practice, since an attacker can then inject code to your application (he/she needs to open the code using GDB, then make a breakpoint and modify the value of a returned variable to overflow and fun just gets started).</p>

<p>It is much more recommended to let the caller handle about memory allocations. See this new example:</p>

<pre><code>char* myFunction(char* output_str, size_t max_len)
{
   const char *str = ""my string"";
   size_t l = strlen(str);
   if (l+1 &gt; max_len) {
      return NULL;
   }
   strcpy(str, str, l);
   return input;
}
</code></pre>

<p>Note that the only content which can be modified is the one that the user. Another side effect - this code is now threadsafe, at least from the library point of view. The programmer calling this method should verify that the memory section used is threadsafe.</p>
",2
1496366,1496313,1,"<p>If you really can't use pointers, do something like this:</p>

<pre><code>char get_string_char(int index)
{
    static char array[] = ""my string"";
    return array[index];
}

int main()
{
    for (int i = 0; i &lt; 9; ++i)
        printf(""%c"", get_string_char(i));
    printf(""\n"");
    return 0;
}
</code></pre>

<p>The magic number 9 is awful, and this is not an example of good programming. But you get the point. Note that pointers and arrays are the same thing (kind of), so this is a bit cheating.</p>
",1
1496391,1496313,5,"<p>Based on your newly-added backstory with the question, why not just return an integer from 1 to 12 for the month, and let the main() function use a switch statement or if-else ladder to decide what to print? It's certainly not the best way to go - char* would be - but in the context of a class like this I imagine it's probably the most elegant.</p>
",0
1496319,1496313,3,"<p>Your function return type is a single character (<code>char</code>). You should return a pointer to the first element of the character array. If you can't use pointers, then you are screwed. :(</p>
",0
1496324,1496313,8,"<p>Your problem is with the return type of the function - it must be:</p>

<pre><code>char *myFunction()
</code></pre>

<p>...and then your original formulation will work.</p>

<p>Note that you <em>cannot</em> have C strings without pointers being involved, somewhere along the line.</p>

<p>Also: Turn up your compiler warnings. It should have warned you about that return line converting a <code>char *</code> to <code>char</code> without an explicit cast.</p>
",1
1496327,1496313,1,"<p>A <code>char</code> is only a single one-byte character. It can't store the string of characters, nor is it a pointer (which you apparently cannot have). Therefore you cannot solve your problem without using pointers (which <code>char[]</code> is syntactic sugar for).</p>
",0
1496328,1496313,255,"<p>Your function signature needs to be:</p>
<pre><code>const char * myFunction()
{
    return &quot;my String&quot;;
}
</code></pre>
<h2>Background:</h2>
<p>It's so fundamental to C &amp; C++, but little more discussion should be in order.</p>
<p>In C (&amp; C++ for that matter), a string is just an array of bytes terminated with a zero byte - hence the term &quot;string-zero&quot; is used to represent this particular flavour of string. There are other kinds of strings, but in C (&amp; C++), this flavour is inherently understood by the language itself. Other languages (Java, Pascal, etc.) use different methodologies to understand <code>&quot;my string&quot;</code>.</p>
<p>If you ever use the Windows API (which is in C++), you'll see quite regularly function parameters like: &quot;LPCSTR lpszName&quot;. The 'sz' part represents this notion of 'string-zero': an array of bytes with a null (/zero) terminator.</p>
<h2>Clarification:</h2>
<p>For the sake of this 'intro', I use the word 'bytes' and 'characters' interchangeably, because it's easier to learn this way. Be aware that there are other methods (wide-characters, and multi-byte character systems (<em>mbcs</em>)) that are used to cope with international characters. <a href=""https://en.wikipedia.org/wiki/UTF-8"" rel=""noreferrer"">UTF-8</a> is an example of an mbcs. For the sake of intro, I quietly 'skip over' all of this.</p>
<h2>Memory:</h2>
<p>This means that a string like <code>&quot;my string&quot;</code> actually uses 9+1 (=10!) bytes. This is important to know when you finally get around to allocating strings dynamically.</p>
<p>So, without this 'terminating zero', you don't have a string. You have an array of characters (also called a buffer) hanging around in memory.</p>
<h2>Longevity of data:</h2>
<p>The use of the function this way:</p>
<pre><code>const char * myFunction()
{
    return &quot;my String&quot;;
}

int main()
{
    const char* szSomeString = myFunction(); // Fraught with problems
    printf(&quot;%s&quot;, szSomeString);
}
</code></pre>
<p>... will generally land you with random unhandled-exceptions/segment faults and the like, especially 'down the road'.</p>
<p>In short, although my answer is correct - 9 times out of 10 you'll end up with a program that crashes if you use it that way, especially if you think it's 'good practice' to do it that way. In short: It's generally not.</p>
<p>For example, imagine some time in the future, the string now needs to be manipulated in some way. Generally, a coder will 'take the easy path' and (try to) write code like this:</p>
<pre><code>const char * myFunction(const char* name)
{
    char szBuffer[255];
    snprintf(szBuffer, sizeof(szBuffer), &quot;Hi %s&quot;, name);
    return szBuffer;
}
</code></pre>
<p>That is, your program will crash because the compiler (may/may not) have released the memory used by <code>szBuffer</code> by the time the <code>printf()</code> in <code>main()</code> is called. (Your compiler should also warn you of such problems beforehand.)</p>
<p>There are two ways to return strings that won't barf so readily.</p>
<ol>
<li>returning buffers (static or dynamically allocated) that live for a while. In C++ use 'helper classes' (for example, <code>std::string</code>) to handle the longevity of data (which requires changing the function's return value), or</li>
<li>pass a buffer to the function that gets filled in with information.</li>
</ol>
<p>Note that it is impossible to use strings without using pointers in C. As I have shown, they are synonymous. Even in C++ with template classes, there are always buffers (that is, pointers) being used in the background.</p>
<p>So, to better answer the (now modified question). (There are sure to be a variety of 'other answers' that can be provided.)</p>
<h2>Safer Answers:</h2>
<p><strong>Example 1, using statically allocated strings:</strong></p>
<pre><code>const char* calculateMonth(int month)
{
    static char* months[] = {&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot; .... };
    static char badFood[] = &quot;Unknown&quot;;
    if (month &lt; 1 || month &gt; 12)
        return badFood; // Choose whatever is appropriate for bad input. Crashing is never appropriate however.
    else
        return months[month-1];
}

int main()
{
    printf(&quot;%s&quot;, calculateMonth(2)); // Prints &quot;Feb&quot;
}
</code></pre>
<p>What the <code>static</code> does here (many programmers do not like this type of 'allocation') is that the strings get put into the data segment of the program. That is, it's permanently allocated.</p>
<p>If you move over to C++ you'll use similar strategies:</p>
<pre><code>class Foo
{
    char _someData[12];
public:
    const char* someFunction() const
    { // The final 'const' is to let the compiler know that nothing is changed in the class when this function is called.
        return _someData;
    }
}
</code></pre>
<p>... but it's probably easier to use helper classes, such as <code>std::string</code>, if you're writing the code for your own use (and not part of a library to be shared with others).</p>
<p><em><strong>Example 2, using caller-defined buffers:</strong></em></p>
<p>This is the more 'foolproof' way of passing strings around. The data returned isn't subject to manipulation by the calling party. That is, example 1 can easily be abused by a calling party and expose you to application faults. This way, it's much safer (albeit uses more lines of code):</p>
<pre><code>void calculateMonth(int month, char* pszMonth, int buffersize)
{
    const char* months[] = {&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot; .... }; // Allocated dynamically during the function call. (Can be inefficient with a bad compiler)
    if (!pszMonth || buffersize&lt;1)
        return; // Bad input. Let junk deal with junk data.
    if (month&lt;1 || month&gt;12)
    {
        *pszMonth = '\0'; // Return an 'empty' string
        // OR: strncpy(pszMonth, &quot;Bad Month&quot;, buffersize-1);
    }
    else
    {
        strncpy(pszMonth, months[month-1], buffersize-1);
    }
    pszMonth[buffersize-1] = '\0'; // Ensure a valid terminating zero! Many people forget this!
}

int main()
{
    char month[16]; // 16 bytes allocated here on the stack.
    calculateMonth(3, month, sizeof(month));
    printf(&quot;%s&quot;, month); // Prints &quot;Mar&quot;
}
</code></pre>
<p>There are lots of reasons why the second method is better, particularly if you're writing a library to be used by others (you don't need to lock into a particular allocation/deallocation scheme, third parties can't break your code, and you don't need to link to a specific memory management library), but like all code, it's up to you on what you like best. For that reason, most people opt for example 1 until they've been burnt so many times that they refuse to write it that way anymore ;)</p>
<h2>Disclaimer:</h2>
<p>I retired several years back and my C is a bit rusty now. This demo code should all compile properly with C (it is OK for any C++ compiler though).</p>
",12
1496330,1496313,0,"<p>Your function prototype states your function will return a char.  Thus, you can't return a string in your function.</p>
",0
1496337,1496313,12,"<p>A C string is defined as a pointer to an array of characters.</p>

<p>If you cannot have pointers, by definition you cannot have strings.</p>
",1
1496895,1496313,2,"<p>Or how about this one:</p>

<pre><code>void print_month(int month)
{
    switch (month)
    {
        case 0:
            printf(""January"");
            break;
        case 1:
            printf(""february"");
            break;
        ...etc...
    }
}
</code></pre>

<p>And call that with the month you compute somewhere else.</p>
",2
1969120,1969106,2,"<p>think back to early grade school math.</p>

<p>What is 4 + 3 * 2?<br>
is it 14 or 10?</p>

<p>Of course, it is 10, because the addition operator has a lower precedence than the multiplication operator and so 4 + 3 * 2 ALWAYS means 4 + (3 * 2).</p>

<p>Order of operations is just the order which you evaluate sub-expressions based on their operators.</p>

<p>Parentheses, Exponents, Division, Multiplication, Addition, Subtraction. Obviously in programming (and of course math too) there are many more operators than that, but I've never heard order of operations used outside of basic fundamental maths.</p>

<p>Just wait until you find out about left-association and right-association in operators.</p>
",0
1969130,1969106,4,"<p>Precedence specifies how an expression should logically be evaluated. For example, precedence says that in the expression</p>

<p>x + y * z</p>

<p>the expression must be evaluated as x +  (y * z ).</p>

<p>However, C makes little attempt to say what must be evaluated first. In the example above, x could be evaluated first, then (y * z). Or, (y * z) could be evaluated, followed by x. There are some exceptions to this - for example the &amp;&amp; and || operators specify a particular order, but in general it's wise not to rely on ordering. </p>
",0
1969144,1969106,5,"<p>Here's a secret: I don't bother learning precedence rules. They are too easy to get wrong, and it makes the next person to look at the code think too much. To paraphrase: assume the person who maintains your code is an axe-wielding psycho who knows where you live. Be nice too them.</p>

<p>So rather than:</p>

<pre><code>x = a + b * c / d;
</code></pre>

<p>I would use:</p>

<pre><code>x = a + ((b * c) / d);
</code></pre>

<p>Or perhaps better (subjective), break it down into separate statements The trickier question, perhaps, is what happens in ""clever"" lines of code that has side-effects on expressions later in the line:</p>

<pre><code>x = Func(z) * a[i++] + i; // where Func(z) somehow mutates i
                          // (or even worse when using ""conditional"" etc)
</code></pre>

<p>Such things should be used sparingly, and you should try to know what behaviour is defined and what is explicitly undefined but works (or fails) depending on the compiler you use.</p>
",1
1969206,1969106,0,"<p>yes off course i struck up with this operators(&amp;&amp; ||) only..
++ operator has higher precedence than logical AND(&amp;&amp;) and logical OR(||). So in expression </p>

<p>m=++i&amp;&amp;++j||++k;</p>

<p>What i thought is variable i,j and k will be incremented then logical operations will be evaluated..But in actual it is not happened.variable k is not incremented..</p>

<p>Logical OR's Lvalue has been TRUE so it never considered its R values execution...
Hence variable k is not incremented..But what happened to the precedence of the ++ operator..Why Logical operator evaluated first, being less precedence than increment operator.</p>
",3
1969239,1969106,0,"<p>Here's a simple way to remember it all:</p>

<p>Plus and minus are very strong in C, despite what they are in math. They are almost as strong as * and / (which are, of course, stronger, like in mathematics).</p>

<p>Logical &amp;&amp; and || are weaker than comparisons, so that you could ask if(a>5 &amp;&amp; b&lt;6) without brackets. However, bitwise &amp; | are near logical ones, for some reason, so if((a&amp;b) > 5) requires braces. This is the only illogical place. AND is always stronger than OR, due to boolean algebra semantics (AND is perceived like multiplication).</p>

<p>Between comparisons and + - we have the BIT Shifts. They belong near arithmetical ops, not with bitwise ^ &amp; |. So, cout &lt;&lt; a &amp; b is broken.</p>

<p>The rest is obvious. Full table is <a href=""http://www.difranco.net/compsci/C_Operator_Precedence_Table.htm"" rel=""nofollow noreferrer"">here</a>.</p>
",0
1969248,1969106,0,"<p>The following table from C Programming Language, by Kernighan and Ritchie, shows the precedence hierarchy in C. The top line has the highest precedence. </p>

<pre><code>Operators                                  Associativity
( [ - .                                    Left to right
! - ++  -{-  + *  &amp;  (type-cast)  sizeof   Right to left
(in the above line, +, - and * are the unary forms)
*  / %                                     Left to right
+  -                                       Left to right
&lt;&lt;  &gt;&gt;                                     Left to right
&lt;  &lt;=  &gt;  &gt;=                               Left to right
==  !=                                     Left to right
&amp;                                          Left to right
^                                          Left to right
|                                          Left to right
&amp;&amp;                                         Left to right
||                                         Left to right
?:                                         Left to right
=  +=  -=  *=  /=  %=  &amp;=  ^=  |=  &lt;&lt;= &gt;&gt;= Right to left
,                                          Left to right
</code></pre>

<p>Example:
<a href=""http://www.careercampus.net/resources/data_and_c_next1.htm"" rel=""nofollow noreferrer"">http://www.careercampus.net/resources/data_and_c_next1.htm</a></p>
",0
1969584,1969106,4,"<p><strong>Precedence</strong> defines the order in which operators are applied: for example, in the expression <code>a * b + c / d - e</code>, the '*' and '/' operators have higher precedence than the '+' and '-' operators, so the expression is evaluated as <code>(a * b) + (c / d) - e</code>; that is, the result of <code>a * b</code> is added to the result of <code>c / d</code>, and <code>e</code> is subtracted from that sum.  </p>

<p><strong>Order of evaluation</strong> refers to the order in which subexpressions are evaluated.  Going by the previous example of <code>a * b + c / d - e</code>, the compiler may decide to evaluate <code>c / d</code> <em>before</em> evaluating <code>a * b</code>; IOW, in most cases, there's no guarantee that evaluation proceeds from left to right.  If we change the variables to functions, i.e., <code>a() * b() + c() / d() - e()</code>, there's no guarantee that <code>a()</code> is called before <code>b()</code>, or that <code>b()</code> is called before <code>c()</code>, etc.  The compiler may decide to call <code>e()</code> first, then <code>c()</code>, then <code>d()</code>., etc.  All that's guaranteed is that the result of <code>a() * b()</code> will be added to the result of <code>c() / d()</code>, and that <code>e()</code> will be subtracted from that sum, regardless of the order in which a(), b(), c(), d(), and e() are called.  Some operators such as the comma operator and the logical <code>&amp;&amp;</code> and <code>||</code> operators force a partial order of evaluation; given the expression <code>a() == b() &amp;&amp; c() == d()</code>, the <code>&amp;&amp;</code> operator forces <code>a() == b()</code> to be evaluated before <code>c() == d()</code>, although it does not force <code>a()</code> to be called before <code>b()</code>.  </p>
",0
1970128,1969106,1,"<p>Let's say you have three functions:</p>

<pre><code>int a(void) { return printf(""Hi!\n""); }
int b(void) { return printf(""I am in b\n""); }
int c(void) { return printf(""c\n"") }
</code></pre>

<p>Then the following function call:</p>

<pre><code>printf(""The answer to life, universe and everything is: %d.\n"",
    a() * b() + c());
</code></pre>

<p>Will print the strings <code>Hi!</code>, <code>I am in b</code>, <code>c</code> in an <em>unspecified order</em> (each with a newline), followed by <code>The  answer to life, universe and everything is: 42.</code>, followed by a newline.</p>

<p>Precedence tells us that <code>*</code> has higher precedence than <code>+</code>, so <code>a() * b() + c()</code> will be interpreted as <code>(a() * b()) + c()</code>, and not <code>a() * (b() + c())</code>.  Order of evaluation, on the other hand, would have implied the order of calls to <code>a()</code>, <code>b()</code>, and <code>c()</code>.  Here, they can be evaluated in any order.  The compiler can, for example, call <code>c()</code> first, then <code>b()</code>, and then <code>a()</code>, storing the intermediate values, and then calculate the expression according to precedence rules.</p>

<p>Of course, the compiler has to evaluate <code>a()</code> and <code>b()</code> both to calculate the sum, but it can do so after evaluating <code>c()</code>, and can evaluate <code>b()</code> before <code>a()</code>.</p>
",0
1480502,1480489,2,"<p>Integer types are the most <a href=""http://home.att.net/~jackklein/c/inttypes.html"" rel=""nofollow noreferrer"">confusing</a> in C/C++ compilers. In your case the answer is simple though, the code demonstares overflow. Char is an 8-bit data type which can only have values 0-255 and 256 which requires 9bits to represent will overflow to 0. Here 1280 = 256*5 and the least significant 8-bits are zero , hence when assigned to a char the value is 0. It will be interesting to see what the output is in MSB vs LSB systems.</p>
",7
1480508,1480489,1,"<p>Casting from a wider type to narrower type, works only if you respect the rules. wihtout of that, you are under the mercy of implementations. So, technically what happens is that the compiler assigns the first byte of y, to x! If y holds more than one byte of information, it is lost. For example, when you have <code>y == 0xFFFFFFFF =&gt; x = 0xFF</code>.</p>
",3
1480515,1480489,0,"<p>It also shows two's complement.</p>
",0
1703378,1703300,2,"<p>As far as I know, strtok does not support that feature. However, you may do additional check: whenever <code>pch</code> is returned, see whether the first character of the remaining buffer has "" "" or "","". Then, you need to track down the remaining buffer, but this is your homework :)</p>
",0
1703388,1703300,0,"<p>The strtok and the CLIB does not expose this information. So there is no portable way to get it.</p>

<p>You may get the information you're looking for with a hack that works for your clib-implementation, but if you want something stable and portable the only choice you have is to implement a strtok-workalike that tells you the separator.</p>

<p>That task is not rocket-science btw...</p>
",0
1502002,1501997,3,"<p>You put comma inside """"-quotes in printf(""%d,"" .</p>

<p>also please format your code.</p>
",0
1502006,1501997,2,"<p>use , after double qoutes in printf</p>
",0
1502010,1501997,2,"<p>This:</p>

<pre><code>printf(""%d,"" num_squares);
</code></pre>

<p>Should be:</p>

<pre><code>printf(""%d"", num_squares);
</code></pre>
",0
1502001,1501997,10,"<p>Don't know about that part of the code, but you're missing a comma in your printf</p>

<pre><code>printf(""%d,"" num_squares); 
</code></pre>

<p>should be</p>

<pre><code>printf(""%d,"", num_squares);
</code></pre>
",0
1542026,1541992,0,"<p>The reason that (a) you're getting numbers printed and (b) that the numbers aren't random is because in the last code block, you're trying to print a string as decimals. After all, that's what %d expects to print - a decimal. That's not got anything to do with pointers.</p>

<p>You don't say what output you're expecting, but you have to chose the correct formatter to do that.</p>

<p>Another suggestion - the normal idiom for incrementing a variable in C and C++ is</p>

<pre><code>++x;
</code></pre>

<p>or</p>

<pre><code>x++;
</code></pre>

<p>to increment a value by 1 and</p>

<pre><code>x += 9;
</code></pre>

<p>to increment it by more than 1 (obviously 9 in this case).</p>
",0
1542028,1541992,5,"<p>1819043176 is 6C6C6568 in hexadecimal, which is stored as the bytes 68, 65, 6c, 6c on a little-endian machine. These are the first four characters of ""hello world"". And so on.</p>

<p>Normally you are not supposed to do these things in C, the results are undefined or implementation-dependent.</p>

<p>If you nevertheless want to peek around in memory then better do it in a more systematical way, for example write a small utility to do a hex dump.</p>
",0
1542038,1541992,0,"<p>I think it's because you are passing a char to printf when the format string is expecting an integer. Try casting q[k] and p[k] to integers.</p>

<pre><code>while (k &lt; 10) {
        printf(""%d "", (int)p[k]);
        k = k + 1;
}
</code></pre>

<p>The call to printf() is not a normal function call, it uses varargs/stdargs and in those, the function needs to unpack the correct type.</p>

<p>So the first number in your output, 1819043176, corresponds to 0x6C6C6568. See how the character value for the lowercase 'h' (0x68) that you were presumably expecting to see is the least significant byte in four-byte integer? This is because the varargs routines were expecting an integer-sized argument because of the %d format specifier.</p>
",0
1542039,1541992,0,"<p>This doesn't do what you think it does (I hope, maybe):</p>

<pre><code>while (k &lt; 10) {
        printf(""%d "", q[k]);
        k = k + 1;
}
</code></pre>

<p>Think about what q is, what printf does, and what %d means (hint, look at the assignment of q).  I would also suggest including the output of what you expect as a result because it's not obvious from the code what you're actually trying to accomplish (other than printing out pointers to ints using printf instead of ints).</p>
",0
1542043,1541992,2,"<p>you have p pointing to the string ""hello world""<br>
but you have defined p as a pointer to integers, so p looks like this</p>

<pre>
p[0] = 'hell'
p[1] = 'o wo'
p[2] = 'rldx'
p[3] = 'xxxx'
p[4] = 'xxxx'
p[5] = 'xxxx'
p[6] = 'xxxx'
p[7] = 'xxxx'
p[8] = 'xxxx'
p[9] = 'xxxx'

where xxxx means you have not set this memory to anything.

lets look at p[0]
h=0x68
e=0x65
l=0x6c
l=0x6c

so you have the hexidecimal number 0x6c6c6568 which you can check is 1819043176

and so on
</pre>
",0
1542058,1541992,4,"<p>I'm not digging enough to give you the answer, but I do have an important suggestion: <strong>crank up your compiler's warnings.</strong> When my bash starts up, it aliases <code>gcc</code> to <code>/usr/bin/gcc -Wall -Wextra -Werror</code> so that anything I try to compile has to pass through some of GCC's harshest tests (and it treats all warnings as errors, so minor mistakes won't compile). Your code gave me an error printout a mile long (not literally). Some errors:</p>

<ul>
<li><code>printf()</code> has a special format specifier for pointers: <code>%p</code>. Don't use <code>%d</code> - that's for <code>int</code>s.</li>
<li><code>p</code> is an <code>int *</code> (pointer to an <code>int</code>), <code>""hello world""</code> is a <code>char *</code>. You can assign one to another, but it's usually a bad idea, so if you <em>really</em> want to do it, you should use a cast to say ""Hey, I meant to do this:"" <code>p = (int *) ""hello world"";</code></li>
<li><code>main()</code> doesn't return <code>void</code>, it returns an <code>int</code>. You know this, because you declared <code>int main(void)</code> like a good programmer, but then we get to the end of <code>main()</code> and there's no <code>return</code> statement! How is it supposed to return an <code>int</code> if you don't <code>return</code> anything? In C++, we can skip the ending <code>return</code> statement, but not in C (at least, we really shouldn't, because bad things can happen).</li>
</ul>

<p>Also, you have a pattern that you repeat often:</p>

<pre><code>k = 0;
while (k &lt; 10) {
        y[k] = k;
        k = k + 1;
}
</code></pre>

<p>Welcome to <code>for</code> loops:</p>

<pre><code>for(k = 0; k &lt; 10; k++) {
        y[k] = k;
}
</code></pre>

<p><code>for()</code> loops have three parts:</p>

<pre><code>for(init; cond; inc)
</code></pre>

<p><code>init</code> is run once before the loop, then the loop executes as long as <code>cond</code> is true, executing <code>inc</code> at the end of every loop. It is almost exactly equivalent to what you're doing, and is more concise.</p>
",4
1543967,1541992,0,"<p>Your problem is about the variable p.
it is int *, and sizeof an integer variable is 4 byte (it may change according to system and compiler) but the sizeof (char) is 1 byte</p>

<p>""hello world"" string is 12 byte -with null-
12 byte can be defined in 3 integer. </p>

<p>after this line</p>

<pre><code>p = ""hello world"";
</code></pre>

<p>only 3*4 memory of p will be used. (*p points array ""y"")
Rest of them will be null...</p>
",0
1251184,1251180,2,"<p>C doesn't have a keyword ""public"", so it's probably a macro defined in the less source code somewhere.</p>
",0
1251190,1251180,22,"<p>In the file <code>less.h</code> is your answer:</p>

<pre><code>#define public      /* PUBLIC FUNCTION */
</code></pre>

<p>It seems like public is only used as a marker for public/global functions and variables.
When compiled, it is expanded to nothing.</p>

<p>How to find this information?</p>

<ol>
<li>Search the .c file from top to the location of the identifier you want more information about</li>
<li>If you do not find any declaration, look for <code>#include</code> directives</li>
<li>Open any included file and look for the declaration of what you are looking for </li>
<li>Repeat from step two for every included file</li>
</ol>

<p>In this case, that was pretty simple.</p>
",4
1251215,1251180,2,"<p>The definition of public as an empty pre-processor macro has been addressed in other answers.  To find the definition, you probably want to use a tool like ctags/etags or cscope.  (There are many tools to scan a source tree to generate this information.)  For example, you can find the definition of public at line 55 of less.h by invoking:</p>

<pre>
$ ctags -dtw *.c *.h
$ vi -t public
</pre>

<p>Or, simply run ctags before you start editing anything.  When you see a definition you don't understand, put the cursor on it and type ^] (that's control-right square bracket, and will work in vi-like editors.)</p>
",1
1251219,1251180,4,"<p>This has nothing to do with C as such. If you look in the include file less.h you will see that the author has defined a number of preprocessor instructions. Some of them like 'public' is most likely for readability. E.g.: </p>

<pre><code> /*
 * Language details.
 */
#if HAVE_VOID
#define VOID_POINTER    void *
#else
#define VOID_POINTER    char *
#define void  int
#endif
#if HAVE_CONST
#define constant    const
#else
#define constant
#endif

#define public      /* PUBLIC FUNCTION */
</code></pre>

<p>See how public is defined. It's translated to nothing and as you have already figured out it's in the global scope. However it's more readable and more obious that it's in the global scope. Also, one could argue that if the source is written consistently like this and a new version of C emerges that does have a <em>public</em> keyword, it's a matter of redefining the the header file and recompile to actually use it. </p>

<p>Preprocessing tricks like this can even be used in clever ways to have one source compile in different languages (like C++ and Java). This is not something you should be doing, but it's possible to it.</p>

<p>The options like HAVE_VOID you see in the example from less.h above are usually specified as compiler (actually preprocessor) options on compile time. So if you have a compiler and a version of C that supports the <em>void</em> keyword you would compile your source with:</p>

<blockquote>
  <p>g++ -g -DHAVE_VOID -Wall myprog.C -o
  myprog</p>
</blockquote>

<p>Everywhere the author uses VOID_POINTER in the source would then actually be considered by the compiler as: </p>

<pre><code>void * 
</code></pre>

<p>If you didn't specify HAVE_VOID the compiler would instead use </p>

<pre><code>char * 
</code></pre>

<p>which is a reasonable substitue.</p>

<p><strong>TIP:</strong> Check your compiler's options to see if you have an option to just preprocess your sources. That way you can look at the actual source that gets sent to the compiler. </p>
",1
1907151,1906917,1,"<p>If we are talking <em>original</em> language design, remember that C got most of its present shape on the PDP-11 CPU, which is 16 bit. So they had integers for arithmetic and characters for string storage. Pointers were basically the same as integers.</p>

<p>The language was very pragmatic and only later got a more formal and intricate syntax. So the answer is, it just happened to be that way. Much later we got 32 bit and 64 bit CPUs and the need to distinguish between integers of different lengths.</p>

<p>To this day I code almost all my C programs like as if there were no type other than char and integer. Oh, by the way, ""char"" in C can be either signed and unsigned according to the standard. This reflects that chars were meant for character storage (strings) and ints for arithmetic.</p>

<p>To clarify, (thank you semaj) the compiler can choose to treat a variable declared ""char"" as ""unsigned char"". This does not happen for an ""int"". An ""int"" is always signed, but with chars you can not be sure. You have to assume that a char can have either unsigned or signed arithmetics. This is a speed optimization to accommodate CPUs that work faster with either implementation. I.e. focus is placed on chars as storage containers, not as an arithmetic type. (It's name is also a give-away. It could have been called ""short"" or ""small"", but was called ""char"" for a reason.)</p>
",1
1906965,1906917,6,"<p>It doesn't make sense to have a short int literal in C since all integer expressions are evaluated as if the subexpressions were at least int in size.</p>
",0
1906984,1906917,5,"<p>Alternatively: Because they aren't needed!</p>

<p>Data types of various sizes are needed to fit well with underlying hardware and/or to economize on storage space, but literals are a compile-time construct that gets stored into appropriate data structures anyway.</p>

<p>It's different with <code>float</code> vs. <code>double</code> because the same number actually has different internal representation in those - more different, anyway, than just a few leading zeros.</p>

<p>Similarly, there's a difference between <code>char</code> and <code>short</code> even though they may be stored in the same bits: If the programmer is talking about character data, it will usually be more convenient for him to specify, say, <code>'A'</code> than <code>65</code>.</p>

<p>But a short <code>99</code> and an int <code>99</code> look the same to the programmer, are treated the same in the program... the wider-ranging type will easily do the work of both.</p>
",1
1895380,1895378,2,"<p>When you need to set a block of memory to the same value, use the <code>memset</code> function.</p>

<p>It looks like this: <code>void * memset ( void * ptr, int value, size_t num );</code></p>

<p>You can find more information about the function at: <a href=""http://www.cplusplus.com/reference/clibrary/cstring/memset/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/clibrary/cstring/memset/</a></p>
",1
1895384,1895378,0,"<p>Hints:</p>

<ul>
<li><p>there is already a posix library function for zeroing a block of memory</p></li>
<li><p>consider casting the <code>void *</code> to some pointer type that you can dereference / assign to.</p></li>
</ul>
",0
1895387,1895378,4,"<p>I am assuming you can't use <code>memset</code> because it's a homework assignment assignment, and deals with memory management.  So, I would just go in a loop and set all bytes to 0.  Pseudocode:</p>

<pre><code>for i = 1 to n:
   data[i] = 0
</code></pre>

<p>Oh, if you're having trouble understanding how to dereference <code>void *</code>, remember you can do:</p>

<pre><code>void *b;
/* now make b point to somewhere useful */
unsigned char *a = b;
</code></pre>
",7
1895536,1895378,1,"<p>If you can't use <code>memset</code>, then you'll need to resort to setting each byte individually.</p>

<p>Since you're calling <code>malloc</code> from your <code>calloc</code> function, I'm going to assume it looks something like this:</p>

<pre><code>void *calloc (size_t count, size_t sz) {
    size_t realsz = count * sz;
    void *block = malloc (realsz);
    if (block != NULL) {
        // Zero memory here.
    }
    return block;
}
</code></pre>

<p>and you just need the code for <code>""// Zero memory here.""</code>.</p>

<p>Here's what you need to know.</p>

<ol>
<li><p>In order to process the block one byte at a time, you need to cast the pointer to a type that references bytes (<code>char</code> would be good). To cast your pointer to (for example) an <code>int</code> pointer, you would use <code>int *block2 = (int*)block;</code>.</p></li>
<li><p>Once you have the right type of pointer, you can use that to store the correct data value based on the type. You would do this by storing the desired value in a loop which increments the pointer and decrements the count until the count reaches zero.</p></li>
</ol>

<p>Hopefully that's enough to start with without giving away every detail of the solution. If you still have problems, leave a comment and I'll flesh out the answer until you have it correct (since it's homework, I'll be trying to get <em>you</em> to do most of the thinking).</p>

<p><em>Update:</em> Since an answer's already been accepted, I'll post my full solution. To write a basic <code>calloc</code> in terms of just <code>malloc</code>:</p>

<pre><code>void *calloc (size_t count, size_t sz) {
    size_t realsz, i;
    char *cblock;

    // Get size to allocate (detect size_t overflow as well).

    realsz = count * sz;
    if (count != 0)
        if (realsz / count != sz)
            return NULL;

    // Allocate the block.

    cblock = malloc (realsz);

    // Initialize all elements to zero (if allocation worked).

    if (cblock != NULL) {
        for (i = 0; i &lt; realsz; i++)
            cblock[i] = 0;
    }

    // Return allocated, cleared block.

    return cblock;
}
</code></pre>

<p>Note that you can work directly with <code>char</code> pointers within the function since they freely convert to and from <code>void</code> pointers.</p>
",6
1275038,1275004,0,"<p>You need to interpret the string. C doesn't do that by itself, look up a library that'll do it for you.</p>

<p><a href=""http://expreval.sourceforge.net/"" rel=""nofollow noreferrer"">http://expreval.sourceforge.net/</a>
<a href=""http://www.codeproject.com/KB/library/expreval.aspx"" rel=""nofollow noreferrer"">http://www.codeproject.com/KB/library/expreval.aspx</a></p>

<p>There are others, just search google.</p>
",1
1275047,1275004,1,"<p>Preprocessor macros are run before the compiler.  It is, by definition, not possible to do exactly what you'retrying to do.</p>

<p>To convert a number into a string at runtime, call the <code>itoa</code> function, like this:</p>

<pre><code>char thestring[8];

itoa(10 * 50, thestring, 10);
</code></pre>

<p>Note that this code declares <code>thestring</code> as an array, not a pointer.  For more information, read about memory management in C.</p>
",1
1275054,1275004,10,"<p>The C preprocessor cannot do that, so use <code>snprintf</code> instead:</p>

<pre><code>char *stringify(int n) {
   char *res = malloc(12);
   snprintf(res, 12, ""%d"", n);
   return res;
}
</code></pre>

<h3>Usage</h3>

<pre><code>const char *thestring = stringify(10 * 50);
</code></pre>

<h3>NB</h3>

<p>For simplicity's sake I've omitted error control and <code>free</code>.</p>
",4
1275189,1275004,4,"<p>I'll take a wild guess that you have more experience in scripting languages than in C.</p>

<p>There are multiple phases you have to be aware of with a purely compiled language like C: Preproccesing, Compiling, Linking, and Running</p>

<p>First the <strong>preprocessor</strong> is run. That is where your macro gets expanded. At this point, its contents are ""10 * 50"". Not much to be done about that.</p>

<p>After the macro pre-processor completes, then the <strong>compiler</strong> converts the program into an object file</p>

<p>After the compiler finishes on every source file, the <strong>linker</strong> steps in and slaps them all together.</p>

<p>Finally, when your user is ready, they <strong>execute</strong> your program. Semanticly, this is when the 10 * 50 gets calculated. (In actuality, most compilers will recognize that this will always be the same value, and replace it with 500, but that's an implementation detail).</p>

<p>Scripting languages like to blur all these lines, so I can see where someone used to one of those might be confused.</p>
",0
1275249,1275004,-1,"<p>You could write a script (perl?) to use as preprocessor which recognizes the strings to evaluate, evaluates them and then it calls the true cpp on the ""evaluated"" file.</p>

<p>Maybe it could work.</p>
",0
1275254,1275004,5,"<p>You probably won't like the format in which the expression is going to be presented, <em>yes</em>, it <em>is</em> possible, but in a very eclectic way - you'd need to create a separate functional language that is being ""run"" by the preprocessor. The proof:</p>

<pre><code>$ cvs -d:pserver:anonymous@chaos-pp.cvs.sourceforge.net:/cvsroot/chaos-pp login 
$ cvs -z3 -d:pserver:anonymous@chaos-pp.cvs.sourceforge.net:/cvsroot/chaos-pp co -P chaos-pp
$ cvs -z3 -d:pserver:anonymous@chaos-pp.cvs.sourceforge.net:/cvsroot/chaos-pp co -P order-pp
$ cd order-pp/example
$ grep -A 6 'int main' fibonacci.c
int main(void) {
   printf
     (""The 500th Fibonacci number is ""
      ORDER_PP(8stringize(8to_lit(8fib(8nat(5,0,0)))))
      "".\n"");
   return 0;
}
$ cpp -I../inc fibonacci.c 2&gt;/dev/null | grep -A 6 'int main' 
int main(void) {
   printf
     (""The 500th Fibonacci number is ""
      ""139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125""
      "".\n"");
   return 0;
}
</code></pre>

<p>In this example we have newly-made preprocessor-run purely functional language being used to calculate 500th Fibonacci number and then stringize it to give to C compiler.</p>

<p>Of course I very much doubt that this is something that you'd ever use in practice, and it is a very far stretched abuse of the preprocessor, but I consider it to be a very thought-provoking hack. (and yes, without the exotic theoretical twists like this one, it's not possible).</p>
",0
1275459,1275004,-2,"<p>As the other responses have said, this cannot be done with the C preprocessor. This is one of the many shortcomings of C that are solved by C++, This is the sort of thing that can be accomplished in a very elegant manner using Template Metaprogramming.</p>

<p>To calculate an arithmetic expression at compile time:</p>

<pre><code>#include &lt;boost/mpl/arithmetic.hpp&gt;
namespace mpl = boost::mpl;
int main(int argc, char *argv[]) {
  const int n = mpl::multiplies&lt;mpl::int_&lt;10&gt;, mpl::int_&lt;50&gt; &gt;::value;
  return 0;
}
</code></pre>

<p>Here's a <a href=""http://lists.boost.org/boost-users/2009/04/47326.php"" rel=""nofollow noreferrer"">string formatting metafunction</a> I found on the boost mailing list archives. This version will convert an int (like the one calculated above) into a string in a base of your choosing:</p>

<pre><code>#include &lt;boost/mpl/string.hpp&gt;
#include &lt;boost/mpl/vector_c.hpp&gt;
#include &lt;boost/mpl/at.hpp&gt;
#include &lt;boost/mpl/if.hpp&gt;
#include &lt;boost/mpl/int.hpp&gt;
#include &lt;boost/mpl/bool.hpp&gt;
#include &lt;boost/mpl/identity.hpp&gt;
#include &lt;boost/mpl/push_back.hpp&gt;
namespace mpl = boost::mpl;
struct itoa_ct
{
  // radix for _itoa() goes up to 36, but only bother with 16 here
  typedef mpl::vector_c&lt;char
    ,'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'
    &gt; radix_t;
  template &lt;int Radix, unsigned int Quotient&gt;
    struct radix_convert
    {
      typedef typename mpl::push_back&lt;
        typename radix_convert&lt;Radix, Quotient / Radix&gt;::type
        , mpl::char_&lt;mpl::at_c&lt;radix_t, Quotient % Radix&gt;::type::value&gt;
        &gt;::type type;
    };
  template &lt;int Radix&gt;
    struct radix_convert&lt;Radix, 0&gt;
    {
      typedef mpl::string&lt;&gt; type;
    };
  template &lt;int I, int Radix = 10&gt;
    struct apply
    {
      // All bases != 10 consider I as unsigned
      typedef typename radix_convert&lt;
        Radix, static_cast&lt;unsigned int&gt;((Radix == 10 &amp;&amp; I &lt; 0) ? -I : I)
        &gt;::type converted_t;
      // Prefix with '-' if negative and base 10
      typedef typename mpl::if_&lt;
        mpl::bool_&lt;(Radix == 10 &amp;&amp; I &lt; 0)&gt;
        , mpl::push_front&lt;converted_t, mpl::char_&lt;'-'&gt; &gt;
        , mpl::identity&lt;converted_t&gt;
        &gt;::type::type type;
    };
};
</code></pre>

<p>Putting the two together your expression becomes:</p>

<pre><code>const char *thestring = mpl::c_str&lt;itoa_ct::apply&lt;mpl::multiplies&lt;mpl::int_&lt;10&gt;, mpl::int_&lt;50&gt; &gt;::value&gt;::type&gt;::value;
</code></pre>

<p>... and this all gets turned into nothing more than a constant string ""500"" at compile time :-)</p>
",3
1611661,1611641,2,"<p>It looks like the prompt is inside the <em>while</em> loop but outside the outermost <em>for</em> loop. Hence the prompt will appear only after all iterations are done. Move the prompt to inside the outermost <em>for</em> loop.</p>
",0
1611675,1611641,2,"<p>I think in terms of readability, you're better putting it at the top of the relevant loop. Get rid of the outer while altogether and change:</p>

<pre><code>char sent;
: :
for (n1=2;n1&lt;=9;n1++) {
    for (n2=2;n2&lt;=9;n2++) {
</code></pre>

<p>into:</p>

<pre><code>char sent[100];
: :
for (n1=2;n1&lt;=9;n1++) {
    if (n1 &gt; 2) {
        printf(""press any key to continue or 'n' to stop writing the file\n"");
        scanf(""%s"",sent);
        if (*sent == 'n') break;
    }
    for (n2=2;n2&lt;=9;n2++) {
</code></pre>

<p>The change of <code>sent</code> from a character to a string is so you don't need to worry about getting linefeeds as characters (if you type <kbd>y</kbd><kbd>ENTER</kbd>, you'll get the next <em>two</em> sections since <kbd>y</kbd> is one character and <kbd>ENTER</kbd> is another - even worse if you enter <kbd>y</kbd><kbd>e</kbd><kbd>s</kbd><kbd>ENTER</kbd>). The use of a fixed size string and <code>scanf()</code> is dangerous however and shouldn't be used in production code. I include it here only yo make your life a little easier.</p>
",0
1611864,1611641,2,"<p>If i correctly understand your code you are computing all possible permutations of 8 different numbers. Try using much faster algorhitm:</p>

<p><a href=""http://en.wikipedia.org/wiki/Permutation#Algorithms_to_generate_permutations"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Permutation#Algorithms_to_generate_permutations</a> there are two pseudo code examples. (one for unordered and one for lexicographical orderd permutations)</p>
",0
1598427,1598425,11,"<p>You should be using <a href=""http://www.opengroup.org/onlinepubs/000095399/functions/strcmp.html"" rel=""noreferrer""><code>strcmp()</code></a>:</p>

<pre><code>if (strcmp(players[i].sname, ""Lee"") == 0) { ...
</code></pre>

<p>Also note that strings in C are surrounded by double quotes: <code>""""</code>. Single characters are surrounded by single quotes: <code>''</code>. I'm not sure exactly what your compiler might be doing with <code>'Lee'</code>, but it's almost certainly not what you want.</p>
",2
1598429,1598425,4,"<p>You'd be looking for <code>strcmp()</code> from the header <code>&lt;string.h&gt;</code>.</p>

<p>Note that you need a string ¡ª <code>'Lee'</code> is not a string but a multi-character constant, which is allowed but seldom useful, not least because the representation is defined by the compiler, not the C standard.</p>

<p>If you are looking to compare two strings ¡ª call the pointers to them <code>first</code> and <code>second</code>, then you write:</p>

<pre><code>if (strcmp(first, second) == 0)    // first equal to second
if (strcmp(first, second) &lt;= 0)    // first less than or equal to second
if (strcmp(first, second) &lt;  0)    // first less than second
if (strcmp(first, second) &gt;= 0)    // first greater than or equal to second
if (strcmp(first, second) &gt;  0)    // first greater than second
if (strcmp(first, second) != 0)    // first unequal to second
</code></pre>

<p>This, in my view, makes it clear what the comparison is and so the notation should be used.  Note that <code>strcmp()</code> may return any negative value to indicate 'less than' or any positive value to indicate 'greater than'.</p>

<p>You will find people who prefer:</p>

<pre><code>if (strcmp(first, second))    // first unequal to second
if (!strcmp(first, second))   // first equal to second
</code></pre>

<p>IMO, they have the advantage of brevity but the disadvantage of being less clear than the explicit comparisons with zero.  <a href=""https://acronymfinder.com/YMMV.html"" rel=""nofollow noreferrer"">YMMV</a>.</p>

<p>Be cautious about using <code>strncmp()</code> instead of <code>strcmp()</code>, which was suggested in one answer.  If you have:</p>

<pre><code>if (strncmp(first, ""command"", 7) == 0)
</code></pre>

<p>then if <code>first</code> contains <code>""commander""</code>, the match will be valid.  If that's not what you want but you want to use <code>strncmp()</code> anyway, you would write:</p>

<pre><code>if (strncmp(first, ""command"", sizeof(""command"")) == 0)
</code></pre>

<p>This will correctly reject <code>""commander""</code>.</p>
",0
1598434,1598425,12,"<p>The short answer: <a href=""http://www.opengroup.org/onlinepubs/000095399/functions/strcmp.html"" rel=""noreferrer""><code>strcmp()</code></a>.</p>

<p>The long answer: So you've got this:</p>

<pre><code>if(players[i].sname == 'Lee')
</code></pre>

<p>This is wrong in several respects. First, single-quotes mean ""character literal"" not ""string literal"" in C.</p>

<p>Secondly, and more importantly, <code>""string1"" == ""string2""</code> doesn't compare strings, it compares <code>char *</code>s, or pointers to characters. It will tell you if two strings <em>are stored in the same memory location</em>. That would mean they're equal, but a false result wouldn't mean they're <em>inequal</em>.</p>

<p><code>strcmp()</code> will basically go through and compare each character in the strings, stopping at the first character that isn't equal, and returning the difference between the two characters (which is why you have to say <code>strcmp() == 0</code> or <code>!strcmp()</code> for equality).</p>

<p>Note also the functions <a href=""http://www.opengroup.org/onlinepubs/000095399/functions/strncmp.html"" rel=""noreferrer""><code>strncmp()</code></a> and <a href=""http://www.opengroup.org/onlinepubs/000095399/functions/memcmp.html"" rel=""noreferrer""><code>memcmp()</code></a>, which are similar to <code>strcmp()</code> but are safer.</p>
",1
1704420,1704411,6,"<p>Check out strtol() and strtoul().</p>

<p>You want to avoid atoi() as it does not have a good way of distinguishing between a string of ""0"" and an invalid number.</p>
",3
1704422,1704411,-2,"<pre><code>balance = atoi(ptr)
</code></pre>
",0
1704423,1704411,0,"<p>Yes.  <code>atoi</code> is a basic one with very limited error handling capability; <code>strtol</code> is a better one.</p>
",0
1704428,1704411,0,"<p>There's also <a href=""http://linux.die.net/man/3/sscanf"" rel=""nofollow noreferrer""><code>sscanf()</code></a>.</p>
",1
1496018,1496009,-3,"<p>try:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void)

{

    char x; 

    int pause;


    printf("" Enter a character representing the observed color of the cylinder \n"" );
    scanf(""%c"", &amp;x);


    while(x){
        switch (x)

        {

        case 'o': printf(""The content is Ammonia\n""); break;
        case 'b': printf(""The content is Carbon Monoxide\n""); break;
        case 'y': printf(""The content is Hydrogen\n""); break;
        case 'g': printf(""The content is Oxygen\n""); break;
        default: printf(""Character out of range \n"");

        }

        printf(""After Switch \n"");
        printf(""Enter new character to continue \n"");
        scanf("" %c"", &amp;x);

        if(x == 'q'){
            break;
        }
    }
    return 0;

}
</code></pre>
",0
1496024,1496009,4,"<p>It has nothing to do with your switch statement, but you will probably have to puzzle over the meaning of these four lines:</p>

<pre><code> o = Ammonia;
 b = Carbon_Monoxide;
 y = Hydrogen;
 g = Oxygen;
</code></pre>

<p>You don't use the variables thus defined anywhere, and the symbols ""Ammonia"", ""Carbon_Monoxide"" and so on are not defined - this is the cause of the error you are seeing.</p>
",5
1496025,1496009,3,"<p>Since this is homework, I don't want to give you the answer straight, but look at what you're doing with those chars (o, b, y, g) and ask yourself if it makes sense.  </p>

<p>Also, on the switch statement, I'm pretty sure you need a break; after each case, else it will print each case's statement</p>
",1
1594764,1594741,5,"<p>Read the <a href=""http://beej.us/guide/bgnet/"" rel=""nofollow noreferrer"">Beej's Guide to Network Programming</a>.</p>

<blockquote>
  <p>This is a beginner's guide to socket
  programming with Internet sockets. It
  is meant to be a springboard that will
  launch you into the exciting world of
  TCP/IP programming.</p>
</blockquote>
",0
1594766,1594741,9,"<p>The easiest way is to use an existing HTTP library, for example <a href=""http://curl.haxx.se/libcurl/"" rel=""noreferrer"">libcurl</a> or <a href=""http://www.webdav.org/neon/"" rel=""noreferrer"">neon</a>. If you are using some framework, maybe it already has a HTTP client.</p>
",0
1594769,1594741,1,"<p>There are many way to get your result, but the simple way would be to use a library since parsing html is often complicated.</p>

<p>You could try to use <a href=""http://xmlsoft.org/"" rel=""nofollow noreferrer"">libxml</a> </p>

<p>There is also <a href=""http://curl.haxx.se/"" rel=""nofollow noreferrer"">libcurl</a> which allows you to simulate a browser.</p>

<p>But trying to parse html yourself will be.... painful..</p>
",0
1404868,1404738,2,"<p>The answer to your question can be found at <a href=""http://www.parashift.com/c++-faq-lite/const-correctness.html#faq-18.17"" rel=""nofollow noreferrer"">http://www.parashift.com/c++-faq-lite/const-correctness.html#faq-18.17</a></p>

<p>This means you should really use <code>const double * const * const * d</code>.</p>
",0
1404790,1404738,0,"<p>use <a href=""http://publib.boulder.ibm.com/infocenter/lnxpcomp/v8v101/index.jsp?topic=/com.ibm.xlcpp8l.doc/language/ref/keyword_dynamic_cast.htm"" rel=""nofollow noreferrer"">const_cast_operator()</a></p>
",2
1404795,1404738,8,"<p>If your C tag is to be believed, gcc generates a warning as the types differ for both your example and <code>const double * const * const * d</code>. In C++, it's an error in the OP code but the slap-const-everywhere approach is legal.</p>

<p>The reason the compiler warns you is that a pointer to a pointer ( or further indirection ) allows a pointer to be returned to the caller by modifying the location the parameter points to. </p>

<p>If the target of the pointer is declared as const, then the called function would expect the value it puts there to be treated as const on return. </p>

<p>A simpler case of passing a <code>T**</code> to a <code>const T**</code> which illustrates why this is an error would be:</p>

<pre><code>void foo ( const char ** z )
{
    *z = ""A"";
}


int main (int nargs, char** argv)
{
    char*   z = 0;
    char**  d = &amp;z;

    // warning in C, error in C++
    foo ( d );

    // bad - modifies const data
    z[0] = 'Q';
}
</code></pre>

<p><code>const</code> in C means that the data won't change. <code>const</code> in C++ means the data won't change publicly - mutable data in a C++ object can change. A C compiler could optimise its code so that it caches some of the <code>const</code> data somewhere, but a C++ compiler can't do that due to possible mutablity, so has the weaker restriction that you can't return const data to non-const as above. So in C++, <code>double***</code> can be cast to <code>const double * const * const * d</code> as the extra <code>const</code>s prevent return of non-modifiable memory, but in C it generates a warning and possible errors if the compiler optimises repeated accesses to the memory elsewhere.</p>
",0
1404798,1404738,0,"<p>This is also true for ** (a pointer to pointer) for identical reasons.</p>

<p>This code also produces this error, and it's clearer to see why the compiler won't let you do this here:</p>

<pre><code>   double d = 0.0;
   double * pd = &amp;d;
   const double ** ppd = &amp;pd; // &lt;--- Error
</code></pre>

<p>If you were able to do this, you could have a 'const' pointer to data (ppd), that you could change by changing the mutable value d. This violates const, so the compiler won't let you do this.</p>
",1
1404950,1404738,0,"<p>With <i>const double***d</i> only the value of <i><strong><em>d</i> is <i>const</i>. In C a conversion from <i>double</em> a</i> to <i>const double* a</i> is legal while a conversion from <i>double</strong> b</i> to <i>const double** b</i> (or further indirection) is not.</p>

<p>Therefore to convert from <i>double*** d</i> to <i>const double*** d2</i> you could do the following:</p>

<pre>
  double*** d;
  const double* b = **d;
  const double** c = &b;
  const double*** d2 = &c;
</pre>

<p>Of course the use of <i>const double*** d</i> remains questionable because of the non-const indirections.</p>
",0
1404834,1404738,0,"<p>Consider <code>d</code> a pointer to a blackbox.</p>

<p>The compiler can add const to either <code>d</code> itself or the blackbox, but not the contents of the blackbox. So</p>

<pre><code>void foo1(double ***d);        /* ok, no casts needed */
void foo2(double *** const d); /* ok, no casts needed; const added to `d` itself */
void foo3(double ** const *d); /* ok, no casts needed; const added to the blackbox */
void foo4(double * const **d); /* oops, trying to change the insides of the blackbox */
void foo5(const double ***d);  /* oops, trying to change the insides of the blackbox */
void foo6(double ** const * const d);
/* ok: d is a constant pointer to a constant blackbox */
</code></pre>
",0
1479854,1479850,0,"<p>If it's a char, then you do something like this</p>

<pre><code>if(charVariable == '+')
</code></pre>

<p>These need to be in single quotes.</p>
",0
1479859,1479850,3,"<p>Write your own <code>isMathOperator</code> function that returns true for that symbols you want to allow.</p>
",0
1479862,1479850,9,"<p>Make a string with all the allowed characters and then check the string.</p>

<pre><code>char* ok = ""/+-*%"";

if (isalpha(symbol) || isalnum(symbol) || strchr(ok, symbol) == NULL) 
{
    printf(""You must enter a math operator, not a letter or number. \n \n"");
}
else {//move along nothing to see here
}
</code></pre>
",3
1479939,1479850,1,"<p>I think you have to check every input character by itself. <a href=""http://linux.die.net/man/3/strchr"" rel=""nofollow noreferrer"">strchr</a> can help</p>

<pre><code>/* code untested. I don't have a compiler available at the moment */
/* input = ""123 / 14 + x - 5""; */
char *pinput = input;
while (*pinput) {
    if (!strchr(""+-*/% abcdefghijklmnopqrstuvwxyz0123456789"", *pinput)) {
        /* unacceptable character */
        break;
    }
    ++pinput;
}
if (*pinput != '\0') {
    fprintf(stderr, ""Invalid input\n"");
}
</code></pre>
",0
1480771,1479850,1,"<p>The general answer to this kind of question in C is that you do what <em>would</em> be done behind the scenes in a language with elaborate string handling: you examine each character and process it in open code.</p>

<p>Having said that, there are now two ways to process each character:</p>

<ul>
<li>use a multi-way <code>if</code> or index a string of valid characters, probably with <code>strchr(3)</code></li>
<li>use a lookup table, i.e., <code>x['a'] = 1, if(x[i]) ...</code></li>
</ul>

<p>And having said <em>that</em>, there is a hybrid approach which uses a preconstructed lookup table that is part of every C library since before C89, called <code>ctype.h</code>. The man pages for this are found under <code>isalpha(3)</code>, use <code>man 3 isalpha</code> on unix and google or msdn if under windows.</p>
",0
1481703,1479850,0,"<p>Implementing the idea of TheUndeadFish:</p>

<pre><code>int isMathOperator(int c)
{
    static char symbols[257] =
    {
        ['+'] = 1, ['-'] = 1, ['/'] = 1, ['x'] = 1,
        ['='] = 1, ['%'] = 1, ...
    };
    assert(c == EOF || (c &amp; 0xFF) == c);
    return((c == EOF) ? 0 : symbols[c]);
}
</code></pre>

<p>Note that like the isxxxx() macros/functions in <code>&lt;ctype.h&gt;</code>, this function accepts any valid 8-bit character or EOF.  It uses the C99 mechanism for initializing specific elements of an array.</p>
",0
1491767,1491749,7,"<p>The best thing is of course to bite the bullet and edit the code. Otherwise you're creating a ""mystery"", that needs to be solved by all future maintainers of the code. Even if that's only you, this is exactly the kind of clever trick that you will forget all about. It sucks to come back, and be puzzled by strange pointless-seeming macros.</p>

<p>That said, if you're using a GNU toolchain, you can perhaps look into using <a href=""http://docs.freebsd.org/info/gcc/gcc.info.Macro_Varargs.html"" rel=""nofollow noreferrer"">varargs macros</a>.</p>
",2
1491797,1491749,9,"<p>If the code can be compiled as C99 code, you can define a <a href=""http://en.wikipedia.org/wiki/Variadic_macro"" rel=""noreferrer"">variadic macro</a> </p>

<pre><code>#define my_printf(str, args...) _my_printf(x, str, ##__VA_ARGS__)
</code></pre>

<p>The preprocessor will replace the arguments ... and the GNU preprocessor will remove the trailing comma in case the macro is invoked only with the str argument.</p>
",8
1491806,1491749,0,"<p>If <code>my_printf</code> already takes a variable number of arguments, I'm not sure why you need to wrap 'one more argument' in a macro... Just insert the new calls with the extra argument and be done with it; the old calls should still work as expected.</p>
",0
1491808,1491749,2,"<p>Not with standard C89 macros, you can't.  However you can get the same effect using functions, by breaking out the main part of your <code>my_printf</code> function into a <code>vmy_printf</code> function, analagous to the standard <code>vprintf</code>:</p>

<pre><code>#include &lt;stdarg.h&gt;

int vmy_printf(int x, const char *format, va_list ap)
{
    /* main body of my_printf goes here, taking its varargs from ap */
}

/* new_my_printf(), for callers who know about the x parameter */
int new_my_printf(int x, const char *format, ...)
{
    int n;
    va_list ap;

    va_start(ap, format);
    n = vmy_printf(x, format, ap);
    va_end(ap);

    return n;
}

/* my_printf(), for the old callers who don't know about x */
int my_printf(const char *format, ...)
{
    int n;
    va_list ap;

    va_start(ap, format);
    n = vmy_printf(DEFAULT_X, format, ap);
    va_end(ap);

    return n;
}
</code></pre>

<p>(This kind of thing is <em>why</em> those v... versions of all the standard varargs functions exist.)</p>
",0
1492234,1491749,10,"<p>You may use C99 variadic macros:</p>

<pre><code>#define my_printf(...) my_printf_(x, __VA_ARGS__)
</code></pre>

<p>As <a href=""http://msdn.microsoft.com/en-us/library/ms177415%28VS.80%29.aspx"" rel=""noreferrer"">Microsoft's implementation</a> suppresse trailing commas, the <code>str</code> argument can be added explicitly</p>

<pre><code>#define my_printf(str, ...) my_printf_(x, str, __VA_ARGS__)
</code></pre>

<p>but this would lead to a syntax error in standard C when invoked without variadic arguments</p>

<pre><code>my_printf(""foo"")
</code></pre>

<p>or an empty argument list</p>

<pre><code>my_printf(""foo"",)
</code></pre>

<p>Therefore, I'd go with the first version.</p>
",0
1492588,1491749,0,"<p>A simple solution to this problem is...</p>

<pre><code>#define my_printf(x) printf x
</code></pre>

<p>(note the missing braces)</p>

<p>To call it, use:</p>

<pre><code>my_printf((any number of arguments))
</code></pre>

<p>(note the double braces)</p>
",0
1581163,1581041,3,"<p>I'm not sure what your question is but I will try to update my answer when you update the question.</p>

<p>One thing to note is that you are using C++ (or C99) style comments (<code>//comment here</code>). If you are compiling with strict ANSI C90 support then this will fail. Also, don't cast the return of <code>malloc</code> (this stems from a very old problem that is not present in C90 and above compilers).</p>

<p>Also, this isn't ANSI C. You have this line:</p>

<pre><code>Population[i] = new person(randomVal(Names, 10), ... /* snipped for brevity */
</code></pre>

<p>There is no ""new"" keyword in ANSI C. This isn't even the right syntax for C++ (Just eye-balling this at a glance looks like you could just drop the <code>new</code> and the <code>person()</code> function returns the right thing).</p>

<p><strong>EDIT</strong></p>

<p>Ok, this is response to the comment. There's a <em>lot</em> of ways you can do this. One simple way is to set a limit for the number of Persons that can have a particular job. Then you could create an array with the same size of your Jobs array and each index into this new array, say HasJob, could match the index into the Jobs array. So, HasJob[0] could store every Person that has the ""Unemployed"" job. You could keep a separate count for each HasJob entry, so then when you insert you know where to stick the new Person object, or you could just initialize all the values to NULL and then every time you insert, do a linear search.</p>

<p>So you could have:</p>

<pre><code>/* 5 is the number of possible Jobs and 100 is the max persons per job */
Person *HasJob[5][100];

memset(HasJob, 0, 5*100*sizeof(Person *));
</code></pre>

<p>Now, you can insert each Person into the HasJob array by doing something like this</p>

<pre><code>int i, j, k;
for(i=0; i &lt; 5; i++)
{

  for(j=0; j &lt; 100; j++)
  {

    if(strcmp(Population[j]-&gt;job, Jobs[i]) == 0)
    {
      k = 0;
      while(((p = HasJob[i][k]) != NULL) &amp;&amp; (k &lt; 100) k++;
      if(k != 100) /* if k == 100, somehow too many persons have this job */
      {
        HasJob[i][k] = Population[j];
      }

    }

  }

}
</code></pre>

<p>So, I haven't tried to compile that and there may be some issues but that is the general process for this way of doing it. Essentially, you go through each job, then for each job go go through each person; if that person is in that job, find an empty spot in HasJob and put that person there. </p>

<p>Again, lots of ways to do it. You could keep a count for each Job and then you wouldn't have to do the linear scan, but this method prevents you have from having to keep track and instantiate those variables. Another method is to use linked lists. This may give you an idea though. Of course, you should probably use <code>#define</code>'s for each of those constant values (the maximum values, such as 5 and 100 could be <code>MAX_JOBS</code>, <code>MAX_PERSONS</code>, etc).</p>
",3
1592748,1592737,40,"<p><code>BYTE</code> isn't a part of the C language or C standard library so it is totally system dependent on whether it is defined after including just the standard <code>stdio.h</code> header file.</p>

<p>On many systems that do define a <code>BYTE</code> macro, it is often an <code>unsigned char</code>. Converting from a <code>const char*</code> to an <code>unsigned char*</code> would require an explicit cast.</p>
",4
1415541,1415525,13,"<p>Iam not sure but I suspect that the expression t2-1 automatically widened into an int value.
I do not have the c standard here what the exact conversion rules are, but I believe types smaller than int are automatically widened.</p>
",2
1415551,1415525,3,"<p>C coercions, as you're discovering, are not always obvious, whenever you operate between different types. <code>t2</code> is u16, <code>1</code> is <code>int</code> (presumably 32-bits), so <code>t2-1</code> is exactly such an ""operation between different types"" and results in an overall coercion to int (as it's ""longer"" than u16...). Later, as s2 and 1 are both 32-bits (though of different signedness), the overall coercion is to unsigned long. So, the sizes of the types involved do help determine the signedness of the overall coercion.</p>

<p>I suggest avoiding mixed-signedness (and ideally also mixed-size!) operations (via casting or special literal notation for literals such as <code>1</code> that otherwise will have <code>int</code> type and make your life potentially complicated and your code potentially unportable;-).</p>
",0
1415558,1415525,0,"<p>-1 is represented as all 1s. Therefore when interpreted as unsigned, its value is 2^32-1, which is clearly greater than 0. I'd guess that the first comparison is getting expanded to perform 32-bit signed arithmetic (perhaps due to the ""1"" being a signed int).</p>

<p>Note that the following WILL get to the printf, because the comparison is now done in 16-bit unsigned space again:</p>

<pre><code>u32 temp = t2 - 1;
if( t1 &lt; temp )
    printf("" t1 &lt; t2-1\n"");
</code></pre>
",3
1417331,1415525,12,"<p>The C language performs the ""Usual arithmetic conversions"" for many operators - the conversions are outlined in 6.3.1.8 of the C99 standard.  For integral operands, first promotions are performed, and this is what's causing your issue.  The promotions are outlined in 6.3.1.1 (Arithmetic operands/Boolean, characters,and integers), which says among other things:</p>

<blockquote>
  <p>If an int can represent all values of the original type, the value is converted to an int; otherwise,  it  is  converted  to  an  unsigned  int.  These  are  called  the  integer promotions.  All other types are unchanged by the integer promotions.</p>
</blockquote>

<p>The promotions are applied only to objects or expressions with an integer type with a rank less than <code>int</code> and <code>unsigned int</code> (or bitfields).</p>

<p>So in your exression:</p>

<pre><code>t1 &lt; t2-1 
</code></pre>

<p>even though the variables are <code>unsigned short</code> they are promoted to int, since on your platform <code>int</code> can represent all the values of <code>unsigned short</code>.  So the expression is evaluated using <code>int</code> types, and no underflow occurs - the <code>t2-1</code> part of the expression ends up as negative 1.</p>

<p>In the expression:</p>

<pre><code>s1 &lt; s2-1
</code></pre>

<p>the <code>unsigned long</code> types aren't promoted, because they have a higher 'rank' than <code>int</code>/<code>unsigned int</code>, so the expression is evaluated using unsigned arithmetic (with the underflow from the subtraction), and the <code>s2-1</code> subexpression evaluates to a very large number, not negative 1.</p>

<p>As litb indicated in a comment, if the platform had <code>int</code> implemented as a 16-bit type (which is permitted - MS-DOS for example), the promotion of <code>unsigned short</code> would be to <code>unsigned int</code> instead of <code>int</code>, since an <code>int</code> wouldn't be able to represent all values of <code>unsigned short</code> (<code>unsigned short</code> must be at least 16-bits).  In that case, both <code>if</code> statements would evaluate to true.</p>
",0
1790233,1790208,7,"<p>Use 
<a href=""http://msdn.microsoft.com/en-us/library/h80404d3%28VS.71%29.aspx"" rel=""noreferrer"">_strtoi64</a> or
<a href=""http://msdn.microsoft.com/en-us/library/h80404d3%28VS.71%29.aspx"" rel=""noreferrer"">_strtoui64</a></p>
",0
1790244,1790208,7,"<p><a href=""http://linux.die.net/man/3/strtoll"" rel=""noreferrer""><code>strtoll()</code></a> is in C99 and POSIX.1-2001. </p>
",2
1844796,1838688,0,"<p>If all you are trying to do is assess his knowledge of a specific language, and you don't know that language, you're gonna fail at evaluating him.</p>

<p>Can you instead evaluate ""can this guy program and is he a good communicator"" and be up-front with him about your knowledge? Give him a basic question to start with, fizzbuzz or whatever, and ask him to code it in C <em>and</em> give you a C tutorial as he does it. Then do something more complex but C-ey (see other answers for ideas) but still in the context of, ""teach me what you know and how this works"".</p>

<p>If you frame the question as, ""I know (for instance) python and Java, but not C, please teach me"" you could end up with a very informative interview. But don't give the poor guy a quiz, you won't be able to give him hints, and he could ace it or flub it with very little correlation with his actual skills.</p>
",0
1797403,1797387,9,"<p>The casts the argument to a pointer to a function that returns <code>char *</code> and takes zero or more arguments. The second function returns <code>int</code>.</p>

<p>You can use a program (and website, now) called ""<a href=""http://www.cdecl.org/"" rel=""nofollow noreferrer"">cdecl</a>"" to help with these, it says:</p>

<ul>
<li><code>(char *(*)())</code>: cast unknown_name into pointer to function returning pointer to char</li>
<li><code>(int (*)())</code>: cast unknown_name into pointer to function returning int</li>
</ul>
",3
1797415,1797387,0,"<p>It means that the first argument of <code>read</code>, named <code>Blub</code> is a pointer to a function that returns a <code>char *</code> and receives no arguments.</p>
",0
1797468,1797387,0,"<p>First one says that read takes ""a function pointer that returns a char pointer"" as first argument and ""pointer to a char pointer"" as second argument. If you want to do Bla, just write Bla(x), I ll handle de read part!</p>

<p>Second one says that, first parameter to PEM_ASN1_write_bio must be ""a function pointer returning an int"". And the second argument is ""a pointer to a char"". And you can use XXX(a,b) instead of PEM_ASN1_write_bio(b,a), thats all</p>
",0
1797776,1797387,1,"<p><code>(int (*)())</code> is a typecast operator, which is to say you ask the compiler to behave
as if the expression on its right were of type <code>int (*)()</code>. As others have indicated,
the type in question means ""a pointer to a function accepting any arguments,
and returning an <code>int</code>"".</p>

<p>To understand the type itself, you first need to understand the weird way in which
variables are declared in C: in most languages, the syntax for variable declarations
is constructed from the syntax for type specifications, but in C, in a way,
it's the other way around.</p>

<p>If you were to declare a variable containing a pointer to such a function, you would write:</p>

<pre><code>int (*fp)();
</code></pre>

<p>meaning that an expression resembling <code>(*fp)()</code> would be of type <code>int</code>: ""take <code>fp</code>,
dereference it, call that with any arguments and you will get an <code>int</code>"".</p>

<p>Now, in order to obtain a typecast operator for the type of <code>fp</code> in the above declaration, lose the identifier and add parentheses around: you get <code>(int (*)())</code>.</p>
",0
1797882,1797387,3,"<p>The easiest way of deciphering complex C expressions is to start with the innermost expression, then in an anti-clockwise pattern move on to the next.
(int (*)())</p>

<ol>
<li>(*) A Pointer, anti-clockwise motion hits on (, then move on again to hit on )</li>
<li>(*)() A pointer to function, move on to (, then move on again to )</li>
<li>int (*)() A pointer to a function returning int, move on to int, then move on to hit on )</li>
<li>(int (*)()) finally move on to (, and there you have it, </li>
</ol>

<p>A pointer to a function returning int, since it is wrapped in the outer () is because of the macro.</p>

<p>Hope this helps,
Best regards,
Tom</p>
",0
1406266,1406256,-1,"<p>lookup gets(), getc() etc - </p>
",2
1406353,1406256,2,"<p>As commented, you're question contains the answer already. But anyway:</p>

<p>If you want do the same thing in c++, you could use streams:</p>

<pre><code>int mynumber;
char mychar;
cout &lt;&lt; ""Number?"" &lt;&lt; endl;
cin &gt;&gt; mynumber;
cout &lt;&lt; ""Character?"" &lt;&lt; endl;
cin &gt;&gt; mychar;
cout &lt;&lt; ""you typed number "" &lt;&lt; mynumber &lt;&lt; "" and char "" &lt;&lt; mychar &lt;&lt; endl;
</code></pre>

<p>Of course, your C implementation would work just as well in C++.</p>

<p>(If you are developing a more serious application, I would recommend using something more sophisticated than just cin or scanf)</p>
",0
1406723,1406256,3,"<p>The problem you're seeing is that it really is reading a character, but it's just not the character you're expecting.  scanf does formatted input.  The first time you call it, you're telling it to expect a number.  But you're really entering more than just a number:</p>

<pre><code>Number?
1234.5678&lt;enter&gt;
</code></pre>

<p>When you press the enter key, it is actually inserting a character into your input stream.  As you may know, we use \n to represent newline, the character you get when you press enter.  So your input stream actually looks like ""1234.5678\n"".</p>

<p>So scanf does its thing and reads 1234.5678 and then it sees '\n'.  It says ""oh, that's not part of the number, so I'll stop.""  Well, your input still has the '\n'.  The next time you call scanf, you tell it to read a character.  The user types whatever they want, but that goes behind the '\n' from the previous scanf.  So scanf tries to match the input stream with a character and says ""ok, the first thing in this input stream is a character, and it's '\n', so I'll return that.""  The stuff the user typed is still sitting in the input stream.</p>

<p>So a simple way to get rid of it is to have a loop that empties all remaining characters from the input stream until it finds '\n'.</p>

<pre><code>printf(""Number?\n"");
scanf(""%f"", &amp;number1);
while( getchar() != '\n');
</code></pre>

<p>After this loop executes, your input stream will be empty.  So the next time you call scanf, it'll wait for the user to type something and will use whatever the user typed.</p>

<p>Also note that scanf has a return value that you should check after calling it.  Read up about scanf to see what it returns.</p>
",2
1406435,1406256,2,"<p>In C you don't need to use scanf to get single characters.  You could use the getchar() function:</p>

<pre><code>printf(""Would you like a donut? [Y/N] "");
answer = getchar();

switch(answer) {
    case 'y':
    case 'Y':
        printf(""Mmmm... donuts!"");
        break;
    case 'n':
    case 'N':
        printf(""Eugh... donuts?"");
        break;
    default:
        printf(""You should never ignore code offering donuts."");
        break;
}  
</code></pre>
",1
1786570,1786497,-2,"<p>The problem is with sprintf</p>

<pre><code>sprintf(aa,""%lf"",a);
</code></pre>

<p>%lf says to interpet ""a"" as a ""long double"" (16 bytes) but it is actually a ""double"" (8 bytes).  Use this instead:</p>

<pre><code>sprintf(aa, ""%f"", a);
</code></pre>

<p>More details <a href=""http://www.cplusplus.com/reference/clibrary/cstdio/sprintf/"" rel=""nofollow noreferrer"">here on cplusplus.com</a></p>
",4
1786516,1786497,7,"<p>You need to write it like <code>sprintf(aa, ""%9.7lf"", a)</code></p>

<p>Check out <a href=""http://en.wikipedia.org/wiki/Printf"" rel=""noreferrer"">http://en.wikipedia.org/wiki/Printf</a> for some more details on format codes.</p>
",4
1786866,1786497,34,"<p>From your question it seems like you are using C99, as you have used <code>%lf</code> for double.</p>

<p>To achieve the desired output replace:</p>

<pre><code>sprintf(aa, ""%lf"", a);
</code></pre>

<p>with</p>

<pre><code>sprintf(aa, ""%0.7f"", a);
</code></pre>

<p>The general syntax <code>""%A.B""</code> means to use B digits after decimal point. The meaning of the <code>A</code> is more complicated, but can be read about <a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""noreferrer"">here</a>.</p>
",2
1896901,1896837,4,"<p>I think using <code>fgetc</code> (or <code>getc</code>) is a better solution in this case, but the other answers are wrong about <code>fscanf</code> in this case.  The <code>scanf</code> family of functions will not skip whitespace if you use <code>""%c""</code> as the format.  The reason your call doesn't work is because you have a whitespace in your format!  So, instead of <code>"" %c""</code> as the format, you need to use <code>""%c""</code> without the leading space.  The leading space is telling <code>fscanf</code>: skip all whitespace and then give me the next non-whitespace character.  <code>fscanf</code> does this, making sure that any value you get in <code>x</code> is <em>not</em> a whitespace.  Thus, your <code>isspace</code> test is testing a condition that is already known to be false!</p>

<p>You can easily fix it by changing your format specification to <code>""%c""</code>.</p>

<p>Having said that, I think it's much better to use <code>fgetc</code>/<code>getc</code> anyway because, as you have found out, <code>scanf</code> family of functions are hard to get right.</p>
",0
1896845,1896837,3,"<p>As I've pointed out before, you need to use fgetc(), not fscanf(). fscanf() doesn't read whitepace.</p>
",2
1896847,1896837,4,"<p>scanf-family functions will automatically skip whitespace when it's present in the format string. Consider using <code>fgetc</code> instead.</p>
",0
1788132,1788117,7,"<p>I should stress first that this is usually a spectacularly bad usage for recursion. The best recursive solutions tend to reduce the ""search space"" of the solution rather quickly, such as a binary search removing half the remaining search space with every iteration.</p>

<p>Repeated subtraction will, if the subtrahend is relatively small compared to the minuend (where <code>minuend - subtrahend</code> gives you the difference), result in a great many recursive calls and quite possibly exhaust your stack space.</p>

<hr>

<p>Having said that, the solution below is in pseudo-code only, since it's probably homework:</p>

<pre><code>def divu (a, b):
    if a &lt; b return 0
    return divu (a - b, b) + 1
</code></pre>

<p>It works by repeatedly subtracting <code>b</code> from <code>a</code>, and going down a level, until you can no longer subtract <code>b</code> from <code>a</code> without going negative. Then it returns up the recursion tree, adding 1 for each level you went down.</p>

<p>This will only work for non-negative values of <code>a</code> and positive values of <code>b</code> (hence the <code>divu</code> name for unsigned), though fixing it for negatives and divide-by-zero is only a little extra work.</p>

<p>Some hints for handling signs and errors:</p>

<ul>
<li>Detect straight up if b is equal to zero and exit with an error, exception, or some other mechanism.</li>
<li>Treat <code>-a / -b</code> as <code>a / b</code>.</li>
<li>Treat <code>-a / b</code> as <code>-(a / b)</code>.</li>
<li>Treat <code>a / -b</code> as <code>-(a / b)</code>.</li>
<li>Otherwise, just work out <code>a / b</code>.</li>
</ul>

<p>It's possible to handle those special cases in a single recursive call but it adds unnecessary checking at <em>each</em> level of recursion. It's probably more efficient to provide a checking function <code>div</code> which can then call <code>divu</code> to do the recursive bit, something like:</p>

<pre><code>def div (a, b):
    if b == 0
        exit with error
    if a &lt; 0 and b &lt; 0:
        return divu (-a, -b)
    if a &lt; 0:
        return -divu (-a, b)
    if b &lt; 0:
        return -divu (a, -b)
    return divu (a, b)
</code></pre>
",0
1311704,1311683,6,"<p>The easiest way might be to memory-map the whole file using <strong>mmap</strong>. With mmap you get access to the file as a long memory buffer that you can modify with changes being reflected on disk. Then you can find the offset of that line and move the whole tail of the file that many bytes back to overwrite the line.</p>
",3
1311742,1311683,1,"<p>For sequential files, no matter what technique you use to delete line 2, you still have to write the file back to disk. </p>
",0
1311773,1311683,3,"<p>you should not overwrite the file, better is to open another (temp)-file, write contents inside and then delete old file and rename the file. So it is safer if problems occur.
I think the easiest way is to </p>

<ol>
<li>read whole file </li>
<li>modify contents in memory</li>
<li>write back to a temp file</li>
<li>delete original file</li>
<li>rename temp file to original file</li>
</ol>

<p>Sounds not too illogical to me..</p>
",0
1898413,1898371,0,"<p>Your function, <strong>as is</strong>, works for me.</p>

<p>I suppose you're calling it wrong. I call it like this</p>

<pre><code>char a[100];
memsetFun(a, 0, sizeof a);
int b[100];
memsetFun(b, 0, sizeof b);
</code></pre>

<p>How are you calling your <code>memsetFun()</code>?</p>

<p><em>Edit</em></p>

<p>With</p>

<pre><code>int b[100];
memsetFun(b, 9, sizeof b);
</code></pre>

<p>as an int is made up of 4 bytes (on my system) each value will be set to <code>0x09090909</code> or <code>151587081</code>.</p>
",0
1898414,1898371,0,"<p>I ran a test if your program setting the memory of an int vector of 5 elements setting with the value 0x01. </p>

<p>The problem here is that you are iterating in a vector of int for example (which is 4 bytes) but iterating over it using char pointer arithmetic (1 byte). If you want to memset 0x01 for example you will write this number per value in the vector: 00000001000000010000000100000001
which gives me the same value using the original memset.</p>
",4
1898425,1898371,4,"<p>Your code looks fine to me and several people here have commented that it works on their system.</p>

<p>So the obvious thing to do is to debug it - that's a skill that will come in handy quite a bit in future :-) You should learn it <em>now</em>.</p>

<p>What does the following code output when you run it?</p>

<pre><code>void* memsetFun(void* pointer, int c, int size) {
    printf(""A %x %d %d\n"", pointer, c, size);
    if ( pointer != NULL &amp;&amp; size &gt; 0 ) {
        printf(""B\n"");
        unsigned char* pChar =  pointer;
        int i = 0;
        for ( i = 0; i &lt; size; ++i) {
            printf(""C %d (%d)"", i, *pChar);
            unsigned char temp = (unsigned char) c;
            *pChar++ = temp; // or pChar[i] = temp (they both don't work)
            printf("" -&gt; (%d)"", i, *(pChar-1));
        }
    }  
    printf(""D\n"");
    return pointer;
}
</code></pre>

<p>From the output, it should be clear what paths the code is taking and what your parameters are (which will greatly assist the debugging process).</p>

<p><em>Update:</em></p>

<p>If you're filling your memory block with anything other than zeros and using this:</p>

<pre><code>printf(""value at %p is %d\n"", address, *((int*) address));
</code></pre>

<p>to print it out, you <em>will</em> get strange results.</p>

<p>You're basically asking for a number of those bytes to be interpreted as an integer. So, for example, if you filled it with <code>0x02</code> bytes and you have a 4-byte integer type, you will get the integer <code>0x02020202</code> (33686018), <em>not</em> <code>0x02</code> as you may expect. If you want to see what the first <em>character</em> value is, use:</p>

<pre><code>printf(""value at %p is %d\n"", address, *((char*) address));
</code></pre>

<p>And based on your <em>latest</em> question update:</p>

<blockquote>
  <p>For example, if you to print the chars ( c ) it prints like a weird char that looks like ( for the value 4 )<br>
  0 0<br>
  0 4</p>
</blockquote>

<p>If that's a single character and you're printing it as a character, there's probably nothing wrong at all. Many output streams will give you that for a control character (CTRL-D in this case, ASCII code 4). If you instead filled it with ASCII code 0x30 (48), you would see the character '0' or ASCII 0x41 (65) would give you 'A'.</p>
",6
1898450,1898371,0,"<p>That is exactly what it's supposed to do. Your function is working perfectly fine. The value ""0x4"" is <em>not</em> the ASCII character '4'.</p>
",0
1898471,1898371,1,"<p>As pointed out already, your function works as it should. Here is a complete example:</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;string.h&gt;

void* memsetFun(void* pointer, int c, int size) {
    if ( pointer != NULL &amp;&amp; size &gt; 0 ) {
        unsigned char* pChar =  pointer;
        int i = 0;
        for ( i = 0; i &lt; size; ++i) {
            unsigned char temp = (unsigned char) c;
            *pChar++ = temp; // or pChar[i] = temp (they both don't work)
        }
    }
    return pointer;
}

int main() {
    // Your memset
    char a[10];
    memsetFun(a, 'A', sizeof(a));

    // Uses system memset for verification
    char b[10];
    memset(b, 'A', sizeof(b));

    assert(sizeof(a) == sizeof(b));
    assert(memcmp(a, b, sizeof(b)) == 0);
    return 0;
}
</code></pre>
",0
1898383,1898371,0,"<p><code>return p;</code> prevents this from compiling:  <code>p</code> is not defined.</p>

<p>A minor efficiency issue¡ªin practice it would have little effect, since any good compiler would rearrange it, but coding perfectionists wouldn't allow it to remain¡ªthe assignment to <code>temp</code> is inside the loop, but it is the same assignment every time.  That is, the assignment to <code>temp</code> can be moved before the loop.</p>
",1
1898384,1898371,0,"<p>You return <code>p</code>, which isn't defined/doesn't point to anything in particular.  Maybe you meant <code>pointer</code>?</p>
",0
1898392,1898371,0,"<p>The code is logically correct. With the <code>p</code> => <code>pointer</code> change it works correctly.</p>

<p>Clarify how exactly it is ""not working"". Perhaps you are not understanding what it is supposed to do?</p>
",2
1898401,1898371,0,"<p>You are probably getting trash numbers because you are casting from an int (4 bytes) to an unsigned char (1 byte), so if c > 255 or &lt; 0 you won't be memsetting the values you are expecting to be.</p>
",1
1915770,1915757,1,"<p>looks like C, and it means the pointer to memory location 0. (""void *"" means a pointer to raw memory and is a note to the compiler/programmer that the type is unknown or unspecified)</p>

<p>clarification: It is a pointer containing the value 0, which on most platforms is a special value known as NULL indicating an invalid/uninitialized pointer, and dereferencing it causes an exception. On some platforms (some microcontrollers for instance) memory location 0 is a valid pointer value.</p>
",16
1915777,1915757,8,"<p>In C, it means a NULL pointer, i.e., a pointer that points to no relevant data.</p>

<p>Trying to access this data raises a Segmentation Fault, at least on Unix/Linux.</p>
",8
1915778,1915757,1,"<p>It's a C/C++ null pointer AFAIR :)</p>
",0
1915782,1915757,0,"<p>Weird C notation. If I had to guess I'd say this guy is trying to force a binary 0 into a pointer on some platform where NULL is not binary 0.</p>
",4
1915784,1915757,1,"<p>The cast suggests C or C++.  That's an integer zero cast to a pointer type, which means it's the null pointer.  It's a standard way to define the null pointer in C (except that <code>(void *)0</code> is more commonly used), but in C++ it's a null pointer value of a particular type.</p>
",3
1916454,1915757,3,"<pre><code>#ifndef NULL
#   define NULL ((void *) 0)
#endif
</code></pre>

<p>Then you can use NULL in different functions!</p>
",1
1783650,1774851,15,"<p>You can access the BIOS settings via I/O port 70h and 71h.  (Some chipsets also have an extended CMOS at 72/73 or similar.)</p>

<p>What OS are you using?  If you are running Windows, you won't be able to do port I/O directly from an application, you'll have to write a kernel mode driver, or use a third-party toolkit like WinIO.  Under Linux, you can use /dev/nvram to get at the CMOS settings.  (Assuming the Linux nvram driver has support for your chipset.  Otherwise use /dev/port.)</p>

<p>Once you get at the CMOS bits, the next task will be figuring out which location in CMOS corresponds to the Video Memory Setting.</p>

<p>Here is a (woefully incomplete) map of CMOS memory locations:
<a href=""http://ivs.cs.uni-magdeburg.de/~zbrog/asm/cmos.html"" rel=""noreferrer"">http://ivs.cs.uni-magdeburg.de/~zbrog/asm/cmos.html</a></p>

<p>The map of CMOS locations is extremely specific to the motherboard, BIOS, and BIOS rev.  (The CMOS map can change between BIOS revs as new menu options are added/removed.)  Maybe your motherboard vendor can provide you with a CMOS map.  They have the tools to generate such a map (it is part of the BIOS compilation process), but they may not be willing to share it.</p>

<p>Without a map, there are other methods to determine which bits in CMOS represent the Video Memory Size.  Try dumping the CMOS settings with various memory sizes and figure out which bits change.</p>

<p>Some other details:</p>

<ol>
<li><p>Outside of a few ""standard"" CMOS bits, most of them are extremely platform dependent, I hope you weren't planning on making a general-purpose application out of this.</p></li>
<li><p>There are checksums at certain offsets in CMOS.  After you change the CMOS value, you will have to fix up the checksum to reflect the changes.</p></li>
<li><p>Once you change the setting, it won't take effect to the next reboot (when the BIOS reads the CMOS settings and initializes the chipset).</p></li>
<li><p>Is this an Intel chipset?  Intel graphics cores have a magic feature called Dynamic Video Memory Technology (DVMT) which tweaks video memory usage based on how graphics-intensive the running application is.  <a href=""http://www.intel.com/support/graphics/sb/cs-010488.htm"" rel=""noreferrer"">http://www.intel.com/support/graphics/sb/cs-010488.htm</a>  I'm not sure if other chipset vendors have a similar technology.</p></li>
<li><p>Throw all of this out the window on a modern UEFI system, which typically uses a nonvolatile storage partition in the BIOS flash chip for the settings.  (Some CMOS locations are populated for legacy compatibility on a UEFI system.)</p></li>
</ol>
",0
1498037,1498023,11,"<p>You're not mentioning a platform, and this is outside the support of the language itself.</p>

<p>For POSIX/Unix/Linux, look into <code><a href=""http://www.opengroup.org/onlinepubs/009695399/functions/dlopen.html"" rel=""nofollow noreferrer"">dlopen()</a></code> and friends.</p>

<p>In Windows, use <code><a href=""http://msdn.microsoft.com/en-us/library/ms684175%28VS.85%29.aspx"" rel=""nofollow noreferrer"">LoadLibrary()</a></code>.</p>

<p>Basically, these will allow you to load code from a platform-specific file (.so and .dll, respectively), look up addresses to named symbols/functions in the loaded file, and access/run them.</p>

<p>I tried to limit myself to the low-level stuff, but if you want to have a wrapper for both of the above, look at glib's <a href=""http://library.gnome.org/devel/glib/stable/glib-Dynamic-Loading-of-Modules.html"" rel=""nofollow noreferrer"">module API</a>.</p>
",3
1498110,1498023,0,"<p>Do you need to be able to add these extensions to the running program, or at least after the executable file is created? If you can re-link (or even re-compile) the program after having added an extension, perhaps simple callbacks would be enough?</p>
",0
1498235,1498023,1,"<p>You can extend your core C/C++ program using some script language, for example - <a href=""http://www.lua.org/"" rel=""nofollow noreferrer"">Lua</a>
There are several C/C++ - Lua integration tools (<a href=""http://www.tecgraf.puc-rio.br/~celes/tolua/"" rel=""nofollow noreferrer"">toLua</a>, <a href=""http://www.codenix.com/~tolua/"" rel=""nofollow noreferrer"">toLua++</a>, etc.)  </p>
",0
1498285,1498023,2,"<p>The traditional way on windows is with DLLs.  But this kind of obselete.  If you want <em>users</em> to actually extend your program (as opposed to your developer team releasing official plugins) you will want to embed a scripting language like Python or Lua, because they are easier to code in.</p>
",0
1498757,1498023,0,"<p>If you're using Windows you could try using <a href=""http://www.microsoft.com/com/default.mspx"" rel=""nofollow noreferrer"">COM</a>. It requires a lot of attention to detail, and is kind of painful to use from C, but it would allow you to build extension points with well-defined interfaces and an object-oriented structure.</p>

<p>In this usage case, extensions label themselves with a 'Component Category' defined by your app, hwich allows the Core to find and load them withough havng to know where their DLLs are. The extensions also implement interfaces that are specified using IDL and are consumed by the core.</p>

<p>This is old tech now, but it does work.</p>
",0
1892292,1892287,0,"<p>Until you show some of the code, I can't be sure of anything. </p>

<p>But AFAIK you shouldn't be able to print out a negative number if you're printing out an <code>uint</code> ¨C?even if it overflows, the integer will always hold a positive number, as far as C is concerned. </p>

<p>So there's something else wrong. </p>
",0
1892304,1892287,1,"<p>Without seeing your code, I am guessing you are using %d or %i in the printf statement.  Use %u instead.</p>
",0
1892307,1892287,1,"<p>Print unsigned values using ""%u"" instead of ""%d"".</p>
",0
1892318,1892287,0,"<p>Use correct format specifier.</p>

<p>%d for int<br>
%u for unsigned int.</p>

<p>Using incorrect format specifier in printf() may cause <strong>Undefined Behavior</strong>.</p>

<p>For example, the following code invokes <em>Undefined Behavior(UB)</em>.</p>

<pre><code>#include&lt;stdio.h&gt;
int main(void)
{
    unsigned int z=Some_value; /*Some_value is an unsigned int */
    printf(""%d"",z); 
  /*UB as format specifier for unsigned int is incorrect,it should be %u not %d*/
}
</code></pre>
",0
1892902,1892287,0,"<p>I guess int is 16bit on your machine/compiler.</p>

<p>Though I don't know what your platform is, I guess that <strong>long</strong> would solve your problem (it is 32bit or more on all platforms I know). Print it with <strong>%ld</strong> instead of %d.</p>

<p>Don't get tempted to use unsigned and %u, because they will just give you numbers up to 65536, and I guess that you want more.</p>
",0
1705697,1705688,1,"<p>You need two data structures.  An array to hold the numbers, and a map from the name to the index in the array.  In C++ you'd use one of the map classes in the standard library.  I don't know what's available in C but I'm sure there are map implementations available.</p>
",1
1705699,1705688,7,"<pre><code>struct car {
    const char *name;
    int count;
} my_cars[] = {{""Saab"", 2}, {""Honda"", 3}, {""Porsche"", 0}};
int i;
for (i = 0; i &lt; sizeof(my_cars) / sizeof(my_cars[0]); i++)
    printf(""%s: %d\n"", my_cars[i].name, my_cars[i].count);
</code></pre>
",2
1705702,1705688,6,"<p>To do that you should use an array instead of standalone data fields</p>

<pre><code>#include &lt;stdio.h&gt;

typedef enum CarType {
  CART_SAAB,
  CART_HONDA,
  CART_PORSHE,

  CART_COUNT_
} CarType;

typedef struct MyCars {
  unsigned ncars[CART_COUNT_];
} MyCars;

int main(void)
{
  MyCars my_cars = { 0 } ;
  unsigned i;

  my_cars.ncars[CART_SAAB] = 2;
  my_cars.ncars[CART_HONDA] = 3;

  for (i = 0; i &lt; CART_COUNT_; ++i)
    printf(""%u\n"", my_cars.ncars[i]);

  return 0;
}
</code></pre>
",3
1705703,1705688,3,"<p><code>enum Makes { SAAB, HONDA, PORSCHE, INVALID };<br>
int my_cars[INVALID];<br>
my_cars[SAAB] = 2;<br>
my_cars[HONDAS] = 3;<br>
my_cars[PORSCHE] = 0;</code></p>
",0
1705708,1705688,5,"<p>C can do anything any other language can do. This does look like homework and I bet you are expected to make something with a key. Remember, your instructor wants you to use the data structures he or she is trying to teach you. He doesn't really want the problem solved in any random way, he wants it solved applying the topics you have been discussing.</p>

<p>So think about a data structure containing both strings and counts, one that can be searched, and provide functions to do that. What you are likely to get here are nice, professional, simple solutions to the problem. And that's not really what your instructor wants...</p>
",0
1705711,1705688,0,"<p>There are maybe a couple of options.</p>

<p>It is possible to have the same space in memory defined (and used) in two different ways. In other words, you could have a struct with the named members and reference it either as the struct or as an array depending on how you intended to address it.</p>

<p>Alternatively, you could do an enumerated typedef that names the locations in the array, e.g.</p>

<pre><code>typedef enum {
  SABS = 0,
  HONDAS,
  PORSCHES
} cars;
</code></pre>

<p>This would then allow you to refer to offsets in the array by name, e.g.</p>

<pre><code>mycars[SABS] = 5;
</code></pre>
",0
1705718,1705688,0,"<p>Umm...based on what you've pseudo coded up there you could probably use a union.  The answers others are giving seem oriented around allowing a mapping between names and numbers.  If thats what you're looking for (as in, being able to print the names) then their answers will be better. However it sounds like to me you're simply looking for clarity in the code to allow you to reference things by name or number, in this case a union would be ideal I think.  This is exactly the type of thing a low level language like C lets you do.</p>

<pre><code>union my_cars {
    struct names {
        int saab;
        int ford;
        ...
    }

    int[NUM_MAKES] nums;
}
</code></pre>

<p>You will have to be careful to ensure NUM_MAKES is in sync with the number of makes you define.  Then you can do something like:</p>

<pre><code>my_cars.names.saab = 20;
my_cars.nums[0] = 30;
</code></pre>

<p>And modify the same element.</p>

<p>FYI, my C is a little rusty so there may be syntax errors there, feel free to correct.</p>

<p>EDIT:</p>

<p>Ahh, I read some of the other answers using ENUMs or DEFINEs and those might actually be simpler/easier than this one...but unions are still worth knowing.  </p>
",6
1705735,1705688,1,"<p>The low-level C way to do this would be to wrap the cars structure into a union:</p>

<pre><code>// define a structure for the cars.
typedef struct 
{
    int saabs;
    int hondas;
    int porsches;
} cars;

// wrap it into a union:
typedef union 
{
  cars byname;
  int  byid[3]; // Note: Number and type must match with the cars structure. 
} cars2;

int main (int argc, char **arg)
{
  cars2 my_cars;
  int i;

  // fill out by name:
  my_cars.byname.saabs = 1;
  my_cars.byname.hondas = 5;
  my_cars.byname.porsches = 3;

  // print by index:
  for (i=0; i&lt;3; i++)
    printf (""%d\n"", my_cars.byid[i]);
}
</code></pre>
",0
1985179,1985094,0,"<p>There's no need to check the value of <code>errno</code> within your function: just check the return value of <code>stat()</code> and let the caller handle specific errors, eg</p>

<pre><code>errno = 0;
is_refreshing_needed(""foo"");
if(errno) switch(errno)
{
    case ENOENT:
    puts(""file not found"");
    break;

    /* ... */

    default:
    puts(""unexpected error condition"");
}
</code></pre>
",0
1985117,1985094,1,"<p>The man page for <code>stat(2)</code> on my system states:</p>

<pre>
RETURN VALUES
     Upon successful completion, the value 0 is returned; otherwise the
     value -1 is returned and the global variable errno is set to indicate the
     error.
</pre>

<p>You must check the return value of the call to <code>stat()</code> to determine whether the call succeeded or failed. So:</p>

<pre><code>if (stat(path, &amp;file) != 0) {
    return 0;
}
</code></pre>
",0
1985119,1985094,1,"<p>Here is a list of error value from <a href=""http://linux.die.net/man/2/stat"" rel=""nofollow noreferrer"">man page</a>:</p>

<blockquote>
  <p><strong>EACCES</strong> Search permission is denied for
  one of the directories in the path
  prefix of path.</p>
  
  <p><strong>EBADF</strong> filedes is bad.</p>
  
  <p><strong>EFAULT</strong> Bad address.</p>
  
  <p><strong>ELOOP</strong> Too many symbolic links
  encountered while traversing the path.</p>
  
  <p><strong>ENAMETOOLONG</strong> File name too long.</p>
  
  <p><strong>ENOENT</strong> A component of the path path
  does not exist, or the path is an
  empty string.</p>
  
  <p><strong>ENOMEM</strong> Out of memory (i.e. kernel
  memory).</p>
  
  <p><strong>ENOTDIR</strong> A component of the path is not
  a directory.</p>
</blockquote>

<p>Use this constants instead of number value.</p>
",0
1985120,1985094,0,"<p>You should use constants (because they are defined in stat.h):</p>

<blockquote>
  <p>The stat() function shall fail if:</p>

<pre><code>   EACCES Search permission is denied for a component of the path prefix.

   EIO    An error occurred while reading from the file system.

   ELOOP  A loop exists in symbolic links encountered during resolution of 
          the path argument.

   ENAMETOOLONG
          The length of the path argument exceeds {PATH_MAX} or a pathname
          component is longer than {NAME_MAX}.

   ENOENT A component of path does not name an existing file or path is an 
          empty string.

   ENOTDIR
          A component of the path prefix is not a directory.

   EOVERFLOW
          The file size in bytes or the number of blocks allocated to the file
          or the  file serial number cannot be represented correctly in the 
          structure pointed to by buf.

   The stat() function may fail if:

   ELOOP  More  than  {SYMLOOP_MAX}  symbolic  links were encountered during 
          resolution of the path argument.

   ENAMETOOLONG
          As a result of encountering a symbolic link in resolution of the 
          path argument, the length of the substituted pathname string 
          exceeded {PATH_MAX}.

   EOVERFLOW
          A value to be stored would overflow one of the members of the stat 
          structure.
</code></pre>
</blockquote>

<p>from man -s3 stat</p>
",0
1985121,1985094,0,"<p>When stat fails it's return -1 ;></p>

<p>so </p>

<pre><code>if (stat() == -1)
    // stat fail
else
    // can refresh if needed
</code></pre>
",0
1985144,1985094,0,"<p>""man stat"" is your friend.  This is from the 'return values"" section of the man page:</p>

<p>""Upon successful completion, 0 is returned. Otherwise, -1  is returned and errno is set to indicate the error.""</p>

<p>The return values include: 
EOI, EOVERFLOW, EACCESS, EFAULT
and there are others.  These errors are errors from the stat() system call and will <em>not</em> change with gcc/glibc version. </p>

<p>to access the error information, you need to include </p>

<p><code>#include &lt;errno.h&gt;</code></p>

<p>and you can use the perror() function to get the error text (you need to <code>#include &lt;stdio.h&gt;</code> for the perror() declaration).  see ""man perror"" for more information. </p>

<p>also, please don't use numbers like 2 (No such file or directory) and 13 (Permission denied).  please use the #define'ed names to make the code easier to read. </p>

<p>good luck!</p>
",0
1807694,1807296,1,"<p>You have two possibilities.<br>
Either you can iterate through the list (with ""while"") looking for the necessary element and return the found value afterwards, or you can recursively call the same function on the list which contains one element less each step and then look only for the first element of the list. In this case you should call this function unless you have no more elements or you have the necessary element found.<br>
If you provide the code you have created, the society definitely will help you to fix it.</p>
",0
1719668,1719662,32,"<p>You have declared your struct in between (or possibly after) your declarations of <code>f2</code> and <code>f1</code>.  Move your struct declaration so that it comes before both declarations.</p>

<p>That is to say:</p>

<pre><code>struct user_data_s
{
    int L;
};

void f2(struct user_data_s* data) {
      printf(""Number %i\n"", data-&gt;L);
}

void f1(struct user_data_s* data) {
      printf(""Number %i\n"", data-&gt;L);
        f2(data);
}
</code></pre>

<p>compiles without errors, but</p>

<pre><code>void f2(struct user_data_s* data) {
      printf(""Number %i\n"", data-&gt;L);
}


struct user_data_s
{
    int L;
};

void f1(struct user_data_s* data) {
      printf(""Number %i\n"", data-&gt;L);
        f2(data);
}
</code></pre>

<p>will not compile, because <code>f2</code> has no way to know what a <code>struct user_data_s</code> is.</p>

<p>You might be used to programming in a higher-level language that lets you place your declarations/definitions pretty much anywhere (such as C# or Python), but unfortunately, C is compiled strictly top-to-bottom.</p>
",3
1719671,1719662,7,"<p>The compiler already gave you a pretty good explanation of what's going on.</p>

<p>You haven't declared <code>struct user_data_s</code> anywhere in advance. The compiler sees <code>struct user_data_s</code> in the above function definitions for the very first time ever. In each case the declaration of <code>struct user_data_s</code> has block scope, i.e. it is local to the corresponding function. This means that the first declaration of <code>struct user_data_s</code> in the <code>f1</code> definition is completely unrelated the the second declaration of <code>struct user_data_s</code> in <code>f2</code> definition. These declarations declare two completely different local (to each function) types <code>struct user_data_s</code>. You can't call <code>f2</code> from <code>f1</code> as in your example since their parameter types are completely unrelated.</p>

<p>Normally, you should have <code>struct user_data_s</code> declared at file scope in advance, instead of declaring it in function definition. Did you forget to include a header with the declaration of <code>struct user_data_s</code> by any chance?</p>
",1
1777576,1777570,8,"<p>Your code is not working because you are checking the value of the pointer (the memory address) not the value of the thing being pointed at. Remember a pointer is an address, you have to <strong>dereference</strong> it to get the value at that address.</p>

<p>Once dereferenced, you can simply do a comparison with a char type to those values:</p>

<pre><code> char ascii_char = *ascii;

 if ( ascii_char == 32 || ((ascii_char &gt; 96) &amp;&amp; (ascii_char &lt; 123)) 
 {

 }
</code></pre>
",1
1777580,1777570,3,"<p>Just put a * before the variable name</p>

<pre><code>if ( *ascii == 32 || ((*ascii &gt; 96) &amp;&amp; (*ascii &lt; 123)) {

}
</code></pre>

<p>or just assign it to another variable and use it instead</p>

<pre><code>int a = *ascii
if ( a == 32 || ((a &gt; 96) &amp;&amp; (a &lt; 123)) {

}
</code></pre>
",1
1777581,1777570,0,"<p>I believe this will do the trick</p>

<pre><code>int asciiNum = (int)*ascii;
</code></pre>
",0
1777583,1777570,0,"<p>If you are not referring to comparing just the first char but the number stored in that ascii pointer then use atoi() function to convert the char array to a number and then compare.</p>
",2
1777965,1777570,1,"<p>Why do you go for ASCII value?</p>

<p>Following would be more readable way:</p>

<p>char ascii_char = *ascii;</p>

<p>if ( ascii_char == ' ' || ((ascii_char >= 'a') &amp;&amp; (ascii_char &lt;= 'z')) </p>

<p>{</p>

<p>}</p>
",0
1794508,1791130,1,"<p>You need to put your receive out before you send the packet request, or else the response probably comes back before you are ready to receive it.</p>

<p>Also, is the response broadcast? If not, and you don't currently have an IP address assigned to your machine, then you're going to have some trouble receiving it because your host will filter received packets by IP address won't know that the response is destined for it (even though the link layer address matches), so it'll not deliver it.</p>

<p>But my guess is it's the first problem. You'll have to either use threads or do a non-blocking receive, or else your receive will block and thus you'll never getting around to sending the request.</p>
",0
1928192,1928155,5,"<p>No, there is no way of doing that. You need to use a loop, or assign each value individually. </p>
",0
1928193,1928155,0,"<p>Have you tried this:</p>

<pre>
char a[] = {0, 1, 2, 3, 4};
</pre>

<p>The compiler will automatically set this to be an array of 5, initialized with each element corresponding to their value and index.</p>

<p><strong><em>Edit:</em></strong>
Looking at it again, I realized what you were looking for. In short the compiler will not accept this. </p>

<p>Hope this helps,
Best regards,
Tom.</p>
",0
1928212,1928155,1,"<p>You could do <code>memcpy(a, ""\0\1\2\3\4"", 5);</code>, but it's bad practice and coding style.</p>

<p>Short of that no you can't.</p>
",0
1928256,1928155,-2,"<p>sprintf( a, ""%d%d%d%d%d"", 0,1,2,3,4 );</p>

<p>Changed my answer.</p>
",4
1928271,1928155,2,"<p>Well, you <em>could</em> set up a template to be copied into it later:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

static char a_src[] = {0,10,20,30,40};
int main() {
    char a[5];

    memcpy (a, a_src, sizeof(a_src));
    printf (""%d\n"", a[3]);
    return 0;
}
</code></pre>

<p>Outputs 30 when run.</p>

<p>But this is still techically sourcing the data at compile-time. If you <em>really</em> want to do it at runtime (with calculated values), you need to do it element by element.</p>
",0
1928275,1928155,2,"<pre><code>
char a[5];

//run some code here
//then

static const char a_01234[sizeof(a)] = {0,1,2,3,4};
memcpy(a, a_01234, sizeof(a));
</code></pre>
",0
1929256,1928155,0,"<p>You could use a pointer and reference it as an array.</p>

<pre><code>char * a;
char b[5] = {0,1,2,3,4};
char c[5] = {5,6,7,8,9};

//run some code here
//then

a = b;  // ""Populate"" the ""array""

// Then reference a using array notation
printf (""%d\n"", a[3]);  // Print the number 3

// run some more code

a = c;  // ""Populate the ""array"" with some new values
printf (""%d\n"", a[3]);  // Print the number 8
</code></pre>
",0
1989917,1989901,1,"<p>You are calling exec without calling fork. So you are replacing your entire server process with a copy of top. This is really unlikely to do what you want.</p>

<p>Very likely, you could accomplish your aims by opening a suitable pseudo-file from the /proc file system, reading the information, and sending it into your socket.</p>

<p>If you really want to use top, you have to use pipe, fork and exec(l) to run top, read it's output from a pipe, and then send that output to the client.</p>

<p>It occurs to me that you might be running in an environment in which the server automatically forks you (like some sort of CGI gateway), in which case your problem is that you need to fdopen to move the socket to be descriptor #1 before exec-ing. It would really help if you would tell us all about your environment <em>by editing your question.</em></p>
",0
1989924,1989901,0,"<p>The output of ""top"" goes to the server's stdout, not out through the socket to the client. You'd have to adjust the stdout of the ""top"" process for this to work.</p>
",0
1974070,1974060,0,"<p>The first line should be</p>

<pre><code>#include &lt;stdio.h&gt;
</code></pre>
",0
1974111,1974060,0,"<p>The code is perfectly fine. There's something wrong with your XCode setup (may be related: <a href=""https://stackoverflow.com/questions/1101794/unable-to-read-unknown-load-command-0x80000022"">unable to read unknown load command</a>.</p>

<pre><code>cristi:tmp diciu$ cat test.c
#include &lt;stdio.h&gt;

#define LOWER    0
#define UPPER    300
#define STEP 20

main()
{
    int fahr;

    for (fahr = LOWER; fahr &lt;= UPPER; fahr = fahr + STEP)
        printf(""%3d %6.1f\n"", fahr, (5.0/9.0)*(fahr-32));
}
cristi:tmp diciu$ gcc test.c
cristi:tmp diciu$ ./a.out 
  0  -17.8
 20   -6.7
 40    4.4
[..]
</code></pre>
",0
1974199,1974060,0,"<p>Works for me in XCode - the only warning/error I got was </p>

<blockquote>
  <p>Control reaches end of non-void function</p>
</blockquote>

<p>As defining <code>main()</code> defaults to int it should return something, eg. 0 for a successful program. Convention suggests that 0 means a program runs correctly and anything else is an error. </p>

<p>Better to define </p>

<pre><code>int main()
{ 
    /* code */ 
    return 0;
}
</code></pre>

<p>as your main function. But this is a digression - see <a href=""https://stackoverflow.com/questions/1974060/symbolic-constant-problem-in-xcode/1974111#1974111"">diciu's answer</a> for a potential explanation of your problem</p>
",0
1691029,1691011,4,"<p>A <code>char</code> is 8 bits (which can only represent a 0-255 range). Trying to cast <strong>3000</strong> to a <code>char</code> is... <del>impossible</del> impossible, at least for what you are intending.</p>
",4
1691031,1691011,3,"<p>This is happening because 3000 is too big a value and causes an overflow.  Char is <em>generally</em> from -128 to 127 signed, or 0 to 255 unsigned, but it can change depending upon the implementation.</p>
",2
1691033,1691011,-6,"<p>oh, i get it, it's <strong>overflow</strong>, it's like char is only from -256 to 256 or something like that i'm not sure, like if you have a var which type's max limit is 256 and you add 1 to it, than it becomes -256 and so on  </p>
",8
1691037,1691011,1,"<p>A char is (typically) just 8 bits, so you cant store values as large as 3000 (which would require at least <del>11</del> 12 bits).  So if you trie to store 3000 in a byte, it will just wrap.</p>

<p>Since 3000 is 0xBBA, it requires two bytes, one 0x0B and one which is 0xBA.  If you try to store it in a single byte, you will just get one of them (0xBA).  And since a byte is (typically) signed, that is -72.</p>
",1
1691050,1691011,2,"<p><code>char</code> is an integral type with certain range of representable values. <code>int</code> is also an integral type with certain range of representable values. Normally, range of <code>int</code> is [much] wider than that of <code>char</code>. When you try to squeeze into a <code>char</code> an <code>int</code> value that doesn't fit into the range of <code>char</code>, the value will not ""fit"", of course. The actual result is implementation-defined. </p>

<p>In your case <code>3000</code> is an <code>int</code> value that doesn't' fit into the range of <code>char</code> on your implementation. So, you won't get <code>3000</code> as the result. If you really want to know why it specifically came out as <code>-72</code> - consult the documentation that came with your implementation.</p>
",0
1691051,1691011,12,"<blockquote>
  <p>The hex value of 3000 is 0xBB8.</p>
</blockquote>

<p>And so the hex value of the char (which, by the way, appears to be signed on your compiler) is 0xB8.</p>

<p>If it were unsigned, 0xB8 would be 184. But since it's signed, its actual value is 256 less, i.e. -72.</p>

<p>If you want to know why this is, read about <a href=""http://en.wikipedia.org/wiki/Two&#39;s_complement"" rel=""nofollow noreferrer"">two's complement</a> notation.</p>
",0
1691052,1691011,-2,"<p><code>char</code> is used to hold a single character, and you're trying to store a 4-digit <code>int</code> in one. Perhaps you meant to use an array of chars, or string (<code>char t[4]</code> in this case).</p>

<p>To convert an int to a string (untested):</p>

<pre><code>#include &lt;stdlib.h&gt;

int main() {
    int num = 3000;
    char numString[4];
    itoa(num, buf, 10);
}
</code></pre>
",1
1691191,1691011,1,"<p>As specified, the 16-bit hex value of 3000 is <code>0x0BB8</code>.  Although <em>implementation specific</em>, from your posted results this is likely stored in memory in 8-bit pairs as <code>B8 0B</code> (some architectures would store it as <code>0B B8</code>.  This is known as <a href=""http://en.wikipedia.org/wiki/Endianness"" rel=""nofollow noreferrer"">endianness</a>.)</p>

<p><em>char</em>, on the other hand, is probably not a 16-bit type.  Again, this is <em>implementation specific</em>, but from your posted results it appears to be 8-bits, which is not uncommon.</p>

<p>So while your program has allocated 8-bits of memory for your value, you're storing twice as much information in that memory.  When your program retrieves this value later, it will only be pulling the first stored octet, in this case <code>B8</code>.  The <code>0B</code> will be ignored, and may cause problems later down the line if it ended up overwriting something important.  This is known as a <a href=""http://en.wikipedia.org/wiki/Buffer_overflow"" rel=""nofollow noreferrer"">buffer overflow</a>, which is very bad.</p>

<p>Assuming <a href=""http://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow noreferrer"">two's complement</a> (technically <em>implementation specific</em>, but a reasonable assumption), the hex value of <code>B8</code> translates to either <code>-72</code> or <code>184</code> in decimal, depending on whether your dealing with a <em>signed</em> or <em>unsigned</em> type.  Since you didn't specify either, your compiler will go with it's default.  Yet again, this is <em>implementation specific</em>, and it appears your compiler goes with <em>signed char</em>.</p>

<p>Therefore, you get <code>-72</code>.  But don't expect the same results on any other system.</p>
",0
847885,847772,-1,"<p>f expects to get as input an array of pointers (const struct_type* []). You pass a pointer to a pointer of struct (const struct_type**).</p>

<p>The best thing to do, IMO, is to change the signature of f to:</p>

<pre><code>void f(const struct_type *const* data);
</code></pre>

<p>Why do you need to pass arrays as arguments to functions?</p>
",4
847943,847772,4,"<p>The reason the compiler is complaining is the first <code>const</code> in <code>f</code>'s declaration.</p>

<p>Try using</p>

<pre><code>void f(struct_type *const data[], unsigned n);
/*...*/
f( v, n );
</code></pre>

<p>and you won't get the same warning.  Alternatively, you could cast <code>v</code> when you call <code>f</code></p>

<pre><code>void f(const struct_type *const data[], unsigned n);
/*...*/
f( (const struct_type * const *) v, n );
</code></pre>

<p>This is a little counterintuitive, but in C, you can't pass a <code>pointer-to-pointer-to-nonconst</code> for a <code>pointer-to-pointer-to-const</code>.  They made a special exception to allow you to pass a <code>pointer-to-nonconst</code> for a <code>pointer-to-const</code>.</p>

<p>Here's a FAQ question <a href=""http://c-faq.com/ansi/constmismatch.html"" rel=""nofollow noreferrer"">""Why can't I pass a <code>char **</code> to a function which expects a <code>const char **</code>?""</a>:</p>

<blockquote>
  <p>You can use a <code>pointer-to-T</code> (for any type <code>T</code>) where a <code>pointer-to-const-T</code> is expected. However, the rule (an explicit exception) which permits slight mismatches in qualified pointer types is not applied recursively, but only at the top level. (<code>const char **</code> is <code>pointer-to-pointer-to-const-char</code>, and the exception therefore does not apply.)</p>
  
  <p>The reason that you cannot assign a <code>char **</code> value to a <code>const char **</code> pointer is somewhat obscure. Given that the <code>const</code> qualifier exists at all, the compiler would like to help you keep your promises not to modify <code>const</code> values. That's why you can assign a <code>char *</code> to a <code>const char *</code>, but not the other way around: it's clearly safe to <em>add</em> <code>const</code>-ness to a simple pointer, but it would be dangerous to take it away. However, suppose you performed the following more complicated series of assignments:</p>

<pre><code>const char c = 'x';     /* 1 */
char *p1;           /* 2 */
const char **p2 = &amp;p1;      /* 3 */
*p2 = &amp;c;           /* 4 */
*p1 = 'X';          /* 5 */
</code></pre>
  
  <p>In line 3, we assign a <code>char **</code> to a <code>const char **</code>. (The compiler should complain.) In line 4, we assign a <code>const char *</code> to a <code>const char *</code>; this is clearly legal. In line 5, we modify what a <code>char *</code> points to--this is supposed to be legal. However, p1 ends up pointing to c, which is <code>const</code>. This came about in line 4, because *p2 was really p1. This was set up in line 3, which is an assignment of a form that is disallowed, and this is exactly why line 3 is disallowed.</p>
  
  <p>Assigning a <code>char **</code> to a <code>const char **</code> (as in line 3, and in the original question) is not immediately dangerous. But it sets up a situation in which p2's promise--that the ultimately-pointed-to value won't be modified--cannot be kept.</p>
  
  <p>(C++ has more complicated rules for assigning <code>const</code>-qualified pointers which let you make more kinds of assignments without incurring warnings, but still protect against inadvertent attempts to modify <code>const</code> values. C++ would still not allow assigning a <code>char **</code> to a <code>const char **</code>, but it would let you get away with assigning a <code>char **</code> to a <code>const char * const</code> *.)</p>
  
  <p>In C, if you must assign or pass pointers which have qualifier mismatches at other than the first level of indirection, you must use explicit casts (e.g. (<code>const char **</code>) in this case), although as always, the need for such a cast may indicate a deeper problem which the cast doesn't really fix.</p>
  
  <p>References: ISO Sec. 6.1.2.6, Sec. 6.3.16.1, Sec. 6.5.3
  H&amp;S Sec. 7.9.1 pp. 221-2 </p>
</blockquote>
",0
847955,847772,0,"<p>See if this would work for you:</p>

<pre><code>f(struct_type *data);

void test(unsigned n)
{
    struct_type *v = malloc(n * sizeof(struct_type *));
    f(v);
}
</code></pre>

<p>Please let me know how you get on.</p>
",2
847815,847772,0,"<p>Edited based on Rampion's answer.  The problem is with the double const in f()'s declaration.</p>

<p>Code with the warning:</p>

<pre><code>struct_type ** v;
v = (struct_type **)malloc(10 * sizeof(struct_type *));      
f(v);
</code></pre>

<p>This compiles without warning:</p>

<pre><code>const struct_type *const* v;
v = (const struct_type **)malloc(10 * sizeof(struct_type *));
f(v);
</code></pre>
",0
1069925,1069851,5,"<p>To get a backtrace, use <code>execinfo.h</code> as documented <a href=""http://www.gnu.org/s/libc/manual/html_node/Backtraces.html"" rel=""nofollow noreferrer"">in the GNU libc manual</a>.</p>

<p>For example:</p>

<pre><code>#include &lt;execinfo.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;


void trace_pom()
{   
    const int sz = 15;
    void *buf[sz];

    // get at most sz entries
    int n = backtrace(buf, sz);

    // output them right to stderr
    backtrace_symbols_fd(buf, n, fileno(stderr));

    // but if you want to output the strings yourself
    // you may use char ** backtrace_symbols (void *const *buffer, int size)
    write(fileno(stderr), ""\n"", 1);
}


void TransferFunds(int n);

void DepositMoney(int n)
{   
    if (n &lt;= 0)
        trace_pom();
    else TransferFunds(n-1);
}


void TransferFunds(int n)
{   
    DepositMoney(n);
}


int main()
{   
    DepositMoney(3);

    return 0;
}
</code></pre>

<p>compiled</p>

<pre>
gcc a.c -o a -g -Wall -Werror -rdynamic
</pre>

<p>According to the mentioned website:</p>

<blockquote>
  <p>Currently, the function name and offset only be obtained on systems that use the ELF
  binary format for programs and libraries. On other systems, only the hexadecimal return
  address will be present. Also, you may need to pass additional flags to the linker to
  make the function names available to the program. (For example, on systems using GNU
  ld, you must pass (-rdynamic.) </p>
</blockquote>

<p>Output</p>

<pre>
./a(trace_pom+0xc9)[0x80487fd]
./a(DepositMoney+0x11)[0x8048862]
./a(TransferFunds+0x11)[0x8048885]
./a(DepositMoney+0x21)[0x8048872]
./a(TransferFunds+0x11)[0x8048885]
./a(DepositMoney+0x21)[0x8048872]
./a(TransferFunds+0x11)[0x8048885]
./a(DepositMoney+0x21)[0x8048872]
./a(main+0x1d)[0x80488a4]
/lib/i686/cmov/libc.so.6(__libc_start_main+0xe5)[0xb7e16775]
./a[0x80486a1]
</pre>
",2
1070199,1069851,16,"<p>Above answer is vastly overcomplicated.   If the function reference is static, as it is above, the address is simply the value of the symbol name in pointer context:</p>

<pre><code>void* myfunction_address = myfunction;
</code></pre>

<p>If you are grabbing the function dynamically out of a shared library, then the value returned from dlsym() (POSIX) or GetProcAddress() (windows) is likewise the address of the function.</p>

<p>Note that the above code is likely to generate a warning with some compilers, as ISO C technically forbids assignment between code and data pointers (some architectures put them in physically distinct address spaces).</p>

<p>And some pedants will point out that the address returned isn't <strong>really</strong> guaranteed to be the memory address of the function, it's just a unique value that can be compared for equality with other function pointers and acts, when called, to transfer control to the function whose pointer it holds.  Obviously all known compilers implement this with a branch target address.</p>

<p>And finally, note that the ""address"" of a function is a little ambiguous.  If the function was loaded dynamically or is an extern reference to an exported symbol, what you really get is generally a pointer to some fixup code in the ""PLT"" (a Unix/ELF term, though the PE/COFF mechanism on windows is similar) that then jumps to the function.</p>
",3
1070290,1069851,9,"<p>If you know the function name before program runs, simply use</p>

<pre><code>void * addr = myfunction;
</code></pre>

<p>If the function name is given at run-time, I once wrote a function to find out the symbol address dynamically using bfd library. Here is the x86_64 code, you can get the address via find_symbol(""a.out"", ""myfunction"") in the example. </p>

<pre><code>#include &lt;bfd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;type.h&gt;
#include &lt;string.h&gt;

long find_symbol(char *filename, char *symname)
{
    bfd *ibfd;
    asymbol **symtab;
    long nsize, nsyms, i;
    symbol_info syminfo;
    char **matching;

    bfd_init();
    ibfd = bfd_openr(filename, NULL);

    if (ibfd == NULL) {
        printf(""bfd_openr error\n"");
    }

    if (!bfd_check_format_matches(ibfd, bfd_object, &amp;matching)) {
        printf(""format_matches\n"");
    }

    nsize = bfd_get_symtab_upper_bound (ibfd);
    symtab = malloc(nsize);
    nsyms = bfd_canonicalize_symtab(ibfd, symtab);

    for (i = 0; i &lt; nsyms; i++) {
        if (strcmp(symtab[i]-&gt;name, symname) == 0) {
            bfd_symbol_info(symtab[i], &amp;syminfo);
            return (long) syminfo.value;
        }
    }

    bfd_close(ibfd);
    printf(""cannot find symbol\n"");
}
</code></pre>
",2
1070331,1069851,3,"<p>About a comment in an answer (getting the address of an instruction), you can use this very ugly trick</p>

<pre><code>#include &lt;setjmp.h&gt; 

void function() {
    printf(""in function\n"");
    printf(""%d\n"",__LINE__);
    printf(""exiting function\n"");

}

int main() {
    jmp_buf env;
    int i;

    printf(""in main\n"");
    printf(""%d\n"",__LINE__);
    printf(""calling function\n"");
    setjmp(env);
    for (i=0; i &lt; 18; ++i) {
        printf(""%p\n"",env[i]);
    }    
    function();
    printf(""in main again\n"");
    printf(""%d\n"",__LINE__);

}
</code></pre>

<p>It should be env[12] (the eip), but be careful as it looks machine dependent, so triple check my word. This is the output</p>

<pre><code>in main
13
calling function
0xbfff037f
0x0
0x1f80
0x1dcb
0x4
0x8fe2f50c
0x0
0x0
0xbffff2a8
0xbffff240
0x1f
0x292
0x1e09
0x17
0x8fe0001f
0x1f
0x0
0x37
in function
4
exiting function
in main again
37
</code></pre>

<p>have fun!</p>
",0
1896447,1896440,4,"<p>I prefer to write <code>int* p = &amp;c;</code>, that is, a pointer to type int is being assigned the address of c.</p>

<p>Pointer notation can be confusing, as you've noticed, because these two are equivalent:</p>

<pre><code>int *p = &amp;c;
</code></pre>

<p>and</p>

<pre><code>int *p;
p = &amp;c;
</code></pre>

<p>Hope this helps!</p>

<p>EDIT: The confusion comes because <code>*</code> is used both as the dereference operator, and for declaring a pointer. So when <code>p</code> contains the address of <code>c</code>, <code>*p</code> dereferences the pointer and returns the value of <code>c</code>. But when you say <code>int *p = &amp;c;</code>, the <code>*</code> is saying ""p is a pointer to an int"", but is not doing any dereferencing.</p>
",0
1896451,1896440,2,"<p>Are you sure <code>p++;</code> is what you mean to do in your function? That's incrementing the location pointed to by <code>p</code>, it's not incrementing the value at the current location. If you're wanting to increment the value (i.e. make <code>c</code> become 6), then what you want is <code>(*p)++;</code>.</p>
",2
1896456,1896440,3,"<p>If you want the function to increment <code>c</code> when called with <code>&amp;c</code>, then write this:</p>

<pre><code>void function(int *p) { ++(*p); }
</code></pre>

<p><code>function(int *p)</code> means that <code>p</code> is the function parameter. So whatever value the caller gives, that will be assigned to <code>p</code> (not to <code>*p</code>).</p>

<p>The type of <code>p</code> is <code>int *</code>. That is, <code>p</code> is a pointer-to-int.</p>

<p>If <code>p</code> is a pointer-to-int, then <code>*p</code> is the int it points to.</p>

<p><code>c</code> is an int. Therefore <code>&amp;c</code> is a pointer-to-int, and the int it points to is <code>c</code>. Therefore, if <code>p</code> is <code>&amp;c</code>, then <code>*p</code> is <code>c</code>.</p>

<p>With my version of the function, this code:</p>

<pre><code>int c = 5;
function(&amp;c);
</code></pre>

<p>Does the same as this code:</p>

<pre><code>int c = 5; // same as before
int *p;    // parameter of the function
p = &amp;c;    // assign the caller's value to the parameter
++(*p);    // body of the function, increments *p, which is the same as c.
</code></pre>

<p>Which does the same as this code:</p>

<pre><code>int c = 5;
++c;
</code></pre>
",0
1896459,1896440,3,"<p>I can't really make out your question, but the <code>function</code> looks like bug to me and what you meant is, perhaps,</p>

<pre><code>++(*p)
</code></pre>

<p>Otherwise it's a no-op.</p>
",9
1896462,1896440,4,"<p><code>*p = &amp;c;</code> means:</p>

<p>Get the address of <code>c</code> in memory which is determined at <strike>compile-time</strike> link-time (<strong><em>Thanks Mikeage</em></strong>) e.g, 0x1234 as an example. The pointer to type int, i.e. <code>*p</code> is assigned to 0x1234, which does not sound right to me, I think you should be doing it this way, <code>p = &amp;c</code> then <code>*p</code> would have the value <em>pointed to</em> by the address of <code>c</code>. And therefore <code>*p</code> would have the value of what <code>c</code> was assigned to (that is called <em>dereferencing</em> - by putting a <code>*</code> before the pointer variable then you can obtain the value).</p>

<p>In your function you are trying to increment the value pointed to by p.</p>

<pre>
void function (int *p)
{
  *p++;
}

// It would be called like this
int c = 5;
function(&c); // Now c would have 6!
</pre>

<p>The key point is you want to <em>pass by reference</em> which is what the parameter <code>&amp;c</code> does.
If you omit the passing by reference like this:</p>

<pre>
void function (int p)
{
  p++;
}
// And call it like this
int c = 5;
function(c); // c is still 5
</pre>

<p>Now <code>c</code> would still be 5, but within the function itself <code>c</code> is 6, but no copy is passed back out as it is incremented within the local stack for the function itself.</p>
",4
1896856,1896440,1,"<p>Others have answered your question.  I will just add that a helpful way of reading pointer declarations is this.  Let's say I have the following declaration:</p>

<pre><code>int i;
</code></pre>

<p>This is really easy.  Here, <code>i</code> is an <code>int</code>.  Now, let's say I have this:</p>

<pre><code>int *pi;
</code></pre>

<p>Here, you can either say that <code>pi</code> is a pointer to an <code>int</code> (which is correct).  Another way to look at it would be that <code>*pi</code> <em>is an</em> <code>int</code>, i.e., when you have <code>*pi</code> in your code, that <code>*pi</code> will be of type <code>int</code>.  Having understood that, I think it's easy to see that <code>++pi</code> or <code>pi++</code> doesn't increment the <code>int</code>, because <code>pi</code> is the wrong type.  You want <code>(*pi)++</code>.  The parentheses are needed because in C, the operator <code>++</code> has higher precedence than the unary operator <code>*</code>.  Since you don't use any of the side effects of the increment, you can as well do: <code>++*p</code>.</p>

<p>Of course, as with all the pointers, <code>pi</code> has to point to something useful for the above to make sense.</p>
",0
746321,746227,9,"<p>Optimisations are not supposed to affect the outcome of a program at all (apart from its code size and running time of course). When they do, it is usually because you are relying on undefined behaviour.</p>

<p>No sane compiler would replace <code>(num/100)*100</code> with <code>num</code>. Optimising compilers are far, far, <em>far</em> smarter than that. The compiler might optimise it to <code>num - (num % 100)</code>, if that is a sensible decision for the target platform.</p>

<p>I always say ""the easier your code is for a compiler to understand, the easier it will be for the compiler to apply the most appropriate optimisation"". And you know what? Usually code that is easy for a compiler to understand is also easier for humans to understand.</p>
",0
746233,746227,9,"<pre><code>num = num - (num % 100) + 38;
</code></pre>
",3
421998,393208,0,"<p>How about to use a profiler and find what code is running the most, and focus in on those parts. </p>

<p>Maybe gprof can help out?</p>

<p>/Johan</p>

<p>Edit: Or since you talked about cleanup, invert my answer above and remove the code that never executes.</p>
",0
412928,393208,10,"<p>Although I am sure that this is not a comprehensive list of <em>static code analysis</em> tools, here are my impressions of some different ones that I've worked with in the past. (I work mostly with C.)</p>

<ol>
<li><p><a href=""http://www.splint.org/"" rel=""noreferrer"" title=""Splint"">Splint</a>: I often use Splint because it is available for many GNU/Linux distributions. It is relatively easy to work with; however, it tends to be overwhelming when operating under the strictest setting. Moreover, the sometimes-necessary use of annotations can clutter and obfuscate easily-readable code. Regardless, I suggest using it.</p></li>
<li><p><a href=""http://spinroot.com/uno/"" rel=""noreferrer"" title=""Uno"">Uno</a>: Uno is definitely a promising, but it is not as rigorous as Splint (by design). Instead, it focuses on the clarity and usefulness of its warnings. For me, Uno is only useful as a supplement to Splint (to clearly point out warnings hidden among the comparatively many that Splint issues).</p></li>
<li><p><a href=""http://www.gimpel.com/html/pcl.htm"" rel=""noreferrer"" title=""PC-lint"">PC-lint</a>: I find that PC-lint is unwieldy for a proprietary program. I once used it when developing for MS-DOS and cryptic names it uses for its errors made it very difficult to use. From what I hear, there are many better products to use on MS-DOS.</p></li>
<li><p><a href=""http://www.striker.ottawa.on.ca/~aland/pscan/"" rel=""noreferrer"" title=""Pscan"">Pscan</a>: (Dead hyperlink) Pscan is great for finding format string vulnerabilities! As with Uno, I suggest using it as a supplement to Splint.</p></li>
</ol>

<p>If you do not work with C, you may also want to check out: <a href=""http://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis"" rel=""noreferrer"" title=""Wikipedia - List of tools for static code analysis"">Wikipedia - List of tools for static code analysis</a>, <a href=""http://www.laatuk.com/tools/review_tools.html"" rel=""noreferrer"" title=""Inspection/Review Tools, Source/Binary Code Static Analyzers"">Inspection/Review Tools, Source/Binary Code Static Analyzers</a>, and <a href=""https://samate.nist.gov/index.php/Source_Code_Analyzers"" rel=""noreferrer"" title=""Source Code Security Analyzers"">Source Code Security Analyzers</a>.</p>
",2
393216,393208,6,"<p>If you run gcc with -Wall, it'll catch some of the things you mention, such as unused variables (and perhaps unused functions).  In terms of optimizations, I don't, though in general the compiler is smart enough to make the kinds of optimizations that matter, so I wouldn't worry too much.  Just don't use horrible algorithms. ;-)</p>
",1
393232,393208,14,"<p><a href=""http://en.wikipedia.org/wiki/Lint_programming_tool"" rel=""noreferrer"">Lint</a> is the classic tool for checking style on C programs.  There's more modern incarnation of it called <a href=""http://en.wikipedia.org/wiki/Splint_(programming_tool)"" rel=""noreferrer"">Splint.</a>  <a href=""http://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#C"" rel=""noreferrer"">This Wikipedia entry</a> has a list of static code analysis tools, some free, some commercial.</p>
",0
393330,393208,27,"<p>As Dan Fego pointed out, GCC can catch unused variables and unused static functions.  It won't normally find unused extern functions as it normally works one source file at a time.</p>

<p>GCC (v4.3.2) has hundreds if not thousands of options.  One that might help is '<code>--combine</code>' to combine source files (as long as you're not in the habit of putting the same function or variable names inside different source files).</p>

<p>The option '<code>--help</code>' tells you more; the options '<code>--help=optimizers</code>' and '<code>--help=warnings</code>' each give you a couple hundred lines of output.  The warnings include:</p>

<pre><code>-Wunused                    This switch lacks documentation
-Wunused-function           Warn when a function is unused
-Wunused-label              This switch lacks documentation
-Wunused-macros             Warn about macros defined in the main file that
                            are not used
-Wunused-parameter          Warn when a function parameter is unused
-Wunused-value              Warn when an expression value is unused
-Wunused-variable           Warn when a variable is unused
</code></pre>

<hr>

<p><em>Added</em>: this is a script called <code>glint</code> that I use to sanitize my code.  It is quite old so it doesn't use the '<code>#!/bin/sh</code>' notation for the first line and it says '<code>$*</code>' instead of '<code>""$@""</code>', both of which should be fixed, but neither needs to be fixed urgently.  Note that even though GCC 4.x no longer supports the '<code>-fwriteable-strings</code>' option, it still supports the '<code>-Wwrite-strings</code>' option and that has value.</p>

<p>This script demonstrates that you can get a lot of mileage out of existing tools with just a small amount of work.  You can configure just about every option it uses - albeit mainly via the environment rather than the command line.  Of course, you can add extra warning options to the command line; what you can't do is remove predetermined options except via the environment.  But that's OK; they're chosen by default for good reasons.  These days, I'd probably set '<code>GLINT_ANSI=-std=c99</code>' or fix the script; I've not been using it much of late since I code fairly closely to the standard that <code>glint</code> enforces. (Note that the '<code>-o /dev/null</code>' means that you can only do one file at a time; hack to fix!)</p>

<pre><code>:   ""@(#)$Id: glint.sh,v 1.5 2002/08/09 21:40:52 jleffler Exp jleffler $""
#
#   Use GCC as excruciatingly pedantic lint
#   Not a complete replacement for lint -- it doesn't do inter-file checking.
#   Now configurable via the environment.
#   Use GLINT_EXTRA_FLAGS to set extra flags via the environment.
#   NB: much Solaris code won't work with -undef enabled.

: ${GLINT_GCC:='gcc'}

: ${GLINT_ANSI='-ansi'}
: ${GLINT_FNO_COMMON='-fno-common'}
: ${GLINT_FSHORT_ENUMS='-fshort-enums'}
: ${GLINT_PEDANTIC='-pedantic'}
: ${GLINT_UNDEF='-undef'}
: ${GLINT_W='-W'}
: ${GLINT_WAGGREGATE_RETURN='-Waggregate-return'}
: ${GLINT_WALL='-Wall'}
: ${GLINT_WCAST_ALIGN='-Wcast-align'}
: ${GLINT_WCAST_QUAL='-Wcast-qual'}
: ${GLINT_WCONVERSION='-Wconversion'}
: ${GLINT_WMISSING_DECLARATIONS='-Wmissing-declarations'}
: ${GLINT_WREDUNDANT_DECLS='-Wredundant-decls'}
: ${GLINT_WMISSING_PROTOTYPES='-Wmissing-prototypes'}
: ${GLINT_WNESTED_EXTERNS='-Wnested-externs'}
: ${GLINT_WPOINTER_ARITH='-Wpointer-arith'}
: ${GLINT_WSHADOW='-Wshadow'}
: ${GLINT_WSTRICT_PROTOTYPES='-Wstrict-prototypes'}
: # ${GLINT_WTRADITIONAL='-Wtraditional'}
: ${GLINT_WWRITE_STRINGS='-Wwrite-strings'}

exec ${GLINT_GCC} \
    ${GLINT_ANSI} \
    ${GLINT_FNO_COMMON} \
    ${GLINT_FSHORT_ENUMS} \
    ${GLINT_PEDANTIC} \
    ${GLINT_UNDEF} \
    ${GLINT_WAGGREGATE_RETURN} \
    ${GLINT_WALL} \
    ${GLINT_WCAST_ALIGN} \
    ${GLINT_WCAST_QUAL} \
    ${GLINT_WCONVERSION} \
    ${GLINT_WMISSING_DECLARATIONS} \
    ${GLINT_WREDUNDANT_DECLS} \
    ${GLINT_WMISSING_PROTOTYPES} \
    ${GLINT_WNESTED_EXTERNS} \
    ${GLINT_WPOINTER_ARITH} \
    ${GLINT_WSHADOW} \
    ${GLINT_WSTRICT_PROTOTYPES} \
    ${GLINT_WTRADITIONAL} \
    ${GLINT_WWRITE_STRINGS} \
    ${GLINT_W} \
    ${GLINT_EXTRA_FLAGS} \
    -o /dev/null -O4 -g -c $*
</code></pre>
",0
393388,393208,3,"<p>splint (<a href=""http://www.splint.org/"" rel=""nofollow noreferrer"">http://www.splint.org/</a>) is quite excellent; I've used it on megaline codes to look for this sort of thing,</p>

<p>(Updated: everybody wants to be an art director.)</p>
",1
462406,462345,66,"<p>According to C99, it should be ""%lld"" (see, for example,<a href=""http://www.nullstone.com/download/releasenotes-ns-c.htm"" rel=""noreferrer"">here</a>).  If Diab C isn't C99, then you'd have to look at the compiler docs, which I can't seem to find online with a quick Googling.</p>
",1
462358,462345,16,"<p>It's <code>""%lli""</code> (or equivalently <code>""%lld""</code>)</p>
",0
462359,462345,2,"<p>Maybe %lld? I think this is the format for gcc, don't know anything about Diab C compiler.</p>
",1
462367,462345,11,"<p>Microsoft and Watcom use <code>%I64d</code> (capital eye), others use <code>%lld</code> (lowercase ell ell).</p>
",3
464223,462345,1,"<p>It is %lld for signed and %llu for unsigned</p>
",0
364767,364757,-1,"<p>I would argue that the problem isn't as much that C doesn't support strict type checking, as it's that it really doesn't support true user-defined types.</p>

<p>My guess is that most C compilers would translate both of your enums into simple ints or shorts or whatever, and would not do anything beyond that.</p>

<p>So as far as I can tell, the answer would be know. </p>
",0
364781,364757,-1,"<p>There's no way C alone can do it because the compiler doesn't know anything except the base types.  The usual thing is to use the <code>assert()</code> macro, but that's a run-time check.</p>
",0
364784,364757,0,"<p>You can't do it. In C++ you could overload the function and do some trickery (or use boost::enable_if), or just rely on C++'s type safety making it error out automatically. In C, that doesn't work since function overloading is not supported. And you can't check the value in the function and cause a compile time error, since all values are known only at runtime (as opposed to types). </p>

<p>The C Standard allows compilers to warn about what you do. So you could enable the <code>-Wall -Werror</code> flag and hope gcc will error out. But this is not a general purpose C way. </p>
",0
364919,364757,10,"<p>In C, enum types are indistinguishable from integers.  Very annoying.</p>

<p>The only way forward I can think of is a kludgy workaround using structs instead of enums.  Structs are generative, so the hundreds and thousands are distinct.  If the calling convention is sensible (AMD64) there will be no run-time overhead.</p>

<p>Here's an example using structs that gets the compile-time errors you wanted.  Kludgy, but it works:</p>

<pre><code>#include &lt;stdio.h&gt;
enum hundred_e {
    VALUE_HUNDRED_A = 100,
    VALUE_HUNDRED_B
};

enum thousand_e {
    VALUE_THOUSAND_A = 1000,
    VALUE_THOUSAND_B
};

struct hundred { enum hundred_e n; };
struct thousand { enum thousand_e n; };

const struct hundred struct_hundred_a = { VALUE_HUNDRED_A }; 
const struct hundred struct_hundred_b = { VALUE_HUNDRED_B }; 
const struct thousand struct_thousand_a = { VALUE_THOUSAND_A }; 
const struct thousand struct_thousand_b = { VALUE_THOUSAND_B }; 

void print_hundred(struct hundred foo)
{
    switch (foo.n) {
        case VALUE_HUNDRED_A:     printf(""hundred:a\n"");     break;
        case VALUE_HUNDRED_B:     printf(""hundred:b\n"");     break;
        default: printf(""hundred:error(%d)\n"", foo.n); break;
    }
}

void print_thousand(struct thousand bar)
{
    switch (bar.n) {
        case VALUE_THOUSAND_A:     printf(""thousand:a\n"");     break;
        case VALUE_THOUSAND_B:     printf(""thousand:b\n"");     break;
        default: printf(""thousand:error(%d)\n"", bar.n); break;
    }
}

int main(void)
{

    print_hundred(struct_hundred_a);
    print_hundred(struct_thousand_a);  /* Want a compile error here */

    print_thousand(struct_thousand_a);
    print_thousand(struct_hundred_a);  /* Want a compile error here */

    return 0;
}
</code></pre>
",0
366529,364757,0,"<p>You could do it using #defines for your functions and __builtin_constant(x), which returns 1 if x resolves to a constant and 0 if it does not.  Note this is a gcc-only intrinsic; I have no idea if there are equivalents on other compilers.</p>
",0
366452,364757,0,"<p>I think strictly the answer is, ""it depends on the compiler"". I'm fairly sure that the code is legal C, so by default a C compiler wouldn't/shouldn't complain, but there are probably different options in different compilers that can pick it up.</p>

<p>If this type of error checking is important to you then I suggest investigating C linters/style checkers/static analysis tools which will catch this and other common (and not so common) errors (if you set them up correctly!). It is a bit of work to  add these tools into your build process, but if for your project you think catching these kind of things at compile is valuable then the cost is going to be worth it.</p>

<p>Two I would recommend are:</p>

<p><a href=""http://www.gimpel.com/html/lintinfo.htm"" rel=""nofollow noreferrer"">FlexeLint</a>, which is a relatively inexpensive commercial product that I have used to great effect.</p>

<p>An open source alternative would be <a href=""http://www.splint.org/"" rel=""nofollow noreferrer"">Splint</a>, but unfortunately it appears to be mostly unmaintained at the moment.</p>

<p>There are more expensive commercial tools such as Klocwork and Coverity.</p>

<p>Adding these kind of tools to your software does take some effort. They are usually extremely flexible and customisable, and you need to make some educated decisions about what behaviours you want to allow, and which you want to disallow in your code base. </p>
",0
1115377,1115376,14,"<p><a href=""http://en.wikipedia.org/wiki/Default_argument"" rel=""nofollow noreferrer"">Yes</a>.</p>
<blockquote>
<p>In computer programming, a default argument is an argument to a function that a programmer is not required to specify. In most programming languages, functions may take one or more arguments. Usually, each argument must be specified in full (<strong>this is the case in the C programming language</strong>).</p>
</blockquote>
<p>(Emphasis mine.)</p>
",0
479133,479099,2,"<p>This isn't necessarily the best solution, but another approach might be to use <code>fscanf()</code>:</p>

<pre><code>while(choice != 0)
{
  printf(""enter number"");
  fscanf(stdin, ""%d"", &amp;choice);
  if(choice &gt; 0)
  {
    printf(""enter percentage\n"");
    fscanf(stdin, ""%f"", &amp;percentage);
    //add to an array holding numbers vs percentages
  }
}
</code></pre>

<p>In this way you don't need the temporary <code>line</code> and <code>percent_line</code> buffers. The <code>fscanf()</code> function will automatically keep reading input until it gets what it is looking for - which means that if you just press Enter at the ""enter number"" prompt, the <code>fscanf()</code> function will not return and will keep reading input until you type a number. Also, error handling is not implemented in the above, I leave it as an exercise for the reader to fix the problem that happens when you enter something that <em>isn't</em> a number.</p>

<p>(Note that I also changed <code>choice</code> to <code>&amp;choice</code>, which I think you intended in the first place.)</p>
",0
479143,479099,0,"<p>You can check if there is <code>\n</code> in <code>line</code> - if not, use <code>fgetc()</code> in the loop until <code>\n</code> found, then proceed to following input.</p>
",0
479404,479099,0,"<p>i think the latter one does the job pretty well. i dont mind if someone enters ""acbgrt"" instead of a number, i just want to make the program behave correctly. it will simply convert the string rubbish into 0, and then exit the loop. </p>
",0
1779377,1779358,0,"<p>With GCC, this is a warning,<br>
when you dont declare a function before using it, the compiler tries to guess the declaration using the type of call made to that function.Hence the behavior.   </p>
",0
1779391,1779358,2,"<p>You failed to declare your <code>swap</code> explicitly, forcing the compiler to make assumptions about the function at the point of the call. The compiler, in accordance with C rules, will assume that <code>swap</code> is</p>

<pre><code>int swap(int *, int *, size_t)
</code></pre>

<p>Later you declare your swap as</p>

<pre><code>void swap(void *, void *, int)
</code></pre>

<p>which is obviously different from what the compiler assumed. This is the conflict the compiler is telling you about.</p>

<p>Also, your <code>void swap</code> attempts to <code>return 0</code>. What were you trying to achieve by that? </p>

<p>P.S. It's <code>int main</code>, not <code>void main</code>.</p>

<p>P.P.S. The program is not guaranteed to produce any output if its output does not end in a new-line character.</p>
",0
1779418,1779358,-1,"<p>Well, it compiles on <a href=""http://codepad.org"" rel=""nofollow noreferrer"">http://codepad.org</a> (after removing the <code>getch()</code>, which is irrelevant). Maybe your compiler complains about using memcpy on non-restricted pointers? </p>

<p>In <code>swap()</code> <code>p1</code> and <code>p2</code> are not guaranteed not to be aliases. This is an actual bug waiting to happen - calling swap on <code>&amp;a[i]</code> and <code>&amp;a[j]</code> might  blow up <code>memcpy</code> when <code>i==j</code>. Either use <code>memmove</code> (which is guaranteed not to blow up on overlapped areas) or declare the pointers <code>restricted</code>.</p>
",2
1779363,1779358,3,"<p>You need to declare swap before using it. For example, put <code>swap</code> above main, or add a prototype for <code>swap</code> like this:</p>

<pre><code>void swap(void *,void *,int);
int main () 
</code></pre>

<p>Incidentally <code>main</code> should be <code>int</code> not <code>void</code> and usually it returns the value zero, unless there is an error.</p>
",0
1779476,1779358,1,"<p>You may wonder why the program compiles at all without a prototype for swap(), and that's because the compiler is more than a C99 tool. It also compiles C89 and K&amp;R C programs.</p>

<p>C89 added the prototypes. Prior to C89, the compiler didn't need to see the declaration (the prototype) of a function unless it returned something other than <code>int</code> and the types of the formal parameters were not known to the compiler at all. The compiler just called every function with the types of the actual arguments, which received a set of default argument promotions to simplify things. The programmer would run the <code>lint</code> utility to cross-check actual and formal parameters. This program is still shipped with the BSD distributions.</p>

<p>K&amp;R programs and their corresponding code styles are still accepted by your compiler, so when it sees a function for which no prototype is available it just goes ahead and calls it anyway.</p>

<p>In this case, you switch paradigms in between the call and the definition of the function. The K&amp;R C assumptions the compiler made about the undeclared function when it had to generate a call turned out not to be valid. Even if you had written the whole program in the K&amp;R style the compiler would have made the same complaints when it found out the <em>real</em> types of the function arguments.</p>
",0
1779364,1779358,15,"<p>The problem is that <code>swap</code> was not declared before it is used. Thus it is assigned a ""default signature"", one which will in this case not match its actual signature. Quote <a href=""https://stackoverflow.com/users/187690/andreyt"">Andrey T</a>:</p>

<blockquote>
  <p>The arguments are passed through a set
  of strictly defined conversions. <code>int *</code>
  pointers will be passed as <code>int *</code>
  pointers, for example. In other words,
  the parameter types are temporarily
  ""deduced"" from argument types. Only
  the return type is assumed to be <code>int</code>.</p>
</blockquote>

<p>Aside from that, your code produces a bunch of other warnings. If using <code>gcc</code>, compile with <code>-Wall -pedantic</code> (or even with <code>-Wextra</code>), and be sure to fix each warning before continuing to program additional functionality. Also, you may want to tell the compiler whether you are writing ANSI C (<code>-ansi</code>) or C99 (<code>-std=c99</code>).</p>

<p>Some remarks:</p>

<ul>
<li>Put spaces after commas.</li>
<li>Make <code>main</code> return an <code>int</code>.

<ul>
<li>And make it <code>return 0</code> or <code>return EXIT_SUCCESS</code>.</li>
</ul></li>
<li>Import the definition of <code>getch</code>: <code>#include &lt;curses.h&gt;</code>.

<ul>
<li>Or just use <a href=""http://linux.die.net/man/3/getchar"" rel=""nofollow noreferrer""><code>getchar</code></a>.</li>
</ul></li>
<li>Import the definition of <code>memcpy</code>: <code>#include &lt;string.h&gt;</code>.</li>
<li>Don't return something in a <code>void</code> function.</li>
<li><p>You may want to use <code>malloc</code> to allocate a buffer of variable size. That will also work with older compilers:</p>

<pre><code>void swap(void *p1, void *p2, int size) {
    void *buffer = malloc(size);
    memcpy(buffer, p1, size);
    memcpy(p1, p2, size);
    memcpy(p2, buffer, size);
    free(buffer);
}
</code></pre></li>
</ul>
",2
1779366,1779358,3,"<p>First off, the actual error message wouldn't hurt.</p>

<p>Secondly, making buffer of [size] only works on some compilers (that's a new feature, not all compilers have it yet). Are you sure yours does?</p>

<p>Thirdly, you need to declare swap before calling it. Add a prototype at the top of the file:</p>

<pre><code>void swap(void *p1,void *p2,int size);
</code></pre>
",0
1054836,1054802,12,"<p>You can find information about that problem here: <a href=""http://en.wikipedia.org/wiki/Selection_algorithm"" rel=""noreferrer"">Selection algorithm</a>.</p>
",0
1054837,1054802,0,"<p>Two stacks can be used like this to locate the Nth smallest number in one pass.  </p>

<ul>
<li>Start with empty Stack-A and Stack-B</li>
<li>PUSH the first number into Stack-A</li>
<li>The next number onwards, choose to PUSH into Stack-A only if the number is smaller than its top</li>
<li>When you have to PUSH into Stack-A, run through these steps

<ul>
<li>While TOP of Stack-A is larger than new number, POP TOP of Stack-A and push it into Stack-B</li>
<li>When Stack-A goes empty or its TOP is smaller than new number, PUSH in the new number and restore the contents of Stack-B over it </li>
<li>At this point you have inserted the new number to its correct (sorted) place in Stack-A and Stack-B is empty again</li>
<li>If Stack-A depth is now sufficient you have reached the end of your search</li>
</ul></li>
</ul>

<hr>

<p>I generally agree to Noldorins' optimization analysis.<br>
This stack solution is towards a simple scheme that will work (with relatively more data movement -- across the two stacks). The heap scheme reduces the fetch for Nth smallest number to a tree traversal (<code>log m</code>).</p>

<p>If your target is an optimal solution (say for a large set of numbers or maybe for a programming assignment, where optimization and the demonstration of it are critical) you should use the heap technique.</p>

<p>The stack solution can be compressed in space requirements by implementing the two stacks within the same space of K elements (where K is the size of your data set). So, the downside is just extra stack movement as you insert.</p>
",3
1054840,1054802,1,"<p>This task is quite possible to complete within roughly <code>O(n)</code> time (<code>n</code> being the length of the list) by using a <a href=""http://en.wikipedia.org/wiki/Heap_structure"" rel=""nofollow noreferrer"">heap structure</a> (specifically, a <a href=""http://en.wikipedia.org/wiki/Priority_queue"" rel=""nofollow noreferrer"">priority queue</a> based on a <a href=""http://en.wikipedia.org/wiki/Fibonacci_heap"" rel=""nofollow noreferrer"">Fibonacci heap</a>), which gives <code>O(1)</code> insertion time and <code>O(log n)</code> removal time).</p>

<p>Consider the task of retrieving the m-th smallest element from the list. By simply looping over the list and adding each item to the priority queue (of size <code>m</code>), you can effectively create a queue of each of the items in the list in <code>O(n)</code> time (or possibly fewer using some optimisations, though I'm not sure this is exceedingly helpful). Then, it is a straightforward matter of removing the element with lowest priority in the queue (highest priority being the smallest item), which only takes <code>O(log m)</code> time in total, and you're finished.</p>

<p>So overall, the time complexity of the algorithm would be <code>O(n + log n)</code>, but since <code>log n &lt;&lt; n</code> (i.e. <code>n</code> grows a lot faster than <code>log n</code>), this reduces to simply <code>O(n)</code>. I don't think you'll be able to get anything significantly more efficient than this in the general case.</p>
",3
1054951,1054802,9,"<p>What you are referring to is the Selection Algorithm, as previously noted. Specifically, your reference to quicksort suggests you are thinking of the <a href=""http://en.wikipedia.org/wiki/Selection_algorithm#Partition-based_general_selection_algorithm"" rel=""nofollow noreferrer"">partition based selection</a>.</p>

<p>Here's how it works:</p>

<ul>
<li>Like in Quicksort, you start by picking a good
pivot: something that you think is nearly
half-way through your list. Then you
go through your entire list of items
swapping things back and forth until
all the items less than your pivot
are in the beginning of the list, and
all things greater than your pivot
are at the end. Your pivot goes into the leftover spot in the middle.</li>
<li>Normally in a quicksort you'd recurse
on both sides of the pivot, but for
the Selection Algorithm you'll only
recurse on the side that contains the
index you are interested in. So, if
you want to find the 3rd lowest
value, recurse on whichever side
contains index 2 (because index 0 is
the 1st lowest value).  </li>
<li>You can stop recursing when you've
narrowed the region to just the one
index. At the end, you'll have one
unsorted list of the ""m-1"" smallest
objects, and another unsorted list of the ""n-m"" largest
objects. The ""m""th object will be inbetween.</li>
</ul>

<p>This algorithm is also good for finding a sorted list of the highest m elements... just select the m'th largest element, and sort the list above it. Or, for an algorithm that is a little bit faster, do the Quicksort algorithm, but decline to recurse into regions not overlapping the region for which you want to find the sorted values.</p>

<p>The really neat thing about this is that it normally runs in O(n) time. The first time through, it sees the entire list. On the first recursion, it sees about half, then one quarter, etc. So, it looks at about 2n elements, therefore it runs in O(n) time. Unfortunately, as in quicksort, if you consistently pick a bad pivot, you'll be running in O(n<sup>2</sup>) time.</p>
",0
566067,310558,0,"<p>Are you zero initializing the ZI section. I think that scatterload code in the runtime initialized the ZI section (my be not it's be awhile). We had a problem with the ZI section being initialized with some data left over from our program loader.</p>

<p>As a result changing any line in the code would cause it to crash at the same location.
Even deleting code would cause a crash. I would verifythe ZI section is zero at the beginning of your program.</p>
",0
310568,310558,0,"<p>I had something similar happen to a project I was working on.  It ended up being a problem with referencing an un-initialized pointer on the stack.  It would usually point to un-used program memory, and overwrite the code that wasn't being used.</p>

<p>When I removed unused code, suddenly it was pointing to memory that wasn't mine to modify, and it would exit ungracefully.</p>

<p>Double check your mallocs, and be sure about your function variable pointers!</p>
",0
1577181,1577172,7,"<p>If you need an integer, type <code>int</code>, and so on. If you need to make assumptions about what a data type can hold (such as, you require that it has 32 bits), check out <a href=""http://en.wikipedia.org/wiki/Stdint.h"" rel=""noreferrer"">stdint.h</a></p>

<p>As long as you make sure you aren't making assumptions about what a data type can hold, you'll be in good shape. The moment you do something like assume a data type will hold n bits, you're into implementation defined land, where you need to make sure it works on both platforms.</p>
",0
1577209,1577172,14,"<p>In many 64-bit OSes (such as 64-bit Linux), ints are still only 32 bits wide; only longs and pointers are 64 bits wide. This is referred to as an <a href=""http://en.wikipedia.org/wiki/64-bit#64-bit_data_models"" rel=""noreferrer"">LP64 data model</a>. The reason for this is that in many cases, an int does not need more range than is provided by 32 bits, and using 64 bits would only waste memory. Under 64-bit Windows, evens longs are 32-bit (for compatibility with 32-bit Windows), and only long longs are 64-bit; this is referred to as an LLP64 data model.</p>

<p>If your application is going to be running on 32-bit as well as 64-bit operating systems, then the range of a 32-bit integer is obviously sufficient -- otherwise, you would be in trouble on the 32-bit OS. So just go ahead and use ints in those cases. If you can identify cases where you need the range of a 64-bit integer, use an <code>int64_t</code> (defined in <code>stdint.h</code>) explicitly. To make sure the binary data formats you write to disk are compatible across platforms, use <code>int32_t</code> and <code>int64_t</code> explicitly in those places... but also be aware of potential endianness issues.</p>

<p>Finally, when writing 64-bit code, be aware that pointers cannot be converted to ints in a LP64 data model -- so use <code>uintptr_t</code> instead.</p>

<p>If you code cleanly, 32-bit/64-bit portability should be almost a non-issue -- there's not really much more you need to be aware of than what I've written above. Portability between Windows and Linux will generate much greater issues that portability between 32-bit and 64-bit.</p>
",2
1577242,1577172,1,"<p>You need to use a data type appropriate for the data you are handling, and as you want to be sure that doesn't change across platforms use uint32_t, uint16_t etc from stdint.h </p>

<p>Most important is if you are manipulating a value whose size <em>will</em> vary with the underlying architecture e.g. the size of container, you should use size_t as it will adapt to compiler target e.g. 32 or 64 bits.</p>
",0
1577414,1577172,3,"<p>In most cases, you don't need a <em>fixed</em> size - you just need a <em>minimum</em> size.  The plain old C data types do have such minimum sizes (ranges):</p>

<pre><code>type               | minimum size
-------------------+---------------------------------------------
char               | at least 8 bits (but see below)
signed char        | -127 to 127
unsigned char      | 0 to 255
short              | -32767 to 32767
unsigned short     | 0 to 65536
int                | -32767 to 32767
unsigned int       | 0 to 65536
long               | -2147483647 to 2147483647
unsigned long      | 0 to 4294967295
long long          | -9223372036854775807 to 9223372036854775807 (see below)
unsigned long long | 0 to 18446744073709551615 (see below)
</code></pre>

<p>(<code>char</code> must have the same range as either <code>signed char</code> or <code>unsigned char</code>.  <code>long long</code> and <code>unsigned long long</code> are new to the C99 specification, but are present as an extension in many compilers supporting only the old standard).</p>

<p>Use whichever size is big enough to fit the ranges of values you're interested in, plus <code>size_t</code> for sizes of objects / number of objects / array indexes, and you'll be right in most cases.</p>

<p>The additional type values in <code>&lt;stdint.h&gt;</code> can be useful, but should be used sparingly.</p>
",1
1978345,1978125,2,"<p>Mostly you would like to use a profiler. The post pointed by Fragsworth is a good start. Personally, I prefer Shark for Mac OS X, and gprof for Linux.</p>

<p>But in your case, you may also call clock() or getrusage(), for example, in this way:</p>

<pre><code>clock_t t = clock();
for (i = 0; i &lt; 1000; ++i) my_func();
printf(""time = %lf\n"", (double)(clock() - t) / CLOCKS_PER_SEC);
</code></pre>

<p>Profiler is useful when you want to dig out which part of code takes most time. Calling clock()/getrusage() is more convenient (to me) when you want to compare/benchmark different implementations.</p>
",0
1978140,1978125,4,"<p>Take a look at <a href=""https://stackoverflow.com/questions/239742/c-code-profiler"">this post</a> on code profilers.</p>
",0
1978141,1978125,1,"<p>The first thing to find out is whether you need to optimize those functions.  Unless they are in the critical path for your code, they may be more then fast enough.</p>

<p>If you have profiled your application and found they are slow, one good way to test to performance is to call the function some large number of times and to find out the average time it takes to run.</p>

<p>You should also try to use CPU-time instead of wallclock-time as that is a more accurate gauge.</p>
",0
1978407,1978125,3,"<blockquote>
  <p>I want to test to see which design gives better performance.</p>
</blockquote>

<p>Why does it matter?  This is not a flip question!  You should have a performance target in mind, and if you meet it, your code is fast enough.  </p>

<p>How do you know how fast is ""fast enough""?  It turns out the user-interface people have good data on the effect of response time on your users' experience:</p>

<ul>
<li><p>0.1 second is about the limit for having the user feel that the system is reacting instantaneously, meaning that no special feedback is necessary except to display the result. (Most people have a reaction time of about 0.1 seconds; jet fighter pilots get down to around 0.08s, i.e., 80ms.)</p></li>
<li><p>1 second is about the limit for the user's flow of thought to stay uninterrupted, even though the user will notice the delay. Normally, no special feedback is necessary during delays of more than 0.1 but less than 1.0 second, but the user does lose the feeling of directly ""driving"" your application.</p></li>
<li><p>10 seconds is about the limit for keeping the user's attention focused on the app. For longer delays, users will want to perform other tasks while waiting for the computer to finish, so they should be given feedback indicating when the computer expects to be done. Feedback during the delay is especially important if the response time is hard to predict or varies a lot.</p></li>
</ul>

<p>The quantitative results above apply only to interaction, of course, which is measured in seconds of waiting time.  But even if your target is network packets sent, pages of RAM allocated, blocks of disk read/written, or just watts of power consumed, the message I am trying to communicate is that <strong>you should have a performance target</strong>, that target should be <em>quantified</em>, and <strong>the target should be connected to the needs of your users</strong>.  If you don't have a quantifiable target, you're not doing engineering; you're just whistling in the dark.  Unless your goal is to educate yourself (or to satisfy idle curiosity), the question you should be asking is ""is my code good enough that I can move on?""</p>

<hr>

<p>If you're not meeting your performance target, or if you are trying to educate yourself, I think the best combination of readable and detailed information comes from using the <a href=""http://valgrind.org/"" rel=""nofollow noreferrer"">valgrind</a> profiler (<code>--tool=callgrind --dump-instr=yes</code>) together with the <code>kcachegrind</code> visualizer.</p>
",3
1981240,1978125,1,"<p>You can use gprof ,which is a free profiler . </p>
",0
1793631,1793616,34,"<p>Pressing enter doesn't actually cause an <code>EOF</code> (""end of file""). You have to signal that you are completely finished with providing input; on Unix you typically do that by pressing <kbd>Ctrl</kbd><kbd>D</kbd>. On Windows I believe it's <kbd>Ctrl</kbd><kbd>Z</kbd> followed by enter, but I'm really not sure about that.</p>
",1
1793636,1793616,4,"<p>How are you ending your input and what system are you on?</p>

<p>If you are hitting an 'interrupt' or 'kill' control key combination then it's likely that you are killing your process before it can print.</p>

<p>If you use something like Ctrl-D on unix or Ctrl-Z at the start of a line on windows then this will signal 'end of input' without killing the process.</p>

<p>You can also try redirecting your input from a test file. e.g.:</p>

<pre><code>myprogram &lt;input.txt
</code></pre>
",0
1793638,1793616,1,"<p>""Press enter""? The cycle in your code continues to iterate until it reaches the end-of-file marker. ""Pressing enter"" will not result in EOF. If you want to simulate EOF from the keyboard, consult the documentation for your terminal. In Windows, for example, you'd have to hit Ctrl+Z to generate EOF.</p>
",0
1793640,1793616,0,"<p>getchar() returns a value from standard in (typically the keyboard). I don't remember what character EOF will map to, but you probably can't type it.</p>
",2
1793666,1793616,4,"<p>On Windows either a CTRL-Z or F6 will signal the end of a file.</p>
",0
1793668,1793616,1,"<p>ENTER is written in code as <code>'\n'</code>. Try this</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    long nc = 0;

    /* count chars, except for ENTER */
    while(getchar() != '\n')
    {
        ++nc;
    }

    printf(""%ld\n"", nc);
    return 0;
}
</code></pre>
",0
1793669,1793616,20,"<p>You will only get an <code>EOF</code> from the stream when the end of file is reached, <em>not</em> the end of line. How you signal an end of file depends on your OS and terminal settings.</p>

<p>It's usually <kbd>CTRL</kbd><kbd>d</kbd> on UNIX-type systems and <kbd>CTRL</kbd><kbd>z</kbd> on Windows. For UNIX in cooked mode (normal input mode), you'll generally have to enter it as the first character of a line and follow it with a newline (<kbd>ENTER</kbd>).</p>

<p>With Windows, the <kbd>CTRL</kbd><kbd>z</kbd> can be entered anywhere on the line, but still needs to be followed by a newline.</p>

<p>In UNIX, the actual character to inform the terminal interface that you want to send <code>EOF</code> can be set with the <code>stty</code> command. If you execute <code>stty -a</code>, you'll see something like:</p>

<pre><code>speed 38400 baud; rows 45; columns 150; line = 0;
intr = ^C; quit = ^\; erase = ^H; kill = ^U; eof = ^D;
eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = ^Z; start = ^Q;
stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V;
flush = ^O; min = 1; time = 0; -parenb -parodd cs8 -hupcl
-cstopb cread -clocal -crtscts -ignbrk brkint -ignpar -parmrk
-inpck -istrip -inlcr -igncr icrnl ixon -ixoff -iuclc -ixany
-imaxbel opost -olcuc -ocrnl onlcr -onocr -onlret -ofill
-ofdel nl0 cr0 tab0 bs0 vt0 ff0 isig icanon iexten echo
-echoe -echok -echonl -noflsh -tostop -echoctl -echoke
</code></pre>

<p>You can see at the end of the second line that <code>eof</code> is set to <code>^D</code> (<kbd>CTRL</kbd><kbd>d</kbd>). You can change this with:</p>

<pre><code>stty eof ^x
</code></pre>

<p>to set it to <kbd>CTRL</kbd><kbd>x</kbd>, for example. You can also set a huge number of other things, most of which will make your current terminal unusable, so be careful :-)</p>

<p>Bottom line, if you want to signal your program that the file is finished, use <kbd>CTRL</kbd><kbd>d</kbd> for UNIX (or check <code>stty</code> if that doesn't work) or <kbd>CTRL</kbd><kbd>z</kbd> for Windows. If you want to just get a <em>line</em> of input, use the <code>\n</code> character in your code as follows:</p>

<pre><code>#include &lt;stdio.h&gt;
int main (void) {
    long nc = 0;
    while(getchar() != '\n')
        ++nc;
    printf(""%ld\n"", nc);
    return 0;
}
</code></pre>
",2
695555,695548,5,"<p>Since it's static it must be initialized with a constant size in some compilation unit (C source file).</p>
",2
695573,695548,5,"<p>You probably have a situation like this:</p>

<pre><code>#include &lt;stdio.h&gt;

static int a[];     // declaration

// lots of code

int a[3];           // use
</code></pre>

<p>which compiles as C with gcc. I'm not sure it should (it is not valid C++) but I'm not enough of a C language lawyer to tell you for sure.</p>
",0
1697376,1697374,9,"<p>Use a pointer to function.<br>
Like <code>int (*ptr2_fun)()</code>
Receiving function being:<br>
 <code>int execute_your_function(int (*fun)())</code></p>

<p>Here you have some <a href=""http://www.cprogramming.com/tutorial/function-pointers.html"" rel=""noreferrer"">examples</a></p>
",1
1697380,1697374,5,"<p>Use <a href=""http://www.cprogramming.com/tutorial/function-pointers.html"" rel=""noreferrer"">function pointers</a></p>
",0
1697381,1697374,3,"<p>Great function pointer tutorial here:</p>

<p><a href=""http://www.newty.de/fpt/index.html"" rel=""nofollow noreferrer"">http://www.newty.de/fpt/index.html</a></p>
",0
1697387,1697374,3,"<p>Sure, you can use a function pointer.</p>

<pre><code>#include &lt;stdio.h&gt;
typedef void (*bar_callback)(void);

void foo(void)
{
  puts(""foo"");
}

void bar(bar_callback callback)
{
  puts(""bar"");
  callback();
}
int main(int argc,char **argv)
{
  bar(foo);
  return 0;
}
</code></pre>
",0
1697392,1697374,3,"<p><strong>Yes</strong>. Not a function <em>per se</em> but a pointer to a function instead.</p>

<p>See <a href=""http://www.opengroup.org/onlinepubs/007908799/xsh/qsort.html"" rel=""nofollow noreferrer""><code>qsort()</code></a>.</p>

<pre><code>int cmp(const void *a, const void *b) { /* ... */ }
/* ... */
qsort(data, nelems, sizeof *data, cmp); /* pass the function `cmp` to qsort() */
</code></pre>
",0
1697410,1697374,8,"<p>No, you can't pass a 'function' as a parameter.  You can, however, pass a pointer to a function instead.</p>

<p>When you reference a function by name without the parentheses for a function invocation, you are referencing a pointer to a function.  Thus, for example, we could consider a function that generates a table of values for a mathematical function:</p>

<pre><code>#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

static void generator(double lo, double hi, double inc, double (*function)(double))
{
    double x;
    for (x = lo; x &lt; hi; x += inc)
        printf(""x = %6g; f(x) = %6g\n"", x, (*function)(x))
}

int main(void)
{
     generator(0.0, 1.0, 0.02, sin);
     generator(0.0, 1.0, 0.02, cos);
     generator(0.0, 1.0, 0.02, sqrt);
     return(0);
}
</code></pre>

<p>Here, the functions 'sin()', 'cos()', and 'sqrt()' all have the same prototype schema: function taking a double argument and returning a double value.  Note that if I mistakenly wrote:</p>

<pre><code>generator(0.0, 1.0, 0.02, sin());
</code></pre>

<p>I would get a bunch of compilation errors - one because 'sin()' expects an argument, and another because 'generator()' expects a pointer to a function and not a double value as the last argument.</p>

<p>(Also note that a good program would at least identify the function it is calculating, and the repeated increments of a double number is not a good idea for accuracy.  It is but an example.)</p>
",0
1676607,1676522,7,"<p>Quote from <a href=""https://pubs.opengroup.org/onlinepubs/9699919799/functions/readdir.html"" rel=""nofollow noreferrer"">POSIX readdir</a>:</p>

<blockquote>
  <p>If a file is removed from or added to
  the directory after the most recent
  call to opendir() or rewinddir(),
  whether a subsequent call to readdir()
  returns an entry for that file is
  unspecified.</p>
</blockquote>

<p>So, my guess is ... it depends.</p>

<p>It depends on the OS, on the time of day, on the relative order of the files added/deleted, ...</p>

<p>And, as a further point, between the time the <code>readdir()</code> function returns and you try to <code>unlink()</code> the file, some other process could have deleted that file and your <code>unlink()</code> fails.</p>

<hr>

<p><em>Edit</em></p>

<p>I tested with this program:</p>

<pre><code>#include &lt;dirent.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int main(void) {
  struct dirent *de;
  DIR *dd;

  /* create files `one.zip` and `one.log` before entering the readdir() loop */
  printf(""creating `one.log` and `one.zip`\n"");
  system(""touch one.log""); /* assume it worked */
  system(""touch one.zip""); /* assume it worked */

  dd = opendir("".""); /* assume it worked */
  while ((de = readdir(dd)) != NULL) {
    printf(""found %s\n"", de-&gt;d_name);
    if (strstr(de-&gt;d_name, "".zip"")) {
      char logname[1200];
      size_t i;
      if (*de-&gt;d_name == 'o') {
        /* create `two.zip` and `two.log` when the program finds `one.zip` */
        printf(""creating `two.zip` and `two.log`\n"");
        system(""touch two.zip""); /* assume it worked */
        system(""touch two.log""); /* assume it worked */
      }
      printf(""unlinking %s\n"", de-&gt;d_name);
      if (unlink(de-&gt;d_name)) perror(""unlink"");
      strcpy(logname, de-&gt;d_name);
      i = strlen(logname);
      logname[i-3] = 'l';
      logname[i-2] = 'o';
      logname[i-1] = 'g';
      printf(""unlinking %s\n"", logname);
      if (unlink(logname)) perror(""unlink"");
    }
  }
  closedir(dd); /* assume it worked */
  return 0;
}
</code></pre>

<p>On my computer, <code>readdir()</code> finds deleted files and does not find files created between <code>opendir()</code> and <code>readdir()</code>. But it may be different on another computer; it may be different on my computer if I compile with different options; it may be different if I upgrade the kernel; ...</p>
",2
1210435,1210431,1,"<pre><code>void test();
void test1();
void test3();
void test4();

void test () {test1 ()}
void test4 () {test ()}
void test3 () {test4 ()}
void test1 () {test3 ()}
</code></pre>

<p>In C, you can't use a function unless it is defined <em>before</em> your function. This is how C works. In most other languages the compiler takes care of that. This is called forward declaration. You are just telling the compiler if you see <code>test</code>, <code>test1</code>, <code>test3</code>, <code>test4</code> in my code don't produce an error, because these functions are defined elsewhere not before my function.</p>
",2
1210436,1210431,5,"<p>C will parse your file from top to bottom.  It needs to at least understand the signature of a function before it can verify it's use.  This is why you are running into the problem you have.</p>

<p>If you want to tell C about a function before it's defined you need to prototype the function.  This is essentially adding the signature of the function to the file for C to process.  </p>

<p>For example you can prototype test1 with the following </p>

<pre><code>void test1();
</code></pre>

<p>Then you can call it before it's defined</p>

<pre><code>void test1();
void test() { test1(); }
void test1() {}
</code></pre>
",0
1210438,1210431,0,"<p>You can declare function prototypes:</p>

<pre><code>void test();
void test1();
void test3();
void test4();

void test () {test1 ();}
void test4 () {test ();}
void test3 () {test4 ();}
void test1 () {test3 ();}
</code></pre>
",0
1210439,1210431,0,"<p>you first let compiler know the function exist :)</p>
",0
1210443,1210431,2,"<p>What you need to do is ""forward declare"" your functions before defining them. As in:</p>

<pre>
// Declarations
void test();
void test1();

// Definitions
void test()
{ 
   // definition using test1
}

void test1()
{
   // definition using test
}
</pre>
",0
1602705,1255223,0,"<pre><code>if(constant=variable)
{
work();
}
</code></pre>
",0
1677735,1677724,1,"<p>Because (on your machine) an int is four bytes, but a char is 1.</p>
",0
1677737,1677724,7,"<p>Replace <code>char *p</code> with <code>int *p</code>.  Your assignment <code>*p = -1</code> only writes 1 byte, and an int is 4 bytes.</p>

<p>Your compiler should have generated a warning, as your assignment <code>char *p = &amp;x</code>; is not type safe.</p>
",2
1677743,1677724,1,"<p><code>x</code> is an int but you declare <code>p</code> as a <code>char *</code>.  On most modern architectures, an int will be exactly the length of 4 char's...</p>
",0
1677745,1677724,2,"<p>You are using a char size pointer to write into an int size memory space. The only reason it ever gets set to -1 is because of luck. -1 happens to be 0xff for a char and 0xffffffff for a int so after writing four 0xff you get one int sized -1.</p>
",0
1677816,1677724,1,"<p>The address of x initially contains these values:</p>

<pre>
Byte   1st 2nd 3rd 4th
Value  255 255 255 255
</pre>

<p>First iteration:<br/>
*p = -1; -> Address of x <strong>255</strong> 255 255 255 <br/>
p = p + 1; -> points p to 2nd byte</p>

<p>Second iteration:<br/>
*p = -1; -> Address of x 255 <strong>255</strong> 255 255 <br/>
p = p + 1; -> points p to 3rd byte</p>

<p>Third iteration:<br/>
*p = -1; -> Address of x 255 255 <strong>255</strong> 255<br/>
p = p + 1; -> points p to 4th byte</p>

<p>4th iteration:<br/>
*p = -1; -> Address of x 255 255 255 <strong>255</strong><br/>
p = p + 1; -> points p to 5th byte(outside of x's address)</p>

<p>From 5th and so forth the value of x will still be -1. I think your program stopped at forth iteration because on the 5th iteration pointer p is already out of bounds. Also, compiler should have given you a warning at compile time because you did not typecast the address of x when assigning it to p. It should have been:<br/>
<code>char* p = (char*) &x;</code></p>
",0
1482129,1482114,10,"<p>There's going to be a few answers pointing out issues with stacks/registers/temporary variables, but I'll point out that if you compile with optimizations, there is no answer.</p>

<pre>
$ gcc -O3 42.c -o 42
$ ./42
there is no answer
$ gcc -O2 42.c -o 42
$ ./42
there is no answer
</pre>

<p>Moreover, when you <em>don't</em> optimize, the answer seems dependent on your compiler:</p>

<pre>
$ gcc 42.c -o 42
$ ./42
x is the answer
$ tcc -run 42.c
y is the answer
</pre>

<p>In GCC, the <em>unoptimized</em> doit2 results in this assembly:</p>

<pre><code>doit2:
        pushl   %ebp
        movl    %esp, %ebp
        subl    $24, %esp
        cmpl    $42, -4(%ebp)
        jne     .L2
        movl    $.LC0, (%esp)
        call    puts
        jmp     .L5
.L2:
        cmpl    $42, -8(%ebp)
        jne     .L4
        movl    $.LC1, (%esp)
        call    puts
        jmp     .L5
.L4:
        movl    $.LC2, (%esp)
        call    puts
.L5:
        leave
        ret
</code></pre>

<p>When optimized, we don't even compare with 42:</p>

<pre><code>doit2:
        pushl   %ebp
        movl    %esp, %ebp
        subl    $8, %esp
        movl    $.LC2, (%esp)
        call    puts
        leave
        ret
</code></pre>
",0
1482130,1482114,12,"<p>This is due to the way functions are called. When <code>doit1</code> is called, the argument <code>a</code> (42) is put on the call stack, and <code>b</code> (also 42) is right above it. When you exit <code>doit1</code> and enter <code>doit2</code>, <code>x</code> and <code>y</code> are in the same place <code>a</code> and <code>b</code> were in <code>doit1</code>. Since neither is initialized, they just use whatever value is already in that spot -- 42 in your case. Of course, depending on optimization, this might not <em>always</em> happen, but it's a pretty good bet that it will.</p>

<p>Wikipedia has a decent article on <a href=""http://en.wikipedia.org/wiki/Call_stack"" rel=""nofollow noreferrer"">how the call stack works</a>.</p>
",0
1482162,1482114,1,"<p>The values of x and y are undefined, they just are what happens to be in the location where they are allocated.</p>

<p>In your case the y variable is either allocated in the same spot where the <code>a</code> parameter or the <code>b</code> variable were in the <code>doit1</code> method. This happens in the compiler that you used, with the specific settings that you used. Any other combination may give a different result, as there are many things that can be implemented in different ways:</p>

<ul>
<li>The <code>doit1</code> function could exist as a function or be inlined.</li>
<li>The parameter to the <code>doit1</code> function can be sent either on the stack or in a register.</li>
<li>The variable <code>b</code> in <code>doit1</code> could exist or not. As it's never used, the compiler could remove the statement.</li>
<li>Either of the <code>x</code> and <code>y</code> variables in <code>doit2</code> could be allocated on the stack or in a register, in any combination.</li>
</ul>
",0
1482223,1482167,2,"<p>When arrays are passed as arguments, they always '<em>degrade</em>' to simple pointers. So the prototype:</p>

<pre><code>int doit(int x[], int y[]) ;
</code></pre>

<p>is equivalent to </p>

<pre><code>int doit( int* x, int* y ) ;
</code></pre>

<p>I prefer the second as it is clear what is really happening, the first promises something that cannot be delivered. It serves perhaps as an indication that what is expected is a pointer to an array rather a pointer to a single object, but it has no effect on actual code generation. Often such functions have additional arguments to specify the size of teh array being passed.</p>

<p>The difference between an array and a pointer is simply that an array contains size information. So for example in the following:</p>

<pre><code>void fn( int x1[], int* x2 )
{
    printf( ""sizeof(x1) = %u\n"", sizeof( x1 ) ) ;
    printf( ""sizeof(x2) = %u\n"", sizeof( x2 ) ) ;
}

int main()
{
    int x[10] ;
    int* y = x ;
    printf( ""sizeof(x) = %u\n"", sizeof( x ) ) ;
    fn( x, y ) ;
}
</code></pre>

<p>Will output (on 32bit platform):</p>

<pre><code>sizeof(x) = 40
sizeof(x1) = 4
sizeof(x2) = 4
</code></pre>

<p>yet x, x1 and x2 all refer to the same array.</p>
",2
1482243,1482167,5,"<p>First, as a small matter of convenience, you may find it easier to initialize the arrays like this:</p>

<pre><code>int x[2] = { 1, 2 };
int y[2] = { 3, 4 };
</code></pre>

<p>As a note, this is only legal in initialization. We can't do this:</p>

<pre><code>int x[2];
x = { 1, 2 };
</code></pre>

<p>This is an array <em>initialization</em>. We're not ""assigning"" to an array because an array isn't an lvalue, but we can still initialize it. Note that any values we don't fill in will be initialized to zero:</p>

<pre><code>int lots[100] = { 1 };
</code></pre>

<p>Now <code>lots</code> is an array of 100 elements, <code>lots[0]</code> is 1, and <code>lots[1]</code> through <code>lots[99]</code> are all 0. We guarantee the values because we <em>initialized</em> the array. If we just did:</p>

<pre><code>int lots[100];
</code></pre>

<p>Then we've declared, <em>but not initialized</em>, our array, so it holds garbage like any other local variable. A common idiom is:</p>

<pre><code>int lots[100] = { 0 };
</code></pre>

<p>To initialize our array to all zeroes - the one value we declare is 0, and the other ones are zeroed out automatically.</p>

<p>Second, to address your actual concern, let's look at <code>doit()</code>:</p>

<pre><code>int doit(int x[], int y[]) {
</code></pre>

<p>This is pretty basic - it declares a function that takes two arrays. But you can't pass arrays to a function in C, or return them from a function in C, so what does this really mean?</p>

<pre><code>int doit(int *x, int *y) {
</code></pre>

<p>In C, all an ""array"" is (when passed to a function) is a pointer to the first element of that array. That's why arrays are zero indexed. To access the first element of an array, we dereference the pointer. To access the second element, we add <code>sizeof(array type)</code> to the pointer, and dereference that:</p>

<pre><code>x[0] == *x
x[1] == *(x + 1)
// and so on
</code></pre>

<p>A commonly noted product of this is the following:</p>

<pre><code>x[2] == *(x + 2) == *(2 + x) == 2[x]
</code></pre>

<p>While not commonly used, it is still pretty cool. But don't use it in real code. That's decidedly <em>not</em> cool.</p>

<p>Anyway, so the addresses of our arrays (well, pointers to the first elements of our arrays) are passed to our <code>doit()</code> function. What happens next:</p>

<pre><code>    x = y;
</code></pre>

<p>This is saying ""Tell our local <code>x</code> pointer to point to <code>y</code>. It doesn't change the original <code>x</code> array, because we're assigning to the <em>pointer</em>, not to the array (which we can't do). So we end up basically with two names, <code>x</code> and <code>y</code>, for the same array. Any changes to <code>x</code> or <code>y</code> will be reflected in the array passed into <code>y</code>.</p>

<pre><code>    x[0] = 5;
    y[2] = 10;
</code></pre>

<p>This is pretty basic. We set the first element of our array to 5 and the third element to 10. No problems here, assuming the array passed in for <code>y</code> has at least three elements (cue ominous music).</p>

<pre><code>}
</code></pre>

<p>Actually, this is one of the bigger problems in <code>doit()</code>. How did we declare <code>doit()</code>?</p>

<pre><code>int doit(int x[], int y[])
</code></pre>

<p>So <code>doit()</code> returns an <code>int</code>, but we have no <code>return</code> statement! While some compilers may accept this in varying degrees, it's much better to either return a value, or change the return type of <code>doit()</code> to <code>void</code> (which I suspect is what you want) so that it doesn't return anything. If your function returns <code>void</code>, you can omit the <code>return</code> statement at the end, or you could explicitly say <code>return;</code> with no arguments, since you're returning nothing. (Don't worry, this monster is almost finished.)</p>

<p>The biggest problem here, as you well know, is that <em>we can't guarantee</em> that the arrays we pass our function will have three elements. We can't even guarantee they'll be arrays. We can call it like this:</p>

<pre><code>int i = 10;
doit(&amp;i, &amp;i);
</code></pre>

<p>And it's legal. The C language will not check to make sure the arrays you pass a function are big enough, nor will it give you any built-in facilities for checking the size of the array. This doesn't work:</p>

<pre><code>size_t array_size(int a[]) {
    return sizeof(a) / sizeof(a[0]);
}
</code></pre>

<p>It won't work because it's rewritten at the compiler level as this:</p>

<pre><code>size_t array_size(int *a) {
    return sizeof(a) / sizeof(a[0]);
}
</code></pre>

<p>And <code>sizeof(int *)</code> is not the size of the array, but the size of the <em>pointer</em> to the array (and the pointer is just a numeric address in memory, usually a computer word). So while it's legal to modify <code>y[2]</code> in your <code>doit()</code> function, the array you passed in <code>main()</code> doesn't have enough elements, so we get <em>undefined behavior</em>. The compiler can do anything - it can overwrite <code>x</code>, or overwrite some other local variable, or overwrite your code data, or do anything it wants to (the classic example is causing demons to fly out of your nose) and still be a valid C compiler. That's the danger of C - it won't check to make sure you play by the rules. The reason for this is that it's meant to be a fast language, capable of producing highly efficient code, and checking whether or not you play by the rules makes your program slower. So if you want to make sure you play by the rules, you have to check the rules yourself:</p>

<pre><code>void doit(int y[], size_t len) {
    y[0] = 5;
    if(len &gt; 2)
        y[2] = 10;
    else
        y[len] = 10;
}
</code></pre>

<p>Then call it:</p>

<pre><code>#define SIZE 2
int y[SIZE] = { 3, 4 };
doit(y, SIZE);
</code></pre>

<p>Now we can call <code>doit()</code> safely, even on small arrays. This pattern of passing an array length as a separate argument to a function is very common in C, and is found in most C standard library functions dealing with arrays and pointers.</p>
",5
1482173,1482167,-4,"<p>The addresses of arrays are passed to the <code>doit()</code> function, but what does ""<em>passed to the pointer</em>"" mean?</p>
",2
1482178,1482167,2,"<p>Adress of the first member of the array.</p>

<p>We can check this using a debugger, for example, gdb.</p>

<pre><code>Starting program: /tmp/doit 

Breakpoint 2, main () at doit.c:11
11  int x[]={1,2,4,5};
(gdb) n
12  int y[]={11,12,14,15};
(gdb) print x
$1 = {1, 2, 4, 5}
(gdb) print y
**$2 = {134520820, -1076989448, 134513312, -1207230476}**
(gdb) print &amp;x[0]   &lt;--- PRINT ADDRESS OF FIRST ELEMENT OF X.***
***$3 = (int *) 0xbfce71f4
(gdb) print &amp;y[0]   &lt;--- PRINT ADDRESS OF FIRST ELEMENT OF Y.***
$4 = (int *) 0xbfce71e4
(gdb) n
14  doit(x,y);
(gdb) step
//FUNCTION CALL IS DISPLAYED HERE. 
Breakpoint 1, ***doit (x=0xbfce71f4, y=0xbfce71e4)*** at doit.c:7
7 }
(gdb) 
</code></pre>

<p>Values of x and y as passed to doit are shown here:</p>

<pre><code>Breakpoint 1, ***doit (x=0xbfce71f4, y=0xbfce71e4)*** at doit.c:7
</code></pre>

<p>x is 0xbfce71f4. Thats the address of the first element of the array X.</p>

<p>y is 0xbfce71e4. Thats the address of the first element of the array Y.</p>

<p>Additionally, think about this. </p>

<p>arrays can't be assigned in C. What I mean, is that x=y will yield a compilation error.
(something like : error: incompatible types in assignment). Consequently, if each parameter received an array, instead of the address of its first element, your code wouldn't compile.</p>
",0
1144507,1144462,0,"<p>with <a href=""http://www.java2s.com/Code/C/stdio.h/fgetposstoresthecurrentfilepositionindicator.htm"" rel=""nofollow noreferrer"">fgetpos</a>  you can store a pointer to a position in a file and jump to it at any time with <a href=""http://www.java2s.com/Code/C/stdio.h/fseekmovesthefilepositionpointer.htm"" rel=""nofollow noreferrer"">fseek</a>:  </p>
",0
1144510,1144462,0,"<p>C or C++? If C++, you can use seekp() to position the output pointer. This will only enable you to overwrite, though.</p>
",1
1144512,1144462,6,"<p>The only way to do what you're describing in a single file would be reserve all the space you were going to need to for the ""log"" entries up front, which I'm guessing you can't do because you don't know how big they're going to be.</p>

<p>You can't just insert into a file, moving up the contents above the insertion point to make room.  It's just not a concept that common filesystems support.  You'd need to physically read and re-write all the ""output"" pieces in order to insert a ""log"" piece, which would require increasingly large amounts of work as the file grew.</p>

<p>Your best bet would be to write two separate files, then join them together at the end.</p>

<p><strong>Edit</strong> following Sharpie's comment: Since the output is a set of commands for a program, does that mean you can safely assume that it won't ever be more than a couple of MB big, and just build it in memory before writing it all out in one go?</p>
",2
1144516,1144462,2,"<p>It is a very unusual requirement.  </p>

<p>One way would be to <strong>prefix a differentiating string</strong> for the two kinds of 
output lines and then writing them into the same file. When you want a specific set of outputs, <strong>grep</strong> for them in the combined file.</p>

<blockquote>
  <p>output.txt...<br>
  MARK1: log<br>
  MARK2: output<br>
  MARK1: log<br>
  MARK2: output<br>
  MARK2: output  </p>
</blockquote>

<pre><code>grep ""^MARK1:"" output.txt
grep ""^MARK2:"" output.txt
</code></pre>

<hr>

<p>You are eventually going to need the file as you wished it to be written.<br>
For that, you will need to <strong>chop off</strong> the prefix strings.<br>
At that time it would be very easy if you used strings that matched a simple <strong>regex</strong><br>
Something like,</p>

<pre><code>sed 's/^MARK.://g' output.txt &gt; filtered.txt
</code></pre>
",0
1144518,1144462,4,"<p>You cannot do this directly, for a very simple reason:</p>

<p>There is no way to insert bytes in the middle of a file. You can only <em>overwrite</em> a piece of a file or <em>append</em> to the end of a file.</p>

<p>If you want to insert into the middle of a file, you have two options:</p>

<ul>
<li>Read all the bytes after the position where you want to insert into memory. Then write the piece that you want to insert, then write all the bytes that you cached into memory. The result will be that bytes are inserted the given position, at a cost of an arbitrarily large block of memory to hold the piece that you have to ""push back"".</li>
<li>Alternatively, you write everything to a new file. Copy bytes from the source file into a new file. If you are at the point where you want to insert your new data, write the new line. Then continue copying from the original file until you're done. This works without requiring a possibly large chunk of memory, but requires you to use a temporary file in which you store the combined result.</li>
</ul>

<p>...</p>

<ul>
<li>Alternatively alternatively, don't write your output directly to a file, but keep everything in memory, and write it ordered to the output file once you're done collecting log lines.</li>
</ul>
",1
1491959,1491951,16,"<p>There's no difference.  There's no code needed to ""create"" an uninitialised array.</p>

<p>In the case of a static array, the memory is reserved and available all the time.  In the case of an automatic array, it's on the stack, and all that's required to ""create"" it is to move the stack pointer, which is going to happen anyway on entry to the function.</p>

<p>(And one day you'll try to use that function in a multithreaded program, and the static version will suffer occasional intermittent failures that drive you to drink and drugs.  It's just not worth the risk.)</p>
",4
1491960,1491951,1,"<p>The only way to know is to try it and test it.  It is unlikely to make much difference, though.</p>
",0
1491963,1491951,2,"<p>You are attempting a micro-optimisation without benchmarking, which is generally deemed to be a bad thing. You should always benchmark. Otherwise , how will you know for sure that any attempt at optimisation worked?</p>

<p>It is unlikely you will gain anything from doing so, and code readability and maintainabilty should come first.</p>
",0
1491965,1491951,5,"<p>As usual, you should be profiling first. Local variables probably only cause the stack pointer to be decremented a bit more which should not have any performance penalty.</p>
",0
1491967,1491951,10,"<p>I would definitely write it the simplest and most readable way first. Once per millisecond sounds like a very <em>rarely</em> run function to be micro-optimising.</p>

<p>Once you've got it working, benchmark it. Decide if performance is good enough. If it's not, optimise and benchmark again. <em>Don't</em> bend clean code out of shape without very solid numbers to back up your decision.</p>
",0
1491981,1491951,2,"<p>Allocating stack variables aren't like allocating heap variables all that happens is the stack pointer is moved down far enough to allocate all the memory needed by the function.  There is no overhead in allocating one or one hundred variables in a stack frame. The stack pointer is already going to be moved when the function is called even if there are zero variables (to record where to return to etc.)</p>
",0
1491994,1491951,0,"<p>Reserving space for variables with automatic storage duration means just decreasing the stack pointer, so as long as these aren't the only local variables, there's no overhead.</p>

<p>What might hurt performance is that stack-allocated variables have to be addressed relative to stack or base pointer, so using <code>static</code> might slightly improve performance.</p>

<p>As always, benchmark the code to make sure.</p>
",0
1494637,1491951,1,"<p>On SPARC especially in 64 bits mode, the static case is slower. The access to a global variable (which the static is, it's only the name that is limited to the scope of the function) needs 5 instructions using 3 register, in your case 10 instructions only to get the address of the arrays. The non static version, as was already pointed out, has no overhead, as the frame is built up in anycase, if the stack pointer grows 16 bytes or 200 makes no difference.
But be careful if you init your array, this can yield a hidden memset that can be costly.</p>

<pre><code>void frequentlyCalledFunction(void)
{
  double matrix1[10][10]={0.0};
  double matrix2[10][10]={0.0};
  /* do something with the matrices ... */
}
</code></pre>

<p>will probably make 1 or 2 memcpy or memset calls to initialise the arrays.</p>
",0
1690438,1690428,8,"<p>You must pass a valid array with at least one member to this function:</p>

<pre><code>#include&lt;assert.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;time.h&gt;

int
maxValue(int myArray[], size_t size) {
    /* enforce the contract */
    assert(myArray &amp;&amp; size);
    size_t i;
    int maxValue = myArray[0];

    for (i = 1; i &lt; size; ++i) {
        if ( myArray[i] &gt; maxValue ) {
            maxValue = myArray[i];
        }
    }
    return maxValue;
}

int
main(void) {
    int i;
    int x[] = {1, 2, 3, 4, 5};
    int *y = malloc(10 * sizeof(*y));

    srand(time(NULL));

    for (i = 0; i &lt; 10; ++i) {
        y[i] = rand();
    }

    printf(""Max of x is %d\n"", maxValue(x, sizeof(x)/sizeof(x[0])));
    printf(""Max of y is %d\n"", maxValue(y, 10));

    return 0;
}
</code></pre>

<p>By definition, the size of an array cannot be negative. The appropriate variable for array sizes in C is <code>size_t</code>, use it.</p>

<p>Your <code>for</code> loop can start with the second element of the array, because you have already initialized <code>maxValue</code> with the first element.</p>
",8
1690445,1690428,5,"<p>A for loop has three parts:</p>

<pre><code>for (initializer; should-continue; next-step)
</code></pre>

<p>A for loop is equivalent to:</p>

<pre><code>initializer;
while (should-continue)
{
    /* body of the for */
    next-step;
}
</code></pre>

<p>So the correct code is:</p>

<pre><code>for (i = 0; i &lt; size; ++i)
</code></pre>
",2
1690448,1690428,1,"<p>the paren after the for seems to be missing some contents.</p>

<p>normally it should be something like</p>

<pre><code>for (i=0; i&lt;size; i++)
</code></pre>
",0
1340890,1340876,1,"<p>Make sure you allocate <code>str1</code> and <code>str2</code> properly.</p>

<pre><code>char str1[STRING_SIZE];
char str2[STRING_SIZE];
</code></pre>

<p>Also, keep in mind that <code>fgets</code> will null-terminate your string, so you're really only getting <code>STRING_SIZE - 1</code> characters.</p>
",1
1340894,1340876,1,"<p>Use getch in a loop.</p>
",1
1490926,1490839,0,"<p>Thanks for all the help. Delroth &amp; Imagist (well FooBar too, I dont know how I missed his comment while I was testing the theory since its exactly what I did) reminded me by simply adding another value for cash after each line would produce the result I was looking for.</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void) 
{
    int cash;

    printf(""Enter a dollar amount: "");
    scanf(""%d"", &amp;cash);

    printf(""$20 bills = %d\n"", cash / 20);
    cash = cash % 20;

    printf(""$10 bills = %d\n"", cash / 10);
    cash = cash % 10;

    printf(""$5 bills = %d\n"", cash / 5);
    cash = cash % 5;

    printf(""$1 bills = %d\n"", cash / 1);
    cash = cash % 1;
    return 0;
}
</code></pre>

<p>thats using the modulo % which hasnt been covered in the book yet, I'm going to try it again the way Pax suggested. Thanks again for the help</p>
",2
1490854,1490839,1,"<p>You may have to use the modulo operator (<code>%</code>) which returns the remainder of the division of two numbers (for example, <code>93 % 20</code> equals <code>13</code>).</p>

<p>For example :</p>

<pre><code>int cash = 93;
int twenty, ten, five, one;

twenty = cash / 20;
cash = cash % 20;

ten = cash / 10;
cash = cash % 10;

/* etc. */
</code></pre>
",0
1490863,1490839,9,"<p>I think you are mistaken a bit here. As you said, values are not left by the previous <code>printf</code>. You need to update the value of the variable <code>cash</code>. Here is what could help:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void) 
{
    int cash;

    printf(""Enter a dollar amount: "");
    scanf(""%d"", &amp;cash);

    printf(""$20 bills = %d\n"", cash / 20);
    cash = cash % 20;
    printf(""$10 bills = %d\n"", cash / 10);
    cash = cash % 10;
    printf(""$5 bills = %d\n"", cash / 5);
    cash = cash % 5;
    printf(""$1 bills = %d\n"", cash);
    return 0;
}
</code></pre>

<p>The modulo (%) operator gives you back the remainder after performing the division. Hence:</p>

<pre><code>93 % 20 = 13
13 % 10 = 3
</code></pre>

<p>and so on.</p>
",4
1490880,1490839,5,"<p><code>cash</code> is a <strong>variable</strong> meaning that it can <strong>vary</strong> in value.  In other words, you can change the value of cash.</p>

<p>The <code>%</code> operator returns the remainder from a division.  So if you do <code>cash = 93 % 20;</code> then <code>cash</code> should contain <code>13</code>.</p>

<p>Remember that you can also set <code>cash</code> in relation to itself.  So <code>cash = cash % 20;</code> would set <code>cash</code> to the value of the remainder of <code>cash / 20</code>.</p>
",0
1490884,1490839,0,"<p>I would put another integer at the top to represent the number of bills for the current denomination:</p>

<pre><code>int billCount;
</code></pre>

<p>then replace each section (except the $1 section) with:</p>

<pre><code>billCount = cash / 20;                  // billCount &lt;- 93/20 = 4.
printf(""$20 bills = %d\n"", billCount); 
cash -= (billCount * 20);               // cash &lt;- cash - (4*20) = 13.
</code></pre>

<p>You <em>can</em> do it with modulo operators with less lines of code but the above code is what the suggestion from  the book is pointing you toward.</p>

<p>Try to work it out using just the information above, if possible (it'll make you a better programmer). If you still can't do it, here's my full solution.</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void) {
    int cash, count;

    printf(""Enter a dollar amount: "");
    scanf(""%d"", &amp;cash);

    count = cash / 20;
    printf(""$20 bills = %d\n"", count);
    cash -= (count * 20);

    count = cash / 10;
    printf(""$10 bills = %d\n"", count);
    cash -= (count * 10);

    count = cash / 5;
    printf("" $5 bills = %d\n"", count);
    cash -= (count * 5);

    printf("" $1 bills = %d\n"", cash);

    return 0;
}
</code></pre>
",2
1491073,1490839,4,"<p>Also, for the record,
you may want to put the bill values in a table
and iterate on this to avoid copy-pasted code:</p>

<pre><code>int main()
{
    int billval[] = { 20, 10, 5, 1, 0 };
    int cash, i;

    printf(""Enter a dollar amount: "");
    scanf(""%d"", &amp;cash);

    for(i = 0; billval[i]; i++) {
        printf(""$%d bills = %d\n"", billval[i], cash / billval[i]);
        cash = cash % billval[i];
    }

    return 0;
}
</code></pre>

<p>Here, the billval table is zero-terminated so we know when to stop
iterating&lt;</p>
",2
1678725,1678707,11,"<p>given a string <code>str</code> which has length <code>length</code> and a rotation amount <code>n</code></p>

<p>rotate left is equivalent to</p>

<pre><code>reverse(str, 0, n);
reverse(str, n, length);
reverse(str, 0, length);
</code></pre>

<p>rotate right is equivalent to</p>

<pre><code>reverse(str, 0, length - n);
reverse(str, length - n, length);
reverse(str, 0, length);
</code></pre>

<p>Now you just need a reverse function.</p>

<p>Update:
I thought of how you can use mod's to make you always rotate in the right direction depending on the sign of <code>n</code>.</p>

<p>e.g.</p>

<pre><code>int mod = n % length;
if (mod != 0) { //if 0, don't rotate
    reverse(str, 0, mod);
    reverse(str, mod, length);
    reverse(str, 0, length);
}
</code></pre>

<p>going through the various cases</p>

<p>if n == 5 and length = 10, mod = 5</p>

<p>if n == 16 and length = 10, mod = 6 -- rotating left by 16 = rotating left by 6</p>

<p>if n == 0 and length = anything, mod = 0</p>

<p>if n == -1 and length = 10, mod = 9 -- rotating right by 1 is the same as rotating left by 9</p>

<p>if n == -15 and length = 9, mod = 3 -- rotating right by 15 is the same as rotating left by 3</p>
",4
1678735,1678707,2,"<p>I'd do something like this:</p>

<pre><code>void rot(char *buf, int len, int r)
{
  char *temp=malloc(r&gt;=0?r:-r);
  if(r&gt;=0)
  {
    memcpy(temp, buf+len-r, r);
    memmove(buf+r, buf, len-r);
    memcpy(buf, temp, r);
  }
  else
  {
    memcpy(temp, buf, r);
    memmove(buf, buf+r, len-r);
    memcpy(buf+len-r, temp, r);
  }

  free(temp);
}
</code></pre>

<p>provided of course that r&lt;len, len is at least 1, you know, normal sanitation checks.</p>
",2
1678754,1678707,0,"<p><a href=""https://stackoverflow.com/questions/1616086/shifting-elements-in-an-array-c"">Shifting elements in an array C++</a></p>

<p>Also,
<a href=""http://www.cs.bell-labs.com/cm/cs/pearls/s02b.pdf"" rel=""nofollow noreferrer"">http://www.cs.bell-labs.com/cm/cs/pearls/s02b.pdf</a></p>
",0
1679769,1678707,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

char* strrot (int offset, size_t size, const char *inStr);

int main (int argc, const char * argv[]) {
    const char *rotStr = ""rotateme"";
    size_t rotStrSize = strlen(rotStr);
    char *resultStr;

    resultStr = strrot(-3, rotStrSize, rotStr);
    printf(""-3, %s\n"", resultStr);
    free(resultStr);

    resultStr = strrot(2, rotStrSize, rotStr);
    printf(""+2, %s\n"", resultStr);
    free(resultStr);

    resultStr = strrot(11, rotStrSize, rotStr);
    printf(""+11, %s\n"", resultStr);
    free(resultStr);

    resultStr = strrot(0, rotStrSize, rotStr);
    printf(""0, %s\n"", resultStr);
    free(resultStr);

    resultStr = strrot(-11, rotStrSize, rotStr);
    printf(""-11, %s\n"", resultStr);
    free(resultStr);

    return 0;
}

char* strrot (int offset, size_t size, const char *inStr) {
    char *result = (char *)malloc(size * sizeof(char));
    int trueOffset = size - (offset % size);

    int inIndex = trueOffset;
    int outIndex = 0;

    for (inIndex = trueOffset; inIndex &lt; (int)size; inIndex++, outIndex++) {
        result[outIndex] = inStr[inIndex];
    }
    for (inIndex = 0; inIndex &lt; trueOffset; inIndex++, outIndex++) {
        result[outIndex] = inStr[inIndex];
    }

    result[(int)size] = '\0';

    return result;
}
</code></pre>

<p>Results:</p>

<pre><code>-3, atemerot
+2, merotate
+11, emerotat
0, rotateme
-11, atemerot
</code></pre>
",0
1719637,1719163,0,"<p>Try putting some debug statements like</p>

<pre><code>printf(""Total is: %d\n"", total);
</code></pre>

<p>and </p>

<pre><code>printf(""x is: %d\n"", x);
</code></pre>

<p>inside your 'if' statements (or anywhere that you want to check the value of your total).  You will very quickly realise where you are going wrong.</p>
",0
1719222,1719163,0,"<p>Forgot to add to total in the loop</p>
",1
1719239,1719163,6,"<p>This is clearly a homework problem, and you are clearly a beginning programmer.  Your teacher can probably give you better help than we can.</p>

<p>Some tips:</p>

<ul>
<li>You have copy-and-pasted code.  You should get rid of about the first half of the program; you should only keep the variable declarations and the loop.</li>
<li>For clarity's sakes C programmers usually have the \n at the end of a string, rather than the beginning of the next string.</li>
<li>You shouldn't use a ""for"" loop iterating over values of 'x' to drive the user interface.  If the user pressed ""1"" 28 times to calculate the GPA average, then pressed ""2"" to enter a grade, then pressed ""1"" to calculate the GPA average again, you'd divide the grade by 30 even though they only entered one grade.  You should not iterate over 'x'.  Instead, you should drive the user interface with a ""while (True)"" loop.  You should increment 'x' only when the user chooses to enter a GPA.</li>
<li>Your code for calculating 'total' is only run the very first time (when 'x' is 0).  There are no other assignments to 'total'.  Now do you see the danger of copy-and-pasted code?</li>
</ul>
",1
1719253,1719163,1,"<p>Where to start...  use do{...}while().  You're not initializing your array of floats.  You're not keeping track of how many grades have been input.  You're also never updating the total variable in your for loop, so no matter what they enter, the displayed total will never change.  You never even use the declared avg variable.</p>

<p>Here's a tip: think about the algorithm first; i.e., HOW are you going to perform these operations?  Can you separate any operations (such as calculating an average) from others (such as getting user input)?  Once you've figured out your process you want to use, consider what types of data structures and program flow (looping) constructs will be appropriate, THEN start coding; it'll make a big difference, and it'll be easier to implement.</p>
",0
1917823,1917763,2,"<p>Here's an algorithm:</p>

<ol>
<li>memset it all to null.</li>
<li>Increment the first character.</li>
<li>Repeat step 2 until the first character overflows.</li>
<li>Increment the second character</li>
<li>Go back to step 2 and repeat until the second character overlows.</li>
<li>Increment the third character.</li>
<li>You get the idea...</li>
</ol>

<p>I leave the implementation up to you. It's your homework.</p>
",0
1244415,1180708,1,"<p>If you can understand french, there is a good tutorial right <a href=""http://www.siteduzero.com/tutoriel-3-14189-apprenez-a-programmer-en-c.html"" rel=""nofollow noreferrer"">here</a>.</p>

<p>It explains the basics, but also the more complex stuff.</p>
",0
1244436,1180708,3,"<p>Why don't you use something that's more lightweight and simpler to use than visual Studio for your C Projects?</p>

<p>I reccommend <a href=""http://www.codeblocks.org/"" rel=""nofollow noreferrer"">Code::Blocks</a>.  Believe me, it's a lot more lightweight than Visual Studio, and in my opinion it's a lot better to work with it whilst learning to develop in C.</p>

<hr>

<p>As regards books, I would go for both <a href=""https://rads.stackoverflow.com/amzn/click/com/0131103628"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">K&amp;R's C Programming Language</a>, but I also reccomend another one : <a href=""https://rads.stackoverflow.com/amzn/click/com/0672326965"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">C Primer Plus</a> and I think the latter one is more appropriate as a beginner's book.</p>
",0
51038,50525,2,"<p>A test confirms that GCC 4.2.3 will simply compare with the overflowed result:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int a, b, c;

    a = 2000000000;
    b = 2000000000;
    c = 2100000000;

    printf(""%d + %d = %d\n"", a, b, a+b);
    if ((a + b) &gt; c)
    {
        printf(""%d + %d &gt; %d\n"", a, b, c);
    }
    else
    {
        printf(""%d + %d &lt; %d\n"", a, b, c);
    }
    return 0;
}
</code></pre>

<p>Displays the following:</p>

<pre><code>2000000000 + 2000000000 = -294967296
2000000000 + 2000000000 &lt; 2100000000
</code></pre>
",0
50530,50525,7,"<p>C will do no such thing. It will silently overflow and lead to a possibly incorrect comparison. You can up-cast yourself, but it will not be done automatically.</p>
",2
50531,50525,0,"<p>I believe this might be platform specific. Check the C documentation on how overflows are handled...</p>

<p>Ah, yes, and the upcast will not happen automatically...</p>
",0
50611,50525,0,"<p>See section 2.7, <em>Type Conversions</em> in the K&amp;R book</p>
",0
992633,50525,0,"<p>If upcasting doesn't gain you any bits (there's no guarantee that sizeof(long)>sizeof(int) in C), you can use conditions like the ones below to compare and check for overflow¡ªupcasting is almost certainly faster if you can use it, though.</p>

<pre><code>#if !defined(__GNUC__) || __GNUC__&lt;2 || (__GNUC__==2 &amp;&amp; __GNUC_MINOR__&lt;96)
#   define unlikely(x) (x)
#else
#   define unlikely(x)     (__extension__ (__builtin_expect(!!(x), 0)))
#endif

/* ----------
 * Signed comparison (signed char, short, int, long, long long)
 * Checks for overflow off the top end of the range, in which case a+b must
 * be &gt;c.  If it overflows off the bottom, a+b &lt; everything in the range. */
if(a+b&gt;c || unlikely(a&gt;=0 &amp;&amp; b&gt;=0 &amp;&amp; unlikely(a+b&lt;0)))
    ...

/* ----------
 * Unsigned comparison (unsigned char, unsigned short, unsigned, etc.)
 * Checks to see if the sum wrapped around, since the sum of any two natural
 * numbers must be &gt;= both numbers. */
if(a+b&gt;c || unlikely(a+b&lt;a))
    ...

/* ----------
 * To generate code for the above only when necessary: */
if(sizeof(long)&gt;sizeof(int) ? ((long)a+b&gt;c)
       : (a+b&gt;c || unlikely(a&gt;=0 &amp;&amp; b&gt;=0 &amp;&amp; unlikely(a+b&lt;0)))
    ...
</code></pre>

<p>Great candidates for macros or inline functions.  You can pull the ""unlikely""s if you want, but they can help shrink and speed up the code GCC generates.</p>
",0
822854,822815,0,"<p>lothar summed pretty well advantages for first idiom -- quite probably it's the best for general solutions.</p>

<p>However, there are times when 3rd option (modified) is better -- if you have a lot to output. To avoid memory stress you can add pools to the mix.</p>
",0
822824,822815,3,"<p>There's no one best way - all the options you propose are used at some time or another. The important thing is to document it well, and keep it consistent across all functions in a library, where practical.</p>
",0
822828,822815,1,"<p>You could use the first idiom (user allocates) and if the space for the string is not sufficient you reallocate. This will work if you and the user agree to use the same allocation (like malloc/free). This will give you optimum performance (no allocation for every iteration) and is still convenient for the user.</p>

<p>With this idiom the allocated storage grows as needed, but the user can at any time choose to ""shrink"" it by reallocating a smaller storage (which will start growing again if necessary).</p>
",1
496458,496448,0,"<p>When you have that function defined on a different dll or lib, so that the compiler defers to the linker to find it. Typical case is when you are calling functions from the OS API.</p>
",0
496474,496448,6,"<p>If each file in your program is first compiled to an object file, then the object files are linked together, you need <code>extern</code>. It tells the compiler ""This function exists, but the code for it is somewhere else. Don't panic.""</p>
",2
496476,496448,330,"<p><code>extern</code> changes the linkage. With the keyword, the function / variable is assumed to be available somewhere else and the resolving is deferred to the linker.</p>
<p>There's a difference between <code>extern</code> on functions and on variables.</p>
<p>For <strong>variables</strong> it doesn't instantiate the variable itself, i.e. doesn't allocate any memory. This needs to be done somewhere else. Thus it's important if you want to import the variable from somewhere else.</p>
<p>For <strong>functions</strong>, this only tells the compiler that linkage is extern. As this is the default (you use the keyword  <code>static</code> to indicate that a function is not bound using extern linkage) you don't need to use it explicitly.</p>
",4
496489,496448,2,"<p>Functions actually <em>defined</em> in other source files should only be <em>declared</em> in headers. In this case, you should use <em>extern</em> when <em>declaring</em> the prototype in a header.</p>

<p>Most of the time, your functions will be one of the following (more like a best practice):</p>

<ul>
<li>static (normal functions that aren't
visible outside that .c file)</li>
<li>static inline (inlines from .c or .h
files)</li>
<li>extern (declaration in headers of the
next kind (see below))</li>
<li>[no keyword whatsoever] (normal
functions meant to be accessed using
extern declarations)</li>
</ul>
",2
1302880,1302859,3,"<p>This is completely anecdotal, but I've heard that the <a href=""http://sqlite.org/"" rel=""nofollow noreferrer"">SQLite</a> project is considered good code.</p>
",0
1302896,1302859,6,"<p>Check out git source code: <a href=""http://github.com/git/git/tree/master"" rel=""noreferrer"">http://github.com/git/git/tree/master</a></p>
",2
1302909,1302859,6,"<p>I consider Steve Dekorte's <a href=""http://iolanguage.com/"" rel=""noreferrer"">IO language</a> implementation to be a good example for clean and pragmatic modern-day C.</p>
",1
1303850,1302859,16,"<p>Dave Hanson's <a href=""http://www.cs.princeton.edu/software/cii/"" rel=""noreferrer"">C Interfaces and Implementations</a> is a <em>very</em> well-crafted library of about 7000 lines of code.  The book is great if you can afford it.</p>

<p>The implementation of the <a href=""http://www.lua.org/"" rel=""noreferrer"">Lua</a> programming language and libraries is about 17,000 lines of C code and is very well done but quite sophisticated in places&mdash;compilers and garbage collectors are not so easy to understand without background in those fields.  But the code is beautifully engineered.</p>

<p>Git is over 125,000 lines of code.  I can't recommend that anyone study it as an example of how to engineer C code.  Just the design and public interfaces, let alone the implementations, are hard to understand&mdash;which is why there are so many git tutorials.</p>
",5
1305047,1302859,1,"<p>How about:</p>

<p>""The C Programming Language"", 2nd edition, Kernighan and Ritchie</p>

<p>Answers to Exercises</p>

<p><a href=""http://users.powernet.co.uk/eton/kandr2/"" rel=""nofollow noreferrer"">http://users.powernet.co.uk/eton/kandr2/</a></p>
",0
1306093,1302859,1,"<p>The following book (with code examples) could ease your paradigm shift a bit:</p>

<p>Stephen Kochan</p>

<p>Programming in C, Third Edition</p>

<p><a href=""http://www.kochan-wood.com"" rel=""nofollow noreferrer"">http://www.kochan-wood.com</a></p>
",0
1317203,1302859,1,"<p><a href=""https://i.stack.imgur.com/J8d41.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/J8d41.jpg"" alt=""C: A reference Manual By Harbison and Steele""></a>
</p>

<p><a href=""https://rads.stackoverflow.com/amzn/click/com/013089592X"" rel=""nofollow noreferrer"" rel=""nofollow noreferrer"">C: A Reference Manual</a> contains a variety of example code usage, with implementations centric to Standard C; A definite document to look into, perhaps along with the C Std.</p>
",0
1317208,1302859,1,"<p>The SVN project is written entirely in C and it is well maintained: consistently styled, good comments, low code smell.  I recommend <a href=""http://subversion.tigris.org/getting.html#source-release"" rel=""nofollow noreferrer"">perusing</a> it.</p>
",0
