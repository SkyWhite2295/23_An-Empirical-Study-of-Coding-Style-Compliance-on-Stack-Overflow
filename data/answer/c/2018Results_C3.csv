48963032,48962640,0,"<p>You are refering to:</p>

<blockquote>
  <p>When an expression that has integer type is added to or subtracted
  from a pointer, the result has the type of the pointer operand. If the
  pointer operand points to an element of an array object, and the array
  is large enough, the result points to an element offset from the
  original element such that the difference of the subscripts of the
  resulting and original array elements equals the integer expression.</p>
</blockquote>

<p>This is not confusing, this is just a definition of <strong>pointer arithmetic</strong>. And should be read as:</p>

<pre><code>E array[N];
assert( (&amp;array[X]+D) == &amp;array[X+D] );
</code></pre>

<p>provided that X and X+D are both in [0,N] (you can point one past the last element).</p>

<p><code>D</code> can be any integer expression. In your case it has unsigned integer type (-1 as <code>uint32_t</code> is <code>UINT32_MAX</code>) so it is undefined behavior as the result is out of the bounds of the array (1+UINT32_MAX>10).</p>

<p>If you had use <code>int32_t</code>, the the result would have point to the first element of the array:</p>

<pre><code>char array[10];
assert( (&amp;array[1]-1) == &amp;array[0] );
</code></pre>
",0
48962798,48962640,5,"<p>Assigning <code>-1</code> to <code>uint32_t</code> converts it to <code>UINT32_MAX</code> (which is <code>4294967295</code>) per <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.2.5p9"" rel=""noreferrer"">reduced modulo, 6.2.5p9</a>.</p>

<p>So your code is equivalent to:</p>

<pre><code>char arr [10];
uint32_t i = UINT32_MAX;
char * p = &amp;arr [1];
</code></pre>

<p><code>p</code> points to the second element in the array <code>arr</code>. So <code>p+i</code>, i.e., <code>p + 4294967295</code>, yields a pointer that is certainly not within the array object. So it'd be <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""noreferrer""><em>undefined behaviour</em></a>.</p>

<p>If you change the type of <code>i</code> to <code>int32_t</code> for example, then it can hold the negative value (as you might have intended in the first place).
<code>p + i</code>, i.e., <code>p - 1</code> would yeild a pointer to the first element in the array <code>arr</code> (equivalent to <code>&amp;arr[0]</code>). There's no undefined behaviour
because the resulting pointer <code>p + i</code> (== <code>&amp;arr[0]</code>) is still pointing within the array object and is perfectly valid.</p>
",1
58498982,3304836,0,"<p>Not with standard macros, no. The C standard (C11) has a specific requirement for macros in <code>6.10.3 Macro replacement</code>:</p>

<pre><code># define identifier replacement-list new-line
</code></pre>

<p>with <code>identifier</code> being explicitly defined in <code>6.4.2.1 Identifiers, General</code> as:</p>

<pre><code>identifier:
    identifier-nondigit
    identifier identifier-nondigit
    identifier digit
identifier-nondigit:
    nondigit
    universal-character-name
    other implementation-defined characters
nondigit: one of
    _ a b c d e f g h i j k l m
    n o p q r s t u v w x y z
    A B C D E F G H I J K L M
    N O P Q R S T U V W X Y Z
digit: one of
    0 1 2 3 4 5 6 7 8 9
</code></pre>

<p>So the only *possible loophole would be <code>other implementation-defined characters</code> but that's not covered by the standard, hence not really portable.</p>

<p>In any case, it wouldn't work very well with code like:</p>

<pre><code>typedef struct {
    int field1;
    int field2;
} tMyStruct;
</code></pre>

<p>since it would rather annoyingly place a C statement where no statements should ever exist :-)</p>

<p>I think if you really want to do this, you're going to have pre-process your file with a more intelligent pre-processor (one that can tell where and where not the code should go), or modify the code to explicitly put in a macro where they should be, such as selecting behaviour with:</p>

<pre><code>#ifdef PING_DEBUGGING
    #define MYPING printf(""%s,%s"", _FUNCTION_, _LINE_)
#else
    #define MY_PING
#endif
</code></pre>

<p>and  using it with:</p>

<pre><code>void myFunc(void) { MYPING;
    // proper body of function.
}
</code></pre>
",0
57281163,57280712,2,"<p>The operation <code>1000000u * 1000000u</code> has precedence over the assignment and occurs independently of it.  Where <code>unsigned int</code> is 32 bit, this will be a 32 bit unsigned result regardless of the type of <code>x</code>.</p>
",0
57280888,57280712,2,"<p>It's required to do it as modular arithmetic in whatever type <code>unsigned</code> is on the C implementation you're using. With your assumption that it's a 32-bit type, the result must be 32-bit. This would not necessarily apply in other superficially-similar examples where different type promotion rules might apply.</p>
",0
57281117,57280712,4,"<pre><code>uint64_t x = 1000000u * 1000000u;
</code></pre>

<p>Your stated assumption is that <code>int</code> is 32 bits. To be 100% clear, we need to assume that <code>UINT_MAX</code> is 2<sup>32</sup>-1, or <code>4294967295</code>. (The standard requires <code>unsigned int</code> to have a range of at least 0 to 65535, which implies a size of at least 16 bits -- but it can have <em>padding bits</em>.) It's almost certainly the same thing (I don't know of any C implementations that have padding bits), but we should be explicit if we want to ask what the standard guarantees.</p>

<p>Given that assumption, the constant <code>1000000u</code> is of type <code>unsigned int</code>, and the result of the multiplication is <code>3567587328u</code>, also of type <code>unsigned int</code>. That value is converted to <code>uint64_t</code> (with no loss of information) and stored in <code>x</code>.</p>

<p><code>uint64_t</code> is guaranteed to be exactly 64 bits wide with no padding bits. An implementation that doesn't have a type that satisfies those conditions will not define <code>uint64_t</code>, so the above wouldn't compile. (I'm assuming, of course, that this refers to the <code>uint64_t</code> defined in the standard <code>&lt;stdint.h&gt;</code> or <code>&lt;inttypes.h&gt;</code> header.)</p>

<p>The general rule for arithmetic expressions is that the type of an expression is determined by the types of its operands, not by the values of its operands or the context in which it appears. If we drop the assumption about the upper bound of <code>unsigned int</code>, the constant <code>1000000u</code> could be of type <code>unsigned int</code> or <code>unsigned long</code>, whichever type is big enough to hold it -- but the value of the product is the same as the type of the constants, even if that results in <strike>overflow</strike> wraparound. (Strictly speaking, unsigned operations don't overflow.)</p>
",2
53806981,26463074,1,"<p>After many attempts, I have found why this is needed: <strong>pointers</strong>!</p>

<p>Let's suppose you have:</p>

<pre><code>int foo = 1;
int bar = 2;
int *p = &amp;foo;
</code></pre>

<p>Picture that as memory locations, first two holding an int, the last one holding a pointer to the first int. _Atomic makes it so that those memory locations are suited for atomic operations.</p>

<p>For reasons that concern your program, you might want:</p>

<ul>
<li>foo to be atomic, so that you can, for example, atomically change
foo's value to be 2 instead of 1.</li>
<li>p to be atomic, so that you can, for example, change atomically what p is pointing to, and point to bar instead of foo.</li>
</ul>

<p>In the first case, to make foo atomic is easy, there is no ambiguity when reading it:</p>

<pre><code>_Atomic int foo;
atomic_store_explicit(&amp;foo , 2, memory_order_release); /* valid atomic op. */
</code></pre>

<p>But now you want to make p atomic, if you write:</p>

<pre><code>_Atomic int *p;
</code></pre>

<p>... that is not what you want!</p>

<p>That is, as explained above, a non atomic pointer to an atomic int. Strictly speaking, there is no guarantee that this pointer will be correctly aligned to be able to do atomic operations on it (although you'll have hard time to force a compiler to misalign a pointer!). This means that, if you managed to make the pointer misaligned, the atomic operations on it will have a chance to fail.  What you want is, on the other hand, an atomic pointer to a int that is non necessary atomic.</p>

<p>So you have to write:</p>

<pre><code>int bar = 2;
_Atomic (int *) p;
atomic_store(&amp;p , &amp;bar); /* now valid atomic operation */
</code></pre>

<p>Now you have your atomic pointer!</p>

<p>Note that for the very simple case of making the foo int atomic, you could also have written, any of these 3 declarations, the last one uses the convenience typedef defined in stdatomic.h:</p>

<blockquote>
  <p>typedef _Atomic int atomic_int;</p>
</blockquote>

<pre><code>_Atomic int foo;
_Atomic (int) foo;
atomic_int foo;
</code></pre>

<p>I made it <em>""easy to understand""</em> with an int and a pointer to and int, but when you have to deal with</p>

<pre><code>_Atomic (struct foobar *) *q;
</code></pre>

<p>You will now know that q itself is not an atomic pointer, but it points to an atomic pointer to a foobar struct!</p>

<p>And so the demonstration:</p>

<pre><code>#include &lt;stdatomic.h&gt;
void test()
{
    _Atomic int foo = 1;         /*   Atomic   */
    _Atomic int *pf = &amp;foo;      /* Non Atomic */
    _Atomic int **ppf = &amp;pf;     /* Non Atomic */
    int bar = 2;                 /* Non Atomic */
    _Atomic (int *) pb = &amp;bar;   /*   Atomic   */
    _Atomic (int *) *ppb = &amp;pb;  /* Non Atomic */

    int *res;

    res = atomic_load(ppf); /* Not OK, yields a warning */
    res = atomic_load(ppb); /* This is correct */
}
</code></pre>

<blockquote>
  <p>In function ¡®test¡¯: </p>
  
  <p>test.c:13:6: warning: assignment from incompatible pointer type [-Wincompatible-pointer-types] </p>
  
  <p>res = atomic_load(ppf);</p>
</blockquote>

<p>Indeed, the first atomic_load tries to return a non atomic pointer to an int: the int pointed to is atomic, not the pointer. It could also fail, because there is no guarantee that &amp;pf (the content of ppf) is properly aligned for an atomic operation (although practically here it is, you would have to cast pf to a misaligned int to make it fail).</p>

<p>The second atomic_load correctly works with an atomic pointer and returns it to 'res'.</p>
",0
54782482,54782027,4,"<p>You shouldn't expose the size of the struct to the caller, because that breaks the whole purpose of having private encapsulation in the first place. Allocation of your private data is no business of the caller. Also, avoid using <code>void*</code> because they complete lack type safety.</p>

<p>This is how you write private encapsulation in C:</p>

<ul>
<li>In module.h, forward declare an incomplete type <code>typedef struct module module;</code>.</li>
<li>In module.c, place the struct definition of this struct. it will only be visible to module.c and not to the caller. This is known as <em>opaque types</em>.</li>
<li>The caller can only allocate pointers to this struct, never allocate objects.</li>
<li><p>Caller code might look like:</p>

<pre><code>#include ""module.h""
...
module* m;
result = module_init(&amp;m)
</code></pre></li>
<li><p>And the <code>module_init</code> function acts as a ""constructor"", declared in module.h and defined in module.c:</p>

<pre><code>bool module_init (module** obj)
{
  module* m = malloc(sizeof *m);
  ...
  m-&gt;something = ...; // init private variables if applicable

  *obj = m;
  return true;
}
</code></pre></li>
<li><p>If the caller does need to know the size of the objects, it would only be for the purpose of hard copy etc. If there's a need for that, provide a copy function which encapsulates the allocation and copy (""copy constructor""), for example:</p>

<pre><code>result module_copy (module** dst, const module* src);
</code></pre></li>
</ul>

<p>Edit:</p>

<p>Please note that the manner of allocation is a separate issue. You don't have to use dynamic allocation for the above design. In embedded systems for example, it is common to use static memory pools instead. See <a href=""https://stackoverflow.com/questions/4440476/static-allocation-of-opaque-data-types"">Static allocation of opaque data types</a></p>
",2
54784137,54782027,1,"<p>In conforming C code you can't create a static instance of an arbitrary unknown type even if you know its size at compile time (not even if you know the alignment).</p>

<p>Let's say you try doing it anyway. How would you do it, given the size in a macro or enum <code>PRIVATE_SIZE</code>?</p>

<pre><code>unsigned char obj[PRIVATE_SIZE];
</code></pre>

<p>And then you'd pass <code>(void*)obj</code> to wherever its needed, right?
Well, this breaks the aliasing rules. While you can legally access any individual char/byte in any object, you can't do it the other way around saying that those chars are not chars, they are just storage behind other types. That is, you can't legally have a <code>short int</code> superimposed on top of, say, <code>obj[2]</code> and <code>obj[3]</code> through smarty-pants casts (e.g. <code>((struct Private*)obj)-&gt;my_short = 2;</code>). The only legal way to do something like this would be through <code>memcpy()</code>, e.g. <code>memcpy(&amp;temp, obj, sizeof temp);</code> and then back after the modification. Or you'd need to work with individual chars of <code>obj[]</code>.</p>

<p>There are two possible ways to sort of do it. One is described in another answer, basically define the instance where the type is known, but only let the outside world have a pointer to it.</p>

<p>Another, very similar, define it in assembly code and, again, let the outside world have a pointer to it. The ""beauty"" of the assembly way is that you really only need a name, an alignment and a size to allocate space for a named object.</p>

<p>And if you put the instances into a special data section (see the gcc's section attribute and the linker scripts), you may even have all of the instances in the same place (think, array) and even find out their cumulative size and therefore count.</p>

<p>Yet another thing to do while not explicitly violating any C rules is to still use this <code>unsigned char obj[PRIVATE_SIZE]</code> trick, but launder it by passing it unchanged through an assembly function that the C compiler can't look into, e.g. something like</p>

<pre><code>// struct Private* launder(unsigned char*);
.text
.globl launder
launder:
    move %first_param_reg, %return_reg
    ret
</code></pre>

<p>But you'll really need to change <code>unsigned char obj[PRIVATE_SIZE]</code> to something that would have proper alignment on your architecture, e.g. <code>double obj[PRIVATE_SIZE / sizeof(double)]</code> (or the same with <code>long long</code> if you like that way better).</p>

<p>As for <code>PRIVATE_SIZE</code>, you can have a check at compile time that it matches the size of the type, e.g.</p>

<pre><code>#include ""mod.h"" // mod.h defines PRIVATE_SIZE
struct Private { ... };
extern char StAtIcAsSeRt[sizeof(struct Private) == PRIVATE_SIZE];
</code></pre>
",0
54787772,54782027,2,"<p>You can't allocate size for a struct such as this because it isn't known at compile time.  Even if you did know the size at run time, you'd still have issues due to alignment.</p>

<p>There is a possible solution which involves defining a separate structure that has the same size and alignment requirements as the private struct.</p>

<p>For example:</p>

<p>module.h:</p>

<pre><code>#include &lt;inttypes.h&gt;

struct Public {
    uint64_t opaque1;
    uint64_t opaque2;
    uint64_t opaque3;
};

void init(struct Public *p);
</code></pre>

<p>module.c:</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;stdalign.h&gt;
#include ""module.h""

struct Private {
    int a;
    double b;
    float c;
};

static_assert(sizeof(struct Private)==sizeof(struct Public), ""sizes differ"");
static_assert(alignof(struct Private)==alignof(struct Public), ""alignments differ"");

void init(struct Public *p)
{
    struct Private *pr = (struct Private *)p;
    pr-&gt;a = 2;
    pr-&gt;b = 2.5;
    pr-&gt;c = 2.4f;
}
</code></pre>

<p>The <code>Public</code> and <code>Private</code> structs are guaranteed to have the same size, and the alignment <em>should</em> be the same.  There is the possibility of the user writing the the ""opaque"" fields of the public struct, in which case you could have aliasing issues regarding effective types, but if the user can be trusted to do that then this should work.</p>

<hr>

<p>Another, more robust option, is if you have some idea of the maximum number of objects you want to support.  If that's the case, you can have a static array of these objects in your implementation file, and the init function would return a pointer to one of the objects in this list.  Then you'd have a related cleanup function that would free the instance.</p>

<p>For example:</p>

<p>module.c:</p>

<pre><code>struct Private {
    int a;
    double b;
    float c;
};

struct PrivateAllocator {
    struct Private obj;
    int used;
};

struct PrivateAllocator list[5] = {
    { { 0, 0, 0}, 0 },
    { { 0, 0, 0}, 0 },
    { { 0, 0, 0}, 0 },
    { { 0, 0, 0}, 0 },
    { { 0, 0, 0}, 0 }
};

struct Private *private_init()
{
    int i;
    for (i=0; i&lt;5; i++) {
        if (!list[i].used) {
            list[i].used = 1;
            return &amp;list[i].obj;
        }
    }
    return NULL;
}

void private_free(struct Private *p)
{
    int i;
    for (i=0; i&lt;5; i++) {
        if (&amp;list[i].obj == p) {
            list[i].used = 0;
            return;
        }
    }
}
</code></pre>
",3
48971583,48971531,1,"<p><strong>For some additional information:</strong> </p>

<p>In C the reference to the start address of the array is given by the name <strong>without</strong> the brackets []:</p>

<p><code>array</code></p>

<p>At the array address the first element is listed in memory, so both :</p>

<p><code>*array</code> and <code>array[0]</code> give the first element of the array.</p>

<p>Moreover, these addresses will also be equal:</p>

<p><code>array == &amp;array[0]</code></p>
",0
48971659,48971531,5,"<p>The expression <code>array[n]</code> is by definition the same as <code>*(array + n)</code></p>

<p>The expression <code>array + 0</code> is by definition the same as <code>array</code> (unless <code>array</code> is an operand of <code>sizeof</code>).</p>

<p>So yes, <code>array[0]</code> and <code>*array</code> are the same.</p>

<p>This is much more than is needed in this case. For arguments of <code>sizeof</code> only the type matters, and it is certainly the same for both expressions.</p>
",3
49657345,49657202,8,"<p>You can use <code>-Wsign-compare</code> with <code>-Wsign-conversion</code>.</p>

<p>The first one warns you when you compare signed values with unsigned ones. The latter warns you about implicit conversions from unsigned to signed and from signed to unsigned.</p>

<p>In your case <code>-Wsign-compare</code> won't do anything because of integer promotion, while <code>-Wsign-conversion</code> will warn about implicit conversion in <code>s16 = u16</code>.</p>
",2
48205860,2873850,8,"<p>Templates can be realized using template headers.</p>

<p>Let foo.h like this:</p>

<pre><code>#ifndef PREFIX
    #define PREFIX
#endif
#define CCAT2(x, y) x ## y
#define CCAT(x, y) CCAT2(x, y)
#define FN(x) CCAT(PREFIX, x)

#ifndef T
    #error Template argument missing.
#endif

void FN(foo)(int x, T t)
{
    // Whatever.
}


#undef T
#undef PREFIX
#undef CCAT2
#undef CCAT
#undef FN
</code></pre>

<p>To use it you can do:</p>

<pre><code>#define T char*
#define PREFIX pchar_
#include ""foo.h""

#define T int
#define PREFIX int_
#include ""foo.h""
</code></pre>

<p>Now you have <code>pchar_foo()</code> and <code>int_foo()</code> which you can use.</p>

<p>The advantages of this is that if there is a build problem, you get line number in the template header instead of the compiler just saying the macro is wrong, and code completion works too in some IDEs.</p>

<p>The <code>PREFIX</code>, the <code>CCAT</code> and <code>FN</code> macros are very common so I extracted their definition into a separate header, and their undefinition to another one.</p>

<p>I implemented parts of the STL using this pattern for fun and use it in some of my C projects.</p>
",1
52582153,52582069,2,"<blockquote>
  <p>the array of hexadecimal characters (syntactically represented as a char pointer)</p>
</blockquote>

<p>No. ""Hexadecimal character"" is not a thing. Also, there is no char pointer there.</p>

<p><code>code</code> is an array of unsigned chars (i.e. bytes). This array has 4 elements: <code>0xb0</code>, <code>0x2a</code>, <code>0xc3</code>, <code>0x00</code> (or equivalently: <code>176</code>, <code>42</code>, <code>195</code>, <code>0</code>).</p>

<p>The type <code>uint8_t (*)()</code> is not an unsigned integer, it's a pointer to a function (of no arguments) returning a <code>uint8_t</code>.</p>

<p>What's going on in <code>(*(uint8_t(*)())code)()</code>:</p>

<ul>
<li><p>We have <code>code</code> (an array) in an expression. It is not the operand of <code>sizeof</code> or <code>&amp;</code>, so it decays to a pointer to its first element.</p></li>
<li><p>This pointer (of type <code>unsigned char *</code>) to <code>code[0]</code> is cast to a different type: <code>uint8_t (*)()</code>, i.e. a pointer to a function returning a <code>uint8_t</code>.</p>

<p>The general form of a cast is <code>( TYPE ) EXPR</code>. Here we have a <code>TYPE</code> of <code>int8_t (*)()</code> and our <code>EXPR</code> is <code>code</code>.</p></li>
<li><p>This function pointer is dereferenced (with <code>*</code>), yielding a function. This operation is redundant because any function value immediately decays back to a pointer (unless it is the operand of <code>&amp;</code>, in which case you get back a function pointer anyway).</p></li>
<li><p>The function pointer is indeed called by the final pair of parens, <code>()</code>.</p></li>
</ul>

<p>What this code actually does is highly platform dependent. On some platforms casting a data pointer to a function pointer gives you a ""function"" whose code is specified by the data, i.e. this ends up jumping to and executing the contents of <code>code</code> as machine code.</p>
",0
55216891,55213569,1,"<blockquote>
  <p>which means it's slower performance-wise than passing in pointers</p>
</blockquote>

<p>That's where you got it wrong. On a typical 32 bit computer, <code>int</code> are 32 bit and pointers are 32 bit. So the actual amount of data passing is identical between both versions. However, use of pointers can boil down to indirect access machine code, so it might actually yield less inefficient code in some circumstances. In the general case <code>int add(int a, int b)</code> is probably the most efficient.</p>

<p>As a rule of thumb, it is fine to pass all standard integer and float types by value to functions. But structs or unions should be passed through pointers.</p>

<p>In this particular case the compiler is likely to ""inline"" the whole function, replacing it with a single addition instruction in the machine code. After which the whole parameter passing turns into a non-issue.</p>

<p>Overall, don't ponder performance too much as a beginner, it is an advanced topic and depends on the specific system. Instead, focus on writing as readable code as possible.</p>
",0
55213606,55213569,1,"<p>Anytime you call a function with parameters you're copying the values of the parameters.  In your examples it's just a matter of whether you're copying pointer values or integer values.  Copying an <code>int</code> will not be noticeably faster or slower than copying a pointer, but with a pointer you have an additional read from memory whenever you dereference the pointer.</p>

<p>For any simple data type, you're better of just accepting parameters by value.  The only time it makes more sense to pass a pointer is if you're dealing with an array or <code>struct</code> which can be arbitrarily large.</p>
",4
54330425,54330088,2,"<blockquote>
  <p>Does the standard restrict possible memory addresses (which I would interpret as possible values for a pointer)?</p>
</blockquote>

<p>The C++ (nor C to my knowledge) standard does not restrict possible memory addresses.</p>

<blockquote>
  <p>Can your code rely on some values to be never used and still be fully portable?</p>
</blockquote>

<p>A program that unconditionally relies on such implementation defined (or unspecified by standard) detail would not be fully portable to all concrete and theoretical standard implementations.</p>

<p>However, using platform detection macros, it may be possible to make the program portable by relying on the detail conditionally only on systems where the detail is reliable.</p>

<hr>

<p>P.S. Another thing that you cannot technically rely on: <code>unsigned long</code> is not guaranteed to be able to represent all pointer values (<code>uintptr_t</code> is).</p>
",0
54446019,54445849,2,"<p>Largely for historic reasons, characters are small integers, and all integer arithmetic is done in the <code>int</code> type or wider. Software sometimes had to work with characters as integer codes and sometimes as things to be printed, so C developed with the <code>char</code> type being flexible.</p>

<p>Wherever an <code>int</code> or <code>unsigned int</code> may be used in an expression, including function arguments, you may use a <code>char</code> instead.</p>

<p>If we were designing the language anew, we might distinguish <code>char</code>-as-character from <code>char</code>-as-integer and require explicit conversions to convert between them. However, the language is what it is.</p>
",0
54446092,54445849,2,"<blockquote>
  <p>I would think that I at least get a warning that I am trying to print <code>%d</code> but the variable is <code>char</code></p>
</blockquote>

<p>""there is no problem"" because <code>""%d""</code> expected an <code>int</code> and <code>a</code> was converted to an <code>int</code> when passed to <code>printf()</code>.  <a href=""https://stackoverflow.com/questions/54445849/printing-char-as-integer/54446092#comment95700925_54445849"">@Weather Vane</a></p>

<hr>

<p><strong>Default argument
promotions</strong></p>

<p>Because <code>a</code> is passed to <code>printf(const char *, ...)</code>as a <code>...</code> argument:</p>

<blockquote>
  <p>The ellipsis notation in a function prototype declarator causes argument type conversion to stop after the last declared parameter. The default argument promotions are performed on trailing arguments.  C11dr ¡ì6.5.2.2 7</p>
</blockquote>

<p>The <em>default argument
promotion</em> of a <code>char</code> converts it into an <code>int</code><sup>1</sup>.</p>

<hr>

<p><sup>1</sup> Or <code>unsigned</code> when <code>CHAR_MAX &gt; INT_MAX</code>.<br>
(Example: exceptional platforms where <code>char, int</code> are the same bit width and sign-ness.)</p>
",2
56855974,4178804,-1,"<p>At first I was thinking, 
""They need to use pointer arithmetic so the
object doesn't get <strong>auto de-referenced</strong> by the
<strong>""[ ]""</strong> operator.</p>

<p>Then I realized, no... <strong>Arrays in C don't have
null slots</strong>.</p>

<p>I conclude, the asker is:</p>

<ol>
<li><p>Using an array of structs.</p></li>
<li><p>Using it as if it were an array of
pointers to structs.</p></li>
</ol>

<p><strong>peoro's solution</strong> is pretty good. But I would recommend modifying it a bit.
Add a "".exists"" property to your struct if you want to do it the lazy/simple way.
Simple is not a bad thing, the more parts in a machine the more things that can go wrong.</p>

<p>Code below demonstrates two things:</p>

<ol>
<li><p><strong>Faking a sparse array</strong> using peoro's solution with .exists flag modification.</p></li>
<li><p>An <strong>actual sparse array</strong> using double pointers.</p></li>
</ol>

<hr>

<pre><code>#include&lt;stdlib.h&gt; //:for: malloc(...)
#include&lt;stdlib.h&gt; //:for:   free(...)
#include &lt;stdio.h&gt; //:for: printf(...)
int main( void ){
    printf(""[BEG:main]\n"");

    typedef struct MyStruct{
        int whatever;
    } MyStruct;

    int        num = 16; //:sixteen_elements

    //:USE CALLOC HERE! If you use malloc you'll
    //:end up with something even worse than
    //:null pointers... Pointers that point to
    //:random places in memory. 
    //:
    //: It will make your:
    //: if( arr[i] != NULL )... 
    //: look before you leap check worthless.
    MyStruct** arr =(
        calloc(
            1 //:allocating 1 item: arr

            //:Amount of memory taken up by
            //:all 16 MyStruct pointers in array.
        ,   sizeof(MyStruct*)*num
        )
    );;

    //:Initialize only the EVEN slots:
    for(int i = 0; i &lt; num; i+=2 ){
        //:Create new MyStruct in slot i,
        //:initialized with junk data.
        arr[i]= malloc(sizeof(MyStruct));
    };;

    //:If element not null, set it's whatever:
    for(int i = 0; i &lt; num; i++){
        if(NULL != arr[i]){
            arr[i] -&gt; whatever = i;
        };;
    };;

    //:Loop and print to confirm:
    for(int i = 0; i &lt; num; i++){
        if(NULL != arr[i]){
            printf(""whatever: %d\n"", arr[i] -&gt; whatever);
        };;
    };;

    //:ALTERNATIVELY:
    //:If we were going to use peoro's method,
    //:I would advise adding a "".exists"" flag
    //:to your struct.

    typedef struct DoublePointersAreTooMuchWork{
        int exists;

        //:Because we are going to use malloc this
        //:time, we have no guarantee what this
        //:value will be. but you will probably
        //:see all of them == 0. If you set
        //: num=1000 you'll probably see a non-zero
        //: entry somewhere. But, no guarantees!
        int mystery_value;
    } MyStruct02;

    MyStruct02* arr2 = malloc(sizeof(MyStruct02)*num);
    for(int i = 0; i &lt; num; i++ ){

        if( i%2 ){ //:evens
            arr2[i].exists = 1;
        }else{
            arr2[i].exists = 0;
        };;
    };;

    for(int i = 0; i &lt; num; i++ ){
        if( arr2[i].exists ){
            printf(""Exists:val:%d\n"", arr2[i].mystery_value);
        }else{
            printf(""[Pretend_I_Dont_Exist]\n"");
        };
    }

    printf(""[END:main]\n"");
} //[[main]____________________________________]//

/** ****************************************** ***
OUTPUT:
[BEG:main]
whatever: 0
whatever: 2
whatever: 4
whatever: 6
whatever: 8
whatever: 10
whatever: 12
whatever: 14
[Pretend_I_Dont_Exist]
Exists:val:0
[Pretend_I_Dont_Exist]
Exists:val:0
[Pretend_I_Dont_Exist]
Exists:val:0
[Pretend_I_Dont_Exist]
Exists:val:0
[Pretend_I_Dont_Exist]
Exists:val:0
[Pretend_I_Dont_Exist]
Exists:val:0
[Pretend_I_Dont_Exist]
Exists:val:0
[Pretend_I_Dont_Exist]
Exists:val:0
[END:main]
*** ****************************************** **/
</code></pre>

<p>While I am at it. If you want to run from the command line, name the file:
""NAE.C99"", then create a bash file called ""NAE.SH"" and put this into it.
Double click the script to run it, or use ""./NAE.SH"" where it resides in your
git bash terminal.</p>

<pre><code>##################################################
############################# SC[ hkmf-strict ] ##
##################################################
base_name_no_extension=""NAE""
##################################################
MY_COMMAND_STRING=$(cat &lt;&lt; GCC_COMMAND_01
    gcc                                     
    -x c                                    
    -c $base_name_no_extension.C99          
    -o my_object_file.o                     
    -m64                                    
GCC_COMMAND_01
)                                       
C=$MY_COMMAND_STRING  ############################
C=$C""-Werror        "" ## WarningsAreErrors      ##
C=$C""-Wfatal-errors "" ## StopAtFirstError       ##
C=$C""-Wpedantic     "" ## UseStrictISO_C         ##
C=$C""-Wall          "" ## WarnAboutAnyWeirdCode  ##
C=$C""-Wextra        "" ## ""-Wall"" WarningsExtra  ##
C=$C""-std=c99       "" ## VersionOf_C_ToUse      ##
MY_COMMAND_STRING=$C  ############################

echo $MY_COMMAND_STRING
     $MY_COMMAND_STRING

C1="" gcc -o EXE.exe my_object_file.o ""    
C2="" ./EXE.exe                       ""    
C3="" rm my_object_file.o             ""    
C4="" rm EXE.exe                      ""  
$C1 &amp;&amp; echo ""OK:""$C1 || ""FAIL:$C1""
$C2 &amp;&amp; echo ""OK:""$C2 || ""FAIL:$C2""
$C3 &amp;&amp; echo ""OK:""$C3 || ""FAIL:$C3""
$C4 &amp;&amp; echo ""OK:""$C4 || ""FAIL:$C4""
##################################################
read -p ""[END_OF_BUILD_SCRIPT:PressAnyKey]:""
##################################################
############################# SC[ hkmf-strict ] ##
##################################################
</code></pre>

<p>This is <strong>C99</strong> code by the way. I try to write it avoiding any C99 specific features though.</p>
",0
56773342,56768780,1,"<p>This seems to be a pure design problem. </p>

<p>The warning/error ""control reaches end of non-void function"" isn't the problem, it is rather just an indicator telling you where the actual problem is.</p>

<p>You could/should simply rewrite the function as</p>

<pre><code>void *get_memory (void) 
{
  void *temp = malloc(100);
  if(temp != NULL)
  {
    // do stuff
  }

  return temp;
}
</code></pre>

<p>And leave error handling to the caller. Because it is not an allocation function's job to terminate the application - that's bad design. </p>

<p>Alternative version with detailed error handling:</p>

<pre><code>typedef enum
{
  OK,
  ERR_OUTOFMEMORY,
  ...
} err_t;

err_t get_memory (void** mem) 
{
  *mem = malloc(100);
  if(*mem == NULL)
  {
    return ERR_OUTOFMEMORY;
  }

  // do stuff

  return OK;
}
</code></pre>
",6
53592825,7380591,2,"<p><code>man syscall</code> will also be of interest for those doing:</p>

<pre><code>syscall(SYS_ble)
</code></pre>

<p>manpages 4.04 says:</p>

<blockquote>
<pre><code>   #define _GNU_SOURCE         /* See feature_test_macros(7) */
   #include &lt;unistd.h&gt;
   #include &lt;sys/syscall.h&gt;   /* For SYS_xxx definitions */

   long syscall(long number, ...);
</code></pre>
  
  <p>Symbolic constants for system call numbers can be found in the header file <code>&lt;sys/syscall.h&gt;</code>.</p>
</blockquote>

<p>so in glibc you need:</p>

<ul>
<li><code>unistd.h</code> for the <code>syscall</code> function</li>
<li><code>sys/syscall.h</code> for the <code>SYS_</code> macros</li>
</ul>

<p>POSIX 7 <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/idx/functions.html"" rel=""nofollow noreferrer"">does not mention <code>syscall</code></a>, so it is just a <a href=""https://www.gnu.org/software/libc/manual/html_node/System-Calls.html#System-Calls"" rel=""nofollow noreferrer"">glibc extension</a>.</p>

<p>It is also worth noting that the Ubuntu 16.04 package libc6-dev 2.23 has both:</p>

<pre><code>/usr/include/syscall.h
/usr/include/sys/syscall.h
</code></pre>

<p>the first of which contains just:</p>

<pre><code>#include &lt;sys/syscall.h&gt;
</code></pre>

<p>and so allows you to use in your code just:</p>

<pre><code>#include &lt;syscall.h&gt;
</code></pre>

<p>But I can't find where that is documented at all, so I would advise you to just stick to the documented <code>#include &lt;sys/syscall.h&gt;</code>.</p>
",0
53592825,7380591,2,"<p><code>man syscall</code> will also be of interest for those doing:</p>

<pre><code>syscall(SYS_ble)
</code></pre>

<p>manpages 4.04 says:</p>

<blockquote>
<pre><code>   #define _GNU_SOURCE         /* See feature_test_macros(7) */
   #include &lt;unistd.h&gt;
   #include &lt;sys/syscall.h&gt;   /* For SYS_xxx definitions */

   long syscall(long number, ...);
</code></pre>
  
  <p>Symbolic constants for system call numbers can be found in the header file <code>&lt;sys/syscall.h&gt;</code>.</p>
</blockquote>

<p>so in glibc you need:</p>

<ul>
<li><code>unistd.h</code> for the <code>syscall</code> function</li>
<li><code>sys/syscall.h</code> for the <code>SYS_</code> macros</li>
</ul>

<p>POSIX 7 <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/idx/functions.html"" rel=""nofollow noreferrer"">does not mention <code>syscall</code></a>, so it is just a <a href=""https://www.gnu.org/software/libc/manual/html_node/System-Calls.html#System-Calls"" rel=""nofollow noreferrer"">glibc extension</a>.</p>

<p>It is also worth noting that the Ubuntu 16.04 package libc6-dev 2.23 has both:</p>

<pre><code>/usr/include/syscall.h
/usr/include/sys/syscall.h
</code></pre>

<p>the first of which contains just:</p>

<pre><code>#include &lt;sys/syscall.h&gt;
</code></pre>

<p>and so allows you to use in your code just:</p>

<pre><code>#include &lt;syscall.h&gt;
</code></pre>

<p>But I can't find where that is documented at all, so I would advise you to just stick to the documented <code>#include &lt;sys/syscall.h&gt;</code>.</p>
",0
50182937,3584705,0,"<p>Although this is an old question, here is my different solution.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int arvc, char* argv[])
{
    int (*a)[5][8];
    int i, j;

    a = (int (*)[5][8])calloc(5*8, sizeof(int));        
    for (i = 0; i &lt; 5; i++) {
        for (j = 0; j &lt; 8; j++)
            (*a)[i][j] = i *10 + j;
    }

    for (i = 0; i &lt; 5; i++) {
        for (j = 0; j &lt; 8; j++)
            printf(""%d "", (*a)[i][j]);
        printf(""\n"");
    }

    return 0;
}
</code></pre>

<h2>Compile and run</h2>

<pre><code>[user@buzz ~]$ gcc main.c -o main
[user@buzz ~]$
[user@buzz ~]$ ./main
0 1 2 3 4 5 6 7
10 11 12 13 14 15 16 17
20 21 22 23 24 25 26 27
30 31 32 33 34 35 36 37
40 41 42 43 44 45 46 47
[user@buzz ~]$
</code></pre>
",0
49585304,49585102,1,"<p>You a returning by value just like you passed by value. Of course parameter <code>v</code> is deallocated (at least semantically because compiler may optimise this with RVO return value optimisation) but its value is returned and copied in <code>v2</code>. Defining a type defines its possible values, and for a struct it is the cartesian product of its element types. So returning a <code>Vec3</code> is just returning a <em>pack</em> of three integers.</p>
",0
49585293,49585102,0,"<p>You are right, local variables are allocated on the stack.</p>

<p>When you call the method, a copy of v1 is pushed into the stack, and all the following manipulations change that exact object.</p>

<p>But, the compiler does an additional step to allow non primitive return values (structs): When calling the method an additional pointer is passed. It points to an address from the caller's stack, and the return value is written directly to that address. This also prevents additional copies and is referred to as ""return value optimizations"".</p>
",0
56115671,4156585,6,"<p>I have just came up with a solution for the exact same problem but the code i have written is platform depended.</p>

<p>The idea behind, putting <strong>known opcodes</strong> at the end of the function and searching for them from start while counting bytes we have skipped.
Here is the medium link which i have explained with some code
<a href=""https://medium.com/@gurhanpolat/calculate-c-function-size-x64-x86-c1f49921aa1a"" rel=""noreferrer"">https://medium.com/@gurhanpolat/calculate-c-function-size-x64-x86-c1f49921aa1a</a></p>
",1
54309837,54308559,2,"<blockquote>
  <p>It seems that (type-name) returns the default value for the type. </p>
</blockquote>

<p>What's that even supposed to mean? There exists no default values for types in C. Your two printf lines does this:</p>

<ul>
<li><p><code>printf(""value: %ld\n"", ((time_t) -1));</code>  </p>

<p>Here <code>-1</code> has type <code>int</code>. You force a conversion from <code>int</code> to <code>time_t</code>, the latter having an unspecified format, other than being ""a real type capable of representing times"". </p>

<p>Then you lie to the program and say that the value passed is of type <code>long int</code>. You invoke undefined behavior, anything can happen. In your particular case, it seems to give the original value <code>-1</code>. It could as well print garbage or cause a program crash.</p>

<p>This has absolutely nothing to do with the <code>time()</code> function, which isn't present anywhere in the code.</p></li>
<li><p><code>printf(""value: %d\n"", ((int) -1));</code>  </p>

<p><code>-1</code> has type <code>int</code>. You tell the compiler to convert from <code>int</code> to <code>int</code>. The compiler, being polite, doesn't question why you'd write such meaningless code, but likely just pre-process it back into <code>-1</code>.</p>

<p>You then tell <code>printf</code> that you want to print your <code>int</code> with value <code>-1</code> as an <code>int</code>. And then it does that.</p></li>
</ul>

<hr>

<blockquote>
  <p>I browsed the C11 language specification N1570. But I can't find a description about the above usage</p>
</blockquote>

<p>See C11 6.5.4 <em>Cast operators</em> and C11 7.21.6.1 <em>The fprintf function</em>.</p>
",0
59009148,3989790,1,"<p>I've been also studying K&amp;R book. An good approach is to use a <code>int array</code> for storing word frequencies. The <strong>array index is the word length</strong>, and <strong>the array values are the frequencies.</strong> </p>

<p>For example: </p>

<pre><code>int histogram[15]; // declares an int array of size 15

// it is very important to initialize the array
for (int i = 0; i &lt;= 15; ++i) {
    histogram[i] = 0;
}

histogram[4] = 7; // this means that you found 7 words of length 4
</code></pre>

<p>Given that now you have a data structure for storing your word length frequencies, you can use the same reasoning of Word Counting example found in the book to populate the <code>histogram</code> array. It is very important that you manage to find the right spot for <strong><em>word length tracking (and resetting it)</em></strong> and <strong><em>histogram update</em></strong>.</p>

<p>You can create a function <code>display_histogram</code> for displaying the histogram afterwards.</p>

<p>Here's a code example:</p>

<pre><code>#include&lt;stdio.h&gt;

#define MAX_WORD_LENGTH 15
#define IS_WORD_SEPARATOR_CHAR(c) (c == '\n' || c ==  ' ' || c == '\t')

#define IN  1
#define OUT 0

/* WARNING: There is no check for MAX_WORD_LENGTH */

void display_horizontal_histogram(int[]);
void display_vertical_histogram(int[]);
void display_histogram(int[], char);

void display_histogram(int histogram[], char type) {
    if (type == 'h') {
        display_horizontal_histogram(histogram);
    } else if (type = 'v') {
        display_vertical_histogram(histogram);
    }
}

void display_horizontal_histogram(int histogram[]) {
    printf(""\n"");

    //ignoring 0 length words (i = 1)
    for (int i = 1; i &lt;= MAX_WORD_LENGTH; ++i) {
        printf(""%2d: "", i);
        for (int j = 0; j &lt; histogram[i]; ++j) {
            printf(""*"");
        }
        printf(""\n"");
    }

    printf(""\n\n"");
}

void display_vertical_histogram(int histogram[]) {
    int i, j,  max = 0;

    // ignoring 0 length words (i = 1)
    for (i = 1; i &lt;= MAX_WORD_LENGTH; ++i) {
        if (histogram[i] &gt; max) {
            max = histogram[i];
        }
    }


    for (i = 1; i &lt;= max; ++i) {
        for (j = 1; j &lt;= MAX_WORD_LENGTH; ++j) {
            if (histogram[j] &gt;= max - i + 1) {
                printf(""  * "");
            } else {
                printf(""    "");
            }
        }
        printf(""\n"");
    }

    for (i = 1; i &lt;= MAX_WORD_LENGTH; ++i) {
        printf("" %2d "", i);
    }

    printf(""\n\n"");
}

int main()
{
    int c, state, word_length;
    int histogram[MAX_WORD_LENGTH + 1];

    for (int i = 0; i &lt;= MAX_WORD_LENGTH; ++i) {
        histogram[i] = 0;
    }

    word_length = 0;
    state = OUT;
    while ((c = getchar()) != EOF) {
        if (IS_WORD_SEPARATOR_CHAR(c)) {
            state = OUT;
            if (word_length != 0) {
                histogram[0]++;
            }
            histogram[word_length]++;
            word_length = 0;
        } else {
            ++word_length;
            if (state == OUT) {
                state = IN;
            }
        }
    }

    if (word_length &gt; 0) {
        histogram[word_length]++;
    }

    display_histogram(histogram, 'h');
    display_histogram(histogram, 'v');
}
</code></pre>

<p>Here's an input/output sample:</p>

<pre><code>kaldklasjdksla klsad lask dlsk aklsa lkas  ad?  kdla? kd dklask las k?lasd kas kla sd sa?d sak das?as  sad saj?ldlsak dklaa slkdals kk?l askd lsak l?sak? lsak lsak laskjl sa jkskjd aslld jslkjsak dalk sdlk jsalk askl jdsj dslk salkoihdioa slk sahoi hdaklshd alsh lcklakldjsalkd salk j  sdklald jskal dsakldaksl daslk

 1: *
 2: ***
 3: ******
 4: ***************
 5: **********
 6: ****
 7: ****
 8: ***
 9: 
10: *
11: **
12: 
13: 
14: **
15: 


              *                                             
              *                                             
              *                                             
              *                                             
              *                                             
              *   *                                         
              *   *                                         
              *   *                                         
              *   *                                         
          *   *   *                                         
          *   *   *                                         
          *   *   *   *   *                                 
      *   *   *   *   *   *   *                             
      *   *   *   *   *   *   *           *           *     
  *   *   *   *   *   *   *   *       *   *           *     
  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15 
</code></pre>
",0
54759818,54759781,4,"<p>The ways 1 and 2 are the <em>same</em> (and the correct ones). An argument of <em>array of type</em> is adjusted to an argument of type <em>pointer to type</em>, i.e. <code>int[][NUM_TWO_DIM_COLS]</code> becomes <code>int (*two_dim)[NUM_TWO_DIM_COLS]</code> after the adjustment.</p>

<hr>

<p>The way 3 is wrong. You're accessing an array out of bounds. The compiler is allowed to take into the account that the pointer points to the first element of an array of <code>NUM_TWO_DIM_COLS</code> and do bounds-checking against this bound.</p>

<p>C11 <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.5.6"" rel=""nofollow noreferrer"">Appendix J.2</a> lists this as undefined behaviour:</p>

<blockquote>
  <p>An array subscript is out of range, even if an object is apparently accessible with the given subscript (as in the lvalue expression <code>a[1][7]</code> given the declaration int <code>a[4][5]</code>) (6.5.6).</p>
</blockquote>
",8
50593868,50593647,1,"<p>The declaration <code>char *const argv[]</code> makes <code>argv</code> an array of constant pointers to <em>mutable</em> <code>char</code>s. Once you create the array, you cannot change where the pointers point (you can't say <code>argv[0] = ""/bin/some_other_program""</code>), but you can change the characters themselves (so <code>argv[1][1] = 'b'</code>, to make it so you pass <code>-b</code> instead).</p>

<p>However, the pointers you are assigning as elements of <code>argv</code> are pointers to constant <code>char</code>s. It's undefined behavior to actually do any of those assignments even if the type of <code>argv</code> will let you, hence the warning. Since you can't change the type of the function, you need to get rid of the <code>const</code>ness somehow. Options are to use <code>strdup</code>, to put the strings into <code>char[]</code> variables (which implicitly also copies them), or to cast away the <code>const</code> at this level (which is UB if the program actually modifies the values but should be safe if it does not). <a href=""https://godbolt.org/g/CgcETw"" rel=""nofollow noreferrer"">Here</a> are examples using the latter two methods.</p>
",8
50596082,50593647,0,"<p>The function in question, <code>posix_spawn</code>, expects a pointer to (the first element of) an array of pointer to non-const <code>char</code>. Despite this, the function does not modify the character strings.  </p>

<p>For historical reasons this situation of poor const-correctness in C APIs is not uncommon. </p>

<p>You can pass string literals to it without any warning in Standard C, because string literals have type: array of non-const char.  (Modifying them is undefined behaviour with no diagnostic required).</p>

<p>If you use the <code>-Wwrite-strings</code> flag to try and get warnings about potential UB then it will give you these false positives for the cases where you interact with a non-const-correct API.</p>

<hr>

<p>The intended way to consume the API in C89 would be to use:</p>

<pre><code>char exe[] = ""/usr/bin/some/exe"";

char * argv[] = {
    NULL,
    ""-a"",
    ""-b"",
    NULL
};

argv[0] = exe;
show(argv);
</code></pre>

<p>Note that in C89 it is not possible to have your array be <code>const</code> and also be initialized with the local variable <code>exe</code>. This is because C89 requires all initializers in a braced list to be <em>constant expressions</em>, the definition of which excludes the address of a local variable.</p>

<p>If you want to use <code>-Wwrite-strings</code> then you could suppress the warning by using <code>(char *)""-a""</code> instead of <code>""-a""</code> and so on.</p>

<hr>

<p>It was suggested in comments to use <code>const char *</code> for the string type and then use a cast, like so:</p>

<pre><code>const char exe[] = ""/usr/bin/some/exe"";

const char * argv[] = {
    NULL,
    ""-a"",
    ""-b"",
    NULL
};
argv[0] = exe;
show((char **)argv);
</code></pre>

<p>However this probably violates the <em>strict aliasing rule</em>.  Even though the rule allows a <code>const T</code> to be aliased as a <code>T</code>, this rule does not ""recurse"" ; it is probably not allowed to alias <code>const char *</code> as <code>char *</code> , although the rule's wording is not 100% clear.  <a href=""https://stackoverflow.com/questions/45124063/is-it-okay-for-int-and-const-int-to-alias"">See this question for further discussion</a>.</p>

<p>If you wanted to offer a wrapper that accepts <code>const char **</code> and calls <code>posix_spawn</code> , and not violate the C Standard, then you would actually have to make a copy of the pointer list into an array of <code>char *</code>.  (But you do not have to actually copy the string content)</p>
",1
50063535,50063534,2,"<p>The global variable <code>optind</code> is increased to <code>argc</code> by the end of <code>getopt_long()</code> routine so the second pass simply would not go further. In order to have the function reprocess everything from the beginning again, the global variable <code>optind</code> needed to be reset. So, add</p>

<pre><code>// Second pass: now we go through all of them.
optind = 1;
long_index = 0;
</code></pre>
",0
56106438,56105680,3,"<p>You have several problems to address, (1), you are missing the closing brace in:</p>

<pre><code>int findWord(char *word[], char *temp, int index) {
    for (int i=0; i&lt;index; i++)
    {
        if (strcmp(word[i], temp) == 0) // found the word
            return 1;
    }
    return 0; // cannot find word }
}   /* missing closing brace */
</code></pre>

<p>(2) you have a typo and are attempting to free <code>words[uniqueWordCount]</code> instead of <code>words[i]</code>, e.g.</p>

<pre><code>    for (i = 0; i&lt;uniqueWordCount; i++) /* loop over each word in words */
        free(words[i]);    /* free words[i], not words[uniqueWordCount] */
</code></pre>

<p>(<strong>note:</strong> attempting to free <code>words[uniqueWordCount]</code> generated your error as <code>uniqueWordCount</code> is one past the last allocated pointer)</p>

<p>Last, you should use <code>int main (void)</code> since neither <code>int argc</code> or <code>char **argv</code> are used.</p>
",3
52012241,4800641,0,"<p>You use the first argument to indicate the number of elements, and then, you can pass any number of elements to the function.</p>

<p>Here is a typical call:</p>

<pre><code>int i = add(5, 20, 30, 40, 50, 60);
</code></pre>

<p>There are 5 numbers to sum, so the first parameter is <strong>5</strong>. Then the rest are the 5 numbers to add up.</p>

<p>The function would then be:</p>

<pre><code>int add(int argc, ...)
{
    int result = 0;
    va_list ptr;
    va_start(ptr, argc);

    for (int i = 0; i &lt; argc; i++)
    {
        result += va_arg(ptr, int);
    }
    return result;
}
</code></pre>

<p><strong>References:</strong></p>

<p><a href=""http://www.cplusplus.com/reference/cstdarg/va_arg/"" rel=""nofollow noreferrer"">va_arg()</a></p>

<p><a href=""http://www.cplusplus.com/reference/cstdarg/va_start/?kw=va_start"" rel=""nofollow noreferrer"">va_start()</a></p>

<p><a href=""http://www.cplusplus.com/reference/cstdarg/va_list/?kw=va_list"" rel=""nofollow noreferrer"">va_list()</a></p>
",0
51800047,4367745,4,"<p>If you want to sort the values into new external variables, you can actually do the swaps without temporaries:</p>

<pre><code>void sort(int a, int b, int c, int *min, int *mid, int *max) {
    min = a;
    mid = b;
    max = c;
    if (min &gt; mid) { mid = a; min = b; }
    if (mid &gt; max)
    {
        max = mid;
        mid = c;
        if (min &gt; mid)
        {
            mid = min;
            min = c;
        }
    }
}
</code></pre>

<p>This works because the last swap test is really only needed if the second test succeeds (otherwise it will simply be a repetition of the first test, which will fail by definition since we already sorted those variables).</p>

<p>Because of this, we can track the assignments of each of the original variables and avoid swap locals.</p>
",0
59201285,5898199,0,"<p>I got a runtime error similar to this while using C++ in Visual Studio 2017.  The solution in my case was to simply clean and rebuild the solution</p>
",0
53991458,6170411,0,"<p>If you are trying to find a <a href=""https://en.wikipedia.org/wiki/Narcissistic_number"" rel=""nofollow noreferrer"">armstrong number</a> the solution you posted is missing a case where your digits are great than 3 ...armstrong numbers can be greater than 3 digits (for example 9474). Here is the code in Python, the logic is simple and it can be converted to any other language. </p>

<pre><code>def check_armstrong(number):
    num = str(number)
    total=0
    for n in range(len(num)):
        total+=sum(int(num[n]),len(num))       

    if (number == total):
        print(""we have armstrong #"",total)

def sum(input,power):
    input = input**power
    return input

check_armstrong(9474)
</code></pre>
",0
54342373,54341921,4,"<p>The approach you are trying to implement means that the programmer must know the number and type of parameters of each ""dynamically invokable"" function in advance, and this defeats the point of having such mechanism in the first place. For example, you must know that <code>comp123_work2</code> accepts a single parameter of type <code>double</code>. </p>

<p>While this violation of OOP principles might not bother you that much, in practice this means you will trade compile errors for hard-to-find runtime issues. Reading an incorrect varargs value, passed to a function through a macro, is a disaster waiting to happen. </p>

<p>There are several approaches you could take to achieve what you are doing now:</p>

<p><strong>1. Pass parameters as <code>void*</code></strong> </p>

<p>This approach doesn't give much more compile time safety, but it's far less surprising to an unsuspecting maintainer of your code.</p>

<p>A common way to deal with different parameter types in C is to simply pass your custom parameters through a <code>void</code> pointer, i.e.:</p>

<pre><code>typedef int(*voidvoidfunc_t)(void*, void*);
extern void* frm_config_get_instance(const char* name);
extern voidvoidfunc_t frm_config_get_function(const char* name);
</code></pre>

<p>And then each implementation can cast to whatever it wants:</p>

<pre><code>int printf_wrapper(void * ch, void * p)
{
    double val = *(double*)p;
    return printf(ch, val);
}

voidvoidfunc_t frm_config_get_function(const char* name)
{
    return printf_wrapper;
}
</code></pre>

<p>And you would simply call it using:</p>

<pre><code>void * parameter = frm_config_get_instance(""inside"");
voidvoidfunc_t func = frm_config_get_function(""comp123_work2"");
double val = 0.0;
int result = func(parameter, &amp;val);
</code></pre>

<p><strong>2. Variable-args function pointers</strong> </p>

<p>Also, note that it's also possible to define a variable arguments function pointer, if all your functions used varargs. Again, no compile time safety (as with any variable args function in C):</p>

<pre><code>typedef int(*varargfunc_t)(void*, ...);
extern void* frm_config_get_instance(const char* name);
extern varargfunc_t frm_config_get_function(const char* name);
</code></pre>

<p>And then:</p>

<pre><code>void * parameter = frm_config_get_instance(""inside"");
varargfunc_t func = frm_config_get_function(""comp123_work2"");
int result = func(parameter, 0.0);
</code></pre>

<p>But then all your ""worker"" functions will have to ""unpack"" args each time, something like:</p>

<pre><code>int printf_wrapper(void * ch, ...)
{
    va_list va;
    va_start(va, ch);
    int ret = vfprintf(stdout, ch, va);
    va_end(va);
    return ret;
}

varargfunc_t frm_config_get_function(const char* name)
{
    return printf_wrapper;
}
</code></pre>

<p><strong>3. Having a separate function for each parameter type</strong></p>

<p>If you don't have that many parameters, a way to achieve compile-time type safety would be using separate functions for each param type, i.e.:</p>

<pre><code>typedef int(*intfunc_t)(void*, int);
typedef int(*floatfunc_t)(void*, float);
typedef int(*stringfunc_t)(void*, const char*);
</code></pre>

<p>Then you are safe from interpreting the args in a wrong way:</p>

<pre><code>int printf_wrapper(void * ch, float val)
{
    return printf(ch, val);
}

floatfunc_t frm_config_get_float_function(const char* name)
{
    return printf_wrapper;
}
</code></pre>

<p>Which means you have a strongly typed fn pointer after the call to <code>frm_config_get_xxxxx_function</code>:</p>

<pre><code>void * parameter = frm_config_get_instance(""inside"");
floatfunc_t func = frm_config_get_float_function(""comp123_work2"");
int result = func(parameter, 0.0f);
</code></pre>

<p><strong>4. Using a variant union type like <code>GValue</code> in GLib</strong></p>

<p>This is perhaps slighly less common and doesn't provide full type safety, but it at least provides metadata which can help you throw an error in case of an incorrect invocation. The idea is to have a union of several values with a value type, so that your function can check if the parameter matches its expectation.</p>

<pre><code>int printf_wrapper(void * ch, GValue *val)
{
    // this checks that the parameter has the correct type
    if (!G_VALUE_HOLDS_FLOAT(val))
        error();

    float f = g_value_get_float(val);
    return printf(ch, f);
}

typedef int(*gvalue_func_t)(void*, GValue *val);
extern void* frm_config_get_instance(const char* name);
extern gvalue_func_t frm_config_get_function(const char* name);
</code></pre>

<p>And then you construct the <code>GValue</code> object at run time:</p>

<pre><code>void * parameter = frm_config_get_instance(""inside"");
gvalue_func_t func = frm_config_get_function(""comp123_work2"");

GValue val = G_VALUE_INIT;
g_value_set_float(&amp;val, 0.0f);
func(parameter, &amp;val);
</code></pre>
",5
54342070,54341921,4,"<p>What you are about to do will probably not work. But you can create a ""light"" version of it:</p>

<pre><code>#define FRM_CONFIG_FUNC(function, ...) \
  ((int(*)(void*, __VA_ARGS__))frm_config_get_function(function))

#define FRM_CONFIG_CALL(func, instance, ...) \
  (func)(frm_config_get_instance(instance), __VA_ARGS__)
</code></pre>

<p>and use it like</p>

<pre><code>res = FRM_CONFIG_CALL(FRM_CONFIG_FUNC(""comp123_work2"", double), ""inside"", 0.0)
</code></pre>

<p>Disclaimer: I haven't tested it, but it might give you the idea.</p>
",1
58073124,58073059,1,"<p>There are multiple ways of doing this. I prefer the following:</p>

<pre><code>/*
 * Makes an image and returns the length
 * returns &lt; 0 on error
 *
 * Call as follows:
 *  char *image ;
 *  int len = make_image( &amp;image );
 *  if (len &lt; 0) { /* Process error code */ }
*/
int makeImage(void **image) {
    unsigned char *_image ;
    int length ;
    /* Create image and set the length of buffer in length variable */
    /* Return the image */
    *image = _image ;
    return length;
}
</code></pre>

<p>If you do not need multiple error codes, setting image parameter to null and checking for it may be enough.</p>
",8
55746138,55745278,3,"<p>I'd drop the switch for a look-up table. Regarding numbers having to be parsed with % operator ""backwards"" from ls digit and up, simply store them digit by digit in a separate temporary array to easily re-order them.</p>

<pre><code>void stringify (unsigned int n)
{
  const char* LOOKUP_TABLE [10] =
  {
    ""zero"", ""one"", ""two"", ""three"", ""four"", 
    ""five"", ""six"", ""seven"", ""eight"", ""nine"",
  };

  if(n == 0)
  {
    puts(LOOKUP_TABLE[0]);
    return ;
  }

  int numbers[10]={0}; // assuming UINT_MAX = 4.29 billion = 10 digits

  for(int i=0; i&lt;10; i++)
  {
    numbers[10-i-1] = n%10;
    n/=10;
  }

  bool remove_zeroes = true;
  for(int i=0; i&lt;10; i++)
  {
    if(!remove_zeroes || numbers[i]!=0)
    {
      remove_zeroes = false;
      printf(""%s "", LOOKUP_TABLE[numbers[i]]);
    }
  }
}
</code></pre>
",1
55745815,55745278,2,"<p>Out of your problem a typo in your code : <code>input = input;</code> must be <code>input = -input;</code></p>

<p>It is easier to work on the number as a string, example :</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
  printf(""Insert a number:\n "");

  char s[32];

  if (fscanf(stdin, ""%31s"", s) != 1) {
    return -1;
  }

  char * p = s;

  if (*p == '-') {
    printf(""negative "");
    p += 1;
  }

  for (;;) {
    switch (*p++) {
    case 0:
    case '\n':
      if ((*s == '-') &amp;&amp; (p == (s+2))) {
        puts(""missing number"");
        return -1;
      }
      putchar('\n');
      return 0;
    case '0':
      printf(""zero "");
      break;
    case '1':
      printf(""one "");
      break;
    case '2':
      printf(""two "");
      break;
    case '3':
      printf(""three "");
      break;
    case '4':
      printf(""four "");
      break;
    case '5':
      printf(""five "");
      break;
    case '6':
      printf(""six "");
      break;
    case '7':
      printf(""seven "");
      break;
    case '8':
      printf(""eight "");
      break;
    case '9':
      printf(""nine "");
      break;
    default:
      puts("" invalid number"");
      return -1;
    }
  }
}
</code></pre>

<p>Compilation and executions :</p>

<pre><code>/tmp % gcc -pedantic -Wall -Wextra n.c
vxl15036 /tmp % ./a.out
Insert a number:
 0
zero 
vxl15036 /tmp % ./a.out
Insert a number:
 -1
negative one 
vxl15036 /tmp % ./a.out
Insert a number:
 12305
one two three zero five 
vxl15036 /tmp % ./a.out
Insert a number:
 007
zero zero seven 
vxl15036 /tmp % ./a.out
Insert a number:
 -
negative missing number
vxl15036 /tmp % ./a.out
Insert a number:
 a
 invalid number
</code></pre>

<p>As you see the number is rewritten as it was enter, 0 at left are not removed and -0 is <em>negative zero</em></p>

<hr>

<p>It can be fun to write <em>one thousand two hundred thirty four</em> for 1234 ;-)</p>
",0
56104848,56104825,2,"<p>You have an error here:</p>

<pre><code>str[strlen (str - 1)] = '\0';   // the last character is the newline. replace with null
</code></pre>

<p>Using the pointer <code>str - 1</code> leads to undefined behavior, as it points to memory outside the original string.</p>

<p>You actually meant to do this:  <code>strlen(str) - 1</code>  (notice the <code>-1</code> is moved outside the parentheses)</p>
",1
56106755,56104968,1,"<p>Your code works. Just press ctrl-d right after enter (signals end of input) to exit.</p>

<p>Couple of other things:</p>

<ul>
<li><code>fgets()</code> doesn't need size minus 1. per the manual: ""<code>fgets()</code> reads in at most one less than size characters...""</li>
<li>there is really no need to copy/reverse the entire string and compare, half will suffice, OR you could simply compare beginning with end until center, without copying.</li>
<li><code>strlen()</code> ""walks"" the string - you can reuse the result of it instead of calling again.</li>
</ul>

<p>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAXLEN 100

int isPalindrome(char *str, size_t len) {
    char *end = str + len - 1;
    while (end &gt; str)
        if (*end-- != *str++) return 0;
    return 1;
}

int main(int argc, char **argv) {
    char str[MAXLEN];
    while (fgets(str, sizeof(str), stdin) != NULL) {
        size_t len = strlen(str) - 1;
        str[len] = 0; // the last character is the newline. Replace with null char
        printf(""%s is %sa palindrome\n"", str, isPalindrome(str, len) ? """" : ""not "");
    }
    return 0;
}
</code></pre>
",0
57266627,57265887,0,"<blockquote>
  <p><em>...is there any way where i don't have to charge original string as well, like if i do trim(string) it will print trimmed string and when i print only string, it will print original string</em> ¨C <a href=""https://stackoverflow.com/questions/57265887/trim-function-in-c#comment101031076_57266142"">avinashse 8 mins ago</a></p>
</blockquote>

<p>Yes, though it gets silly.</p>

<p>You could modify the original string.</p>

<pre><code>trim(string);
printf(""trimmed: %s\n"", string);
</code></pre>

<p>The advantage is you have the option of duplicating the string if you want to retain the original.</p>

<pre><code>char *original = strdup(string);
trim(string);
printf(""trimmed: %s\n"", string);
</code></pre>

<p>If you don't want to modify the original string, that means you need to allocate memory for the modified string. That memory then must be freed. That means a new variable to hold the pointer so you can free it.</p>

<pre><code>char *trimmed = trim(original);
printf(""trimmed: %s\n"", trimmed);
free(trimmed);
</code></pre>

<p>You can get around this by passing a function pointer into <code>trim</code> and having <code>trim</code> manage all the memory for you.</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

void trim(char *string, void(*func)(char *) )
{
    // Advance the pointer to the first non-space char
    while( *string == ' ' ) {
        string++;
    }

    // Shrink the length to the last non-space char.
    size_t len = strlen(string);
    while(string[len-1]==' ') {
        len--;
    }

    // Copy the string to stack memory
    char trimmedStr[len + 1];
    strncpy(trimmedStr,string, len);

    // strncpy does not add a null byte, add it ourselves.
    trimmedStr[len] = '\0';

    // pass the trimmed string into the user function.
    func(trimmedStr);
}

void print_string(char *str) {
    printf(""'%s'\n"", str);
}

int main()
{
    char string[]=""         a sdf ie    "";
    trim(string, print_string);
    printf(""original: '%s'\n"", string);
    return 0;
}
</code></pre>

<p>Ta da! One variable, the original is left unmodified, no memory leaks.</p>

<p>While function pointers have their uses, this is a bit silly.</p>

<p>It's C. Get used to managing memory. ¡¥\_(¥Ä)_/¡¥</p>
",1
57266142,57265887,0,"<p>You could the original string in order to do this. For trimming the prefix I just advance the pointer, and for the suffix, I actually add <code>\0</code>. If you want to keep the original starting as is, you will have to move memory (which makes this an O(n^2) time complexity solution, from an O(n) I provided).</p>

<pre><code>#include &lt;stdio.h&gt;

char *trim(char *string)
{
    // trim prefix
    while ((*string) == ' ' ) {
         string ++;
    }

    // find end of original string
    char *c = string;
    while (*c) {
         c ++;
    }
    c--;

    // trim suffix
    while ((*c) == ' ' ) {
        *c = '\0';
        c--;
    }
    return string;
}

int main()
{
    char string1[] = ""       abcdefg abcdf   "";
    char *string = trim(string1);
    printf(""String is [%s]\n"",string);
    return 0;
}
</code></pre>

<p>(re-thinking... is it really O(n^2)? Or is it O(2n) which is a higher O(n)...? I guess depending on implementation)</p>
",2
53158454,53158112,1,"<p>Try shifting the bits the other way:</p>

<pre><code>uint16_t crc16_CCITT (unsigned char *ptr, int count)
{
   uint16_t crc = 0xffff;
   int i = 0;

   while (--count &gt;= 0)
   {
      crc = crc ^ (uint16_t )*ptr++ &lt;&lt; 8;
      for (i = 0; i &lt; 8; ++i)
      {
         if (crc &amp; 0x8000)
         {
            crc = (crc &lt;&lt; 1) ^ 0x1021;
         }
         else
         {
            crc = crc &lt;&lt; 1;
         }
      }
   }
   return crc;
}
</code></pre>
",5
59291273,13579801,1,"<pre><code>int i = 1;
int j = 0;
int k = 1;
if(i, j, k) {
   printf(""Inside"");
}else {
   printf(""Outside"");
}
</code></pre>

<p>Correction to above: This code will print ""Inside"" as the comma operator is evaluated from left to right and k is the last expression evaluated in the if statement, which returns true since k = 1.</p>
",0
54432581,54432523,8,"<p>An octal escape sequence is <code>\</code> followed by one to three octal digits, per C 2018 6.4.4.4 1. Per 6.4.4.4 7: ¡°Each octal or hexadecimal escape sequence is the longest sequence of characters that can constitute the escape sequence.¡± So, when the compiler sees <code>""\012\0345""</code>, it interprets it as the sequence <code>\012</code> (which is ten), the sequence <code>\034</code> (which is twenty-eight), and the character <code>5</code>.</p>

<p>To represent the string you intended, you could use <code>""\00012\000345""</code>. Since an octal escape sequence stops at three digits, this is interpreted as the sequence <code>\000</code>, the characters <code>1</code> and <code>2</code>, the sequence <code>\000</code>, and the characters <code>3</code>, <code>4</code>, and <code>5</code>. (A null terminating character will also be appended automatically.)</p>

<p>When you printed <code>""\012\0345""</code>, the characters with codes ten and twenty-eight were printed but had no visible effect. (Your C implementation likely uses ASCII, in which case they are control characters. <code>\012</code> is new-line, so it should have caused a line advance, but you probably did not notice that. <code>\034</code> is a file-separator control character, which likely has no effect when printed to a regular terminal display.)</p>

<p>When you printed <code>testArr</code>, the null character in the first position ended the string.</p>
",0
54391943,54391480,2,"<p>Functions can certainly return <code>void *</code>.  But that is a specific pointer type with properties that make it suitable for conveying pointers to objects of any type.  It is <strong><em>not</em></strong> a general-purpose wildcard type.  Moreover, it does not carry any kind of information about the actual type, if any, of the object to which it points, so there is no way to determine that type dynamically.  A C++ programmer might describe this situation as C not providing any RTTI.</p>

<p>Instead, you can return a type that can convey objects of a variety of types, known in advance, with a mechanism to discriminate among those.  For example,</p>

<pre><code>union num_or_string {
    struct { _Bool is_num; };
    struct { _Bool _x1; int num; };
    struct { _Bool _x2; char *string; };
};

union num_or_string NumOrChar(void) {
    // return a union num_or_string containing an int or a char *
}

void printResult (union num_or_string) {
    if (num_or_string.is_num) {
        printf(""It's a number: %d\n"", num_or_string.num);
    } else {
        printf(""It's a string: %s\n"", num_or_string.string);
    }
}
</code></pre>
",1
53465557,53465543,3,"<p>Both your array declarations are in fact <a href=""https://en.cppreference.com/w/c/language/array#Variable-length_arrays"" rel=""nofollow noreferrer"">variable length array</a> declarations. <code>COUNT</code> is not a constant expression in C, despite being <code>const</code>.</p>

<p>But regardless, the bigger size simply exceeds your implementation's limits, overflowing the call stack where those locals are usually allocated. Though I suspect this behavior will go away should you compile with optimizations. A compiler can easily deduce that <code>nums</code> isn't used in your snippet, and remove it entirely.</p>
",7
54273249,54273130,2,"<p>Consider the message ¡°'node (node,char,int)' differs in levels of indirection from 'int ()'¡±. In this message, the <code>int ()</code> is the type one gets non-C-standard compilers from the default declaration that is provided when you do not declare a function. That is, when you use <code>AddNode</code> before its declaration, it is automatically declared as <code>int AddNode()</code>.</p>

<p>Then, later in your code when your declaration of <code>AddNode</code> appears, your declaration contrasts with the default declaration, and the compiler prints this message.</p>

<p>To fix this, put a declaration of <code>AddNode</code> before you use it. Such a declaration must appear in each source file where it is used. (Actually, the declaration must appear in the C <em>translation unit</em>, which means all the files that are included when you compile a source file. The translation unit includes header files that are included with <code>#include</code>. You must have a declaration of <code>AddNode</code> either in the source file itself or in a file it includes.)</p>

<p>Additionally, you declare <code>AddNode</code> as <code>node AddNode(node head, char name, int size);</code> but pass <code>""Test Name""</code> for the second parameter. As a function argument, <code>""Test Name""</code> acts as <code>char *</code>, not <code>char</code>, so you probably want to change the declaration to <code>node AddNode(node head, char *name, int size);</code>.</p>
",0
49122212,7190796,0,"<pre><code>ret_val = ioctl(sock_id, SIOCETHTOOL, &amp;ir);
</code></pre>

<p>You're <em>halfway</em> there, at least. You appear to recognise the fact that the <code>ioctl</code> may fail but you don't carry through and actually <em>check</em> the return value.</p>

<p>Given that your text indicates the value is <em>always</em> wrong ("" 57872 or some junk value or 0 always""), I'd say it's a safe bet that you're getting back a consistent error code, such as <code>EOPNOTSUPP</code>.</p>

<p>Modify the code to check that <em>first,</em> then run it again.</p>
",0
50772452,22591383,0,"<p>I added a field to the struct</p>

<pre><code>struct node {
  void * data;
  node * next;
  char * translation;
}
</code></pre>
",0
50345176,50345045,8,"<p>This is probably just for readibility. <code>&amp;(statement-&gt;row_to_insert.id)</code> is equivalent to <code>&amp;statement-&gt;row_to_insert.id</code> due to operator precedence in C operators <code>-&gt;</code> and <code>.</code> have higher precedence than <code>&amp;</code>. You can read more <a href=""http://en.cppreference.com/w/c/language/operator_precedence"" rel=""noreferrer"">here</a>.</p>
",3
57994971,57994788,5,"<p>Padding is typically based on the <strong>base type</strong> of each of its members.</p>

<p>The member <code>state</code> is an array of <code>uint16_t</code>, so this field is aligned on a 2 byte boundary even though the entire array is 4 bytes.  What's important is that each member of the array is correctly aligned.  So there is 1 byte of padding after <code>zip</code> to align <code>state</code> and <code>state</code> starts at offset 2.</p>

<p>After that the next available offset is 6 so two more padding bytes are needed for <code>country</code> to be aligned on a 4 byte boundary.  So then the offset of <code>country</code> is 8.</p>

<p>So now the structure looks like this:</p>

<pre><code>typedef struct
{
    uint8_t zip;         // offset 0
    // 1 byte padding
    uint16_t state[2];   // offset 2
    // 2 bytes padding
    uint32_t country;    // offset 8
} address;
</code></pre>

<p>For more details on how padding is usually implemented, see <a href=""http://www.catb.org/esr/structure-packing/"" rel=""noreferrer"">this guide</a>.</p>
",0
55859377,55858897,1,"<p>There is no need for separate arrays unless you want to access them separately by name:</p>

<pre><code>#if defined build_option
    #define MyPrefix "".""
#else
    #define MyPrefix
#endif

const char *strs[] =
{
    MyPrefix ""some/path"",
    MyPrefix ""another/path"",
    MyPrefix ""and/a/third/path"",
};
</code></pre>

<p>Adjacent string literals are concatenated after preprocessing and before main compilation (semantic analysis and translation).</p>

<p>Here is a solution that defines both the original and modified strings:</p>

<pre><code>#define DefineMyStrings(name, prefix) \
    char *name[] =                    \
    {                                 \
        prefix ""some/path"",         \
        prefix ""another/path"",      \
        prefix ""and/a/third/path"",  \
    };

DefineMyStrings(original,)
DefineMyStrings(prefixed, ""."")


#include &lt;stdio.h&gt;


#define NumberOf(a) (sizeof (a) / sizeof *(a))

int main(void)
{
    for (int i = 0; i &lt; NumberOf(original); ++i)
        printf(""original[%d] = %s.\n"", i, original[i]);

    for (int i = 0; i &lt; NumberOf(prefixed); ++i)
        printf(""prefixed[%d] = %s.\n"", i, prefixed[i]);
}
</code></pre>
",3
55859555,55858897,1,"<p>Here is a possible static solution</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

static char *strsrc[] = {
        ""some/path"",
        ""another/path"",
        ""and/a/third/path"",
};
static char strdst[3][BUFSIZ];

int main(void)
{
        for (int i = 0; i &lt; 3; i++) {
                strncpy(&amp;strdst[i][1], strsrc[i], BUFSIZ); 
                strdst[i][0] = '.';
                puts(strdst[i]);
        }
        return 0;
}
</code></pre>

<p>I just copied the string to the destination offeseted and then overwrite the first character. Constants are already null terminated so no need to '\0' them.</p>

<p>Regards,</p>
",0
55859289,55858897,1,"<p>You can do it at compile time without modifying the content of the strings, but take note that this method only works if the characters you want to replace are at the end or the beginning of a string literal.</p>

<pre><code>#ifdef build_option
  #define TK1 "".""
#else
  #define TK1 """"
#endif

void main(void) {
  const char  str1[] = TK1""some/path"";
  const char  str2[] = TK1""another/path"";
  const char  str3[] = TK1""and/a/third/path"";
  const char* strs[3];
  strs[0] = str1;
  strs[1] = str2;
  strs[2] = str3;
 }
</code></pre>
",7
55859417,55858897,2,"<p>Compile time solution:</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdio.h&gt;

#ifdef build_option
  #define PATH(str) "".""str
#else
  #define PATH(str) str
#endif

const char  str1[] = PATH(""some/path"");
const char  str2[] = PATH(""another/path"");
const char  str3[] = PATH(""and/a/third/path"");
const char* strs[3] = { str1, str2, str3 };

int main()
{
  for(int i = 0; i &lt; 3; ++i)
  {
    printf(""%s\n"", strs[i]);
  }
  return 0;
}
</code></pre>

<p>How does it work? Well, you just have to know that you can naturally concatenate string literals. Either google it or have a look at <a href=""https://stackoverflow.com/questions/12120944/how-does-concatenation-of-two-string-literals-work"">this stackoverflow thread</a>. The rest is normal macro stuff. No runtime disadvantage, no memory allocation, no copying.</p>
",1
55859137,55858897,1,"<p>Use <code>malloc()</code> to allocate new strings and copy from the literals to them.</p>

<pre><code>const char* strs[] = {""some/path"", ""another/path"", ""and/a/third/path""};
const int numstrs = sizeof strs / sizeof strs[0];
char *newstrs[numstrs];
for (int i = 0; i &lt; numstrs; i++) {
    newstrs[i] = malloc(strlen(strs[i] + 2)); // +2 for added prefix and null byte
    newstrs[i][0] = '.';
    strcpy(&amp;newstrs[i][1], strs[i]);
}
</code></pre>
",0
58001801,58001686,3,"<p>You created a shared object, but you are not creating an executable to use it. Since the executable is not using it, the referenced symbol is not found.</p>

<p>Remove the extraneous <code>-L</code> option, and specify the shared object when linking.</p>

<pre><code>gcc hello.c -o hello ./my_malloc.so
</code></pre>
",0
58193435,8453046,3,"<p>If you are using Linux, since Kernel 3.15 you can use</p>

<pre><code>#include &lt;fcntl.h&gt;

int fallocate(int fd, int mode, off_t offset, off_t len);
</code></pre>

<p>with the <code>FALLOC_FL_COLLAPSE_RANGE</code>  flag.</p>

<p><a href=""http://manpages.ubuntu.com/manpages/disco/en/man2/fallocate.2.html"" rel=""nofollow noreferrer"">http://manpages.ubuntu.com/manpages/disco/en/man2/fallocate.2.html</a></p>

<p>Note that not all file systems support it but most modern ones such as ext4 and xfs do.</p>
",0
53290359,53290205,2,"<p>Each of the shift terms except the first is evaluated as an <code>int</code>; the first is evaluated as a <code>uint32_t</code> which is probably an <code>unsigned int</code>.  These results are then or'd together in a <code>uint32_t</code>, and then assigned to your 64-bit result.</p>

<p>You need at least the first shift performed as a 64-bit calculation:</p>

<pre><code>*ptr = (uint64_t)val1 &lt;&lt; 32 | val2 &lt;&lt; 24 | val3 &lt;&lt; 16 | val4;
</code></pre>

<p>This can shift by 32 (as required, instead of 31 as before) because the shift is smaller than the size of the operand (<code>uint64_t</code>).  Previously, you couldn't use 32 because you'd be told the shift is too big.</p>

<p>You might prefer the symmetry of:</p>

<pre><code>*ptr = (uint64_t)val1 &lt;&lt; 32 | (uint64_t)val2 &lt;&lt; 24 | (uint64_t)val3 &lt;&lt; 16 | (uint64_t)val4;
</code></pre>

<p>Your printing is also faulty.  You should be using the macros from <code>&lt;inttypes.h&gt;</code> to specify the format for the <code>uint64_t</code> value:</p>

<pre><code>printf(""%p  0x%"" PRIx64 ""\n"", ptr, *ptr);
</code></pre>

<p>Note that if you used <code>unsigned long long *ptr</code> etc, you'd use <code>0x%llx</code>.</p>

<p>The use of <code>final_val</code> is also dubious at best; it could crash on some machine types if <code>final_val</code> is not appropriately aligned for a 64-bit type (not aligned on a 64-bit boundary).  In the code shown, you should simply use a <code>uint64_t</code> variable to be the target of the pointer (since the code shown doesn't use <code>final_val</code> otherwise).  If you did need to use the array of <code>uint8_t</code> values for some reason, then there are better ways to load the data.  You'd get different results on little-endian vs big-endian machines, too.</p>
",1
54770305,54769246,7,"<p>Per <em>6.5.2.2 Function Calls</em>, ? 7:</p>

<blockquote>
  <p>If the expression that denotes the called function has a type that does include a prototype, the arguments are implicitly converted, as if by assignment, to the types of the corresponding parameters, taking the type of each parameter to be the unqualified version of its declared type</p>
</blockquote>

<p>The relevant text in <em>6.5.16.1 Simple Assignment</em> is:</p>

<blockquote>
  <p>Constraints</p>
  
  <p>One of the following shall hold:</p>
  
  <ul>
  <li>the left operand has atomic, qualified, or unqualified arithmetic type, and the right has arithmetic type;</li>
  <li>the left operand has an atomic, qualified, or unqualified version of a structure or union type compatible with the type of the right;</li>
  <li>the left operand has atomic, qualified, or unqualified pointer type, and (considering the type the left operand would have after lvalue conversion) both operands are pointers to qualified or unqualified versions of compatible types, and the type pointed to by the left has all the qualifiers of the type pointed to by the right;</li>
  <li>the left operand has atomic, qualified, or unqualified pointer type, and (considering the type the left operand would have after lvalue conversion) one operand is a pointer to an object type, and the other is a pointer to a qualified or unqualified version of void, and the type pointed to by the left has all the qualifiers of the type pointed to by the right;</li>
  <li>the left operand is an atomic, qualified, or unqualified pointer, and the right is a null pointer constant; or</li>
  <li>the left operand has type atomic, qualified, or unqualified _Bool, and the right is a pointer.</li>
  </ul>
</blockquote>

<p>None of these allow the left operand as a pointer and the right operand as an integer. Thus, such an assignment (and by the first quoted text above, the function call) is a <strong>constraint violation</strong>. This means the compiler is required by the standard to ""diagnose"" it. However it's up to the compiler what it does beyond that. Yes, an error would be highly preferable, but just printing a warning is a low-quality way to satisfy the requirement to ""diagnose"" constraint violations like this.</p>
",5
48418960,48418785,0,"<p>No there is no feature like destructors or try-catch blocks in C. You just simply need to check the function return values and clean up resources.</p>

<p>Often C programmers use <em>infamous</em> <code>goto</code> statement to jump to the cleanup code.</p>

<pre><code>void foo()
{
    if (!doA())
        goto exit;
    if (!doB())
        goto cleanupA;
    if (!doC())
        goto cleanupB;

    /* everything has succeeded */
    return;

cleanupB:
    undoB();
cleanupA:
    undoA();
exit:
    return;
}
</code></pre>

<p>Example copied from <a href=""https://stackoverflow.com/a/245761/450989"">https://stackoverflow.com/a/245761/450989</a></p>
",5
52463548,14761015,1,"<p>Because <strong>memset</strong> works on byte and set every byte to 1.<br/> </p>

<pre><code>memset(hash, 1, cnt);
</code></pre>

<p>So once read, the value it will show <strong>16843009 = 0x01010101 = 1000000010000000100000001</strong><br/>
Not <strong>0x00000001</strong><br/>
But if your requiremnt is only for bool or binary value then we can set using C99 standard for C library</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdbool.h&gt;        //Use C99 standard for C language which supports bool variables

int main()
{
    int i, cnt = 5;
    bool *hash = NULL;
    hash = malloc(cnt);

    memset(hash, 1, cnt);
    printf(""Hello, World!\n"");

    for(i=0; i&lt;cnt; i++)
        printf(""%d "", hash[i]);

    return 0;
}
</code></pre>

<p><strong>Output:</strong><br/></p>

<p>Hello, World!<br>
1 1 1 1 1 </p>
",0
53849073,7316862,1,"<p>For anyone coming to this question but not restricted to C89  (technically C11 is also ANSI C because ANSI has ratified it):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

#define ISSIGNED(x) _Generic((x), \
    unsigned char: 0,       \
    unsigned short: 0,      \
    unsigned int: 0,        \
    unsigned long: 0,       \
    unsigned long long: 0,  \
    signed char: 1,         \
    signed short: 1,        \
    signed int: 1,          \
    signed long: 1,         \
    signed long long: 1,    \
    char: (CHAR_MIN &lt; 0)    \
)

int main()
{
    char x;
    printf(""%d\n"", ISSIGNED(x));
}
</code></pre>
",0
49196125,49196057,1,"<p>Well, in essence ""no"" since it comes down to the particular register layout of the sensor in question. These are, as far as I know, never self-describing so you're going to have to statically ""know"" in the software end what is available and where.</p>

<p>Of course what you can do if you're desperate is to invent (or find) a DSL that is better at describing arbitrary bit fields than C, and describe the register set in that. Then use code generation techniques to make the required C code, thus moving the part that needs to be updated into a more suitable language (at the cost of more actual software <em>complexity</em>, of course).</p>
",1
50379855,50379663,14,"<p>Both <code>stdio.h</code> and <code>stdlib.h</code> are, in fact, required to define <code>NULL</code>, <a href=""https://web.archive.org/web/20151125170555/http://flash-gordon.me.uk/ansi.c.txt"" rel=""noreferrer"">all the way back to the original ANSI C standard in 1989</a><sup>1</sup> (unfortunately this is a .txt file, so I can't link to a specific section; search for <code>4.9 INPUT/OUTPUT &lt;stdio.h&gt;</code> and/or <code>4.10 GENERAL UTILITIES &lt;stdlib.h&gt;</code>, and then scroll down a little).  If either of the minimized test programs</p>

<pre><code>#include &lt;stdio.h&gt;
void *p = NULL;
</code></pre>

<p>or</p>

<pre><code>#include &lt;stdlib.h&gt;
void *p = NULL;
</code></pre>

<p>fails to compile to an object file, then your C implementation is buggy.  (If  the above test programs do <em>not</em> fail to compile, you're gonna need to do some <a href=""https://blog.regehr.org/archives/527"" rel=""noreferrer"">delta-minimization</a> on your actual program, and probably then track down your wiseacre cow-orker who thought it would be funny to put <code>#undef NULL</code> in an application header file.)</p>

<p>NULL is also required to be defined in several other standard headers, but its <em>true</em> home, as you may guess from the cross-references to section 4.1.5 to explain what NULL is supposed to be defined <em>to</em>, is <code>stddef.h</code>.  A C implementation that fails to define <code>NULL</code> in <code>stddef.h</code> is <em>egregiously</em> buggy.  Also, <code>stddef.h</code> is one of the very few headers that is required to be provided by a ""freestanding implementation""; if you are working in an embedded environment, it's possible that they thought they could get away with leaving NULL out of <code>stdio.h</code> or <code>stdlib.h</code>, but they have no excuse whatsoever for leaving it out of <code>stddef.h</code>.</p>

<p>In the alternative, just use <code>0</code> for the null pointer constant.  That's perfectly fine style as long as all your functions have prototypes.  (You have to cast it to pass it correctly to a function that takes a variable number of arguments, e.g. to <code>execl</code>, but you have to cast <em>NULL</em> to pass it correctly to a function that takes a variable number of arguments, so it comes out in the wash.)</p>

<hr>

<p><sup>1</sup> Footnote for historians: yes, the linked document really is the <em>ANSI</em> C standard, not the ISO standard with nigh-identical wording (but very different section numbering) that came out a year later.  I am not aware of any copy of the 1990 edition of the ISO C standard that is available online at no charge.</p>
",3
53452126,53444743,-4,"<p>Let's try for something with zero curly braces:</p>

<pre><code>int result;
result =                   Do1() ? 1 : 0;
result = result ? result : Do2() ? 2 : 0;
result = result ? result : Do3() ? 3 : 0;
result = result ? result : Do4() ? 4 : 0;
result = result ? result : Do5() ? 5 : 0;

result &gt; 4 ? (Undo5(),0) : 0;
result &gt; 3 ? Undo4() : 0;
result &gt; 2 ? Undo3() : 0;
result &gt; 1 ? Undo2() : 0;
result &gt; 0 ? Undo1() : 0;

result ? printf(""Failed %d\r\n"", result) : 0;
</code></pre>

<p>Yes. <code>0;</code> is a valid statement in C (and C++). In the case that some of the functions return something that is incompatible with this syntax (e.g. void perhaps) then the Undo5() style can be used.</p>
",5
53451690,53444743,2,"<p>Yes, as explained by other answers, using <code>goto</code> for error-handling is often appropriate in C.</p>
<p>That said, if possible, you probably should make your cleanup code safe to call even if the corresponding action was never performed.  For example, instead of:</p>
<pre><code>void foo()
{
    int result;
    int* p = malloc(...);
    if (p == NULL) { result = 1; goto err1; }
   
    int* p2 = malloc(...);
    if (p2 == NULL) { result = 2; goto err2; }

    int* p3 = malloc(...);
    if (p3 == NULL) { result = 3; goto err3; }

    // Do something with p, p2, and p3.
    bar(p, p2, p3);

    // Maybe bar() saved references to p and p2, but we don't need
    // p3 anymore.
    free(p3);    

    return 0;

err3:    
    free(p2);
err2:
    free(p);
err1:
    return result;
}
</code></pre>
<p>I'd advocate:</p>
<pre><code>void foo()
{
    int result = -1; // Or some generic error code for unknown errors.

    int* p = NULL;
    int* p2 = NULL;
    int* p3 = NULL;

    p = malloc(...);
    if (p == NULL) { result = 1; goto exit; }
   
    p2 = malloc(...);
    if (p2 == NULL) { result = 2; goto exit; }

    p3 = malloc(...);
    if (p3 == NULL) { result = 3; goto exit; }

    // Do something with p, p2, and p3.
    bar(p, p2, p3);

    // Set success *only* on the successful path.
    result = 0;

exit:
    // free(NULL) is a no-op, so this is safe even if p3 was never allocated.
    free(p3);

    if (result != 0)
    {
        free(p2);
        free(p);
    }
    return result;
}
</code></pre>
<p>It's <em>slightly</em> less efficient since it requires initializing variables to <code>NULL</code>, but it's more maintainable since you don't need extra labels.  There's less stuff to get wrong when making changes to the code.  Also, if there's cleanup code that you need on both success <em>and</em> failure paths, you can avoid code duplication.</p>
",9
53448955,53444743,-1,"<p><strong>TL;DR:</strong></p>

<p>I believe it should be written as:</p>

<pre><code>int main (void)
{
  int result = do_func();
  printf(""Failed %d\n"", result);
}
</code></pre>

<hr>

<p><strong>Detailed explanation:</strong></p>

<p>If nothing can be assumed what-so-ever about the function types, we can't easily use an array of function pointers, which would otherwise be the correct answer. </p>

<p>Assuming all function types are incompatible, then we would have to wrap in the original obscure design containing all those non-compatible functions, inside something else.</p>

<p>We should make something that is readable, maintainable, fast. We should avoid tight coupling, so that the undo behavior of ""Do_x"" doesn't depend on the undo behavior of ""Do_y"".</p>

<pre><code>int main (void)
{
  int result = do_func();
  printf(""Failed %d\n"", result);
}
</code></pre>

<p>Where <code>do_func</code> is the function doing all the calls required by the algorithm, and the <code>printf</code> is the UI output, separated from the algorithm logic.</p>

<p><code>do_func</code> would be implemented like a wrapper function around the actual function calls, handling the outcome depending on the result:</p>

<p>(With gcc -O3, <code>do_func</code> is inlined in the caller, so there is no overhead for having 2 separate functions)</p>

<pre><code>int do_it (void)
{
  if(Do1()) { return 1; };
  if(Do2()) { return 2; };
  if(Do3()) { return 3; };
  if(Do4()) { return 4; };
  if(Do5()) { return 5; };
  return 0;
}

int do_func (void)
{
  int result = do_it();
  if(result != 0)
  {
    undo[result-1]();
  }
  return result;
}
</code></pre>

<p>Here the specific behavior is controlled by the array <code>undo</code>, which is a wrapper around the various non-compatible functions. Which functions to to call, in which order, is all part of the specific behavior tied to each result code. </p>

<p>We need to tidy it all up, so that we can couple a certain behavior to a certain result code. Then when needed, we only change the code in one single place if the behavior should be changed during maintenance:</p>

<pre><code>void Undo_stuff1 (void) { }
void Undo_stuff2 (void) { Undo1(); }
void Undo_stuff3 (void) { Undo2(); Undo1(); }
void Undo_stuff4 (void) { Undo3(); Undo2(); Undo1(); }
void Undo_stuff5 (void) { Undo4(); Undo3(); Undo2(); Undo1(); }

typedef void Undo_stuff_t (void);
static Undo_stuff_t* undo[5] = 
{ 
  Undo_stuff1, 
  Undo_stuff2, 
  Undo_stuff3, 
  Undo_stuff4, 
  Undo_stuff5, 
};
</code></pre>

<hr>

<p>MCVE:</p>

<pre><code>#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

// some nonsense functions:
bool Do1 (void) { puts(__func__); return false; }
bool Do2 (void) { puts(__func__); return false; }
bool Do3 (void) { puts(__func__); return false; }
bool Do4 (void) { puts(__func__); return false; }
bool Do5 (void) { puts(__func__); return true; }
void Undo1 (void) { puts(__func__); }
void Undo2 (void) { puts(__func__); }
void Undo3 (void) { puts(__func__); }
void Undo4 (void) { puts(__func__); }
void Undo5 (void) { puts(__func__); }

// wrappers specifying undo behavior:
void Undo_stuff1 (void) { }
void Undo_stuff2 (void) { Undo1(); }
void Undo_stuff3 (void) { Undo2(); Undo1(); }
void Undo_stuff4 (void) { Undo3(); Undo2(); Undo1(); }
void Undo_stuff5 (void) { Undo4(); Undo3(); Undo2(); Undo1(); }

typedef void Undo_stuff_t (void);
static Undo_stuff_t* undo[5] = 
{ 
  Undo_stuff1, 
  Undo_stuff2, 
  Undo_stuff3, 
  Undo_stuff4, 
  Undo_stuff5, 
};

int do_it (void)
{
  if(Do1()) { return 1; };
  if(Do2()) { return 2; };
  if(Do3()) { return 3; };
  if(Do4()) { return 4; };
  if(Do5()) { return 5; };
  return 0;
}

int do_func (void)
{
  int result = do_it();
  if(result != 0)
  {
    undo[result-1]();
  }
  return result;
}

int main (void)
{
  int result = do_func();
  printf(""Failed %d\n"", result);
}
</code></pre>

<p>Output:</p>

<pre><code>Do1
Do2
Do3
Do4
Do5
Undo4
Undo3
Undo2
Undo1
Failed 5
</code></pre>
",2
53445796,53444743,8,"<p>For completeness a bit of obfuscation:</p>

<pre><code>int foo(void)
{
  int rc;

  if (0
    || (rc = 1, do1()) 
    || (rc = 2, do2()) 
    || (rc = 3, do3()) 
    || (rc = 4, do4()) 
    || (rc = 5, do5())
    || (rc = 0)
  ) 
  {
    /* More or less stolen from Chris' answer: 
       https://stackoverflow.com/a/53444967/694576) */
    switch(rc - 1)
    {
      case 5: /* Not needed for this example, but left in in case we'd add do6() ... */
        undo5();

      case 4:
        undo4();

      case 3:
        undo3();

      case 2:
        undo2();

      case 1:
        undo1();

      default:
        break;
    }
  }

  return rc;
}
</code></pre>
",8
53446166,53444743,-7,"<p>A sane (no gotos, no nested or chained ifs) approach would be</p>

<pre><code>int bar(void)
{
  int rc = 0;

  do
  { 
    if (do1())
    {
      rc = 1;
      break;        
    }

    if (do2())
    {
      rc = 2;
      break;        
    }

    ...

    if (do5())
    {
      rc = 5;
      break;        
    }
  } while (0);

  if (rc)
  {
    /* More or less stolen from Chris' answer: 
       https://stackoverflow.com/a/53444967/694576) */
    switch(rc - 1)
    {
      case 5: /* Not needed for this example, but left in in case we'd add do6() ... */
        undo5();

      case 4:
        undo4();

      case 3:
        undo3();

      case 2:
        undo2();

      case 1:
        undo1();

      default:
        break;
    }
  }

  return rc;
}
</code></pre>
",4
53448670,53444743,-1,"<p>If the functions return some kind of state pointer or handle (like most allocation &amp; initialization functions would), you can quite cleanly do this without <code>goto</code> by giving initial values to variables. Then you can have a single deallocation function that can handle the case where only part of the resources has been allocated.</p>

<p>For example:</p>

<pre>
void *mymemoryblock = NULL;
FILE *myfile = NULL;
int mysocket = -1;

bool allocate_everything()
{
    mymemoryblock = malloc(1000);
    if (!mymemoryblock)
    {
        return false;
    }

    myfile = fopen(""/file"", ""r"");   
    if (!myfile)
    {
        return false;
    }

    mysocket = socket(AF_INET, SOCK_STREAM, 0);
    if (mysocket &lt; 0)
    {
        return false;
    }

    return true;
}

void deallocate_everything()
{
    if (mysocket >= 0)
    {
        close(mysocket);
        mysocket = -1;
    }

    if (myfile)
    {
        fclose(myfile);
        myfile = NULL;
    }

    if (mymemoryblock)
    {
        free(mymemoryblock);
        mymemoryblock = NULL;
    }
}
</pre>

<p>And then just do:</p>

<pre>
if (allocate_everything())
{
    do_the_deed();
}
deallocate_everything();
</pre>
",1
53455471,53444743,-1,"<p>Here is an answer that I have found resilient to bugs.</p>

<p>Yes. It uses <code>goto</code>. I firmly believe you should use what gives you most clarity, rather than just blindly following the advice of those before you (<code>goto</code> as a construct <em>can</em> make spaghetti code, but in this instance every other error handling method ususally ends up <em>more</em> spaghetti-like than using this method of <code>goto</code>, so IMO it's superior). </p>

<p>Some people may not like the form of this code, but I contest that when used to the style it is cleaner, easier to read (when everything's lined up, of course), and much more resilient to errors. If you have the properly linter/static analysis setup, and you're working with POSIX, it pretty much requires you to code in this fashion to allow for good error handling.</p>

<pre><code>static char *readbuf(char *path)
{
    struct stat st;
    char *s = NULL;
    size_t size = 0;
    int fd = -1;

    if (!path) { return NULL; }

    if ((stat(path, &amp;st)) &lt; 0) { perror(path); goto _throw; }

    size = st.st_size;
    if (size == 0) { printf(""%s is empty!\n"", path); goto _throw; }

    if (!(s = calloc(size, 1))) { perror(""calloc""); goto _throw; }

    fd = open(path, O_RDONLY);
    if (fd &lt; -1) { perror(path); goto _throw; }
    if ((read(fd, s, size)) &lt; 0) { perror(""read""); goto _throw; }
    close(fd); /* There's really no point checking close for errors */

    return s;

_throw:
    if (fd &gt; 0) close(fd);
    if (s) free(s);
    return NULL;
}
</code></pre>
",23
53450440,53444743,-2,"<pre><code>typedef void(*undoer)();
int undo( undoer*const* list ) {
  while(*list) {
    (*list)();
    ++list;
  }
}
void undo_push( undoer** list, undoer* undo ) {
  if (!undo) return;
  // swap
  undoer* tmp = *list;
  *list = undo;
  undo = tmp;
  undo_push( list+1, undo );
}
int func() {
  undoer undoers[6]={0};

  if (Do1()) { printf(""Failed 1""); return 1; }
  undo_push( undoers, Undo1 );
  if (Do2()) { undo(undoers); printf(""Failed 2""); return 2; }
  undo_push( undoers, Undo2 );
  if (Do3()) { undo(undoers); printf(""Failed 3""); return 3; }
  undo_push( undoers, Undo3 );
  if (Do4()) { undo(undoers); printf(""Failed 4""); return 4; }
  undo_push( undoers, Undo4 );
  if (Do5()) { undo(undoers); printf(""Failed 5""); return 5; }
  return 6;
}
</code></pre>

<p>I made <code>undo_push</code> do the O(n) work.  This is less efficient than having <code>undo</code> do the O(n) work, as we expect more push's than undos.  But this version was a touch simpler.</p>

<p>A more industrial strength version would have head and tail pointers and even capacity.</p>

<p>The basic idea is to keep a queue of undo actions in a stack, then execute them if you need to clean up.</p>

<p>Everything is local here, so we don't pollute global state.</p>

<hr>

<pre><code>struct undoer {
  void(*action)(void*);
  void(*cleanup)(void*);
  void* state;
};

struct undoers {
  undoer* top;
  undoer buff[5];
};
void undo( undoers u ) {
  while (u.top != buff) 
  {
    (u.top-&gt;action)(u.top-&gt;state);
    if (u.top-&gt;cleanup)
      (u.top-&gt;cleanup)(u.top-&gt;state);
    --u.top;
  }
}
void pundo(void* pu) {
  undo( *(undoers*)pu );
  free(pu);
}
void cleanup_undoers(undoers u) {
  while (u.top != buff) 
  {
    if (u.top-&gt;cleanup)
      (u.top-&gt;cleanup)(u.top-&gt;state);
    --u.top;
  }
}
void pcleanup_undoers(void* pu) {
  cleanup_undoers(*(undoers*)pu);
  free(pu);
}
void push_undoer( undoers* to_here, undoer u ) {
  if (to_here-&gt;top != (to_here-&gt;buff+5))
  {
    to_here-&gt;top = u;
    ++(to_here-&gt;top)
    return;
  }
  undoers* chain = (undoers*)malloc( sizeof(undoers) );
  memcpy(chain, to_here, sizeof(undoers));
  memset(to_here, 0, sizeof(undoers));
  undoer chainer;
  chainer.action = pundo;
  chainer.cleanup = pcleanup_undoers;
  chainer.data = chain;
  push_undoer( to_here, chainer );
  push_undoer( to_here, u );
}
void paction( void* p ) {
  (void)(*a)() = ((void)(*)());
  a();
}
void push_undo( undoers* to_here, void(*action)() ) {
  undor u;
  u.action = paction;
  u.cleanup = 0;
  u.data = (void*)action;
  push_undoer(to_here, u);
}
</code></pre>

<p>then you get:</p>

<pre><code>int func() {
  undoers u={0};

  if (Do1()) { printf(""Failed 1""); return 1; }
  push_undo( &amp;u, Undo1 );
  if (Do2()) { undo(u); printf(""Failed 2""); return 2; }
  push_undo( &amp;u, Undo2 );
  if (Do3()) { undo(u); printf(""Failed 3""); return 3; }
  push_undo( &amp;u, Undo3 );
  if (Do4()) { undo(u); printf(""Failed 4""); return 4; }
  push_undo( &amp;u, Undo4 );
  if (Do5()) { undo(u); printf(""Failed 5""); return 5; }
  cleanup_undoers(u);
  return 6;
}
</code></pre>

<p>but that is getting ridiculous.</p>
",1
50831535,50830843,4,"<p>Casting <code>&amp;cb_p</code> is ill-advised. A <code>float**</code> and a <code>void**</code> are not compatible pointer types. The assumption that ""all pointers are the same"" need not hold in general.</p>

<p>You can however do something that almost looks like a cast, but isn't one. You can use a compound literal. That expression creates an lvalue, unlike the regular value a cast produces. And you can take the address of an lvalue:</p>

<pre><code>mem_set( &amp;(void*){cb_p}, &amp;mem_pos );  
</code></pre>

<p><code>(void*){cb_p}</code> produces an unnamed void pointer (this is the compound literal expression), which is initialized from <code>cb_p</code>. And since it's an lvalue, the address can be legally taken. That will avoid the named temporary as you wish.</p>

<p>Just make certain that your compiler supports <a href=""/questions/tagged/c99"" class=""post-tag"" title=""show questions tagged &#39;c99&#39;"" rel=""tag"">c99</a> or later.</p>
",1
55778694,55778658,2,"<p>Here's your code as seen by the compiler after the substitution is performed:</p>

<pre><code>#include &lt;stdio.h&gt;

void ol_parser_parse()
{
    printf(""hello world\n"");
}
void main()
{
   ol_parser_parse();
}
</code></pre>

<p>There's nothing mysterious about it at that point. Every instance of ""yyparse"" becomes ""ol_parser_parse"" on every line following the <code>#define</code>.</p>

<p>In the documentation <em>identifier</em> means the thing being substituted and <em>replacement token list</em> is what you're substituting it with. You can also have parameters, like:</p>

<pre><code>#define TIMES_TWO(n) ((n) * 2)
</code></pre>

<p>Where you can then do:</p>

<pre><code>int x = TIMES_TWO(3);
</code></pre>

<p>Where that's equivalent to:</p>

<pre><code>int x = ((3) * 2);
</code></pre>

<p>Where the extra brackets are so you can do this and not mess up order of operations:</p>

<pre><code>int x = TIMES_TWO(1 - 5);
</code></pre>

<p>Without the brackets it'd show up as this:</p>

<pre><code>int x = 1 - 5 * 2;
</code></pre>

<p>Which evaluates to <code>1 - 10</code> which is not what you want.</p>

<p>There's an art to using <code>#define</code> effectively to hide otherwise ugly implementation details. The name <code>ol_parser_parse</code> isn't something you need to worry about if you can use the <code>yyparser</code> macro. That gives the implementers the freedom to rename that function and the corresponding macro without breaking all your code.</p>
",0
55589859,55589300,1,"<p>I believe you have 2 issues with your attempt.</p>

<blockquote>
  <p>Is this a proper way of taking half of 2D array and ""converting"" it to a 3D array? </p>
</blockquote>

<p>It's not. You are dereferencing pointer with type <code>float[65][3][2]</code>, when the actual type is <code>float[390][2]</code>, which is strict aliasing violation. To get around this issue, you need to put your C compiler to non-standard mode by disabling strict aliasing, or just rewrite your code to not do that. </p>

<blockquote>
  <p>Will this access the right elements of original w_2d:</p>
</blockquote>

<p>It depends on how you have stored your data on the original array. It might work if the data is stored in order similar to:</p>

<pre><code>float[2][65][3][2]
</code></pre>

<p>However, from your <code>w_2d</code> declaration is suspect that your data is arranged like:</p>

<pre><code>float[65][6][2] 
      or
float[6][65][2]
</code></pre>

<p>In this case I doubt that you will get the elements you want.</p>
",2
49378787,49377995,2,"<p>The <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/search.h.html"" rel=""nofollow noreferrer""><code>&lt;search.h&gt;</code></a> header is a POSIX-standard header ¡ª and the library functions it declares include:</p>

<ul>
<li>hash search (<a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/hsearch.html"" rel=""nofollow noreferrer""><code>hsearch()</code></a>)</li>
<li>linear search (<a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/lsearch.html"" rel=""nofollow noreferrer""><code>lsearch()</code></a>)</li>
<li>tree search (<a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/tsearch.html"" rel=""nofollow noreferrer""><code>tsearch()</code></a>)</li>
</ul>

<p>Those pages each list the set of relevant functions for a particular search.  Note that binary search, aka <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/bsearch.html"" rel=""nofollow noreferrer""><code>bsearch()</code></a>, is defined by the C standard rather than POSIX.</p>

<p>The functions were part of Unix SVR4 (and possibly other System V versions), and made it into the Single Unix Specification and hence POSIX too.</p>

<p>If your system doesn't support the header, then it isn't strictly POSIX compliant.  You can certainly find implementations of the functions on the web (BSD, Linux ¡ª and probably other places too).  You may be able to find a version to download for your system.  (Macs have it already; I'd expect to find AIX, HP-UX, Solaris include it by default, too.)</p>
",3
53005749,53005714,-1,"<p>An implicitly defined function is assumed to return <code>int</code> and to take an arbitrary number of arguments. That may or may not be true for the real function.</p>

<p>Depending on your platform, the arguments may be passed in an unexpected way, e. g. in registers, via the stack, etc. And if the way of passing the arguments doesn't match the expectations, things go crazy.</p>
",0
53005774,53005714,-2,"<p>The default function declaration in C has parameters of <code>int</code>.</p>

<p>So, if you do not declare the function, the compiler will assume it returns <code>int</code> and has all parameters of <code>int</code>.</p>

<p>However, you still need to <em>define</em> the function or the linker will give an error.</p>
",0
58759173,58759050,2,"<p>This might work, however without the <code>calloc()</code> or whatever:</p>

<pre><code>typedef struct tree_
{
    struct tree *left; 
    struct tree *right; 

    float info[MAX_DIMENSIONS];
    float distance_to_neighbor;
} tree;
</code></pre>
",0
49644000,49643599,1,"<p>Yes, everything* in C is passed by value, which means that copies of arguments are passed to function - that's the only way of passing values to functions. ""Pass by pointer"" (or ""reference"") doesn't really exist - it's still ""passing by value"", where ""value"" is pointer. Pointers are values after all.</p>

<hr>

<p><strong>Linguistic note:</strong> when we say ""<em>could you pass me some sugar please</em>"" we expect someone to temporarily transfer possession of sugar bowl to us, so at any moment of time there's only one sugar bowl. In other words, we expect sugar bowl to be <em>moved</em> to us. That's not the case in programming. ""Passing"" in this context means merely ""associating parameters with function being called"", and doesn't necessarily involve moving. That's why we differentiate between ""pass-by-value"", ""pass-by-reference"", ""pass-by-name"" etc.</p>

<hr>

<p>Example:</p>

<pre><code>/* I have 2 apples, 3 oranges and one pear */
int apple = 2;
int orange = 3;
int pear = 1;

/* Apples are my favorite fruit */
int *my_favorite_fruit = &amp;apple;

void no_eat_fruit (int fruit) {
    /* Does not work, ""fruit"" is copy, so changes to it have no effect outside function */
    fruit--;
}
no_eat_fruit(apple);
/* No apples have been eaten at this point */


void eat_fruit(int *fruit) {
    /* Here, ""fruit"" is copy, but ""*fruit"" refers to original object */
    *fruit--;
}
eat_fruit(&amp;apple);
eat_fruit(my_favorite_fruit);
/* I have no apples left */

/* Let's change my mind, now I like oranges */

void no_change_my_mind(int *favorite) {
    /* Doesn't work, ""favorite"" is copy, so changes to it have no effect outside function */
    favorite = &amp;orange;
}
no_change_my_mind(my_favorite_fruit);
/* I still like apples, LOL! */

void change_my_mind(int **favorite) {
    /* In order to change pointer, we have pass pointer-to-pointer.
       Here, ""favorite"" is copy, but ""*favorite"" points to original pointer */
    *favorite = &amp;orange;
}
change_my_mind(&amp;my_favorite_fruit);
</code></pre>

<hr>

<p><code>*</code> with exception to arrays. Arrays ""<a href=""https://stackoverflow.com/questions/1461432/what-is-array-decaying"">decay into pointers</a>"" when passed into function.</p>
",11
49686519,49643599,0,"<p>This question has been racking my brains. I had to prove it. Out of respect for el.pescado's efforts, I am leaving his or her answer as accepted answer.</p>

<h1>Code</h1>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


void copy( int * memoryslot )
{
  /* This does not prove that * memoryslot is a copied pointer */
  printf(""copy:              ValueCopied:        %p\n"", memoryslot);  /* memoryslot is a ptr    */
  printf(""copy: CalculatedPointerAddress:        %p &lt;- Well, it is not. Here is the proof.\n"", &amp;memoryslot); /* get address of pointer */
  * memoryslot = 30; /* To prove I can still use a copy to change the original value */
  return;
}

int main(void) 
{
  int memoryslot = 20;
  int * memoryslotPtr = &amp;memoryslot;
  printf(""Caller                 Pointer to memory slot\n"");
  printf(""-------------------------------------\n"");
  printf(""main:                    Value:        %d\n"", memoryslot);
  printf(""main:   CalculatedValueAddress:        %p\n"", &amp;memoryslot);
  printf(""main: CalculatedPointerAddress:        %p &lt;- If * memoryslot were the same, it would be this.\n"", &amp;memoryslotPtr);

  /* Pass address, yields same as &amp;memoryslot */
  copy( memoryslotPtr ); 

  printf(""main:                    Value:        %d\n"", memoryslot);


  return EXIT_SUCCESS;
}
</code></pre>

<h1>Output</h1>

<pre><code>Caller                 Pointer to memory slot
-------------------------------------
main:                    Value:        20
main:   CalculatedValueAddress:        0x7ffee9134c48
main: CalculatedPointerAddress:        0x7ffee9134c40 &lt;- If * memoryslot were the same, it would be this.
copy:              ValueCopied:        0x7ffee9134c48
copy: CalculatedPointerAddress:        0x7ffee9134c08 &lt;- Well, it is not. Here is the proof.
main:                    Value:        30
</code></pre>
",0
52446528,52446237,3,"<p>Per the C standard, members that are structures or unions may be anonymous. This works because the members within them are not anonymous, so every subobject within the enclosing structure or union has a name. Anonymous members of other types are not supported (except that bit fields used for padding may be anonymous, but they are also not normally accessible).</p>

<p>(The C grammar allows you to include declarations without names (C 2018 6.7.2.1 1: The <em>struct-declarator-list</em> is optional in a <em>struct-declaration</em>), but they do not create members, and there would be no way of referring to them. And declaring a member without a name requires omitting the entire <em>declarator</em> of the grammar, which includes (per 6.7. 1) <code>*</code> for pointers, <code>[</code> and <code>]</code> for arrays, and <code>(</code> and <code>)</code> for functions. So the grammar would permit you to declare <code>struct { float; float f; } foo;</code> but not <code>struct { float [3]; float f; } foo;</code>.)</p>
",6
59509251,9871119,7,"<p>I came to this post because I was looking for a way to teach a bit of Object Oriented ""style"" of programming in C for a very simple data structures course.  I did not want to teach C++ because I did not want to keep explaining its more advanced features.</p>

<p>But I wanted to explore how one might <em>implement</em> the OO pattern used in Python but in a low-level language / run-time.  By explaining what is going on in C, students might  better understand the Python OO run-time patterns.  So I went a bit beyond the first answer above and adapted some of the patterns from <a href=""https://stackoverflow.com/a/12642862/1994792"">https://stackoverflow.com/a/12642862/1994792</a> but in a way that would elucidate OO run time patterns a bit.</p>

<p>First I made the ""class"" with a ""constructor"" in <strong>point.c</strong>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct point
{
    int x;
    int y;
    void (*print)(const struct point*);
    void (*del)(const struct point*);
};

void point_print(const struct point* self)
{
    printf(""x=%d\n"", self-&gt;x);
    printf(""y=%d\n"", self-&gt;y);
}

void point_del(const struct point* self) {
  free((void *)self);
}

struct point * point_new(int x, int y) {
    struct point *p = malloc(sizeof(*p));
    p-&gt;x = x;
    p-&gt;y = y;
    p-&gt;print = point_print;
    p-&gt;del = point_del;
    return p;
}
</code></pre>

<p>Then I imported the class, constructed an object from the class, used the object, then destructed the object in <strong>main.c</strong></p>

<pre><code>#include ""point.c""

int main(void)
{
    struct point * p3 = point_new(4,5);
    p3-&gt;print(p3);
    p3-&gt;del(p3);
}
</code></pre>

<p>It feels very ""Pythonic in C"".</p>
",4
53711801,10043841,1,"<p><code>scanf</code> returns the number of ""items"", i.e. values passed both in the format string (a single item is e.g. <code>%d</code>, <code>%c</code> and so on), and in the subsequent arguments to <code>scanf</code>, for example, to read two integers separated by comma and space, you would use:</p>

<pre><code>int x, y;
int items = scanf(""%d, %d"", &amp;x, &amp;y);
assert(items == 2);
</code></pre>

<p>I've already spoiled what my suggestion will be above - instead of adding unused variables, if you just want to read it, add an assertion:</p>

<pre><code>#include &lt;assert.h&gt;
/* ... */
assert(scanf(""%d"", &amp;sides) &gt; 0);
/* ... */
</code></pre>

<p>Unfortunately, <code>assert(scanf(""%d"", &amp;sides));</code> is not enough, because of EOF (this will return <code>-1</code>). It would be really elegant.</p>

<p>I think this is the way to go, if you don't want to continue your program with an uninitialized variable (<code>sides</code>) in this case.</p>

<p>Alternatively, you can capture <code>scanf</code>'s result to a variable, and handle it gracefully like in the other answers.</p>
",0
49181830,49179053,0,"<p>For any type <code>T</code> and declaration <code>T *p;</code>, the type of <code>p</code> is ""pointer to <code>T</code>"", or <code>T *</code>.  </p>

<p>There is no single ""pointer"" type.  All pointer types are distinct, and named in reference to the base type.  </p>
",0
49179462,49179053,0,"<p>The only place that I'm aware of that describes a pointer variable as having ""pointer type"" is the Standard (C11 6.7.9, for example):</p>

<blockquote>
  <p>10 If an object that has automatic storage duration is not initialized explicitly, its value is
  indeterminate. If an object that has static or thread storage duration is not initialized
  explicitly, then: </p>
  
  <ul>
  <li><strong>if it has pointer type, it is initialized to a null pointer;</strong></li>
  <li>if it has arithmetic type, it is initialized to (positive or unsigned) zero;</li>
  <li>if it is an aggregate, every member is initialized (recursively) according to these rules,
  and any padding is initialized to zero bits;</li>
  <li>if it is a union, the first named member is initialized (recursively) according to these
  rules, and any padding is initialized to zero bits;</li>
  </ul>
</blockquote>

<p>But it only does that when discussing types in the abstract. Whenever ""real world"" objects are discussed, the Standard usually uses the ""pointer to <em>type</em>"" phrase (C11 6.2.5, for example):</p>

<blockquote>
  <p>29 EXAMPLE 1 The type designated as ¡®¡®float *¡¯¡¯ has type ¡®¡®pointer to float¡¯¡¯. Its type category is
  pointer, not a floating type. The const-qualified version of this type is designated as ¡®¡®float * const¡¯¡¯
  whereas the type designated as ¡®¡®const float *¡¯¡¯ is not a qualified type ¡ª its type is ¡®¡®pointer to const-</p>
</blockquote>
",2
53728364,53728231,1,"<p>Think of <code>#define</code> macros as something that get searched and replaced. If you replace the macros with their definitions you get:</p>

<pre><code>typedef struct fileList{
    ""/data/file1"";
    ""/data/file2"";
    ""/data/file3"";
}fileList;
</code></pre>

<p>and</p>

<pre><code>printf(""Hello world! %s\n"", fl.""/data/file1"");
</code></pre>

<p>Those snippets are clearly not syntactically valid.</p>

<hr>

<p>It looks like you're trying to create a struct with three string fields. One way to do that might be:</p>

<pre><code>typedef struct fileList {
    const char *file1;
    const char *file2;
    const char *file3;
} fileList;
</code></pre>

<p>Then if you want to create an instance of that struct and set the <em>values</em> of those string fields to the string literals you listed, you could write:</p>

<pre><code>int main() {
    fileList fl;
    fl.file1 = ""/data/file1"";
    fl.file2 = ""/data/file2"";
    fl.file3 = ""/data/file3"";
    printf(""Hello world! %s\n"", fl.file1);
}
</code></pre>

<p>No need for preprocessor macros at all.</p>
",3
58244478,16100090,0,"<p>If the function in question is in a different c file, you can do</p>

<pre><code>#define name_of_function(...) \
    printf(""Function %s is parent\n"", __FUNCTION__); \
    name_of_function(__VA_ARGS__);
</code></pre>

<p>And at the top of the c file it lives in</p>

<pre><code>#ifdef name_of_function
#undef name_of_function
#endif
</code></pre>

<p>If they're in the same file, you can wrap the function definition in the second macro, then redefine the first macro at the end.
It's not terribly extensible because you can't generate new defines from other defines, but if you're trying to track down parents for a particular function it works without any nonsense.</p>

<p><a href=""https://godbolt.org/z/f2jKOm"" rel=""nofollow noreferrer"">https://godbolt.org/z/f2jKOm</a></p>
",0
59512667,59512346,1,"<blockquote>
  <p>function cmpTdata works fine for other structures when I'm sorting doubles.</p>
</blockquote>

<p><code>double</code> math differs from  <em>unsigned</em> math.  The following is never true as <em>unsigned</em> are never less than 0.</p>

<pre><code>if ((dataB-&gt;indx - dataA-&gt;indx) &lt; 0) { return 1; }
</code></pre>

<p>This implies code was not compiled with a good compiler that would have warned.  So the biggest oops is not ""doing the math wrong"", but not using tools readily at hand.  Best to enable all warnings.</p>

<pre><code>foo.c:9:35: warning: comparison of unsigned expression &lt; 0 is always false [-Wtype-limits]
</code></pre>

<hr>

<p>Recommend the C compare idiom - recognized by various compilers to emit efficient code.</p>

<pre><code>int cmpTdata(const void *a, const void *b) {
  const txtD *dataA = (txtD*) a;
  const txtD *dataB = (txtD*) b;
  return (dataA-&gt;indx &gt; dataB-&gt;indx) - (dataA-&gt;indx &lt; dataB-&gt;indx);
}
</code></pre>
",4
56121355,56121281,1,"<p><code>getIps</code> is allocating <code>line</code> as a local variable. You can¡¯t return a
local variable that way; that memory is freed as soon as the function
exits.</p>

<p>Also, you¡¯re allocating <code>line</code> as a two-dimensional array of <code>char</code>, but
the caller is trying to map that onto a one-dimensional array of
pointers to <code>char</code>. Again, this doesn¡¯t work.</p>

<p><code>getIps</code> could instead allocate a similar array of pointers, and use
<code>malloc</code> to allocate space for each string. However, since the caller
has already started doing that, it¡¯s simpler to just pass the address to <code>getIps</code>
and have it use that.</p>

<p>There are other issues. The code assumes there will only be three lines
of input; if there are more, you will overrun the buffer. You¡¯re
hardcoding things that should use <code>#define</code>, such as <code>int total=3</code>. You
don¡¯t check the return value of <code>fopen</code>. </p>
",2
55830499,55830471,3,"<p>That general approach will work but you'll need to absorb the comma into the <code>#ifdef</code>:</p>

<pre><code>{
    10
    ,20
    #ifdef winters
        ,50
    #endif
};
</code></pre>

<p>The reasons for wanting to do this though are questionable.</p>
",0
52179893,52179719,3,"<p>When faced with questions like this, you can usually turn to <code>cdecl</code> (online version <a href=""https://cdecl.org/"" rel=""nofollow noreferrer"">here</a>):</p>

<pre><code>cdecl&gt; explain char *names[3]
declare names as array 3 of pointer to char

cdecl&gt; explain char (*names)[3]
declare names as pointer to array 3 of char
</code></pre>

<p>So the former creates array of three pointers-to-char:</p>

<pre><code>+----------+
| names[0] | -&gt; char
|      [1] | -&gt; char
|      [2] | -&gt; char
+----------+
</code></pre>

<p>And the latter creates a <em>single</em> pointer to a char array of size three.</p>

<pre><code>+-------+
| names | -&gt; char, char, char - no, not a dance step :-)
+-------+
</code></pre>
",1
52179856,52179719,1,"<p>The second line <a href=""https://cdecl.org/"" rel=""nofollow noreferrer"">decodes as</a> ""declare names as pointer to array 3 of char"".</p>

<p>I've been writing C for over 25 years, and I've never used such a variable.</p>

<p>Anyway, I guess this should work:</p>

<pre><code>char data[3];
char (*names) = data;
</code></pre>

<p>Note that the variable name, <code>names</code>, is highly misleading since the variable holds only 3 single characters, as opposed to <code>char *names[3]</code> which is three pointers to characters and thus easily could be used to hold three strings.</p>

<p>Also note that the above code makes little sense, you could just use <code>data</code> directly if you had it.</p>
",0
52179941,52179719,1,"<p>The first an array of three pointers to <code>char</code>.  </p>

<p>The second is a pointer to an array of three <code>char</code>s.<br>
(Read it as ""<code>*names</code> is a <code>char[3]</code>"").</p>

<p>You can create such a pointer by taking the address of an array of three <code>char</code>s:</p>

<pre><code>char name[3];
char (*names)[3] = &amp;name;
</code></pre>

<p>or dynamically in the normal way:</p>

<pre><code>char (*names)[3] = malloc(sizeof(*names)); /* or sizeof(char[3]), if you're fond of bugs */
</code></pre>

<p>or through the regular array-to-pointer conversion:</p>

<pre><code>char stuff[2][3] = {};
char (*names)[3] = stuff; /* Same as &amp;stuff[0], as normal. */ 
</code></pre>
",0
52180043,52179719,1,"<ul>
<li><code>char *names[3]</code> is an array of 3 <code>char</code> pointers.</li>
<li><code>char (*names)[3]</code> is an array pointer (pointer to array) to an array of 3 characters <code>char[3]</code>.</li>
</ul>

<p>So these two have fundamentally different meanings! Don't confuse them with each other.</p>

<p>If you wish to allocate <em>an array of pointers</em>, then you can do it as in either of these examples:</p>

<pre><code>char** names = malloc(3 * sizeof(*names) );
char** names = malloc(sizeof(char*[3]));
char** names = calloc(3, sizeof(char*));
</code></pre>

<p>These are all equivalent (but calloc also sets all pointers to NULL). <code>names</code> will be a pointer to the first element in the array. It will be a pointer to a <code>char*</code>.</p>

<p>If you wish to allocate <em>an array</em> and point to the first element, simply do:</p>

<pre><code>char* names = malloc(3 * sizeof(*names));
</code></pre>

<p>Alternatively, you can use the array pointer syntax and point to the array as whole:</p>

<pre><code>char (*names)[3] = malloc(sizeof(*names));
</code></pre>
",0
53707119,53706962,3,"<p>It would not be possible for a legacy compiler to implement <code>!</code> as bitwise negation, because such approach would produce incorrect results in situations when the value being negated is outside the {0, 0xFF...FF} set.</p>

<p>Standard requires the result of <code>!x</code> to produce zero for any non-zero value of <code>x</code>. Hence, applying <code>!</code> to, say, 1 would yield 0xFF..FFFE, which is non-zero.</p>

<p>The only situation when the legacy code would have worked as intended is when <code>SOME_FLAG</code> is set to <code>1</code>.</p>
",2
53707645,53706962,0,"<p>Let's start with the most interesting (and least obvious) part: gcc logically barks with <code>-Wlogical-not-parentheses</code>. What does this mean?</p>

<p>C has two different operators that have similar looking characters (but different behaviour and intended for very different purposes) - the <code>&amp;</code> which is a bitwise AND, and <code>&amp;&amp;</code> which is a boolean AND. Unfortunately this led to typos, in the same way that typing <code>=</code> when you meant <code>==</code> can cause problems, so some compilers (GCC) decided to warn people about ""<code>&amp;</code> without parenthesis used as a condition"" (even though it's perfectly legal) to reduce the risk of typos.</p>

<p>Now...</p>

<p>You're showing code that uses <code>&amp;</code> (and not showing code that uses <code>&amp;&amp;</code>). This implies that <code>some_state</code> is not a boolean and is number. More specifically it implies that each bit in <code>some_state</code> may be completely independent and unrelated.</p>

<p>For an example of this, let's pretend that we're implementing a Pacman game and need a nice compact way to store the map for each level. We decide that each tile in the map might be a wall or not, might be a collected dot or not, might be power pill or not, and might be a cherry or not. Someone suggests that this can be an array of bytes, like this (assuming the map is 30 tiles wide and 20 tiles high):</p>

<pre><code>#define IS_WALL         0x01
#define HAS_DOT         0x02
#define HAS_POWER_PILL  0x04
#define HAS_CHERRY      0x08

uint8_t level1_map[20][30] = { ..... };
</code></pre>

<p>If we want to know if a tile happens to be safe to move into (no wall) we could do this:</p>

<pre><code>    if( level1_map[y][x] &amp; IS_WALL == 0) {
</code></pre>

<p>For the opposite, if we want to know if a tile is a wall we could do any of these:</p>

<pre><code>    if( level1_map[y][x] &amp; IS_WALL != 0) {

    if( !level1_map[y][x] &amp; IS_WALL == 0) {

    if( level1_map[y][x] &amp; IS_WALL == IS_WALL) {
</code></pre>

<p>..because it makes no difference which one it is.</p>

<p>Of course (to avoid the risk of typos) GCC might (or might not) warn about some of these.</p>
",3
53707116,53706962,3,"<p>While there was no standard before 1989, and thus compilers could do things as they wished, no compiler to my knowledge has ever done this; changing the meaning of operators wouldn't be a smart call if you want people to use your compiler.</p>

<p>There's very little reason to write an expression like <code>(!foo &amp; FLAG_BAR)</code>; the result is just <code>!foo</code> if <code>FLAG_BAR</code> is odd or always zero if it is even. What you've found is almost certainly just a bug.</p>
",0
49644026,49643862,3,"<p>Why are you trying to squeeze 16 characters of hex into a 12 byte string, which can only really handle 11 characters plus a null terminator. It also helps readability of output if you include newlines at appropriate points. And you would probably do better with with <code>unsigned long long</code> and <code>strtoull()</code> ¡ª <code>int</code> won't hold 16 hex digits on most machines.  It is also conventional to write expected output on standard output; use standard error for error messages.</p>

<p>Putting those changes together yields an MCVE (<a href=""https://stackoverflow.com/help/mcve"">Minimal, Complete, Verifiable Example</a>) like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    const char lm_bin[] = ""0110110000001110110000010100111000110011110110110111000110111000"";
    unsigned long long lm_dec = strtoull(lm_bin, NULL, 2);
    char lm_hex[17];
    sprintf(lm_hex, ""%llx"", lm_dec);
    printf(""binary %s\n"", lm_bin);
    printf(""hex %s\n"", lm_hex);
    return 0;
}
</code></pre>

<p>And the output from that is what you sought, I believe:</p>

<pre><code>binary 0110110000001110110000010100111000110011110110110111000110111000
hex 6c0ec14e33db71b8
</code></pre>

<p>That code doesn't check for conversion errors and could use <code>snprintf()</code> instead of <code>sprintf()</code>, and could do all the printing in a single call to <code>printf()</code> ¡ª and doesn't need to use the string for the hex-formatted output (it could format <code>lm_dec</code> directly).  So, there's lots of room for changes and improvements in the code.</p>
",1
49469081,49468978,2,"<p>You're indexing is wrong, and you're probably not allocating correctly.</p>

<p>You probably want to allocate by doing <code>malloc(sizeof(u64) * ROW * COL)</code> (note I used <code>u64</code> instead of <code>u32</code>). As it currently is, you're only allocating half of the memory you're probably intending to.</p>

<p>You should index by doing <code>ary[r*COL + c]</code> (or <code>ary[c*ROW + r]</code>, depending on your needs). And you should be using <code>size_t</code> instead of <code>u32</code> for your index values, to avoid <a href=""https://stackoverflow.com/a/49469091/1287251"">the overflow issues C_Elegans mentions</a>.</p>

<p>Also, while this isn't causing problems in this small program, you should get in the habit of surrounding your macro definitions with parentheses (e.g. <code>#define ROW (1024 * 1024)</code>).</p>
",1
53092667,53092506,2,"<p>Unless it is the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, or is a string literal used to initialize a character array in a declaration, an <em>expression</em> of type ""array of <code>T</code>"" will be converted (""decay"") to an expression of type ""pointer to <code>T</code>"", and the value of the expression will be the address of the first element of the array.</p>

<p>In plain English, when you passed <code>grade_table</code> to <code>read_data</code>, you actually passed a pointer to the first element, so any updates to <code>grade_table2</code> in <code>read_data</code> are reflected in <code>grade_table</code> in <code>main</code>.  </p>

<p>In the context of a function parameter declaration, <code>T a[N]</code> and <code>T a[]</code> are interpreted as <code>T *a</code>.  Note that this is only true for function parameters.  </p>

<p>This ""decay"" rule <em>only</em> applies to array expressions.  <code>struct</code> and <code>union</code> arguments are passed by value like any scalar type (<code>int</code>, <code>float</code>, etc.).  </p>
",0
55445885,55445869,0,"<p>I initially misinterpreted the valgrind output, so @chux's deserves acceptance.  I'll try to put together the best answer I can though.</p>

<h2>Checking errors</h2>

<p>The first error (the one I didn't immediately consider) is to check the value returned by <code>fopen(3)</code> with <code>ferror(3)</code>.  The <code>fopen(3)</code> call returns <code>NULL</code> on error (and sets <code>errno</code>), so checking <code>NULL</code> with <code>ferror(3)</code> is wrong.</p>

<h2>Serializing a structure on a file.</h2>

<p>With the initialization you write all the <strong>fields</strong> of your structure, but you don't initialize all the memory it covers.  Your compiler might for example leave some padding in the structure, in order to get better performance while accessing data.   As you write the whole structure on the file, you are actually passing non-initialized data to the <code>fwrite(3)</code> function.</p>

<p>By changing the size of the array you change Valgrind's behaviour.  Probably this is due to the fact that the compiler changes the layout of the structure in memory, and it uses a different padding.</p>

<p>Try wiping the <code>rec</code> variable with <code>memset(&amp;rec, 0, sizeof(rec));</code> and Valgrind should stop complaining.  This will only fix the <em>symptom</em> though: since you are serializing binary data, you should mark <code>struct record</code> with <a href=""https://gcc.gnu.org/onlinedocs/gcc-3.3/gcc/Type-Attributes.html"" rel=""nofollow noreferrer""><code>__attribute__((packed))</code></a>. </p>

<h2>Initializing memory</h2>

<p>Your original initialization is good.</p>

<p>An alternative way of initializing data is to use <code>strncpy(3)</code>.  Strncpy will accept as parameters a pointer to the destination to write, a pointer to the source memory chunk (where data should be taken from) and the available write size.</p>

<p>By using <code>strncpy(&amp;rec.text, ""hello world"", sizeof(rec.text)</code> you write ""hello world"" over the <code>rec.text</code> buffer.  But you should pay attention to the termination of the string: <code>strncpy</code> won't write beyond the given size, and if the source string is longer than that, there won't be any string terminator.</p>

<p>Strncpy can be used safely as follows</p>

<pre><code>strncpy(&amp;rec.text, ""hello world"", sizeof(rec.text) - 1);
rec.text[sizeof(rec.text) - 1] = '\0';
</code></pre>

<p>The first line copies ""hello world"" to the target string.  <code>sizeof(rec.text) - 1</code> is passed as size, so that we leave room for the <code>\0</code> terminator, which is written explicitly as last character to cover the case in which <code>sizeof(rec.text)</code> is shorter than ""hello world"".</p>

<h2>Nitpicks</h2>

<p>Finally, error notifications should go to <code>stderr</code>, while <code>stdout</code> is for results.</p>
",16
55446106,55445869,4,"<p>The problem is that there is padding in the structure to <em>make the <code>int a</code></em> always aligned by 4 in memory, even within an array of <code>struct record</code>s. Now, 20+4 is divisible by 4, and so is 40+4 and 60+4. But 30+4 and 50+4 are not. Hence 2 padding bytes need to be added to make the <code>sizeof (struct record)</code> divisible by 4.</p>

<p>When you're running the code with array size 34, <code>sizeof (struct record) == 36</code>, and bytes 35 and 36 contain indeterminate values - even if the <code>struct record</code> is otherwise fully initialized. What is worse, code that writes indeterminate values can leak sensitive information - the <a href=""http://heartbleed.com/"" rel=""nofollow noreferrer"">Heartbleed bug</a> being a prime example.</p>

<p>The solution is actually to <em>not</em> write the structure using <code>fwrite</code>. Instead write the members individually - this improves portability too. There isn't much performance difference either, as <code>fwrite</code> <em>buffers</em> the writes and so does <code>fread</code>.</p>

<hr>

<p>P.S. the road to hell is paved with packed <code>struct</code>s, you want to avoid them like plague in generic code.</p>

<hr>

<p>P.P.S. <code>ferror(file)</code> will almost certainly never be true just after <code>fopen</code> - and in normal failures <code>fopen</code> will return <code>NULL</code> and <code>ferror(NULL)</code> will probably lead to a crash.</p>
",7
48470839,48470801,5,"<p>Use a union:</p>

<pre><code>union Foo {
  struct {
    short x;
    short y;
    float s;
  } ssf;
  double dbl;
};

int main() {
  union Foo v;
  v.ssf.x = 4012;
  v.ssf.y = 1234;
  v.ssf.s = 0.8f;

  // read a double
  double store = v.dbl;

  // set the double value
  v.dbl = store;

  // read the float back out
  printf(""%f\n"", v.ssf.s);

  return 0;
}
</code></pre>
",6
51392943,51392832,0,"<p>You are missing something in the comment </p>

<blockquote>
  <p>If putting the simple_root after the last else, there is a risk of error, e.g. the previous two conditions doesn't match</p>
</blockquote>

<p>This is already the case - if you don't match those two then <code>triple_root</code> and <code>simple_root</code> are already not set.  I'm not sure how they are used after this piece of code or what your error handling is.  You can either return immediately after the <code>printf</code> statement or set <code>triple_root</code> to be a <code>NaN</code>.</p>

<p>Then you can move the simple_root equation below the <code>if</code> statement.  Alternatively you could put that in to a function.  A one line function is fine and can make the code easier to understand.</p>
",0
55629016,55628627,4,"<p>This is called an opaque <code>struct</code>, is useful when you want to protect the access to the members (a kind of private specifier).</p>

<p>in this way, only <code>file1.c</code> can access the members of the <code>struct</code>, to make it visible to the rest of the .c files you need to</p>

<p>1) Define the <code>struct</code> inside the .h file</p>

<p>or</p>

<p>2) Access the members through a function:</p>

<pre><code>//file.h

typedef struct foo foo;
int foo_val(const foo *);

//file1.c

#include ""file.h"" // Always prefer """" instead of &lt;&gt; for local headers

struct foo { // Notice that you don't need to retypedef the struct
   int val;
};

int foo_val(const foo *f)
{
    return f-&gt;val;
}

//file2.c

#include ""file.h""

struct foo *f;

printf(""%d"", foo_val(f)); 
</code></pre>
",0
55399728,55399427,4,"<p>Here:</p>

<pre><code>void initializeBoard(Player player) {
    memset(*player.gameBoard.board, WATER, sizeof(player.gameBoard.board));
}
</code></pre>

<p>You are passing the <code>Player</code> object by copy rather than reference.  The object you are setting, is not the object you intend to set, and is in any event temporary.  Passing large structures on the stack is also inefficient (you may want to reconsider the signature of <code>displayGameBoard()</code> too in that case).  Also the member <code>board</code> does not need to be dereferenced.</p>

<pre><code>void initializeBoard(Player* player);

...

void initializeBoard(Player* player) 
{
    memset( player-&gt;gameBoard.board, WATER, sizeof(player-&gt;gameBoard.board));
}
</code></pre>

<p>Then call it in <code>initializePlayer()</code> thus:</p>

<pre><code>initializeBoard(player);
</code></pre>
",4
52510174,52508492,0,"<p>s is not initialized, so it holds some garbage address (probably an invalid one).</p>

<p>When you do <code>*s = ""Hello World!"";</code> you are writing <code>""Hello World!""</code> (which is a pointer value) to some garbage address (probably an invalid one).</p>

<p>Let's say it doesn't crash though - then <code>puts</code> will read the bytes from that same garbage address (i.e. it will read the address of the string, not the string) and display them on the screen.</p>

<p>After running the incorrect code the memory might contain these values for example:</p>

<pre><code>Address      Value (4 bytes at a time)
...
0x12345678   0x65401234      &lt;- some important thing you just overwrote that is liable to make your program crash,
                                now it holds the address of the string literal
...
0x4000000C   0x12345678      &lt;- variable 's' in main
0x40000010   0x12345678      &lt;- variable 's' in function, copy of variable 's' in main
...
0x65401234   'H', 'e', 'l', 'l'  &lt;- where the compiler decided to put the string literal
0x65401238   'o', ' ', 'W', 'o'
0x6540123C   'r', 'l', 'd', '!'
0x65401240   0
</code></pre>

<p>When you call <code>puts(s);</code> you would be calling <code>puts(0x12345678);</code> and it would print the bytes <code>0x65401234</code> (but it wouldn't print ""0x65401234"", it'd try to print the letters corresponding to those)</p>

<p>If you do it right, you end up with:</p>

<pre><code>Address      Value (4 bytes at a time)
...
0x4000000C   0x65401234      &lt;- variable 's' in main
0x40000010   0x4000000C      &lt;- variable 's' in function, has address of variable 's' in main
...
0x65401234   'H', 'e', 'l', 'l'  &lt;- where the compiler decided to put the string literal
0x65401238   'o', ' ', 'W', 'o'
0x6540123C   'r', 'l', 'd', '!'
0x65401240   0
</code></pre>

<p>Then <code>puts(s)</code> is <code>puts(0x65401234)</code> which prints the string.</p>
",2
52508577,52508492,0,"<p>Since <code>s</code> is uninitialized, its contents are unknown (and using it is invalid according to the C standard). Suppose it did contain some value and the C implementation did pass that value to <code>function</code> for the parameter <code>c</code>. Then <code>function</code> attempts to write the address of <code>""Hello World""</code> to the place where <code>c</code> points. But where is that place?</p>

<p>We supposed <code>s</code> contained some value. But it is quite likely an address that is not mapped in your address space. Your small program likely does not use much of even a 32-bit address space, so most of that space will not be mapped to real memory by the operating system. So, if you pick a random address and try to write there, it is probably an invalid address, and your process will crash.</p>

<p>Another likely possibility is that <code>s</code> happens to contain zero because this is early in your program and nothing has written anything else to the place where the compiler put <code>s</code>, so it just contains the zeros that the operating system initialized your memory with. In many systems, the address zero is deliberately left unmapped in address spaces just for this purpose, so that uses of uninitialized pointers will crash.</p>

<p>More than that, a good compiler will see that <code>s</code> is used without being initialized and will warn you about that. If you force it to generate code anyway, the optimizer may, as a a result of its usual transformations, completely replace this broken code with something else.</p>

<p>If you are unlucky, then the uninitialized <code>s</code> will contain a value that happens to be a valid address in your address space, and then <code>function</code> may write the address of <code>""Hello World!""</code> into it. Now you are writing data into some place in your process that may be needed for another purpose, so it can break your program in a variety of ways. Note that this does not give the result you seem to think it would, that <code>puts</code> would write ¡°Hello World!¡±. If <code>function</code> did write the address of <code>""Hello World!""</code> into <code>*c</code>, the address would be in memory at the place <code>s</code> happens to point to. Then you are passing to <code>puts</code> the address of a place where there is an address. However, <code>puts</code> expects the address of a place where there are characters. It will read the bytes of the address of <code>""Hello World!""</code> and print them, until it reaches a zero byte. Most often, the result is unprintable or at least unusual characters.</p>
",6
59163551,59163500,2,"<p>This is not possible.  </p>

<p>A variable can have the <code>const</code> qualifier applied to it to prevent code from modifying that variable.  This however only applies at compile time.  There is nothing built in to the language to do this a run time.</p>

<p>What you can do is put this variable in an external module and make it accessible only via getter/setter functions.  Then you can set a flag internal to the module that prevents the setter function from making a change.</p>

<p>For example:</p>

<p>ro_var.h:</p>

<pre><code>int getx(void);
int setx(int val);
void flag(void);
</code></pre>

<p>ro_var.c:</p>

<pre><code>static int x;
static int ro = 0;

int getx(void)
{
    return x;
}

int setx(int val)
{
    if (ro) {
        return 0;
    } else {
        x = val;
        return 1;
    }
}

void flag(void)
{
    ro = 1;
}
</code></pre>
",0
52882536,11968558,4,"<p>It's not mentioned in any of the other answers so far, but you may need to press the right key combo (^D or ^Z) 2 or 3 times in order to actually signal EOF; <a href=""https://stackoverflow.com/questions/37959469/understanding-how-eof-and-ctrl-d-work"">see here</a> for explanation.</p>
",0
54219910,25515347,-1,"<p>You probably should allocate dynamically your array as:</p>

<pre><code>void foo() {
  const int array_size = 32;
  char *my_array;
  my_array = malloc((array_size)*sizeof(char));
  // .. do stuff
  // (array_size is used multiple times)

  free(my_array);
}
</code></pre>
",2
56817959,56817797,8,"<p>Calling a function is an expression regardless of the function's return type. C's grammar is orthogonal to its type system. They are independent pieces of the language. Grammatically <code>func();</code> is an <em>expression statement</em>.</p>

<pre><code>expression_statement
    : ';'
    | expression ';'
    ;

postfix_expression
    : primary_expression
    | postfix_expression '[' expression ']'
    | postfix_expression '(' ')'
    | postfix_expression '(' argument_expression_list ')'
</code></pre>

<p>There are very few things you can do with a <code>void</code> result. You can't assign it to a variable since <code>void</code> variables aren't allowed. If <code>func()</code>'s result is <code>void</code> you can use four operators:</p>

<ul>
<li>Parentheses: <code>(func())</code></li>
<li>Comma sequencing: <code>func(), 42</code></li>
<li>Ternary operator: <code>42 ? func() : func()</code>.</li>
<li>Cast to void: <code>(void) func()</code></li>
</ul>

<p>You can also return a <code>void</code> result:</p>

<pre><code>return func();
</code></pre>

<p>Finally, in a <code>for(init; condition; increment)</code> loop the three pieces are all expressions. <em>init</em> and <em>increment</em> (but not <em>condition</em>) can be <code>void</code>.</p>

<pre><code>for (func(); 42; func()) { }
</code></pre>

<p>Few of these are useful and none are good style, but they're all legal.</p>
",1
56818184,56817797,3,"<p>Paragraph 1 of clause 6.5 was not completely thought out with regard to <code>void</code>. The C standard is imperfect and has a number of defects. This paragraph should be received as a general description to orient readers and is not a precise mathematical specification of what an expression is.</p>
",1
56818046,56817797,1,"<p>It is said that:</p>
<blockquote>
<p>An expression is a sequence of operators and operands that</p>
<ul>
<li>specifies computation of a value, or</li>
<li>that designates an object or a function or</li>
<li>that generates side effects</li>
<li>or that performs a combination thereof.</li>
</ul>
</blockquote>
<p>The specifies computation of a value is but <em>one</em> among possibilities. The <code>void</code> function call would be the one &quot;that generates side effects&quot;.</p>
<hr />
<p>Any expression in the  expression statement in C is considered a <code>void</code> expression. <a href=""https://port70.net/%7Ensz/c/c11/n1570.html#6.8.3p2"" rel=""nofollow noreferrer"">C11 6.8.3 Expression and null statements p2</a>:</p>
<blockquote>
<ol start=""2"">
<li>The expression in an expression statement is evaluated as a <code>void</code> expression for its side effects.<em><strong>153)</strong></em></li>
</ol>
<p><em><strong>153)</strong></em> Such as assignments, and function calls which have side effects.</p>
</blockquote>
<p>i.e. in the expression <em>statement</em></p>
<pre><code>a = 5;
</code></pre>
<p><code>a = 5</code> is a <em>void</em> expression that is evaluated for its side effects only, i.e. the assignment of value <code>5</code> into <code>a</code>, not for computation of a value, even though <code>a = 5</code> could be used for a computation of a value in <em>other contexts</em>. Likewise you can write <code>a;</code> and it is a legal use of an expression &quot;evaluated for its side effects&quot;, even though it has none. It does not cease to be an expression there.</p>
<p>The LHS of a comma operator is a void expression. A void expression can be used in <code>? :</code> - then both branches will be void expressions and the entire expression in itself will be a void expression.</p>
",6
56424719,29126729,0,"<p>here it is fixed up, I had to chage the order of x,y,z and fix the nenner formula.</p>

<pre><code>void getAngle( float  xValue , float  yValue, float zValue){
     float x = 0.0;
     float y = 0.0;
     float z = 0.0;
     float rad_angle =0.0;
     float  angle =0 ;
     float zaehler = 0.0;
     float nenner = 0.0;
     y=xValue;
     z=yValue;
     x=zValue;

     printf("" Getangle \n"" );
     printf("" X = %lf , [BY = %lf , Z = %lf \n "" , x,y,z);
     zaehler =z-x;
     nenner  = (y -((x+z)/2))*(2/sqrt(3)); 
     printf ("" the sin value is  :  %lf  \n"" , zaehler);
     printf (""  the cos value is  : %lf \n"",nenner);
     rad_angle = atan2(nenner,zaehler);
     printf(""Radangle = %lf \n"",rad_angle);
     angle =( rad_angle  * 180/PI);
     printf(""Angle in degree   = %lf \n"",angle);
}
</code></pre>
",0
50940563,50940522,5,"<p>Just for the number of chars in a file you don't have to worry 
<a href=""https://www.google.co.uk/search?q=2%5E64+bytes+in+exabytes"" rel=""nofollow noreferrer"">https://www.google.co.uk/search?q=2%5E64+bytes+in+exabytes</a></p>

<p>That gives 18 exabyte files worth of storage space. </p>

<p>To answer the question directly though. You should look at a library of you need numbers larger that 64 bit</p>

<p>GMP is one I have used many times 
<a href=""https://gmplib.org"" rel=""nofollow noreferrer"">https://gmplib.org</a></p>

<p>As a note 
1 exabyte = 1,000,000 terabytes</p>
",0
57969163,57969054,3,"<p><code>char name[25]</code> (a declaration of an array) does this:</p>

<ul>
<li>Reserves 25 bytes of memory</li>
<li>Declares <code>name</code> as an array of characters (which is almost but not exactly like <code>char *</code>) pointing to that memory.</li>
</ul>

<p><code>char name[25] = ""abcd""</code> (a declaration of an array with an initialiser) does this:</p>

<ul>
<li>Reserves 25 bytes of memory, filled with <code>""abcd\0""</code></li>
<li>Declares <code>name</code> as an array of characters (which is almost but not exactly like <code>char *</code>) pointing to that memory.</li>
</ul>

<p>(The case of <code>name[] = ""abcd""</code> is not a syntax supported by C.)</p>

<p>In both cases, one of the critical differences between pointers and arrays is that the target of a pointer can change; the target of an array cannot. I.e. you can never assign anything to <code>name</code> declared as <code>char[]</code> above, but you can assign to <code>name</code> declared as <code>char *</code>, as follows. <code>char *name; name = ""abcd""</code> (a declaration of a pointer, assignment of a literal character array to a pointer) does this:</p>

<ul>
<li>Reserves 5 bytes of memory, filled by <code>""abcd\0""</code></li>
<li>Declares <code>name</code> as a pointer to character (which is almost but not exactly like <code>char[]</code>) pointing to undefined target</li>
<li>Assigns the address of the memory occupied by <code>""abcd\0""</code> to the variable <code>name</code>.</li>
</ul>
",0
52572330,52571008,0,"<p>Starting in <code>main</code>, <code>int y = 1;</code> creates a local object named <code>y</code> and initializes it to 1.</p>

<p>Then <code>int x = 2;</code> creates a local object named <code>x</code> and initializes it to 2.</p>

<p>Then <code>foo1(&amp;y);</code> calls <code>foo1</code> while passing it the address of <code>y</code>.</p>

<p>In <code>foo1(int *z)</code>, the parameter <code>z</code> is effectively an object local to the function <code>foo1</code>. As <code>foo1</code> starts, <code>z</code> contains the address of <code>y</code>.</p>

<p>Then <code>z = (int *)malloc(sizeof(int));</code> allocates memory and assigns the address of that memory to <code>z</code>. This changes <code>z</code>, so <code>z</code> no longer contains the address of <code>y</code>.</p>

<p>Then <code>*z = 3;</code> puts 3 in the place where <code>z</code> points, which is now the allocated memory. So the contents of the allocated memory change. <code>y</code> does not change because <code>z</code> no longer points to <code>y</code>, since <code>z = (int *)malloc(sizeof(int));</code> changed <code>z</code>.</p>

<p>Then <code>foo1</code> returns and main calls <code>foo2(&amp;x);</code>, which calls <code>foo2</code> while passing it the address of <code>x</code>.</p>

<p>In <code>foo2(int *t)</code>, the parameter <code>t</code> is effectively an object local to the function <code>foo2</code>. As <code>foo2</code> starts, <code>t</code> contains the address of <code>x</code>.</p>

<p>Then <code>*t = 3;</code> puts 3 in the place where <code>t</code> points. Since <code>t</code> points to <code>x</code>, this changes the contents of <code>x</code>, so now <code>x</code> contains 3.</p>

<p>Then <code>foo2</code> returns.</p>

<p>Back inside <code>main</code>, <code>printf(""%d %d"", y, x);</code> prints the contents of <code>y</code> and <code>x</code>. Since <code>y</code> did not change, it is still 1. Since <code>x</code> did change, it is now 3.</p>
",0
52571047,52571008,0,"<pre><code>void foo1(int *z)
{
  z = (int *)malloc(sizeof(int));
  *z = 3;
}
</code></pre>

<p>I am not sure why you are using <code>malloc</code>, but <code>*z</code> ends up pointing to the memory address of the memory you just assigned with the malloc. So overriding the original pointer means the change isn't reflected in the original <code>main()</code> method.</p>

<p>A bit more clear:
You have a pointer <code>* z</code> that is pointing to the <code>y</code> from <code>main()</code>. When you use <code>malloc</code> it returns a pointer, so when you assign that to <code>z</code>, it is now pointing to a <em>different</em> block of memory that has nothing to do with the <code>y</code> from <code>main()</code>. You then assign this new block of memory the value of <code>3</code>. Hence the original <code>y</code> is unchanged.</p>
",2
58671233,58671135,3,"<p>The truth is there is <em>zero</em> reason to use <code>memset</code> + <code>strcpy</code> in this case. In fact if the programmer wanted to ensure that the remaining bytes were zeroed, then <code>strncpy</code> with a conditional for testing if the string fit in entirety into the buffer  should have been used:</p>

<pre><code>strncpy(program_input_string, argv[1], sizeof program_input_string);

// if the last character in the array is not '\0', it means that the
// string did not fit into the array in its entirety, and perhaps 
// the only sensible course of action is to abort the program...
if (program_input_string[sizeof program_input_string - 1] != '\0') {
    fputs(""The argument was too long!"", stderr);
    exit(1);
}
</code></pre>

<p>This has <em>two</em> obvious advantages: it does not set the initial sequence to zero needlessly <em>and</em> it cannot overrun the input buffer - and if the buffer overrun were to happen it will exit with a sensible error message and exit code.</p>

<hr>

<p>Thus the definite answer to the question ""why was this construct used"" would be the all-too-common ""programmer incompetence"".</p>
",0
58671202,58671135,1,"<blockquote>
  <p>I am wondering why memset was used in this particular case, where the next line of code stores the value in the variable that was just set to all 0 by memset. Is there a reason to use memset right before strcpy?</p>
</blockquote>

<p>The particular <code>memset()</code> call presented sets <em>every byte</em> of the destination array to 0.  The <code>strcpy()</code> call, when successful, overwrites only as many bytes as are in the <code>argv[1]</code> string, including the terminator, which may be fewer.  Whether this distinction is in fact important to the program is impossible to determine from the code presented.</p>

<p>Note also that the code presented is subject to buffer overrun -- it is in fact an example of one of the canonical cases for that issue.  If <code>argv[1]</code> is <em>longer</em> than the destination array then undefined behavior ensues.</p>
",0
55833800,55833758,4,"<p>Wrong syntax; should be</p>

<pre><code> extern FPTR funcptr;
</code></pre>

<p>because an <code>extern</code> <a href=""https://en.cppreference.com/w/c/language/declarations"" rel=""nofollow noreferrer"">declaration</a> still needs to mention a type.</p>

<p>And you'll better call it with <code>(*funcptr)()</code> which is at least more readable.</p>
",1
53357821,12343027,1,"<p>In C, you would likely use a macro to define the value of your constant.</p>

<p>The following is an example of what I mean by this.</p>

<pre><code>#define N 5

int main() {
    int array[N];
    // ...
    return 0;
}
</code></pre>
",0
59526650,59526605,2,"<p>The <code>_</code> is the function used by the <a href=""https://en.wikipedia.org/wiki/Gettext"" rel=""nofollow noreferrer"">gettext</a> library to add support for translations. The strings wrapped by <code>_</code> can be modified using data from a translation file for the program so that you can change it at runtime depending on where it's running.</p>
",0
59526637,59526605,1,"<p>It's a macro declared towards the <a href=""https://github.com/c9/node-gnu-tools/blob/master/findutils-src/xargs/xargs.c#L114-L116"" rel=""nofollow noreferrer"">top of the same file</a>.</p>

<p>It's used for internationalization of strings when the appropriate flag is passed at compile time.</p>
",0
55472600,55471965,3,"<blockquote>
  <p>ISO C90 forbids variable length array 'base_symbols'</p>
</blockquote>

<p>There's nothing wrong with the code, you get error this because you are using an old, obsolete compiler. You need to get a modern one such as gcc. </p>

<p>Please note that older versions of gcc did support newer versions of the language if you compiled correctly: <code>gcc -std=c11</code> or <code>gcc -std=c99</code>, but used ""gnu90"" as default, which is C90 + non-standard extensions. Newer versions 5.0 or later default to ""gnu11"".</p>

<p>For example, <code>-ansi</code> means ""give me 30 years old crap mode"" aka C90. Unless you really need C90 for backwards-compatibility reasons, you should be using <code>gcc -std=c17 -pedantic-errors -Wall -Wextra</code>.</p>

<p><a href=""https://stackoverflow.com/questions/17206568/what-is-the-difference-between-c-c99-ansi-c-and-gnu-c"">What is the difference between C, C99, ANSI C and GNU C?</a></p>
",1
48241963,48241903,4,"<p>You can do it using an approach similar to binary search: first compare to <code>65536</code>, then either to 256 or 16777216, depending on the outcome of the first comparison. This way you always finish in two comparisons, while your code sometimes would require three:</p>

<pre><code>uint8 len = (addr &lt; 65536)
    ? ((addr &lt; 256)      ? 1 : 2)
    : ((addr &lt; 16777216) ? 3 : 4);
</code></pre>
",4
48254081,48251570,1,"<p>Assuming a machine with <code>sizeof(int) == 4</code> and <code>CHAR_BITS == 8</code> (so <code>sizeof(int) &gt; sizeof(uint16_t)</code>, the C standard stipulates that:</p>

<pre><code>crc = crc ^ (uint16_t)data &lt;&lt; 8;
</code></pre>

<p>undergoes the 'usual arithmetic conversions', and is treated more or less as though you'd written (the <code>8</code> is already an <code>int</code> so it doesn't get converted):</p>

<pre><code>crc = (uint16_t)( ((int)crc) ^ (((int)((uint16_t)data)) &lt;&lt; 8) );
</code></pre>

<p>And it is the assignment of the <code>int</code> result of the xor operator in the assignment to the <code>uint16_t</code> variable <code>crc</code> that triggers (accurately) the warning.</p>

<p>Similar remarks apply to each of the two other lines marked.</p>

<p>If you were working on a machine where <code>sizeof(int) == sizeof(uint16_t)</code>, you would not be getting the warnings in the first place.</p>

<p><a href=""https://port70.net/~nsz/c/c11/n1570.html#6.3.1.8"" rel=""nofollow noreferrer"">6.3.1.8 Usual arithmetic conversions</a>:</p>

<blockquote>
  <p>?1 Many operators that expect operands of arithmetic type cause conversions and yield result
  types in a similar way. The purpose is to determine a common real type for the operands
  and result. For the specified operands, each operand is converted, without change of type
  domain, to a type whose corresponding real type is the common real type. Unless
  explicitly stated otherwise, the common real type is also the corresponding real type of
  the result, whose type domain is the type domain of the operands if they are the same,
  and complex otherwise. This pattern is called the <em>usual arithmetic conversions</em>:</p>
  
  <ul>
  <li><p><em>¡­floating point omitted¡­</em></p></li>
  <li><p>Otherwise, the integer promotions are performed on both operands. Then the
  following rules are applied to the promoted operands:</p>
  
  <ul>
  <li><p>If both operands have the same type, then no further conversion is needed.</p></li>
  <li><p>Otherwise, if both operands have signed integer types or both have unsigned
  integer types, the operand with the type of lesser integer conversion rank is
  converted to the type of the operand with greater rank.</p></li>
  <li><p>Otherwise, if the operand that has unsigned integer type has rank greater or
  equal to the rank of the type of the other operand, then the operand with
  signed integer type is converted to the type of the operand with unsigned
  integer type.</p></li>
  <li><p>Otherwise, if the type of the operand with signed integer type can represent
  all of the values of the type of the operand with unsigned integer type, then
  the operand with unsigned integer type is converted to the type of the
  operand with signed integer type.</p></li>
  <li>Otherwise, both operands are converted to the unsigned integer type
  corresponding to the type of the operand with signed integer type.</li>
  </ul></li>
  </ul>
</blockquote>

<p>And <a href=""https://port70.net/~nsz/c/c11/n1570.html#6.3.1.1"" rel=""nofollow noreferrer"">6.3.1.1 Boolean, characters, and integers</a> says:</p>

<blockquote>
  <p>?2 ¡­?If an <code>int</code> can represent all values of the original type (as restricted by the width, for a
  bit-field), the value is converted to an <code>int</code>; otherwise, it is converted to an <code>unsigned
  int</code>. These are called the <em>integer promotions</em>.<sup>58)</sup> All other types are unchanged by the
  integer promotions.</p>
  
  <p><sup>58)</sup> The integer promotions are applied only: as part of the usual arithmetic conversions, to certain
  argument expressions, to the operands of the unary <code>+</code>, <code>-</code>, and <code>~</code> operators, and to both operands of the
  shift operators, as specified by their respective subclauses.</p>
</blockquote>

<p>¡ì6.3.1.1?1 defines 'rank' in excruciating detail, but basically bigger types have a higher rank than smaller types (so <code>long</code> has a higher rank than <code>signed char</code>).</p>

<p>You can then find the specifications for the various operators:</p>

<p><a href=""https://port70.net/~nsz/c/c11/n1570.html#6.5.7"" rel=""nofollow noreferrer"">6.5.7 Bitwise shift operators</a>:</p>

<blockquote>
  <p>Each of the operands shall have integer type.</p>
  
  <p>The integer promotions are performed on each of the operands. The type of the result is that of the promoted left operand.</p>
</blockquote>

<p><a href=""https://port70.net/~nsz/c/c11/n1570.html#6.5.11"" rel=""nofollow noreferrer"">6.5.11 Bitwise exclusive OR operator</a>:</p>

<blockquote>
  <p>Each of the operands shall have integer type.</p>
  
  <p>The usual arithmetic conversions are performed on the operands.</p>
</blockquote>

<p><a href=""https://port70.net/~nsz/c/c11/n1570.html#6.5.16"" rel=""nofollow noreferrer"">6.5.16 Assignment operators</a></p>

<blockquote>
  <p>An assignment operator stores a value in the object designated by the left operand. An assignment expression has the value of the left operand after the assignment,<sup>111)</sup> but is not an lvalue. The type of an assignment expression is the type the left operand would have after lvalue conversion.</p>
  
  <p><sup>111)</sup> The implementation is permitted to read the object to determine the value but is not required to, even
  when the object has volatile-qualified type.</p>
</blockquote>

<p><a href=""https://port70.net/~nsz/c/c11/n1570.html#6.5.16.1"" rel=""nofollow noreferrer"">6.5.16.1 Simple assignment</a>:</p>

<blockquote>
  <p>In simple assignment (<code>=</code>), the value of the right operand is converted to the type of the
  assignment expression and replaces the value stored in the object designated by the left
  operand.</p>
</blockquote>
",0
56237777,56237736,3,"<p>You're returning a pointer to a local. Dereferencing a pointer after the end of its target's lifetime is <em>undefined behavior</em>.</p>

<p>Your <code>dictCreate</code> should heap-allocate the <code>Dictionary</code> structure as well (in addition to heap-allocating the <code>int</code> array).</p>
",1
50381334,50381275,0,"<p>The marked line seems odd:</p>

<pre><code>ret = sgx_unseal_data(
              (sgx_sealed_data_t*)sealed_data,
              NULL,
              NULL,
              (uint8_t*)&amp;resecret,    // Probably shouldn't use address-of (&amp;) here?
              (uint32_t*)&amp;resecret_size);
</code></pre>

<p>I believe the call should be:</p>

<pre><code>ret = sgx_unseal_data(
              (sgx_sealed_data_t*)sealed_data,
              NULL,
              NULL,
              (uint8_t*)resecret,                  
              (uint32_t*)&amp;resecret_size);
</code></pre>
",0
56881090,56880769,5,"<p>You keep multiplying an accumulator by 0.999915454854432f, thus bringing the value closer and closer to zero. You might be getting so close to zero that it becomes a <a href=""https://en.wikipedia.org/wiki/Denormal_number"" rel=""noreferrer""><em>denormal</em></a> representation. That may trigger slower execution in the floating point hardware and can be a source of surprising performance bloat. Just a wild guess!</p>

<p>See the ""Performance Issues"" section in the above Wikipedia page.</p>
",1
49809957,49809907,4,"<p>You can use forward declaration of the <code>struct</code> to do that.</p>

<pre><code>// Forward declaration of the struct
struct Task_t;
typedef void (*tFunc_t)(struct Task_t*);
</code></pre>

<p>You don't need to use <code>pTask_t</code> to define the <code>typedef</code> for the function pointer.</p>
",0
56398956,56398362,0,"<p>Suppose you want to type pun types <code>X</code> and <code>Y</code>, you should use the union - </p>

<pre><code>typedef union {
    X x;
    Y y;
}X_Y;
</code></pre>

<p>This allows you to share the bit representation of X with Y and vice versa. 
If you use - </p>

<pre><code>typedef union {
    X* x;
    Y* y;
}X_Y_p;
</code></pre>

<p>you are sharing the bit representations for the pointer. For a system that uses the same bit representation for all pointer, you are essentially casting pointer of <code>X</code> to pointer of <code>Y</code>, which you identified causes Undefined Behaviour. </p>

<p>It is not illegal to have something <code>X_Y_p</code> because <code>X*</code> and <code>Y*</code> are types by themselves. But they achieve something different. They let you type pun pointers, which is not what you want to do (and not necessary in most cases, because pointers share representation on <em>most</em> systems). A cast should be fine there. </p>
",0
56598755,56598648,3,"<p>This should be possible with one extra round of expansion:</p>

<pre><code>#define CONCATENATE(x) CONCATENATE2(x)
#define CONCATENATE2(x) _TEST_ ## x ## _CLK_ENABLE ()
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/3605299b273838c2"" rel=""nofollow noreferrer"">[Live example]</a></p>

<p>The extra indirection is necessary to force the argument itself (e.g. <code>ABC</code>) to be expanded. Without it, we'd end up with <code>_TEST_ABC()</code>.</p>
",3
55589024,55587802,0,"<p>as KamilCuk mentioned, I don't know why he deleted the comment.</p>

<p>left shift signed int is undefined behavior. and shifting unsigned short more that 16 is also undefined, as unsigned short is 16 bits. So I have to dealing these edges.</p>
",0
50430422,50430284,3,"<p>Classically, the values for <code>stdin</code>, <code>stdout</code> and <code>stderr</code> were <a href=""https://stackoverflow.com/questions/50428935"">variations on the theme of</a>:</p>

<pre><code>#define stdin (&amp;__iob[0])
#define stdout (&amp;__iob[1])
#define stderr (&amp;__iob[2])
</code></pre>

<p>These are address constants and can be used in initializers for variables at file scope:</p>

<pre><code>static FILE *def_out = stdout;
</code></pre>

<p>However, the C standard does not guarantee that the values are address constants that can be used like that <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21"" rel=""nofollow noreferrer"">C11 ¡ì7.21 Input/output <code>&lt;stdio.h.&gt;</code></a>:</p>

<blockquote>
  <p><code>stderr</code>,  <code>stdin</code>, <code>stdout</code><br>
  which are expressions of type ''pointer to FILE'' that point to the FILE objects associated, respectively, with the standard error, input, and output streams.</p>
</blockquote>

<p>Sometime a decade or more ago, the GNU C Library changed their definitions so that you could no longer use <code>stdin</code>, <code>stdout</code> or <code>stderr</code> as initializers for variables at file scope, or <code>static</code> variables with function scope (though you can use them to initialize automatic variables in a function).  So, old code that had worked for ages on many systems stopped working on Linux.</p>

<p>The macro expansion of <code>stdin</code> etc is either a simple identity expansion (<code>#define stdin stdin</code>) or equivalent (on macOS, <code>#define stdout __stdoutp</code>).  These are variables, not address constants, so you can't copy the value of the variable in the file scope initializer.  It is a nuisance, but the standard doesn't say they're address constants, so it is legitimate.</p>

<p>They're required to be macros because they always were macros, so it retains that much backwards compatibility with the dawn of the standard I/O library (circa 1978, long before there was a standard C library per se).</p>
",0
54642269,32038108,4,"<p>By definition the C <code>time()</code> function returns a <code>time_t</code> epoch time in UTC.  So the code commented ""//get the local time in time_t"" is really getting UTC already, and the comment is incorrect.</p>

<p>From the Linux man-page:</p>

<blockquote>
  <p><strong>time_t time(time_t *tloc);</strong><br>
  time() returns the time as the number of seconds since the Epoch, 1970-01-01 00:00:00 +0000 (<strong>UTC</strong>).</p>
</blockquote>

<p>Giving the code:</p>

<pre><code>#include &lt;time.h&gt;

...

time_t utc_now = time( NULL );
</code></pre>
",0
49808446,49808402,2,"<p><code>sizeof</code> just gets the size based on the type declaration. It doesn't care about the contents, and it's calculated at compile time. </p>

<p><code>strlen()</code> has to scan the array looking for the null byte, as you said. This is <code>O(n)</code>.</p>

<p>They give different answers.</p>

<pre><code>char s[1000] = ""abc"";
printf(""sizeof = %d strlen = %d\n"", sizeof s, strlen(s)); // prints 1000 and 3
strcpy(s, ""1234567890123456789012345678901234567890"");
printf(""sizeof = %d strlen = %d\n"", sizeof s, strlen(s)); // prints 1000 and 40
</code></pre>

<p>If you call <code>strlen()</code> on a string literal, the compiler can optimize it and calculate the size at compile time. So <code>strlen(""foo"")</code> will likely be <code>O(1)</code>.</p>
",3
49008399,49006496,2,"<p>You forgot to include an extra byte for null terminators in your array. If <code>LIMITE_CARACTERES</code> is the maximum length of a string provided as input, then you need an array of size <code>LIMITE_CARACTERES + 1</code> in which to store it. So you need to change this line</p>

<pre><code>char genes[LIMITE_GENES][LIMITE_CARACTERES];
</code></pre>

<p>to</p>

<pre><code>char genes[LIMITE_GENES][LIMITE_CARACTERES + 1];
</code></pre>
",1
51587121,51587092,3,"<pre><code>#define linear
</code></pre>

<p>will <em>make</em> it syntactically correct even if it wasn't before (though, technically, you'd probably want a <code>#undef linear</code> beforehand to avoid possible conflicting macro definitions).</p>

<p>It depends entirely on the <em>context</em> of the code, which you haven't shown. As it stands now, with no header inclusions or definitions like <code>-Dlinear=</code> on the compiler command line, it would not compile in a standards-conformant environment without extensions.</p>

<p>The best way to tell, of course, is to just try to actually compile the thing and see what happens :-)</p>

<p>Given that the <a href=""https://users.ipfw.edu/chansavj/ACY2017/ANSI_C/ANSI_C_4thEd/Solutions%20to%20Exercises%20(Windows)/Solutions/83556-0s/Ch13/pgm13-5ex3.c"" rel=""nofollow noreferrer"">solutions link</a> for chapter 13 (the one you're asking about) has <em>no</em> mention of the <code>linear</code> word in the solution, I'd say it's a safe bet to assume your book is incorrect. I'd consider contacting the author (apparently currently working at FDU in New Jersey) to clear it up.</p>
",1
54549151,54549121,1,"<p>It is a strcture that wraps a function-pointer.</p>

<p>Have a look here: <a href=""https://stackoverflow.com/questions/840501/how-do-function-pointers-in-c-work"">How do function pointers in C work?</a></p>
",0
54549146,54549121,2,"<p>It is a <a href=""https://www.geeksforgeeks.org/function-pointer-in-c/"" rel=""nofollow noreferrer"">function pointer</a>. They are powerful and quite hard to get your head around if you are a beginner.</p>
",0
54520194,54520169,5,"<p>You would use bitwise operators and bit shifting.</p>

<pre><code>uint16_t result = ((uint16_t)Buffer[0] &lt;&lt; 8) | Buffer[1];
</code></pre>

<p>This does the following:</p>

<ul>
<li>The value of <code>Buffer[0]</code> is shifted 8 bits to the left.  That gives you 0x0800</li>
<li>A bitwise OR is performed between the prior value and the value of <code>Buffer[1]</code>.  This sets the low order 8 bits to <code>Buffer[1]</code>, giving you 0x0806</li>
</ul>
",5
54520243,54520169,1,"<p>Here's a macro I use for this very thing:</p>

<pre><code>#include &lt;stdint.h&gt;

#define MAKE16(a8, b8) ((uint16_t)(((uint8_t)(((uint32_t)(a8)) &amp; 0xff)) | ((uint16_t)((uint8_t)(((uint32_t)(b8)) &amp; 0xff))) &lt;&lt; 8))
</code></pre>
",0
52698473,52698324,3,"<p>If you do not use the correct enabling macro (<code>_POSIX_C_SOURCE</code> according to <a href=""http://man7.org/linux/man-pages/man3/strtok_r.3.html"" rel=""nofollow noreferrer"">the manual page</a>) then the function will not be automatically declared. That means the compiler must deduce the argument types, and more importantly the return type will automatically be <code>int</code> (as noted in the second warning message).</p>

<p>If the argument types or the return type are wrong, then that call will lead to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>, and very likely crashes.</p>

<p>By adding the correct macros, the function will be properly declared in the header file, and the correct types for arguments and returned value will be used.</p>

<hr>

<p>The problem here is probably the mismatched return type. On a 64-bit system pointers (like e.g. <code>char *</code>) are 64 bits wide, while <code>int</code> is usually only 32 bits wide. This mismatch in sizes will cause many pointers to be wrong, and attempting to use them is a great source of segmentation faults.</p>
",3
48750247,48749562,2,"<p>This won't give you arbitrary chaining, but assuming that you're writing the code manually, and not in auto-generated code, and thus probably won't chain calls beyond a certain point, you can do something like:</p>

<pre><code>#include &lt;stdio.h&gt;

typedef void (*ftype10)(char *s);
typedef ftype10 (*ftype9)(char *s);
typedef ftype9 (*ftype8)(char *s);
typedef ftype8 (*ftype7)(char *s);
typedef ftype7 (*ftype6)(char *s);
typedef ftype6 (*ftype5)(char *s);
typedef ftype5 (*ftype4)(char *s);
typedef ftype4 (*ftype3)(char *s);
typedef ftype3 (*ftype2)(char *s);
typedef ftype2 (*ftype1)(char *s);
typedef ftype1 (*ftype)(char *s);

ftype logs(char *s) {
    printf(""%s\n"", s);
    fflush(0);
    return (ftype)&amp;logs;
}

int main() {
    logs(""line1"")(""line2"")(""line3"");
    return 0;
}
</code></pre>
",0
48749761,48749562,4,"<p>You can't do such a recursive type definition in C. But mutual recursion is possible - you can chain by returning a <code>struct</code> that will contain pointer to the function as a member:</p>

<pre><code>#include &lt;stdio.h&gt;

struct foo {
    struct foo (*logs)(char *);
};

struct foo logs(char *arg) {
    puts(arg);
    return (struct foo){ logs };
}

int main() {
    logs(""foo"").logs(""bar"");
}
</code></pre>

<hr>

<p>However, this is hardly useful in <em>your</em> case; nor in any other general case, since the <code>foo</code> doesn't get passed in as <code>this</code>, so you'd just end up typing <code>.</code> instead of <code>;</code>.</p>

<p>I could see it only useful in only those cases where the function <em>wouldn't</em> always return itself ;)</p>

<p>Perhaps you'd want to use <em>variable arguments</em> instead.</p>
",0
54134904,54134793,3,"<p>In the original code, <code>Cpp_Token_Type</code> is a <code>uint32_t</code>, whereas in your simplification <code>Cpp_Token_Type</code> is an <code>enum</code> type. If you were to create a variable of type <code>Cpp_Token_Type</code> it would behave quite differently in the two cases. E.g., in your example, <code>t</code> is signed with your definition, unsigned in the original.</p>
",4
54060369,54060312,3,"<p>The behavior is entirely unpredictable. Zero is just as much garbage in this context as anything else. By the way, I happen to get different results:</p>

<pre><code>$ cat a.c
#include &lt;stdio.h&gt;

void f1() {
    int a;
    printf (""f1: a = %d\n"",a);
}

void f2() {
    int a;
    printf (""f2: a = %d\n"",a);
    int *b = &amp;a;
    printf(""f2: *b = %d\n"",*b);
}

int main()
{
    f1();
    f2();
}

$ gcc a.c -O2 -o a
$ ./a
f1: a = 0
f2: a = 0
f2: *b = 0

$ gcc a.c -o a
$ ./a
f1: a = 22011
f2: a = 22011
f2: *b = 22011
</code></pre>
",2
54060528,54060312,0,"<p>There's no automatic initialization of <code>automatic</code> (<code>local</code> in your parlance) variables in C.</p>

<p>Your options:</p>

<ol>
<li>don't use C (maybe not even C++ as it has a similar issue)</li>
<li>initialize each of them as needed whether you like it or not</li>
<li>if the structure and logic of your code permit, make them <code>static</code> (or even move them outside of the function body) and they will become initialized to 0 (or NULL) at program start</li>
<li>define a structure containing all of those variables, then do <code>memset(&amp;structure, 0, sizeof structure);</code> on it</li>
</ol>

<p>There really isn't a way around <em>undefined behavior</em> as it has already been mentioned by others. You must avoid it (for that you'll need to learn what triggers it, there's much more to it than uninitialized variables).</p>
",0
50492929,50492891,3,"<p><strong>Don't bother.</strong> The compiler optimizes better than you could. </p>

<p><strike>You might perhaps try</p>

<pre><code>len = ((len - 1) &amp; 0x3f) + 1;
</code></pre>

<p>(but when <code>len</code> is 0 -or 65, etc...- this might not give what you want)</strike></p>

<p>If that is so important for you, benchmark!</p>
",1
50494811,50492891,3,"<p>I created a program</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    unsigned int len;
    scanf(""%u"", &amp;len);
    len = len &gt; 64 ? 64 : len;
    printf(""%u\n"", len);
}
</code></pre>

<p>and compiled with <code>gcc -O3</code> and it generated this assembly:</p>

<pre><code>cmpl    $64, 4(%rsp)
movl    $64, %edx
leaq    .LC1(%rip), %rsi
cmovbe  4(%rsp), %edx
</code></pre>

<p>the <code>leaq</code> there loads the <code>""%u\n""</code> string in between - I presume it is because the timing of the instructions. The generated code seems pretty efficient. There are no jumps, just a conditional move. No <a href=""https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array"">branch prediction failure</a>.</p>

<p>So the best way to optimize your executable is to get a good compiler.</p>
",0
53948981,53948551,3,"<p>In a windowing operating system or execution environment the console window will close immediately the process terminates, so it is not clear what you are asking here since in your example the program terminates regardless of what input is entered.</p>

<p>If you are running the code from an IDE, often the IDE will create a console process and launch your code within that.  In that case the console is not <em>""owned""</em> by your application, but is executed as a <em>child</em> process; in which case the window will remain open until the parent process launched by the IDE is closed.  Similarly if you launch your program from a command shell.  It is probably unreasonable behaviour for a process to attempt to close its parent even if it is possible.</p>

<p>It is possible to <em>""hide""</em> the console window while the process continues to run, which may be what you are asking; the means of doing that is platform specific, and you have not specified; for Windows such a question would be a duplicate of <a href=""https://stackoverflow.com/questions/622592/win32-programming-hiding-console-window"">Win32 programming hiding console window</a>.  However it is quite possible that these methods will not work if the process is not launched directly but from some other console process.</p>
",0
53948625,53948551,4,"<p>The C11 standard <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">n1570</a> does not know about the ""console screen"" (and I guess you speak of the <a href=""https://en.wikipedia.org/wiki/Terminal_emulator"" rel=""nofollow noreferrer"">terminal emulator</a> running your program). Notice that C11 does not mention ""screens"" or ""keyboards"" (only <a href=""https://en.wikipedia.org/wiki/Standard_streams"" rel=""nofollow noreferrer"">standard streams</a>, and very often <a href=""https://en.cppreference.com/w/c/io"" rel=""nofollow noreferrer""><code>stdout</code></a> is <em>not</em> a ""console"") and many computers (e.g. most Internet servers or supercomputers, or even your mobile phone...) don't have both. Also, your program could be run (even on Windows) with <a href=""https://en.wikipedia.org/wiki/Redirection_(computing)"" rel=""nofollow noreferrer"">redirections</a> or in a <a href=""https://en.wikipedia.org/wiki/Pipeline_(Unix)"" rel=""nofollow noreferrer"">pipeline</a> and then it has no console (so your question don't make any sense in such a common case).</p>

<p>So in general, <strong>there is no way to do what you want</strong> (since it does not make any sense), in a standard way.</p>

<p>Perhaps your <a href=""https://en.wikipedia.org/wiki/Operating_system"" rel=""nofollow noreferrer""><em>operating system</em></a> provide some (OS specific) way to achieve that. So investigate the OS API relevant to your system (e.g. <a href=""https://docs.microsoft.com/en-us/windows/desktop/apiindex/windows-api-list"" rel=""nofollow noreferrer"">WinAPI</a> on Windows, or Linux syscalls -listed in <a href=""http://man7.org/linux/man-pages/man2/syscalls.2.html"" rel=""nofollow noreferrer"">syscalls(2)</a>).</p>

<p>Perhaps you want to use some terminal related library like <a href=""https://www.gnu.org/software/ncurses/"" rel=""nofollow noreferrer"">ncurses</a>.</p>

<p>If your terminal follows the <a href=""https://en.wikipedia.org/wiki/ANSI_escape_code"" rel=""nofollow noreferrer"">ANSI escape code</a> conventions, you might follow them.</p>

<p>Otherwise, consider making your program having some <a href=""https://en.wikipedia.org/wiki/Graphical_user_interface"" rel=""nofollow noreferrer"">GUI</a>. For that, you practically need some <a href=""https://en.wikipedia.org/wiki/Widget_toolkit"" rel=""nofollow noreferrer"">widget toolkit</a> (such as <a href=""https://at.io/"" rel=""nofollow noreferrer"">Qt</a>, <a href=""https://gtk.org/"" rel=""nofollow noreferrer"">GTK</a>, etc..)</p>

<p>You might also consider some <a href=""https://en.wikipedia.org/wiki/Inter-process_communication"" rel=""nofollow noreferrer"">inter-process communication</a> with your <a href=""https://en.wikipedia.org/wiki/Desktop_environment"" rel=""nofollow noreferrer"">desktop environment</a>. How to do that (or even its possibility) is very operating-system and desktop specific and might be related to <a href=""https://en.wikipedia.org/wiki/Session_(computer_science)"" rel=""nofollow noreferrer"">session</a> management.</p>

<p>BTW, remember that <code>stdout</code> is often buffered (and perhaps line-buffered). You'll better end your <code>printf</code> control strings with <code>\n</code> and/or call <a href=""https://en.cppreference.com/w/c/io/fflush"" rel=""nofollow noreferrer"">fflush</a>.</p>
",4
51750637,16220983,1,"<p>From Hacker's Delight 2-6. Assuming 5 bits of data that must be sign extended (sign bit has value 16).</p>

<p>Best case: If the upper bits are all zeros:</p>

<pre><code>(i ^ 16) - 16
</code></pre>

<p>Next best case (as with OP's <code>instruction</code>): If the upper bits contain data that must be discarded:</p>

<pre><code>(i &amp; 15) - (i &amp; 16)
</code></pre>
",0
54014720,54014666,1,"<p>With <code>extern struct myStruct structure;</code> there will be an entry in the symbol table pointing to <code>structure</code>
and it will be keyed to the string <code>structure</code>.</p>

<p>To get the address of its b member, you simply do:</p>

<pre><code>struct myStruct *p = dlsym(handle, ""structure"");
if(!p) fail();
int *pb = &amp;p-&gt;b;
</code></pre>
",0
50539103,33058848,0,"<p>Similar to other answers, with a few improvements you might need to keep your code a bit safer and coherent:</p>

<pre><code>#include &lt;stdlib.h&gt; /* srand and rand */
#include &lt;unistd.h&gt; /* getpid */
#include &lt;time.h&gt; /* time */
#include &lt;errno.h&gt; /* errno */
#include &lt;math.h&gt; /* NAN  */

/* generate a float random number in a range */
float randmm(float min, float max)
{
     static int first = -1;
     if((first = (first&lt;0)))
         srand(time(NULL)+getpid());
     if(min&gt;=max)
         return errno=EDOM, NAN;

     return min + (float)rand() / ((float)RAND_MAX / (max - min));
}
</code></pre>

<p>Going through the code we have:</p>

<ul>
<li>A static variable <code>first</code> that will guarantee you don't forget to seed the pseudo-random number generator (PRNG). The logic is simple and elegant: in the first call, <code>first</code> is -1, it is then compared to be less than zero, which updates it to <strong>true</strong> (value 1). The second call asks if <code>first</code>, now 1, is less than zero, which is <strong>false</strong> (value 0), so <code>srand()</code> isn't called. Third is a charm, they say, so now <code>first</code>, which is 0, is asked if it is less than zero, which keeps being false for this and the next iterations.</li>
<li>Next, you might need to guarantee that min-max is not zero, or else you will get a nasty division by zero (or NAN). For that we shall explicitly cause the correct error. Using <code>errno.h</code> to set the error and <code>math.h</code> to have <code>NAN</code> (not a number) macro available. It is not advisable to compare two floats for equality (like <code>if(min==max)</code>) so it is not a good idea to try to invert the min/max values in case min is greater, and have a third option in case they are equal. Just simplify your <code>if</code> with only two options: it is right, or it is not.</li>
<li>Finally, I've preferred to work with <code>float</code> instead of <code>double</code> to not give too much trust on what this function can generate. A 32 bits integer (which is <code>RAND_MAX</code>) can only do so much. To fill a <code>float</code> is reasonable, for all bits. <code>float</code> has only 23 bits for the number, plus 8 for exponent. If you use <code>double</code> you will be mislead and overconfident in the capacity of this function. If you need a true double, consider using <code>/dev/urand</code> or other proper <strong>true random number generator</strong> (TRNG).</li>
<li>The last line, the return, is just a simple equation. I guess you can figure that out easily. I just like to explicitly cast to <code>float</code> so I can see the code's intention besides the compiler's interpretation.</li>
<li>And of course, to use as OP want, just call as <code>float x = randmm(-1.0, 1.0);</code></li>
</ul>
",3
48158591,48157994,3,"<p>You should consider the possibility of giving the 7-argument and 11-argument forms of <code>LCD_Attach</code> different names; then you can use normal argument lists for both.  That will be more maintainable and will catch more problems at compile time.</p>

<p>However, what you asked for can be done.  If all of the variadic arguments to <code>LCD_Attach</code> have the same type, you can use the argument-counting technique from <a href=""https://stackoverflow.com/a/2124433/388520"">this old answer</a> plus C11's <code>static_assert</code>:</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;stdarg.h&gt;

// Replace `int` in this macro with whatever the concrete type of all
// the arguments to `LCD_Attach` actually is.
#define NUMARGS(...)  (sizeof((int[]){__VA_ARGS__})/sizeof(int))

#define LCD_Attach(...) do { \
  static_assert(NUMARGS(__VA_ARGS__) == 7 || NUMARGS(__VA_ARGS__) == 11, \
                ""wrong number of arguments to LCD_Attach""); \
  LCD_Attach(NUMARGS(__VA_ARGS__), __VA_ARGS__); \
} while (0)

void (LCD_Attach)(int num, ...)
{
   assert(num == 7 || num == 11); // runtime backstop, should never fire
   va_list ap;
   va_start(ap, num);
   if (num == 7) {
     // do something
   } else {
     // do something else
   }
   va_end(ap);
}

void test_7(void) { LCD_Attach(1, 2, 3, 4, 5, 6, 7); }
void test_11(void) { LCD_Attach(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11); }
void test_wrong(void) { LCD_Attach(1, 2, 3, 4, 5, 6); }
</code></pre>

<p>=></p>

<pre><code>$ gcc -fsyntax-only -std=c11 -pedantic -Wall test.c
In file included from test.c:1:0:
test.c: In function ¡®test_wrong¡¯:
test.c:10:3: error: static assertion failed:
  ""wrong number of arguments to LCD_Attach""
   static_assert(NUMARGS(__VA_ARGS__) == 7 || NUMARGS(__VA_ARGS__) == 11, \
   ^
test.c:31:25: note: in expansion of macro ¡®LCD_Attach¡¯
 void test_wrong(void) { LCD_Attach(1, 2, 3, 4, 5, 6); }
                         ^~~~~~~~~~
</code></pre>

<p>If they don't all have the same type, you have to use the more complicated argument-counting technique from <a href=""https://stackoverflow.com/a/2124385/388520"">this other answer to the same question</a>, but the principle is the same.</p>
",0
49684803,49684764,1,"<p>Not at all tested, but I think this recursive solution is approximately right:</p>

<pre><code>int get_pointer(void* p, int n)
{
    if (n==1) return *p;
    return get_pointer((void*)(*(int*)p), n-1);
}
</code></pre>
",0
52703598,52703470,2,"<p>The <code>sprintf</code> call writes a total of 10 characters to the memory starting at <code>&amp;s[0]</code>, which only has space for 9. This is Undefined Behavior, meaning anything at all might happen.</p>

<p>In practice, it's likely some other variable with static storage duration comes immediately after the storage for <code>s</code>, and that value is being overwritten.  Or possibly it's some of the data used internally by the program to keep track of whether a function-local <code>static</code> variable has already been initialized or needs its first-time initialization.  The order of your C code can change how the compiler decides to place this data within the program, which is likely why changing that order gave you those different results.</p>
",0
52703609,52703470,2,"<p>Overflow by one error: the ""%02d:%02d:%02d%c"" does indeed format 9 characters, providing each %d value doesn't overflow.The problem comes when sprintf() adds its own \0 making a total of 10 characters.  </p>

<p>This extra \0 overflows s[9] and wacks whatever follows it. Such ""slight overflows"" result in undefined behavior... it depends on what the compiler put after the array, which depends on where the variables are in memory. Everything from not being noticed to segment faults can occur.</p>

<p>Overflows of static memory, with the longest lifespan, are more likely to be noticed. It depends on something referencing the corrupted memory with a byte that has become zero. If this is the first character of another string then the overwritten string becomes zero-length. </p>
",2
52703575,52703470,3,"<p>You're writing past the end of the array.</p>

<p><code>s</code> contains 9 characters.  Your format string will write a total of 10 bytes: 2 digits, <code>:</code>, 2 digits, <code>:</code>, 2 digits, an explicit 0 byte, and an implicit 0 byte.  So you write off the end of the array.  Doing so invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.  This manifested in your program appearing to work before moving the variable, and an unrelated variable being changes after you moved it.</p>

<p>The problem can be fixed by either making <code>s</code> large enough to hold the extra character, or by removing the extra character from your format string which isn't needed.</p>
",2
49485255,49484809,4,"<p>From a performance standpoint, separating in sub-structures may increase wasted space in the &quot;parent&quot; structure, as alignment and padding requirements will have to be evaluated singularly for each substructure instead of globally (unless the compiler can prove that there's no layout-compatible <code>struct</code> around that may be used to alias these sub-members).</p>
<p>Example:</p>
<pre><code>struct Nested {
    int a;
    struct {
        int c;
        double d;
    } b;
};
</code></pre>
<p>On most common modern machines will be placed in memory like</p>
<pre><code>0x00 a
0x04 (padding)
0x08 b.c
0x0c (padding)
0x10 b.d
Total: 0x18 bytes
</code></pre>
<p>while the equivalent &quot;flattened&quot; structure</p>
<pre><code>struct Flattened {
    int a;
    int c;
    double d;
};
</code></pre>
<p>will have all its members contiguous.</p>
<pre><code>0x00 a
0x04 c
0x08 d
Total: 0x10 bytes 
</code></pre>
<hr />
<p>This is pretty much the only performance pitfall I can think of. The most important thing to actually evaluate is the usability cost. Deeply nested sub-structures are <em>generally</em> more verbose to use, so you should reflect on <em>why</em> are you doing this and if it's actually worth it.</p>
<p>Are these entities that stand on their own, without the main structure? As in, your client code may want to make a copy of (or take a pointer to) one of them? Then take their definition out of your parent struct and give them a name. This is the usual case, and I see no problem to nest <em>instances</em> as much as you want - that's what actually what happens when you do OOP. Also notice that if you have pointers and stuff to be initialized in each structure you should probably provide some function to do so (in a similar way to how constructors are used in OO languages) to avoid replicating tedious code all around.</p>
<p>Do you need to exploit in some way the fact that are in facts structs - for example you have an array of them as a member (or, in C++, you want to exploit the automatic definition of the copy constructor for most of your members)? Then you may be OK, although again, not exporting a definite name is being evil towards your clients (what if they want a pointer to one of these objects to save some typing?).</p>
<p>Are you using them inside a (tagged) <code>union</code>, as &quot;alternative active types&quot;? That's a legitimate use case - although just for the first level!</p>
<p>Are you grouping stuff just for the sake of grouping? Then think twice, <a href=""https://punchlet.wordpress.com/2011/06/18/letter-the-sixth-belatedly/"" rel=""nofollow noreferrer"">you may be falling in a similar trap as what happens sometimes with (C++) namespaces</a>:</p>
<blockquote>
<p>Why can we not take advantage of our patient¡¯s mania for hierarchy? Can we not encourage them to write code like this:</p>
<pre><code>namespace MyLibrary {
    namespace Useful {
        namespace Utility {
           int f();
        }
        namespace Business {
           int f();
           namespace Utility {
                int f();
           }
       }
    }
}
</code></pre>
<p>It turns out that almost no encouragement is needed. Humans apparently actually like writing stuff like this:</p>
<pre><code>MyLibrary::Useful::Business::Utility::f();
</code></pre>
<p>and when they have done so seem to think they have done something profound. The thought of naming the functions so that their own names are distinct seems repellent to them. And even when the names are distinct, and there is absolutely no reason to use these ludicrous constructs, they will still embrace them as they would long-lost lovers.</p>
</blockquote>
<p>Over-categorizing stuff is way overrated.</p>
",0
56098540,56098462,0,"<p>You can simply store the values in the <code>void*</code>, rather than their address:</p>

<pre><code>expr.l_var = (void*)motor_rt_params[0].position;
expr.r_var = (void*)motor_rt_params[1].position;
</code></pre>

<p>Then to use them, cast to <code>intptr_t</code> (values, not pointers).  These types are guaranteed to be the same width as a pointer, so you won't need to care anymore about the width of the source values.</p>
",2
56098524,56098462,2,"<p>What about to also save the size when you initialize the pointers ?</p>

<pre><code>typedef struct
{  
    void *l_var;      
    void *r_var;    
    size_t sz;
}EXPR;

expr.l_var = &amp;motor_rt_params[0].position;
expr.r_var = &amp;motor_rt_params[1].position;
expr.sz = sizeof(motor_rt_params[1].position);
</code></pre>

<p>allowing to to for instance</p>

<pre><code>void SCRIPT_Process(void *l_var, void *r_var, size_t sz, uint32_t oper)
{
    int32_t res;

    switch (oper)
    {
        case OP_PLUS: 
          if (sz == sizeof(int32_t))
            res = *((int32_t *) l_var) + *((int32_t *)r_var);
          else /* suppose a int16_t */
            res = *((int16_t *) l_var) + *((int16_t *)r_var);
          break;
        case OP_MINUS: 
          if (sz == sizeof(int))
            res = *((int32_t *) l_var) - *((int32_t *)r_var);
          else /* suppose a int16_t */
            res = *((int16_t *) l_var) - *((int16_t *)r_var);
    }
}

SCRIPT_Process(expr.l_var , expr.r_var , expr.sz, OP_PLUS);
</code></pre>

<p>supposing it is <em>int</em> or <em>short</em> only, I let you adding the case of a <code>int8_t</code></p>

<p>The advantage also placing the size in the EXPR is to not lost that information  / create inconsistencies by error because managed in different piece of code.</p>

<p>Or may be to give the EXPR rather than the fields separately in arguments to <code>SCRIPT_Process</code> ?</p>

<p>May be you also need to know if signed or unsigned, with an additional field, or using an <em>int</em> for the size valuing the positive size for unsigned (4, 2 or 1) and negative size for a signed (-4, -2 -1).</p>

<p>An other way is to save pointers to the right functions rather than the size, a kind of C++ virtual implementation.</p>

<p>Of course all of that supposes you cannot save values as <code>int32_t</code> in the struct and you really need to save the pointers.</p>
",0
50734190,50734093,10,"<p>If <code>snprintf</code> (<code>fprintf</code>, <code>printf</code> or any function from that family) comes across a null pointer argument for a <code>%s</code> format specifier, the behavior is undefined. In real life instead of crashing or behaving unpredictably many Standard Library implementations prefer to insert a <code>(null)</code> sequence into the recipient buffer. This is what you observe in your experiment - the beginning of that <code>(null)</code> that <code>snprintf</code> managed to fit into the remaining space of that <code>str</code> recipient array.</p>

<hr>

<p>There was a story a long time ago (even Internet, which never forgets, seems to have forgotten about it), about an ordinary customer of a large US telecommunication company, who registered ""null"" as his email ID, thus getting ""null@company.com"" as his email address. Suddenly he started receiving a large amount of internal company's emails containing other customers' personal data. If I remember correctly, it was caused by a bug in internal company's software, where a null pointer was passed to a function responsible for forming the destination email addresses. And that function, instead of crashing, resorted to a similar fail-safe behavior in response to a null-pointer argument. The bug remained unnoticed until someone actually registered ""null@company.com"" as a valid email address.</p>
",4
50734195,50734093,7,"<p>The <code>snprintf</code> function tries to write <code>""(null)""</code> into your string, but since the destination is only four characters you can never get more than a three-character string (plus terminator).</p>

<p>Note that the insertion of <code>""(null)""</code> is not specified by the standard, passing a NULL argument for the <code>""%s""</code> format specifier is really <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""noreferrer""><em>undefined behavior</em></a>.</p>
",3
53880226,21311397,0,"<p>Make sure you have the define and include for crypt as the very first lines at the top of your file before any other includes.</p>

<pre><code>#define _XOPEN_SOURCE
#include &lt;unistd.h&gt;
</code></pre>
",0
49359188,49355251,0,"<p>The compile might work if you remove that line, but the program won't link.</p>

<ul>
<li>You have to <em>define</em> <code>aaa</code> somewhere.</li>
<li>Your header files must be surrounded by <code>#ifndef HEADER_H</code>... header guards.</li>
<li>Having two header files that include each other is a sign of bad program design.</li>
<li>The presence of <code>extern</code> anywhere in your code is a sign of bad program design, with very few exceptions.</li>
<li>There are a few cases where you can place a (static inline) function definition inside a header file, but most of the time that means bad program design.</li>
</ul>

<p>Summary: really bad program design leads to really bad programs.</p>
",0
58745569,58745522,0,"<p>One problem is the loop</p>

<pre><code>for (size_t count = 0; count &lt; strlen(string); count++)
</code></pre>

<p>iterates over <em>all</em> characters in the string <code>string</code>, but inside the loop you ""extract"" two characters at a time.</p>

<p>One simple solution is to iterate over <em>half</em> the length, since each hexadecimal number you extract is two digits:</p>

<pre><code>for (size_t count = 0; count &lt; strlen(string) / 2; count++)
</code></pre>

<p>You also make the same mistake when allocating memory for the <code>HexBuffer</code>, you allocate twice as much as needed.</p>

<p>You also need to take this into account when you print the values using the returned pointer.</p>
",2
52504891,52504671,2,"<p>No, you are not wrong. The suffixes that hardcode ""abstract"" types like <code>unsigned long</code> are not very compatible with using the more concrete types with specified widths.</p>

<p>Sometimes people simply know the mapping, which can make it correct anyway, but it's not as portable or clean.</p>

<p>There are macros you can use for literals, see <a href=""http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdint.h.html"" rel=""nofollow noreferrer""><code>&lt;stdint.h&gt;</code></a>:</p>

<ul>
<li>The macro INT<i>N</i>_C shall expand to an integer constant expression corresponding to the type <code>int_leastN_t</code> (so e.g. <code>INT32_C(4711)</code> generates a constant compatible with <code>int32_t</code>).</li>
<li>The same for UINT<i>N</i>_C().</li>
</ul>
",1
52619675,52512235,0,"<p>Technically, there is a way to tell between them, but you really have to try pretty hard:</p>

<pre><code>char a [10];
printf( ""size is %zu\n"", sizeof(MY_LONG [a]) );
</code></pre>

<p>In the above example, the literal (<code>0x1UL</code>) version will have the array take the <code>unsigned long</code> literal as an index, yielding <code>1</code> because it is <code>sizeof(char)</code>. The cast version will have the array taking a <code>int</code> literal as an index, then casting the resulting char to <code>unsigned long</code> before passing it to <code>sizeof()</code>. <code>sizeof(unsigned long)</code> is typically <code>8</code>.</p>

<p>This is because the indexing operator <code>[]</code> outranks the casting operator <code>()</code>.</p>
",0
52512268,52512235,5,"<p>There is no practical difference, these are 100% equivalent.</p>

<p>The only formal difference is that <code>UL</code> is part of the integer constant, while the cast could be put in front of any expression, including a run-time evaluated expression.</p>

<p>The main reason for UL is to enforce a type of a integer constant, where it matters. It is often more readable than a cast. Example: <code>1UL &lt;&lt; n</code> versus <code>(unsigned long)1 &lt;&lt; n</code>. </p>

<p>Casts on the other hand, have a wider use, as they cannot only be used to force a type at compile-time, but also to trigger a type conversion in run-time.</p>
",3
55133548,55132116,13,"<p><code>strncpy</code> <strong>is not a bounded <code>strcpy</code></strong>. It's a fixed-length (not bounded, fixed-length) operation targeting a destination that's not a C string (null-terminated) but a <em>null-padded</em> field, like what was used in certain kinds of data record tables in the 70s and early 80s. It has basically <strong>no modern purpose</strong> and should not be used unless you really want this behavior.</p>

<p><code>snprintf</code> is the canonical C function for ""bounded <code>strcpy</code>"". On POSIX systems, <code>strnlen</code>+<code>memcpy</code> would be another good alternative, and necessary if you need to support strings longer than <code>INT_MAX</code>. If you don't have <code>strnlen</code>, you can easily make it with <code>memchr</code> and do the same.</p>

<p>Note that the simple use of <code>snprintf</code> is not ""bounded"" in the sense of having a bound on how much it reads from the source; it necessarily reads the whole source string to determine the return value, which both can incur a time cost and depends on the source being a valid (terminated) string. If you want it bounded in the sense of both source and destination, you can do something like:</p>

<pre><code>snprintf(dest, n, ""%.*s"", (int)n-1, src);
</code></pre>

<p>However, that's sufficiently non-idiomatic and error-prone that I would just use <code>strnlen</code> and <code>memcpy</code> instead.</p>
",3
56411971,56411907,0,"<p>I have understand it. The machine is based with 64bit address. Converting the address to int value will loss the upper value of address. So here the a's address is different from ptr's address.</p>

<p>If to use pointer in C++, we can use <code>intptr_t</code> or preferably <code>uintptr_t</code></p>
",0
56384578,56384011,1,"<p>For better understanding I will shuffle the answering order:</p>

<p>2 - <code>array</code> is a pointer of type <code>void</code>. In C, pointers may be assigned to and from pointers of type <code>void*</code>. Any pointer to an object may be converted to type <code>void*</code> without loss of information. If the result is converted back to the original pointer type, the original pointer is recovered. </p>

<p>1 - It does not work the same for single elements, you do not have a generic type that can be assigned to any type. So the code is switching the content of pointed memory.</p>

<p>3 - <code>n</code> is the number of elements in array, while <code>size</code> is the size of a single element in the array. <code>stride = size * sizeof(char);</code> means <code>stride</code> is equal to <code>size</code>, as <code>sizeof(char)</code> equals 1. The size of the array <code>sizeof(array)</code> equals <code>n * size</code> - the number of elements in the array multiplied with the size of an element. Since both <code>i</code> and <code>j</code> are less than <code>n</code>, <code>i * stride</code> and <code>j * stride</code>
will never be greater than the memory used by the array. I wonder though why the use of this <code>stride</code>, as far as I know <code>sizeof(char)</code> is always 1.</p>
",1
56384109,56384011,0,"<ol>
<li><code>array</code> is of type <code>void*</code>. It is just a pointer with no interpretation, so we don't know what data type it points to. The number of elements is given int <code>n</code> and the size of each in <code>size</code>. It is done this way so the function can be used with arrays of any type.</li>
<li><code>char *arr = array;</code> is interpreting the void pointer as pointing to a sequence of bytes.</li>
<li><code>sizeof(array)</code> gives the size of the <em>pointer</em>, not the size of the actual array. The actual size in bytes is <code>i * size</code>.</li>
</ol>

<p>The shuffle algorithm appears to be the <a href=""https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle"" rel=""nofollow noreferrer"">Fisher-Yates Shuffle</a>.</p>

<p>I'll also note that <code>* sizeof(char)</code> is pointless, since <code>sizeof(char)</code> is 1 by definition. </p>
",0
56140128,56140049,4,"<blockquote>
  <p>Can I expect the compiler to be clever and use those <code>restrict</code>
  adornments in such a case or are they making matters even worse (e.g.
  by introducing undefined behavior)?</p>
</blockquote>

<p>The <code>restrict</code> qualifier serves primarily to give compilers license for optimization.  The only language <em>constraint</em> (whose violation requires a diagnostic) is that only object pointers may be <code>restrict</code>-qualified.  As a quality of implementation matter, you can hope that your compiler will diagnose violations of restrict qualification, but in practice, no compiler can guarantee to catch all violations.</p>
",0
56808813,56808778,3,"<p>In <code>v = 1 &lt;&lt; 31;</code>, <code>1</code> is not an <code>unsigned long int</code>. It is an <code>int</code>. Shifting it by 31 bits overflows the <code>int</code> type (in your C implementation).</p>

<p>To get an <code>unsigned long int</code> with a 1 in bit 31, you should shift an <code>unsigned long int</code> by 31 bits: <code>v = (unsigned long int) 1 &lt;&lt; 31;</code> or <code>v = 1ul &lt;&lt; 31</code>.</p>
",1
56916016,56915978,4,"<p>GCC and clang support a <code>-Wunused-function</code> warning (or just <code>-Wunused</code> if you also want to know about other stuff like unused variables and parameters).</p>

<p><em>Edit</em>: I thought this worked across compilation units (with some caveats), but based on Jonathan Leffler's comments on this post, it looks like it doesn't.  It's still helpful so I'll leave the answer in place, but it might be better to take a look at something like <a href=""https://github.com/caolanm/callcatcher"" rel=""nofollow noreferrer"">callcatcher</a>.</p>
",5
53435169,53434866,2,"<p>Newer standards are not guaranteed to be compatible, even though the committee has a (far too) strong focus on backwards compatibility. </p>

<ul>
<li>C90 is not completely compatible with newer versions. </li>
<li>C11 and C17 are compatible with C99, apart from some corrections.</li>
</ul>

<p>Official recommendations of functions to avoid are found in:</p>

<ul>
<li>C17 6.11 <em>Future language directions</em>, and </li>
<li>C17 6.32 <em>Future library directions</em></li>
</ul>

<p>Notably, the official recommendations are free from misguided Microsoft propaganda regarding the string handling functions etc.</p>

<p>Unofficial recommendations by yours sincerely here: 
<a href=""https://stackoverflow.com/a/46563868/584518"">Which functions from the standard library must (should) be avoided?</a>.</p>
",0
53434999,53434866,1,"<p>The following code is valid in C89, deprecated under C99, and invalid in C11 and further, due to its use of the unsafe function <code>gets</code>:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    char str[100];
    puts(""What's your name?"");
    gets(str);
    printf(""Hello %s!\n"", str);
}
</code></pre>
",0
50738663,36673295,0,"<p>Please try to use this to release memory of the json object ""json_object_object_del()""</p>

<p>json_object_object_del(recv_json_object_wifi);
recv_json_object_wifi=NULL; 
json_object_object_del (wifi_object);
wifi_object=NULL; </p>
",0
48872012,48871981,2,"<p>In C an enumeration is just a symbolic compile-time constant of type <code>int</code>. You can assign <em>any</em> <code>int</code> value to an enumeration, even if it's not a valid value for the enumeration.</p>

<p>Passing the integer value <code>34</code> is the same as passing <code>HR_Z_AXIS | AM_Y_AXIS</code>.</p>
",10
55213338,55207459,3,"<p>In C, an <em>address</em> is a value of a pointer type.</p>

<p>For example, the unary address operator <code>&amp;</code> yields the <em>address</em> of its operand, and expression that is of type <em>pointer to some_type</em>, where some_type is the type of the operand.</p>

<p>Saying that it ""returns a pointer"" is perhaps a bit imprecise. I've found it clearer to use the word <em>pointer</em> as an adjective, not as a noun. Thus we can have a pointer value, a pointer object, a pointer type, a pointer expression, etc. A pointer value (a value of some pointer type) is usually an address (the address of some function or object) -- except when it's a null pointer value, an invalid pointer value, or a pointer just past the end of some object.</p>
",0
57237785,57237520,0,"<p>Either</p>

<pre><code>WCHAR * BranchNameArr [] = { BranchName };
Branch = BranchNameArr;
</code></pre>

<p>or</p>

<pre><code>WCHAR * BranchNamePtr =  BranchName;
Branch = &amp; BranchNamePtr;
</code></pre>

<p>are fine.</p>
",0
58781986,58781878,0,"<p>Macros like that are used to give a name (and thus meaning) to bit-masks.</p>

<p>Bit-fiddling code can be hard to follow, so adding macros that represent often occurring pieces of code can help a lot.</p>
",0
50797400,50797306,0,"<p>The second <code>#define</code> overrides the first one. so ultimately <code>abc</code> is a string literal. Now you are trying to interpret  <code>abc</code>  as a integer because you are using <code>%d</code> in <code>printf</code>.</p>

<p>This is what <code>printf look like:</code>printf(""%d"",""rd"");` after the pre-processor finishes its job.</p>
",1
51220932,51220907,1,"<p>Most likely the requirement for aligning memory access on X byte boundaries.  Also, it's up to the compiler - it can do what it likes.</p>
",0
59385991,59385745,3,"<p>The author has effectively buried the prime sequence in a constant based on the fact that</p>

<ol>
<li>There are fewer than 63 primes between 2 and 100, so an encoding used 64bits of a ULL can be used.</li>
<li>Starting with 3, it navigates only odd numbers between 3 and 99 inclusively. Since there are only 49 such numbers in 3...99, we have plenty of bits to encode with.</li>
<li>Each iteration effectively does a right-shift of <code>b</code> by one bit (with <code>b /= 2</code>).</li>
</ol>

<p>Therefore, by encoding the constant such that the zero bit of <code>b</code> is lit on the current iteration if the value <code>p</code> is a prime, and you only print <code>p</code> in that specific case, The result is a list of numbers that detail exactly what was encoded, and nothing more. In this case that encoding was primes, but that the numbers are primes have nothing to do with the actual math; it's all about the pre-determine encoding, the bit shift, and reporting a counter if that first bit is lit after the shift.</p>
",0
55714297,55714249,5,"<p>You're overrunning the bounds of the array in your loops:</p>

<pre><code>for(i=0;i&lt;=num1;i++){
    for(j=0;j&lt;=num2;j++){
</code></pre>

<p>In the outer loop <code>i</code> ranges from 0 to <code>num1</code>, while in the inner loop <code>j</code> ranges from 0 to <code>num2</code>.  However, the maximum valid index for each array dimension is <code>num1-1</code> and <code>num2-1</code> respectively.  Reading / writing past the end of an array invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>, which is why it sometimes worked and sometimes didn't.</p>

<p>Change the loop conditions to <code>&lt;</code>:</p>

<pre><code>for(i=0;i&lt;num1;i++){
    for(j=0;j&lt;num2;j++){
</code></pre>
",0
57801250,57801070,4,"<p>Namespace your C code. </p>

<p>I prefix all my globals (even <code>static</code> ones and even in executables) with the prefix of my library and that makes name collisions with libc a non-issue (it also simplifies moving code, amalgamating code or making formerly <code>static</code> functions <code>extern</code>).</p>

<p>In general you can't stop a C program author that links your library from interposing over your library's functions (their program, their rules).
If you're a shared-library author on a platform like Linux, you can, however, prevent them from trivial linker-based overriding of your library's internal functions. One way to do it is with library-private (hidden) symbol aliases:</p>

<p>Example (relies on non-standard C extensions and on using a shared
rather than static library) :</p>

<pre><code>#!/bin/sh -eu
cat &gt; h.h&lt;&lt;EOF
void a(void);
void A(void);
void b(void);
EOF
cat &gt;  mylib.c &lt;&lt;EOF
#include &lt;stdio.h&gt;
#include ""h.h""

void b_(void);
void a()
{
    b(); //overridable
}
void A(void)
{
    b_(); //non-overridable
}
void b(void)
{
    puts(""b"");
}
__attribute((visibility(""hidden""),alias(""b""))) typeof(b) b_ ;
//^ the b_ hidden function (unlike a static function)
//can be used from other translation units of the same shared lib
//but not from outside

EOF

gcc -c mylib.c -fpic
gcc mylib.o -o libmylib.so -shared

cat &gt; main.c &lt;&lt;EOF
#include ""h.h""
#include &lt;stdio.h&gt;
void b(void) { puts(""my b""); }
int main()
{
    puts(""do a""); a(); puts(""==="");
    puts(""do b""); b(); puts(""==="");
    puts(""do A""); A(); puts(""==="");

}
EOF
gcc main.c $PWD/libmylib.so
./a.out
</code></pre>

<p>Output:</p>

<pre><code>do a
my b
===
do b
my b
===
do A
b
===
</code></pre>

<p>More info for example in <a href=""https://www.slideshare.net/KarlFrank99/dsohowto"" rel=""nofollow noreferrer"">How to Write Shared Libraries</a> by U. Drepper.</p>
",3
53950449,53950409,4,"<p>The <code>%c</code> format specifier expects the address of a <code>char</code>, i.e. a <code>char *</code> to be passed in.  You're passing in a <code>char</code> instead.  The same goes for <code>%i</code> and <code>int</code> further down.  Using the wrong format specifier invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""noreferrer"">undefined behaivor</a>, which is in this case manifests as a crash.</p>

<p>You need to pass the <em>address</em> of the variables in question so that <code>scanf</code> can modify them.  Also, for <code>%c</code> you should have a space in the format string before it to consume any whitespace left in the input buffer.</p>

<p>So you want:</p>

<pre><code>scanf("" %c"", &amp;command);
</code></pre>

<p>And:</p>

<pre><code>scanf(""%i"", &amp;temp);
</code></pre>
",0
51870090,51869569,3,"<p>The software that starts a C program is responsible for creating proper contents for <code>argv</code>:</p>

<ul>
<li><p>Per C 2018 5.1.2.2.1 2, ¡°If the value of <strong>argc</strong> is greater than zero, the array members <strong>argv[0]</strong> through <strong>argv[argc-1]</strong> inclusive shall contain pointers to strings, which are given implementation-defined values by the host environment prior to program startup.¡±</p></li>
<li><p>Per 7.1.1 1, ¡°A <em>string</em> is a contiguous sequence of characters terminated by and including the first null character.¡±</p></li>
</ul>

<p>Thus, it is not <strong>legal</strong> according to the C standard for <code>argv</code> to point to sequences of bytes that are not null-terminated. It is <strong>possible</strong>? Yes, if there is a bug in the software, it is possible. A bug in bash cannot cause this, as bash works through the operating system, and bash would not be able to pass arguments to your program that the operating system does not process. Nor could other user-mode programs cause this, as they have to work through the operating system in the same way. It would require a bug in the code that loads and executes programs and/or the code inside a C program that starts the program before calling <code>main</code>.</p>
",0
50646586,50646491,4,"<p>The code first executes <code>printf(""Lucknow"")</code> which prints ""Lucknow"" on the screen and returns the value 7 to the second <code>printf()</code> call. The second <code>printf()</code> prints ""made,7,easy"" and returns 11 which is the number of characters it printed. It doesn't know or care what the other function did.</p>
",0
53527215,53527066,1,"<p>When applying the macro substitution, this:</p>

<pre><code>const int *arr4[2][2] = {{tc1, tc2}, {tc3, tc4}};
</code></pre>

<p>Becomes:</p>

<pre><code>const int *arr4[2][2] = {{{1,2}, {2,3}}, {{3,4}, {4,5}}};
</code></pre>

<p><code>arr4</code> is a 2D array of <code>int *</code>, but you assign something like <code>{1,2}</code> to each element which is not a <code>int *</code>.  This <em>could</em> work if you use a compound literal:</p>

<pre><code>const int *arr4[2][2] = {{(int [])tc1, (int [])tc2}, {(int [])tc3, (int [])tc4}};
</code></pre>

<p>Which becomes:</p>

<pre><code>const int *arr4[2][2] = {{(int []){1,2}, (int []){2,3}}, {(int []){3,4}, (int []){4,5}}};
</code></pre>

<p>Then you assign an actual array, which decays into a pointer to its first element, to each element of <code>arr4</code>.</p>

<p>This works:</p>

<pre><code>const int *arr2[2][2] = {{ts1, ts2}, {ts3, ts4}};
</code></pre>

<p>Because <code>ts1</code>, <code>ts2</code>, <code>ts3</code>, and <code>ts4</code> are arrays of type <code>int</code>, so using them here results in them decaying to a pointer to their first elements.</p>
",1
54357019,54357006,2,"<p>You have to include you loop in brackets:</p>

<pre><code>int n, NT=97;

double *x=malloc(NT*sizeof(double));

x[0]=0;
double dt=30;   
double utem=0.5, dx;

for (n=1;n&lt;NT;n++)
{
    dx=dt*utem;
    x[n] = x[n-1] + dx;
}

printf(""x is %6.13f \n"", (double)x[n]);   
</code></pre>
",1
56936803,56935852,5,"<p>The <code>_t</code> suffix is not reserved by ISO 9899 as such. The future library directions for C11 revision does only say that (<a href=""https://port70.net/~nsz/c/c11/n1570.html#7.31.10"" rel=""nofollow noreferrer"">C11 7.31.10</a>):</p>

<blockquote>
  <ol>
  <li>Typedef names <em>beginning with</em> <code>int</code> or <code>uint</code> and ending with <code>_t</code> may be 
  added to the types defined in the <code>&lt;stdint.h&gt;</code> header.?[...]</li>
  </ol>
</blockquote>

<p>That said, there are great many types with <code>_t</code> suffix defined in C11:</p>

<blockquote>
  <p><code>char16_t</code>, <code>char32_t</code>, <code>clock_t</code>, <code>cnd_t</code>, <code>constraint_handler_t</code>, <code>div_t</code>, <code>double_t</code>, <code>errno_t</code>, <code>fenv_t</code>, <code>fexcept_t</code>, <code>float_t</code>, <code>fpos_t</code>, <code>imaxdiv_t</code>, 
  <code>int_fast</code><strong><code>N</code></strong><code>_t</code>, <code>int_least</code><strong><code>N</code></strong><code>_t</code>, <code>intmax_t</code>, <code>int</code><strong><code>N</code></strong><code>_t</code>, <code>intptr_t</code>, <code>ldiv_t</code>, <code>lldiv_t</code>, <code>max_align_t</code>, <code>mbstate_t</code>, <code>mtx_t</code>, <code>ptrdiff_t</code>, <code>rsize_t</code>, 
  <code>sig_atomic_t</code>, <code>size_t</code>, <code>thrd_start_t</code>, <code>thrd_t</code>, <code>time_t</code>, <code>tss_dtor_t</code>, <code>tss_t</code>, <code>uint_fast</code><strong><code>N</code></strong><code>_t</code>, <code>uint_least</code><strong><code>N</code></strong><code>_t</code>, 
  <code>uintmax_t</code>, <code>uint</code><strong><code>N</code></strong><code>_t</code>, <code>uintptr_t</code>, <code>wchar_t</code>, <code>wctrans_t</code>, <code>wctype_t</code>, <code>wint_t</code></p>
</blockquote>

<p><a href=""https://stackoverflow.com/a/12727104/918959"">POSIX, on the other hand, <strong>reserves</strong> the <code>_t</code> suffix for system use.</a> The POSIX 1003.1 rationale has this excerpt:</p>

<blockquote>
  <p>To allow implementors to provide their own types, all conforming applications are required to avoid symbols ending in <code>_t</code>, which permits the implementor to provide additional types.</p>
</blockquote>

<p>All in all, considering that the chances are that you want to use your C code in a POSIX system now or later, to steer away from using <code>_t</code> for your own types.</p>
",1
57038268,57037658,8,"<p>The answer is that <strong>you can¡¯t.</strong></p>

<p>The C programming language offers no way of doing this, and <em>attempting</em> to do so invariably causes <em>undefined behaviour</em>. This means that there are no guarantees about what the result will be.</p>

<p>Now, you might be tempted to exploit undefined behaviour to subvert C¡¯s runtime system and change the value. However, whether and how this works entirely depends on the specific executing environment. For example, when compiling the code with a recent version of GCC and clang, and enabling optimisation, the variable <code>x</code> simply ceases to exist in the output code: There is no memory location corresponding to its name, so you can¡¯t even directly modify a raw memory address.</p>

<p>In fact, the above code yields roughly the following assembly output:</p>

<pre><code>main:
    subq    $8, %rsp
    movl    $100, %esi
    movl    $.LC0, %edi
    xorl    %eax, %eax
    call    printf
    xorl    %eax, %eax
    call    func
    movl    $100, %esi
    movl    $.LC0, %edi
    xorl    %eax, %eax
    call    printf
    xorl    %eax, %eax
    addq    $8, %rsp
    ret
</code></pre>

<p>As you can see, the value <code>100</code> is a literal directly stored in the ESI register before the <code>printf</code> call. Even if your <code>func</code> attempted to modify that register, the modification would then be overwritten by the compiled <code>printf</code> call:</p>

<pre><code>    ¡­
    movl    $200, %esi /* This is the inlined `func` call! */
    movl    $100, %esi
    movl    $.LC0, %edi
    xorl    %eax, %eax
    call    printf
    ¡­
</code></pre>

<p>However you dice it, the answer is: There is no <code>x</code> variable in the compiled output, so you cannot modify it, even accepting undefined behaviour. You could modify the <em>output</em> by overriding the <code>printf</code> function call, but that wasn¡¯t the question.</p>
",4
57049129,57037658,6,"<p>Hack: By only changing code in <code>void func()</code>, create a <code>define</code>.<br>
Akin to <a href=""https://stackoverflow.com/questions/57037658/how-to-change-the-local-variable-without-its-reference#comment100605688_57038621"">@chqrlie</a></p>

<pre><code>void func()
{
  /*do some code to change the value of x*/
  #define func() { x = 200; }
}

int main()
{
   int x = 100;
   printf(""%d\n"", x);  // it will print 100
   func(); // not return any value and reference of x also not sent
   printf(""%d\n"", x);  // it need to print 200
}
</code></pre>

<p>Output</p>

<pre><code>100
200
</code></pre>
",0
57038621,57037658,2,"<p>The answer is that you can¡¯t, but...</p>

<p>I perfectly agree with what @virolino and @Konrad Rudolph and I don't like my ""solution"" to this problem be recognised as a best practise, but since this is some sort of challenge one can come up with this approach.</p>

<pre><code>#include &lt;stdio.h&gt;


static int x;
#define int 

void func() {
  x = 200;
}   

int main() {
   int x = 100;

   printf(""%d\n"", x);  // it prints 100
   func(); // not return any value and reference of x also not sent
   printf(""%d\n"", x);  // it prints 200
}
</code></pre>

<p>The define will set <code>int</code> to nothing. Thus <code>x</code> will be the global static <code>x</code> and not the local one. This compiles with a warning, since the line <code>int main() {</code> is now only <code>main(){</code>. It only compiles due to the <a href=""https://stackoverflow.com/questions/11067485/why-does-c-allow-main-even-when-it-is-not-int-main-or-void-main"">special handling</a> of a function with return type int.</p>
",3
57269993,57269034,8,"<blockquote>
  <p>Is it accurate to say that, if you are writing portable C, the longest available unsigned integer type is <code>unsigned long long</code>? I'm not looking for a specific number of bits, or even 'at least a specific number of bits', but 'the longest supported by the current compiler and target platform, whatever that may happen to be'.</p>
</blockquote>

<p>No. Neither if you're targetting C89, nor if C99+. C89 does not support <code>unsigned long long</code> at all, so you're stuck with <code>unsigned long</code>. So if you want to support archaic platforms you cannot use it.</p>

<p>And C99 added <code>uintmax_t</code> typedef (and <code>intmax_t</code> too) which <em>can</em> be greater than <code>unsigned long long</code>. Naturally <code>uintmax_t</code> must have range of <em>at least</em> that of <code>unsigned long long</code>. </p>

<p><a href=""https://port70.net/~nsz/c/c99/n1256.html#7.18.1.5"" rel=""nofollow noreferrer"">C99 7.18.1.5</a>:</p>

<blockquote>
  <p><strong>7.18.1.5 Greatest-width integer types</strong></p>
  
  <p>1 The following type designates a signed integer type capable of
  representing any value of any signed integer type:</p>

<pre><code>intmax_t
</code></pre>
  
  <p>The following type designates an unsigned integer type capable of
  representing any value of any unsigned integer type:</p>

<pre><code>uintmax_t
</code></pre>
  
  <p>These types are required.</p>
</blockquote>

<p>This could be an extended integer type that is implementation-defined (GCC for example does not support extended integer types), but <strong>you</strong> wouldn't need to know about it; or, if a future standard implements <code>unsigned superduper long long</code> then in the future implementations <code>uintmax_t</code> could be a typedef to that.</p>

<hr>

<p>If you really need to support all sorts of compilers, you can use some trickery to create a typedef to the largest portable type like this:</p>

<pre><code>#include &lt;limits.h&gt;

#if defined(__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= 199901L

/* C99+ */
#include &lt;stdint.h&gt;
typedef uintmax_t mymaxuint;
#define MYMAXUINT_MAX UINTMAX_MAX     

#elif defined(ULLONG_MAX)

/* Some compiler that does not support C99+ but seems to have 
   a macro for unsigned long long for some reason */
typedef unsigned long long mymaxuint;    
#define MYMAXUINT_MAX ULLONG_MAX

#else

typedef unsigned long mymaxuint;
#define MYMAXUINT_MAX ULONG_MAX

#endif
</code></pre>
",0
49103338,49103302,1,"<p>The macro expands to </p>

<pre><code>int
target_initialise( void * Target ) {

    (void) (Target == Target);

    return 0;
}
</code></pre>

<p>and it's used to silence compiler warnings. If you for example compile with
with gcc and use <code>-Wall</code>, then the compiler warns about a lot of things, for
example unused variables. So in <code>target_initialise</code> the variable <code>Target</code> is
not used and the compiler would warn about that, but using the macro the
compiler would remain silent.</p>

<p>I have no idea why the code is doing that.</p>
",0
57958545,57958497,4,"<p>The default for <code>%f</code> is six decimal places, hence 0 is output.</p>

<p>Be assured, <code>Md</code> will be non-zero in your debugger.</p>

<p><code>printf(""%.*lf\n"", DBL_DIG, Md);</code> is one way round this: <code>DBL_DIG</code> is introduced via <code>&lt;float.h&gt;</code>, although you'd be advised to get used to <em>scientific notation</em></p>

<pre><code>printf(""%e\n"", Md);
</code></pre>

<p>which will permit printing of arbitrarily sized floating point values.</p>
",3
49293673,49293559,2,"<p>You're passing your main variables via value. Read about how you can pass by reference, <a href=""https://stackoverflow.com/questions/13654138/what-exactly-is-the-difference-between-pass-by-reference-in-c-and-in-c"">here</a>. <code>scanf</code> requires addresses of variables in order to modify them; so you need to pass their addresses like this:</p>

<pre><code>get(&amp;a, &amp;b);
</code></pre>

<p>And you can modify your <code>get()</code> method like this:</p>

<pre><code>void get(int* pM,int* pN) {
  printf(""enter the value"");
  scanf(""%d%d, pM, pN);
}
</code></pre>
",0
50494864,50494792,4,"<p>Even if you manage to work around issues with midnight, there's also daylight savings time to take into account, and wrapping months, meaning you have to take leap years into account as well... don't go there.</p>

<p>Instead, it's much easier to just add 2 hours (2 * 60 * 60 seconds) to the time <em>before</em> you convert it to <code>time_t</code>:</p>

<pre><code>    t = time(NULL) + 2 * 60 * 60;
    date = localtime(&amp;t);
</code></pre>

<p>This is much more reliable, because a <code>time_t</code> is just the number of seconds since some well-defined epoch.</p>
",1
49526867,49526642,1,"<p>Without a bit more context it's hard to know the author's reason for doing this, but the most common is that it converts the value to either 0 or 1. This is particularly interesting if you're using <code>__builtin_expect()</code>, in which case yes, it could result in better-optimized code.</p>

<p>It's also used occasionally to make the code a bit more self-documenting¡­ if you see it, you know that you're meant to be treating it as true/false. Usually, when used like this, it's part of a macro.</p>

<p>It's also worth noting that the result is an <code>int</code>, regardless of the original type. This isn't <em>usually</em> consequential, but sometimes it's important.</p>
",0
52499635,52499456,1,"<p>There are two major problems, as I see it</p>
<ul>
<li><p>The variable <code>total</code> is not initialized, so the first occurrence of <code>total = total + grade;</code> would invoke undefined behaviour.</p>
<p>You have to initialize it explicitly to <code>0</code>.</p>
</li>
<li><p>The same variable <code>grade</code> is used for holding the repeated input. After the loop, <code>grade</code> will only hold the last input value.</p>
<p>You need to either use an array for storing inputs and comparison, or, compare and update the min and max as you go, inside the loop.</p>
</li>
</ul>
",0
50442140,50442072,2,"<p>""every other bit"" means each either bits 0, 2, 4, 6 ... or bits 1, 3, 5, 7 ...</p>

<p>If you start with 32 bits and take each other bit then your result is 16 bits.</p>
",0
52465256,52463428,3,"<p>Any good compiler evaluates simple expressions at compile-time. The behavior you are seeing is unrelated to preprocessing. If you directly write:</p>

<pre><code>int a = 365 * 24;
</code></pre>

<p>then any good compiler will generate code that initializes <code>a</code> to 8760. (Some compilers might not if they are executed with their optimization features disabled. But any decent compiler will perform this optimization when optimization is enabled.)</p>

<p>In modern compilers, optimization will do a great deal more than this. For example, they will identify invariant code outside of loops. (That is, if there are expressions or even full statements inside of a loop whose results do not depend on the data in the current loop iteration, they will move those expressions or statements outside of the loop, so that they are only evaluated once instead of each time the loop executes.) They will remove objects that are never used. If one path of a conditional branch has undefined behavior in some circumstances, they may deduce that that path is never taken, so they will optimize code by removing that path and the conditional branch in those circumstances. They may even replace entire loops with equivalent mathematical expressions. For example, when I compile:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


int main(int argc, char *argv[])
{
    int n = atoi(argv[1]);
    int s = 0;
    for (int i = 1; i &lt;= n; ++i)
        s += i;
    printf(""%d\n"", s);
}
</code></pre>

<p>with Apple LLVM 9.1.0 (clang-902.0.39.2), the resulting assembly code does not contain a loop. After calling <code>atoi</code>, it executes instructions that are, in effect<sup>1</sup>, <code>printf(""%d\n"", 0 &lt; n ? n*(n+1)/2 : 0);</code>. So the loop is entirely replaced by a test and a simple arithmetic expression.</p>

<h1>Footnote</h1>

<p><sup>1</sup> The actual instructions are:</p>

<pre><code>leal    -1(%rax), %ecx
movl    %eax, %edx
addl    $-2, %edx
imulq   %rcx, %rdx
shrq    %rdx
leal    -1(%rdx,%rax,2), %esi
</code></pre>

<p>A closer representation of those is <code>(n-1)*(n-2)/2 + 2*n - 1</code>. One reason for the compiler to do this is that it gets the ¡°correct¡± result if <code>n</code> is <code>INT_MAX</code>, as <code>n*(n+1)/2</code> would produce zero because <code>n+1</code> wraps, whereas <code>(n-1)*(n-2)/2 + 2*n - 1</code> gets the same result that the loop gets (assuming wrapping arithmetic), which is <code>INT_MAX+1</code> or <code>INT_MIN</code> due to wrapping. By C rules, the compiler could have used the simpler <code>n*(n+1)/2</code> since the behavior on overflow is not defined by C, but this compiler may be conforming to stricter rules such as using wrapping two¡¯s complement arithmetic.</p>
",3
56617705,56617670,0,"<pre><code>  buildings = realloc(buildings, i+1);
</code></pre>

<p>This is wrong. It should be:</p>

<pre><code>  buildings = realloc(buildings, sizeof(struct B) * (i+1));
</code></pre>

<p>There's a similar issue with this:</p>

<pre><code>  humans = realloc(humans, n+1);
</code></pre>

<p>Also, this code is completely baffling. I can't suggest how to fix it because I have no idea what you think it does:</p>

<pre><code>  buildings[i].ptra = (*buildings-&gt;ptra) calloc(1, buildings-&gt;ptra);
  buildings[i].ptra = &amp;(humans[n]);
  buildings[i].ptra = strdup(""NameXYZ""); 
</code></pre>
",3
57977256,57977203,3,"<p>Create a separate counter for the resulting arrays and increment it on each iteration of  the inner loop.</p>

<pre><code>int k = 0;
for(int i=0; i&lt; sizeof(r)/sizeof(r[0]); i++){
            for(int j=0;j&lt; sizeof(phi)/sizeof(phi[0]);j++){
                  z[k]=atan(theta)*r[i]*cos(phi[j]);
                  y[k]=r[i]*sin(phi[j]);
                  x[k]=r[i]*cos(phi[j]);
                  fprintf(file,""%g \t %g \t %g\n"", x[k],y[k],z[k])
                  k++;
             }
}
</code></pre>
",0
58391276,58390689,0,"<p>I think you mean the following while loop</p>

<pre><code>while ( f &lt; 0 || f &gt; 3 )
{
     printf(""-press 1 to calculate the sum of a and b\n"");
     printf(""-press 2 to calculate the difference between a and b\n"");
     printf(""-press 3 to calculate the product of a and b\n"");
     scanf( ""%d"", &amp;g );
     f = g;
}
</code></pre>

<p>That is pay attention to 1) the condition of the while loop, 2) removed the return statement and 3) removed the character <code>'\n'</code> in scanf because it is redundant.</p>

<p>And in printf calls remove the operator &amp; and use the conversion specifier %d.</p>

<pre><code> if ( f == 1 ) {
  printf("" A+B= %d\n"", c) ;
 }
 else if ( f == 2) {
  printf("" A-B= %d\n"", d );
 }
 else if ( f == 3 ) {
  printf("" A*B= %d\n"",e );
 }
</code></pre>
",0
55363308,55362750,0,"<blockquote>
  <p>I need to calculate the size of <code>func_A</code> and <code>func_B</code></p>
</blockquote>

<p>You may want to reassess that need, or edit your question to provide some justification here if you want more-useful answers.</p>

<blockquote>
  <p>Do you know when it is Ok to use functions pointer for such calculations</p>
</blockquote>

<p>In the absence of any indication of what platform you're using we must assume you're talking about the C Abstract Machine, and in that case <em>it is never OK</em>.</p>

<blockquote>
  <p>and why in this specific example I get the compilation error?</p>
</blockquote>

<p>Because the compiler is in this instance following the standard and also helpfully informing you of that.</p>
",0
56137295,56135821,1,"<p>The DMA controller uses a 16-bit transfer size. I was assuming that since I was multiplying size by sizeof(uint32_t) which has a value of 4 that there would always be an even number of bytes. If I change from a size = 7(what I had previously) to size = 8 everything works. </p>
",0
49557172,49557100,5,"<p><code>c</code> is a <code>char</code>. You asked to scan an <code>int</code>. PVS-Studio did right in warning you. Change the type of <code>c</code> to <code>int</code> and scan for a <code>%d</code>.</p>
",2
53735013,53734908,1,"<p>I think you're pretty close.  The big problem is that the value of temp and tempword aren't what you want to assign.  Most likely they won't change, but their contents will.  Also, you're using double pointers for your variables when you shouldn't need to do that.  I would change your code to be like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

typedef struct textBit
{
    int textID;
    char* theWord;
    int randInt;
} TextBit;

void printTextBit(TextBit bit);

int main()
{
    int counter = 0;
    char myText[] = ""hello this is a bunch of text i am just writing for an example to test something"";
    TextBit* textBits;
    textBits = malloc(sizeof(TextBit) * 16);

    char* tok = strtok(myText, "" "");
    while(tok != NULL)
    {
        TextBit *temp;
        temp = &amp;textBits[counter];
        temp-&gt;textID = counter;
        temp-&gt;randInt = 25;
        temp-&gt;theWord = strdup(tok);

        printf(""%d %s\n"", counter, tok);
        //printTextBit(temp);

        counter++;
        tok = strtok(NULL, "" "");
    }

    for(int i = 0; i &lt; counter; i++) {
        printTextBit(textBits[i]);
    }
}

void printTextBit(TextBit bit)
{
    printf(""TextBit: %s (#%d) - %d\n"", bit.theWord, bit.textID, bit.randInt);
}
</code></pre>

<p>Using strdup will copy the word over to your struct.  You could use malloc and strcpy separately, but strdup does both in one line.  Also, this code uses <code>temp</code> to point into the textBits array.</p>
",0
51665801,51658307,4,"<p>What exactly constitutes a ""variable"" differs from language to language.  It also matters what kind of a runtime environment is used - native binary (C/C++/Fortran/Cobol/Pascal), bytecode in a virtual machine (Java/C#/Scala/F#), a source-level interpreter (old-skool BASIC, bash/csh/sh), etc.  </p>

<p>In the case of C, a variable is simply a chunk of memory large enough to hold the value of the specified type - there is no metadata associated with that memory chunk that tells you anything about its name (which typically isn't preserved in the machine code), its type, whether it's part of an array or not, etc.  IOW, if you examined an integer variable in memory in a running program, all you'd see is the value stored in that integer.  You wouldn't see any other information stored <em>about</em> that variable.  </p>

<p><em>During translation</em> (i.e., while the code is being compiled), the compiler maintains an internal table that keeps track of variables, variable names, types, scope, visibility, etc.  However, none of that information (usually) makes it into the generated machine code.  <code>auto</code> (local) variables are typically referred to by an offset from given stack address.  <code>static</code> variables typically have a fixed address.  Values of different types are dealt with by using different machine code instructions (for example, there are usually separate instructions for dealing with integers vs. floats).  </p>

<p>A pointer variable simply stores an address.  The exact format of that address will vary based on the system, but on modern x86 and similar systems, it's essentially an unsigned integer value.  On a segmented memory system, it may be a pair of values (page # and offset).  </p>

<p><strong>EDIT</strong></p>

<p>C code is typically compiled into a native binary (although there's at least one compiler that targets the Java VM, and there may be compilers that target other virtual machines).  On an x86-like system, a running native binary is typically laid out like this in (virtual!) memory:</p>

<pre><code>              +-------------------------+
High address: | Environmental variables |
              | and command line args   |
              +-------------------------+
              |        Stack            |
              |          |              |
              |          V              |
              |          ^              |
              |          |              |
              |         Heap            |
              +-------------------------+
              | Read-only data items    |
              +-------------------------+
              | Global data items       |
              +-------------------------+
              | Program text (machine   |
 Low address: | code)                   |
              +-------------------------+
</code></pre>

<p>The exact details vary from system to system, but this is a decent overall view.</p>

<p>Each time a function is called (including <code>main</code>), memory is taken from the stack to build what is called a <em>stack frame</em>.  The stack frame contains space for the function arguments (if any), local variables (if any), address of the previous stack frame, and the address of the next instruction to execute after the function returns.  </p>

<pre><code>              +--------------------+
High address: | Function arguments |
              +--------------------+
              | Return address     |
              +--------------------+
              | Prev frame address | &lt;-- %rbp/%ebp (frame pointer)
              +--------------------+
 Low address: | Local variables    | &lt;-- %rsp/%esp (stack pointer)
              +--------------------+ 
</code></pre>

<p>The <code>%rsp</code> (64-bit) or <code>%esp</code> (32-bit) register stores the address of the top of the stack (on x86, the stack grows ""down"" towards decreasing addresses), and the <code>%rbp</code> (64-bit) or <code>%ebp</code> (32-bit) register stores the address of the stack frame.  Function arguments and local variables are referred to via offsets from the frame pointer, such as</p>

<pre><code>-4(%rpb) -- object starting 4 bytes ""below"" current frame address
32(%rbp) -- object starting 32 bytes ""above"" current frame address
</code></pre>

<p>Here's an example - we have a function <code>foo</code> that takes two <code>int</code> arguments and has two <code>int</code> local variables:</p>

<pre><code>#include  &lt;stdio.h&gt;

void foo( int x, int y )
{
  int a;
  int b;

  a = 2 * x + y;
  b = x - y;

  printf( ""x = %d, y = %d, a = %d, b = %d\n"", x, y, a, b );

}
</code></pre>

<p>Here's the generated assembly for that function (MacOS 10.13, LLVM version 9.1.0):</p>

<pre><code>        .section        __TEXT,__text,regular,pure_instructions
        .macosx_version_min 10, 13
        .globl  _foo                    ## -- Begin function foo
        .p2align        4, 0x90
_foo:                                   ## @foo
        .cfi_startproc
## BB#0:
        pushl   %ebp
Lcfi0:
        .cfi_def_cfa_offset 8
Lcfi1:
        .cfi_offset %ebp, -8
        movl    %esp, %ebp
Lcfi2:
        .cfi_def_cfa_register %ebp
        pushl   %ebx
        pushl   %edi
        pushl   %esi
        subl    $60, %esp
Lcfi3:
        .cfi_offset %esi, -20
Lcfi4:
        .cfi_offset %edi, -16
Lcfi5:
        .cfi_offset %ebx, -12
        calll   L0$pb
L0$pb:
        popl    %eax
        movl    12(%ebp), %ecx
        movl    8(%ebp), %edx
        leal    L_.str-L0$pb(%eax), %eax
        movl    8(%ebp), %esi
        shll    $1, %esi
        addl    12(%ebp), %esi
        movl    %esi, -16(%ebp)
        movl    8(%ebp), %esi
        subl    12(%ebp), %esi
        movl    %esi, -20(%ebp)
        movl    8(%ebp), %esi
        movl    12(%ebp), %edi
        movl    -16(%ebp), %ebx
        movl    %eax, -24(%ebp)         ## 4-byte Spill
        movl    -20(%ebp), %eax
        movl    %eax, -28(%ebp)         ## 4-byte Spill
        movl    -24(%ebp), %eax         ## 4-byte Reload
        movl    %eax, (%esp)
        movl    %esi, 4(%esp)
        movl    %edi, 8(%esp)
        movl    %ebx, 12(%esp)
        movl    -28(%ebp), %esi         ## 4-byte Reload
        movl    %esi, 16(%esp)
        movl    %edx, -32(%ebp)         ## 4-byte Spill
        movl    %ecx, -36(%ebp)         ## 4-byte Spill
        calll   _printf
        movl    %eax, -40(%ebp)         ## 4-byte Spill
        addl    $60, %esp
        popl    %esi
        popl    %edi
        popl    %ebx
        popl    %ebp
        retl
        .cfi_endproc
                                        ## -- End function
        .section        __TEXT,__cstring,cstring_literals
L_.str:                                 ## @.str
        .asciz  ""x = %d, y = %d, a = %d, b = %d\n""


.subsections_via_symbols
</code></pre>

<p>Here's what our stack frame will look like:</p>

<pre><code>              +---+
High address: | y |
              +---+
              | x |
              +---+
              |   | return address
              +---+
              |   | address of previous frame
              +---+
              | a |
              +---+
              | b |
              +---+
</code></pre>

<p>Now, that's how things look in 32-bit world.  64-bit gets a little more complicated - some function arguments are passed in registers rather than on the stack, so the nice neat picture above breaks down.  </p>

<p>Now, I'm talking about the concept of a variable <em>at runtime</em>, which is what I think you were asking about.  </p>
",3
52199158,52198887,0,"<p>The principle is certainly valid and is used when dealing with polymorphic objects (void* data members that can mean different things).</p>
",0
52199220,52198887,4,"<blockquote>
  <p>My confusion is that when <code>tm-&gt;free</code> is called to free <code>tm</code>, then <code>tm-&gt;free</code> will be also freed, will <code>tm-&gt;free</code> corrupt when it is be executed?</p>
</blockquote>

<p><code>tm-&gt;free</code> is not the whole function. It's merely a pointer to it. The code of the <code>xfree</code> function is entirely outside the memory region any <code>testmem</code> object occupies.</p>

<p>You must also note the sequence of events here. <code>tm-&gt;free</code> is evaluated to obtain the address of <code>xfree</code> <em>before</em> anything in the body of the function is executed. So the pointer to the function is valid when the call is made. And it only has to be valid up to that point. The pointer can become invalidated during the execution of the function, but it no longer matters, since its value is no longer needed.</p>

<hr>

<p>As a side note, and for some extra type safety, you don't need to mess with <code>void*</code> and pointer conversions. This has the same functionality...</p>

<pre><code>typedef struct testmem {
    int a;
    void (*free)(struct testmem *);
} testmem;

void xfree(testmem *mem) {
    printf(""Before: a = %d\n"", mem-&gt;a);
    free(mem);
    // Can't use mem anymore, it's invalid after free is called
}
</code></pre>

<p>... but keeps you from passing unrelated pointer types to the function.</p>
",0
50420070,50419518,1,"<p>That depends on what you mean by not re-compiling. You need to change the program file somehow, but you can do that in various ways:</p>

<ul>
<li>A hex editor other ""direct"" modification of the executable file, where you can look for the string ""John Doe"" and replace it with ""Johny"" (with extra null-byte padding), as described by <a href=""https://stackoverflow.com/a/50419620/27302"">PSkocik</a> and <a href=""https://stackoverflow.com/a/50419532/27302"">MustacheMoses</a></li>
<li>Depending on the modification, I am fairly sure there are more specialized tools for attempting them. I don't know what they are, though.</li>
<li>You could also make <code>NAME</code> be an <code>extern</code> variable instead of a macro, with <code>extern char *NAME;</code> in a header file and <code>char *NAME = ""John Doe"";</code> in a separate .c file. Then if you want to change the name, you just need to change it in the one, small, file where it's defined, re-compile that, and then just re-link with the rest of the program. That still involves some re-compiling, but it's a lot faster than re-compiling everything.</li>
</ul>

<p>To make a recommendation I'd need to know your use case, but the third option I mention is a lot more common than just modifying an executable file directly.</p>
",0
50419620,50419518,2,"<p>Not trivially. Included files get pasted into the source and the source nor the headers no longer technically exist in the binary output.</p>

<p>You can however edit the binary, and if you do it right (e.g., can't replace a 10-character string with a 3-character replacement as that'd misalign stuff), you can get it to work.</p>

<p>Example: (your example simplified):</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
      printf(""Name is: %s\n\n"",""John Doe"");
}
</code></pre>

<p>Compile, run, edit, re-run:</p>

<pre><code>$ gcc file.c 
$ ./a.out
  Name is: John Doe

$ sed -i 's/John Doe/Johnny\x00\x00/' a.out
$ ./a.out
  Name is: Johnny
</code></pre>
",6
56533839,56533288,3,"<p>This works because C has multiple <em>name spaces</em>:</p>

<ul>
<li>labels (disambiguated by <code>goto</code> or trailing <code>:</code>);</li>
<li>tag names for <code>struct</code>, <code>enum</code>, and <code>union</code> (disambiguated by the <code>struct</code>, <code>union</code>, or <code>enum</code> keywords):</li>
<li>names for <code>struct</code> and <code>union</code> members (disambiguated by a leading <code>.</code> or <code>-&gt;</code>, each <code>struct</code> or <code>union</code> type acts as its own namespace, so different <code>struct</code> and <code>union</code> types can use the same member names);</li>
<li>all other identifiers (variable and function names, typedef names, enumeration constants, etc.).  </li>
</ul>

<p>So you can use the same name as a label, a tag name, a member name, and a regular identifier all in the same code, and the compiler is able to distinguish between them:</p>

<pre><code>struct x { int x; }; // tag name, member name

void foo( struct x x ) // tag name, all other identifiers
{
  if ( x.x ) // all other identifiers, member name
    goto x;  // label name

  // do something here

  x: printf( ""At label x\n"" ); // label name
}
</code></pre>
",0
56533322,56533288,6,"<p>The line <code>typedef struct point point;</code> does two things:</p>

<ul>
<li>It creates a <strong>forward declaration</strong> of <code>struct point</code></li>
<li>It creates a type alias for <code>struct point</code> called <code>point</code>.</li>
</ul>

<p>Forward declarations are useful if you need to know a struct exits before it is fully defined, for example:</p>

<pre><code>typedef struct x X;

typedef struct y {
    int a;
    X *x;
} Y;

 struct x {
     int b;
     Y *y;
 };
</code></pre>
",1
56533371,56533288,2,"<p>You can use <code>struct foo</code> in many places before <code>struct foo { ... }</code> is defined. This is known as an ""incomplete type"".</p>

<p>It's useful because it lets you define abstract types:</p>

<p><em>foo_header.h</em></p>

<pre><code>struct foo;  // abstract
struct foo *foo_create(void);
void do_stuff_with(struct foo *);
void foo_destroy(struct foo *);
</code></pre>

<p>This way users of the library can use struct pointers and functions that work on these pointers without knowing how the struct is actually defined, which is nice for encapsulation.</p>

<p>It's also used in recursive types:</p>

<pre><code>struct node {
    int data;
    struct node *next;  // struct node isn't defined yet!
};
// here the definition of struct node is complete
</code></pre>

<p>C supports it because it's easy to implement: To compile code that uses <code>struct foo *</code>, the compiler only has to know how big the pointer is. It doesn't care about the struct members.</p>

<p>Similarly, in your <code>typedef</code> example, the compiler doesn't need to know the details of the struct to create a type alias for it.</p>
",0
48452310,48449808,1,"<p>Because you haven't shown us the way you construct the dungeon and more
importantly the data structures you use, it's impossible to give you a
definitive answer to this. The comments have good suggestions for you.</p>

<p>I'd like to comment some of the things you've done in your <code>main</code> function. The
comment section is just to small for this.</p>

<pre><code>if (strcmp(argv[1], ""--save"") == 0)
{
    action = write_binary;
}
</code></pre>

<p>That is not incorrect per se, but you <strong>should</strong> check that there is an argument
at all. If the user didn't pass an argument, <code>argv[1]</code> will be <code>NULL</code> and your
program will crash. Better this way:</p>

<pre><code>int main(int argc, char **argv)
{
    // argv[0] contains the name of the program,
    // if user executes your program like this:
    // ./yourprogram arg1 arg2 ... argv[0] will be
    // ./yourprogram
    if(argc != 2)
    {
        fprintf(stderr, ""usage: %s [--save | --load]\n"", argv[0]);
        return 1;
    }

    // now is safe to do this
    if (strcmp(argv[1], ""--save"") == 0)
    {
        action = write_binary;
    }

    ...

    return 0;
}
</code></pre>

<p>If your program eventually takes more arguments, it's better to use a helper
function like <a href=""http://man7.org/linux/man-pages/man3/getopt.3.html"" rel=""nofollow noreferrer""><code>getopt</code></a>. That makes life much easier.</p>

<pre><code>if (action = write_binary)
{
    f = fopen(pathway + ""save.bin"", ""wb"");
}
</code></pre>

<p>There are 2 errors here:</p>

<ol>
<li><p><code>if(action = write_binary)</code> is not the same as <code>if(action == write_binary)</code>.
The first one assigns the value of <code>write_binary</code> to <code>action</code>, it that value is
an scalar (can be converted into a number) other than 0, then the condition is
evaluated to <code>true</code>, <code>false</code> otherwise. If the value is not a scalar value, the
compiler will print you an error message.  </p>

<p>The second <code>if</code> compares if <code>action</code> and <code>write_binary</code> are the same. That's
most probably what you want.</p></li>
<li><p><code>pathway + ""save.bin""</code> does not concatenate strings. There is no native type
for strings in C, like C++'s <code>std::string</code> or Python's <code>String</code>. In C a string
is a sequence of bytes that ends with a byte of value <code>'\0'</code> (==0). You usually
use a <code>char</code> array or a pointer to an array of <code>char</code>s for saving strings.</p>

<p>A string literal (the one you write with quotes) returns in reality a pointer
to a read-only location where a strings is saved. Note that</p>

<pre><code>const char *str = ""hello"";
</code></pre>

<p>does not assign a string to <code>str</code>, it assigns the address where <code>""hello""</code> is
stored. That's why you always need functions like <code>strcpy</code> to copy strings.</p>

<p>You should do:</p>

<pre><code>int main(int argc, char **argv)
{
    ...
    FILE *f = NULL;

    char *ptr_path_home;
    const char *directory;
    const char *basename = ""save.bin""

    ptr_path_home = getenv(""HOME"");
    directory = "".rlg327"";

    char *pathway = malloc(strlen(ptr_path_home) + strlen(directory) +
            strlen(basename) + 3);

    // +3 because you need 2 slashes and the 0-terminating byte

    sprintf(pathway, ""%s/%s/%s"", ptr_path_home, directory, basename);
    ...

    if(action == write_binary)
    {
        // save file
        f = fopen(pathway, ""wb"");
        if(f == NULL)
        {
            free(pathway);
            perror(pathway);
            return 1;
        }
        ...
        fclose(f);

    }

    free(pathway);
    return 0;
}
</code></pre></li>
</ol>
",0
56048617,56048309,8,"<p>Not completely correct. You don't need to clear the whole <code>responseData</code> array - clearing its first byte is just enough:</p>

<pre><code> responseData[0] = 0;
</code></pre>

<p>As Gabriel Pellegrino notes in <a href=""https://stackoverflow.com/questions/56048309/why-do-variables-declared-with-the-same-name-in-different-scopes-get-assigned-th/56048617#comment98739222_56048617"">the comment</a>, a more idiomatic expression is</p>

<pre><code> responseData[0] = '\0';
</code></pre>

<p>It explicitly defines a character via its code point of zero value, while the former uses an <code>int</code> constant zero. In both cases the right-side argument has type <code>int</code> which is implicitly converted (truncated) to <code>char</code> type for assignment. (Paragraph fixed thx to the pmg's <a href=""https://stackoverflow.com/questions/56048309/why-do-variables-declared-with-the-same-name-in-different-scopes-get-assigned-th/56048617#comment98750414_56048617"">comment</a>.)</p>

<p>You could know that from the <code>strcat</code> documentation:  the function <strong>appends</strong> its second argument string to the first one. If you need the very first chunk to get <strong>stored</strong> into the buffer, you want to append it to an empty string, so you need to ensure the string in the buffer is empty. That is, it consists of the terminating NUL character only. <code>memset</code>-ting the whole array is an overkill,  hence a waste of time.</p>

<p>Additionally, using a <code>strlen</code> on the array is asking for troubles. You can't know what the actual contents of the memory block allocated for the array is. If it was not used yet or was overwritten with some other data since your last use, it <em>may</em> contain <em>no</em> NUL character. Then <code>strlen</code> will run out of the array causing Undefined Behavior. And even if it returns successfuly, it will give you the string's length bigger than the size of the array. As a result <code>memset</code> will run out of the array, possibly overwriting some vital data!</p>

<p>Use <strong>sizeof</strong> whenever you <code>memset</code> an array!</p>

<pre><code>memset(responseData, 0, sizeof(responseData));
</code></pre>

<p><strong>EDIT</strong></p>

<p>In the above I tried to explain how to fix the issue with your code, but I didn't answer your questions. Here they are:</p>

<ol>
<li><strong>Why do variables (...) in different scopes get assigned the same memory addresses?</strong></li>
</ol>

<p>In regard of execution each iteration of the <code>while(1) { ... }</code> loop indeed creates a new scope. However, each scope terminates before the new one is created, so the compiler reserves appropriate block of memory on the stack and the loop re-uses it in every iteration. That also simplifies a compiled code: every iteration is executed by exactly the same code, which simply jumps at the end to the beginning. All instructions within the loop that access local variables use exactly the same addressing (relative to the stack) in each iteration. So, each variable in the next iteration has precisely the same location in memory as in all previous iterations.</p>

<ol start=""2"">
<li><strong>I'm finding that I have to manually clear memory</strong></li>
</ol>

<p>Yes, automatic variables, allocated on the stack, are <em>not initialized</em> in C by default. We always need to explicitly assign an initial value before we use it ¨C otherwise the value is undefined and may be incorrect (for example, a floating-point variable can appear not-a-number, a character array may appear not terminated, an <code>enum</code> variable may have a value out of the enum's definition, a pointer variable may not point at a valid, accessible location, etc.).</p>

<ol start=""3"">
<li><strong>otherwise the contents (...) are just continuously appended</strong></li>
</ol>

<p>This one was answered above.</p>

<ol start=""4"">
<li><strong>Coming from JavaScript, this was surprising</strong></li>
</ol>

<p>Yes, JavaScript apparently <em>creates</em> new variables at the new scope, hence each time you get a brand new array ¨C and it is empty. In C you just get the same area of a previously allocated memory for an automatic variable, and it's your responsibility to initialize it.</p>

<p>Additionally, consider two consecutive loops:</p>

<pre><code>void test()
{
    int i;

    for (i=0; i&lt;5; i++) {
        char buf1[10];
        sprintf(buf1, ""%d"", i);
    }

    for (i=0; i&lt;1; i++) {
        char buf2[10];
        printf(""%s\n"", buf2);
    }
}
</code></pre>

<p>The first one prints a single-digit, character representation of five numbers into the character array, overwriting it each time - hence the last value of <code>buf1[]</code> (as a string) is <code>""4""</code>.</p>

<p>What output do you expect from the second loop? Generally speaking, we can't know what <code>buf2[]</code> will contain, and <code>printf</code>-ing it causes UB. However we <em>may suppose</em> the same set of variables (namely a single 10-items character array) from both disjoint scopes will get allocated the same way in the same part of a stack. If this is the case, we'll get a digit <code>4</code> as an output from a (formally uninitialized) array.</p>

<p>This result depends on the compiler construction and should be considered a coincidence. Do not rely on it as this is UB!</p>

<ol start=""5"">
<li><strong>Why wouldn't C just reset that memory behind the scenes?</strong></li>
</ol>

<p>Because it's not told to. The language was created to compile to effective, compact code. It does as little 'behind the scenes' as possible. Among others things it does <em>not</em> do is <em>not</em> initializing automatic variables unless it's told to. Which means you need to add an explicit initializer to a local variable declaration or add an initializing instruction (e.g. an assignment) before the first use. (This does not apply to global, module-scope variables; those are initialized to zeros by default.)</p>

<p>In higher-level languages some or all variables are initialized on creation, but not in C. That's its feature and we must live with it ¨C or just not use this language.</p>
",7
56048750,56048309,3,"<blockquote>
  <p>Why would I want to declare a variable and have access to the memory contents of a variable declared in a different scope with the same name? Why wouldn't  C just reset that memory behind the scenes?</p>
</blockquote>

<p>Objects with <code>auto</code> storage duration (i.e., block-scope variables) are not automatically initialized - their initial contents are <em>indeterminate</em>.  Remember that C is a product of the early 1970s, and errs on the side of runtime speed over convenience.  The C philosophy is that the programmer is in the best position to know whether something should be initialized to a known value or not, and is smart enough to do it themselves if needed.   </p>

<p>While you're <em>logically</em> creating and destroying a new instance of <code>responseData</code> on each loop iteration, it turns out the same memory location is being reused each time through.  We like to think that space is allocated for each block-scope object as we enter the block and released as we leave it, but in practice that's (usually) not the case - space for <em>all</em> block-scope objects within a function is allocated on function entry, and released on function exit<sup>1</sup>.  </p>

<p>Different objects in different scopes <em>may</em> map to the same memory behind the scenes.  Consider something like</p>

<pre><code>void bletch( void )
{
  if ( some_condition )
  {
    int foo = some_function();
    printf( ""%d\n"", foo );
  } 
  else
  {
    int bar = some_other_function();
    printf( ""%d\n"", bar );
  }
</code></pre>

<p>It's impossible for both <code>foo</code> and <code>bar</code> to exist at the same time, so there's no reason to allocate separate space for both - the compiler will (usually) allocate space for one <code>int</code> object at function entry, and that space gets used for either <code>foo</code> or <code>bar</code> depending on which branch is taken.  </p>

<p>So, what happens with <code>responseData</code> is that space for <em>one</em> 8000-character array is allocated on function entry,?and that same space gets used for each iteration of the loop.  That's why you need to clear it out on each iteration, either with a <code>memset</code> call or with an initializer like</p>

<pre><code>char responseData[8000] = {0}; 
</code></pre>

<p><hr>
<sup></p>

<ol>
<li>As M.M points out in a comment, this isn't true for variable-length arrays (and potentially other variably modified types) - space for those <em>is</em> set aside as needed, although where that space is taken from isn't specified by the language definition.  For all other types, though, the <em>usual</em> practice is to allocate all necessary space on function entry.
</ol>

<p></sup></p>
",1
52160777,21670041,1,"<p>You have to use the set_member_name and begin_object. The former sets the name of the subobject, and the latter inits the subobject so the rest of data goes inside it. </p>

<p>For example, from my <a href=""http://git.level2crm.com/mobile/level2-native-sdk/blob/develop/src/comms/countly-proxy.c"" rel=""nofollow noreferrer"">Countly app</a>:</p>

<pre><code>  json_builder_begin_object (builder);

  if(crash-&gt;hardware){
      json_builder_set_member_name (builder, ""hardware"");
      json_builder_begin_object(builder);
      if(crash-&gt;hardware-&gt;os){
      json_builder_set_member_name (builder, ""_os"");
      json_builder_add_string_value (builder, crash-&gt;hardware-&gt;os);
      }

      if(crash-&gt;hardware-&gt;os_version) {
      json_builder_set_member_name (builder, ""_os_version"");
      json_builder_add_string_value (builder, crash-&gt;hardware-&gt;os_version);
      }
      if(crash-&gt;hardware-&gt;manufacture) {
      json_builder_set_member_name (builder, ""_manufacture"");
      json_builder_add_string_value (builder, crash-&gt;hardware-&gt;manufacture);
      }
      if(crash-&gt;hardware-&gt;device) {
      json_builder_set_member_name (builder, ""_device"");
      json_builder_add_string_value (builder, crash-&gt;hardware-&gt;device);
      }
      if(crash-&gt;hardware-&gt;resolution) {
      json_builder_set_member_name (builder, ""_resolution"");
      json_builder_add_string_value (builder, crash-&gt;hardware-&gt;resolution);
      }
      if(crash-&gt;hardware-&gt;app_version) {
      json_builder_set_member_name (builder, ""_app_version"");
      json_builder_add_string_value (builder, crash-&gt;hardware-&gt;app_version);
      }
      if(crash-&gt;hardware-&gt;cpu) {
      json_builder_set_member_name (builder, ""_cpu"");
      json_builder_add_string_value (builder, crash-&gt;hardware-&gt;cpu);
      }
      if(crash-&gt;hardware-&gt;opengl) {
      json_builder_set_member_name (builder, ""_opengl"");
      json_builder_add_string_value (builder, crash-&gt;hardware-&gt;opengl);
      }
      json_builder_end_object (builder);

  }
</code></pre>
",0
59307779,31897880,0,"<pre><code>    unsigned long LMAX=(unsigned long)-1L;
    long SLMAX=LMAX/2;
    long SLMIN=-SLMAX-1;
</code></pre>

<p>If you don't have yhe L suffix just use a variable or cast to signed before castong to unsigned.</p>

<p>For long long:</p>

<pre><code>    unsigned long long LLMAX=(unsigned long long)-1LL;
</code></pre>
",0
51074378,26948723,-1,"<p>There are many ways to check if <code>stdin</code> has input available. The most portable ones are, in that order: <code>select</code>, <code>fcntl</code> and <code>poll</code>. </p>

<p>Here some snippets on how to do it, case by case.</p>

<pre><code>#include &lt;stdio.h&gt; /* same old */
#include &lt;stdlib.h&gt; /* same old */
#include &lt;time.h&gt; /* struct timeval for select() */
#include &lt;unistd.h&gt; /* select() */
#include &lt;poll.h&gt; /* poll() */
#include &lt;sys/ioctl.h&gt; /* FIONREAD ioctl() */
#include &lt;termios.h&gt; /* tcgetattr() and tcsetattr() */
#include &lt;fcntl.h&gt; /* fnctl() */

#define BUFF 256

int chkin_select(void);
int chkin_poll(void);
int chkin_ioctl(void);
int chkin_fcntl(void);
int chkin_termios(void);

/*
  Simple loops to test varios options of non-blocking test for stdin
*/

int main(void)
{
    char sin[BUFF]=""r"";

    printf(""\nType 'q' to advance\nTesting select()\n"");
    while(sin[0]++ != 'q')
    {
        while(!chkin_select())
        {
            printf(""nothing to read on select()\n"");
            sleep(2);
        }
        fgets(sin, BUFF, stdin);
        printf(""\nInput select(): %s\n"", sin);
    }

    printf(""\nType 'q' to advance\nTesting poll()\n"");
    while(sin[0]++ != 'q')
    {
        while(!chkin_poll())
        {
            printf(""nothing to read poll()\n"");
            sleep(2);
        }
        fgets(sin, BUFF, stdin);
        printf(""\nInput poll(): %s\n"", sin);
    }

    printf(""\nType 'q' to advance\nTesting ioctl()\n"");
    while(sin[0]++ != 'q')
    {
        while(!chkin_ioctl())
        {
            printf(""nothing to read ioctl()\n"");
            sleep(2);
        }
        fgets(sin, BUFF, stdin);
        printf(""\nInput ioctl(): %s\n"", sin);
    }

    printf(""\nType 'q' to advance\nTesting fcntl()\n"");
    while(sin[0]++ != 'q')
    {
        while(!chkin_fcntl())
        {
            printf(""nothing to read fcntl()\n"");
            sleep(2);
        }
        fgets(sin, BUFF, stdin);
        printf(""\nInput fcntl: %s\n"", sin);
    }

    printf(""\nType 'q' to advance\nTesting termios()\n"");
    while(sin[0]++ != 'q')
    {
        while(!chkin_termios())
        {
            printf(""nothing to read termios()\n"");
            sleep(2);
        }
        fgets(sin, BUFF, stdin);
        printf(""\nInput termios: %s\n"", sin);
    }

    return EXIT_SUCCESS;
}

/*
   select() and pselect() allow a program to monitor multiple file
   descriptors, waiting until one or more of the file descriptors become
   ""ready"" for some class of I/O operation (e.g., input possible).  A
   file descriptor is considered ready if it is possible to perform a
   corresponding I/O operation (e.g., read(2) without blocking, or a
   sufficiently small write(2)).
 */
int chkin_select(void)
{
    fd_set rd;
    struct timeval tv={0};
    int ret;

    FD_ZERO(&amp;rd);
    FD_SET(STDIN_FILENO, &amp;rd);
    ret=select(1, &amp;rd, NULL, NULL, &amp;tv);

    return (ret&gt;0);
}

/*  poll() performs a similar task to select(2): it waits for one of a
       set of file descriptors to become ready to perform I/O.

       The set of file descriptors to be monitored is specified in the fds
       argument, which is an array of structures of the following form:

           struct pollfd {
               int   fd;         // file descriptor //
               short events;     // requested events //
               short revents;    // returned events //
           };

       The caller should specify the number of items in the fds array in
       nfds.
*/
int chkin_poll(void)
{
    int ret;
    struct pollfd pfd[1] = {0};

    pfd[0].fd = STDIN_FILENO;
    pfd[0].events = POLLIN;
    ret = poll(pfd, 1, 0);

    return (ret&gt;0);
}

/*
    The ioctl(2) call for terminals and serial ports accepts many
       possible command arguments.  Most require a third argument, of
       varying type, here called argp or arg.

       Use of ioctl makes for nonportable programs.  Use the POSIX interface
       described in termios(3) whenever possible.
*/
int chkin_ioctl(void)
{
    int n;
    ioctl(STDIN_FILENO, FIONREAD, &amp;n);
    return (n&gt;0);
}

/*
       fcntl() performs one of the operations described below on the open
       file descriptor fd.  The operation is determined by cmd.

       fcntl() can take an optional third argument.  Whether or not this
       argument is required is determined by cmd.  The required argument
       type is indicated in parentheses after each cmd name (in most cases,
       the required type is int, and we identify the argument using the name
       arg), or void is specified if the argument is not required.

       Certain of the operations below are supported only since a particular
       Linux kernel version.  The preferred method of checking whether the
       host kernel supports a particular operation is to invoke fcntl() with
       the desired cmd value and then test whether the call failed with
       EINVAL, indicating that the kernel does not recognize this value.
*/
int chkin_fcntl(void)
{
    int flag, ch;

    flag = fcntl(STDIN_FILENO, F_GETFL, 0); /* save old flags */
    fcntl(STDIN_FILENO, F_SETFL, flag|O_NONBLOCK); /* set non-block */
    ch = ungetc(getc(stdin), stdin);
    fcntl(STDIN_FILENO, F_SETFL, flag); /* return old state */

    return (ch!=EOF);
}

/*
 The termios functions describe a general terminal interface that is provided to control asynchronous communications ports.
 This function doesn't wait for '\n' to return!
 */
int chkin_termios(void)
{
    struct termios old, new;
    int ch;

    tcgetattr(STDIN_FILENO, &amp;old); /* save settings */

    new = old;
    new.c_lflag &amp;= ~ICANON; /* non-canonical mode: inputs by char, not lines */ 
    new.c_cc[VMIN] = 0; /* wait for no bytes at all */
    new.c_cc[VTIME] = 0; /* timeout */
    tcsetattr(STDIN_FILENO, TCSANOW, &amp;new); /* new settings */

    ch = ungetc(getc(stdin), stdin); /* check by reading and puking it back */

    tcsetattr(STDIN_FILENO, TCSANOW, &amp;old); /* restore old settings */
    return (ch!=EOF);
}
</code></pre>

<p>Try to avoid <code>ioctl</code> and <code>termios</code>, they are too specific, or too low-level. Also, you can't really use <code>feof</code> in a meaningful way with stdin or any FIFO for that matter. You can guarantee the pointer position, and if you try <code>ftell</code> or <code>fseek</code> you will get an error (ask <code>perror</code>).</p>

<hr>

<p>References:</p>

<ul>
<li><a href=""http://man7.org/linux/man-pages/man2/select.2.html"" rel=""nofollow noreferrer"">http://man7.org/linux/man-pages/man2/select.2.html</a></li>
<li><a href=""http://man7.org/linux/man-pages/man2/poll.2.html"" rel=""nofollow noreferrer"">http://man7.org/linux/man-pages/man2/poll.2.html</a></li>
<li><a href=""http://man7.org/linux/man-pages/man2/ioctl.2.html"" rel=""nofollow noreferrer"">http://man7.org/linux/man-pages/man2/ioctl.2.html</a></li>
<li><a href=""http://man7.org/linux/man-pages/man2/fcntl.2.html"" rel=""nofollow noreferrer"">http://man7.org/linux/man-pages/man2/fcntl.2.html</a></li>
<li><a href=""http://man7.org/linux/man-pages/man3/termios.3.html"" rel=""nofollow noreferrer"">http://man7.org/linux/man-pages/man3/termios.3.html</a></li>
</ul>
",5
55091769,50026717,0,"<p>You ran out of memory.</p>

<p>Every pass around the loop <code>for(int i = 2; i &lt;= n; ++i)</code> potentially doubles the size of <code>res</code>, and you called it with <code>n == INT_MAX</code>. Ain't no computer in the universe that can allocate <code>1&lt;&lt;INT_MAX</code> bytes of RAM.</p>

<p>The problem statement says to run for <code>n == 30</code>. Your output suggests enough RAM to run for 30.</p>
",0
52123305,52123304,2,"<p>Assignments, using the <code>=</code> operator, can be easily confused with the equality <code>==</code> operator. This is clearly shown by this part of the text:</p>

<blockquote>
  <p>Although the intent of the code may be to assign <code>b</code> to <code>a</code> and test the value of the result for equality to <code>0</code>, it is frequently a case of the programmer mistakenly using the assignment operator <code>=</code> instead of the equals operator <code>==</code>. </p>
</blockquote>

<p>I agree that in the case of the <code>while</code> loop - where you expect that each loop takes the next element - this element of surprise is not really present for accomplished coders. For new coders it may still wrong foot-them. Either they mistake the assignment for testing equality or they don't directly see when the result of the expression is <code>0</code>.</p>

<hr>

<p>I'd make sure the expression is written <code>while (ptr != NULL)</code> because that way the intent is most clear, and the expression doesn't have any side effects. You could use <code>while ((ptr = ptr-&gt;next) != NULL)</code> if you do allow a single side effect within selection statements (I prefer the term ""flow control statements"" myself, but that's more Java-like).</p>

<p>I'd myself stay away from the additional parentheses as in <code>while ((ptr = ptr-&gt;next))</code> as that may be mistaken for sloppiness and code beautifiers may warn against the unnecessary parentheses.</p>
",0
54027461,53994115,0,"<p>As already mentioned, when serializing data in and out of the CPU it is preferable to force network byte order. This can be done easily using functions like <code>htonl()</code>, which should be available on most platforms (and compile down to nothing on big endian machines).</p>

<p>Here's the doc from Linux:
<a href=""https://linux.die.net/man/3/htonl"" rel=""nofollow noreferrer"">https://linux.die.net/man/3/htonl</a></p>

<p>Also, it's not good practice to explicitly code sizes and types into your program.
Use <code>sizeof(array[0][0])</code> to get the size of the element type of <code>array</code>, then iterate over it and use <code>htonl()</code> to write each element to the file.</p>
",0
53994151,53994115,1,"<p>No, it is not the right way if you plan to transfer the file to a different machine and read it as you haven't considered the <a href=""https://en.wikipedia.org/wiki/Endianness"" rel=""nofollow noreferrer"">Endianness</a>. Let's say the file is:</p>

<ol>
<li>Written in little endian machine but read in big endian machine</li>
<li>Written in big endian machine but read in little endian machine</li>
</ol>

<p>It won't work for none of the cases above.</p>
",0
54027461,53994115,0,"<p>As already mentioned, when serializing data in and out of the CPU it is preferable to force network byte order. This can be done easily using functions like <code>htonl()</code>, which should be available on most platforms (and compile down to nothing on big endian machines).</p>

<p>Here's the doc from Linux:
<a href=""https://linux.die.net/man/3/htonl"" rel=""nofollow noreferrer"">https://linux.die.net/man/3/htonl</a></p>

<p>Also, it's not good practice to explicitly code sizes and types into your program.
Use <code>sizeof(array[0][0])</code> to get the size of the element type of <code>array</code>, then iterate over it and use <code>htonl()</code> to write each element to the file.</p>
",0
52572148,52572053,1,"<p>The problem is </p>

<pre><code>cur = cur -&gt; next; // You read an uninitialized value (garbage)
</code></pre>

<p>Set the values for the new node after reserving space</p>

<pre><code>*new = malloc ( sizeof (struct SinglyLinkedListNode)) ...

new-&gt;data = data;
new-&gt;next = NULL;
</code></pre>
",1
56651536,56651136,1,"<blockquote>
  <p>malloc just allocates empty space (with no assumption about the object that will be put there)</p>
</blockquote>

<p>Correct. Dynamically allocated memory specifically, has no type until the point where you write something to that area. Formally the C language calls this the <strong><em>effective type</em></strong>. The formal definition is found in C17 6.5/7:</p>

<blockquote>
  <p>The <em>effective type</em> of an object for an access to its stored value is the declared type of the object, if any. If a value is stored into an object having no declared type through an lvalue having a type that is not a character type, then the type of the lvalue becomes the effective type of the object for that access and for subsequent accesses that do not modify the stored value.</p>
</blockquote>

<p>What's returned from malloc is just a raw chunk of memory, with no special attributes, until the point where you write to that area. After which the compiler has to put a ""type label"" on it internally. As soon as you access it by using [], the compiler will have to assume that the data allocated has to be treated as an array, to keep the type system consistent between statically allocated and dynamically allocated objects.</p>

<p>Similarly, the memory area becomes a struct at the point when you access the memory, as it will have padding etc and dictate the memory offset of each member. So if given a struct with opposite order of your example, like this:</p>

<pre><code>struct test {
    char a;
    int  b;
};
</code></pre>

<p>Then it is implementation-defined if <code>x-&gt;b</code> will result in access to byte 1, byte 4 or something else, since the compiler is free to add padding between the members.</p>

<p>But as soon as you access <code>x-&gt;something</code>, the compiler will have to start regarding whatever <code>x</code> points at as effective type <code>struct test</code>, or the type system wouldn't behave consistently.</p>
",0
52255412,52250685,2,"<p>You can use a macro to invoke the timing logic based on the value in your variable 'timing'</p>

<pre><code>#include &lt;stdio.h&gt;

int elapsed1 = 0, time1 = 0;
int timing = -1;

#define TIMEIT(x) \
if (timing) {\
time1=getTime();} \
x;\
if (timing) {elapsed1+=getTime()-time1;}


void a(void);
int getTime();

int main()
{
    printf(""Hello, World!\n"");

    timing = -1;
    TIMEIT(a());

    timing = 0;
    TIMEIT(a());

    return 0;
}
void a(void) {printf(""\n Hello from a()"");}
int getTime() {printf(""\n Hello from getTime()""); return 42;}
</code></pre>
",2
51920129,51920030,3,"<p>You appear to want the (partial) sum of a <a href=""https://en.wikipedia.org/wiki/Geometric_progression"" rel=""nofollow noreferrer"">geometric progression</a>, a*r^n with <code>a == 1</code> and <code>r == 10</code>.</p>

<p>I wouldn't even bother with recursion:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdint.h&gt;

double partial_sum(double a, double r, size_t n) {
    double x = 0;
    for (size_t i = 0; i &lt; n; ++i) {
        x += pow(r, i);
    }
    return x;
}
</code></pre>
",1
51868904,51868895,9,"<p>Here's how you check: Did you free it before? If so, it's been freed. If not, no.</p>

<p>C doesn't track this for you, so you may want to <code>NULL</code> out any pointers you <code>free</code> if you lose track of if you have or haven't released the associated memory.</p>

<p>C does the most minimal thing unless you spell out explicitly that you want it to do something more:</p>

<pre><code>free(p);
p = NULL;
</code></pre>

<p>Now you can test, but remember, it's your responsibility to do this, so if this behaviour is important, you must do it consistently.</p>
",0
59448682,59447452,0,"<p>This is not particularly a good idea, but easy to do:</p>

<pre><code>execlp(""sh"", ""sh"", ""-c"", ""ls -la -R / | grep \""^l\"" &gt; somefile.txt"", (char *)0);
</code></pre>
",0
59437247,59437116,2,"<pre><code>char *str = ""test"";
</code></pre>

<p>There are 2 objects ""in play"" here: the <code>str</code> object of type <code>char*</code> (pointer to char) and the unnamed object of type <code>char[5]</code>.</p>

<p>The unnamed array object (with contents <code>{'t', 'e', 's', 't', 0}</code>), when used as initialization value for a pointer get converted to a pointer to its first element and it's that address that gets copied to <code>str</code>.</p>

<p>There is no allocation of memory, so there is no chance of having memory leaking!</p>
",4
53038654,53038637,1,"<p>Let us take a string of length 5 -- <code>abcde</code>. <code>len</code> is 5.</p>

<pre><code>while (index &gt;=0) {
    printf(""%c"", s[index]);
    index--;
}
</code></pre>

<p>For the first element in the loop, you are printing <code>s[index]</code>. You want to print <code>e</code> i.e. <code>s[4]</code></p>

<p>Therefore you need to set index as <code>len-1</code></p>

<p>If not, you are printing <code>s[5]</code> which is <code>\0</code>, the NULL terminator.</p>
",0
50563515,50563406,1,"<p>It is a known flaw in the C language that <code>|</code> and <code>&amp;</code> have lower precedence than <code>==</code> (Dennis Ritchie admitted this at some point). This is the practical reason why your code doesn't work.</p>

<p>Solve this by writing the macro properly:</p>

<pre><code>#define MASK_A (IPC_CREAT | IPC_EXCL | 0666)
</code></pre>

<p>Any decent C programming book will address issues like this and show how to write macros properly with parenthesis.</p>
",2
50563541,50563406,2,"<p>It is advised to <em>always</em> parenthesise your macros</p>

<pre><code>#define MASK_A (IPC_CREAT|IPC_EXCL|0666)
</code></pre>

<p>Especially when it comes to <code>&amp;</code> and <code>|</code>, C's precedence rules
can be confusing:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
int main()
{
    int mask = 0xAA|0xBB00; assert(mask==0xBBAA);

    printf(""%x\n"", 0xAA|0xBB00 == mask);
    //prints aa because 0xAA|(0xBB00==mask /*false==0*/)  equals 0xAA
    //IOW, == has a higher precedence than |  
    //ans so 0xAA|0xBB00==mask is equivalent to 0xAA|(0xBB00==mask) 

    printf(""%x\n"", (0xAA|0xBB00) == mask);
    //prints 1 ¡ª parentheses force the intended grouping
}
</code></pre>

<p>As Denis Ritchie, the language's author, put it in the first K&amp;R,</p>

<blockquote>
  <p><a href=""https://en.wikipedia.org/wiki/C_(programming_language)#cite_note-22"" rel=""nofollow noreferrer"">""Some of the operators have the wrong precedence; some parts of the
  syntax could be better.""</a></p>
</blockquote>

<p>He explains these precedences for <code>|</code> and <code>&amp;</code> in his article, 
<a href=""http://The%20Development%20of%20the%20C%20Language"" rel=""nofollow noreferrer"">The Development of the C Language*</a> where he explains that 
<code>|</code> and <code>&amp;</code> were used in <code>B</code> instead of the short-circuiting, logical <code>||</code> and <code>&amp;&amp;</code> (which B didn't have and neither did prehistoric C) and so the precedence rules for <code>|</code> and <code>&amp;</code> were so that:</p>

<pre><code>  if (a==b &amp; c)
</code></pre>

<p>would be parsed as</p>

<pre><code> if ((a==b) &amp; c)
</code></pre>

<p>The short-circuting, logical <code>&amp;&amp;</code> and <code>||</code> were later added, but the original precedences for <code>|</code> and <code>&amp;</code> were kept.</p>
",0
58966115,58965609,0,"<p>This is an oversight in the language design, it only allows implicit addition of <code>const</code> at the first level.   </p>

<p>You'll have to either use a cast or change the function parameter type.</p>

<p><a href=""https://stackoverflow.com/a/8909208/1505939"">Related answer</a></p>
",0
53466590,53466525,4,"<p>All the <code>malloc(sizeof(node*))</code> should be <code>malloc(sizeof(node))</code>. You're only alloocating enough space for a pointer, not the whole structure. This is causing undefined behavior with all the following code that indirects through these pointers.</p>
",0
55340402,55340259,4,"<p>The warning is when the first reference to a struct is inside something else.</p>

<p>Put <code>struct screen;</code> above the declaration of <code>struct window</code>.</p>

<p>Circular dependencies of header files is a bad idea. Consider refactoring. You do not need the definition of a struct to declare pointers to it. The forward declaration will suffice.</p>
",2
55340651,55340259,2,"<p>This is about fundamental design, nothing else. To have two header files that mutually include each other simply doesn't make any sense, don't do this. <code>#include</code> is to be regarded as a one-way dependency. In program design, more complex objects depend on/consist of less complex ones.</p>

<p>For example a screen contains a window, so it should be the one doing <code>#include ""window.h""</code>. While a window doesn't know a thing about screens, it should only concern itself with displaying a window. Cross-communication between the two modules might have to be in a third module.</p>
",0
59138468,59134158,2,"<p>A simple example of a value with more than one representation is an IEEE floating point zero. It has a ""positive zero"" and a ""negative zero"" representations. </p>

<p><em>Note</em> An implementation that conforms to IEC 60559 must distinguish between positive and negative zeros, so in such an implementation they are different values rather than different representations of the same value. However an implementation doesn't need to conform to IEC 60559. Such implementations are allowed to e.g. always rerurn the same value for signbit of zero, even though the underlying hardware distinguishes +0 and -0.</p>

<p>On a sign-and-magnitude machine, integer zeros also have more than one representation.</p>

<p>On a segmented architecture like the 16-bit 8086, ""long"" pointers have more than one representation, for example 0x0000:0x0010 and 0x0001:0x0000 are two representations of the same pointer value.</p>

<p>Finally, in any data type with padding, padding bits do not influence the value. Examples include structs with padding holes.</p>
",2
59137853,59134158,6,"<p>An <em>object</em> is a region of storage (memory) that can contain values of a certain type [C18 3.15].</p>

<p>An <em>object representation</em> are the Bytes that make up the contents of an object [C18 6.2.6.1].</p>

<p>Not every possible combination of Bytes in an object representation also has to correspond to a value of the type (an object representation that doesn't is called a <em>trap representation</em> [C18 3.19.4]).</p>

<p>And not all the Bits in an object representation have to participate in representing a value. Consider the following type:</p>

<pre class=""lang-c prettyprint-override""><code>struct A
{
    char c;
    int n;
};
</code></pre>

<p>Compilers are allowed to (and generally will) insert padding Bytes between the members <code>c</code> and <code>n</code> of this struct to ensure correct alignment of <code>n</code>. These padding Bytes are part of an object of type <code>struct A</code>. They are, thus, part of the object representation. But the values of these padding Bytes do not have any effect on the logical value of type <code>A</code> that is stored in the object.</p>

<p>Let's say we're on a target platform where Bytes consist of 8 Bits, an <code>int</code> consists of 4 Bytes in little endian order, and there are 3 padding Bytes between <code>c</code> and <code>n</code> to ensure that <code>n</code> starts at an offset that is a multiple of 4. The value <code>(struct A){42, 1}</code> may be stored in an object as</p>

<pre><code>2A 00 00 00 01 00 00 00
</code></pre>

<p>But it may as well be stored in an object as</p>

<pre><code>2A FF FF FF 01 00 00 00
</code></pre>

<p>or whatever else the padding Bytes may happen to be. Each of these sequences of Bytes is a valid object representation of <em>the same</em> logical value of type <code>struct A</code>.</p>

<p>This is also what the footnote is about. If you had two objects <code>x</code> and <code>y</code> that each contained a different object representation of the same value of type <code>struct A</code>, then <code>x == y</code> will evaluate to true while simply performing a <code>memcmp()</code> will not since <code>memcmp()</code> simply compares the bytes of the object representation without any consideration as to what the logical value stored in these objects actually is&hellip;</p>
",7
53152440,53152341,4,"<p>Your <code>sizeof(node*)</code> does not represent the size you need.</p>

<pre><code>newnode = malloc(sizeof(node*))    // wrong
newnode = malloc(sizeof (node))    // correct
newnode = malloc(sizeof *newNode)  // better
</code></pre>

<hr>

<p>Why is <code>sizeof *newNode</code> better?</p>

<p>Because it prevents accidental forgetting to update the code in <strong>two</strong> places if the type changes</p>

<pre><code>struct node {
    char *data;
    struct node *next;
    struct node *prev;
};
struct nodeEx {
    char *data;
    size_t len;
    struct nodeEx *next;
    struct nodeEx *prev;
};

struct nodeEx *newnode = malloc(sizeof (struct node)); // wrong
struct nodeEx *newnode = malloc(sizeof *newnode);      // correct
</code></pre>
",3
51281827,22984503,2,"<p>I know this is not necessary related to the question but it might be useful for some of you. </p>

<p>My solution in <strong>Java</strong> with <strong>100%</strong> is the following:</p>

<pre>
<code>
class Solution {
    public int solution(int[] A) {
        Arrays.sort(A);
        int n = A.length;

        int maxWithNegativeNumbers = A[0] * A[1] * A[n - 1];
        int maxWithPositiveNumbers = A[n - 3] * A[n - 2] * A[n - 1];

        return Math.max(maxWithNegativeNumbers, maxWithPositiveNumbers);
    }
}
</code>
</pre>

<p>You need to add the following import as well: </p>

<pre><code> import java.util.*;
</code></pre>
",0
57846177,29272431,4,"<p>The correct way to make the stack executable doesn't require that stack canaries be disabled, unlike what the accepted answer suggests.</p>

<p>Here's the correct way:</p>

<pre><code>gcc -z execstack ...
</code></pre>

<p>What this does is, the <code>-z</code> option of <code>gcc</code> is passed to the linker [<a href=""https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html#index-z"" rel=""nofollow noreferrer"">source</a>]:</p>

<blockquote>
  <p><em>keyword</em></p>
  
  <p>-z?is passed directly on to the linker along with the keyword?<em>keyword</em>. See the section in the documentation of your linker for permitted
  values and their meanings.</p>
</blockquote>

<p>From <code>man ld</code> [<a href=""https://linux.die.net/man/1/ld"" rel=""nofollow noreferrer"">source</a>]:</p>

<blockquote>
  <p><strong>execstack</strong></p>
  
  <p>Marks the object as requiring executable stack.</p>
</blockquote>
",1
59224816,59222875,1,"<p>Your approach is broken. For example should the public part have a <code>double</code> and the private part just a <code>char</code>, the arithmetic would cause the the public part to be misaligned.</p>

<hr>

<p>What you can use and <em>should</em> use is the common initial prefix:</p>

<pre><code>struct thing {
    int public_attribute;
};

struct internal {
    struct thing public;
    int private_attribute;
};

struct thing *thing_init()
{
    struct internal *mem = malloc(sizeof(struct internal));
    internal-&gt;public-&gt;public_attribute = 6 * 9;
    internal-&gt;private_attribute = 42;

    return &amp;interal-&gt;public;

    // or
    return (struct thing *)internal;
}
</code></pre>

<p>I.e. the public part is the first member of the entire structure. This technique is well-defined in C. </p>

<p>Then in all functions that get in <code>struct thing *</code> you cast this pointer to <code>struct internal *</code>, and are ready to use the public and private members.</p>

<p>This technique is used e.g. by the CPython interpreter, where all Python objects in C code share a common initial sequence of <code>PyObject</code> followed by private parts.</p>
",2
57940090,57940058,1,"<p>The problem is ¨¢ occupies more than one character, So we have to do this in a string. Here, <code>sizeof(""¨¢"")</code> returns one more than the number of characters that ¨¢ occupies (the terminating null).</p>

<p>Let's try this:</p>

<pre><code>char wordoutput[50];
int j;
int k;
for(i = 0, j &lt; 0; i &lt; strlen(word); i ++){
    int match = 1;
    for (k = 0; match &amp;&amp; k &lt; sizeof(""¨¢"") - 1; k++)
        if (!word[i+k] || word[i+k] == ""¨¢""[k])
            match = 0;
    if (match)
        wordoutput[j++] = word[i];
    else {
        i += sizeof(""¨¢"") - 2;
        wordoutput[j++] = 'a';
    }
}
wordoutput[j++] = 0;
</code></pre>

<p>We build up the string in wordoutput, replacing all ¨¢ with a in the process.</p>
",0
56671771,56671636,0,"<p>Add additional loops to print tables two and three:</p>

<pre><code>void imprimir_3_tableros(char tablero1[10][10],char tablero2[10][10],char tablero3[10][10]){
int i;
int j;

printf(""  A    B    C    D    E    F    G    H    I    J             A    B    C    D    E    F    G    H    I    J              A    B    C    D    E    F    G    H    I    J\n"");

printf(""¨X¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨[        ""
       ""¨X¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨[        ""
       ""¨X¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨j¨T¨T¨T¨T¨[\n"");

for (i = 0; i &lt; 10; ++i) {
    if(i != 0)
        printf(""¨d¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨g       ""
               ""¨d¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨g       ""
               ""¨d¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨p¨T¨T¨T¨T¨g\n"");

    for (j = 0; j &lt; 10; ++j)
        printf(""¨U %d  "", tablero1[i][j]);

    printf(""¨U        "");

    for (j = 0; j &lt; 10; ++j)
        printf(""¨U %d  "", tablero2[i][j]);

    printf(""¨U         "");

    for (j = 0; j &lt; 10; ++j)
        printf(""¨U %d  "", tablero3[i][j]);

    printf(""¨U\n"");
}
printf(""¨^¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨a        ""
       ""¨^¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨a        ""
       ""¨^¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨m¨T¨T¨T¨T¨a\n"");
}
</code></pre>

<p>Adjust spacing as needed.</p>
",1
52106963,52106691,1,"<p>There are some unresolved issues in the question, notably:</p>

<ul>
<li>How are the column sizes determined?</li>
<li>How will the caller free the allocated memory?</li>
</ul>

<p>Nonetheless, we can start answering. It looks like you need to allocate at least <strong>three</strong> spaces: One for the column sizes, one for the pointers to the columns, and one for all the actual <code>int</code> data. This supposes we put all the <code>int</code> data for all the columns in a single array but point into appropriate places in the array through the column pointers. An alternative is to allocate space for each column¡¯s data separately.</p>

<p>In the former case, the function could be:</p>

<pre><code>int **generate(int n, int **column_sizes)
{
    // Allocate space for columns sizes and assign column sizes.
    int NumberOfColumns = /* Some calculation not explained in question. */;
        // (size_t would be better than int, but I will use the types in the question.)
    int *sizes = malloc(NumberOfColumns * sizeof *sizes);
    // Insert code to abort if malloc failed.
    *column_sizes = sizes;
    int TotalElements = 0;
    for (int i = 0; i &lt; NumberOfColumns; ++i)
    {
        sizes[i] = /* Some calculation to find size of column i. */;
        TotalElements += sizes[i];
    }

    // Allocate space for pointers to columns.
    int **returned_array = malloc(NumberOfColumns * sizeof *returned_array);
    // Insert code to abort if malloc failed.

    // Allocate space for the actual int data.
    int *Space = malloc(TotalElements * sizeof *Space);
    // Insert code to abort if malloc failed.

    // Assign pointers to columns.
    returned_array[0] = Space;
    for (int i = 1; i &lt; NumberOfColumns; ++i)
        returned_array[i] = returned_array[i-1] + sizes[i-1];

    // Fill in the actual int data.
    for (int i = 0; i &lt; NumberOfColumns; ++i)
        for (int j = 0; j &lt; column_sizes[i]; ++j)
            returned_array[i][j] = /* Some unexplained calculation. */;

    return returned_array;
}
</code></pre>

<p>With this definition, the caller could free the memory by freeing the array of column sizes, freeing the space pointed to by the first pointer in the returned array, and freeing the returned array. If, in an alternative implementation, each column is allocated separately, the caller would have to free each pointer in the returned array.</p>
",4
51883858,51883764,2,"<p>Create a pointer to the variables in question:</p>

<pre><code>int *someDataVar1 = &amp;someDataStruct.longSubStructName.anotherLongName.theVariable;
int *someDataVar2 = &amp;someStruct.longSubStructName.anotherLongName.theVariable;

*someDataVar1 = *someDataVar2 + 10;
</code></pre>

<p>If you're using a deeply nested field like this many times in a block of code, doing something like this can help to increase readability.  If you only need to use it once or twice however you're probably better off leaving it way it is.</p>

<p>Here's an example where such a construct might make sense:</p>

<pre><code>for (clientNum = 0; clientNum &lt; clientCount; clientNum++) {
    printf(""name: %s\n"", mainStructure.subStructure.clientList[clientNum].name);
    printf(""address: %s\n"", mainStructure.subStructure.clientList[clientNum].address);
    printf(""identifier: %x\n"", mainStructure.subStructure.clientList[clientNum].identifier);
    printf(""file count: %d\n"", mainStructure.subStructure.clientList[clientNum].fileCount);

    for (fileNum = 0; fileNum &lt; mainStructure.subStructure.clientList[clientNum].fileCount; fileNum++) {
        printf(""filename: %s\n"", mainStructure.subStructure.clientList[clientNum].fileList[fileNum].fileName);
        printf(""size: %d\n"", mainStructure.subStructure.clientList[clientNum].fileList[fileNum].size);
        printf(""checksum: %d\n"", mainStructure.subStructure.clientList[clientNum].fileList[fileNum].checksum);
        mainStructure.subStructure.clientList[clientNum].fileList[fileNum].printed++;
    }

    mainStructure.subStructure.clientList[clientNum].printed++;
}
</code></pre>

<p>Lots of verbose, repeated information here.  So much so it can make it difficult to see what you're actually working with.  This can be made more readable as follows:</p>

<pre><code>for (clientNum = 0; clientNum &lt; clientCount; clientNum++) {
    struct client *thisClient = &amp;mainStructure.subStructure.clientList[clientNum];
    printf(""name: %s\n"", thisClient-&gt;name);
    printf(""address: %s\n"", thisClient-&gt;address);
    printf(""identifier: %x\n"", thisClient-&gt;identifier);
    printf(""file count: %d\n"", thisClient-&gt;fileCount);

    for (fileNum = 0; fileNum &lt; thisClient-&gt;fileCount; fileNum++) {
        struct file *thisFile = &amp;thisClient.fileList[fileNum];
        printf(""filename: %s\n"", thisFile-&gt;fileName);
        printf(""size: %d\n"", thisFile-&gt;size);
        printf(""checksum: %d\n"", thisFile-&gt;checksum);
        thisFile-&gt;printed++;
    }

    thisClient-&gt;printed++;
}
</code></pre>
",10
49859016,49858015,1,"<p>Assuming you have something like</p>

<pre><code>const char* ls[] = {""var_1"", ""var_2"", """"};
</code></pre>

<p>where this list is not tightly-coupled to the struct data (if so you can use the answer by dbush), but is a separate item for whatever reason.</p>

<p>Then the slightly hacky, but well-defined version would be to use look-up tables. Create two lookup tables, one with strings, one with offsets:</p>

<pre><code>#include &lt;stddef.h&gt;

typedef struct
{
  int var_1;
  int var_2;
} my_struct_t;

static const char* VAR_STRINGS[] =
{
  ""var_1"",
  ""var_2"",
  """"
};

static const size_t VAR_OFFSET[] =
{
  offsetof(my_struct_t, var_1),
  offsetof(my_struct_t, var_2),
};
</code></pre>

<p>Then do something like <code>index = search_in_VAR_STRINGS_for(ls[i]);</code> to get an index. (Loop through all items, or use binary search etc). The following code is then actually legal and well-defined:</p>

<pre><code>unsigned char* ptr = (unsigned char*)&amp;my_struct;
ptr += VAR_OFFSET[index];
int var_1 = *(int*)ptr;
</code></pre>

<p>This takes padding in account and the pointer arithmetic is guaranteed to be OK by C11 6.3.2.3/7:</p>

<blockquote>
  <p>When a pointer to an object is converted to a pointer to a character type,
  the result points to the lowest addressed byte of the object. Successive increments of the
  result, up to the size of the object, yield pointers to the remaining bytes of the object.</p>
</blockquote>

<p>And since what's really stored at that address (<em>effective type</em>) is indeed an <code>int</code>, the variable access is guaranteed to be OK by C11 6.5/7 (""strict aliasing""):</p>

<blockquote>
  <p>An object shall have its stored value accessed only by an lvalue expression that has one of
  the following types:<br>
  ¡ª a type compatible with the effective type of the object,</p>
</blockquote>

<p>But various error handling obviously needs to be in place to check that something doesn't go out of bounds.</p>
",0
56473996,56473847,1,"<p>First and foremost, you are allocating space for an array of <em>two</em> <code>char*</code>s and you have a <em>single</em> statically sized buffer for a string. But you¡¯re attempting to read <em>three</em> strings. Where do you think the space for the strings is coming from? You¡¯re not allocating it.</p>

<p>You need to make your various numbers match up: allocate an array of <em>three</em> strings, and then allocate <em>three</em> string buffers:</p>

<pre><code>char **lst = malloc(3 * sizeof *lst);

for (int i = 0; i &lt; 3; i++) {
    lst[i] = malloc(10);
    fgets(lst[i], 10, fp);
}
</code></pre>

<p>And don¡¯t forget to <code>free</code> all allocated buffers subsequently:</p>

<pre><code>for (int i = 0; i &lt; 3; i++) {
    free(lst[i]);
}
free(lst);
</code></pre>

<p>¡­ of course this code isn¡¯t terribly great either since it hard-codes the number of lines you can read, and the maximum line length. But it should get you started.</p>
",2
55241546,55241410,2,"<p>It's called a <em>typecast</em>, or <em>cast</em> for short. The syntax is:</p>

<pre><code>(type) expression
</code></pre>

<p>It does exactly what you already inferred: it evaluates to the value of <code>expression</code>, converted to the given <code>type</code>.</p>
",0
55241612,55241410,-1,"<p>This is <strong>typecasting</strong>. Putting a type in parentheses before an expressions converts the expression to that type. For example,</p>

<pre class=""lang-c prettyprint-override""><code>(int) 1.0; // gives 1
</code></pre>
",0
59339728,59339716,0,"<p>The commented line needs to be</p>

<pre><code>void datumvergleich (struct datum1 d1, struct datum2 d2 )
</code></pre>

<p>in order to match the function prototype further up in the program (you don't need to specify the variable names in function prototypes, just the types). Note that if <code>datum1</code> and <code>datum2</code> will always have exactly the same members, then you could use the same <code>struct</code> for both <code>d1</code> and <code>d2</code>.</p>

<p>Note that you can use <code>typedef</code> to obviate the tedium of writing <code>struct datum1</code> etc. See <a href=""https://stackoverflow.com/questions/252780/why-should-we-typedef-a-struct-so-often-in-c"">Why should we typedef a struct so often in C?</a></p>
",0
59139827,59139761,1,"<h3>Your code:</h3>
<pre><code>if (isprint(h)==1){  // Why compare against 1?  What does that do?
        r=r++;       // Do you know how ++ works?? Read about it.
    }
</code></pre>
<hr>
<h3>Fixed Version</h3>
<pre><code>if (isprint(h)) {
    r++;
}
</code></pre>
",1
48883229,48883047,5,"<p>In order to derive this by hand you need to know several implementation-defined aspects of your system - namely</p>

<ul>
<li>If <code>char</code> is signed or not</li>
<li>If the <code>char</code> is signed, what representation scheme is used</li>
<li>How does your system treat narrowing conversions of values that cannot be represented exactly in the narrow type.</li>
</ul>

<p>Although the standard allows implementations to decide, a very common approach to narrowing conversions is to truncate the bits that do not fit in a narrow type. Assuming that this is the approach taken by your system, the first part of figuring out the output is to find the last eight bits of the <code>int</code> value being converted. In your case, 65535 is 1111111111111111<sub>2</sub>, so the last eight bits are all ones.</p>

<p>Now you need to decide the interpretation of 11111111<sub>2</sub>. On your system <code>char</code> is signed, and the system uses two's complement representation of negative values, so this pattern is interpreted as an eight-bit <code>-1</code> value.</p>

<p>When you call <code>printf</code>, eight-bit value of signed <code>char</code> is promoted to <code>int</code>, so the preserved value is printed.</p>

<p>On systems where <code>char</code> is unsigned by default the same pattern would be interpreted as 255.</p>
",3
51202267,26024970,0,"<p>Always check from the smallest range up and compare with <code>&lt;</code>/<code>&lt;=</code>, or check from the maximum range down with <code>&gt;</code>/<code>&gt;=</code>. Besides use <code>else if</code> to avoid redundant checks like most of the above answers. For example OP's solution compares score with 60 twice, which is unnecessary</p>

<pre><code>if (score &lt; 60)
    grade = 'F';
else if (score &lt; 70)
    grade = 'D';
else if (score &lt; 80)
    grade = 'C';
else if (score &lt; 90)
    grade = 'B';
else
    grade = 'A';
</code></pre>

<p>But you don't actually need that many <code>if</code> blocks</p>

<pre><code>const char* SCORE[] = ""FDCBA"";
if (score &lt; 60)
    grade = 'F'; // or = SCORE[0];
else if (score &lt; 100);
    grade = SCORE[score/10 - 5];
else if (score == 100)
    grade = 'A'; // or = SCORE[4];
</code></pre>
",0
49217075,49217000,6,"<p>Yes for all the types you list, other than <code>char</code>.</p>

<p><code>char</code> is signed or unsigned in an implementation defined manner. Furthermore, <code>char</code> is an entirely distinct type from <code>singed char</code> and <code>unsigned char</code>, even though it will have the exact same properties as one of them.</p>

<p>You may think I'm talking crazy here, but here it is straight from the C standard:</p>

<p><strong>6.2.5 Types - p15</strong></p>

<blockquote>
  <p>The three types char, signed char, and unsigned char are collectively
  called the character types. The implementation shall define char to
  have the same range, representation, and behavior as either signed
  char or unsigned char.</p>
</blockquote>
",1
49207837,49207780,7,"<p>The later is called a <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.7.2.1p18"" rel=""noreferrer"">""flexible array member""</a> which is special case for structures. The last member of a struct is allowed to have no size.</p>

<blockquote>
  <p>As a special case, the last element of a structure with more than one named member may have an incomplete array type; this is called a flexible array member. In most situations, the flexible array member is ignored. In particular, the size of the structure is as if the flexible array member were omitted except that it may have more trailing padding than the omission would imply. However, when a . (or ->) operator has a left operand that is (a pointer to) a structure with a flexible array member and the right operand names that member, it behaves as if that member were replaced with the longest array (with the same element type) that would not make the structure larger than the object being accessed; the offset of the array shall remain that of the flexible array member, even if this would differ from that of the replacement array. If this array would have no elements, it behaves as if it had one element but the behavior is undefined if any attempt is made to access that element or to generate a pointer one past it. </p>
</blockquote>

<p>Also see <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.7.2.1p20"" rel=""noreferrer"">example 20</a>.</p>

<p>The former is a normal array and it's not allowed to have zero size. See <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.7.6.2"" rel=""noreferrer"">6.7.6.2 Array declarators</a>.</p>

<blockquote>
  <p>If they delimit an expression (which specifies the size of an array), the expression shall have an integer type. If the expression is a constant expression, it shall have a value greater than zero. 
  In other words, the language standard says so.</p>
</blockquote>
",0
48471104,48469928,1,"<p>This is one of the intended uses of a three-argument signal handler.  The <code>si_addr</code> field of the <code>siginfo</code> argument will contain the address of the inaccessible memory word that provoked the fault.  (Note: this field only has that meaning for <code>SIGSEGV</code> and <code>SIGBUS</code>.  For other signals, it may be garbage, or may instead point to the offending <em>instruction</em>.)</p>

<pre><code>static void
hdl(int sig, siginfo_t *info, void *ctx)
{
    assert(sig == SIGSEGV || sig == SIGBUS);
    printf(""Memory fault, addr = %p\n"", info-&gt;si_addr);
}
</code></pre>

<p>You can use <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/mprotect.html"" rel=""nofollow noreferrer""><code>mprotect</code></a> to fix up the permissions on the page containing <code>si_addr</code>, and then return from the signal handler to resume execution.</p>
",0
52543057,52542874,2,"<p><code>*x</code> is equivalent to <code>*(x + 0)</code> and <code>*(x + n)</code> is equivalent to <code>x[n]</code> where <code>x</code> is a pointer and <code>n</code> integer. Hence you're printing <code>x[0]</code> and <code>x[1]</code> - the first and second elements of an integer array.</p>
<hr />
<p>The bytes of an object allocated with <code>malloc</code> are <em>indeterminate</em> unless initialized, and hence the values of the objects too. The standard says (<a href=""http://port70.net/%7Ensz/c/c11/n1570.html#3.19.2"" rel=""nofollow noreferrer"">C11 3.19.2-3.9.4; same text in C17 but cannot link it as nicely)</a>:</p>
<blockquote>
<p><strong>indeterminate value</strong></p>
<p>either an unspecified value or a trap representation</p>
</blockquote>
<p>and</p>
<blockquote>
<p><strong>unspecified value</strong></p>
<p>valid value of the relevant type where this International Standard imposes no requirements on which value is chosen in any instance</p>
<p><strong>NOTE</strong> An unspecified value cannot be a trap representation.</p>
</blockquote>
<p>and</p>
<blockquote>
<p><strong>trap representation</strong></p>
<p>an object representation that need not represent a value of the object type</p>
</blockquote>
<p>An <code>int</code> object cannot have a trap representation in GCC. However, the behaviour is still not well-specified, as the standard does not impose requirements on which value is chosen in <em>any instance</em> - so even</p>
<pre><code>printf(&quot;%d, %d\n&quot;, x[0], x[0]);
</code></pre>
<p>can print</p>
<pre><code>0, 42
</code></pre>
<p>so &quot;checking&quot; the indeterminate values is meaningless.</p>
<p>The &quot;as-if rule&quot; allows the compiler to elide the call to <code>malloc</code> altogether - so that even if the <code>malloc</code> implementation always gave a block with first 4 bytes zeroed, the compiled code could have any changing number for <code>x[0]</code>.</p>
",3
58852107,58852017,4,"<p>Basically <code>char</code> is just a small integer.</p>

<p>Using <a href=""https://en.wikipedia.org/wiki/ASCII"" rel=""nofollow noreferrer"">ASCII encoding</a> (the most commonly used encoding by far) the values for <code>'a'</code> and <code>'b'</code> are <code>97</code> and <code>98</code> (respectively).</p>

<p>When you do multiplication the <code>char</code> values are <a href=""https://en.cppreference.com/w/c/language/conversion#Integer_promotions"" rel=""nofollow noreferrer"">promoted</a> to <code>int</code> values, so it's a simple <code>97 * 98</code> multiplication. The result of that is <code>9506</code>.</p>

<p>Now <code>9506</code> is to large to fit in a <code>char</code> variable so it's truncated. The result value is easier to see if we use hexadecimal notation: Decimal <code>9506</code> is hexadecimal <code>0x2522</code>. The value is truncated (through modulo with <code>128</code>) to <code>0x22</code> which is <code>34</code> decimal.</p>
",0
58852083,58852017,5,"<p>Ascii value of ""a"" is 97, of ""b"" is 98. Since the <code>char</code> (which can be <code>signed char</code> or <code>unsigned char</code> <a href=""https://stackoverflow.com/q/2054939/684229"">depending on implementation</a>) can hold maximum value of 127 for <code>signed char</code> (or 255 for <code>unsigned char</code>), you get: </p>

<p>97*98 <a href=""https://en.wikipedia.org/wiki/Modulo_operation"" rel=""noreferrer"">modulo</a> 128 = 34</p>

<p>well, in C notation:</p>

<pre><code>(97*98) % 128 == 34
</code></pre>

<p>PS: replacing 128 with 256 gives 34 as well.</p>
",3
58852417,58852017,0,"<p>As Character range is between -128 to 127 or 0 to 255. In this case integer value for c1 &amp; c2 are 97 &amp; 98 respectively.
so c=c1*c2; will result into 97*98 = 9506, While saving value which exceed range it cycle back to the lower limit and continue.
just to cross check 9506 % 256 will give you result 34.</p>
",0
54590286,54590170,4,"<p>You are correct that <code>ptrToPtr</code> will not change (if you perform no assignment to it), so it does not need to be volatile. However, <code>*ptrToPtr</code> may change, because it is effectively <code>myStructVariable-&gt;list</code>.</p>

<p>So your declaration should be <code>struct list_objects * volatile * ptrToPtr = &amp;myStructVariable-&gt;list;</code>.</p>
",0
54590565,54590170,2,"<p>It is true that the <code>volatile</code> in this case is specific to the pointer and you should be able to do things like discarding the qualifier when copying the variable:</p>

<pre><code>int* volatile vptr;
int* ptr = vptr;
</code></pre>

<p>Just as we can assign the value of a <code>const int</code> to an <code>int</code>.</p>

<p>However, that's not what your code does. It tries to point at the original type. For that you need a ""pointer to volatile pointer to type"". In your case this would be <code>struct list_objects *volatile * ptrToPt</code> (read right-to-left).</p>

<p>Alternatively, this would be fine too:</p>

<pre><code>struct list_objects*  volatile vptr = ...;
struct list_objects*  ptr = vptr;
struct list_objects** pptr = &amp;ptr;
</code></pre>

<p>But note that this take a copy of the original pointer, so if the original changes, then <code>ptr</code> will still contain the old address.</p>
",1
59017386,59017351,4,"<blockquote>
  <p>Aren't <code>str1</code> and <code>str2</code> pointing to read-only data segment memory?</p>
</blockquote>

<p>Technically, it's simply undefined behaviour to try and change string literals. They <em>may</em> be read-only but it's not guaranteed.</p>

<blockquote>
  <p>But the values they point at are all changed in the end?</p>
</blockquote>

<p>No. The only <em>values</em> that are changed are pointers to the strings, <em>not</em> the strings themselves.</p>

<p>Think of it this way, this is your initial state:</p>

<pre><code>Variable  PointsTo  Address With Data ...
str1        -&gt;      0x1000:      | J | o | h | n | \0 |
str2        -&gt;      0x1100:      | M | a | r | y | \0 |
 |                               \____The strings_____/
 +- The pointers to the strings.
</code></pre>

<p>When you swap the pointer values, you end up with:</p>

<pre><code>Variable  PointsTo  Address With Data ...
str2        -&gt;      0x1000:      | J | o | h | n | \0 |
str1        -&gt;      0x1100:      | M | a | r | y | \0 |
</code></pre>

<p>Note that the string literals have not changed at all (the exact same content exists at the exact same memory locations). The <em>pointer</em> values have changed but they're not subject to the same restrictions as the string literals.</p>
",0
59017382,59017351,3,"<p>This doesn't swap strings. A string is an array of characters. This swaps pointers. Pointers are not arrays and not strings. Pointers may point (in)to strings. In general it is not possible to swap strings.</p>

<p>For both strings you print (1) the string itself and (2) the address of a pointer to a string. This latter value is not particularly interesting, as there may be many pointers that point to the same string. A more interesting quantity is the address of the string itself. You can print it like that:</p>

<pre><code> printf (""The string is %s (%p)"", s, s);
</code></pre>
",0
54826561,54824948,4,"<p>Problems with the current code:</p>

<ul>
<li>""4 strings of 8 chars each"" is <code>char in[4][8+1];</code> and not <code>char in[8]</code>. You need room for null termination.</li>
<li>32 bits means iterate from 0 to 31, not from 0 to 32.</li>
<li>There's no need to copy byte per byte. It's slow and makes everything needlessly complicated.</li>
</ul>

<p>This seems to be the requirements:</p>

<ul>
<li>Split the original string in 4 sub strings.</li>
<li>Convert each sub string to an integer.</li>
<li>Display the result as hex</li>
</ul>

<p>In which case you can simply iterate 4 times over the input string:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main (void)
{
  const char* inst = ""10101010101010101111111100111101"";
  char in [4][8+1];

  puts(""Bin      Hex"");
  for(size_t i=0; i&lt;4; i++)
  {
    memcpy(in[i], &amp;inst[i*8], 8);
    in[i][8] = '\0';
    unsigned long val = strtoul(in[i], NULL, 2);    
    printf(""%.8s %.2lX\n"", in[i], val);
  }
}
</code></pre>

<p>Output:</p>

<pre><code>Bin      Hex
10101010 AA
10101010 AA
11111111 FF
00111101 3D
</code></pre>
",0
59190704,59190513,2,"<p><code>wait</code> will return the pid of the process that changed.  To map that back to <code>i</code>, save all your pids returned from <code>fork</code> into a table and reference back as a lookup.</p>

<pre><code>pid_t table[pro] = {0};
pid_t child=0;

for (i = 0; i &lt; pro; i++)  
  { 
    pid = fork();
    if(pid == 0) 
    { 
      printf(""Created child %d with pid=%d\n"",i, getpid());
      char child[10];
      snprintf(child, 10, ""%d"", i);
      if (execlp(programName, programName, child, NULL) &lt; 0){
        printf(""Error running: %s\n"",programName);
      }
      exit(2); 
    }
    else
    {
      table[i] = pid;
    }    
  }
  while((child=wait(&amp;status)) &gt; 0)
  {
    if ( WIFEXITED(status) ){

      i = -1;
      for (int j = 0; j &lt; pro; j++)
      {
        if (table[j] == child))
        {
          i = j;
          break;
        }
      }

      printf(""Death of child: %d with timeout %d\n"",i, WEXITSTATUS(status));
</code></pre>
",0
55470394,55470305,3,"<pre><code>...\include\stddef.h"" 38/9] macro ""NULL"" redefined
...\ncs_types.h"" 125/13] previous definition of macro ""NULL""
</code></pre>

<p>This is telling you that <code>NULL</code> is initially defined in <code>ncs_types.h</code> and then <em>redefined</em> in <code>stddef.h</code>. The ordering of the error messages is a little confusing.</p>

<p>You have three options:</p>

<ol>
<li>Don't define <code>NULL</code> in your header file at all. It'll be defined later, by <code>stddef.h</code>. This probably won't work if you're using <code>NULL</code> in that header.</li>
<li>Include <code>stddef.h</code> <em>before</em> your header file.</li>
<li>Include <code>stddef.h</code> <em>in</em> your header file, instead of defining <code>NULL</code>.</li>
</ol>
",2
52347625,52347412,1,"<pre><code>pthread_create(&amp;thread, NULL, do_stuff, task);
task = task_create(test1, NULL, ""test1"");
</code></pre>

<p>You're passing junk to the thread. You haven't set <code>task</code> to any particular value here, yet you pass it to the thread as a parameter.</p>

<pre><code>void* do_stuff(void *args) {         // *** args is garbage here
    printf(""in do stuff\n"");
    pthread_mutex_lock(&amp;mutex);
    printf(""after do stuff has lock\n"");
    task_t *task = (task_t *)args;   // ** So task is garbage here
    (task-&gt;work) (task-&gt;params);
    pthread_mutex_unlock(&amp;mutex);
}
</code></pre>

<p>Here, you initialize <code>task</code> from <code>args</code>. But <code>args</code> has a garbage value.</p>

<p>If you have some kind of collection that's going to track what tasks a thread is going to work on, you have to pass the thread a parameter that allows it to reliably find that collection. In this particular case, <code>&amp;task</code> would work.</p>
",0
50113146,50113098,3,"<p>The problem is in this line:</p>

<pre><code>char *names[][11] = {""Drew"", ""Larry Page"", ""Seggy"", ""Mark""};
</code></pre>

<p>you don't want a 2d array of pointer to <code>char</code>, you want an array of pointer to <code>char</code>:</p>

<pre><code>char *names[] = {""Drew"", ""Larry Page"", ""Seggy"", ""Mark""}; /* Don't hardcode 11 */
</code></pre>
",4
55250417,55250375,2,"<blockquote>
  <p>How can I achieve this without using if or switch statement ?</p>
</blockquote>

<p><strong>You can put all 1000 constants in an array</strong> and then use <code>arg</code> to select the one you want.</p>

<pre><code>int list[1000] = {NUM1, NUM2, NUM3, NUM4...NUM1000};

void func(int arg){
    var = list[arg - 1];   // use arg-1 because C arrays start from zero
}
</code></pre>

<blockquote>
  <p>How to form #define constant name in C?</p>
</blockquote>

<p><strong>You can't, and if you could it wouldn't help you.</strong> Macros created with #define are handled by the preprocessor. That is, before your code is sent to the compiler itself, the preprocessor scans through it and replaces each macro name (e.g. <code>NUM1</code>) with the corresponding value (e.g. <code>123</code>). The resulting code is then passed on to the compiler, so the compiler never even sees the macro names. So even if you <em>could</em> somehow create the macro name at dynamically at run time, there'd be no way to connect that name back to the value that was associated with it in the source code.</p>
",2
58227876,26204277,0,"<pre><code>#include &lt;stdio.h&gt;


int main() {
    int n = 50;

    for (int i = 0; i &lt;= n; ++i) {

        for (int k = i; k &lt; n; ++k)
            printf("" "");

        for (int j = 0; j &lt; i; ++j)
            printf(""*"");

        for (int j = 1; j &lt; i; ++j)
            printf(""*"");

        printf(""\n"");
    }

    for (int l = 1; l &lt; n/2; ++l) {
        for (int i = 1; i &lt; n; ++i)
            printf("" "");

        printf(""[|]\n"");

    }

    return 0;
}
</code></pre>
",0
49615101,49614752,29,"<p>This is not guaranteed by the C standard. The semantics of converting a floating-point literal in the source code are specified in C 2011 [draft N1570] 6.4.4.2. This says the recommended, but not required, practice is that the translation-time conversion of floating-point constants should match the execution-time conversion of character strings by library functions, such as <code>strtod</code>.</p>

<p>More than that, the standard does not even require that two different literals with the same mathematical value, such as <code>1.23</code> and <code>1.230</code>, convert to the same value. These examples come from footnote 75 in the standard, which is a footnote to a paragraph stating that all floating-point constants <strong>of the same source form</strong> shall convert to the same value. Thus, <code>1.23</code> always converts to the same value wherever it appears in the source, but <code>1.230</code> does not necessarily convert to the same value as <code>1.23</code> or <code>123e-2</code>. Even <code>123e-2</code> and <code>123e-02</code> may be different.</p>

<p><code>atof(p)</code> is specified in 7.22.1.2 to be equivalent to <code>strtod(p, (char **) NULL)</code> except for how they behave with errors. <code>strtod</code> is specified in 7.22.1.3. That clause has some recommended practices for accuracy but is silent about matching the translation-time conversion of literals.</p>
",18
49615411,49614752,1,"<p>This check will inevitably be implementation-dependent, so I've written the following little test script:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
  {
  double d1 = 1.2;
  double d2 = atof(""1.2"");
  char *p;
  double d3 = strtod(""1.2"", &amp;p);

  printf(""d1 = %40.40f\n"", d1);
  printf(""d2 = %40.40f\n"", d2);
  printf(""d3 = %40.40f\n"", d3);

  if(d1 != d2)
    printf(""d1 != d2\n"");

  if(d2 != d3)
    printf(""d2 != d3\n"");
  }
</code></pre>

<p>In the case of the HP C/C++ compiler, version A.06.25.02, this outputs</p>

<pre><code>d1 = 1.1999999999999999555910790149937383800000
d2 = 1.1999999999999999555910790149937383800000
d3 = 1.1999999999999999555910790149937383800000
</code></pre>

<p>which demonstrates that the conversion (of 1.2, at least) which is performed by the compiler matches the conversions performed by <code>atof</code> and <code>strtod</code>.</p>
",0
52597264,52597206,-1,"<p>your malloc is wrong, its only allocating space for a pointer. After that everything is Undefined Behavior. Should be</p>

<pre><code> tElemPtr novyPrvok = (tElemPtr *)malloc(sizeof(*tElemPtr));
</code></pre>
",2
51365985,51365482,0,"<p>In C, there is no difference. Both programs fail to conform to the syntax of the language.</p>

<p>C does not specify the text of error or warning messages produced by a compiler. Most compilers make some effort to produce error messages which help the programmer understand what the error is. Some do better than others, but none is perfect.</p>

<p>Whatever compiler you are using, in its current version, happens to produce two different error messages for that code. How it decided which message to produce is something probably only the authors of that compiler could tell you. If you feel that one or the other error message is significantly misleading, you could file a bug report or a formal complaint, if the compiler you are using has some sort of user-support channel which allows you to do one of those things. </p>
",0
48106442,48106169,5,"<p>This is actually a problem with operator precedence.  The unary <code>!</code> is evaluated first, calculating the logical NOT of <code>SimReleaseMode</code>; this is a boolean quantity (with type <code>int</code>, though, because C) and then <em>that</em> is used as the left-hand operand of the comparison.  GCC knows that neither possible numeric value of a boolean quantity (0 or 1) can compare equal to <code>RELEASE_MODE_MIXED</code> (numeric value 2), so it warns you.</p>

<p>You probably meant to write</p>

<pre><code>if (!(SimReleaseMode == RELEASE_MODE_MIXED))
</code></pre>

<p>or more idiomatically</p>

<pre><code>if (SimReleaseMode != RELEASE_MODE_MIXED)
</code></pre>
",0
52937954,52937668,0,"<p>clang is capable of recognizing what this function does:</p>

<pre><code>unsigned int log2i(unsigned int n) {
    unsigned int i = 0;

    while (n &gt;&gt;= 1) {
        i++;
    }

    return i;
}
</code></pre>



<pre><code>log2i:
        shr     edi
        lzcnt   ecx, edi
        mov     eax, 32
        sub     eax, ecx
        ret
</code></pre>

<p>But since you have an exact power of two, in practice, it¡¯s probably fine and better to use a GCC/clang/others builtin even if it¡¯s not standard C:</p>

<pre><code>unsigned int log2Exact(unsigned int n) {
    return __builtin_ctz(n);
}
</code></pre>



<pre><code>log2Exact:
        tzcnt   eax, edi
        ret
</code></pre>
",3
48631051,48630922,0,"<p>You're not checking the value of <code>newBuff</code> returned by <code>shmat()</code> to ensure that it is not invalid, e.g. <code>(void*) -1</code> (per <a href=""http://man7.org/linux/man-pages/man2/shmop.2.html"" rel=""nofollow noreferrer"">http://man7.org/linux/man-pages/man2/shmop.2.html</a>). You also need to check the return value of <code>shmget()</code> to ensure that it succeeded in the first place.</p>

<p>Almost certainly, <code>newBuff</code> is -1, and trying to dereference that gives you a segfault.</p>
",1
49591090,49591050,2,"<p>The <code>s[i]</code> are pointing to string literals, you need a 2-dimensinal <code>char</code> array like this:</p>

<pre><code>char s[][7] = {""aaaa"", ""abcd"", ""ababab"", ""aaabbb""}
</code></pre>

<p>Also note that for a string of length <code>n</code> you need at least <code>n+1</code> spaces because of the <code>'\0'-termination.</code>""aaabbb""` has length 6, so it need at least 7 spaces.</p>

<p>Then you can do</p>

<pre><code>int main() {
    char s[][7] = {""aaaa"", ""abcd"", ""ababab"", ""aaabbb""};

    size_t i;
    for (i = 0; i &lt; sizeof s / sizeof s[0]; i++) {
        removeDuplicates(s[i]);
    }
    return 0;
}
</code></pre>
",0
48590254,48590145,11,"<p>Let's assume that <code>int</code> is 32 bits.</p>

<ol>
<li><p><code>0xFFFFFFFF</code> will have type <code>unsigned int</code>. There are special rules that explain this, but because it is a hexadecimal constant and it doesn't fit in <code>int</code>, but does fit in <code>unsigned int</code>, it ends up as <code>unsigned int</code>.</p></li>
<li><p><code>0xFFFFFFFF * 0xFFFFFFFF</code> will first go through the usual arithmetic conversions, but since both sides are <code>unsigned int</code>, nothing happens. The result of the multiplication is <code>0xfffffffe00000001</code> which is reduced to <code>unsigned int</code> by using the modulo 2<sup>32</sup> value, resulting in the value 1 with type <code>unsigned int</code>.</p></li>
<li><p><code>(unsigned int)1 % 256u</code> is equal to <code>1</code> and has type <code>unsigned int</code>. Usual arithmetic conversions apply here too, but again, both operands are <code>unsigned int</code> so nothing happens.</p></li>
<li><p>The result is converted to <code>uint32_t</code>, but it's already <code>unsigned int</code> which has the same range.</p></li>
</ol>

<p><strong>However,</strong> let's instead suppose that <code>int</code> is 64 bits.</p>

<ol>
<li><p><code>0xFFFFFFFF</code> will have type <code>int</code>.</p></li>
<li><p><code>0xFFFFFFFF * 0xFFFFFFFF</code> will overflow! This is undefined behavior. At this point we stop trying to figure out what the program does, because it could do anything. Maybe the compiler would decide not to emit code for this function, or something equally absurd.</p></li>
</ol>

<p>This would happen in a so-called ""ILP64"" or ""SILP64"" architecture. These architectures are rare but they <em>do exist.</em> We can avoid these portability problems by using <code>0xFFFFFFFFu</code>.</p>
",1
53978016,53978000,1,"<p><code>s</code> does not have type <code>S</code>.  It has type <code>S *</code>, i.e. it is a pointer, so <code>sizeof(s)</code> is the size of a struct pointer on your system.</p>

<p>If you want to print the size of the structure, you would need to print <code>sizeof(S)</code> or <code>sizeof(*s)</code>.</p>

<p>Also, you're using the wrong format specifier to print the result of <code>sizeof</code>.  You're currently using <code>%d</code> in each of your <code>printf</code> calls, whereas the proper format specifier is <code>%zu</code> for <code>sizeof</code>.</p>
",3
49761323,49761187,8,"<p>Simplify your code by moving the logic of finding the maximum to a function.</p>

<pre><code>#include &lt;stdio.h&gt;

float max_of_two(float x, float y)
{
   return (x &gt; y) ? x : y;
}

float max_of_three(float m, float n, float p)
{
   return max_of_two(max_of_two(m, n), p);
}

int main()
{
    float m,n,p;
    scanf(""%f%f%f"", &amp;m,&amp;n,&amp;p);
    printf(""%f"", max_of_three(m, n, p));
    return 0;
}
</code></pre>
",0
49761261,49761187,4,"<p>Your <code>else</code>s only apply to the previous <code>if</code>, nesting <code>if</code> statements is not working the way you intend, instead you should be using the ""and"" operator to check if the two conditions are true in the same <code>if</code>. Additionally you want to check with <code>&gt;=</code> not just <code>&gt;</code> in case the two largest numbers are equal.</p>

<pre><code>int main() {
    // your code goes here
    float m,n,p;
    scanf(""%f%f%f"", &amp;m,&amp;n,&amp;p);
    if(m &gt;= n &amp;&amp; m &gt;= p){
        printf(""%f"",m);
    } else if(n &gt;= p &amp;&amp; n &gt;= m) {
        printf(""%f"",n);
    } else{   
        printf(""%f"",p);
    }
    return 0;
}
</code></pre>

<p>for a simpler example, if you had code like this:</p>

<pre><code>if (a) {
    if (b) {
        printf(""first\n"");
    }
} else {
    print(""second\n"");
}
</code></pre>

<p>The <code>else</code> is only related to whether <code>a</code> is true or false. If you had <code>a = true</code> and <code>b = false</code> the above would print nothing. Your program would enter the <code>if (a)</code> body (so the <code>else</code> never runs), then see <code>if (b)</code> and skip <code>printf(""first\n"")</code> before exiting.</p>
",0
48781305,48780994,3,"<p>The value in a float is stored in a special format. In the most common format, it is encoded with one bit for a sign, eight bits for an exponent, and 23 bits for the significand (a fraction). For 5.4, the sign bit is 0 (for positive), the exponent is 2 and is encoded as 129 (127 is added; the exponent is stored with a bias), and the fraction is 1.35000002384185791015625, using the bits 0x2ccccd. (Those are the fraction minus one, then multiplied by 2<sup>23</sup>.) Put together, the sign bit, the exponent bits, and the significand bits form 0x40accccd. In decimal, that is 1085066445.</p>

<p>So, when you store 5.4 in the <code>float</code> member of the union, the bits 0x40accccd are written to the storage. When you read the <code>int</code> member, those bits are interpreted as 1085066445.</p>
",2
51995654,51995304,0,"<p>Here is an illustration of the alignment that the compiler generates:<br>
<strong>Bytes:</strong>  </p>

<pre><code>+-----+---------------+  
|  0  | a[1]          |  
+-----+---------------+  
|  1  | N/A (padding) |  
+-----+---------------+  
|  2  | b             |  
+-----+---------------+  
|  3  | b             |  
+-----+---------------+  
|  4  |    c          |  
+-----+---------------+  
</code></pre>

<p><strong>As 16-bit quantities:</strong>  </p>

<pre><code>+---+------+----+  
| 0 | a[i] |    |  
+---+------+----+  
| 2 | b         |
+---+------+----+  
| 4 |   c  |    |
+---+------+----+  
</code></pre>

<p>Processors like to fetch 16-bit quantities from even addresses.<br>
When they are on odd addresses, the computer may have to make 2 16-bit fetches, and extract the unaligned data out of them.</p>

<p>The easy method to eliminate this extra fetch is to add padding bytes so that 16-bit quantities <em>align</em> to even addresses.</p>

<p>A rule of thumb is to place the larger items first, then the smaller.
Applying this rule:  </p>

<pre><code>+---+------+  
| 0 | b    |  
+---+------+  
| 2 | a[1] |  
+---+------+  
| 3 | c    |  
+---+------+  
</code></pre>

<p>The rule eliminates the need for an extra padding byte.  </p>
",0
55189765,55189716,3,"<p>You either need to add appropriate flush calls or you need to change your standard output not to be buffered.</p>

<p>The library is trying to be efficient and not actually write to the terminal until it has a full line. So it stores partial lines in a buffer. When you <code>fork</code>, you wind up with two processes that are substantially identical, that is, they each have the same buffered data. If both of them finishes a line of output, both of them will write the buffered data.</p>

<p>You may still have an issue that all the various outputs are jumbled up together. The more usual way to handle this is to have only one process responsible for all output and the ""worker"" processes communicate their results back to the ""manager"" process to be printed in a sane, orderly way.</p>
",1
58246126,58246046,0,"<p>fgets fills the same buffer each time, so  you are storing in your list multiple copies of the same item.  the buffer in main. (Consider <code>strdup</code>?)</p>

<p>Also your malloc is over generous.  You need to  malloc the size of a list (not a pointer).</p>

<pre><code>Item *newItem = (Item*)malloc(sizeof(Item) );
</code></pre>

<p>At some point freeing an item in the list will be needed, where you free the string and the pointer to the Item memory.</p>
",0
54027122,54027043,1,"<p>you are initializing a <em>char array</em> with a list of string literals. What you want is an <em>array of pointers</em>.</p>

<p>For example:</p>

<pre><code>   char *history[15] = { ""Which English king was \""mad\""?"",""George III"",
                         ""Who started the Protestant Reformation?"",""Martin Luther"",
                         ...
</code></pre>

<p>And the same for other arrays.</p>
",6
54027122,54027043,1,"<p>you are initializing a <em>char array</em> with a list of string literals. What you want is an <em>array of pointers</em>.</p>

<p>For example:</p>

<pre><code>   char *history[15] = { ""Which English king was \""mad\""?"",""George III"",
                         ""Who started the Protestant Reformation?"",""Martin Luther"",
                         ...
</code></pre>

<p>And the same for other arrays.</p>
",6
51571105,51571080,1,"<p>For one, your project does compile, since you get a run time error.</p>

<p>The run time error occurs because you are not using <code>scanf</code> correctly. The arguments to scanf after the format string should be pointers to the variables.</p>

<p>I don't know which compiler you are using, but any fairly modern compiler would have given you compiler warnings about this, e.g. here's Clang's output:</p>

<pre><code>apa.c:9:20: warning: format specifies type 'int *' but the argument has type 'int' [-Wformat]
        scanf(""%d"",n);
               ~~  ^
</code></pre>

<p>Changing this into <code>scanf(""%d"",&amp;n);</code> makes your program work.</p>

<p><a href=""https://linux.die.net/man/3/scanf"" rel=""nofollow noreferrer"">https://linux.die.net/man/3/scanf</a></p>
",0
51473027,51472987,5,"<p>You are missing a pair of braces. Try with this:</p>

<pre><code>struct details a [] = {{ 
        .author = ""Narsimha"", 
        .title = input
    }};
</code></pre>

<p>The outer braces are for defining an array. The inner braces are for the <code>struct</code>.</p>
",0
51697895,51697753,0,"<p>As a addition to other answers -- from the warning message, it looks like you've already provided an upper bound of 255 on <code>literal</code>, but no lower bound.  Perhaps you have an <code>if (literal &gt;= 256)</code> that causes this code to not be reached?  If you also provide a lower bound (perhaps make the check <code>if (literal &lt; 0 || literal &gt;= 256)</code>) then the warning should go away.</p>

<p>More generally, though you don't show enough context in this code to know what is really going on, this kind of warning comes from the compiler trying to make sure you sanitize input from the user, checking to make sure that it is reasonable before doing something with it that might cause undefined behavior if it is unreasonable.  So the warning is an indication that your input error checking is inadequate.</p>
",0
51697915,51697753,1,"<p>In general <code>sprintf</code> is considered unsafe, as it doesn't check the bounds of its ouput array.  You should consider using <code>snprintf</code> instead when writing into a fixed size buffer.  You could also check the return value to see if the buffer was too small</p>
<pre><code>if (snprintf(tag, sizeof(tag), &quot;Literal - %d&quot;, literal) &gt;= sizeof(tag))
    fprintf(stderr, &quot;tag buffer overflow -- string is truncated\n&quot;);
</code></pre>
",3
51697809,51697753,4,"<p>This warning is valid because <code>tag</code> is not large enough to hold all possible values of the string to be constructed.</p>

<p>An integer, assuming 32 bits, needs up to 11 characters to store its string representation.  There are 10 characters written to <code>tag</code> before the integer value, so there are 6 bytes left to write other data.  That's what the warning is telling you.</p>

<p>Since <code>literal</code> has a range of 0 to 255, you can cast the value to <code>unsigned char</code> and use <code>%hhu</code> for the format specifier, which states that the argument is an <code>unsigned char</code>.</p>
",2
55709426,55709407,7,"<p>In your code</p>

<pre><code>if(age&lt;13 &amp;&amp; age&gt;19)
</code></pre>

<p>is a condition that can never be TRUE. No number can be simultaneously less than 13 <strong>and</strong> greater than 19.</p>

<p>What you need is</p>

<pre><code>if(age &gt;= 13 &amp;&amp; age &lt;= 19) 
{
    //teenager
}
else
   // not teenager
</code></pre>
",4
58530179,58528670,2,"<p>Looks like you have far more than just one problem, but let's just start with the first one:</p>

<pre><code>char binStr[ bitLen ], binStrErr[ bitLen ];
</code></pre>

<p>The string you are requesting next contains not just the 16 bytes you get as input, but also an additional sentinel character as the 17th character.</p>

<p>So at this point you already had 2 buffer overflows, which you can already see nicely in the output from the Pi. The same buffer overflow also occurs in the first example, except the memory layout is different enough so that it doesn't yield visible artifacts.</p>

<pre><code>for (int c = 0; c &lt;= i; c++)
{
    binNum[c - 1] = binNum[c];
    binNumErr[c - 1] = binNumErr[c];
}
</code></pre>

<p>Here comes the next buffer overflow, respectively actually an underflow this time. You are writing to <code>binNum[-1]</code> which is a memory location outside of the memory <code>binNum</code> is pointing to.</p>

<p>Anyway, a buffer overflow means the behavior of your program is undefined.</p>

<p>Get used to <a href=""http://valgrind.org/docs/manual/quick-start.html"" rel=""nofollow noreferrer"">valgrind</a> or similar tools for checking your code for undefined with regard to such errors.</p>
",0
53200599,53200279,0,"<pre><code>  if(maze-&gt;cells[row][col] == ' '){
    maze-&gt;cells[row][col] = '*';
  }
</code></pre>

<p>You need an <code>else return 0;</code> here. Otherwise, you can just go back and forth infinitely. If the square is already taken, we can't take it again.</p>
",0
50849988,50849934,1,"<p>In function factorial(), you assign argv[3] to i. But you don not have argv[3] entry as you run your program with <code>./calculate factorial 4</code>. That means argc is only 3 (length of argv array is 3). You are accessing argv[] array out of its range. Use <code>i = atoi(argv[2])</code> to get the intended value.</p>

<p>Also in recursion call, i is always initialized with argv[] value. So it will never reach 0 and result in infinite loop.</p>

<p>Write factorial() like below and call from main() as <code>factorial(atoi(argv[2]))</code></p>

<pre><code>int factorial(int i){                                                      
if ( i == 0 ){                                                              
    return 1;                                                               
}                                                                           
return(i * factorial((i - 1));                                        
}
</code></pre>
",1
57897927,57897755,3,"<p>The array has compile-time constant size, and the number of elements can be determined by the expression <code>sizeof(strings) / sizeof(*strings)</code>.  Given then:</p>

<pre><code>const size_t STRING_COUNT = sizeof(strings) / sizeof(*strings) ;
</code></pre>

<p>Then the last element in the array is:</p>

<pre><code>strings[STRING_COUNT - 1] ;
</code></pre>

<p>and the array can be iterated with:</p>

<pre><code>for( size_t i = 0; i &lt; STRING_COUNT; i++ ) ...
</code></pre>

<p>If <code>strings</code> is passed as an argument, it will be passed as a pointer, so the array size information will be lost.  In that case you would normally pass the size information as a separate argument:</p>

<pre><code>some_function( strings, STRING_COUNT ) ;
</code></pre>

<p>Alternatively you can explicitly add a sentinel value to the array:</p>

<pre><code>char* strings[] = 
{
    ""one"",
    ""two"",
    NULL
} ;
</code></pre>

<p>which can then be detected just as the NUL character is for strings. Note that for a string, string length and the length of the array the string is stored in are not related, the array need only be at least as long as the string plus NUL terminator.  The same is true of using a sentinel value.  For example given:</p>

<pre><code>char* strings[20] = 
{
    ""one"",
    ""two""
    NULL
} ;
</code></pre>

<p><code>sizeof(strings)/sizeof(*strings)</code> will be 20, but the array contains only pointers to two valid string-constants before the initialiser after initialisation.</p>

<p>So whether you use the array size or a sentinel depends on the specific data structure you need.  The array size is appropriate for constant arrays or arrays with constant number of valid elements.  A sentinal might be used for variable arrays, but is not always necessary - you can simply maintain a separate count of valid elements, or may have a sparse array where valid elements are not necessarily contiguous.</p>
",0
50552472,50552275,2,"<p>Notice that in C11 (read its standard <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">n1570</a> and some <a href=""http://en.cppreference.com/w/c"" rel=""nofollow noreferrer"">C reference site</a>) different types can be handled differently (see its ¡ì6.5.2).</p>

<p>In particular, the implementation can handle <code>int</code>, <code>double</code> and pointer values differently (their size and <a href=""https://en.wikipedia.org/wiki/Data_structure_alignment"" rel=""nofollow noreferrer"">alignment</a> is often different, see <a href=""http://en.cppreference.com/w/c/language/sizeof"" rel=""nofollow noreferrer""><code>sizeof</code></a> &amp; <a href=""http://en.cppreference.com/w/c/types"" rel=""nofollow noreferrer""><code>alignof</code></a>), and some <a href=""https://en.wikipedia.org/wiki/Application_binary_interface"" rel=""nofollow noreferrer"">ABI</a> conventions decide that they are passed in different registers (e.g. in function calls).</p>

<p>So you cannot write something which handles (portably) all of <code>int</code>, <code>double</code> etc... the same way (unless you have <a href=""https://en.wikipedia.org/wiki/Variadic_function"" rel=""nofollow noreferrer"">variadic</a> functions; with <code>&lt;stdarg.h&gt;</code>)</p>

<p>You might decide to implement some ""generic"" list whose content is some arbitrary pointer. But then you need some <em>conventions</em> about them (who is allocating that pointer, who is freeing it, perhaps what operations are allowed, etc...). Look into <a href=""https://developer.gnome.org/glib/stable/glib-Doubly-Linked-Lists.html"" rel=""nofollow noreferrer"">Glib doubly-linked lists</a> for inspiration.</p>

<p>You could also use preprocessor techniques to generate an <a href=""https://en.wikipedia.org/wiki/Abstract_data_type"" rel=""nofollow noreferrer"">abstract data type</a> (of your list) and functions implementing it, given some type name for the content. Look into <a href=""http://sglib.sourceforge.net/"" rel=""nofollow noreferrer"">SGLIB</a> for inspiration.</p>

<p>You could also use some <a href=""https://en.wikipedia.org/wiki/Metaprogramming"" rel=""nofollow noreferrer"">metaprogramming</a> techniques: you'll describe somehow the type of the element, and you feed that description into your metaprogram which is some C code generator. Look into <a href=""http://swig.org/"" rel=""nofollow noreferrer"">SWIG</a> for inspiration. The generated C code would implement your list's abstract data type.</p>

<p>Don't forget memory <a href=""https://en.wikipedia.org/wiki/Memory_management"" rel=""nofollow noreferrer"">management issues</a> and describe and document clearly your conventions around them. Read about <a href=""https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization"" rel=""nofollow noreferrer"">RAII</a>.</p>

<p>Think also of complex cases like some list of list of strings (perhaps dynamically allocated ¨¤ la <a href=""http://man7.org/linux/man-pages/man3/strdup.3.html"" rel=""nofollow noreferrer"">strdup</a> or obtained using <a href=""http://man7.org/linux/man-pages/man3/asprintf.3.html"" rel=""nofollow noreferrer"">asprintf</a>). You'll discover that things are not simple, and you'll need to <em>explicit</em> conventions (e.g. could some string be <em>shared</em> between two sublists? When would that string be <code>free</code>-d, ...).</p>
",0
50552376,50552275,4,"<p>As a general suggestion, you should not assume that <code>list_cons</code> would be the only way to construct a linked list. Sometimes <code>malloc</code> is just not available or user wants to preallocate everything in a static array or wants to use custom allocator or...</p>

<p>As a concrete sample, you may look at <a href=""https://github.com/torvalds/linux/blob/master/include/linux/list.h"" rel=""nofollow noreferrer"">https://github.com/torvalds/linux/blob/master/include/linux/list.h</a>.</p>

<p>If you want other license for your code, search for data structure implementations in xBSD Unix sources.</p>

<p>The general idea is that you only require a linked list structure to contain next/prev and similar fields, not limiting user to your type names. All iterations and basic operations are defined as preprocessor macros, on top of which you implement complex algorithms.</p>
",3
48949799,48949715,1,"<p>This program is a simple demonstration of why you always need to parenthesize macro parameters when you use them in expressions. It also illustrates a broader point of why you need to be very careful with macros in general.</p>

<blockquote>
  <p>I'd think that the output of F1 and F2 should be the same</p>
</blockquote>

<p>Had <code>F1</code> and <code>F2</code> been functions, not macros, the output would indeed be the same. However, macros are simple textual substitutions, so the two expressions that you get with and without parenthesizing of <code>X</code> are different:</p>

<p>F1:</p>

<pre><code>((a-b &gt; 0) ? a-b : -(a-b))
</code></pre>

<p>F2:</p>

<pre><code>(a-b &gt; 0) ? a-b : -a-b
</code></pre>

<p>Note that due to lack of parentheses <code>F2</code> applies unary minus to <code>a</code>, not to <code>(a-b)</code>.</p>

<p>This remains a relatively simple use of macros. Imagine the problems you would get in case when <code>X</code> is substituted for an expression with side effects, as in <code>F2(a++, b--)</code>.</p>
",0
50077736,50077702,1,"<p><code>strtok</code> needs to make changes to your string, so it can't operate on a <code>const char*</code> argument. You'll need to make a copy of that string before sending it to <code>strtok</code>.</p>
",5
48793656,48793028,2,"<p><code>currentPosition = newBuffer + (currentPosition - buffer);</code></p>

<p>so <code>(currentPosition - buffer)</code> is the offset (position - starting = offset)</p>

<p>after a realloc, the old pointer may or may not be good, it is UB... so you always need to use the new returned pointer... but the contents are copied. so it is like a new bigger buffer and you need to update your current position to the same offset in the new buffer ... so</p>

<p><code>currentPosition = newBuffer + (currentPosition - buffer);</code></p>

<p>makes perfect sense...</p>
",0
48437823,48437660,1,"<p><strong><em>I think, the exact intention is asked for.</em></strong></p>

<pre><code>val &amp;= val - 1;
</code></pre>

<p>This removes the right-most, least-significant bit:</p>

<pre><code>val:           xxxx1000..000
val - 1:       xxxx0111..111
val &amp; (val-1): xxxx0000..000
</code></pre>

<p>It typically is used to count (destructively) the number of bits.</p>

<p>The same trick: to get the least significant bit itself, use <a href=""https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#lowestOneBit-int-"" rel=""nofollow noreferrer"">Integer.lowestOneBit(val)</a>:</p>

<pre><code>int lowestOneBit = val &amp; -val;
</code></pre>

<p>To understand the latter: <code>-n == ~n + 1</code>. That is: a negative number in java is twos-complement: the one-complement (~n) of every bit plus one.</p>
",0
48437787,48437660,5,"<p><code>val</code> is initialized to</p>

<pre><code>val = x ^ y;
</code></pre>

<p>i.e. <code>val</code> is the bit-wise XOR of x and y, which means it contains <code>1</code> in all the bits where <code>x</code> and <code>y</code> differ and <code>0</code> in all the bits where <code>x</code> and <code>y</code> are the same.</p>

<p>Now, each iteration of the loop performs</p>

<pre><code>val &amp;= val - 1;
</code></pre>

<p>which is equivalent to</p>

<pre><code>val = val &amp; (val - 1);
</code></pre>

<p>Each such bit-wise AND operation turns a single <code>1</code> bit of <code>val</code> to <code>0</code>.</p>

<p>For example, suppose the binary representation of <code>val</code> is:</p>

<pre><code>1010
</code></pre>

<p>The binary representation of <code>val - 1</code> is:</p>

<pre><code>1001
</code></pre>

<p>and after performing bit-wise AND, we get:</p>

<pre><code>1000
</code></pre>

<p>Therefore, by the end of the loop, <code>dist</code> contains the number of <code>1</code> bits in the original value of <code>val</code>, which is the number of bits by which <code>x</code> and <code>y</code> differ.</p>
",0
56709219,56709138,3,"<p>Your array isn't big enough:</p>

<pre><code>int cArray[29][49];
</code></pre>

<p>This creates a 2D array of size 29 x 49.  You need an array of 30 x 50:</p>

<pre><code>int cArray[30][50];
</code></pre>

<p>Your bounds checks are also incorrect:</p>

<pre><code>        cArray[rowInd][columnInd] = c;
        columnInd++;

        if (columnInd &gt; 29){
                rowInd++;
                columnInd=0;
        }
</code></pre>

<p>The size of the second dimension is 49, 50 after fixing it, so you should be checking that value.  You should also put in a check to make sure your row index doesn't exceed the bounds of the array.</p>

<pre><code>        if (columnInd &gt;= 50){
                rowInd++;
                columnInd=0;
        }
        if (rowInd &gt;= 30) {
            break;
        }
</code></pre>
",0
57835053,57834935,4,"<p>Note that a ""string"" with an embedded NUL is no longer a <em>string</em>. You cannot safely use it as an argument to functions declared in <code>&lt;string.h&gt;</code>, for example</p>

<pre><code>char embeddednul[] = ""zero\0one\0two\0""; // embeddednul[12] = embeddednul[13] = 0
printf(""len: %d\n"", strlen(embeddednul)); // 4??
char tmp[1000] = {0};
strcpy(tmp, embeddednul); // copies 'z', 'e', 'r', 'o', and 0

char *p = embeddednul;
while (*p) {
    while (*p) putchar(*p++); // prints zero
    putchar('\n');            // then   one
    p++;                      // then   two
}
</code></pre>
",1
56471418,56471105,4,"<p>You cannot do this.</p>

<p>You can determine whether a <code>char*</code> value is a null pointer or not, but if it's non-null, you cannot determine whether it's a valid pointer. You certainly can't do so portably; you probably can't do it non-portably either.</p>

<p>For example:</p>

<pre><code>char *ptr = malloc(6);
strcpy(ptr, ""hello"");
// now ptr points to a valid string
free(ptr);
// now ptr doesn't point to a valid string -- but there's no way to test it
</code></pre>

<p>If you happen to know that the pointer is valid (or is either valid or null), you still can't do it. For example:</p>

<pre><code>char buf[5] = ""hello""; // not a string, since there's no '\0'
char *ptr = buf;       // ptr points to valid data, but it's not a string
</code></pre>

<p>You can scan memory starting at <code>*ptr</code> looking for a <code>'\0'</code> string terminator, but you can't know when to stop looking. In this case, you might look at 5 bytes of memory and not find a <code>'\0'</code> -- but what if <code>ptr</code> pointed to a valid string that's 1000 characters long?</p>

<p>And in this case, it's entirely possible that there happens to be a <code>'\0'</code> byte immediately after the array, which could make it appear that <code>ptr</code> points to a valid string. (Accessing that 6th byte has undefined behavior. The worst consequence of undefined behavior is that it can appear to ""work"", which just means it's more difficult to track down the bug.)</p>

<p>The only way to determine whether a pointer points to a valid string is to write your code in a way that guarantees that it does. If it doesn't, it's not a problem you can detect after it occurred.</p>
",0
56617547,56617448,0,"<p>Terminals are usually (even on Windows) controlled by <a href=""https://en.wikipedia.org/wiki/ANSI_escape_code"" rel=""nofollow noreferrer"">Ansi Escape codes</a>. You can use them to control the output color, or the location of the cursor. See: <a href=""https://stackoverflow.com/questions/16755142/how-to-make-win32-console-recognize-ansi-vt100-escape-sequences"">How to make win32 console recognize ANSI/VT100 escape sequences?</a> and <a href=""https://docs.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences</a></p>
",0
49109498,49108976,2,"<p>If you close either of the file descriptors for a pipe, it can never be reopened.  There is no name by which to reopen it.  Even with <code>/dev/fd</code> file systems, once you close the file descriptor, the corresponding entry in the file system is removed ¡ª you're snookered.</p>

<p>Don't close a pipe if you might need to use it again.</p>

<p>Consider whether to make a duplicate of the pipe before closing; you can then either use the duplicate directly or duplicate the duplicate back to the original (pipe) file descriptor, but that's cheating; you didn't actually close all the references to the pipe's file descriptor.  (Note that the process(es) at the other end of the pipe won't get an EOF indication because of the close ¡ª there's still an open file descriptor referring to the pipe.)</p>
",1
59520670,28414581,4,"<p>I just compiled this program on my Linux Debian x64: </p>

<pre><code>#include &lt;stdio.h&gt;

int main(){

// C18 standard, p. 20

    printf(""\n\n***********************************************************************************\n\n"");

    printf (""%-25s %20s %20s %15s\n\n"", """", ""IZVORNA KODA"", ""BINARNA KODA"", ""OPOMBA"");

    signed char n009 = 255;
    printf (""%-25s %20s %20d %15s\n"",""signed char:"", ""255"", n009, ""!"");

    signed char n007 = 128;
    printf (""%-25s %20s %20d %15s\n"",""signed char:"", ""128"", n007, ""!"");

    signed char n006 = 127;
    printf (""%-25s %20s %20d %15s\n"",""signed char:"", ""127"", n006, ""MAX - C18"");

    signed char n005 = 1;
    printf (""%-25s %20s %20d %15s\n"",""signed char:"", ""1"", n005, ""C18"");

    signed char n004 = 0;
    printf (""%-25s %20s %20d %15s\n"",""signed char:"", ""0"",  n004, ""C18"");

    signed char n003 = -1;
    printf (""%-25s %20s %20d %15s\n"", ""signed char:"", ""-1"", n003, ""C18"");

    signed char n002 = -127;
    printf (""%-25s %20s %20d %15s\n"", ""signed char"", ""-127"", n002, ""C18"");

    signed char n001 = -128;    
    printf (""%-25s %20s %20d %15s\n"", ""signed char"", ""-128"", n001, ""MIN - C18"");

    printf(""\nALOKACIJA: %d bitov"",sizeof(n009)*8);

    printf(""\n\n***********************************************************************************\n\n"");

    printf (""%-25s %20s %20s %15s\n\n"", """", ""IZVORNA KODA"", ""BINARNA KODA"", ""OPOMBA"");

    unsigned char n017 = 255;
    printf (""%-25s %20s %20d %15s\n"",""unsigned char:"", ""255"", n017, ""MAX - C18"");

    unsigned char n016 = 128;
    printf (""%-25s %20s %20d %15s\n"",""unsigned char:"", ""128"", n016, ""C18"");

    unsigned char n015 = 127;
    printf (""%-25s %20s %20d %15s\n"",""unsigned char:"", ""127"", n015, ""C18"");

    unsigned char n014 = 1;
    printf (""%-25s %20s %20d %15s\n"",""unsigned char:"", ""1"", n014, ""C18"");

    unsigned char n013 = 0;
    printf (""%-25s %20s %20d %15s\n"",""unsigned char:"", ""0"", n013, ""MIN - C18"");

    unsigned char n012 = -1;
    printf (""%-25s %20s %20d %15s\n"",""unsigned char:"", ""-1"", n012, ""!"");

    unsigned char n011 = -127;
    printf (""%-25s %20s %20d %15s\n"",""unsigned char:"", ""-127"", n011, ""!"");

    unsigned char n010 = -128;
    printf (""%-25s %20s %20d %15s\n"",""unsigned char:"", ""-128"", n010, ""!"");

    printf(""\nALOKACIJA: %d bitov"",sizeof(n010)*8);

    printf(""\n\n***********************************************************************************\n\n"");

    short int n018 = 65535;
    printf (""%-25s %20s %20d %15s\n"",""short int:"", ""65535"", n018, ""!"");

    short int n019 = 32768;
    printf (""%-25s %20s %20d %15s\n"",""short int:"", ""32768"", n019, ""!"");

    short int n020 = 32767;
    printf (""%-25s %20s %20d %15s\n"",""short int:"", ""32767"", n020, ""MAX - C18"");

    short int n021 = 32766;
    printf (""%-25s %20s %20d %15s\n"",""short int:"", ""32766"", n021, ""C18"");

    short int n022 = 1;
    printf (""%-25s %20s %20d %15s\n"",""short int:"", ""1"", n022, ""C18"");

    short int n023 = 0;
    printf (""%-25s %20s %20d %15s\n"",""short int:"", ""0"", n023, ""C18"");

    short int n024 = -1;
    printf (""%-25s %20s %20d %15s\n"",""short int:"", ""-1"", n024, ""C18"");

    short int n025 = -32767;
    printf (""%-25s %20s %20d %15s\n"",""short int:"", ""-32767"", n025, ""C18"");

    short int n026 = -32768;
    printf (""%-25s %20s %20d %15s\n"",""short int:"", ""-32768"", n026, ""MIN - C18"");

    printf(""\nALOKACIJA: %d bitov"",sizeof(n026)*8);

    printf(""\n\n***********************************************************************************\n\n"");

    unsigned short int n027 = 65535;
    printf (""%-25s %20s %20d %15s\n"",""unsigned short int:"", ""65535"", n027, ""MAX - C18"");

    unsigned short int n028 = 32768;
    printf (""%-25s %20s %20d %15s\n"",""unsigned short int:"", ""32768"", n028, ""C18"");

    unsigned short int n029 = 32767;
    printf (""%-25s %20s %20d %15s\n"",""unsigned short int:"", ""32767"", n029, ""C18"");

    unsigned short int n030 = 32766;
    printf (""%-25s %20s %20d %15s\n"",""unsigned short int:"", ""32766"", n030, ""C18"");

    unsigned short int n031 = 1;
    printf (""%-25s %20s %20d %15s\n"",""unsigned short int:"", ""1"", n031, ""C18"");

    unsigned short int n032 = 0;
    printf (""%-25s %20s %20d %15s\n"",""unsigned short int:"", ""0"", n032, ""MIN - C18"");

    unsigned short int n033 = -1;
    printf (""%-25s %20s %20d %15s\n"",""unsigned short int:"", ""-1"", n033, ""!"");

    unsigned short int n034 = -32767;
    printf (""%-25s %20s %20d %15s\n"",""unsigned short int:"", ""-32767"", n034, ""!"");

    unsigned short int n035 = -32768;
    printf (""%-25s %20s %20d %15s\n"",""unsigned short int:"", ""-32768"", n035, ""!"");

    printf(""\nALOKACIJA: %d bitov"",sizeof(n035)*8);

    printf(""\n\n***********************************************************************************\n\n"");

    int n036 = 4294967295;
    printf (""%-25s %20s %20d %15s\n"",""int:"", ""4294967295"", n036, ""!"");

    int n037 = 2147483648;
    printf (""%-25s %20s %20d %15s\n"",""int:"", ""2147483648"", n037, ""!"");

    int n038 = 2147483647;
    printf (""%-25s %20s %20d %15s\n"",""int:"", ""2147483647"", n038, ""MAX - C18"");

    int n039 = 1;
    printf (""%-25s %20s %20d %15s\n"",""int:"", ""1"", n039, ""C18"");

    int n040 = 0;
    printf (""%-25s %20s %20d %15s\n"",""int:"", ""0"", n040, ""C18"");

    int n041 = -1;
    printf (""%-25s %20s %20d %15s\n"",""int:"", ""-1"", n041, ""C18"");

    int n042 = -2147483647;
    printf (""%-25s %20s %20d %15s\n"",""int:"", ""-2147483647"", n042, ""C18"");

    int nnnm = -2147483648;
    printf (""%-25s %20s %20d %15s\n"",""int:"", ""-2147483648"", nnnm, ""MIN - C18"");

    printf(""\nALOKACIJA: %d bitov"",sizeof(n042)*8);

    printf(""\n\n***********************************************************************************\n\n"");

    unsigned int n043 = 4294967295;
    printf (""%-25s %20s %20d %15s\n"",""unsigned int:"", ""4294967295"", n043, ""!"");

    unsigned int n044 = 4294967294;
    printf (""%-25s %20s %20d %15s\n"",""unsigned int:"", ""4294967294"", n044, ""!"");

    unsigned int n045 = 2147483648;
    printf (""%-25s %20s %20d %15s\n"",""unsigned int:"", ""2147483648"", n045, ""!"");

    unsigned int n046 = 2147483647;
    printf (""%-25s %20s %20d %15s\n"",""unsigned int:"", ""2147483647"", n046, ""MAX - C18"");

    unsigned int n047 = 1;
    printf (""%-25s %20s %20d %15s\n"",""unsigned int:"", ""1"", n047, ""C18"");

    unsigned int n048 = 0;
    printf (""%-25s %20s %20d %15s\n"",""unsigned int:"", ""0"", n048, ""MIN - C18"");

    unsigned int n049 = -1;
    printf (""%-25s %20s %20d %15s\n"",""unsigned int:"", ""-1"", n049, ""?"");

    unsigned int n05d = -2147483647;
    printf (""%-25s %20s %20d %15s\n"",""unsigned int:"", ""-2147483647"", n05d, ""?"");

    unsigned int n050 = -2147483648;
    printf (""%-25s %20s %20d %15s\n"",""unsigned int:"", ""-2147483648"", n050, ""?"");

    printf(""\nALOKACIJA: %d bitov"",sizeof(n050)*8);

    printf(""\n\n***********************************************************************************\n\n"");

    long int n051 = 9223372036854775807;
    printf (""%-25s %20s %20d %15s\n"",""long int:"", ""9223372036854775807"", n051, ""!"");

    long int n052 = 4294967294;
    printf (""%-25s %20s %20d %15s\n"",""long int:"", ""4294967294"", n052, ""!"");

    long int n053 = 2147483648;
    printf (""%-25s %20s %20d %15s\n"",""long int:"", ""2147483648"", n053, ""!"");

    long int n054 = 2147483647;
    printf (""%-25s %20s %20d %15s\n"",""long int:"", ""2147483647"", n054, ""MAX - C18"");

    long int n055 = 1;
    printf (""%-25s %20s %20d %15s\n"",""long int:"", ""1"", n055, ""C18"");

    long int n056 = 0;
    printf (""%-25s %20s %20d %15s\n"",""long int:"", ""0"", n056, ""C18"");

    long int n057 = -1;
    printf (""%-25s %20s %20d %15s\n"",""long int:"", ""-1"", n057, ""C18"");

    long int naaa = -2147483647;
    printf (""%-25s %20s %20d %15s\n"",""long int:"", ""-2147483647"", naaa, ""MIN - C18"");

    long int n058 = -2147483648;
    printf (""%-25s %20s %20d %15s\n"",""long int:"", ""-2147483648"", n058, ""?"");

    long int nnnn = -2147483649;
    printf (""%-25s %20s %20d %15s\n"",""long int:"", ""-2147483649"", nnnn, ""!"");

    long int nbbb = -4294967294;
    printf (""%-25s %20s %20d %15s\n"",""long int:"", ""-4294967294"", nbbb, ""!"");

    long int nccc = -9223372036854775807;
    printf (""%-25s %20s %20d %15s\n"",""long int:"", ""-9223372036854775807"", nccc, ""!"");

    printf(""\nALOKACIJA: %d bitov"",sizeof(n057)*8);


    printf(""\n\n***********************************************************************************\n\n"");

    unsigned long int n059 = 9223372036854775807;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long int:"", ""9223372036854775807"", n059, ""!"");

    unsigned long int n060 = 4294967294;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long int:"", ""4294967294"", n060, ""!"");

    unsigned long int n061 = 2147483648;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long int:"", ""2147483648"", n061, ""!"");

    unsigned long int n062 = 2147483647;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long int:"", ""2147483647"", n062, ""MAX - C18"");

    unsigned long int n063 = 1;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long int:"", ""1"", n063, ""C18"");

    unsigned long int n064 = 0;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long int:"", ""0"", n064, ""MIN - C18"");

    unsigned long int n065 = -1;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long int:"", ""-1"", n065, ""?"");

    unsigned long int n066 = -2147483648;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long int:"", ""-2147483648"", n066, ""?"");

    unsigned long int nzzz = -4294967294;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long int:"", ""-4294967294"", nzzz, ""!"");

    unsigned long int nggg = -9223372036854775807;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long int:"", ""-9223372036854775807"", nggg, ""!"");

    printf(""\nALOKACIJA: %d bitov"",sizeof(n064)*8);

    printf(""\n\n***********************************************************************************\n\n"");

    long long int n080 = 9223372036854775807;
    printf (""%-25s %20s %20d %15s\n"",""long long int:"", ""9223372036854775807"", n080, ""!"");

    long long int n081 = 4294967294;
    printf (""%-25s %20s %20d %15s\n"",""long long int:"", ""4294967294"", n081, ""!"");

    long long int n082 = 2147483648;
    printf (""%-25s %20s %20d %15s\n"",""long long int:"", ""2147483648"", n082, ""!"");

    long long int n083 = 2147483647;
    printf (""%-25s %20s %20d %15s\n"",""long long int:"", ""2147483647"", n083, ""MAX - C18"");

    long long int n084 = 1;
    printf (""%-25s %20s %20d %15s\n"",""long long int:"", ""1"", n084, ""C18"");

    long long int n085 = 0;
    printf (""%-25s %20s %20d %15s\n"",""long long int:"", ""0"", n085, ""MIN - C18"");

    long long int n086 = -1;
    printf (""%-25s %20s %20d %15s\n"",""long long int:"", ""-1"", n086, ""?"");

    long long int n087 = -2147483648;
    printf (""%-25s %20s %20d %15s\n"",""long long int:"", ""-2147483648"", n087, ""?"");

    long long int n088 = -4294967294;
    printf (""%-25s %20s %20d %15s\n"",""long long int:"", ""-4294967294"", n088, ""!"");

    long long int n089 = -9223372036854775807;
    printf (""%-25s %20s %20d %15s\n"",""long long int:"", ""-9223372036854775807"", n089, ""!"");

    printf(""\nALOKACIJA: %d bitov"",sizeof(n089)*8);

    printf(""\n\n***********************************************************************************\n\n"");

    unsigned long long int n067 = 9223372036854775807;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long long int:"", ""9223372036854775807"", n067, ""!"");

    unsigned long long int n068 = 4294967294;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long long int:"", ""4294967294"", n068, ""!"");

    unsigned long long int n069 = 2147483648;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long long int:"", ""2147483648"", n069, ""!"");

    unsigned long long int n070 = 2147483647;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long long int:"", ""2147483647"", n070, ""MAX - C18"");

    unsigned long long int n071 = 1;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long long int:"", ""1"", n071, ""C18"");

    unsigned long long int n072 = 0;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long long int:"", ""0"", n072, ""MIN - C18"");

    unsigned long long int n073 = -1;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long long int:"", ""-1"", n073, ""?"");

    unsigned long long int n074 = -2147483648;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long long int:"", ""-2147483648"", n074, ""?"");

    unsigned long long int n075 = -4294967294;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long long int:"", ""-4294967294"", n075, ""!"");

    unsigned long long int n076 = -9223372036854775807;
    printf (""%-25s %20s %20d %15s\n"",""unsigned long long int:"", ""-9223372036854775807"", n076, ""!"");

    printf(""\nALOKACIJA: %d bitov"",sizeof(n076)*8);

    return 0;
}
</code></pre>

<p>I used a newest standard <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2310.pdf"" rel=""nofollow noreferrer"">C18</a> to compile: </p>

<pre><code>gcc -std=c18 -o 001 001.c
</code></pre>

<p>And as soon as I ran the binary, I got this output:</p>

<pre><code>***********************************************************************************

                                  IZVORNA KODA         BINARNA KODA          OPOMBA

signed char:                               255                   -1               !
signed char:                               128                 -128               !
signed char:                               127                  127       MAX - C18
signed char:                                 1                    1             C18
signed char:                                 0                    0             C18
signed char:                                -1                   -1             C18
signed char                               -127                 -127             C18
signed char                               -128                 -128       MIN - C18

ALOKACIJA: 8 bitov

***********************************************************************************

                                  IZVORNA KODA         BINARNA KODA          OPOMBA

unsigned char:                             255                  255       MAX - C18
unsigned char:                             128                  128             C18
unsigned char:                             127                  127             C18
unsigned char:                               1                    1             C18
unsigned char:                               0                    0       MIN - C18
unsigned char:                              -1                  255               !
unsigned char:                            -127                  129               !
unsigned char:                            -128                  128               !

ALOKACIJA: 8 bitov

***********************************************************************************

short int:                               65535                   -1               !
short int:                               32768               -32768               !
short int:                               32767                32767       MAX - C18
short int:                               32766                32766             C18
short int:                                   1                    1             C18
short int:                                   0                    0             C18
short int:                                  -1                   -1             C18
short int:                              -32767               -32767             C18
short int:                              -32768               -32768       MIN - C18

ALOKACIJA: 16 bitov

***********************************************************************************

unsigned short int:                      65535                65535       MAX - C18
unsigned short int:                      32768                32768             C18
unsigned short int:                      32767                32767             C18
unsigned short int:                      32766                32766             C18
unsigned short int:                          1                    1             C18
unsigned short int:                          0                    0       MIN - C18
unsigned short int:                         -1                65535               !
unsigned short int:                     -32767                32769               !
unsigned short int:                     -32768                32768               !

ALOKACIJA: 16 bitov

***********************************************************************************

int:                                4294967295                   -1               !
int:                                2147483648          -2147483648               !
int:                                2147483647           2147483647       MAX - C18
int:                                         1                    1             C18
int:                                         0                    0             C18
int:                                        -1                   -1             C18
int:                               -2147483647          -2147483647             C18
int:                               -2147483648          -2147483648       MIN - C18

ALOKACIJA: 32 bitov

***********************************************************************************

unsigned int:                       4294967295                   -1               !
unsigned int:                       4294967294                   -2               !
unsigned int:                       2147483648          -2147483648               !
unsigned int:                       2147483647           2147483647       MAX - C18
unsigned int:                                1                    1             C18
unsigned int:                                0                    0       MIN - C18
unsigned int:                               -1                   -1               ?
unsigned int:                      -2147483647          -2147483647               ?
unsigned int:                      -2147483648          -2147483648               ?

ALOKACIJA: 32 bitov

***********************************************************************************

long int:                  9223372036854775807                   -1               !
long int:                           4294967294                   -2               !
long int:                           2147483648          -2147483648               !
long int:                           2147483647           2147483647       MAX - C18
long int:                                    1                    1             C18
long int:                                    0                    0             C18
long int:                                   -1                   -1             C18
long int:                          -2147483647          -2147483647       MIN - C18
long int:                          -2147483648          -2147483648               ?
long int:                          -2147483649           2147483647               !
long int:                          -4294967294                    2               !
long int:                 -9223372036854775807                    1               !

ALOKACIJA: 64 bitov

***********************************************************************************

unsigned long int:         9223372036854775807                   -1               !
unsigned long int:                  4294967294                   -2               !
unsigned long int:                  2147483648          -2147483648               !
unsigned long int:                  2147483647           2147483647       MAX - C18
unsigned long int:                           1                    1             C18
unsigned long int:                           0                    0       MIN - C18
unsigned long int:                          -1                   -1               ?
unsigned long int:                 -2147483648          -2147483648               ?
unsigned long int:                 -4294967294                    2               !
unsigned long int:        -9223372036854775807                    1               !

ALOKACIJA: 64 bitov

***********************************************************************************

long long int:             9223372036854775807                   -1               !
long long int:                      4294967294                   -2               !
long long int:                      2147483648          -2147483648               !
long long int:                      2147483647           2147483647       MAX - C18
long long int:                               1                    1             C18
long long int:                               0                    0       MIN - C18
long long int:                              -1                   -1               ?
long long int:                     -2147483648          -2147483648               ?
long long int:                     -4294967294                    2               !
long long int:            -9223372036854775807                    1               !

ALOKACIJA: 64 bitov

***********************************************************************************

unsigned long long int:    9223372036854775807                   -1               !
unsigned long long int:             4294967294                   -2               !
unsigned long long int:             2147483648          -2147483648               !
unsigned long long int:             2147483647           2147483647       MAX - C18
unsigned long long int:                      1                    1             C18
unsigned long long int:                      0                    0       MIN - C18
unsigned long long int:                     -1                   -1               ?
unsigned long long int:            -2147483648          -2147483648               ?
unsigned long long int:            -4294967294                    2               !
unsigned long long int:   -9223372036854775807                    1               !
</code></pre>

<p>where everything looks fine until <code>unsigned int</code>, <code>long int</code>,<code>unsigned long int</code>, <code>long long int</code> and <code>unsigned long long int</code> which are all the same and some even violate the standard (!) which clearly defines max and min values on page 20:</p>

<p><a href=""https://i.stack.imgur.com/UL2Gr.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UL2Gr.png"" alt=""enter image description here""></a></p>

<p>So it is clear that (a) there is a problem with the GCC toolchain and (b) you should avoid using <code>int</code> which is a disaster of the C programming language and this is why standard C11 presented the <code>stdint.h</code> which defines new integer data types: </p>

<ul>
<li>int8_t </li>
<li>int16_t </li>
<li>int32_t</li>
<li>uint8_t</li>
<li>uint16_t</li>
<li>uint32_t</li>
<li>int64_t </li>
<li>uint64_t</li>
</ul>

<p>and <strong>every</strong> single profesional programer out there is using the new data types, where old ones are kept for compatibility with older software but should be avoided. </p>

<p>Also pay attention to the online lessons. If they use old data types they clearly don't have a clue about C, so you should avoid those lessons.</p>
",0
51185978,51185885,3,"<p>You probably want somewhing like this:</p>

<pre><code> const char* text;
 const char* input;
 int i=2;
 input = ""orange"";

 switch(i) {
 case 1:
      text = ""%s is color"";
      break;
 case 2:
      text = ""%s is fruit"";
      break;
 default:
      break;
 }

 printf(text, input);
</code></pre>
",2
51280824,51280044,1,"<p>The code in your question contains ~5 syntax errors. It's better to show the code that you used exactly.</p>

<p>Once fixed to be syntactically correct C, your program attempts to write more data to the malloc-allocated block than can fit: <a href=""https://taas.trust-in-soft.com/tsnippet/t/9c2ce34f"" rel=""nofollow noreferrer"">https://taas.trust-in-soft.com/tsnippet/t/9c2ce34f</a></p>

<p>It has been pointed out by Frankie_C in the comments that you may want to reserve room for a final <code>'\0'</code>, but this is not sufficient to make the program defined: there is also a logic error in that the program attempts to copy <code>in_len</code> more chars as soon as there remains room for one more char: <a href=""https://taas.trust-in-soft.com/tsnippet/t/3a2b848b"" rel=""nofollow noreferrer"">https://taas.trust-in-soft.com/tsnippet/t/3a2b848b</a></p>

<p>I changed the loop condition to <code>while (n &lt; out_len - rem) {</code> just like in Karthick's answer. Now the problem is that the array of chars passed to <code>printf(""%s""</code> does not end with a final <code>'\0'</code>: <a href=""https://taas.trust-in-soft.com/tsnippet/t/7c1ca032"" rel=""nofollow noreferrer"">https://taas.trust-in-soft.com/tsnippet/t/7c1ca032</a></p>

<p>The final <code>\'0'</code> has to be written. Since the destination block was allocated by <code>malloc</code> and is not guaranteed to be 0-initialized, it is not enough to leave room for a character at the end. You must also explicitly set the last character to <code>'\0'</code>, for instance with:</p>

<pre><code>c[out_len] = '\0'; 
</code></pre>

<p>Finally, the modified version of your program that does not produce undefined behavior is (<a href=""https://taas.trust-in-soft.com/tsnippet/t/dea9e8b2"" rel=""nofollow noreferrer"">https://taas.trust-in-soft.com/tsnippet/t/dea9e8b2</a> ):</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

char *cpy_data(char *ip_str, int in_len, int out_len)
{
    char *c = malloc(out_len + 1);
    memset(c, 0, out_len);
    int rem, n;
    rem = out_len % in_len;
    n = 0;
    while(n &lt; out_len - rem){
        memcpy(&amp;c[n], ip_str, in_len);
        n += in_len;
    }
    if (rem)
        memcpy(&amp;c[n], ip_str, rem);
    c[out_len] = '\0';    
    printf(""%s \n"", c);
    return c;
}

int main(int argc, char **argv) {
  char *ch = ""apples"";
  ch = cpy_data(ch, 6, 20);  
}
</code></pre>
",0
52570786,52570357,2,"<p>A <a href=""https://www.wikiwand.com/en/C_data_types#/Basic_types"" rel=""nofollow noreferrer"">long integer is <em>at least</em> 32 bits</a>, so yes, you're going to lose information trying to shove a signed 32 bit integer into an unsigned 16 bit integer. If you have compiler warnings on (I use <code>-Wall -Wshadow -Wwrite-strings -Wextra -Wconversion -std=c99 -pedantic</code>) it should tell you that.</p>

<pre><code>test.c:20:28: warning: implicit conversion loses integer precision: 'long' to 'uint16_t'
      (aka 'unsigned short') [-Wconversion]
        tmp.registers[i] = strtol(tmp.vals, &amp;end, 10);
                         ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>

<p>However, this isn't going to cause a segfault. You'll lose 16 bits and the change in sign will do funny things.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;inttypes.h&gt;

int main() {
    long big = 1234567;
    uint16_t small = big;
    printf(""big = %ld, small = %"" PRIu16 ""\n"", big, small);
}
</code></pre>

<p>If you <em>know</em> what you're reading will fit into 16 bits, you can make things a little safer first by using <code>strtoul</code> to read an <strong><em>unsigned</em></strong> <code>long</code>, verify that it's small enough to fit, and explicitly cast it.</p>

<pre><code>    unsigned long num = strtoul(tmp.vals, &amp;end, 10);
    if( 0 &lt;= num &amp;&amp; num &lt; 65536 ) {
        tmp.registers[i] = (uint16_t)num;
    }
    else {
        fprintf(stderr, ""%lu is too large to fit in the register\n"", num);
    }
</code></pre>

<hr>

<p>More likely <code>tmp.registers</code> (and possibly <code>buffer</code>) weren't properly initialized and allocated points to garbage. If you simply declared the <code>tmp</code> on the stack like so:</p>

<pre><code>Registers tmp;
</code></pre>

<p>This only allocates memory for <code>tmp</code>, not the things it points to. And it will contain garbage. <code>tmp.registers</code> will point to some random spot in memory. When you try to write to it it will segfault... eventually.</p>

<p>The register array needs to be allocated.</p>

<pre><code>size_t how_many = 10;
uint16_t *registers = malloc( sizeof(uint16_t) * how_many );
Thing tmp = {
    .registers = registers,
    .vals = NULL
};
</code></pre>

<hr>

<p>This is fine so long as your loop only ever runs <code>how_many</code> times. But you can't be sure of that when reading input. Your loop is potentially reading an infinite number of registers. If it goes over the 10 we've allocated it will again start writing into someone else's memory and segfault.</p>

<p>Dynamic memory is too big a topic for here, but we can at least limit the loop to the size of the array by tracking the maximum size of <code>registers</code> and how far in it is. We could do it in the loop, but it really belongs in the struct.</p>

<pre><code>typedef struct {
    uint16_t *registers;
    char *vals;
    size_t max;
    size_t size;
} Registers;
</code></pre>

<p>While we're at it, put initialization into a function so we're sure it's done reliably each time.</p>

<pre><code>void Registers_init( Registers *registers, size_t size ) {
    registers-&gt;registers = malloc( sizeof(uint16_t) * size );
    registers-&gt;max = size;
    registers-&gt;size = 0;
}
</code></pre>

<p>And same with our bounds check.</p>

<pre><code>void Registers_push( Registers *registers, uint16_t num ) {
    if( registers-&gt;size == registers-&gt;max ) {
        fprintf(stderr, ""Register has reached its limit of %zu\n"", registers-&gt;max);
        exit(1);
    }
    registers-&gt;registers[ registers-&gt;size ] = (uint16_t)num;
    registers-&gt;size++;
}
</code></pre>

<p>Now we can add registers safely. Or at least it will error nicely.</p>

<pre><code>Registers registers;
Registers_init( &amp;registers, 10 );

tmp.vals = strtok(buffer, delimiter);
while (tmp.vals != NULL) {
    unsigned long num = strtoul(tmp.vals, &amp;end, 10);
    if( 0 &lt;= num &amp;&amp; num &lt; 65536 ) {
        Registers_push( &amp;tmp, (uint16_t)num );
    }
    else {
        fprintf(stderr, ""%lu is too large to fit in the register\n"", num);
    } 
    tmp.vals = strtok(NULL, delimiter);
    i++;
}
</code></pre>

<p>At this point we're re-implementing a size-bound array. It's a good exercise, but for production code <a href=""https://developer.gnome.org/glib/stable/glib-Pointer-Arrays.html"" rel=""nofollow noreferrer"">use an existing library such as GLib</a> which provides self-growing arrays and a lot more features.</p>
",3
59310498,59310415,3,"<blockquote>
  <p>Here and there people seem to agree that a dynamically allocated pointer or struct, is stored in the heap as well as the variables it is pointing to.</p>
</blockquote>

<p>This allocates a stack-allocated pointer, which you use to store the address of a dynamically allocated <code>int</code> array:</p>

<pre><code>int* p = (int*) calloc(rows, sizeof(int));
</code></pre>

<p>If you wanted to make a <em>dynamically allocated pointer</em>, you'd instead write:</p>

<pre><code>int** pp = (int**) calloc(1, sizeof(int*));
</code></pre>

<p>Note that we still store the address of the dynamically allocated pointer in a stack allocated pointer. If we didn't, we'd just lose access to the dynamic allocation. You can use that dynamically allocated pointer to store the address of dynamically allocated array, like before:</p>

<pre><code>*pp = (int*) calloc(rows, sizeof(int));
</code></pre>

<p>To release memory, you'd have to free both the array and the pointer:</p>

<pre><code>free(*pp);
free(pp);
</code></pre>
",0
51740436,51739429,1,"<p>This is almost certainly an ""XY problem"". That is, you think saving the call order is the solution to your actual problem, but your actual problem might be to ensure that the functions can't be called in the wrong order in the first place. </p>

<p>So the most correct way to fix this is to remake the program design. Someone mentioned state machines as one solution. Another solution might be something like an array of function pointers (which is a common implementation of state machines).</p>

<hr>

<p>That being said, you <em>can</em> do something artificial to track the call order, though I wouldn't really recommend it. Example:</p>

<pre><code>#define CALL_ORDER_N 3

const char* call_order [CALL_ORDER_N] = {NULL};
size_t call_order_i = 0;


static void save_call (const char* func)
{
  call_order[call_order_i] = func;
  call_order_i++;
  if(call_order_i == CALL_ORDER_N)
  {
    call_order_i = 0;
  } 
}
</code></pre>

<p>Where <code>call_order</code> saves the 3 last function calls as pointers to string literals. The function <code>save_call</code> updates this array, by passing the <code>__func__</code> constant to it from each function. <code>__func__</code> is guaranteed to work like a <code>static const char[]</code> so this is safe. You'd do something like this:</p>

<pre><code>void myFunction1 (void)
{
  save_call(__func__);
  ...
}

void myFunction2 (void)
{
  save_call(__func__);
  ...
}

void myFunction3 (void)
{
  save_call(__func__);
  ...
}
</code></pre>

<p>And then go through the calls to see if they were in the correct order:</p>

<pre><code>static bool is_call_order_ok (void)
{
  const char* expected_order [CALL_ORDER_N] = 
  {
    ""myFunction1"",
    ""myFunction2"",
    ""myFunction3""
  };

  size_t co_i = call_order_i;

  for(size_t i=0; i&lt;CALL_ORDER_N; i++)
  {
    if(strcmp(call_order[co_i], expected_order[i])==0)
    {
      co_i++;
      if(co_i == CALL_ORDER_N)
      {
        co_i = 0;
      } 
    }
    else
    {
      return false;
    }
  }

  return true;
}
</code></pre>

<p>Full example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;string.h&gt;

#define CALL_ORDER_N 3

const char* call_order [CALL_ORDER_N] = {NULL};
size_t call_order_i = 0;


static void save_call (const char* func)
{
  call_order[call_order_i] = func;
  call_order_i++;
  if(call_order_i == CALL_ORDER_N)
  {
    call_order_i = 0;
  } 
}

static bool is_call_order_ok (void)
{
  const char* expected_order [CALL_ORDER_N] = 
  {
    ""myFunction1"",
    ""myFunction2"",
    ""myFunction3""
  };

  size_t co_i = call_order_i;

  for(size_t i=0; i&lt;CALL_ORDER_N; i++)
  {
    if(strcmp(call_order[co_i], expected_order[i])==0)
    {
      co_i++;
      if(co_i == CALL_ORDER_N)
      {
        co_i = 0;
      } 
    }
    else
    {
      return false;
    }
  }

  return true;
}


void myFunction1 (void)
{
  save_call(__func__);
}


void myFunction2 (void)
{
  save_call(__func__);
}


void myFunction3 (void)
{
  save_call(__func__);
}



int main (void)
{
  printf(""Call 1,2,3: "");
  myFunction1();
  myFunction2();
  myFunction3();
  printf(is_call_order_ok() ? ""Ok\n"" : ""Failed\n"");

  printf(""Call 3,2,1: "");
  myFunction3();
  myFunction2();
  myFunction1();
  printf(is_call_order_ok() ? ""Ok\n"" : ""Failed\n"");

  printf(""Call 1,1,1: "");
  myFunction1();
  myFunction1();
  myFunction1();
  printf(is_call_order_ok() ? ""Ok\n"" : ""Failed\n"");

  return 0;
}
</code></pre>

<hr>

<p>The advanced, more professional version of the above, would be to cook together a mini-API with a single function, in order to give private encapsulation to every single variable. The function <code>save_call</code> would then be a multi-purpose function, that can be used to register expected call order, save function calls, as well as verify if the current registered order is ok.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;string.h&gt;

#define CALL_ORDER_N 3

static bool save_call (const char* func, bool verify)
{
  bool result;

  static const char* call_order [CALL_ORDER_N] = {NULL};
  static size_t call_order_i = 0;
  static const char* expected_order [CALL_ORDER_N] = {NULL};

  size_t i = call_order_i;

  if(verify)                           // special case, verify the order
  {
    for(size_t expected=0; expected&lt;CALL_ORDER_N; expected++)
    {
      if(call_order[i] == expected_order[expected])
      {
        i++;
        if(i == CALL_ORDER_N)
        {
          i = 0;
        } 
      }
      else
      {
        return false;
      }
    }
    return true;
  }

  if(expected_order[i] == NULL)        // register order of calls
  {
    expected_order[i] = func;
    result = true;
  }
  else                                 // save calls
  {
    call_order[i] = func;
    result = false;
  }

  call_order_i++;
  if(call_order_i == CALL_ORDER_N)
  {
    call_order_i = 0;
  } 

  return result;
}


void myFunction1 (void)
{
  if(save_call(__func__, false))
    return ;
  printf(""Execute stuff in %s.\n"", __func__);
}


void myFunction2 (void)
{
  if(save_call(__func__, false))
    return ;
  printf(""Execute stuff in %s.\n"", __func__);
}


void myFunction3 (void)
{
  if(save_call(__func__, false))
    return ;
  printf(""Execute stuff in %s.\n"", __func__);
}



int main (void)
{
  /* register call order: */
  myFunction1();
  myFunction2();
  myFunction3();


  printf(""Call 1,2,3:\n"");
  myFunction1();
  myFunction2();
  myFunction3();
  printf(save_call(NULL, true) ? ""Ok\n\n"" : ""Failed\n\n"");

  printf(""Call 3,2,1:\n"");
  myFunction3();
  myFunction2();
  myFunction1();
  printf(save_call(NULL, true) ? ""Ok\n\n"" : ""Failed\n\n"");

  printf(""Call 1,1,1:\n"");
  myFunction1();
  myFunction1();
  myFunction1();
  printf(save_call(NULL, true) ? ""Ok\n\n"" : ""Failed\n\n"");

  return 0;
}
</code></pre>

<p><code>save_call</code> should of course be properly placed in a .h/.c file pair of its own.</p>
",0
58892062,58892041,1,"<p>Result of the expression <code>startPage&lt;0 ? 0:startPage;</code> is not assigned to a variable, so it is not used.  Thus, the compiler is warning you that there is a <code>statement with no effect</code></p>

<p>Instead,</p>

<pre><code>startPage = startPage &lt; 0 ? 0 : startPage;
</code></pre>

<p>will work.  Though, this is more readable if you write:</p>

<pre><code>if (startPage &lt; 0) {startPage = 0}
</code></pre>
",3
52457341,52457026,1,"<p>I took the liberty of massaging your code a little bit, and assuming you want a sum...</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    int num, sum = 0;
    printf(""Enter the account activity: "");
    fflush(stdout);
    for (;;) {
        if (scanf(""%d"", &amp;num) != 1) break;
        if (num == 0) break;
        sum += num;
    }
    printf(""Result is %d.\n"", sum);
    return 0;
}
</code></pre>
",0
48764120,48763924,7,"<blockquote>
  <p>Next we will get a memory from pool using getPerson function. This function, checks against <code>!=NULL</code> which I think will fail every time.</p>
</blockquote>

<p>The check will fail every time as long as you continue calling <code>getPerson</code> repeatedly. However, if you do a mixture of <code>getPerson</code> and <code>returnPerson</code>, some <code>NULL</code> checks will succeed, because <code>returnPerson</code> puts non-<code>NULL</code> values into the array.</p>

<p>This observation is key to understanding the approach: the array serves as a small temporary storage for <code>struct Person</code> blocks that have been allocated with <code>malloc</code>, but are no longer in use. Rather than calling <code>malloc</code> again, your code grabs an available block from this special list, if there is one available.</p>

<p>In situations when you make thousands of allocations, but never keep more than <code>LIST_SIZE</code> objects active at any given time, the number of <code>malloc</code> calls is limited to <code>LIST_SIZE</code>.</p>

<blockquote>
  <p>Is this the way to handle overhead?</p>
</blockquote>

<p>This is a variation on using lookaside lists, an optimization technique so important that Microsoft created <a href=""https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/using-lookaside-lists"" rel=""noreferrer"">an API for its use in driver code</a>. A simpler approach would use <code>Person *list[LIST_SIZE]</code> as a stack of released blocks, i.e. with the index of the last released block and no loop.</p>

<p>Another approach would be to set up a linked list of such blocks, reusing the memory of the block itself to store the <code>next</code> pointer. This technique may be too complex for an introductory boo, though.</p>
",3
48768124,48763924,0,"<p>I think the point of the example might be that a <code>Person</code> object holds pointers to additional memory. We can see from the <code>deallocatePerson</code> function that there are 3 pointers to strings inside the struct:</p>

<pre><code>void deallocatePerson(Person *person) 
{
    free(person-&gt;firstName);
    free(person-&gt;lastName);
    free(person-&gt;title);
}
</code></pre>

<p>It means that to construct a complete <code>Person</code> you need several calls to <code>malloc</code> (1 for the struct itself and 3 for the strings). </p>

<p>So by saving a complete struct, including its strings, one <code>getPerson</code> call replaces <em>four</em> calls to <code>malloc</code>. That makes it likely to save some execution time.</p>

<p>Otherwise, I would not be surprised if <code>malloc</code>/<code>free</code> internally holds a similar array or linked list of recently used memory blocks ready to be recycled. If you have just <code>free</code>'d a memory block of the correct size, a new call to <code>malloc</code> will likely locate that block <em>very</em> fast.</p>

<p>Had <code>Person</code> been a simple struct without pointers to additional storage, the local caching is not <em>that</em> likely to improve performance (but perhaps instead <em>add</em> overhead by doing a  linear search).</p>
",0
48383042,48382703,2,"<p>If <code>library</code> is the only module exposed to the caller - it is the actual API - then this design is fine. A nosy caller, who for some reason goes to dig up internal header files only used by <code>library</code>, can't do much with it anyway - <code>struct my_data</code> in the header is an incomplete type.</p>

<p>However, a less confusing alternative might be to write <code>library_component.h</code> as:</p>

<pre><code>typedef struct my_data_t my_data_t;
</code></pre>

<p>And then use that very same definition in <code>library.h</code> - the type is declared in <code>library_component.h</code> and <code>library.h</code> gets access through it with <code>#include</code>. Then everything will be clear. In <code>library_component.c</code> you would have <code>struct my_data_t { ...</code>. </p>

<p>And finally, all functions in <code>library.h</code> should be designed to use <code>my_data_t*</code>, which is a must since the type is incomplete and the caller won't be able to create instances of it.</p>

<p>This design method is known as <em>opaque type</em>/<em>opaque pointers</em>.</p>
",1
52113383,52113208,5,"<p>As it is easy to see, the code reinterprets the bytes <a href=""https://en.wikipedia.org/wiki/Single-precision_floating-point_format"" rel=""nofollow noreferrer"">IEEE 754 binary32 float</a> as a 32-bit unsigned integer via union type punning. It then uses the bit-wise operations to check particular bits in the exponent of the floating point number. Understanding what it <em>actually does</em> requires intricate knowledge of the binary32 storage format.</p>

<hr>

<p><code>PD_BADFLOAT</code> checks if <a href=""https://en.wikipedia.org/wiki/Exponent_bias"" rel=""nofollow noreferrer"">the biased exponent</a> is either 0 or the maximum value 255 as <a href=""https://en.wikipedia.org/wiki/Single-precision_floating-point_format#Exponent_encoding"" rel=""nofollow noreferrer"">0 and 255 have special meanings</a> (those with exponent 0 are <a href=""https://en.wikipedia.org/wiki/Denormal_number"" rel=""nofollow noreferrer"">subnormal numbers</a> and zero; and 255 meaning NaNs and infinities). Notice however, that these are not <em>bad floating point numbers</em> - but they do not behave like regular numbers either.</p>

<hr>

<p>The second checks if the unbiased exponent is outside the range [-63, 65] (the description seems to be wrong w.r.t. the bounds) meaning that its magnitude is above than 2?? (~ 3.7 * 101?) or below than 2??3, (~ 1.08 * 10?1?).</p>

<p>All this is very implementation-specific and non-portable - it seems that these have been programmed with speed in mind.</p>

<hr>

<p>The former is an exact equivalent of the negation of the standard macro <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.12.3.5"" rel=""nofollow noreferrer""><code>isnormal</code></a>.</p>

<p>For the latter, the portable way I believe is to use the C99+ function <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.12.6.4"" rel=""nofollow noreferrer""><code>frexpf</code></a> to get the exponent from the <code>float</code> and then compare against the desired limits, or by just constructing constants that represent these values and comparing the absolute value with these limits.</p>

<p>Hence something like</p>

<pre><code>static inline int PD_BADFLOAT(float f) {
    return !isnormal(f);
}

static inline int PD_BIGORSMALL(float f) {
    int exp;
    if (isnormal(f)) {
        frexpf(f, &amp;exp);
        return exp &lt; -63 || exp &gt; 65;
    }

    // return 1 for subnormal numbers and
    // NaN, INF...
    return 1;
}
</code></pre>
",2
57031068,57030963,2,"<p>You cannot place statements outside of functions in C. At global scope only declarations are allowed. <code>tilelist[0] = &amp;blue27tile;</code> is a statement, for example.</p>

<p>Try:</p>

<pre><code>char *tilelist[] = { blue27tile, grey10tile };
</code></pre>
",0
54236035,54235886,1,"<p>Don't be afraid to use str utilities. <code>man strcpy</code>, <code>man strcat</code>.
Here is what I think you want (Unclear from post):</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int     main()
{
  char* home = getenv(""HOME"");
  char* add = ""/path.png?5667!http-get:*:image/png:!!!!!"";
  char* full = malloc(strlen(home) + strlen(add) + 1);
  strcpy(full, home);
  strcat(full, add);
  printf(""Full = %s"", full);
  return 0;
} 
</code></pre>
",1
49466917,49466891,3,"<p>It's a <a href=""https://en.wikipedia.org/wiki/Null_character"" rel=""nofollow noreferrer"">NUL character</a>, it's used to denote the end of a string for C-strings. In this case it's completely useless since a string literal (created with <code>""""</code>) already gets a <code>\0</code> appended to it by the compiler.</p>

<p>The <code>\0</code> is needed to signal that functions that work with strings to stop when it encounters this character.</p>
",3
59545570,59545516,6,"<p>Although <code>buffer_one</code> is a <code>char[8]</code> type, under certain instances, such as when passed as a function parameter, it <em>decays</em> to a pointer set to the first element of the array. That pointer will be a <code>char*</code> type.</p>

<p>Since the first parameter of <code>strcpy</code> is expected to be a <code>char*</code> type, compilation is successful.</p>
",0
59545757,59545516,0,"<blockquote>
  <p>Why does an integer need an ampersand when formatting a pointer in printf while a character array doesn't?</p>
</blockquote>

<p>To print the pointer of an object like <code>int</code> or <code>char []</code>, code uses <code>&amp;</code> to get the address of the object.</p>

<pre><code>int value = 5;
char buffer_one[8];

printf(""Address of an int: %p\n"", (void *) &amp;value);
printf(""Address of an array: %p\n"", (void *) &amp;buffer_one);
</code></pre>

<p>If code does not use <code>&amp;</code>, then the object must be or convert to a pointer.  In the following, the array <code>buffer_one</code> is converted to the address of it first element.</p>

<pre><code>printf(""Address of initial array element: %p\n"", (void *) buffer_one);
</code></pre>

<p><strong>Conclusion</strong> The <code>&amp;value</code> is needed as the <code>int</code> does not automatically convert to a pointer.  <code>buffer_one</code> does not need a <code>&amp;</code> as it converts to a pointer in this usage.  <code>buffer_one</code> can also use a <code>&amp;</code>, like any object.</p>

<hr>

<p>The address of the array <code>buffer_one</code> is the same memory location as the address of its first element. Although its is <em>very common</em>, that the last 2 prints above will print the same pointer, C does not require this.  The address of the array and the address of the <code>char</code> are <em>equivalent</em>, though not necessarily encoded the same.</p>
",0
53802918,53802818,2,"<p>Turn on your compiler warnings, and mind them.</p>

<pre><code>if (input == ""!"");
//           ^ ^ ^
if (input == '!')
</code></pre>

<p>Other than the errors above and needing an ENTER your program should work as is.</p>
",0
53803114,53802818,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(){
    int counter;
    counter = 0;
    char input = '0';

        while (input != '!'){
            scanf(""%c"", &amp;input);
            if(input != '\n')
                counter ++;
        }

    printf(""Keystrokes = %d"", counter);
    return 0;
}
</code></pre>
",0
55500868,55499061,1,"<p>Other people have given you what went wrong, this is how to figure it out for next time:</p>

<pre><code>$ gcc -Wall -Werror -std=gnu11 -Wextra -g -O0 -o program program.c
$ gdb ./program
(gdb) run
Program received signal SIGSEGV, Segmentation fault.
main () at program:23
23          printf("" 9. %d\n"", **ppp[3]);
(gdb) p ppp[3]
$1 = (int **) 0x7fffffffe2d8
(gdb) p **ppp[3]
Cannot access memory at address 0x280000001e
</code></pre>

<p>That shows that trying to dereference <code>*ppp[3]</code> is what caused your segfault. From there, a bit of thinking and playing with it ought to get you to what went wrong. From there to trying a <code>p (**ppp)[3]</code> and seeing that it prints the result you expect shouldn't be too big a step.</p>
",0
55500868,55499061,1,"<p>Other people have given you what went wrong, this is how to figure it out for next time:</p>

<pre><code>$ gcc -Wall -Werror -std=gnu11 -Wextra -g -O0 -o program program.c
$ gdb ./program
(gdb) run
Program received signal SIGSEGV, Segmentation fault.
main () at program:23
23          printf("" 9. %d\n"", **ppp[3]);
(gdb) p ppp[3]
$1 = (int **) 0x7fffffffe2d8
(gdb) p **ppp[3]
Cannot access memory at address 0x280000001e
</code></pre>

<p>That shows that trying to dereference <code>*ppp[3]</code> is what caused your segfault. From there, a bit of thinking and playing with it ought to get you to what went wrong. From there to trying a <code>p (**ppp)[3]</code> and seeing that it prints the result you expect shouldn't be too big a step.</p>
",0
54331752,54331673,1,"<p>According to the documentation:</p>

<blockquote>
  <p>On success, the function returns str.
  If the end-of-file is encountered while attempting to read a character, the eof indicator is set (feof). If this happens before any characters could be read, the pointer returned is a null pointer (and the contents of str remain unchanged).
  If a read error occurs, the error indicator (ferror) is set and a null pointer is also returned (but the contents pointed by str may have changed).</p>
</blockquote>

<p>str is the buffer you specified as the first argument. If <code>fgets</code> is done reading, NULL is returned.</p>
",2
53768397,53768281,1,"<p>Using a 2D array for the snake coordinates isn't a good idea, since you'll have to traverse the entire 2D array in order to figure out where the snake is.</p>

<p>It is better to use a <a href=""http://www.cplusplus.com/reference/deque/deque/"" rel=""nofollow noreferrer"">deque</a> or <a href=""https://en.wikipedia.org/wiki/Circular_buffer"" rel=""nofollow noreferrer"">circular queue</a> to implement the snake.</p>

<p>Then your snake's body segments are arranged conceptually as:</p>

<pre><code>C D E F G H I
</code></pre>

<p>To move the snake forward you unpaint the part of its body on the right (<code>I</code>) and add a part of the body on the left (<code>B</code>), to get:</p>

<pre><code>B C D E F G H
</code></pre>

<p>In your code you will replace the capital letters by the 2D coordinates of the snake's body segments.</p>
",4
53769116,53768281,1,"<p>@Richard is right that a circular queue is the best approach to keeping track of points, but you should make your life easier by starting from something like this:</p>

<pre><code>typedef struct
{
    int x; int y;
} 
Point;

typedef struct
{
    Point segments[MAX_LEN];
    int length;
}
Snake;
</code></pre>

<p>Because then the <code>draw</code> function is much simpler:</p>

<pre><code>void draw(Snake *snake)
{
    for (int i = 0; i &lt; snake-&gt;length; i++)
    {
        Point seg = snake-&gt;segments[i];
        board[seg.x][seg.y] = '*';
    }
}
</code></pre>

<p>Of course the main point is to have a head pointer which will iterate over the <code>points</code> array so that you can easily remove the tail and add head.</p>
",1
52935047,52934962,0,"<p>It might be a missing parenthesis or an extra parenthesis? Is that last paren needed?</p>

<pre><code>total+=square((arr[k][0])-(arr[k+1][0]));
</code></pre>
",0
56465763,56464964,3,"<pre><code>#define callx(...) call(EXTRA, __VA_ARGS__)
</code></pre>
",1
57001401,57001348,8,"<p>The major problem is this assignment:</p>

<pre><code>structlist_ptr[0] = &amp;new_struct;
</code></pre>

<p>With that you make <code>*structlist_ptr</code> (the usual way to use ""reference"" pointers) point to the <strong><em>local</em></strong> variable <code>new_struct</code>.</p>

<p>Once the function returns, the life-time of the local variables will end as they go out of scope. They will, in a manner of speaking, cease to exist. That leaves you with a stray and invalid pointer. Attempting to dereference it will lead to <em>undefined behavior</em>.</p>
",3
50075694,50075542,1,"<p>Macros are <em>replaced</em> in the source code by the preprocessor. So everywhere you use <code>MAXBOMBS</code> they will quite literally be replaced by <code>(n*m)/100</code>. That is of course not correct, unless you happen to have two variables in scope named <code>n</code> and <code>m</code>. But it will not be any <code>n</code> or <code>m</code> from the structure you want.</p>

<p>You could solve this two ways: Either a function-like macro</p>

<pre><code>#define MAXBOMBS(s) (((s).n * (s).m) / 100)
</code></pre>

<p>You can use it like</p>

<pre><code>battlefield f;
// Code that initializes the n and m members
some_function(MAXBOMBS(f));
</code></pre>

<p>Or you create an actual function which takes a <code>battlefield</code> structure as argument, and does the calculation needed and return the result:</p>

<pre><code>static inline int maxbombs(battlefield bf)
{
    return (bf.n * bf.m) / 100;
}
</code></pre>

<p>I recommend the solution using a function.</p>
",0
52704917,52703675,2,"<p>You're not properly terminating the <code>starstr</code> string - up until you reach size 23, there <em>just happens</em> to be a 0-valued byte immediately following the last element of <code>starstr</code>, so it looks like it's working properly up to that point.  </p>

<p>An n-character string needs to be stored in an array that's <em>at least</em> n+1 elements wide to account for the terminator, so you need to adjust your <code>calloc</code> call like so:</p>

<pre><code>char *starstr = calloc( n + 1, sizeof *starstr );
</code></pre>

<p>A couple of notes - first, the cast on <code>calloc</code> is unnecessary as of C89<sup>1</sup>, and can suppress a useful diagnostic if you're using a C89 compiler<sup>2</sup>.  Second, you can use <code>sizeof</code> on your target to get the right type size - the type of the <em>expression</em> <code>*starstr</code> is <code>char</code>, so <code>sizeof *starstr</code> is equivalent to <code>sizeof (char)</code>.  <code>sizeof (char)</code> is 1 by definition, so strictly speaking you can replace all that with the literal <code>1</code>, but this way if you ever decide to use a ""wide"" character type like <code>wchar_t</code>, you won't have to change the <code>calloc</code> call itself.  </p>

<p>Finally, as written this code has a fairly nasty memory leak - you're allocating a new array each time you call <code>nstars</code>, but you aren't deallocating it when you're done.  </p>

<p>Frankly, you shouldn't need to allocate a new array for each line - allocate the array <em>once</em> at the final size (+1 to account for the terminator), then add a new asterisk to the end:</p>

<pre><code>int main( void )
{
  ...
  char *starstr = calloc( n + 1, sizeof *starstr );

  /**
   * ALWAYS check the result of a malloc, calloc, or realloc call.
   */
  if ( !starstr )
  {
    fprintf( stderr, ""Could not allocate memory for string - exiting\n"" );
    exit( 0 );
  }

  for ( int i = 0; i &lt; n; i++ )    // Each time through the loop, add an
  {                                // asterisk to the end of starstr,
    starstr[i] = '*';              // then print starstr.  
    printf( ""%s\n"", starstr );
  }
  free( starstr );
  ...
}
</code></pre>

<p>Since <code>calloc</code> zeroes out the allocated memory, you don't need to explicitly write a string terminator after you add a new asterisk.  Had you used <code>malloc</code> instead, you'd need to write </p>

<pre><code>starstr[i] = '*';
starstr[i+1] = 0;
printf( ""%s\n"", starstr );
</code></pre>

<p><hr>
<sup></p>

<ol>
<li>It's required in C++, but if you're writing C++, you shouldn't be using <code>malloc</code>,<code>calloc</code>, or <code>realloc</code> unless you <em>really</em> need to get your hands dirty.  
<li>C89 allowed implicit <code>int</code> declarations, so if you forgot to include <code>stdlib.h</code> or didn't otherwise have a declaration for <code>calloc</code> in scope, the compiler would assume it returned an <code>int</code> and would issue a diagnostic if you tried to assign the result to a pointer.  However, if you cast the result to a pointer, then the compiler <em>wouldn't</em> issue the diagnostic, and you may have wound up with a runtime error.  C99 and later no longer allow implicit <code>int</code> declarations, so this particular issue isn't a problem anymore, but it's still better to leave the cast off.  It makes the code easier to read and easier to maintain.  
</ol>

<p></sup></p>
",1
58405347,58405280,3,"<p>For the last element in this list, you don't need to allocate any memory.  Just set it to NULL.  Also, be sure to add 1 to each of the <code>calloc</code> calls for the tokens to make room for the null terminating byte:</p>

<pre><code>// Allocate space
char **argv_list = calloc(4, sizeof(char*));
argv_list[0] = calloc(strlen(token1) + 1, sizeof(char));
argv_list[1] = calloc(strlen(token2) + 1, sizeof(char));
argv_list[2] = calloc(strlen(token3) + 1, sizeof(char));
argv_list[3] = NULL;
// Assign values
strcpy(argv_list[0], token1);
strcpy(argv_list[1], token2);
strcpy(argv_list[2], token3);
</code></pre>
",0
56302429,56301598,0,"<p>These headers are specific for the VMS operating system. They're guarded by <strong>both</strong> <code>#ifndef POSIX</code> and <code>#ifdef VMS</code>. They contain the <a href=""https://fossies.org/dox/freevms-0_3_15/ttdef_8h.html"" rel=""nofollow noreferrer"">terminal bps settings and alike</a> for <em>this operating system</em>. The files do not exist in Unixen or Windows, and are not needed there to compile uemacs.</p>
",0
57831681,57831615,2,"<p>You're missing some parentheses. Instead of writing <code>acos((b*b + c*c - a*a)/2*b*c)</code>,<br>
 write <code>acos((b*b + c*c - a*a)/(2*b*c))</code>. Otherwise, <code>b*c</code> ends up in the numerator of your fraction, not the denominator, and you try to take the arccos of an impossible number.</p>

<p>Generally speaking, when you have a problem like this, it helps to simplify and break down the code. If <code>acos</code> returns an unexpected value, then it must have an incorrect argument. So calculate the argument to <code>acos</code>, put it in a variable, print <em>that</em>, make sure it's correct, and then move on.</p>
",1
50614674,50614579,2,"<p>Compiler warnings reveal your problems.</p>

<pre><code>cc -Wall -Wshadow -Wwrite-strings -Wextra -Wconversion -std=c99 -pedantic -g   -c -o test.o test.c
test.c:7:21: warning: use of GNU empty initializer extension [-Wgnu-empty-initializer]
  char function[] = {};
                    ^
test.c:7:21: warning: zero size arrays are an extension [-Wzero-length-array]
test.c:18:15: warning: format specifies type 'char *' but the argument has type 'char (*)[0]'
      [-Wformat]
  scanf(""%s"", &amp;function);
         ~~   ^~~~~~~~~
</code></pre>

<p>These are all related. <code>char function[] = {}</code> is a <a href=""https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html"" rel=""nofollow noreferrer"">GNU extension to declare a 0 size array</a>. Then you try to put stuff into it, but it's size 0. So there's going to be an overflow.</p>

<p>Instead, you need to allocate some space to <code>function</code> and be sure to limit <code>scanf</code> to only that size, no larger.</p>

<pre><code>// {0} initializes all characters to 0.
// 1024 is a good size for a static input buffer.
char function[1024] = {0};

// one less because of the null byte
scanf(""%1023s"", &amp;function);
</code></pre>

<hr>

<p>The next warning...</p>

<pre><code>test.c:23:17: warning: incompatible pointer to integer conversion assigning to 'char' from 'char *';
      dereference with * [-Wint-conversion]
    word[cpt++] = pch;
                ^ ~~~
                  *
</code></pre>

<p>is because you're trying to put the string (<code>char *</code>) <code>pch</code> where a character (<code>char</code>) goes. Even if you're only reading a single character from <code>strtok</code> (which you cannot guarantee) it always returns a string. You want an array of strings (<code>char **</code>). It also helps to have descriptive variable names.</p>

<pre><code>char *word;                 // this was pch
char *words[nb_terms];      // this was word
</code></pre>

<p>After changing <code>pch</code> to <code>word</code>, and <code>word</code> to <code>words</code> in the rest of the code it all works.</p>

<pre><code>  size_t word_idx = 0;
  for(
      char *word = strtok(function,""+"");
      word != NULL;
      word = strtok(NULL, ""+"")
  ) {
      words[word_idx++] = word;
  }
</code></pre>

<p>I'll add <a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow noreferrer"">the usual caveats about <code>scanf</code></a>.</p>
",0
51032484,46766507,1,"<p>The C Standard uses the term ""object"" to describe at least three different concepts: a sequence of consecutively-addressed bytes which are exclusively allocated for a particular purpose, any combination of address and type which <em>could</em> be used to identify an allocation or portion thereof, regardless of whether it actually <em>is</em> used, or a combination of address and type that <em>have been</em> or <em>will be</em> used within some context to access storage or derive another object [same definition] that has been or will be used in such fashion.  The distinction between the these definitions didn't matter in the language described by K&amp;R's book <em>The C Programming Language</em>, but the Standard added rules which make it necessary to distinguish those meanings, without offering the terminology necessary to draw such distinctions.</p>

<p>When N1570 p6.5p7 of the C Standard says that an object may only have its stored value accessed via lvalues of certain types, it's unclear what exactly it means by ""object"".  If it was referring to the second sense of ""object"", almost any access to anything made with a non-character-type lvalue would invoke UB.  It would probably make more sense to use the third sense of ""object"" when interpreting that text, but such ""objects"" would have an active lifetime that differs from that of the underlying storage.</p>

<p>In your example, there are three allocations--<code>x</code>, <code>y</code>, and <code>z</code>.  If <code>sizeof (int)</code> is 4 and <code>sizeof z</code> is 8, then after <code>unsigned char *p = (unsigned char*)&amp;z.b</code>, there would exist an object of type <code>unsigned char</code> identified by <code>*p</code>, but the Standard is unclear whether the pointer conversion would have caused an <code>unsigned char</code> object to exist where none had previously, or merely merely yielded a pointer to an <code>unsigned char</code> object that was created when <code>z</code> was created and will exist as long as <code>z</code> does.</p>
",0
51246706,51246601,4,"<p>Precedence and evaluation order are different things. In the expression <code>(a*b) - (c+d)</code>, the compiler is free to evaluate <code>(c+d)</code> before <code>(a*b)</code>, even though multiplication has higher precedence than addition. But in the expression <code>a,b</code>, as well as the code <code>a;b</code>, the compiler is required to sequence the computation of <code>a</code> before the computation of <code>b</code>.</p>
",0
51351947,51351838,9,"<p>Let's look at a few examples.</p>

<p>With</p>

<pre><code>int *A;
</code></pre>

<p>you can use <code>*A</code> in an expression and it will have type <code>int</code>, so <code>A</code> must be a pointer to <code>int</code>.</p>

<p>With</p>

<pre><code>int A[100];
</code></pre>

<p>you can use <code>A[i]</code> in an expression and it will have type <code>int</code>, so <code>A</code> must be an array of <code>int</code>.</p>

<p>But you can construct more complex declarations:</p>

<p>With</p>

<pre><code>int (((A)));
</code></pre>

<p>you can use <code>(((A)))</code> in an expression and it will have type <code>int</code>, so <code>A</code> must be an <code>int</code>.</p>

<p>With</p>

<pre><code>int *A[100];
</code></pre>

<p>you can use <code>*A[i]</code> in an expression and it will have type <code>int</code>, so <code>A</code> ...</p>

<ul>
<li>must be an array ...</li>
<li>and its elements must be pointers to <code>int</code></li>
</ul>

<p>so <code>A</code> must be an array of pointers to <code>int</code>.</p>

<p>Similarly, with</p>

<pre><code>int (*A)[100];
</code></pre>

<p>you can use <code>(*A)[i]</code> in an expression and it will have type <code>int</code>, so <code>A</code> ...</p>

<ul>
<li>must be a pointer ...</li>
<li>and the thing it's pointing to must be an array of <code>int</code></li>
</ul>

<p>so <code>A</code> must be a pointer to an array of <code>int</code>.</p>

<hr>

<p>This is what is meant by ""<em>the syntax of the declaration for a variable mimics the syntax of expressions</em>"": When you declare a variable, you write a sort of mini-expression whose result type is given, and by reasoning backwards, you can deduce the type of the variable being declared.</p>
",9
48364492,48364473,0,"<p>If the value for <code>denominator</code> is not 2, 4, 8 it will end up at the comment below.</p>

<p>(assuming <code>numerator</code> is 1)</p>

<p>Put a return statement there!</p>

<pre><code>int duration(string fraction)
{
// X part of the fraction
int numerator = fraction[0];
// Y part of the fraction
int denominator = fraction[2];
// Checking for eigth note, quatar note and half note
if (numerator == 1)
{
    switch (denominator)
    {
        case 8:
        return 1;
        case 4:
        return 2;
        case 2:
        return 4;
   }
   // Got here and about to leave function without a return value
}
// Checking for dotted quater note
else
    return 3;
}
</code></pre>
",0
50307925,50307823,2,"<p>Adding a <code>*</code> before <code>b</code> will make the code work because then it expands to:</p>

<pre><code>char *a[] = {""I"", ""like"", ""to"", ""fight,""}, 
     *b[] = {""pinch"", ""and"", ""bight.""};
</code></pre>

<p>Of course having the <code>*</code> there will look utterly confusing when using the <code>string</code> macro (making it look like <code>b</code> is an array of <code>string</code> pointers), which I imagine is the point of the exercise: to show why using macros as a poor man's <code>typedef</code> leads to confusion.</p>
",0
51464323,51462297,2,"<p>The assignment <code>*p = 'a'</code> puts a value in the place where <code>p</code> points, but it does not assign a value to the pointer <code>p</code>.</p>

<p>When you use <code>*p = 'a'</code>, the pointer <code>p</code> must already have a value. It is your job as a programmer to assign it a value by allocating space with <code>malloc</code> or by setting <code>p</code> to point to an existing object that you wish to change, as with <code>p = &amp;x</code>, where <code>x</code> is defined earlier.</p>

<p>If you use <code>*p = 'a'</code> without previously assigning a behavior to <code>p</code>, then the behavior is not defined by the C standard. Common results of this include:</p>

<ul>
<li>The code acts as if <code>p</code> has an effectively random value, perhaps the value of some bits that were left over from previous work in the memory where the new <code>p</code> was created. Then <code>*p = 'a'</code> may write <code>'a'</code> into an unexpected place, and this can cause your program to malfunction in various ways. Or <code>p</code> may point to unallocated memory, and <code>*p = 'a'</code> will cause your program to crash.</li>
<li>During optimization, a compiler may recognize that <code>p</code> is uninitialized in some or all circumstances when <code>*p = 'a'</code> is executed. Due to the construction of modern optimizers, this may cause the compiler to eliminate the entire code path on which <code>*p = 'a'</code> appears, in the applicable circumstances. This can cause an entire section of your program to vanish.</li>
</ul>
",0
56193388,56193352,3,"<p>Remember in a C string you'll need the total length <strong>plus one more byte for the NUL terminator character</strong>. That means you need:</p>

<pre><code>char ccat[strlen(str1)+strlen(str2)+1];
</code></pre>

<p>Since you didn't allocate enough room for the final character you get random garbage there, like <code>@</code> or it could be anything. Or nothing.</p>

<p>Secondly you were preventing <code>strncpy</code> from applying the complete string, NUL terminator included. That resulted in an incomplete write. Proper termination is necessary, so the quick fix is <code>strlen(str1)+1</code>, but you should be describing the <em>length of the receiving buffer</em> to prevent overflows, not the length of the thing you're writing.</p>

<p>You'll also either need to add a NUL terminator manually, or change how you add in the strings. This approach might be better:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    char *str1 = ""foo"";
    char *str2 = ""bar"";

    char ccat[strlen(str1)+strlen(str2)+1];

    // The length limit on the first one is the length of the buffer - 1
    strncpy(ccat, str1, sizeof(ccat)-1);
    // The length limit on the second is that minus the length of what's in there
    strncat(ccat, str2, sizeof(ccat)-strlen(ccat)-1);

    puts(str1);
    puts(str2);
    puts(ccat);

    return 0;
}
</code></pre>

<p>It's worth noting that your compiler may warn (<code>-Wall</code>) about common overflow problems if you mess up, like this example:</p>

<pre><code>the value of the size argument in 'strncat' is too large, might lead to a buffer overflow [-Wstrncat-size]
</code></pre>
",1
56193589,56193352,-3,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{

    char str1[] = ""foo"";
    char str2[] = ""bar"";


    char ccat[strlen(str1)+strlen(str2)];

    strncpy(&amp;ccat[0], str1, strlen(str1));
    strncpy(&amp;ccat[strlen(str1)], str2, strlen(str2));
    ccat[strlen(str1)+strlen(str2)]='\0';

    puts(str1);
    puts(str2);
    puts(ccat);
    printf(""\n%s"", ccat);
}
</code></pre>
",3
52323686,52323678,6,"<p>Either use <code>calloc()</code> rather than <code>malloc()</code> in the first instance to allocate the memory already zeroed, use  or <code>memset()</code> after the allocation:</p>

<pre><code> int * p = calloc(m, sizeof(int));
</code></pre>

<p>OR</p>

<pre><code>int * p = malloc(m * sizeof(int));
memset(p, 0, m * sizeof(int));
</code></pre>

<p>Obviously, the former is preferable.</p>
",11
49499167,49499068,2,"<p>Statements of your program are executed in the order pre-defined by C standard. This includes the computation of the <code>while</code> condition of the <code>do</code>/<code>while</code> loop.</p>

<p>The loop checks the condition upon reaching the end of loop's body. This includes execution of all <code>if</code> statements inside the loop, along with their <code>else</code> branches. Since you have no special handling for <code>'c'</code> <em>inside</em> your loop, <code>if (answer != '\n')</code> branch gets executed, and gives the printout that you see.</p>

<p>You can fix this by using a ""forever"" loop, and handling <code>'c'</code> input inside its body:</p>

<pre><code>for (;;) {
    answer = getchar();
    if (answer == 'c')  {
        break;
    }
    ... // The rest of your code goes here
}
</code></pre>
",3
48453207,48453090,4,"<p>You can either free the memory in <code>evenOdd</code> after the <code>printArray</code> or return the pointer, so that the calling function can free it:</p>

<pre><code>int *evenOdd(int asize){
    int* array = malloc(asize * sizeof *array);
    if(array == NULL)
        return 0;

    int position;
    // loop that goes through every position in the array and decides if a 0 or 
    // 1 is assigned.
    for(position = 0; position &lt; asize;position++){
       if(position%2 == 0){
        array[position] = 0;
       }else{
        array[position] = 1;
       }
    }
    printArray(array,asize);

    return array;
}

int main(void) {
    int *array = evenOdd(10);
    if(array == NULL)
    {
        fprintf(stderr, ""not enough memory\n"");
        return 1;
    }

    free(array);
    return 0;
}
</code></pre>

<blockquote>
  <p>I understand how the allocation of <code>malloc</code> works and I can free the variable inside the function</p>
</blockquote>

<p>Note that you don't free variables, you free the memory pointed to by a pointer.
That's a fine distinction, because of this you can allocate memory in a function
and free it in a different function, as long as your program ""remembers"" the
address that <code>malloc</code>/<code>realloc</code>/<code>calloc</code> returned. You achieve this by returning the
allocated pointer like in the code above. Another way is by passing a double
pointer:</p>

<pre><code>void bar(int **arr, size_t size)
{
    if(arr == NULL)
        return;

    *arr = malloc(size * sizeof **arr);

    if(arr == NULL)
        return;

    size_t i;
    for(i = 0; i &lt; size; ++i)
        (*arr)[i] = i % 2;
}

void foo()
{

    int *arr = NULL;
    bar(&amp;arr, 10);

    if(arr == NULL)
    {
        fprintf(stderr, ""not enough memory\n"");
        return;
    }

    free(arr);
}
</code></pre>
",2
57965996,57965854,1,"<p>When using buffers in C that contain arbitrary binary data you need to store two length fields: the capacity of the buffer as-allocated, and the amount of data currently stored in the buffer.</p>

<p>(For comparison to C#/.NET and Java, this is like how <code>List&lt;T&gt;</code> (<code>ArrayList</code> in Java) has both an internal <code>T[].Length</code> and a separate <code>Count</code> value).</p>

<p>I've rewritten your code to show how I would do it. Note that:</p>

<ul>
<li>The <code>Buffer</code> struct stores both <code>capacity</code> and <code>length</code>.</li>
<li>The code uses <code>assert()</code> to validate parameters and verify that allocations succeeded. This is only for demonstration purposes because <code>assert</code> is removed from the program if <code>NDEBUG</code> is defiend, whereas memory allocations should always be verified.</li>
<li>I separated the logic for appending (<code>append_buffer</code>) from the logic for reallocating the buffer (<code>expand_buffer</code>).</li>
</ul>

<p>Like so:</p>

<pre><code>#undef NDEBUG // So `assert` is always compiled.

struct Buffer {
    char*  data;
    size_t capacity; // Size of the actual allocated space
    size_t length;   // Amount of space currently used
};

struct Buffer* new_buffer( size_t initialCapacity ) {
    struct Buffer* info = malloc( sizeof(Buffer) ); // Allocate space for the metadata
    assert( info ); // Always ensure allocation succeeded!
    info-&gt;data = calloc( initialCapacity, sizeof(char) );
    assert( info-&gt;data );
    info-&gt;capacity = initialCapacity;
    info-&gt;length   = 0;
    return info;
}

void append_buffer( struct Buffer* buffer, char* data, size_t dataLength ) {
    assert( buffer ); // Parameter argument validation
    assert( data );
    if( dataLength == 0 ) return;

    size_t remainingCapacity = buffer-&gt;capacity - buffer-&gt;length;
    if( remainingCapacity &lt; dataLength ) {
        size_t desiredCapacity = buffer-&gt;capacity + dataLength; // You might want to add a growth factor here
        expand_buffer( buffer, desiredCapacity );
    }

    char* start = buffer-&gt;data + buffer-&gt;length;
    memcpy( start, data, dataLength );
    buffer-&gt;length += dataLength;
}

void expand_buffer( struct Buffer* buffer, size_t desiredCapacity ) {
    assert( buffer );
    assert( buffer-&gt;data );
    char* newData = realloc( buffer-&gt;data, desiredCapacity );
    assert( newData );
    buffer-&gt;data     = newData;
    buffer-&gt;capacity = desiredCapacity;
    // buffer-&gt;length remains unchanged
}

void destroy_buffer( struct Buffer* buffer ) {
    assert( buffer );

    if( buffer-&gt; data ) {
        free( buffer-&gt;data );
        buffer-&gt;data = NULL;
    }

    free( buffer );
}
</code></pre>
",2
48816806,48816561,1,"<p>Two adjustments are needed for you <code>filecopy</code> function:</p>

<ul>
<li>You need to allocate space for your buffer. Right now you are using an uninitialized pointer and passing it to <code>read</code> which is <strong>undefined behavior</strong>.</li>
<li>You need to save the return value of <code>read</code> and pass the value to <code>write</code></li>
</ul>

<p>The end result should look something like this.</p>

<pre><code>void filecopy(int infd, int outfd) {
    char buf[1024];
    size_t bytes_read;
    while((bytes_read = read(infd, buf, sizeof buf)) != -1) 
        write(outfd, buf, bytes_read);
}
</code></pre>
",0
48816623,48816561,5,"<p><code>char *buf;</code> is an uninitialized pointer, writing data through that pointer is
undefined behaviour.</p>

<pre><code>char buf[1024];

ssize_t len;

while((len = read(infd, buf, sizeof buf)) != -1)
    write(outfd, buf, len);
</code></pre>

<p>would be correct. </p>

<p>Note that <code>char *buf[1];</code> is a array (of dimension 1) of <code>pointers</code>, that's
different to an array of <code>char</code>s. Using that you would need to do
<code>read(infd, buf[0], somelength)</code>, but here again <code>buf[0]</code> would be an
uninitialized pointer and you would have the same problem. That's why declaring
an <code>char</code> array of say 1024 (you can choose another size) is the correct thing
to do.</p>

<p>Also in main use <code>strlen(tmp)</code> and not <code>sizeof(tmp)</code></p>

<pre><code>char tmp[30];
sprintf(tmp, ""%s: can't open %s\0"", prog, *argv);
write(STDOUT_FILENO, &amp;tmp, strlen(tmp));
</code></pre>

<p><code>strlen</code> returns you the length of the string which might be smaller than 29 and
if you use <code>sizeof(tmp)</code> you might be writing garbage past the end of the
string. Note also that  0 may be too small for the whole string, I'd use a
larger number or construct the string using <code>snprintf</code>:</p>

<pre><code>snprintf(tmp, sizeof tmp, ""%s: can't open %s\0"", prog, *argv);
</code></pre>

<p>would be more safe.</p>

<p>Last thing:</p>

<pre><code>while(--argc &gt; 0)
    if((fd = open(*++argv, O_RDONLY, ""rb"")) == -1) {
        ...
</code></pre>

<p>While this is correct, I feel that this code is awkward and hard to read. It
would be so much simpler to read if you did:</p>

<pre><code>for(int i = 1; i &lt; argc; ++i)
    if((fd = open(argv[i], O_RDONLY, ""rb"")) == -1) {
        ...
</code></pre>

<p>I've never seen <code>open</code> being called with <code>""rb""</code> as the mode. My man page says:</p>

<blockquote>
  <p><em>man 2 open</em></p>

<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int open(const char *pathname, int flags, mode_t mode);
</code></pre>
  
  <p>[...]</p>
  
  <p>The mode argument specifies the file mode bits be applied when a new file is created.  This argument must be supplied when
  <code>O_CREAT</code> or <code>O_TMPFILE</code> is specified in <code>flags</code>; if neither <code>O_CREAT</code> nor <code>O_TMPFILE</code> is specified, then mode is ignored.
  The effective mode is modified by the process's <code>umask</code> in the usual way: in the absence of a default <code>ACL</code>, the mode of the created file is
  <code>(mode &amp; ~umask)</code>.  Note that this mode applies only to future accesses of the newly created file; the <code>open()</code> call that creates a
  read-only file may well return a read/write file descriptor.</p>
  
  <p>The following symbolic constants are provided for mode:</p>
  
  <p><code>S_IRWXU</code>  <code>00700</code> user (file owner) has read, write, and execute permission</p>
  
  <p><code>S_IRUSR</code>  <code>00400</code> user has read permission</p>
  
  <p><code>S_IWUSR</code>  <code>00200</code> user has write permission</p>
  
  <p><code>S_IXUSR</code>  <code>00100</code> user has execute permission</p>
  
  <p>[...]</p>
</blockquote>

<p>As you are neither using <code>O_CREAT</code> nor <code>O_TMPFILE</code>, this parameter will be
ignore and you are passing a <code>char*</code> as a <code>mode_t</code> which is integer in nature.
Hence your call should be:</p>

<pre><code>    if((fd = open(argv[i], O_RDONLY, 0)) == -1) {
        ...
</code></pre>
",1
48917972,48917949,1,"<p>Definitions of <code>typedef</code> and prototypes of functions can occur as many times as you want. For example:</p>

<pre><code>typedef int lala;
typedef int lala;

void somePrototype();
void somePrototype();

int main() {
    return 0;
}
</code></pre>

<p>will compile just fine: <a href=""https://ideone.com/4EjfaR"" rel=""nofollow noreferrer"">https://ideone.com/4EjfaR</a></p>

<p>Try adding the definition of a function to a header file. You will see then that you get a redefinition error and will require a header guard.</p>
",7
50590943,50590883,3,"<p>Set <code>acc</code> to point to the address of that substructure:</p>

<pre><code>access1 *acc = &amp;(base2-&gt;base1);
</code></pre>

<p>You also never allocated space for <code>base2</code> to point to, it should be:</p>

<pre><code>access2 *base2 = malloc(sizeof access2);
</code></pre>
",0
59459196,59459100,2,"<p>You are never allocating memory to store the actual <code>guest</code> data structure.</p>

<p>The <code>guest_list</code> declaration allocates an array that can hold the given number of pointers.  It does not allocate the memory that the pointers will reference.</p>
",0
54625618,54625547,3,"<p>In union the space allocated is the maximum of the bytes needed for each field in the union itself. So for bio (assuming <code>sizeof(int)=4</code>):</p>

<pre><code>sizeof(bio) = max(sizeof(int), sizeof(char)) = sizeof(4, 1) = 4
</code></pre>

<p>This is because all union fields share the same memory space, which starts at the beginning of the union itself.</p>

<pre><code>bio.age = 24
bio.name = 'a' //a will use the first byte in the union, just like the first byte of the integer
</code></pre>

<p>You can check it by printing pointers as well.</p>
",2
54371285,54371097,0,"<p><code>scanf("" %[^\n]%*c"", answer);</code> is trying to write a string to an uninitialized, unallocated (and more importantly) <em>incomplete</em> pointer of type <code>void *</code>. </p>

<p>You need to declare it as a complete type (i.e. <code>char *</code>) and allocate memory for it, either on the stack by explicitly declaring array size <code>[LEN]</code> or dynamically with <code>malloc(LEN)</code> and later <code>free</code> it.</p>
",2
51794713,51791590,1,"<p>As I noted in a <a href=""https://stackoverflow.com/questions/51791590/speed-difference-for-bitwise-operations#comment90546653_51791590"">comment</a>, you need to be careful with the benchmarking to ensure that an aggressive optimizer cannot optimize the function calls away.</p>

<p>An aggressive optimizer could remove the test loops because you pass the same values to the Hamming distance functions on each iteration and ignore the returned value ¡ª which would leave you with nothing to measure.</p>

<p>If it were my testing, I'd have a test function containing the timing and function calls. The function call would be inside two loops, and I'd pass the two loop indexes as arguments to the function, and sum the return values, and print the sum at the end to help ensure that the functions produce the same results. I'd also make it run for seconds, not milliseconds.</p>

<p>Here's my code.  It uses timing code available in my <a href=""https://github.com/jleffler/soq"" rel=""nofollow noreferrer"">SOQ</a> (Stack Overflow Questions) repository on GitHub as files <code>timer.c</code> and <code>timer.h</code> in the <a href=""https://github.com/jleffler/soq/tree/master/src/libsoq"" rel=""nofollow noreferrer"">src/libsoq</a> sub-directory.</p>

<pre><code>#include ""timer.h""
#include &lt;stdio.h&gt;

#define L1_MIN 0
#define L1_MAX 10240
#define L2_MIN 0
#define L2_MAX 10240

static int hamm_fast(int x, int y)
{
    int count = 0;
    for (int i = 0; i &lt; 32; ++i)
    {
        count += (x &amp; 1) ^ (y &amp; 1);
        x &gt;&gt;= 1;
        y &gt;&gt;= 1;
    }
    return count;
}

static int hamm_slow(int x, int y)
{
    int n = x ^ y;
    int count = 0;
    for (int i = 0; i &lt; 32; ++i)
    {
        count += n &amp; 1;
        n &gt;&gt;= 1;
    }
    return count;
}

static void tester(const char *tag, int (*function)(int x, int y))
{
    Clock t;
    clk_init(&amp;t);

    clk_start(&amp;t);
    int sum = 0;
    for (int i = L1_MIN; i &lt; L1_MAX; i++)
    {
        for (int j = L2_MIN; j &lt; L2_MAX; j++)
            sum += (*function)(i, j);
    }
    clk_stop(&amp;t);

    char buffer[32];
    int iterations = (L1_MAX - L1_MIN) * (L2_MAX - L2_MIN);
    printf(""%s sum = %d (%d iterations) %s\n"", tag, sum, iterations,
            clk_elapsed_us(&amp;t, buffer, sizeof(buffer)));
}

int main(void)
{
    for (int i = 0; i &lt; 10; i++)
    {
        tester(""Fast"", hamm_fast);
        tester(""Slow"", hamm_slow);
    }
    return 0;
}
</code></pre>

<p>The output I got on one run was:</p>

<pre><code>Fast sum = 710934528 (104857600 iterations) 2.461100
Slow sum = 710934528 (104857600 iterations) 1.181584
Fast sum = 710934528 (104857600 iterations) 2.480401
Slow sum = 710934528 (104857600 iterations) 1.182961
Fast sum = 710934528 (104857600 iterations) 2.466685
Slow sum = 710934528 (104857600 iterations) 1.197394
Fast sum = 710934528 (104857600 iterations) 2.435806
Slow sum = 710934528 (104857600 iterations) 1.175533
Fast sum = 710934528 (104857600 iterations) 2.384162
Slow sum = 710934528 (104857600 iterations) 1.184161
Fast sum = 710934528 (104857600 iterations) 2.376042
Slow sum = 710934528 (104857600 iterations) 1.191555
Fast sum = 710934528 (104857600 iterations) 2.389027
Slow sum = 710934528 (104857600 iterations) 1.169186
Fast sum = 710934528 (104857600 iterations) 2.393707
Slow sum = 710934528 (104857600 iterations) 1.209600
Fast sum = 710934528 (104857600 iterations) 2.423526
Slow sum = 710934528 (104857600 iterations) 1.204585
Fast sum = 710934528 (104857600 iterations) 2.515968
Slow sum = 710934528 (104857600 iterations) 1.196783
</code></pre>

<p>As you can see, the 'fast' code is about twice as slow as the 'slow' code.  That's primarily because the 'fast' code is doing many more operations per loop than the 'slow' code.  The 'fast' code does 2 <code>&amp;</code> operations, 1 <code>^</code> operation, and 2 <code>&gt;&gt;=</code> operations compared to 1 <code>&amp;</code> and 1 <code>&gt;&gt;=</code> in the 'slow' code. But the results are apparently the same; that's the good news.  The functions are equivalent in terms of result, but not in terms of speed.</p>

<p>Compilation on a MacBook Pro running macOS 10.13.6 High Sierra, using GCC 8.2.0.</p>

<p>Compilation command line (source file <code>spot79.c</code>):</p>

<pre><code>$ gcc -O3 -g -I./inc -std=c11 -Wall -Wextra -Werror -Wmissing-prototypes \
&gt;     -Wstrict-prototypes spot79.c -o spot79 -L./lib -lsoq
$
</code></pre>

<p>The <code>timer.h</code> header was in the <code>./inc</code> directory and the <code>soq</code> library was in <code>./lib</code> ¡ª that's simply my build setup.</p>
",0
58047964,58046959,0,"<p><code>b[bSize] = a;</code> stores the value of <code>a</code> in <code>b[bSize]</code>. <code>a</code> is a pointer to the first element of the array <code>A</code> defined in <code>main</code>. So you are not storing individual strings, just a pointer to <code>A</code>, and that pointer never changes.</p>

<p>To use this algorithm, you must copy each string. That requires changes to how <code>b</code> is defined and how strings are compared. (You cannot compare strings with <code>==</code>.)</p>

<p>(There is however, a much better algorithm for this task that does not require generating all permutations.)</p>
",0
51901224,51901114,2,"<p>The buffer contains the digit and the CR (two characters), but you are writing only a single character. You could use <code>strlen()</code> to determine the length of the resulting string, but <code>snprintf()</code> already returns that, so it is more efficient to use that value:</p>

<pre><code>    int len = snprintf( buffer, sizeof(buffer), ""%d\r"", i ) ;
    write( STDOUT_FILENO, buffer, len ) ;
</code></pre>

<p>or </p>

<pre><code>    write( STDOUT_FILENO, buffer, 
           snprintf( buffer, sizeof(buffer), ""%d\r"", i ) ) ;
</code></pre>
",0
48716339,48716319,1,"<p>Your <code>copy</code> function is wrong, <code>sizeof(origin)</code> returns the number of bytes needed
to store a pointer in memory, not the length of the string. So you've allocated
the incorrect number of bytes and if the length of the string is longer than
<code>sizeof(origin) - 1</code>, then you would overflow the buffer, which leads to
undefined behaviour which would explain the segfault.</p>

<p>It should be</p>

<pre><code>char *copy(const char *origin)
{
    char *str = NULL;
    str = malloc(strlen(origin) + 1);
    if(str == NULL)
        return NULL;
    strcpy(str, origin);
    return str;
}
</code></pre>

<p>Note that I've removed the cast of <code>malloc</code>, which is not needed in C. If you
need it because this is a C++ program, the use <code>new</code> instead of <code>malloc</code>.</p>

<p>And you should always check if <code>malloc</code> returns <code>NULL</code> before accessing the
memory.</p>
",4
58071744,58071708,1,"<p>Use the following algorithm:</p>

<ol>
<li>Fill the buffer.</li>
<li>Check the buffer for the first newline character.</li>
<li>If there is no newline character, stop, you are done.</li>
<li>Allocate a new buffer the size of the entry whose end you just found.</li>
<li>Copy the entry whose end you found in step 2 into the budffer.</li>
<li>Move any characters left in the buffer to the beginning of the buffer.</li>
<li>Go to step 1.</li>
</ol>

<p>This is not spectacularly efficient, but it will get the job done.</p>
",1
58072578,58071708,0,"<p>Possible alternatives:</p>

<p>a) When you remove anything from the buffer (e.g. from the start of the buffer to the middle), shift any remaining data (e.g. shift the data from the middle to the end back to the start) and then fill the buffer again (from the new middle to the end). Note: This can't work if one line of text can be larger than the buffer.</p>

<p>b1) Make the buffer larger than the file. That way you can just replace newline characters with string terminators (and maybe discard any ""end of line white space"" and skip empty lines, etc); and avoid a whole pile of ""<code>malloc()</code> overhead"" because you don't need to allocate memory for each individual string (because you're re-using the memory you already allocated). Note: This can't work if the file can be larger than available virtual memory.</p>

<p>b2) Use <code>mmap()</code> to memory map the file; then replace newline characters with string terminators, etc. Note: This can't work if the file can be larger than available virtual memory.</p>

<p>c1) Stop using awful ""plain text"" file formats and just store strings (with string terminators and without any newline characters) in the file to start with. This allows you to <code>mmap()</code> without modifying the memory after. Note: This can't work if the file can be larger than available virtual memory.</p>

<p>c2) Stop using awful ""plain text"" file formats, store strings in the file, but also have a list/array/index of ""offset in the file for start of string"" at the start of the file. This allows you to <code>mmap()</code> without modifying the memory, and also avoids the need to scan through the entire file searching for the end of each string/start of the next string. Note: This can't work if the file can be larger than available virtual memory.</p>

<p>If the file's data is already cached in RAM by the operating system; ""option c2)"" might be 1000 times faster than ""option a)"". </p>

<p>e) Combine ""option b2)"" with ""option c2)"". When your program starts compare the time stamps for ""input.txt"" and ""input.bin"" and if ""input.txt"" is newer use ""option b2)"", generate an index, and save it as ""input.bin"" for next time; otherwise (if ""input.bin"" is newer) use ""option c2)"".</p>
",0
54410115,54408929,0,"<p>Alternative approach:</p>

<p><a href=""https://clc-wiki.net/wiki/strspn"" rel=""nofollow noreferrer""><code>strspn()</code></a>, <a href=""https://clc-wiki.net/wiki/strcspn"" rel=""nofollow noreferrer""><code>strcspn()</code></a> are the best tools here.  <a href=""https://stackoverflow.com/questions/54408929/how-can-we-get-vowel-substring-from-a-given-string/54410115#comment95631042_54409246"">@Gem Taylor</a></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {
  char str[] = ""aeixae"";
  const char *s = str;
  while (*(s += strcspn(s, ""aeiou"")) != '\0') { // skip letters that are not aeiou
    size_t len = strspn(s, ""aeiou"");            // find length made up of aeiou
    printf(""&lt;%.*s&gt;\n"", (int) len, s);           // print sub string
    s += len;
  }
}
</code></pre>

<p>Output</p>

<pre><code>&lt;aei&gt;
&lt;ae&gt;
</code></pre>
",4
54096051,54095989,4,"<p>This happens because you put definitions into header file. Each <em>translation unit</em> in which the header is included produces a separate definition for the linker, which results in a duplicate definition error.</p>

<p>Definitions belong in an implementation file. Only declarations must go into the header; implementations must go into a separate file:</p>

<p>inventory.h</p>

<pre><code>extern const char *jpeg_perf_inputs[];
extern const char *zip_large_input [];

extern size_t num_jpeg_perf_inputs;
extern size_t num_zip_large_inputs;
</code></pre>

<p>inventory.c</p>

<pre><code>#include""inventory.h""

const char *jpeg_perf_inputs[] = {
    ""perf_11k_img_jpg"",
    ""Sample_jpg_image_1mb_jpg""};

const char *zip_large_input [] = {
    ""a.zip"",
    ""b.zip""
};
size_t num_jpeg_perf_inputs = sizeof(jpeg_perf_inputs) / sizeof(jpeg_perf_inputs[0]);
size_t num_zip_large_inputs = sizeof(zip_large_input) / sizeof(zip_large_input[0]);
</code></pre>

<p>The header is sufficient to compile the dependencies, while the implementation produces a single instance of definition for each object.</p>

<p>Note the use of <code>size_t</code> in place of <code>int32_t</code>.</p>
",0
54679168,54679080,5,"<p>Your arrays are function scoped, on the stack. Writing outside the bounds of <em>any</em> array is undefined behavior, and will do all sorts of terrible things in many cases, but a segfault is rarely the direct result of writing only a little outside the bounds of an array on the stack. After all, the stack is all writable memory, it's just not logically part of the array (so you might be overwriting other local variables, function return addresses, registers spilled to the stack, etc.).</p>

<p>Point is, the code is wrong, but segfaults usually don't happen unless you're trying to write to the <code>NULL</code> pointer, significantly outside allocated memory, or you just get ""lucky"" and happen to overwrite a buffer near the end of an allocated page (and therefore write into an unallocated page).</p>
",0
54679194,54679080,5,"<p>When you write past the bounds of an object, you invoke <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.  This means you can't predict the behavior of the program.  It may crash, it may output strange results, or it may appear to work properly.</p>

<p>Also, how undefined behavior manifests can change by making seemingly unrelated changes, such as an extra <code>printf</code> for debugging or adding an unused local variable.  It can also change by using different optimization settings or a different compiler.  For example, when I ran your code it detected stack smashing and crashed with SIGABORT.</p>

<p>Just because a crash <strong>could</strong> happen doesn't mean it <strong>will</strong>.</p>
",1
49695054,49694986,-1,"<p><strong>Easy Fix:</strong></p>

<pre><code>int main()
{

double length, width, peri, area;

////////////////////////////////////
// Gather your inputs
////////////////////////////////////
printf(""Enter the length of the rectangle in centimeters: "");
scanf(""%lf"", &amp;length);
printf(""\nEnter the width of the rectangle in centimeters: "");
scanf(""%lf"", &amp;width);

////////////////////////////////////
// Now that you have a length and width, do your calculations
////////////////////////////////////
peri = (length*2) + (width*2);
area = length*width;

printf(""The perimeter of the rectangle is %lf cm.
\nThe area of the rectangle is %lf cm."", circ, area);


return 0;
}
</code></pre>
",2
51004128,51003956,1,"<p>Basically, you have two choices -- synchronous or asynchronous -- and both have their advantages and disadvantages.</p>

<p>For synchronous, you need either delimeters or a length field embedded in the record (or fixed length records, but that is pretty inflexible).  This works best for synchronous protocols like synchronous rpc or simplex client-server interactions where only one side talks at a time while the other side waits.  For ASCII/text based protocols, it is common to use a control-character delimiter like NL/EOL or NUL or CTX to mark the end of messages.  Binary protocols more commonly use an embedded length field -- the receiver first reads the length and then reads the full amount of (expected) data.</p>

<p>For asynchronous, you use non-blocking mode.  It IS possible to use non-blocking mode with stdio streams, it just requires some care.  out-of-data conditions show up to stdio like error conditions, so you need to use <code>ferror</code> and <code>clearerr</code> on the <code>FILE *</code> as appropriate.</p>

<p>It's possible for both to be used -- for example in client-server interactions, the clients may use synchronous (they send a request and wait for a reply) while the server uses asynchronous (to be be robust in the presence of misbehaving clients).</p>
",1
51005406,51003956,0,"<p>The <code>read</code> api on Linux or the <code>ReadFile</code> Api on windows will immediately return and not wait for the specified number of bytes to fill the buffer (when reading a pipe or socket). Read then reurns the number of bytes read.</p>

<p>This means, when reading from a pipe, you set a buffersize, read as much as returned and the process it. You then read the next bit. The only time you are blocked is if there is no data available at all.</p>

<p>This differs from <code>fread</code> which only returns once the desired number of bytes are returned or the stream determines doing so is impossible (like eof).</p>
",1
52010143,46442411,5,"<p>It can be <a href=""https://en.wikipedia.org/wiki/Integer_(computer_science)#Common_integral_data_types"" rel=""noreferrer""><code>18446744073709551615</code></a>.</p>

<pre><code>18,446,744,073,709,551,615
q5 q4  t   b   m   t   h
</code></pre>
",0
50770682,46442411,5,"<p>Your assumption for the maximum size of signed and unsigned integers is correct. The actual values are 9223372036854775807 for signed and 18446744073709551615 for unsigned.</p>

<p>Detecting overflow for unsigned addition is rather simple - if the result is less than either operand there was an overflow.</p>

<p>Subtraction is similar, if the result is greater than the first operand then you had overflow.</p>

<p>Multiplication is tough, I don't know a simple rule for that one.</p>

<p>Overflow is impossible for division unless you divide by zero.</p>
",0
59562870,59562159,1,"<p>Short answer: no.</p>

<p><code>strlen</code> expects an argument of type <code>char *</code>, which points to the first character of a <em>string</em>, which is a sequence of character values including a zero-valued <em>terminator</em>.  <code>strlen</code> returns the number of characters before the terminator:</p>

<pre><code>/**
 * A naive implementation of strlen.  Actual implementations
 * are a little more clever.
 */
size_t strlen( const char *str )
{
  size_t count = 0;
  while( str[count] )
   count++; 
 return count;
}
</code></pre>

<p>The important thing to remember is that <code>strlen</code> returns the length of the string, not the size of the array containing the string.  If you have something like</p>

<pre><code>char foo[1024] = ¡°bar¡±;
</code></pre>

<p>the <code>strlen( foo );</code> returns 3. </p>

<p>If you tried to pass an integer or floating point array to <code>strlen</code> the compiler would yell at you because of the wrong argument type.  You could work around this by casting the argument to <code>char *</code>, but you would still likely get a wrong answer, not only because integer and float types are multiple <code>char</code>s wide, but also because such a value may have an embedded zero-valued byte.  For example, the integer value 16 is represented as the bytes <code>0x00, 0x00, 0x00, 0x10</code>.  If that¡¯s the first element of your integer array, then <code>strlen</code> would return 0 on a big-endian platform and 1 on a little-endian platform.</p>

<p>If you defined the array, then you know how big it is. If you¡¯re writing a function that receives an array argument, then you must either also receive the size as a separate argument, or you must rely on the presence of a sentinel value in the array.</p>
",0
59562312,59562159,3,"<p><code>strlen</code> is effectively an optimized version of the following:</p>

<pre><code>size_t len = 0;
const char *p = s;
while (!*p) {
   ++len;
   ++p;
}
</code></pre>

<p>You can easily adapt that.</p>

<pre><code>size_t len = 0;
const float *p = s;
while (*p != 0.0) {
   ++len;
   ++p;
}
</code></pre>

<p>Of course, that means you need a sentinel value just like you had for the string.</p>

<pre><code>float temps[] = { 72.5, 73.4, 74.7, 75.2, 0.0 };
</code></pre>

<p>While you can use a value other than <code>0.0</code> as your sentinel value, using a sentinel value might not be desirable, so you might not really want to take the same approach as one does for strings.</p>

<p>For an array (as opposed to a pointer), you can use the following to determine the number of elements in the array:</p>

<pre><code>sizeof(a)/sizeof(*a)
</code></pre>

<p>That means you can use the following to determine the number of elements in <code>temps</code>:</p>

<pre><code>sizeof(temps)/sizeof(*temps)
</code></pre>
",0
50087891,50087851,0,"<p>For starters, this</p>

<pre><code>  moves[i] = (int**)malloc(sizeof(int)*N);
</code></pre>

<p>should be</p>

<pre><code>  moves[i] = (int**)malloc(sizeof(int*)*N);
</code></pre>

<p>or even better, because less error prone</p>

<pre><code>  moves[i] = (int**)malloc(N * sizeof *(moves[i]));
</code></pre>

<p>and if it really is C (and not C++) just only:</p>

<pre><code>  moves[i] = malloc(N * sizeof *(moves[i]));
</code></pre>
",1
50816906,50808782,4,"<p>For arrays to be first-class objects, you would expect at least to be able to assign them. But that requires knowledge of the size, and the C type system is not powerful enough to attach sizes to any types. C++ could do it, but doesn't due to legacy concerns¡ªit has <em>references</em> to arrays of particular size (<code>typedef char (&amp;some_chars)[32]</code>), but plain arrays are still implicitly converted to pointers as in C. C++ has std::array instead, which is basically the aforementioned array-within-struct plus some syntactic sugar.</p>
",11
55755042,55754938,5,"<p>In C, <code>1e6</code> has type <code>double</code> and its value is 1 times 10 raised to the 6th power.  It is equivalent to <code>1000000.0</code>.</p>

<p>Do not get fooled by the other answers: <code>1e6</code> does <em>not</em> mean the same thing as <code>1000000</code> in C, because <code>1e6</code> has type <code>double</code> while <code>1000000</code> will have some integer type.  There are big differences in behavior between floating-point types like <code>double</code> and integers types.</p>

<p>The syntax for writing numbers like <code>1e6</code> is defined in the ""Floating constants"" section of the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf"" rel=""noreferrer"">C11 specification</a> (and earlier versions too).  It's kind of like <a href=""https://en.wikipedia.org/wiki/Scientific_notation"" rel=""noreferrer"">scientific notation</a>.</p>
",1
55754945,55754938,1,"<p>It's <code>1e6</code></p>

<p>Scientific notation for <code>Math.pow(10, 6) == 1000000</code></p>

<p>/* yes, you can do that with pretty much <strong>any</strong> standard programming language, including C */</p>
",0
55659431,55657620,1,"<p>I think what you want is:</p>

<p><code>int *r = (int *) malloc(sizeof(int) * nproc);// allocating for nproc integers</code></p>
",1
52798841,52798822,4,"<blockquote>
  <p>Or will there be a single slot for that variable that is recycled each time the function is called?</p>
</blockquote>

<p>There is a single ""slot"" in the program's memory space for the variable. It's used every time the function is executed, even if the function calls back itself recursively or if two threads execute the function at the same time.</p>

<p>This is why you should be careful with static locals because they tend to make functions non-thread-safe. As an alternative you could use thread-local storage but that isn't part of Portable C or use a context object passed as a function parameter.</p>

<p>So this:</p>

<pre><code>int foo( int x ) {
    static int y = 5;
    return y += x;
}
</code></pre>

<p>Is equivalent to this:</p>

<pre><code>int y = 5; // if you add the `static` modifier then that restricts the scope of `y` to just this file, it does not affect its lifetime or storage semantics.

int foo( int x ) {
    return y += x;
}
</code></pre>
",4
50425846,50425769,1,"<p>You have two major problems, both leading to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>:</p>

<ol>
<li><p>You don't terminate the string in <code>large_str</code>. That means all string function which looks for the terminator (like <code>strcpy</code>) will go out of bounds.</p></li>
<li><p>You copy a very large string (even larger without the terminator) into a small buffer. That means you will go out of bounds of the small buffer.</p></li>
</ol>

<p>Remember that C doesn't have any kind of bounds-checking.</p>

<p>Also note that these problems are in <em>both</em> your programs.</p>
",0
50418452,50402409,1,"<p>What you are doing now is the correct way to deal with it.  Your desire to use pointers to cleanup functions with a specific type runs foul of the (strict) rules in C11 (and C99, and probably C90 though I've not formally checked C90).</p>

<blockquote>
  <h2>[¡ì6.3] Conversions</h2>
  
  <h3><a href=""http://port70.net/~nsz/c/c11/n1570.html#6.3.2.3"" rel=""nofollow noreferrer"">¡ì6.3.2.3 Pointers</a></h3>
  
  <p>?8 A pointer to a function of one type may be converted to a pointer to a function of another type and back again; the result shall compare equal to the original pointer. If a converted pointer is used to call a function whose type is not compatible with the referenced type, the behavior is undefined.</p>
</blockquote>

<hr>

<p>Your existing code is:</p>

<pre><code>struct foo {
    void *data;
    // ...
};

void foo_cleanup(struct foo *foo, void (*data_cleanup)(void *data)) {
    data_cleanup(foo-&gt;data);
    // ...
}

void bar_cleanup(void *data) {
    struct bar *bar = (struct bar *)data;
    // ...
}
</code></pre>

<p>This code is clean and obeys the rules.  The pointer to the <code>bar</code> cleanup function has the signature <code>void (*)(void *)</code> which matches the pointer used by <code>foo_cleanup()</code>.  The cast in <code>bar_cleanup()</code> is optional but explicit.  Even if you omit the cast notation, that conversion will occur as C automatically converts from <code>void *</code> to <code>struct bar *</code>.</p>

<p>If you try to use the cleanup function:</p>

<pre><code>void bar_cleanup(struct bar *bar);
</code></pre>

<p>you would have to make a call equivalent to:</p>

<pre><code>struct foo foo37;
¡­code initializing foo37¡­
foo_cleanup(&amp;foo37, (void (*)(void *))bar_cleanup);
</code></pre>

<p>This coerces the type of the function to a different pointer type.  Unless the code inside <code>foo_cleanup()</code> knows somehow (how?) that the pointer needs to use function with the signature <code>void (*)(struct bar *)</code> and changes it before calling the cleanup function, it runs afoul of the rule in ¡ì6.3.2.3.</p>

<pre><code>foo_cleanup(struct foo *foo, void (*data_cleanup)(void *data))
{
    (*data_cleanup)(foo-&gt;data);    // Undefined behaviour
    if (data-&gt;¡­)
        (*(void (*)(struct bar *))data_cleanup)(foo-&gt;data);  // OK, but¡­
    ¡­
}
</code></pre>

<p>The unconditional call is wrong because the types of the real function pointer and the one claimed by the parameter type are different.   The conditional call is clean because it casts the pointer back to its real type before calling the function.  (This is C; the conversion from <code>void *</code> to <code>struct bar *</code> is automatic and valid.) . However, having to know what to convert the pointer-to-function to in the <code>foo_cleanup()</code> function defeats the purpose of using a pointer-to-function in the first place.  It also isn't clear how <code>foo_cleanup()</code> does determine which cast is correct, and if you add a new type, you have to change the code again to support the new type.</p>

<p>All of this means that a solution using <code>void bar_cleanup(struct bar *bar)</code> is not really acceptable.</p>

<p>If you follow the strict rules laid down by the standard and still want to call <code>void bar_cleanup(struct bar *)</code>, you have to write gruesome, non-maintainable, inflexible code.</p>

<p>If you want absolutely reliable code, you will follow these rules and keep your existing code (<code>void bar_cleanup(void *data)</code>).  It has the beneficial side-effect of avoiding painful casts ¡ª function pointer casts are not pretty ¡ª and leaves the <code>foo_cleanup()</code> function unchanged regardless of how many different pointer types are stored in the <code>data</code> member of <code>struct foo</code> as long as the calling code knows which is the correct type (and if the calling code doesn't know, it's a case of ""Abandon Hope All Ye Who Enter Here"" anyway).</p>

<p>In practice, how serious a problem is this?  Actually, you'll probably get away with it at the moment.  But it is invoking undefined behaviour and compilers are ever eager to identify and exploit undefined behaviour to 'optimize' the code they generate.  You can do as you want without the cast in <code>foo_cleanup()</code>, but you are
taking risks which can be simply and painlessly avoided by keeping your current code.</p>

<p>Note that this applies to comparator functions passed to <code>qsort()</code> or <code>bsearch()</code> in the standard library.  Those functions should be written to take two <code>const void *</code> parameters and return an <code>int</code>.  Doing otherwise runs foul of ¡ì6.3.2.3.
There are examples in otherwise respected C books that do not keep to these strict rules.</p>
",4
50402480,50402409,-1,"<pre><code>typedef void (*CLEANUP_FUNC)(void *);

void foo_cleanup(struct foo *foo, CLEANUP_FUNC *data_cleanup) {
    data_cleanup(foo-&gt;data);
    // ...
}

void bar_cleanup(struct bar *data) {
    // ...
}

foo_cleanup(foo, (CLEANUP_FUNC *)bar_cleanup);
</code></pre>

<hr>

<p>The following is a full example featuring generic stack <code>Stack</code> and some elements of type <code>Foo</code>.</p>

<pre><code>#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// ---

typedef void (STACK_DEALLOCATOR)(void *);

typedef struct Stack {
   STACK_DEALLOCATOR *element_deallocator;
   size_t num_elements;
   size_t num_allocated;
   void **elements;
} Stack;

Stack *Stack_New(STACK_DEALLOCATOR *element_deallocator) {
   Stack *this = malloc(sizeof(Stack));
   if (this == NULL)
      goto ERROR;

   this-&gt;element_deallocator = element_deallocator;
   this-&gt;num_elements = 0;
   this-&gt;num_allocated = 4;

   this-&gt;elements = malloc(sizeof(void *) * this-&gt;num_allocated);
   if (this-&gt;elements == NULL)
      goto ERROR2;

   return this;

   ERROR2: free(this);
   ERROR:  return NULL;
}

int Stack_Push(Stack *this, void *element) {
   if (this-&gt;num_elements == this-&gt;num_allocated) {
      // ...
   }

   this-&gt;elements[ this-&gt;num_elements++ ] = element;
   return 1;
}

void Stack_Destroy(Stack *this) {
   void **element = this-&gt;elements;
   for (size_t i=this-&gt;num_elements; i--; ) {
      this-&gt;element_deallocator(*(element++));
   }

   free(this-&gt;elements);
   free(this);
}

// ---

typedef struct Foo {
   int data;
   // ....
} Foo;


Foo *Foo_New(int data) {
   Foo *this = malloc(sizeof(Foo));
   if (this == NULL)
      return NULL;

   this-&gt;data = data;
   return this;
}

void Foo_Destroy(Foo *this) {
   free(this);
}

// ---

int main(void) {
   Stack *stack = Stack_New((STACK_DEALLOCATOR *)Foo_Destroy);
   if (stack == NULL) {
      perror(""Stack_New"");
      goto ERROR;
   }

   Foo *foo = Foo_New(123);
   if (foo == NULL) {
      perror(""Foo_New"");
      goto ERROR2;
   }

   if (!Stack_Push(stack, foo)) {
      perror(""Stack_Push"");
      goto ERROR3;
   }

   Stack_Destroy(stack);
   return 0;

   ERROR3: Foo_Destroy(foo);
   ERROR2: Stack_Destroy(stack);
   ERROR:  return 1;
}
</code></pre>
",3
59551454,59551419,7,"<p>It's two statements in succession. Entirely equivalent to this</p>

<pre><code>if(/* ... */) {
  // Body
}
while(0) {
  // empty
}
</code></pre>

<p><code>while(0);</code> is just a loop with a single empty statement for a body.</p>

<p>There is no value in adding it after the <code>if</code>. I suspect it's leftover from a previous refactoring, but the git history in that repository does not go that far.</p>
",0
59551455,59551419,4,"<ol>
<li><p>It compiles because it is two statements, first</p>

<pre><code>if (...) { ... }
</code></pre>

<p>followed by another statement</p>

<pre><code>while (0);
</code></pre>

<p>i.e. a loop with empty body that is never run.</p></li>
<li><p>There is no value. <code>while (0);</code> as a separate statement is utterly useless. <a href=""https://stackoverflow.com/questions/257418/do-while-0-what-is-it-good-for""><code>do { ...?} while (0)</code> is not useless</a> but it is a completely different thing.</p></li>
</ol>

<hr>

<p>Probably the code was refactored from a form that initially used <code>do { ... } while (0)</code> and using <code>break</code>s to exit the flow early (from the linked question above). Currently the source file does not have <em>any</em> instances of <code>do</code> statement, there are only 3 times that the verb <em>do</em> exists in some strings.</p>
",0
51445760,51443140,1,"<p>Your loop control variable <code>i</code> is incremented by one in the <code>for</code> loop:</p>

<pre><code>for(i=0; i&lt;40; i++) 
</code></pre>

<p>and then by a further 3 by:</p>

<pre><code>i=i+3;
</code></pre>

<p>So <code>i</code> is overall incremented by 4 in each iteration.  Pointer arithmetic accounts for the size of the object pointed to.  Here you are pointing to a 32 bit (4 byte) integer, and incrementing by 4 each time, so the address is incremented by 4 x 4 = 16 bytes.</p>

<p>You should have:</p>

<pre><code>   for( i = 0; i &lt; 10; i++ ) 
   {
      int* temp = mem_allocate + i ;
      // i=i+3; REMOVE THIS!
      ...
</code></pre>

<p>Note that the cast was unnecessary; <code>mem_allocate</code> was already an <code>int*</code> as is the type of the expression <code>mem_allocate + i</code>.</p>

<p>Your code is flawed in other ways, unrelated to the question you have asked - specifically the ill-advised modification of <code>mem_allocate</code> - if you modify it, any attempt to free it will be invalid.  </p>

<p>Consider:</p>

<pre><code>#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
   const int n = 1024; 
   uint32_t* mem_allocate = malloc( n * sizeof(*mem_allocate) ) ;

   for( int i = 0; i &lt; n; i++ ) 
   {
      mem_allocate[i] = 0xAAAAAAAAu; 
   }


   free( mem_allocate ) ; 

   return 0 ; 
}
</code></pre>

<p>As you can see you made a simple thing unnecessarily complicated.</p>
",2
52099685,52099606,3,"<p>You have a variable in <code>main</code> called <code>mPt</code> and a variable in <code>bPhase</code> called <code>mPt</code>.  These are <strong>not</strong> the same variable.  Different variables may exist with the same name in different scopes.</p>

<p>Also, when <code>bPhase</code> returns you don't do anything with the return value.  You need to assign it to <code>mPt</code>.  Then you'll see the value you expect.</p>

<pre><code>mPt = bPhase(x0, delta);
</code></pre>
",0
48740467,48740208,5,"<blockquote>
  <p>even though it has no definition</p>
</blockquote>

<p>is not quite right. It actually <em>does</em> have a definition, it's right there in the function declaration. Whether or not you <em>use</em> it is a totally different matter.</p>

<p>Be that as it may, the term you're using, visibility, is okay for beginners but the language specification (and the language lawyers like myself that use it) prefer the term scope.</p>

<p>And the scope of variables is covered in (for C11) <code>6.2.1 Scopes of identifiers</code>. Stanza <code>/4</code> of that section states (my emphasis):</p>

<blockquote>
  <p>If the declarator or type specifier that declares the identifier appears inside a block <strong><em>or within the list of parameter declarations in a function definition, the identifier has block scope, which terminates at the end of the
  associated block.</em></strong></p>
</blockquote>

<p>That means the variable is ""visible"" all the way to the end of the function block (assuming you don't shadow it by introducing another variable of the same name in an inner scope).</p>
",0
49639894,49639736,1,"<p>By doing</p>

<pre><code>buf val = {NULL, 100};
</code></pre>

<p><code>val.ptr</code> is pointing to <code>NULL</code>, of course <code>snprintf</code> will fail. You need to
allocate memory for it:</p>

<pre><code>int main(void)
{
    val.ptr = calloc(val.len, 1);
    if(val.ptr == NULL)
    {
        fprintf(stderr, ""not enough memory\n"");
        return 1;
    }

    snprintf(val-&gt;ptr, val-&gt;len, ""%s%s"", ""hello"", ""world"");

    free(val.ptr);

    return 0;
}
</code></pre>

<p>Note that </p>

<pre><code>val-&gt;ptr = (void *)(strcat(""hello"",""world""));
</code></pre>

<p>is very wrong. The first argument of <code>strcat</code> cannot be a pointer to a string
literal, because modifying string literals yields undefined behaviour and on most systems string literals are stored on read-only memory.
You'll need an array where you can modify the characters in the array:</p>

<pre><code>char str[20] = ""hello"";
strcat(str, ""world"");
</code></pre>
",2
49639894,49639736,1,"<p>By doing</p>

<pre><code>buf val = {NULL, 100};
</code></pre>

<p><code>val.ptr</code> is pointing to <code>NULL</code>, of course <code>snprintf</code> will fail. You need to
allocate memory for it:</p>

<pre><code>int main(void)
{
    val.ptr = calloc(val.len, 1);
    if(val.ptr == NULL)
    {
        fprintf(stderr, ""not enough memory\n"");
        return 1;
    }

    snprintf(val-&gt;ptr, val-&gt;len, ""%s%s"", ""hello"", ""world"");

    free(val.ptr);

    return 0;
}
</code></pre>

<p>Note that </p>

<pre><code>val-&gt;ptr = (void *)(strcat(""hello"",""world""));
</code></pre>

<p>is very wrong. The first argument of <code>strcat</code> cannot be a pointer to a string
literal, because modifying string literals yields undefined behaviour and on most systems string literals are stored on read-only memory.
You'll need an array where you can modify the characters in the array:</p>

<pre><code>char str[20] = ""hello"";
strcat(str, ""world"");
</code></pre>
",2
56421534,33979641,0,"<p>The problem is <em>indeed</em> with your <code>wincheck</code> function. It rightly checks that the three candidate cells are equal but does <em>not</em> check that those cells have been populated. That means the game will be detected as won even before a move is made (since <em>all</em> cells are set to <code>-</code>, a simple equality check will pass).</p>

<p>It's therefore not enough to do <em>just</em> the equality check, you also have to ensure that at least <em>one</em> of those cells has been set to a real player.</p>

<p>You can also make your code a bit more readable with a little refactoring, something like:</p>

<pre><code>// Returns the actual winner, or '-' if none. Needs x/y start cell
// and x/y deltas (direction, basically).

int checkOneWinPossibility(char board[3][3], int x, int y, int xd, int yd) {
    // Check all no-winner scenarios, return winner only if they all fail.

    if (board[x][y] == '-') return '-';
    if (board[x][y] != board[x+xd][y+yd]) return '-';
    if (board[x][y] != board[x+xd*2][y+yd*2]) return '-';

    return board[x][y];
}

int checkAllWinPossibilities(char board[3][3]){
    int winner;

    // Horizontals.

    if ((winner = checkOneWinner(board, 0, 0, 0, 1)) != '-') return winner;
    if ((winner = checkOneWinner(board, 1, 0, 0, 1)) != '-') return winner;
    if ((winner = checkOneWinner(board, 2, 0, 0, 1)) != '-') return winner;

    // Verticals.

    if ((winner = checkOneWinner(board, 0, 0, 1, 0)) != '-') return winner;
    if ((winner = checkOneWinner(board, 0, 1, 1, 0)) != '-') return winner;
    if ((winner = checkOneWinner(board, 0, 2, 1, 0)) != '-') return winner;

    // Diagonals.

    if ((winner = checkOneWinner(board, 0, 0, 1, 1)) != '-') return winner;
    if ((winner = checkOneWinner(board, 2, 0, -1, 1)) != '-') return winner;

    return '-';
}
</code></pre>

<p>That last diagonal check <em>could</em> be combined with the <code>return</code> statement just by doing:</p>

<pre><code>return checkOneWinner(board, 2, 0, -1, 1);
</code></pre>

<p>but I prefer (being slightly OCD) to leave it as is for consistency :-)</p>

<p>They also both return the <em>actual</em> winner rather than just an indication that there is a winner. You may not <em>need</em> that information since it will obviously be the last player that moved, but there's no probably no substantial harm in returning the extra information.</p>
",0
56421534,33979641,0,"<p>The problem is <em>indeed</em> with your <code>wincheck</code> function. It rightly checks that the three candidate cells are equal but does <em>not</em> check that those cells have been populated. That means the game will be detected as won even before a move is made (since <em>all</em> cells are set to <code>-</code>, a simple equality check will pass).</p>

<p>It's therefore not enough to do <em>just</em> the equality check, you also have to ensure that at least <em>one</em> of those cells has been set to a real player.</p>

<p>You can also make your code a bit more readable with a little refactoring, something like:</p>

<pre><code>// Returns the actual winner, or '-' if none. Needs x/y start cell
// and x/y deltas (direction, basically).

int checkOneWinPossibility(char board[3][3], int x, int y, int xd, int yd) {
    // Check all no-winner scenarios, return winner only if they all fail.

    if (board[x][y] == '-') return '-';
    if (board[x][y] != board[x+xd][y+yd]) return '-';
    if (board[x][y] != board[x+xd*2][y+yd*2]) return '-';

    return board[x][y];
}

int checkAllWinPossibilities(char board[3][3]){
    int winner;

    // Horizontals.

    if ((winner = checkOneWinner(board, 0, 0, 0, 1)) != '-') return winner;
    if ((winner = checkOneWinner(board, 1, 0, 0, 1)) != '-') return winner;
    if ((winner = checkOneWinner(board, 2, 0, 0, 1)) != '-') return winner;

    // Verticals.

    if ((winner = checkOneWinner(board, 0, 0, 1, 0)) != '-') return winner;
    if ((winner = checkOneWinner(board, 0, 1, 1, 0)) != '-') return winner;
    if ((winner = checkOneWinner(board, 0, 2, 1, 0)) != '-') return winner;

    // Diagonals.

    if ((winner = checkOneWinner(board, 0, 0, 1, 1)) != '-') return winner;
    if ((winner = checkOneWinner(board, 2, 0, -1, 1)) != '-') return winner;

    return '-';
}
</code></pre>

<p>That last diagonal check <em>could</em> be combined with the <code>return</code> statement just by doing:</p>

<pre><code>return checkOneWinner(board, 2, 0, -1, 1);
</code></pre>

<p>but I prefer (being slightly OCD) to leave it as is for consistency :-)</p>

<p>They also both return the <em>actual</em> winner rather than just an indication that there is a winner. You may not <em>need</em> that information since it will obviously be the last player that moved, but there's no probably no substantial harm in returning the extra information.</p>
",0
49247638,49247612,6,"<p>Check the value of <code>argc</code>, it tells you how many arguments have been passed. </p>

<pre><code>int main(int argc, char **argv)
{
    if(argc != 4)
    {
        fprintf(stderr, ""usage: %s sleep produce consume\n"", argv[0]);
        return 1;
    }

    toSleep = atoi(argv[1]);
    produce = atoi(argv[2]);
    consume = atoi(argv[3]);
    ....
}
</code></pre>

<p>Note that <code>argc</code> is the value of the number of arguments <strong>plus</strong> the filename
of the executed binary (more precisely how the binary was executed) and
<code>argv[0]</code> is always that string. So when <code>argc == 4</code>, 3 arguments have been
passed (<code>argv[1]</code>, <code>argv[2]</code>, <code>argv[3]</code>) and <code>argv[4] == NULL</code>. The <code>argv</code> list
is always <code>NULL</code> terminated.</p>

<p>If you wan to check if an individual <code>argv[i]</code> is <code>NULL</code>, then</p>

<pre><code>if(argv[i] == NULL)
{
    // argv[i] is NULL
}
</code></pre>

<p>but you usually don't have to do these checks if you properly checked <code>argc</code>.
But sometimes it makes sense to check against <code>NULL</code>, for example when you have
variable number of arguments, when a program can take either 3 or 4 arguments,
then checking if <code>argv[3] == NULL</code> is also an option to see if the last optional
argument has been passed. But I prefer checking <code>argc</code> instead anyway.</p>

<p>Note also that <code>toSleep</code>, <code>produce</code> and <code>consume</code> are <code>int</code>, although the check</p>

<pre><code>if(toSleep == '\0' ||  produce == '\0' || consume == '\0' )
</code></pre>

<p>is technically correct, I suggest you do</p>

<pre><code>if(toSleep == 0 ||  produce == 0 || consume == 0 )
</code></pre>

<p>which shows your intentions more clearly.</p>
",1
57881809,57881794,7,"<p>This: <code>if(i == 20 || 30)</code> is equivalent to <code>if((i == 20) || 30)</code> and <code>30</code> is always <code>true</code>.</p>

<p>If you really want to do what I think you want to do, you should have written:</p>

<pre><code>if(i == 20 || i == 30)
</code></pre>

<p>instead.</p>
",2
48848865,48847938,1,"<p>You have a couple of small errors:</p>

<p>When you create the threads with</p>

<pre><code>pthread_create(&amp;workers[a], ...
</code></pre>

<p><code>a</code> is in the first call already 1, because you've initialized it with 1. That
means that the last <code>pthread_create</code> call will access <code>workers</code> out of
bounds, you are passing a pointer to an undefined address and this is undefined
behaviour. You should initialize <code>a</code> with 0.</p>

<p>The second problem is when you join the threads:</p>

<pre><code>for (i = 0; i&lt;10 ; i++){
    pthread_join(workers[i], NULL);
}
</code></pre>

<p>Because of <code>a</code> being initialized with 1, <code>worker[0]</code> is not an initialized
thread. The man page does not mention what happens when you pass an
uninitialized thread to <code>pthread_join</code>, but my guess is that it is undefined behaviour and most likely the reason
why you have the segfault. I would also write the condition <code>i &lt; M*N</code>, because
if you change any of those values, you would be accessing <code>workers</code> out of
bounds.</p>

<p>You fail to free the memory for the <code>struct v</code> objects, you would have to do it
after the <code>join</code>. You are leaking memory there. I don't think that you even need
to use <code>malloc</code> here, you can declare an array of dimension <code>M*N</code> of <code>struct v</code>
objects, just like you did with the <code>pthread_t</code> array. When accessing the array,
I'd use <code>i*N+j</code> to calculate the correct index for both arrays.</p>

<p>I modified your code with my corrections and my suggestions:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;

#define M 3
#define K 2
#define N 3 

int A [M][K] ={{1,4},{2,5},{3,6}};
int B [K][N] ={{8,7,6},{5,4,3}};
int C [M][N];

/* structure for passing data to threads */

struct v
{
    int i; /* row */
    int j; /* column */
};

void *matrix_multiplication( void *ptr );  //the thread

int main (int argc, char* argv[]){


    pthread_t workers[M*N];
    struct v data[M*N];
    int i = 0;
    int j = 0;

    /* We have to create M * N worker threads */
    for (i = 0; i &lt; M ; i++) {
        for (j = 0; j &lt; N; j++){

            int idx = i*N+j;
            data[idx].i = i;
            data[idx].j = j;

            /* Now create the thread passing it data as a parameter */
            pthread_create(workers + idx, NULL, matrix_multiplication, data+idx);
        }
    }

    //wait for all the threads to be finished   
    for (i = 0; i&lt;M*N ; i++)
        pthread_join(workers[i], NULL);

    //printing the matrix
    for (i = 0; i &lt; M ; i++) {
        for (j = 0; j &lt; N; j++){
            printf(""%d "",C[i][j] );
        }
        printf(""\n"");
    }   


    return 0;
}

void *matrix_multiplication( void *ptr ){   

    struct v *data = ptr;
    int sum = 0, z;

    for(z=0; z &lt; K; z++){
        sum += A[data-&gt;i][z] * B[z][data-&gt;j];
    } 

    C[data-&gt;i][data-&gt;j] = sum;
    printf(""%d\n"",sum );
    pthread_exit(0);
}
</code></pre>

<p>As you see, I don't use <code>malloc</code>, so I don't have to worry about freeing memory
afterwards. When I run this code, I get:</p>

<pre class=""lang-none prettyprint-override""><code>41
45
18
28
27
34
23
54
36
28 23 18 
41 34 27 
54 45 36 
</code></pre>

<hr>

<p><strong>edit</strong></p>

<blockquote>
  <p><em>OP asked in the comment section</em></p>
  
  <p>How can I free memory If I used malloc for the struct?!</p>
</blockquote>

<p>There are different ways, but the first step is to store the pointer that
<code>malloc</code> returns. Right now you are not storing that value.</p>

<p>The first option would be: free the memory in the thread. Let's use your way of
passing values to the threads:</p>

<pre><code>struct v *data = malloc(sizeof(struct v));
data-&gt;i = i;
data-&gt;j = j;

/* Now create the thread passing it data as a parameter */
pthread_create(&amp;workers[a] , NULL , matrix_multiplication, data);
</code></pre>

<p>Every single thread get's an own <code>struct v</code> object and you never use it outside
the thread. That's why you can do this in the thread:</p>

<pre><code>void *matrix_multiplication( void *ptr ) {
    ...
    free(ptr);
    pthread_exit(0);
}
</code></pre>

<hr>

<p>Let's say that the parent process needs to get the pointer passed to the thread.
For example because the thread wrote some value there that the main
threads wants to evaluate. Let's say the threads should calculate their
calculation time. Your <code>struct v</code> could look like this:</p>

<pre><code>struct v {
    int i;
    int j;
    double time;
}
</code></pre>

<p>The threads would calculate the time and write it on <code>data-&gt;time</code>. The
thread can pass to the main thread a pointer through <code>pthread_exit</code>, in this
case you the thread can pass the same pointer it got from the main thread:</p>

<pre><code>#include &lt;time.h&gt;

void *matrix_multiplication( void *ptr ){   

    struct v *data = ptr;
    int sum = 0, z;

    clock_t begin = clock();
    for(z=0; z &lt; K; z++){
        sum += A[data-&gt;i][z] * B[z][data-&gt;j];
    } 

    C[data-&gt;i][data-&gt;j] = sum;
    clock_t end = clock();

    data-&gt;time = (double)(end - begin) / CLOCKS_PER_SEC;

    //threads exit
    pthread_exit(ptr);
}
</code></pre>

<p>Now when you joing the threads, you get the pointer you've pass to the thread,
you can use that pointer and then free it if you don't need it anymore.</p>

<pre><code>double agg_time = 0;
for (i = 0; i&lt;M*N ; i++) {
    struct v *data;
    pthread_join(workers[i], (void**) &amp;data);

    printf(""i: %d, j: %d ,time: %lf\n"", data-&gt;i, data-&gt;j, data-&gt;time);
    agg_time += data-&gt;time;
    free(data);
}
printf(""aggregated time: %lf\n"", agg_time);
</code></pre>

<p>The output of this would be</p>

<pre class=""lang-none prettyprint-override""><code>i: 0, j: 0 ,time: 0.000002
i: 0, j: 1 ,time: 0.000001
i: 0, j: 2 ,time: 0.000002
i: 1, j: 0 ,time: 0.000002
i: 1, j: 1 ,time: 0.000001
i: 1, j: 2 ,time: 0.000001
i: 2, j: 0 ,time: 0.000002
i: 2, j: 1 ,time: 0.000001
i: 2, j: 2 ,time: 0.000014
aggregated time: 0.000026
28 23 18 
41 34 27 
54 45 36 
</code></pre>

<p>If you pass a <code>malloc</code>ed pointer to the threads, this is the one I like the most.</p>

<hr>

<p>A third option would be to store the <code>malloc</code> data in an array and free it after
the join.</p>

<pre><code>int main(void)
{
    ...
    struct v *data[M*N];

    ...

    for (i = 0; i &lt; M ; i++) {
        for (j = 0; j &lt; N; j++) {
            int idx = i*N+j;
            data[idx] = malloc(sizeof *data[idx]);

            data[idx]-&gt;i = i;
            data[idx]-&gt;j = j;

            pthread_create(workers + idx, NULL, matrix_multiplication, data[idx]);
        }
    }

    // do the join
    for (i = 0; i&lt;M*N ; i++){
        pthread_join(workers[i], NULL);
    }

    // do the free
    for(int i = 0; i &lt; M*N; ++i)
        free(data[i]);
}
</code></pre>

<p>I don't like this version too much, because it makes the code larger, you need
to check that <code>malloc</code> doesn't return <code>NULL</code> (I've omitted this test) and have
an error handling strategy for when it fails. That was the nice thing about my very
first code, you don't do <code>malloc</code>, you don't have to worry about <code>free</code>. However
if you need to pass an allocated block of memory to the thread, I'd do the one
above, where the thread returns the pointer back to the main thread through
<code>pthread_exit</code>.</p>
",1
52876438,52875782,0,"<p>In addition to Jabberwocky answer.</p>

<p>Overflow is not the only reason, yoh have overflow of a 'round' number... </p>

<p>fact(34) returns the amazing result of 0.</p>

<p>If it was a <code>uint64</code> return value and arg </p>

<pre><code>unsigned long long fact(unsigned long long n)
</code></pre>

<p>and you print the result with </p>

<pre><code>printf(""%llx"",x);
</code></pre>

<p>you'll get the result:  445da75b00000000</p>

<p>Cast it to int and you'll get a perfect 0. </p>

<p>It is logical since you have multiply a lot of even numbers and some of the are even power of 2. </p>

<h1>You just need 32 2s multiplies to reach this result:</h1>

<ul>
<li>2,6,10,14,18,22,26,30,34 each give you one 2 so you have 9 2s</li>
<li>4,12,20,28 each give you 4, which is 2*2, so it gives you 8 2s, so you already have 17 2s</li>
<li>8,24 give you 8 which is 2*2*2, so you have more 6 2s, and total is 23 2s</li>
<li>16 give you more 4 2s, so you have 27 2s</li>
<li>32 give you more 5 2s, so you have exactly 32 2s.</li>
</ul>
",0
52876178,52875782,4,"<p>35! exceeds the capacity of an <code>unsigned int</code> on your platform by far.</p>

<p>What happens then is that <code>fact(35)</code> returns 0, which results in a division by 0 hence the SIGFPE (<strong>f</strong>loating <strong>p</strong>oint <strong>e</strong>xception).</p>

<p>Consider using the <code>unsigned long long</code> type, but this won't help for 35 either, because 35! is really huge.</p>
",1
53230902,53230695,1,"<p>Make <code>C</code> a constant (<code>#define C 3</code>)!</p>

<p>Problem is: Without <code>C</code> being constant, but a variable, it <em>could</em> have been modified before declaring the array, so the latter actually is a VLA. The function, in contrast, expects a fixed size array, so types don't match.</p>

<p>Be aware you don't have to make <code>R</code> constant:</p>

<pre><code>int rec_ped(int k[18][3], int idx);
</code></pre>

<p>is equivalent to</p>

<pre><code>int rec_ped(int k[][3], int idx);
</code></pre>

<p>which is equivalent to</p>

<pre><code>int rec_ped(int (*k)[3], int idx);
</code></pre>

<p>i. e. the function actually accepts a pointer to an array of length 3 just like <code>void f(int*);</code> accepts a pointer to int. In both cases, the pointer could reference the first element of an array (array of array or array of int respectively) or just a single element...</p>
",7
53230899,53230695,4,"<p>When an array decays to a pointer, it only applies to the outermost array dimension.  It does <em>not</em> apply to inner dimensions.  So <code>int (*)[3]</code> and <code>int (*)[C]</code> are not the same, even though <code>C</code> happens to be 3 at the time the function is called.  A fixed size array and a variable length array can't be considered the same in this situation.</p>

<p>What you can do however is pass the dimensions of an array as parameters:</p>

<pre><code>int rec_ped(int rows, int cols, int k[rows][cols], int idx) {
</code></pre>

<p>Then you can call it like this:</p>

<pre><code>rec_ped(R, C, A, 18);
</code></pre>
",1
51213724,51213172,1,"<p>Precedence only controls how expressions are <em>parsed</em>, not how they are evaluated.  Arithmetic <code>*</code> has higher precedence than <code>+</code>, so <code>a * b + c</code> is parsed as <code>(a * b) + c</code>.  However, each of <code>a</code>, <code>b</code>, and <code>c</code> may be evaluated in any order.  The result of <code>a * b</code> must be known before it can be added to the result of <code>c</code>, but that doesn't mean that <code>a * b</code> must be evaluated <em>before</em> <code>c</code>.  </p>

<p>Secondly, unlike most operators in C, the <code>||</code> and <code>&amp;&amp;</code> operators force left-to-right evaluation.  An expression like <code>a || b &amp;&amp; c</code> will be parsed as <code>a || (b &amp;&amp; c)</code>, but <code>a</code> will <em>always</em> be evaluated first, and <code>b &amp;&amp; c</code> will only be evaluated if the result of <code>a</code> is 0.  </p>
",0
51213318,51213172,12,"<p>There are three issues here:</p>

<ol>
<li>Order of precedence.</li>
<li>Order of evaluation.</li>
<li>Short circuiting of logical operators.</li>
</ol>

<p>Order of precedence implies that <code>++a || ++b &amp;&amp; ++c</code> is evaluated as <code>++a || (++b &amp;&amp; ++c)</code>.</p>

<p>However, due to the short circuiting requirements of logical operators, <code>++a</code> is evaluated first. Only if that evaluates to <code>false</code> will <code>(++b &amp;&amp; ++c)</code> be evaluated. In your case, <code>++a</code> evaluates to <code>true</code>. Hence, <code>(++b &amp;&amp; ++c)</code> is never evaluated.</p>
",0
51213396,51213172,0,"<p>As far as precedence goes, <code>x || y &amp;&amp; z</code> acts just like <code>x + y * z</code>: the second operator binds more tightly than the first one, and those expressions are equivalent to <code>x || (y &amp;&amp; z)</code> and <code>x + (y * z)</code>, respectively.</p>

<p>The reason that <code>b</code> and <code>c</code> in the question aren't incremented is because, in addition to precedence, logical operations short circuit: once you've gotten far enough along to know the result, the rest of the expression is skipped. Both <code>||</code> and <code>&amp;&amp;</code> evaluate their arguments left-to-right, so in <code>a() || b()</code> and in <code>a() &amp;&amp; b()</code>, the call to <code>a()</code> occurs before the call to <code>b()</code>.</p>

<p>In simple cases, if <code>a()</code> returns <code>true</code>, then in the expression <code>a() || b()</code> the call to <code>b()</code> will not be executed, because it won't affect the result. Similarly, if <code>a()</code> returns <code>false</code>, then in the expression <code>a() &amp;&amp; b()</code>, the call to <code>b()</code> will not be executed.</p>

<p>In the code in the example, the increments to <code>b</code> and <code>c</code> won't be performed, because <code>++a</code> produces a non-zero value, so the result of the expression is <code>true</code> without needing to evaluate anything after <code>++a</code>.</p>
",0
51213354,51213172,2,"<p>The logical OR operator <code>||</code> (as well as the logical AND operator <code>&amp;&amp;</code>) is one of the few operators that perform <em>short circut operation</em>.</p>

<p>Section 6.5.14 of the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C standard</a> says the following about the logical OR operator:</p>

<blockquote>
  <p><em>4</em> Unlike the bitwise <code>|</code> operator, the <code>||</code> operator guarantees
  left-to-right evaluation; if the second operand is evaluated, there is
  a sequence point between the evaluations of the first and second
  operands. <strong>If the first operand compares unequal to 0, the second
  operand is not evaluated.</strong></p>
</blockquote>

<p>Because <code>++a</code> evaluates to 1, the result of the <code>||</code> operator is guaranteed to be 1 and the right hand side is not evaluated.  Also, because <code>&amp;&amp;</code> has higher precedence than <code>||</code>, the right side of the <code>||</code> operator is <code>++b &amp;&amp; ++c</code>, meaning that neither <code>++b</code> or <code>++c</code> is evaluated.</p>
",0
56234001,36142470,0,"<p>In this example you must press <strong>twice</strong> Ctrl-C within 300ms.</p>

<p>So if you keep Ctrl-C pressed the program will stop otherwise not.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;


int ctrlcs=0;

void cchandler(int signum){
  printf(""Press again to quit.\n"");
  ctrlcs+=1;
  if (ctrlcs==2) {
    signal(SIGINT, SIG_DFL);
  } 
  usleep(300000);  // delay for the second Ctrl-C
}

int main(){

  signal(SIGINT, cchandler);

  while(1) {
   printf("" I am running into infinite loop.., stop me if you dare..\n"");
   sleep (5);
   ctrlcs=0;
  }

}
</code></pre>
",0
59172586,59172198,4,"<p>Let say the function signature is <code>int sendString(char* s)</code>.
You can then write:</p>

<pre class=""lang-c prettyprint-override""><code>
// declare SendDebugString as a pointer to a function
// accepting a string as argument and returning an int
int (*SendDebugString)(char *s);

// assign a function to SendDebugString
SendDebugString = Uart1_SendDebugString;

// call the function
SendDebugString(""hello world!"");
</code></pre>
",3
55349851,55349759,2,"<p>You should use the type <code>int</code> to match what <code>fgetc</code> returns, not <code>unsigned int</code>. The reason the loop stop condition works with <code>unsigned int</code> is not that the value is ever negative, but that, when the <code>!=</code> operator is used with <code>unsigned</code> and <code>signed</code> operands of the same rank, both get promoted to <code>unsigned</code> before the comparison. Assigning the <code>EOF</code> result of <code>fgetc</code> to <code>currentByte</code> and promoting <code>EOF</code> to <code>unsigned</code> both produce the same result, and thus they compare equal.</p>
",1
50380227,50380084,1,"<p>Very simply putting, the processors align the variables based on the word size. The integers in your case are aligned at 4 byte boundaries, so when you interlace your characters and integers, 3 bytes after every character is not utilized. 
Refer to: <a href=""https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/"" rel=""nofollow noreferrer"">https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/</a></p>
",0
55733517,55732650,0,"<p>The trick is to limit the number of characters read into <code>a</code> and <code>b</code>, not to check if the user entered too many characters after the fact (by which time the damage will already have been done).</p>

<p>There are several ways to do this.  One is to use an explicit width on the <code>%s</code> conversion specifier in the <code>scanf</code> call:</p>

<pre><code>scanf( ""%11s"", a );
</code></pre>

<p>Another use to use <code>fgets</code> instead of <code>scanf</code>:</p>

<pre><code>fgets( a, sizeof a, stdin);
</code></pre>

<p>Both will prevent more than 11 characters being read into <code>a</code>, and will add the 0-terminator.  </p>

<p><em>However</em>, if the user typed 12 or more characters, those extra characters will still be waiting in the input stream, which will be picked up by your next input operation, which is probably not what you want.  You'll need to scrub the input stream if that's the case.  One approach is to read and discard any non-whitespace characters immediately after your input operation:</p>

<pre><code>if ( fgets( a, sizeof a, stdin ) != NULL ) // if ( scanf( ""%11s"", a ) == 1 )
{
  // Successfully read into a
  // Scrub any non-whitespace characters remaining in the input stream
  int c;
  while ( !isspace( c = getchar() ) )
    ; // empty loop body
  if ( c != EOF ) 
    ungetc( c, stdin );
}
else
{
  // error on input
}
</code></pre>

<p>The <code>while</code> loop will keep reading individual characters from the input stream until it sees a whitespace character.  If we do read a whitespace character, we push it back onto the input stream.  </p>
",0
55732826,55732650,0,"<pre><code>int i=12;
char a[i] ,b[i];
</code></pre>

<p>So arrays <code>a</code> and <code>b</code> each have 12 elements.</p>

<pre><code>if(a[i]&gt;i || b[i]&gt;i){
</code></pre>

<p>Nothing has changed the value of <code>i</code>, so <code>i</code> is still 12. So <code>a[i]</code> is equivalent to <code>a[12]</code>. But since <code>a</code> only has 12 elements, there is no thirteenth element (since <code>a[0]</code> is the first element, <code>a[12]</code> is the thirteenth). So this is an attempt to access an entry in an array that doesn't exist.</p>

<p>If you want to detect whether or not a person enters more than 12 characters, you need code that can allow them to enter more than 12 characters. That's not what you've written.</p>
",0
55562154,55562008,2,"<p>There's no such specifier as <code>""%u[^,]""</code>. That format is treated as a separate <code>""%u""</code> followed by a separate <code>""[^,]""</code>.</p>

<p>The <code>%[</code> format only reads strings, it doesn't have any type-prefix (and it's not needed as <code>scanf</code> will stop reading integers at the first non-digit character in the input). Which means you can use only <code>""%u""</code> for the middle specifier:</p>

<pre><code>c = fscanf(fp, "" %[^,], %u, %lf"", CHANNEL_NAME_, &amp;val1_, &amp;val2_);
</code></pre>

<p>Note that I added a leading space in the format string. That's because the <code>""%[""</code> format does not skip leading spaces (like any possible newlines after the previous line).</p>

<hr>

<p>With the format specifier <code>""%u[^,]""</code>, the function actually tries to match the exact sequence <code>""[^,]""</code> in the input, which it won't find, leading to the last value not being read. Hence the value of <code>c</code> being <code>2</code> (as <code>fscanf</code> only matched two values, the initial string and the first unsigned integer).</p>
",2
49931914,49931881,4,"<p>Assuming C99, or C11 with an implementation that doesn't define <code>__STDC_NO_VLA__</code>, you could use the variable length array (VLA) notation and could write:</p>

<pre><code>void function(int r, int c, int a[r][c])
{
    for (int i = 0; i &lt; r; i++)
    {
        for (int j = 0; j &lt; c; j++)
            printf(""%d, "", a[i][j]);
        putchar('\n');
    }
}
</code></pre>

<p>Or something equivalent to that.  The dimensions must be defined before they're used in the array specification.</p>

<p>If you don't have access to even a C99 compiler but only a C90 compiler, then you have to pass a pointer to the first element of the array and the sizes and you perform the array index calculation explicitly.</p>

<pre><code>void function(int r, int c, int *a)
{
    for (int i = 0; i &lt; r; i++)
    {
        for (int j = 0; j &lt; c; j++)
            printf(""%d, "", a[i * c + j]);
        putchar('\n');
    }
}
</code></pre>

<p>Now you call the function like this:</p>

<pre><code>int main(void)
{
    int array[2][2] = { { 1, 2 }, { 4, 5 } };
    function(2, 2, &amp;array[0][0]);
    return 0;
}
</code></pre>
",4
53227510,53227473,3,"<p>The <code>getch</code> function read <em>any</em> character, including whitespace characters such as a newline.</p>

<p>If you pressed the Enter key, <code>getch</code> will capture it.</p>
",1
49327553,49326197,3,"<p>The source code you linked to is a small application that reads in a text sample, generates a tree data structure that contains word frequency (how many times each word appears in the text sample), and then prints out the list of words from most frequent to least frequent.</p>

<pre><code>/*

  Chapter 6. Structures

          Write a program that prints out the distinct words in its 
          input sorted into decreasing order of frequency of occurrence.
          Precede each word by its count.

  Author: Bryan Williams

*/
</code></pre>

<p>The pattern used in this application has a classical and elegant K&amp;R feel about it. The first step is to process the text sample generating a tree structure in which each node contains a piece of text (a word from the text sample) along with a frequency count of how many times the piece of text is found. The second step is to then sort the tree nodes by the frequency counts. The third step is to print the sorted tree nodes in order of frequency to provide a list of the text pieces found along with how many times the text piece was found in the text sample.</p>

<p>The tree used is a <a href=""https://en.wikipedia.org/wiki/Binary_tree"" rel=""nofollow noreferrer"">binary tree</a> and the tree nodes have the following structure:</p>

<pre><code>typedef struct WORD
{
  char *Word;          // pointer to the text piece, a word of text
  size_t Count;        // frequency count for this word
  struct WORD *Left;   // pointer to tree node child left
  struct WORD *Right;  // pointer to tree node child right
} WORD;
</code></pre>

<p>The tree structure is used in order to be efficient about either determining if a text piece has already been found and just incrementing the count or adding the text piece with a count of one to our data storage if it does not.</p>

<p>However the sorting step uses a different criteria for the order of items in the tree than for the processing of the text sample. The text sample uses the text pieces as the way to order the tree nodes but for the actual output we need an order based on the frequency counts. So we need to sort the nodes of the tree on the frequency counts.</p>

<p>Since this is an in memory tree, the first thought for the program would be to create a list of the tree nodes in an array and then sort the list. However sorting an array usually requires moving array elements around except for the special case of the array already being sorted. This approach would also double the amount of memory used for the tree nodes since a copy of the nodes is being made.</p>

<p>Rather than making a copy of the tree nodes and then sorting that list, instead the program creates a list of pointers to the tree nodes and then sorts the list of pointers by referencing the tree nodes the pointers point to.</p>

<p><strong>A Bit About the <code>qsort()</code> interface</strong></p>

<p>The function definition of <code>CompareCounts(const void *vWord1, const void *vWord2)</code> means that <code>vWord1</code> is a pointer to a <code>const</code> variable whose type is unknown or could be anything.</p>

<p>If we look at the <code>qsort()</code> function declaration it looks like:</p>

<p><code>void qsort (void* base, size_t num, size_t size, 
            int (*comparator)(const void*,const void*));</code></p>

<p>So the comparison function used with <code>qsort()</code> must have a compatible argument list or interface description or a modern C compiler will issue an error.</p>

<p>Traditionally with the comparison function used with <code>qsort()</code> as well as <code>bsearch()</code>, we would have a comparison function that would look like:</p>

<pre><code>CompareCounts(const void *vWord1, const void *vWord2)
</code></pre>

<p>In the comparison function we would then take the <code>void *</code> arguments and cast them to a pointer of the the actual type that is to be used in the comparison. After that we then use the local, properly typed variables to do the comparison operation.</p>

<p>What <code>qsort()</code> does is to take two elements of the array that it wants to compare and calls the comparison function with pointers to those two elements. The use of <code>void *</code> is to work around the type checking of the C compiler.</p>

<p>The interface specified that the <code>void *</code> pointer is pointing to something that is <code>const</code> because <code>qsort()</code> doesn't want you to change the data that it is providing. It is asking you to test the two data items provided and indicate which is greater or lesser or equal in the collating sequence you are using to sort the data.</p>

<p>The reason for the <code>void *</code> pointer is because the <code>qsort()</code> function does not know what the data is or how the data is structured. <code>qsort()</code> only knows the number of bytes, the size, of each data element so that it can iterate through the array of items, element by element. This allows the array to be any size of <code>struct</code> or other type of data.</p>

<p><strong>The Specific Example Comparison Function</strong></p>

<p>The interface, how the arguments were casted, for <code>CompareCounts()</code> looked strange to me until I reviewed the source code you linked to. That program generates a tree structure then generates an array of pointers which point to the actual nodes in the tree. It is this array of pointers to nodes that is passed to <code>qsort()</code> to sort.</p>

<p>So the array of data provided to <code>qsort()</code> is an array each element of which  points to a tree node which is a <code>WORD</code> element stored in the tree data structure. The array of pointers are sorted based on the data the pointers  point to.</p>

<p>In order to access a particular node by using the array passed to the <code>qsort()</code> function we have to take the array element and dereference it to get the actual tree node.</p>

<p>Since <code>qsort()</code> passes a pointer to the array element, the <code>void *vWord1</code> is a pointer to an array element and we have to dereference that pointer to get the actual array element, a pointer to a tree element. However it is not the pointer values we want to use as the sorting criteria but rather what the pointers point to. This requires us to dereference the pointer of the array element in order to access the data of the <code>WORD</code> element in the tree we want to compare.</p>

<p><code>WORD * const *Word1 = vWord1;</code> does a cast of the <code>void *</code> pointer <code>vWord1</code> to be a pointer to a const pointer to a <code>WORD</code>. What this means is that <code>Word1</code> is a pointer, which <code>qsort()</code> uses to point to the item to be sorted, that is a pointer which is <code>const</code> (the array element itself which <code>qsort()</code> does not want you to change) and the <code>const</code> pointer that <code>Word1</code> points to, points to a <code>WORD</code> (the pointer to the tree node which is the data that the array contains).</p>

<p>What each node of the tree contains is a text word along with a count as to how many times that word is found in a sample of text. The <code>qsort()</code> function is being used to sort the nodes of the tree which results from examining the text sample input from most frequent to least frequent. The list of node pointers is what is provided to <code>qsort()</code>.</p>

<p>So the sort is not sorting the array based on the array values but rather sorting based on what the array values, tree node pointers, point to.</p>

<p>By the way When I try a sample compile, I am seeing a warning <code>warning C4090: 'initializing': different 'const' qualifiers</code> with Visual Studio 2015 for the lines:</p>

<pre><code>WORD * const *Word1 = vWord1;
WORD * const *Word2 = vWord2;
</code></pre>

<p>However with the following change the compiler warning goes away:</p>

<pre><code>const WORD * const * Word1 = vWord1;
const WORD * const * Word2 = vWord2;
</code></pre>

<p>This change is actually in line with what <code>qsort()</code> is asking, that none of the data should be changed whether the pointer from the array element or the data that the pointer from the array element points to.</p>

<p>Anyway, the expression <code>(*Word1)-&gt;Count</code> is taking the pointer to the array element provided by <code>qsort()</code>, dereferencing it to get the pointer to the tree node, and then dereferencing the pointer to the tree node in order to get the member of the <code>WORD</code> struct we want to sort against. The sort uses the frequency count of the words, stored in <code>Count</code> as the sorting criteria.</p>

<p><strong>Addendum topic: Playing with const</strong></p>

<p>A question raised is that with this kind of complex definition, <code>const WORD * const * Word1 = vWord1;</code> what are various ways to generate compiler errors by breaking <code>const</code> and seeing when using <code>const</code> can provide an additional safeguard against inadvertently modifying something that should not be modified.</p>

<p>If we use this definition without the <code>const</code> modifier we would have <code>WORD * * Word1 = vWord1;</code> which means that we have a pointer variable <code>Word1</code> that has a meaning of something like:</p>

<p>Word1 -> ptr -> WORD</p>

<p>where <code>Word1</code> is our pointer variable which points to some unknown pointer which in turn points to a variable of type <code>WORD</code>.</p>

<p>Lets look at several different variations of definitions.</p>

<pre><code>WORD * * Worda = vWord1;         // no const
WORD * * const Wordb = vWord1;   // Wordb is const pointer which points to a non-const pointer which points to a non-const WORD
WORD * const * Wordc = vWord1;   // WordC is a non-const pointer which points to a const pointer which points to a non-const WORD
const WORD * const * Wordd = vWord1;  // Wordd is a non-const pointer which points to a const pointer which points to a const WORD
const WORD * const * const Worde = vWord1;  // Worde is a const pointer which points to a const pointer which points to a const WORD
</code></pre>

<p>In the source code of the question with a definition of <code>WORD * const * Word1 = vWord1;</code> then <code>Word1</code> is a non-const pointer which points to a const pointer which points to a non-const <code>WORD</code>. So lets look at several different kinds of assignments:</p>

<pre><code>Word1 = vWord2;   // replace the value of the pointer Word1, allowed since non-const
(*Word1)++;       // Error: increment value of pointer pointed to by Word1, not allowed since pointer pointed to is const so compiler error
(*Word1)-&gt;Count++;  // increment value of variable pointed to by the pointer pointed to by Word1, allowed since non-const
</code></pre>
",13
59417653,56867545,0,"<p>From a glance at the psudo-code, I see a number of things:</p>

<ul>
<li><p>the first is that it's pseudo-code, which rather hampers our ability to do a full analysis :-) So comments below are based on what I see as most likely options.</p></li>
<li><p>you haven't actually posted the code for <code>get_current_time()</code>, the execution time of that may be irrelevant but that's not <em>necessarily</em> the case. Sometimes timing functions get in the way of accuarte timing.</p></li>
<li><p>the reason I mention that last point is that the outer time calculation will consist of the function calculations itself, the stack setup and teardown, <em>and the inner time calculation.</em> You should probably just run with the outer time to see if the timings are reduced.</p></li>
<li><p>because of the vagaries of code execution, it's often better to time something in a loop and average the time taken. For all we know, the first call may take 250ms and subsequent calls take 1ms.</p></li>
</ul>

<p>If you're really concerned about stack setup and teardown (it's usually not <em>too</em> bad but it's definitely not free and, for very short-lived functions, it can often swamp the execution time of the actual work being done), there are options.</p>

<p>For example, you can choose higher optimisation levels, or force your function inline such as by making it a function macro, assuming you protect against all the usual macro-related issues, of course.</p>
",3
58295428,58295368,2,"<p>In C, what you wrote is the idiomatic code for solving the task.</p>

<p>In languages with try-finally you could use that, and it may or may not be clearer. But C doesn't have this feature.</p>
",1
55641877,55641827,4,"<p>You'd need to implement <a href=""http://c-faq.com/varargs/"" rel=""nofollow noreferrer"">C's variable-length argument list</a> with something like:</p>

<pre><code>int print(const char *format, ...)
{
    va_list arg;
    int     result;
    char   *str;

    va_start(arg, format);
    result = vasprintf(&amp;str, format, arg);
    va_end(arg);

    /// Do something with str.

    return result;
}
</code></pre>

<p>Note: The <code>vasprintf()</code> function is a GNU extensions and is not available in C or POSIX. Yet, it's also available under *BSD. (Thanks @Ctx)</p>
",2
55528290,55528241,6,"<p><code>scanf</code> works off of a line buffer. If the buffer is exhausted, it takes a new line; but if there's still things in the buffer, it does not actually take new input.</p>

<p>Also, <code>scanf</code> consumes exactly what you tell it to. If you want a number, it will consume a number, or fail. The return value of <code>scanf</code> is the number of things that it consumed successfully.</p>

<p>Thus, what happens is, your first <code>scanf</code> reads a new line (since it has nothing in the buffer); if the first character happens to not be a number, it will not consume anything and leave the buffer as is, and return <code>0</code> as ""zero things successfully consumed"". Next time you ask for a number, it will see that same character, and fail again, and again not consume anything. It's like it has this character stuck in its throat.</p>

<p>You can get around it by reading the rest of the buffer on failure, <code>fflush</code>-ing the buffer, reading a string and parsing it yourself... or, since you just need one character, give up <code>scanf</code> and just use <code>getchar</code>.</p>

<p>tl;dr: Don't ignore <code>scanf</code> return value :)</p>
",0
58496610,58496404,0,"<p>If you want to update the pointer you need to pass the address of the pointer, not the contents of it. Your code is allocating a new pointer in the subroutine, but this has no effect on the original pointer. Edited code below - I have not checked that this compiles, but you can see the changes.</p>

<pre><code>int device_num = 0;
int display_devices_size = 3;
DISPLAY_DEVICE* display_devices = (DISPLAY_DEVICE*)malloc(sizeof(DISPLAY_DEVICE) * display_devices_size);

// Pass the ADDRESS of display_devices

get_display_devices(&amp;display_devices,&amp;display_devices_size,&amp;device_num);

// Function takes a pointer to a pointer as the first argument.

DISPLAY_DEVICE* get_display_devices(DISPLAY_DEVICE** display_devices, int* display_devices_size, int* device_num)
{
    DISPLAY_DEVICE d;
    d.cb = sizeof(DISPLAY_DEVICE);
    while (EnumDisplayDevices(NULL, *device_num, &amp;d, 0))
    {
        //After the first call to EnumDisplayDevices DispDev.DeviceString contains graphic card's name.
        //After the second call DispDev.DeviceString contains monitor's name.
        if (*device_num &gt;= *display_devices_size)
        {
            DISPLAY_DEVICE* temp = (DISPLAY_DEVICE*)realloc(*display_devices, (*display_devices_size) * sizeof(DISPLAY_DEVICE) * 2);
            if (temp != NULL)
            {
                *display_devices = temp;
                *display_devices_size = *display_devices_size * 2;
            }
        }
        (*display_devices)[*device_num] = d;
        (*device_num)++;
    }

}
</code></pre>
",2
58496628,58496404,0,"<p>This function does not return a value, so it should be of type <code>void</code>.</p>

<p>When you declare a pointer variable (in this case, DISPLAY_DEVICE*), the memory that is allocated for it is sizeof(DISPLAY_DEVICE*), not sizeof(DISPLAY_DEVICE).  This memory is what is referred to by the name 'display_devices' in the caller.</p>

<p><code>realloc</code> can change the address pointed to (if it can't resize the argument memory block, it allocates new memory and deallocates the old memory).  As a result, this function should take a pointer to what is referred to as 'display_devices' in the caller, so that it can change that memory location.</p>

<p>The function prototype should be:</p>

<p><code>void get_display_devices(DISPLAY_DEVICE** display_devices, int* display_devices_size, int* device_num)</code></p>

<p>and it should be called as</p>

<p><code>get_display_devices(&amp;display_devices,&amp;display_devices_size,&amp;device_num);</code></p>

<p>In addtion, all references to 'display_devices' in the called function should be changed to *display_devices, to dereference the value of that memory location to the new allocation.  All the references to display_devices_size should stay the same.</p>

<p>n.b.: I'm not even approaching what the function is supposed to do, I'm only answering the question you asked about the pointer manipulation.  It appears that you will need a lot more work on it before you get it to do what you want it to.</p>
",1
54814703,54814597,18,"<p>Computers generally use <em>cache</em> to help speed up access to main memory.</p>

<p>The hardware usually used for main memory is relatively slow¡ªit can take many processor cycles for data to come from main memory to the processor. So a computer generally includes a smaller amount very fast but expensive memory called cache. Computers may have several levels of cache, some of it is built into the processor or the processor chip itself and some of it is located outside the processor chip.</p>

<p>Since the cache is smaller, it cannot hold everything in main memory. It often cannot even hold everything that one program is using. So the processor has to make decisions about what is kept in cache.</p>

<p>The most frequent accesses of a program are to consecutive locations in memory. Very often, after a program reads element 237 of an array, it will soon read 238, then 239, and so on. It is less often that it reads 7024 just after reading 237.</p>

<p>So the operation of cache is designed to keep portions of main memory that are consecutive in cache. Your <code>sum1</code> program works well with this because it changes the column index most rapidly, keeping the row index constant while all the columns are processed. The array elements it accesses are laid out consecutively in memory.</p>

<p>Your <code>sum2</code> program does not work well with this because it changes the row index most rapidly. This skips around in memory, so many of the accesses it makes are not satisfied by cache and have to come from slower main memory.</p>

<p>Related Resource: <a href=""https://eli.thegreenplace.net/2015/memory-layout-of-multi-dimensional-arrays/"" rel=""noreferrer"">Memory layout of multi-dimensional arrays</a></p>
",1
54816762,54814597,1,"<p>To expand on the other answers that this is due to cache-misses for the second program, and assuming that you are using Linux, *BSD, or MacOS, then Cachegrind may give you enlightenment. It's part of valgrind, and will run your program, without changes, and print the cache usage statistics. It does run very slowly though. </p>

<p><a href=""http://valgrind.org/docs/manual/cg-manual.html"" rel=""nofollow noreferrer"">http://valgrind.org/docs/manual/cg-manual.html</a></p>
",0
54814723,54814597,25,"<p>C uses <em>row-major ordering</em> to store multidimensional arrays, as documented in <a href=""https://port70.net/~nsz/c/c11/n1570.html#6.5.2.1p3"" rel=""nofollow noreferrer""><strong>&sect; 6.5.2.1</strong> <em>Array subscripting, paragraph 3</em></a> of the C Standard:</p>

<blockquote>
  <p>Successive subscript operators designate an element of a multidimensional array object. If E is an n-dimensional array (n >= 2) with dimensions i x j x . . . x k, then E (used as other than an lvalue) is converted to a pointer to an (n - 1)-dimensional array with dimensions j x . . . x k. If the unary * operator is applied to this pointer explicitly, or implicitly as a result of subscripting, the result is the referenced (n - 1)-dimensional array, which itself is converted into a pointer if used as other than an lvalue. <strong>It follows from this that arrays are stored in row-major order (last subscript varies fastest).</strong></p>
</blockquote>

<p>Emphasis mine.</p>

<p>Here's an image from <a href=""https://en.wikipedia.org/wiki/Row-_and_column-major_order"" rel=""nofollow noreferrer"">Wikipedia</a> that demonstrates this storage technique compared to the other method for storing multidimensional arrays, <em>column-major ordering</em>:</p>

<p><a href=""https://i.stack.imgur.com/Z1NAT.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/Z1NAT.png"" alt=""row and column major ordering""></a></p>

<p>The first function, <code>sum1</code>, accesses data consecutively per how the 2D array is actually represented in memory, so the data from the array is already in the cache. <code>sum2</code> requires fetching of another row on each iteration, which is less likely to be in the cache.</p>

<p>There are some other languages that use column-major ordering for multidimensional arrays; among them are R, FORTRAN and MATLAB. If you wrote equivalent code in these languages you would observe faster output with <code>sum2</code>.</p>
",1
52183229,52183191,7,"<p>Maybe you meant to work with hexadecimal numbers :</p>

<pre><code>uint8_t ui8[2]; // uint8_t array
ui8[0] = 0x70; // LSB
ui1[1] = 0x60; // MSB

uint16_t ui16 = ui8[1] | (ui8[0] &lt;&lt; 8);
printf(""%x\n"", ui16); // 7060
</code></pre>

<hr>

<p>If you want to work with decimal number, when you need to multiply the ""MSB"" by 100 and add them. It's far more uncommon to work with decimal number for that.</p>

<pre><code>uint8_t ui8[2]; // uint8_t array
ui8[0] = 70; // LSB
ui1[1] = 60; // MSB

uint16_t ui16 = ui8[1] + (ui8[0] * 100);
printf(""%d\n"", ui16); // 7060
</code></pre>

<hr>

<p>Please not than in both case, ""70"" will be before the ""60"", because you're shifting the first element of the array (70). The 70 will be the MSB.</p>
",1
56115018,56114764,2,"<p>Your problem is in the line <code>char word[20];</code> and the way <code>scanf</code> reads words. From <code>scanf</code>'s point of view, a word is any sequence of non-spaces. For example, <code>realloc(longest,strlen(word)+1);</code> is treated as one word, and that alone is longer than 20 characters. </p>

<p>You should use a more robust function to read words and allocate space for them. The most cost-efficient solution is <code>getline()</code> for reading the line followed by <code>strsep()</code> for extracting words.</p>
",0
53854707,53854645,4,"<p>Your <code>fwrite</code> is trying to write to <code>in</code>, not <code>arch</code>. Since you don't check the return value of <code>fwrite</code>, this error (trying to write to a file that's opened for read) is undetected.</p>
",3
50702723,50702173,1,"<p>This line:</p>

<pre><code>int status = fscanf(file, ""%s"", curr_username);
</code></pre>

<p>Writes data to <code>curr_username</code> which is not initialised and has no defined storage space or address.  The consequence is non-deterministic such that even apparently unrelated code changes can change the behaviour.  The behaviour following this invalid memory access will depend on what memory/address is accessed and how that memory is subsequently used.  </p>

<p>The behaviour is undefined and non-deterministic, but typically you will see:</p>

<ul>
<li>a memory fault exception and crash, </li>
<li>errant behaviour in other unrelated code, </li>
<li>code appearing to work normally (latent bug).  </li>
</ul>

<p>In your case you have observed the latter two of these.</p>

<p>In this line:</p>

<pre><code>if (!curr_username || status == EOF)
</code></pre>

<p>testing <code>curr_username</code> for null makes no sense - <code>scanf</code> does not modify the pointer.  One might guess that the addition of the new variable caused <code>curr_username</code> to be instantiated in memory that happened in this case to contain zero, so the condition becomes true, whereas previously it contained a non-zero value that just happened to be a writable memory address.</p>
",0
48837712,48837684,5,"<p>Could it be as simple as this? You will want to use a simple increment operator (<strong>+=</strong>), to increment the variable <code>sum</code>.</p>

<pre><code>int main(void)
{
    int n, i, sum = 0;
    if( scanf(""%d"", &amp;n)!= 1){
        fprintf(stderr,""Error in input\n"");
        exit(EXIT_FAILURE);
    }

    for(i = 1; i &lt; n; i++)
    {
        if(n % i == 0)
        {
            printf(""%d\n"", i);
            sum += i;
        }
    }
    printf(""Sum of divisors: %d\n"", sum);
    return 0;
}
</code></pre>
",1
49155153,49154655,2,"<p>The solution is to print no plus sign in front of the first number, and to print a plus sign in front of all other numbers. To achieve this I am using a boolean with false/true values.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int is_prime(int m)
{
    int i;
    for(i=2; i&lt;=m/2; i++)
    {
        if (m % i==0)
        {
            return 0;
        }

    }
    return 1;
}
int main()
{
    int num, min, max, sum = 0;
    scanf(""%d"", &amp;min);
    scanf(""%d"", &amp;max);
    bool first = true;
    for(num = min; num &lt;= max; num++)
    {
        if(is_prime(num))
        {
            sum += num;
            if(!first) 
            {
                printf(""+"");
            }
            printf(""%d"", num);
            first = false;
        }

    }
    printf(""=%d\n"", sum);
    return 0;
 }
</code></pre>

<p>This code also works with using an integer instead of a boolean: <code>int first = 1;</code> and <code>first = 0;</code></p>
",1
50295423,50295207,4,"<pre><code>malloc(sizeof(int)*n);
</code></pre>

<p>This allocates place for <code>n</code> <code>int</code>s, starting with index <code>0</code>, the last valid one at index <code>n - 1</code>.</p>

<pre><code>    for(i=2; i&lt;=n; i++)
    {
        a[i]=i;
</code></pre>

<p>This writes to indexes <code>2..n</code>, which includes <code>n</code>, which is outside the bounds of the array.</p>

<p>The same also happens in</p>

<pre><code>        for(j=2; i*j&lt;=n; j++)
        {
            a[i*j]=0;
</code></pre>

<p>if <code>n</code> is divisible by <code>i</code></p>
",0
55698942,55698635,1,"<p>Given the source below, I get the output:</p>

<pre><code>cpu_list[0] is 0
cpu_list[1] is 0
cpu_list[0] is 5 in not_main function 
cpu_list[1] is 7 in not_main function 
cpu_list[0] is 5
cpu_list[1] is 7
</code></pre>

<p>The key changes are moving the definition of <code>cpu_list</code> to file scope in <code>fileA.c</code>, and not recursing in <code>not_main()</code>, and printing the values again in <code>main()</code> after <code>not_main()</code> returns.  A minor change is losing <code>j</code>; it was not providing any value as it was just a copy of <code>i</code>.</p>

<p>Note that it is important (I'm tempted to say 'crucial') that both <code>fileA.c</code> and <code>fileB.c</code> include the header.  That gives you the cross-checking that's necessary to ensure that both the array and the function are defined and declared consistently.</p>

<h3><code>my_files.h</code></h3>

<pre><code>extern int cpu_list[];
extern int not_main(void);
</code></pre>

<h3><code>fileA.c</code></h3>

<pre><code>#include &lt;stdio.h&gt;
#include ""my_files.h""

int cpu_list[2];

int not_main(void)
{
    int i;
    for (i = 0; i &lt; 2; i++)
    {
        cpu_list[i] = 2 * i + 5;
    }

    printf(""cpu_list[0] is %d in not_main function \n"", cpu_list[0]);
    printf(""cpu_list[1] is %d in not_main function \n"", cpu_list[1]);

    return 0;
}
</code></pre>

<h3><code>fileB.c</code></h3>

<pre><code>#include &lt;stdio.h&gt;
#include ""my_files.h""

int main(void)
{
    printf(""cpu_list[0] is %d\n"", cpu_list[0]);
    printf(""cpu_list[1] is %d\n"", cpu_list[1]);

    not_main();

    printf(""cpu_list[0] is %d\n"", cpu_list[0]);
    printf(""cpu_list[1] is %d\n"", cpu_list[1]);

    return 0;
}
</code></pre>
",0
49052740,49051598,0,"<p>To convert a number formatted as string in base 2 (""binary"") to an actual integer, use <a href=""https://linux.die.net/man/3/strtoul"" rel=""nofollow noreferrer""><code>strtoul()</code></a>:</p>

<pre><code>const unsigned long x = strtoul(""11100011"", NULL, 2);
printf(""x=%lu\n"", x);
</code></pre>

<p>The final <code>2</code> there specifies the base, and <code>2</code> of course gives binary, and this prints <code>227</code>.</p>
",0
49053010,49051598,0,"<p>As already mentioned in other answers, the core problem is that you don't null terminate the string. But there's various other bad practice in this program:</p>

<ul>
<li><a href=""https://stackoverflow.com/a/46563868/584518"">The atoi() family of functions should never be used for any purpose</a>, since they have no error handling.</li>
<li>Never use bitwise operators on signed numbers or signed integer constants. <code>1</code> is a signed type, for example. Code like <code>1&lt;&lt;15</code> will invoke undefined behavior on 8 and 16 bit CPUs.</li>
</ul>

<p>A corrected program might look like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main (void)
{
  unsigned int c = 100;

  char test[8+1];

  for(size_t i=0; i&lt;8; i++)
  {
    test[i] = c &amp; (1u&lt;&lt;(8-1-i)) ? '1' : '0';
  }
  test[8] = '\0';

  int j = (int)strtol(test, NULL, 10);
  printf(""%.8d\n"", j);

  return 0;
}
</code></pre>

<p>Or if you live and breathe C language operator precedence (major nerd warning), you could be cocky and just write <code>test[i] = c &amp; 1u &lt;&lt; 8-1-i ? '1' : '0';</code>. As the operator precedence here is: <code>-</code>, <code>&lt;&lt;</code>, <code>&amp;</code>, <code>?:</code>, <code>=</code>.</p>
",0
54480791,54478448,0,"<p>It depends on the regex implementation you're using. Here's an example using POSIX extended regular expressions that simply checks the return value of <a href=""https://pubs.opengroup.org/onlinepubs/9699919799/functions/regcomp.html"" rel=""nofollow noreferrer""><code>regcomp</code></a> and prints an error message obtained with <code>regerror</code>:</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;regex.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void test(const char *regex) {
&#9;regex_t preg;
&#9;int errcode = regcomp(&amp;preg, regex, REG_EXTENDED);
&#9;if (errcode == 0) {
&#9;&#9;printf(""%s =&gt; Success\n"", regex);
&#9;&#9;regfree(&amp;preg);
&#9;}
&#9;else {
&#9;&#9;char errmsg[80];
&#9;&#9;regerror(errcode, NULL, errmsg, 80);
&#9;&#9;printf(""%s =&gt; %s\n"", regex, errmsg);
&#9;}
}

int main() {
&#9;test(""(*\\.com)"");
&#9;test(""(.*\\.com)"");
&#9;return 0;
}
</code></pre>

<p><a href=""https://tio.run/##XZBda4MwFIavza84ODpiseJlobNXld2UXuyDDeYoEo82oIkkcQxG//pcktpu3V148p7nPQlbNIyN4w0XrB0qhDuFDX4mhzX5RdpUXP5HiovGMfIheQUGtaFMCm2AHUoFc6@J4IsE/rQ30NvDigRcGEClmLSaDCxjsuvprbuNwWdjeMjv9/nrU77b5JvIzdRALzMZpN4b9HYFU9NwpiFbw@PAGGpdiHDSuEFXXivEk9@RIwmw1egFflPr7XTztkzfp7wFUp3rYtg9b7fxlIphmXrtdfXsT@s5euo6EuLe25VcUL@0/6eQzosise@OQhebWHIFFZpBCUhX5DiO36xuy0aPi5eybX8A"" rel=""nofollow noreferrer"" title=""C (gcc) ¨C Try It Online"">Try it online!</a></p>

<p>This should print something like:</p>

<pre class=""lang-none prettyprint-override""><code>(*\.com) =&gt; Invalid preceding regular expression
(.*\.com) =&gt; Success
</code></pre>

<p>Note that <code>(*\.com)</code> is a valid POSIX <em>basic</em> regex since an unescaped <code>(</code> matches a literal <code>(</code>. With basic regexes, a <code>*</code> at the beginning of a regex or parenthesized subexpression also matches a literal <code>*</code>.</p>
",1
51373271,51373162,5,"<p>Basically you are mixing integer values and char values.  In <code>itob</code> you are storing each digit as a number &lt; base, not as an actual character, with the line <code>string[i] = value % base;</code>.  For known base &lt;= 10 that line should be changed to <code>string[i] = '0' + value % base</code>.  Or for base &lt;= 36 you could change that to the two lines <code>static char chars[] = ""0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ""; string[i] = chars[value % base]</code>.  Either way make sure to check that base is in range before proceeding.</p>

<p>Then you must change the second %d in your printf to %c  to denote that you are printing a char.</p>

<p>Also note the number will be stored little-endian, least significant digit first.</p>

<p>Edit: Also change <code>string[++i] = '\0'</code> to <code>string[i] = '\0'</code> because <code>i</code> is already pointing to the index after all of the appended characters.</p>
",2
50522398,50521910,4,"<p>The unusual data structure in the arrays allows for some optimization.  While you're dealing with the ranges (pairs of values) identified by <code>arr[0]</code>, you need only test the first element of the pair against the minimum and the second element against the maximum.  When you're dealing with the non-range values, you have to check each element against both minimum and maximum.</p>

<p>That leads to code such as the following:</p>

<pre><code>#undef NDEBUG
#include &lt;assert.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;

static void find_min_max(size_t num, uint32_t arr[num], uint32_t *pmin, uint32_t *pmax)
{
    assert(arr != 0 &amp;&amp; pmin != 0 &amp;&amp; pmax != 0 &amp;&amp; num &gt; 1);
    assert(arr[0] &lt;= num);
    assert(arr[0] == 0 || num &gt; 2);

    uint32_t max = arr[1];
    uint32_t min = arr[1];
    uint32_t lim = arr[0] * 2;
    size_t i;

    for (i = 1; i &lt; lim; i += 2)
    {
        assert(arr[i] &lt;= arr[i + 1]);
        if (arr[i] &lt; min)
            min = arr[i];
        if (arr[i + 1] &gt; max)
            max = arr[i + 1];
    }

    for ( ; i &lt; num; i++)
    {
        if (arr[i] &lt; min)
            min = arr[i];
        else if (arr[i] &gt; max)
            max = arr[i];
    }
    *pmin = min;
    *pmax = max;
}

static void test_min_max(const char *tag, size_t num, uint32_t arr[num])
{
    uint32_t lim = arr[0] * 2;
    size_t i;

    printf(""%s (%zu):\n"", tag, num);
    for (i = 1; i &lt; lim; i += 2)
        printf(""  Range %zu: %"" PRIu32 ""..%"" PRIu32 ""\n"", i / 2, arr[i], arr[i + 1]);
    while (i &lt; num)
        printf(""  Value: %"" PRIu32 ""\n"", arr[i++]);

    uint32_t min;
    uint32_t max;
    find_min_max(num, arr, &amp;min, &amp;max);

    printf(""%s: min = %"" PRIu32 "", max = %"" PRIu32 ""\n"", tag, min, max);
}

int main(void)
{
    uint32_t arr1[] = { 2, 34, 78, 5, 10, 100 };
    uint32_t arr2[] = { 1, 18, 39, 2 };
    uint32_t arr3[] = { 0, 14, 5, 256, 99 };
    uint32_t arr4[] = { 2, 9, 14, 5, 256 };
    uint32_t arr5[] = { 2, 9, 14, 5, 256, 2 };
    uint32_t arr6[] = { 2, 9, 14, 5, 256, 379 };
    uint32_t arr7[] = { 0, 9, };
    uint32_t arr8[] = { 1, 9, 9 };

    test_min_max(""arr1"", sizeof(arr1) / sizeof(arr1[0]), arr1);
    test_min_max(""arr2"", sizeof(arr2) / sizeof(arr2[0]), arr2);
    test_min_max(""arr3"", sizeof(arr3) / sizeof(arr3[0]), arr3);
    test_min_max(""arr4"", sizeof(arr4) / sizeof(arr4[0]), arr4);
    test_min_max(""arr5"", sizeof(arr5) / sizeof(arr5[0]), arr5);
    test_min_max(""arr6"", sizeof(arr6) / sizeof(arr6[0]), arr6);
    test_min_max(""arr7"", sizeof(arr7) / sizeof(arr7[0]), arr7);
    test_min_max(""arr8"", sizeof(arr8) / sizeof(arr8[0]), arr8);

    return 0;
}
</code></pre>

<p>When run, it produces the output:</p>

<pre><code>arr1 (6):
  Range 0: 34..78
  Range 1: 5..10
  Value: 100
arr1: min = 5, max = 100
arr2 (4):
  Range 0: 18..39
  Value: 2
arr2: min = 2, max = 39
arr3 (5):
  Value: 14
  Value: 5
  Value: 256
  Value: 99
arr3: min = 5, max = 256
arr4 (5):
  Range 0: 9..14
  Range 1: 5..256
arr4: min = 5, max = 256
arr5 (6):
  Range 0: 9..14
  Range 1: 5..256
  Value: 2
arr5: min = 2, max = 256
arr6 (6):
  Range 0: 9..14
  Range 1: 5..256
  Value: 379
arr6: min = 5, max = 379
arr7 (2):
  Value: 9
arr7: min = 9, max = 9
arr8 (3):
  Range 0: 9..9
arr8: min = 9, max = 9
</code></pre>

<p>Whether this more complicated code really buys significant efficiency over simply scanning the values (as shown in the question) is debatable ¡ª or measurable, but the measurement requires vastly bigger numbers of elements in the arrays to be detectable.  On the array sizes shown, there'll be essentially no measurable difference.</p>
",6
49662483,49662387,4,"<p>The main issue you're running into is that <code>void*</code> pointer does not carry any information along with it about the type of data at the end of a pointer. An <code>int*</code> pointer or a pointer to an object instance would carry additional information. However the compiler doesn't know how big the object is at the other end of the pointer, nor does it know how to dereference the pointer.</p>

<p>Instead, you need to do something like the following:</p>

<pre><code>void* ptr = malloc(100);
memset(ptr, 0, 100); // sizeof(ptr) == 4 or 8 (32-bit or 64-bit), so you can't use sizeof() here
int* iptr = (int*)ptr; // We tell the compiler that the values at the end of the pointer should be interpreted as integers
for(int i = 0; i &lt; 100; i++) {
    assert(iptr[i] == 0);
}
</code></pre>

<h2>Edit</h2>

<p>It occurred to me after posting this that <code>int</code> is more than 1 byte, so this would actually assert on too many bytes. You only allocated 100, and we're checking 400 here.</p>

<p>Instead of converting your <code>void*</code> to an <code>int*</code>, you should convert to a <code>char*</code> or similar 1-byte type (or have the for loop only run from 0 to 25 -- but that's just confusing)</p>

<h2>Edit 2 - A Quick Lesson on Pointers</h2>

<p>I realize upon looking at my code and the code others have posted that most colleges do a terrible job of teaching pointers, which leads to a lot of confusion. So I thought this minor addendum might help.</p>

<p>First, the basics: You probably already know that data is written to RAM. Normally WHERE it's written in RAM isn't <strong><em>too</em></strong> important, so long as you remember where it is. If I were keeping a running sum in the 103rd ""slot"" in memory, then I just have to remember to keep adding to the 103rd slot. When you name a variable in C/C++, the compiler picks a random and unused space in memory. You're effectively creating a human-readable name for that space. So if I say <code>int a = 5;</code>, the compiler picks a random spot in memory (maybe the 78th slot) and then whenever I say <code>a</code> in my code, the compiler knows that I'm referring to the 78th slot in memory.</p>

<p>Note that the <strong>compiler</strong> knows I'm referring to the 78th slot in memory. This means that the <code>a</code> in my source code gets replaced with a reference to the 78th slot in memory when the code is compiled, and the actual assembly code that is produced looks something like:</p>

<pre><code>// Code:
int a = 5;
a = a + 1;
int b = a;

// Compiles to (this may be invalid x86 assembly - it just serves as an example):
mov 78, 5 -- move the value ""5"" to memory address 78
add [78], 1, 78 -- add the value stored in memory address 78 and 1, then store the result in memory address 78
mov 79, [78] -- move the value stored in memory address 78 to memory address 79
</code></pre>

<p>Notice how the compiled code references memory addresses directly. This is what the compiler saves us from by allowing us to assign a name to a variable.</p>

<p>With a <strong>pointer</strong>, instead of storing data into RAM, we store a memory address into RAM - then we have to check this memory address to find the real data. It would be like if you went to your friend's house at 123 Street Road and found a note on the door saying ""Sorry, I moved. You can find me at 987 Boulevard Avenue"". So then you go to 987 Boulevard Avenue and have a fun party with your friend. Because that's his <strong>real</strong> address.</p>

<p>There are many reasons we might use a pointer. I'll gloss over the possible reasons for using them, because all that matters is that you know what they do and how they work. So when we create a pointer, once again the compiler is keeping track of a slot in memory and we're giving it a human readable name. So when you say <code>int* a = new int;</code>, the compiler picks a random unused spot in memory (maybe the 823rd slot) and whenever you say <code>a</code> in your code, the compiler knows that you're referring to the 823rd slot. <strong>However</strong>, what's actually stored in the 823rd slot is <strong>not</strong> the integer you're looking for -- it's a memory address where you can find the integer you really want.</p>

<p>There are three helpful operators to remember when dealing with pointers:</p>

<ul>
<li><code>*</code>: The indirection operation (which I recently learned is also called the dereference operator). This tells the compiler ""follow the pointer"". So if you had an <code>int*</code> called <code>a</code> then <code>*a</code> would say ""what is the value of the integer located in the memory address stored in a?"" (confusing, I know)</li>
<li><code>&amp;</code>: I guess this would be called the ""reference"" operator? I always just called it the ""memory address operator"". If you pass a variable to this operator, it will return the location in memory where that variable is stored. This is useful if you want to create a pointer to a variable you already have</li>
<li><code>[]</code>: The offset operator. This tells the compiler that instead of going to the memory location referenced in the pointer, go to a place in memory <strong>just past</strong> that. It'd be like if you look at that ""just moved"" note at your friend's house and instead of visiting his new house, you went to the house 3 doors down. This is very useful when dealing with arrays. We store 20 integers in memory in a row. You have a pointer to the first integer, and all others integers are just an offset from that first one (<code>[1]</code> is a single integer after the starting one, <code>[2]</code> is two integers after the starting one, etc)</li>
</ul>

<p>Note that the offset operator can only work if it knows the size of the object at the end of the pointer. <code>[1]</code> means to go one byte further in memory if you're pointing to an array of 1-byte objects. <code>[1]</code> means to go 8 bytes further in memory if you're pointing to an array of 8-byte objects. This is why <code>int*</code> and <code>long*</code> are different. They're both pointers (so they're both just an integer pointing to a place in memory) but when you use the offset operator the compiler will jump different amounts based on the type of variable.</p>

<p><code>void*</code>, on the other hand, has <strong>no</strong> type information. You're literally telling the compiler that it should have no clue what's at the other end of that pointer. There are times when this is useful, but it generally just makes code harder since it takes all of the work the compiler does for you and forces the programmer to do it.</p>
",0
49662547,49662387,0,"<p><code>ptr == 0</code> checks whether the pointer is pointing to <code>NULL</code>, it doesn't check
whether the contents pointed to by <code>ptr</code> are 0. So you have to check byte by byte if
the contents are 0.</p>

<p>The second problem is:</p>

<pre><code>memset(ptr, 0, sizeof(ptr));
</code></pre>

<p><code>sizeof</code> does <strong>not</strong> return the amount of bytes you've allocated, it returns
the size of a pointer. In you case you are only setting the first 8 bytes to 0
(assuming that on your target architecture the size of a pointer is 8).</p>

<p>You have to do</p>

<pre><code>memset(ptr, 0, 100);
</code></pre>

<p>Because you only have a <code>void*</code> pointer, you would need to cast it to <code>char*</code> or
<code>unsigned char*</code> for processing the values. You are only checking against 0, so in this case 
signed/unsigned doesn't matter. You have to do:</p>

<pre><code>// avoid hardcoding numbers, use variables instead
size_t len = 100;

void *ptr = malloc(len);

if(ptr == NULL)
{
    fprintf(stderr, ""Not enough memory\n"");
    return 0; // or whatever, do not continue
}

memset(ptr, 0, len);

char *base = ptr;
for(size_t i = 0; i &lt; len; ++i)
{
    // checking byte by byte if 0
    assert(base[i] == 0);
}
</code></pre>
",0
55701714,55700148,0,"<p>The basic idea is to use a frequency table, which stores how often each character appears in the input. This happens in the first part of the below code.</p>

<p>In the second half, the code prints how often each of the interesting characters appears. This part does NOT assume that the letters appear in a single block in the character set. Therefore it also works on EBCDIC computers. It calculates the sum of the uppercase and lowercase frequencies and outputs that.</p>

<pre><code>#include &lt;studio.h&gt;

int main(void) {

    int freq[256] = {0};    // initializes the whole array to 0; only works with 0

    int ch;
    while ((ch = fgetc(stdin)) != EOF) {
        freq[ch]++;
    }

    const char *upper = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    const char *lower = ""abcdefghijklmnopqrstuvwxyz"";

    for (int i = 0; upper[i] != '\0') {
        fprintf(""character %c appears %5d times\n"",
            upper[i],
            freq[upper[i]] + freq[lower[i]]);
    }
}
</code></pre>
",0
59429825,59429136,4,"<p>The term ""signed <code>size_t</code>"" is used informally, and does not appear in the language standard. In fact it would be a syntax error if you tried to use it in C code.</p>

<p>The C standard says that the <code>z</code> length modifier:</p>

<blockquote>
  <p>Specifies that a following <strong><code>d</code></strong>, <strong><code>i</code></strong>, <strong><code>o</code></strong>, <strong><code>u</code></strong>, <strong><code>x</code></strong>, or <strong><code>X</code></strong> conversion specifier
  applies to a <strong><code>size_t</code></strong> or the corresponding signed integer type argument;
  or that a following <strong><code>n</code></strong> conversion specifier applies to a pointer to a
  signed integer type corresponding to <strong><code>size_t</code></strong> argument.</p>
</blockquote>

<p>There is no portable way to determine what that corresponding signed integer type is. Even the POSIX-specific <code>ssize_t</code> type (defined in <code>&lt;sys/types.h&gt;</code>) is not specified to be the signed type corresponding to <code>size_t</code>. And as chux points out in a comment, it might make sense in some implementations for <code>ssize_t</code> to be wider than <code>size_t</code>, so it can represent all values up to <code>SIZE_MAX</code> (plus, of course, negative values).</p>

<p>In practice, <code>size_t</code> will usually be a typedef for one of the predefined unsigned integer types, <code>unsigned int</code>, <code>unsigned long int</code>, or <code>unsigned long long int</code>, and <code>%zd</code> would then require an argument of type <code>int</code>, <code>long int</code>, or <code>long long int</code>, respectively. It's also possible that <code>size_t</code> is defined in terms of some <em>extended integer type</em>.</p>

<p>My guess is that the authors of the standard simply didn't want to go to the effort of specifying that the <code>z</code> length modifier applies only to a signed type. Doing so would have added complexity with no real benefit. If you're using a POSIX-conforming implementation, you can <em>probably</em> use <code>%zd</code> to print a value of type <code>ssize_t</code>.</p>

<p>There's no portable use for <code>%zd</code>, but having it there in <code>printf</code> is harmless, and probably easier than not having it there.</p>
",5
59429471,59429136,4,"<p>The exact type of a ""signed <code>size_t</code>"" is implementation-defined and AFAIK, there's no standard way to get the type. So I don't see a way to use <code>%zd</code> portably. On most platforms, <code>ptrdiff_t</code> should be the signed version of <code>size_t</code>, but this isn't guaranteed. In fact, there's a <code>t</code> format modifier for <code>ptrdiff_t</code> which can also be used with a <code>u</code> specifier like <code>%tu</code>, meaning an ""unsigned <code>ptrdiff_t</code>"". I think these combinations are only for completeness and don't have a practical use.</p>
",0
49756251,49756150,7,"<p>The first two values are single-precision floating-point values, and the final one is a double-precision value. If you print them with more decimals you will see the difference, for example like this:</p>

<pre><code>0.3176470696926116943359375000000000000000000000000000000000000000000000
0.3176470696926116943359375000000000000000000000000000000000000000000000
0.3176470588235293934786795944091863930225372314453125000000000000000000
</code></pre>

<p>Remember that the standard floating-point type in C is double, not float. A floating-point constant, such as your <code>255.</code>, has the type double, not float. So the final argument to printf, <code>a/255.</code>, will be calculated using double precision, and sent to printf as a double. The variables <code>value_1</code> and <code>value_2</code> are of type float, and even though they are converted to double when sent to printf, they have fewer binary digits.</p>
",0
58274005,58273851,0,"<p>Your WDT is a so-called special function register. In hardware, it may end up being three bytes, or it could be four bytes, some of which are fixed/read-only/unused. Your compiler's implementation of the write is itself implementation-dependent if the SFR is declared in a particular way that makes the compiler emit SFR-specific write instructions.</p>

<p>This effectively makes the result of the assignment implementation-dependent; the high eight bits might end up being discarded, might set some other microarchitectural flags, or might cause a trap/crash if they aren't set to a specific (likely all-zeros value). It depends on the processor's datasheet (since you didn't mention a processor/toolchain, we don't know exactly).</p>

<p>For example, the AVR-based atmega328p datasheet shows an example of such a register:</p>

<p><a href=""https://i.stack.imgur.com/KgmEr.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/KgmEr.png"" alt=""enter image description here""></a></p>

<p>In this case, the one-byte register is actually only three bits, effectively (bits 7..3 are fixed to zero on read and ignored on write, and could very well have no physical flip-flop or SRAM cell associated with them).</p>
",0
57154391,57152013,2,"<p>The bits of the <code>flag</code> member are assigned more meanings than just <code>_READ</code> (<code>01</code>), <code>_EOF</code> (<code>010</code>, which is octal for 8), and <code>_ERR</code> (<code>020</code>, 16). There are also <code>_WRITE</code> (<code>02</code>) and <code>_UNBUF</code> (<code>04</code>).</p>

<p>Kernighan and Ritchie¡¯s code, <code>(fp-&gt;flag &amp; (_READ | _EOF | _ERR )) != _READ</code>, is true if and only if <code>_READ</code> is clear, <code>_EOF</code> is set, or <code>_ERR</code> is set.</p>

<p>Your code, <code>fp-&gt;flag != _READ</code>, is true if and only if <code>_READ</code> is clear, <code>_EOF</code> is set, <code>_ERR</code> is set, <code>_WRITE</code> is set, or <code>_UNBUF</code> is set.</p>

<p>Thus, for example, if <code>_UNBUF</code> is set while <code>_READ</code> is set, <code>_EOF</code> is clear, and <code>_ERR</code> is clear, the Kernighan and Ritchie code will evaluate to false but your code will evaluate to true. The Kernighan and Ritchie code asks only about three flags and does not care about the other flags. Your code is affected by all the flags.</p>
",1
51279565,37841617,3,"<p>It's a safe bet that, even though the error message <em>mentions</em> <code>C99</code>, you are in fact using a compiler following a <em>later</em> standard, one in which <code>gets</code> was <em>removed</em> rather than just deprecated.</p>
<p>For example, when I try to compile the following simple program:</p>
<pre><code>#include &lt;stdio.h&gt;
char buff[1000];
int main(void) {
    gets(buff);
    return 0;
}
</code></pre>
<p>with <code>clang</code> under Ubuntu 18.04:</p>
<pre><code>clang -Werror --std=c11 -o qq qq.c
</code></pre>
<p>I get that <em>same</em> error:</p>
<pre><code>qq.c:4:2: error: implicit declaration of function 'gets' is invalid in C99
                 [-Werror,-Wimplicit-function-declaration]
</code></pre>
<p>This is actually only <em>tangentially</em> related to the deprecation and removal of <code>gets</code> (in that it's no longer declared anywhere). It's more to do with the fact you shouldn't be trying to use <em>any</em> function without an active declaration, as per <code>ISO C99 Foreword /5</code> (paraphrased):</p>
<blockquote>
<p>This second edition cancels and replaces C90, as amended and corrected by various other ISO gumpf. Major changes from the previous edition include:</p>
<ul>
<li><p><em><strong>remove implicit function declaration.</strong></em></p>
</li>
<li><p>lots of other stuff, irrelevant to this question.</p>
</li>
</ul>
</blockquote>
<p>You can see this if you replace <code>gets</code> with <code>xyzzy</code>, which results in the same error:</p>
<pre><code>qq.c:4:2: error: implicit declaration of function 'xyzzy' is invalid in C99
                 [-Werror,-Wimplicit-function-declaration]
</code></pre>
<p>In fact, if you actually try to use <code>gets</code> with the <code>C99</code> flags set, you'll get a totally <em>different</em> message (or none at all if your compiler implements C99 before they deprecated <code>gets</code> - that wasn't done until TC3):</p>
<pre><code>qq.c:4:2: error: 'gets' is deprecated
                 [-Werror,-Wdeprecated-declarations]
</code></pre>
",0
48942447,48942328,2,"<p>Don't use <code>gets</code>. It is <a href=""http://man7.org/linux/man-pages/man3/gets.3.html"" rel=""nofollow noreferrer"">dangerous</a> and obsolete. Use <a href=""http://en.cppreference.com/w/c/io/fgets"" rel=""nofollow noreferrer"">fgets</a> instead. Replace <code>gets(p-&gt;n)</code> with <code>fgets(p-&gt;n, sizeof(p-&gt;n), stdin);</code> and so on.</p>

<p>Don't name your function <code>read</code> (since that is the name of a POSIX standard <a href=""http://pubs.opengroup.org/onlinepubs/009696699/functions/read.html"" rel=""nofollow noreferrer"">function</a>). Replace it by another name, e.g. <code>myread</code>.</p>

<p>You probably want to do:</p>

<pre><code>X *p1=malloc(sizeof(X));
</code></pre>

<p>in your main. Then, you need to check that <code>malloc</code> succeeded:</p>

<pre><code>if (!p1) { perror(""malloc p1""); exit(EXIT_FAILURE); }
</code></pre>

<p>Beware that <code>malloc</code> gives (on success) some <em>uninitialized</em> memory zone. You may want to clear it using <code>memset(p1, 0, sizeof(p1))</code>, or you could use <code>p1 = calloc(1, sizeof(X))</code> instead.</p>

<p>At last you can pass it to your <code>myread</code>:</p>

<pre><code>myread(p1);
</code></pre>

<p>Don't forget to call <code>free(p1)</code> (e.g. near the end of your <code>main</code>) to avoid a <a href=""https://en.wikipedia.org/wiki/Memory_leak"" rel=""nofollow noreferrer"">memory leak</a>.</p>

<p>Learn to use <a href=""http://valgrind.org/"" rel=""nofollow noreferrer"">valgrind</a>, it catches many memory related bugs.</p>

<p>Of course you need to <strong>carefully read the documentation of every standard function</strong> that you use. For example, <a href=""http://man7.org/linux/man-pages/man3/fgets.3.html"" rel=""nofollow noreferrer"">fgets(3)</a> documents that you need to <code>#include &lt;stdio.h&gt;</code>, and that call to <code>fgets</code> can fail (and your code needs to check that, see also <a href=""http://man7.org/linux/man-pages/man3/errno.3.html"" rel=""nofollow noreferrer"">errno(3)</a> &amp; <a href=""http://man7.org/linux/man-pages/man3/perror.3.html"" rel=""nofollow noreferrer"">perror(3)</a>...). Likewise, <a href=""http://man7.org/linux/man-pages/man3/malloc.3.html"" rel=""nofollow noreferrer"">malloc(3)</a> wants <code>#include &lt;stdlib.h&gt;</code> and should be checked. And <a href=""http://man7.org/linux/man-pages/man3/scanf.3.html"" rel=""nofollow noreferrer"">scanf(3)</a> can fail too, and needs to be checked.</p>

<p>You should compile with all warnings and debug info (<code>gcc -Wall -Wextra -g</code> with <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a>), improve your code to get no warnings, and you should <a href=""https://sourceware.org/gdb/current/onlinedocs/gdb/"" rel=""nofollow noreferrer"">use the <code>gdb</code> debugger</a>; you may want to use GCC sanitizers (e.g. <a href=""https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html"" rel=""nofollow noreferrer"">instrumentation options</a> like <code>-fsanitize=address</code>, <code>-fsanitize=undefined</code> and others),</p>

<p>Beware of <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><strong>undefined behavior</strong></a> (UB). It is really <a href=""https://stackoverflow.com/a/46526702/841108"">scary</a>.</p>

<p><sup>PS. I hope that you are using Linux with <code>gcc</code>, since it is a very developer friendly system. If not, adapt my answer to your operating system and compiler and debugging tools.</sup></p>
",3
53950660,53950614,3,"<p>You've declared <code>p3</code> as an array of <em>pointers</em> instead of an array of characters.  You then pass <code>*p3</code> to <code>strcpy</code> which is an uninitialized pointer, which then attempts to dereference the invalid pointer invoking <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>You also haven't given <code>p3</code> space for the null byte at the end of the string <code>c</code>.  </p>

<p>Change <code>p3</code> to a <code>char</code> array and give it an extra byte of space:</p>

<pre><code>char p3[strlen(c)+1];
strcpy( p3, c);
</code></pre>

<p>And change <code>printSummary</code> to match:</p>

<pre><code>void printSummary(int *a, float *b, char c[]) {
    printf(""Summary: \n  A: %d\n  B: %.1f\n  C: %s\n"", *a, *b, c);
}
</code></pre>
",3
48610852,48610819,1,"<pre><code>while (read_bytes = fread(buf, 1, READSIZE, file) == READSIZE || ![...])
</code></pre>

<p>Ignoring the <code>[...]</code> for now, what is happening here is a problem with <a href=""http://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer"">operator precedence</a>. In particular, <code>=</code> has lower precedence than <code>==</code>. So, this:</p>

<pre><code>read_bytes = fread(buf, 1, READSIZE, file) == READSIZE
</code></pre>

<p>Is the same as:</p>

<pre><code>read_bytes = (fread(buf, 1, READSIZE, file) == READSIZE)
</code></pre>

<p>Which basically says ""set the value of <code>read_bytes</code> to 1 if <code>READSIZE</code> bytes were read, 0 otherwise."" What you probably wanted was:</p>

<pre><code>(read_bytes = fread(buf, 1, READSIZE, file)) == READSIZE
</code></pre>

<p>But I would discourage this because of the kind of bugs it can introduce, like what happened in your case.</p>

<p>And back to the <code>![...]</code>. <code>||</code> also has a higher precedence than <code>=</code> ¨C however, in your code the <code>fread(...) == READSIZE</code> always evaluated to <code>true</code>, so the or-operator short-circuited and the other operand was never executed. Keep this in mind.</p>
",3
48757080,48756797,2,"<p>What you are doing here</p>

<pre><code>int setPersonalInfo(void)
{
    char first, last, sex;
    printf (""Enter your first name: "");
    scanf (""%s"", &amp;first);

    printf (""Enter your last name: "");
    scanf (""%s"", &amp;last);

    printf (""Enter your gender (M or F): "");
    scanf (""%s"", &amp;sex);
};
</code></pre>

<p>is wrong. <code>first</code>, <code>last</code> and <code>sex</code> are single character variables, the can hold
a single charcater only.</p>

<p>A string in C is a sequence of characters that ends with the <code>'\0'</code>-terminating
byte. <code>scanf</code> expects a pointer to an array of <code>char</code>s where the sequence of
charatcers can be stored. <code>&amp;first</code> gives you only a pointer to a <code>char</code>, but
it's not a pointer to an array of <code>char</code>s, it can hold only one value. A string
of length <code>n</code> needs at least <code>n+1</code> spaces.</p>

<p>Correct version:</p>

<pre><code>int setPersonalInfo(void)
{
    char first[20], last[20], sex[20];
    printf (""Enter your first name: "");
    scanf (""%19s"", first);

    printf (""Enter your last name: "");
    scanf (""%19s"", last);

    printf (""Enter your gender (M or F): "");
    scanf (""%19s"", sex);
};
</code></pre>

<p>Next problem:</p>

<pre><code>int printInfo()
{
    char first, last, sex;
    int month, day, year;
    printf(""%s\n%s%s%s\n"", sex, first, "" "", last);

    printf(""%u%s%u%s%u\n"", month, ""/"", day,""/"", year);    
};
</code></pre>

<p>Here you two problems:</p>

<ol>
<li>The variables are uninitialized</li>
<li>You have a similar problem as above.</li>
</ol>

<p><code>first</code>, <code>last</code>, <code>sex</code> are single charatcer variables. <code>printf</code> expects with <code>%s</code> a pointer to
a string, you are passing the uninitialized value of a <code>char</code> as a pointer. This
is undefined behaviour and the text printed on screen is meaningless.</p>

<p>But the biggest issue here is that the functions read values and store them in
their local variables. Once the functions ends, the local variables cease to
exit and the values are lost. The function should return those values or you
need to pass pointers to the functions, so that the functions can use the
pointers to store the values: like this:</p>

<pre><code>void foo(int *val)
{
    *val = 15;
}

void bar(void)
{
    int x = 10;
    foo(&amp;x);

    // now x is 15
}
</code></pre>
",0
52584246,52584118,0,"<p>try something like:</p>

<pre><code>history[hisCounter] = calloc(MAX_CANON, sizeof(char));
strcpy(history[hisCounter], commandline);
</code></pre>

<p>Or better yet, look into linked lists and use that instead.</p>
",3
54591560,54590258,0,"<blockquote>
  <p>Here is it possible to assign int array to the int *itemsPurchased pointer? If it is possible how print the values?</p>
</blockquote>

<p>Yes we can assign an array to a pointer as array is a constant pointer and reverse is invalid.</p>

<p>But this assignment should be used very carefully as array will be a stack variable and scope of the variable should be taken care before accessing this structure pointer </p>

<p>Also this method can be preferred over the dynamic memory allocation where memory fragmentation is a concern by malloc and free and we can avoid the dynamic allocation overhead.</p>

<p>Following is the code for this and output of print value in the array:</p>

<pre><code>#include &lt;stdio.h&gt;

typedef struct KnightsMartSale {
    char firstName[21];
    char lastName[21];
    int numItemsOnList;
    int *itemsPurchased; // array of item numbers
    struct KnightsMartSale *next;
} KMSale;

int main() {

    KMSale sale;
    int iPos = 0;

    int Array[] = {1, 2, 3, 4, 5};

    sale.numItemsOnList = sizeof(Array) / sizeof(Array[0]);
    sale.itemsPurchased = Array;

    for (iPos=0; iPos &lt; sale.numItemsOnList; iPos++) {
        printf(""sale %d: %d\n"", iPos, sale.itemsPurchased[iPos]);
    }

    return 0;
}
</code></pre>

<p>output:</p>

<pre><code>sale 0: 1
sale 1: 2
sale 2: 3
sale 3: 4
sale 4: 5
</code></pre>
",0
55274741,55274350,3,"<p>As an alternative to using <code>va_copy()</code> ¡ª as suggested by <a href=""https://stackoverflow.com/users/82294/dietrich-epp"">Dietrich Epp</a> in an <a href=""https://stackoverflow.com/a/55274498"">answer</a> ¡ª you can simply use <code>va_start()</code> and <code>va_end()</code> twice.</p>

<pre><code>void myself_printf(char *key_fmt, char *value_fmt, ...)
{
    char real_key[1024];
    char real_value[1024];
    va_list args;

    va_start(args, value);
    vsnprintf(real_key, sizeof(real_key), key_fmt, args);
    va_end(args);

    vs_start(args, value);
    vsnprintf(real_value, sizeof(real_key), value_fmt, args);
    va_end(args);

    ¡­do something useful with real_key and real_value¡­
}
</code></pre>

<p>The original version of the question used <code>char real_key[1024000];</code> and similarly for <code>real_value</code>. Allocating almost 2 MiB of data on the stack won't work reliably on Windows (the limit there is usually 1 MiB of stack), and uses an awful lot of space on Unix systems (where the stack size is usually 8 MiB).  Be cautious!</p>

<p>You would need to use <code>va_copy()</code> if the <code>va_list</code> was passed as an argument to your function.  For example:</p>

<pre><code>void myself_printf(char* key, char* value, ...)
{
    va_list args;    
    va_start(args, value);
    myself_vprintf(key, value, args);
    va_end(args);
}

void myself_vprintf(char *key_fmt, char *value_fmt, va_list args1)
{
    char real_key[1024];
    char real_value[1024];
    va_list args2;
    va_copy(args2, args1);

    vsnprintf(real_key, sizeof(real_key), key_fmt, args1);
    vsnprintf(real_value, sizeof(real_value), value_fmt, args2);
    va_end(args2);

    ¡­do something useful with real_key and real_value¡­
}
</code></pre>

<p>The specification of <a href=""https://port70.net/~nsz/c/c11/n1570.html#7.16.1.3"" rel=""nofollow noreferrer""><code>va_end()</code></a> says:</p>

<blockquote>
  <p>The <code>va_end</code> macro facilitates a normal return from the function whose variable argument list was referred to by the expansion of the <code>va_start</code> macro, or the function containing the expansion of the <code>va_copy</code> macro, that initialized the <code>va_list ap</code>. The <code>va_end</code> macro may modify <code>ap</code> so that it is no longer usable (without being reinitialized by the <code>va_start</code> or <code>va_copy</code> macro). If there is no corresponding invocation of the <code>va_start</code> or <code>va_copy</code> macro, or if the <code>va_end</code> macro is not invoked before the return, the behavior is undefined.</p>
</blockquote>

<p>Note that the specification of the <a href=""https://port70.net/~nsz/c/c11/n1570.html#7.21.6.8"" rel=""nofollow noreferrer""><code>vfprintf()</code></a> function includes footnote <a href=""https://port70.net/~nsz/c/c11/n1570.html#note288"" rel=""nofollow noreferrer"">288</a> which says:</p>

<blockquote>
  <p>As the functions <code>vfprintf</code>, <code>vfscanf</code>, <code>vprintf</code>, <code>vscanf</code>, <code>vsnprintf</code>, <code>vsprintf</code>, and <code>vsscanf</code> invoke the <code>va_arg</code> macro, the value of <code>arg</code> after the return is indeterminate.</p>
</blockquote>

<p>Granted, footnotes are not normative, but this is a strong indication that the functions are expected to use <code>va_arg</code> and hence the double use of <code>arg</code> as shown in the question leads to undefined behaviour unless there is an intervening call to <code>va_end</code> and another <code>va_start</code> or a use of <code>va_copy</code> (and its matching <code>va_end</code>).</p>
",1
55274498,55274350,5,"<p>Strictly speaking, you must use <code>va_copy</code>, since <code>vsnprintf</code> can invalidate <code>args</code>.</p>

<pre><code>void myself_printf(char* key, char* value, ...) {
    char real_key[1024000];
    char real_value[1024000];
    va_list args, args2;
    va_start(args, value);
    va_copy(args2, args);

    // use args twice format key and value
    vsnprintf(real_key, 1024000, key, args);
    vsnprintf(real_value, 1024000, value, args2);

    va_end(args);
    va_end(args2);
}
</code></pre>

<p>This is what <code>va_copy</code> is designed for.</p>

<p>As noted, this is a large amount of stack space, although it is within typical stack sizes. Consider using <code>vasprintf</code>, if it is available.</p>

<h2>Citations</h2>

<p>n1548 ¡ì7.16</p>

<blockquote>
  <p>The object ap may be passed as an argument to another function; if that function invokes the va_arg macro with parameter ap, the value of ap in the calling function is indeterminate¡­</p>
</blockquote>

<p>In other words, you cannot portably use <code>args</code> after you pass it to <code>vsnprintf</code>.</p>

<p>This is clarified in footnote 281:</p>

<blockquote>
  <p>As the functions vfprintf, vfscanf, vprintf, vscanf, vsnprintf, vsprintf, and vsscanf invoke the va_arg macro, the value of arg after the return is indeterminate.</p>
</blockquote>

<p>While it seems that <code>va_list</code> is passed by value, that does not mean that it is actually passed by value, or that the <code>va_list</code> itself encapsulates all of its state. A common trick with typedefs in C is to declare them as a 1-element array:</p>

<pre><code>typedef int my_type[1];
</code></pre>

<p>Since <code>my_type</code> decays to pointer type when it is passed by function, it only <em>appears</em> to be passed by value.</p>

<h2>Demo</h2>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
void func(const char *msg, ...) {
    va_list ap;
    va_start(ap, msg);
    vfprintf(stdout, msg, ap);
    vfprintf(stdout, msg, ap);
    va_end(ap);
}
int main(int argc, char **argv) {
    func(""%d + %d = %d\n"", 2, 3, 5);
    return 0;
}
</code></pre>

<p>On my computer, the output is:</p>

<pre>2 + 3 = 5
590862432 + -1635853408 = 1586038440
</pre>
",13
57256435,57256347,2,"<p>That's not how it works. By using the <code>""%d""</code> format specifier, the <code>scanf</code> function assumes that the argument is a pointer to an <code>int</code>. So it get that pointer, uses the dereference operator, and stores the value <code>5</code> in the location pointed to by the pointer.</p>

<p>In essence what's happening is this:</p>

<pre><code>int b;
int *pb = &amp;b;  // Point to the variable b
*pb = 5;       // Dereference pointer and store value at that location
</code></pre>
",2
55984663,55984637,4,"<blockquote>
  <p>Cannot update pointer value</p>
</blockquote>

<p>You mean cannot update pointed value</p>

<p>Doing</p>

<blockquote>
<pre><code> volatile uint32_t *myAddress = (volatile uint32_t*)0x12341234;

 uint32_t timestamp = 0x1111;

 *myAddress = timestamp;
</code></pre>
</blockquote>

<p>you use the (very probably) invalid address <code>0x12341234</code>, to deference it has an undefined behavior</p>

<p>Do something like that :</p>

<pre><code>uint32_t v;

volatile uint32_t *myAddress = &amp;v;

uint32_t timestamp = 0x1111;

*myAddress = timestamp;
// now v values 0x1111
</code></pre>

<hr>

<p>Example :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main()
{
  uint32_t v = 0;

  volatile uint32_t *myAddress = &amp;v;

  uint32_t timestamp = 0x1111;

  *myAddress = timestamp; // now v values 0x1111

  printf(""0x%x 0x%x\n"", (unsigned) v, (unsigned) *myAddress);

  return 0;
}
</code></pre>

<p>Compilation and execution :</p>

<pre><code>pi@raspberrypi:/tmp $ gcc -pedantic -Wextra -Wall c.c
pi@raspberrypi:/tmp $ ./a.out
0x1111 0x1111
pi@raspberrypi:/tmp $ 
</code></pre>
",6
49121428,49121384,1,"<p>In <code>bubbleSort</code>, when <code>i</code> is 0, <code>for (j = 0; j &lt; tam - i; j++)</code> is <code>for (j = 0; j &lt; tam - 0; j++)</code>, so <code>j</code> iterates up to and including <code>tam-1</code>.</p>

<p>Then, in the loop, you compare <code>v[j]</code> with <code>v[j + 1]</code>. The latter may be <code>v[tam-1 + 1]</code>, which is <code>v[tam]</code>, which is outside the array. That alone is a reference not permitted by the C standard. And then the code goes on to swap <code>v[j]</code> with <code>v[j + 1]</code>, if the comparison evaluated to true. That writes data outside the bounds of the array <code>v</code>, so it corrupts some memory in your process.</p>
",1
53843630,53843568,5,"<p>There might be errors with how you are initializing <code>b</code> or <code>x</code>. However, one definite error is that <code>eta</code> is being used uninitialized. This means <code>eta[i]</code> may begin with some arbitrary value instead of <code>0</code> as you are likely expecting.</p>

<p>Add an initialization before accumulating into it.</p>

<pre><code>  for(i = 0; i &lt; n; i++) {
    eta[i] = 0;
    for (j = 0; j &lt; p; j++)
      eta[i] += b[j] * x[n * j + i];
  }
</code></pre>
",2
53061293,53057267,8,"<p>As Ring ? noted in a comment, they are identical by definition; if there is any difference in how they perform, it's nothing but intentional badness on the part of the compiler.</p>
",2
49021145,49021019,2,"<p>My preferred solution, adapted to the code in the question, is:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int sum = 0;
    int x;
    const char *pad = """";   /* Or put a prefix here */
    while (scanf(""%d"", &amp;x) == 1 &amp;&amp; x != 0)
    {
        sum += x;
        printf(""%s%d"", pad, sum);
        pad = "","";          /* Or use "", "" if you prefer */
    }
    putchar('\n');
    return 0;
}
</code></pre>

<p>Note that this code does not test the uninitialized variable <code>x</code> on the first iteration (unlike the code in the question), and it checks that the <code>scanf()</code> succeeds before using the value (unlike the code in the question).  These are routine precautions you should be taking.  It would be possible to adapt the code to keep track of how many bytes have been printed on the line (what's the return value from <code>printf()</code>?) and arrange for <code>pad</code> to contain <code>""\n""</code> (instead of a comma, or <code>"",\n""</code> if you want a comma at the end of all lines except the last) when the line gets 'too long'.</p>

<p>Note too that if you type the numbers at the program, the output gets messy.  If the program is reading from a built-in list of numbers, or reading from a file, then you get good outputs.</p>
",0
49021097,49021019,1,"<p>You could use the following approach:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int x = 0;
    int sum = 0;
    int i = -1;
    int ret;

    while(1)
    {
        i++;
        ret = scanf(""%d"", &amp;x);

        if(ret != 1)
          break;

        sum += x;

        if(x != 0)
        {
            if(i == 0) 
               printf(""%d"", sum);
            else
              printf("",%d"", sum);
        }
        else
        {
            break;
        }
    }

    printf(""\n"");
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>1
2
3
0
1,3,6
</code></pre>
",0
53821630,53821538,3,"<p>Compiled with </p>

<pre><code>gcc sort.c -Wall -Wextra
</code></pre>

<p>There was one error about not matching conversion specifier (<code>unsigned int</code> requires <code>%u</code> but you had <code>%lld</code> - possibly typo for <code>%11d</code> but even then it were wrong.</p>

<p>Running, I get sometimes correct output, sometimes not. So I compiled with <code>-fsanitize=undefined</code>, and</p>

<pre><code>sort.c:11:13: runtime error: signed integer overflow: 
    1288106901 - -1003011281 cannot be represented in type 'int'
E: 
  290879035
  591885416
  767444883
 1288106901
 1955087149
-1509681722
-1289472872
-1003011281
</code></pre>

<p>I.e. your smart code wasn't too smart there. The correct way to return a value from the comparison function would be </p>

<pre><code>return x &lt; y ? -1 : x &gt; y ? 1 : 0;
</code></pre>

<p>or</p>

<pre><code>return (x &gt; y) - (x &lt; y);
</code></pre>

<p>as <a href=""https://stackoverflow.com/questions/53821538/possible-bug-in-std-c-quicksort-am-i-missing-something/53821630?noredirect=1#comment94491824_53821630"">suggested by HolyBlackCat</a></p>
",11
48185637,48185491,5,"<blockquote>
  <p>Does variable j need to be declared at the start of the function? </p>
</blockquote>

<p>Yes, if you are using C89. Or, at least you'd need to introduce a scope with <code>{ ..}</code> and declare it.</p>

<blockquote>
  <p>Does the same apply for while() and if()? And what about do.. while() ?</p>
</blockquote>

<p>The syntax doesn't permit declaring variables in (i.e., <code>while (int i = 0)</code> isn't valid) them. But you can declare <em>insde</em> them which is allowed in all C standards.</p>

<blockquote>
  <p>Do the rules of scope differ between C98 and C99 or later?</p>
</blockquote>

<p>There's no C98 but yes the rules changed in C99 and later and allows you declare variables in the <code>for</code> loop (as you have in your code).</p>

<blockquote>
  <p>Is the following code ANSI C compliant?</p>
</blockquote>

<p>That depends on what ""ANSI C"" refers to. It's valid in C99 and later.</p>
",3
55359613,55359391,1,"<p><code>pool-&gt;data + pool-&gt;offset</code> wouldn't be possible because you can't do pointer arithmetic on <code>void</code> pointers - that isn't valid C. Pointer arithmetic also assumes that the underlying type of this all is an array.</p>

<p><code>&amp;pool-&gt;data</code> gives the address of the pointer itself, which happens to be the address of the struct. The type <code>void**</code>. You can't do arithmetic on that either.</p>

<p>Therefore the naive, bad solution here is to cast the pointer to an <code>int</code> and then do simple addition. That doesn't work either, because <code>int</code> is not guaranteed to be able to hold the contents of a pointer. <code>uintptr_t</code> should have been used instead of <code>int</code>.</p>

<p>And finally, accessing that chunk of memory through <code>int*</code> then de-referencing it is only possible if what's stored there is already regarded as type <code>int</code> by the compiler. If not, it invokes undefined behavior, <a href=""https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule"">What is the strict aliasing rule?</a>.</p>

<p>Summary: this is quite questionable code and there's many better ways to implement it.</p>
",3
48408479,48371965,4,"<p>Per @NominalAnimal's comment:</p>

<p>Use <code>gcc -Wall -O2 test.c -lcsfml-graphics -lcsfml-window -o test</code> to compile the program.</p>

<p>The <code>-lcsfml-graphics</code> tells the compiler to link the executable with the csfml-graphics library (""libcsfml-graphics.so"" or ""libcsfml-graphics.a"" on Linux), and <code>-lcsfml-window</code> similarly with the csfml-window library.</p>

<p>(Note: l is ""the letter ell"", not ""digit one"", here.) </p>
",0
54815051,54814993,5,"<p>For this case, <code>memset(test+1, 0xFF, 2)</code> should work.</p>
",1
54815403,54814993,5,"<p>Your options are</p>

<ol>
<li><pre><code>test[1] = 0xFF;
test[2] = 0xFF;
</code></pre></li>
<li><pre><code>memset(test + 1, 0xFF, 2);
</code></pre></li>
<li><pre><code>const char bytes[2] = {0xFF, 0xFF};
memcpy(test + 1, bytes, 2);
</code></pre></li>
<li><pre><code>uint16_t value = 0xFFFF;     // beware of byte order
memcpy(test + 1, &amp;value, 2);
</code></pre></li>
<li><pre><code>memcpy(test + 1, (const unsigned char []){0xFF, 0xFF}, 2));
</code></pre></li>
<li><p>or any other code that addresses the individual bytes separately.</p></li>
</ol>

<hr>

<p>What is <em>not</em> an option is:</p>

<pre><code>*(uint16_t)&amp;test[1] = 0xFFFF;
</code></pre>

<p>The reason is simple: it breaks two rules in C: strict aliasing <em>and</em> alignment. What is worse is that you <em>can</em> get away with this in <em>this</em> part of code, but <a href=""https://stackoverflow.com/questions/46790550/c-undefined-behavior-strict-aliasing-rule-or-incorrect-alignment"">dereferencing unaligned <code>uint16_t</code> pointers is never safe, even on x86-64 that supposedly supports unaligned accesses</a></p>
",0
56697375,56697210,-1,"<p>As far as I see with GCC it does not generate a null pointer. Decrementing is just subtracting a number. With underflow the number just wraps around. You can see that here.</p>

<pre><code>#include ""stdio.h""
#include &lt;inttypes.h&gt;

int main()
{
    char *p = NULL;
    printf(""%zx\n"", (uintptr_t)p);    
    --p;
    printf(""%zx\n"", (uintptr_t)p);
}
</code></pre>

<p>Output is</p>

<pre><code>0
ffffffffffffffff
</code></pre>

<p><a href=""https://wandbox.org/permlink/gNzc38RWGSBi9tS3"" rel=""nofollow noreferrer"">https://wandbox.org/permlink/gNzc38RWGSBi9tS3</a></p>
",4
56697339,56697210,6,"<p>Yes, the behavior is undefined.</p>

<p><code>--p</code> is equivalent to <code>p = p - 1</code> (except that <code>p</code> is only evaluated once, which doesn't matter in this case).</p>

<p><a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""noreferrer"">N1570</a> 6.5.6 paragraph 8, discussing additive operators, says:</p>

<blockquote>
  <p>When an expression that has integer type is added to or subtracted
  from a pointer, the result has the type of the pointer operand. If the
  pointer operand points to an element of an array object, and the array
  is large enough, the result points to an element offset from the
  original element such that the difference of the subscripts of the
  resulting and original array elements equals the integer expression.<br>
  [...]<br>
  If both the pointer operand and the result point to elements
  of the same array object, or one past the last element of the array
  object, the evaluation shall not produce an overflow; otherwise, the
  behavior is undefined.</p>
</blockquote>

<p>Since your pointer value <code>p</code> doesn't point to an element of an array object or one past the last element of an array object, the behavior of <code>p - 1</code> is undefined.</p>

<p>(Incidentally, I'd be surprised if your code caused <code>p</code> to be a null pointer -- though since the behavior is undefined the language certainly permits it. I can imagine an optimizing compiler ignoring the <code>--p;</code> because it knows its behavior is undefined, but I haven't seen that myself. How do you know <code>p</code> is null?)</p>
",5
48513431,48513375,2,"<pre><code>argc--;
argv++;
/* Since you just incremented argv, you just lost the program name! */
/* You need argv[0] as the program name to create the error message */

if(argc &lt;= 0) {   
    print_usage( argv[0] );
    exit(EXIT_FAILURE);
}
</code></pre>

<hr>

<pre><code>void print_usage(char* program) {

    fprintf(stderr, ""Usage: %s [file]...\n"", program);
}
</code></pre>
",0
59419540,59419451,3,"<p>Your value for <code>M</code> is wrong. You should use <code>ULLONG_MAX</code>, which is <code>18446744073709551615</code> (you're missing <code>37</code>).</p>

<pre><code>#include &lt;limits.h&gt;
unsigned long long M = ULLONG_MAX;
</code></pre>
",3
49329970,49329833,0,"<p>It looks like you are unsure about why it is adding 3 instead of adding 2.</p>

<pre><code>delta + 2     = -2147483646  (80000002)    &lt;&lt;
</code></pre>

<p>It's because you reassigned your <code>delta</code> variable instead of storing the result in a separate variable.</p>

<pre><code>delta = delta + 1 // delta is reassigned to -2147483648
// delta + 1     = -2147483648  (80000000)
delta = delta + 2 // Here is the problem. It should be delta + 1.
// delta + 2     = -2147483646  (80000002)    &lt;&lt;
</code></pre>

<p>Instead, you should just add 1 each time.</p>
",0
55203789,55203770,58,"<p>Literally, it's a page break (""form feed"") character.  The compiler treats it as ordinary whitespace. But it's very useful for printing source code - it starts a new page (for example, use <code>^L</code> between functions to force each call to get its own page).</p>

<p>In <a href=""http://en.wikipedia.org/wiki/Vim_%28text_editor%29"" rel=""noreferrer"">Vim</a>/vi based editors, you can insert such a character within edit mode by typing <kbd>Ctrl</kbd> + <kbd>V</kbd> followed by <kbd>Ctrl</kbd> + <kbd>L</kbd>. It will look like <code>^L</code> in the editor, but it's actually just one character (ASCII value: 12 or 0x0C).</p>
",11
55701397,55701242,1,"<p>When I first wrote this answer, the <code>main()</code> program was not provided.  Now that it is provided, the primary problem is that <a href=""https://stackoverflow.com/questions/5240789/scanf-leaves-the-new-line-char-in-buffer""><code>scanf()</code> leaves the newline in the input buffer</a>.  When the main program reads the <code>r</code> (or <code>R</code>), the newline after it is left in the buffer.  The code in <code>ReadText()</code> immediately reads that newline, and nothing more.</p>

<p>Adding the space in <code>"" %c""</code> in <code>ReadText()</code> means that all blanks, tabs and <em>newlines</em> will be read while processing the space, and only when something that isn't white space is entered will the input terminate.  For your code here, using just <code>""%c""</code> is correct and necessary (unless you decide to use <code>getchar()</code> instead).  You should handle EOF too; in <code>ReadText()</code>, you should check:</p>

<pre><code>if (scanf(""%c"", &amp;userInput) != 1)
    break;
</code></pre>

<p>The best fix is probably to use a function like:</p>

<pre><code>static void gobble(void)
{
    int c;
    while ((c = getchar()) != EOF &amp;&amp; c != '\n')
        ;
}
</code></pre>

<p>and call it in <code>main()</code> after the <code>scanf()</code> to read the command character:</p>

<p>printf(""Enter command (C, R, P, or Q): "");
   if (scanf("" %c"", &amp;command) != 1)
       return 0;   // EOF most probably
   gobble();</p>

<p>The <code>"" %c""</code> here (in <code>main()</code>) is sensible.  It is not appropriate in <code>ReadText()</code>.</p>

<p>Remember: <code>scanf()</code> is probably the hardest function to use really well in standard C ¡ª it is excruciatingly complex and subtle, and any given call is often affected by prior input operations, especially previous calls to <code>scanf()</code>.  Recovery after an error in the input is also rather hard unless you use a function like <code>gobble()</code> to clean out any left over unread residue on the line ¡ª but the diagnosis of what went wrong is hard too.  It is often better to read the line with <code>fgets()</code> (or POSIX <code>getline()</code>) and then scan it with <code>sscanf()</code>, which allows you to (a) make multiple attempts at parsing the same data, and (b) allows you to report the entire faulty line rather than just what fragments are left after <code>scanf()</code> has read some but not all of the line.</p>
",5
55701562,55701242,1,"<p>The problem is in your main function -- you call <code>scanf("" %c""</code> to read the command, which leaves the newline after that in the input buffer.  So when you call ReadText, the first thing it reads is that newline, and it returns immediately.</p>

<p>You need to add some code to read (and discard) the rest of the current input line before calling ReadText.</p>
",0
54744710,54743497,1,"<p>Yes, that's a definition of a pointer to an unnamed structure. This can be quite useful for structures that are only ever referenced through that pointer, since it makes it impossible to create an instance statically for instance.</p>
",0
48853500,48853472,0,"<p>You can declare a global variable or function as many times as you wish. But you must have only one definition. The first line assigns the variable a value, so it is a declaration and definition combined. The second line does not assign a value, so it is only a declaration.</p>
",0
58939272,58938528,2,"<p>The relevant excerpts from the page are</p>

<blockquote>
  <p>The thing to do is to pack the data into a known format and send that over the wire for decoding. For example, to pack floats, <strong>here¡¯s something quick and dirty with plenty of room for improvement</strong></p>
</blockquote>

<p>and </p>

<blockquote>
  <p>On the plus side, it¡¯s small, simple, and fast. On the minus side, it¡¯s not an efficient use of space and the range is severely restricted¡ªtry storing a number greater-than 32767 in there and it won¡¯t be very happy! You can also see in the above example that the last couple decimal places are not correctly preserved.</p>
</blockquote>

<p>The code is presented only as an <em>example</em>. It is <strong>really quick and dirty</strong>, because it packs and unpacks the float as a <a href=""https://en.wikipedia.org/wiki/Fixed-point_arithmetic"" rel=""nofollow noreferrer""><em>fixed point number</em></a> with 16 bits for fractions, 15 bits for integer magnitude and one for sign. It is an example and does <em>not</em> attempt to map floats 1:1. </p>

<p>It is in fact rather incredibly stupid algorithm: It can map 1:1 all IEEE 754 float32s within magnitude range ~256...32767 without losing a bit of information, truncate the fractions in floats in range 0...255 to 16 bits, and <strong>fail spectacularly for any number >= 32768</strong>. And <code>NaN</code>s.</p>

<hr>

<p>As for the endianness problem: for any protocol that does not work with integers >= 32 bits intrinsically, someone needs to decide how to again serialize these integers into the other format. For example in the Internet at lowest levels data consists of 8-bit octets.</p>

<p>There are <em>24</em> obvious ways mapping a 32-bit unsigned integer into 4 octets, of which <em>2</em> are now generally used, and some more historically. Of course there are a countably infinite (and exponentially sillier) ways of encoding them...</p>
",1
56851787,56851689,6,"<p>The behavior is undefined.</p>

<blockquote>
  <p><strong>7.22.4.4 The exit function</strong></p>
  
  <p><a href=""https://port70.net/~nsz/c/c11/n1570.html#7.22.4.4p2"" rel=""nofollow noreferrer"">2</a> The exit function causes normal program termination to occur. No
  functions registered by the at_quick_exit function are called. If a
  program calls the exit function more than once, or calls the
  quick_exit function in addition to the exit function, the behavior is
  undefined.</p>
</blockquote>

<p>Calling <code>exit</code> in an <code>at_exit</code> handler (that is being run during the normal processing of exit) is definitely a second call to exit.</p>

<p>Exiting normally is a possible behavior, but seeing as anything can happen (the nature of the behavior being undefined), it could very well result in catastrophe. Best not to do it.</p>
",3
56746250,56745928,3,"<p>No, there is not, unless perhaps the obscure <code>-q</code> option was used when linking. <code>ET_EXEC</code> ELF files are linked for a particular load address and have address references resolved and finalized as immediates in in their instruction streams and plain numbers in their data sections. The information that these numbers refer to addresses of objects or functions and aren't just plain constant numbers has <strong>already been lost</strong> and is fundamentally unrecoverable. PIE executables, on the other hand, have dynamic relocation records on all address references so that they can be patched up at load time, and usually have all such references in the data segment (GOT or static data) so that the text segment is purely read-only and shareable.</p>

<p>So no, there's no way to do what you want.</p>
",1
52141000,52140627,2,"<p>There's a few ways to get an exact memory fit in C.</p>

<p>One is to precalculate exactly how much memory you need, which you could probably do here. But that's not always possible, and it's more code to write, and more bugs, and more runtime.</p>

<p>Another is to use <code>realloc</code>. Reallocating can get messy and expensive and it's a great way to invite bugs. Sometimes its necessary if you're working with an existing hunk of memory, like growing an array.</p>

<p>The other is to allocate a stack buffer large enough to hold any possible value, then use <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/strdup.html"" rel=""nofollow noreferrer""><code>strdup</code></a> to copy it to exactly the right amount of heap memory. This is great when you need to process something all at once and you're not sure how big it might be. For example, reading from a file.</p>

<pre><code>// Allocate a big, reusable buffer
char line[BUFSIZ];
while( fgets(line, sizeof(line), fp) ){
    ...now you can slice and dice line...
}
</code></pre>

<p>We can do the same thing for your problem.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// The largest possible string to hold a binary integer
#define BINARY_INT_SIZE ((sizeof(int)*8) + 1)

// A cheap way to convert from integer 0/1 to char 0/1
const char BINARY_TO_CHAR[] = {'0', '1'};

char * convertToBinary(int number) {
    // Initialize the stack variable to hold the conversion   
    char result[BINARY_INT_SIZE] = {0};

    for( int counter = 0; number; counter++ ) {
        printf(""%d %d %d\n"", counter, number, number % 2);
        result[counter] = BINARY_TO_CHAR[number % 2];
        number/=2;
    }

    // Copy from the stack into exactly enough heap memory
    return strdup(result);
}
</code></pre>

<p>Stack memory is cheap and fast to allocate and discard. Much faster than reallocating heap memory over and over again in a loop. Using <code>strdup</code> guarantees the persisting heap memory is compact.</p>
",0
53160417,53160264,1,"<blockquote>
  <p>I guess my first solution didn't really work out because a white space simply isn't a character (?)</p>
</blockquote>

<p>Of course whitespace is a character - in fact, a group of characters are considered whitespace. However, whitespace characters play special role when it comes to <code>scanf</code>: it serves to separate inputs parsed with the format string, except a few special cases.</p>

<p>That is why you are not going to get <code>""abc ""</code> from <code>scanf</code> with <code>%s</code>: the trailing whitespace would always be ignored, so neither of your two approaches would work.</p>

<p>This would work:</p>

<pre><code>char buf[100], ch;
scanf(""%99s%c"", buf, &amp;ch);
if (strcmp(buf, ""abc"") == 0 &amp;&amp; ch == ' ') {
    printf(""Yes!\n"");
}
</code></pre>

<p>The idea is to read the character immediately after <code>%s</code>'s capture into a variable, and compare that variable to space character <code>' '</code>.</p>

<p>Note the use of <code>%99s</code> to limit the size of the input to the allocated length of the buffer (plus an additional character for the null terminator).</p>

<p><a href=""https://ideone.com/QXoM4m"" rel=""nofollow noreferrer"">Demo.</a></p>

<p><strong>Important:</strong> It goes without saying that you need to check the return value of <code>scanf</code> to see that there was some input for all format specifiers. In the case above you need to check that <code>scanf</code>'s return value was <code>2</code>.</p>
",4
49987336,49987105,3,"<p>What you have if you do this is a resource leak, which may be a memory leak in your process's memory space and is certainly a type of memory leak in the system as a whole (until your process's lifetime ends, in which case the resources it's holding are closed). At some point you'll exceed the per-process or system-wide limit on open file descriptors or other resources needed to manage an open directory, and further attempts to open directories (and likely files as well) will fail until you close some.</p>

<p>This is an inherent limitation, not an artificial one, because every open directory handle carries with it some state: which directory it's associated with, what the current position of the iterator is, etc. Keeping state inherently consumes memory of some sort.</p>
",0
53155277,53155121,8,"<p>You must be working on a DOS/Windows system. This linefeed translation is a MS legacy feature for text files. You can open the file in ""binary"" mode, then line ends will not be translated:</p>

<pre><code>FILE *fp=fopen(""file.name"",""wb"");//""b"" means binary
putc('\n',fp);
</code></pre>
",1
49521820,49521757,4,"<p>Read up on this: <a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""noreferrer"">printf</a></p>

<p>And use <code>%f</code> for <code>double</code> not <code>%d</code> which is for <code>int</code></p>
",7
49223009,49222966,1,"<p>In POSIX systems like linux and macos <a href=""https://linux.die.net/man/3/getline"" rel=""nofollow noreferrer""><code>getline</code></a> is part of the standard and your
<code>getline</code> conflicts with it.</p>

<p>Rename your function to <code>mygetline</code>. I copied your code and rename the function,
it compiles without a problem.</p>
",0
57155380,57155281,1,"<p>In <code>str_index</code>, if <strong>any</strong> character in <code>str</code> is the first character in <code>substr</code>, then, when <code>i</code> is such that <code>str[i]</code> is that character, <code>substr[j] == substr[k]</code> will be true in the first iteration of <code>for(j = i, k = 0;¡­</code>, and <code>k</code> will be incremented. When that loop ends, <code>k &gt; 0</code> is true, and <code>return i;</code> will be executed.</p>

<p>You need to modify the code so that it returns <code>i</code> only if <strong>all</strong> the characters in <code>substr</code> have been matched.</p>
",0
54464538,54463659,1,"<blockquote>
  <p>highest of two values<br>
  only done with mathematical operations (+*-%/ and pow)</p>
</blockquote>

<p>When the values are both > 0, find the 2 quotients a/b, b/a.  One of the quotients will be 0 (assuming types are some integer) and the other 1 or more.  (Or both quotients are 1 when values are the same).</p>

<p>Perform </p>

<pre><code>pow(one_or_more, 0);  // 1 (v2 &gt; v1)
pow(0, one_or_more);  // 0 (v1 &gt; v2) 
pow(1,1);             // 1 (same)
</code></pre>

<p>Use 0,1 to index the answer.</p>

<p>Sample</p>

<pre><code>int a[2] = { value1, value2 };
int index = pow(a[1]/a[0], a[0]/a[1]);
printf(""%d\n"", a[index]);
// or ""to print the maximum option""
printf(""%d\n"", index);
</code></pre>

<hr>

<p>The allowable use <code>pow()</code> hints to this approach.</p>

<p>Side benefit:  No overflow when values are > 0. <code>-,+,*</code> tend to open the door to overflow possibility and that is avoided.</p>

<p>Down side: Trouble with values &lt;= 0.</p>
",0
49550860,49550806,3,"<blockquote>
  <p>I have to give some arguments while executing in the terminal,</p>
</blockquote>

<p>No, you don't have to. You <em>may</em> give some arguments. There are <a href=""https://softwareengineering.stackexchange.com/a/307472/40065"">conventions</a> regarding program arguments (but these are just <em>conventions</em>, not requirements).</p>

<p>It is perfectly possible to write some C code with a <code>main</code> without argument, or with <em>ignored</em> arguments. Then you'll compile your program into some executable <code>myprog</code> and you just type <code>./myprog</code> (or even just <code>myprog</code> if your <a href=""https://en.wikipedia.org/wiki/PATH_(variable)"" rel=""nofollow noreferrer""><code>PATH</code> variable</a> mentions at the right place the directory containing your <code>myprog</code>) in your terminal.</p>

<p>The C11 standard <a href=""http://www.iso-9899.info/n1570.html"" rel=""nofollow noreferrer"">n1570</a> specifies in ¡ì5.1.2.2.1 [Program startup] that</p>

<blockquote>
  <p>The function called at program startup is named <code>main</code>. The implementation declares no
      prototype for this function. It shall be defined with a return type of int and with no
      parameters:</p>

<pre><code>       int main(void) { /* ... */ }
</code></pre>
  
  <p>or with two parameters (referred to here as argc and argv, though any names may be
      used, as they are local to the function in which they are declared):</p>

<pre><code>       int main(int argc, char *argv[]) { /* ... */ }
</code></pre>
  
  <p>or equivalent) or in some other implementation-defined manner.</p>
</blockquote>

<p>The POSIX standard specifies further the relation between the command line, the <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html"" rel=""nofollow noreferrer"">execve</a> function, and the <code>main</code> of your program. See also <a href=""https://stackoverflow.com/a/40982829/841108"">this</a>.</p>

<p>In practice I strongly recommend, in any serious program running on a POSIX system, to give two <code>argc</code> &amp; <code>argv</code> arguments to <code>main</code> and to parse them following established <a href=""https://softwareengineering.stackexchange.com/a/307472/40065"">conventions</a> (In particular, I hate serious programs not understanding <code>--help</code> and <code>--version</code>).</p>
",0
49551151,49550806,0,"<p>You can always pass some number of arguments or pass nothing unless you are checking for the number of arguments and arguments passed (or forcing compiler to do so). Your command interpreter has no idea what your program is going to do with the passed argument or whether the program need any argument. It's your program which takes care of all these things.<br>
For example, </p>

<pre><code>int main(void){
    return 0;
} 
</code></pre>

<p>you can pass any number of arguments to the above program    </p>

<pre><code>$ gcc hello.c -o hello  
$ ./hello blah blah blah 
</code></pre>

<p>In case of </p>

<pre><code>int main(int argc, char **argv){
    return 0;
}
</code></pre>

<p>you can pass no arguments.   </p>

<pre><code>$ gcc hello.c -o hello 
$ ./hello
</code></pre>

<p>For  </p>

<pre><code>int main(int argc, char **argv){
    if(argc &lt; 3){
        printf(""You need to pass two arguments to print those on the terminal\n"");
        exit(0);
    }
    else{
         printf(""%s %s\n"", argv[1], arv[2]);
    }
    return 0;
}
</code></pre>

<p>You have to pass two arguments because the program checking the number of arguments passed and using them  </p>

<pre><code>$ gcc hello.c -o hello  
$ ./hello Hello world
</code></pre>
",3
52823815,52823714,7,"<p>You're scanning <em>way</em> past the end of the mapped memory.</p>

<pre><code>end = (long *) mm + mem_size;
</code></pre>

<p>You convert <code>mm</code> to a <code>long*</code>. Adding <code>mem_size</code> to that pointer value advances the pointer by <code>mem_size * sizeof (long)</code> bytes.</p>

<p>Change that to:</p>

<pre><code>end = (long *)(mm + mem_size);
</code></pre>
",2
48562725,48562546,7,"<p>Your variable has static storage duration, as such and according to N1570 (C11) <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.7.9p4"" rel=""nofollow noreferrer"">¡ì6.7.9/p4</a>:</p>

<blockquote>
  <p>All the expressions in an initializer for an object that has static or
  thread storage duration shall be constant expressions or string
  literals.</p>
</blockquote>

<p>String literals have static storage duration <sup><a href=""http://port70.net/~nsz/c/c11/n1570.html#6.4.5p6"" rel=""nofollow noreferrer"">¡ì6.4.5/p6</a></sup>, so their <em>addresses</em> can be considered constant expressions (which is why they are allowed as initializers). But you are trying to access the value at such an address, and the C standard explicitly forbids it. To quote <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.6p9"" rel=""nofollow noreferrer"">¡ì6.6/p9</a>, emphasis mine:</p>

<blockquote>
  <p>An address constant is a null pointer, a pointer to an lvalue
  designating an object of static storage duration, or a pointer to a
  function designator; it shall be created explicitly using the unary &amp;
  operator or an integer constant cast to pointer type, or implicitly by
  the use of an expression of array or function type. <strong>The
  array-subscript [] and member-access . and -> operators, the address &amp;
  and indirection * unary operators, and pointer casts may be used in
  the creation of an address constant, but the value of an object shall
  not be accessed by use of these operators.</strong></p>
</blockquote>

<p>On the other hand, when you used character <strong>constants</strong> for comparison, you obtain a valid constant expression. </p>
",7
50517513,50517336,6,"<p><code>&amp;</code> is a bitwise operator in this case. When you do <code>b&amp;1</code> you have an integer <code>b</code> say 13 in decimal and the number <code>1</code>. </p>

<pre><code>         d7 d6 d5 d4 d3 d2 d1 d0
b = 13 =  0  0  0  0  1  1  0  1 
     1 =  0  0  0  0  0  0  0  1
          -----------------------  after bitwise and operator
          0  0  0  0  0  0  0  1
</code></pre>

<p>Above each bit of <code>b</code> is logically <code>&amp;</code>ed with corresponding bit of binary representation of <code>1</code>. Because one of the integers is <code>1</code> which has only one <code>1</code> at position <code>d0</code>, all the bitwise and operator will evaluate to <code>0</code> in all the positions from <code>d7</code> to <code>d1</code>, and because the outcome of <code>d0</code> in the result will depend on what is present in <code>d0</code> of your variable <code>b</code>.</p>

<p>All the odd numbers have a <code>1</code> in their binary representation at <code>d0</code> position. All the even numbers have a <code>0</code> in their binary representation at <code>d0</code> position.</p>

<p>Therefore this is a way to check what digit is present at <code>d0</code>. If it is <code>1</code> the outcome of <code>b&amp;1</code> will be <code>1</code>, else it will be <code>0</code>, which will enable us to determine if the integer is even or odd, in this case.</p>

<p>Although similar application of  bitwise operator gives you to check which bit of an integer is <code>1</code> or <code>0</code>, set a specific bit in an integer etc.</p>

<p><strong>EDIT</strong></p>

<p>@chux Makes some pretty good points, see the answer. Be aware of the one's complement issue (but possibly you will never encounter it unless you are using some weird hardware). Also, these days, checking for odd-even the modulus operator will be better as good compilers can make efficient code.</p>
",0
50517406,50517336,5,"<p><a href=""https://stackoverflow.com/questions/5700911/how-do-i-check-if-an-integer-is-even-or-odd-using-bitwise-operators"">It is a bitwise operation, checking if <code>b</code> is odd or even.</a></p>

<pre><code>if (number &amp; 1) {
  // Number is Odd.
} else {
  // Number is Even.
}
</code></pre>
",0
59318375,59313324,2,"<p>You can¡¯t use a binary tree to store words because there can be more than two distinct letters after a letter. </p>

<p>What you need is called an <em>m-ary tree</em>. See <a href=""https://en.wikipedia.org/wiki/M-ary_tree"" rel=""nofollow noreferrer"">this wikipedia page</a> for a description. </p>

<p>Regarding the NULL?at the start, it doesn¡¯t make much sense. The root pointer must hold the address of the top node of the tree. It can¡¯t be NULL if the tree is not empty. </p>

<p>It is unclear from you explanation if the NULL?was for the letter. Anyway, a binary tree can have only at most two distinct successors to a node. </p>
",0
48936883,48936647,4,"<p>If your compiler supports VLAs or you are using C99, then you can do this:</p>

<pre><code>#include &lt;stdio.h&gt;

int readmatrix(size_t rows, size_t cols, int (*a)[cols], const char* filename)
{

    FILE *pf;
    pf = fopen (filename, ""r"");
    if (pf == NULL)
        return 0;

    for(size_t i = 0; i &lt; rows; ++i)
    {
        for(size_t j = 0; j &lt; cols; ++j)
            fscanf(pf, ""%d"", a[i] + j);
    }


    fclose (pf); 
    return 1; 
}

int main(void)
{
    int matrix[2][3];

    readmatrix(2, 3, matrix, ""file.dat"");

    for(size_t i = 0; i &lt; 2; ++i)
    {
        for(size_t j = 0; j &lt; 3; ++j)
            printf(""%-3d "", matrix[i][j]);
        puts("""");
    }

    return 0;
}
</code></pre>

<p><code>file.dat</code> looks like this:</p>

<pre><code>1 2 3
4 5 6
</code></pre>

<p>and the output of my program is</p>

<pre><code>$ ./a 
1   2   3   
4   5   6   
</code></pre>

<p>Note that this is a basic example, you should always check the return value of
<code>fscanf</code>. If <code>file.dat</code> had one row only, then you would get in trouble. Also
there are not numbers in the file, you would get also undefined values in the
matrix.</p>

<p>I'd advice to read the whole line with <code>fgets</code> and then parse the line using
<code>sscanf</code> or some other function like <code>strtok</code>, then it would be easier to react
to errors in the input file.</p>

<hr>

<p><strong>edit</strong></p>

<p>A more robust way of reading a file like this would be:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;


int **readmatrix(size_t *rows, size_t *cols, const char *filename)
{
    if(rows == NULL || cols == NULL || filename == NULL)
        return NULL;

    *rows = 0;
    *cols = 0;

    FILE *fp = fopen(filename, ""r"");

    if(fp == NULL)
    {
        fprintf(stderr, ""could not open %s: %s\n"", filename, strerror(errno));
        return NULL;
    }

    int **matrix = NULL, **tmp;

    char line[1024];

    while(fgets(line, sizeof line, fp))
    {
        if(*cols == 0)
        {
            // determine the size of the columns based on
            // the first row
            char *scan = line;
            int dummy;
            int offset = 0;
            while(sscanf(scan, ""%d%n"", &amp;dummy, &amp;offset) == 1)
            {
                scan += offset;
                (*cols)++;
            }
        }

        tmp = realloc(matrix, (*rows + 1) * sizeof *matrix);

        if(tmp == NULL)
        {
            fclose(fp);
            return matrix; // return all you've parsed so far
        }

        matrix = tmp;

        matrix[*rows] = calloc(*cols, sizeof *matrix[*rows]);

        if(matrix[*rows] == NULL)
        {
            fclose(fp);
            if(*rows == 0) // failed in the first row, free everything
            {
                fclose(fp);
                free(matrix);
                return NULL;
            }

            return matrix; // return all you've parsed so far
        }

        int offset = 0;
        char *scan = line;
        for(size_t j = 0; j &lt; *cols; ++j)
        {
            if(sscanf(scan, ""%d%n"", matrix[*rows] + j, &amp;offset) == 1)
                scan += offset;
            else
                matrix[*rows][j] = 0; // could not read, set cell to 0
        }

        // incrementing rows
        (*rows)++;
    }

    fclose(fp);

    return matrix;
}

int main(void)
{

    size_t cols, rows;
    int **matrix = readmatrix(&amp;rows, &amp;cols, ""file.dat"");

    if(matrix == NULL)
    {
        fprintf(stderr, ""could not read matrix\n"");
        return 1;
    }


    for(size_t i = 0; i &lt; rows; ++i)
    {
        for(size_t j = 0; j &lt; cols; ++j)
            printf(""%-3d "", matrix[i][j]);
        puts("""");

    }


    // freeing memory
    for(size_t i = 0; i &lt; rows; ++i)
        free(matrix[i]);
    free(matrix);

    return 0;
}
</code></pre>

<p>Now <code>file.dat</code> looks like this:</p>

<pre><code>1 2 3 4 
4 5 6 5 
9 8 8 7 
5 5 5 5 
1 1 1 1 
</code></pre>

<p>And the output is</p>

<pre><code>1   2   3   4   
4   5   6   5   
9   8   8   7   
5   5   5   5   
1   1   1   1   
</code></pre>

<p>In this example I calculate the number of columns only for the first column and
use that number for all other columns. If the input file has rows with less
columns that the first row, then the missing values are stored with 0. If it has rows with
more columns than the row will be trimmed.</p>

<p>I calculate the number of rows like this:</p>

<pre><code>            while(sscanf(scan, ""%d%n"", &amp;dummy, &amp;offset) == 1)
            {
                scan += offset;
                (*cols)++;
            }
</code></pre>

<p>First I declare a pointer <code>scan</code> to point to <code>line</code>, so that I can modify the
pointer without losing the original line. The <code>%n</code> in <code>sscanf</code> is not counted in
the number of successfull conversions, this returns the position of <code>scan</code> where
it stopped reading. I used that to loop the <code>sscanf</code>. I explicitly check that
<code>sscanf</code> returns 1 and if that's the case, I increment the number of columns and
I update <code>scan</code> to update to the point where <code>sscanf</code> stoppped reading. This
allows me to continue scanning until the end of the line is reached. I use a
similar technique to parse all the integers.</p>
",1
52606723,52606317,0,"<p>Your code works fine. Check this</p>

<pre><code>int main()
{
  char mac1[] = ""0x2:0x13:0xa9:0x1f:0xb0:0x88"";
  char mac2[] = ""02:13:a9:1f:b0:88"";
  int a[6];

  sscanf(mac1, ""%x:%x:%x:%x:%x:%x"", &amp;a[0], &amp;a[1], &amp;a[2], &amp;a[3], &amp;a[4], &amp;a[5]);
  printf(""%02x:%02x:%02x:%02x:%02x:%02x\n"", a[0], a[1], a[2], a[3], a[4], a[5]);

  sscanf(mac2, ""%x:%x:%x:%x:%x:%x"", &amp;a[0], &amp;a[1], &amp;a[2], &amp;a[3], &amp;a[4], &amp;a[5]);
  printf(""%02x:%02x:%02x:%02x:%02x:%02x\n"", a[0], a[1], a[2], a[3], a[4], a[5]);
}
</code></pre>

<p>Output:</p>

<pre><code>02:13:a9:1f:b0:88
02:13:a9:1f:b0:88
</code></pre>
",0
54228212,54228175,2,"<p>You can't use an array to initialize another array. And you can't use assignment between arrays either.</p>

<p>The only way is to do an explicit copy from one array to the other. And for null-terminated byte strings then the usual way us through <a href=""https://en.cppreference.com/w/c/string/byte/strcpy"" rel=""nofollow noreferrer""><code>strcpy</code></a>:</p>

<pre><code>char str1[100] = ""This is a string"";
char temp[100];

strcpy(temp, str1);
</code></pre>

<p>And to get a proper declaration of <code>strcpy</code> you should include <code>&lt;string.h&gt;</code>. There's no way around it (unless you want to write your own <code>strcpy</code>-like function which I highly recommend against).</p>

<p>You can of course also copy the whole array, including all the uninitialized contents, using <a href=""https://en.cppreference.com/w/c/string/byte/memcpy"" rel=""nofollow noreferrer""><code>memcpy</code></a>, but it's also declared in <code>&lt;string.h&gt;</code>.</p>
",6
54228388,54228175,2,"<p>You can do something like this.  Don't initialize <code>temp</code>.  Just advance the pointers to the characters until you hit the null terminator in str1.  This will be less efficient than the strcpy implementation.</p>

<pre><code>    char *p = str1;
    char *q = temp;

    while (*p)
            *q++ = *p++;

    *q = '\0';
</code></pre>
",1
48378530,48378100,1,"<p>C strings are simple arrays of characters, terminated by a trailing null character. You cannot assign arrays to other arrays, but you can assign them to pointers.</p>

<p>Now by doing <code>names[i] = &amp;name;</code>, you are <em>doing</em> such a pointer assignment. Other than Java or C++ strings, just the address is copied to the pointer, there is no copying of string contents involved (by the way, &amp;name is of bad type: <code>char(*)[20]</code>, i. e. a pointer to array of length 20, you need a pointer to char, which you get by simply assigning name directly: <code>names[i] = name;</code>; name decays to a pointer automatically in this case).</p>

<p>The result is that all your string pointers in <code>names</code> point to one and the same character array <code>name</code>, overwriting the pointers to the arrays created by malloc (these are then lost completely, so you cannot free them again either, i. e. you have a memory leak!).</p>

<p>Instead, you have to copy the strings explicitly. However, to not forget the trailing null character:</p>

<pre><code>int len = strlen(name)     + 1;
// trailing null char(!):  ^^^
names[i] = malloc(len);
memcpy(names[i], name, len);
</code></pre>

<p>Notice: using memcpy. Alternatives would have been strcpy or strncpy, but as length (including the trailing null character!) is known anyway, memcpy is most efficient...</p>

<p>Alternative could have been:</p>

<pre><code>names[i] = malloc(20);
scanf(""%19s"", names[i]);
</code></pre>

<p>You spare copying for the price of the arrays potentially being too long. Have a close look on the format string: By adding a maximal length (you need to leave space for the terminating null character <em>again</em>, thus one less!) you prevent the user from writing beyond your buffer (which would be undefined behaviour and potentially lead to crash). If you do not return the array anywhere, even nicer:</p>

<pre><code>char names[3][20];
</code></pre>

<p>Edit: Nice alternative, too: <code>strdup</code> (see coderredoc's answer); Two other important points:</p>

<ul>
<li>always check the result of <code>malloc</code> for being null (memory allocation might have failed! - again see coderredoc's answer).</li>
<li>avoid (further) memory leaks by freeing the created strings again (not with my very last alternative)! </li>
</ul>
",0
48857869,48857596,2,"<p><code>##</code> is the preprocessor <a href=""https://www.cprogramming.com/reference/preprocessor/token-pasting-operator.html"" rel=""nofollow noreferrer"">token pasting operator</a>, aka macro concatenation.</p>

<p>It is used to join together text in the preprocessor.</p>

<p>For instance <code>#define type i##nt</code> replaces to <code>int</code>. It's a way to get the pre-processor to recognize arguments that need to be concatenated to adjacent tokens.</p>

<p><code>#define MK_CMD(x) void cmd_ ## x (arg_t*)</code> is used by the author to declare a function prototype.</p>

<p>When invoked, <code>MK_CMD(hello)</code> would replace to <code>void cmd_hello(arg_t*)</code>.</p>

<p>If instead the #define were declared as <code>#define MK_CMD(x) void cmd_x (arg_t*)</code>, it would only ever emit <code>void cmd_x (arg_t*)</code> instead of replacing x with the macro argument.</p>
",0
48857898,48857596,4,"<p>You use this kind of macros when you are ""lazy"". Sometimes you have a bunch of
functions that are almost identical and they differ only very slightly. Instead
of writing the same code over and over, you can use a macro to save you
keystrokes. And if you find a bug in one, the others might have to fixed at the
same place again. Having a macro like this solves the problem, because if you
fix the bug in the macro, you fix it for all functions at the same time.</p>

<p>The <code>##</code> in a macro is a concatenation, it allows to merge tokens when expanding
the macro. A useful place for this is this:</p>

<pre><code>#define MK_CMD(x) void cmd_ ## x (arg_t*)
//Functions definitions
MK_CMD(prompt);
MK_CMD(load);
MK_CMD(disp);
MK_CMD(add);
MK_CMD(mul);
MK_CMD(sqrt);
MK_CMD(exit);
MK_CMD(help);
</code></pre>

<p>This will expand to</p>

<pre><code>void cmd_prompt(arg_t*);
void cmd_load(arg_t*);
void cmd_disp(arg_t*);
...
</code></pre>

<p>This is declaring functions for the compiler, so that it knows that there is a
function called <code>cmd_prompt</code> that takes a pointer to <code>argt_t</code> as an argument.
There is a function called <code>cmd_load</code> that ....</p>

<p>Let's say you later realized that the <code>cmd_*</code> functions need a second argument,
an <code>int</code>, then you don't have to manually change all function prototypes, you
only have to change the macro to</p>

<pre><code>#define MK_CMD(x) void cmd_ ## x (arg_t*,int)
</code></pre>

<p>and all other functions will have that parameter. See, a feature for the ""lazy""
programmer.</p>

<p>The other macro falls also into this category, this time is to create a
initialization for the array with curly braces (this has an specific name I cannot
remember right now), like <code>int arr[3] = {1, 2, 3}</code>;</p>

<p>Once again, the ""lazy"" programmer may not want to use the curly braces all over
the place and to increase readability, so it does:</p>

<pre><code>#define CMD(func, params, help) {#func, cmd_ ## func, params, help}
#define CMDS 8
cmd_t dsp_table[CMDS] ={
CMD(prompt,""s"",""Select the prompt for input""),
CMD(load,""cf"",""Load into register float""),
CMD(disp,""c"",""Display register""),
CMD(add,""ff"",""Add two numbers""),
CMD(mul,""ff"",""Multiply two numbers""),
CMD(sqrt,""f"",""Take the square root of number""),
CMD(exit,"""",""Exits the interpreter""),
CMD(help,"""",""Display this help"")};
</code></pre>

<p>which expands to:</p>

<pre><code>cmd_t dsp_table[8] = {
    {""prompt"", cmd_prompt, ""s"", ""Select the prompt for input""},
    {""load"", cmd_load, ""cf"", ""Load into register float""},
    ...
};
</code></pre>

<p>I use lazy in quotes, because I don't necessarily mean that as a negative thing.
This features of macros can be dead useful when used properly and can save you a
lot of time. I have used that in the past for a library that encapsulates reading and setting
values through something like a union, but more complex. The code looks like this:</p>

<pre><code>#define sensor_set_value_typed(gtype, type_short_name, c_type)\
int sensor_set_value_ ## type_short_name(sensor *sens, c_type val)\
{\
    gtype t_val;\
    gtype_id type_id;\
    if(sens == NULL)\
        return 0;\
    ...\
    gtype_init(&amp;t_val);\
    gtype_set_type(&amp;t_val, gtype);\
    gtype_set_value(&amp;t_val, &amp;val);\
    return complicated_api_set_value(sens, &amp;t_val);\
}
</code></pre>

<p>I removed many parts of the code and renamed some of the variables and functions, because this code is not open source, I just want to ilustrate
the idea behind the macros without revealing all that happens behind the scenes. The algorithm is the
same for 99% percent of the code, only the <code>gtype</code> information is different and
these functions can be used as a wrapper of the more clunkly type encapsulating
library. But in order to do so without the macro, I would have to make a lot of copy&amp;paste and change one line for all those
functions. If I found one error on one of the wrappers, I have to fix the same
error at the same place on all wrappers. With the macro I can do this:</p>

<pre><code>sensor_set_value_typed(GTYPE_BOOL, bool,  bool);
sensor_set_value_typed(GTYPE_I8, i8,  int8_t);
sensor_set_value_typed(GTYPE_U8, u8, uint8_t);
sensor_set_value_typed(GTYPE_I16, i16,  int16_t);
sensor_set_value_typed(GTYPE_U16, u16, uint16_t);
sensor_set_value_typed(GTYPE_I32, i32,  int32_t);
sensor_set_value_typed(GTYPE_U32, u32, uint32_t);
sensor_set_value_typed(GTYPE_I64, i64,  int64_t);
sensor_set_value_typed(GTYPE_U64, u64, uint64_t);
sensor_set_value_typed(GTYPE_FLOAT, float,  float);
sensor_set_value_typed(GTYPE_LONG, long, long);
sensor_set_value_typed(GTYPE_DOUBLE, double,  double);
</code></pre>

<p>and now I have 12 wrappers of the basic library in 12 lines. Now the user can use the
wrapper</p>

<pre><code>int32_t val = get_value_from_real_sensor();
sensor_set_value_i32(sensor, val);
</code></pre>

<p>instead of using the complicated underlying library. The <code>GTYPE_BOOL</code>,
<code>GTYPE_I8</code>, etc are values defined in an <code>enum</code> which describes the basic types.</p>
",0
56258932,56258014,2,"<p>In C, the evaluation of an expression is determined by the operator and its operands, not by where the result will eventually be stored.</p>

<p>The expression <code>a * b * d</code> is structured as <code>(a * b) * d</code>. So <code>a * b</code> is evaluated, and then the result is multiplied by <code>d</code>.</p>

<p>One of the rules for <code>*</code> is in C 2018 6.5.5 3:</p>

<blockquote>
  <p>The usual arithmetic conversions are performed on the operands.</p>
</blockquote>

<p>The <em>usual arithmetic conversions</em> are defined in 6.3.1.8 1. They are a bit complicated, and I give most of the details below. Applying them to your example:</p>

<ul>
<li>In <code>a * b</code>, <code>a</code> is a <code>uint32_t</code> , and <code>b</code> is a <code>uint8_t</code>.</li>
<li>The <em>integer promotions</em> convert <code>b</code> to an <code>int</code>¡ªessentially all arithmetic in <code>C</code> is done in a width of at least <code>int</code>.</li>
<li>If <code>int</code> is 32 bits or narrower, <code>a</code> remains <code>uint32_t</code>. Otherwise, <code>a</code> is converted to <code>int</code>.</li>
<li>If converted types of <code>a</code> and <code>b</code> are both <code>int</code>, the conversions are done, and the multiplication is performed.</li>
<li>If the converted type of <code>a</code> is <code>uint32_t</code>, <code>b</code> is converted to <code>uint32_t</code>, and the multiplication is performed.</li>
<li>Then the multiplication with <code>d</code> is performed the same way.</li>
</ul>

<p>So, if <code>int</code> is 32 bits or narrower, the multiplications are performed with <code>uint32_t</code>, and the result is <code>uint32_t</code>. If <code>int</code> is wider, the multiplications are performed with <code>int</code>, and the result is <code>int</code>.</p>

<p>Casting either operand to <code>uint64_t</code> would cause the arithmetic to be done with <code>uint64_t</code>. (Except it is theoretically possible that <code>int</code> is wider than <code>uint64_t</code>, in which case the arithmetic would be done with <code>int</code>, but that is still satisfactory¡ªperforming a cast guarantees the arithmetic will be done with at least that width.)</p>

<p>For real numbers, the usual arithmetic conversions are largely:</p>

<ul>
<li>If either operand is <code>long double</code>, the other is converted to <code>long double</code>.</li>
<li>Otherwise, if either is <code>double</code>, the other is converted to <code>double</code>.</li>
<li>Otherwise, if either is <code>float</code>, the other is converted to <code>float</code>.</li>
<li>Otherwise, the <em>integer promotions</em> are performed on both operands.</li>
<li>Then, if both have the same type, no further conversion is performed.</li>
<li>Otherwise, if both are signed or both are unsigned, the narrower (actually ¡°lesser rank¡±) operand is converted to the type of the other.</li>
<li>Otherwise, if the unsigned operand is the same width or wider (greater or equal rank), the signed operand is converted to the type of the unsigned operand.</li>
<li>Otherwise, if the type of the signed operand can represent all the values of the type of the unsigned operand, the unsigned operand is converted to the type of the signed operand.</li>
<li>Otherwise, both operands are converted to the unsigned type that has the same width as the signed operand.</li>
</ul>

<p>The integer promotions are defined in 6.3.1.1 2. They apply to all integer types as wide as or narrower than <code>int</code> or <code>unsigned int</code> (technically of rank less than or equal to the rank of <code>int</code> and <code>unsigned int</code>), including bit-fields of type <code>_Bool</code>, <code>int</code>, <code>signed int</code>, or <code>unsigned int</code>.</p>

<blockquote>
  <p>If an <code>int</code> can represent all values of the original type (as restricted by the width, for a bit-field), the value is converted to an <code>int</code>; otherwise, it is converted to an <code>unsigned int</code>. These are called the integer promotions. All other types are unchanged by the integer promotions.</p>
</blockquote>
",2
53716203,53716081,1,"<p>It looks like you want to do a left-shift (rotation). <br>
This is a pretty simple operation</p>

<ul>
<li>Keep a pointer to the head</li>
<li>For every element, make that spot point to the next element</li>
<li>put the head on the tail</li>
</ul>

<p>The Code:</p>

<pre><code>#include &lt;stdio.h&gt;

void rotateLeft( char **arr, int elements )
{
    // keep a pointer to the head
    char *head = arr[0];

    // shift every element left
    for (int i=0; i&lt;(elements-1); i++)
    {
        arr[i] = arr[i+1];
    }

    // put the head on the tail
    arr[elements-1] = head;
}

// EDIT - rotate without [] notation.
void rotateLeftNoArrayNotation( char **arr, int elements )
{
    // keep a pointer to the head
    char *head = *arr; //arr[0];

    // shift every element left
    for (int i=0; i&lt;(elements-1); i++)
    {
        *(arr+i) = *(arr+i+1); //arr[i] = arr[i+1];
    }

    // put the head on the tail
    *(arr+elements-1) = head; //arr[elements-1] = head;
}

int main( void )
{
    char *players[3] = { ""Player 1"", ""Player 2"", ""Player 3"" };

    for (int i=0; i&lt;3; i++)
        printf( ""players[%u] = \""%s\""\n"", i, players[i] );

    rotateLeftNoArrayNotation( players, 3 );

    for (int i=0; i&lt;3; i++)
        printf( ""players[%u] = \""%s\""\n"", i, players[i] );

    return 0;
}
</code></pre>

<p>Which gives:</p>

<pre><code>$ ./rotLeft
players[0] = ""Player 1""
players[1] = ""Player 2""
players[2] = ""Player 3""
players[0] = ""Player 2""
players[1] = ""Player 3""
players[2] = ""Player 1""
</code></pre>
",3
59049447,59049190,3,"<blockquote>
  <p>, then there is no need for an extern declaration in the function.</p>
</blockquote>

<p>Here what Dennis Ritchie saying is that, If definition of nn varibale is already occured in source file then now in <code>function1()</code> and <code>funcation2()</code> you do not need to declare variable as <code>extern</code> again, like (<code>extern int nn;</code>) you can directly use them.</p>

<p>But by doing <code>int nn;</code> in your <code>funcation1()</code> you are defining one another local variable. Which is complete different variable. </p>
",0
59049544,59049190,1,"<p>You're completely misunderstanding Mr. Richie. He's saying that this:</p>

<pre><code>int n;

void foo()
{
    n = 42;
}
</code></pre>

<p>requires no <code>extern</code> because the referenced variable <code>n</code> is defined <em>before</em> the function, <code>foo</code>, that uses it.</p>

<p>Were the code like this:</p>

<pre><code>void foo()
{
    n = 42;
}

int n;
</code></pre>

<p>the compiler now has no idea what you're talking about when using <code>n</code> in the body of <code>foo</code>. There is no <code>n</code> until later, but the compiler has no idea that there ever <em>will</em> be. </p>

<p>You can address this by:</p>

<pre><code>extern int n;

void foo()
{
    n = 42;
}

int n;
</code></pre>

<p>Now, when compiling <code>foo</code>, the compiler knows there is some <code>int</code> called <code>n</code> ... somewhere. Doesn't know where yet, and frankly doesn't care. Likewise, this will also work:</p>

<pre><code>void foo()
{
    extern int n;
    n = 42;
}

int n;
</code></pre>

<p>That's all he's trying to say. Your code and comments seem to think that by doing this:</p>

<pre><code>void foo()
{
    int n;
    n = 42;
}

int n;
</code></pre>

<p>the <code>n</code> in <code>foo</code> will magically resolve to the outer <code>n</code>. That isn't how the language works. All this does is make the code compile because now the compiler sees an <code>n</code> that fulfills usage for <code>n = 42</code>. It's an <em>automatic</em> variable (lifetime to the <code>{</code> scope <code>}</code> in which it is declared). It has absolutely nothing to do with the <code>int n;</code> outside that scope (but can easily shadow (hide) the name <code>n</code> if you're not careful. That is exactly what is happening in your code.</p>
",0
57881979,57881594,1,"<p>When you delete a node <code>it</code>, you need to both replace the previous node's next pointer with <code>it-&gt;next</code>, and replace the next node's previous pointer with <code>it-&gt;prev</code>.</p>

<p>However, when doing this you must also account for the special cases at the start and end of the list:</p>

<pre><code>if (it-&gt;prev != NULL)
    it-&gt;prev-&gt;next = it-&gt;next;
else
    this-&gt;first = it-&gt;next;

if (it-&gt;next != NULL)
    it-&gt;next-&gt;prev = it-&gt;prev;
else
    this-&gt;last = it-&gt;prev;
</code></pre>

<p>Your <code>tmp</code> variable should just be used to save the pointer to the next node to be examined, in case <code>it</code> is freed.  Putting it all into your loop:</p>

<pre><code>Bool LinkedList_removestr(LinkedList * this, char * str)
{
    Node * tmp = NULL;
    Node * it = this-&gt;first;
    Bool Bandera = FALSE;

    while (it != NULL)
    {
        /* Save it-&gt;next, because 'it' may be freed */
        tmp = it-&gt;next;

        if (strcmp(it-&gt;name, str) == 0)
        {
            Bandera = TRUE;

            /* Adjust next pointer of previous node */
            if (it-&gt;prev != NULL)
                it-&gt;prev-&gt;next = it-&gt;next;
            else
                this-&gt;first = it-&gt;next;

            /* Adjust previous pointer of next node */
            if (it-&gt;next != NULL)
                it-&gt;next-&gt;prev = it-&gt;prev;
            else
                this-&gt;last = it-&gt;prev;

            free(it);
        }

        it = tmp;
    }

    return Bandera;
}
</code></pre>
",2
54869096,54865006,0,"<p>I have seen macros used to simplify complex expressions, or to simplify accessing members of deeply nested structures, something like</p>

<pre><code>#define GET_NAME(foo) (foo)-&gt;bar-&gt;blah-&gt;name
</code></pre>

<p>I've never seen anyone use a macro to <em>just</em> abstract away a <code>&amp;</code> operation on a specific global object, though.  Without more context I can't say whether it's a good or bad idea.  </p>
",0
54866187,54865006,0,"<p>I don't think it's that bad...</p>

<p>Some implementation do something similar with <code>errno</code>:</p>



<pre class=""lang-c prettyprint-override""><code>extern int *__geterrno(void);

#define errno (*__geterrno())
</code></pre>
",0
51898301,51898140,0,"<p><a href=""http://port70.net/~nsz/c/c11/n1570.html#6.5.7p3"" rel=""nofollow noreferrer"">6.5.7p3</a> on Bitwise Shift Operations says:</p>

<blockquote>
<pre><code>The integer promotions are performed on each of the operands.
</code></pre>
</blockquote>

<p>If you have a subint type on the left side (or right side, but there it doesn't really matter) of a bitshift operations, it'll be promoted to <code>int</code>. </p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
    http://port70.net/~nsz/c/c11/n1570.html#6.5.7p3
#define TPSTR(X) _Generic(X,unsigned char: ""uchar"", int: ""int"")
    unsigned char c = 0x0F;
    printf(""%s\n"", TPSTR(c&gt;&gt;2));
    printf(""%s\n"", TPSTR((unsigned char)c&gt;&gt;2));
    printf(""%s\n"", TPSTR((unsigned char)c&gt;&gt;(unsigned char)2));
}
</code></pre>

<p>compiles and prints <code>int int int</code>.</p>

<p>The result of a right-shift on a signed integer type (int) will only be implementation defined iff the left operand has a negative value:</p>

<p><a href=""http://port70.net/~nsz/c/c11/n1570.html#6.5.7p5"" rel=""nofollow noreferrer"">6.5.7p5</a>:</p>

<blockquote>
  <p>If E1 has a signed type and a negative value, the resulting value is
  implementation-defined.</p>
</blockquote>
",1
51898265,51898140,5,"<p>The result will always be well defined.</p>

<p>A right shift of a signed type is only implementation defined <em>if the value is negative</em>.  This is specified in section 6.5.7p5 of the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""noreferrer"">C standard</a> regarding Bitwise shift operators:</p>

<blockquote>
  <p>The result of E1 >> E2 is E1 right-shifted E2 bit positions. If E1 has
  an unsigned type or if E1 has a signed type and a nonnegative value,
  the value of the result is the integral part of the quotient of E1 /
  2<sup>E2</sup>. If E1 has a signed type and a negative value, the resulting value
  is implementation-defined.</p>
</blockquote>

<p>The value also cannot be negative because integer promotions preserve the sign of the value being promoted.  From section 6.3.1.1p3 regarding conversion of integers:</p>

<blockquote>
  <p>The integer promotions preserve value including sign. As discussed
  earlier, whether a ""plain"" char is treated as signed is
  implementation-defined.</p>
</blockquote>

<p>So because the value is guaranteed to be positive, the right shift operation is well defined.</p>
",4
52839199,52839067,3,"<p><code>""space farers""</code> is a sequence of characters. C handles this by treating it as a pointer to the first character. This is why you see</p>

<pre><code>char * str = ""space farers"";
</code></pre>

<p><code>*xx</code> says 'return what this pointer xx points at'. For  <code>*""space farers""</code> thats the first character of the string, ie <code>s</code>.</p>

<p>A clearer way would be</p>

<pre><code> char * str = ""space farers"";
 char s = *str;
</code></pre>

<p>this removes the strange <code>*""....""</code> construct;</p>
",4
52839948,52839067,3,"<p>Under most circumstances, an <em>expression</em> of type ""N-element array of <code>T</code>"" will be converted (""decay"") to an expression of type ""pointer to <code>T</code>"", and the value of the expression will be the address of the first element of the array.  The exceptions occur when the array expression is the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, or is a string literal used to initialize a character array in a declaration.</p>

<p>Thus, for any array</p>

<pre><code>T arr[N];
</code></pre>

<p>the expression <code>arr</code> will ""decay"" to type ""pointer to <code>T</code>"", and the value will be the same as <code>&amp;arr[0]</code>.  </p>

<p>The <em>expression</em> <code>""space farers""</code> has type ""13-element array of <code>char</code>"".  Since it isn't the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, and it isn't being used to initialize a character array in a declaration, it ""decays"" to an expression of type <code>char *</code>, and the value of the expression is the address of the first element of the array.  Just as <code>*arr</code> is equivalent to <code>arr[0]</code>, <code>*""space farers""</code> is equivalent to <code>""space farers""[0]</code>, and gives us the <em>value</em> stored in the first element of the array - the character value <code>'s'</code>.  </p>
",3
52803122,52803097,1,"<p>The <code>for</code> loop runs the next statement in the code the appropriate number of times. Often this statement is a single statement, or a group of statements in curly brackets. If you put a semicolon instead, it's treated as a <a href=""https://stackoverflow.com/questions/5599380/use-of-null-statement-in-c"">null statement</a>, and so ""nothing"" is done the appropriate number of times.</p>

<p>If you explain what you mean when you say ""How could I wrap it around intuitively?"" that might make it easier to answer your question.</p>
",0
52803138,52803097,2,"<p>The statement</p>

<pre><code>for (gap = n/2; gap &gt; 0; gap /= 2) ;
</code></pre>

<p>is equal to</p>

<pre><code>for (gap = n/2; gap &gt; 0; gap /= 2)
    ;
</code></pre>

<p>which is equal to</p>

<pre><code>for (gap = n/2; gap &gt; 0; gap /= 2)
{
}
</code></pre>

<p>In other words, that's an empty loop that does nothing except the comparison <code>gap &gt; 0</code> and <code>gap /= 2</code> (part of the loop) each iteration.</p>
",0
52803151,52803097,1,"<p>The syntax of the for loop is (simplified for clarity):</p>

<pre><code>for ( ... ) &lt;statement&gt;

statement:
     ';'  // empty statement
      &lt;any other statement&gt;
     '{' ... '}'  // block of statements
</code></pre>

<p>So following the for statement comes one statement or a block of statement. And a single <code>;</code> is a statement, namely the empty (do nothing) statement. So</p>

<pre><code>for (....) ;
    for (....) ;
</code></pre>

<p>is <em>not</em> a nested for-loop. It is equivalent to:</p>

<pre><code>for (....) ;
for (....) ;
</code></pre>

<p>or</p>

<pre><code>for (....) {}
for (....) {}
</code></pre>
",0
52925238,52925136,3,"<p>The <code>shost</code> and <code>dhost</code> members of the structure are arrays (or possibly pointers). Arrays will decay to pointers to their first element, i.e. using plain <code>eth-&gt;dhost</code> is the same as <code>&amp;eth-&gt;dhost[0]</code>.</p>

<p>A pointer is usually 32 or 64 bits wide on modern computers, while a <code>char</code> is typically only 8 bits wide. In other words, it's really impossible to store a pointer in a <code>char</code>.</p>

<p>What you need to do is to ""return"" the <em>pointer</em> instead of a single byte. To do this define <code>destination</code> and <code>src</code> as pointers:</p>

<pre><code>unsigned char *destination, *src;
</code></pre>

<p>And update the function arguments to pointer to pointers:</p>

<pre><code>void get_ethernet_header(const u_char *Buffer, int Size,
                         unsigned char** destination,
                         unsigned char** src, unsigned short* qtype)
</code></pre>

<p>Finally remember to print it the correct way (like you do inside the <code>get_ethernet_header</code> function). The rest can stay the same.</p>

<hr>

<p>Another and possible safer solution, is to use arrays instead, and copy the data. Then you don't have to rely on the ""buffer"" containing the structure being alive and valid.</p>
",2
53819854,53817191,0,"<p>The program can be made faster by changing <code>for(int i=2; n!=1;){</code> to <code>for(int i=2; i*i &lt;= n;){</code>. This terminates the search for factors once <code>n</code> is less than the square of the current candidate factor. There can be no prime factors after this point, other than <code>n</code> itself, since if <code>j</code> were a prime factor greater than <code>i</code>, then <code>n/j</code> would be a factor less than <code>i</code>. But such a factor would have been extracted from <code>n</code> earlier in the loop.</p>

<p>Since this means the loop may exit with <code>n</code> being a prime factor, it is necessary to insert some code after the loop to test whether <code>n</code> is greater than 1 and, if so, adjust <code>totalFactor</code> and <code>primeFactor</code> accordingly.</p>

<p>The program can also be made faster by testing only prime numbers as candidate factors instead of testing every integer from 2 on. Note that, since the program is required to support numbers up to 2,000,000, and the new loop will stop at the square root of <code>n</code>, only primes up to 1,414 are needed. A list of such primes can easily be prepared in advance.</p>
",0
59359256,59359205,4,"<p><code>return</code> literally exits the function, possibly returning a value to the caller. Nothing executes in the function after it is reached.</p>

<p>For a <code>void</code> return, you can just put the return on a later line:</p>

<pre><code>LCS(X, Y, m - 1, n - 1);
printf(""%c"", X[m - 1]);
return;
</code></pre>

<p>If your function does return something (say an <code>int</code>), you could store it in a temporary variable, do your thing, then return;</p>

<pre><code>int val = LCS(X, Y, m - 1, n - 1);
printf(""%c"", X[m - 1]);
return val;
</code></pre>
",0
59359248,59359205,10,"<p>Once a <code>return</code> statement is encountered, the function returns immediately from that point.  No further statements after the <code>return</code> are executed.</p>

<p>Just because you're using recursion that doesn't mean you need to return immediately on the recursive call.  What you need here is to first make the recursive call, then print, then return.</p>

<pre><code>if(X[m-1]==Y[n-1])
{
    LCS(X,Y,m-1,n-1);
    printf(""%c"",X[m-1]);
    return;
}
if(map[m-1][n]&gt;map[m][n-1])
    LCS(X,Y,m-1,n);
else
    LCS(X,Y,m,n-1);
</code></pre>

<p>Also, note that since the function's return type is <code>void</code> that you can't specify a return value in a <code>return</code> statement.</p>
",0
59360628,59359205,-2,"<p>Late to the party. You cannot put anything after the return statement. If you really really want it, you might emulate the behaviour. You can achieve it with macro programming.</p>

<pre><code>#define RETURN(x, y) { \
    printf(""%c"", (y)); \
    return (x); \
}
</code></pre>

<p>Usage:</p>

<pre><code>if(X[m-1]==Y[n-1]) {
    RETURN(LCS(X,Y,m-1,n-1), X[m-1]);
}
</code></pre>

<p>If you are really into it, you can create a generic version allowing for side effects on <code>y</code> from <code>x</code>:</p>

<pre><code>#define RETURN(type, x, y) { \
    type result = (x); \
    printf(""%c"", (y)); \
    return (result); \
}
</code></pre>

<p>Finally, you want to print something else, you can achieve it with this macro (macro can be further improved via P99, if you really want):</p>

<pre><code>#define RETURN(type, x, format, ...) { \
    type result = (x); \
    printf(format, ## __VA_ARGS__); \
    return (result); \
}
</code></pre>
",4
48881633,48881585,2,"<p>Your question is not very clear.</p>

<p>Of course converting a value from one type to one with fewer bits available will lose the bits that don't fit, so if they're being used they will be lost. Where would it otherwise go?</p>

<p>For pointers the question is even less clear, the size of the pointed-at object does not affect the size of the pointer, in general.</p>

<p>Given:</p>

<pre><code>struct small { int a; };
struct big { int b[1000]; };
</code></pre>

<p>it does <em>not</em> follow that <code>sizeof (struct small *)</code> is smaller than <code>sizeof (struct big *)</code>, and on many typical modern systems they will be the exact same size.</p>
",3
48675557,48675353,0,"<p>After </p>

<pre><code> wait(NULL);
</code></pre>

<p>You need an exit/return. The parent has done its job of bringing up the child and is done</p>
",0
52407121,52406955,1,"<p>You seek to the end of the file, so <code>fread</code> will have nothing to read. You need to seek back to the start.</p>

<p>The <code>fread</code> is also being asked to read the length of the path, which seems wrong, the way your loop is set up seems to be for 1 byte at a time.</p>

<pre><code>fseek(fp, 0, SEEK_END); // Seeks to end of file
int len = ftell(fp);

// Nothing to read, at end
while (fread(buffer, strlen(path), 1, fp) == 1){
    printf(""%02x hexabytes\n"", len);
}
</code></pre>

<p>Simply seek again after the <code>ftell</code>.</p>

<pre><code>fseek(fp, 0, SEEK_END); // Seeks to end of file
int len = ftell(fp);
fseek(fp, 0, SEEK_SET); // Go to start again
// Read from start, 1 byte at a time
char byte;
while (fread(&amp;byte, 1, 1, fp) == 1){
    printf(""%02X\n"", (int)byte);
}
</code></pre>

<p>You could also read 1000 bytes at a time (as your <code>buffer</code> is) but then you need a second loop, or you could read the entire file, but you need to dynamically allocate the buffer (<code>buffer = malloc(len);</code>).</p>
",3
52408283,52406955,1,"<p>Even if you fix the <code>fseek</code> problem, you have other issues:</p>

<pre><code>while (fread(buffer, strlen(path), 1, fp) == 1){
  printf(""%02x hexabytes\n"", len);
}
</code></pre>

<p>Note that you are not reading a single byte at a time; you're reading bytes in <code>strlen(path)</code>-sized chunks at a time.</p>

<p>You're also not printing the byte(s) you just read; you're printing the <em>length of the file</em>.  So assuming your file size is, say, 65536 bytes, you'll get the output</p>

<pre><code>10000 hexabytes
10000 hexabytes
10000 hexabytes
...
</code></pre>

<p><code>65536 / strlen(path)</code> times.  I don't think that's what you want.</p>

<p>I think what you're going for is something more along these lines:</p>

<pre><code>unsigned char buffer[1000]; // for arbitrary bytes, unsigned char works better.

int bytes_read = 0;

while ( (bytes_read = fread( buffer, 1, sizeof buffer, fp )) != EOF )
{
  for( int b = 0; b &lt; bytes_read; b++ )
  {
    printf( ""%02hhx\n"", buffer[b] ); // %x expects unsigned *int*, use the
  }                                  // hh modifier to specify unsigned char
}
</code></pre>

<p>The expression</p>

<pre><code>bytes_read = fread( buffer, 1, sizeof buffer, fp )
</code></pre>

<p>reads up to <code>sizeof buffer</code> (1000 in this case) bytes from <code>fp</code> and stores the number actually read to <code>bytes_read</code>.  If we haven't hit <code>EOF</code>, then we print the contents of <code>buffer</code>.  </p>
",0
52407033,52406955,1,"<p>You need to reset the file pointer to the beginning of the file:</p>

<pre><code>fseek(fp, 0, SEEK_SET);
</code></pre>
",4
54083120,54082905,0,"<blockquote>
  <p>How is it possible to ""combine"" these two types of code to have array wrappers that depends of a variable ?</p>
</blockquote>

<p>You cannot, at least in standard C.  In the standard's terms, the members of a structure type cannot be variably-modified. This serves the purpose that the size of a structure type is always a compile-time constant (even, technically, structure types having flexible array members).</p>

<p>In the general case, you have the alternative of passing your array normally, in the form of a pointer to its first element.  You may declare the function parameter as a pointer to <code>const</code> elements, so that the function cannot modify the array (at least, not without casting away the <code>const</code>ness, which you could surely persuade your compiler to warn about).</p>

<p>That does not serve your <code>copyarray()</code> use case, because you cannot return arrays (as such) either, nor assign to whole arrays. But <code>memcpy()</code> does that job fine without need for wrapping or passing around arrays by value, so the case seems contrived.</p>
",0
52385828,52385096,0,"<p>Hell first of all you can try and hardcode it :) Just kidding.</p>

<p>If you are on linux, you can get binary name withing /proc/pid/exe.</p>

<p>For example:</p>

<pre><code>auto ret = readlink(""/proc/self/exe"", buf, sizeof(buf));
if (ret == -1) //error
std::string fpath(buf, ret);
</code></pre>

<p>Now in fpath you have absolute path to your program. You can parse your program out with function like dirname.</p>

<p>So first you need to get absolute path to char*. This can be done with strcpy</p>

<pre><code>char *fullpath = new char[fpath.length()+1];
strcpy(fullpath, fpath.c_str());
std::string dir = dirname(fullpath);
std::string program_name = fpath.substr(dir.length());

printf(""Usage: %s argument\n"", program_name);
</code></pre>

<p>And that is it. I will just leave it for you to decide size of the buffer ;)</p>

<p>If you are on Windows, you can use function GetModuleFileName
<a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms683197(v=vs.85).aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/ms683197(v=vs.85).aspx</a></p>

<p>Enjoy</p>
",3
58394484,58394456,5,"<p>This:</p>

<pre><code>for(int i=0; i&lt;sizeof(length); i++){
                 ^
                 |
                wut
</code></pre>

<p>Is not correct, you're not interested in looping over the bytes of <code>length</code> itself. It should just be:</p>

<pre><code>for(int i = 0; i &lt; length; ++i){
</code></pre>
",1
58255711,58255615,1,"<p><code>p = ...</code> never persists across the function call. Like everything else in C, if you want to change the caller's data, dereference the pointers you're given. <code>k</code> should be <code>int *</code>, and the assignments should be <code>int *k = *a; *a = *b; *b = k;</code>. that's it. Note also this changes <em>nothing</em> about the original <code>a</code> and <code>b</code>. All your swapping at this point are pointer values.</p>

<p>This code swaps two integers</p>

<pre><code>#include&lt;stdio.h&gt;

void fun(int *a,int *b)
{
    int k = *a;
    *a = *b;
    *b = k;
}

int main()
{
    int a=3,b=6;
    printf(""%d %d\n"",a,b);
    fun(&amp;a,&amp;b);
    printf(""%d %d\n"",a,b);
    return 0;
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>3 6
6 3
</code></pre>

<p>Whereas, this code swaps two pointers. The integers they point to (a and b) remain as-is.</p>

<pre><code>#include&lt;stdio.h&gt;

void fun(int **a,int **b)
{
    int *k = *a;
    *a = *b;
    *b = k;
}

int main()
{
    int a=3,b=6,*x=&amp;a,*y=&amp;b;
    printf(""%d %d\n"",a,b);
    printf(""%d %d\n"",*x,*y); // note using x and y with deref
    fun(&amp;x,&amp;y);
    printf(""%d %d\n"",a,b);
    printf(""%d %d\n"",*x,*y); // note using x and y with deref
    return 0;
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>3 6
3 6
3 6
6 3
</code></pre>
",0
58255683,58255615,0,"<p>Instead of this:</p>

<pre><code>int **k;
k=a;
a=b;
b=k;
</code></pre>

<p>you should have tried this:</p>

<pre><code>int *k;
k=*a;
*a=*b;
*b=k;
</code></pre>

<p>And yeah, you should print <code>*x</code> and <code>*y</code>, because those are the variables you swap, not <code>a</code> and <code>b</code>.</p>
",3
52938340,52934952,0,"<p>Using floating-point for this is problematic, as floating-point arithmetic rounds results to representable values, and the rounding may cause <code>30.6 * month - 91.4</code> to produce values slightly less than 31 or 184 for <code>month</code> being 4 and 9, respectively. Then <code>myfloor(30.6 * month - 91.4)</code> would be the undesired value of 30 or 183 instead of the desired 31 or 184.</p>

<p>There is no need to use floating-point for this, as integer arithmetic suffices:</p>

<pre><code>ordinal_day = (306 * month - 914 + 10000) / 10 - 1000 + day;
</code></pre>

<p><code>(306 * month - 914) / 10 is mathematically equivalent to</code>30.6 * month -91.4<code>except that integer division truncates the result (effectively rounding to an integer in the direction toward zero) instead of taking the floor (rounding to an integer in the direction toward negative infinity). Since we want floor, 10,000 is added to ensure the quotient is positive, and then 1000 is subtract after the division to compensate. (If</code>month` could be ?30 or less, further adjustment is needed, as the quotient could then be negative.)</p>
",0
52935097,52934952,5,"<p>The easiest solution would probably be to just let C do it.  Per <a href=""http://c0x.coding-guidelines.com/6.3.1.4.html"" rel=""nofollow noreferrer"">¡ì 6.3.1.4 of the C11 spec</a>:</p>

<blockquote>
  <p>When a finite value of real floating type is converted to an integer type other than _Bool, the fractional part is discarded (i.e., the value is truncated toward zero).</p>
</blockquote>

<p>So, all you need to do is convert the value to an integer, than convert that back to a float:</p>

<pre><code>float myFloor(float value) {
  return (float) (int) value;
}
</code></pre>

<p>If you need to handle negatives, you can easily do so:</p>

<pre><code>float myFloor(float value) {
  float tmp = (float) (int) value;
  return (tmp != value) ? (tmp - 1.0f) : tmp;
}
</code></pre>
",9
49461187,49461127,1,"<p>For all C runtimes I'm aware of <code>stdout</code> is line buffered when connected to a terminal (and block buffered when connected to anything else), so output is only flushed to the screen when a newline is output, or <code>fflush</code> is used to explicitly flush the buffer. Without the newline (or an <code>fflush(stdout)</code> call), the <code>printf</code> output goes to the buffer, but never gets flushed to the screen.</p>

<p>Obviously, <code>fflush(stdout)</code> fixes this, as does actually outputting a newline. You could also globally disable buffering for <code>stdout</code> with <a href=""http://en.cppreference.com/w/c/io/setvbuf"" rel=""nofollow noreferrer"">the <code>setvbuf</code> function</a>, though that risks slowing I/O.</p>
",0
53398486,53398168,1,"<p>The ""binary"" file you are writing is a source file, not an executable. If I translate your raw data:</p>

<pre><code>unsigned char rawData[106] = {
0x23, 0x69, 0x6E, 0x63, 0x6C, 0x75, 0x64, 0x65, 0x20, 0x3C, 0x73, 0x74,
0x64, 0x69, 0x6F, 0x2E, 0x68, 0x3E, 0x0D, 0x0A, 0x23, 0x69, 0x6E, 0x63,
</code></pre>

<p>It corresponds to the text:</p>

<pre><code>#include
</code></pre>

<p>(etc)</p>

<p>This is not an executable, it is the source file!</p>

<p>You cannot simply save a C source file with an ""exe"" extension and have it be able to run. You need to actually compile it.</p>
",1
53398232,53398168,3,"<p>The format specifier <code>""%s""</code> is for <strong><em>null-terminated</strong> byte strings</em>. The <em>null-terminator</em> equals the byte <code>0</code> (<code>0x00</code>). It's <em>very</em> likely that it exists somewhere in the array data. You need some other way to write it, like e.g. <a href=""https://en.cppreference.com/w/c/io/fwrite"" rel=""nofollow noreferrer""><code>fwrite</code></a>.</p>

<p>Also, since you're writing a binary file, you should open it in binary mode as well. Otherwise any byte corresponding to the newline character (<code>'\n'</code>, <code>0x0a</code> in <a href=""https://en.cppreference.com/w/c/language/ascii"" rel=""nofollow noreferrer"">ASCII encoding</a>) will be translated to the Windows newline sequence <code>""\r\n""</code>.</p>

<p>Lastly, the attributes of the file you create will not include the executable flag.</p>
",3
53398222,53398168,2,"<p><code>fprintf</code> is for writing <em>text</em> to a file or stream. The <code>%s</code> format specifier will stop on a null character, which is obviously not going to work for binary data which can contain nulls anywhere.</p>

<p>Just the fact that it's binary data should be enough to deter you from using <code>fprintf</code> and other text IO functions, but in particular the  PE-EXE format is guaranteed to have nulls within its content by virtue of <a href=""https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files#PE_Header"" rel=""nofollow noreferrer"">its very header</a> which begins with the magic number <code>""PE\0\0""</code>.</p>

<p>Use the function <code>fwrite</code> to write binary data to a file:</p>

<pre><code>fwrite(rawData, 1, sizeof(rawData), file_ptr);
</code></pre>
",2
53295963,53294651,1,"<p>It's not obvious why the posted code fails, but the rule #1 here is to always check the size of the data before copying. In addition, the whole function can be simplified by dropping the malloc. For example:</p>

<pre><code>void dir_forward (const char cmd[])
{
  cmd += sizeof(""cd "") - 1;  // remove ""cd ""

  size_t dst_length = strlen(path);
  size_t src_length = strlen(cmd);
  size_t new_length = dstr_length + src_length + 2; // '\\' and '\0' give +2
  if(new_length &gt; PATH_MAX)
  {
    exit(EXIT_FAILURE);
  }

  char* ptr = &amp;path[dst_length]; // point at null terminator

  memcpy(ptr, cmd, src_length);
  ptr += src_length;

  *ptr = '\\';
  ptr++;

  *ptr = '\0';
}
</code></pre>

<p>Full example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#ifndef PATH_MAX
#define PATH_MAX 255
#endif

static char path[PATH_MAX] = ""C:\\tmp\\"";

void dir_forward (const char cmd[])
{
  cmd += sizeof(""cd "") - 1;  // remove ""cd ""

  size_t dst_length = strlen(path);
  size_t src_length = strlen(cmd);
  size_t new_length = dstr_length + src_length + 2; // '\\' and '\0' give +2
  if(new_length &gt; PATH_MAX)
  {
    exit(EXIT_FAILURE);
  }

  char* ptr = &amp;path[dst_length]; // point at null terminator

  memcpy(ptr, cmd, src_length);
  ptr += src_length;

  *ptr = '\\';
  ptr++;

  *ptr = '\0';
}

int main (void)
{
  dir_forward(""cd foo"");
  puts(path);
}
</code></pre>
",1
54961289,54960959,1,"<p>I had started to write-up an answer, that I just deleted that suggested this is what you wanted:</p>

<pre><code>static void threadStart(void (*function)(void*), void* arg) {
    // schedules thread in Queue
    function(arg);
}
</code></pre>

<p>But then I looked at what you are trying to do with a function pointer, that nearly resembles a <code>pthread_create</code> start routine.</p>

<p>So it didn't make sense that you've got a function called <code>threadStart</code> that neither starts a thread nor appears to be the start routine for a thread.  I could be wrong, because we don't see anything else in your code that suggests how <code>threadStart</code> is invoked.</p>

<p>So I was wondering if this is what you really meant, a function to be run within a thread:</p>

<pre><code>void* threadStart(void* arg)
{
    someOtherCodeOrFunction(arg); // your code goes here
}
</code></pre>

<p>And you meant to instantiate that thread to run that above function with <code>arg</code> as the parameter value:</p>

<pre><code>pthread_create(&amp;thread, NULL, threadStart, arg);
</code></pre>
",0
53604258,53604209,3,"<p>You have uninitialised variables. The initialisation line:</p>

<pre><code>int c, blankCount, tabCount, newlineCount;
</code></pre>

<p>does not actually initialise them to anything<sup>(a)</sup>, and the assignment line:</p>

<pre><code>blankCount, tabCount, newlineCount = 0;
</code></pre>

<p>will simply <em>evaluate</em> the three sub-expressions<sup>(b)</sup> and throw away the results. Only the <em>third</em> subcomponent <code>newlineCount = 0</code> has the side effect of zeroing that variable.</p>

<p>The others will still have some arbitrary value meaning their final value will not indicate correctly the quantities of each.</p>

<p>What you should have instead is something like:</p>

<pre><code>int c, blankCount = 0, tabCount = 0, newlineCount = 0;
</code></pre>

<p>as the initialisation line of your function, and get rid of the assignment line altogether.</p>

<hr>

<p><sup>(a)</sup> Covered in, for example <code>C11 6.7.9 Initialization /10</code>:</p>

<blockquote>
  <p>If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate.</p>
</blockquote>

<hr>

<p><sup>(b)</sup> As you get to know C more deeply, you'll realise they <em>are</em> expressions. The ""statement"" <code>pi = 3.14159</code> is actually an expression that results in <code>pi</code> with the side effect of first setting it to that value. That's why you can do things like <code>twopi = 2 * (pi = 3.14159)</code> and why <code>oldi = i++</code> works.</p>

<p>It also allows for weirdness like being able to compile the statement:</p>

<pre><code>42;
</code></pre>

<p>:-)</p>
",0
50886774,50886679,1,"<p>The conventional to iterate over a list is</p>

<pre><code>for (var = first_item; end_not_reached(var); var = next_after(var))
</code></pre>

<p>Your encoding has the correct order of dates, i.e. <code>var1 &lt;= var2</code> when <code>var1</code> is earlier than <code>var2</code>. Therefore, to check whether you've reached the end of the list, all you need to do is compare the iterator with the end date.</p>

<p>The next month after a given date is given by the following function:</p>

<pre><code>int next_month(int date) {
    return date % 100 == 12 ? date + 89 : date + 1;
}
</code></pre>

<p>Thus:</p>

<pre><code>if (next_month(var1) == var2)
    ... // the months are consecutive with var1 just before var2

for (var = var1; var &lt;= var2; var = next_month(var)) {
    ¡­
}
</code></pre>
",0
50886756,50886679,1,"<p>It seems the encoding scheme for years and months in your two variables are:</p>

<pre><code>combined_value = year * 100 + month
</code></pre>

<p>So the lower two decimal digits are the month, the upper digits (typically 4) are the year. Well, we know how to extract decimal digits in C:</p>

<pre><code>lower_decimal_digit = num % 10
lower_2_decimal_digits = num % 100
</code></pre>

<p>and so on (we can also do this with a variable number of digits but that's not necessary here). Similarly, we can keep only the higher digits:</p>

<pre><code>all_but_lower_decimal_digit = num / 10
all_but_lower_2_decimal_digits = num / 100
</code></pre>

<p>so in your case, the two commands:</p>

<pre><code>int year = combined / 100;
int month = combined % 100;
</code></pre>

<p>do the trick. I'm sure you can proceed from there.</p>
",1
59380616,59379817,0,"<p>Adding an <code>unsigned int</code> (or even a signed <code>int</code>!) is known as <em>pointer arithmetic</em>. It's legal and quite common in C code.  You do have to be very careful about going out of the bounds of your memory buffer, though, or you will experience <em>undefined behavior</em>. This is bad. Fortunately, this code appears to be quite well behaved as long as the original string is less than half the length of its memory buffer.</p>

<p>Allow me to try some ASCII art to see if I can make clear what's going on in the <code>double_string</code> function. It starts with this:</p>

<pre><code>   char *start = ary;
   char *end = ary + strlen(ary);
   char *org = end;
</code></pre>

<p>At this point, your pointers look like this:</p>

<pre><code>    start                                end
      |                                   |
      |                                  org
      |                                   |
      v                                   V
    ----------------------------------------------------------------------------------
ary | T | A | C | s | a | s | a | s | a |\0 |   |   |   |   |   |   |   |   |   |   | ...
    ----------------------------------------------------------------------------------
</code></pre>

<p>Then we have the loop.</p>

<pre><code>  while(start&lt;org)
  {
     *end = *start;
     start++;
     end++;
  }
</code></pre>

<p>After the first loop iteration, it looks like this:</p>

<pre><code>        start                                end
          |                                   |
          |                              org  |
          |                               |   |
          v                               V   V
    ----------------------------------------------------------------------------------
ary | T | A | C | s | a | s | a | s | a | T |   |   |   |   |   |   |   |   |   |   | ...
    ----------------------------------------------------------------------------------
</code></pre>

<p>Second iteration:</p>

<pre><code>            start                                end
              |                                   |
              |                          org      |
              |                           |       |
              v                           V       V
    ----------------------------------------------------------------------------------
ary | T | A | C | s | a | s | a | s | a | T | A |   |   |   |   |   |   |   |   |   | ...
    ----------------------------------------------------------------------------------
</code></pre>

<p>And so on. The loop continues as long as <code>start</code> is less than (to the left of, in my illustration) <code>org</code>:</p>

<pre><code>                                        start                                end
                                          |                                   |
                                         org                                  |
                                          |                                   |
                                          V                                   V
    ----------------------------------------------------------------------------------
ary | T | A | C | s | a | s | a | s | a | T | A | C | s | a | s | a | s | a |   |   | ...
    ----------------------------------------------------------------------------------
</code></pre>

<p>Now <code>start&lt;org</code> is no longer true, because they're equal. They point to the same location. The loop terminates. All that's left to do is terminate the string with <code>*end = '\0';</code>:</p>

<pre><code>                                        start                                end
                                          |                                   |
                                         org                                  |
                                          |                                   |
                                          V                                   V
    ----------------------------------------------------------------------------------
ary | T | A | C | s | a | s | a | s | a | T | A | C | s | a | s | a | s | a |\0 |   | ...
    ----------------------------------------------------------------------------------
</code></pre>
",2
53582366,53582241,1,"<p>Your <code>struct Address</code> contains two <code>int</code> fields followed by two <code>char</code> arrays:</p>

<pre><code>struct Address {
    int streetNumber;
    int apartmentNumber;
    char street[41];
    char postalCode[8];
    char city[41];
};
</code></pre>

<p>but you don't initialize them in that order:</p>

<pre><code>{11, ""Trailer Park"", 0, ""A7A 2J2"", ""King City"" },
</code></pre>

<p>Unless you use named initializers, fields must be specified in order.  Put the street number first, then the apartment number, <em>then</em> the street:</p>

<pre><code>{11, 0, ""Trailer Park"", ""A7A 2J2"", ""King City"" },
</code></pre>

<p>Do the same with the other three.</p>
",2
52175583,52175423,5,"<p>GCC is a menace on occasion.</p>

<p>It allows you to define functions inside other functions ¡ª nested functions.  You have (presumably accidentally and unintentionally) nested your <code>powerOfThree()</code> function inside <code>main()</code>.  If you move the <code>return 0;</code> before the start of <code>powerOfThree()</code> and add the missing close brace, then things will work sanely.</p>

<p>I think that nested functions must be defined before they're used.  See the GCC manual on <a href=""https://gcc.gnu.org/onlinedocs/gcc-8.2.0/gcc/Nested-Functions.html#Nested-Functions"" rel=""nofollow noreferrer"">nested functions</a> ¡ª which does allow a declaration using <code>auto</code> if you must declare it before you define it.  As it stands, the compiler assumes you meant to call the non-nested version of the function declared before <code>main()</code>.  I recommend against using the GCC-only feature (nested functions).</p>

<pre><code>#include &lt;stdio.h&gt;

static int powerOfThree(int);

int main(void)
{
    int userInput;
    printf(""Please enter a number: "");
    if (scanf(""%d"", &amp;userInput) == 1 &amp;&amp; userInput &gt;= 0)
    {
        printf(""The value of 3 to the power %d is: %d\n"",
               userInput, powerOfThree(userInput));
    }
    return (0);
}

static int powerOfThree(int n)
{
    if (n &lt; 1)
        return 1; 
    else
        return (3 * powerOfThree(n-1));
}
</code></pre>
",0
53138566,53138161,2,"<p>The updated code doesn't use <code>capacity</code> in <code>readfile()</code>.  The function doesn't explicitly report an error when it fails to open the file ¡ª that cost me some time.</p>

<p>Here's a variant of your code which produces the output I expect:</p>

<pre><code>#include &lt;stdio.h&gt;
int printcontents(unsigned char storage[ ]);
int changecolor (unsigned char storage[ ]);
int readfile(unsigned char storage[ ], size_t capacity, char filename[ ]);
int main(void)
{
    unsigned char data1[4000] = {0};  
    readfile(data1, 4000, ""file.gif"");    // filled 3022 indices in data1; file.gif exists
    printcontents(data1);       // prints the array contents as desired here 
    changecolor(data1);     // doesn¡¯t change the array contents 
    printcontents(data1);       // prints the same array contents as original      
    return 0;
}
int printcontents(unsigned char storage[ ])
{
    printf(""%#X\n"", storage[13]);  // data1 passed in function call in main
    return 0;
}
int changecolor (unsigned char storage[ ])
{
    storage[13] = storage[13] &gt;&gt; 2;     // data1 passed in function call in main
    return 0;
}
int readfile(unsigned char storage[ ], size_t capacity, char filename[ ])
{
    FILE * content = fopen(filename, ""r"");
    if (content != NULL)
    {
        size_t numElements, bytesPer = sizeof(unsigned char);
        fseek(content, 0, SEEK_END);
        numElements = ftell(content);
        if (numElements &gt; capacity)
            numElements = capacity;
        rewind(content);
        if (fread(storage, bytesPer, numElements, content) != numElements)
            printf(""Bogus input\n"");    // returned 3022

        printf(""Got %zu bytes\n"", numElements);
        for (int i = 0; i &lt; 16; i++)
            printf("" 0x%.2X"", storage[i]);
        putchar('\n');
        fclose(content);
    }
    else
        fprintf(stderr, ""failed to open file '%s'\n"", filename);
    return 0;
}
</code></pre>

<p>I used a random number generator to create the <code>file.gif</code> file.  When I ran the program on that file, I got:</p>

<pre><code>Got 3023 bytes
 0x62 0x66 0x74 0x77 0x76 0x62 0x66 0x6E 0x6D 0x72 0x70 0x62 0x63 0x66 0x71 0x7A
0X66
0X19
</code></pre>

<p>As you can see, the value in position 13 of the array (between 0x63 and 0x71) changes from 0x66 (102) to 0x19 (25), which is the correct 'divide by 4' value.</p>

<p>It's not possible to guess from here what's going wrong in your version.  The simplest guess is that the file <code>file.gif</code> isn't there, despite your assertions to the contrary.  Your code doesn't show that the <code>fread()</code> succeeded.</p>

<p>Most of the changes I made were those necessary to get the code pass my default compiler warnings.  I'm using <code>clang</code> from XCode 10.1 on Mojave 10.14.1, and I compiled <code>arr41.c</code> to <code>arr41</code> using:</p>

<pre><code>/usr/bin/clang -O3 -g -std=c11 -Wall -Wextra -Werror -Wmissing-prototypes \
    -Wstrict-prototypes arr41.c -o arr41
</code></pre>

<p>I also added the diagnostic code to warn when the file wasn't opened, and to print the amount of data read, the first 16 bytes of that data, and tidied up the formatting of the printed values (end outputs with newlines, in general).</p>

<p>I note in passing that this is not an MCVE (<a href=""https://stackoverflow.com/help/mcve"">Minimal, Complete, Verifiable Example</a>).  An MCVE might be:</p>

<pre><code>#include &lt;stdio.h&gt;

static void printcontents(unsigned char storage[]);
static void changecolor(unsigned char storage[]);

int main(void)
{
    unsigned char data1[20] = ""ABCDEFGHIJKLMNOPQRS"";
    printcontents(data1);
    changecolor(data1);
    printcontents(data1);
    return 0;
}

static void printcontents(unsigned char storage[])
{
    printf(""%#X\n"", storage[13]);
}

static void changecolor(unsigned char storage[])
{
    storage[13] = storage[13] &gt;&gt; 2;
}
</code></pre>

<p>Output:</p>

<pre><code>0X4E
0X13
</code></pre>

<p>Again, this is clearly correct.</p>
",0
48121854,48121596,3,"<p>now that you have posted your code.</p>

<p>you need to declare <code>applyChange()</code> <em>before</em> you call it.</p>

<p>put </p>

<pre><code>void applyChange(int values[3][3][3], int changeCode[9]);
</code></pre>

<p>at the top of the file</p>
",2
56021652,56020984,2,"<p>The standard C character input functions return a value that is either an <code>unsigned char</code> or <code>EOF</code>. Thus, to use the return value from a function like <code>fgetc</code>, store it in an <code>int</code>, not <code>char</code>:</p>
<pre><code>int x = fgetc(stdin);
if (x == EOF)
    // Code for handling error or end of file.
else
    // Code for handling a character.
</code></pre>
<p>Also note that many of the standard C routines for working with characters use <code>unsigned char</code>. Using <code>char</code> in your code can cause problems.</p>
<p>If your code has a function that reads text from the input and converts numerals in it to numbers and then returns those numbers, you must design your function so that it has some way of indicating whether it is returning ?1 or <code>EOF</code>. A common way to do this is to return two separate values: One is an indication of whether a value was successfully read or not, and the other is the value (if successful).</p>
<p>Methods of returning two values include:</p>
<ul>
<li>Return a struct that contains two members.</li>
<li>Return a status indication (success or failure) in the function return value and return the actual value in an object that is passed to the function via a pointer.</li>
</ul>
<p>Source: C 2018 7.21.7.1 paragraphs 2 and 3 say:</p>
<blockquote>
<p>If the end-of-file indicator for the input <code>stream</code> pointed to by stream is not set and a next character is present, the <code>fgetc</code> function obtains that character as an <code>unsigned char</code> converted to an <code>int</code>¡­</p>
<p>If the end-of-file indicator for the stream is set, or if the stream is at end-of-file, the end-of-file indicator for the stream is set and the <code>fgetc</code> function returns <code>EOF</code>. Otherwise, the <code>fgetc</code> function returns the next character from the input stream pointed to by <code>stream</code>. If a read error occurs, the error indicator for the stream is set and the <code>fgetc</code> function returns <code>EOF</code>.</p>
</blockquote>
",0
58829165,58829124,-1,"<p>Change your for loop to take 3 elements at once.</p>

<pre><code>for(a=0;a&lt;arraySize;a+=3) {
   printf(""VECTORS:[%lf"", vector[a]);
   if (a+1 &lt; arraySize) printf("", %lf"", vector[a+1]);
   if (a+2 &lt; arraySize) printf("", %lf"", vector[a+2]);
   printf(""]\n"");
}
</code></pre>
",2
48697446,48696399,1,"<p>I hope that you <code>concat</code> function</p>

<pre><code>char concat(const char *s1, const char *s2);
</code></pre>

<p>is just a typo and you meant</p>

<pre><code>char *concat(const char *s1, const char *s2);
</code></pre>

<p>otherwise the function would be returning a pointer as if it were a <code>char</code>.</p>

<p>Using valgrind would give more details where exactly you are reading/writing where you are not allowed to and
where you are leaking memory. Without that it's hard to pinpoint the exact
place. One thing I noticed is that depending on the length of <code>find</code> and <code>replace</code>,
you might not have enough memory for <code>tmpbuf</code> which would lead to a buffer
overflow.</p>

<p>I think that the best way to write the <code>replaceString</code> is by making it
allocate the memory it needs itself, rather than providing it a buffer to write into.
Because you are getting both <code>find</code> and <code>replace</code> from the user, you don't know
how large the resulting buffer will need to be. You could calculate it
beforehand, but you don't do that. If you want to pass a pre-allocated buffer to
<code>replaceString</code>, I'd pass it as a double pointer, so that <code>replaceString</code> can do
<code>realloc</code> on it when needed. Or allocate the memory in the function and return a
pointer to the allocated memory.</p>

<p>This would be my version:</p>

<pre><code>char *replaceString(const char *haystack, const char *needle, const char *replace)
{
    if(haystack == NULL || needle == NULL || replace == NULL)
        return NULL;

    char *dest = NULL, *tmp;

    size_t needle_len = strlen(needle);
    size_t replace_len = strlen(replace);
    size_t curr_len = 0;

    while(*haystack)
    {
        char *found = strstr(haystack, needle);

        size_t copy_len1 = 0;
        size_t new_size = 0;
        size_t pre_found_len = 0;

        if(found == NULL)
        {
            copy_len1 = strlen(haystack) + 1;
            new_size = curr_len + copy_len1;
        } else {
            pre_found_len = found - haystack;
            copy_len1 = pre_found_len;
            new_size = curr_len + pre_found_len + replace_len + 1;
        }


        tmp = realloc(dest, new_size);
        if(tmp == NULL)
        {
            free(dest);
            return NULL;
        }

        dest = tmp;

        strncpy(dest + curr_len, haystack, copy_len1);

        if(found == NULL)
            return dest; // last replacement, copied to the end

        strncpy(dest + curr_len + pre_found_len, replace, replace_len + 1);
        curr_len += pre_found_len + replace_len;

        haystack += pre_found_len + needle_len;
    }

    return dest;
}
</code></pre>

<p>The idea in this version is similar to yours, but mine reallocates the memory as
it goes. I changed the name of the arguments to have the same name as the
<code>strstr</code> function does based on my documentation:</p>

<blockquote>
  <p><em>man strstr</em></p>

<pre><code>char *strstr(const char *haystack, const char *needle);
</code></pre>
</blockquote>

<p>Because I'm going to update <code>haystack</code> to point past the characters copied, I
use this loop:</p>

<pre><code>while(*haystack)
{
    ...
}
</code></pre>

<p>which means it is going to stop when the <code>'\0'</code>-terminating byte is reached.</p>

<p>The first thing is to use <code>strstr</code> to locate a substring that matches <code>needle</code>.
Base on whether a substring is found, I calculate how much bytes I would need to
copy until the substring, and the new size of the buffer. After that I
reallocate the memory for the buffer and copy everything until the substring,
then append the replacement, update the <code>curr_len</code> variable and update the
<code>haystack</code> pointer to point past the substring.</p>

<p>If the substring is not found, no more replacements are needed. So we have to
copy the string pointed to by <code>haystack</code> and return the constructed string. The
new size of the destination is <code>curr_len + strlen(haystack) + 1</code> (the <code>+1</code>
because I want the <code>strncpy</code> function to also copy the <code>'\0'</code>-terminating byte).
And it has to copy <code>strlen(haystack) + 1</code> bytes. After the first <code>strncpy</code>, the
function returns <code>dest</code>.</p>

<p>If the substring is found, then we have to copy everything until the substring,
append the replacement and update the current length and the <code>haystack</code> pointer.
First I calculate the string until the found substring and save it in
<code>pre_found_len</code>. The new size of the destination will be
<code>curr_len + pre_found_len + replace_len + 1</code> (the current length + length of
string until substring + the length of the replacement + 1 for the
<code>'\0'</code>-terminating byte). Now the first <code>strncpy</code> copies only <code>pre_found_len</code>
bytes. Then it copies the replacement.</p>

<p>Now you can call it like this:</p>

<pre><code>int main(void)
{
    const char *orig = ""Is this the real life? Is this just fantasy?"";
    char *text = replaceString(orig, ""a"", ""_A_"");
    if(text)
    {
        puts(orig);
        puts(text);
    }

    free(text);
}
</code></pre>

<p>which will output:</p>

<pre class=""lang-none prettyprint-override""><code>Is this the real life? Is this just fantasy?
Is this the re_A_l life? Is this just f_A_nt_A_sy?
</code></pre>

<p>Now you can use this function in <code>getAndReplace</code> to replace the <code>prefix</code>:</p>

<pre><code>char *getAndReplace(char* filename, char* find, char* replace, char* prefix)
{
    ...

    char *rep1 = replaceString(buffer, find, replace);

    if(rep1 == NULL)
    {
        // error
        free(buffer);
        return NULL;
    }

    char *prefix_rep = malloc(strlen(replace) + strlen(prefix) + 1);
    if(prefix_rep == NULL)
    {
        // error
        free(buffer);
        free(rep1);
        return NULL;
    }

    sprintf(prefix_rep, ""%s%s"", replace, prefix);

    char *rep2 = replaceString(rep1, prefix, prefix_rep);

    if(rep2 == NULL)
    {
        // error
        free(buffer);
        free(rep1);
        free(prefix_rep);
        return NULL;
    }

    // rep2 has all the replacements
    ...


    // before leaving
    free(buffer);
    free(rep1);
    free(prefix_rep);

    // returning all replacements
    return rep2;
}
</code></pre>

<p>When using <code>malloc</code> &amp; co, don't forget to check if they return <code>NULL</code> and don't
forget to free the memory when not needed.</p>
",0
49498705,49498542,1,"<p>Most of the time, computers use what's called 2's complement to represent signed integers. <code>0xFFFFFFFF</code> is <code>-1</code> for 4 bytes int. 
 <a href=""https://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow noreferrer"">Two's complement - Wikipedia</a></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

int main(int argc, char const *argv[])
{
    uint32_t Temp1;
    Temp1 = (uint32_t)801 - (uint32_t)0xFFFFFFFF; // Two Unsigned Integers

    uint32_t Temp2;
    Temp2 = 801 - 0xFFFFFFFF; // Two Signed Integers and result assigned to unsigned

    unsigned int Temp3;
    Temp3 = (unsigned int)((unsigned int)801 - (unsigned int)0xFFFFFFFF); // Two Unsigned Integers

    int32_t Temp4;
    Temp4 = 801 - 0xFFFFFFFF; // Two Signed Integers


    printf(""Temp1: %d %X %u %d\n"",Temp1,Temp1, Temp1, 0xFFFFFFFF );
    printf(""Temp2: %d %X %u %X\n"",Temp2,Temp2, Temp2, 0xFFFFFFFF );
    printf(""Temp3: %d %X %u %u\n"",Temp3,Temp3, Temp3, 0xFFFFFFFF );
    printf(""Temp4: %d %X %u %x\n"",Temp4,Temp4, Temp4, 0xFFFFFFFF );
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>Temp1: 802 322 802 -1                                                                                                                          
Temp2: 802 322 802 FFFFFFFF                                                                                                                    
Temp3: 802 322 802 4294967295                                                                                                                  
Temp4: 802 322 802 ffffffff 
</code></pre>
",5
49498753,49498542,5,"<p>The hexadecimal constant <code>0xFFFFFFFF</code>, assuming an <code>int</code> is 32-bit, has type <code>unsigned int</code>.  As a result, when used in an expression with <code>801</code>, which has type <code>int</code>, the latter is converted to type <code>unsigned int</code> as a result of the <strong>usual arithmetic conversions</strong>.</p>

<p>At no point in the above examples is arithmetic being done on signed types, so there is no implementation defined behavior regarding signed wraparound or the representation of negative numbers.</p>

<p>Section 6.3.1.8 of the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C standard</a> says the following regarding conversion of integer types:</p>

<blockquote>
  <p>If both operands have the same type, then no further conversion is
  needed.</p>
  
  <p>Otherwise, if both operands have signed integer types or both have
  unsigned integer  types,  the  operand  with  the  type  of  lesser 
  integer  conversion  rank  is converted to the type of the operand
  with greater rank.</p>
  
  <p><strong>Otherwise,  if  the  operand  that  has  unsigned  integer  type  has 
  rank  greater  or equal  to  the  rank  of  the  type  of  the  other 
  operand,  then  the  operand  with signed  integer  type  is 
  converted  to  the  type  of  the  operand  with  unsigned integer
  type.</strong></p>
  
  <p>Otherwise, if the type of the operand with signed integer type can
  represent all of the values of the type of the operand with unsigned
  integer type, then the  operand  with  unsigned  integer  type  is 
  converted  to  the  type  of  the operand with signed integer type.</p>
  
  <p>Otherwise,   both   operands   are   converted   to   the   unsigned<br>
  integer   type corresponding to the type of the operand with signed
  integer type</p>
</blockquote>

<p>The third paragraph is the one that takes effect in this case, since <code>int</code> and <code>unsigned int</code> are of the same rank.  This means that all arithmetic above is done on <code>unsigned int</code> types.  </p>

<p>Operations on this type happen modulo 2<sup>32</sup>, which effectively means that the values wrap around.  Subtracting <code>0xFFFFFFFF</code> from <code>801</code> wraps around to result in 802, which is what gets printed in all cases.</p>

<p>To elaborate on the wraparound behavior, let's take as an example an unsigned 3-bit integer type which can have values 0 thru 7.  Suppose we were to calculate 3 - 7 with this type.  This is analogous to the subtraction you're doing since the value being subtracted is the maximum value the datatype can hold.</p>

<p>Now we subtract:</p>

<ul>
<li>3 - 1 = 2</li>
<li>3 - 2 = 1</li>
<li>3 - 3 = 0</li>
<li>3 - 4 = 7</li>
<li>3 - 5 = 6</li>
<li>3 - 6 = 5</li>
<li>3 - 7 = 4</li>
</ul>

<p>Note how the value wraps around once the second operand is larger than the first, and that effective result is the same as adding 1.  This is the same as in your examples.</p>
",3
57233063,57232936,5,"<p>The <code>NULL</code> macro is defined in <code>&lt;stddef.h&gt;</code>. (It is also defined in several other headers.) It expands to a <em>null pointer constant</em> and is intended to be used with pointers, not with characters.</p>

<p>There is no standard macro for <code>'\0'</code>. It is equivalent to <code>0</code> (character constants have <code>int</code> type), and a macro for it would be of limited use.</p>

<p>The character <code>'\0'</code> is often referred to as a null character, but this is different from the <code>NULL</code> pointer constant.</p>
",2
57233008,57232936,5,"<p>None. And <code>'\0'</code> isn't a <code>char</code> but <code>int</code>. If you don't want to use <code>'\0'</code> you can use <code>0</code>, <code>0x0</code>, <code>00</code>,  <code>000</code> and so forth...</p>
",1
57233087,57232936,3,"<blockquote>
  <p>Which C standard header file defines NULL character?</p>
</blockquote>

<p>None.  A <em>null character</em> is part of the language definition.</p>

<blockquote>
  <p>A byte with all bits set to 0, called the <em>null character</em>, ... ; it
  is used to terminate a character string.  C11dr ¡ì5.2.1 2</p>
</blockquote>

<p>If you want your own macro, consider</p>

<pre><code>#define NUL_CHAR ((char) '\0')
</code></pre>

<hr>

<p>Note than when coded as <code>'\0'</code>, this is a constant of type <code>int</code>.</p>

<hr>

<p><strong><code>NULL</code></strong></p>

<p>Uppercase <code>NULL</code> (with 2 <code>L</code>) is  used to name the <em>null pointer</em> constant <code>NULL</code>.  That is best used with pointers, not as a <em>null character</em> at the end of a string.</p>

<blockquote>
  <p>The macro <code>NULL</code> is defined in <code>&lt;stddef.h&gt;</code> (and other headers) as a null pointer constant</p>
</blockquote>
",0
54496175,54495742,1,"<p>The main problem seems to be that you don't appreciate the difference between copying / assigning <em>pointers</em> and copying / assigning <em>the data to which they point</em>.  Secondarily, it seems you may not appreciate the utility of pointers that don't point to anything, especially null pointers.  Some details follow.</p>

<hr>

<p>You are dynamically allocating space for a bunch of strings ...</p>

<blockquote>
<pre><code>  for(int idx = 0; idx &lt; d-&gt;size; idx++)
  {
    d-&gt;deque[idx] = (char *)malloc((MAX+1) * sizeof(char));
</code></pre>
</blockquote>

<p>...  and then leaking all of that space by replacing the pointer to each with a pointer to an empty string literal:</p>

<blockquote>
<pre><code>    d-&gt;deque[idx] = """";
  }
</code></pre>
</blockquote>

<p>As if the leak were not bad enough, you are not permitted to free a string literal or modify its content, which you nevertheless try to do to any of those pointers that remain in the dequeue whenever you <code>clear()</code> it.  This is likely the cause of some of your errors.</p>

<p>If you want to set each allocated string to an empty one then modify its <em>content</em> instead of replacing the pointer to it.  For example:</p>

<pre><code>    d-&gt;deque[idx][0] = '\0';
</code></pre>

<p>In fact, however, you probably don't need to do even that.  You are already performing bookkeeping to know which arrays contain valid (string) data and which don't, and that should be sufficient to do the right thing.  Supposing you maintain copies of the strings in the first place.</p>

<p>But that's not all.  When you <code>rAppend()</code> elements to your deque you have a similar problem.  You create a temporary deque, and then copy the string <em>pointers</em> from your original deque into the temporary:</p>

<blockquote>
<pre><code>dTemp.deque[idx] = d-&gt;deque[idx];
</code></pre>
</blockquote>

<p>Not only does this leak the original (empty) data in the temporary deque, it aliases that deque's contents with the main deque's.  When you later clear the temporary deque, therefore, you free all the string pointers in the original.  Subsequently using or freeing them produces undefined behavior.</p>

<p>Perhaps you instead want to <code>strcpy()</code> all the elements of the main deque into the temp and back, but I suggest instead skipping the temp deque altogether with something along these lines:</p>

<pre><code>void rAppend(deque *d, char item[]) // as in rear append - same enqueue for queue structure.
{ 
  if(isFull(d))
  {
    printf(""Is Full\n"");
    char **tmp = realloc(d.deque, d-&gt;size * 2);

    if (tmp)
    {
        d-&gt;deque = tmp;
        for (int i = 0; i &lt; d-&gt;size; i++)
        {   
            // Copied from the original, but see below
            d-&gt;deque[d-&gt;size + i] = malloc( sizeof(char) * MAX );
        }
        d-&gt;size * 2;
    }  // else?
  }
  printf(""Appending to rear.. %s\n"", item);
  d-&gt;pRear++;
  // Oops, this is another leak / aliasing issue:
  d-&gt;deque[d-&gt;pRear] = item;
  if(d-&gt;pFront == -1)
      d-&gt;pFront = 0;
}
</code></pre>

<p>The whole point of the temporary deque is lost on me, since the <code>realloc()</code> you need to do preserves the original data anyway (as long as it succeeds, anyway).</p>

<p>Note too, however, that this still has an aliasing issue: you have aliased a deque element with the appended string, and leaked the memory allocated for that element.  Furthermore, when you clear the deque, you free that string for everyone holding a pointer to it.  Or at least you attempt to do so.  You're not permitted to do that to string literals.</p>

<p>I suggest not allocating space in your deque for the individual strings at all, and not freeing it.  Continue to use assignment to store elements in your deque, understanding and embracing that these are aliases.  This will be more analogous to your implementation for <code>int</code>s.</p>
",1
59315988,59315000,1,"<p>This is a great question, as the answer reveals a lot about what's going on under the hood even though it mostly doesn't impact how you write your software.</p>

<p>First: the answer depends a <strong>lot</strong> on the CPU you're using, as each architecture has its own conventions for dealing with registers and return values and the like. As noted in a comment above, ""ABI"" is Application Binary Interface defines a set of conventions that everybody has to agree on.</p>

<p>The ABI is how you drill down on your particular platform, and this post is <em>at best</em> a drive by.</p>

<p>For simple returns - an integer, for instance - almost all CPUs have an ""obvious"" register to use for this, and on the Intel x86 platform it's <code>eax</code>, and for x64 it's <code>rax</code>.</p>

<p>This is essentially the ""A"" register shared (at least notionally) by many processors, and a function/subroutine stores the return value here to make it available to the caller. </p>

<p>In these cases, whatever the caller finds in this ""A"" register is considered the return, but it has no way of knowing whether the subroutine intentionally put a value here for return, or if it's just some random leftover from a calculation.</p>

<p>This has a curious side effect that a function that does not intentionally return a value nevertheless ""returns"" whatever happens to be in the <code>eax</code> register when it returns. Sometimes this is the result of a calculation, sometimes it's the return value from a sub-function called just before return.</p>

<pre><code>int myfunc()
{
   .. do some stuff
   int x = 4 * other_function();
   // note no ""return""
}
</code></pre>

<p>It might be that the calculated <code>x</code> is ""returned"" just because it happened to have landed in the A register, but don't count on it: it's essentially a bug. It could also be some other value. A good compiler will warn you for dodgy business like this: there are questions on SO all the time about these mystery returns.</p>

<p>Of course, it's not always that simple: you can't fit a 128-bit value into a 64-bit register, so functions that return a <code>double</code> (or a <code>long long</code>) have to take other provisions.</p>

<p>For integral values, many architectures agree on using two registers together, and for floating point values, there could be a separate set of floating point registers used that the caller agrees to consult.</p>

<p>It's <em>vital</em> that the caller and callee agree on where these are to go.</p>

<p>A special case is returning a large item, such as a structure. This is not a great idea and most do not recommend it (though legal), and it should be obvious that returning a (say) 488 byte structure will not fit in registers on most architectures.</p>

<p>The trick is that the caller allocates space for the full return value and then passes the address of that return area in a hidden argument to the function (sometimes in the ""A"" register). The callee knows to copy the computed structure to the memory pointed to by that hidden pointer.</p>

<p>Ref: <a href=""https://stackoverflow.com/questions/2155730/how-do-c-compilers-implement-functions-that-return-large-structures"">How do C compilers implement functions that return large structures?</a></p>

<p>As mentioned, this is just a drive by, and you really have to study the architecture of the processor you're working with, but the most important fact here: these are <em>conventions</em>, which means that they are just something that everybody agrees on rather than being some inherent ""right"" answer.</p>
",2
54496980,54496773,0,"<p>scanf will discard any input in the input stream if the data don't match the format specifier.</p>

<p>The scanf specifier in your code is %d, discards any characters other than integers. To check how many characters are read by scanf(), better print scanf() return data.</p>

<p>int count = scanf(...);</p>
",1
49140648,49140574,4,"<p>You are returning a pointer to stack memory, which is undefined behavior. Most likely your returned string will be corrupted shortly after the function returns or after the invocation of another function.</p>

<p>This is closer to what you want:</p>

<pre><code>char* cipherinput(int ciphercount) {
    int i=0;
    char cipher[MAX_CIPHER_SIZE+1]; // +1 to guarantee null termination.
    cipher[0] = '\0';

    if(ciphercount&gt;=2){
        printf(""Enter the Cipher!\n"");
        //loop through and add
        for(i=0;i&lt;ciphercount;i++){
            scanf("" %c"", cipher[i]);
        }
        cipher[ciphercount] = '\0'; // null terminate
    }

    return strdup(cipher);   // this is the same as ptr=malloc(strlen(cipher+1)) followed by strcpy(ptr,cipher)
}
</code></pre>

<p>The function returns a copy of the string the user typed in.  The caller of this function is expected to invoke <code>free</code> on the returned pointer after it's done with it.  If <code>ciphercount &lt; 2</code>, the function will return an empty string.</p>
",1
49140711,49140574,1,"<p>Normal way 1, Allocate result in function and return it</p>

<pre><code>    char *cipherinput(int ciphercount){
      char *cipher = malloc(MAX_CIPHER_SIZE);
...
      return cipher;
    }
</code></pre>

<p>Note that your caller will have to <code>free</code> the result</p>

<p>Normal way 2, Caller creates and passes result buffer</p>

<pre><code>void cipherinput(int ciphercount, char * cipher){
 ....
}
</code></pre>

<p>caller goes</p>

<pre><code>    char cipher[MAX_CIPHER_SIZE];
    cipherinput(x, cipher);
</code></pre>

<p>Normal way #3. HAve fixed static buffer in function. NOTE THIS IS NOT rentrant or thread safe. </p>

<pre><code>char *cipherinput(int ciphercount){
  static char cipher[MAX_CIPHER_SIZE];
  .....
  return cipher;
}
</code></pre>

<p>In general #2 is probably best since you are less likely to leak</p>
",0
49140742,49140574,1,"<p>If you want to use <code>char *cipher</code> outside your function </p>

<pre><code>char *cipherinput(int ciphercount){
     int i=0;
     char *cipher[MAX_CIPHER_SIZE];
     //...
     return *cipher;
}
</code></pre>

<p>You need to allocate memory for your cipher buffer. Your <code>cipher[MAX_CIPHER_SIZE]</code> will not exist once the <code>cipherinput</code>  function returns. This is the most common approach:</p>

<pre><code> char* cipherinput(int ciphercount) {
        // ...
        char *cipher = malloc( sizeof(char) * (MAX_CIPHER_SIZE+1) ); // +1 to guarantee null termination.

        //...
        return cipher;
    }
</code></pre>

<p>This approach requires you to remember to free the memory allocated for <code>cipher</code> once you do not needed.</p>

<p>In embedded systems you may want to avoid memory allocation, since allocation and deallocation may not be timely operation. 
In such case, the best approach is to pass a buffer to your function: </p>

<pre><code>char cipher[MAX_CIPHER_SIZE+1];    // buffer outside the function
cipherinput(ciphercount, cipher);  // function call
</code></pre>

<p>Function implementation:</p>

<pre><code>void cipherinput(int ciphercount, char * cipher){
 // access elements of cipher buffer via cipher[i]);
 // ...
}
</code></pre>
",2
50481350,50481263,1,"<p>It means ""when this thing happens"". It's a <em>reasonably</em> common usage in English, but I can see how it would be confusing for developers who don't have English as a first language.</p>

<p>As an example outside computing, you might say, ""<strong>On entry</strong> to a country, you must present your passport"" or equivalently ""You must present your passport <strong>on entry</strong> to a country.""</p>
",2
50481330,50481263,0,"<p>It's not an abbreviation. The word ""on"" is a naming convention to indicate that the function is called when an event occurs. E.g. ""onKeyPress"" means this function is called when a key is pressed.</p>

<p>Possible duplicate: <a href=""https://softwareengineering.stackexchange.com/questions/299101/what-does-the-prefix-on-in-a-function-e-g-onbuttonpressed-mean"">What does the prefix ¡°on¡± in a function (e.g.¡°onButtonPressed¡±) mean?</a></p>
",6
52948354,52948256,3,"<p>I'm just <strong><em>guessing</em></strong> here since you don't provide a <a href=""http://stackoverflow.com/help/mcve"">Minimal, Complete, and Verifiable Example</a>.</p>

<p>It seems you're passing the length <code>5</code> as argument for the buffer size. That is the buffer size <em>including</em> the string terminator.</p>

<p>From <a href=""https://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer"">this <code>snprintf</code> (and family) reference</a>:</p>

<blockquote>
  <p><code>bufsz</code>   -   up to <code>bufsz - 1</code> characters may be written, plus the null terminator</p>
</blockquote>

<p>Your string is <em>six</em> characters including the terminator, so you need a buffer of at least six characters and tell <code>snprintf</code> that size.</p>

<p>Oh and the note about range is because you use <em>signed</em> integers, so the range includes negative numbers as well, which means extra space. You should probably use <code>unsigned int</code> instead, and the format <code>""%02u""</code>.</p>
",4
49121844,49121760,2,"<p><code>Undefined reference to 'blah'</code> is a <em>linker</em> error rather than a compiler error and is almost <em>always</em> caused by not including a needed library.</p>

<p>Including a header file in your source file does <em>not</em> usually link in the code required to provided the functions declared in that header.</p>

<p>For example, were you to prevent linking of the C runtime library, you could include <code>stdio.h</code> as many times as you wanted to, and <em>still</em> not be able to resolve <code>printf</code>.</p>

<p>Bottom line, you generally need two steps:</p>

<ul>
<li>include the relevant header file in your source code so it knows about the <em>declarations</em> of things provided; and</li>
<li>link against the relevant library or object file so it has access to the <em>definitions</em> of the things provided.</li>
</ul>

<p>That <em>could</em> be something as simple as:</p>

<pre><code>gcc -o test -I/path/to/iah202includes test.c -L/path/to/iah202libs -liah202
</code></pre>

<p>where <code>-I</code> indicates where include files can be found, <code>-L</code> adjusts the search path for library files, and <code>-l</code> actually specifies the library file to use.</p>

<hr>

<p>Even <em>simpler</em> is if you have the source file for the graphics stuff (which seems to be the case based on your comments). In that case no library is needed, you can simply use:</p>

<pre><code>gcc -o test test.c iab202_graphics.c
</code></pre>

<p>and that will compile <em>both</em> those translation units then link them together.</p>
",5
50496093,50495973,0,"<p>There is (almost) not builtin solution:</p>

<ul>
<li>either you want to modify <em>inplace</em>: in that case you have to ""move"" the end of your string (basically <code>|</code>);</li>
<li>or create a new string, copy the relevant part an skip what's not.</li>
</ul>
",0
50496752,50495973,0,"<p>An alternative would be a simple function that iterates over the source string copying characters that are not to be removed to a destination string as in the following.</p>

<pre><code>char *  CopyStringRemove(char *pDest, const char *pSrc)
{
    // copy the source string, pSrc, to the destination string, pDest, while
    // removing special codes that are between a &lt; character and a | character.
    // we will copy the two special code characters but remove everything in between.
    char * pRet = pDest;

    if (pDest) {
        if (pSrc) {
            int   iState = 0;      // state indicates whether copying characters or not.

            for (; *pSrc; pSrc++) {
                switch (*pSrc) {
                case '&lt;':
                    iState = 1;         // indicate we are skipping characters
                    *pDest++ = *pSrc;   // however copy this character we found
                    break;
                case '|':
                    iState = 0;     // indicate we are copying characters
                    break;
                default:
                    break;
                }
                switch (iState) {
                case 0:
                    *pDest++ = *pSrc;    // state is to copy the current character
                    break;
                case 1:                  // state is to not copy current character, just skip over it.
                    break;
                }
            }
        }
        *pDest = 0;
    }

    return pRet;
}
</code></pre>

<p>This function provides quite a bit of flexibility in that the source can be a constant or not. The destination may be an array on the stack or an array malloced from the heap. If the source array is not <code>const</code> then you can do an inplace change by calling the <code>CopyStringRemove()</code> function with both source and destination being the same buffer.</p>

<p>It also allows for problems with the input such as not having a '&lt;' character or a '|' character in the string.</p>

<p>A test harness such as:</p>

<pre><code>void testfunc(const char *buff)
{
    {
        char destbuff[128] = { 0 };
        printf(""    orig string \""%s\""\n"", buff);
        CopyStringRemove(destbuff, buff);
        printf(""        new     \""%s\""\n"", destbuff);
    }

    {
        char destbuff[128] = { 0 };
        char buff2[128] = { 0 };
        strcpy_s(buff2, sizeof(buff2), buff);
        printf(""    orig string \""%s\""\n"", buff2);
        CopyStringRemove(destbuff, buff2);
        printf(""        new     \""%s\""\n"", destbuff);
    }

    {
        char buff2[128] = { 0 };
        strcpy_s(buff2, sizeof(buff2), buff);
        printf(""    orig string \""%s\""\n"", buff2);
        CopyStringRemove(buff2, buff2);
        printf(""        new     \""%s\""\n"", buff2);
    }

}

void main_xfun(void)
{
    char *buff = ""cat -v &lt;  x y z | "";
    char *buffa = ""cat -v &lt;  x y z  "";
    char *buffb = ""cat -v   x y z | "";
    char *buffc = ""cat -v   x y z  "";

    printf(""\ntest #1\n"");
    testfunc(buff);
    printf(""\ntest #2\n"");
    testfunc(buffa);
    printf(""\ntest #3\n"");
    testfunc(buffb);
    printf(""\ntest #4\n"");
    testfunc(buffc);
}
</code></pre>

<p>yields a result of:</p>

<pre><code>test #1
    orig string ""cat -v &lt;  x y z | ""
        new     ""cat -v &lt;| ""
    orig string ""cat -v &lt;  x y z | ""
        new     ""cat -v &lt;| ""
    orig string ""cat -v &lt;  x y z | ""
        new     ""cat -v &lt;| ""

test #2
    orig string ""cat -v &lt;  x y z  ""
        new     ""cat -v &lt;""
    orig string ""cat -v &lt;  x y z  ""
        new     ""cat -v &lt;""
    orig string ""cat -v &lt;  x y z  ""
        new     ""cat -v &lt;""

test #3
    orig string ""cat -v   x y z | ""
        new     ""cat -v   x y z | ""
    orig string ""cat -v   x y z | ""
        new     ""cat -v   x y z | ""
    orig string ""cat -v   x y z | ""
        new     ""cat -v   x y z | ""

test #4
    orig string ""cat -v   x y z  ""
        new     ""cat -v   x y z  ""
    orig string ""cat -v   x y z  ""
        new     ""cat -v   x y z  ""
    orig string ""cat -v   x y z  ""
        new     ""cat -v   x y z  ""
</code></pre>
",0
56550674,39689772,0,"<p>Comparing memory addresses can get a bit tricky.</p>

<p>I will start with the simple case and move on to <strong>2 more advanced cases</strong>.</p>

<p>For full explanation of the code, I've posted a youtube video.</p>

<p><a href=""https://www.youtube.com/watch?v=Yk9ROvIQCts"" rel=""nofollow noreferrer"">https://www.youtube.com/watch?v=Yk9ROvIQCts</a></p>

<p>However, the comments in this code are hopefully enough by themselves.</p>

<pre><code>#include &lt;stdio.h&gt; //:for: printf(...)

//: Generic function pointer type:
//: Only DATA pointers can be cast to void*
//: Function pointers CANNOT be cast to void*
typedef void ( * GenFunc ) ( void );

struct global_state{

    int val;

}GS;

int  Func_A(   void   ){ return 5    ; }
void Func_B( int  val ){ GS.val = val; } 

int main( void ){
    printf(""[BEG :main]\n"");



    //|1|1|1|1|1|1|1|1|1|1||1|1|1|1|1|1|1|1|1|1|//
    //| Compare Addresses of KNOWN types:      |//
    //|1|1|1|1|1|1|1|1|1|1||1|1|1|1|1|1|1|1|1|1|//
    int a = 6;                             //|1|//
    int b = 6;                             //|1|//
                                           //|1|//
    int* ptr_1 = &amp;( a );                   //|1|//
    int* ptr_2 = &amp;( b );                   //|1|//
    int* ptr_3 = &amp;( a );                   //|1|//
                                           //|1|//
    if( ptr_1 != ptr_2 ){                  //|1|//
        printf(""[ptr : &lt;&gt; ]\n"");           //|1|//
    };;                                    //|1|//
    if( ptr_1 == ptr_3 ){                  //|1|//
        printf(""[ptr : == ]\n"");           //|1|//
    };;                                    //|1|//
    //|1|1|1|1|1|1|1|1|1|1||1|1|1|1|1|1|1|1|1|1|//



    //|2|2|2|2|2|2|2|2|2|2||2|2|2|2|2|2|2|2|2|2|//
    //| Compare addresses of function pointers |//
    //| without casting to (void*). It is      |//
    //| undefined behavior to cast function    |//
    //| pointers to (void*).                   |//
    //|2|2|2|2|2|2|2|2|2|2||2|2|2|2|2|2|2|2|2|2|//
    GenFunc gfp_1 = (GenFunc) &amp;( Func_A ); //|2|//
    GenFunc gfp_2 = (GenFunc) &amp;( Func_B ); //|2|//
    GenFunc gfp_3 = (GenFunc) &amp;( Func_A ); //|2|//
    if( gfp_1 != gfp_2 ){                  //|2|//
        printf(""[gfp : &lt;&gt; ]\n"");           //|2|//
    };;                                    //|2|//
    if( gfp_1 == gfp_3 ){                  //|2|//
        printf(""[gfp : == ]\n"");           //|2|//
    };;                                    //|2|//
    //|2|2|2|2|2|2|2|2|2|2||2|2|2|2|2|2|2|2|2|2|//



    //|3|3|3|3|3|3|3|3|3|3||3|3|3|3|3|3|3|3|3|3|//
    //| wglGetProcAddress returns generic      |//
    //| function pointer. The documentation    |//
    //| says we need to check for:             |//
    //|                                        |//
    //| 0x00, 0x01, 0x02, 0x03, or -1          |//
    //|                                        |//
    //| for failure.                           |//
    //|                                        |//
    //| PRETEND gfp_1 was fetched using        |//
    //| wglGetProcAddress.                     |//
    //| (Note: Zero is special and does NOT )  |//
    //| (      require a cast.              )  |//
    //|3|3|3|3|3|3|3|3|3|3||3|3|3|3|3|3|3|3|3|3|//
    if(                                    //|3|//
        (gfp_1 ==           0  ) ||        //|3|//
        (gfp_1 == (GenFunc) 0x1) ||        //|3|//
        (gfp_1 == (GenFunc) 0x2) ||        //|3|//
        (gfp_1 == (GenFunc) 0x3) ||        //|3|//
        (gfp_1 == (GenFunc)  -1) ||        //|3|//
    0){                                    //|3|//
        printf(""[Failure!]"");              //|3|//
    };;                                    //|3|//
    //|3|3|3|3|3|3|3|3|3|3||3|3|3|3|3|3|3|3|3|3|//



    printf(""[END :main]\n"");
}
</code></pre>
",0
48468586,48468530,4,"<p><code>free(x)</code> doesn't set <code>x</code> no NULL automatically, it just deallocates the memory and leaves <code>x</code> pointing to an invalid location. If you want to free <code>x</code> you can use a function like</p>

<pre><code>void clear(void** ptr) { free(*ptr); *ptr = NULL; }

...

free(&amp;(mstr-&gt;my_file-&gt;host));
</code></pre>

<p>Or you can do it manually each time. The comma operator can help here:</p>

<pre><code>mstr-&gt;my_file-&gt;host = (free(mstr-&gt;my_file-&gt;host), NULL);
</code></pre>

<p><em>Edit</em>: if you happen to be using glib (and its memory management wrappers), there is <a href=""https://developer.gnome.org/glib/stable/glib-Memory-Allocation.html#g-clear-pointer"" rel=""nofollow noreferrer""><code>g_clear_pointer</code></a> and <a href=""https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-clear-object"" rel=""nofollow noreferrer""><code>g_clear_object</code></a> to help with this.</p>
",3
54831713,54831487,2,"<p>You probably want something like this:</p>

<pre><code>  ...
  while ((c = getchar()) != 'X')
    fprintf(output, ""%c"", c);

  fclose(output);
  ...
</code></pre>

<p>Input:</p>

<p>ABCX<kbd>Enter</kbd></p>

<p>Output.txt will contain <code>ABC</code>.</p>
",0
54831698,54831487,3,"<p>Since you do not have a proper exit condition in your loop, the only way to terminate your program is by forcefully ending the process. This means that there is no guarantee that any pending buffered output will be written to the stream <code>output</code>.</p>

<p>What you can do is change your loop condition to <code>while((c = getchar()) != EOF)</code>. Then, you can use the characters <kbd>Ctrl</kbd>+<kbd>Z</kbd> (Windows) or <kbd>Ctrl</kbd>+<kbd>D</kbd> (*nix) to make the loop condition false, reaching the line <code>fclose(output)</code>, which will flush the buffer and close the file.</p>

<p>Also, make <code>c</code> an <code>int</code>, since that's what <code>EOF</code> is.</p>
",1
48356097,48356018,2,"<p><code>FILE</code> is a structure holding metadata (filled in by <code>fopen()</code>), which is used as parameter by other functions that affect reading from the file. You never access what is in a <code>FILE</code> structure directly.</p>

<p>One of the file access functions is <a href=""http://en.cppreference.com/w/c/io/fgetc"" rel=""nofollow noreferrer"">fgetc()</a>, which takes a <code>FILE *</code> as parameter and returns an <code>int</code> -- either <code>EOF</code> (end-of-file) or the next character from the file so identified.</p>

<pre><code>char inputFile[] = ""hello.txt""; 
FILE * inFile = fopen(inputFile, ""r"");
// inFile == NULL means fopen() failed
if ( inFile != NULL )
{
    int currentChar;
    currentChar = fgetc( inFile );
    // check currentChar for EOF, then do something with it
    fclose(inFile);
}
else
{
    perror( ""fopen() failed"" );
}
</code></pre>
",1
51982027,51981946,5,"<p>I <em>guess</em> the line you're getting the error on is this one</p>

<pre><code>(Book*)object-&gt;price = 300;
</code></pre>

<p>The error is because of <a href=""http://en.cppreference.com/w/c/language/operator_precedence"" rel=""noreferrer""><em>operator precedence</em></a>, where the ""arrow"" operator <code>-&gt;</code> have higher precedence than the cast operator.</p>

<p>That means your statement is really like this:</p>

<pre><code>(Book*)(object-&gt;price) = 300;
</code></pre>

<p>That means you're try to dereference the <code>void *</code> variable <code>object</code> (which is not really possible) and then cast the <code>price</code> member to <code>Book *</code>.</p>

<p>To correct it use</p>

<pre><code>((Book*)object)-&gt;price = 300;
</code></pre>
",1
54692791,54692672,1,"<p>You have to write the code to remember the last character(if any at all) before EOF.</p>

<pre><code>int c;
int lc = EOF;
while((c=getchar()) != EOF) {
   lc = c;
}

//here lc will hold the last character read before EOF,
//or it will also be EOF if no characters got read at all.
</code></pre>

<p>Note that your original condition was <code>while(c=getchar() != EOF)</code>, which is incorrect - it is evaluated as <code>while(c=(getchar() != EOF))</code>, you have to write <code>while((c=getchar()) != EOF</code></p>
",1
54692734,54692672,3,"<p>There is no indication that the character just returned from <code>getchar</code> is the last available character. To print the last character before <code>EOF</code>, you must remember the return from <code>getchar</code>. When <code>EOF</code> is returned, then print the previously remembered character.</p>

<p>For example, this code prints the last character of a stream:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int c, previous = EOF;

    while (1)
    {
        c = getchar();
        if (c == EOF)
            break;
        previous = c;
    }

    if (previous == EOF)
        printf(""There were no characters in the stream.\n"");
    else
        printf(""The last character was %c.\n"", previous);
}
</code></pre>

<p>When you try the above, you are likely to find the last character is a new-line character, <code>'\n'</code>.</p>

<p>In general, it would be impossible for a C implementation to know the character just returned is the last character. Input might be coming from a terminal, for example, and the user has just typed a character, which <code>getchar()</code> returns. At this point, we do not know what the user will do next¡ªthey might type another character, or they might type and end-of-file indication (as by pressing control-D twice, in a Unix system). So, having just gotten a character, we do not know whether what is coming next is another character or is <code>EOF</code>.</p>
",2
54692817,54692672,1,"<pre><code>char c; 
int tmp = 0; 
while(tmp != EOF) 
{ 
  c = (char)tmp; 
  tmp=getchar(); 
} 
</code></pre>

<p><code>c</code> becomes <code>0</code> (null terminator) in case of an empty input, otherwise it is the last character before <code>EOF</code>.</p>
",0
54763032,54762554,0,"<p>Yes.</p>

<p>Paring it down and switching the type to something <a href=""https://cdecl.org/"" rel=""nofollow noreferrer"">cdecl.org</a> can parse, we get:</p>

<pre><code>volatile int rawRxBuffer[];
</code></pre>

<p>and the corresponding output is:</p>

<pre><code>declare rawRxBuffer as array of volatile int
</code></pre>

<p>the point is that it's an ""array of volatile"", i.e. each array element is volatile.</p>
",0
55784611,55784566,3,"<p>if you do not enter a valid integer for <code>scanf(""%d"",...);</code> the unvalid input is <em>not</em> removed so you will get it in the next <code>scanf(""%d"",...);</code> so <code>(int_check!=1 || n&lt;5)</code> will never be false</p>

<p>you need to flush the invalid input by yourself, warning do not use <code>fflush(stdin);</code> because that works only on file</p>

<p>Note to see the message you need to flush it, for instance replace</p>

<blockquote>
<pre><code>    printf(""Enter the valid number of terms for the array inout. It should be an integer and greater than 5:"");
</code></pre>
</blockquote>

<p>by</p>

<pre><code>    printf(""Enter the valid number of terms for the array inout. It should be an integer and greater than 5:\n"");
</code></pre>

<p>or use  <code>fflush(stdout);</code> after the <em>printf</em> is you prefer to stay on the same line</p>
",9
48842570,48842475,1,"<p>If you were to step the code in a debugger you would discover that the while loop is never even entered.  It is not a problem of an infinite while-loop.  Rather that <code>scanf()</code> never returns.</p>

<p>Change:</p>

<pre><code>scanf(""%d %d\n"", &amp;a, &amp;b);
</code></pre>

<p>to</p>

<pre><code>scanf(""%d %d"", &amp;a, &amp;b);
</code></pre>
",0
48472437,48465710,0,"<p>Just use <code>fgets()</code>.  If the returned string is empty, stop.  If it is not empty, use <code>sscanf()</code> to parse it.</p>
",0
58648447,58648402,2,"<p>You're testing the character that was entered <em>before</em> the last number. You need to test the character first, and then ask for the number.</p>

<pre><code>while (true) {
    scanf("" %c"", &amp;c);
    if (c == '-') {
        break;
    }
    scanf(""%d"", &amp;n);
}
</code></pre>
",0
49465092,49465037,3,"<p>From the point of view of the C standard, your code invokes undefined behavior (you're calling a function using a different type signature than the one with which it was defined) and could produce any possible output (or crash or otherwise act unexpectedly).</p>

<p>From the point of view of the implementation, <code>int</code>s are presumably returned via a register on your platform / calling convention. So <code>abc</code> puts its value into that register. <code>m</code> does not touch that register because <code>m</code> is <code>void</code> and does not return anything. <code>main</code> then looks into the register to find the return value of <code>m</code> (because <code>main</code> thinks <code>m</code> is an <code>int</code> function) and finds the 5 there.</p>
",0
49465088,49465037,6,"<p>It is common in C implementations for functions to return a value by placing the value in a processor register designated for that value. So what can happen is:</p>

<ul>
<li>To return 5, <code>abc</code> puts 5 in that register.</li>
<li>Since <code>m</code> does not return a value, it does not change the register.</li>
<li>When <code>main</code> attempts to get the return value of <code>m</code>, it reads the register where the return value should be. Since <code>abc</code> put 5 there and <code>m</code> did not change it, <code>main</code> gets 5 and prints it.</li>
</ul>

<p>None of the above is guaranteed by the C standard, and it is easily disrupted when a compiler performs optimization, so it is not behavior you can rely on in any way.</p>

<p>That said, a C implementation of any quality would report that there are conflicting types for <code>m</code>, because its use in <code>main</code> either:</p>

<ul>
<li>causes an implicit declaration of a function returning <code>int</code>, and its explicit declaration later on conflicts with that (for versions of C before 1999 and non-standard versions of C), or</li>
<li>is a use of an undeclared function name which is not allowed (by later C standards).</li>
</ul>
",0
48588075,48587826,2,"<p>In <code>int* p;</code> you define an object <code>p</code> that is a pointer to an <code>int</code>. This declaration creates the pointer but does not assign any value to it. Defining a pointer does not automatically create a thing that it points to. You have to do that separately.</p>

<p>In <code>(*p) = 5;</code>, you say to put <code>5</code> in the place that <code>p</code> points. However, <code>p</code> has not been assigned any value, so it is not a valid pointer. What happens at this point is uncontrolled. Given the message you report, it appears that the uninitialized pointer contain bits that were pointing to an invalid address, so attempting to write <code>5</code> to that location resulted in a trap, which the system reported to you by saying that your program is not working.</p>

<p>For example, you could do this:</p>

<pre><code>int x = 4;    // Create an int object and put 4 in it.
int *p = &amp;x;  // Create a pointer-to-int and put the address of x in it.
*p = 5;       // Put 5 in the int pointed to by p.
</code></pre>
",0
48587945,48587826,3,"<p>You are writing to uninitialized memory.  The operating system is killing your application to protect itself from your clumsy memory overwrite attack.  Try this instead:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(){
    int r;               // Let's give p something valid to look at
    int* p = &amp;r;         // Assign the address of r into the p pointer.
    (*p) = 5;            // Write to what is pointed to by p (into r)
    printf(""%i\n"", *p);  // print it.
    return 0;            // return all is well.
}
</code></pre>

<p>This shows how you can use a pointer in a more correct manner.</p>
",0
54870020,54869417,0,"<p>There needs to be some way for the user to tell the program that he's done inputting values.</p>

<p>You could have the user first enter the number of values he wants to read:</p>

<pre><code>int count;
printf(""Number of values: "");
int rval = scanf(""%d"", &amp;count);

if (rval == 1) {
    for(i=0; i&lt;count &amp;&amp; i&lt;100; i++) {
        rval = scanf(""%d"", &amp;A[i]);
        if (!rval) {
            int c;
            while ((c=getchar()) != '\n' &amp;&amp; (c != EOF));
        }
    }
}
</code></pre>

<p>Or you could have the user enter values continuously until a special value is entered:</p>

<pre><code>printf(""Enter values (enter -1 to stop): "");
for(i=0; i&lt;count; i++) {
    int value;
    int rval = scanf(""%d"", &amp;value);
    if (!rval) {
        int c;
        while ((c=getchar()) != '\n' &amp;&amp; (c != EOF));
    } else if (value != -1) {
        A[i] = value;
    } else {
        // -1 was entered
        break;
    }
}
</code></pre>
",0
58764345,58763130,2,"<p>At the start of the loop, <code>a</code> is the array to be merged and <code>b</code> is the array to merge into.<br>
At the end of the loop, <code>a</code> and <code>b</code> are swapped in preparation for the next iteration.</p>

<p>This means that after the loop, <code>a</code> points to the sorted result, but that can be either the input array or the locally allocated one (which must be freed or there will be a memory leak).</p>

<p>When necessary, the conditional arranges things by copying the result, and ensuring that <code>b</code> points to the locally allocated memory so <code>free(b)</code> will free the memory allocated by the function.  </p>

<p>It could also be written</p>

<pre><code>if (a != arr) {
    for (int i = 0; i &lt; len; i++)
        arr[i] = a[i];
    free(a);
} else {
    free(b);
}
</code></pre>

<p>Introducing another variable would make it less confusing, in my opinion:</p>

<pre><code>void merge_sort(int arr[], int len) {
    int *local_memory = malloc(len * sizeof(int));
    int *a = arr;
    int *b = local_memory;
    int seg, start;
    for (seg = 1; seg &lt; len; seg += seg) {
        /* ... */
        int *temp = a;
        a = b;
        b = temp;
    }
    if (a != arr) {
        int i;
        for (i = 0; i &lt; len; i++)
            arr[i] = a[i];
    }
    free(local_memory);
}
</code></pre>
",0
53203599,53203535,13,"<p>Yes you can do this. But there is a complication: there is no way to directly declare another pointer to same type - or an object of that type, because... the struct type is anonymous.</p>

<p>It is still possible to use it however, by allocating memory for it with <code>malloc</code>, as conversions from <code>void *</code> to any pointer to object are possible without an explicit cast:</p>

<pre><code>struct b {
    int y;
    struct {
        int z;
    } *x;
} y;

y.x = malloc(sizeof *y.x * 5);
</code></pre>

<p>Why would you think that this is better than polluting the namespace is beyond my imagination.</p>

<hr>

<p>GCC provides the <code>typeof</code> so you can increase insanity by things like</p>

<pre><code>typeof(y.x) foo;
</code></pre>

<p>or even declare a structure of that type</p>

<pre><code>struct b y;
typeof(y.x[0]) foo;
foo.z = 42;
y.x = &amp;foo;
</code></pre>
",2
50311768,50311439,0,"<p>Experimenting with bash (version 3.2.57(1)-release (x86_64-apple-darwin17)) suggests that the ¡°otherstuff¡± in your example is not passed to the program. When a program is called with the command line you show, the memory pointed to by <code>argv[1]</code> contains ¡°arg1¡±, then a null character, then ¡°arg2¡±. Thus, the null and ¡°otherstuff¡± in your command line has not been passed to the program.</p>

<p>(Hypothetically: If the shell were to pass it to the program, I would expect it would pass it in the memory continuing from that pointed to by <code>argv[1]</code>, and there would be no danger of it overwriting any buffer. If the shell were designed to tolerate an embedded null character in an argument, I expect (based on how we design things) that it would treat the argument as a complete string and provide the necessary space to hold it.)</p>

<p>The fact that the argument prior to ¡°arg2¡± contains a null character is irrelevant to the handling of ¡°arg2¡±. After initial processing of the command line, the shell does not treat the line as one string. It has divided it into words or other units and handles them with its own data structures. So the presence of null characters in prior arguments has no effect on later arguments.</p>

<p>Additionally, it may not be possible for the shell to pass an argument containing an embedded null character. The routines typically used to execute a program, such as <code>execl</code>, accept the arguments as null-terminated strings. So the embedded null terminates the string, and the <code>execl</code> routine never passes anything beyond the null character.</p>
",0
55510122,55509451,2,"<p>As pointed in comments:</p>

<ul>
<li>you can't use <code>strlen</code> when using binary data</li>
<li>you can't use <code>sizeof</code> when using pointers on array.</li>
</ul>

<p>Lets see:</p>

<pre><code>/* you should have some static variables to store data */

static void * body = NULL;
size_t body_size = 0;      

/* extract body from message */        
int returnBody(void *message, size_t message_size){    

    if (! message || message_size &lt; 5)
    {
        return 0;
    }

    /* if your system doesn't have memmem function, see https://stackoverflow.com/a/52989329/1212012 */    
    void *data = memmem(message, message_size, ""\r\n\r\n"", 4);

    if (data)  {
        /* header found */
        /* data are four bytes after the \r\n\r\n sequence */
        data += 4;
        size_t header_size = data - message;
        body_size = message_size - header_size;

        void *p = realloc(body, body_size);
        if (!p) {
            perror(""realloc"");
            return 0;
        }

        body = p;
        memcpy(body, data, body_size);

        return 1;
    }
    return 0;
}
</code></pre>

<p>And your reading writting function should be like:</p>

<pre><code>char update[1024] = {0};
FILE *fileo;
fileo = fopen(""test.exe"", ""wb"");
/* you should test `fileo` here */

/* first read */
instruction = recv(s, update, sizeof update, 0);

/* set message and its size for */   
int result =returnBody(udpate, instruction);//Removes headers

/* you should test `result` here */


fwrite(body, body_size, 1, fileo);

/* clearing update is not necessary */
/*memset(update, 0, sizeof update); */

while ((instruction = recv(s, update, sizeof update, 0)) &gt; 0)
{
    fwrite(update, instruction, 1, fileo);
    //memset(update, 0, sizeof update);
}
fclose(fileo);        
</code></pre>
",1
55463657,55463446,4,"<p>Your problem in handling control-Z is not leaving the <code>switch</code> statement, it is leaving the <code>while</code> statement.</p>

<p>On a Windows system, when the user presses control-Z at the start of an input line, the software will act similarly to an end-of-file. Notably, when <code>scanf(""%c"", &amp;choose);</code> executes, there will be no input for it to read, so nothing will be stored in <code>choose</code>. Instead, <code>scanf</code> will return <code>EOF</code> to indicate no match to <code>""%c""</code>could be made (because no input was available). However, your code does not test the return value of <code>scanf</code>, so it will not see this.  One way to fix this is:</p>

<pre><code>while (1)
{
    int n = scanf(""%c"", choose);
    if (n != 1) // Did scanf match %c and store something in choose?
        break; // No, so break out of the while loop.
    switch (choose)
    ¡­
}
</code></pre>

<p>Then there is the matter of what should be in the <code>switch</code> statement. You say you ¡°need to handle all the inputs from switch.¡± A <code>char</code> typically has 256 possible values. So, unless you have 256 <code>case</code> labels in the <code>switch</code>, you are not handling all the inputs in the <code>switch</code> statement. You should have a <code>default</code> label.</p>

<p>If any of the cases inside the <code>switch</code> needs to cause execution to leave the <code>while</code> statement, you can arrange this in various ways. One way is to use a variable to indicate that:</p>

<pre><code>while (1)
{
    int n = scanf(""%c"", choose);
    if (n != 1) // Did scanf match %c and store something in choose?
        break; // No, so break out of the while loop.

    int LeaveWhile = 0;
    switch (choose)
    {
        case 'A':
            // Code to handle A input.
            break;
        case 'B':
            ¡­
        case something:  // Some case where we want to end the loop.
            LeaveWhile = 1; // Indicate end of loop.
            break;
        ¡­
        default:
            // Code to handle remaining values.
            break;
    }

    // If it is time to leave the while loop, break out of it.
    if (LeaveWhile)
        break;
}
</code></pre>
",0
55463620,55463446,4,"<p>If the user presses <kbd>Ctrl</kbd>+<kbd>Z</kbd> on Windows, your program will see that as an end of input file (<code>stdin</code>). When <code>scanf</code> tries to read a byte from <code>stdin</code>, it will fail and return <code>-1</code> (<code>EOF</code>), while the usual return value is 1 (i.e. number of items read).</p>

<p>So you can use the following code:</p>

<pre><code>while (scanf(""%c"", &amp;choose) == 1)
{
    switch (choose) {

    case 1:
        //something
        break;
    case 2:
        // something
        break;

    // no default!

    }
}
</code></pre>

<p>I put the return value of <code>scanf</code> into the <code>while</code>'s condition. When <code>scanf</code> cannot read a byte from <code>stdin</code> anymore, the loop will terminate.</p>
",3
55464037,55463446,1,"<p>Before describing how I would handle the problem of the ""break"" keyword being overused in C, there is another issue you may hit that should be mentioned.  </p>

<p>The behavior of <kbd>control-C</kbd> and <kbd>control-Z</kbd> vary with the OS and the TTY (console) settings.</p>

<p>Linux, with default TTY settings, will cause an interrupt with <kbd>control-C</kbd>, which if not handled will end the program.  <kbd>control-Z</kbd> will suspend the program.  By default, in neither case is the character delivered to the program, and so it can not be read by scanf, and it will not be dispatched by the switch statement.</p>

<p>Windows will also interrupt with <kbd>control-C</kbd> by default.</p>

<p>I mention this because you depend on reading control characters in your input parsing.  If you aren't having the behavior you want, consider looking at TTY settings.</p>

<p>As for exiting the ""while(1)"" from inside the switch, the standard way is to change the loop from ""while(1){}"" to ""int looping =1; while (looping){}"", and set looping to 0 inside the body of the while loop.</p>

<p>In some cases, I will do this with (cover the eyes of the children watching) a goto to a label after the while body.  I prominently display goto label, and reverse indent it to outside the level of the while loop body.</p>

<p>Sometimes the break condition is more natural, and sometimes the goto is clearer.  If you don't have an aesthetic preference for one over the other, you might default to the break condition rather than the goto.</p>
",2
55463503,55463446,0,"<p>Add a flag at the top of the loop that gets set when you want to break out, then do so after the <code>switch</code>:</p>

<pre><code>while (1) {
    int breakout = 0;

    scanf(""%c"", &amp;choose);
    switch (choose) {
    case 1:
        //something
        break;
    case 2:
        // something else
        // exit the loop in this case
        breakout = 1;
        break;
    }
    if (breakout) break;
}
</code></pre>
",3
53318957,53318873,1,"<p><code>realloc(s, size*(sizeof(Student)) );</code> must be <code>realloc(arr, size*(sizeof(Student)) );</code> (<code>s</code> is <code>NULL</code>!).</p>

<p>Then, you never return the newly allocated array to the caller:</p>

<p><code>arr = temp</code> does <em>not</em> change the passed in pointer. You'd need a pointer to a pointer to return the new value, like</p>

<pre><code>void Enqueue(Student **arr ,  int index){
...
  *arr = temp;
...
}
</code></pre>

<p>or just return the new array:</p>

<pre><code>Student* Enqueue(Student *arr, int index) {
...
return temp;
}
</code></pre>

<p>And then there are the other memory management bugs, as mentioned by @WhozCraig.</p>
",0
52875348,52875241,6,"<p>Complement to the other answers:</p>

<p>Try this and you'll understand:</p>

<pre><code>#include &lt;stdio.h&gt;

char character = 'c';

void Check()
{
  printf(""Check: c = %c\n"", character);
}

int main(void)
{
  char character = 'b';
  printf(""The current value of head is %c\n"", character);
  Check();
}
</code></pre>
",0
52875353,52875241,5,"<p>It will live on (till the program dies, as any static-storage variable would) and you can still get to it:</p>

<pre><code>#include &lt;stdio.h&gt;
char character = 'c';
int main (void)
{
    char character = 'b';
    printf(""The current value of head is '%c'\n"", character);
    {
        extern char character;
        //in this scope, overrides the local `character` with 
        //the global (extern?) one
        printf(""The current value of head is '%c'\n"", character);
    }
    printf(""The current value of head is '%c'\n"", character);
}
/*prints:
The current value of head is 'b'
The current value of head is 'c'
The current value of head is 'b'
*/
</code></pre>

<p>The local extern declaration doesn't work reliably/portably for <code>static</code> globals, though you can still get to them through pointers or through a separate function.</p>

<hr>

<p>(
Why isn't <code>static char character='c'; int main(){ char character='b'; { extern char character; } }</code> reliable  with the global being <code>static</code>?</p>

<p><a href=""http://port70.net/~nsz/c/c11/n1570.html#6.2.2p4"" rel=""nofollow noreferrer"">6.2.2p4</a> seems like it wants to make it work for statics too, but the wording is ambiguous (a prior declaration has no linkage and another has static/extern linkage so what now?).</p>

<p><a href=""http://port70.net/~nsz/c/c11/n1570.html#6.2.2p4"" rel=""nofollow noreferrer"">6.2.2p4</a>:</p>

<blockquote>
  <p>For an identifier declared with the storage-class specifier extern in
  a scope in which a prior declaration of that identifier is visible,31)
  if the prior declaration specifies internal or external linkage, the
  linkage of the identifier at the later declaration is the same as the
  linkage specified at the prior declaration. If no prior declaration is
  visible, or if the prior declaration specifies no linkage, then the
  identifier has external linkage.</p>
</blockquote>

<p>My clang 6.0.0 is accepting it with a <code>static char character='b';</code> but my gcc 7.3.0 isn't.</p>

<p>Thanks to <a href=""https://stackoverflow.com/users/298225/eric-postpischil"">Eric Postpischil</a> for pointing out the ambiguous possibility of this being usable with <code>static</code> too.
)</p>
",4
52875323,52875241,1,"<p>Normaly, the global variable will stay. Since your local variable only shadows the name, it doesn't affect the storage.</p>

<p>But it could also depend on linker settings. Linker could optimize the unsused global variable out.</p>
",0
52875283,52875241,13,"<p>You have two separate variables named <code>character</code>: one at file scope set to 'c', whose lifetime is the lifetime of the program, and one in <code>main</code> set to 'b', whose lifetime is that of its scope.  </p>

<p>The definition of <code>character</code> in <code>main</code> <strong>masks</strong> the definition at file scope, so only the latter is accessible.</p>
",3
52875359,52875241,3,"<p>After the declaration of <code>character</code> in <code>main</code>, any reference to <code>character</code> in that function refers to that one, not the one at global scope. We call this <em>shadowing</em>.</p>

<p>As for the effect on memory, you can't say due to the <em>as-if</em> rule adopted by the language: a compiler might optimise to</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
     printf(""The current value of head is b"");
}
</code></pre>

<p>for example.</p>
",0
52826833,52826810,-1,"<p>Output buffering. C library stdio has new line'd buffer has output buffering. TO disable buffering call <code>setbuf(stdout, NULL);</code></p>
",0
52827122,52826810,2,"<blockquote>
  <p>assume when I input a, it will immediately output b. However, it wait until I strike enter.</p>
</blockquote>

<p>""a, ... immediately output b"" --> not likely.  </p>

<blockquote>
  <p>What's the reason putchar(n+1) not put it char immediately as the second putchar(ch) did?</p>
</blockquote>

<p>Input buffering is the likely first concern as <code>stdin</code> is often <em>line buffered</em>.</p>

<p>Typically nothing of the first characters of a line are even available to <code>stdin</code> until <kbd>Enter</kbd> or <code>'\n'</code> are entered (and echoed). </p>

<p>With <em>line buffered</em> input, the entire <code>""a c programmer\n""</code> is keyed in and echoed before the first <code>getchar()</code> call returns with <code>'a'</code>.</p>

<p>Aside from this common case, other possibilities exist as this is implementation defined.</p>

<hr>

<p>Output buffering likely occurs too, but that is something after all the 1st line's input is entered and echoed.  Thus when <code>putchar('b'), putchar(' '), ...</code> execute, no output is seen until <code>putchar('\n')</code>.  See <a href=""https://stackoverflow.com/q/39536212/2410359"">What are the rules of automatic flushing stdout buffer in C?</a></p>
",0
53745830,53745707,2,"<p>This code demonstrates the right way, and the wrong way to change a number.</p>

<p>The function <code>get_number_A</code> will NOT make a meaningful change to its parameter, because C uses ""pass-by-copy"" for its parameters.</p>

<p>The function <code>get_number_B</code> will make a meaningful change to its parameter, because a pointer to the variable is passed.</p>

<pre><code>void get_number_A(int x)
{
    x = 5; // This change will NOT happen outside of this function.
}

void get_number_B(int* p)
{
    *p = 7; // This change will happen outside of this function.
}

int main(void)
{
    int number = 0;

    get_number_A(number);
    printf(""A.) The number is: %d; it was NOT modified.\n"", number);

    get_number_B(&amp;number);
    printf(""B.) The number is: %d; it was SUCCESSFULLY modified.\n"", number);

    return 0;
}
</code></pre>

<p><a href=""https://ideone.com/MCr8Qa"" rel=""nofollow noreferrer"">View this code on IDEOne</a></p>
",0
55378474,55358510,0,"<p>The problem is that you don't build an object file named <code>main.o</code>, your rule attempt to build an <em>executable</em> by that name.</p>

<p>The simple and most immediate way to solve your problem is to add the <code>-c</code> flag when building:</p>

<pre><code>main.o : globals.h util.h main.c
    $(CC) -c -o main.o main.c
#         ^^
# Note flag added
</code></pre>

<hr>

<p>A ""better"" and at least simpler way is to rely on the <a href=""https://www.gnu.org/software/make/manual/html_node/Implicit-Rules.html#Implicit-Rules"" rel=""nofollow noreferrer""><em>implicit rules</em></a> that <code>make</code> have for creating, among other things, object and executable files.</p>

<p>Then you could simply have your <code>Makefile</code> look something like this:</p>

<pre><code># CFLAGS is the C compiler flags
# Add flags to enable verbose warnings (always a good idea)
CFLAGS = -Wall -Wextra -pedantic

TARGET = lexic

# The libraries to link the target application with
LDLIBS = -ll

# By default the make program uses the first target
default: $(TARGET)

# Because of the implicit rules, make will be able to link the executable by itself
$(TARGET): lex.yy.o util.o main.o

# Also because of implicit rules, object files will be created automatically as well
# But we list them here to specify their header-file dependencies
util.o main.o: globals.h util.h
</code></pre>

<p>Important note: The implicit rule for Lex files (including Flex) is to create the source file <code>X.c</code> from the file <code>X.l</code>. So unless your Lex file is names <code>lex.yy.l</code> then you need to change the name of the object file <code>lex.yy.o</code> in the above <code>Makefile</code>.</p>
",0
54626503,54626446,3,"<p>With :</p>

<pre><code>for(i = 0; i &lt; length/2; i++){
</code></pre>

<p>you never set the middle character (for odd lengths) in <code>dest</code>.</p>

<p>With your example <code>""hello""</code>, <code>length/2</code> is <code>2</code>, so you set (for <code>i</code> = <code>0</code>) :</p>

<pre><code>dest[0] = src[5-0-1]; // dest[0] = src[4]
dest[5-0-1] = src[0]; // dest[4] = src[0]
</code></pre>

<p>and then (for <code>i</code> = <code>1</code>) :</p>

<pre><code>dest[1] = src[5-1-1]; // dest[1] = src[3]
dest[5-1-1] = src[1]; // dest[3] = src[1]
</code></pre>

<p>and that's it. You never set <code>dest[2]</code>.</p>
",2
54626504,54626446,2,"<p>Because <code>i&lt;length/2</code> is already based on integer division, i.e: it will floor the result. This will skip the middle element in case of odd length strings.</p>
",0
49789452,49789206,2,"<p>First and foremost: the <code>1.5</code> in the standard input is not a a floating point value. It's a string of characters which <em>may be interpreted</em> as floating point value. It's also a string of characters that may not be interpreted <em>entirely</em> as an integer. </p>

<p>When scanning it, the <code>1</code> may be consumed to scan a value for <code>a</code>. But then the <code>.</code> is encountered, which may not be part of of a character sequence that stands for the value of an integer. So <code>scanf</code> will not consume it, it will stay in the input buffer until some other operation will deal with it.</p>

<p>But you call <code>scanf</code> again, and tell it to expect an integer. It still sees the <code>.</code>, which it can't handle. So it returns without consuming anything or writing anything into the argument you've given it. It reports the result of the operation in its return value, that you neglect to check. On the whole, your code doesn't take any error handling into account. It's written with the assumption <code>scanf</code> will always succeed, which is not realistic. You can read about <a href=""http://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow noreferrer""><code>scanf</code>'s return value here</a>.</p>

<p>Beyond that, you don't initialize any of your variables. That leaves them with indeterminate values. If <code>scanf</code> succeeds, those variables get assigned something else and your program runs successfully. But if <code>scanf</code> fails they don't, and you use those indeterminate values, resulting in your program having undefined behavior. There's no point trying to understand undefined behavior. You should fix your code instead. And you do that by handling failure properly. How you choose to handle <code>scanf</code>'s failure is up to you. </p>
",0
54707319,54707239,1,"<p>Two problems:</p>

<ol>
<li><p>Consider these lines from the reallocation code:</p>

<pre><code>pointer[i] = (double*)realloc(*(pMatrix+i), 2 * size * sizeof(double));
pointer[i] = (double*)malloc(size * sizeof(double));
</code></pre>

<p>In the second you don't allocate as much memory as the reallocation.</p></li>
<li><p>After you have reallocated, you free the old data, but it has already been done by the <code>realloc</code> calls.</p></li>
</ol>

<p>On an unrelated note, in C you <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc/"">should not cast the result of <code>malloc</code> (or it siblings)</a>.</p>
",0
53209286,53209216,2,"<p>You need to add <code>O_WRONLY</code> (or <code>O_RDWR</code>) to the <code>open</code> call.</p>

<pre><code>#include&lt;fcntl.h&gt;
#include&lt;unistd.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/stat.h&gt;
#include&lt;stdio.h&gt;
int main()
{
    int fd,j;
    fd = open(""test.txt"", O_WRONLY | O_CREAT | O_APPEND,0777);
    if(0&gt;fd) perror(0);
    printf(""%d\n"",fd);
    j=write(fd,""A"",1);
    printf(""write return %d\n"",j);
    if(0&gt;j) perror(0);
    return 0;
}
</code></pre>
",5
58449528,58449263,1,"<p>Use a space character following the <code>%d</code> in scanf to read in the whitepace that follows the value entered.</p>

<p>In other words, use:</p>

<pre><code>scanf(""%d "", &amp;t);
</code></pre>

<p>Also note that <code>gets</code> has been deprecated for years. It is vulnerable to buffer overrun attacks. Use <code>fgets</code> instead.</p>

<p>Here is a fixed version of this program:</p>

<pre><code>#include &lt;stdio.h&gt; 

#define CHECK_BUFSIZE 19

int check()
{ 
    char s[CHECK_BUFSIZE+1];
    fgets(s, CHECK_BUFSIZE, stdin);
    printf(""%s"",s);
}

int main()
{
    int t,i;
    scanf(""%d "",&amp;t);   
    check();
    return(0);
}
</code></pre>
",1
52901836,52901658,1,"<p>The rule at play here is clause 6.3.2.1, paragraph 2, in the 2018 C standard (and the same or similar clauses in earlier standards). This rule tells us when a name represents the object and when it is converted to a value (so it can no longer be used to access the object).</p>

<p>A variable is actually two things: an object, which is a region of storage (a byte for a <code>char</code>, several bytes for an <code>int</code>, possibly many bytes for a structure or an array) and an identifier (its name).</p>

<p>When you use the name in source code, it is an <em>lvalue</em>, which designates an object.<sup>1,2</sup>. Clause 6.3.2.1, paragraph 2, tells us that when an <em>lvalue</em> is used with unary <code>&amp;</code>, it is <strong>not</strong> converted to a value. It designates the object, and then the <code>&amp;</code> operator can provide the address of that object.</p>

<p>This paragraph also tells us this conversion is not performed when an lvalue is used with <code>sizeof</code>, <code>++</code>, or <code>--</code>, or when it is the left operand of <code>.</code> (for accessing structures) or of <code>=</code> (for assignment).</p>

<p>Otherwise, the lvalue is converted to its value.<sup>3</sup></p>

<p>Thus, in <code>scanf(""%d"", my_integer)</code>, <code>my_integer</code> is converted to the value in it. Only this value is passed to <code>scanf</code>, and therefore <code>scanf</code> has no way of accessing the object. When you write <code>scanf(""%d"", &amp;my_integer)</code>, the <code>&amp;</code> takes the address of <code>my_integer</code>, and this address is passed to <code>scanf</code>. This gives <code>scanf</code> a way to access the object (by its address).</p>

<p>Identifiers used in expressions are not the only lvalues in C. Another common lvalue is the expression <code>*p</code>, where <code>p</code> is a pointer. This is an lvalue, effectively the same as if the name of the object that <code>p</code> points to had been used.<sup>4</sup></p>

<h1>Notes</h1>

<p><sup>1</sup> The term ¡°lvalue¡± comes from its historic appearance on the left side of an expression as in <code>a = 3</code>. Since <code>a</code> is being changed by the assignment, the name ¡°a¡± must provide access to the object. It cannot be just a value.</p>

<p><sup>2</sup> The C standard says an lvalue <em>potentially</em> designates an object, but we do not need to consider the exceptions here. </p>

<p><sup>3</sup> Also, if the lvalue designates an array, it is not converted to its value. However, a different conversion is performed in most circumstances; an array is converted to a pointer to its first element.</p>

<p><sup>4</sup> Other lvalues are string literals, references to structure members (such as <code>s.member</code> or <code>p-&gt;member</code>), and compound literals. lvalues can also ¡°pass through¡± certain other operators such as parentheses or <code>_Generic</code>.</p>
",0
52901672,52901658,5,"<p>This is confusing wording. Perhaps a clearer way to put it is that <code>scanf</code> needs to know where to put the values that it will read in. Giving it the current value of a variable doesn't do it any good (unless that variable contains the address you want the values placed).</p>

<pre><code>int my_integer;
scanf (""%d"", &amp;my_integer);
</code></pre>

<p>This passes to <code>scanf</code> the address where <code>my_integer</code>'s value is stored. Without the <code>&amp;</code>, you'd be passing it the value of <code>my_integer</code>, which would be garbage since the variable hasn't been initialized.</p>

<p>The phrase ""not variables themselves"" is confusing. Perhaps ""not values themselves"" would be more helpful, because sometimes variables do contain pointers to where values are stored.</p>
",0
52855916,52855674,20,"<p>Different regions have very different addresses. If they were in the same region, they would have similar addresses. Better example, where we allocate 2 objects in each region:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main (void)
{
  int stack1;
  int stack2;
  static int bss1;
  static int bss2;
  static int data1=1;
  static int data2=1;
  int* heap1 = malloc(1);
  int* heap2 = malloc(1);  
  char* rodata1 = ""hello"";
  char* rodata2 = ""world"";

  printf("".stack\t%p %p\n"",  &amp;stack1,  &amp;stack2);
  printf("".bss\t%p %p\n"",    &amp;bss1,    &amp;bss2);
  printf("".data\t%p %p\n"",   &amp;data1,   &amp;data2);
  printf("".heap\t%p %p\n"",   heap1,    heap2);
  printf("".rodata\t%p %p\n"", rodata1,  rodata2);

  free(heap1);
  free(heap2);
}
</code></pre>

<p>Output (for example):</p>

<pre><code>.stack  000000000022FE2C 000000000022FE28
.bss    0000000000407030 0000000000407034
.data   0000000000403010 0000000000403014
.heap   0000000000477C50 0000000000477C70
.rodata 0000000000404000 0000000000404006
</code></pre>

<p>As you can see the two variables in the same segment have nearly identical addresses, the only difference being the size of the objects (and possibly some room for alignment). While they have very different addresses compared to variables in the other segments.</p>
",5
52265262,52265163,7,"<p><a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""noreferrer"">The <code>scanf</code> family has myriad problems</a> including leaving items in the buffer which it will then continue to re-read. That's what's happening to you. If you don't need to use it, don't use it.</p>

<p>Use <code>fgets</code> to read whole lines. Then if you want to parse the line further use <code>sscanf</code>.</p>

<pre><code>char line[BUFSIZ];
while( fgets(line, sizeof(line), stdin) != NULL ) {
    ...
}
</code></pre>
",0
53348942,53348398,1,"<p><sup><em>Transferring a <a href=""https://stackoverflow.com/questions/53348398/undefined-symbols-for-architecture-x86-64-and-linker-command-failed-with-exit-co?noredirect=1#comment93575377_53348398"">comment</a> into an answer, as requested.</em></sup></p>

<p>The error message says ""there is no function <code>main()</code>"", and the source code you show has no function <code>main()</code>, so there's minimal surprise that there's that error message.</p>

<p>Where did you think <code>main()</code> was going to come from?</p>

<p>When you build a program, there needs to be a <code>main()</code> from somewhere, and the standard C library does not provide an implementation.  (If you work with Flex or Lex, or Bison or Yacc, you may find minimal <code>main()</code> programs in their libraries, but these are an exception, not the rule.)</p>
",0
48089950,41749817,0,"<p>If you are ""receiving an error on line 12 stating that my break statement is not in the loop or switch"" then either you have a very deficient compiler or you've posted the wrong code. That code has a <em>few</em> problems but a <code>break</code> in the wrong place is not one of them.</p>

<p>That particular error message often occurs when you've mislaid some braces, along the lines of:</p>

<pre><code>int i;
for (i = 0; i &lt; 10; ++i)
    printf(""%d\n"", i);
    if (someCondition)
        break;
</code></pre>

<p>That's because, despite the fact it <em>looks</em> like you're breaking out of a loop, the actual <code>break</code> statement is not <em>within</em> the loop. Only the <code>printf</code> is.</p>

<p>In terms of the code you <em>have</em> provided, there are numerous ways to clean it up:</p>

<ul>
<li>Remove unneeded includes.</li>
<li>Refactor out the number input to a common function.</li>
<li>Allow a single non-positive number to terminate the program.</li>
<li>Use <code>DRY</code> principle for input, there's really any need to duplicate code segments if you structure it corretly.</li>
<li>Make input more robust, allowing for invalid numbers.</li>
<li>Add more comments, these will greatly assist you (or others who have to maintain your code) in the future.</li>
<li>Use better variable names. Other than <code>i</code> for small localised loops, I almost <em>never</em> use single-character variable names.</li>
<li>Fix the <code>if(n1==-1,n2==-1)</code> bit. That doesn't do what you appear to think it does. The comma operator will <em>evaluate</em> both expressions but the result of the full expression is the rightmost one. So it's effectively <code>if(n2==-1)</code>.</li>
</ul>

<p>To that end, the following is how <em>I</em> would write the code:</p>

<pre><code>#include &lt;stdio.h&gt;

#define ERR_NON_POS -1
#define ERR_INVALID -2

// Gets a single number.
//  If non-positive or invalid, returns error (a negative value ERR_*).
//  Otherwise, returns the (positive) number.

int getNumber(void) {
    int number;
    if (scanf(""%d"", &amp;number) != 1) return -2;
    if (number &lt;= 0) return -1;
    return number;
}

int main(void) {
    // Infinite loop, we'll break from within as needed.

    for (;;) {
        printf(""Enter two positive integers (a negative number will stop): "");

        // Do it one at a time so a SINGLE negative number can stop.

        int number1 = getNumber();
        if (number1 == ERR_INVALID) {
            puts(""** Non-integral value entered"");
            break;
        }
        if (number1 == ERR_NON_POS) break;

        int number2 = getNumber();
        if (number2 == ERR_INVALID) {
            puts(""** Non-integral value entered"");
            break;
        }
        if (number2 == ERR_NON_POS) break;

        // Work out greatest common divisor (though there are better ways
        //  to do this than checking EVERY possibility).

        int gcd = 1;
        for (int i = 2; (i &lt;= number1) &amp;&amp; (i &lt;= number2); ++i) {
            if (number1 % i == 0 &amp;&amp; number2 % i == 0) {
                gcd = i;
            }
        }

        // Work out the lowest common multiple.

        int lcm = number1 * number2 / gcd;

        // Print them both and go get more.

        printf(""For numbers %d and %d, GCD is %d and LCM is %d.\n"", number1, number2, gcd, lcm);
    }

    return 0;
}
</code></pre>

<hr>

<p>And, if you're wondering about the more efficient way of calculating GCD, you should look into Euclid's algorithm. This can be defined as (for non-negative <code>a</code> and <code>b</code>):</p>

<pre><code>gcd(a,b) = a               if b is zero
           gcd(b, a mod b) if b is non-zero
</code></pre>

<p>That means you can have a recursive function:</p>

<pre><code>int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}
</code></pre>

<p>Or an iterative one if you're vehemently opposed to recursion:</p>

<pre><code>int gcd(int a, int b) {
    while (b != 0) {
        int t = a % b;
        a = b;
        b = t;
    }
    return a;
}
</code></pre>
",0
48352617,48352578,1,"<p>It it possible that you're not counting the final '\n' character when you </p>

<pre><code>while(string[numChars] &amp;&amp; string[numChars] != '\n')
 ++numChars;
</code></pre>

<p>?</p>

<p>If so, you never hit </p>

<pre><code>      if (string[i] == '\n'){
       putchar(string[0]);
       putchar('\n');
   }
</code></pre>

<p>because your loop stops one early.</p>
",2
49967545,49967237,4,"<p>The code in the question is:</p>

<pre><code>char *str = ""face"";
printf(""%d\n"", -2[str]);
</code></pre>

<p>Let's be clear: this is horrid, and anyone writing that code should be made to rewrite it.</p>

<p>There are two parts to the confusion when approaching this:</p>

<ol>
<li><a href=""https://stackoverflow.com/questions/381542/with-arrays-why-is-it-the-case-that-a5-5a"">Why is <code>a[i] == i[a]</code>?</a></li>
<li>How is <code>-2[str]</code> evaluated?</li>
</ol>

<p>The linked question covers (1) extensively.  Read it.</p>

<p>To address the second part, consider an alternative program:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    char data[] = ""XYZface"";
    char *str = &amp;data[3];
    printf(""[%s] %d %d %d (%c)\n"", str, -2[str], -(2[str]), (-2)[str], (-2)[str]);

    return 0;
}
</code></pre>

<p>This outputs:</p>

<pre><code>[face] -99 -99 89 (Y)
</code></pre>

<p>Why?  The <code>-2[str]</code> notation is equivalent to <code>-str[2]</code> (you have read the linked Q&amp;A, haven't you?) and not <code>str[-2]</code>, because there are no negative literal numbers.</p>

<p>Read <a href=""https://port70.net/~nsz/c/c11/n1570.html#6.4.4.1"" rel=""nofollow noreferrer"">C11 ¡ì6.4.4.1 Integer constants</a>: there are no minus signs in there.  When you write <code>-2</code>, you have a unary minus operator and a literal <code>2</code>.  Mostly, that's the same as negative two, but not when mixed with a higher priority operator such as subscripting.  The <a href=""https://port70.net/~nsz/c/c11/n1570.html#6.5.2"" rel=""nofollow noreferrer"">¡ì6.5.2 Postfix operators</a> such as subscripting have higher priority than the <a href=""https://port70.net/~nsz/c/c11/n1570.html#6.5.3"" rel=""nofollow noreferrer"">¡ì6.5.3 Unary operators</a> such as negation.</p>

<p>Let's also be clear: there is no undefined behaviour in the question's code (or mine, I trust).  Technically, the value for letter <code>'c'</code> (<code>+99</code>) is implementation-defined, but there are few extant systems where the integer value of <code>'c'</code> is not 99 (but see <a href=""https://en.wikipedia.org/wiki/EBCDIC"" rel=""nofollow noreferrer"">EBCDIC</a> for a code set where the answer would be different).</p>
",0
49967459,49967237,5,"<p>First, we need to parse the expression in question: We have two operators in <code>-2[str]</code> - a subscript operator <code>[]</code> and a unary minus operator <code>-</code>. Subscript operator has <a href=""http://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer"">higher precedence</a> than unary minus, so <code>printf</code> prints a negation of <code>2[str]</code>*.</p>

<p>There are many Q&amp;As explaining that <code>2[str]</code> is the same as <code>str[2]</code>, so I am not going to repeat the explanation; you can read about it <a href=""https://stackoverflow.com/q/381542/335858"">in this Q&amp;A</a>.</p>

<p>Finally, the value of <code>str[2]</code> is <code>'c'</code>, which represents code of <code>99</code> on your system. Negation is applied to that value, so that is how <code>-99</code> gets printed.</p>

<p>* Note that <code>-</code> is not part of an integer constant, because <a href=""https://stackoverflow.com/q/17899318/335858"">in C integer constants do not include sign</a>.</p>
",3
53581892,53578973,0,"<p>1st of all in C arry indexing is 0-based. So you most likley do not want</p>

<blockquote>
<pre><code>str[1][1]   str[1][2]   str[1][3]

YES         NO          YES 
</code></pre>
</blockquote>

<p>but</p>

<blockquote>
<pre><code>str[0][0]   str[0][1]   str[0][2]

YES         NO          YES 
</code></pre>
</blockquote>

<p>To achieve this you have three possibilities.</p>

<ol>
<li><p>As arrays cannot be assigned, copy the array's content. </p>

<p>Define a 2D array of array of <code>char</code> with size 4 and copy whatever is less then 4 <code>char</code>long into them</p>

<pre><code>char str[1][10][4];
strcpy(str[0][0], ""YES"");
strcpy(str[0][1], ""NO"");
strcpy(str[0][2], ""YES"");
strcpy(str[0][3], ""BAR"");
</code></pre>

<p>You can later change each <code>char</code> separately:</p>

<pre><code>strcpy(str[0][0][0] = '1'; /* gives you ""1ES"" */
strcpy(str[0][2][0] = '3'; /* gives you ""2ES"" */
</code></pre></li>
<li><p>If you only need to use <code>""YES""</code> and <code>""NO""</code> you can define them once, and make your array a 2D array of pointer to <code>char</code> and let its entries refer to the value defined before:</p>

<pre><code>char yes[] = ""YES"";
char no[] = ""NO"";

char * str[1][10];
str[0][0] = yes;
str[0][1] = no;
str[0][2] = yes;
</code></pre>

<p>If you later change a <code>char</code> for one it changes the value of all:</p>

<pre><code>strcpy(str[0][0][0] = '1'; /* gives you ""1ES"" for str[0][0] and str[0][2] */

strcpy(str[0][2][0] = '2'; /* gives you ""2ES"" for str[0][0] and 
</code></pre></li>
<li><p>If you do not want to change the strings's characters separately then define them as under 2. above but define them as pointers to constant by doing:</p>

<pre><code>char * yes = ""YES"";
char * no = ""NO"";

char * str[1][10];
str[0][0] = yes;
str[0][1] = no;
str[0][2] = yes;
</code></pre>

<p>You cannot later change a <code>char</code>.</p></li>
</ol>
",0
53579067,53578973,2,"<p>What about:</p>

<pre><code>char str[10][4] = { ""Yes"", ""No"", ""Yes"", /* ... */ };
</code></pre>

<p>Be aware that you need one array position more for the trailing null character!</p>

<p>As shown above, additional (unassigned) values are set to 0, so you'd get empty strings if not sufficient initialisers provided.</p>

<p>By the way, you <em>can</em> drop first array parameter, below a variant doing so <em>and</em> using designated initialisers:</p>

<pre><code>char str[][4] = { [0] = ""Yes"", [7] = ""Yes"", [10] = ""No"", [12] = ""No"", /* ... */ };
</code></pre>

<p>Again, unsigned values are 0, outer array length is number of entries (if no designated initialisers used) or long enough to include highest index provided (so size is highest index + 1).</p>

<p><em>Edit: Assigning at a later point of time:</em></p>

<pre><code>char str[10][4];
// ...
memcpy(str[7], ""Yes"", sizeof(""Yes""));
</code></pre>

<p>Be aware that you can apply <code>sizeof</code> <em>only</em> to string <em>literals</em> &ndash; for strings received via a <em>pointer</em> you must use <code>strlen</code> instead (the latter not counting the terminating null character, though, which <code>sizeof</code> does).</p>

<p>Note that I deliberately did not use <code>strcpy</code> because if length is known, memcpy is more efficient, and if not known, <code>strcpy</code> is unsafe (risking undefined behaviour due to writing beyond target array bounds).</p>

<p>If you use pointers, the matter gets easier:</p>

<pre><code>char const* const YES = ""Yes""; // constants for safer usage
char const* const NO  = ""No"";

char const* str[10]; // array of pointers, not array of arrays

str [7] = NO;
</code></pre>

<p>Of course, you still can pre-initialise:</p>

<pre><code>char const* str[10] = { YES, NO, YES, NO, /* ... */ };
</code></pre>
",2
50093419,50093377,0,"<p>Your question is indeed chaotic.  I'm not sure what you really want to know, but notice that 'else if (p_game_info->status=P2_TURN){'  is wrong.  You need a double equal sign there.</p>
",3
57936037,57933793,1,"<p>Although the article you link to appears to show using five bits for each of <code>M</code> and <code>A</code> when the dividend width is four bits, it fails to explicitly state what width to use or why. Nonetheless, the shift of <code>A</code> and <code>Q</code> as a single register can be readily accomplished:</p>

<ul>
<li>Identify the top bit of Q.</li>
<li>Shift A left one bit and insert the top bit from Q as the low bit of A.</li>
<li>Shift Q left one bit, letting the top bit be shifted out (and lost).</li>
</ul>

<p>This uses a shift of 33 bits for <code>A</code>, if it is 33 bits when you are using a basic width of 32 bits, and a shift of 32 bits for <code>Q</code>. No 65-bit shift or register is needed.</p>
",0
54975000,54974823,4,"<p>You can't.</p>

<p>Because <code>function</code> is declared as <code>void (*function)(void*)</code> it always returns void, so you don't need to.</p>
",0
54975000,54974823,4,"<p>You can't.</p>

<p>Because <code>function</code> is declared as <code>void (*function)(void*)</code> it always returns void, so you don't need to.</p>
",0
54457641,41369927,0,"<p><code>process_1</code> does not wait for <code>process_2</code>. It just exits immediately. At which point <code>process_2</code> may not even have started. So when <code>process_2</code> sends the signal, <code>process_1</code> is likely to not exist anymore.
                    &ndash;&nbsp;kaylum</p>
",0
50013776,50013577,1,"<p>To fix first error use Mazaher Bazari answer</p>

<p>but your code still won't work like you want</p>

<p>try fix like this</p>

<pre><code>class Program
{
    public static void Main(string[] args)
    {
        var item1 = new GroceryItem(""Lettuce"", 2.05);
        item1.pItem = new FreshItem(item1);
        item1.pItem.Quantity = 12;
        double cost1 = item1.pItem.FindCost();


        Console.WriteLine(item1.Name + "" "" + item1.Price);
        Console.WriteLine(cost1);
        Console.ReadLine();
    }
}
public class PurchasedItem
{
    public int Quantity;
    protected GroceryItem item;
    public PurchasedItem(GroceryItem gItem)
    {
        item = new GroceryItem(gItem.Name, gItem.Price);
    }

    public virtual double FindCost()
    {
        return item.Price * this.Quantity * 1.10;
    }


}
public class FreshItem : PurchasedItem
{
    public double weight;

    public FreshItem(GroceryItem gItem) : base(gItem)
    {
    }

    public override double FindCost()
    {
        return this.item.Price * this.weight;
    }

}
public class GroceryItem
{
    public string Name;
    public double Price;

    public PurchasedItem pItem
    {
        get;
        set;
    }

    public GroceryItem()
    {
    }

    public GroceryItem(string name, double price)
    {
        this.Name = name;
        this.Price = price;
    }
}
</code></pre>

<p>you should add <code>Virtual</code> and <code>Override</code> to override method if not you need to new instance as FreshItem to use FreshItem FindCost</p>
",0
48895456,48895296,2,"<p>It is absolutely possible for the result to exceed 127. <code>int_fast8_t</code> (and <code>uint_fast8_t</code> and all the rest) set an explicit minimum size for the value, but it could be larger, and the compiler will not prevent it from exceeding the stated 8 bit bounds (it behaves exactly like the larger type it represents, the ""8ness"" of it isn't relevant at runtime), only guarantee it can definitely represent all values in said 8 bit range.</p>

<p>If you need it to explicitly truncate/wrap to 8 bit values, either use (or cast to) <code>int8_t</code> to restrict the representable range (though <a href=""https://stackoverflow.com/q/18195715/364696"">overflow wouldn't be defined</a>), or explicitly use masks to perform the same work yourself when needed.</p>
",2
48895443,48895296,1,"<p>Nope. All the fast types really are are typedefs. For example, stdint.h on my machine includes</p>

<pre><code>/* Fast types.  */

/* Signed.  */
typedef signed char     int_fast8_t;
#if __WORDSIZE == 64
typedef long int        int_fast16_t;
typedef long int        int_fast32_t;
typedef long int        int_fast64_t;
#else
typedef int         int_fast16_t;
typedef int         int_fast32_t;
__extension__
typedef long long int       int_fast64_t;
#endif

/* Unsigned.  */
typedef unsigned char       uint_fast8_t;
#if __WORDSIZE == 64
typedef unsigned long int   uint_fast16_t;
typedef unsigned long int   uint_fast32_t;
typedef unsigned long int   uint_fast64_t;
#else
typedef unsigned int        uint_fast16_t;
typedef unsigned int        uint_fast32_t;
__extension__
typedef unsigned long long int  uint_fast64_t;
#endif
</code></pre>

<p>The closest you can come without a significant performance penalty is probably casting the result to an 8-bit type.</p>
",0
48895512,48895296,1,"<p>From the C(99) <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.20.1.1p1"" rel=""nofollow noreferrer"">standard</a>:</p>

<blockquote>
  <p>The typedef name intN_t designates a signed integer type with width N
  , no padding bits, and a two¡¯s complement representation. Thus, int8_t
  denotes a signed integer type with a width of exactly 8 bits.</p>
</blockquote>

<p>So use <code>int8_t</code> to guarantee 8 bit int.</p>

<p>A compliant C99/C11 compiler on a POSIX platform must have <code>int8_t</code>.</p>
",6
49712195,49707519,0,"<p>As noted in the comment, you need to find the modification time of the source file via <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html"" rel=""nofollow noreferrer""><code>stat()</code></a>, the access time of the destination file also using <code>stat()</code>, and use the (obsolescent) <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/utime.html"" rel=""nofollow noreferrer""><code>utime()</code></a>
to set the modification and access times on the destination correctly.</p>

<p>That leads to code like:</p>

<pre><code>/*b SO 4970-7519 */

#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;utime.h&gt;

int main(int argc, char **argv)
{
    if (argc != 3)
    {
        fprintf(stderr, ""Usage: %s ref-file target-file\n"", argv[0]);
        return 1;
    }

    struct stat sb_ref;
    if (stat(argv[1], &amp;sb_ref) != 0)
    {
        fprintf(stderr, ""%s: failed to stat file %s\n"", argv[0], argv[1]);
        return 1;
    }

    struct stat sb_tgt;
    if (stat(argv[2], &amp;sb_tgt) != 0)
    {
        fprintf(stderr, ""%s: failed to stat file %s\n"", argv[0], argv[2]);
        return 1;
    }

    struct utimbuf ut = { .actime = sb_tgt.st_atime, .modtime = sb_ref.st_mtime };
    if (utime(argv[2], &amp;ut) != 0)
    {
        fprintf(stderr, ""%s: failed to set modification time on %s\n"", argv[0], argv[2]);
        return 1;
    }

    return 0;
}
</code></pre>

<p>How to demonstrate that it works?  That's fiddlier than writing the code.
You'll probably need to use <code>ls -l</code> to see the modification times, and <code>ls -lu</code> to see the access times, possibly with <code>-T</code> to show the full time (in a most peculiar format on a Mac).  Alternatively, you could use the <code>stat</code> command ¡ª but they're not readily controlled (and the GNU and BSD/macOS versions are quite different).  I chose to also use a command I wrote called <code>fl</code> (file list) which allows me to control the information I see.</p>

<p>I used this script:</p>

<pre><code>files=""mt47.c get.jl.activity""
touch mt47.c
make mt47

echo;echo;echo
fl -F '%Y-%m-%d %H:%M:%S ' -am $files
ls -lT  $files
ls -luT $files
/usr/bin/stat $files
/opt/gnu/bin/stat $files

mt47 get.jl.activity mt47.c

echo;echo;echo
fl -F '%Y-%m-%d %H:%M:%S ' -am $files
ls -lT  $files
ls -luT $files
/usr/bin/stat $files
/opt/gnu/bin/stat $files
</code></pre>

<p>The result I got was:</p>

<pre><code>gcc -O3   -g      -I./inc    -std=c11    -Wall -Wextra -Werror -Wmissing-prototypes -Wstrict-prototypes          -L./lib   mt47.c  -lsoq  -o mt47



2018-04-07 14:32:51  2018-04-07 14:32:51  mt47.c
2017-08-27 08:39:55  2017-03-03 17:06:27  get.jl.activity
-rw-r--r--  1 jleffler  staff  173 Mar  3 17:06:27 2017 get.jl.activity
-rw-r--r--  1 jleffler  staff  825 Apr  7 14:32:51 2018 mt47.c
-rw-r--r--  1 jleffler  staff  173 Aug 27 08:39:55 2017 get.jl.activity
-rw-r--r--  1 jleffler  staff  825 Apr  7 14:32:51 2018 mt47.c
16777220 8614148509 -rw-r--r-- 1 jleffler staff 0 825 ""Apr  7 14:32:51 2018"" ""Apr  7 14:32:51 2018"" ""Apr  7 14:32:51 2018"" ""Mar  3 17:06:27 2017"" 4194304 8 0 mt47.c
16777220 9176002 -rw-r--r-- 1 jleffler staff 0 173 ""Aug 27 08:39:55 2017"" ""Mar  3 17:06:27 2017"" ""Jul 22 10:26:30 2017"" ""Mar  3 17:06:27 2017"" 4194304 8 0 get.jl.activity
  File: mt47.c
  Size: 825         Blocks: 8          IO Block: 4194304 regular file
Device: 1000004h/16777220d  Inode: 8614148509  Links: 1
Access: (0644/-rw-r--r--)  Uid: (  501/jleffler)   Gid: (   20/   staff)
Access: 2018-04-07 14:32:51.478822831 -0700
Modify: 2018-04-07 14:32:51.301222000 -0700
Change: 2018-04-07 14:32:51.301240604 -0700
 Birth: 2017-03-03 17:06:27.000000000 -0800
  File: get.jl.activity
  Size: 173         Blocks: 8          IO Block: 4194304 regular file
Device: 1000004h/16777220d  Inode: 9176002     Links: 1
Access: (0644/-rw-r--r--)  Uid: (  501/jleffler)   Gid: (   20/   staff)
Access: 2017-08-27 08:39:55.000000000 -0700
Modify: 2017-03-03 17:06:27.000000000 -0800
Change: 2017-07-22 10:26:30.000000000 -0700
 Birth: 2017-03-03 17:06:27.000000000 -0800



2018-04-07 14:32:51  2017-03-03 17:06:27  mt47.c
2017-08-27 08:39:55  2017-03-03 17:06:27  get.jl.activity
-rw-r--r--  1 jleffler  staff  173 Mar  3 17:06:27 2017 get.jl.activity
-rw-r--r--  1 jleffler  staff  825 Mar  3 17:06:27 2017 mt47.c
-rw-r--r--  1 jleffler  staff  173 Aug 27 08:39:55 2017 get.jl.activity
-rw-r--r--  1 jleffler  staff  825 Apr  7 14:32:51 2018 mt47.c
16777220 8614148509 -rw-r--r-- 1 jleffler staff 0 825 ""Apr  7 14:32:51 2018"" ""Mar  3 17:06:27 2017"" ""Apr  7 14:32:51 2018"" ""Mar  3 17:06:27 2017"" 4194304 8 0 mt47.c
16777220 9176002 -rw-r--r-- 1 jleffler staff 0 173 ""Aug 27 08:39:55 2017"" ""Mar  3 17:06:27 2017"" ""Jul 22 10:26:30 2017"" ""Mar  3 17:06:27 2017"" 4194304 8 0 get.jl.activity
  File: mt47.c
  Size: 825         Blocks: 8          IO Block: 4194304 regular file
Device: 1000004h/16777220d  Inode: 8614148509  Links: 1
Access: (0644/-rw-r--r--)  Uid: (  501/jleffler)   Gid: (   20/   staff)
Access: 2018-04-07 14:32:51.000000000 -0700
Modify: 2017-03-03 17:06:27.000000000 -0800
Change: 2018-04-07 14:32:51.514236142 -0700
 Birth: 2017-03-03 17:06:27.000000000 -0800
  File: get.jl.activity
  Size: 173         Blocks: 8          IO Block: 4194304 regular file
Device: 1000004h/16777220d  Inode: 9176002     Links: 1
Access: (0644/-rw-r--r--)  Uid: (  501/jleffler)   Gid: (   20/   staff)
Access: 2017-08-27 08:39:55.000000000 -0700
Modify: 2017-03-03 17:06:27.000000000 -0800
Change: 2017-07-22 10:26:30.000000000 -0700
 Birth: 2017-03-03 17:06:27.000000000 -0800
</code></pre>

<p>It demonstrates to my satisfaction that the code in <code>mt47.c</code> (which is shown above) does what I intend it to do.  It also shows me why I wrote <code>fl</code>.</p>
",0
48636902,48636834,3,"<p>What exactly are you asking?<br>
<code>fork()</code> duplicates the calling process, returning the child process' PID in the parent, and 0 in the child.</p>

<p>In C, <code>if</code> evaluates any non-zero value to true, meaning <code>entering IF</code> will be printed from the parent thread, and <code>entering ELSE</code> from the child thread.</p>

<p>It should be noted that order in which they are printed is nondeterministic, so you may see <code>entering ELSE</code> before <code>entering IF</code>.</p>

<p>See: <a href=""http://man7.org/linux/man-pages/man2/fork.2.html"" rel=""nofollow noreferrer"">man(2) fork</a></p>
",3
51451371,51450569,2,"<p>To represent binary bit patterns in C, it is normal to use hexadecimal notation.  The utility of hex is that a single hex digit exactly coincides with 4 binary digits, so with experience you can quickly convert between the 16 hex digits and the corresponding binary value in your head, and for longer integers it is simply a matter of converting each digit in turn - 4 bits at a time.  Representing long integers in binary quickly becomes impractical.</p>

<p>So your table might be represented as:</p>

<pre><code>uint8_t row[] = { 0xd3, // 11010011
                  0x53, // 01010011
                  0x80  // 10000000
                } ;
</code></pre>

<p>Then you set/clear bits in the following manner:</p>

<pre><code>row[2] |= mask ;  // Set mask bits
row[0] &amp;= mask ;  // Clear mask bits
</code></pre>

<p>To create a mask specifying numbered bits without hard-coding the hex value you can use an expression such as:</p>

<pre><code>uint8_t mask = 1&lt;&lt;7 | 1&lt;&lt;5 | 1&lt;&lt;0 ;  // 10100001 mask bits 0, 5 &amp; 7
</code></pre>

<p>Occasionally a ""visual"" binary representation is desirable - for character bitmaps for example, the character A is much easier to visualise when represented in binary:</p>

<pre><code>00000000  
00011000  
00100100  
01000010  
01111110  
01000010  
01000010  
00000000  
</code></pre>

<p>It is possible to efficiently code such a table while maintaining the ""visualisation"" by exhaustively defining a macro for each binary value; e.g:</p>

<pre><code>#define B_00000000 0x00 
#define B_00000001 0x01 
#define B_00000010 0x02 
#define B_00000011 0x03 
#define B_00000100 0x04 
...
#define B_11111110 0xfe 
#define B_11111111 0xff
</code></pre>

<p>Note to create the above macros, it is best perhaps to write a code generator - i.e. a program to generate the code, and put the macros in a header file.</p>

<p>Given such macros you can then represent your table as:</p>

<pre><code>uint8_t row[] = { B_11010011
                  B_01010011
                  B_10000000
                } ;
</code></pre>

<p>or the character bitmap for A thus:</p>

<pre><code>uint8_t charA[] = { B_00000000,  
                    B_00011000,  
                    B_00100100,  
                    B_01000010,  
                    B_01111110,  
                    B_01000010,  
                    B_01000010,  
                    B_00000000 } ;
</code></pre>

<p>In the case that the bits are received at run-time serially, then the corresponding <code>uint8_t</code> can be built using sequential mask and shift:</p>

<pre><code>uint8_t getByte()
{
    uint8_t mask = 0x80 ;
    uint8_y byte = 0 ;

    while( mask != 0 )
    {
        uint8_t bit = getBit() ;
        byte |= bit ? mask : 0 ;
        mask &gt;&gt;= 1 ;
    }

    return byte ;
}
</code></pre>

<p>What the <code>getBit()</code> function does is for you to define; it may read a file, or a string, or keyboard entry for example, but it must return either zero or non-zero or the binary digits <code>0</code> and <code>1</code> respectively.  If the data is received LSB first then the mask starts from 0x01, and a <code>&lt;&lt;</code> shift used instead.</p>
",1
51450956,51450569,0,"<p>C doesn't have a syntax for entering binary literals, so you should type them as octal or hex, e.g.</p>

<pre><code>uint8_t row1 = 0xd3;
uint8_t row2 = 0x53;
uint8_t row3 = 0x80;
</code></pre>

<p>See <a href=""https://stackoverflow.com/questions/47981/how-do-you-set-clear-and-toggle-a-single-bit/47990#47990"">How do you set, clear, and toggle a single bit?</a> for how you can manipulate specific bits.</p>

<pre><code>row3 |= mask;
</code></pre>

<p>will set the bits that are set in <code>mask</code>.</p>
",2
52527092,52524495,1,"<p>There is no magic way to do this. YOu have to do the heavy lifting yourself</p>

<p>if you can reorg the file so its like Lavigne958 suggests</p>

<p>Then you need to do</p>

<pre><code>int val[10];
while(!feof(fptr))
{
  fscanf(ftpr, ""r%d=%d\n"", &amp;n, &amp;var);
  val[n] = var;
}
</code></pre>

<p>if they must be called r1, r2, r3, ... then do</p>

<pre><code>int *val[10];
val[1] = &amp;r1; // yes I know I missed out [0]
val[2] = &amp;r2;
...

while(!feof(fptr))
{
  fscanf(ftpr, ""r%d=%d\n"", &amp;n, &amp;var);
  *(val[n]) = var;
}
</code></pre>
",0
54954192,54954155,1,"<p>Briefly, you're asking <code>scanf</code> to scan strings into memory space that you've only allocated big enough for a few integers. Observe that your malloc call is given a number of ints to allocate and then you're assigning that to a <code>char *</code>. Those two things don't mix, and what's happening is you're scanning a bunch of bytes into your buffer that is too small, running off the end, and stomping on something else, then crashing. The compiler is letting you get away with this because both <code>malloc</code> and <code>scanf</code> are designed to work with various types (<code>void*</code>), so the compiler doesn't know to enforce the type consistency in this case. </p>

<p>If your goal is to save the word tokens from the input string into an array of words, you can do that but you need to allocate something quite different up front and manage it a bit differently.</p>

<p>But if your goal is simply to produce the output you want, there are actually simpler ways of doing it, like with using <code>strtok</code> or just looping through the input char by char and tracking where you hit spaces, etc.</p>
",1
49697460,49697227,0,"<p>To modify an object in the caller's scope you must pass a pointer to the object - so you need one more level of indirection.  There is also at least one semantic error in the implementation - assigning '\0' to the pointer returned by <code>malloc()</code>, will both invalidate the pointer and cause a memory leak.</p>

<p>Change <code>split()</code> prototype to:</p>

<pre><code>int split( char* s, char*** arr ) ;
</code></pre>

<p>Then call it thus:</p>

<pre><code>arrsz = split( str, &amp;arr ) ; 
</code></pre>

<p>And change the implementation:</p>

<pre><code>int split( char* str, char*** arr ) 
{
  int arrsz = 0 ;
  char delim[2] = "":"" ;
  char* tok ;

  *arr = malloc(sizeof(char**));
  *arr[0] = malloc(1);
  **arr[0] = '\0';         // &lt;&lt;&lt; This is fixed too

  tok = strtok( str, delim ) ;
  while( tok != NULL ) 
  {
    arrsz++;
    *arr = (char **)realloc(*arr,(arrsz*sizeof(char *))+1);
    *arr[arrsz-1] = malloc((sizeof(char)*strlen(tok))+1);
    strcpy(*arr[arrsz-1],tok);
    *arr[arrsz]=malloc(1);
    *arr[arrsz]='\0';

    tok = strtok(NULL,delim);
  }

  return(arrsz);
}
</code></pre>

<p>There may be other errors I have not spotted, but that is fundamental.  Best from hereon debugged using a debugger rather then Q&amp;A.</p>
",3
56964635,56964088,2,"<p>C doesn't support anything equivalent. If you have a tool chain that supports custom build events, you could introduce a pre-build step calling e. g. a python script (or any other language you prefer). This script then would:</p>

<ul>
<li>load the header file</li>
<li>iterate over all lines until it finds the structure in question</li>
<li>check for all known members in desired order (i. e. no members replaced)</li>
<li>finally check, if end of structure is reached (i. e. no new members added)</li>
</ul>

<p>If your tool chain stops, if the pre-build task fails, you are out already (just return 0 on success and anything else on failure), otherwise you could create a simple C-File, empty on success and containing an <code>#error</code> directive on failure.</p>

<p>Within your C code, you could additionally assure that the size of your struct matches:</p>

<pre><code>#define CONCATENATE(X, Y) CONCATENATE_(X, Y)
#define CONCATENATE_(X, Y) X##Y

#define STATIC_ASSERT(CONDITION) \
    typedef int(CONCATENATE(_static_assert_, __LINE__))[(CONDITION)? 1 : -1]

STATIC_ASSERT(sizeof(struct errors) == sizeof(unsigned char));
</code></pre>

<p>The macro is defined to be re-usable, as is, though, might produce additional warnings if used within function body (because of unused local type).</p>
",4
49017794,49017408,5,"<p>Header files are a necessity of C and C++ when you need to reference code or data structures across different files, something especially important when external programs that need to link against a library and the compiler has to understand how to use it.</p>

<p>It's advantageous to break up your application into a series of <code>.c</code> or <code>.cpp</code> files in order to make the compilation process more efficient. Most compiler environments, where they're <code>Makefile</code> driven or IDE managed, have methods for detecting which files need to be recompiled when a change is made.</p>

<p>In larger applications building all files can take considerable time, but recompiling a single <code>.cpp</code> file is often fairly quick. So long as you change only the <code>.cpp</code> source and don't touch the headers you can do a quick recompile and relink, ready for testing right away.</p>

<p>If instead you put everything into a header file then you'd need to recompile everything, every time, which can be a painfully slow process.</p>

<p>Keep in mind some code bases can take <em>hours</em> to rebuild, so this is not a sustainable practice.</p>
",2
49017528,49017408,1,"<p>Header files are different from source files by convention. Using the <code>.h</code> or <code>.hpp</code> extension communicates that the file is intended to be <code>#included</code> and is not meant to exist as a standalone source file. You can generally assume that <code>.h</code>/<code>.hpp</code> files are safe to include from multiple source files.</p>

<p>Meanwhile, <code>.c</code> and <code>.cpp</code> extensions communicate that the file likely is intended to be a translation unit and is not suitable to be <code>#included</code> in other translation units.</p>

<p>You could very well write an entire codebase with every file having any arbitrary extension, or none at all, if you really want to make it hard on yourself and anybody else working in the codebase.</p>
",2
49017691,49017408,2,"<p>I thought of a strange analogy.</p>

<p>You go to a restaurant.<br>
The waiter presents you with a menu. The menu is your interface to the kitchen.<br>
You pick the dish(es) you want to order.  </p>

<p>Then,</p>

<p>Option 1:</p>

<p>The waiter asks you to move to the kitchen and see for yourself how the dishes are prepared. You remain in the kitchen until the food is served to you.</p>

<p>Option 2:</p>

<p>The waiter brings the food to your table after it is prepared in a kitchen that you don't necessarily see.</p>

<p>Which one would you prefer?</p>

<p>Putting the implementation in the .h file is analogous to Option 1. </p>

<p>Putting the implementation in a .c/.cpp file somewhere else is analogous to Option 2.</p>
",0
50592842,50591174,11,"<p>For proper benchmarking, it's important to run the functions in random order and many times.</p>

<pre><code>typedef int(signature)(int, int);

...

int main() {
    int loops, iterations, runs;

    fprintf(stderr, ""Loops: "");
    scanf(""%d"", &amp;loops);
    fprintf(stderr, ""Iterations: "");
    scanf(""%d"", &amp;iterations);
    fprintf(stderr, ""Runs: "");
    scanf(""%d"", &amp;runs);

    fprintf(stderr, ""Running for %d loops and %d iterations %d times.\n"", loops, iterations, runs);

    signature *functions[2] = {
        forloop_inf,
        forloop_diff
    };

    int result = functions[0](loops, iterations);
    for( int i = 0; i &lt; runs; i++ ) {
        int pick = rand() % 2;
        signature *function = functions[pick];

        int new_result;
        printf(""%d %f\n"", pick, monitor_int(loops, iterations, function, &amp;new_result));
        if( result != new_result ) {
            fprintf(stderr, ""got %d expected %d\n"", new_result, result);
        }
    }
}
</code></pre>

<p>Armed with this we can do 1000 runs in random order and find the average times.</p>

<p>It's also important to benchmark with optimizations turned on. Not much point in asking how fast unoptimized code will run. I'll try at <code>-O2</code> and <code>-O3</code>.</p>

<p>My findings are that with <code>Apple LLVM version 8.0.0 (clang-800.0.42.1)</code> doing 10000 loops and 1000000 iterations at <code>-O2</code> <code>forloop_inf</code> is indeed about 50% faster than <code>forloop_diff</code>.</p>

<pre><code>forloop_inf: 0.000009
forloop_diff: 0.000014
</code></pre>

<p>Looking at <a href=""https://gist.github.com/schwern/ae5bbae9637d3af4fc922671b1de3134"" rel=""noreferrer"">the generated assembly code for -O2</a> with <code>clang -O2 -S -mllvm --x86-asm-syntax=intel test.c</code> I can see <a href=""https://gist.github.com/schwern/65f940eb731b2ce75543cbeb4b6af318"" rel=""noreferrer"">many differences between the two implementations</a>. Maybe somebody who knows assembly can tell us why.</p>

<p>But at <code>-O3</code> the performance difference is no longer discernible.</p>

<pre><code>forloop_inf: 0.000002
forloop_diff: 0.000002
</code></pre>

<p>This is because <a href=""https://gist.github.com/schwern/1cf28882ccdf3599e816bd767b56cb0b"" rel=""noreferrer"">at <code>-O3</code> they are almost exactly the same</a>. One is using <a href=""https://www.aldeid.com/wiki/X86-assembly/Instructions/je"" rel=""noreferrer""><code>je</code></a> and one is using <a href=""https://www.aldeid.com/wiki/X86-assembly/Instructions/jle"" rel=""noreferrer""><code>jle</code></a>. That's it.</p>

<hr>

<p>In conclusion, when benchmarking...</p>

<ul>
<li>Do many runs.</li>
<li>Randomize the order.</li>
<li>Compile and run as close as you can do how you would in production.

<ul>
<li>In this case that means turning on compiler optimizations.</li>
</ul></li>
<li>Look at the assembly code.</li>
</ul>

<p>And most of all.</p>

<ul>
<li>Pick the safest code, not the fastest.</li>
</ul>

<p><code>i &lt; max</code> is safer than <code>i != max</code> because it will still terminate if <code>i</code> somehow jumps over <code>max</code>.</p>

<p>As demonstrated, with optimizations turned on, they're both so fast that even not fully optimized they can whip through 10,000,000,000 iterations in 0.000009 seconds. <code>i &lt; max</code> or <code>i != max</code> is unlikely to be a performance bottleneck, rather whatever you're doing 10 billion times is.</p>

<p>But <code>i != max</code> could lead to a bug.</p>
",4
51607352,51606505,7,"<p>The line of code containing the ternary operator is intricate and intriguing.  It also has subtle but crucial asymmetries in the way it is interpreted that are far from obvious when it is written as shown in the question.  Let's consider a minor variant of the original code as follows, which exercises both the 'true' and 'false' parts of the ternary operator (in two separate statements ¡ª though I could have made a function and passed arguments to that instead):</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int a = 5, b = 4, c;
    c = a &gt; b ? 1, 2, 3 : 2, 5, 6;
    printf(""a = %d, b = %d, c = %d\n"", a, b, c);
    a = b - 1;
    c = a &gt; b ? 1, 2, 3 : 2, 5, 6;
    printf(""a = %d, b = %d, c = %d\n"", a, b, c);
    return 0;
}
</code></pre>

<p>The output from this program is:</p>

<pre><code>a = 5, b = 4, c = 3
a = 3, b = 4, c = 2
</code></pre>

<p>What's going on here?</p>

<p>Remember, the comma operator has even lower precedence than the assignment operator, so that you can, if you wish, write code such as:</p>

<pre><code>if (a &gt; b)
    c = 2, d = 3, e = 6;
</code></pre>

<p>and there are three assignments in the body of the <code>if</code> statement.  That would not be regarded as good code for general use, but the technique can be useful in a macro ¡ª very occasionally it can be useful in a macro.</p>

<p>Let's add some parentheses ¡ª the correct set of parentheses as the compiler interprets the code:</p>

<pre><code> c =  a &gt; b  ?  1, 2, 3  : 2 , 5, 6;
(c = (a &gt; b) ? (1, 2, 3) : 2), 5, 6;
</code></pre>

<p>The condition <code>a &gt; b</code> controls whether <code>1, 2, 3</code> or <code>2</code> is evaluated, and the result is assigned to <code>c</code>.  The result of <code>1, 2, 3</code> is <code>3</code>, so if <code>a &gt; b</code>, the value assigned is <code>3</code> (as in the question), and if <code>a &lt;= b</code>, the value assigned is <code>2</code>.  The <code>5</code> and the <code>6</code> are evaluated for side-effects ¡ª but there are no side-effects so they are effectively discarded.</p>

<p>The <code>:</code> of the ternary operator has a grouping effect on the code between the <code>?</code> and the <code>:</code> which does not occur after the <code>:</code>.</p>

<p>Note that to get this code to compile, I had to discard my default compiler options.  With the code in the question and my normal, default compiler options, I get (source code in <code>top67.c</code>):</p>

<pre><code>$ gcc -O3 -g -std=c11 -Wall -Wextra -Werror -Wmissing-prototypes -Wstrict-prototypes \
&gt;     top67.c -o top67 
top67.c:3:5: error: function declaration isn¡¯t a prototype [-Werror=strict-prototypes]
 int main()
     ^~~~
top67.c: In function ¡®main¡¯:
top67.c:6:18: error: left-hand operand of comma expression has no effect [-Werror=unused-value]
     c = a &gt; b ? 1, 2, 3 : 2, 5, 6;
                  ^
top67.c:6:21: error: left-hand operand of comma expression has no effect [-Werror=unused-value]
     c = a &gt; b ? 1, 2, 3 : 2, 5, 6;
                     ^
top67.c:6:28: error: right-hand operand of comma expression has no effect [-Werror=unused-value]
     c = a &gt; b ? 1, 2, 3 : 2, 5, 6;
                            ^
top67.c:6:31: error: right-hand operand of comma expression has no effect [-Werror=unused-value]
     c = a &gt; b ? 1, 2, 3 : 2, 5, 6;
                               ^
cc1: all warnings being treated as errors
$
</code></pre>

<p>I'd get more errors from the code shown in this answer.  You should be compiling with similar options to avoid problems in your own code.</p>
",0
52159846,52159776,2,"<p>It looks like you're looking for a <em>compound literal</em> (defined in C11 <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.5.2.5"" rel=""nofollow noreferrer"">¡ì6.5.2.5 Compound literals</a>; also a feature in C99):</p>

<pre><code>func((int[]){ 1, 2, 33, 491 });
</code></pre>

<p>A compound literal looks like a cast followed by a braced initializer for the type specified in the cast.  The scope of the compound literal is to the end of the statement block in which it is introduced, so it will be valid for the entire block in which the call to <code>func()</code> is found. Consequently, it is valid for the whole of the call to <code>func()</code>. And the compound literal is a modifiable value.</p>

<p>We can validly quibble about the interface to the function not specifying how many values are in the array (so how does <code>func()</code> know how big the array is), but that is somewhat tangential to the idea of the compound literal notation.</p>

<p>The function itself is a perfectly ordinary function taking an array argument:</p>

<pre><code>extern void func(int arr[]);

void func(int arr[])
{
    ¡­
}
</code></pre>

<p>Or, of course:</p>

<pre><code>extern void func(int *arr);

void func(int *arr)
{
    ¡­
}
</code></pre>

<p>And (with the major caveat about how the function knows how big the array is), you could write:</p>

<pre><code>void calling_func(void)
{
    func((int[]){ 1, 2, 33, 491 });
    int array[] = { 2, 99, 462, -9, -31 };
    func(array);
}
</code></pre>
",2
54369885,54369477,2,"<p>Code is attempting exact integer like math with values like 0.01 that cannot be exactly represented with typical <a href=""https://en.wikipedia.org/wiki/Double-precision_floating-point_format"" rel=""nofollow noreferrer""><code>double</code></a>. This often leads to unexpected results.</p>

<p>Change to integers of smallest unit.  (Scale by 100)</p>

<p>Avoid repeated calculations by reducing <code>cent</code> at each step rather than recalculate from the beginning.</p>

<pre><code>#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

int main(void) {
    double input;
    scanf(""%lf"",&amp;input);
    long long cent = llround(input * 100);  // scale by 100 and round

    long long note_100 = cent/10000;  // divide by scaled amount (100*100)
    cent %= 10000;
    int note_50 = cent/5000;
    cent %= 5000;
    int note_20 = cent/2000;
    cent %= 2000;
    ...
    printf(""NOTAS:\n"");
    printf(""%lld nota(s) de R$ 100.00\n"", note_100);
    printf(""%d nota(s) de R$ 50.00\n"", note_50);
    printf(""%d nota(s) de R$ 20.00\n"", note_20);
    ...
    return 0;
}
</code></pre>
",0
55371985,55371619,0,"<p>You cannot declare a type inside a function parameter list. This is what happens when in File_utils.h you have a declaration of  <code>is_relative_path</code> with no prior declaration of <code>stuct dirent</code>.</p>

<p>Either <code>#include &lt;dirent.h&gt;</code> in File_utils.h (recommended), or add a declaration</p>

<pre><code>struct dirent;
</code></pre>

<p>somewhere in it above <code>is_relative_path</code>.</p>
",0
50468697,50468583,0,"<p><code>""C#""</code> etc are not single characters but whole strings (null-terminated). You can't have an array of characters and an array of strings at the same time, mixed with each other.  </p>

<p>Probably you want something like an array of strings <code>const char* keyboard[]  = {""C"", ""C#"", ...</code>.</p>

<p>If you wish to compare them with other variables, then use <code>strcmp(keyboard[i], other)</code>.</p>
",0
50207317,50207205,6,"<ol>
<li><p>This code would not execute the child processes <em>in parallel</em> but execute each one sequentially. The difference does not show <em>until</em> the child processes do something beyond printing one message and exiting (you could add <code>sleep(1)</code>).</p></li>
<li><p><code>wait</code> function will wait for the termination of <em>one</em> child process (whichever finishes first). If you've got 3 child processes, you must call <code>wait</code> successfully at least that 3 times to ensure that each one of them has terminated. Perhaps easier would be to call <code>wait</code> until it sets <code>errno</code> to <code>ECHILD</code>, meaning that there are no children left:</p>

<pre><code>while (1) {
    errno = 0;
    if (wait(NULL) == -1) {
        if (errno != ECHILD) {
            perror(""Unexpected error from wait"");
        }
        break;
    }       
}
</code></pre></li>
<li><p>Each parent process should wait for its <strong>own children</strong> (<a href=""https://stackoverflow.com/questions/40601337/what-is-the-use-of-ignoring-sigchld-signal-with-sigaction2"">or set the <code>SIGCHLD</code> disposition to <code>SIG_IGN</code></a>). Instead of counting the number of <code>wait</code>s, use the code above</p></li>
<li><p>This means just: ""call a function by the name <code>CPU</code>"", i.e.</p>

<pre><code>void CPU(void) {
}
</code></pre>

<p>in the child process.</p></li>
</ol>

<hr>

<p>BTW, your code is missing the necessary headers for a couple functions - </p>

<pre><code>#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
</code></pre>

<p>for <code>wait</code>,</p>

<pre><code>#include &lt;unistd.h&gt;
</code></pre>

<p>for <code>fork</code> and additionally <code>#include &lt;errno.h&gt;</code> for my <code>errno</code> addition.</p>
",0
49640075,49639732,3,"<p>Read the warnings: <code>implicit declaration of function ¡®getListOfFiles¡¯</code>.</p>

<p>You are using getListOfFiles() not seen it before and so assumes that it returns an int. You can solve by either declaring the function before defining it.  <code>char** getListOfFiles(char *path)</code> near the top of your file or for this simple case just move the whole definition before <code>main()</code></p>
",0
49640075,49639732,3,"<p>Read the warnings: <code>implicit declaration of function ¡®getListOfFiles¡¯</code>.</p>

<p>You are using getListOfFiles() not seen it before and so assumes that it returns an int. You can solve by either declaring the function before defining it.  <code>char** getListOfFiles(char *path)</code> near the top of your file or for this simple case just move the whole definition before <code>main()</code></p>
",0
58104127,58102796,1,"<p>You have asked about whether 10! is too big, but had you observed <code>i</code> at the point the value overflows, you will see that <code>i == 12</code>.  The expression for <code>temp</code> then is then:</p>

<p>3<sup>25</sup> / 25 x 12!</p>

<p>The sub expression 25 x 12!  has value 11975040000 which would require 34 bits if it is an integer expression which it will be if <code>fact()</code> is an integer function.  If it is a 32 bit integer function, it will overflow.</p>

<p>If <code>fact()</code> is changed to a an unsigned 64 bit type, it gets further, but that is only good for 19! and the divisor sub-expression overflows at <code>i=18</code> (29 x 18!) before converging. </p>

<p>It will converge for <code>i = 3</code> using the following factorial function implementation:</p>

<pre><code>double fact(int n)
{
    if (n &gt;= 1)
        return n * fact(n - 1);
    else
        return 1;
}
</code></pre>

<p>With result 0.886207.  For arbitrarily large values of x you will need an arbitrary precision or ""bignum"" math library rather then built-in types.</p>

<p>Inspired by Lee Crocker's comment I tried various expressions (tested at <a href=""https://onlinegdb.com/ryBKEuFPH"" rel=""nofollow noreferrer"">GDB Online</a>)</p>

<p>1) Based on my <code>double fact( int )</code> and less your the extraneous parentheses ;</p>

<pre><code>double e = (2*i)+1 ;
temp = pow(x,e) / (e * fact(i));
</code></pre>

<p>Results for x = 1 to 9:</p>

<pre><code>x: 1.0  s(x): 0.746824                                                                                                                          
x: 2.0  s(x): 0.882081                                                                                                                          
x: 3.0  s(x): 0.886207                                                                                                                          
x: 4.0  s(x): 0.886227                                                                                                                          
x: 5.0  s(x): 0.886227                                                                                                                          
x: 6.0  s(x): 0.889677                                                                                                                          
x: 7.0  s(x): 2453.707036                                                                                                                       
x: 8.0  s(x): 1055556860.115990                                                                                                                 
x: 9.0  s(x): -nan 
</code></pre>

<p>2) Using <code>tgamma()</code> :</p>

<pre><code>temp = pow(x,e) / (e * tgamma(i+1)) ; 
</code></pre>

<p>Result:</p>

<pre><code>x: 1.0  s(x): 0.746824                                                                                                                          
x: 2.0  s(x): 0.882081                                                                                                                          
x: 3.0  s(x): 0.886207                                                                                                                          
x: 4.0  s(x): 0.886227                                                                                                                          
x: 5.0  s(x): 0.886226                                                                                                                          
x: 6.0  s(x): 0.882858                                                                                                                          
x: 7.0  s(x): -83.077451                                                                                                                        
x: 8.0  s(x): 3729162898.780624  
</code></pre>

<p>3) Using <code>lgamma()</code>:</p>

<pre><code>temp = pow(x,e) / exp(log(e) + lgamma(i+1)) ;
</code></pre>

<p>Result : </p>

<pre><code>x: 1.0  s(x): 0.746824                                                                                                                          
x: 2.0  s(x): 0.882081                                                                                                                          
x: 3.0  s(x): 0.886207                                                                                                                          
x: 4.0  s(x): 0.886227                                                                                                                          
x: 5.0  s(x): 0.886236                                                                                                                          
x: 6.0  s(x): 1.904565                                                                                                                          
x: 7.0  s(x): -322346.422518                                                                                                                    
x: 8.0  s(x): 5416428382.734000                                                                                                                 
x: 9.0  s(x): -nan       
</code></pre>

<p>The results differ for <code>x = 6.0</code>, but all versions break down at around there.  Which is better I am not clear - <code>fact()</code> I suspect.  The standard library functions offer no significant improvement is any.</p>

<p>4) Added Lee's expression to test (if I've understood his answer correctly) :</p>

<pre><code>temp = exp(e * log(x) - log(e) - lgamma(i+1)) ;
</code></pre>

<p>Result:</p>

<pre><code>x: 1.0  s(x): 0.746824
x: 2.0  s(x): 0.882081
x: 3.0  s(x): 0.886207
x: 4.0  s(x): 0.886227
x: 5.0  s(x): 0.886245
x: 6.0  s(x): 2.892730
x: 7.0  s(x): 96596.597282
x: 8.0  s(x): -720878097610.696167
x: 9.0  s(x): -18109761159507625984.000000
</code></pre>

<p>For reference, my test code:</p>

<pre><code>double s( double x )
{
    double sx = x ;
    double temp = 1.0 ;

    for( int i = 1; temp &gt; 1e-6; i++ ) 
    {
        double e = (2*i)+1 ;

        // Uncomment one of the following:
        //temp = pow(x,e) / (e * fact(i));
        //temp = pow(x,e) / (e * tgamma(i+1)) ; 
        //temp = pow(x,e) / exp(log(e) + lgamma(i+1)) ;
        //temp = exp(e * log(x) - log(e) - lgamma(i+1)) ;

        sx += (i % 2) == 0 ? temp : -temp ;  
    }

    return sx ;
}

int main()
{
    for( double x = 1.0; x &lt; 10.0; x += 1.0 )
    {
        printf( ""x: %.1f  s(x): %lf\n"", x, s(x) ) ;
    }

    return 0;
}
</code></pre>
",2
58107346,58102796,0,"<p>Exponentials and factorials grow very quickly, and often overflow integer types and cause precision issues even with floating point types. Mathematicians often do calculations like these in logarithmic space. The C math library has the function lgamma(), for example, that calculates the natural logarithm of the gamma function (gamma(x) = fact(x-1)), to a precision that might be lost if you had to represent the whole factorial first and then take the log of it.</p>

<p>So, assuming <code>double x</code> and <code>int n</code>, you can rewrite <code>pow(x,n) / (n * fact(n / 2))</code> as <code>exp(n * log(x) - log(n) - lgamma(1 + n / 2))</code>, and get reasonable results for large <code>n</code>.</p>

<p>Here's my code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

void series(double base) {
    double x = base;
    double sx = x, temp;
    int i = 1;

    do {
        int e = 2 * i + 1;

        temp = exp(e * log(x) - log(e) - lgamma(i+1));
        if (1 == i%2) sx -= temp;                        
        else sx += temp;

        printf(""%d %lf %lf\n"", i, temp, sx); 
        i += 1;
    } while (temp &gt; 1E-6);
}

int main(void) {
    series(3.0);
}
</code></pre>

<p>and the output:</p>

<pre><code>1 9.000000 -6.000000
2 24.300000 18.300000
3 52.071429 -33.771429
4 91.125000 57.353571
5 134.202273 -76.848701
6 170.333654 93.484953
7 189.800357 -96.315405
8 188.404766 92.089362
9 168.572686 -76.483324
10 137.266330 60.783006
11 102.542831 -41.759826
12 70.754554 28.994728
13 45.355483 -16.360755
14 27.146262 10.785507
15 15.236934 -4.451427
16 8.051335 3.599907
17 4.018901 -0.418994
18 1.900832 1.481838
19 0.854220 0.627618
20 0.365648 0.993266
21 0.149418 0.843848
22 0.058409 0.902257
23 0.021883 0.880374
24 0.007871 0.888245
25 0.002723 0.885522
26 0.000907 0.886429
27 0.000291 0.886138
28 0.000090 0.886228
29 0.000027 0.886201
30 0.000008 0.886209
31 0.000002 0.886207
32 0.000001 0.886207
</code></pre>
",5
57914033,57913658,0,"<p>I think you would be better off 
(generally speaking anyway) using <code>fgets</code> for the user input. <code>scanf</code> is problematic by comparision. fgets reads input in this case from stdin  (the keyboard). Now it's simple to remove any newline character and test the length.</p>

<pre><code>char getTrump(){
  const int suitSize = 12;
  char suit[suitSize];
  bool correct = false;
  memset(suit, 0, suitSize);

  do
  {
    printf(""Please choose a trump suit (H, D, S, C): "");
    fgets(suit, suitSize-1, stdin);

    if (suit[strlen(suit)-1] == '\n')
        suit[strlen(suit)-1] = '\0';

    // check input length only one char
    if (strlen(suit) == 1 &amp;&amp; isValidSuit(*suit) == 1){
        printf(""Correct\n"");
        correct = true;
    }
    else{
        printf(""Please enter a valid suit.\n"");
    }
  } while (!correct);
  return *suit;
}
</code></pre>
",2
53212352,53212077,1,"<p>Finding the length of a string is no problem.  <code>strlen</code> will do that for you.  However, you don't even need that.</p>

<p>You can use the <code>strstr</code> function to find a substring within a string, in this case <code>""::""</code>.  When you find one, keep looking right after the last one you found until you don't find it anymore, then the last one you found is the one you want.  Then you want the substring that starts right after it.</p>

<pre><code>char *extract(char *input)
{
    char *last = NULL, *start = input, *curr;
    while ((curr == strstr(start, ""::"")) != NULL) {
        last = curr;       // keep track of the last ""::"" found
        start = last + 1;  // move the starting string to right after the last ""::""
                           // move up 1 instead of 2 in case of "":::""
    }
    if (last != NULL) {
        last +=2;     // We found one; move just past the ""::""
    }
    return last;
}
</code></pre>
",3
56852064,56849279,1,"<p>When a variable or function is declared at <em>file scope</em> (not inside any other <code>{ }</code> brace pair), and they are declared <code>static</code>, they are local to the <em>translation unit</em> they reside in.</p>

<p><em>Translation unit</em> is a formal term in C and it's slightly different from a file. A translation unit is a single c file and all the h files it includes.</p>

<p>So in your case, the <code>static</code> variable is local to the translation unit consisting of <code>test.h</code> and <code>main.c</code>. You will be able to access it in main.c, but not in foo.c.</p>

<p>Meaning that if you have another .c file including <code>test.h</code>, you'll get two instances of the same variable, with the same name. That in turn can lead to all manner of crazy bugs. </p>

<p>This is one of many reasons why we <strong><em>never</em></strong> define variables inside header files. </p>

<p>(To avoid spaghetti program design, we should not declare variables in headers either, unless they are <code>const</code> qualified.)</p>
",1
54739967,54739944,0,"<p>If I'm reading this right, you've written a comparator that pretends a <code>vector</code> is a <code>const char*</code>. It isn't. The subsequent C-string comparison is likely not to hit a would-be null terminator and is going to go out of bounds.</p>

<p>Instead, write a comparator that actually compares <code>vector</code> objects to whatever it is that you want to compare them to.</p>
",1
54740011,54739944,1,"<p>Your comparison function is expecting that each of its parameters is a <code>char **</code>.  However, you call <code>vector_find</code> with a <code>char *</code> being passed as the second parameter which is subsequently passed to <code>cmp</code>.  Attempting to use a <code>char *</code> as a <code>char **</code> invokes undefined behavior as you end up passing to <code>strcmp</code> is actually a <code>char</code>.</p>

<p>You don't show how you populate your <code>vector</code>, but I'm guessing the elements of <code>data</code> are of type <code>char *</code>.  That being the case, the comparison function should be expecting a <code>char *</code> instead of a <code>char **</code>.</p>

<pre><code>int cstring_cmp(const void *a, const void *b)
{
    const char *ia = a;
    const char *ib = b;
    printf(""%s    %s"", ia, ib);
    return strcmp(ia, ib);
}
</code></pre>
",1
55820578,55820522,5,"<p><code>sex</code> is a single <code>char</code> variable, but you are treating it as a pointer to a string.</p>

<ol>
<li>Change your <code>scanf</code> call to have <code>%c</code> (single character) in the format string, rather than <code>%s</code>.</li>
<li>Change your tests for the value of <code>sex</code> to use single quotes (i.e. <code>if (sex == 'M')</code>).</li>
</ol>

<p>Note that though this code <em>should not need</em> string comparison if the variable <code>sex</code> is treated like the single <code>char</code> it is, if you were to compare strings in a future project, you would not use the operators <code>==</code> and <code>!=</code> - instead, use the function <a href=""https://www.programiz.com/c-programming/library-function/string.h/strcmp"" rel=""noreferrer""><code>strcmp</code></a> in <code>&lt;string.h&gt;</code></p>
",1
52182497,52182340,0,"<p>Since you do not tell us what is <code>pointer2</code>, it's difficult to answer.</p>

<p>But, if you write:</p>

<pre><code>int *pointer2 = NULL;
size_t size = 10; 

if (size-1 &gt; 0)
{
    pointer2 = calloc(size-1, sizeof *pointer);
}
</code></pre>

<p>The <code>pointer2</code> will points to an portion of memory able to store <code>size-1</code> integer (<code>int</code>) values.</p>

<hr>

<ul>
<li><a href=""https://stackoverflow.com/q/605845/1212012"">In <strong>C</strong>, it is not necessary to cast <code>[m|c|re]alloc</code> results</a>   </li>
<li>Magic values, like the <code>2</code> in <code>calloc(..., 2);</code> are dangerous : if the type of <code>pointer2</code> changed, the allocation could become invalid, or if the type size change over some architectures, it can become problematic.</li>
</ul>
",0
53018130,53017522,-1,"<p>Couple obvious problems:</p>

<ul>
<li><code>initscr</code> being called multiple times in the loop; it only needs to be called once</li>
<li><code>string</code> is not NUL terminated, so you're probably seeing garbage after the end of it.</li>
<li><code>memove</code> calls also do the wrong thing with NUL terminator on the string even if it was there...</li>
</ul>
",1
53017966,53017522,-1,"<p>One pointer, you are using <code>initscr()</code> in the while loop.  This means you're re-initializing and discovering the terminal type each pass of the loop.  You should do this once.</p>

<p>Also, <code>initscr()</code> does an initial clear before any further processing, so the <code>clear()</code> after <code>initscr()</code> is not needed.</p>

<p>Perhaps your terminal output will improve if you avoid excessively re-initializing the system.</p>
",4
48858508,48858444,4,"<p>With regard to code like:</p>

<pre><code>case 1:
{
    double *a = malloc(100 * sizeof(double));
    &lt;&lt; some operation here &gt;&gt;
    break;
}
</code></pre>

<p>the <em>lifetime</em> of <code>a</code> is entirely within the block specified by the braces <code>{}</code>. That object does not exist following that block.</p>

<p>It would be more normal to free the variable within the same scope (i.e., immediately before the <code>break</code>):</p>

<pre><code>case 1: {
    double *a = malloc(100 * sizeof(double));
    &lt;&lt; some operation here &gt;&gt;
    free(a);
    break;
}
</code></pre>

<p>But, on the off-chance you wanted to use it after that point for something else, you could create the objects before the braces so that they're accessible later, something like:</p>

<pre><code>double *a = NULL, *b = NULL;

switch(CaseType){
    case 1: {
        a = malloc(100 * sizeof(double));
        &lt;&lt; some operation here &gt;&gt;
        break;
    }
    case 2: {
        b = malloc(200 * sizeof(double));
        &lt;&lt; some operation here &gt;&gt;
        break;
    }
}

// Do something with a and/or b, ensuring they're not NULL first.

free(a);  // freeing NULL is fine if you haven't allocated anything.
free(b);
</code></pre>

<hr>

<p>As an aside, you should <em>always</em> assume that calls subject to failure (like <code>malloc</code>) <em>will</em> fail at some point and code accordingly. I'll give you the benefit of the doubt that such code exists in the <code>&lt;&lt; some operation here &gt;&gt;</code> section :-)</p>
",1
49860445,49860374,1,"<p>Printing a pointer with <code>%d</code> is formally undefined behavior, meaning anything can happen, including a program crash. Your program will for example likely break when you compile it as a 64 bit application, where <code>int</code> is 32 bits but a pointer is likely 64 bits. Therefore, always use <code>%p</code> and never anything else when printing a pointer.</p>

<p>There is no implicit conversion taking place - the printf family of functions doesn't have that kind of intelligence - it doesn't know the type passed. With the format specifier, <em>you</em> tell the function which type it is getting. And if you lie to printf and say ""I'll give you an int"" and then give it a pointer, you unleash bugs. This makes the printf family of functions very dangerous in general.</p>

<p>(The only implicit conversion that take place in printf is when you pass small integer types or float, in which case the ""default argument promotions"" take place and promote the parameter either to <code>int</code> or <code>double</code>. This is not the case here, however.)</p>

<p>In this specific case, you happened to get the decimal representation of <code>0x0060FF08</code>, which is by no means guaranteed.</p>

<p>Pedantically, you should also cast the pointer to type <code>(void*)</code> since this is what <code>%p</code> expects.</p>
",8
56138294,56138232,0,"<p>You need the fopen() function which will open a pointer to your text file. See this <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm"" rel=""nofollow noreferrer"">tutorial on fopen()</a>. If you want to change the file names everytime you run the program, you can pass the filename as an argument to your program. See this <a href=""https://www.geeksforgeeks.org/command-line-arguments-in-c-cpp/"" rel=""nofollow noreferrer"">tutorial on using arguments in C++/C</a>. </p>
",1
54816963,54815428,0,"<blockquote>
  <p>How would I estimate this? Which timing function would you suggest to use?</p>
</blockquote>

<p>If you want to get the resolution (precision) of the various timing elements, you can use the <a href=""https://linux.die.net/man/3/clock_getres"" rel=""nofollow noreferrer""><code>clock_getres</code></a> function, passing in the various <code>CLOCK_</code> id types, for example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

static void printres(clockid_t id)
{
    struct timespec ts;
    int rc = clock_getres(id, &amp;ts);
    printf(""clock id: %d\n"", (unsigned int)id);
    if (rc != 0) {
        printf(""Error: %d\n"", rc);
        return;
    }
    printf(""tv_sec = %lu\ntv_nsec = %lu\n"", ts.tv_sec, ts.tv_nsec);
}

int main(int argc, char** argv)
{
    printres(CLOCK_REALTIME);
    printres(CLOCK_MONOTONIC);
    printres(CLOCK_PROCESS_CPUTIME_ID);
    printres(CLOCK_THREAD_CPUTIME_ID);
    return 0;
}
</code></pre>

<p>On my system, <code>tv_nsec</code> for all but <code>CLOCK_THREAD_CPUTIME_ID</code> is <code>1000</code>, for <code>CLOCK_THREAD_CPUTIME_ID</code> the value for <code>tv_nsec</code> is <code>1</code>, this means that the precision for the other clock types is 1 millisecond (1000 nanoseconds) while the precision of <code>CLOCK_THREAD_CPUTIME_ID</code> is 1 nanosecond.</p>

<p>For your first function that calls <a href=""https://linux.die.net/man/3/localtime"" rel=""nofollow noreferrer""><code>localtime</code></a> the precision for that would be 1 second as that function calculates the time from the Unix epoch in seconds.</p>

<blockquote>
  <p>What do the compiler options -O0 -lrt mean when I have to compile with gcc -O0 -lrt timing.c -o timing?</p>
</blockquote>

<p>For some compilers like <code>gcc</code> and <code>clang</code> the option <code>-O</code> means to optimize the code when compiling it to the level specified, so <code>-O0</code> means <em>not</em> to optimize the code at all, this is usually useful when debugging code.</p>

<p>The <code>-l</code> option says to compile against the specified library, so <code>-lrt</code> says to compile using the <code>rt</code> library, or ""real time library""; this is necessary on some systems as <code>CLOCK_REALTIME</code> can be defined in that library.</p>

<p>I hope that can help.</p>
",0
52503806,52503693,8,"<p>This is due to the spaces used in your scanf command.</p>

<p>If you replace that with</p>

<pre><code>scanf(""%i"", &amp;number);
</code></pre>

<p>you get an instant response.</p>
",1
52503852,52503693,7,"<p>With your <code>scanf</code> format <code>"" %i ""</code>, the <code>scanf</code> function will read (and skip) possible leading spaces because of your leading space in the format.</p>

<p>Then it will read the integer.</p>

<p>Then, due to the trailing space, it will read and discard space until it find a <em>non-space</em> input.</p>

<p>Since there's no non-space input afterward, then <code>scanf</code> will block until you give some non-space input.</p>

<p>Solve simply by not having any spaces in the format. Or by entering some extra dummy input (followed by <kbd>Enter</kbd>).</p>
",0
50010516,50007005,2,"<p><strong>TL/DR - C declaration syntax allows all three methods</strong>.</p>

<p>Have patience, this is going to take a while.</p>

<p>Let's start with the syntax for a declaration:</p>

<pre><code><em>declaration</em>:
    <em>declaration-specifiers init-declarator-list<sub>opt</sub></em> ;
    <em>static_assert-declaration</em>

<em>declaration-specifiers</em>:
    <em>storage-class-specifier declaration-specifiers<sub>opt</sub></em>
    <em>type-specifier          declaration-specifiers<sub>opt</sub></em>
    <em>type-qualifier          declaration-specifiers<sub>opt</sub></em>
    <em>function-specifier      declaration-specifiers<sub>opt</sub></em>
    <em>alignment-specifier     declaration-specifiers<sub>opt</sub></em>

<em>init-declarator-list</em>:
    <em>init-declarator</em>
    <em>init-declarator-list</em> , <em>init-declarator</em>

<em>init-declarator</em>:
    <em>declarator</em>
    <em>declarator</em> = <em>initializer</em>
</code></pre>

<p>The <code><em>opt</em></code> subscript means that the item is optional; IOW, a sequence of declaration specifiers <em>may</em> be followed by a sequence of declarators (or not), a type specifier <em>may</em> be followed by more declaration specifiers (or not), etc.</p>

<p>We also have the following <em>constraint</em>:</p>

<blockquote>A declaration other than a static_assert declaration shall declare at least a declarator
(other than the parameters of a function or the members of a structure or union), a tag, or
the members of an enumeration.</blockquote>

<p><sub><em><a href=""http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C 2011 Online Draft, 6.7</a></em></sub></p>

<p>Lovely.  What does all that mean?</p>

<p>Basically, a declaration in C has two main parts - a sequence of <em>declaration specifiers</em> (which may include storage class specifiers like <code>static</code> and <code>auto</code>, type specifiers like <code>int</code>, <code>double</code>, <code>char</code>, <code>struct foo</code>, type qualifiers like <code>const</code>, etc.) and an optional sequence of <em>declarators</em> (basically, variable or function names), each of which may be initialized.  For example, in the declaration</p>

<pre><code>static const int *foo[N] = { &amp;bar, &amp;blah, ... };
</code></pre>

<p>our <em>declaration specifiers</em> are <code>static const int</code>, our <em>declarator</em> is <code>*foo[N]</code>, and our <em>initializer</em> is <code>{ &amp;bar, &amp;blah, ... }</code>.  </p>

<p>What we're interested in for the purpose of your question is the <code><em>type-specifier</em></code>, and specifically a <code><em>struct-or-union-specifier</em></code>:</p>

<pre><code><em>type-specifier</em>:
    void
    char
    short
    int
    long
    float
    double
    signed
    unsigned
    _Bool
    _Complex
    <em>atomic-type-specifier</em>
    <em>struct-or-union-specifier</em>
    <em>enum-specifier</em>
    <em>typedef-name</em>

<em>struct-or-union-specifier</em>:
    <em>struct-or-union identifier<sub>opt</sub></em> { <em>struct-declaration-list</em> }
    <em>struct-or-union identifier</em>
</code></pre>

<p>The <code><em>struct-or-union-specifier</em></code> has two forms - one where you specify the contents of the struct, and one where you do not. </p>

<p>The <code><em>identifier</em></code> is the <em>tag name</em> of the structure or union; it's how you can refer to that specific type later on (either as part of another declaration, or part of a <code>sizeof</code> expression, etc).  </p>

<p>Note that in the first case, where you're specifying the members of the structure type, the tag name is optional - it's perfectly legal to write a declaration like <pre><code>struct { int a; int b; } x;
|                      | |
+---------+------------+ |
          |              V
          V          <em>declarator</em>
    <em>type-specifier</em>
</code></pre></p>

<p>The struct definition itself is a type specifier, just like <code>int</code> or <code>double</code>, etc.</p>

<p>However, without a tag name, you cannot refer to this same structure type in future declarations.  You can certainly repeat the definition for another variable:</p>

<pre><code>struct { int a; int b; } y;
</code></pre>

<p>but the types of <code>x</code> and <code>y</code> will be <em>distinct</em> - the compiler considers each <code>struct</code> definition to be a different type, even though they have the same contents.  </p>

<p>Now, remember from the general declaration syntax above, the list of declarators in a declaration is <em>optional</em>.  This is what allows us to declare a structure with just a tag name (although per the constraint above, you <em>must</em> include the tag name if you are not declaring a variable of this type):<pre><code>
struct foo { int a; int b; };
|                          |
+-----------+--------------+
            |
            V
      <em>type-specifier</em>
</code></pre></p>

<p>We've defined the struct type and given it the tag name <code>foo</code>; we can declare objects of this type as</p>

<pre><code>struct foo x;
struct foo y;
</code></pre>

<p>Because from the syntax above:<pre><code>struct foo x;
|        |
+---+----+
    |
    V
<em>type-specifier</em>
</code></pre></p>

<p>This time, <code>x</code> and <code>y</code> are considered to be the same type.  </p>

<p>We can also declare a variable at the same time we define the struct:<pre><code>struct foo { int a; int b; } x;
|                          |
+----------+---------------+
           |
           V
     <em>type-specifier</em></p>

<p>struct foo y;
|        |
+----+---+
     |
     V
<em>type-specifier</em>
</code></pre></p>

<p>The first declaration creates the <code>struct foo</code> type and declares <code>x</code> to be a variable of that type.  The second declaration uses the previously defined <code>struct foo</code> type to declare a variable <code>y</code>.</p>

<p>Basically, C declaration syntax, especially with respect to structures, unions, and enums, is fairly flexible, and all of the methods listed in your book are equally valid.</p>
",0
50007093,50007005,2,"<p>At the time a <code>struct</code> is defined, you can also define one or more instances of that struct.  This is what is happening in both the 2nd and the 3rd examples.</p>

<p>The difference between the two is that one declares three variables of type <code>struct book</code> at the time that type is defined, while the other declares three variables whose type is an anonymous struct.  In the latter case, that means that no other variables of that type may be defined since the struct has no name and does not have an associated <code>typedef</code>.</p>
",3
51108441,51108370,4,"<p>You either got lucky with the uninitialized data, or your compiler is optimizing the pointer away.</p>

<p>When you do a thing like that with</p>

<pre><code>int *a;
*a = 9;
printf(""%d\n"", *a);
</code></pre>

<p>The compiler can just turn that into</p>

<pre><code>puts(""9"");
</code></pre>

<p>Because it can know and see all of the values.</p>

<p>That's probably why your function call version crashes. Because the compiler has to generate a function that can be called by other code modules.</p>

<p>This sort of thing will vary a lot based on compiler, compiler version, and of course the flags given to the compiler.</p>
",0
54750141,54750029,6,"<p>The problem is in how you're reading the input:</p>

<pre><code>scanf(""%s"",&amp;s);
</code></pre>

<p>The <code>%s</code> format specifier to <code>scanf</code> reads characters until it encounters whitespace.  This means it stops reading at the first space.</p>

<p>If you want to read a full line of text, use <code>fgets</code> instead:</p>

<pre><code>fgets(s, sizeof(s), stdin);
</code></pre>
",0
58056398,58055839,4,"<p>It appears you are not providing any non-whitespace (which are eaten away by th space in the format string, including newlines) characters (or perhaps nothing at all) from standard input. If this happens, <code>scanf</code> will fail to parse a char and leaves <code>c</code> uninitialized.</p>

<p>Using uninitialized variable is is <em>Undefined Beheavior</em>, so in theory <em>anything</em> could happen. In practice, from your description, it sounds like memory reserved for <code>c</code> happens to have byte value 0, which is unprintable character, so <code>printf</code> prints something else (maybe <code>/0</code>, maybe nothing). And then the environment (<em>vim</em>) might show you the program exit code, also 0 here (assuming the Undefined Behavior doesn' cause your program to crash).</p>

<p>To fix this, check return value of <code>scanf</code>:</p>

<pre><code> #include&lt;stdio.h&gt;

 int main()
 {
   char c ;

   int r = scanf("" %c"",&amp;c);
   if (r==1) {
      // Always print something and add newline
      // to be sure we see some output always.
      printf(""c='%c'\n"",c);
   } else {
      printf(""scanf error: %d\n"", r);
      // If r==-1, errno variable tells what error was
   }
   return 0;
 }
</code></pre>

<hr>

<p>Practical hint: To provide standard input when there is no terminal (so you can't type the input), you can pipe something:</p>

<pre><code>echo A | ./thisprogram
</code></pre>
",7
52617287,52616639,0,"<p>If I understand your question, you want to copy all of the tokens into a new string without the spaces.  If that's what you want, you could do something like this.  First declare your array1 like this: </p>

<pre><code>char *array1;
</code></pre>

<p>Then allocate memory for it after your initial loop before you reset <code>i</code>:</p>

<pre><code>array1 = malloc(i + 1);
</code></pre>

<p>Then after tokenizing, you can copy the strings:</p>

<pre><code>            strcpy(array1, cmd);
            for (i = 0; i &lt; spaces; i++) {
                    strcat(array1, token[i]);
            }
            printf(""concat: %s\n"", array1);
</code></pre>

<p>One thing to take care of is to verify that your tokenization handles the scenario where there are no spaces.</p>
",2
50816708,50816579,3,"<p>To begin with you should check what <a href=""http://en.cppreference.com/w/c/io/fgets"" rel=""nofollow noreferrer""><code>fgets</code></a> returns. If it fails it will return <code>NULL</code>.</p>

<p>As for your problem, the <a href=""http://en.cppreference.com/w/c/io/fgets"" rel=""nofollow noreferrer""><code>fgets</code></a> function will not necessarily read a whole line. If you tell <a href=""http://en.cppreference.com/w/c/io/fgets"" rel=""nofollow noreferrer""><code>fgets</code></a> to read at most <code>16</code> characters (including terminator) then <a href=""http://en.cppreference.com/w/c/io/fgets"" rel=""nofollow noreferrer""><code>fgets</code></a> will read up to 15 character from the input, and then leave the rest in the buffer. It will <em>not</em> read up until newline and discard what doesn't fit in the buffer.</p>

<p>To validate that you get a whole line with <code>fgets</code>, check that the last character in the string is a newline.</p>

<hr>

<p>To help you along the way, you need to do something like</p>

<pre><code>if (fgets(name, sizeof name, stdin) == NULL)
{
    // Error or end-of-file, either way no use in continuing
    break;
}

if (strcspn(name, ""\n"") == strlen(name))
{
    // No newline in string, there might be more to read in the input buffer
    // Lets read and discard all remaining input in the input buffer until a newline
    int c;
    while ((c = fgetc(stdin)) != EOF &amp;&amp; c != '\n')
    {
    }

    // TODO: Should probably tell the user about this event

    // Continue with next attempt
    ++attempts;
    continue;
}
</code></pre>

<p>I do recommend that you break this out into a separate function that you can reuse for reading of the password as well.</p>
",3
48879455,48879389,7,"<p>C doesn't have pass-by-reference. And that's not what's happening here anyway. When a macro is ""called"", the preprocessor <em>replaces</em> the call-site with the body.</p>

<p>With your example, the invocation</p>

<pre><code>swap(x,y);
</code></pre>

<p>is replaced by </p>

<pre><code>x = x+y;y = x-y; x = x-y;;
</code></pre>

<p>This last line is what the actual parser of the compiler sees.</p>

<p>Many compilers have options to stop after the preprocessing step. I suggest you use that to see exactly what the preprocessor have done.</p>

<hr>

<p>I also hope you start to see how macros can ""break"" your code.</p>

<p>For example if the code was</p>

<pre><code>if (some_condition)
    swap(x,y);
</code></pre>

<p>Then it would be <em>expanded</em> to (with some reformatting)</p>

<pre><code>if (some_condition)
    x = x+y;
y = x-y;
x = x-y;
;
</code></pre>

<p>This is clearly not what was intended and will not work.</p>

<p>You also have the case when the arguments to the macro are not simple variables, but expressions. Like</p>

<pre><code>swap(x+1,y*2)
</code></pre>

<p>While would be replaced by</p>

<pre><code>x+1 = x+1+y*2;y*2 = x+1-y*2; x+1 = x+1-y*2;;
</code></pre>

<p>This also would not work.</p>
",1
48937822,48937757,7,"<p>The intention of the code is <strong>to dumbly pluralise</strong> (append an <code>'s'</code>) a word informed in argument <code>s</code> by considering the number informed in argument <code>n</code>. In other words (if the code was correct), if <code>n &gt; 1</code>, then it appends an <code>s</code> to the end of the string.</p>

<p>However, the presented code will not work because of many errors:</p>

<ol>
<li>It assumes the string informed in <code>s</code> won't be longer than 8 characters (8 + 's' + '\0'), otherwise the function may crash the process or cause other undesired effects - You should use safer functions to perform string copying;</li>
<li>The loop used to move the pointer to the end of the string, increments the pointer until it's too late. It stops after the <code>\0</code> (nul terminator), because the post-increment operator (++) is always executed, despite the result of the condition. It should be <code>while (*c) c++;</code>;</li>
<li>It returns an invalid pointer to a local variable <code>s2</code>, which may cause multiple problems in the program, including a crash - You should dynamically allocate memory for the result, or pass a pointer as argument, indicating where the string will be stored, and how many bytes it can take;</li>
<li>It doesn't terminate the <em>new string</em> properly - there's no guarantee the string will contain another '\0' after the appended <code>'s'</code>.</li>
</ol>
",0
51436063,51436001,1,"<p>You are writing to memory which you do now own i.e. was not handed back by <code>malloc</code> , <code>calloc</code> or <code>realloc</code>. This results in <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behaviour</a>. Your program can do anything at all, including not producing any error message or core dump.</p>
",7
52456922,52456208,1,"<p>As mentioned by Jonathan Leffler, you are missing a semicolon:</p>

<pre><code>typedef struct xxxListItem{
    void *data;
    struct xxxListItem *next; // &lt;--- right here!
}XXXList;
</code></pre>
",1
52813539,52813472,4,"<p>No <code>sizeof</code> isn't a library function, it's a <a href=""https://en.cppreference.com/w/c/language/sizeof"" rel=""nofollow noreferrer"">special operator keyword</a>.</p>

<p>It has two forms: One is with parentheses to get the size of a type. The other is not using parentheses and is for getting the size of the result of a generic expression.</p>

<p>With <code>sizeof(name)</code> you're really using the second variant, with the expression <code>(name)</code>. I.e. the parentheses are part of the expression and not the <code>sizeof</code> operator.</p>
",0
55543715,55543409,0,"<p>The standard library has enough facilities for you not to need to write any loop of your own. See:</p>

<p><a href=""https://stackoverflow.com/questions/53849/how-do-i-tokenize-a-string-in-c"">How do I tokenize a string in C++?</a></p>

<p>about working with words and</p>

<p><a href=""https://en.cppreference.com/w/cpp/algorithm"" rel=""nofollow noreferrer"">The C++ standard algorithms library</a></p>

<p>for sorting etc. Oh, you might also want to read up on iterators.</p>
",0
58044141,58044019,0,"<p>Many format specifiers for <a href=""https://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow noreferrer""><code>scanf</code></a> skip leading while-space (like newlines), but not <code>""%[""</code>.</p>

<p>So the newline that is added by you pressing <kbd>Enter</kbd> in the first input will be the the first thing that the next call to <code>scanf</code> will read. And with your format a newline (or really, any space) will tell <code>scanf</code> to stop reading, which means nothing more will ever be read. Over and over again.</p>

<p>I would rather recommend you use <a href=""https://en.cppreference.com/w/c/io/fgets"" rel=""nofollow noreferrer""><code>fgets</code></a> to read lines, as that also included automatic buffer-overflow protection (granted you pass the correct buffer size).</p>

<p>And if you're worried about the newline added by <code>fgets</code> it's easy to remove with the <a href=""https://en.cppreference.com/w/c/string/byte/strcspn"" rel=""nofollow noreferrer""><code>strcspn</code></a> function.</p>

<p>So better do something like</p>

<pre><code>char input[100];
while (fgets(input, sizeof input, stdin) != NULL)
{
    input[strcspn(input, ""\n"")] = 0;  // Remove possible trailing newline

    if (strcmp(input, ""EXIT"") == 0)
        break;  // Exit
    else
    {
        // Rest of code
    }
}
</code></pre>
",0
56619870,56619483,0,"<ul>
<li><p><code>fgets()</code>reads the (CR+)LF too, and stores it into the buffer.</p>
</li>
<li><p>But <strong>only</strong> if there is sufficient place!</p>
</li>
<li><p>Otherwise, your buffer will contain the first <code>n-1</code> characters, plus a NUL character.</p>
<p>So: allocate a large-enough buffer, and strip the CR/LF:</p>
</li>
</ul>
<hr />
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    int pass = 0;
    char password[] = &quot;password&quot;;
    char buffer[3+ sizeof password];

    printf(&quot;\n Enter your password : \n&quot;);
    fgets(buffer, sizeof buffer, stdin);
    buffer[strcspn(buffer,&quot;\r\n&quot;)]=0;

    if(strcmp(buffer, password))
    {
        printf (&quot;\n Incorrect Password \n&quot;);
    }
   
    else
    {
        printf (&quot;\n Correct Password \n&quot;);
        pass = 1;
    }

    if(pass)
    {
        printf (&quot;\n Root privileges authorized \n&quot;);
    }

    return 0;
}
</code></pre>
",5
56619827,56619483,1,"<p>The problem with your code is that fgets is taking the first 8 characters off the input and ignoring the rest. Obviously, if you are inviting a password you don't want to ignore any input! You might want to do something a little more fancy to ensure that you capture the full input. </p>

<p>My first two tries at answering this were wrong. Thanks to wildplasser for holding my feet to the fire.</p>

<p>So, the hack answer is: use a really big buffer. fgets is probably your easier solution there.</p>

<p>Alternatively, you could allocate memory dynamically as your input string exceeds your buffer.</p>

<p>But, just for fun, here is an implementation that breaks us out of the ""line buffer"" trap that I wasn't aware getchar was in.</p>

<p>For this, I leveraged a very beautiful comment here: <a href=""https://stackoverflow.com/questions/7741930/getchar-and-stdin"">getchar() and stdin</a></p>

<p>PS: Ok, Ok, I <em>tested</em> it this time. It works. On my Mac.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;termios.h&gt;

int main(void)
{
    int c, i;
    char buffer[9];
    struct termios tty_opts_default, tty_opts_raw;

    if (!isatty(STDIN_FILENO)) {
      printf(""Error: stdin is not a TTY\n"");
      return 1;
    }

    /* save tty settings for later. */
    tcgetattr(STDIN_FILENO, &amp;tty_opts_default);

    /* put tty settings into raw mode. */
    cfmakeraw(&amp;tty_opts_raw);
    tcsetattr(STDIN_FILENO, TCSANOW, &amp;tty_opts_raw);

    /* NOW we can grab the input one character at a time. */
    c = getchar();
    while (i &lt; 8 &amp;&amp; c != EOF &amp;&amp; c != '\n' &amp;&amp; c != '\r') {
      /* Since we are collecting a pwd, we might want to enforce other
         password logic here, such as no control characters! */
      putchar('*');
      buffer[i++] = c;
      c = getchar();
    }
    buffer[i] = '\0';

    /* Restore default TTY settings */
    tcsetattr(STDIN_FILENO, TCSANOW, &amp;tty_opts_default);

    /* Report results to user. */
    printf(""\nPassword received.\n"");
    printf(""(It was '%s' -- don't tell anyone! Quick! Hide the terminal!)\n"", buffer);

    return 0;
}
</code></pre>
",11
50575821,50575679,1,"<p>Your program prompts for a single character and reads it using <code>getchar()</code> (which returns an <code>int</code>, not a <code>char</code>, so <code>q</code> needs to be define as an <code>int</code> and checked for equality to <code>EOF</code>).</p>

<p>If you enter an incorrect character (say, <code>'x'</code>), you're actually entering <em>two</em> characters: the <code>'x'</code> and a newline when you type <kbd>Enter</kbd>. It takes two <code>getchar()</code> calls to read them both, so you get two error messages.</p>

<p>If the input is meant to be line-oriented you can read a line into a string using <code>fgets()</code> (but handling input longer than your target array is tricky), or you can read a single character and then read and discard characters up to a <code>'\n'</code> or <code>EOF</code>.</p>
",6
54543872,54543792,2,"<p>This task sounds a bit like a homework problem, so I won't give you working code outright but I will help you out a bit: </p>

<p>A <code>for</code> loop <code>for(init; cond; increment) { loop-body; }</code> is equivalent to:</p>

<pre><code>init;
while(cond)
{
    loop-body;
    increment;
}
</code></pre>

<p>Now, a <code>do-while</code> loop is similar to a while loop, except that even if <code>cond</code> is false from the start, <code>loop-body</code> will be executed at least once.  In other words, the above <code>while</code> loop is equivalent to the following <code>do-while</code> loop:</p>

<pre><code>init;
int first_run = 1;
do
{ 
    if(first_run)
    {
        if((cond) == 0) break;
        first_run = 0;
    }
    loop-body;
    increment;
}
while(cond);
</code></pre>
",2
53619898,53619588,1,"<p>A lot of your loops aren't doing what you think.</p>

<pre><code>for (i = 1; i &lt;= 100; i++)
{
    randnumber = rand() % 100 + 1;
    printf(""%d  "", randnumber);
}
</code></pre>

<p>That just sets and prints <code>randnumber</code> 100 times. <code>randnumber</code> is overwritten each time.</p>

<pre><code>for (i = 0; i &lt; randnumber; i++)
{
    a[randnumber];
}
</code></pre>

<p>That does nothing. Technically it loops from 0 to <code>randnumber</code> doing nothing. It doesn't initialize <code>a</code>.</p>

<pre><code>for (i = 1; i &lt; randnumber; i++)
{
    if (a[i] &gt; large)
    {
        large = a[i];
    }
    else if (a[i] &lt; small)
    {
        small = a[i];
    }
}
</code></pre>

<p>This searches <code>a</code> for the largest and smallest, but it does it from 0 to <code>randnumber</code>. It needs to go from 0 to 99, the size of <code>a</code>. But <code>a</code> is not initialized so it's full of garbage. That's why you're getting weird results.</p>

<hr>

<p>The mistakes are you need to iterate from 0 to the size of <code>a</code>. You need to bring your first two loops together to initialize <code>a</code>. And you need to seed <code>rand</code> or it will always produce the same numbers.</p>

<pre><code>// Seed the random number generator.
// Note this is a terrible seed.
srand((unsigned int)time);

// Fill a with random numbers.
for (i = 0; i &lt; 100; i++)
{
    randnumber = rand() % 1000 + 1;
    a[i] = randnumber;
}

large = small = a[0];
for (i = 1; i &lt; 100; i++)
{
    if (a[i] &gt; large)
    {
        large = a[i];
    }
    else if (a[i] &lt; small)
    {
        small = a[i];
    }
}
</code></pre>

<p>I've also bumped up the random range to 1000. If you pick 100 random numbers from 1 to 100 odds are the smallest will be 1 and the largest will be 100. Not very interesting.</p>
",1
57946800,57946617,2,"<p>For the division algorithm there, you first <em>double</em> the width of the divisor (so its twice as many bits as the dividend), and then shift the value 'up' into the upper half.  You then shift it down one bit at a time.</p>

<p>So that example is showing a 4-bit division (0b0111 divided by 0b0010).  The first step is then to double the width of the divisor (to 8 bits), shifting it up by 4.  So the divisor in the first step is<br/> 0b0010 0000 (they add the space to make the two 4-bit words clearer).  It will then be shifted down by one bit each step, ending up as 0b0000 0010 (the original divisor) on the last step.</p>
",7
52253358,52253281,4,"<p>You print all 20 elements of the array, but if the user entered a string smaller than that not all elements would be initialized. They would be <em>indeterminate</em> and seemingly random.</p>

<p>Remember that <code>char</code> strings in C are really called <strong><em>null-terminated</strong> byte strings</em>. That <em>null-terminated</em> bit is important, and mean you can easily find the end of the string by checking the current character agains <code>'\0'</code> (which is the terminator character).</p>

<p>Or you could just use the <a href=""https://en.cppreference.com/w/c/string/byte/strlen"" rel=""nofollow noreferrer""><code>strlen</code></a> function to get the length of the string instead:</p>

<pre><code>for(i=0;i&lt;strlen(st);i++) { ... }
</code></pre>

<p>Or use the <code>""%s""</code> format to print the string:</p>

<pre><code>printf(""%s"", st);
</code></pre>

<p>Also note that without any protection the <code>scanf</code> function will allow you give longer input than is space for in the array, so you need to protect agains that, for example by limiting the amount of characters <code>scanf</code> will read:</p>

<pre><code>scanf(""%19s"",st);  // Write at most 19 character (*plus* terminator) to the string
</code></pre>

<hr>

<p>Now for why your input doesn't seem to be printed, it's because the <em>indeterminate</em> contents of the uninitialized elements. While you're not going out of bounds of your array, you still go out of bounds of the actual string. Going out of bounds leads to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>.</p>

<p>What's <em>probably</em> is happening is that some of the ""random"" indeterminate contents happens to be a carriage return <code>'\r'</code>, which moves the cursor to the start of the line and the output already written will be overwritten by the uninitialized elements in your array.</p>
",3
48994603,48994485,2,"<p>Key part of understanding this code is the conditional with a bitwise operation inside:</p>

<pre><code>if(dataOutRead[i]==1) {
    data = data | (0x01 &lt;&lt; i);
} else {
    data = data &amp; ~(0x01 &lt;&lt; i);
}
</code></pre>

<p>It uses bytes of <code>dataOutRead</code> as a sequence of ones and not ones (presumably, but not necessarily, zeros). This sequence is ""masked"" into bits of <code>data</code> starting with the least significant one:</p>

<ul>
<li>When <code>dataOutRead[i]</code> is <code>1</code>, the corresponding bit is set</li>
<li>When <code>dataOutRead[i]</code> is not <code>1</code>, the corresponding bit is cleared. This step is unnecessary, because <code>data</code> is zeroed out before entering the loop.</li>
</ul>

<p>This could be thought of as converting a ""byte-encoded-binary"" (one byte per bit) into its corresponding binary number.</p>

<p>The second loop does the same thing with reversed bits, processing only the lower four bits, and sticking them into the upper nibble of the <code>data</code> byte in reverse order.</p>

<p>It's hard to speculate on the purpose of this approach, but it could be useful in applications that use arrays of full-byte Booleans to control the state of some hardware register, e.g. in a microcontroller.</p>
",3
49181434,49179337,0,"<p>A simple solution on systems that support it (all modern desktop operating systems for example), is to memory-map the entire file.  The file content is then memory addressable directly and the operating-systems virtual memory management handles the memory and paging for you regardless of the size of the file.  </p>

<p>You then either operate on the file content directly as if it were memory - no explicit allocation, reallocation or (even write-back should you modify it) necessary - or get each line start and length by scanning for newline, allocate exact amount of memory required and copy it.</p>

<p>Windows and POSIX API's for memory mapped files differ, but you will find plenty of examples for whatever system you are using.</p>
",0
53792516,53792077,7,"<p>I think you've misread the man page. Assuming that you're talking about the Linux man page, it claims (correctly) that <code>explicit_bzero</code> and <code>memset_explicit</code> and <code>memset_s</code> are more secure (for certain purposes) than <code>memset</code> and <code>bzero</code>. It doesn't claim any security difference between <code>memset</code> and <code>bzero</code>. The reason <code>bzero</code> is deprecated is that it's a trivial wrapper around <code>memset</code> and all1 C implementations have <code>memset</code>, so programmers might as well use <code>memset</code>.</p>

<p>The difference between <code>memset</code>/<code>bzero</code> and the <code>explicit_</code>/<code>_s</code> variants is that compilers are forbidden from optimizing away the explicit variants. This makes the explicit variants suitable for scrubbing confidential data. For example, consider the following program snippet:</p>

<pre><code>bzero(password, password_length);
free(password);
</code></pre>

<p>With just <code>bzero</code> or <code>memset</code>, many modern compilers see ¡°oh, you're writing to memory and then freeing it. There's no way to read back what <code>bzero</code> just wrote, so the call to <code>bzero</code> is equivalent to doing nothing. Doing nothing is faster than calling <code>bzero</code>, therefore I'll generate no code for the <code>bzero</code> call.¡±</p>

<p>The flaw in the compiler's reasoning is that the reason for zeroing the memory is not the defined behavior of your program, but what happens in case of subsequent undefined or unspecified behavior. From the point of view of a C compiler, undefined behavior means anything can happen. From the point of view of a security engineer, exactly what happens on undefined behavior such as a buffer overflow or a use-after-free is very important. Likewise, exactly what is read back from uninitialized memory is unspecified, but important to a security engineer. Security engineers try to reduce the security impact of such undefined or unspecified behavior.</p>

<p>So for a security engineer that optimization of <code>memset</code> is unfortunate. A security engineer wants to guarantee that when memory has been freed, <a href=""https://en.wikipedia.org/wiki/Heartbleed"" rel=""noreferrer"">its former contents will not leak out, even, say, due to a buffer overflow</a>. Hence <code>explicit_bzero</code>: compilers are instructed to treat the content of the target memory when this function returns as observable, so they aren't allowed to optimize the call away on the basis that the program isn't reading back from it. Semantically, <code>explicit_bzero(buffer, length)</code> is equivalent to</p>

<pre><code>bzero(buffer, length);
for (size_t i = 0; i &lt; length; i++) __observe__(buffer[i]);
</code></pre>

<p>where <code>__observe__</code> has no effect but nonetheless depends on the value of its argument. The compiler is therefore not allowed to remove the call to <code>bzero</code>, because then <code>__observe__</code> would not read back the correct values.</p>

<p>Explicit zeroing has limitations. The man page highlights that it won't scrub copies of a variable in registers, but this is usually not a big concern because it's rare for a buffer overflow or a read from uninitialized memory to end up leaking register values. The biggest limitation in practice is <code>realloc</code>. When you use dynamically allocated memory, <code>realloc</code> may move it, and there's no way to scrub the old value. For this reason, if the contents of a buffer is sensitive, you must not use <code>realloc</code> on it.</p>

<p>Another limitation of explicit zeroing is that it only applies at the program level, not at the system level. Copies of the data may remain in caches, in swap, etc. The goal of zeroing memory inside your program is to protect from a security breach inside your program. It doesn't protect from larger system compromises.</p>

<p>Note that writing your own <code>explicit_bzero</code> is <a href=""http://www.daemonology.net/blog/2014-09-06-zeroing-buffers-is-insufficient.html"" rel=""noreferrer"">impossible to do portably</a>. The best you can do is to make it work with a finite set of versions of a finite set of compilers, with no guarantee that the next version won't have a fancier optimizer that sees through your attempt. That's why C11 added it as a standard function with <a href=""https://en.cppreference.com/w/c/string/byte/memset"" rel=""noreferrer""><code>memset_s</code></a>.</p>

<p>1 <sub> Almost. Technically freestanding implementations don't have to have <code>memset</code> but it's such a simple and useful function that most do, and it's usually provided by the compiler so it's available even when building without the usual C runtime. </sub>  </p>
",0
58580524,58580077,1,"<p>You're most probably getting a segmentation fault because you're overwriting the return address with the wrong value. You can easily check what is going on by placing a breakpoint right at the <code>ret</code> instruction, and see the state of the stack at that point.</p>

<p>Start the program inside the debugger and place a breakpoint where needed:</p>



<pre class=""lang-none prettyprint-override""><code>$ gdb ./test

(gdb) break main
(gdb) run ""$(python -c 'print (""A""*0x6c + ""BBBB"" + ""\x86\x84\x04\x08"")')""
</code></pre>

<p>When the breakpoint at <code>main</code> is reached, add a second breakpoint on the <code>ret</code> instruction of the vulnerable function:</p>

<pre class=""lang-none prettyprint-override""><code>(gdb) break *0x080484ec
(gdb) continue
</code></pre>

<p>Then, when the second breakpoint is reached, look what's on the stack now at the position pointed by <code>$esp</code>:</p>

<pre class=""lang-none prettyprint-override""><code>(gdb) x/wx $esp
</code></pre>

<p>What you would like to see is something like this:</p>

<pre class=""lang-none prettyprint-override""><code>0x7fffe830: 0x08048486
</code></pre>

<p>If you don't see that, it means your payload is wrong, and perhaps you wrongly calculated the needed offset. Take a look at what's in the stack before the saved return address:</p>

<pre class=""lang-none prettyprint-override""><code>(gdb) x/17wx $esp - 0x40
</code></pre>

<p>Again, what you would like to see is the following (assuming <code>$esp = 0x7fffe830</code>):</p>

<pre class=""lang-none prettyprint-override""><code>0x7fffe7f0: 0x41414141  0x41414141  0x41414141  0x41414141
0x7fffe800: 0x41414141  0x41414141  0x41414141  0x41414141
0x7fffe810: 0x41414141  0x41414141  0x41414141  0x41414141
0x7fffe820: 0x41414141  0x41414141  0x41414141  0x42424242
0x7fffe830: 0x08048486
</code></pre>

<p>The <code>0x41414141</code> values are your <code>AAAAAA...</code> padding, followed by four Bs (<code>0x42424242</code>) and the overridden return address <code>0x08048486</code>. If you see anything different, you can see if there is the need for more (or less) padding.</p>

<p>If the above did not help, check where the segmentation fault occurs, again using <code>gdb</code>. Since <code>gdb</code> automatically stops for you when a segfault happens, you would just have to run the program once and see where it crashes:</p>

<pre class=""lang-none prettyprint-override""><code>$ gdb ./test

(gdb) run ""$(python -c 'print (""A""*0x6c + ""BBBB"" + ""\x86\x84\x04\x08"")')""

# ...

Program received signal SIGSEGV (fault address 0x0)
</code></pre>

<p>See what's going on and where the program died:</p>

<pre class=""lang-none prettyprint-override""><code>(gdb) backtrace
...
</code></pre>
",4
53146533,53146413,4,"<p>Also from <a href=""http://man7.org/linux/man-pages/man3/system.3.html"" rel=""nofollow noreferrer""><code>man system</code></a>:</p>

<blockquote>
  <p>[...] even though POSIX.1-2001 requires a conforming implementation to provide a shell, that shell may not be available or executable if the calling program has previously called <a href=""http://man7.org/linux/man-pages/man2/chroot.2.html"" rel=""nofollow noreferrer"">chroot(2)</a> [...]</p>
</blockquote>

<p>So that's a possible case where <code>/bin/sh</code> might not be available. In practice I wouldn't worry too much about it. (But then again, I probably wouldn't use <code>system</code> in real code in the first place.)</p>
",0
53292040,53291982,2,"<p>If you don't mind using GCC extensions (<a href=""https://gcc.gnu.org/onlinedocs/gcc-8.2.0/gcc/Pointer-Arith.html#Pointer-Arith"" rel=""nofollow noreferrer"">Pointer arithmetic on <code>void</code> pointers and function pointers</a>) and you're actually using GCC (or Clang), then you can write (more or less) what you wrote using <code>+=</code>:</p>

<pre><code>void foo(int size)
{
    node-&gt;pointer += size; // Not standard ¡ª using GCC extension
}
</code></pre>

<p>It is not standard C, though, and therefore not portable.  From C11 (ISO/IEC 9899:2011):</p>

<blockquote>
  <ul>
  <li><a href=""http://port70.net/~nsz/c/c11/n1570.html#6.2.5p19"" rel=""nofollow noreferrer"">¡ì6.2.5 Types ?19</a>: <em>The <code>void</code> type comprises an empty set of values; it is an incomplete object type that cannot be completed.</em></li>
  <li><a href=""https://port70.net/~nsz/c/c11/n1570.html#6.5.3.4"" rel=""nofollow noreferrer"">¡ì6.5.3.4 The <code>sizeof</code> and <code>_Alignof</code> operators</a>: <em>The sizeof operator shall not be applied to an expression that has function type or an incomplete type, to the parenthesized name of such a type, or ¡­</em></li>
  <li><a href=""https://port70.net/~nsz/c/c11/n1570.html#6.5.6p2"" rel=""nofollow noreferrer"">¡ì6.5.6 Additive operators</a>: <em>For addition, either both operands shall have arithmetic type, or one operand shall be a pointer to a complete object type and the other shall have integer type.</em></li>
  <li><a href=""https://port70.net/~nsz/c/c11/n1570.html#6.5.6p3"" rel=""nofollow noreferrer"">¡ì6.5.6 Additive operators</a>: <em>For subtraction, one of the following shall hold:</em>
  
  <ul>
  <li><em>both operands have arithmetic type;</em></li>
  <li><em>both operands are pointers to qualified or unqualified versions of compatible complete object types; or</em></li>
  <li><em>the left operand is a pointer to a complete object type and the right operand has integer type.</em></li>
  </ul></li>
  <li><a href=""https://port70.net/~nsz/c/c11/n1570.html#6.5.16.2p1"" rel=""nofollow noreferrer"">¡ì6.5.16.2 Compound assignment ?1</a>: <em>For the operators <code>+=</code> and <code>-=</code> only, either the left operand shall be an atomic, qualified, or unqualified pointer to a complete object type, and the right shall have integer type; or the left operand shall have atomic, qualified, or unqualified arithmetic type, and the right shall have arithmetic type.</em></li>
  </ul>
</blockquote>

<p>Since the <code>void</code> type is incomplete and cannot be completed, and therefore a <code>void *</code> is a pointer to an incomplete type, you can't use <code>void</code> with <code>sizeof</code>, nor can you use <code>void *</code> with <code>+</code> or <code>-</code> to do pointer arithmetic, and consequently you can't use <code>void *</code> with the compound assignments <code>+=</code> and <code>-=</code> either. </p>

<p>The standard C equivalent would be:</p>

<pre><code>void foo(int size)
{
    node-&gt;pointer = (char *)node-&gt;pointer + size;
}
</code></pre>

<p>This code doesn't return a value, any more than yours did (though you said it would because the return type was <code>void *</code>).  Since <code>node-&gt;pointer</code> is a <code>void *</code>, you don't need a cast back to <code>void *</code>; this is C and the conversion is automatic.</p>
",6
55113806,55113502,1,"<p>You wrote <code>a = &amp;d;</code> to try to return your integer via pointer. Unfortunately that sets a in <code>funct2</code> to point to <code>d</code> instead. What you want is <code>*a = d;</code>.</p>
",0
50520270,50520150,0,"<p>In <code>neighbors2</code>, you set <code>i_left</code> and <code>i_right</code> so that the're limited to the rows of the grid. If the current cell is in the top or bottom row, you only loop through two rows instead of 3.</p>

<p>In <code>first_row()</code> and <code>last_row()</code> you also limit it to the rows of the grid. But the result is that these functions will add the cells on the same row as the current cell, which is what <code>second_row</code> does. So you end up adding those rows twice.</p>

<p>You shouldn't call <code>first_row()</code> when <code>i = 0</code>, and you shouldn't call <code>third_row()</code> when <code>i == HEIGHT</code>.</p>

<pre><code>static int addUp(board b, int i, int j) {
    int n = (i == 0 ? 0 : first_row(b, i, j)) + 
            second_row(b, i, j) + 
            (i == HEIGHT ? 0 : third_row(b, i, j));
    return n - b[i][j];
}
</code></pre>

<p>Another option would be to do the check in the functions themselves:</p>

<pre><code>function first_row((board b, int i, int j) {
    if (i == 0) {
        return 0;
    }
    int f = 0;
    int j_left = max(0,j-1);
    int j_right  = min(WIDTH, j+2);
    int jj;

    for (jj = j_left; jj &lt; j_right; ++jj) {
        f += b[i][jj];
    }

    return f;
}    
</code></pre>

<p>and similarly for <code>third_row()</code>. But doing it in the caller saves the overhead of the function calls.    </p>

<p>BTW, your variable names are very confusing. All the <code>i</code> variables are for rows, which go from top to bottom, not left to right.</p>
",3
53095652,53095390,4,"<p>In O(n) without calculating the size of the stacks, taking care of the special case of a stack being empty and not the other one.</p>

<p>Something like (hint algorithm)</p>

<pre><code>bool are_equal(stack1, stack2) {
    while ( 1 ) {
       bool e1 = is_empty(stack1);
       bool e2 = is_empty(stack2);
       if (e1 &amp;&amp; e2) return true;                    // equal
       if (e1 || e2) return false;                   // not equal
       if (pop(stack1) != pop(stack2)) return false; // not equal
    }
}
</code></pre>
",0
49122079,43999847,1,"<blockquote>
  <p>I call the function destroy list with the the last node I entered ... how can I make a destroy function that goes in the opposite direction?</p>
</blockquote>

<p>With a singly-linked list, there is only one direction you <em>can</em> go, the direction in which the links are pointing. It <em>sounds</em> like the state of your list after building is something like:</p>

<pre><code>                          pointer
                             |
                             V
firstVal -&gt; secondVal -&gt; thirdVal -&gt; NULL
</code></pre>

<p>and you then call <code>destroyList(pointer)</code>. That is <em>not</em> what you need for a singly-linked list. Such a list should maintain a head pointer to the <em>start</em> of the list, as follows:</p>

<pre><code> pointer
    |
    V
firstVal -&gt; secondVal -&gt; thirdVal -&gt; NULL
</code></pre>

<p>If you were to build your list like that, then your code for destroying the list would work just fine.</p>

<p>Since you haven't actually <em>shown</em> the code that builds the list (instead giving only a description of said list once built), that's most likely your problem.</p>

<p>In order to build the list correctly, you can use pseudo-code such as:</p>

<pre><code>head = null
def append(head, tail, node):
    node.next = null
    if head == null:
        head = node
        tail = node
        return
    tail.next = node
    tail = node
</code></pre>
",1
55081652,55081244,1,"<p>The loop body modifies <code>a</code> which is then re-evaluated in the <code>for</code> loop where it should be loop-invariant.  Change the loop body from:</p>

<pre><code>  c=c+0.001*pow(a,a);
  a=a+0.001;
</code></pre>

<p>to</p>

<pre><code>  double x = i * 0.001 ;
  c += 0.001 * pow( x, x ) ;
</code></pre>

<p>You can in fact simplify this further by using x as the loop control variable:</p>

<pre><code>const double dx = (b - a) / 1000 ;
for( double x = a; x &lt; b; x += dx )
{
    c += 0.001 * pow( x, x ) ;
}
</code></pre>

<p>Further the multiplication by 0.001 on each iteration is unnecessary; you can apply that after the loop to the same effect and in some cases less accumulated error.</p>

<pre><code>const double dx = (b - a) / 1000 ;
for( double x = a; x &lt; b; x += dx )
{
    c += pow( x, x ) ;
}
c *= dx  ;
</code></pre>

<p>So the complete code becomes:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main() 
{
    double a = 0 ;
    double b = 1.0 ;
    printf( ""Enter limit 1:"");
    scanf(  ""%lf"", &amp;a ) ;
    printf( ""Enter limit 2:"");
    scanf( ""%lf"", &amp;b ) ;

    const double dx = (b - a) / 1000 ;
    double c = 0 ;
    for( double x = a; x &lt; b; x += dx )
    {
        c += pow( x, x ) ;
    }
    c *= dx  ;

    printf( ""The area is %lf"", c )  ;
    return 0;
}
</code></pre>

<p>Example:</p>

<pre><code>Enter limit 1:0                                                                                                                                          
Enter limit 2:1                                                                                                                                          
The area is 0.783431                                                                                                                                     
</code></pre>
",0
58416786,58415456,1,"<blockquote>
  <p>Is there something shorter like maybe:</p>

<pre>memset(arr, rand() % 255, sizeof(arr)); </pre>
</blockquote>

<p>That would be a bit too short, as it would fill the array with multiple copies of the same value.</p>

<p>The former loop would be fine, assuming that you have declared <code>arr</code> as an array of <code>unsigned char</code> (note that <code>char</code> is signed in many environments, so that <code>rand() % 255</code> could overflow).</p>

<p>If you want something shorter, you could just wrap the loop into a function (a simple one, there's no need to <a href=""https://wandbox.org/permlink/0mJSgAbnm7pWtPtd"" rel=""nofollow noreferrer"">overly complicate</a> things). </p>
",0
52884192,52884069,3,"<p>You can always cast stuff explicitly in C -- so you can cast <code>(void *(*)(void *, void *))func</code> to pass the function pointer.  The problem is that if the callee then tries to call through the function pointer without first casting it back to <code>int *(*)(int *, int *)</code>, the result is undefined behavior.</p>

<p>Now it may be the case that on your specific ABI this is likely to work anyways (all pointer types have the same representation, and are passed as arguments in the same way), so you might get away with it, but its still undefined behavior.  This is a good example of where the standard underspecifies things which are likely to be abused as a result.  Arguably this sort of thing should at least be implementation defined, not undefined.</p>
",1
55677606,55677555,1,"<p><a href=""http://port70.net/~nsz/c/c11/n1570.html#6.5p2"" rel=""nofollow noreferrer"">6.5p2</a></p>

<blockquote>
  <p>If a side effect on a scalar object is unsequenced relative to either
  a different side effect on the same scalar object or a value
  computation using the value of the same scalar object, the behavior is
  undefined. If there are multiple allowable orderings of the
  subexpressions of an expression, the behavior is undefined if such an
  unsequenced side effect occurs in any of the orderings.84)</p>
</blockquote>

<p><code>++a</code> and <code>a++</code> are unsequenced. Your program is ill-formed.</p>
",0
53855156,53855080,0,"<p>There is only one variable <code>mess</code>.
When you call:</p>

<pre><code>printf(""%s %s\n"", mes(55), mes(25));
</code></pre>

<p>You are filling in that one variable two different times, once with <code>""25""</code> and once with <code>""55""</code> (overwriting the <code>""25""</code>).  As a result, when <code>printf</code> goes to format with <code>%s %s</code>, it finds the same string twice, <code>""55""</code> and again <code>""55""</code> because the <code>""25""</code> has already been overwritten.</p>

<p>You need to be aware that all parameters to a function are evaluated before the function is called. The order of parameter evaluation is not defined, but is often right-to-left.  Breaking down that <code>printf</code> into little steps:</p>

<ol>
<li>Evaluate the <code>mes(25)</code>; now static char mess is now <code>""25""</code>.</li>
<li>Evaluate the <code>mes(55)</code>, now static char mess is overwritten to <code>""55""</code>.</li>
<li>Evaluate the parameter <code>""%s %s\n""</code> (there isn't much to evaluate here.  Its just a string)</li>
<li>Call <code>printf</code> with parameters: <code>""%s %s\n""</code>, and <code>""55""</code> and <code>""55""</code></li>
</ol>
",1
53855208,53855080,0,"<p>Returning the address of a static variable is almost always a bad pattern as you'e found. There's only one such static allocation for the whole program, so for example calling mes twice causes the second call to overwrite the results of the first.</p>

<p>A more reasonable pattern is having the caller furnish a buffer. This is also needed for thread safety:</p>

<pre><code>#include &lt;stdio.h&gt;

const char* mes(char *buf, int a)
{
    sprintf(buf, ""%d"", a);
    return buf;
}

const int* hes(int *arr, char *buf, int a)
{
    arr[0] = a;
    return arr;
}

int main()
{
    char buf1[100], buf2[100];
    int arr[100];
    printf(""%s %s\n"", mes(buf1, 55), mes(buf2, 25)); //55 55
    printf(""%s\n"", mes(buf1, 55)); //55
    printf(""%s\n"", mes(buf1, 25)); //25
    printf(""%d %d\n"", hes(arr, 55)[0], hes(arr, 25)[0]); //55 25
}
</code></pre>
",0
51229945,51229905,9,"<p>The casts <code>char &lt;=&gt; uint8</code> are fine. It is always allowed to access any defined memory as unsigned characters, including string literals, and then of course to  cast a pointer that points to a string literal back to <code>char *</code>.</p>

<p>In </p>

<pre><code>uint8 *my_string = ""XYZ"";
</code></pre>

<p><code>""XYZ""</code> is an anonymous array of 4 <code>char</code>s - including the terminating zero. This decays into a pointer to the first character. This is then implicitly converted to <code>uint8 *</code> - strictly speaking, it should have an explicit cast though.</p>

<hr>

<p>The problem with the type <code>char</code> is that the standard leaves it up to the implementation to define whether it is signed or unsigned. If there is lots of arithmetic with the characters/bytes, it might be beneficial to have them unsigned by default.</p>

<p>A particularly notorious example is the <code>&lt;ctype.h&gt;</code> with its <code>is*</code> character class functions - <code>isspace</code>, <code>isalpha</code> and the like. They require the characters as <a href=""https://stackoverflow.com/questions/47119083/does-isspace-accept-getchar-values""><strong><code>unsigned char</code>s</strong> (converted to int)</a>! A piece of code that does the equivalent of <code>char c = something(); if (isspace(c)) { ...?}</code> is not portable and a compiler cannot even warn about this! If the <code>char</code> type is signed on the platform (default on x86!) and the character  isn't ASCII (or, more properly, a member of the basic execution character set), then the behaviour is undefined - <a href=""https://stackoverflow.com/questions/6693654/isalpha-giving-an-assertion"">it would even abort on MSVC debug builds</a>, but unfortunately just causes silent undefined behaviour (array access out of bounds) on glibc.</p>

<p>However, a compiler would be very loud about using <code>unsigned char *</code> or its alias as an argument to <code>strlen</code>, hence the cast.</p>
",23
52869153,52869121,6,"<p>Your output is ""corrupted"" because <code>buffer</code> does not contain a <kbd>NUL</kbd> terminated C string. Read more about <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>. Be <a href=""https://stackoverflow.com/a/46526702/841108"">scared</a> (UB sometimes <em>appears</em> to work, and that might explain what you experiment). </p>

<p>So before your call to <code>read</code> add <code>memset(buffer, 0, sizeof(buffer))</code> to clear your <code>buffer</code>. Or initialize it with <code>char buffer[11] ="""";</code> (both are nearly equivalent and likely, with optimizations enabled e.g. <code>gcc -O2</code>, to generate the same machine code). Since your buffer is 11 bytes long and you <code>read</code> at most 3 bytes you'll then be sure that it is <kbd>NUL</kbd> terminated after the <code>read</code>.</p>

<p>Be sure to compile with all warnings and debug info (so <code>gcc -Wall -Wextra -g lab1_4.c -o lab1_4</code> in your case). Read <a href=""https://ericlippert.com/2014/03/05/how-to-debug-small-programs/"" rel=""nofollow noreferrer""><em>How to debug small programs</em></a></p>

<p>Read carefully the documentation of <a href=""http://man7.org/linux/man-pages/man2/read.2.html"" rel=""nofollow noreferrer"">read(2)</a> and of every function you are using. Notice the return count from <code>read</code>. You should test and use it.</p>
",10
48489722,48489700,8,"<blockquote>
  <p>The operands shall be of integral or unscoped enumeration type and integral promotions are performed. The type of the result is that of the promoted left operand. <strong><em>The behavior is undefined</em></strong> if the right operand is negative, <strong><em>or greater than or equal to the length in bits of the promoted left operand.</em></strong></p>
</blockquote>

<p>C++11, ¡ì5.8 ?1 (emphasis added)</p>

<blockquote>
  <p>The integer promotions are performed on each of the operands. The type of the result is that of the promoted left operand. If the value of the right operand is negative or <strong><em>is greater than or equal to the width of the promoted left operand, the behavior is undefined</em></strong>.</p>
</blockquote>

<p>C99, ¡ì6.5.7 ?3 (emphasis added)</p>

<p>It's extremely likely that these rules were made exactly because the shift operators on existing platforms had this kind of limitations; without this rule in place, every shift of an unknown value would have to be transformed to code more complex than a simple underlying platform shift instruction, while it's expected for shifts to be extremely fast operations.</p>
",0
48527919,48527796,3,"<p>Simple steps. Start small and grow.</p>

<p>Easy one is to remove all questions to the user(s). Hard code the answers in the program. You can retrofit the IO later.</p>

<p>Start with a way ot generating 25 random numbers and load them into an array. Place the array in a global variable. You need a another array to show when a number is sucessfully guessed.</p>

<p>Now write a function to display that guessed array as 5X5.</p>

<p>Gradually build the program up</p>

<p><em>Always</em> make functions</p>

<ul>
<li>generate_array</li>
<li>show_guessed</li>
<li>....</li>
</ul>

<p>If get stuck on specific things then post a new question. </p>
",1
48528203,48527796,0,"<p>This is not a direct answer, but a very long comment with some requests for more information and effort.</p>

<p>The problem I have with your request is that I see zero effort.  I see a request for teh C0d3z and a promise not to cheat after receiving something that makes it far too easy to cheat.</p>

<p>What I, and probably others here, want to see is effort and some attempt.</p>

<ol>
<li>Do you know how to print text to the screen like you see in the requirements?  Do you know how to print text at all?  If so, make the print routines and state this.</li>
<li>Do you know how to generate random numbers?  If so, say so in your question and we see effort.</li>
<li>Do you know how to receive input from the user?</li>
<li>Do you know what an array is?</li>
<li>Do you know how to save code in your editor and compile it?</li>
</ol>

<p>You can see that without any sort of background or starting code, we don't know where you are in your learning.  </p>

<p>So...</p>

<p>Post an attempt at solving your problem in your question.  If you are truly so new to coding that you cannot do this, then you need to sit down with your professor / TA / whomever and tell them this.  Reading through your teaching material (textbook or whatever) should help a whole lot as well.  This assignment feels like something I would see towards the end of a beginner's C class.  If this is where you are, and you really have no clue what to do, then you may need to retake the class.</p>
",0
55055687,55055652,4,"<p><code>if (A &amp;&amp; B)¡­</code> does not mean:</p>

<ul>
<li>do this if A is true, and</li>
<li>do this if B is true.</li>
</ul>

<p>It means:</p>

<ul>
<li>do this if A is true and B is true.</li>
</ul>

<p>To make a condition so the <code>if</code> is triggered if A is true and is triggered if B is true, you use <code>A || B</code>. This means:</p>

<ul>
<li>do this if A is true or B is true.</li>
</ul>
",0
56083322,56081980,1,"<p>A do-while loop is probably the simplest method:</p>

<pre><code>int is_valid = 0;
do {
    // Get user input here
    is_valid = validate_input(...);
} while (! is_valid);

// Continue with processing...
</code></pre>
",0
55579857,55579569,2,"<p>I see several potential problems:</p>

<ol>
<li>You must reset <code>cpos</code> to zero when you encounter the whitespace.</li>
<li>Before the fprintf in the loop, you should be sure to nul-terminate the current str.</li>
<li>If the last character before EOF is <code>\n</code> or <code></code>, you will output a blank line at the end.</li>
<li>I don't know your dataset, but I'd still be mindful about exceeding 99 characters of input, as you could overflow the buffer the first time you encounter a word with 100 or more characters.</li>
</ol>
",0
53799138,53798275,2,"<ol>
<li><p>You don't need to check every single operation, only the ones that could overflow.  One obvious example is any operations based on untrusted input, but even then it may be more appropriate to do a sanity check on arguments instead of generically checking all math operations.</p>

<p>Ray's statement that ""¡­ unless it's really critical code (and I mean space shuttle guidance system or pacemaker controller levels of mission critical), my opinion is that those checks would be overkill most of the time ¡­"" is dangerous.  Yes, he's right that you don't need to check every operation, but you should always check the ones which can overflow.</p>

<p><a href=""https://undeadly.org/cgi?action=article&amp;sid=20060330071917"" rel=""nofollow noreferrer"">https://undeadly.org/cgi?action=article&amp;sid=20060330071917</a> has a good example of where this can bite you, even if you're not writing a space shuttle guidance system or pacemaker controller.</p>

<p>It's also worth noting that compilers can sometimes optimize away checks that it can prove will never fail.  For example, if you were to call <code>f()</code> with two constants and check the result, there is a decent chance that the compiler will completely optimize it away, especially at higher optimization levels.</p></li>
<li>The code suggested by CERT is portable, but generally not the fastest option.  GCC and clang have <code>__builtin_*_overflow</code> intrinsics, and on Windows there is an <code>&lt;intsafe.h&gt;</code>.  If a larger type is available (e.g., if you want to check the result of a 32-bit operation and you have 64-bit types available) it should be pretty quick to perform the operation using the larger type then cast back.  If you want some portable code to do it, there is a <a href=""https://github.com/nemequ/portable-snippets/tree/master/safe-math"" rel=""nofollow noreferrer"">safe-math module in portable-snippets</a> (disclaimer: my project) you can steal.</li>
<li>Static analysis tools can be very helpful here; several of them can detect potential integer overflows.  I know I've seen such errors from Coverity, and I think I've seen them from scan-build and cppcheck.</li>
</ol>
",1
53862004,53798275,0,"<blockquote>
  <p>although unsigned int behavior is undefined, [...]</p>
</blockquote>

<p>You are misunderstanding ""undefined"".  It really does mean undefined. There is no definition of behaviour. <em>Anything at all</em> can happen. You should not expect, let alone rely on, any particular behaviour as you describe in your answer. </p>

<p>Here are some of the possibilities:</p>

<ul>
<li>Appears to work like wraparound arithmetic</li>
<li>Appears to work like saturating arithmetic</li>
<li>Prints unexpected thing</li>
<li>Formats the hard drive</li>
<li>Launches missiles</li>
<li>Sets the computer on fire</li>
<li>(<em>anything else you want to put here</em>)</li>
</ul>

<p>See <a href=""https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior"">What is undefined behaviour?</a></p>
",0
49103185,49102869,0,"<blockquote>
  <p>j will just end up being j = 3 - i(2) which is 1</p>
</blockquote>

<p>Correct:</p>

<pre><code>#include&lt;stdio.h&gt;
int main(void)
{
 int i,j;    

 j = -3;
 for (i = 0; i &lt; 3; i++)
 {
    switch (j + 2)
    {  // j = -1 -&gt;

        case 3:
             printf(""3\n"");
        case 2: j--;
             printf(""2\n"");
        break;

        case 0: 
        j += 2;
             printf(""0\n"");
        break;

        default: 
        j = 0;
        printf(""j=%d  i=%d  default:\n"", j, i);
    }

    if (j &gt; 0){
          printf(""j&gt;0\n"");       
          break;
    }

    j = 3 - i;
    printf(""j=3-i  j=%d i=%d \n"", j, i);
  }

  printf(""j=%d  i=%d  END\n"", j, i);
  return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>j=0  i=0  default:
j=3-i  j=3 i=0 
j=0  i=1  default:
j=3-i  j=2 i=1 
j=0  i=2  default:
j=3-i  j=1 i=2 
j=1  i=3  END
</code></pre>

<p>Therefore, for the above code, the minimum simplification is:</p>

<pre><code>j = 1; 
i = 3;
</code></pre>
",3
53675753,53675716,2,"<p>This is valid.</p>

<p>The expression <code>age &gt; 40</code> evaluates to either 0 or 1, so you can use any integer type (<code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, either signed or unsigned) to store it.</p>
",10
56152298,56151251,1,"<p>There are two reasons.</p>

<ul>
<li><p>Everything inside the <code>{ ... }</code> of a <code>switch</code> resides in the same scope, unless you add further local scopes inside it. So you can't have two variables with the same name, for the same reason as you can't have:</p>

<pre><code>int main (void) 
{
  int a; int a; // will not compile
}
</code></pre></li>
<li><p>Grammatically, <code>case x:</code> works like a label. In the C syntax, it is formally called <em>labeled-statement</em> and a labeled-statement can only be followed by a <em>statement</em>, not a declaration. So you can't have a variable declaration directly after <code>case x:</code>, for the same reason as you can't have </p>

<pre><code>int main (void) 
{ 
  label: int a; // will not compile
}
</code></pre></li>
</ul>

<p>The best solution is to create another local scope per case. Or rename the variables. </p>
",0
49468465,49468257,2,"<blockquote>
  <p>why the inner-struct should be a pointer, with out the pointer it does not compile.</p>
</blockquote>

<p>The compiler needs to know the size of your data types, and it figures this out based on the size of their members.  It knows what the size of a pointer to a <code>struct</code> will be, even if it hasn't seen the <code>struct</code> yet, but it doesn't know the size of the <code>struct</code> itself.</p>

<blockquote>
  <p>Did I declared, and used the structs correctly?</p>
</blockquote>

<p>Looks fine at first glance.  Did you compile it?  Did your code run as you expected?</p>

<blockquote>
  <p>I have no idea what can be a potential use-case for such idiom. Can you give me some examples?</p>
</blockquote>

<p>A linked list is the simplest and most common example (a <code>struct</code> contains a pointer to a <code>struct</code> of the same type).</p>
",0
49468438,49468257,1,"<p>Think of a struct as a web page and the pointers you declare inside of it as the links on that web page. Replacing a pointer by a value is the same as if you would copy an entire secondary linked web page and paste it where the link in the primary web page was.</p>

<p>If you also have a link in the second web page that pointed back to the first one, you will have a document linking to itself after that copy/pasting.</p>

<p>Now if you think of doing the same (copy/paste) again with that ""ego""-pointing link, you would have to paste the web page into a copy of itself and yet you would never eliminate the back-pointing links because one more of this link appears with every copy. And, what's more the document would explode to infinite size.</p>

<p>For the C-Compiler it simply doesn't make any sense to reserve values cyclically into themselves because this would consume all your memory already at the start of your program. </p>

<p>If you leave it with the pointers however, there is no problem at all, like with  the two web pages linking back and forth to each other.</p>
",0
51199686,51199630,5,"<p>The variable <code>obj</code> resides at file scope, so it's initializer must be a compile time constant.  You're attempting to call a function instead.  That's not allowed, as that would otherwise mean code would be run (in this case calling a function) outside of a function.</p>

<p>You would need to move the code that assigns a value into the main function.</p>

<pre><code>#include&lt;stdio.h&gt;

struct test{
    int data;
};

typedef struct test* Test;

Test obj;

int main()
{
    obj = calloc(1,sizeof(struct test));
    return 0;
}
</code></pre>
",0
57292542,57292046,1,"<p>In C source code, <code>1024</code> is an <code>int</code>, and <code>1024L</code> is a <code>long int</code>. During an assignment, the value on the right is converted to the type of the left operand. As long as the rules about which combinations of operands are obeyed and the value on the right is in the range of the left operand, there is no difference¡ªthe value remains unchanged.</p>

<p>In general, a decimal constant without a suffix is an <code>int</code>, and a decimal constant with an <code>L</code> is a <code>long int</code>. However, if its value is too big to be represented in the usual type, it will automatically be the next larger type. For example, in a C implementation where the maximum <code>int</code> is 2147483647, the constant <code>3000000000</code> in source code will be a <code>long int</code> even though it has no suffix. (Note that this rule means the same constant in source code can have different types in different C implementations.) If a <code>long int</code> is not big enough, it will be <code>long long int</code>. If that is not big enough, it can be a signed extended integer type, if the implementation supports one.</p>

<p>The rules above are for decimal constants. There are also hexadecimal constants (which begin with <code>0x</code> or <code>0X</code>) and octal constants (which begin with <code>0</code>¡ª<code>020</code> is octal for sixteen, unlike <code>20</code> which is decimal for twenty), which may have signed or unsigned types. The different integer types are important because overflow and conversions behave differently depending on type. It is easy to take integer operations as a matter of course and assume they work, but it important to learn the details to avoid problems.</p>
",0
50998538,50998399,1,"<p>From the standard, <code>C11 7.21.6.2 The fscanf function /3 and /6</code>:</p>

<blockquote>
  <p>The format is composed of zero or more directives: one or more white-space 
  characters, an ordinary multibyte character (neither <code>%</code> nor a white-space character), or a conversion specification.</p>
  
  <p>A directive that is an ordinary multibyte character is executed by reading the next characters of the stream. If any of those characters differ from the ones composing the directive, the directive fails and the differing and subsequent characters remain unread.</p>
</blockquote>

<p>Hence the <code>:</code> simply means ""make sure that the next character in the stream is a colon"". Nothing more, nothing less.</p>

<p>Your format <em>string</em> simply means you'll be able to scan things like <code>12:34:56am</code> - without the literal colons in the format string, the scan would fail.</p>
",0
52599043,52598598,0,"<p>Replace</p>

<pre><code>        if(isdigit(atoi(token[1])) != 0){
            val = atoi(token[1]);
        }
</code></pre>

<p>with </p>

<pre><code>        if(isdigit(token[1][0])) != 0){
            val = atoi(token[1]);
        }
</code></pre>

<p>The problem is that isdigit takes a character as its argument.  Sure, the man page says it takes an integer, but that integer represents a character.</p>

<p>What your code is doing is:</p>

<ol>
<li><p>convert token[1] to an integer (or 0 if it's not a valid integer)</p></li>
<li><p>determine whether that integer happens to match an ASCII digit</p></li>
<li><p>If so, convert it again, and save the value.</p></li>
</ol>

<p>I doubt that's your intent.</p>

<p>My version checks whether the first character of token[1] is a digit, and converts the value if it is.  Make sure you understand what token[1][0] means.</p>

<p>BTW, note that if you enter more than 5 space-separated words in your string, you'll store to tokens[6] and higher, which will produce undefined results (possibly crash.)  Also, your program is wrong if the user enters more than two spaces between words.</p>

<p>Don't guess what strtok is going to do regarding how it detects and handles delimiters.  Instead, let it do its job.  Store the values as you get them.  Either pick a limit value for the array where you're storing your results and exit the loop before exceeding it, or malloc space for more results as necessary.  Here's an example:</p>

<pre><code>    char * tstr = str;
    int tok_count = 0;
    char *tok;
    do {
        tok = strtok(tstr, "" "");
        if (tok != NULL) {
            token[tok_count++] = tok;
        }
        tstr = NULL;
    } while (tok != NULL &amp;&amp; tok_count &lt; TOK_COUNT);
</code></pre>

<p><code>TOK_COUNT</code> has to be at least 1, and should be the array size for <code>tokens</code>.</p>
",7
49015760,49015387,0,"<p>Another approach would be to use <code>fgets</code>.</p>

<pre><code>int main(int argc, char **argv) 
{
   char buffer[BUFSIZ];
   FILE *file;
   file = fopen(argv[1], ""r"");
   if (file)
   {
      // Read BUFSIZ-1 number of characters at a time.
      while ( fgets(buffer, BUFSIZ, file) != NULL )
      {
         for ( size_t i = 0;  buffer[i] != '\0'; ++i )
         {
            char c = buffer[i];
            if (c != 'a')
            {
               putchar(c);
            }
         }
      }
   }
}
</code></pre>

<p>If the file contains binary data, you can use <code>fread</code> instead of <code>fgets</code>.</p>

<pre><code>int main(int argc, char **argv) 
{
   char buffer[BUFSIZ];
   FILE *file;
   file = fopen(argv[1], ""r"");
   if (file)
   {
      // Read BUFSIZ number of characters at a time.
      size_t n = 0;
      while ( (n = fread(buffer, 1, BUFSIZ, file)) &gt; 0 )
      {
         for ( size_t i = 0;  i &lt; n; ++i )
         {
            char c = buffer[i];
            if (c != 'a')
            {
               putchar(c);
            }
         }
      }
   }
}
</code></pre>
",0
49015522,49015387,1,"<p>Something like this should get you started....</p>

<pre><code>FILE *fp = fopen(argv[1], ""r"");
if (fp)
{
  fseek(fp, 0, SEEK_END);
  size_t flen = ftell(fp);
  fseek(fp, 0, SEEK_SET);
  char *fbuf = (char*)malloc(flen + 1); // +1 to add a nul-term at the end
  if (!fbuf)
  {
     fprintf(stderr, ""Out of memory trying to read file\n"");
     exit(1);
  }
  if (fread(fbuf, 1, flen, fp) != flen) // read the whole file at once
  {
     fprintf(stderr, ""Error reading file\n"");
     exit(1);
  }
  fbuf[flen] = '\0'; // nul-term the buffer in case you use ""str"" functions on it
  fclose(fp);
  ...
</code></pre>
",0
49377530,49377469,1,"<p>There are a couple of issues with your example code. First you are not incrementing the value of <code>i</code> inside the while loop which is creating an infinite loop.  As Jonathan has suggested in the comments you'd be better off using a <code>for</code> loop instead of a <code>while</code> loop.</p>

<p>Secondly, you can't increment an array in C. When I try to compile your example using <code>clang</code> I get <code>error: array type 'char [21]' is not assignable</code></p>

<p>You can achieve your goal by doing the pointer arithmetic in the <code>printf</code> statement rather than trying to save the new value back into <code>a</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char a[] = ""1234:once:echo hello"";
    int i;

    for (i = 0; i &lt; strlen(a); i++) {
       if(a[i] == ':') {
            break;
        }
    }

    printf(""%s\n"", a + i);
}
</code></pre>
",2
49375142,49374965,0,"<p>This should work for you. I added a nested <code>for</code> inside of the <code>while</code>, to loop through <code>buf</code> and check for the <strong>'#'</strong> hash character. You should always be sure to check if the necessary file exists or not, instead of assuming that it does.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv) {
    FILE *file;
    if (!(file = fopen(argv[1], ""r""))) {
        fprintf(stderr, ""The specified file does not exist\n"");
        return 1;
    }
    char buf[100];
    int x;
    while (fgets(buf, sizeof(buf), file)) {
        for (x = 0; x &lt; sizeof(buf); x++) {
            if (buf[x] == '#')
                buf[x] = '\0';
        }
        if (strncmp(buf, "":once:"", 6) == 0)
            printf(""%s\n"", buf + 6);
        else
            printf(""%s\n"", buf);
    }
    fclose(file);
    return 0;
}
</code></pre>
",0
49375079,49374965,1,"<p>You should change <code>char p;</code> to <code>char *p;</code>, otherwise this is not going to work at all. If you're looking for <code>:once:</code> only at the start of a line, you can use <code>strncmp()</code> to check the first six characters, and offset the start of the string if necessary.</p>

<p>Also, since <code>fgets()</code> retains line break characters, you may as well add <code>\n</code> and <code>\0</code> when you encounter a <code>#</code> symbol, and then leave out the <code>\n</code> when printing each line. That way your output won't be filled with double line breaks.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv) {

    FILE *file = fopen(argv[1], ""r"");
    char buf[100];
    char *p;
    while (fgets(buf, sizeof(buf), file)) {
        if ((p = strchr(buf, '#'))) {
            *(p++) = '\n';
            *p = '\0';
        }
        printf(""%s"", buf + (strncmp(buf, "":once:"", 6) == 0 ? 6 : 0));
    }
    fclose(file);
}
</code></pre>
",0
52308355,52305502,0,"<p>You have to tell <code>gcc</code> preprocessor where to find files you want to include.</p>

<p>You have two kinds of header:</p>

<ul>
<li>System headers: included with <code>#include &lt;header&gt;</code>. </li>
<li>Local headers: included with <code>#include ""header""</code>. </li>
</ul>

<p>Preprocessor searchs in <strong>header search path</strong> to find system headers.
Preprocessor searchs in current directory, then in header path to find local headers.</p>

<p>You can add folders in <strong>header search path</strong> using <code>-I</code> option in <code>gcc</code> invocation.</p>

<p>So in your case, you can compile with these commands:</p>

<pre><code>$gcc -I C:\Users\Admin\CLionProjects\project\include C:\Users\Admin\CLionProjects\project\src\main.c
</code></pre>

<p>or</p>

<pre><code>$cd C:\Users\Admin\CLionProjects\project\src
$gcc -I ..\include main.c
</code></pre>
",0
58972280,58972156,1,"<p>You can't do it with <code>[]</code> but you can do this:</p>

<pre><code>#define COMSS_GETNBERNEWVALUE(a)   uca##a##_NbreReceivedValue
</code></pre>

<p>Then <code>COMSS_GETNBERNEWVALUE(1)</code> will be substituted with <code>uca1_NbreReceivedValue</code>, <code>COMSS_GETNBERNEWVALUE(2)</code> will be substituted with <code>uca2_NbreReceivedValue</code> etc.</p>

<p>Bu you cannot use this method if instead of having <code>uca1_NbreReceivedValue</code>, <code>uca2_NbreReceivedValue</code> etc. you have <code>ucaFirst_NbreReceivedValue</code>, <code>uca1_NbreReceivedValue</code>.</p>
",2
54383672,54383495,0,"<p>C is a low-level programming language and the behavior around using memory through C variables might be a bit confusing to programmers coming from languages with higher level abstractions.</p>

<p>Let's break down your <code>main</code> function first.</p>

<pre><code>int p[32];
</code></pre>

<p>When a function is called in your program, it gets allocated some section in RAM assigned to your process. This section is called the stack. With this statement, you're telling the compiler that your function (<code>main</code>) needs space for 32 integers in stack. Further statements you make with the variable <code>p</code> will be operating on this space reserved for the 32 integers.</p>

<p>Note that, you're not telling anything to the compiler on how this portion of memory assigned for <code>p</code> is initialized. So all these bytes allocated for 32 integers will store whatever they contained before your function is called.</p>

<p>Let's look at the next one.</p>

<pre><code>int *q = p + 5;
</code></pre>

<p>This is very similar but now you are asking for some memory in stack with a size that can fit ""a pointer to a integer"". Pointer is the C abstraction for bare ""memory address with a type"". So this space will be used to store addresses in memory, and these addresses will refer to another space in RAM that is intended to store integers.</p>

<p>You are also telling the compiler to initialize the stack space for <code>q</code>, with the value of <code>p + 5</code>. Unlike the space for the 32 integers above (<code>p</code>), the space for <code>q</code> will be initialized right after your function is called.</p>

<p>The expression <code>p + 5</code> is applying what is called ""pointer arithmetic"". This is used to take an address in RAM, and go up or down based on whatever offset we need. Remember, <code>p</code> was an array and arrays in C work like pointers (addresses) when they take part in pointer arithmetic. Thus, what <code>p + 5</code> really means is the ""address that is 5 integers after the first address p points to"". This ends up being the ""pointer to the sixth element of <code>p</code>"" (first being <code>p[0]</code>), in other words, the address of <code>p[5]</code>.</p>

<pre><code>f(q);
</code></pre>

<p>In this statement, you are passing the address stored in <code>q</code>, which happened to be the address of the sixth element in <code>p</code>. The function <code>f</code> in return assigns <code>35</code> to the location in RAM pointed by this address, hence changing the integer that would be accessed by <code>p[5]</code> to the integer value of <code>35</code>.</p>

<p>Right at this point, <code>p[5]</code> is the only element within <code>p</code> that has an initialized value. All other integers in <code>p</code> will continue to store what they held before <code>main</code> was called during the initialization of your program.</p>

<pre><code>printf( ""%d"", p[5] );
</code></pre>

<p>When the execution returns back to <code>main</code>, the integer that can be accessed by <code>p[5]</code> is now set to <code>35</code>, and that is exactly what you expect to see with this <code>printf</code> statement.</p>
",0
48087558,48085841,0,"<pre><code>char *(*scan)(char *, char *, char *, char *, int , int);
</code></pre>

<p>This defines a function pointer <code>scan</code>, which points to a function that accepts four <code>char *</code> and two <code>int</code> parameters, and returns a <code>char *</code>.</p>

<p>That means you can do things like:</p>

<pre><code>char *scanLeft(char *p1, char *p2, char *p3, char *p4, int p5, int p6) {
    // do something
}
char *scanRight(char *p1, char *p2, char *p3, char *p4, int p5, int p6) {
    // do something else
}
:
scan = scanLeft;  char *xyzzy = scan(""a"", ""b"", ""c"", ""d"", 271828, 314159);
scan = scanRight; char *plugh = scan(""a"", ""b"", ""c"", ""d"", 271828, 314159);
</code></pre>

<p>and the two calls via the <code>scan</code> function pointer will go to <em>different</em> functions.</p>
",0
50714840,50712999,1,"<p>Problem is that you are copying wrongly. Remember that indices of letters in a C-string <code>s</code> are from 0 to <code>strlen(s)-1</code> (all included) and that you have ASCII NUL at <code>strlen(s)</code>.
But your loop:</p>

<pre><code>for (i=0;i&lt;size;i++){
   str[size-i]=string[i];
</code></pre>

<p>fills indices from <code>strlen(string)</code> to 1 (size-(size-1)), thus <code>str[0]</code> is left uninitialized. Then trying to print <code>str</code> leads to <strong>Undefined Behavior</strong>, on many environement, <code>str[0]</code> will be 0 and then make <code>str</code> correspond to the empty string, but this is not guaranteed.</p>

<p>Solution can be:</p>

<pre><code>#include &lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

int main(){
  char string[]=""hello"";
  char *str;
  int size,i;

  size=strlen(string);
  str=(char*)malloc(size+1);
  for(i=0;i&lt;size;i++){
    str[size-1-i] = string[i]; // Copying in reverse
  }
  str[size]='\0'; // end of string
  printf(""The reversed string is %s\n"",str); // Displaying the reversed string
}
</code></pre>

<p>Note:  you are not reversing the string, you are just building another string that is the reverse of the given one.</p>
",0
58619708,50575751,1,"<p>First, what's so bad about creating your own repository of test files? You can even write a program in bash or something to run your sudoku game on all of your input files automatically to check if your code still works.</p>

<p>If you are working with <code>FILE*</code> pointers, though, you can likely use <code>fmemopen</code> in test code to create an in-memory stream that you can use with <code>fread</code>, etc.</p>

<p>If you are working with <code>fd</code>s, you can do something similar with <code>pipe</code>. Write into one end, read from the other.</p>
",0
49444625,49444355,2,"<p>Probably you use an old version of gcc. Before version 5.x, gcc defaults to a non-standard called ""gnu90"", which is a non-standard version of the obsolete C90 standard. There is no reason to ever use gnu90 unless you are maintaining some old Linux code. To avoid this, compile with:</p>

<pre><code>-std=c11 -pedantic-errors
</code></pre>

<p><code>-std=c11</code> meaning you want the compiler to use the current C standard, without involving gnus or other strange animals. <code>-pedantic-errors</code> means that you want it to actually follow the standard and not just pretend to do it.</p>

<p>In order to get the warning for no return from functions, you need to use the option <code>-Wreturn-type</code>, which is included by using <code>-Wall</code>. Always compile with</p>

<pre><code>-Wall -Wextra
</code></pre>

<p>Note that ""Wall"" does not stand for ""all warnings"", as it leads you to believe. Rather, <code>-Wall</code> means a fistful of warnings and <code>-Wextra</code> means a few warnings more.</p>
",0
54732122,54731842,1,"<p>Based on the line <code>21</code>, the next line to be generated is <code>1211</code>. To store this line in the computer's memory, you need 4 bytes for the visible characters, plus 1 byte for the terminating NUL character <code>'\0'</code>.</p>

<p>In your current code, you reserve an array of fixed length, having space for 1 visible character plus the terminating <code>'\0'</code>. This is not enough.</p>

<p>Your code overwrites this array, plus the memory after it, which invokes <em>undefined behavior</em> and may or may not crash your program, now or at any later time. C is a nasty programming language in this regard.</p>

<p>Sadly, C doesn't offer any data structure like a <code>StringBuffer</code> or a <code>StringBuilder</code>, therefore you have to do that yourself. The basic ingredient is the <code>malloc</code> function that allocates memory for you. A safe bet would be to say:</p>

<pre><code>char *line_new = malloc(2 * strlen(line) + 1);
</code></pre>

<p>This gives you enough space. When you don't need this space anymore, you must call <code>free(line_new)</code>, otherwise your program will quickly use up all your computer's memory.</p>
",0
49784072,49783903,5,"<p>If you must ""fold"" a 2D matrix into a ""flat"" array, use the allocation line that your professor suggested (after removing the <a href=""https://stackoverflow.com/q/605845/335858"">unnecessary cast</a>) and make a pair of functions for accessing the matrix:</p>

<pre><code>float get(const float *m, size_t width, size_t r, size_t c) {
    return m[r*width+c];
}
void set(float *m, size_t width, size_t r, size_t c, float val) {
    m[r*width+c] = val;
}
</code></pre>

<p><strong>Note:</strong> The above illustrates packing the matrix in <a href=""https://en.wikipedia.org/wiki/Row-_and_column-major_order"" rel=""nofollow noreferrer"">row-major order</a>; column-major order is another possibility.</p>
",1
50395771,50394407,1,"<p>You probably want this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  char string[] = ""/user/doc/file1"";

  // find pointer to last '/' in string
  char *lastslash = strrchr(string, '/');

  if (lastslash)           // if found
    *(lastslash + 1) = 0;  //   terminate the string right after the '/'

  printf (""string = %s\n"", string);
}
</code></pre>

<p>Output</p>

<pre><code>string = /user/doc/
</code></pre>
",2
50417621,50417055,2,"<p>The <code>static</code> keyword serves double duty here.  It specifies that the <em>object</em> has static storage duration - that is, storage for the object is allocated when the program starts and released when the program exits.</p>
<p>It also specifies that the <em>identifier</em> for that object has <em>internal linkage</em>.  IOW, the identifier is not exported to the linker (it is effectively &quot;private&quot; to that translation unit).</p>
<p><a href=""http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">Chapter and verse</a>:</p>
<blockquote>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>6.2.2 Linkages of identifiers</strong><br><br>
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An identifier declared in different scopes or in the same scope more than once can be
made to refer to the same object or function by a process called <em>linkage</em>.<sup>
29)</sup> There are
three kinds of linkage: external, internal, and none.<br><br>
2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In the set of translation units and libraries that constitutes an entire program, each
declaration of a particular identifier with <em>external linkage</em> denotes the same object or
function. Within one translation unit, each declaration of an identifier with <em>internal
linkage</em> denotes the same object or function. Each declaration of an identifier with <em>no
linkage</em> denotes a unique entity.<br><br>
3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the declaration of a file scope identifier for an object or a function contains the storage class
specifier <strong><code>static</code></strong>, the identifier has internal linkage.<sup>30)</sup>
<hr>
<sup>
29) There is no linkage between different identifiers.<br>
30) A function declaration can contain the storage-class specifier <strong><code>static</code></strong> only if it is at file scope; see
6.7.1.</sup>
</blockquote>
<p>If you want an object to have static storage duration, but also have its identifier visible to other translation units, then you must declare it at file scope <em>without</em> the static keyword:</p>
<pre><code>#include &lt;stdio.h&gt;

int i_am_static_and_visible;
static int i_am_static_but_not_visible;

void foo( void )
{
  static int i_am_static_but_not_visible_either;
  ...
}
</code></pre>
",0
48325412,48324879,4,"<p>The problem is in the line</p>

<pre><code>ch3 = &amp;ch1; 
</code></pre>

<p>The expression <code>&amp;ch1</code> has type ""pointer to 6-element array of <code>char</code>"", or <code>char (*)[6]</code>.  <code>ch3</code> has type <code>char *</code>.  The two types are not compatible, hence the error.  To fix this, drop the <code>&amp;</code> from <code>&amp;ch1</code>:</p>

<pre><code>ch3 = ch1;
</code></pre>

<p>The expression <code>ch1</code> has type ""6-element array of <code>char</code>"", or <code>char [6]</code>.  Since it's not the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, it will be converted (""decay"") to an expression of type <code>char *</code>, and the value of the expression will be the address of the first element of the array.</p>

<p>There are other issues with this code, but that's what's causing your error.</p>
",0
49930217,49929638,1,"<p>Swapping variables is idiomatically done inline with a temporary:</p>

<pre><code>char *temp;
temp = first;
first = last;
last = first;
</code></pre>

<p>This doesn't translate well into a C function call, which uses pass by value. This means the function receives a copy of the value as its parameters. You could write a macro instead, but a general purpose macro has to take care of issues like arguments being expressions, and avoid name collisions of its own internal variables from the parameters being passed in.</p>

<pre><code>#define swap(A, B) do {            \
    char **swap_A__ = &amp;(A);        \
    char **swap_B__ = &amp;(B);        \
    char *swap_temp__ = *swap_A__; \
    *swap_A__ = *swap_B__;         \
    *swap_B__ = swap_temp__;       \
} while (0)
</code></pre>

<p>This saves you from writing a function, but the implementation loses the simplicity of the idiomatic approach.</p>

<p>While the function call would be preferred, it loses the appearance of a pass by reference interface. If you were able to implement a generic swapping function:</p>

<pre><code>void swap_generic(void *a, void *b, size_t sz);
</code></pre>

<p>Then, you could wrap your swap macro to call the generic function, and give you the ability to simulate a ""call by reference"" interface, but passing the appropriate arguments to the generic function:</p>

<pre><code>#define swap(A, B) do {                                    \
    _Static_assert(sizeof(A) == sizeof(B), ""unswappable""); \
    _Static_assert(sizeof(&amp;(A) - &amp;(B)), ""type check"");     \
    swap_generic(&amp;(A), &amp;(B), sizeof(A));                   \
} while (0)
</code></pre>

<p>Implementing the generic swapping function could be done as follows:</p>

<pre><code>void swap_generic (void *a, void *b, size_t sz) {
    char *aa = a;
    char *bb = b;
    while (sz--) {
        char temp = *aa;
        *aa++ = *bb;
        *bb++ = temp;
    }
}
</code></pre>
",0
49929704,49929638,11,"<p>In C, all parameters are pass by value.  That means that <code>first</code> and <code>last</code> in the function are distinct from <code>first</code> and <code>last</code> in <code>main</code>.  Changes to a local variable are not reflected in the caller.</p>

<p>You need to pass the <strong>address</strong> of the variables you want to change.  Then in the function, you dereference the given pointers to change what they point to.</p>

<p>So change your function as follows:</p>

<pre><code>void swap(char ** first, char ** last) {
  char * temp;
  temp = *first;
  *first = *last;
  *last = temp;
  printf(""at end of swap func the first name is: %s\n"", *first);
  printf(""at end of swap func the last name is: %s\n"", *last);
}
</code></pre>

<p>And call it like this:</p>

<pre><code>swap(&amp;first, &amp;last);
</code></pre>

<p>Note that what's actually being swapped are the <em>pointer values</em>, not what the pointers actually point to.  You could swap the characters between the two strings, but the strings in question are <strong>string literals</strong> which cannot be modified.</p>

<p>If you had <code>char</code> arrays that contained strings, then you could swap the characters.  In fact, you would have to do it that way because arrays are not the same as pointers.</p>

<p>Here's a full example of how you would do a full string swap:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// assumes that each array is big enough to hold the contents of the other
void swap(char *first, char *last) {
  int len1 = strlen(first);
  int len2 = strlen(last);
  int maxlen = (len1 &gt; len2) ? len1 : len2;
  char temp[maxlen+1];
  strcpy(temp, first);
  strcpy(first, last);
  strcpy(last, temp); 
  printf(""at end of swap func the first name is: %s\n"", first);
  printf(""at end of swap func the last name is: %s\n"", last);
}

int main() {
  char first[10] = ""Joe"";
  char last[10] = ""Bloggs"";
  printf(""The original format: %s %s\n"", first, last);
  swap(first, last);
  printf(""The new format: %s %s"", first, last);
}
</code></pre>
",2
50062404,50062327,2,"<p>This is usually done like so, quite simply:</p>

<pre><code>bool withinRange(double input1, double input2, double deviation)
{
  return fabs(input1 - input2) &lt;= deviation;
}
</code></pre>

<p>Note that the C Boolean type is called <code>bool</code>. I edited to make the answer include the boundary, that is more intuitive so it might make it easier to verify.</p>

<p>Basically the absolute value of a subtraction is the distance between the two terms, so we compute that and compare it against the limit.</p>
",0
52039174,52039096,7,"<p>The <code>fgetc</code> function returns an <code>int</code>, and the value will be <code>EOF</code> at end of file. This is the typical approach:</p>

<pre><code>int c;
while ((c = fgetc(cfl)) != EOF) {
    ...
}
</code></pre>
",2
52713737,52713488,2,"<p>Despite your <code>for</code> loop making no sense at all, you are approaching the problem in a very awkward way. When your goal is read a line of data, then you should be thinking about using a <em>line-oriented</em> input function and not reading individual integers.</p>

<p>For instance if the user wants to enter data for 4-jobs, then you can either read and validate 3 integers per-job, or simply require each job data to be entered on a single line and then read the line and write the line to a file.</p>

<p>You do this very simply by providing a buffer of sufficient size to hold all the anticipated characters the user will enter on each line (<em>don't skimp on buffer size</em>). Then simply read each line with one of the <em>line-oriented</em> input functions like <code>fgets</code> or POSIX <code>getline</code> and then write the line back out to your output file using <code>fputs</code> (<code>fgets</code> and <code>fputs</code> make a good combination here)</p>

<p>For example, to minimally handle your circumstance, you could do:</p>

<pre><code>#include &lt;stdio.h&gt;

#define MAXC  1024
#define OFILE ""jobs.txt""

int main (void) {

    char buf[MAXC];
    int nlines = 0, n = 0;
    FILE *fp = fopen (OFILE, ""w"");

    if (!fp) {  /* validate file is open for writing */
        perror (""fopen-file open failed"");
        return 1;
    }

    printf (""How many Jobs? "");
    if (scanf (""%d"", &amp;nlines) != 1) {
        fputs (""error: invalid integer input.\n"", stderr);
        return 1;
    }
    fgets (buf, MAXC, stdin);   /* read and discard trailing '\n' */

    while (n &lt; nlines &amp;&amp; fgets (buf, MAXC, stdin)) { /* read lines */
        fputs (buf, fp);    /* write lines  */
        n++;                /* update count */
    }
    if (fclose(fp) == EOF)
        perror (""fclose-stream error"");

    return 0;
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/fgets_fputs
How many Jobs? 4
10 13 12
20 39 10
7 29 13
13 18 19
</code></pre>

<p><strong>Example Output File</strong></p>

<pre><code>$ cat jobs.txt
10 13 12
20 39 10
7 29 13
13 18 19
</code></pre>

<p>Now beyond simply reading each line of data entered by the user, it would be wise to validate that each contained 3-integers before writing to the file, and if not providing an error and require the user to re-input the data. It takes little more effort, e.g.</p>

<pre><code>    /* no changes above */
    ...
    fgets (buf, MAXC, stdin);   /* read and discard trailing '\n' */

    printf ("" enter data for job[%2d]: "", n + 1);   /* prompt for data */
    while (fgets (buf, MAXC, stdin)) { /* read lines */
        int i1, i2, i3;
        /* validate 3-integers provided */
        if (sscanf (buf, ""%d %d %d"", &amp;i1, &amp;i2, &amp;i3) == 3) {
            fputs (buf, fp);    /* write lines  */
            n++;                /* update count */
        }
        else    /* otherwise, handle error */
            fputs (""  error: invalid input.\n"", stderr);

        if (n &lt; nlines) /* if lines remain to read, prompt */
            printf ("" enter data for job[%2d]: "", n + 1);
        else    /* otherwise break the loop */
            break;
    }
    ...
    /* no changes below */
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/fgets_fputs
How many Jobs? 4
 enter data for job[ 1]: 10 13 12
 enter data for job[ 2]: 20 39
  error: invalid input.
 enter data for job[ 2]: 20 39 10
 enter data for job[ 3]: 7 29 13
 enter data for job[ 4]: 13 18 xjf;slfj (cat steps on keyboard)
  error: invalid input.
 enter data for job[ 4]: 13 18 19
</code></pre>

<p>The output file is the same.</p>
",0
49971713,49970614,0,"<p>You can quite easily implement such a function yourself.</p>

<p>Let's steal the interface (mostly) from POSIX.1 <a href=""http://man7.org/linux/man-pages/man3/getline.3.html"" rel=""nofollow noreferrer""><code>getline()</code></a>, as it is known to work well. So:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

size_t get_ints(int **dataptr, size_t *sizeptr, FILE *in)
{
    int    *data;
    size_t  size, used = 0;
    int     value;

    /* Invalid parameters? None may be NULL. */
    if (!dataptr || !sizeptr || !in) {
        errno = EINVAL;
        return 0;
    }

    /* Has an error in the input stream already occurred? */
    if (ferror(in)) {
        errno = EIO;
        return 0;
    }

    /* Has data already been allocated? */
    if (!*dataptr || !*sizeptr) {
        /* No, not yet. */
        *dataptr = NULL;
        *sizeptr = 0;
    }
    data = *dataptr;
    size = *sizeptr;

    /* Read loop. */
    while (1) {

        /* Try reading one int. */
        if (fscanf(in, "" %d"", &amp;value) != 1)
            break;

        /* Have one. Make sure data array has room for value. */        
        if (used &gt;= size) {
            /* Reallocation policy. We need at least size = used + 1,
               but realloc() calls are relatively slow, so we want
               to allocate in larger chunks. This is just one typical
               policy. */
            if (used &lt; 255)
                size = 256; /* Minimum allocation is 256 ints. */
            else
            if (used &lt; 1048575)
                size = (3 * used) / 2;  /* Grow by 50% ... */
            else
                size = (used | 1048575) + 1048577; /* up to 1048576, after which round up to next multiple of 1048576. */

            data = realloc(data, size * sizeof data[0]);
            if (!data) {
                /* Note: original data in *data still exists! */
                errno = ENOMEM;
                return 0;
            }

            *dataptr = data;
            *sizeptr = size;
        }

        /* Append to array. */
        data[used++] = value;
    }

    /* An actual I/O error? */
    if (ferror(in)) {
        errno = EIO;
        return 0;
    }

    /* No, either an end of stream, or the next stuff
       in the stream is not an integer. 
       If used == 0, we want to ensure the caller knows
       there was no error. For simplicity, we avoid that
       check, and simply set errno = 0 always. */
    errno = 0;
    return used;
}
</code></pre>

<p>The interface to the above <code>get_ints()</code> function is simple: it takes a pointer to a dynamically allocated array, a pointer to the size (in ints) allocated for that array, and the stream handle, and returns the number of ints read from the stream. If an error occurs, it returns 0 with <code>errno</code> set to indicate the error. (<code>getline()</code> returns <code>-1</code> instead.)</p>

<p>If no error occurs, this particular implementation sets <code>errno = 0</code>, but do note that this behaviour is uncommon; normally, you can only expect <code>errno</code> to have a valid error number when the function returns the error code (usually -1, but zero for this function).</p>

<p>The way you use this function is very easy. For example, let's assume you want to read an array of ints from the standard input:</p>

<pre><code>int main(void)
{
    int    *iarray = NULL; /* No array allocated yet, */
    size_t  isize  = 0;    /* so allocated size is zero, and */
    size_t  icount = 0;    /* no ints in it yet. */

    icount = get_ints(&amp;iarray, &amp;isize, stdin);
    if (!icount) {
        /* No ints read. Error? */
        if (errno)
            fprintf(stderr, ""Error reading from standard input: %s.\n"", strerror(errno));
        else
            fprintf(stderr, ""No integers in standard input.\n"");
        return EXIT_FAILURE;
    }

    printf(""Read %zu integers from standard input.\n"", icount);

    /*
     *  Do something with the integers...
    */

    /* Discard the dynamically allocated array. */
    free(iarray);
    iarray = NULL;
    isize  = 0;
    icount = 0;

    return EXIT_SUCCESS;
}
</code></pre>

<p>Note that as long as you initialize your <code>iarray = NULL</code> and <code>isize = 0</code> when declaring it, the <code>get_ints()</code> function will allocate as much memory as is needed for the ints it reads. It is also then always safe to do <code>free(iarray); iarray = NULL; isize = 0;</code> to discard the array, even if <code>iarray</code> was NULL, because <code>free(NULL)</code> is safe to do (does nothing).</p>

<p>This is an excellent way of doing memory management in C. If you do it this way -- initialize your pointers to <code>NULL</code>, then <code>free()</code> them and reset them to <code>NULL</code> after they are no longer needed -- your programs won't have memory leaks or crash due to use-after-free or similar bugs. Many instructors won't bother, because they erroneously think that sort of carefulness can be tacked on later, <em>if necessary</em>.</p>

<p>(Do note, however, that even in the above program, in the error cases where the program is about to abort/exit/return, there is no such cleanup done. This is because the operating system will release all resources automatically. [Except for shared memory and filesystem objects.] Simply put, if your program is guaranteed to exit, it is not necessary to free dynamically allocated memory.)</p>
",0
54012440,54012242,2,"<blockquote>
  <p>Question 1: Here, I've passed the pointer to the function and I keep thinking, ""What is this loop iterating over?"". Am I correct in thinking that I am incrementing the pointer to each of the first elements in each array (myArr[0][0], myArr[1][0], myArr[2][0], myArr[3][0])? </p>
</blockquote>

<p>more or less.  <code>pt</code> starts at the address of <code>myArr</code>.  You know there's 4 things in the array so you loop 4 times, incrementing <code>pt</code> after accessing it (read below) every time to pass to <code>printMyArr</code> each of the 4 elements of the ""top level"", ""outer"" array.  Then  <code>printMyArr</code> iterates over the 4 elements of the inner array to show each number.  </p>

<blockquote>
  <p>Also, am I correct in assuming that the syntax of this line is in essence saying: ""Execute the function passing the current pointer and THEN when it's done increment the pointer.""?</p>
</blockquote>

<p>Functionally, yes.  Technically the order of operations looks like this:</p>

<p>1) get the value of <code>pt</code>
2) increment <code>pt</code>
3) call function, passing the previous value of <code>pt</code> from step 1</p>

<p><code>pt</code> is incremented as part of the <code>pt++</code> call, but <code>pt++</code> evaluates to the old value.  As an argument to a funciton, <code>pt++</code> must be evaluated <em>before</em> the function it's passed to runs.  But the timing looks the same as it evaluating directly after the function runs for your case.  </p>

<p>Let's take questions 2 and 3 together because they're both part of the answer.</p>

<blockquote>
  <p>Question 2: This is what has me the most confused. After quite a bit of digging I found this bit to make it run right and I realize this is how it works, but why?</p>
  
  <p>Question 3: Am I correct thinking that I am incrementing each element here?</p>
</blockquote>

<pre><code>p = (int *)pt;          
for(counter=0; counter&lt;4; counter++)
    printf(""\n\n\n%d"", *p++);  
</code></pre>

<p><code>p</code> stores an address of an integer.  You set it to the address of the first element of the inner array (which is the address of the inner array itself, so to speak).  Then, knowing you have 4 elements in the array, you'r able to loop 4 times, doing a similar pointer post-increment operation on <code>p</code> that you did with <code>pt</code> on the outer array.</p>

<p>The first iteration, <code>p</code> is the same as <code>pt</code>, the address of the first of 4 integer values in memory.  <code>*p</code>, dereferencing the pointer, gets the first integer.  <code>*p++</code>, due to order of operations ( ++ being of the highest precedence, and dereferencing * being lower), returns the integer at <code>p</code>, leaving <code>p</code> pointing to the next integer address for the next loop.    </p>

<p>In general, <a href=""https://gustedt.wordpress.com/2014/04/02/dont-use-casts-i/"" rel=""nofollow noreferrer"">casting values in C should be avoidid whenever possible</a>.  You merely have to do a dereference here to point <code>p</code> to the set of integers.    <code>pt</code> holds the address of one of 4 addresses ( outer array ) of contiguous sets of 4 integers (inner array) in memory.  The value at <code>*pt</code> is the address of the ""current"" set of 4 contiguous integers in memory.  So you can simply say, </p>

<pre><code>int* p=*pt;
</code></pre>

<p>Which doesn't arbitrarily cast a type and is very straightforward and clear.  (Thanks @WhozCraig)</p>
",9
55544665,55544459,1,"<p>As <a href=""https://stackoverflow.com/users/10953328/taegyung"">Taegyung</a> points out, a simple method is:</p>

<pre><code>int c;
int LineNumber = 1;
printf(""%d "", LineNumber);
while ((c = getchar()) != EOF)
{
    putchar(c);
    if (c == '\n')
        ++LineNumber;
}
</code></pre>

<p>One problem is this is going to print a line number for the last ¡°empty¡± line. If we want to avoid that, then we want to print a line number only if (a) we have just started a new line, and (b) there is another character in the file:</p>

<pre><code>#include &lt;stdbool.h&gt;
¡­

int c;
int LineNumber = 0;
bool AtStartOfLine = true;
while ((c = getchar()) != EOF)
{
    if (AtStartOfLine)
        printf(""%d "", ++LineNumber);
    putchar(c);
    AtStartOfLine = c == '\n';
}
</code></pre>
",1
56566977,56566922,4,"<p>You are measuring the time of printing as well.  You should not count the time of execution of <code>printf</code>.</p>

<pre><code>  clock_t begin_old = clock();
  int val = binsearch_old(x, v, n);
  clock_t end_old = clock();
  printf(""\nbinsearch_old :: position: %i\n"", val);
  double time_spent_old = (double)(end_old - begin_old) / CLOCKS_PER_SEC;
  printf(""time spent old: %f\n"", time_spent_old);
</code></pre>

<p>If you do not count so then you should ask yourself <code>why does printf have different times for similar calls ?</code>.</p>
",1
48112048,48112001,2,"<p><code>scanf</code> should have address, not value.   </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
  int* p;
  p=(int*)malloc(sizeof(int));
  printf(""Enter a value : \n"");
  scanf(""%d"", p);
  printf(""%d"", *p);
  free(p); // should free manually
} 
</code></pre>
",2
55552994,55552929,3,"<p>This is your problem:</p>

<pre><code>scanf(""%i"", x);
</code></pre>

<p>Should be</p>

<pre><code>scanf(""%i"", &amp;x);
</code></pre>

<p>You need to take the address of x, otherwise just using x , will be treated as a pointer pointing to who knows what.  Make sure you compile with warnings on, as your compiler should warn you about stuff like that.  My compiler complains with</p>

<p>""format string '%i' requires an argument of type 'int *', but variadic argument 1 has type 'int'""</p>
",1
55153772,55153727,1,"<p><code>str[0] = 0;</code> is all you need -- that sticks a NUL terminator into the start of the array.  <code>strcpy(str, """");</code> has the same effect and works just as well.</p>
",2
53273707,53273561,1,"<p>Usually, those <em>are</em> the system calls. It's <em>conceivable</em> that they may just be a normal function that uses other system calls to do the work (for example, <code>read</code> calling an underlying set of smaller operations), UNIX and its brethren tend to map one-to-one.</p>

<p>But the basic idea with unbuffered I/O is that there is no caching going on.</p>

<p>When you read and write data in an unbuffered manner, the data is immediately sent to, or retrieved from, the underlying layers (the system calls alluded to).</p>

<p>Contrast that with a <em>buffered</em> approach where data can be cached before it's written, or more can be read than needed in the expectation it <em>will</em> be needed, both which can lead to more efficiency.</p>

<p>For example, see the following (pseudo-code) <code>writebuffered</code>:</p>

<pre><code>def internal buffer size 1024 initially empty
def function writebuffered, accepts data:
    for each char in data:
        if internal buffer is full:
            write internal buffer
            empty internal buffer
        append char to internal buffer
</code></pre>

<p>You can see there that it will only make a system call (the <code>write</code>) when the internal buffer is full, resulting in less system calls overall. Obviously, you wouldn't process a character at a time in real life but the act of processing larger chunks would unnecessarily complicate the code. The intent here is just to show the buffering.</p>

<p>Likewise, when reading (for example, 27 characters), the system call may get a larger amount (say 1K) and save it in a readahead buffer for later, since you'll <em>likely</em> want to read more.</p>

<p>Then that later read, assuming it's for less than or equal to <code>1K - 27</code> bytes, won't have to make another system call to get data, it can just get it from the readahead buffer.</p>
",1
56306206,56306122,4,"<p>C distinguishes between assignment (which is an expression) and initialization (which is part of the definition of a variable). In particular, the <code>= { ... }</code> syntax is only valid for initialization.</p>

<p>If you want to do this with a separate loop, you need two nested loops (or a lot of repeated code to set all the elements):</p>

<pre><code>for (int i=0; i&lt;26; i++) {
    for (int j = 0; j&lt;7; j++) {
        R[i].Rpr[j] = NULL;
    }
}
</code></pre>

<p>Alternatively, just use initialization:</p>

<pre><code>repere R[26] = { { { NULL } } };
</code></pre>

<p>Technically this only initializes the first element of the inner array in the struct in the first element of the outer array, but C has no ""half-initialized"" variables. The rule is that if there's an initializer that doesn't cover all of the variable's fields, they are implicitly set to zero. For pointers that means they're all null pointers.</p>

<p>In fact, this ""initialize everything with 0"" initializer can be made both shorter and more generic:</p>

<pre><code>repere R[26] = { 0 };
</code></pre>

<p>This <code>{ 0 }</code> initializer works for other types as well. (Some compilers warn about this construct (""<em>missing braces in initializer</em>"" and similar). Those compilers are stupid and need to stop.)</p>
",0
56306248,56306122,0,"<p>As others pointed, Here</p>

<pre><code>maillon *Rpr [7];
</code></pre>

<p><code>Rpr</code> is <em>array of pointers of <code>maillon</code> type</em> and you need to initialize each pointers with <code>NULL</code>. For e.g</p>

<pre><code>for (int i=0; i&lt;26; i++) {
    for (int j = 0; j&lt;7; j++) { /* Rpr is array of 7 pointers, so rotate 7 times */
        R[i].Rpr[j] = NULL; /* initializing each Rpr[index] with NULL */
    }
}
</code></pre>
",1
53900554,53900208,2,"<p>You should not use <a href=""http://man7.org/linux/man-pages/man3/rand.3.html"" rel=""nofollow noreferrer""><code>rand()</code></a>, because it is quite poor in many C standard library implementations. It will return a pseudorandom number between 0 and <code>RAND_MAX</code>, inclusive, but <code>RAND_MAX</code> is often relatively small; for example, 32767.</p>

<p>Using the modulo operator to yield a range of integers is problematic if the range is a large fraction of the range of values the generator function can return, because the distribution is not exactly uniform.</p>

<p>For example, let's say <code>RAND_MAX</code> is 59999, and we used <code>rand() % 40000</code>. The probability of the result being between 0 and 19999 is 67%, but only 33% between 20000 and 39999. This is because that <code>rand()</code> produces a value in [0,19999] at 1/3 probability, [20000,39999] at 1/3 probability, and [40000..59999] at 1/3 probability; but that last third folds back so that it yields [0,19999] after the modulo operation!</p>

<p>For small ranges the bias is not so noticeable.</p>

<p>Personally, I like to generate enough random bits to cover the desired range, then use the exclusion method to pick the value.</p>

<p>If we need to use <code>rand()</code>, we can use the following helper function to generate a pseudorandom number whose range is at least <code>atleast</code> (but may be larger; i.e. it can return a larger value):</p>

<pre><code>#include &lt;inttypes.h&gt;

static inline uint64_t  rand_atleast(uint64_t  atleast)
{
    uint64_t  result = 0;
    do {
        result = ((uint64_t)RAND_MAX + 1) * result + (uint64_t)rand();
        atleast /= ((uint64_t)RAND_MAX + 1);
    } while (atleast &gt; 0);
    return result;
}
</code></pre>

<p>To use the exclusion method to create <code>int</code>s within a desired range, we can use a structure to contain the stuff we need, a helper function to initialize that range (to describe some specific range of ints), and another helper function to generate integers within that range:</p>

<pre><code>struct range_spec {
    uint64_t  mask;
    uint64_t  limit;
    int       base;
};

static inline void set_range(struct range_spec *spec,
                             int minimum, int maximum)
{
    uint64_t  mask;
    int       base;

    if (minimum &lt;= maximum) {
        base = minimum;
        mask = maximum - minimum;
    } else {
        base = maximum;
        mask = minimum - maximum;
    }

    spec-&gt;base  = base;
    spec-&gt;limit = mask;

    mask |= mask &gt;&gt; 1;
    mask |= mask &gt;&gt; 2;
    mask |= mask &gt;&gt; 4;
    mask |= mask &gt;&gt; 8;
    mask |= mask &gt;&gt; 16;
    mask |= mask &gt;&gt; 32;

    spec-&gt;mask = mask;
}

static inline int rand_range(const struct range_spec *spec)
{
    const uint64_t  mask = spec-&gt;mask;
    const uint64_t  limit = spec-&gt;limit;
    uint64_t        result;

    do {
        result = rand_atleast(mask) &amp; mask;
    } while (result &gt; limit);

    return spec-&gt;base + result;
}
</code></pre>

<p>However, this is a lot of work to get pretty poor pseudorandom numbers: not worth it in my opinion.</p>

<hr>

<p>I usually use Xorshift64* instead.  It is fast, quite random (see <a href=""https://stackoverflow.com/a/53900430/1475978"">this extended comment</a> of mine), and really easy to implement.</p>

<p>Essentially, you can use a small header file, say <strong>rng64.h</strong>:</p>

<pre><code>#ifndef   RNG64_H
#define   RNG64_H
#include &lt;inttypes.h&gt;
#include &lt;time.h&gt;

typedef struct {
    uint64_t  limit;
    int64_t   base;
    int       shift;
} rng64_intrange_spec;

static uint64_t  rng64_state = 1;

static inline uint64_t  rng64(void)
{
    uint64_t  x = rng64_state;
    x ^= x &gt;&gt; 12;
    x ^= x &lt;&lt; 25;
    x ^= x &gt;&gt; 27;
    rng64_state = x;
    return x * UINT64_C(2685821657736338717);
}

static inline uint64_t  rng64_randomize(void)
{
    uint64_t  x;
    int       n = 1000;

    x = ((uint64_t)time(NULL) * UINT64_C(19076794157513))
      ^ ((uint64_t)clock() * UINT64_C(809712647));
    if (!x)
        x = 1;
    while (n--&gt;0) {
        x ^= x &gt;&gt; 12;
        x ^= x &lt;&lt; 25;
        x ^= x &gt;&gt; 27;
    }

    rng64_state = x;
    return x;
}

static inline double rng64_one(void)
{
    return (double)rng64() / 18446744073709551616.0;
}

static inline int64_t rng64_intrange(rng64_intrange_spec *spec)
{
    const uint64_t  limit = spec-&gt;limit;
    const int       shift = spec-&gt;shift;
    uint64_t        value;

    do {
        value = rng64() &gt;&gt; shift;
    } while (value &gt; limit);

    return spec-&gt;base + value;
}

static inline void rng64_set_intrange(rng64_intrange_spec *spec,
                                  int64_t minimum,
                                  int64_t maximum)
{
    int64_t   base;
    uint64_t  limit;
    int       bits = 0;

    if (minimum &lt;= maximum) {
        base  = minimum;
        limit = maximum - minimum;
    } else {
        base  = maximum;
        limit = minimum - maximum;
    }

    spec-&gt;base  = base;
    spec-&gt;limit = limit;

    while (limit &gt;= 32768) {
        limit &gt;&gt;= 16;
        bits   += 16;
    }
    while (limit &gt;= 8) {
        limit &gt;&gt;= 4;
        bits   += 4;
    }
    while (limit &gt; 0) {
        limit &gt;&gt;= 1;
        bits   += 1;
    }

    spec-&gt;shift = 64 - bits;
}

#endif /* RNG64_H */
</code></pre>

<p>Somewhere near the beginning of your program, call <code>rng64_randomize()</code> to generate a state based on the current time (wall clock via <code>time()</code>, and CPU time used to execute the current process via <code>clock()</code>). The initial state is churned a bit, to ensure you don't get similar sequences when running the code in quick succession.  You can set the <code>rng64_state</code> to any value except zero, to generate a specific sequence. (Zero state will generate only zeroes.) I recommend using</p>

<pre><code>printf(""Using %"" PRIu64 "" as the Xorshift64* random number seed.\n"", rng64_randomize());
</code></pre>

<p>which prints both the seed, and the pseudorandom number generator algorithm used, near the beginning of the program. That allows someone to reproduce the test (by setting <code>rng64_state</code> to that value instead of calling <code>rng64_randomize()</code>, or reimplement the test using their own equivalent code).  Reproducibility is good. </p>

<p>While <code>(uint64_t)time(NULL)</code> is not guaranteed to work by the C standard, it does work in all current widely-used C implementations I am aware of.</p>

<p>If you want to compare to a different pseudorandom number generator, just reimplement another using a similar header file, and include that instead. That way you don't need to change any code that uses the generator, only the generator code itself.</p>

<p><code>rng_one()</code> returns uniform pseudorandom numbers between 0 and 1.0, inclusive. If you want the upper limit to be exclusive, use e.g.</p>

<pre><code>static inline double rng64_one(void)
{
    double  r;
    do {
        r = (double)rng64() / 18446744073709551616.0;
    } while (r &gt;= 1.0);
    return r;
}
</code></pre>

<p>and if both limits exclusive (so it never returns 0.0 or 1.0 exactly), <code>while (r &lt;= 0.0 || r &gt;= 1.0);</code> instead.</p>

<p>Here's an example of how to use the rng64.h above:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include ""rng64.h""

int main(int argc, char *argv[])
{
    rng64_intrange_spec  r;
    int   minval, maxval, count, i;
    char  dummy;

    if (argc != 4 || !strcmp(argv[1], ""-h"") || !strcmp(argv[1], ""--help"")) {
        fprintf(stderr, ""\n"");
        fprintf(stderr, ""Usage: %s [ -h | --help ]\n"", argv[0]);
        fprintf(stderr, ""       %s MIN MAX COUNT\n"", argv[0]);
        fprintf(stderr, ""\n"");
        fprintf(stderr, ""This program outputs COUNT pseudorandom integers,\n"");
        fprintf(stderr, ""between MIN and MAX, inclusive.\n"");
        fprintf(stderr, ""\n"");
        return EXIT_FAILURE;
    }

    if (sscanf(argv[1], "" %d %c"", &amp;minval, &amp;dummy) != 1) {
        fprintf(stderr, ""%s: Invalid minimum.\n"", argv[1]);
        return EXIT_FAILURE;
    }
    if (sscanf(argv[2], "" %d %c"", &amp;maxval, &amp;dummy) != 1 || maxval &lt; minval) {
        fprintf(stderr, ""%s: Invalid maximum.\n"", argv[2]);
        return EXIT_FAILURE;
    }
    if (sscanf(argv[3], "" %d %c"", &amp;count, &amp;dummy) != 1 || count &lt; 0) {
        fprintf(stderr, ""%s: Invalid count.\n"", argv[3]);
        return EXIT_FAILURE;
    }

    fprintf(stderr, ""Generating %d pseudorandom integers in [%d, %d],\n"", count, minval, maxval);
    fprintf(stderr, ""using Xorshift64* with seed %"" PRIu64 "".\n"", rng64_randomize());
    fflush(stderr);

    rng64_set_intrange(&amp;r, minval, maxval);

    for (i = 0; i &lt; count; i++)
        printf(""%d\n"", (int)rng64_intrange(&amp;r));

    return EXIT_SUCCESS;
}
</code></pre>

<p>Specify the minimum and maximum values (integers), and the number of integers to output, as command-line parameters.</p>
",2
55551247,55551177,2,"<p>A line is composed of words and separator characters (spaces I suppose) with a terminating null. A line with the max possible number of words looks like</p>

<pre><code>a a a a a\0
</code></pre>

<p>In this example, the line has 10 characters.  There are 5 words. In general N characters can't hold more than N/2 words.</p>
",0
59074559,59074435,2,"<p>No, it won't necessarily change <code>value</code>. <code>realloc()</code> is allowed to extend the length of an existing allocation, or create a new allocation and free the old one. You need to assign the returned pointer back to <code>value</code>.</p>

<p>Change <code>string_copy</code> to return the new pointer.</p>

<pre><code>char * string_copy(char *value)
{
     char *begin = value;
     char result[1000] = {'\0'};

     //get_result will return the length of result
     int length = get_result(result);

     if (length &gt;= strlen(begin)) 
     {
         begin =  realloc(begin, length+1);
     }
     strncpy(begin, result, length);
     begin[length] = '\0';

     return begin;
}

void test_function()
{
    char *value;
    value = calloc(1,10);
    value = string_copy(value);
    printf(""value = %s\n"", value);
}
</code></pre>
",0
49964228,49964180,1,"<p>This <code>for</code> loop</p>

<pre><code>for(i=strlen(args); i !=1; i--){
    nome[i]=args[i];
}
</code></pre>

<p>copies all characters except first and second (i.e. at indexes <code>0</code> and <code>1</code>), but since it places the characters at their old positions, the initial two characters end up uninitialized.</p>

<p>You can use <code>strcpy</code> with the first character skipped, thus avoiding the <code>for</code> loop altogether</p>

<pre><code>strcpy(nome, &amp;args[1]);
</code></pre>

<p>or you can avoid copying in the first place, drop <code>nome</code>, and pass <code>&amp;args[1]</code> to the function:</p>

<pre><code>if (args[0] == '_') {
    return lerficheiro(&amp;args[1]);
} 
</code></pre>
",5
51938137,51937273,1,"<blockquote>
<strong>6.9.1 Function definitions</strong><br>
...<br>
12 If the <strong><code>}</code></strong> that terminates a function is reached, and the value of the function call is used by
the caller, the behavior is undefined.
</blockquote>
<p><sup><em><a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C 2011 online draft</a></em></sup></p>
<p>In plain English, the behavior of this code is not predictable.  It's working as expected for you with your particular combinatoin of hardware, OS, and compiler, but that may not be the case with a different compiler, or even in a different program using the same compiler.</p>
<p>&quot;Undefined behavior&quot; means that the compiler and runtime environment are not required to &quot;do the right thing&quot;, whatever the right thing would be.  The code may work as expected, <em>or</em> it may crash immediately, <em>or</em> it may corrupt other data leading to a crash later on, <em>or</em> any of a hundred other outcomes.</p>
<p>C's definition is a bit loose in places.  There is a <em>constraint</em> (i.e. a semantic rule) that says if a <code>return</code> statement appears in a function that returns anything other than <code>void</code>, then it <em>must</em> be followed by an expression (the return value).  Similarly, there's a constraint that says if a <code>return</code> statement appears in a function returning <code>void</code>, then it <em>must not</em> be followed by an expression.  However, there are no constraints that say a <code>return</code> statement must be present in either case.</p>
<p>Believe it or not, knowing the history of C, this makes sense.  C didn't originally have a <code>void</code> type, and there wasn't a good way to distinguish between functions that computed and returned a value vs. functions that just executed some statements.  It was a bit of a pain to force a return on something whose value would never be used anyway, so the presence of <code>return</code> statements are not enforced by either the grammar or any constraints.</p>
",0
51937304,51937273,8,"<p>The compiler is <em>not</em> guessing.</p>

<p>You have (without the required <code>return</code>) some <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""noreferrer""><strong>undefined behavior</strong></a>. Be <a href=""https://stackoverflow.com/a/25636788/841108"">scared</a>.</p>

<p>What might happen is that your particular compiler (with your particular compilation flag on your particular machine) has filled (by accident, bad luck or whatever reason) a processor register which contains some apparently suitable return value (as requested by the relevant <a href=""https://en.wikipedia.org/wiki/Application_binary_interface"" rel=""noreferrer"">ABI</a> and <a href=""https://en.wikipedia.org/wiki/Calling_convention"" rel=""noreferrer"">calling conventions</a>).</p>

<p>With different compilers (or different versions of them) or a different operating system or computer, or different optimizations flags you could observe some other behavior.</p>

<p>A compiler might use random numbers to allocate registers (or make other decisions); but for the sake of compiler writers, it usually don't ; in other words, compilers writers try to make their compiler somehow deterministic, but the <a href=""https://en.wikipedia.org/wiki/C11_(C_standard_revision)"" rel=""noreferrer"">C11</a> standard (read <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""noreferrer"">n1570</a>) does not require that.</p>
",1
50240333,50237458,0,"<p>You could follow the <code>qsort</code> model and pass a delegate function to handle the actual formatting:</p>

<pre><code>void print_array( void *array, size_t arrsize, size_t eltsize, const char *(*fmt)( const void *item ) )
{
  unsigned char *cur = array;
  fprintf( stdout, ""{"" );
  if ( arrsize &gt; 0 )
  {
    fprintf( stdout, ""%s"", fmt( cur ) );
    cur += eltsize;

    for ( size_t i = 1; i &lt; arrsize; i++ )
    {
      fprintf( stdout, "", %s"", fmt( cur ) );
      cur += eltsize;
    }
  }
  fprintf( stdout, ""}"" );
}
</code></pre>

<p>If you want to print out an array of integers, you create a formatting function for an integer and pass it to <code>print_array</code>:</p>

<pre><code>const char *intFmt( const void *item )
{
  static char buffer[12];
  sprintf( buffer, ""%d"", *(const int *) item );
  return buffer;
}
</code></pre>

<p>If you want to print an array of doubles, you'd create a different formatting function:</p>

<pre><code>const char *dblFmt( const void *item )
{
  static char buffer[12];
  sprintf( buffer, ""%10.2f"", *(const double  *) item );
  return buffer;
}
</code></pre>

<p>You could create formatters for aggregate types (structs, unions, other arrays), enums, etc., giving you almost unlimited flexibility.  Also, by delegating type-aware stuff to the formatters, your <code>print_array</code> function itself stays simple; you don't have to hack it every time you want to support a new type.  </p>

<p>There are drawbacks to this approach.  There's no way for the compiler to warn you when you're using the wrong formatter for a given type (anytime you muck around with <code>void *</code>, you're throwing type safety out the window).  Also, in this implementation, I'm using static buffers in the formatters, making them non-reentrant and not thread safe.  It would be better to pass a target buffer to <code>print_array</code> (which it would pass through to the formatter), but I'm trying to keep the example somewhat readable.  </p>

<p>You would probably also want to pass the output stream as an argument, rather than always print to <code>stdout</code>.  </p>

<p>But, this should at least give you a flavor of what's possible.  Here's a complete implementation, along with some sample output:</p>

<pre><code>#include &lt;stdio.h&gt;

void print_array( void *array, size_t arrsize, size_t eltsize, const char *(*fmt)( const void *item ) )
{
  unsigned char *cur = array;
  fprintf( stdout, ""{"" );
  if ( arrsize &gt; 0 )
  {
    fprintf( stdout, ""%s"", fmt( cur ) );
    cur += eltsize;

    for ( size_t i = 1; i &lt; arrsize; i++ )
    {
      fprintf( stdout, "", %s"", fmt( cur ) );
      cur += eltsize;
    }
  }
  fprintf( stdout, ""}"" );
}

const char *intFmt( const void *item )
{
  static char buffer[12];
  sprintf( buffer, ""%d"", *(const int *) item );
  return buffer;
}

const char *dblFmt( const void *item )
{
  static char buffer[12];
  sprintf( buffer, ""%10.2f"", *(const double  *) item );
  return buffer;
}

struct node {
  int val;
  struct node *next;
};

const char *nodeFmt( const void *item )
{
  static char buffer[50];
  const struct node *value = item;

  sprintf( buffer, ""{ val: %d; next %p }"", value-&gt;val, (void *) value-&gt;next );
  return buffer;
}

const char *voidFmt( const void *item )
{
  static char buffer[20];
  sprintf( buffer, ""%p"", item );
  return buffer;
}

int main( void )
{
  int iArr[] = {1, 2, 3, 4, 5};
  double dArr[] = {2.0, 4.0, 8.0, 16.0};
  struct node nArr[] = { {1, NULL}, {2, NULL} };

  void *arrs[] = { iArr, dArr, nArr };

  nArr[0].next = &amp;nArr[1];

  print_array( iArr, sizeof iArr / sizeof *iArr, sizeof *iArr, intFmt );
  putchar( '\n' );
  print_array( dArr, sizeof dArr / sizeof *dArr, sizeof *dArr, dblFmt ); 
  putchar( '\n' );
  print_array( nArr, sizeof nArr / sizeof *nArr, sizeof *nArr, nodeFmt );
  putchar( '\n' );
  print_array( arrs, sizeof arrs / sizeof *arrs, sizeof *arrs, voidFmt );
  putchar( '\n' );

  return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>jbode:print_array john.bode$ ./print_array 
{1, 2, 3, 4, 5}
{      2.00,       4.00,       8.00,      16.00}
{{ val: 1; next 0x7ffeeafc5a70 }, { val: 2; next 0x0 }}
{0x7ffeeafc5a40, 0x7ffeeafc5a48, 0x7ffeeafc5a50}
</code></pre>
",0
53088049,53088013,4,"<p>The <code>fgets</code> function reads in a line of text and stores that text, <strong>including the newline</strong> if there's room for it.</p>

<p>So the output is one more because of the newline.</p>
",2
54694751,54694657,6,"<p>This condition will always be true:</p>

<pre><code>(c!=(' ')||c!=('\n'))
</code></pre>

<p>The logical OR operator <code>||</code> evaluates to true if <em>either side</em> evaluates to true.  If <code>c</code> is a space then the first part will be false but the second part will be true, making the result true.  If <code>c</code> is a newline then the first part will be true and the second part won't even be evaluated, making the result true.  If <code>c</code> is any other value, both parts will be true.</p>

<p>You want to use a logical AND here instead, which is only true if <em>both</em> parts are true.  You want the condition to be true if <code>c</code> is not a space AND <code>c</code> is not a newline:</p>

<pre><code>((c!=' ') &amp;&amp; (c!='\n'))
</code></pre>
",0
55237189,55236909,4,"<p>The de facto standard rule is that the part of the code that did the dynamic allocation is also responsible for freeing it. So if your function was in some file ""toupper.c"", then there should have been some manner of clean-up function available in that same C file.</p>

<p>However, the best solutions separates memory allocation and algorithms. This means that a better way to write this function is this:</p>

<pre><code>void toUpper (char* dst, const char* src)
{
  while (*src!= '\0')
  {
    *dst= ...
    ...
    dst++;
    src++;
  }
}
</code></pre>

<p>Here, the caller can allocate space for <code>dst</code> as it pleases, it's no business of the algorithm. For example:</p>

<pre><code>char str1[] = ""hello world"";
char* str2 = malloc(strlen(str1) + 1);
toUpper(str2, str1);
...
free(str2);
</code></pre>

<p>Just make sure to document the function so that the caller knows that they have to allocate space for <code>dst</code> - to be at least as large as <code>src</code>.</p>

<p>As a side-note, <code>char* temp = (char*) malloc(size);</code> is wrong, you didn't allocate room for the null terminator. Also your algorithm must make sure to copy the null terminator into the destination buffer.</p>
",3
48330646,48330569,2,"<p>The problem with your <code>if</code>s is that you are trying to access memory out of
bound, for an array of dimension 10, you can only access from 0 - 9, anything
beyound that yields undefined behaviour.</p>

<pre><code>char choice [10];
...
if(choice[0] == '1')
{
    ...
}
</code></pre>

<p>In most programming languages, you start counting at 0. So if you declare an
array of dimension <em>n</em>, the first element is at position 0 and the last at
position <em>n-1</em>.</p>

<p>If you however want to compare strings, you should use <code>strcmp</code>. Note also that
<code>fgets</code> saves the newline when there is enough space in the buffer.</p>

<blockquote>
  <p><em>man fgets</em></p>

<pre><code>#include &lt;stdio.h&gt;

char *fgets(char *s, int size, FILE *stream);
</code></pre>
  
  <p><strong>DESCRIPTION</strong></p>
  
  <p><code>fgets()</code>  reads  in  <strong>at  most  one less than <code>size</code> characters from stream</strong> and stores them into the buffer pointed to by <code>s</code>.
  Reading stops after an EOF or a newline.  <strong>If a newline is read, it is stored into the buffer</strong>.
  A terminating null byte (<code>'\0'</code>)  is  stored  after  the last character in the buffer.</p>
</blockquote>

<p>Comparing strings in your case:</p>

<pre><code>if(strcmp(choice, ""1\n"") == 0)
{
    // string is equal to ""1\n""
}
</code></pre>
",3
55186515,55186410,3,"<p>Are you talking about <code>BUFSIZ</code>? It's a macro provided by <code>&lt;stdio.h&gt;</code> and it expands to the size of the buffer used by <code>setbuf()</code>.</p>

<p>I'm not sure what use it has in your own code.</p>
",4
58719779,58719686,2,"<p>The version number is an <code>int</code>, not a string. You need to use <code>%d</code> format, and dereference the pointer.</p>

<pre><code>printf(""version: %d\n"", *intBuffer);
</code></pre>

<p>You also need to add a null terminator to <code>charBuffer</code> before using <code>%s</code> to print.</p>

<pre><code>fread(charBuffer, sizeof(char), 4, inputFile);
charBuffer[4] = 0;
printf(""Format: %s\n"", charBuffer);
</code></pre>
",0
49962422,49962157,1,"<p>Do note that the <code>for</code> loop</p>

<pre><code>for(int x = 'A'; x &lt;= 'Z'; x++)
{
    x = tolower(x);
    putchar(x);
}
</code></pre>

<p>is just syntactic sugar for a <code>while</code> loop - here equivalent to</p>

<pre><code>{
    int x = 'A';
    while (x &lt;= 'Z') {
        x = tolower(x);
        putchar(x);
        x ++;
    }
}
</code></pre>

<p>By the time it reaches the <code>x ++</code>, the value  is <code>'a'</code> i.e. 97, and after the increment, it will be <code>'b'</code> i.e. 98. Since <code>'b' &lt;= 'Z'</code> (98 &lt;= 90) is false, the iteration stops.</p>

<p>Many newcomers to C think <code>for</code> is some magical structure, as it is in some other programming languages, and that's where they go wrong.</p>

<p>P.s. had you written <code>putchar(tolower(x));</code> your program would have worked.</p>
",1
49962257,49962157,3,"<p>The problem with your approach is that your are modifying the variable that is
used as the running variable for the loop.</p>

<p>Take a look at the <a href=""https://www.asciitable.com/"" rel=""nofollow noreferrer"">ASCII Table</a> and you'll notice that the upper case
letters have an integer value smaller than the lower case letters.</p>

<p>So in the first iteration, <code>x</code> is assigned to <code>A</code>, then you do</p>

<pre><code>x = tolower(x);
</code></pre>

<p>which changes the value of <code>x</code> from <code>A</code> to <code>a</code>. The integer value of <code>a</code> is 97,
which is greater than the integer value of <code>Z</code> (which is 90). When the next
iteration is started <code>x++</code> is executed, which make <code>x</code> even larger than 90, so the condition</p>

<pre><code>x &lt;= 'Z'
</code></pre>

<p>will be evaluated to false, hence the loop stops.</p>

<p>So, don't change the variable that your are using as the running variable for the
loop. You can do either</p>

<pre><code>for(int x = 'A'; x &lt;= 'Z'; x++)
{
    int lower_x = tolower(x);
    putchar(lower_x);
}
</code></pre>

<p>or</p>

<pre><code>for(int x = 'A'; x &lt;= 'Z'; x++)
{
    putchar(tolower(x));
}
</code></pre>

<p>In both cases <code>x</code> is only modified by the loop itself and you don't run into
the problem you've had.</p>

<p>Note that while</p>

<pre><code>int main()
{
    for(int x = 'A'; x &lt;= 'z'; x++) // Notice (x &lt;= 'Z') &gt; &gt; (x &lt;= 'z')
    {
        x = tolower(x);
        putchar(x);
    }
    return 0;
}
</code></pre>

<p>gives you the same results in this case, this is not in general the correct
solution, because it is still modifying the <code>x</code> variable outside the
loop-construct. The values of <code>x</code>
will be</p>

<ul>
<li><em>First iteration</em> <code>x == 'A'</code></li>
<li><em>Second iteration</em> <code>x == 'b'</code></li>
<li><em>Third iteration</em> <code>x == 'c'</code></li>
<li>...</li>
</ul>

<p>Like I said, the end result might the same, but this is only a coincidence. Image
you have this task: <em>print the values multiplied by 100 from 10 to 20</em></p>

<p>If you do</p>

<pre><code>for(int x = 10; x &lt;= 20; x++)
{
    x = x * 100;
    printf(""%d\n"", x);
}
</code></pre>

<p>You will have the same situation as before. But the solution</p>

<pre><code>for(int x = 10; x &lt;= 200; x++)
{
    x = x * 100;
    printf(""%d\n"", x);
}
</code></pre>

<p>would print completely incorrect values. Like for your problem, the correct
solution would be <strong>not to modify</strong> <code>x</code> in the block</p>

<pre><code>for(int x = 10; x &lt;= 20; x++)
{
    printf(""%d\n"", x * 100);
}
</code></pre>
",0
55326152,55326011,1,"<p>You program reads past the array.</p>

<p>When <code>i</code> equals <code>9</code>, <code>A[j+1]</code> reads past the array when <code>i == j</code> which is allowed by your <code>for(j=0;j&lt;=i;j++)</code> loop stop condition.</p>

<p>This also applies to <code>A[k+1]</code></p>
",0
55326144,55326011,0,"<p>It's not about your compilation. It may happen if you run the same file multiple time.</p>

<p>since you are accessing A[10] which does not contain a specific value, your program could behave in different ways, if the value in A[10] is greater than 24, that value remains in its position and correct response will print out, otherwise, it will propagate to somewhere between your numbers. so you loos your last number (24) and a random value goes inside your array.</p>
",0
54968046,54967299,0,"<p>Macros perform text substitution. That means that it just replaces whatever you give it as <code>a</code>, <code>b</code> and <code>c</code> inside the definition. You can do the same manually and it should give you the code that this generates.</p>

<p>Notes:</p>

<ul>
<li>Macros operate without any syntax checking, type checking or other sanity checks, which is why they are generally frowned upon.</li>
<li>The actual operation of this code depends on what you feed to it, too. My answer doesn't explain how this is supposed to work for exactly that reason. It depends on things outside the control of this macro.</li>
<li>This code would probably be better coded as inline function, which provides type checking and generally a few constraints that in turn provide guarantees.</li>
<li>Probably mostly irrelevant here, but this macro is even buggy, because it uses a symbol that is reserved (double, consecutive underscore) to the compiler and implementation. I'm not sure about the precise term, but either it causes the program to be ill-formed or it causes undefined behaviour, but ""buggy"" sums it up pretty well. That's one more thing making this code bad.</li>
</ul>
",0
56760767,56760306,-1,"<blockquote>
  <p>If someone has a better solution, e.g. something with malloc, it would also be a big help.</p>
</blockquote>

<p><strike></p>

<h3>Option 1:</h3>

<p>Don't make <code>bufferSize</code> an input to the function. Use a hard-coded size that you know will
not cause buffer overflow, such as <a href=""https://en.cppreference.com/w/cpp/header/limits"" rel=""nofollow noreferrer""><code>std::numeric_limits&lt;unsigned short&gt;::max()</code></a>.</p>

<h3>Option 2:</h3>

<p>Use <code>std::vector</code> insteady of an array.</p>

<pre><code>// char buffer[bufferSize / sizeof(char)];
std::vector&lt;char&gt; buffer(bufferSize);
</code></pre>

<p>Then use <code>buffer.data()</code> when you need to access the data of the object.</p>

<p></strike></p>

<h3>Update (since C++ tag was removed)</h3>

<p>Don't make <code>bufferSize</code> an input to the function. Use a hard-coded size that you know willnot cause buffer overflow, such as <code>USHORT_MAX</code>.</p>

<pre><code>void copyUsingBuffer(char from[], char to[])
{
    int bufferSize = USHORT_MAX
    char buffer[USHORT_MAX];

    struct stat statBuffer;
    int sourceFD, destFD;

    ...
}
</code></pre>
",3
55780710,55780564,14,"<p>Yeah, C is weird sometimes. Because that variable is at file scope and has no initializer or storage class specifier, it constitutes a tentative defintion. The C standard defines it as follows:</p>

<blockquote>
  <p><strong>6.9.2 External object definitions</strong></p>
  
  <p>A declaration of an identifier for an object that has file scope
  without an initializer, and without a storage-class specifier or with
  the storage-class specifier static, constitutes a tentative
  definition. If a translation unit contains one or more tentative
  definitions for an identifier, and the translation unit contains no
  external definition for that identifier, <strong>then the behavior is exactly
  as if the translation unit contains a file scope declaration of that
  identifier, with the composite type as of the end of the translation
  unit</strong>, with an initializer equal to 0.</p>
</blockquote>

<p>I emphasized the relevant part. Because there is no initializer on your variable, it's as though you'd written it at the very end of the file and initialized to zero. The physical layout of the file is immaterial, because logically, the definition of the structure type is available at the end of the file.</p>

<p>So the answer is indeed (4). I wouldn't write code like that in real life however, this is terribly confusing in the C eco-system where near everything must be pre-declared to be used.</p>
",0
50480450,50480423,3,"<p>C has no facility to run such initialization code outside of functions. And since initializers to static variables at file scope need to be constant expressions, you have two options:</p>

<ol>
<li><p>Create a script in your scripting language of choice that generates an initializer macro of the right size, for you to use as an initializer to the array. For instance, the script can read this file:</p>

<pre><code>#include ""my_init_list.h""
char* list[] = {""A"", ""B"", ""C"", /* However many more */};
int counter[] = COUNTERS_INITIALIZER;
</code></pre>

<p>It would parse the initializer for <code>list</code>, and output the file <code>my_init_list.h</code> which would contain the macro <code>COUNTERS_INITIALIZER</code> that is expanded to <code>{1, 1, ..., 1}</code>. If you run the script as a step in your build process, that should do it.</p></li>
<li><p>Put the initialization code into a function, and rig your function to run once early in your program's startup code (what <code>main</code> executes when it starts running).</p></li>
</ol>
",0
55323100,55322940,0,"<p>Your compare would have to to spectacularly slow to justify all that navigation.  As it stands I cannot think of a better way than a linear search.  If you can alter the structures and CRUD you can certainly index key points (""A"" starts here, ""B"" starts here etc.) and that would allow you to better guess the start and direction of your linear search.</p>

<p>I think you'll find that a linked list, doubly or otherwise, is not a great choice for random lookups or updating in order.  Use a B-Tree which seems to be a better fit for the situations you've outlined in your question and comments.</p>
",1
55361007,55360632,3,"<p>Provided your C implementation supports it, you could include the <code>&lt;threads.h&gt;</code> header and create new threads. This would allow you to use one thread to scan the list forward and another to scan the list backward. However, there are a number of issues with this, including:</p>

<ul>
<li>If you have so many nodes to check that creating an additional thread to scan them improves execution time significantly, then you have so many nodes that you could improve the searching of them by using a better structure than a doubly-linked list, such as trees or hashing.</li>
<li>It is fairly easy to start a new thread, but it is harder to stop the threads in a sensible way. You would need to stop one thread when the other finds a result, and you would need to stop both threads when they meet each other in the list. This means adding more code for communication and coordination.</li>
<li>Creating multiple threads can, in the right circumstances, reduce the ¡°wall clock¡± execution time (how long it is until you get a result), but it does not reduce the resources consumed. Instead of using one processor for some amount of time, you would be using two processors for about the same total time. (¡°Total¡± meaning the sum of the execution times on each processor.)</li>
<li>Some of the resources processors use is shared. For example, they both access the same main memory. Depending on exactly what resources your program requires, letting it use more processors might not help. If the bottleneck in your program is reading data from memory, the first processor is just waiting on memory anyway, and adding a second processor will just mean they are both waiting. That may be fine on a system where you are the only user and are not using it heavily (although there are questions of how much energy may be used doing it one way versus another). However, on a system where there are many processes running and the full CPU power is needed, it can be wasteful to use multiple processes to get a result sooner.</li>
<li>Conversely, modern processors are very complicated and include some multiprocessing internally¡ªa processor can compare some data at the same time it is asking for other data to be loaded from memory. Sometimes clever writing of code can take advantage of this multiprocessing to get multiple things done at once. For example, you could write code that alternately works forward in the list and backward, each one step at a time together in one loop, and the processor might execute this efficiently, comparing the data from one direction while loading data for the other direction.</li>
</ul>

<p>It is not a bad idea to think about using parallel processing to speed up a program, but it is likely not the right approach for a simple scan of a doubly linked list. There are additional complications beyond those discussed above.</p>
",2
48969095,48968479,0,"<p>You can rewrite this</p>

<pre><code>char a[number][50];
char help[50];
for(i=0; i&lt;number; i++)
{
    scanf(""%s"", help);
    strcpy(a[i], help);
}
</code></pre>

<p>as</p>

<pre><code>char a[number][50];
for(i=0; i &lt; number; ++i)
    scanf(""%s"", a[i]);
</code></pre>

<p>you don't need another intermediate buffer. Also bear in mind, that <code>""%s""</code>
matches only non-empty characters, if your filename has an empty character,
<code>scanf</code> won't read the whole input and leave behind extra characters in the input
buffer, thus messing with the next <code>scanf</code> call. Here it would be better to use
<code>fgets</code>.</p>

<pre><code>char a[number][50];
for(i = 0; i &lt; number; ++i)
{
    if(fgets(a[i], sizeof a[i], stdin) == NULL)
    {
        fprintf(stderr, ""Could not read the filename\n"");
        exit(1);
    }

    a[i][strcspn(a[i], ""\n"")] = 0; // removing newline
}
</code></pre>

<p>I haven't seen the mode <code>'t'</code> for <code>fopen</code>, is that a an extension of the modes
for Windows?</p>

<p>A problem with your code is that you are calling</p>

<pre><code>filew = fopen(""finalresult.txt"",""a+t"");
</code></pre>

<p>inside the loop but you never close it inside the loop. <code>FILE* file</code> is buffered,
that means when you use <code>fprintf(file,...)</code> or <code>fwrite(..., file)</code>
the content gets buffered and the content is physically written in the file at a
later point, for example when the buffer is full or you use <code>fflush(filew)</code>. So
when you <code>fopen</code> the same file before doing a <code>fflush</code> or <code>fclose</code>, the old
buffered content remains in the buffer and is written at a much later point (in
your case when the program exits), thus overwriting your new content. Your new content
will have the same fate. At the end you end up with a mess because the content
gets overwritten at the end of the program. That's why you see ""garbage"" in the
file.</p>

<p>So, you have to do <code>fclose</code> before doing <code>fopen</code> with the same filename, or
better you should do the <code>fopen</code> before the loop.</p>

<p>Also this check is incorrect:</p>

<pre><code>if(numr!=100) {
    if(ferror(filer)) {
        fprintf(stderr,""read file error.\n"");
        exit(1);
    }
}
</code></pre>

<p>This would only be correct, if the file size is a multiple of 100. If it's not,
the last block will have less than 100 bytes and you would end your program,
even though the <code>fread</code> had no errors.</p>

<p>So I'd rewrite your program like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

int main(void)
{
    size_t num_of_files;
    printf(""Enter the number of files: "");
    fflush(stdout);
    if(scanf(""%zu"", &amp;num_of_files) != 1)
    {
        fprintf(stderr, ""Could not read the number of files\n"");
        exit(1);
    }

    int c;
    // clearing the input buffer
    while((c = getchar()) != '\n' &amp;&amp; c != EOF);

    char fnames[num_of_files][50];
    for(size_t i = 0; i &lt; num_of_files; ++i)
    {
        printf(""Enter the filename %zu: "", i+1);
        fflush(stdout);

        if(fgets(fnames[i], sizeof fnames[i], stdin) == NULL)
        {
            fprintf(stderr, ""Could not read the filename\n"");
            exit(1);
        }

        fnames[i][strcspn(fnames[i], ""\n"")] = 0; // removing newline
    }


    FILE *filew = fopen(""finalresult.txt"", ""wt"");
    if(filew == NULL)
    {
        fprintf(stderr, ""Could not open file finalresult.txt for writing: %s\n"",
                strerror(errno));
        exit(1);
    }

    for(size_t i = 0; i &lt; num_of_files; ++i)
    {
        FILE *filer = fopen(fnames[i], ""rt"");
        if(filer == NULL)
        {
            fprintf(stderr, ""could not open %s for reading, skipping: %s\n"",
                    fnames[i], strerror(errno));
            continue;
        }

        char buffer[100];
        size_t len;
        while((len = fread(buffer, 1, sizeof buffer, filer)) != 0)
        {
            if(fwrite(buffer, 1, len, filew) != len)
            {
                fprintf(stderr, ""Error writing finalresult.txt\n"");
                fclose(filer);
                fclose(filew);
                exit(1);
            }
        }

        if(!feof(filer))
            fprintf(stderr, ""file %s could not be read completely\n"", fnames[i]);

        fclose(filer);
    }

    fclose(filew);

    return 0;
}
</code></pre>
",0
48614103,48614033,2,"<p>It's a terminal setting: <code>echoctl</code>.  It means that when you type <kbd>Control-D</kbd>, the terminal echoes <code>^D</code>, and then the <code>1</code> overwrites the <code>^</code>.  Try using:</p>

<pre><code>stty -echoctl
</code></pre>

<p>and then rerunning your program.</p>

<p>With that said, I'm surprised that the <code>D</code> isn't wiped out by the blank after the <code>%d</code> in the format string.  I suspect your actual code may be missing that.  When I tested on my Mac, the program with the space after the <code>%d</code> did not show the <code>D</code> for long enough for me to spot it; when I removed that space, I got the output shown in the question.</p>
",1
48614101,48614033,2,"<p>The code is correct (apart from the <code>#include ""string.h""</code> which should be
<code>#include &lt;string.h&gt;</code>)<sup>1</sup>, the problem is that when you press
<kbd>Ctrl</kbd>+<kbd>D</kbd> on your terminal, your terminal might write
something on the terminal, which you <strong>cannot</strong> control and this output might be</p>

<pre><code>^D
</code></pre>

<p>After <code>fgets</code> returns <code>NULL</code>, you do <code>printf(""%d \n"", found);</code> which prints the '1'.
But because there was <code>^D</code> on the terminal, the <code>^</code> was replaced by the '1' and
you end up with:</p>

<pre><code>1D
</code></pre>

<p>Change your last <code>printf</code> to this:</p>

<pre><code>printf(""\n\n%d \n, found);
</code></pre>

<p>And you might see only a '1' in the next lines of the output.</p>

<p>This has nothing to do with your C program, it's the behaviour of your terminal.
My terminal for example doesn't print when pressing <kbd>Ctrl</kbd>+<kbd>D</kbd>,
but when pressing <kbd>Ctrl</kbd>+<kbd>C</kbd> I get <code>^C</code>. There's nothing you
can do.</p>

<p><strong>edit</strong></p>

<p>With <em>There's nothing you can do</em> I mean that you cannot control the way the
terminal from you C program without calling external tools like <code>stty</code>. While
this might solve your problem, you are loosing portability.</p>

<p>However, before you start you program, you can configure your terminal using a
program like <code>stty</code>. See <a href=""https://stackoverflow.com/a/48614103/1480131"">Jonathan Leffler</a>'s answer for more info on that.</p>

<hr>

<p><strong>Fotenotes</strong></p>

<p><sup>1</sup>As Jonathan Leffler points out in the comments, using quotes instead
of angle brackets for system headers is not an error per se. For example my GCC
compiler searches in the same directory of the compiled file for headers that
were included with quotes. But in general, it's a good practice to include the
header files included provided by your system with angle brackets.</p>
",2
54259215,54259154,1,"<p>You're not allocating before using, you're using <em>then</em> allocating, but also allocating incorrectly. The correct allocation is:</p>

<pre><code>str = malloc(sizeof(char*) * n);
</code></pre>

<p>Where <code>str</code> is an array of <code>char*</code>, <em>not</em> an array of <code>char</code>.</p>

<p>It's good that you're listening to your compiler warnings, but this one was really specific and you should be able to find the problem. Ordering of allocations is extremely important and ""close enough"" is not acceptable. It either works, or it's undefined behaviour.</p>
",0
54259212,54259154,1,"<p>You have these two sections of code in the wrong order:</p>

<pre><code>for (int i = 0; i &lt; n; i++)
    str[i] = (char*)malloc(sizeof(char)*n);

str = (char**)malloc(sizeof(char)*n + 1);
</code></pre>

<p>You need to allocate memory for <code>str</code> before you can assign to <code>str[i]</code>. And it should be <code>sizeof(char *) * n</code>; there's no need to add 1 to this (you only need this in <code>tr</code>, since you add a null terminator at the end).</p>

<p>It should be:</p>

<pre><code>str = malloc(sizeof(char*)*n);
for (int i = 0; i &lt; n; i++) {
    str[i] = malloc(sizeof(char)*n);
}
</code></pre>

<p>After </p>

<p>Also, please read <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">Do I cast the result of malloc?</a> and <a href=""https://stackoverflow.com/questions/359732/why-is-it-considered-a-bad-practice-to-omit-curly-braces?lq=1"">Why is it considered a bad practice to omit curly braces?</a></p>
",0
48890446,48890399,5,"<p>Yes, this is well-defined.</p>

<p>There's a sequence point after the evaluation of the expression <code>++i</code> in the <code>if</code> condition.</p>
",1
48836858,48836443,0,"<p>Yes you are right, you are using <code>strtok</code> incorrectly.</p>

<p>The first thing I would do is to read each line and the parse the line using
<code>strtok</code>, like this:</p>

<pre><code>char line[1024];

const char *delim="",\n"";

while(fgets(line, sizeof line, fp))
{
    char *token = strtok(line, delim);

    do {
        printf(""token: %s\n"", token);
    } while(token = strtok(NULL, delim));
}
</code></pre>

<p><code>strtok</code> requires that all subsequent calls of <code>strtok</code> must be called with
<code>NULL</code>. <code>strtok</code> will return <code>NULL</code> when no more token can be found, usually the
end of the line has been reached. Note that I added the newline in the
delimiters argument. When the destination buffer is large enough <code>fgets</code> writes
the newline as well. Putting the newline in the delimiters list is nice trick
because <code>strtok</code> will get rid of the newline for you.</p>

<p>The code above gives you a way getting each cell of the csv, as a string. You
would have to convert the values yourself. This is the tricky bit, if the csv
contains empty spaces, quotes, etc, you need different strategies to parse the
correct value of the cell. You can use function like <code>strtol</code> &amp; friend which
allow you to recover from errors, but they are not bullet proof, there will be
cases when they fail as well.</p>

<p>An easy example would be:</p>

<pre><code>char line[1024];

const char *delim="",\n"";

while(fgets(line, sizeof line, fp))
{
    char *token = strtok(line, delim);

    do {
        int val;
        if(sscanf(token, ""%d"", &amp;n) != 1)
            fprintf(stderr, ""'%s' is not a number!\n"", token);
        else
            printf(""number found: %d\n"", val);
    } while(token = strtok(NULL, delim));
}
</code></pre>

<p>Note that this not cover all cases, for example cell that are in quotes.</p>

<p>The last thing to be done would be to store the values. One way of doing it is
to allocate memory for a pointer to an <code>int</code> array and reallocate memory for
every cell. Here again the problem lies in the csv file, sometimes they have the
wrong format, some rows will be empty or some rows will have more or less
columns than the other rows, this can be tricky. At this point it would be a good
idea to use a library for parsing csv.</p>

<p>The following code will assume that csv is well formatted and the number of
columns is always the same across all rows and no line is longer than 1023
characters long. When <code>*cols</code> is 0, I calculate the number of columns base on
the first line. If other rows have less columns, all remaining values will be 0
(because of the <code>calloc</code> sets new allocated memory to 0). If there are more
colmuns than in the first row, this columns will be ignored:</p>

<pre><code>int **parse_csv(const char *filename, size_t *rows, size_t *cols)
{
    if(filename == NULL || rows == NULL || cols == NULL)
        return NULL;

    FILE *fp = fopen(filename, ""r"");

    if(fp == NULL)
        return NULL;

    int **csv = NULL, **tmp;

    *rows = 0;
    *cols = 0;

    char line[1024];
    char *token;
    char *delim = "",\n"";

    while(fgets(line, sizeof line, fp))
    {
        tmp = realloc(csv, (*rows + 1) * sizeof *csv);
        if(tmp == NULL)
            return csv; // return all parsed rows so far

        csv = tmp;

        if(*cols == 0)
        {
            // calculating number of rows
            char copy[1024];
            strcpy(copy, line);

            token = strtok(copy, delim);

            do {
                (*cols)++;
            } while((token = strtok(NULL, delim)));
        }

        int *row = calloc(*cols, sizeof *row);

        if(row == NULL)
        {
            if(*rows == 0)
            {
                free(csv);
                return NULL;
            }

            return csv; // return all parsed rows so far
        }

        // increment rows count
        (*rows)++;

        size_t idx = 0;

        token = strtok(line, delim);

        do {
            if(sscanf(token, ""%d"", row + idx) != 1)
                row[idx] = 0; // in case the conversion fails,
                              // just to make sure to have a defined value
                              // in the cell

            idx++;
        } while((token = strtok(NULL, delim)) &amp;&amp; idx &lt; *cols);

        csv[*rows - 1] = row;
    }

    fclose(fp);
    return csv;
}

void free_csv(int **csv, size_t rows)
{
    if(csv == NULL)
        return;

    for(size_t i = 0; i &lt; rows; ++i)
        free(csv[i]);

    free(csv);
}
</code></pre>

<p>Now you can parse it like this:</p>

<pre><code>size_t cols, rows;
int **csv = parse_csv(""file.csv"", &amp;rows, &amp;cols);

if(csv == NULL)
{
    // error handling...
    // do not continue
}

...

free_csv(csv, rows);
</code></pre>

<p>Now <code>csv[3][4]</code> would give you the cell at row 3, col 4 (starting from 0).</p>

<hr>

<p><strong>edit</strong></p>

<p>Things I noticed from you code:</p>

<p><code>void main()</code> is wrong. <code>main</code> should have only one of the following prototypes:</p>

<ul>
<li><code>int main(void);</code></li>
<li><code>int main(int argc, char **argv);</code></li>
<li><code>int main(int argc, char *argv[]);</code></li>
</ul>

<p>Another:</p>

<pre><code>int main(void)
{
    char *strcat(char *dest, const char *src);
    char *strtok(char *str, const char *delim);
    ...

}
</code></pre>

<p>Don't put that in the <code>main</code> function, put it outside, also there are standard
header files for this. In this case include <code>string.h</code></p>

<pre><code>#include &lt;string.h&gt;

int main(void)
{
    ...
}
</code></pre>

<p>Another</p>

<pre><code>const char *delim = (const char *)',';
</code></pre>

<p>This is just wrong, it's like trying to sell an apple and call it orange. <code>','</code>
is a single character of type <code>char</code>. It has the value 44. It's the same as
doing:</p>

<pre><code>const char *delim = (const char*) 44;
</code></pre>

<p>you are setting the address where <code>delim</code> should point to 44.</p>

<p>You have to use double quotes:</p>

<pre><code>const char *delim = "","";
</code></pre>

<p>Note that <code>'x'</code> and <code>""x""</code> are not the same. <code>'x'</code> is 120 (see <a href=""http://www.asciitable.com/"" rel=""nofollow noreferrer"">ASCII</a>), it's
a single char. <code>""x""</code> is a string literal, it returns you a pointer to the start
of a sequence of characters that ends with the <code>'\0'</code>-terminating byte, aka a
string. Those are fundamentally different things in C.</p>
",0
51324647,51324586,10,"<p>The contents of an uninitialized local and non-static variable (array or not) is <em>indeterminate</em> and will seem almost random. Don't attempt to use such values.</p>

<p>If you want to initialize the values then you need to do it explicitly, as in</p>

<pre><code>int array[10] = { 0 };  // Will initialize all elements to zero
</code></pre>

<hr>

<p>Then a little nitpicking about your usage of the term ""empty"" together with arrays: Arrays are <em>never</em> ""empty"". If you define an array of ten elements, then it will always have ten elements.</p>

<p>And remember that C doesn't have any kind of ""null value"" concept. Everything has a value, which might be initialized or set by you, or it is uninitialized in which case the value is indeterminate.</p>
",1
54333088,54332790,1,"<p>You can accomplish it the old-school way:</p>

<ol>
<li><p><code>fork()</code> and in the child:</p></li>
<li><p>Open a file for storing standard output and another one for errors.</p></li>
<li><p>Use <code>dup2(oldfd, newfd)</code> to duplicate the two files' descriptors to <code>stdout</code>, and <code>stderr</code> respectively.</p></li>
<li><p>Invoke <code>execlp</code> with gcc and its arguments.</p></li>
<li><p>In the parent process you can add <code>waitpid</code> call to wait for the child to finish.</p></li>
</ol>
",5
59226189,59225918,1,"<p>Every object except bit-fields in C is constructed out of bytes. C 2018 clause 6.2.6 discusses the representations of types, and 6.2.6.1 2 says:</p>

<blockquote>
  <p>Except for bit-fields, objects are composed of contiguous sequences of one or more bytes, the number,
  order, and encoding of which are either explicitly specified or implementation-defined.</p>
</blockquote>

<p>In other words, structures are manufactured for you by the C implementation. When you define and use a structure, the compiler builds it for you by laying out bytes and reading and writing various bytes according to the structure members you access.</p>

<p>This manufactured structure is not known to the network software. Network software just sends bytes back and forth. So, to send a structure, you let the network software send the individual bytes. It is up to receiving software on the other end to put the bytes together and use them as a structure, if it wants to do so.</p>

<p>Converting a pointer to a structure to a pointer to <code>char</code> is a way of showing that you want to treat the manufactured structure as the raw bytes it is composed of. In this case, the explicit cast is unnecessary because the function parameter is declared as <code>void *</code>, and the rules of C say that any pointer to an object may be implicitly converted to <code>void *</code>. In other words, you can just pass <code>&amp;struct_var</code>, and the compiler will automatically convert it for you.</p>
",1
59226148,59225918,0,"<blockquote>
  <p>What does (char *) (&amp;struct_var) do in C?</p>
</blockquote>

<p>The cast converts from one pointer type to a <code>char *</code>.</p>

<blockquote>
  <p>what is the purpose of typecasting struct var to char *?</p>
</blockquote>

<p>With <code>ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);</code>, the cast is not needed in C.  Any object pointer converts to a <code>void *</code> without a need to explicit casting. </p>

<p>Unless this is <em>old</em> code (different rules then pre 1989) or meant for a C and C++ compiler, the cast simply takes up space.</p>
",0
51947783,51947555,4,"<p>If you use a function with a static local and assign it on first use directly from the EEPROM, thereafter the previously initialised value will be returned without re-reading the EEPROM.</p>

<p>Something like (modify the EEPROM read to suit your actual interface):</p>

<pre><code>int getBoardRevsion( void )
{
    static int board_revision = -1 ;
    if( board_revision == -1 )
    {
        board_revision = (int)readEeprom( BOARD_REVISION_OFFSET, 1) ;
    }

    return board_revision ;
}
</code></pre>

<p><code>board_revision</code> is entirely private to all except <code>getBoardRevsion()</code>, while strict read-only access is enforced through the function.</p>
",1
51947649,51947555,9,"<p>For a simple single-core embedded system, this is done by declaring the variable <code>static</code> at file scope in the EEPROM driver, such as:</p>

<pre><code>static uint16_t max_current;
</code></pre>

<p>The driver can then access this directly, but <code>static</code> prevents any other module from doing so. You give them read-only access by providing a getter function in the same driver:</p>

<pre><code>uint16_t get_max_current (void)
{
  return max_current;
}
</code></pre>
",7
54149746,54147781,2,"<p>If I were you I would use CSV-format instead and do something like this to read the file in</p>

<p>csv-format</p>

<pre><code>41,cstfname1,cst1lname,9999,1234
61,cstfname2,cst2lname,88888,5678
...
</code></pre>

<hr>

<pre><code>char lineBuffer[255]; // assuming nobody has gigantic long names
int line = 0;
while (fgets(lineBuffer,sizeof(lineBuffer),fp))
{
  ++line;
  char* p = strtok(lineBuffer,"",""); // here CSV-format comes in handy
  if (atoi(p) == yourId)
  {
    // parse the rest of the line
    char* name = strtok(NULL,"","");
    if (name != NULL)
    { 
      strcpy(customer.fname, name);
    }
    else
    {
      fprintf(stderr, ""Wrong format encountered in line %d\n"", line);
      exit(EXIT_FAILURE);
    }
    ... rest of the fields
  }
}
</code></pre>
",0
57068019,57067987,4,"<p>Your format string expects 4 arguments but you only pass 3.  Doing so invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>, meaning you can't predict the behavior of the program.  </p>

<p>In this case the string ""(null)"" is printed, but your code could print some random sequence of characters, no extra characters, or it could crash.  There's no guarantee.</p>

<p>What <em>probably</em> happened is that the <code>%s</code> format specifier attempted to read the next 8 bytes on the stack to get a pointer, and those 8 bytes happened to all be 0, so the string ""(null)"" is printed because it read a NULL pointer.  But again, there's no guarantee of that.</p>

<p>Also see, <a href=""https://stackoverflow.com/questions/11589342/what-is-the-behavior-of-printing-null-with-printfs-s-specifier"">What is the behavior of printing NULL with printf's %s specifier?</a>.</p>
",6
50514162,50513788,0,"<p>your array is an array of piointers to nowhere. YOu need to allocate and <em>then</em> copy. <code>strdup</code> will do it for you</p>

<pre><code>  char *tempArra[100];
  char line[1024];
int i = 0;
 while(1){
      if (!fgets(line, 1024, stdin))
          return 0;
   // tokenize line and store in  tempArray
   //after done processing that line, empty tempArray to process anotherline
    tempArra[i++] = strdup(line); &lt;&lt;&lt;&lt;&lt;&lt;&lt;

  }
</code></pre>
",1
50514037,50513788,1,"<p>The line where you do the memset:</p>

<pre><code>memset(temparray, '\0', 100);
</code></pre>

<p>uses a different variable name (<em>tempArra</em> is not the same variable as <em>temparray</em>). Try this instead:</p>

<pre><code>memset(tempArra, 0, sizeof(tempArra));
</code></pre>
",1
54877394,54877349,2,"<p><code>p</code> is not a pointer, it's a <code>struct Data</code> variable. <code>p.str</code> is the member of this structure, it's a <code>char *</code> pointer.</p>

<pre><code>p.str = mystr;
</code></pre>

<p>copies the address of the <code>mystr</code> array into this pointer (an array variable decays to a pointer to its first element in this context).</p>
",2
50273513,50273488,0,"<p>Nope, it's impossible to have a pointer to a constant in C. </p>

<p><strong>UPD:</strong> however it seems that there is <a href=""https://stackoverflow.com/a/3443883/1201488"">a trick</a> using a <s>struct</s> <em>compound literals</em> syntax (thanks to @antti-haapala for the correction). Try this:</p>

<pre><code>calc(&amp;(int){10});
</code></pre>
",3
55012449,55012337,3,"<p>You did not store a copy of the name. You made a local copy and then stored a pointer to it, which became invalid the moment your function returned.</p>

<p>This is why your test inside the function showed no problem.  After the function returned, using that pointer resulted in undefined behavior.</p>

<p>Allocate memory for your string with <code>malloc</code>:</p>

<pre><code>char *nameCopy = malloc(strlen(name)+1);
if (nameCopy) strcpy(nameCopy, name);
</code></pre>

<p>Remember to <code>free</code> this memory later when you get around to deleting your nodes.</p>
",6
54457825,54457408,-2,"<p>You do things mostly correctly, but a pointer isn't just another integer, and you can't use arbitrary values, you have to use some that are allocated (i.e. given by the OS) to the program.</p>
<ol>
<li><p>To be able to dereference a pointer, we store the type of value stored in memory. That means that instead of a define you should declare <code>int *LOCATION;</code> to state that you want to point to a memory location where an integer is stored.</p>
</li>
<li><p>In consequence, you shouldn't cast a pointer to <code>int</code>, because <code>&amp;a</code> is already of the same type : a pointer to an int.</p>
<p>Furthermore, you can't assign values to something you <code>define</code>. A define is not a type -- I'm sure you can find another question about what it is exactly.</p>
</li>
<li><p>Getting the address of <code>a</code> before dereferencing it is correct, so do not assign arbitrary values to <code>LOCATION</code> ahead of time. At best, assign it <code>NULL</code>, to signify the pointer is not initialized.</p>
</li>
</ol>
<p>Your code then becomes :</p>
<pre><code>int* LOCATION = NULL;
int main()
{
    int a = 10;
    LOCATION = &amp;a;
    printf(&quot;address of a: %lx\n&quot;, LOCATION);    // accessing the pointer accesses the memory address
    printf(&quot;value of a: %x\n&quot;, *LOCATION); // dereferencing the pointer with * gives the value stored at that address
} 
</code></pre>
<hr />
<p>Now if you're using a memory-mapped peripheral, for example as @P__J__ suggests some hardware register with a fixed address, you need to cast the address to the right type.</p>
<pre><code>#define LOCATION_ADDR 0x68feac
int volatile * const LOCATION = (int *) LOCATION_ADDR; 
</code></pre>
<ul>
<li><code>volatile</code> here means that the memory stored at that location may change due to factors external to the program. This changes compiler optimizations, for example a loop that reads this location until it changes  would be removed without volatile.</li>
<li><code>const</code> here means the pointer location won't change, though the data it contains might (different from <code>const int</code> !).</li>
<li>Once you're comfortable with this, you might use this in the define directly, i.e. <code>#define LOCATION ((volatile int*)0x68feac)</code></li>
</ul>
<hr />
<p>If you want the hardware register to contain a pointer to an int, simply add another <code>*</code>.</p>
<pre><code>#define LOCATION 0x68feac //Assuming that the memory location is available

int main()
{
    int a = 10;
    // dereferencing the address at LOCATION, storing into it the address of a
    *((volatile int **)LOCATION) = &amp;a;
    printf(&quot;%p\n&quot;, *((volatile int **)LOCATION));
    printf(&quot;%x\n&quot;, **((volatile int **)LOCATION));
    return 0;
}
</code></pre>
",3
51107854,51107782,7,"<p>This appears to be a trick to force any non-zero number to <code>1</code>, while keeping zeros - alongside a more common <a href=""https://stackoverflow.com/q/10307281/335858""><code>!!(expr)</code> idiomatic construct</a>.</p>

<p>The idea is to set <code>LED_GRN</code> to <code>1</code> or <code>0</code> based on the value of <code>ivLEDGrnSequence &amp; ivLEDSlot</code>.</p>

<p>Other ways to do the same thing are as follows:</p>

<pre><code>LED_GRN = !!(ivLEDGrnSequence &amp; ivLEDSlot);
LED_GRN = (ivLEDGrnSequence &amp; ivLEDSlot) != 0;
</code></pre>
",4
52302369,52302332,5,"<p><code>while (currX)</code>  tests the truthiness of <code>currX</code>. It's effectively short for <code>while (0!=currX)</code>.</p>
",1
50919525,50919510,1,"<p>There's several ways to solve it, but this should work:</p>

<pre><code>typedef struct {
    char drzava[30];
    char grad[30];
    char adresa[50];
    char tip[10];
    int brojsoba;
    int brojradnika;

    struct {
        int sirina;
        int duzina;
        int povrsinasobe;
    } povrsina;

} izgradnja;
</code></pre>

<p>Or just split it up:</p>

<pre><code>typedef struct {
    int sirina;
    int duzina;
    int povrsinasobe;
} Povrsina;

typedef struct {
    char drzava[30];
    char grad[30];
    char adresa[50];
    char tip[10];
    int brojsoba;
    int brojradnika;
    Povrsina povrsina;
} izgradnja;
</code></pre>
",2
55499827,55498959,1,"<p>Use a bitmask to mark the numbers of the used columns:</p>

<p>[you could also use a plain indicator array of chars or ints]</p>

<hr>

<pre><code>#define ZBITS (CHAR_BIT*sizeof zzz[0])

#define ZTEST(z) (zzz[z/ZBITS] &amp; (1u&lt;&lt; (z%ZBITS)))
#define ZSET(z) zzz[z/ZBITS] |= (1u&lt;&lt; (z%ZBITS))

// size of A is nxn

/* ind_col is 1xn array that contains the column index of abs. max number for each row */
int *ind_col ; 
ind_col = calloc(n,sizeof *ind_col);    


/* max_val is 1xn array that contains the abs. max number for each row */
double *max_val ;  
unsigned *zzz;

max_val = calloc(n,sizeof  *max_val);
zzz = calloc(1+n/ZBITS, sizeof *zzz);               

int i,j;

for(i=0; i&lt;n; i++){ 
  for(j=0; j&lt;n; j++) { 
    double zabs;

    zabs = fabs(A[i*n+j]) ;
    if ( zabs &lt; max_val[i]) continue;  // no new max is found
    if (ZTEST(j)) continue; // check if the same column index was previously used

    ZSET(j); // close the door ...
    max_val[i] = zabs;             
    ind_col[i] = j;
    }

  }

free(zzz);

#undef ZBITS
#undef ZTEST
#undef ZSET
</code></pre>

<hr>

<p>UPDATE(2):</p>

<p><em>improved?</em> version using a <em>mark</em> array for the exclusion:</p>

<hr>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

unsigned *ihaveaname(double *A,unsigned n)
{

unsigned *ind_col ;
double *max_val ;
unsigned *mark;
unsigned irow,jcol;

ind_col = calloc(n,sizeof *ind_col);
max_val = calloc(n,sizeof  *max_val);
mark = calloc(n, sizeof *mark);

for(jcol=0; jcol&lt;n; jcol++) { ind_col[jcol] = n; } // sentinel
for(jcol=0; jcol&lt;n; jcol++) { mark[jcol] = n; } // sentinel
for(jcol=0; jcol&lt;n; jcol++) { max_val[jcol] = 0.0; }

for(irow=0; irow&lt;n; irow++){
  for(jcol=0; jcol&lt;n; jcol++) {
    double zabs;

    zabs = fabs(A[irow*n+jcol]) ;
    if (zabs &lt; max_val[irow]) continue;  // no new max is found
    if (mark[jcol] &lt; irow) { // check if the same column index was used by a previous row
                // fprintf(stderr,""[Skip col%u row%u]"", jcol,irow);
                continue;
                }
    if (jcol &gt; 0) { //undo previous submax
                unsigned ocol;
                ocol = ind_col[irow] ;
                if (ocol &lt;jcol) {
                        mark[ocol] = n; // reset sentinel ...
                        // fprintf(stderr,""[Undo ocol%u]"", ocol);
                        }
                }

    // fprintf(stderr,""[Mark col%u &lt;- row%u]"", jcol,irow);
    mark[jcol] = irow; // mark our row index in here ...

    max_val[irow] = zabs;
    ind_col[irow] = jcol;
    }

    // fprintf(stderr,""Max[%u] = %f\n"", irow,max_val[irow]);
  }
free(mark);
free(max_val);
return ind_col;
}

int main(void)
{
unsigned uu, *uuu;

double array[9]={
        1,2,3,
        2,3,1,
        3,1,2};

uuu = ihaveaname(array, 3);

for (uu=0;uu &lt; 3;uu++){
        printf(""%u:=%u\n"", uu, uuu[uu]);
        }
return 0;
}
</code></pre>
",6
55499827,55498959,1,"<p>Use a bitmask to mark the numbers of the used columns:</p>

<p>[you could also use a plain indicator array of chars or ints]</p>

<hr>

<pre><code>#define ZBITS (CHAR_BIT*sizeof zzz[0])

#define ZTEST(z) (zzz[z/ZBITS] &amp; (1u&lt;&lt; (z%ZBITS)))
#define ZSET(z) zzz[z/ZBITS] |= (1u&lt;&lt; (z%ZBITS))

// size of A is nxn

/* ind_col is 1xn array that contains the column index of abs. max number for each row */
int *ind_col ; 
ind_col = calloc(n,sizeof *ind_col);    


/* max_val is 1xn array that contains the abs. max number for each row */
double *max_val ;  
unsigned *zzz;

max_val = calloc(n,sizeof  *max_val);
zzz = calloc(1+n/ZBITS, sizeof *zzz);               

int i,j;

for(i=0; i&lt;n; i++){ 
  for(j=0; j&lt;n; j++) { 
    double zabs;

    zabs = fabs(A[i*n+j]) ;
    if ( zabs &lt; max_val[i]) continue;  // no new max is found
    if (ZTEST(j)) continue; // check if the same column index was previously used

    ZSET(j); // close the door ...
    max_val[i] = zabs;             
    ind_col[i] = j;
    }

  }

free(zzz);

#undef ZBITS
#undef ZTEST
#undef ZSET
</code></pre>

<hr>

<p>UPDATE(2):</p>

<p><em>improved?</em> version using a <em>mark</em> array for the exclusion:</p>

<hr>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

unsigned *ihaveaname(double *A,unsigned n)
{

unsigned *ind_col ;
double *max_val ;
unsigned *mark;
unsigned irow,jcol;

ind_col = calloc(n,sizeof *ind_col);
max_val = calloc(n,sizeof  *max_val);
mark = calloc(n, sizeof *mark);

for(jcol=0; jcol&lt;n; jcol++) { ind_col[jcol] = n; } // sentinel
for(jcol=0; jcol&lt;n; jcol++) { mark[jcol] = n; } // sentinel
for(jcol=0; jcol&lt;n; jcol++) { max_val[jcol] = 0.0; }

for(irow=0; irow&lt;n; irow++){
  for(jcol=0; jcol&lt;n; jcol++) {
    double zabs;

    zabs = fabs(A[irow*n+jcol]) ;
    if (zabs &lt; max_val[irow]) continue;  // no new max is found
    if (mark[jcol] &lt; irow) { // check if the same column index was used by a previous row
                // fprintf(stderr,""[Skip col%u row%u]"", jcol,irow);
                continue;
                }
    if (jcol &gt; 0) { //undo previous submax
                unsigned ocol;
                ocol = ind_col[irow] ;
                if (ocol &lt;jcol) {
                        mark[ocol] = n; // reset sentinel ...
                        // fprintf(stderr,""[Undo ocol%u]"", ocol);
                        }
                }

    // fprintf(stderr,""[Mark col%u &lt;- row%u]"", jcol,irow);
    mark[jcol] = irow; // mark our row index in here ...

    max_val[irow] = zabs;
    ind_col[irow] = jcol;
    }

    // fprintf(stderr,""Max[%u] = %f\n"", irow,max_val[irow]);
  }
free(mark);
free(max_val);
return ind_col;
}

int main(void)
{
unsigned uu, *uuu;

double array[9]={
        1,2,3,
        2,3,1,
        3,1,2};

uuu = ihaveaname(array, 3);

for (uu=0;uu &lt; 3;uu++){
        printf(""%u:=%u\n"", uu, uuu[uu]);
        }
return 0;
}
</code></pre>
",6
53674972,53674826,1,"<p>Since, (1) <code>a[x]</code> is <code>*(a+x)</code>, and consequently (2) <code>&amp;(a[x]) = a+x</code> </p>

<pre><code>    x &lt; y 
=&gt;  a+x &lt; a+y
=&gt; &amp;(*(a+x)) &lt; &amp;(*(a+y))  // from (2)  
=&gt; &amp;(a[x]) &lt; &amp;(a[y])      // from (1)
</code></pre>
",0
53674949,53674826,5,"<p>Yes, this is guaranteed.  Section 6.5.8p5 of the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""noreferrer"">C standard</a> regarding Relational Operators states:</p>

<blockquote>
  <p><strong>When  two  pointers  are  compared,  the  result  depends  on  the 
  relative  locations  in  the address space of the objects pointed to.</strong> 
  If two pointers to object types both point to the same  object,  or 
  both  point  one  past  the  last  element  of  the  same  array 
  object,  they compare  equal.   If  the  objects  pointed  to  are 
  members  of  the  same  aggregate  object, pointers  to  structure 
  members  declared  later  compare  greater  than  pointers  to 
  members declared  earlier  in  the  structure,  and  <strong>pointers  to 
  array  elements  with  larger  subscript values compare greater than
  pointers to elements of the same array with lower subscript values.</strong><br>
  All  pointers  to  members  of  the  same  union  object  compare 
  equal.   If  the expression P points  to  an  element  of  an  array 
  object  and  the  expression Q points  to  the last element of the
  same array object, the pointer expression Q+1 compares greater than P
  . In all other cases, the behavior is undefined</p>
</blockquote>

<p>So even if you have strange memory layouts, the language guarantees that the address of an array element with a higher subscript will compare greater that the address of an array element with a lower subscript.  As long as the array subscripts are valid the comparison will hold.</p>
",2
51619489,51617926,0,"<p>This is not a multiple assignment (which C does not support) - it's a <em>declaration</em> of two objects, one of which has an initializer.</p>

<p>This is way more detail than you want, but I don't want to work on what I'm supposed to be working on and need a distraction.  </p>

<p>The top-level syntax for a declaration of an object or function in C is as follows:</p>

<pre><code><em>declaration</em>:
    <em>declaration-specifiers</em> <em>init-declarator-list<sub>opt</sub></em> ;
</code></pre>

<p><code><em>declaration-specifiers</em></code> includes things like type specifiers (<code>int</code>, <code>float</code>, <code>double</code>, <code>struct xxx</code>, etc.), type qualifiers (<code>const</code>, <code>volatile</code>), and storage class specifiers (<code>static</code>, <code>register</code>, <code>auto</code>, <code>typedef</code>)</p>

<p><code><em>init-declarator-list<sub>opt</sub></em></code> is an optional list of <em>declarators</em>, each of which may have an optional initializer.  A <em>declarator</em> introduces the name of the thing being declared, along with its array-ness, pointer-ness, and/or function-ness.  </p>

<p>So when we look at the declaration:</p>

<pre><code>struct Node* temp = *head_ref, *prev;
</code></pre>

<p><code>struct Node</code> is part of the <code><em>declaration-specifiers</em></code>, while <code>*temp = *head_ref</code> and <code>*prev</code> make up the <code><em>init-declarator-list</code></em> (In a declaration, the <code>*</code> operator always binds to the declarator, not the type specifier - the above is parsed as <code>struct Node (*temp) = (*head_ref), (*prev)</code>).  </p>
",0
51618052,51617926,4,"<p>The definition</p>

<pre><code>struct Node* temp = *head_ref, *prev;
</code></pre>

<p>is the same as</p>

<pre><code>struct Node* temp = *head_ref;
struct Node *prev;
</code></pre>

<p>This is some very basic syntax, something that even a pretty bad tutorial or book should have shown.</p>
",0
48700129,48700093,1,"<p>This line:</p>

<pre><code>if(ptr=NULL)
</code></pre>

<p>Should be:</p>

<pre><code>if(ptr==NULL)
</code></pre>

<p>Otherwise, <code>ptr</code> gets assigned the value of <code>NULL</code> and <code>ptr=NULL</code> evaluates to false.  Hence, the <em>else clause</em> is run immediately after the <code>ptr</code> is assigned to <code>NULL</code>.</p>

<p>One other thing, to improve the readability of your for-loop, this is a bit more readable:</p>

<pre><code>   for(int i = 0; i &lt; n; i++)
   {
       scanf(""%d"",&amp;ptr[i]);
</code></pre>

<p>The <code>for</code> statement is standard for saying, <code>loop n times</code>.  The use of <code>&amp;ptr[i]</code> (or <code>ptr+i</code>) makes it a lot more obvious which address is being referenced.</p>
",4
48651348,48650970,2,"<p>It looks that you forgot to initialize count variable to 0:</p>

<pre><code>int count = 0;
</code></pre>

<p>You increment it and it can contain any random value, even negative.</p>

<p>Also, note that your utilization of <strong>strstr</strong> doesn't look correct. The function returns the pointer to <em>first</em> occurrence that matches. Note, that it doesn't remember already found matches, so if match exists it should loop forever in this loop. Instead it should look like:</p>

<pre><code>char *pos = buffer;
while((pos = strcasestr(pos, word)) != NULL){
  searchedWord = pos;
  /* do something with searchedWord but remember that it belongs to  
   allocated buffer and can't be used after free() */
  pos++;
}
</code></pre>
",3
51560295,51560280,8,"<p>We know what the size of <code>a</code> is even if it is not defined in this module. <code>sizeof</code> does not tell you how much memory has been allocated for an object in this module. It tells you how much memory the object requires.</p>
",0
51561055,51560280,6,"<p>Two points:</p>

<ol>
<li><p><code>sizeof</code> is evaluated at compile time, not run time<sup>1</sup>.  It doesn't depend on when <code>a</code> has actually been allocated.  This is because...</p></li>
<li><p><code>sizeof</code> operates on <em>types</em>, not objects.  When the operand is an object expression like <code>a</code>, the <em>type</em> of that expression is used.  Again, this is all done at compile time, when the type of an expression is known to the compiler.  </p></li>
</ol>

<p><hr>
<sup></p>

<ol>
<li> Except for variably modified types like VLAs.
</ol>

<p></sup></p>
",0
51560349,51560280,1,"<p><code>sizeof</code> returns the amount of memory allocated to that <code>data type</code>.</p>

<p>For <code>int</code> it is <code>4 bytes</code> and not <code>0 byte</code>, hence the output</p>

<p>This link will help you further with the details:</p>

<p><a href=""https://www.geeksforgeeks.org/sizeof-operator-c/"" rel=""nofollow noreferrer"">https://www.geeksforgeeks.org/sizeof-operator-c/</a></p>
",1
51560332,51560280,4,"<p>Just because the variable is not defined in this translation unit doesn't mean the compiler doesn't know its size.  If it didn't, it wouldn't be able to read or write from it.</p>

<p>The <code>sizeof</code> operator is valid on any variable or complete type, and <code>int</code> is a complete type.  If on the other hand you had a forward declaration of a struct:</p>

<pre><code>struct mystruct;
</code></pre>

<p>You couldn't calculate <code>sizeof(struct mystruct)</code> because the type is incomplete and thus the size can't be known.</p>
",0
48758138,44754943,2,"<p>Keep in mind that the C standard doesn't <em>actually</em> specify how this works under the covers, the description that follows is of a very common implementation method.</p>

<hr>

<p>With a single translation unit holding the code:</p>

<pre><code>int main() { fun(); }
</code></pre>

<p>the information available from that compiled (not yet linked) object file is basically:</p>

<pre><code>symbol  status   value
------  ------   -----
main    defined  pointer to main within object
fun     needed   zero
</code></pre>

<p>That's because it <em>knows</em> where <code>main</code> is but has no information on <code>fun</code> - it will need to be found later. So reading the object file will naturally return an unknown value for <code>fun</code>.</p>

<p>Of course, you will need some code to define <code>fun</code> as well, such as in another translation unit:</p>

<pre><code>void fun(void) { puts(""Hello, world.""); }
</code></pre>

<p>Compiling <em>this</em> would result in the following information:</p>

<pre><code>symbol  status   value
------  ------   -----
fun     defined  pointer to fun within object
puts    needed   zero
</code></pre>

<p>It's the <em>link</em> stage that ties these together. It takes <em>both</em> object files (and the object/library files for the any other dependencies, such as the C run-time library containing <code>puts</code>) and binds them together, making adjustments to all code that uses undefined symbols.</p>

<p>So what you end up with an executable file format where all symbols are known and all references are resolved.</p>
",0
54399639,54399580,11,"<blockquote>
<p>Can anyone explain me the output of this code?</p>
<p>infinite loop of spaces</p>
</blockquote>
<pre><code>char c[] = &quot;hello&quot;;

printf(&quot;%*d&quot;, c);
</code></pre>
<p>the <code>%*d</code> say the first arg after the format indicates the width, here it is the address of <em>c</em> interpreted as a huge number, and the default added character to respect the width is a space.</p>
<p>note there is a missing arg normaly giving the value to print</p>
<hr />
<p>if I use a valid code like that :</p>
<pre><code>#include &lt;stdio.h&gt;

int main()
{
  printf(&quot;%0*d\n&quot;, 3, 1);
  return 0;
}
</code></pre>
<p>the result is 001 because I ask for to write '1' with a width of 3 and the added character is '0'</p>
",0
50175401,50175053,2,"<pre><code>#define Paste(x, y)  x##y
#define Expand(x, y) Paste(x, y)

#define NBR 42
#define THE_ANS_IS Expand(theAnsIs, NBR)
</code></pre>
",0
53206899,53205846,1,"<p>I would create a function specific to the task and just use a mask.</p>

<pre><code>void setType(uint8_t type, uint8_t* header)
{
    header[0] = (header[0] &amp; 0x0f) | (type &lt;&lt; 4);
}

// To use:

uint8_t header[8]; 
setType(3, header);
</code></pre>

<p>I would create a similar function to set each field of the header.</p>

<p>The above assumes that by ""first four bits"" you mean the most significant bits of the first byte of the header rather than the least significant bits of the first byte of the header.</p>
",2
54451942,54451905,1,"<p>You most likely are suffering from line buffering in your terminal.  Until you write a newline character, any characters written are not displayed.</p>

<p>Try adding a newline when displaying your input:</p>

<pre><code>printf(""%s\n"", str);
</code></pre>

<p>The same goes for any other <code>printf</code> calls you do that you want to ensure are displayed.</p>

<p>By the way, your null-termination test is incorrect.  The escape character is <code>\</code>, not <code>/</code>.  Change your loop to:</p>

<pre><code>while (str[h] != '\0')
</code></pre>

<p>Or simply:</p>

<pre><code>while (str[h])
</code></pre>
",3
54452050,54451905,0,"<p>There are a few things wrong with your code here:</p>

<pre><code>while(isQuit(str) == 0)
{ 
    isPalindrome(str);
    return 0 ;
}
</code></pre>

<p>Since you have the return keyword in your loop body (unconditionally), the loop will execute at most one time.</p>

<p>Also, neither <code>isQuit</code> nor <code>isPalindrome</code> take input from the user.  This means that even if you were to fix the loop by removing the <code>return</code> statement, it <em>still</em> wouldn't be right; you'd have an infinite loop of <code>isQuit</code> and <code>isPalindrome</code> being passed the same <code>str</code> that the user got asked for on line 15.</p>

<p>What you have to do is change your <code>while</code> loop to continually poll the user for input and act upon it, in addition to the issues pointed out in @paddy's answer.</p>
",0
48224179,48219758,1,"<p>It was asked you parse an argument (not a string from <code>stdin</code>), so you need to use <code>argc</code> and <code>argv</code>. Also <code>sizeof(char)</code> is 1 by the C standard, so is superfluous. 
Don't duplicate <code>strlen</code> either, we have libraries for a reason.</p>

<p>I'd do it this way (which I confirmed works on my system)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int char_cmp(const void *pa, const void *pb){

    char a = *((char *) pa), b= *((char *) pb);
    if (a &lt; b){ 
        return -1;
    } else if (a &gt; b){ 
        return 1;
    } else {
       return 0;
    }   
}

int main(int argc, char *argv[]){

char *input= NULL;
if (2 != argc){
    fprintf(stdout, ""give one argument string\n"");
    return 1;
} else {
    input = strdup(argv[1]);
    if (NULL == input){ 
        fprintf(stderr, ""memory error\n"");
        return 2;   
    }       
}   
qsort(input, strlen(input), 1, char_cmp);
fprintf(stdout, ""%s\n"", input);
free(input);
return 0;

}
</code></pre>
",1
59442759,59442729,4,"<p>This (<code>scanf(""%d"",&amp;p);</code>) is the wrong code to read <code>int64_t</code>.  Formally, you need <code>scanf(""%"" SCNd64, &amp;p)</code> ¡ª and <code>&lt;inttypes.h&gt;</code> (instead of, or as well as, <code>&lt;stdint.h&gt;</code>).</p>

<p>You would probably get away with <code>scanf(""%lld"", &amp;p);</code> since on most machines, <code>int64_t</code> is a synonym for <code>long long</code>.</p>

<p>You should also check that <code>scanf()</code> returns <code>1</code> before using the result.</p>

<p>When you initialize <code>p</code>, you get the 'correct' part of <code>p</code> set by the <code>scanf()</code> call because you're on a little-endian machine, and the remainder is zero as you want.  But doing that invokes undefined behaviour.  Anything could happen.  It is unportable (it probably won't do what you want on big-endian machines), and completely unreliable because it is undefined behaviour.</p>
",0
59442755,59442729,4,"<p>You¡¯ve declared <code>p</code> as an <code>int64_t</code>, but <code>%d</code> means <code>int</code>. The conversion specifiers for <code>int64_t</code> and other <code>stdint.h</code> types live in <code>inttypes.h</code>:</p>

<pre><code>#include &lt;inttypes.h&gt;
</code></pre>

<pre><code>scanf(""%"" SCNd64, &amp;p);
</code></pre>

<p>Similarly, when printing it (using the correct specifier here would have shown you the problem):</p>

<pre><code>printf(""i:%"" PRId64 "" &lt; number:%"" PRId64 ""\n"", i, number);
</code></pre>

<p>Both of these mistakes are something good compilers should be able to warn you about ¨C for example, clang will do it by default. If you¡¯re using gcc, be sure to compile with at least <code>gcc -Wall</code>.</p>

<p>Also, checking the return value of <code>scanf</code> to make sure it succeeded is a good idea. Exiting otherwise is fine if you don¡¯t want to do any deeper recovery.</p>

<pre><code>if (scanf(""%"" SCNd64, &amp;p) != 1) {
    return EXIT_FAILURE;
}
</code></pre>

<p>Finally, the correct return type for <code>main</code> is <code>int</code>, not <code>int32_t</code>.</p>
",1
56717620,56717553,9,"<p>This is undefined behavior, anything can happen included something that looks like correct. But <strong>it is</strong> incorrect.
Your compiler can probably tell you the problem if you use correct options.</p>

<p>Standard says (emphasized is mine):</p>

<blockquote>
  <p>7.21.6.1 The <strong>fprintf</strong> function</p>
  
  <ol start=""2"">
  <li>The fprintf function writes output to the stream pointed to by stream,
  under control of the string pointed to by format that specifies how
  subsequent arguments are converted for output. <strong>If there are
  insufficient arguments for the format, the behavior is undefined.</strong> If
  the format is exhausted while arguments remain, the excess arguments
  are evaluated (as always) but are otherwise ignored. The fprintf
  function returns when the end of the format string is encountered.</li>
  </ol>
</blockquote>
",1
48672714,48670422,0,"<p>One way to ensure you can use a 64 bit integer with a C89 compiler:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;limits.h&gt;
typedef unsigned long uint64_t;

int main() {
    uint64_t some_int = 123456789;
    assert(CHAR_BIT * sizeof(long) &gt;= 64);
    printf(""Your int is: %lu\n"", some_int);
    return 0;
}
</code></pre>
",10
48672609,48670422,2,"<p>The phrase ""ANSI C"" commonly refers to the language defined by the 1989 ISO C standard. The 1990 ISO C standard describes exactly the same language (it adds some ISO-mandated sections). ANSI officially dropped its own 1989 standard and adopted the ISO standard -- and has also adopted the 1999 and 2011 editions of the ISO C standard. So the C standard defined by ANSI is the 2011 ISO C standard.</p>

<p>Because of this ambiguity, I suggest avoiding the phrase ""ANSI C"" and referring to the year in which the standard was published by ISO: C90, C99, or C11.</p>

<blockquote>
  <p><strong>What format specifier should I use to print double-length integers in 32-bit ANSI C?</strong></p>
</blockquote>

<p>There is none.</p>

<p>C90 did not support the  and  header or the type <code>long long</code>. It did not require support for any 64-bit integer type (<code>long</code> <em>may</em> be 64 bits, but is commonly 32). Because the types didn't exist, <code>printf</code> provided no format specifiers for them.</p>

<p>In principle, you could use a C90 implementation that supports 64-bit <code>long</code> (sacrificing portability), or you could implement your own 64-bit type using an array of narrower integers, providing operations as functions.</p>

<p>If you could update your question to explain exactly <strong>why</strong> you want to restrict yourself to a 29-year-old version of the C standard, it might be possible to give a more useful answer. I'd tell you simply to use an implementation that support C99 or C11, but you've indicated that's not a solution (without explaining why).</p>
",1
57881229,57881199,1,"<p>You don't. You use something else. Perhaps <code>popen</code></p>

<pre><code>FILE *fp = popen(""./askname"", ""w"");
fprintf(fp, ""%s\n"", foo);
</code></pre>
",0
56905556,56905425,1,"<p><strong>EDIT:</strong> I'm pretty sure it's a bug and you should consider it a false positive. See the links in the bottom.</p>

<p>I can't see any bitfields in the code you pasted?</p>

<p>It would've made sense if the code looked like this:</p>

<pre><code>
struct s
{
  char a : 4;
  char b : 4;
};

int main()
{
  struct s S;
  S.a = 0;
  S.b = 0;

  return 0;
}
</code></pre>

<p>I noticed these reports of seemingly false positives regarding that same warning, on TI's forum: <a href=""https://e2e.ti.com/support/tools/ccs/f/81/t/317480?ULP-15-1-Question"" rel=""nofollow noreferrer"">https://e2e.ti.com/support/tools/ccs/f/81/t/317480?ULP-15-1-Question</a>
<a href=""https://e2e.ti.com/support/microcontrollers/msp430/f/166/t/317382?ULP-15-1-Question"" rel=""nofollow noreferrer"">https://e2e.ti.com/support/microcontrollers/msp430/f/166/t/317382?ULP-15-1-Question</a></p>

<p>I know they're old, but unless you're using latest version of CCS, this might be a case of a false positive?</p>
",5
54601572,54601450,5,"<p>Since you want to allocate a 2D array, you first need to allocate an array of <code>struct pixel *</code>:</p>

<pre><code>struct pixel **ptrs = malloc(height * sizeof(struct pixel*));
</code></pre>

<p>There are several changes here to note:</p>

<ol>
<li>You are allocating pointers to <code>struct pixel</code>, not <code>unsigned char</code>. </li>
<li><code>malloc()</code> returns a pointer. Multiplying a pointer by an integer is invalid.</li>
<li>The multiplication goes in the parentheses because it helps calculate the correct number of bytes to allocate.</li>
</ol>

<p>Next you need to allocate an array of <code>struct pixel</code> for each row in the 2D array:</p>

<pre><code>for (int i=0, i&lt;height, i++) {
    ptrs[i] = malloc(width * sizeof(struct pixel));
}
</code></pre>

<p>Now the array is completely allocated and you can fill it in with data:</p>

<pre><code>ptrs[5][6] = { 255, 0, 0}; // a blue pixel
</code></pre>

<p>Finally remember to <code>free()</code> all of your pointers before you exit your program:</p>

<pre><code>for (int i=0, i&lt;height, i++) {
    free(ptrs[i]);
}

free(ptrs);
</code></pre>
",2
48629929,48629795,4,"<p>The line </p>

<pre><code>if(fp=NULL){
</code></pre>

<p>Should be</p>

<pre><code>if(fp==NULL){
</code></pre>

<p><code>gcc</code> with <code>-Wall</code> option should have warn you about this.</p>

<p>I advice you to write <code>if (NULL == fp){...</code> that way, if <code>==</code> becomes a <code>=</code>, the compiler won't emit a warning, but an error telling you that you cannot change the <code>NULL</code> value...</p>
",5
50689348,50689304,1,"<p><code>strcat</code> modifies the <code>destination</code> parameter buffer, <a href=""https://stackoverflow.com/questions/2589949/string-literals-where-do-they-go"">but <code>a</code>'s buffer is in read-only memory as it's a string literal</a>.</p>

<p>The solution is to create a buffer at runtime and use that as the buffer. You'll need to copy <code>a</code> into it first, of course.</p>

<pre><code>char* a = ""1234567890"";
char* b = ""abcdefghij"";

size_t aLen = strlen( a );

char* combined = malloc( sizeof(char) * ( strlen(a) + strlen(b) + 1 ) );
strcpy_s( combined, aLen, a ); // always use _s versions of string/buffer functions!
strcat( combined, b );

puts( combined );

free( combined );
</code></pre>

<p>Alternatively in C99 we could just use a stack-allocated array that's preinitialized (and preallocated to be large enough). Stack arrays, including pre-initialized ones, <em>can</em> have their buffer written to:</p>

<pre><code>char a[100] = ""1234567890"";
strcat( a, ""abcdefghij"" );
puts( a );
</code></pre>
",10
56585323,56585206,3,"<p>You may want to <em>initialize</em> your <code>descr</code></p>

<pre><code>char descr[6][20] = {
    ""name0"",
    ""name1"",
    ""name2"",
    ""name3"",
    ""name4"",
    ""name5"", /* you may leave the last comma out */
};
</code></pre>

<p>This initialization <strong>not</strong> (usually) go into a header file.</p>

<p>If you don't want to initialize and prefer later assignments (like in your original code) use <code>strcpy</code>.</p>

<pre><code>char descr[6][20];
strcpy(descr[0], ""name0"");
/* ... */
</code></pre>

<p>Again, this code is <strong>not</strong> meant for a header file.</p>
",2
54412283,54412171,3,"<p>References, i.e. an argument preceeded by an <code>&amp;</code> like in your <code>int around(int &amp;count1,int &amp;count2,int &amp;count3)</code> is a C++-feature and not available in C.</p>

<p>Anyway, none of your functions is actually altering the arguments, so passing ""by reference"" makes no sense.</p>

<p>Changing all your functions (and their forward declarations) that look like</p>

<pre><code>int around(int &amp;count1,int &amp;count2,int &amp;count3) ...
</code></pre>

<p>into </p>

<pre><code>int around(int count1, int  count2, int  count3) ...
</code></pre>

<p>Should solve the issue for a C-compiler.</p>

<p>For a C++-compiler it would have worked anyway.</p>
",0
50940323,50939968,0,"<p>You're not copying anything at all in that snippet.</p>

<pre><code>first_phrase += buf[i];
</code></pre>

<p>Adds the (integer code) of the i-th character in buf to the uninitialised pointer <code>first_phrase</code>. Adding a random number to an unitialised variable is meaningless but it's not illegal.</p>

<p>Trying to see what an unitialised pointer happens to point at <em>is</em> illegal, because the pointer doesn't point at anything.1 You probably do that later in your code, at which point your program will segfault (if you're lucky).</p>

<hr>

<p>1 And the fact that it's been incremented to some other unspecified value doesn't make it more or less legal.</p>
",0
48837702,48837599,1,"<p>You are passing the wrong types all over the place.</p>

<pre><code>char input[14];
</code></pre>

<p>this declares an <code>char</code> array of dimension 14. <code>input[i]</code> is the <code>i</code>th <code>char</code> in
the array, it has type <code>char</code>. It's not a pointer, you cannot dereference it,
that's why <code>*input[x]</code> fails. In fact the compiler should have given you an
error there, this error:</p>

<pre class=""lang-none prettyprint-override""><code>invalid type argument of unary ¡®*¡¯ (have ¡®int¡¯)
</code></pre>

<p>The same problem with <code>atoi</code>. It expects a pointer to <code>char</code> that points to a
string. <code>input[x]</code> is single <code>char</code>, you cannot pass to <code>atoi</code>. Again the
compiler should have warned you.</p>

<pre><code>fscanf(fp,""%s%c"",input, &amp;newlineC)
</code></pre>

<p>This is very clumsy. If the input is larger than 13 characters, you will
overflow the buffer. A better way would be:</p>

<pre><code>fscanf(fp, ""%13s%c"", input, &amp;newline);
</code></pre>

<p>Or even better</p>

<pre><code>int val;
fscanf(fp, ""%d"", &amp;val);
</code></pre>

<p>Another error: if you know that <code>input[x]</code> is a digit, then the integer that the
digit represent is <code>input[x] - '0'</code>. So this should be the calculation:</p>

<pre><code>val = val + input[x] - '0';
</code></pre>

<p>Overall I would use <code>fgets</code> and <code>strtol</code>:</p>

<pre><code>while(fgets(input, sizeof input, fp))
{
    long int val;
    char *tmp;

    val = strtol(line, &amp;tmp, 0);

    if(*tmp == 0 || *tmp == '\n')
        printf(""An integer was read: %ld\n"", val);
    else
        printf(""More than an integer was read: '%s'\n"", line);
}
</code></pre>
",2
52146986,52145506,0,"<p>This answer may work if your platform has a simple varargs handling, like most platform do. If your platform do not permit va_list object to be trivially copied this cannot work. On most platforms va_copy is a simple macro that does some thing like:</p>

<pre><code>#define va_copy(dest, src) dest = src
</code></pre>

<p>... this is the case for x86, ppc and many other targets. Anyway here is the code, I hope it works, I've no way to test or confirm it works without knowing the platform you are using it on!</p>

<pre><code>int fun(char **buf, size_t buf_size, const char *fmt, va_list ap) {
  va_list ap_copy = ap;
  int len;
  /* first call*/
  va_start(ap_copy, fmt);
  len = vsnprintf(*buf, buf_size, fmt, ap_copy);
  va_end(ap_copy);
  if(len &gt;= buf_size)
  {
      /* 2nd call*/
      va_start(ap, fmt);
      len = vsnprintf(*buf, len + 1, fmt, ap);  //new_vsnprintf()
      va_end(ap);
  }  
}   
</code></pre>
",1
52146986,52145506,0,"<p>This answer may work if your platform has a simple varargs handling, like most platform do. If your platform do not permit va_list object to be trivially copied this cannot work. On most platforms va_copy is a simple macro that does some thing like:</p>

<pre><code>#define va_copy(dest, src) dest = src
</code></pre>

<p>... this is the case for x86, ppc and many other targets. Anyway here is the code, I hope it works, I've no way to test or confirm it works without knowing the platform you are using it on!</p>

<pre><code>int fun(char **buf, size_t buf_size, const char *fmt, va_list ap) {
  va_list ap_copy = ap;
  int len;
  /* first call*/
  va_start(ap_copy, fmt);
  len = vsnprintf(*buf, buf_size, fmt, ap_copy);
  va_end(ap_copy);
  if(len &gt;= buf_size)
  {
      /* 2nd call*/
      va_start(ap, fmt);
      len = vsnprintf(*buf, len + 1, fmt, ap);  //new_vsnprintf()
      va_end(ap);
  }  
}   
</code></pre>
",1
55558630,55558522,0,"<p>You've implemented your insert() function so that it <em>modifies</em> its first parameter. To do that, you have to pass the root by pointer; if you passed it by value (a <code>bintree_node_t*</code>), a change of the root inside <code>BinTree_insert()</code> would not be reflected outside the function (though changes to the root <em>node</em> would be).</p>

<p>For example, if the tree is empty (root equals NULL), your insertion function creates a new node, and has the root pointer point at that node; that can't be done if you want to keep the original root pointer, which would continue being NULL.</p>

<p>What you could do is have the insertion function return the new root. Then you could pass the old root as a <code>bintree_node_t*</code> (i.e. by value).</p>
",0
57873036,57872852,0,"<p>What's most likely here is that some other part of the program managed to allocate the 8 (or 16, depending on architecture) bytes in memory directly after arr2, so arr3 ended up being allocated after those bytes. Therefore, when you wrote 210 and 211, those actually overwrote that other memory before the remainder were written to arr3.</p>
",1
50869062,50868974,8,"<p>According the the C11 standard <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">n1570</a> (see its ¡ì7.21.6.1) you've got <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><strong>undefined behavior</strong></a> (UB), which is also documented <a href=""http://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer"">here</a> or in <a href=""http://man7.org/linux/man-pages/man3/printf.3.html"" rel=""nofollow noreferrer"">printf(3)</a>. So be <em>very</em> <a href=""https://stackoverflow.com/a/46526702/841108"">scared</a>, since arbitrarily bad things could happen. So take the habit of reading the documentation of every function that you are using.</p>

<p>If you ask your compiler to disassemble the generated form of your program (e.g. by compiling with <code>gcc -S -O -fverbose-asm</code> if you <a href=""https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html"" rel=""nofollow noreferrer"">use</a> GCC, on Linux/x86-64) you'll discover that the address of the string literal <code>""10+10""</code> is passed (on 64 bits) and then truncated (inside <code>printf</code>, because of the <code>%d</code>) to an <code>int</code>. So the 17661648 could correspond to the lowest 32 bits of that address.</p>

<p>Details are of course implementation specific (and could vary from one run to the next one because of <a href=""https://en.wikipedia.org/wiki/Address_space_layout_randomization"" rel=""nofollow noreferrer"">ASLR</a>, depends upon the compiler and the <a href=""https://en.wikipedia.org/wiki/Application_binary_interface"" rel=""nofollow noreferrer"">ABI</a> and the target system). To actually understand and explain the behavior requires diving into many details (your particular computer, your particular <a href=""https://en.wikipedia.org/wiki/Compiler"" rel=""nofollow noreferrer"">compiler</a> and <a href=""https://en.wikipedia.org/wiki/Optimizing_compiler"" rel=""nofollow noreferrer"">optimization</a> flags, your particular <a href=""https://en.wikipedia.org/wiki/Operating_system"" rel=""nofollow noreferrer"">operating system</a>, the compiler generated assembler &amp; machine code, your particular <a href=""https://en.wikipedia.org/wiki/C_standard_library"" rel=""nofollow noreferrer"">C standard library</a>, etc....) and you don't want to do that (because it could take years).</p>

<p>You should take several hours to read more <a href=""http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html"" rel=""nofollow noreferrer"">about UB</a>. It is an essential notion to understand when programming in C, and you should avoid it.</p>

<p>Any good compiler would have warned you, and then you should improve your code to get no warnings. If using GCC, be sure to compile with <code>gcc -Wall -Wextra -g</code> to get all warnings and debug info. Then <a href=""https://sourceware.org/gdb/current/onlinedocs/gdb/"" rel=""nofollow noreferrer"">use the <code>gdb</code> debugger</a> to understand the actual behavior of your program on your system. In all cases, be sure to configure your C compiler to enable all warnings and debug info, and learn to use your debugger. Read <a href=""https://ericlippert.com/2014/03/05/how-to-debug-small-programs/"" rel=""nofollow noreferrer""><em>How To Debug Small Programs</em></a>.</p>
",3
59060240,59060201,2,"<p>Yes, this is valid and common. One of the reasons for using dynamic allocation is because the memory needs to be used outside of the function that allocates it -- if it only needed to be used locally, you might have been able to use a local variable. In this case, you'll necessarily have to free it in some other function.</p>
",0
54756852,54756704,0,"<h2>Pointer Arithmetic</h2>
<p>When a pointer points into an array, adding integers to the pointer or subtracting integers from the pointer moves the pointer back and forth within the array.</p>
<p>This function should be passed a <code>char *s</code> that points to a string, which is an array of characters ending in a null character (<code>'\0'</code>). Then  <code>size_t len = strlen(s);</code> sets <code>len</code> to the size of this string, and <code>char *t = s+len-1;</code> sets <code>t</code> to point to the last character before the null character.</p>
<p>Then, in the loop <code>t=t-1;</code> moves <code>t</code> backward.</p>
<p>Unfortunately, this loop uses <code>t&gt;=s</code> as its control condition. This is intended to stop when <code>t</code> has been moved to the character before <code>s</code>, meaning it has gone back before the start point. However, the C standard only defines pointer arithmetic for elements within the array plus a special position at the end of the array. If this function is passed an <code>s</code> that points to the beginning of an array, then the loop will eventually make <code>t</code> point before the array, and the C standard does not define the resulting behavior.</p>
<h2>Other Things to Know About Pointer Arithmetic</h2>
<p>Any object may be treated as an array of one element. If you have some type <code>T</code> and some object <code>T x;</code>, you may set a pointer <code>T *p = &amp;x;</code>, and then it is allowed to advance the pointer by one element, <code>p = p+1;</code>. Dereferencing that pointer with <code>*p</code> is not defined, but you can compare it, as in <code>&amp;x == p</code>, or you can subtract one from it.</p>
<p>If <code>print_reverse</code> were passed a pointer into an array beyond the beginning, then its loop would be okay. However, that is now how it is used in the example code; <code>print_reverse(&quot;Hello&quot;);</code> is not good code.</p>
<p>Any object may be treated as an array of characters. You can convert a pointer to any object to a pointer to <code>unsigned char</code> and then examine the bytes that make up an object. This is used for special purposes. You should not use it in general code while you are learning C, but you should be aware it exists.</p>
",0
57841936,57841904,2,"<blockquote>
  <p>Why do I get 7 with <code>PRODUCT(i+1)</code>?</p>
</blockquote>

<p>because <code>3+1*3+1</code> == <code>3+3+1</code></p>

<hr>

<p>Try <code>#define PRODUCT(x) ((x) * (x))</code></p>
",0
54740054,54739051,2,"<p>Ok, so you understand the first recursive bit fine (keep incrementing dst to find the end).</p>

<p>Once you've found the end, it's time to start copying. The code it's using to copy one byte is: (*dest++ = *src++)</p>

<p>It might help your understanding to expand that code to something like: *dest = *src; dest += 1; src += 1 
(because they are post-increment operators)</p>

<p>Now, a normal 'copy' function would repeat that statement in a <em>while</em> or <em>for</em> loop, but because we are cleverly showing off, we use a second ternary operator and recursion. The final '0' doesn't really do anything, but it needs to be there as the ""else"" part of the ternary operator.</p>

<p>While this may not be the worst implementation of <em>strcat</em> ever written, it's certainly a strong contender. </p>
",1
48294997,48294924,2,"<p><code>int val1 = (val&amp;0xf) + ((val&gt;&gt;4)&amp;0xf)*10</code></p>

<p>add parentheses around <code>val&amp;0xf</code>, check c operator precedence for details.</p>

<p>if you want hex format, use <code>printf(""%x"", ...)</code></p>

<hr>

<ol>
<li><a href=""http://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/c/language/operator_precedence</a></li>
</ol>
",2
55192444,55192398,7,"<p>There are two different things going on here to be aware of:</p>

<ol>
<li>The <em>source C file itself</em> may not be able to contain this character correctly.</li>
<li>The <code>char</code> type within the semantics of the actual program does not support this character, either.</li>
</ol>

<p>As to the first issue, it depends on your platform (etc) but being conservative with C source is most portable, which means sticking to ASCII characters only within the code file. That means, e.g., in comments as well as within meaningful code. That said, lots of platforms will allow and support Unicode characters inside the source files.</p>

<p>Regarding the second, a <code>char</code> is old-fashioned for containing characters, and is limited to an octet, which means <a href=""https://www.fileformat.info/info/unicode/char/221a/index.htm"" rel=""noreferrer"">arbitrary unicode characters</a> with values above 0xFF just don't fit inside of them. I suppose some non-ASCII characters do in a platform dependent way (Windows code pages?) above value 0x7F, but in this case, I would treat this as a string, using a unicode escape sequence for this character: <code>""\u221A""</code>. </p>

<pre><code>char * sqrt = ""\u221A"";
if (strcmp(sqrt, ""\u221A"") == 0) {
    printf(""Working"");
} else {
    printf(""Not working"");
}
</code></pre>

<p>Heads-up that C strings (<code>char*</code>) are not really designed around non-ASCII characters either, so in this case you end up embedding the UTF8 encoded representation of the character (which is three bytes long) inside the char string. This works, preserves the value, and the compare works, but if you're going to be working with unicode more generally...</p>

<p>If your platform supports ""wide characters"" (<code>wchar_t</code> or <code>unichar</code> or similar) that can hold Unicode characters, then you can use those types to hold this character, and do direct equality comparisons like you were doing:</p>

<pre><code>wchar_t sqrt = L'\u221A';
if (sqrt == L'\u221A') {
    ...
</code></pre>

<p>(FYI Be a little aware that these wide char types may not be wide enough for arbitrary Unicode code points on your platform thus might work for the square root char, but not, say, an emoji.)</p>

<hr>

<p>Finally, for the sake of completeness, I feel honor-bound to admit that given a contemporary development environment/toolchain <em>and</em> target platform, you could probably get away with using the explicit character in a widechar literal like so:</p>

<pre><code>wchar_t sqrt = L'¡Ì';
if (sqrt == L'¡Ì') {
    ....
</code></pre>

<p>But I'm old-fashioned, this feels sketchy, and I don't recommend it. :) </p>
",5
48919808,48919256,0,"<p>There are many beginner mistakes in the code.
Let me point you one by one.</p>
<hr />
<pre><code>char* a=&quot;oooat&quot;;
a=my_unique(a, a+strlen(a));
cout&lt;&lt;a;
</code></pre>
<ol>
<li><p>When you declare a string like this : <code>char* a=&quot;oooat&quot;</code>, <code>a</code> is a string literal. The memory for the string is allocated into text section of the program. Which basically means you cannot modify the values inside the strings. You can only read from them. Hence when you are passing pointer <code>a</code> to the function and modifying it, it will result in segmentation fault(Illegal access to memory).</p>
</li>
<li><p>Why do you need a ret pointer here? <code>char* ret=first;</code></p>
<p>You are passing a pointer and modifying the value inside it. Hence the new data will be reflected in the calling function and we need not return it explicitly. So, it is redundant.</p>
</li>
<li><p>Overall logic can be simplified as well</p>
</li>
</ol>
<hr />
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define MYSTR &quot;ooooat&quot;

void my_unique(char *first, char *last) {
    int size = last - first;
    int i = 0, j = 0, k = 0;

    for (; i &lt; size; i++, j++) {
        first[j] = first[i];
        // Continue to check how many repetitions are there
        while (i + 1 &lt; size &amp;&amp; (first[i] == first[i+1])) i++;
    }

    // In the end terminate the string with a NULL.
    first[j] = '\0';
    return;
}

int main()
{
    char a[] = MYSTR;
    my_unique(a, a+strlen(a));
    printf(&quot;%s&quot;, a);
    return 0;
}
</code></pre>
",0
48821801,48820700,0,"<pre><code>static void free_string_list(char** strings) {
   if (!strings)
      return;

   for (char** p = strings; *p; ++p)
      free(*p);

   free(strings);
}


// Correctly handles leading spaces.
// Correctly handles trailing spaces.
// Correctly handles multiple spaces.
// Return NULL and sets errno on error.
// Free result with free_string_list otherwise.
static char** split_into_words(const char* s) {
   size_t count = 0;
   {
      const char *src = s;
      while (1) {
         while (*src &amp;&amp; *src == ' ')
            ++src;

         if (!*src)
            break;

         while (*src &amp;&amp; *src != ' ')
            ++src;

         ++count;
      }
   }

   char** words = malloc(sizeof(char*) * (count+1));
   if (!words)
      goto ERROR;

   {
      const char *src = s;
      char** dst = words;
      while (1) {
         while (*src &amp;&amp; *src == ' ')
            ++src;

         if (!*src)
            break;

         const char* src_s = src;

         while (*src &amp;&amp; *src != ' ')
            ++src;

         const char* src_e = src;
         size_t len = src_e - src_s;
         char* dst_word = *dst = malloc(len+1);
         if (!dst_word)
            goto ERROR;

         memcpy(dst_word, src_s, len);
         dst_word[len] = 0;
         ++dst;
      }

      *dst = NULL;
   }

   return words;

ERROR:
   free_string_list(words);
   return NULL;
}


// Correctly handles exec failures (e.g. command not found and permission errors).
// Outputs error message on error.
// -1 = Error creating child or executing command.
//  0 = ok.
//  1 = Child killed or program returned an error.
int execute_command(char** cmd) {
   int pipefd[2];  // r,w
   pipefd[0] = -1;
   pipefd[1] = -1;
   if (pipe(pipefd) == -1) {
      perror(""pipe"");
      goto EXEC_ERROR;
   }

   {
      int flags = fcntl(pipefd[1], F_GETFD, 0);
      if (flags == -1) {
         perror(""fcntl F_GETFD"");
         goto EXEC_ERROR;
      }

      if (fcntl(pipefd[1], F_SETFD, flags | FD_CLOEXEC) == -1) {
         perror(""fcntl F_SETFD"");
         goto EXEC_ERROR;
      }
   }

   pid_t pid = fork();
   if (pid == -1) {
      perror(""fork"");
      goto EXEC_ERROR;
   }

   if (pid == 0) {
      close(pipefd[0]);
      execvp(cmd[0], cmd);
      int exec_errno = errno;
      perror(""exec"");
      write(pipe, &amp;exec_errno, sizeof(exec_errno));
      _exit(1);
   }

   close(pipefd[1]);
   pipefd[1] = -1;

   {
      int exec_errno;
      ssize_t bytes_read = read(pipefd[0], &amp;exec_errno, sizeof(exec_errno));
      if (bytes_read == -1) {
         perror(""read"");
         goto EXEC_ERROR;
      }

      if (bytes_read != 0) {
         errno = exec_errno;
         perror(""exec"");
         goto EXEC_ERROR;
      }
   }

   close(pipefd[0]);
   pipefd[0] = -1;

   int status;
   if (waitpid(pid, &amp;status, 0) == -1) {
      perror(""waitpid"");
      goto EXEC_ERROR;
   }

   if (WIFSIGNALED(status)) {
      fprintf(stderr, ""Child killed by signal %d\n"", WTERMSIG(status));
      goto PROGRAM_ERROR;
   }

   if (WEXITSTATUS(status) &gt; 0) {
      fprintf(stderr, ""Child exited with error %d\n"", WEXITSTATUS(status));
      goto PROGRAM_ERROR;
   }

   return 0;

EXEC_ERROR:
   if (pipefd[0] != -1) close(pipefd[0]);
   if (pipefd[1] != -1) close(pipefd[1]);
   return -1;

PROGRAM_ERROR:
   return 1;
}

int main(void) {
   int rv = 1;
   char* line = NULL;
   size_t line_size = 0;
   char** cmd = NULL;

   while (1) {
      ssize_t num_read = getline(&amp;line, &amp;line_size, stdin);
      if (num_read == -1) {
         if (errno) {
            perror(""getline"");
            goto ERROR;
         }

         break;
      }

      if (line[num_read-1] == '\n')
         line[num_read-1] = 0;

      char** cmd = split_into_words(line);
      if (!cmd) {
         perror(""malloc"");
         goto ERROR;
      }

      if (strcmp(cmd[0], ""exit"") == 0)
         break;

      if (execute_command(cmd) == -1)
         goto ERROR;

      free_string_list(cmd);
      cmd = NULL;
   }

   rv = 0;
ERROR:
   free_string_list(cmd);
   free(line);
   return rv;
}
</code></pre>

<p>Untested.</p>
",0
58919382,58919243,1,"<p>Octal <code>015</code> is base-10 value <code>13</code><br>
Hex value <code>0x71</code> is base-10 value <code>113</code><br>
<code>5</code> is base-10.</p>

<p>Add together <code>13 + 113 + 5</code>, and you get <code>131</code></p>
",0
58919344,58919243,1,"<p>In C, a number starting with <code>0</code> is in octal (base 8), and a number starting with <code>0x</code> is in hexadecimal (base 16).</p>

<p><code>015 + 0x71 + 5</code> is 15<sub>8</sub> + 71<sub>16</sub> + 5 = (1?8 + 5) + (7?16 + 1) + 5 = 13 + 113 + 5 = 131.</p>
",0
57826747,57826621,4,"<p>You need to use the arrow <code>-&gt;</code> operator when you have a pointer to a struct (or union) <strong>on the left</strong>, and the dot <code>.</code> operator when you have a struct on the left. It doesn't depend on what's on the right.</p>

<p>If <code>person</code> was a pointer to a single <code>Person</code>, to access its field, you'd use <code>person-&gt;name</code> and <code>person-&gt;age</code>.</p>

<p>But here <code>person</code> is evidently a pointer to the first element of an array of <code>Person</code>. (A pointer to the first element is how arrays are passed around in C.) To access an individual element of the array, you use the subscript operator (square brackets <code>[¡­]</code>): <code>person[i]</code>. <code>person[i]</code> is the element with index <code>i</code>, not a pointer to the element with index <code>i</code>. Since <code>person[i]</code> is a struct, you use the dot operator to access its fields.</p>

<hr>

<p>In addition, as others have already remarked, <code>free(person);</code> inside the loop doesn't make sense. You'd free the whole array as soon as you've processed the first element. Call <code>free(person)</code> after the loop, once you've finished cleaning up all the elements of the array (assuming that <code>person</code> was allocated with <code>malloc</code>).</p>
",0
57826676,57826621,1,"<p><code>person-&gt;name</code> would be synonymous with <code>person[0].name</code>; since you want to refer to the name of an arbitrary <code>person</code>, you couldn't use <code>-&gt;</code> this way.</p>

<p>(I suppose you would use <code>(person+i)-&gt;name</code>, but your original code is clearer, IMHO.)</p>

<p>As for initializing <code>age</code>: what else would you use other than <code>.</code>?</p>

<p>P.S. <code>free</code>ing <code>person</code> inside the loop means a) you free it multiple times, and b) <code>person[i]</code> will be a problem after the first iteration.</p>
",0
54024773,54022229,1,"<p>Let's start with some background information.</p>

<p>First, the expression <code>++i</code> evaluates to the current value of <code>i</code> plus 1 - as a <em>side effect</em>, the value stored in <code>i</code> is incremented.  As a standalone expression, it's roughly equivalent to <code>i = i + 1</code>.  </p>

<p>Secondly, except when it is the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, an <em>expression</em> of type ""N-element array of <code>T</code>"" (<code>T [N]</code>) will be converted (""decay"") to an expression of type ""pointer to <code>T</code>"" (<code>T *</code>), and the value of the expression will be the address of the first element of the array.  </p>

<p>Finally, the expression <code>a[i]</code> is <em>defined</em> as <code>*(a + i)</code> - given a starting address <code>a</code>, offset <code>i</code> <em>elements</em> (not bytes!) from that address and dereference the result.  This means that the expression <code>a + i</code> is equivalent to the expression <code>&amp;a[i]</code>.  </p>

<p>Let's see how this applies to your code:</p>

<p>In the <code>increment</code> function, the line</p>

<pre><code>++ *ptr;
</code></pre>

<p>adds 1 to the thing that <code>ptr</code> points to.  </p>

<p>When you call <code>increment(a)</code>, the <em>expression</em> <code>a</code> has type ""2-element array of <code>int</code>"".  Since <code>a</code> is not the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, this expression ""decays"" to type ""pointer to <code>int</code>"" (<code>int *</code>), and the value of the expression is the address of the first element of <code>a</code>.  IOW, it's exactly the same as if you had written <code>increment(&amp;a[0])</code>.  Therefore, in the <code>increment</code> function, the following are true:</p>

<pre><code> ptr == &amp;a[0]
*ptr ==  a[0]
</code></pre>

<p>Thus, the expression <code>++ *ptr</code> is equivalent to the expression <code>++ a[0]</code>.  After this call, <code>a[0]</code> is now 6.</p>

<p>When you call <code>increment(&amp;i)</code>, <code>ptr</code> now points to <code>i</code>:</p>

<pre><code> ptr == &amp;i
*ptr ==  i
</code></pre>

<p>so <code>++ *ptr</code> is equivalent to the expression <code>++ i</code>, so you're adding 1 to <code>i</code>.  </p>

<p>When you call <code>increment(a[i])</code>, <code>i</code> is equal to 1, so this is equivalent to calling <code>increment(a[1])</code>.  After this call, <code>a[1]</code> is equal to 11.  </p>

<p>And finally, <code>increment(a+i)</code> is equivalent to <code>increment(&amp;a[i])</code>, which is equivalent to <code>increment(&amp;a[1])</code>, and after this call <code>a[1]</code> is equal to  12.  </p>
",0
54022321,54022229,0,"<blockquote>
  <p>but I am not sure what these operations do:</p>
</blockquote>

<p><code>increment(&amp;i);</code> passes the address of <code>i</code> variable to your increment function. That function dereferences the pointer and increments the pointed-to value, which is essentially equivalent to <code>i++</code>.</p>

<p><code>increment(&amp;a[i])</code> does the same, but now it passes the address of the <em>i</em>-th element of <code>a</code>. Since <code>i</code> was incremented to <code>1</code> before, it is equivalent to <code>a[1]++</code>.</p>
",0
54023122,54022229,0,"<p>Okay here's a step by step explanation in inline comments. Hope it helps. You may need to scroll horizontally to read the full comment.</p>

<pre><code>#include&lt;stdio.h&gt; 
// This function takes a pointer to int and increments the pointed value
void increment(int *ptr){++ *ptr;}      

int main(){ 
    int a[]={5,10},i=0; // It doesn't look so but here, a is a pointer to int
    increment(a);       // increments the first value pointed by a (a[0]) so now a is [6,10]
    increment(&amp;i);      // increments i, now i = 1
    increment(&amp;a[i]);   // increments a[1], now a = [6,11]
    increment(a+i);     // since i = 1, increments the value right after the one pointed by a so again, a[1], now a = [6,12]
    printf(""\nResult:i=%d\n"",i);        
    printf(""a[0]=%d\n"" ""a[1]= %d\n"");
    return 0 ;
}
</code></pre>
",4
54022352,54022229,0,"<p>The function <code>increment(int *ptr)</code> expects a pointer to an <code>int</code>, i.e. an address.</p>

<p>Since the variable <code>i</code> is of type <code>int</code> you have to pass its address by using the <em>address-of</em> operator <code>&amp;</code> as in: <code>increment(&amp;i)</code></p>

<p><code>a[i]</code> is equal to <code>*(a+i)</code> - i.e. you access the address of the array element at <code>a+i</code> and dereference it in order to get the value of that array element at position <code>i</code>.<br>
Same reason as in the first case, <code>increment</code> expects a pointer and therefore you have to pass an address as in: <code>increment(&amp;a[i]);</code></p>
",0
54024773,54022229,1,"<p>Let's start with some background information.</p>

<p>First, the expression <code>++i</code> evaluates to the current value of <code>i</code> plus 1 - as a <em>side effect</em>, the value stored in <code>i</code> is incremented.  As a standalone expression, it's roughly equivalent to <code>i = i + 1</code>.  </p>

<p>Secondly, except when it is the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, an <em>expression</em> of type ""N-element array of <code>T</code>"" (<code>T [N]</code>) will be converted (""decay"") to an expression of type ""pointer to <code>T</code>"" (<code>T *</code>), and the value of the expression will be the address of the first element of the array.  </p>

<p>Finally, the expression <code>a[i]</code> is <em>defined</em> as <code>*(a + i)</code> - given a starting address <code>a</code>, offset <code>i</code> <em>elements</em> (not bytes!) from that address and dereference the result.  This means that the expression <code>a + i</code> is equivalent to the expression <code>&amp;a[i]</code>.  </p>

<p>Let's see how this applies to your code:</p>

<p>In the <code>increment</code> function, the line</p>

<pre><code>++ *ptr;
</code></pre>

<p>adds 1 to the thing that <code>ptr</code> points to.  </p>

<p>When you call <code>increment(a)</code>, the <em>expression</em> <code>a</code> has type ""2-element array of <code>int</code>"".  Since <code>a</code> is not the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, this expression ""decays"" to type ""pointer to <code>int</code>"" (<code>int *</code>), and the value of the expression is the address of the first element of <code>a</code>.  IOW, it's exactly the same as if you had written <code>increment(&amp;a[0])</code>.  Therefore, in the <code>increment</code> function, the following are true:</p>

<pre><code> ptr == &amp;a[0]
*ptr ==  a[0]
</code></pre>

<p>Thus, the expression <code>++ *ptr</code> is equivalent to the expression <code>++ a[0]</code>.  After this call, <code>a[0]</code> is now 6.</p>

<p>When you call <code>increment(&amp;i)</code>, <code>ptr</code> now points to <code>i</code>:</p>

<pre><code> ptr == &amp;i
*ptr ==  i
</code></pre>

<p>so <code>++ *ptr</code> is equivalent to the expression <code>++ i</code>, so you're adding 1 to <code>i</code>.  </p>

<p>When you call <code>increment(a[i])</code>, <code>i</code> is equal to 1, so this is equivalent to calling <code>increment(a[1])</code>.  After this call, <code>a[1]</code> is equal to 11.  </p>

<p>And finally, <code>increment(a+i)</code> is equivalent to <code>increment(&amp;a[i])</code>, which is equivalent to <code>increment(&amp;a[1])</code>, and after this call <code>a[1]</code> is equal to  12.  </p>
",0
54022321,54022229,0,"<blockquote>
  <p>but I am not sure what these operations do:</p>
</blockquote>

<p><code>increment(&amp;i);</code> passes the address of <code>i</code> variable to your increment function. That function dereferences the pointer and increments the pointed-to value, which is essentially equivalent to <code>i++</code>.</p>

<p><code>increment(&amp;a[i])</code> does the same, but now it passes the address of the <em>i</em>-th element of <code>a</code>. Since <code>i</code> was incremented to <code>1</code> before, it is equivalent to <code>a[1]++</code>.</p>
",0
54022352,54022229,0,"<p>The function <code>increment(int *ptr)</code> expects a pointer to an <code>int</code>, i.e. an address.</p>

<p>Since the variable <code>i</code> is of type <code>int</code> you have to pass its address by using the <em>address-of</em> operator <code>&amp;</code> as in: <code>increment(&amp;i)</code></p>

<p><code>a[i]</code> is equal to <code>*(a+i)</code> - i.e. you access the address of the array element at <code>a+i</code> and dereference it in order to get the value of that array element at position <code>i</code>.<br>
Same reason as in the first case, <code>increment</code> expects a pointer and therefore you have to pass an address as in: <code>increment(&amp;a[i]);</code></p>
",0
54023122,54022229,0,"<p>Okay here's a step by step explanation in inline comments. Hope it helps. You may need to scroll horizontally to read the full comment.</p>

<pre><code>#include&lt;stdio.h&gt; 
// This function takes a pointer to int and increments the pointed value
void increment(int *ptr){++ *ptr;}      

int main(){ 
    int a[]={5,10},i=0; // It doesn't look so but here, a is a pointer to int
    increment(a);       // increments the first value pointed by a (a[0]) so now a is [6,10]
    increment(&amp;i);      // increments i, now i = 1
    increment(&amp;a[i]);   // increments a[1], now a = [6,11]
    increment(a+i);     // since i = 1, increments the value right after the one pointed by a so again, a[1], now a = [6,12]
    printf(""\nResult:i=%d\n"",i);        
    printf(""a[0]=%d\n"" ""a[1]= %d\n"");
    return 0 ;
}
</code></pre>
",4
51542958,51541606,1,"<p>And this is one of the reasons why I <em>strongly</em> recommend against <code>typedef</code>-ing pointer types - the <code>const</code> semantics apply to the pointer, not to what is being pointed to.  </p>

<pre><code>const pduong p;
</code></pre>

<p>means</p>

<pre><code>struct _duong * const p; // p is a const pointer to non-const type
</code></pre>

<p>not</p>

<pre><code>const struct _duong *p;  // p is a non-const pointer to const type
</code></pre>

<p>In other words, you are declaring <code>p</code> as a <em>const pointer</em> to <code>struct _duong</code>, not as a pointer to <code>const struct _duong</code>.  </p>

<p>Personally, I would recommend you ditch the <code>typedef</code> altogether and declare the pointer explicitly:</p>

<pre><code>const struct _duong *p;
</code></pre>

<p>Typedefs are great for abstracting away details, and <code>typedef</code>-ing pointer types is fine <em>if the user doesn't have to be aware of the ""pointer-ness"" of the type</em>.  In this case, the user <em>does</em> have to be aware of <code>p</code>'s ""pointer-ness"" to use it correctly, so its type should not be hidden behind a typedef.  </p>
",0
51541688,51541606,2,"<p>No the pointer itself is a constant.</p>

<p>I.e you cannot change the pointer. But whatever that pointer points to you can change.</p>

<p>To correct this change</p>

<pre><code>const pduong p; 
</code></pre>

<p>to</p>

<pre><code>const pduong p = &amp;DUONG;
</code></pre>

<p>And then drop the line</p>

<pre><code> p = &amp;DUONG;
</code></pre>

<p><strong>EDIT</strong></p>

<p>Perhaps you want</p>

<pre><code>const duong p_contents = {25, 165};
const pduong * const p = &amp;p_contents;
</code></pre>
",2
48796978,48796930,1,"<p>One way to do it is:</p>

<pre><code>static int arr1[] = {1,2,3,4};
static int arr2[] = {4,3,2,1};

int myFunc(int x) {
    int myArr[4];
    if (x &gt; 4) {
        memcpy(myArr, arr1, sizeof arr1);
    }
    else if (x &lt;= 4) {
        memcpy(myArr, arr2, sizeof arr2);
    }
}
</code></pre>

<p>But maybe you just need a pointer to the global array (if you aren't going to modify the copy, perhaps that is your case), so you can just store a pointer:</p>

<pre><code>int myFunc(int x) {
    const int* myArr;
    if (x &gt; 4) {
        myArr = arr1;
    }
    else if (x &lt;= 4) {
        myArr = arr2;
    }
}
</code></pre>
",1
48798325,48796930,0,"<p>One easy way is to use a pointers to the static global arrays. The name of the array is a pointer. 
Then your function <code>int myFunc(int x)</code> looks almost as your original one.</p>

<p>This is a sample code:</p>

<pre><code>#include&lt;stdio.h&gt;

static int arr1[] = {1,2,3,4,5,6};
static int arr2[] = {4,3,2,1};

int myFunc(int x) {
    int *myArr;
    size_t i;
    size_t myArrSize;

    if (x &gt; 4) {

        myArr = arr1;
        myArrSize = sizeof(arr1)/sizeof(int);
    }
    else if (x &lt;= 4) {

        myArr = arr2;
        myArrSize = sizeof(arr2)/sizeof(int);        
    }

    for(i=0; i&lt; myArrSize; i++)
        printf(""array[%d]=%d\n"", i , myArr[i]);

     printf(""\n"");
}

int main() {

   myFunc(6);
   myFunc(4);

   return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>array[0]=1
array[1]=2
array[2]=3
array[3]=4
array[4]=5
array[5]=6

array[0]=4
array[1]=3
array[2]=2
array[3]=1
</code></pre>

<p>As you can notice the sizes of <code>arr1</code> and <code>arr2</code> can be different. </p>
",0
52051193,52051133,3,"<p>The preprocessor works by <em>replacing</em> the macros in the code before the actual compilation takes place.</p>

<p>That means, your function declaration</p>

<pre><code>float pfa(int CM[M][M], int M ,int index)
</code></pre>

<p>will be compiled as</p>

<pre><code>float pfa(int CM[3][3], int 3 ,int index)
</code></pre>

<p>That is of course not a valid function declaration.</p>

<p>Instead, since you will not pass a matrix of differing size, you don't need the <code>M</code> argument:</p>

<pre><code>float pfa(int CM[M][M], int index)
</code></pre>

<hr>

<p>As an alternative, if the size of the matrix could be different from <code>MxM</code> and instead be variable, then it's easy to solve as well. Then we need to pass the size <em>first</em> and use it to create the matrix as a <a href=""https://en.wikipedia.org/wiki/Variable-length_array"" rel=""nofollow noreferrer"">variable-length array</a>:</p>

<pre><code>float pfa(size_t size, int CM[size][size], int index)
</code></pre>

<p>Note that this can be used even with the current code where the size will always be <code>M</code>.</p>
",2
52051571,52051133,0,"<p>The best way to write this program in modern C, is to not use a global constant, but the ""pointer to variable-length array"" feature:</p>

<pre><code>float pfa (size_t n, int CM[n][n], int index);

...

pfa(M, CM, index)
</code></pre>

<p>This removes tight coupling (unnecessarily strong dependency) between the constant and the function.</p>
",0
58161004,58160912,3,"<p>Initialization occurs when an object is created. For static objects, their lifetimes start when program execution starts. They are not reinitialized or reassigned when execution reaches the statements that define them.</p>
",0
49312981,49312672,1,"<p>Before we write any code, we should investigate what it is exactly that we should accomplish.</p>

<p>Let's consider a 4¡Á4 array and its transpose. For illustration, I shall use letters A to P to describe the values:</p>

<pre><code>A B C D                   A E I M
E F G H   transposed is   B F J N
I J K L                   C G K O
M N O P                   D H L P
</code></pre>

<p>Note how the diagonal entries, <code>A</code>, <code>F</code>, <code>K</code>, and <code>P</code> do not change. Also note how <code>E</code> and <code>B</code> are swapped; as are <code>I</code> and <code>C</code>, <code>J</code> and <code>G</code>, <code>M</code> and <code>D</code>, and so on.</p>

<p>So, a transpose is, in fact, possible to implement in place, by swapping pairs of elements.</p>

<p>For a 4¡Á4 matrix, there are six pairs to swap:</p>

<pre><code>Original                                                   Transpose

A B C D   A E C D   A E I D   A E I M   A E I M   A E I M   A E I M
E F G H   B F G H   B F G H   B F G H   B F J H   B F J N   B F J N
I J K L   I J K L   C J K L   C J K L   C G K L   C G K L   C G K O
M N O P   M N O P   M N O P   D N O P   D N O P   D H O P   D H L P

No swaps    B-E       C-I       D-M       G-J       H-N       L-O
</code></pre>

<p>Essentially, we swap each one in the lower triangle with the corresponding one in the upper triangle. For illustration, using <code>L</code> for lower triangle elements, <code>U</code> for upper triangle elements, and <code>D</code> for diagonal elements:</p>

<pre><code>D U U U
L D U U
L L D U
L L L D
</code></pre>

<p>We can now write our pseudo-code algorithm:</p>

<pre><code>Let T[N][N] be the matrix to be transposed
Let C be the column number in the lower triangular part,
      and the row number in the upper triangular part
Let R be the row number in the lower triangular part
      and the column number in the upper triangular part
For C = 0 to N-1, inclusive:
    For R = C+1 to N-1, inclusive:
        Swap T[C][R] and T[R][C]
    End For
End For
</code></pre>

<p>The most common error new programmers make, is swap the entry pairs twice. That does two transposes to the same data, which obviously leads to no observable changes, and confuses many a new programmer!</p>
",0
49714167,49714111,2,"<p>The problem with this code is you are comparing a pointer to a string and an integer, in this line.</p>

<pre><code>if (educode == 5678)
</code></pre>

<p>5678 is an <code>int</code> type, and you are determining whether or not it equals a pointer to a string of <code>chars</code>. C is an explicitly-typed language, so comparisons like these don't work like that. You will want to use this instead.</p>

<pre><code>if (atoi(educode) == 5678)
    system(""mkdir test"");
</code></pre>

<p>Use the <code>stdlib</code> function <a href=""http://www.cplusplus.com/reference/cstdlib/atoi/"" rel=""nofollow noreferrer""><code>atoi()</code></a> to convert your string to an integer value.</p>

<p><strong>Side note:</strong> Using the <code>system()</code> function is the same way to run shell commands across all platforms (Windows, Linux, Mac). However, not all of these commands are the same. For instance, what <code>del</code> does in DOS-based environments, is <code>rm</code> in Linux/Unix. On Windows, you would use <code>rename</code> or <code>move</code> for the same action that <code>mv</code> does on Linux. This program is simple enough, you might just want to use a Batch file, if you're confident this code is only for Windows.</p>
",0
49802983,49802606,2,"<p>Compiling your code produces no warnings, good work, but running it with <code>-fsanitize=address</code> immediately reveals a problem.</p>

<pre><code>$ make
cc -fsanitize=address -Wall -Wshadow -Wwrite-strings -Wextra -Wconversion -std=c99 -pedantic -g `pkg-config --cflags glib-2.0`   -c -o test.o test.c
cc `pkg-config --libs glib-2.0` -lssl -lcrypto -fsanitize=address  test.o   -o test

$ ./test
Enter the number of students, and number of tests score per student: 

3
3
Enter the scores for student 1 
5
=================================================================
==80655==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffeed7491e0 at pc 0x0001028420c3 bp 0x7ffeed749060 sp 0x7ffeed748820
WRITE of size 4 at 0x7ffeed7491e0 thread T0
10    #0 0x1028420c2 in scanf_common(void*, int, bool, char const*, __va_list_tag*) (libclang_rt.asan_osx_dynamic.dylib+0x1a0c2)
    #1 0x10284235e in wrap_scanf (libclang_rt.asan_osx_dynamic.dylib+0x1a35e)
    #2 0x1024b76e0 in main (/Users/schwern/tmp/./test+0x1000016e0)
    #3 0x7fff5d504014 in start (/usr/lib/system/libdyld.dylib+0x1014)
</code></pre>

<p>The problem is here.</p>

<pre><code>int i=0, j=0, a=0, b=0;
int arr[a][b], max[i];
</code></pre>

<p><code>arr</code> is initialized as <code>arr[0][0]</code> and never extended. When you try to write to <code>arr[i][j]</code> with <code>scanf(""%d"", &amp;arr[i][j])</code> the memory will not be allocated. Instead the program will overwrite some other memory and strange things will happen. Instead, <code>arr</code> will have to be initialized <em>after</em> we get the sizes. Similar issue with <code>max</code>.</p>

<p>This class of errors is often a culprit of doing all your variable declaration and initialization at the start of the function. This is a style you'll see a lot, but it's no longer necessary unless you're using a very ancient compiler.</p>

<p>Instead, declare your variables in context. Then it's obvious what they're for. And only initialize them when necessary, then you can get ""uninitialized value"" warnings from the compiler.</p>

<hr>

<p>To fix this we <em>could</em> allocate memory for <code>arr</code> and <code>max</code>, but <a href=""https://stackoverflow.com/questions/15062718/allocate-memory-2d-array-in-function-c#15062765"">allocating a 2D array</a> like <code>arr</code> is not simple.</p>

<p>Instead we can observe that all your outer loops iterate over the same thing: the number of tests. There's no need to store all student's test scores and <em>then</em> calculate the max. We can do each student in one loop. No arrays needed to store data between loops.</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void) {
    printf(""Enter the number of students, and number of tests score per student: \n\n"");

    // Variables are declared as needed with names describing
    // what they are to make the code self-documenting.
    // They are not unnecessarily initialized allowing warnings to help out.
    int num_students;
    int tests_per_student;
    scanf(""%d"", &amp;num_students);
    scanf(""%d"", &amp;tests_per_student);

    // Each student is fully processed in a single loop. No arrays needed.
    // Note the other variables declared in place in as narrow a scope as possible.
    for(int i=0; i &lt; num_students; i++) {
        // By declaring `max` inside the loop it is guaranteed to be reset each
        // loop iteration. Code outside the loop cannot affect it. It cannot
        // be confused with another `max`.
        int max = 0;

        printf(""Enter the scores for student %d \n"", (i+1));
        for(int j=0; j &lt; tests_per_student; j++) {
            // Similarly for score. We only need it inside this one loop.
            int score;
            scanf(""%d"", &amp;score);

            if(score &gt; max) {
                max = score;
            }
        }

        // With all the work done, print the max for this student and move on
        // to the next one.
        printf(""The highest score for student %d was:\t %d\n\n"", (i+1), max);
    }
}
</code></pre>
",0
52574147,52573905,1,"<p>Check the return value of <code>scanf</code> -- when it successfully converts a <code>float</code> it will return 1 (or more generally, however many conversions in the format string succeeded).  So when the input is <code>#</code>, it will return 0 (nothing converted) and leave the <code>#</code> on in the input stream.  You can then check the next character to make sure its a <code>#</code>.  So you end up with a loop like:</p>

<pre><code>for (a=0; a&lt;maximum &amp;&amp; scanf(""%f"",&amp;insertnum[a]) == 1; a++) {
    ++count;
}
</code></pre>

<p>or even</p>

<pre><code>for (count=0; count &lt; maximum &amp;&amp; scanf(""%f"",&amp;insertnum[count]) == 1; ++count);
if (count == maximum) {
    // read the limit -- may be more data
} else {
    if (getchar() == '#') {
        // got the expected terminator
    } else {
        // something else caused a problem
</code></pre>
",0
52573993,52573905,3,"<p>Read you user input in as a string.  Sniff for the terminating condition, then convert from string to float.  Using the helper function, <code>strtof</code> which is available from <code>#include &lt;stdlib.h&gt;</code></p>

<pre><code>#define maximum 100 
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main() {

    float sum, mean, variance, difference;
    float sumforvariance, standarddev;
    sumforvariance = 0;
    sum = 0;
    mean = 0;
    variance = 0;
    difference = 0;
    standarddev = 0;

    int a, count=0, b, c;

    float insertnum[maximum];

    for (a = 0; a &lt; maximum; a++) {

        char userinput[101] = {0};
        userinput[0] = '\0';

        scanf(""%100s"", userinput);

        if (userinput[0] == '#')
        {
            break;
        }
        insertnum[count] = strtof(userinput, nullptr);
        count++;
    }
    return 0;
}
</code></pre>

<p>Also, you forgot to initialize <code>count</code>. And your code was inserting the <code>#</code> read into the array as well. So I fixed that for you.</p>

<p>Aside - I'll never forget the day my computer science professor passionately screamed to the class about the dangers of ""reading numbers"" from input.  Users type <em>characters</em> with the keyboard not <em>numbers</em>. Hence, ""validating input"" became engrained with me to this day.  You might want to consider just letting your loop break whenever the user types anything not a number.  A modified version of the loop as follows:</p>

<pre><code>for (a = 0; a &lt; maximum; a++) {
    char userinput[101] = {0};
    userinput[0] = '\0';
    scanf(""%100s"", userinput);
    char* endptr = NULL;

    float f = strtof(userinput, &amp;endptr);
    if (userinput == endptr)
    {
        // whatever was typed was not a float
        break;
    }
    insertnum[count] = f;
    count++;
}
</code></pre>
",0
49143131,49143086,2,"<p>In the loop in <code>findNumber</code>, the statement:</p>

<pre><code>if(array[i] == array_size &amp;&amp; array[i] != value)
</code></pre>

<p>causes the loop to print a message and stop if <code>array[i]</code> equals <code>array_size</code>. In this, <code>array[i]</code> is an element in the array. You likely intended to test <code>i == array_size</code> instead. However, that is also incorrect, because, inside the loop, <code>i</code> will never equal <code>array_size</code>. The controlling condition in the <code>for</code> statement is <code>i &lt; array_size</code>, which means, if <code>i</code> is not less than <code>array_size</code>, the loop will not do another iteration.</p>

<p>You need to both correct the test to <code>i == array_size</code> and put it after the loop, not in the loop.</p>

<p>Additionally, remove the <code>array[i] != value</code> from that <code>if</code> statement. If <code>i</code> equals <code>array_size</code>, it will refer to an element outside the array.</p>
",0
51349981,51336522,0,"<p>Very similar problem has been solved here: <a href=""https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2"">how-to-check-if-a-number-is-a-power-of-2</a></p>

<pre><code>bool IsPowerOfTwo(long long x)
{
    return (x != 0) &amp;&amp; ((x &amp; (x - 1)) == 0);
}

int main()
{
    bool result = IsPowerOfTwo(256);

    if (result )
    {
        printf(""yes"");
    }
    else
    {
        printf(""no"");
    }

    return 0;
}
</code></pre>
",0
53950203,53950193,1,"<p>Most C compilers accept the <code>-I</code> <a href=""https://gcc.gnu.org/onlinedocs/gcc/Preprocessor-Options.html"" rel=""nofollow noreferrer"">preprocessor option</a>, adding some directory to the include search path.</p>

<p>So configure your build (probably your <a href=""https://en.wikipedia.org/wiki/Build_automation"" rel=""nofollow noreferrer"">build automation</a> tool, e.g. your <a href=""https://en.wikipedia.org/wiki/Makefile"" rel=""nofollow noreferrer""><code>Makefile</code></a> if you use <a href=""https://www.gnu.org/software/make/"" rel=""nofollow noreferrer""><code>make</code></a>) to add such a flag to the compilation command.</p>
",0
48958079,48958065,4,"<pre><code>putchar(argv[i]);
</code></pre>

<p>is incorrect, because <code>putchar</code> expects a single character (type <code>char</code>), you are passing a pointer (<code>char*</code>). It should be</p>

<pre><code>puts(argv[i]);
</code></pre>

<p>So the correct code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    if (argc != 2) {
        fprintf(stderr, ""usage: one file only\n"", argv[0]);
        return 1;
    }

    // no need for the else
    // you exit program anyway if argc != 2
    // makes code more readable

    puts(argv[1]);

    return 0;
}
</code></pre>

<p>If you want to print character by character:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    if (argc != 2) {
        fprintf(stderr, ""usage: one file only\n"", argv[0]);
        return (1);
    }

    for(size_t i = 0; argv[1][i] != '\0'; ++i)
        putchar(argv[1][i]);

    putchar('\n');

    return 0;
}
</code></pre>

<p><strong>edit</strong> changed <code>puts("""")</code> to <code>putchar('\n')</code> and removed <code>strlen</code> as Jonathan Leffler mentioned in the comments.</p>
",4
54496529,54496487,6,"<p>It does not matter, and it is not specified (check the C11 standard <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""noreferrer"">n1570</a>). Be aware of the <a href=""https://en.wikipedia.org/wiki/As-if_rule"" rel=""noreferrer"">as-if</a> rule. It actually depends on how your compiler is <a href=""https://en.wikipedia.org/wiki/Optimizing_compiler"" rel=""noreferrer"">optimizing</a>.</p>

<p>If you put your code in just some <code>main</code> function and compile that with optimizations enabled, the <a href=""https://gcc.gnu.org/"" rel=""noreferrer"">GCC</a> compiler could give you an empty program (since all the computations can be done at compile time, and since <code>d</code> is not used for observable side-effects).</p>

<p>If you have GCC, compile a function with your code using <code>gcc -O3 -S -fverbose-asm</code> and look inside the produced <code>*.s</code> assembler file. You'll be surprised.</p>

<p>Specifically, with GCC 8 on Linux/Debian/x86-64, the compilation of </p>

<pre><code>// file dvep.c
#include &lt;math.h&gt;
int
main (void)
{
  int i = 0;
  double d = sqrt ((double) i);
  return 0;
}
</code></pre>

<p>using the <code>gcc -O3 -S -fverbose-asm dvep.c</code> command produces a <code>dvep.s</code> file whose <code>main</code> function is reduced to:</p>

<pre><code>    .globl  main
    .type   main, @function
main:
.LFB0:
    .cfi_startproc
# dvep.c:9: }
    xorl    %eax, %eax  #
    ret 
    .cfi_endproc
</code></pre>

<p>and you then see that no floating point operations happens at runtime inside <code>main</code></p>
",0
54496561,54496487,6,"<p>It depends on optimization and architecture. For example, GCC with <code>-O3</code> will omit the call to <code>sqrt</code> altogether for some values, as seen <a href=""https://godbolt.org/z/ot9yzE"" rel=""nofollow noreferrer"">here</a>.</p>

<p>If the variable is not known at compile-time (i.e. if it is read from a file or from user input), then there's no way around actually calling <code>sqrt</code> with the double value of <code>i</code>. On x86 this requires an instruction like <a href=""https://www.felixcloutier.com/x86/cvtsi2sd"" rel=""nofollow noreferrer""><code>CVTSI2SD</code></a> (Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value), as seen <a href=""https://godbolt.org/z/Zy-Nfn"" rel=""nofollow noreferrer"">here</a>. The compiler produces that instruction at compile time, but running the instruction (obviously) occurs at runtime.</p>
",0
49053614,49053499,1,"<ol>
<li>Lose the semicolons at the end of your <code>if</code>s.</li>
<li>You're using a single <code>=</code>, which is assignment.  You need to use two (<code>==</code>) to test for equality.</li>
<li>While not required for single statement <code>if</code>s, you may want to include braces.</li>
</ol>

<p>Corrected code looks like this:</p>

<pre><code>if (MonthlyDuration == 13) {
    Year += 1;
}
if (MonthlyDuration != 13) {
    Year += 0;
}
</code></pre>
",4
54139697,54139418,5,"<p>You can convert numerals or other text to strings with the preprocessor <code>#</code> operator. This requires using two macros, one to expand the <code>size</code> macro and another to apply the operator:</p>

<pre><code>#define size 10

#define StringifyHelper(x)  #x
#define Stringify(x)        StringifyHelper(x)

...

char tab[size+1];
scanf(""%"" Stringify(size) ""[^\n]"", tab);
</code></pre>
",0
48656365,48655797,1,"<p>In a comment, I asked:</p>
<blockquote>
<p>Do you want to pass the single character <code>'H'</code>, or a pointer to it? If you want to pass a single character, you need to review the signature of <code>strcpy()</code> ¡ª it would be a mistake to pass a single character as the second argument. What do you know about dereferencing pointers?</p>
</blockquote>
<p>To which the response was:</p>
<blockquote>
<p>I know a little bit about dereferencing. It basically gathers a value from a pointer? If I use the code <code>strcpy(word, *string_ptr);</code>, I can copy the entire value of the string to the variable word.</p>
<p>I need to be able to pass a single character; the question requires me to loop over the entire string until a non-letter character is reached, convert any uppercase letters to lowercase and then return a single word. then I'll have to do this again for the next set of letter characters in the string.</p>
</blockquote>
<p>And I noted:</p>
<blockquote>
<p>Right ¡ª <code>strcpy(word, *string_ptr)</code> will copy the string <code>&quot;Hello world&quot;</code> into the array <code>word</code>. And if you only want to copy one character from a string, consider <code>strncpy()</code>, but don't forget to null-terminate the result string. It looks like you're going to need to update the value in <code>*string_ptr</code> to allow for the characters copied to the return function ¡ª that's why it needs to be a <code>char **</code> and not just a <code>char *</code>.</p>
</blockquote>
<p>However, given the requirements, it is probably better not to use <code>strcpy()</code> or <code>strncpy()</code>.</p>
<p>You could get to the <code>H</code> using <code>(*string_ptr)[0]</code> or even <code>**string_ptr</code>, but the array notation with the pointer is rather ungainly to type out very often (more than once?).  Both of them are vulnerable to crashes if the pointer in <code>(*string_ptr)</code> is a null pointer ¡ª or otherwise invalid; however, that's also true of the code below.  You could check with <code>assert(*string_ptr != NULL);</code> if you wished, and you included <code>&lt;assert.h&gt;</code>, whatever other error handling you choose.</p>
<p>There are many options, but I'd probably use a variant on:</p>
<pre><code>char *src = *string_ptr;   /* Starting position */
char *dst = word;
int c;

while (*src != '\0')
{
    int c = (unsigned char)*src++;
    ¡­break on space or other characters as required¡­
    ¡­map c as required¡­
    *dst++ = c;
}
*dst = '\0';  /* Null terminate the string */
*string_ptr = src;
return word;
</code></pre>
<p>That avoids a variety of problems.  Using the local pointer <code>src</code> (the source string ¡ª matches <code>dst</code>, the destination string) avoids having to write <code>(*string_ptr)</code> all the time.  Using <code>c</code> gets ready to pass the value to the functions (macros) from <code>&lt;ctype.h&gt;</code>.  The cast to <code>(unsigned char)</code> deals with
accented characters in a single-byte code set when the plain <code>char</code> type is signed (and is harmless when the plain <code>char</code> type is unsigned).  The increment in the loop avoids overshooting the end of the string.</p>
",0
56998751,56998522,1,"<p>The loop <code>for(int i = 0; i &lt; 20; i++)</code> fails to stop when an entry ends. Just before this loop, <code>token[z]</code> is copied into <code>str</code>. This copy stops at the null byte that terminates <code>token[z]</code>. Beyond that, it leaves in <code>str</code> whatever was there from before.</p>

<p>Then the loop <code>for(int i = 0; i &lt; 20; i++)</code> adds values for <strong>all</strong> letter non-quote and non-null characters in <code>str</code>, including letters that are left over from prior long names.</p>

<p>This loop should be modified to stop where the current name ends.</p>
",1
53319651,53319480,0,"<p>No, there is, in general, no way to know whether a function is being called for the last time in a program execution.</p>

<p>A program could be designed to convey this knowledge, by passing an argument indicating it. You would have to build this into all functions in the call chain. Even so, it may cause some code to be awkward, as the last iterations of some loops may need special treatment.</p>

<p>Generally, it is preferable to call separate clean-up code at suitable times rather than trying to incorporate it automatically into routine operations in the way you seem to be attempting.</p>
",0
53319690,53319480,0,"<p>No you cannot.</p>

<p>Example :</p>

<ul>
<li>A GUI will call your function every time the user clicks ""ok"".</li>
<li>There is no way for the program to known if the user will click again or switch-off the computer after a click.</li>
</ul>

<p>A little joke:
The only possiblity for you, to achieve what you want, is have your function free() abort the whole program, so that you are sure it will not be called again.</p>
",0
53320001,53319480,0,"<p>No, it's not possible, as other answers have stated.</p>

<p>The closest thing you can do is register an <code>atexit</code> handler to perform whatever cleanup you want to do:</p>

<pre><code>static int init = 0;

void cleanup()
{
    // last call to sbrk to clean up
}

void *my_malloc(size_t size)
{
    if (!init) {
        init = 1;
        atexit(cleanup);
    }
    ...
}
</code></pre>
",0
48659658,48659216,1,"<p>If you want bits from the offset <code>X</code> then shift right by <code>X</code>.</p>

<p>If you want <code>Y</code> bits, then then mask (after the shift) will be 2 to the power of <code>Y</code> minus one (for your example with four bits, 2 to the power of 4 is 16, minus one is 15 which is <code>1111</code> binary). This can be dome by using left-shifting by <code>Y</code> bits and subtracting <code>1</code>.</p>

<p>However, the masking isn't needed if you want to count the number of zeros in the wanted bits, only the right shift. Loop <code>Y</code> times, each time shifting a <code>1</code> left one step, and check using bitwise and if the value is zero. If it is then increment a counter. At the end of the loop the counter is the number of zeros.</p>

<hr>

<p>To put it all in code:</p>

<pre><code>// Count the number of zeros in a specific amount of bits starting at a specific offset
// value is the original value
// offset is the offset in bits
// bits is the number of bits to check
unsigned int count_zeros(unsigned int value, unsigned int offset, unsigned int bits)
{
    // Get the bits we're interested in the rightmost position
    value &gt;&gt;= offset;

    unsigned int counter = 0;  // Zero-counter
    for (unsigned int i = 0; i &lt; bits; ++i)
    {
        if ((value &amp; (1 &lt;&lt; i)) == 0)
        {
            ++counter;  // Bit is a zero
        }
    }

    return counter;
}
</code></pre>

<p>To use with the example data you have:</p>

<pre><code>count_zeros(0xa5, 2, 4);
</code></pre>

<p>The result should be <code>2</code>. Which it is <a href=""https://ideone.com/bEujqx"" rel=""nofollow noreferrer"">if you see this live program</a>.</p>
",3
48726192,48726135,0,"<p>This line worked:</p>

<pre><code>mat1[i][j] = (int * )malloc(p * sizeof(int ));
</code></pre>

<p>because <code>mat1</code> is a <code>int***</code>, so that <code>mat1[i][j]</code> is an <code>int*</code>.</p>

<p>But this doesn't:</p>

<pre><code>free((*mat1)[i][j]);
</code></pre>

<p>because <code>*mat1</code> is a <code>int**</code>, so that <code>(*mat1)[i][j]</code> is an <code>int</code>, which is exactly what the warning in complaining about.</p>

<p>I believe what you want is:</p>

<pre><code>free(mat1[i][j]);
</code></pre>

<p>which corresponds to the <code>malloc</code> referenced above.</p>
",1
54267847,54266612,0,"<p>More the remarks already done there are several strange things in your program</p>

<ul>
<li>the read number is never used, so there is no way to give a result depending on it</li>
<li>you modify <em>taken</em> to give all the couples but you do not reset it before to give the couples with the read number, supposing <em>taken</em> is  useful how that can works in this case ?</li>
<li>and globally why so complicated ?</li>
</ul>

<p>You can do like that, with two ways to do the second part :</p>

<pre><code>#include &lt;stdio.h&gt;

#define MIN 1
#define MAX 4

int main()
{
  /* print all couples */
  for (unsigned i = MIN; i &lt;= MAX; ++i) {
    for (unsigned j = MIN; j &lt;= MAX; ++j) {
      printf(""(%u %u)\n"", i, j);
    }
  }

  unsigned number;
  printf(""Enter number from %d to %d\n"", MIN, MAX);
  scanf(""%u"", &amp;number);

  /* first way following the same order as before */
  puts(""same order"");

  if ((number &gt;= MIN) &amp;&amp; (number &lt;= MAX)) {
    for (unsigned i = MIN; i &lt;= MAX; ++i) {
      for (unsigned j = MIN; j &lt;= MAX; ++j) {
        if ((i == number) || (j == number))
          printf(""(%u %u)\n"", i, j);
      }
    }
  }

  /* an other way, faster but not in the same order */
  puts(""different order"");

  printf(""(%u %u)\n"", number, number);
  for (unsigned i = MIN; i &lt; number; ++i) {
    printf(""(%u %u)\n(%u %u)\n"", number, i, i, number);
  }
  for (unsigned i = number + 1; i &lt;= MAX; ++i) {
    printf(""(%u %u)\n(%u %u)\n"", number, i, i, number);
  }

  return 0;
}
</code></pre>

<p>Execution :</p>

<pre><code>(1 1)
(1 2)
(1 3)
(1 4)
(2 1)
(2 2)
(2 3)
(2 4)
(3 1)
(3 2)
(3 3)
(3 4)
(4 1)
(4 2)
(4 3)
(4 4)
Enter number from 1 to 4
2
same order
(1 2)
(2 1)
(2 2)
(2 3)
(2 4)
(3 2)
(4 2)
different order
(2 2)
(2 1)
(1 2)
(2 3)
(3 2)
(2 4)
(4 2)
</code></pre>
",0
49468417,49468124,1,"<p>Input from a terminal is generally <em>buffered</em>. This means it is held in memory waiting for your program to read it.</p>

<p>This buffer is performed by multiple pieces of software. The software that is actually reading your input in the terminal window generally accumulates characters you type until you press enter or press certain other keys or combinations that end the current input. Then the line that has been read is made available to your program.</p>

<p>Inside your program, the C standard library, of which <code>getchar</code> is a part, reads the data that has been sent to it and holds it in a buffer of its own. The <code>getchar</code> routine reads the next character from this buffer. (If the buffer is empty when <code>getchar</code> wants another character, <code>getchar</code> will block, waiting for new data to arrive from the terminal software.)</p>
",3
50266017,50265168,1,"<p>The problem is that <code>struct sequence</code> doesn't actually carry any salvageable information, it only contains pointers.</p>

<p>Pointers carry memory addresses, they point where the actual information is in memory, but of course if you are reading the file in another process with an entirely different memory space, the information won't be there. In fact, you are likely to crash for trying to interact with memory space that wasn't properly initialized first.</p>

<p>A very simple solution is, don't use pointers, use arrays:</p>

<pre><code>struct sequence
{
    char sequence[1024];
    char label[1024];
}
</code></pre>

<p>Now the structure actually carry the data, no longer just pointers. You will be able to read and write it to file with no worries. However, some code will need to be changed further.</p>

<p>You can no longer assign data to them like <code>x.label = label</code>, you need to use <code>strcpy()</code>, like <code>strcpy(x.label, label)</code>. Those changes will need to be made everywhere in the code where you assign values to the properties of this structure.</p>
",6
55973963,55972476,3,"<p>The C standard does not specify the order of evaluation of arguments. However, all arguments are evaluated before the function is called. Per C 2018 6.5.2.2 10 (which discusses function calls):</p>

<blockquote>
  <p>There is a sequence point after the evaluations of the function designator and the actual arguments but before the actual call.</p>
</blockquote>

<p>Thus, when execution of the called function begins, all arguments have been evaluated, so their values are known. Then the size expressions of variably modified parameters are evaluated, per 6.9.1 10 (which discusses function definitions):</p>

<blockquote>
  <p>On entry to the function, the size expressions of each variably modified parameter are evaluated and the value of each argument expression is converted to the type of the corresponding parameter as if by assignment.</p>
</blockquote>

<p>(Note that arguments are what a caller passes to a function, and parameters are the objects declared as part of the function declaration or definition that acquire values on entry to the function.)</p>
",0
52789561,52789331,0,"<p>Each iteration of the first cycle creates a new instance of its local <code>char random_number_string[8];</code> array and then destroys it at the end. On each iteration of that cycle you are storing a pointer to the beginning of that <code>random_number_string</code> array in <code>p[i]</code>. Each pointer <code>p[i]</code> becomes ""sour"" (dangling) at the end of each <code>i</code>-th iteration. Thus all <code>p[i]</code> values end up invalid. Any attempts to access these values result in undefined behavior.</p>

<p>And this is exactly what your second cycle does. The behavior of your program is undefined.</p>

<p>Note, BTW, that it is incorrect to say that all of your array elements point to the same memory location (as some answers here do). Your array <code>p</code> contains <em>invalid</em>, <em>indeterminate</em> pointer values. Nothing definitive can be said about these values.</p>
",0
53038775,53038728,0,"<p>As a general statement, the length of each data type is compiler and machine dependent. So the value of float, double and long double are machine and compiler dependent and may be different on different computers</p>
",0
49208540,49208360,1,"<p>What do you mean with 'dynamic structure array'? Is it an array of structures or an array of strings (=array of char pointers)?</p>

<p>If it's just an array of pointers, you would simply call malloc() for every entry and then assign the string.</p>

<pre><code>char *strings[5];

void insert_string(int array_index, char *string, int length)
{
    strings[array_index] = malloc(length);
    strcpy(strings[array_index], string, length);
}
</code></pre>

<p>Of course you'd have to add code to prevent your array from overflowing, or automatically keeping track of the index...</p>
",1
49321539,49321489,4,"<p>This:</p>

<pre><code>/* Merge string a and string b together, then sort them alphabetically  */
c = strcat(a,b) ;
</code></pre>

<p>doesn't do what you seem to expect, it doesn't write into the caller's (i.e. <code>main()</code>'s) buffer at all. It overwrites the value of <code>c</code> (the function argument) with the return value of <code>strcat()</code>, which will be the destination, i.e. <code>a</code>.</p>

<p>You need to read up on how C strings work, and how the memory holding them is handled.</p>

<p>That particular call could be replaced by:</p>

<pre><code>sprintf(c, ""%s%s"", a, b);
</code></pre>

<p>but this is dangerous and risks overwriting buffers since no size information is passed into the function (so it can't use <code>snprintf()</code>).</p>
",8
51256971,51256920,2,"<p>As per <code>C11 6.3.2.1 Lvalues, arrays, and function designators /3</code>:</p>

<blockquote>
  <p>Except when it is the operand of the <code>sizeof</code> operator, the <code>_Alignof</code> operator, or the unary <code>&amp;</code> operator, or is a string literal used to initialize an array, an expression that has type ""array of type"" is converted to an expression with type ""pointer to type"" that points to the initial element of the array object and is not an lvalue.</p>
</blockquote>

<p>That means your array (of size 13) is decaying into a pointer (of size 8 since you appear to have 64-bit pointers) when passed to a function.</p>

<p>If you want to preserve the length, you'll have to do that yourself, such as with:</p>

<pre><code> #include &lt;stdio.h&gt;
 #include &lt;string.h&gt;
 #include &lt;stdlib.h&gt;

 void fun(char *chPtr, size_t actualSz) {
    printf(""in fun, str=%s, size=%zd, size[0]=%zd, strlen=%zd\n"",
        chPtr, actualSz, sizeof(chPtr[0]), strlen(chPtr));
 }

 int main(void) {
     char chArr[]=""(a(bc)d(e)f)"";
     printf(""in main, sizeof=%zd, strlen=%zd\n"",
         sizeof(chArr)/sizeof(chArr[0]),
         strlen(chArr));
     fun(chArr, sizeof(chArr));
     return 0;
 }
</code></pre>

<p>You'll notice I've also changed the format specifiers to the correct <code>size_t</code>-based ones, and used a little more verbosity with respect to variable names.</p>

<p>This gives:</p>

<pre><code>in main, sizeof=13, strlen=12
in fun, str=(a(bc)d(e)f), size=13, size[0]=1, strlen=12
</code></pre>
",0
54726540,54726495,1,"<p>Note that in C, when both operands of a division have integer type, the division also has an integer type, and the value is the result of division <a href=""https://en.cppreference.com/w/c/language/operator_arithmetic#Division"" rel=""nofollow noreferrer"">rounded toward zero</a>.</p>

<p>So in the first iteration, the statement <code>x = x /10;</code> changes <code>x</code> from <code>1023</code> to <code>102</code> (not <code>102.3</code>).</p>
",0
49061996,49061889,2,"<p>Based on your output the <code>@</code> comes always at the beginning of the strings. So
you can easily do this:</p>

<pre><code>// str contains the string ""@2""
puts(str + (str[0] == '@' ? 1 : 0));
</code></pre>

<p>If you want to remove a <code>@</code> at some random position, then you should write a
function like this</p>

<pre><code>char *remove_char(char *src, char c)
{
    if(src == NULL)
        return NULL;

    char *p = strchr(src, c);

    if(p == NULL)
        return src; // c not found

    // removing c
    memmove(p, p+1, strlen(p));

    return src;
}
</code></pre>

<p>Then you can call it like</p>

<pre><code>char line[] = ""abc@def"";
puts(remove_char(line, '@'));
</code></pre>

<p>This would print <code>abcdef</code></p>
",0
52286295,52286086,1,"<p>The warning you want is enabled in GCC by <code>-pedantic</code>. In Code Blocks go over to Settings, Compiler and find ""Enable warnings demanded by strict ISO C"". Turn that on.</p>
",1
52057863,52057537,2,"<p>As suggested in my comment, and since it's now a bit more clear, an easy way to compare two multisets represented as strings is to:</p>

<ol>
<li>Sort the two strings (easy using the <code>qsort()</code> standard function)</li>
<li>Compare the result (using the <code>strcmp()</code> standard function)</li>
</ol>

<p>This will work since it will map both ""akash"" and ""ashka"" to ""aahks"", before comparing.</p>
",1
52057880,52057537,1,"<p>First, note that <code>found</code> is never initialized. The values within it are unknown. It ought to be initialized by setting every element to zero before each test for equality. (Or, if not every element, every element up to <code>strlen(s1)-1</code>, as those are the ones that will be used.)</p>

<p>Once <code>found</code> is initialized, though, there is another problem.</p>

<p>The first loop on <code>i</code> uses <code>for(i=0;i&lt;strlen(s1)-1;i++)</code>. Within this, <code>found[i]</code> is set if a match is found to <code>s1[i]</code>. Note that <code>i</code> never reaches <code>strlen(s1)-1</code> within the loop, since the loop terminates when it does.</p>

<p>The second loop on <code>i</code> uses <code>for(i=0;i&lt;strlen(s1);i++)</code>. Within this loop, <code>found[i]</code> is tested to see if it is set. Note that <code>i</code> does reach <code>strlen(s1)-1</code>, since the loop terminates only when <code>i</code> reaches <code>strlen(s1)</code>. However, <code>found[strlen(s1)-1]</code> can never have been set by the first loop, since <code>i</code> never reaches <code>strlen(s1)-1</code> in the first loop. Therefore, the second loop would always report failure.</p>

<p>Additionally, it is not clear whether two strings ought to be considered equal if and only if they are anagrams (the characters in one can be rearranged to form the other string, without adding or removing any characters) or if each character in one string is found at least once in the other (¡°aaabbc¡± would be equal to ¡°abbccc¡±, because both strings contain a, b, and c).</p>

<p>As written, with the initialization and loop bugs fixed, your program tests whether each character in the first string appears in the second string. This is not an equivalence relation because it is not reflexive: It does not test whether each character in the second string appears in the first string. So, you need to think more about what property you want to test and how to test for it.</p>
",2
52190460,52190131,0,"<p>You need to have some memory for <code>char *starter</code> to point at. </p>

<p>Here's your mistake.</p>

<pre><code>char * starter;
scanf(""%s"",&amp;starter);
</code></pre>

<p>also here;</p>

<pre><code>typedef struct {
char * name;
}player;
</code></pre>

<p>Instead try this;</p>

<pre><code>typedef struct {
char name[100];
}player;

char starter[100];
scanf(""%s"",starter);
</code></pre>
",2
52401366,52401126,1,"<p>No there is not, the standard input/output streams in C are much more low-level and do not support the concept of a base (nor the concept of outputting ""a number"", they are character streams).</p>

<p>Just use <a href=""https://linux.die.net/man/3/printf"" rel=""nofollow noreferrer""><code>printf()</code></a>:</p>

<pre><code>const int number = 4711;
printf(""%d in hex is %x; in octal it's %o\n"", number, (unsigned int) number,
       (unsigned int) number);
</code></pre>

<p>will print:</p>

<pre><code>4711 in hex is 1267, in octal it's 11147
</code></pre>

<p>And no, there's no standard way of printing in binary, you're going to have to implement that on your own if you need it.</p>

<p>To input, you need to match the type of the variable with the type implied by the formatting specifier:</p>

<pre><code>if(scanf(""%lx"", &amp;id) == 1)
{
  printf(""the ID is %lu (0x%lx)\n"", id, id);
}
</code></pre>

<p>the type of hexadecimal numbers is <code>unsigned</code> with the <code>printf()</code> and <code>scanf()</code> family of functions.</p>
",4
54493727,54493624,1,"<p>I suspect the intent of the exercise is to have the function print the numbers while proceeding through the recursion and print their negations on the way out:</p>

<pre><code>#include &lt;stdio.h&gt;

static void recursion(int n, int m)
{
    printf(""%d "", n);
    if (n &lt;= 0)
        return;
    recursion(n-m, m);
    printf(""%d "", -n);
}

int main()
{
    int n, m;
    scanf(""%d %d"", &amp;n, &amp;m);
    recursion(n, m);
    printf(""\n"");
    return 0;
}
</code></pre>
",10
49180197,49179518,0,"<p>It would make sense to ask for data before printing them.</p>

<p>This is setting <code>y</code> to <code>0</code>:    <code>y=0</code>
   This is checking of <code>y</code> is equal <code>0</code>: <code>y==0</code></p>

<p>Take a look at:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


void main(void) {

    float x;

    printf(""Set Temperature:\n""); 

    scanf(""%f"", &amp;x);
    printf(""Temperature = %.3f\n"", x);


    int y;

    printf(""Set Sensor Reading:\n""); 
    scanf(""%d"", &amp;y);    
    printf(""Sensor Reading = %d \n"", y);


    int z;

    printf(""Set RPM Value:\n"", z);
    scanf(""%d"", &amp;z);
    printf(""RPM Value = %d\n"", z);


    if( (x&lt;=143.4) &amp;&amp; (y==0) ) 
    {
        printf(""Continue to run\n"");
        printf(""Temperature is Low\n"");
        printf(""Not mixed correctly\n"");

        if (z&lt;400) {
            printf(""Increase the speed to 400rpm\n"");
        } 
        else 
            if(z&gt;400)
            {
                printf(""Decrease the speed to 400rpm\n"");
            } 
            else
            {
                printf(""keep running at this speed\n"");
            }
    }
    else
    {
        printf(""stop running\n"");
        printf(""Temperature is above 143.4 degree Celcius\n"");
        printf(""Colors are mixed correctly\n"");
    }
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>Set Temperature:                                                                                                                               
143.4                                                                                                                                          
Temperature = 143.400                                                                                                                          
Set Sensor Reading:                                                                                                                            
20                                                                                                                                             
Sensor Reading = 20                                                                                                                            
Set RPM Value:                                                                                                                                 
10                                                                                                                                             
RPM Value = 10                                                                                                                                 
stop running                                                                                                                                   
Temperature is above 143.4 degree Celcius                                                                                                      
Colors are mixed correctly  
</code></pre>
",0
59448863,59448778,1,"<p>A more correct way to word the question is ""When does the behavior of the program become undefined"", or ""What is the first place that a segmentation fault could occur""</p>

<p>So, to answer that:</p>

<p>Consider this line:
<code>free( strcpy((char *)malloc(20),foo() + ""Hello,?World\n""));</code></p>

<p>EDIT (remove this): <em>This line is non-sensical. Adding an <code>int</code> to a literal <code>char *</code> doesn't mean anything. My C compiler issues a warning and moves on, so I will too.</em></p>

<p>EDIT (add this): As pointed out in the comments, <code>foo()</code> returns 1, so this passes <code>""ello,?World\n""</code> to strcpy. This is ok, because this is less than the 20 chars allocated.  It's a warning in my C compiler because it's <em>weird</em>.</p>

<p>The question is: is this less than 20 bytes.  I think so? So, this line basically just has the side-effect of calling <code>foo()</code></p>

<p><code>foo</code> is just gibberish code -- but I will put comments in it to see if any part of it is undefined:</p>

<pre><code>int foo(void) {
 // This is defined (added struct so it compiles)
 struct N *p = malloc(sizeof *p);

 // This is defined
 p-&gt;a = 42;

 // This is defined
 p-&gt;q = ""life,?universe,?everything"";

 // This is defined
 p-&gt;n = (struct N *)p;

 // This is defined
 q = p;

 // This is defined
 free(p);

 // Right now, q is pointing at free space -- it is very bad to derefence q
 return 1;
}
</code></pre>

<p>Going back to <code>main()</code></p>

<p><code>(void) printf(""q=%p\n"", q);</code></p>

<p>This prints the <code>q</code> pointer value -- it is not a dereference, so it's ok.</p>

<p><code>(void) printf(""q-&gt;a=%d\n"", q-&gt;a);</code></p>

<p>I say that this is undefined.  You are clearly dereferencing <code>q</code> which is pointing at free space.  <code>q-&gt;a</code> is an int sized location in free space and you are reading it.  Now, if the memory has not been reclaimed, this <em>might</em> not segfault. It is still not correct or defined.</p>

<p>Now we get to the line that you are told will segfault:</p>

<p><code>(void) printf(""q-&gt;q=%s\n"", q-&gt;q);</code></p>

<p>This is undefined for the same reason that <code>q-&gt;a</code> is.  </p>

<p>When I run it I get</p>

<pre><code>q=0x7fc30f4017c0
q-&gt;a=2
Segmentation fault: 11
</code></pre>

<p>So, you see: it did not print 42 for q->a and it didn't get to the next line.  The program became undefined and did one of the things it's allowed to do, which is anything it wants. For example</p>

<ol>
<li>It can print the wrong number</li>
<li>It can segfault</li>
<li>It can work perfectly</li>
<li>It can be a vector for a security exploit that takes over your machine and gives a hacker access to your bank accounts.</li>
</ol>

<p>This explains it better: <a href=""https://devblogs.microsoft.com/oldnewthing/20110929-00/?p=9523"" rel=""nofollow noreferrer"">https://devblogs.microsoft.com/oldnewthing/20110929-00/?p=9523</a></p>

<p>More: <a href=""https://devblogs.microsoft.com/oldnewthing/20140627-00/?p=633"" rel=""nofollow noreferrer"">https://devblogs.microsoft.com/oldnewthing/20140627-00/?p=633</a></p>
",5
53803479,53802253,2,"<p>Most terminals support colors. The problem is sending the right escape code. For the Windows command line, you have do a different escape sequence. <a href=""https://en.wikipedia.org/wiki/ANSI_escape_code#Windows"" rel=""nofollow noreferrer"">There is a wikipedia entry that describes how to do an escape in different environments</a>.</p>
",0
53212542,53212458,4,"<p>Strictly speaking, C doesn't even have a stack, however most implementation use one, and yours likely does.</p>

<p>That being said, it's best to restrict variables to the innermost scope needed to use them.  That way, they don't consume stack space longer than needed and they aren't visible to scopes that don't need them.</p>

<p>So your second approach is preferable.</p>
",0
52738609,52738218,1,"<p>In <code>lib.c</code>, <code>void (* const lib_callback_pnt)(int);</code> is a declaration of an identifier for an object (in this case, a pointer) that has file scope without an initializer and without a storage-class specifier. Then C 2018 6.9.2 2 tells us:</p>

<blockquote>
  <p>A declaration of an identifier for an object that has file scope without an initializer, and without a storage-class specifier or with the storage-class specifier <strong>static</strong>, constitutes a <em>tentative definition</em>. If a translation unit contains one or more tentative definitions for an identifier, and the translation unit contains no external definition for that identifier, then the behavior is exactly as if the translation unit contains a file scope declaration of that identifier, with the composite type as of the end of the translation unit, with an initializer equal to 0.</p>
</blockquote>

<p>This tells us that in standard C, <code>lib_callback_pnt</code> is initialized to zero even if it is defined in a different translation unit. And the fact that it behaves as if it had an initializer means it is defined in <code>lib.c</code>.</p>

<p>Furthermore, when <code>lib_callback_pnt</code> is defined in <code>main2.c</code>, this violates C 2018 6.9 5:</p>

<blockquote>
  <p>If an identifier declared with external linkage is used in an expression (other than as part of the operand of a <strong>sizeof</strong> or <strong>_Alignof</strong> operator whose result is an integer constant), somewhere in the entire program there shall be exactly one external definition for the identifier; otherwise, there shall be no more than one.</p>
</blockquote>

<h1>Note</h1>

<p>There is some tradition in Unix of permitting the declaration of <code>int foo;</code> in one translation unit and <code>int foo = 1;</code> in another. Technically, this violates the C standard, but it may be commonly available in compilers and linkers.</p>
",3
52739040,52738218,2,"<p>Your lib.c actually does define <code>lib_callback_pnt</code>.  C11 says at <a href=""https://port70.net/~nsz/c/c11/n1570.html#6.9.2p2"" rel=""nofollow noreferrer"">6.9.2p2</a>:</p>

<blockquote>
  <p>A declaration of an identifier for an object that has file scope without an initializer, and without a storage-class specifier or with the storage-class specifier <code>static</code>, constitutes a <em>tentative definition</em>. If a translation unit contains one or more tentative definitions for an identifier, and the translation unit contains no external definition for that identifier, then the behavior is exactly as if the translation unit contains a file scope declaration of that identifier, with the composite type as of the end of the translation unit, with an initializer equal to 0.</p>
</blockquote>

<p>So the declaration of <code>lib_callback_pnt</code> in lib.c is a tentative definition. Since that translation unit doesn't contain any other declaration of <code>lib_callback_pnt</code> that explicitly defines it, the behavior should be the same as a true definition that initializes it with ""<code>= 0</code>"".</p>

<p>Apparently gcc with ELF output doesn't follow this requirement exactly by default.<br>
 On my Linux system, if I <code>gcc -c lib.c; nm lib.o | grep lib_callback_pnt</code>, I get:</p>

<pre><code>0000000000000008 C lib_callback_pnt
</code></pre>

<p>And my <code>man nm</code> documentation explains ""C"" means a ""common symbol"":</p>

<blockquote>
  <p>""C"" The symbol is common.  Common symbols are uninitialized data.  When linking, multiple common symbols may appear with the same name.  If the symbol is defined anywhere, the common symbols are treated as undefined references.</p>
</blockquote>

<p>So your method does work with gcc/ELF, but it's incorrect according to the C Standard, so you can't count on it to work with other compilers.</p>
",3
53737811,53737693,0,"<p>If you put it in a loop it will do its job repeatetly. The loop does not affedt whats inside of it in any way.</p>

<p>Normally if handling a problem that comes with a sort of ""realtime"" aspect it is a good idea to not use blocking - so you have always the control. Use non-blocking instead and check the return-codes if it read something or just returned by no data.</p>
",0
53737724,53737693,0,"<p>If <code>os_io_read()</code> blocks it blocks. Putting it in a <code>for</code> loop will not affect this behavior.</p>
",0
49217646,49217559,2,"<p>Firstly @WhozCraig comment is correct, you should try to use zero base indices because otherwise you're wasting memory and making it harder to code in general.
Other than that your example with the two loops is the only way to do it and there is no more efficient way, if you want to read into the whole array you'll need to traverse it all.</p>
",3
49245320,49245110,1,"<p>You need to move the opening/closing of the file out of the loop.</p>

<pre><code>FILE *f = fopen(""file.txt"", ""w"");
if (f == NULL)
{
   printf(""Error opening file!\n"");
   exit(1);
}

for (szPos = 0; szPos &lt; szBytes; szPos++) {
   // printf(""%x"",pbtData[szPos]);
   fprintf(f,""%x"",pbtData[szPos]);
}
printf(""\n"");

fclose(f);
</code></pre>

<hr>

<p>You may want to add a space to the output to clearly see the output.</p>

<pre><code>   fprintf(f, ""%x "", pbtData[szPos]);
   //            ^
</code></pre>
",0
55776420,55776346,1,"<p>You can't access a local variable outside a function. You either declare that in a broader scope, like global, which is a last-resort, or pass it in to be populated.</p>

<p>For example:</p>

<pre><code>int exec_uname(ssh_session session, int* bytes) {
  // ... code

  // Push back to caller
  *bytes = nbytes;
}
</code></pre>

<p>So when called:</p>

<pre><code>int nbytes;
int result = exec_uname(session, &amp;nbytes);
printf(""Server output: %d"", nbytes);
</code></pre>

<p>You'll still need to check <code>result</code> to be sure the function terminated properly or the value in <code>nbytes</code> will not be usable.</p>
",6
53725211,53724000,0,"<p>Your image in crude ASCII art:</p>

<pre>
| MSB 5  |     4  |    3   |    2   |    1   | LSB 0  |
|     ACTIVE ELECTRICAL ENERGY      | TARIFF |VALIDITY|
|vvvvvvvv|vvvvvvvv|vvvvvvvv|vvvvvvvv|uuuuuuuu|rrrrrrbb|
</pre>

<p>Supposing you have all those bits in <code>allbits</code>, do</p>

<pre><code>unsigned v = allbits &gt;&gt; 16;
unsigned u = (allbits &gt;&gt; 8) &amp; 0xff;
unsigned r = (allbits &gt;&gt; 2) &amp; 0x3f
unsigned b = allbits &amp; 0x03;
</code></pre>

<p>Or the other way around, building <code>allbits</code> from the parts</p>

<pre><code>allbits = (v &lt;&lt; 16) | (u &lt;&lt; 8) | (r &lt;&lt; 2) | (b);
</code></pre>
",2
56952851,56952717,0,"<p>Most implementations push the arguments on the stack, using register won't work well on register-starved architectures or if there's more arguments than registers generally.</p>

<p>And the called function doesn't know anything at all about the arguments, their count or their types. That's why e.g. <code>printf</code> and related functions use format specifiers. The called function will then interpret the next part of the stack according to that format specifier (using the <a href=""https://en.cppreference.com/w/c/variadic/va_arg"" rel=""nofollow noreferrer""><code>va_arg</code></a> ""function"").</p>

<p>If the type fetched by <code>va_arg</code> doesn't match the actual type of the argument, you will have <em>undefined behavior</em>.</p>
",0
56952801,56952717,0,"<blockquote>
  <p>where the arguments are copied (stack/register?)?</p>
</blockquote>

<p>It varies. On x64 normal conventions are used: the first few arguments (depending on type) probably go into registers, and other arguments go onto the stack. The C standard requires that the compiler support at least 127 arguments to a function, so it's inevitable that some of them are going to go on the stack.</p>

<blockquote>
  <p>how the called function gets the information about the arguments passed by calling function?</p>
</blockquote>

<p>By using the initial arguments, such as the printf format string. The varargs support facilities in C doesn't allow the function to inspect the number and types of arguments, only to get them one at a time (and if they're improperly casted, or if more arguments are accessed than were passed, the result is undefined behavior).</p>
",0
50179237,50179094,2,"<p>Once preprocessed, your code boils down more or less to this:</p>

<pre><code>#include &lt;stdio.h&gt;

printf(""Csau"");

int main()
{
    return 0;
}
</code></pre>

<p>And this is not correct C. You cannot call a function outside functions. It doesn't make sense. When you run the program, the system calls your <code>main</code> function and that's it.</p>
",0
49908534,49908464,2,"<p>It skips because you are reading the file with <code>fgets</code> as well, so <code>fgets</code> get
the first line, <code>fscanf</code> the second line but leaves the newline in the input
buffer, so <code>fgets</code> will read only an empty line, etc. It's a bad idea to mix
both reading function.</p>

<p>The best thing would be to read all lines with <code>fgets</code> and parse each line with
<code>sscanf</code>. Use the return value of <code>sscanf</code> to determine how many integer you've
read. From your input it seems that a line can have 1, 2 or 3 integers. So this
would do:</p>

<pre><code>char line[1024];
while(fgets(line, sizeof line, inputFile))
{
    int pages, frames, requests, ret;

    ret = sscanf(line, ""%d %d %d"", &amp;pages, &amp;frames, &amp;requests);

    if(ret &lt; 1)
    {
        fprintf(stderr, ""Error parsing the line, no numbers\n"");
        continue;
    }

    if(ret == 1)
    {
        // do something with pages
    } else if(ret == 2) {
        // do something with pages &amp; frames
    } else if(ret == 3) {
        // do something with pages, frames and requests
    }
}
</code></pre>

<hr>

<p><em>edit</em></p>

<p>based on your comments, of only the first line has 3 values and the rest of the
lines have one value each, then you can simplify the code like this:</p>

<pre><code>#include &lt;stdio.h&gt;

int parse_file(const char *fname, int *pages, int *frames, int *request, int *vals, size_t size)
{
    size_t idx = 0;

    if(fname == NULL || pages == NULL || frames == NULL
            || request == NULL || vals == NULL)
        return -1;

    FILE *fp = fopen(fname, ""r"");
    if(fp == NULL)
    {
        fprintf(stderr, ""Cannot open %s\n"", fname);
        return -1;
    }

    if(fscanf(fp, ""%d %d %d"", pages, frames, request) != 3)
    {
        fprintf(stderr, ""Wrong format, expecting pages, frames and requests\n"");
        fclose(fp);
        return -1;
    }

    // reading all other values and storing them in an array
    while((idx &lt; size) &amp;&amp; (fscanf(fp, ""%d"", vals + idx) == 1)); // &lt;-- note the semicolon

    fclose(fp);
    return idx; // returning the number of values of the array
}

int main(void)
{
    int pages, frames, request, vals[100];

    int num = parse_file(""/your/file.txt"", &amp;pages, &amp;frames, &amp;request,
                vals, sizeof vals / sizeof vals[0]);

    if(num == -1)
    {
        fprintf(stderr, ""Cannot parse file\n"");
        return 1;
    }

    // your code

    return 0;
}
</code></pre>
",6
58989770,58989572,5,"<p>The return value 3221225725 (C00000FD in hexadecimal) is the error code for stack overflow on Windows.</p>

<p>The stack overflow happens because your recursion never stops. <code>main</code> is calling <code>test</code> which is calling <code>main</code> which is calling <code>test</code> and so on indefinitely until the process' stack is full and then Windows kills the process and returns the error code to the caller.</p>

<p>If you want to use recursion, you need a stop condition so the recursion will end at some point. Google ""factorial recursion"" for a simple example.</p>

<p>Be aware that recursion can be abused and often an iterative approach is more efficient.</p>
",1
49760301,49760141,0,"<p>Your code has undefined behaviour, the fact that it ""works"" means nothing.</p>

<p>You are mixing types here and that's what the compiler is warning you. The
problem here is this:</p>

<pre><code>ptr = name;
</code></pre>

<p>because you are assigning a <code>char</code> pointer to a <code>int</code> pointer, they are
incompatible because <code>char</code> and <code>int</code> have different sizes and this will be a
problem when accessing memory through the <code>int</code> pointer.</p>

<p>When you do this:</p>

<pre><code>printf(""%c"", *(ptr+i));
</code></pre>

<p>you eventually accessing memory out of bounds. <code>ptr + i</code> is pointer arithmetic,
that means that the compiler takes the size into account. When the compiler
calculates the offset for the expression <code>ptr + i</code>, it calculates the offset by doing <code>i * sizeof(int)</code>.
Depending on the length of the string, this offset will be larger than limit of the <code>name</code> array. So it will
dereference a pointer past the bounds of the memory, and this yields undefined behaviour.</p>

<p>So the code is just simply wrong, like I said, the fact that it ""works"" means
nothing. The code could have ended with a segfault or erasing your hard drive.</p>
",2
53097239,53097166,1,"<p>A  <kbd>NUL</kbd> character cannot be <em>inside</em> a C string, since by definition it is ending a C string.</p>

<p>(The <kbd>NUL</kbd> character is <code>'\0'</code> -practically, a zero byte- and is of course different of the  <code>NULL</code> <em>pointer</em>).</p>

<p>And your <code>str</code> is probably too small. Consider declaring it with <code>char str[32];</code> and clearing it with <code>memset(str, 0, sizeof(str));</code> before reading into it.</p>

<p>So what your user would input is not a string, but simply a sequence of bytes (you might read character by character a stream of bytes using <a href=""https://en.cppreference.com/w/c/io/getchar"" rel=""nofollow noreferrer"">getchar</a>). Hence you cannot use <a href=""https://en.cppreference.com/w/c/io/fgets"" rel=""nofollow noreferrer"">fgets</a> for reading (of course, forget about <code>gets</code>, it is obsolete, dangerous, and removed from the <a href=""https://en.wikipedia.org/wiki/C11_(C_standard_revision)"" rel=""nofollow noreferrer"">C11</a> standard. Read <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">n1570</a> to check).</p>

<p>A different question is what should your user do to enter such a <kbd>NUL</kbd> character on the keyboard. Such details are operating system specific (on some systems there might be no way to type a <kbd>NUL</kbd> character, on other systems you might have to press several keys simultaneously, including the <kbd>Ctrl</kbd> key). You could consider some <a href=""https://en.wikipedia.org/wiki/Redirection_(computing)"" rel=""nofollow noreferrer"">redirection</a> from some binary file containing <kbd>NUL</kbd> bytes.</p>

<p>It is surprising (and very unusual) that you want to enter a <kbd>NUL</kbd>; I am guessing that you are mis-undestanding your homework.</p>

<p>Perhaps you want to handle the empty input case. For that, you need to explicitly detect the end-of-file condition (e.g. when <code>getchar</code> gives <code>EOF</code>, which is <em>not</em> a character). Beware that <a href=""https://en.cppreference.com/w/c/io/feof"" rel=""nofollow noreferrer"">feof</a> is only valid after some (failed) read operation.</p>

<p>Be sure to compile with all warnings and debug info (with <a href=""https://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a> compiler, use <code>gcc -Wall -Wextra -g</code>). Read <a href=""https://ericlippert.com/2014/03/05/how-to-debug-small-programs/"" rel=""nofollow noreferrer""><em>How to debug small programs</em></a></p>
",1
51349107,51349016,0,"<p>you need something like this</p>

<p>EDIT - <a href=""https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/scanf-s-scanf-s-l-wscanf-s-wscanf-s-l?f1url=https%3A%2F%2Fmsdn.microsoft.com%2Fquery%2Fdev15.query%3FappId%3DDev15IDEF1%26l%3DEN-US%26k%3Dk(STDIO%2Fscanf_s)%3Bk(scanf_s)%3Bk(DevLang-C%2B%2B)%3Bk(TargetOS-Windows)%26rd%3Dtrue"" rel=""nofollow noreferrer"">more info here</a></p>

<p>scanf_s is for reading from console
printf to print on screen</p>

<pre><code>int main()
{
    int i;
    scanf_s(""%d"", &amp;i);
    printf(""%d"", i);
    return 0;
}
</code></pre>
",0
48105155,48100752,0,"<p>The <code>p</code> in <code>main</code> is a different object in memory than the <code>p</code> in <code>foo</code>.  Writing to one has no effect on the other.  If you want <code>foo</code> to update the value of <code>p</code> in <code>main</code>, then you must pass a pointer to <code>p</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int i = 97, *p = &amp;i;
    foo(&amp;p);
    printf(""%d "", *p);
}

void foo(int **p)
{
    int j = 2;
    *p = &amp;j;
    printf(""%d "", **p);
}
</code></pre>

<p><strong>WARNING</strong> - doing this will invoke <em>undefined behavior</em>, since <code>p</code> will point to an object that no longer exists - once <code>foo</code> exits, <code>j</code> no longer exists, and <code>p</code> will be an <em>invalid</em> pointer.  You <em>may</em> get the output you expect, or you may not.  </p>

<p>In order for a function to write to a parameter, you must pass a pointer to that parameter:</p>

<pre><code>void foo( T *ptr )
{
  *ptr = new_value(); // updates the thing ptr points to
}

void bar( void )
{
  T var;              // var is an instance of T
  foo( &amp;var );        // have foo update the value of var
}
</code></pre>

<p>This is true for <em>any non-array type <code>T</code></em>, including pointer types.  If we replace <code>T</code> with the pointer type <code>P *</code>, we get</p>

<pre><code>void foo( P * *ptr )
{
  *ptr = new_value(); // updates the thing ptr points to
}

void bar( void )
{
  P * var;            // var is an instance of P *
  foo( &amp;var );        // have foo update the value of var
}
</code></pre>

<p>The semantics are exactly the same - the only thing that's changed is that <code>var</code> starts out as a pointer type.  </p>

<p>Things get weird with array types, which we're not going to go into quite yet.  </p>
",0
52303934,52303888,1,"<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
  int phoneNumber = 1234567;
  int p1 = phoneNumber / 10000;
  int p2 = phoneNumber % 10000;
  printf(""OK: %03d-%04d\n"", p1, p2);
  // OK: 123-4567
  return 0;
}
</code></pre>
",1
51107470,51107247,6,"<p>As Eugene mentioned in the above comment, what you saw is likely a result of using preprocessor directives. Some IDEs will look at these (#define, #if, etc) and then change colors to indicate which code is unreachable.</p>
",1
48142890,48142380,0,"<p>The teacher's code is moderately appalling.  It returns an array of pointers that are dynamically allocated, but they actually point to the global variable <code>LT</code>, which is an array of 150 characters.  Consequently, each call to <code>read_split_line_file()</code> overwrites the previous data.  Doing the dynamic allocation seems a tad silly.  It would be reasonable to have the calling code provide the array of pointers, and even the line buffer.</p>

<p>However, it appears that you're meant to use the function along the lines of:</p>

<pre><code>FILE *fp = fopen(data_file_name, ""r"");
¡­error check fp¡­

enum { MAX_CONTRACT = 150 };
Contracts contract[MAX_CONTRACT];
int i;

for (i = 0; i &lt; MAX_CONTRACT; i++)
{
    char **row;
    int num_fields;
    if ((row = read_split_line_file(fp, 4, &amp;num_fields, ""\t"")) == 0)
        break;
    if (num_fields != 4)
       ¡­report format error¡­
    ¡­convert row[0] into contract[i].contract_id;
    ¡­copy    row[1] into contract[i].name;
    ¡­copy    row[2] into contract[i].street_id;
    ¡­convert row[3] into contract[i].power;
    free(row);
}
fclose(fp);
/* You have i valid contracts here */
</code></pre>

<p>You need to fill in the lines starting with <code>¡­</code> with appropriate code.</p>
",0
52914892,52914641,0,"<p>That'll sometimes overflow the buffer (very bad), sometimes it'll get the quoting wrong, and with no arguments, the buffer will be uninitialized (=> undefined behavior).</p>

<p>When a shell runs your program, it'll de-quote strings and interpolate <code>$-variables</code>. To do this forwarding robustly, you'd need to requote, in addition to checking against buffer overflow. That would be a bit tedious for in a short program. </p>

<p>The easier thing would be to simply posix_spawn or fork/exec with the argv array directly:</p>

<pre><code>int status;
pid_t pid;

if (0&gt;(pid=fork())) return -1;
if(0==pid){
    execvp(argv[1],argv+1);
    _exit(127);
}
while(0&gt;(waitpid(pid,&amp;status,0)))
    if (EINTR==errno) continue; else abort(); /*shouldn't happen*/
</code></pre>

<p>Now, a real <code>system()</code> would additionally ignore <code>SIGINT/SIGQUIT</code> in the parent and block <code>SIGCHLD</code> in the parent before the status is reaped. <code>posix_spawnp</code> would also be preferred.</p>

<p>To copy that right, you can start off with the musl libc's implementation of <code>system</code>, and modify it to create a </p>

<pre><code>int my_system(char const *file, char *argv[i]);
</code></pre>

<p>that'll skip the shell (and with it, the need to create a string with correct quoting and buffer overflow checking):</p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;spawn.h&gt;
#include &lt;errno.h&gt;
#include &lt;pthread.h&gt;

//extern char **__environ;
extern char **environ;

int my_system(char const *file, char *argv[])
{
    pid_t pid;
    sigset_t old, reset;
    struct sigaction sa = { .sa_handler = SIG_IGN }, oldint, oldquit;
    int status = -1, ret;
    posix_spawnattr_t attr;

    //pthread_testcancel();

    //if (!cmd) return 1;

    sigaction(SIGINT, &amp;sa, &amp;oldint);
    sigaction(SIGQUIT, &amp;sa, &amp;oldquit);
    sigaddset(&amp;sa.sa_mask, SIGCHLD);
    sigprocmask(SIG_BLOCK, &amp;sa.sa_mask, &amp;old);

    sigemptyset(&amp;reset);
    if (oldint.sa_handler != SIG_IGN) sigaddset(&amp;reset, SIGINT);
    if (oldquit.sa_handler != SIG_IGN) sigaddset(&amp;reset, SIGQUIT);
    posix_spawnattr_init(&amp;attr);
    posix_spawnattr_setsigmask(&amp;attr, &amp;old);
    posix_spawnattr_setsigdefault(&amp;attr, &amp;reset);
    posix_spawnattr_setflags(&amp;attr, POSIX_SPAWN_SETSIGDEF|POSIX_SPAWN_SETSIGMASK);

#if 0
    ret = posix_spawn(&amp;pid, ""/bin/sh"", 0, &amp;attr,
        (char *[]){""sh"", ""-c"", (char *)cmd, 0}, environ);
#else
    ret = posix_spawnp(&amp;pid, file, 0, &amp;attr, argv, environ);
#endif

    posix_spawnattr_destroy(&amp;attr);

    if (!ret) while (waitpid(pid, &amp;status, 0)&lt;0 &amp;&amp; errno == EINTR);
    sigaction(SIGINT, &amp;oldint, NULL);
    sigaction(SIGQUIT, &amp;oldquit, NULL);
    sigprocmask(SIG_SETMASK, &amp;old, NULL);

    if (ret) errno = ret;
    return status;
}
</code></pre>

<p>Now with my_system, you have no need for quoting and you can simply call it with</p>

<pre><code>my_system(argv[1], argv+1);
</code></pre>
",0
55559686,55559641,0,"<p>In C,in</p>

<pre><code>a = f(x) &amp;&amp; g(y)
</code></pre>

<p>If f(x) evaluates to 0 we know a will always be 0 no matter what g(y) is.  g(y) will therefore not be evaluated and any side effects of g(y) will not happen. </p>

<p>In your case, this means the increment never happens.</p>
",2
49983557,49983240,0,"<p>Most compilers allocate local variables in the stack, however most operating system limit stack size to something reasonable, like in the tens to hundreds of megabytes.  So let's assume it does some compiler magic is hide this limit and isn't in the stack but on the heap.</p>

<p>Long story short your program doesn't get physical RAM until it actually attempts to read or write for most things.  This causes a pages fault which gets handled by a component in the operating system called a virtual memory manger.  This then maps RAM to a segment of your address space (program memory) in a unit called a page.  Pages vary in size based on processor architecture, however for AMD64 it uses 4KB or 4MB page sizes, depending on what the operating system would like to do.</p>
",0
53252496,53252397,-1,"<p>You can't (or at least <em>shouldn't</em>) define functions inside functions in C.</p>

<pre><code>cc -Wall -Wshadow -Wwrite-strings -Wextra -Wconversion -std=c99 -pedantic -g `pkg-config --cflags glib-2.0`   -c -o test.o test.c
test.c:15:41: error: function definition is not allowed here
    double power(double num, int power) {
                                        ^
test.c:36:5: error: function definition is not allowed here
    {
    ^
</code></pre>

<p>And you have two <code>main</code> functions. <code>main</code> is the function which gets run by the operating system when the program is run. You only need one.</p>

<p>There's a couple other problems...</p>

<pre><code>test.c:41:52: warning: format specifies type 'double' but the argument has type 'int' [-Wformat]
    printf(""%.2f raised to the power of %d is : "", p);
            ~~~~                                   ^
            %.2d
test.c:41:42: warning: more '%' conversions than data arguments [-Wformat]
    printf(""%.2f raised to the power of %d is : "", p);
</code></pre>

<p>That <code>printf</code> is missing an argument. It should be...</p>

<pre><code>printf(""%.2f raised to the power of %d is : "", number, p);
</code></pre>

<p>With those fixes it works fine.</p>

<hr>

<p>You can <a href=""https://www.wikiwand.com/en/Don%27t_repeat_yourself"" rel=""nofollow noreferrer"">DRY</a> up <code>power</code> by defining a second function just for positive numbers.</p>

<pre><code>double power_positive(double num, int power) {
    int i = 0;
    double result = 1;
    for (i = 0; i &lt; power; i++) {
        result *= num;
    }
    return result;
}

double power(double num, int power) {
    if (power &lt; 0) {
        return 1 / power_positive(num, -power);
    }
    else {
        return power_positive(num, power);
    }
}
</code></pre>
",6
49194417,49194332,1,"<pre><code>void printMe(int num) {
    if (num == N+1) { return; }
    printf(""%d"", num);
    printMe(num+1);
}
</code></pre>
",6
50191042,50190976,1,"<p>Yes, you should loop while <code>fgets</code> doesn't return a null pointer. E.g. <code>while (fgets(...) != NULL)</code>.</p>

<p>If you want to get the first character of <code>j</code> (which is what <code>*fgets(...)</code> will give you) then get it inside the loop:</p>

<pre><code>n = j[0];  // Equal to n = *j
</code></pre>
",0
53511726,53511559,0,"<p>You may use <code>copysign()</code> functions available in <code>math.h</code> to get the sign of <code>float</code> number. </p>

<pre><code>float sign = copysign(1, float_num);
</code></pre>

<p>Value of <code>sign</code> is going to be <code>+1</code> or <code>-1</code> depending upon the type of input. </p>
",1
48175780,48175319,4,"<p>Because <code>maxPlace</code> might be uninitialized. And because you're reading input incorrectly such that you'll always get <code>N</code> elements even if the user only put in 1.</p>

<hr>

<p>It's illustrative to show how I tracked this down. Normally I'd track down a segfault using <a href=""http://www.valgrind.org/"" rel=""nofollow noreferrer"">Valgrind</a> which would tell me the offending line, but that's currently broken on OS X. So here's the old fashioned way with prints and deduction.</p>

<p>First, the <code>-fsanitize=address</code> compiler flag will cause a runtime failure if you walk off the end of allocated memory, such as using an uninitialized variable. This can usually catch memory errors as soon as they happen rather than far down the road. It will also tell you what function it happened in.</p>

<pre><code>$ make
cc -fsanitize=address -Wall -Wshadow -Wwrite-strings -Wextra -Wconversion -std=c99 -pedantic -g `pkg-config --cflags glib-2.0`   -c -o test.o test.c
cc `pkg-config --libs glib-2.0` -lssl -lcrypto -fsanitize=address  test.o   -o test

$ ./test
Enter a series of integrs: 5
ASAN:DEADLYSIGNAL
=================================================================
==80879==ERROR: AddressSanitizer: SEGV on unknown address 0x7ffee6679358 (pc 0x0001095a7cac bp 0x7ffee6659330 sp 0x7ffee66592b0 T0)
    #0 0x1095a7cab in selection_sort (/Users/schwern/tmp/./test+0x100001cab)
    #1 0x1095a78db in main (/Users/schwern/tmp/./test+0x1000018db)
    #2 0x7fff73819114 in start (/usr/lib/system/libdyld.dylib+0x1114)

AddressSanitizer can not provide additional info.
SUMMARY: AddressSanitizer: SEGV (/Users/schwern/tmp/./test+0x100001cab) in selection_sort
==80879==ABORTING
Abort trap: 6
</code></pre>

<p>Now I know it's in <code>selection_sort()</code>. I can start adding debugging print statements to narrow it down. That <code>for</code> loop is suspect, maybe you're walking off the array, so I started with that. I'll also want to know if you recurse, so I've put a print on that.</p>

<pre><code>puts(""Entering loop"");
for (i = 1; i &lt; length; i ++)
{
    printf(""i: %d\n"", i);
    if (array[i] &gt; max)
    {
        max = array[i];
        maxPlace = i;
    }
    puts(""Loop next"");
}
puts(""Leaving loop"");

temp = array[length - 1];
array[length - 1] = max;
array[maxPlace] = temp;

puts(""Recursing"");
selection_sort(array, length - 1);
</code></pre>

<p>And try that...</p>

<pre><code>$ ./test
Enter a series of integrs: 5
Entering loop
i: 1
Loop next
i: 2
Loop next
i: 3
Loop next
i: 4
Loop next
i: 5
Loop next
i: 6
Loop next
i: 7
Loop next
i: 8
Loop next
i: 9
Loop next
Leaving loop
ASAN:DEADLYSIGNAL
</code></pre>

<p>Nope, you're not walking off the array. But you're also not recursing. So it has to be in just the few lines of code after the loop. Ok, mark those up. Nothing fancy, numbers are fine when the scope is this small.</p>

<pre><code>puts(""1"");
temp = array[length - 1];
puts(""2"");
array[length - 1] = max;
puts(""3"");
array[maxPlace] = temp;
</code></pre>

<p>Run that...</p>

<pre><code>$ ./test
Enter a series of integrs: 5
Entering loop
i: 1
Loop next
i: 2
Loop next
i: 3
Loop next
i: 4
Loop next
i: 5
Loop next
i: 6
Loop next
i: 7
Loop next
i: 8
Loop next
i: 9
Loop next
Leaving loop
1
2
3
ASAN:DEADLYSIGNAL
</code></pre>

<p>Now I know it's after <code>3</code> and before <code>recursing</code>. That means it's <code>array[maxPlace] = temp;</code>. Ok, what's in <code>maxPlace</code>?</p>

<pre><code>puts(""1"");
temp = array[length - 1];
puts(""2"");
array[length - 1] = max;
printf(""maxPlace: %d\n"", maxPlace);
array[maxPlace] = temp;
</code></pre>

<p>Run that...</p>

<pre><code>$ ./test
Enter a series of integrs: 5
Entering loop
i: 1
Loop next
i: 2
Loop next
i: 3
Loop next
i: 4
Loop next
i: 5
Loop next
i: 6
Loop next
i: 7
Loop next
i: 8
Loop next
i: 9
Loop next
Leaving loop
1
2
maxPlace: 32766
ASAN:DEADLYSIGNAL
</code></pre>

<p><code>maxPlace</code> being 32766 means it probably contains garbage. Now that I know what variable is the problem I can look at how it's declared, initialized, and set to discover there's a case where it will never be initialized: if the list is sorted in descending order.</p>

<hr>

<p>But I only put in one number, 5! Shouldn't <code>if (length &lt; 2)</code> have caught that? No, because you're always iterating over <code>N</code> elements no matter how much input you read.</p>

<pre><code>printf(""Enter a series of integrs: "");
for(i = 0; i &lt; N; i ++)
{
    scanf(""%d"", &amp;array[i]);
}
</code></pre>

<p>If I put in <code>5</code> and then hit <code>ctrl-d</code> to end input, <code>scanf</code> will only set <code>array[0] = 5</code>. But the loop will continue running for 1 to 9. <code>scanf</code> will fail because <code>stdin</code> is closed. The rest of the array will be uninitialized.</p>

<p>And you're sorting <code>N</code> elements, not the number read. So you'll always sort 10 elements whether they're initialized or not.</p>

<p>You're getting lucky that they happen to be 0.</p>

<pre><code>$ ./test
Enter a series of integrs: 5
In sorted order: 0 0 0 0 0 0 0 0 0 5 
</code></pre>

<p>Instead, you should be reading until <code>N</code> or until <code>scanf</code> fails, whichever comes first. This will also protect you from garbage input. And also only sort and print up to the number of integers read, not the maximum capacity of the array.</p>

<pre><code>int main (void)
{
    int array[N];
    int num_ints;

    printf(""Enter a series of integrs: "");
    for(num_ints = 0; num_ints &lt; N; num_ints++)
    {
        if( scanf(""%d"", &amp;array[num_ints]) &lt; 1 ) {
            break;
        }
    }

    selection_sort(array, num_ints);

    printf(""In sorted order: "");
    for(int i = 0; i &lt; num_ints; i ++)
    {
        printf(""%d "", array[i]);
    }
    printf(""\n"");

    return 0;
}
</code></pre>
",0
50591226,50589933,0,"<p>Your hash table stores pointers to instances of ""struct utilizador"".  However, every time you call <code>insereHash</code>, you are passing the same <code>ar_temp</code> instance, which you are overwriting on every call to <code>input</code>.</p>

<p>That's why you print the same string multiple times at the end - the entries are in the right place, but you overwrote the data.</p>

<p>You want:</p>

<pre><code> ha-&gt;itens:  [.| |.|.| ]
              |   | |
              |   | +-&gt; {""asdre"",""ana""}
              |   +---&gt; {""qwert"",""joa""}  
              +-------&gt; {""zxcvb"",""tutu""}
</code></pre>

<p>You have:</p>

<pre><code> ha-&gt;itens:  [.| |.|.| ]
              |   | |
              +---+-+-&gt; {""zxcvb"",""tutu""} &lt;-- ar_temp
</code></pre>
",1
50283275,50283219,3,"<p>The parentheses around the expansion of PB1 make it into a single argument with a comma operator in between ¡ª so your invocation expands to:</p>

<pre><code>GPIO_setAsInputPin((GPIO_PORT_P2, GPIO_PIN4))
</code></pre>

<p>You should probably use:</p>

<pre><code>#define PB1   (GPIO_PORT_P2), (GPIO_PIN4)
</code></pre>

<p>which expands to:</p>

<pre><code>GPIO_setAsInputPin((GPIO_PORT_P2), (GPIO_PIN4))
</code></pre>

<p>giving you two arguments.  Or you could omit the parentheses around the names and you'd probably be safe.</p>

<p>You may still have problems if <code>GPIO_setAsInputPin</code> is itself a macro that expects two arguments.  Then you'd need something like:</p>

<pre><code>#define GPIO_setAsInputPin_1(x)    GPIO_setAsInputPin(x)
</code></pre>

<p>and you would invoke:</p>

<pre><code>GPIO_setAsInputPin_1(PB1);
</code></pre>

<p>and you'd get as output:</p>

<pre><code>GPIO_setAsInputPin((GPIO_PORT_P2), (GPIO_PIN4));
</code></pre>

<p>or whatever the underlying macro expands to.</p>
",0
48356035,48354205,2,"<p>If you disregard the specific numbers and instead write</p>

<pre><code>while (i &lt;= MAX_INT)
</code></pre>

<p>the compiler sees this as <em>""loop while <code>i</code> is less than or equal to the largest value it can ever have""</em>. </p>

<p>As <code>i</code> - by definition - can never be larger than the largest value, this condition will always be true and the loop would be infinite.</p>

<p>However, as the code tries to compute <code>i + 1</code> even when <code>i</code> cannot possibly become any larger, there is an error in the program. The language standard explicltly states that if the program tries this - overflow on a signed variable - the result is undefined. </p>

<p>Undefined behavior can have <em>any</em> result according to the language standard. This includes getting some other value for <code>i</code> (perhaps a negative one despite trying to add 1), having the OS trap and terminate the program, or <em>possibly</em> even terminate a loop that would otherwise be infinite. We just don't know.</p>
",2
49260589,49259678,0,"<p>You could try to convert float to the string. 
You may use <code>snprintf</code> or something  similar for your needs. </p>

<p>The precision of the conversion of the <code>snprintf</code> may not be best. 
You may want to limit number of characters after the <code>'.'</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    float num = -12345.678; 
    char str[32];
    size_t counter = 0;

    // freestyle solution
    int len;
    printf(""Please input the number:\n"");
    if (1 == scanf(""%f"", &amp;num)) {
        len = snprintf(NULL, 0, ""%g"", num);
        printf(""\%g (%d)\n"", num, len);
    }

    //sg7: improved one - '.' and '-' counted.
    len = snprintf(str, 32, ""%f"", num);
    printf(""\n%s Number of characters: %zu"",str, len);

    return 0;
}
</code></pre>

<p>Test:</p>

<pre><code>Please input the number:                                                                                                                       
-12.345678                                                                                                                                     
-12.3457 (8)                                                                                                                                   

-12.345678 Number of characters: 10 
</code></pre>
",1
48457381,48457275,4,"<p>The task of (re)allocating memory is often resource-expensive and shouldn't be done often. The general rule, as used by for example a lot of C++ library container classes:</p>

<ul>
<li>At start, allocate <code>n * [system alignment]</code> bytes.</li>
<li>When the input no longer fits the allocated segment, re-allocate it with twice the previous size. Repeat each time you run out of memory.</li>
</ul>

<p>That is, exponentially increase the amount of allocated memory.</p>
",1
53841971,53841589,0,"<p>Just do <code>char word[n] = ""aaaaa"";</code></p>

<p>Full code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define n  5

char word[n] = ""aaaaa"";
char noob[n];

void
myfunction(void)
{
    int x, i, j;

    for (i = 0; i &lt; n - 1; i++) {
        // I did this to convert first from a char to int and then add one in
        // order to change a to b
        x = word[i];
        x++;
        word[i] = x;
        puts(word);

        // here is the problem after going through the first loob (i) we have
        // the word baa and it should go through the second loop j but it
        // doesn't
        for (j = 0; j &lt; n - 1; j++) {
            noob[j] = word[j];
            word[j + 1] = word[j];
            word[j] = noob[j];
            puts(word);
        }

    }
}

int
main(void)
{
    myfunction();

    return 0;
}
</code></pre>

<p>Of course this work when you know the length of your words at compile time. It the length would be known only at runtime (for example with a user inputting it) you need do dynamically allocate (with <code>malloc</code> for example) and remove.</p>
",0
53514928,53514870,1,"<p>You are simply modifying the parameter copy of main's <code>t</code> pointer within the <code>get(COMPUTER_NAME_FORMAT f, WCHAR* c)</code> function.</p>

<p>The effect is not propagated outside <code>get</code>.
You are assigning the value of tmp to a temporary pointer that is lost after <code>get</code> returns.</p>

<p>Pass <code>c</code> as <code>WCHAR** c</code> in <code>get</code> as follows:</p>

<pre><code>BOOL get(COMPUTER_NAME_FORMAT f, WCHAR** c){
  //stuff
  tmp = (WCHAR*)realloc(tmp, sizeof(WCHAR) * s);
  *c=tmp;
  //other stuff
}
</code></pre>
",2
50163104,50163050,1,"<p><code>while(x)</code> means to continue while <code>x</code> is non-zero.</p>

<p><code>a &amp;&amp; b</code> evaluates to non-zero if both <code>a</code> and <code>b</code> are non-zero.</p>

<p>So if either of <code>a</code> or <code>b</code> is zero, it is not true that both are non-zero. Therefore the loop doesn't continue.</p>
",0
50625737,50625536,1,"<p>It's doing an infinite loop as you are resetting <code>i</code> every time when doing</p>

<pre><code>i = 2;
</code></pre>

<p>But even without that, you'll probably overflow <code>i</code> and you don't have a recursion terminal case.</p>

<p>you will have to rethink your logic for this to work.</p>
",3
56672685,56672387,2,"<p>Any decent <a href=""https://en.wikipedia.org/wiki/Lint_(software)"" rel=""nofollow noreferrer"">linter</a> will flag numerous problems with this code. Here's what the one provided with <a href=""https://atom.io/"" rel=""nofollow noreferrer"">Atom editor</a> found, plus what I eyeballed.</p>

<pre><code>int lookup_personal_info(char *first_name, void *last_name, uint8_t (*sin)[9], const struct **info_out)
</code></pre>

<ul>
<li><code>last_name</code> is declared <code>void *</code> but used as a <code>char *</code></li>
<li><code>const struct **info_out</code> declares an anonymous struct. It should be <code>personal_info **info_out</code></li>
<li>The function returns a <code>bool</code> not an <code>int</code>.</li>
<li><code>sin</code> is never used except to check it's passed in.</li>
</ul>

<pre><code>    if (!first_name || !last_name || !sin)
        return false;
</code></pre>

<ul>
<li>Passing in a null pointer is probably a bug by the caller. This silently ignores that bug making it difficult to find. It should raise an error.</li>
<li>It forgets to check <code>info_out</code>.</li>
</ul>

<pre><code>    char *initials[3] = { first_name[0], last_name[1] };
</code></pre>

<ul>
<li>This is an array of character pointers being initialized with <code>char</code>. It should be <code>char initials[3]</code>.</li>
<li>It is not null terminated. Maybe it doesn't have to be, but I wouldn't risk that.</li>
<li><code>last_name</code> is declared <code>void *</code> yet used as a <code>char *</code>.</li>
<li>It's using the first character of <code>first_name</code> as an initial, that makes sense, but why the second... thing... in <code>last_name</code>?</li>
</ul>

<pre><code>    personal_info *data = malloc(sizeof(struct personal_info));
</code></pre>

<p><code>struct personal_info</code> is not a type, the type is <code>personal_info</code>.</p>

<pre><code>    *info_out = (personal_info *) data;
</code></pre>

<p><code>info_out</code> was incorrectly declared as an anonymous struct. It should be <code>personal_info **info_out</code>. Then no type cast is necessary.</p>

<pre><code>    bool is_ok = database_lookup(initials, &amp;data);
    if (is_ok)
        goto fail;
</code></pre>

<p>The check is backwards.</p>

<p>The use of <code>goto</code> is justified to ensure proper cleanup on error. It's probably included in the example as a red herring.</p>

<pre><code>fail:
    data = NULL;
    free(data);

    return true;
</code></pre>

<ul>
<li><code>free</code> is called after nulling out <code>data</code> leaking memory.</li>
<li>There's no need to set <code>data</code> to <code>NULL</code>, it's local to the function which will shortly exit.</li>
<li>Both failure and success return <code>true</code>.</li>
</ul>
",1
56672446,56672387,2,"<p>Setting a pointer to <code>NULL</code> before calling <code>free</code> on it makes the call to <code>free</code> benign (i.e. does nothing).</p>

<p>If you have a static analysis tool in your IDE that checks for and probably incorrect code, I wouldn't be surprised that it got picked up by it.</p>

<p>The idiomatic way to call <code>free</code> safely is to set the <code>free</code>-d pointer to <code>NULL</code> <em>after</em> the call, not before.</p>
",5
56672438,56672387,0,"<p>This doesn't make much sense to me.  Why free a <code>NULL</code> pointer...</p>

<pre><code>fail:
    data = NULL;
    free(data);
</code></pre>
",0
48506458,48505911,4,"<p>There are three main problems here.</p>

<p>First, you're reading past the end of the array:</p>

<pre><code>for(int i=0; i&lt;n; i++){
    if(strcmp(a[i], a[i+1]) == 0){
</code></pre>

<p>When <code>i</code> has a value of <code>n-1</code>, <code>a[i+1]</code> is actually <code>a[n]</code>, which is one element past the end of the array.  Reading past the end of an array invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a> which in this caes manifests in a crash.  You need to change your loop to stop at <code>n-1</code>:</p>

<pre><code>for(int i=0; i&lt;n-1; i++){
</code></pre>

<p>Second, your algorithm is only comparing adjacent words in this list.  For this to work, your list needs to be sorted, and your code isn't doing that.</p>

<p>Third, assuming you did sort the words, your counter starts at 0 when you find a new word.  So when you first find a word the count is 0, then when you find a second occurrence the count is 1, and so forth.  You need to start <code>result</code> at 1 when you find a new word.</p>
",1
49307440,49307311,1,"<p>On my computer, the output of the code you have shown is</p>

<pre><code>List 0$
 :$
List 1$
 :$
List 2$
 :$
List 3$
 :$
List 4$
 :$
</code></pre>

<p>I added dollar signs at the end of each line, so you can see that there are no trailing spaces.  On the other hand. the colons are being printed on their own lines, not after the numbers.  Is that maybe your actual problem and you didn't explain it quite right?</p>

<p>To get the output you said you wanted, either of these is supposed to work:</p>

<pre><code>fprintf (f, ""List %d:\n"", i);
</code></pre>

<p>or</p>

<pre><code>fprintf (f, ""%s%d%s\n"", ""List"", i, "":"");
</code></pre>
",0
50019395,50017462,1,"<p>Yeah it looks like a false positive. In your if-else if-else, you only initialize the variable inside the <code>if</code> and <code>else if</code> statements. Apparently you got the tool confused with goto or some such.</p>

<p>But that's not really important, as the origin of the problems is the function design. You don't default initialize variables and you have a tight coupling between memory allocation and the actual algorithm. The use of goto here is ok but it reduces readability somewhat.</p>

<p>I would split this in two functions, where you leave memory handling and error handling to an outer function. Something along the lines of this pseudo code would be much more readable:</p>

<pre><code>int wrapper_function ( ... )
{
  unsigned char *write_cdata = NULL;
  int err = initialize_me_to_something.

  if(ENC_ZIP_ENABLED(comp_enc_flags))
  {
    write_cdata = kmalloc (...
    if(write_cdata == NULL)
    {
      return -ENOMEM;
    }
  }
  else
  {
    if(!(comp_enc_flags &amp; ENC)
    {
      write_cdata = write_data;
      ...
    }
    else
    { // some special case
      err = do_skcipher_encrypt(...
      return err;
    }
  }


  err = do_the_actual_job(write_cdata, otherparameters); 

  if (err &lt; 0) 
  {
    cleanup();
  }

  return err;
}
</code></pre>

<p><code>goto</code> is not necessarily evil, but neither are multiple return statements. They are both frowned upon with more or less rational arguments provided. However, multiple return statements tend to improve readability quite a bit over the ""on error goto"" pattern. Most importantly, they tend to naturally give a better program design with multiple small functions instead of a single big one.</p>

<p>As a side effect, you get rid of some extra branching instructions, which might give a slight performance improvement. </p>
",2
56440531,56439903,0,"<p>If you can use <code>getopt()</code> or other similar POSIX functions. Then this is one way to go:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;getopt.h&gt;

int main(int argc, char** argv)
{
    int opt;

    while ((opt = getopt(argc, argv, ""h?"")) != -1)
    {
        switch (opt)
        {
        case '?':
        case 'h':
            printf(""Usage: bla bla\n"");
            break;    
        }
    }

    return EXIT_SUCCESS;
}
</code></pre>

<p>Example:</p>

<pre><code>~ # /tmp/temp_test -?
Usage: bla bla

~ # /tmp/temp_test -y
/tmp/temp_test: invalid option -- 'y'
Usage: bla bla
~ #
</code></pre>

<p>More information in <a href=""https://linux.die.net/man/3/getopt_long"" rel=""nofollow noreferrer"">man page</a>.</p>
",0
49241900,49241835,5,"<p>Assuming:</p>

<pre><code>char array[7] = ""anana"";
</code></pre>

<p>Then:</p>

<pre><code>memmove(array+1, array, 6);
array[0] = 'B';
</code></pre>

<p>The <code>memmove</code> function is specifically for cases where the data movement involves an overlap.</p>
",0
49241976,49241835,1,"<p>You can use a more traditional approach using...  </p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
  char s[] = ""ananas"";
  char b[7] = ""B"";

  for(int i = 0; i &lt; 7; ) {
    char temp = s[i++];
    b[i] = temp;
  }

  printf(""%s"", b);    

  return 0;
}
</code></pre>
",3
48638664,48638132,2,"<p>There are several issues here but to avoid this being to lengthy I will
try to point you in the right direction.</p>

<p>The second argument to user_struct_to_string should be char* because
you allocate the string outside the function before calling it.</p>

<pre><code>void user_struct_to_string(struct user_data*, char* );
</code></pre>

<p>having <code>char**</code> would only be needed if you allocate the string inside 
user_struct_to_string() in order to return the address of that newly 
allocated string to the caller.</p>

<p>so the call would be</p>

<pre><code>user_struct_to_string(&amp;input_users[i], string_holder); 
</code></pre>

<p>(it would be wise to pass the max length to the function as well to avoid
going pass the size of what string_holder points to)</p>

<p>Inside your function you write</p>

<pre><code>memset(*return_data, 0, sizeof(return_data)); 
</code></pre>

<p>which doesn't do what you want, sizeof(return_data) - in the original case
when it was was a char** gives the size of the pointer, not the length of the
allocated string. That is why it is handy to pass the max length of the 
allocated string to the function.</p>

<pre><code>void user_struct_to_string(struct user_data*, char* return_data, size_t maxLen )
{
...
  memset(return_data, 0, maxLen); 
...
}
</code></pre>

<p>Although even better would be to just set the first byte string_holder to \0
and then pass it to the function</p>

<p>BTW You create to arrays with user_id and user_age, why not directly write 
it into the string you want to return?</p>

<pre><code>void user_struct_to_string(struct user_data*, char* return_data )
{
...
  sprintf( return_data, ""{%d,%d}"", input_user-&gt;id, input_user-&gt;age);
}    
</code></pre>
",2
48638397,48638132,2,"<p>This will not do what you expect:</p>

<pre><code>memset(*return_data, 0, sizeof(return_data));
</code></pre>

<p><code>sizeof</code> will evaluate to the pointer size, not the size of the string. You will need to pass the length of the string to that function. </p>

<p>You should also use <code>strncat</code> and pass the length of <code>return_data</code>. </p>

<p>Also replace <code>sprintf</code> by <code>snprintf</code> and pass the length of <code>user_id</code>. </p>
",2
48642981,48642905,4,"<p>String literals, like <code>&quot;how is it possible at all ? &quot;</code> are really arrays of read-only characters stored somewhere by the compiler.</p>
<p>When you do</p>
<pre><code>char *pointer=&quot; how is it possible at all ? &quot;;
</code></pre>
<p>you initialize <code>pointer</code> to point to the first element of that array.</p>
<p>This is very similar to</p>
<pre><code>char string[] = &quot; how is it possible at all ? &quot;;
char *pointer = &amp;string[0];  // Make pointer point to the first character in the array
</code></pre>
<hr />
<p>How pointers themselves work depends on the compiler and the target architecture, but most of the time they are simple integers whose value is the address of the memory they point to. Then the compiler handles them specially and translates usage of the pointers into the correct machine-code instructions to access the memory a pointer is pointing to.</p>
<hr />
<p>Because string literals are read only, that's the reason you should really use <code>const char *</code> when making pointers to them. C allows plain non-constant <code>char *</code>, but then the compiler might not be able to detect attempts to modify the read-only literal, which leads to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>.</p>
",1
48448358,48448269,3,"<p>you are being too complicated. You just need a single malloc</p>

<pre><code>*fib_array = malloc(n * sizeof(int));
</code></pre>

<p>and remove you second indexings <code>[0]</code> from everywhere</p>

<p>The consfusion comes from <code>**int</code>. This looks like a multi dim array. Its not - its declared <code>**</code> so that you can set the value in the caller. A simpler exampe will help</p>

<pre><code>void Make42(int* v)
{
    *v = 42;
}

int main()
{
    int myv = 0;
    Make42(&amp;myv);
    // now myv == 42
}
</code></pre>

<p>The <code>*</code> in the arg list is so that Make42 can 'reach out' and modify what was passed to it (myv in this case)</p>

<p>In your code the <code>**</code> on fib array is there for the same purpose.  you could have done (In know you werent allowed to by the test definition )</p>

<pre><code>    int *fib(int n){
        int *fib_array = malloc(n * sizeof(int));
        ......
        return fib_array;
   }
</code></pre>

<p>and in main</p>

<pre><code>fib_sequence = fib(count);
</code></pre>

<p>this makes it much clearer that you are really manipulating a simple array</p>
",3
48448597,48448269,1,"<p>pm100 is right, but a little short for answering to a beginner...</p>

<p>At first, you have passed a pointer to a pointer. If you want the original pointer to contain a value, you need to dereference the pointer to pointer:</p>

<pre><code>*fib_array = ...
</code></pre>

<p>By assigning to the pointer only (as you did in your code), you do not modify the orignial pointer (<code>fib_sequence</code> in main) at all. And as you have not initialised it, it might point to <em>anywhere</em>, thus the segmentation fault when you try to print the values of it.</p>

<p>Then why an array of pointers to individually stored values? You can use a contiguous array of <code>int</code>s, which you get by</p>

<pre><code>*fib_array = malloc(n * sizeof(int));
</code></pre>

<p>OK, further usage won't be too nice (<code>(*fib_array)[i] = ...</code>), so I recommend a temporary variable instead:</p>

<pre><code>int* fa = malloc(n * sizeof(int));
// now fill in the values comfortably:
fa[i] = ...;

// finally, assign the pointer to the target:
*fib_array = fa;
</code></pre>

<p>Side note: always check the result of <code>malloc</code>, it could be <code>NULL</code>:</p>

<pre><code>fa = ...
if(fa)
   // assign values
else
    // appropriate error handling
</code></pre>

<p>In your concrete case, you could omit the else branch in your function and check your pointer outside within main function.</p>

<p>By the way, a simple return value would have made your live easier, too:</p>

<pre><code>int* fib(int n)
{
    int* fib_array = malloc(n * sizeof(int*));
    // ...
    return fib_array;
}
</code></pre>

<p>Notice: no need for pointer to pointer... Usage:</p>

<pre><code>int* fib_sequence = fib(count);
</code></pre>
",1
49620611,49620373,1,"<p>The segfault is actually here.</p>

<pre><code>scanf(""%d"",&amp;siswa[i]);
</code></pre>

<p>The problem comes from here.</p>

<pre><code>int siswa[lebar];
</code></pre>

<p><code>lebar</code> is not initialized at that point. Uninitialized variables in C can contain anything. That means <code>siswa</code> could be of any size.</p>

<p>The garbage value of <code>lebar</code> used to initialize <code>siswa</code> is then overwritten by <code>scanf(""%d"",&amp;lebar);</code>. The loop assumes <code>siswa</code> is as long as the new value of <code>lebar</code>, but <code>siswa</code> could be any size. <code>siswa[i]</code> might be unallocated. If so, you'll get a segfault when you try to use it.</p>

<p>The simple solution is to allocate memory for <code>siswa</code> after <code>lebar</code> is initialized.</p>

<pre><code>#include &lt;stdlib.h&gt;

...

int lebar,jumlah,i;
int *siswa;

printf(""Berapa Jumlah Siswa dalam Satu Kelas: "");
scanf(""%d"",&amp;lebar);
siswa = malloc( lebar * sizeof(int) );
</code></pre>

<hr>

<p>The compiler can warn you about such things, but you have to turn the warnings on. <code>-Wall</code> is a good start but, despite the name, it does not turn on all warnings. I use <code>-fsanitize=address -Wall -Wshadow -Wwrite-strings -Wextra -Wconversion -std=c99 -pedantic -g</code>. That produces...</p>

<pre><code>test.c:7:11: warning: variable 'lebar' is uninitialized when used here [-Wuninitialized]
int siswa[lebar];
          ^~~~~
test.c:6:10: note: initialize the variable 'lebar' to silence this warning
int lebar,jumlah,i;
         ^
          = 0
1 warning generated.
</code></pre>

<p>Which points at the problem. When run and it crashes, <code>-fsanitize=address</code> will give you a stack trace.</p>

<pre><code>==16611==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffee60c22a0 at pc 0x000109ed40c3 bp 0x7ffee60c2160 sp 0x7ffee60c1920
WRITE of size 4 at 0x7ffee60c22a0 thread T0
    #0 0x109ed40c2 in scanf_common(void*, int, bool, char const*, __va_list_tag*) (libclang_rt.asan_osx_dynamic.dylib+0x1a0c2)
    #1 0x109ed435e in wrap_scanf (libclang_rt.asan_osx_dynamic.dylib+0x1a35e)
    #2 0x109b3eb0e in main (/Users/schwern/tmp/./test+0x100001b0e)
    #3 0x7fff67e07114 in start (/usr/lib/system/libdyld.dylib+0x1114)
</code></pre>

<p>It's not the easiest thing to read, but it indicates the problem is when <code>scanf</code> is called. <a href=""https://clang.llvm.org/docs/AddressSanitizer.html"" rel=""nofollow noreferrer"">Here's more on the Address Sanitizer</a>.</p>
",1
49620611,49620373,1,"<p>The segfault is actually here.</p>

<pre><code>scanf(""%d"",&amp;siswa[i]);
</code></pre>

<p>The problem comes from here.</p>

<pre><code>int siswa[lebar];
</code></pre>

<p><code>lebar</code> is not initialized at that point. Uninitialized variables in C can contain anything. That means <code>siswa</code> could be of any size.</p>

<p>The garbage value of <code>lebar</code> used to initialize <code>siswa</code> is then overwritten by <code>scanf(""%d"",&amp;lebar);</code>. The loop assumes <code>siswa</code> is as long as the new value of <code>lebar</code>, but <code>siswa</code> could be any size. <code>siswa[i]</code> might be unallocated. If so, you'll get a segfault when you try to use it.</p>

<p>The simple solution is to allocate memory for <code>siswa</code> after <code>lebar</code> is initialized.</p>

<pre><code>#include &lt;stdlib.h&gt;

...

int lebar,jumlah,i;
int *siswa;

printf(""Berapa Jumlah Siswa dalam Satu Kelas: "");
scanf(""%d"",&amp;lebar);
siswa = malloc( lebar * sizeof(int) );
</code></pre>

<hr>

<p>The compiler can warn you about such things, but you have to turn the warnings on. <code>-Wall</code> is a good start but, despite the name, it does not turn on all warnings. I use <code>-fsanitize=address -Wall -Wshadow -Wwrite-strings -Wextra -Wconversion -std=c99 -pedantic -g</code>. That produces...</p>

<pre><code>test.c:7:11: warning: variable 'lebar' is uninitialized when used here [-Wuninitialized]
int siswa[lebar];
          ^~~~~
test.c:6:10: note: initialize the variable 'lebar' to silence this warning
int lebar,jumlah,i;
         ^
          = 0
1 warning generated.
</code></pre>

<p>Which points at the problem. When run and it crashes, <code>-fsanitize=address</code> will give you a stack trace.</p>

<pre><code>==16611==ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address 0x7ffee60c22a0 at pc 0x000109ed40c3 bp 0x7ffee60c2160 sp 0x7ffee60c1920
WRITE of size 4 at 0x7ffee60c22a0 thread T0
    #0 0x109ed40c2 in scanf_common(void*, int, bool, char const*, __va_list_tag*) (libclang_rt.asan_osx_dynamic.dylib+0x1a0c2)
    #1 0x109ed435e in wrap_scanf (libclang_rt.asan_osx_dynamic.dylib+0x1a35e)
    #2 0x109b3eb0e in main (/Users/schwern/tmp/./test+0x100001b0e)
    #3 0x7fff67e07114 in start (/usr/lib/system/libdyld.dylib+0x1114)
</code></pre>

<p>It's not the easiest thing to read, but it indicates the problem is when <code>scanf</code> is called. <a href=""https://clang.llvm.org/docs/AddressSanitizer.html"" rel=""nofollow noreferrer"">Here's more on the Address Sanitizer</a>.</p>
",1
49686019,49685909,2,"<p><code>temp</code> is uninitialized after <code>int temp;</code>.</p>

<pre><code>logcat (MSPRO_P-&gt;regs[test], byte, &amp;temp, test)
</code></pre>

<p>Since a pointer to <code>temp</code> is passed to the function, we, as programmers can guess that this function is supposed to initialize <code>temp</code>. But that is very difficult, if not impossible, for the compiler to assert with absolute certainity, specially when that function is in separate translation unit. From compilers perspective, there is no easy way to tell whether <code>logcat</code> will write to <code>*temp</code> or read it first in uninitialized state. And that's why the warning. </p>

<p>The easiest way to get rid of this warning is assign some initial value to temp, like:</p>

<p><code>int temp = 0</code></p>
",1
49686239,49685909,3,"<p>gcc isn't supposed to warn about passing a pointer to an uninitialized variable to a function it doesn't know anything about (the assumption is that the function will initialize it). So I'm pretty sure that gcc knows things about <code>logcat</code> and the uninitialized use is detected in there. Maybe it got inlined or such.</p>

<p>Example:</p>

<pre><code>$ cat &gt; foo.c
static int
bar(int *a)
{
    return *a + *a;
}

int
foo(void)
{
    int x;
    int y = bar(&amp;x);
    return x + y;
}
$ cc -Wall -c foo.c
$
</code></pre>

<p>Here, despite it being blindingly obvious to humans, gcc doesn't actually know what happens inside the function <code>bar</code>. So no warning.</p>

<p>Let's help gcc to understand what's going on:</p>

<pre><code>$ cc -O1 -Wall -c foo.c
foo.c: In function ¡®foo¡¯:
foo.c:4:12: warning: ¡®x¡¯ is used uninitialized in this function [-Wuninitialized]
  return *a + *a;
         ~~~^~~~
foo.c:10:6: note: ¡®x¡¯ was declared here
  int x;
      ^
$
</code></pre>

<p>Just turning on optimization helped gcc to see what's going on (probably some inlining happened).</p>

<p>From the minimal piece of code you've shown and the warning message, where it looks like you cut out the bit that actually tells you exactly where in your code the problem happens, I conclude that the problem is in your <code>logcat</code> function.</p>
",0
50070827,50070765,3,"<p>You don't need <code>malloc</code> for that tiny amount of memory, a <code>char str[5]</code> would
also do the job in this case. Also bear in mind that you <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">shouldn't cast <code>malloc</code></a>. And <code>sizeof(char)</code> is always 1,
so you can omit that as well. You should also always check the return value of
<code>malloc</code>:</p>

<pre><code>char *str = malloc(5);
if(str == NULL)
{
    // error handling
}
</code></pre>

<p>And don't forget to free the memory.</p>

<p>But I'm digressing now. The problem in your code problem is that</p>

<pre><code>str[2] = 'e';
</code></pre>

<p>is overwriting the 4 in <code>""h34""</code>. That's why the output is <code>h3e</code>. After the
<code>sprintf</code> call the memory looks like this:</p>

<pre><code>index     0     1     2     3      4
       +-----+-----+-----+------+-----+
       | 'h' | '3' | '4' | '\0' | ??? |
       +-----+-----+-----+------+-----+
</code></pre>

<p>The correct index is <code>3</code>, not 2:</p>

<pre><code>char str[5];
str[0] = 'h';

sprintf(&amp;str[1], ""%d"", 34);
str[3] = 'e';
str[4] = '\0'; // making sure to terminate string

puts(str); // output is h34e
</code></pre>

<p>If you append a character, you must not forget to set the
<code>'\0'</code>-terminating byte. That's what I'm doing in <code>str[4] = '\0'</code>. In your
example you were ""lucky"" because you didn't overwrite the <code>'\0'</code>-terminating
byte, so the string was still terminated correctly.</p>

<p>Also <code>snprintf</code> takes the length as well, without the length you should use
<code>sprintf</code>. In this case you can use <code>sprintf</code> because you know the size of the
buffer and the length of the number, you know that you are not going to write
beyond the limits, that's why in this case it's OK to use <code>sprintf</code> instead of
<code>snprintf</code>.</p>

<p>But of course you can do that in two lines of code:</p>

<pre><code>char str[5];
sprintf(str, ""h%de"", 34);
</code></pre>

<p>But I also like your original code because it forces you to think about how to access
elements of the array with indices and how strings are stored in memory. As an exercise this is good. For more serious projects, I wouldn't create strings in such a way. I'd use the one-liner solution.</p>
",7
52146565,52146256,1,"<p>I suggest (when in a <em>playing</em> mood)</p>

<pre><code>printf(""%d\n"", !(!!(a - b) * !!(a - c) * !!(b - c)));
</code></pre>
",6
52146391,52146256,4,"<p>I would do it like this:</p>

<pre><code>int different(int a, int b, int c)
{
  return a != b &amp;&amp; b != c &amp;&amp; a != c;
}
</code></pre>

<p>This will return <code>1</code> if all three numbers are different, else it will return 0 which must mean that there is at least one pair of duplicates.</p>

<p>Use it like so:</p>

<pre><code>printf(""%d\n"", different(11, 22, 11));
</code></pre>

<p>which will print:</p>

<pre><code>0
</code></pre>
",2
52146565,52146256,1,"<p>I suggest (when in a <em>playing</em> mood)</p>

<pre><code>printf(""%d\n"", !(!!(a - b) * !!(a - c) * !!(b - c)));
</code></pre>
",6
52146391,52146256,4,"<p>I would do it like this:</p>

<pre><code>int different(int a, int b, int c)
{
  return a != b &amp;&amp; b != c &amp;&amp; a != c;
}
</code></pre>

<p>This will return <code>1</code> if all three numbers are different, else it will return 0 which must mean that there is at least one pair of duplicates.</p>

<p>Use it like so:</p>

<pre><code>printf(""%d\n"", different(11, 22, 11));
</code></pre>

<p>which will print:</p>

<pre><code>0
</code></pre>
",2
48270967,48270927,0,"<p>I believe that you are swapping the first character with the null terminating character at the end of the string, causing the string to be of length 0 since the first character is <code>\0</code>. You need to move your <code>j</code> marker back by one once you found <code>\0</code>.</p>

<pre><code>char* rev_string(char* t)
{
    int i;
    int j;
    i = j = 0;
    char tmp;
    while(t[i] != '\0')
        i++;
    i--;
    while(i &gt; j)
    {
        tmp = t[i];
        t[i] = t[j];
        t[j] = tmp;
        i--;
        j++;
    }
    return t;
}
</code></pre>
",2
48636493,48634737,0,"<p>In addition to assigning integers to pointers (<code>month = newVal;</code> for example), some of your conditional tests are always true.</p>

<pre><code>     if (E = 14 || 15) {
         month = newVal;
         newVal = E - 13;
     }
</code></pre>

<p>This assigns the value of <code>14 || 15</code> (which is <code>1</code>) to <code>E</code>, and then tests that E is non-zero, which of course, it always is.</p>

<p>This test (and the other one like it) should be:</p>

<pre><code>if (E == 14 || E == 15) {
    *month = newVal;
    newVal = E - 13;
}
</code></pre>

<p>Note that the <code>newVal</code> integer is assigned to the integer that is pointed to by <code>month</code> (by using <code>*month</code>), and not the actual pointer variable <code>month</code>. This remedy should be applied to assignments to the <code>day</code> and <code>year</code> pointers also.</p>
",0
49702960,49702444,2,"<p>These two variables</p>

<pre><code>char *a = ""3"";
char *b = ""2"";
</code></pre>

<p>point to string literals and you cannot modify string literals, that yields
undefined behaviour. In most cases string literals are stored in read-only
memory, so modifying them usually ends with a segfault.</p>

<p>If you want to concatenate strings, then you need space for the second string.</p>

<p>First solution: Create bigger arrays:</p>

<pre><code>char a[20] = ""3"";
char b[20] = ""2"";

strcat(a, b);
puts(a);
</code></pre>

<p>This would print <code>32</code>.</p>

<p>The problem with this solution is that if <code>b</code> is too long, then it won't fit
into <code>a</code> and you will overflow <code>a</code>. If you for example are reading from the
user, the user might enter a string that is longer than <code>a</code> can hold. In that
case <code>strncat</code> should be used or take a look at my second solution.</p>

<p>Second solution: dynamically allocate memory</p>

<pre><code>int main(void)
{
    const char *a = ""3"";
    const char *b = ""2"";

    char *dest = malloc(strlen(a) + 1);

    if(dest == NULL)
    {
        fprintf(stderr, ""Not enough memory\n"");
        return 1;
    }

    strcpy(dest, a);

    char *tmp = realloc(a, strlen(a) + strlen(b) + 1);
    if(tmp == NULL)
    {
        fprintf(stderr, ""Not enough memory\n"");
        free(dest);
        return 1;
    }

    dest = tmp;

    strcat(dest, b);

    // printing concatenated string
    puts(dest);

    free(dest);

    return 0;
}
</code></pre>

<p>Another solution would be</p>

<pre><code>int main(void)
{
    const char *a = ""3"";
    const char *b = ""2"";

    size_t len = strlen(a) + strlen(b);

    // using calloc instead of malloc, because
    // calloc sets the allocated memory to 0,
    // great initialization for when using strcat
    char *dest = calloc(len + 1, 1);

    if(dest == NULL)
    {
        fprintf(stderr, ""Not enough memory\n"");
        return 1;
    }

    strcat(dest, a);
    strcat(dest, b);

    // printing concatenated string
    puts(dest);

    free(dest);

    return 0;
}
</code></pre>

<p>Or you could also use <code>snprintf</code> like this:</p>

<pre><code>int main(void)
{
    const char *a = ""3"";
    const char *b = ""2"";

    int len = snprintf(NULL, 0, ""%s%s"", a, b);

    char *dest = malloc(len + 1);

    if(dest == NULL)
    {
        fprintf(stderr, ""Not enough memory\n"");
        return 1;
    }

    sprintf(dest, ""%s%s"", a, b);

    // printing concatenated string
    puts(dest);

    free(dest);

    return 0;
}
</code></pre>

<p>This solution uses the fact that when you pass <code>NULL</code> and 0 as the first
parameters of <code>snprintf</code>, this function will return the number of characters that the
resulting string would need, thus you can use that function to determine the
total length of the concatenated string. This solution is great when you want to
concatenate different types, like for example concatenating strings with numbers.</p>

<p>In general there are many ways to concatenate strings, which one you take
depends on your needs: how you read the data, what you want to do with the
concatenation, whether you are using string literals, etc.</p>
",1
54480692,54477461,1,"<blockquote>
  <p>The problem is that the ""scanf"" inside the if statement takes two input instead of one</p>
</blockquote>

<p>No.  The upper code has a set of 3 <code>scanf()</code> and another 4th <code>scanf()</code>.  It is the 4th one that causes the ""takes two input instead of one"".</p>

<p>The 3 <code>scanf()</code> idea has merit, even if it is unusual, to  read a <code>unsigned short</code>.  </p>

<p>To fix code and still employ the idea:</p>

<pre><code>int diceNumber(void) {
  unsigned short dice;
  for (;;) {
    printf(""\nInput the number of dice to roll: "");
    fflush(stdout); // insure output is seen 
    int count = scanf(""%hu"", &amp;dice);
    if (count == 1) {
      if (dice &lt;= 0) puts(""YOU MUST USE A DICE AT LEAST!"");
      else break;
    } else if (count == EOF) {  // This case omitted in original code.
      return EOF;  
    }
    scanf(""%*[^\n]"");  // consume almost all of rest of line
    scanf(""%*c"");      // consume rest of line (expected \n)
    puts("""");
    puts(""WRONG INPUT!"");
    // if(dice &lt;= 0) not possible for unsigned short
  }
  return (int) dice;  
}
</code></pre>
",1
49098302,49097814,2,"<p>The <code>__FILE__</code> macro expands to a <code>const char*</code> containing the name of the current source file. The <code>__LINE__</code> macro expands to an <code>int</code> that is the line number in the current file where the macro is located. So, the declaration of your new function would have to look like this:</p>

<pre><code>void *_memcheck_malloc(size_t size, const char *file, int line);
</code></pre>

<p>When you define a macro to change all calls to <code>malloc</code> to instead call <code>_memcheck_malloc</code>, you have to define the additional parameters that the macro will automatically supply to the different function, because any existing call to <code>malloc</code> won't include them. You want this</p>

<pre><code>32    int *p = malloc(4 * sizeof(int));
</code></pre>

<p>to be changed into this:</p>

<pre><code>32    int *p = _memcheck_malloc(4 * sizeof(int), ""filename.c"", 32);
</code></pre>

<p>So, your macro definition looks like this:</p>

<pre><code>#define malloc(X) _memcheck_malloc((X), __FILE__, __LINE__)
</code></pre>

<p>The <code>X</code> argument is replaced with whatever exists in the original text; this is simple pattern-matching, so everything within the parentheses in the original text is replaced with everything within the parentheses in the macro invocation. The parentheses around the <code>X</code> argument (in the replacement text) are to make sure that whatever expression is supplied to the macro is evaluated as a <em>single value</em>.</p>

<p>The <code>free()</code>, <code>calloc()</code>, and <code>realloc()</code> macros would follow this pattern.</p>

<p><strong>CAVEAT</strong> Macros can be just as tricky as hell, and in the main, should be avoided if possible. This situation is one of the few <em>widely accepted</em> uses of macro substitution. Don't be sucked into the idea that ""Wow, macros are cool -- I can do all kinds of things with this!"" You can, and if you do, you will almost invariably come to regret it.</p>
",1
55715008,55714878,2,"<p>In case of such simple macro definition - just a constant - there's no real need to enclose that <code>8</code> into <code>()</code>. This pair of <code>()</code> might prevent some abuse, but the examples would be contrived and unrealistic.</p>

<p>But once operators get involved, i.e. the substituted text is intended to be an <em>expression</em>, adding those <code>()</code> becomes significantly more important. For example, if you have a sequence of related manifest constant definitions that involve <em>negative</em> values as well, adding those <code>()</code> to substitutions that use unary <code>-</code> is a very good idea</p>

<pre><code>#define CONSTANT_A 2
#define CONSTANT_B 1
#define CONSTANT_C 0
#define CONSTANT_D (-1)
</code></pre>

<p>In this case, just for the sake of consistency it might make sense to enclose all of them into <code>()</code>. It is a matter of personal taste.</p>
",0
51130401,51130124,5,"<p><code>int a = ""Hi"";</code> is not valid C code and speculating about what it might do on a non-standard compiler isn't very meaningful.</p>

<p>The code is a constraint violation of the rules of simple assignment 6.5.16.1. You cannot assign a <code>char*</code> to an <code>int</code> implicitly, without a cast.</p>

<p>(If you want to block invalid C code from compiling on the gcc compiler, use <code>-std=c11 -pedantic-errors</code>.)</p>
",7
53903987,53903959,2,"<p><code>fread</code> reads binary objects, but your file is text. You need to read text and then parse that (such as with <code>fscanf</code>, or <code>fgets</code> followed by <code>sscanf</code>).</p>
",3
48687373,48687315,9,"<p>Well, it is ""working"" but the compiler thinks you're missing something since you ignore the return value so it's giving you a warning. Not an error, although you're using <code>-Werror</code> so it will consider the warning an error and fail.</p>

<p>There are two solutions:</p>

<ol>
<li>Add code that checks the return value, and handles any errors; OR</li>
<li>Cast the call to <code>(void)</code>, thereby explicitly saying ""this return value is here but I'm not using it"".</li>
</ol>

<p>Since I/O is brittle and can fail, the first is of course generally the best approach. </p>
",8
48774891,48774550,2,"<p>For my part, I'd create a lookup table:</p>

<pre><code>static char sendcodes[256][5]; // declared outside of any function;
                               // ""static"" means it's only visible
                               // within the current source file

void init_sendcodes( void )
{
  for ( unsigned char c = 'a'; c &lt;= 'z'; c++ )
    sprintf( sendcodes[c], ""%02hhx"", c - 'a' + 4 );
}

char *mapSendcode( char c )
{
  return sendcodes[c];
}
</code></pre>

<p>Note that this code assumes an encoding where <code>'a'</code> through <code>'z'</code> are contiguous (ASCII or UTF-8). If they're not, well, you'll have to use multiple loops.  </p>

<p>When you're done, <code>sendcode['a']</code> contains the string <code>""0x04""</code>, <code>sendcode['b']</code> contains <code>""0x05""</code>, etc.  So while it takes some work to initialize the table, you only have to do that once at the beginning of the program - after that it's just an array lookup.  </p>
",1
53866055,53861209,-1,"<p>Your array type is needlessly obfuscated. What you should do is to create a table where the letters save as the index. </p>

<p>For this to be possible, you need to ensure that your system uses a sane symbol table. This is the case for all mainstream systems (ASCII, UTF8 etc). If you worry about obsolete crap like EBCDIC, you can add this to the code: <code>_Static_assert('Z'-'A' == 25, ""Dysfunctional symbol tables not supported"");</code></p>

<p>Once it is established that <code>'A'</code> to <code>'Z'</code> are adjacent, you can simply do this:</p>

<pre><code>#define TABLE_SIZE ('Z'-'A' + 1)
#define INDEX(ch) (ch-'A')        // convert from ASCII to a number 0 to 25

const char* MORSE [TABLE_SIZE] =
{
  [INDEX('A')] = "".-"",
  [INDEX('B')] = ""-..."",
  ...
};
</code></pre>

<p>The above is the same as writing <code>const char* MORSE [TABLE_SIZE] = { "".-"", ... }</code>, but the <em>designated initializers</em> couple each letter to a Morse code. <code>INDEX('A')</code> evaluates to <code>0</code>, since we want the first string pointed at from index zero in the array.</p>

<p>Then decode like this:</p>

<pre><code>const char str[] = ""HELLO"";
for(size_t i=0; i&lt;strlen(str); i++)
{
  printf(""%s\t"", MORSE[ INDEX(str[i]) ] );
}
</code></pre>

<p>This only supports capital letters and no spaces, but you get the idea.</p>
",3
53861276,53861209,1,"<p>My guess is that the problem is with using <code>strcmp</code> function to compare single characters (for example, <code>strcmp(letter,node-&gt;letter)</code>).</p>

<p>This function (<code>strcmp</code>) compares null-terminated C strings, so in your case when you try to compare letter ""B"" it will actually compare string ""BA"".</p>

<p>You can compare characters with <code>==</code> operator like this:
<code>
if(letter == node-&gt;letter)
</code></p>

<p>But of course, without complete code snippet it is hard to tell.</p>
",2
48357636,48357577,3,"<p>C doesn't have <a href=""https://en.wikipedia.org/wiki/Type_introspection"" rel=""nofollow noreferrer""><em>introspection</em></a>. It's not possible, during runtime, to get or call a function from a string.</p>

<p>There are workarounds though. For example you can create a table containing the name of the function and a pointer to the function. Then you can search this table to find the function to call.</p>

<p>Perhaps something like</p>

<pre><code>void functionOne(int arg1, int arg2)
{
    ...
}

struct
{
    char *name;
    void (*function)(int, int);
} functions[] = {
    { ""funcitonOne"", &amp;functionOne },
};
</code></pre>

<p>To make it more generic, when you have many functions taking different amount of arguments, it's a little harder. Then you could instead of passing arguments like normal, pass an array containing the arguments:</p>

<pre><code>void functionOne(int *arguments)
{
    // arguments[0] is the first arguments, etc.
    ...
}
</code></pre>

<p>Modify the function pointer in the structure accordingly.</p>

<p>If the types of arguments differ as well, then you could use structures with a type-tag and a union for the values.</p>
",0
48358134,48357577,1,"<p>In general, <strong>you cannot do what you want in <em>portable</em> C11</strong> (read <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">n1570</a>), as explained by others: <strong>function names are a <em>compile-time</em> thing</strong> and are unknown at execution time. The C programming language doesn't have <a href=""https://en.wikipedia.org/wiki/Reflection_(computer_programming)"" rel=""nofollow noreferrer"">reflection</a> and/or <a href=""https://en.wikipedia.org/wiki/Type_introspection"" rel=""nofollow noreferrer"">introspection</a>. BTW, a function might even ""disappear"" during <a href=""https://en.wikipedia.org/wiki/Optimizing_compiler"" rel=""nofollow noreferrer"">optimized compilation</a> (so don't ""practically"" exist at runtime, but your program behaves <a href=""https://en.wikipedia.org/wiki/As-if_rule"" rel=""nofollow noreferrer"">as-if</a> that function exists), in the sense that it has been <a href=""https://en.wikipedia.org/wiki/Inline_expansion"" rel=""nofollow noreferrer"">inlined</a> or removed from the <a href=""https://en.wikipedia.org/wiki/Executable"" rel=""nofollow noreferrer"">executable</a>. However, C has <a href=""https://en.wikipedia.org/wiki/Function_pointer"" rel=""nofollow noreferrer"">function pointers</a> (whose type describes the signature of the indirectly called function); practically speaking, they point to <a href=""https://en.wikipedia.org/wiki/Machine_code"" rel=""nofollow noreferrer"">machine code</a>.</p>

<hr>

<p>But if you code an application program on an <a href=""https://en.wikipedia.org/wiki/X86-64"" rel=""nofollow noreferrer"">x86-64</a> computer running e.g. Linux, you might <em>sometimes</em> have some workarounds, using some ""dirty"" tricks, specific to that <a href=""https://en.wikipedia.org/wiki/Operating_system"" rel=""nofollow noreferrer"">operating system</a> and <a href=""https://en.wikipedia.org/wiki/Instruction_set_architecture"" rel=""nofollow noreferrer"">instruction set architecture</a>:</p>

<ul>
<li><p>given some <em>string</em> like <code>""functionOne""</code> (practically, of type <code>const char*</code>), you could get a function pointer to it (e.g. the <code>functionOne</code>, provided it has extern <a href=""https://en.wikipedia.org/wiki/Linkage_(software)"" rel=""nofollow noreferrer"">linkage</a>) -thru dynamic linking facilities- using <a href=""http://man7.org/linux/man-pages/man3/dlopen.3.html"" rel=""nofollow noreferrer"">dlopen(3)</a> with a <code>NULL</code> path, then <a href=""http://man7.org/linux/man-pages/man3/dlsym.3.html"" rel=""nofollow noreferrer"">dlsym(3)</a>. BTW the reverse mapping (from addresses to names) is available thru <a href=""http://man7.org/linux/man-pages/man3/dladdr.3.html"" rel=""nofollow noreferrer"">dladdr(3)</a>.</p></li>
<li><p>given a <a href=""https://en.wikipedia.org/wiki/Function_pointer"" rel=""nofollow noreferrer"">function pointer</a> (or actually any <em>valid</em> address in your <a href=""https://en.wikipedia.org/wiki/Virtual_address_space"" rel=""nofollow noreferrer"">virtual address space</a> pointing inside some <em>executable</em> <a href=""https://en.wikipedia.org/wiki/Code_segment"" rel=""nofollow noreferrer"">code segment</a>), you could call it indirectly if the signature of that function is known at compile time (it is given in the type of that function pointer).</p></li>
<li><p>if you want to call an arbitrary function with <em>arbitrary</em> signature and arbitrary arguments only known at <em>run-time</em>, you might use the <a href=""https://sourceware.org/libffi/"" rel=""nofollow noreferrer"">libffi</a>. It knows the <a href=""https://en.wikipedia.org/wiki/Application_binary_interface"" rel=""nofollow noreferrer"">ABI</a> of your system.</p></li>
<li><p>a possible trick is also to emit some temporary file <code>/tmp/emittedcode.c</code> containing C code (at runtime), fork a compilation process into a temporary plugin (e.g. <code>gcc -Wall -O -shared -fPIC/tmp/emittedcode.c -o /tmp/emittedplugin.so</code>), and <a href=""https://en.wikipedia.org/wiki/Dynamic_loading"" rel=""nofollow noreferrer"">dynamically load</a> that temporary plugin <code>/tmp/emittedplugin.so</code> with <a href=""http://man7.org/linux/man-pages/man3/dlopen.3.html"" rel=""nofollow noreferrer"">dlopen(3)</a>. Be sure to clean the mess (e.g. remove all temporary files, perhaps using <a href=""http://man7.org/linux/man-pages/man3/atexit.3.html"" rel=""nofollow noreferrer"">atexit(3)</a>) at program termination.</p></li>
<li><p>perhaps you want to generate some machine code at runtime; then consider also some <a href=""https://en.wikipedia.org/wiki/Just-in-time_compilation"" rel=""nofollow noreferrer"">JIT compiling</a> library such as <a href=""https://gcc.gnu.org/onlinedocs/jit/"" rel=""nofollow noreferrer"">GCCJIT</a>, <a href=""http://llvm.org/"" rel=""nofollow noreferrer"">LLVM</a>, <a href=""https://www.gnu.org/software/libjit/"" rel=""nofollow noreferrer"">libjit</a>, <a href=""https://github.com/asmjit/asmjit"" rel=""nofollow noreferrer"">asmjit</a>.</p></li>
</ul>

<p>If your PC is not running Linux, you might find equivalent stuff for your OS and computer. Read <a href=""http://pages.cs.wisc.edu/~remzi/OSTEP/"" rel=""nofollow noreferrer""><em>Operating Systems: Three Easy Pieces</em></a> to learn more about OSes in general. Read the documentation of your particular OS (for Linux, read first the <a href=""http://www.cse.hcmut.edu.vn/~hungnq/courses/nap/alp.pdf"" rel=""nofollow noreferrer"">ALP</a> or some newer book on Linux programming, then <a href=""http://man7.org/linux/man-pages/man2/intro.2.html"" rel=""nofollow noreferrer"">intro(2)</a>, <a href=""http://man7.org/linux/man-pages/man2/syscalls.2.html"" rel=""nofollow noreferrer"">syscalls(2)</a>, <a href=""http://man7.org/linux/man-pages/man5/elf.5.html"" rel=""nofollow noreferrer"">elf(5)</a> and related pages).</p>

<hr>

<p>BTW, if you just want to call functions from your program (from names in some input file), you might instead build at initialization some <a href=""https://en.wikipedia.org/wiki/Hash_table"" rel=""nofollow noreferrer"">hash table</a> (or <a href=""https://en.wikipedia.org/wiki/Associative_array"" rel=""nofollow noreferrer"">map</a>, perhaps a <a href=""https://en.wikipedia.org/wiki/Red%E2%80%93black_tree"" rel=""nofollow noreferrer"">red-black tree</a>) associating function names to function pointers, like suggested in <a href=""https://stackoverflow.com/a/48357636/841108"">this</a> other answer.</p>

<p>Maybe you want some <a href=""https://en.wikipedia.org/wiki/Homoiconicity"" rel=""nofollow noreferrer"">homoiconic</a> programming language having some <a href=""https://en.wikipedia.org/wiki/Eval"" rel=""nofollow noreferrer""><code>eval</code> primitive</a>. Look into Common Lisp. Be aware of <a href=""http://sbcl.org/"" rel=""nofollow noreferrer"">SBCL</a>, it is compiling into dynamically generated machine code at most <a href=""https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop"" rel=""nofollow noreferrer"">REPL</a> interactions.</p>

<p>Maybe you are writing some <a href=""https://en.wikipedia.org/wiki/Interpreter_(computing)"" rel=""nofollow noreferrer"">interpreter</a> (that is often more difficult and time consuming than you think, read the <a href=""https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools"" rel=""nofollow noreferrer"">Dragon Book</a>). Consider perhaps embedding and using an existing one, such as <a href=""https://www.gnu.org/software/guile/"" rel=""nofollow noreferrer"">Guile</a> or <a href=""http://lua.org/"" rel=""nofollow noreferrer"">Lua</a>.</p>
",0
55212663,55212649,4,"<p>This is the syntax for a function pointer type.</p>

<p>Taking the first example:</p>

<pre><code>CONF *(*create) (CONF_METHOD *meth);
</code></pre>

<p>It defines a struct member named <code>create</code> which points to a function receiving a single parameter of type <code>CONF_METHOD*</code> and returning a value of type <code>CONF*</code></p>

<p>So, for example, if you had a function:</p>

<pre><code>CONF *my_create(CONF_METHOD* meth)
{
   //...
}
</code></pre>

<p>Then you could store a pointer to that function in your struct:</p>

<pre><code>struct conf_method_st c;
c.create = my_create;
</code></pre>

<p>And you can invoke it just like a function:</p>

<pre><code>CONF *conf = c.create(meth);
</code></pre>
",0
48236793,48236767,0,"<p>Replace <code>int</code> with <code>int64_t</code> to use 64 bits instead of 32.</p>
",2
48354779,48354620,2,"<p>For objects defined inside a function without <code>static</code>, there is no default value. Their initial value is indeterminate, and, generally, the behavior of using one without setting the value is undefined.</p>
",0
52126628,52126001,2,"<p>A character point with an addition lead to a character point.</p>

<p><code>printf</code> is just a function</p>

<p>So it takes a variety of parameter - varags</p>

<ol>
<li><p>""%d""+1 Will be a string just <code>d</code>n it</p></li>
<li><p>""%d""+2 - will be the null byte - nothing</p></li>
<li><p>""%d""+0 - Will be %d - hence expected output - see the manual page</p></li>
</ol>
",0
51132074,51132026,3,"<p>because it changes the value of <code>n</code>. Since the value is used to compute the expression <code>n * fact(...)</code>, the value of <code>n</code> must be read <em>after</em> the <code>fact</code> is evaluated. Since <code>--n</code> (or <code>n--</code>, it does not matter here) must be passed as value to <code>fact</code>, the decrement must occur <em>before</em> the <code>fact</code> is invoked. Therefore the expression result will be incorrect.</p>
",6
48918190,48917111,0,"<p>Please pay attention to the compiler warnings. It will discover problems for you. Suggestion for improvements in the program comments:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
//#include &lt;iostream&gt; // C++ include, not needed!

void create();

int main()
{
    int choice; // changed to int to match scanf(""%d"", char is to small to hold an `int`

    printf(""\n\t\t **********************\n\n"");
    printf(""\n\t\t Train Booking Application\n"");
    printf(""\n\t\t **********************\n\n"");
    printf(""Select 1 to create a booking,\tSelect 2 to Edit booking,\tSelect 3 to Delete a booking\n"");

    scanf(""%d"", &amp;choice);

     switch (choice){        // switch is a better choice than nested ifs
         case 1:
             create();
         break;

         default:
         printf(""not implemented yet...\n"");
         break;
     }

    return 0;   
}

void create(){
    char Fname[256],Sname[256];  // changed to arrays to match scanf (""%s""
    // char Fname, Sname with %s would destroy memory 
    printf(""Please enter your First name:\n"");
    scanf (""%s"",Fname);
    printf(""Please enter your Second name:\n"");
    scanf (""%s"",Sname);
}
</code></pre>
",0
59324908,59324851,3,"<p>If you're interested in reading and writing a full line at a time, use <code>fgets</code> instead:</p>

<pre><code>char buffer[1024]
while(fgets(buffer, sizeof(buffer), stdin)) {
      fputs(buffer, stdout);
}
</code></pre>
",5
48133309,48133294,0,"<p>strcmp returns 0 if the strings are the same. ""man strcmp""</p>
",0
48133314,48133294,1,"<p><code>strcmp</code> returns <code>0</code> if the strings compare equivalently.</p>

<p>Try negating your if statement, or checking for <code>0</code> explicitly.</p>

<pre><code>if (!strcmp(...))
if (strcmp(...) == 0)
</code></pre>

<p><a href=""http://en.cppreference.com/w/c/string/byte/strcmp"" rel=""nofollow noreferrer""><strong>strcmp</strong> Reference</a></p>

<blockquote>
  <p><strong>Return value</strong></p>
  
  <ul>
  <li>Negative value if lhs appears before rhs in lexicographical order. </li>
  <li>Zero if lhs and rhs compare equal. </li>
  <li>Positive value if lhs appears after rhs in lexicographical order.</li>
  </ul>
</blockquote>
",0
48133323,48133294,0,"<p><code>strcmp</code> returns 0 when both strings are equal.</p>

<p>It should be</p>

<pre><code>if (strcmp(inputUnit, ""in"") == 0) {
    returnValue = inputValue * 2.54;
    printf(""%.2f %s = %.4f cm\n"", inputValue, inputUnit, returnValue);
}
</code></pre>

<p>See</p>

<blockquote>
  <p><em>man strcmp</em></p>

<pre><code>#include &lt;string.h&gt;

int strcmp(const char *s1, const char *s2);
</code></pre>
  
  <p><strong>DESCRIPTION</strong></p>
  
  <p>The  <code>strcmp()</code>  function  compares  the two strings <code>s1</code> and <code>s2</code>.
  <strong>It returns an integer less than, equal to, or greater than zero if <code>s1</code> is
  found, respectively, to be less than, to match, or be greater than <code>s2</code></strong>.</p>
</blockquote>
",0
48133308,48133294,0,"<p>The <code>strcmp</code> function returns 0 if he strings match.  So you need to check if the function returns 0.</p>

<pre><code>if (strcmp(inputUnit, ""in"") == 0) {
</code></pre>
",0
48361444,48361429,4,"<p><code>name</code> is an array of characters, but the first argument to <code>SetPerson</code> is a single character. Change <code>SetPerson</code> to</p>

<pre><code>void SetPerson(char* a, int b) {
    printf(""Name: %s\n"", a);
    printf(""Number: %d"", b);
}
</code></pre>

<p>Note that in C, arrays and pointers are basically interchangeable.</p>

<p><strong>Edit</strong> (after question was modified)</p>

<p>You're basically doing the same thing in reverse with the number. You have an array of ints (basically <code>int*</code> which you're passing to a <code>int</code> argument.</p>

<p>Drop the array portion of the declaration for <code>number</code>; you're not telling the compiler to allocate a 6-digit (in base 10) number, you're telling it to allocate 6 32-bit (probably; <code>int</code> is generally 32-bit these days, but may not be) numbers.</p>

<p>Then you'll need to change the arguments to scanf to pass a <em>pointer</em> to <code>number</code> instead of the actual number; use the address-of operator (<code>&amp;</code>) for that:</p>

<pre><code>scanf(""%d"", &amp;number);
</code></pre>
",3
48193737,48193547,2,"<p>Your code has many small mistakes:</p>

<ul>
<li><code>scanf(""%s"", &amp;b[i].name);</code> does not need <code>&amp;</code></li>
<li><code>num=0;</code> is not necessary; remove it</li>
<li>Nested loop condition should use <code>j &lt; b[i].numb</code> as its condition</li>
<li>Nested loop is not using <code>j</code>. It needs to add <code>[j]</code> to both <code>obj</code> and <code>price</code>.</li>
</ul>

<p>Once you fix these problems, your code runs as expected as long as the input is correct (<a href=""https://ideone.com/fW6QrJ"" rel=""nofollow noreferrer"">demo</a>).</p>

<p>However, this is not enough to make your code robust: you need to add error checking to ensure that invalid input does not cause undefined behavior:</p>

<ul>
<li>Add limits to string format specifiers in <code>scanf</code> to avoid buffer overflows (e.g. <code>%49s</code> to read <code>name[50]</code>),</li>
<li>Add a limit to the outer loop in case <code>m</code> is above 50,</li>
<li>Add a limit to the nested loop in case <code>b[i].numb</code> is above 10,</li>
<li>Add checks of return values for <code>scanf</code>.</li>
</ul>
",1
48999787,48999398,0,"<p>Your problem is that <code>int write_grade_message();</code> is a function that can take
any number of parameters but you won't see them inside <code>write_grade_message</code>.</p>

<p>You have to declare it like this:</p>

<pre><code>int write_grade_message(int average)
{
    // your code
    if (average &lt; 60){
        printf(""Failed semester - registration suspended"");
    }
    else if(average &lt; 69){
        printf(""On probation for next semester"");
    }
    else if(average &lt; 79){
        printf("""");
    }
    else if(average &lt; 89){
        printf(""Dean's list for the semester"");
    }
    else if(average &lt; 100){
        printf(""Highest honors for the semester"");
    }

    return(0);
}
</code></pre>

<p>Also note that in <code>compute_grade_avg</code> the variables <code>average</code>, <code>sum</code> and <code>size</code>
are of type <code>int</code>. Division with <code>int</code>s returns you always an <code>int</code>, so <code>ceil</code>
won't round up the number. You would need to use floating points for that.
However you have to change the type of the
function to return <code>float</code> and <code>result</code> and <code>average</code> must be <code>float</code>s too.</p>

<pre><code>float compute_grade_avg(int grades[], int size)
{
    float result, average;

    ...

    average = ((float) sum)/size;
    result = ceil(average);

    return result;
}
</code></pre>
",0
48239286,48239170,1,"<p>The phrasing in the question is in error. You cannot omit the types in a <em>function prototype</em>. If you omit the types in function definition, declaration, it doesn't <strong>have a prototype</strong>. Only the declaration, definition that contains function types (be it just <code>void</code>) has <strong>a prototype</strong>.</p>

<hr>

<p>When you do omit the types in a function definition, you get the old style* <em>declaration-list</em>. You must specify types for the parameters <em>before</em> the function body, <a href=""https://stackoverflow.com/questions/33816001/weird-c-function-declaration"">an example of which can be seen here</a>. The caller cannot know how to call this correctly, and the compiler cannot check. Scalar types are subject to <em>default argument promotions</em>, just like the variable-argument part of the prototyped functions.</p>

<hr>

<p>As for the code in your question, it is <em>not</em> standards-compliant - in fact, there are 2 grave errors:</p>

<pre><code>float addf(a,b); // even without a,b it runs
</code></pre>

<p>Is an incorrect declaration, that is not allowed by C - you must write</p>

<pre><code>float addf();  // empty parentheses
</code></pre>

<p>and b, the actual parameters must be of type <strong>double</strong>, because the default argument promotions will convert them.</p>
",0
52232341,52232318,0,"<p>You need to ""dereference"" your <code>int*</code> (pointer) to get an <code>int</code>.</p>
",0
52232360,52232318,2,"<p>You don't want to print the pointer itself (<code>totalMiles</code>), you want to print what it points to (<code>*totalMiles</code>).</p>

<pre><code>printf(""Total miles saved: %d\n"", *totalMiles);
</code></pre>
",0
49465655,49465454,1,"<p>this statement only reserves memory space. Since <code>n</code> is not defined at the compile time, the content of the array contains trash values.</p>

<pre><code>  tree t[n];
</code></pre>

<p>any access to <code>t[i]</code> will cause your program to access a memory location, denoted by the value which exists in <code>t[i]</code>, most likely an address of invalid memory location. This causes your crash. In other cases it could cause memory corruption in unrelated parts of the program and produce incorrect results or crash again.</p>

<p>you need to initialize your array elements before accessing it by allocating the node.</p>

<pre><code>for(i=0;i&lt;n;i++){
    scanf(""%d"",&amp;x);
    t[i] = malloc(sizeof(tnode)); // this was missing.
    t[i]-&gt;s=x;
    t[i]-&gt;next=NULL;
    t[i]-&gt;know=false;
}
</code></pre>
",4
54359733,54357679,0,"<p>It looks like you could use two iterators (a head and tail) and work on each ""word"" in place, one at a time.</p>

<p>Your sort order ""should be"" a case-insensitive sort, and you seem to have some code subtracting 'a' from each character to rebase/offset the value into your array. However, I don't see any code that converts upper-case characters to their lower-case equivalents (which is only necessary for sorting, based on your requirement, you should still be outputting the original upper-case character input.)</p>

<p>I am not seeing a reason to store a count of any characters in the string, possibly that could be removed, or clarified.</p>

<p><strong>Welcome to stack overflow.</strong> One way to get improved responses and help with your questions is to include some details about what you are trying to do, and not just your code. If you <em>must</em> include code to convey your problem, consider breaking it down into separate chunks. Not only will this help us understand if you have more than one question (and boy will the community let you know!) but it will also help you understand how to simplify your questions to get better help and faster :) as this is written it may belong on <a href=""https://codereview.stackexchange.com/"">https://codereview.stackexchange.com/</a> site instead. It probably is not good Q&amp;A for StackOverflow, again, as-is.</p>

<p>HTH!</p>
",0
52782538,52782107,2,"<p>Complement to Antti Haapala's answer:</p>

<p>While it is totally up to the compiler how and where to store variables, the memory layout of variables declared consecutively is often in the same order than the order of declaration especially in non optimized code.</p>

<p>So the variables declared like this:</p>

<pre><code>int8_t a = 0x65;
char b = 'k';
uint16_t c = 22222;
</code></pre>

<p><em>could</em> be stored like this:</p>

<pre><code>Address  Content in binary
--------------------------
0000:    01010101  (0x64)
0001:    01101011  ('k' = 107, ASCII code of k)
0002:    11001110  (low bits of 22222)
0003:    01010110  (high bits of 22222)
</code></pre>

<p>where <code>Address</code> is the relative address with repsect to the memory address of variable <code>a</code>.</p>

<p>Once again: don't assume that this is the necessarily the case on your platform.</p>
",2
52782184,52782107,10,"<blockquote>
  <p>I have a problem I can't seem to figure it out. I hope someone could be able to throughly explain it to me. I get that its very elementary.</p>
</blockquote>

<p>And here you go wrong. It <em>is</em> very elementary but not quite as you think it to be</p>

<ul>
<li><p>Distinct variables need not be stored in consecutive locations in memory. (Or as the last bullet says, not be stored in memory at all)</p></li>
<li><p>The storage of individual bytes within a multibyte value is <em>implementation-defined</em> - check your compiler manuals. Most personal computing processors nowadays use little-endian 2's complement for integers, however.</p></li>
<li><p>Even if they <em>were</em> organized by the compiler to appear in memory in exactly the same order as they are declared, each datatype can require an implementation-specific alignment and can therefore start only at an address that is multiple of this alignment</p></li>
<li><p>And finally, there need not be any variables or memory allocations whatsoever, the compiler just needs to generate a program that behaves <a href=""https://stackoverflow.com/questions/15718262/what-exactly-is-the-as-if-rule""><em>as if</em></a> there were such variables.</p></li>
</ul>

<hr>

<p>We can <em>certainly</em> say something about your program however. If the excerpt</p>

<pre><code>#include &lt;stdint.h&gt;

int8_t a = 0x65;
char b = 'k';
uint16_t c = 22222;
</code></pre>

<p>compiles <em>and</em> the variables are placed in memory, then </p>

<ul>
<li><code>a</code> will be 8 bits with value <code>0b01100101</code></li>
<li><code>c</code> will be 16 bits and stored in memory as <em>2</em> bytes - <code>0b11001110</code> and <code>0b01010110</code> at increasing memory addresses (little-endian, usual), or the same 2 bytes reversed: <code>0b01010110</code> and <code>0b11001110</code> (big-endian).</li>
<li>As for <code>b</code>, <em>if</em> the <em>execution character set</em> is ASCII-compatible, as <code>int8_t</code> exists, then <code>char</code> must also be 8 bits wide, then its value will be stored as <code>0b01101011</code> (i.e. 107, the ASCII code of <code>k</code>).</li>
</ul>

<p>Additionally, most often the alignment requirement of an <code>uint16_t</code> object is 2; if that is the case, it must start at an even address.</p>

<p>This deduction is only possible because the <code>int8_t</code> and <code>uint16_t</code> <em>must not have padding bits</em>, hence from having them we can deduce that the width of the smallest addressable unit (<code>char</code>) must be 8 bits too. And <code>uint16_t</code> has only 2 bytes, hence it can only have two choices for endianness.</p>

<hr>

<p>It is easy to test how GCC organizes <em>global variables</em>. Consider the module having the source code</p>

<pre><code>#include &lt;stdint.h&gt;
int8_t a = 0x65;
char b = 'k';
uint16_t c = 22222;
</code></pre>

<p>we can compile it to an object file:</p>

<pre><code>% gcc -c layouttest.c -o layouttest.o
</code></pre>

<p>and then use <code>nm</code> to list the symbols and their addresses:</p>

<pre><code>% nm layouttest.o            
0000000000000000 D a
0000000000000001 D b
0000000000000002 D c
</code></pre>

<p>It seems to be as Jabberwocky's answer expects. If we now compile with <code>-O3</code>, the results can be different:</p>

<pre><code>% gcc -c layouttest.c -o layouttest.o -O3; nm layouttest.o
0000000000000003 D a
0000000000000002 D b
0000000000000000 D c
</code></pre>

<p>I.e. the variables were reorganized, with <code>c</code> at the bottom.</p>
",4
49041333,49040515,0,"<blockquote>
  <p>it is only printing 1</p>
</blockquote>

<pre><code>int longitud_string(char *s){
int i;
i=0;                   // Set i = 0
while(*s != '\0')
    s = s + 1;
i++;                   // Set i = 1
return i;              // return i (1)
}
</code></pre>

<p>What you may have wanted is:</p>

<pre><code>int longitud_string(char *s)
{
    int i = 0;
    while(*s != '\0')
    {                 // Need brace here
        s = s + 1;
        i++;          //            Increment both in the loop

    }                 // Close brace here.
    return i;
}
</code></pre>

<p>But we could simplify it like this:</p>

<pre><code>int longitud_string(char *s)
{
    int i = 0;
    while(s[i] != '\0') {
        i++;
    }
    return i;
}
</code></pre>
",0
48448354,48442694,0,"<p>The extra zero is coming from here:</p>

<pre><code>while(o&lt;=i)
</code></pre>

<p><code>i</code> is the number of digits.  Since <code>o</code> starts at 0 it ranges from 0 to <code>i</code>, so you go through the loop one extra time.  At that point, <code>c</code> is 0, so that's what gets printed.</p>

<p>You can fix this by changing your condition:</p>

<pre><code>while(o&lt;i)
</code></pre>

<p>There is another issue, however.  This program prints the words in the reverse order.  You can fix this by saving the digits in an array, then looping backward through that array to print the digits.</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int i=0,a,p;
    int digits[25];  // enough for a 64-bit number
    // list of digits names that can be indexed easily
    char *numberStr[] = { "" zero "", "" one "", "" two "", "" three "", "" four "", 
                          "" five "", "" six "", "" seven "", "" eight "", "" nine "" };

    printf(""enter the number you want "");

    scanf(""%d"",&amp;a);

    while(a !=0)
    {
        // save each digit in the array
        digits[i] = a%10;
        a=a/10;
        i++;
    }
    i--;   // back off i to contain the index of the highest order digit

    // loop through the array in reverse
    while(i&gt;=0)
    {
        p=digits[i];
        printf(""%s"", numberStr[i]);
        i--;
    }

    return 0;
}
</code></pre>
",1
48488009,48487847,1,"<blockquote>
  <p>int addnum(int *ptr); // what happened here ?</p>
</blockquote>

<p>It is so called <code>forward declaration</code> allowing compiler to know that such function will be defined later.</p>

<p>In C it is possible (although unwise) to implement a pair of mutually recursive functions thus:</p>

<pre><code>int first(int x) {
        if (x == 0)
            return 1;
        else
            return second(x-1); // forward reference to second
}

int second(int x) {
    if (x == 0)
        return 0;
    else
        return first(x-1); // backward reference to first
}
</code></pre>
",0
48763632,48763548,3,"<p>Your code can be simplified greatly, while improving how it works.</p>

<p>The loops that <code>getchar()</code> will fail if given less input; you should just use <code>sscanf()</code> with a size-limited string conversion, or <a href=""https://linux.die.net/man/3/getline"" rel=""nofollow noreferrer""><code>getline()</code></a> if you have it.</p>

<p>You should make the alphabet a proper string:</p>

<pre><code>const char *nat = ""abcdr"";
</code></pre>

<p>and then use <a href=""https://linux.die.net/man/3/strchr"" rel=""nofollow noreferrer""><code>strchr()</code></a> to search a string for a character, passing <code>nat</code> as  the string.</p>
",1
48461432,48461232,0,"<p>you have two options (among many others i'm certain)</p>

<ul>
<li>Read individual numbers from the input (user types number, then hit enter/return); convert the string to number and if number is 1, 10 or 0, skip it and read the next number.</li>
<li>Read all the number in a string and use strtok to split the input in different numbers and convert the string to number and if number is 1, 10 or 0, skip it and read the next number.</li>
</ul>

<p>look at this : 
<a href=""https://stackoverflow.com/questions/5087062/how-to-get-int-from-stdio-in-c"">How to get int from stdio in C?</a></p>

<p>look at this (and adapt to convert each string token to int (use something like strtol):
<a href=""https://stackoverflow.com/questions/3889992/how-does-strtok-split-the-string-into-tokens-in-c"">How does strtok() split the string into tokens in C?</a></p>
",0
50544625,50544558,0,"<p><code>fscanf(""%s"", ...)</code> reads a string: all characters valid for a string are read into it, until whitespace is encountered (or the file ends). Note that <code>eti300</code> is a perfectly valid string, and as such, all of it is consumed by the first <code>fscanf</code>. This leaves no number for the second <code>fscanf</code> to start with, so it errors.</p>

<p>If you can, change the format of your data to introduce whitespace (such as a newline) between a name and the next ID number following it.</p>

<p>If that is not an option, you will have to parse the numbers out of the strings manually (such as finding the first digit and splitting the string there). This could be done via character-by-character reads from the file, or by reading the data into memory as strings and processing it there.</p>
",0
48474825,48474249,0,"<pre><code>int check_odd(unsigned int n) {
  unsigned int m = 0;
  for ( ; n ; n /= 10)
    m |= (n &amp; 1) &lt;&lt; ((n % 10) / 2);
  m = m - ((m &gt;&gt; 1) &amp; 0x55555555);
  m = (m &amp; 0x33333333) + ((m &gt;&gt; 2) &amp; 0x33333333);
  return (((m + (m &gt;&gt; 4) &amp; 0xF0F0F0F) * 0x1010101) &gt;&gt; 24) &lt; 3;
}
</code></pre>
",1
48440624,48435393,1,"<p>About comma and period:</p>

<p>You will have a comma -after the quarter- if their is dime, nickel or cent.
So instead of testing if <code>dime</code> is not <code>0</code>, <code>nickel</code> is not <code>0</code>, <code>cent</code> is not <code>0</code>, you can sum these values and test if it's <code>0</code> or not. </p>

<p>About <code>'s'</code>, you just have to know if their <code>1</code> coin or more.</p>

<p>Giving that, you can make a function that will format only one coin type. This function should be responsible of choosing to add an 's' or not, and choose between comma and period. Each choice can be made whit one <code>if/else</code> test, so you can have:</p>

<pre><code>#include &lt;stdio.h&gt;
/*
  what: name of coin
  quantity: number of coin
  rest: coins that must be displayed after
*/
void print_coin(const char *what, int quantity, int rest)
{
    /* is there something to display*/
    if (0 == quantity)
        { return; }
    /* One coin*/    
    else if (1 == quantity)
        { printf(""1 %s"", what) ;}
    /* several coins, add an 's' */
    else
       { printf(""%d %ss"", quantity, what) ;}

    /* choose between comma and period */
    if (rest &gt; 0)
        { printf("", "");}
    else 
        { printf("".\n"");}
}

/* print all coins function */
void print_coins(int quarter, int dime, int nickel)
{
    /* print each coins, one after the other */

    print_coin(""quarter"", quarter, dime + nickel);
    print_coin(""dime"", dime, nickel);
    print_coin(""nickel"", nickel, 0);
}

int main(void)
{
    /* examples */
    print_coins(1, 2, 3);
    print_coins(1, 0, 1);
    print_coins(1, 0, 0);
    return 0;
}
</code></pre>
",0
54281364,54281312,2,"<p>in <em>caricaFile</em> you save all the read titles in the same location (titolo->nome) so only the last is finaly memorized because you save all the time the same pointer (titolo) in list. </p>

<p>You need to duplicate the val when you save it in the list, rather than to just do <code>x-&gt;val = val;</code> in NEW, for instance :</p>

<pre><code>link NEW(TITOLO val, link next) {
  link x = malloc(sizeof *x);
  x-&gt;next = next;

  TITOLO copy = malloc(sizeof (struct tit));

  strcpy(copy-&gt;nome, val-&gt;nome);
  x-&gt;val = copy;
  return x;
}
</code></pre>

<p>Execution with the new definition of NEW :</p>

<pre><code>Insert title: aze
Insert title: qsd
Insert title: wxc
Insert title: iop
aze iop qsd wxc 
</code></pre>

<hr>

<p>It is a very bad idea to make typedef being pointer like TITOLO is because this put the reader in error thinking it is a value rather than a pointer</p>
",5
48199148,48199120,7,"<p>In <code>&amp;a+1</code>, <code>&amp;a</code> takes the address of the array. This yields a pointer to an array, so adding one adds the size of one array. This is because each type of pointer has its own unit of measurement¡ªadding one always adds one of the pointed-to objects.</p>

<p>In <code>a+1</code>, <code>a</code> is the array itself. C automatically converts an array to the address of the first element. So, <code>a</code> yields a pointer to an element, so adding one adds the size of one element.</p>

<p>(In <code>&amp;a+1</code>, <code>a</code> was not automatically converted to a pointer to the first element. Using <code>&amp;</code> with an array is an exception to the conversion. See note 1 below.)</p>

<h3>Notes</h3>

<ol>
<li><p>The automatic conversion of an array to a pointer to its first element occurs in most situations. It does not occur when the array is the argument of <code>sizeof</code>, <code>&amp;</code>, or <code>_Alignof</code> or when the array is a string literal used to initialize an array.</p></li>
<li><p>In C¡¯s model, a pointer uses units of whatever type of object it points to. So saying ¡°adds the size of one array¡± is a bit imprecise. However, if we are talking about navigating storage using valid pointers in an array of objects, moving from one object to another traverses a number of bytes equal to the size of the object.</p></li>
<li><p>You should not print pointers with <code>%d</code>. The behavior of that is not defined by the C standard. To print a pointer, convert it to <code>void *</code> and print with <code>%p</code>:</p>

<pre><code>printf(""%p\n"", (void *) a);
printf(""&amp;a + 1 %p\n"", (void *) (&amp;a + 1));
printf(""a + 1 %p\n"", (void *) (a + 1));
</code></pre></li>
<li><p>Note that <code>%p</code> does not necessarily produce the actual memory address. The C standard allows an implementation to produce some other representation of the pointer. In good C implementations without complicated memory models, <code>%p</code> will print the memory address of the pointed-to object. However, this is a quality-of-implementation feature.</p></li>
</ol>
",1
49217173,49217041,1,"<p>Think through the logic carefully.  You're close, but need to get closer.  This works:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        fprintf(stderr, ""Usage: forkloop &lt;iterations&gt;\n"");
        exit(1);
    }

    int iterations = strtol(argv[1], NULL, 10);
    if (iterations &lt; 1 || iterations &gt; 20)
    {
        fprintf(stderr, ""invalid iterations %d (1..20 allowed)\n"", iterations);
        exit(1);
    }
    printf(""Initial process: PID %d (parent %d)\n"", (int)getpid(), (int)getppid());
    fflush(stdout);
    int i;
    for (i = 0; i &lt; iterations; i++)
    {
        int pid = fork();
        if (pid &lt; 0)
        {
            perror(""fork"");
            exit(1);
        }
        else if (pid == 0)
        {
            /* Child - report ID */
            printf(""ppid = %d, pid = %d, i = %d\n"", getppid(), getpid(), i);
            fflush(stdout);
        }
        if (pid != 0)
        {
            /* Parent - break loop and wait for kid (and grandkid, and ...) to die */
            break;
        }
    }

    int corpse;
    int status;
    while ((corpse = wait(&amp;status)) &gt; 0)
    {
        printf(""PID %d: child %d exited with status 0x%.4X\n"",
               (int)getpid(), corpse, status);
        fflush(stdout);
    }

    return i;
}
</code></pre>

<p>(There's no guarantee that <code>pid_t</code> returned by <code>getpid()</code> et al is actually an <code>int</code>, though it is normally equivalent.  I added the casts to ensure there is no problem, though in practice you can get away without them.  The last <code>fflush()</code> is not strictly needed; the process exits which flushes the output anyway.  The earlier ones are a good idea; you could get confusing output if they were absent and the output of the program was piped to some process to capture it.  Before you <code>fork()</code>, it's a good idea to have no pending output ¡ª so <code>fflush(0)</code> aka <code>fflush(NULL)</code> is perhaps a good idea, in general, though here it isn't necessary.)</p>

<p>Sample outputs (source code <code>kids17.c</code>, program name <code>kids17</code>):</p>

<pre><code>$ gcc -O3 -g -std=c11 -Wall -Wextra -Werror -Wmissing-prototypes \
&gt;     -Wstrict-prototypes kids17.c -o kids17 
$ kids17
Usage: forkloop &lt;iterations&gt;
$ kids17 4
Initial process: PID 2686 (parent 888)
ppid = 2686, pid = 2687, i = 0
ppid = 2687, pid = 2688, i = 1
ppid = 2688, pid = 2689, i = 2
ppid = 2689, pid = 2690, i = 3
PID 2689: child 2690 exited with status 0x0400
PID 2688: child 2689 exited with status 0x0300
PID 2687: child 2688 exited with status 0x0200
PID 2686: child 2687 exited with status 0x0100
$ ¡­some work done¡­
$ kids17 10
Initial process: PID 2704 (parent 888)
ppid = 2704, pid = 2705, i = 0
ppid = 2705, pid = 2706, i = 1
ppid = 2706, pid = 2707, i = 2
ppid = 2707, pid = 2708, i = 3
ppid = 2708, pid = 2709, i = 4
ppid = 2709, pid = 2710, i = 5
ppid = 2710, pid = 2711, i = 6
ppid = 2711, pid = 2712, i = 7
ppid = 2712, pid = 2713, i = 8
ppid = 2713, pid = 2714, i = 9
PID 2713: child 2714 exited with status 0x0A00
PID 2712: child 2713 exited with status 0x0900
PID 2711: child 2712 exited with status 0x0800
PID 2710: child 2711 exited with status 0x0700
PID 2709: child 2710 exited with status 0x0600
PID 2708: child 2709 exited with status 0x0500
PID 2707: child 2708 exited with status 0x0400
PID 2706: child 2707 exited with status 0x0300
PID 2705: child 2706 exited with status 0x0200
PID 2704: child 2705 exited with status 0x0100
$
</code></pre>

<p>I didn't have any other processes actively spawning child processes while I was running this testing.</p>
",0
48092341,48090982,0,"<p>The parameters you pass to the <code>consultRMA</code> don't match:</p>

<p>The prototype of <code>consultRMA</code> is:</p>

<pre><code>int consultRMA(LnOVC *f, char region[MAX_REG_MILIT], int bIAge, int bSAge,
               indexSecondRegMilit tab[6], tabIndxAge IndxAge, index_primaire tabPrm[]);
</code></pre>

<p>but you call it like this:</p>

<pre><code>consultRMA(fichier, bi, bs, s, tabRM, AgeIndx, tableIndexPrim);
</code></pre>

<p>but it should probably be called like this:</p>

<pre><code>consultRMA(fichier, s, bi, bs, tabRM, AgeIndx, tableIndexPrim);
</code></pre>

<p>If you had enabled all compiler warnings you would have got a warning that the parameters don't match (which is actually more like an error).</p>
",1
50390641,50390054,1,"<p>You probably want this:</p>

<pre><code>#include &lt;stdio.h&gt;

#define SIZE 100

int main(void) {    
  char line[SIZE];
  int position;

  scanf(""%d"", &amp;position); //get position
  getchar();   // absorb \n from scanf (yes scanf is somewhat odd)

  while (fgets(line, SIZE, stdin) != NULL) {
      printf(""The character in postion %d is '%c'\n"", position, line[position]);
  }

  return 0;
}
</code></pre>

<p>No out of range check whatsoever is done here for brevity</p>

<p><strong>Example of execution:</strong></p>

<pre><code>1
abc
The character in postion 1 is 'b'
Hello
The character in postion 1 is 'e'
TEST
The character in postion 1 is 'E'
</code></pre>

<p><strong>This small example may help too:</strong></p>

<pre><code>#include &lt;stdio.h&gt;

#define SIZE 100

int main(void) {
  char line[SIZE];

  fgets(line, SIZE, stdin);
  for (int i = 0; line[i] != 0; i++)
  {
    printf(""The character in postion %d is '%c'\n"", i, line[i]);
  }
}
</code></pre>

<p>No error checks done either for brevity.</p>
",0
49739566,49739445,0,"<p>There are libraries for handling these sorts of problems, like <a href=""https://gmplib.org/"" rel=""nofollow noreferrer"">The GNU
Multiple Precision
Arithmetic Library</a>:</p>

<blockquote>
  <p><strong>What is GMP?</strong></p>
  
  <p>GMP is a free library for arbitrary precision arithmetic, operating on signed integers, rational numbers, and floating-point numbers. There is no practical limit to the precision except the ones implied by the available memory in the machine GMP runs on. GMP has a rich set of functions, and the functions have a regular interface.</p>
  
  <p>The main target applications for GMP are cryptography applications and research, Internet security applications, algebra systems, computational algebra research, etc.</p>
</blockquote>

<p>But 10^18 would take a <em>huge</em> (and effectively impossible) amount of memory (if my math is correct: 2.881 EiB). </p>
",1
49739705,49739445,0,"<p>The <a href=""https://www.codechef.com/APRIL18B/problems/WGHTNUM"" rel=""nofollow noreferrer"">referenced problem</a> takes input from <code>2 ¡Ü N ¡Ü 10^18</code>. That isn't 10^18 digits (or 10^10^18 which is absurdly enormous) but 18 digits or 2 to 1,000,000,000,000,000,000. This will fit inside a 64 bit integer, signed or unsigned.</p>

<p>Use <a href=""https://en.wikipedia.org/wiki/C_data_types#stdint.h"" rel=""nofollow noreferrer""><code>int64_t</code> from stdint.h</a>.</p>

<p>10^18 is pushing the limits of 64 bit integers, probably why they chose it. Anything larger should use an <a href=""https://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic"" rel=""nofollow noreferrer"">arbitrary precision math</a> library such as <a href=""https://gmplib.org/"" rel=""nofollow noreferrer"">GMP</a>.</p>

<p>...but there are limits. Simply storing such a number would take about 1 million gigabytes. So while the problem is about solving for numbers with 10^18 digits, I strongly suspect you're not supposed to solve it by actually storing those numbers. There's some mathematical technique you're supposed to apply.</p>
",8
49290565,49290527,1,"<p>You never assign the <code>FILE*</code> from <code>open_file</code> function to your variable, so it never gets processed.</p>

<pre><code>in = open_file(""Enter mad-lib file name:\n"", ""r"");
out = open_file(""Enter file name for resulting story:\n"", ""w"");
</code></pre>
",0
49290567,49290527,1,"<p>You are not storing the <code>FILE</code> pointers that <code>open_file</code> is returning, so <code>in</code>
and <code>out</code> remain uninitialized.</p>

<p>You have to do:</p>

<pre><code>in = open_file(""Enter mad-lib file name:\n"", ""r"");
out = open_file(""Enter file name for resulting story:\n"", ""w"");
process_file(in, out);
</code></pre>

<p>Also your <code>process_file</code> is wrong. <code>NewContent</code> is not initialized, when you do</p>

<pre><code>strcat(NewContent, content);
</code></pre>

<p>this yields undefined behaviour. Declare <code>NewContent</code> like this:</p>

<pre><code>char NewContent[MAX_LEN] = { 0 };
</code></pre>

<p>so that it is properly <code>\0</code>-terminated.</p>

<p>Also depending on the size of the file you are copying, <code>MAX_LEN</code> might not be
long enough to hold the whole file. In that case you would overflow the buffer.
It would be better not to use <code>NewContent</code> in the first place and write to <code>out</code>
in the same reading loop:</p>

<pre><code>FILE* process_file(FILE* in, FILE* out) {
    char content[MAX_LEN];
    //gets whats in file in
    while(fgets(content, MAX_LEN, in) != NULL) { //&lt;- your fgets was wrong
        fputs (content, stdout);
        fprintf(out, ""%s"", content); // or fputs(content, out);
    }
    printf(""Successfully copied file\n"");
    return in;
}
</code></pre>

<p>And you were calling <code>fgets</code> incorrectly (look at my corrected code)</p>

<p>Also bear in mind, that you did have 2 loop doing <code>while(fgets(...) != NULL</code>.
Well, the first loop ends, that's because <code>fgets</code> returns <code>NULL</code>, most likely
because the whole file was read or there was an I/O error. In either case
subsequent calls of <code>fgets</code> will return <code>NULL</code> as well, so your second loop
would not even be executed at all.</p>
",5
49333844,49333800,1,"<p>The <code>%s</code> specifier is for <strong>null-terminated strings</strong> but your arrays are fixed-length character buffers. You should use the format-string specifier that sets the length of the output instead <code>%.{length}s</code>: </p>

<pre><code>printf( ""The hour is %.2s\n"", Hour );
</code></pre>

<p>See the documentation for <code>printf</code>: <a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/cstdio/printf/</a></p>

<blockquote>
  <p><code>.precision</code> : this is the maximum number of characters to be printed. By default all characters are printed until the ending null character is encountered.</p>
</blockquote>

<p>As your character-buffers do not contain terminal nulls <code>'\0'</code> there won't be a null character so the computer will keep on scanning memory until it does encounter a zero.</p>

<p>An alternative is to increase the size of the buffers and set their last character value to nulls.</p>
",10
54332246,54332176,2,"<p>One way would be to call the function <code>foo</code> with</p>

<pre><code>foo(a[0], a + 2)
</code></pre>

<p>assuming that <code>a</code> has at least 1 element. Personally though I'd pass the whole lot and ignore the second element in the function, particularly if <code>foo</code> is allowed to modify the first element, in which case my idea won't work. My suggestion will also wreak havoc with array indexing, and, technically you can always reach the forbidden element with pointer arithmetic.</p>

<p>Because of this ability to reach the element by pointer arithmetic, a way to obviate that is to copy the array <em>sans</em> element, call the function, then write back any modifications to the original array in the caller.</p>
",0
54332230,54332176,2,"<p>If you can't change the called function, and also can't change <code>a</code>:</p>

<ul>
<li>Allocate memory <code>b</code> for n - 1 elements</li>
<li>Copy element <code>a[0]</code> in <code>b[0]</code></li>
<li>Copy from element <code>a[2]</code> to <code>a[n-1]</code> in <code>b[1]</code> to <code>b[n-2]</code> using memcpy for example.</li>
</ul>

<p>If you can change <code>a</code>, Axifive's solution is more efficient.</p>
",0
58574635,58572353,1,"<p>Perhaps I would do something like:</p>

<pre><code>  #include &lt;string.h&gt;       // strlen()
  #include &lt;unistd.h&gt;       // read(), write(), close()
  #include &lt;stdlib.h&gt;       // EXIT_SUCCESS, realloc(), free()
  #include &lt;fcntl.h&gt;        // O_RDONLY

  #define EOF (-1)          // Flag to indicate that the end-of-file was encountered.
  extern int errno;         // Used to detect, and report, error information.

  /*----------------------------------------------------------------------------
  ** Read a line from specified file (fd), and return the line in allocated
  ** memory.  The caller is responsible for freeing the returned memory.
  **
  ** Return codes:
  ** -------------
  ** -1 EOF           Encountered the end of the file (fd).
  **  0 EXIT_SUCCESS  Success.
  ** &gt;1 (errno value) Failure.
  */
  int get_next_line(int fd, char **line)
    {
    int    rCode      = EXIT_SUCCESS;
    size_t lineOffset = 0;

    while(!rCode)
      {
      char *newBuf = NULL;
      int   bytes;
      char  ch;

      bytes=read(fd, &amp;ch, sizeof(ch));         // Read one byte from file (fd).
      switch(bytes)
        {
        case (-1):                             // Check for read() error condition.
          rCode=errno;                           // Return errno to caller.
          break;                                 // Return from the function.

        case 0:                                // Check for end-of-file condition.
          rCode = EOF;                           // Return EOF flag to caller.
          ch = '\0';                             // Pretend to have read '\0'.
                                                 // No break.  Fall through to default case.
        default:                               // read() was successful.
          newBuf=realloc(*line, lineOffset+2);   // Modify line's memory allocation as needed.
          if(!newBuf)                            // Check for realloc() error condition.
            {
            rCode=errno;                           // Return errno to caller.
            break;                                 // Return from the function.
            }

          *line = newBuf;                        // realloc() was successful.  Reset line pointer.
          if('\n' == ch)                         // If newline was read, throw it away
            {
            (*line)[lineOffset] = '\0';            // Instead of a newline, terminate the line,
            break;                                 // and return from the function.
            }

          (*line)[lineOffset++] = ch;            // Append the character read from the file to the allocated memory.
          (*line)[lineOffset] = '\0';            // Terminate the string in allocated memory.
          continue;                              // Go back to the top of the while() loop, and read another byte.
        }

      break;
      }

    return(rCode);
    }

  /*----------------------------------------------------------------------------
  ** Program start.
  */
  int main(int argC, char *argV[])
    {
    int rCode=EXIT_SUCCESS;
    int fd = (-1);
    char *line_A = NULL;

    if(2 != argC)
      {
      char *msg = ""Missing filename, or too many command-line arguments.\n"";

      write(2, msg, strlen(msg));
      goto CLEANUP;
      }

    errno=EXIT_SUCCESS;
    fd=open(argV[1], O_RDONLY);
    if((-1) == fd)
      {
      char *msg = ""open() failed.\n"";

      write(2, msg, strlen(msg));
      goto CLEANUP;
      }

    while(EOF != rCode)
      {
      rCode=get_next_line(fd, &amp;line_A);
      if(rCode &gt; 0)
        goto CLEANUP;

      write(1, line_A, strlen(line_A));
      write(1, ""\n"", 2);
      }

  CLEANUP:

    if(line_A)
      free(line_A);

    if((-1) != fd)
      close(fd);

    return(rCode);
    }
</code></pre>
",1
49662110,49661944,1,"<p><code>return x &gt; y ? 1 : -1;</code> Never returns 0 (a match). Try <code>return (int)(x - y);</code> (just noted unsigned types so need to be aware of that - I've used a simple cast but there is likely a safer way)</p>

<p>Comment re: overflow is correct (but unlikely in normal usage), if on is a huge positive and the other is a huge negative then you're going to have problems.</p>

<p>A nice clear way to handle any size without overflow or sign issues:</p>

<pre><code>if (x == y)
    return 0;
return x &gt; y ? 1 : -1;
</code></pre>
",3
53011684,53011620,2,"<pre><code>(*addr).pods[key] = (*addr).pods[key]-&gt;nextNode;
</code></pre>

<p>The <code>pods</code> is an array of pointers. Once you have the pointer, you need to dereference it to access the underlying object.</p>
",0
53011689,53011620,1,"<p>Change this:</p>

<pre><code>(*addr).pods[key].nextNode;
</code></pre>

<p>to this:</p>

<pre><code>(*addr).pods[key]-&gt;nextNode;
</code></pre>

<p>since <code>pods[key]</code> is of type <code>node*</code>, i.e. a <em>pointer</em> to a <code>node</code>.</p>
",0
49547577,49547464,3,"<p>Once you fix undefined behavior by adding space for null terminator, let's consider behavior of your program.</p>

<blockquote>
  <p>What is wrong with <code>aux2</code>?</p>
</blockquote>

<p>Since <code>atoi</code> considers the whole string, <code>aux2</code> is the same as <code>aux</code>, because it's the string starting at <code>'5'</code> and continuing to <code>'\0'</code>.</p>

<p>If you wanted to get the individual digits, use subtraction of <code>'0'</code>:</p>

<pre><code>int aux2 = num[0] - '0';
int aux3 = num[1] - '0';
</code></pre>

<p>Make sure that <code>num</code> has exactly two characters, and both characters are digits.</p>
",1
49330089,49329962,-1,"<p><strong>EDIT:</strong>
Adding explanation. There are some issues with your code, few major, few not that serious</p>

<ol>
<li>Don't use <code>void main()</code>. It's not the best thing to use.</li>
<li>Indenting your code will make it easier to read</li>
<li>Let's look at the <code>readmassage</code> function.</li>
<li>You are assigning the result of <code>getchar()</code> to an <code>int</code>. That's not right. it should be a <code>char</code></li>
</ol>

<p>here's a version of your code with minor fixes</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void reverser(char*);
int readmassage(char[], int);
void main()
{
    char mysentence[30];
    readmassage(mysentence, 30);
    printf(""Input: %s"", mysentence);
    reverser(mysentence);
    printf(""Output: %s"", mysentence);
    system(""pause"");
    return 0;
}
void reverser(char*massage)
{
    char temp,*p;
    p = massage + strlen(massage)-1;
    while (p &gt; massage) {
    temp = *massage;
    *massage = *p;
    *p-- = temp;
}}
int readmassage(char massage[], int lenght)
{
    char ch;
    int i = 0;
    while (ch != '\n')
    {
      ch = getchar();
      printf(""Here\n"");
      if (lenght &gt; i)
      {
        massage[i++] = ch;
        printf(""%c\n"", massage[i]);
      }
    }
    massage[i] = '\0';
    return i;
}
</code></pre>

<p>When you try this you will find that the input string gets read fine, just be sure to not to hi <code>Enter</code> after every character and instead type the full string out as <code>\n</code> is a valid character that can be in the stream and will terminate the loop the next iteration.</p>

<p>This is why you should use a char array reading function like <code>fgets</code>.</p>

<p>Once you get here you can see that the <code>reverser</code> is just following a slightly flawed reversing logic.</p>

<p>grammatical errors aside, fixing this you can get</p>

<p>here you go</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void reverser(char* message)
{
    int start, end;
    start = 0;
    end = strlen(message) - 1;
    char temp;
    while (start &lt; end) {
      temp = message[start];
      message[start] = message[end];
      message[end] = temp;
      start++;
      end--;
    }
}
void readmessage(char message[], int length)
{
    fgets(message, length , stdin);
} 

int main()
{
    char mysentence[30];
    readmessage(mysentence, 30);
    printf(""Read the string\n"");
    reverser(mysentence);
    printf(""%s\n"", mysentence);
    return 0;
}
</code></pre>
",4
50609350,50609313,6,"<p>Usually (and conventionally in many, but not all, free software) <code>_</code>  is a <code>#define</code>-d macro for something like <a href=""http://man7.org/linux/man-pages/man3/gettext.3.html"" rel=""noreferrer"">gettext(3)</a>, to ease <a href=""https://en.wikipedia.org/wiki/Internationalization_and_localization"" rel=""noreferrer"">internationalization &amp; localization</a> of software.</p>
",0
55364403,55362879,2,"<p>I think you need 2 arrays. </p>

<p>One contains the positions of all the free pixels, and the other, the free pixel map would contain location of each pixel in the free pixels array, if it is free. </p>

<p>Whenever you <em>occupy a new pixel</em> you remove it from the free pixels array. If it was the last item, you just <em>decrease the counter</em> for free pixels. If it is not the last pixel of the free pixels array, you'll ""swap"" it with the last pixel of the free array first. </p>

<p>Since both the free pixel array and the map of free pixels are linked to each other, occupying a new pixel only takes O(1) updates to the structures; same applies for when a pixel is freed again.</p>

<p>Now, <em>choosing</em> a free pixel at random for food is really easy, it is an O(1) operation - just choose a number from <code>0</code> through <code>n_free_pixels - 1</code> and choose the <code>ith</code> pixel from the free pixel array.</p>

<p>For this approach you'll need about 4-8 bytes extra memory per pixel; if say 320x200 is enough, then 4 bytes per pixel for 256k (both arrays will have unsigned shorts). BUT if you place the food in a <em>grid</em> and consider a grid position unusable if the snake occupies any part of it, then you can get away with much less.</p>

<hr>

<p>Consider a 2x2 map for simplicity. In the beginning all pixels free, so the contents of the maps would be</p>

<pre><code>Free pixel map        Free pixel list
+-----+-----+
|0    |1    |         | 0 | 1 |?2 |?3 
|  0  |? 1  |
|     |     |
+-----+-----+         n_free = 4
|2    |3    |
|  2  |  3  |
|     |     |
+-----+-----+
</code></pre>

<p>Then you want to choose one pixel to occupy, and choose a number between 0 and n_free - 1. In this case 1. Now you take the pixel position from the free pixel list at index 1 (which is also 1)...</p>

<pre><code>Free pixel map        Free pixel list
+-----+-----+
|0    |1    |         | 0 | 1 | 2 | 3 
|  0  |  1  |               ^
|     |     |
+-----+-----+         n_free = 4
|2    |3    |
|  2  |  3  |
|     |     |
+-----+-----+
</code></pre>

<p>We mark that pixel as reserved in the free pixel map</p>

<pre><code>Free pixel map        Free pixel list
+-----+-----+
|0    |1    |         | 0 | 1 | 2 | 3 
|  0  |  #  |               
|     |     |
+-----+-----+         n_free = 4
|2    |3    |
|  2  |  3  |
|     |     |
+-----+-----+
</code></pre>

<p>Since the position in free list wasn't the last, we'll swap the 
last element (pixel 3) into that position, and update the free map to point to that index, and finally decrease <code>n_free</code> by one:</p>

<pre><code>Free pixel map        Free pixel list
+-----+-----+
|0    |1    |         | 0 | 3 | 2 
|  0  |  #  |               ^
|     |     |
+-----+-----+         n_free = 3
|2    |3    |
|  2  |  1  |
|     |  ^  |
+-----+-----+
</code></pre>

<hr>

<p>If pixel <code>1</code> is subsequently <em>released</em>, we can add it at the position <code>n_free</code> of the free list, and modify the map to point to that element and finally increase <code>n_free</code>; the new state would be </p>

<pre><code>Free pixel map        Free pixel list
+-----+-----+
|0    |1    |         | 0 | 3 | 2 | 1
|  0  |  3  |                       ^
|     |     |
+-----+-----+         n_free = 4
|2    |3    |
|  2  |  1  |
|     |     |
+-----+-----+
</code></pre>
",0
49848263,49848205,2,"<p><code>item[0].name</code> is an array, you cannot assign a pointer (string literal) to an
array. You need to copy the contents, in this case with <code>strcpy</code> for example:</p>

<pre><code>strcpy(item[0].name, ""Brutalizer"");
</code></pre>

<p>Or if the length of the source is not know beforehand, then you can use
<code>strncpy</code> to avoid buffer overflows:</p>

<pre><code>strncpy(item[0].name, ""Brutalizer"", sizeof item[0].name);
item[0].name[sizeof(item[0].name) - 1] = '\0'; // make sure that it's \0-terminated
</code></pre>

<p>or you can use <code>snprintf</code></p>

<pre><code>snprintf(item[0].name, sizeof item[0].name, ""Brutalizer"");
</code></pre>
",4
53289016,53285285,0,"<p>Your string of bytes is not null-terminated (it is not a C-style string).</p>

<p>You should replace the <code>strcat</code> by <code>memcpy</code>, as follows:</p>

<pre><code>memcpy(response_pointer, body_start_pointer, fsize);
</code></pre>

<p>And you should replace the <code>strlen()</code> by the real length:</p>

<pre><code>write(new_socket, response, fsize);
</code></pre>

<p>Besides, the following line is useless and should be removed (as there is no need for null-termination):</p>

<pre><code>*body_pointer = '\0';
</code></pre>
",0
50259908,50259705,2,"<p>You can use the array element as a parameter to formatting functions like <code>printf()</code></p>

<pre><code>char *commands = ""lrudbcsiln"";
for (int i; i &lt; strlen(commands); i++) {
    printf(MainMenuNames[i], commands[i]);
    putchar('\n');
}
</code></pre>
",0
48525277,48525176,3,"<p>You don't have a char array - <code>uid</code> is only a char.</p>
",5
59450722,59450697,1,"<p>First variable is not initialized, you are printing garbage there.</p>

<pre><code>int auto_var1, auto_var2 = 0;
</code></pre>

<p>Change this to initialize both, they'll both print 0 then.</p>

<pre><code>int auto_var1 = 0, auto_var2 = 0;
</code></pre>
",1
50066636,50066547,1,"<p>You have a little mix-up with what to pass to <code>printf</code>. Here is what you are looking for:</p>

<pre><code>printf(""cPtr1 Stored:'%c'  Point:%p   Memory:%p\n"", *cPtr1, (void*)cPtr1, (void*)&amp;cPtr1);
printf(""cPtr2 Stored:'%c'  Point:%p   Memory:%p\n"", *cPtr2, (void*)cPtr2, (void*)&amp;cPtr2);
</code></pre>

<p><a href=""https://ideone.com/OxXVfE"" rel=""nofollow noreferrer"">Demo.</a></p>

<p>As you can see, both <code>cPtr1</code> and <code>cPtr2</code> are pointing to the same character. Moreover, the two pointers are the same. Pointers themselves, however, occupy separate locations in memory.</p>

<p>Explanation of changes:</p>

<ul>
<li>You need to dereference pointers <code>*cPtr1</code> to print with <code>%c</code></li>
<li>You need to use <code>%p</code> to print a pointer</li>
<li>When you print a pointer, you need to cast the argument to <code>(void*)</code>.</li>
</ul>
",2
50302001,50301925,1,"<p>That is just a limitation of printing the whole ""board"" on every change. The only way to fix it is to only print what changes. Depending on your OS etc you may be able to print individual characters or lines instead of the whole board.</p>

<p>You could look at a library like curses to give character level control (there may be something better - don't know, I don't do this often enough to know ;-)</p>

<p>As other answers have said, printing in bigger pieces (like a whole buffer at a time) is better than <code>printf</code> for each individual character but you will still probably have the same issue but it is certainly worth a try.</p>
",0
50302000,50301925,1,"<p>You may want to try building the full screen of data into a buffer first and THEN print it. Start with an array of characters as long as you need it to be:</p>

<pre><code>char buffer[SIZE_X * SIZE_Y];
</code></pre>

<p>Then go through your loop above, but instead of using <code>printf()</code>, set the character at that location in the buffer to what you want it to be:</p>

<pre><code>buffer[(SIZE_X * Y) + X] = /* '@', '#', or '.' as appropriate */
</code></pre>

<p>Then, once you are through the loop, you will print the whole buffer to the screen:</p>

<pre><code>printf(buffer);
</code></pre>

<p>Just make sure you don't accidentally overwrite your null terminator with another character or you may get more text than you bargained for.</p>
",2
48263867,48263206,1,"<p>There are a few problems in the code: </p>

<p>1) allocating only one byte for the string <code>str</code>: </p>

<pre><code>#define N 1
char *str=(char*)(malloc(N*sizeof(char)));
</code></pre>

<p>2) using <code>gets(sen)</code> instead of    <code>fgets(sen,M+1,stdin);</code></p>

<p>3) <code>char *acronyms (char *st,  char *sentence)</code>
has very problematic logic. The end of string is not recognized, the <code>' '</code> may or may not be present: </p>

<pre><code> if (*q !=' ') {
        *p =*q;
        p++;
 }
</code></pre>
",0
48263974,48263206,1,"<p>This may not seem very satisfying at first glance, but once you have an understanding of the underlying principles pointed to by these 5 concepts (each with example(s)),this, and other similar tasks will seem much simpler.   </p>

<p>Necessary steps to do what you are trying:</p>

<p>1) Understand console user input techniques (<em><a href=""https://stackoverflow.com/a/4023921/645128"">Good example here</a></em>)<br>
2) Understand definition of string ( <em><a href=""https://www.tutorialspoint.com/cprogramming/c_strings.htm"" rel=""nofollow noreferrer"">Good definition,explanation here</a></em>. )<br>
3) Understand usage of <code>[c][m]alloc(...)</code> (<em><a href=""https://stackoverflow.com/questions/1538420/difference-between-malloc-and-calloc"">Good discussion here...</a></em> ...)<br>
3a) ...and when to use it. or not. ( <em><a href=""https://www.gribblelab.org/CBootCamp/7_Memory_Stack_vs_Heap.html"" rel=""nofollow noreferrer"">heap vs. stack memory</a></em> )<br>
4) Understand string parsing techniques. ( <em><a href=""https://stackoverflow.com/q/9210528/645128"">ex 1</a></em> , <em><a href=""https://www.codeproject.com/Tips/274477/General-string-parsing-techniques"" rel=""nofollow noreferrer"">ex 2</a></em>, <em><a href=""https://books.google.com/books?id=05xA_d5dSwAC&amp;pg=PA565&amp;lpg=PA565&amp;dq=C+string+parsing+techniques&amp;source=bl&amp;ots=3Pry5BgaOb&amp;sig=KrAnYK3fW-vrRTMJsxsVH8nm9Qw&amp;hl=en&amp;sa=X&amp;ved=0ahUKEwimyrrHiNrYAhUIS5AKHfUpAxIQ6AEIRDAD#v=onepage&amp;q=C%20string%20parsing%20techniques&amp;f=false"" rel=""nofollow noreferrer"">ex 3</a></em> )<br>
5) Become aware of legal, but unwise techniques, such as using <em><a href=""https://www.geeksforgeeks.org/gets-is-risky-to-use/"" rel=""nofollow noreferrer"">gets</a></em>, or <em><a href=""https://stackoverflow.com/questions/1253053/cs-bad-functions-vs-their-good-alternatives/1253079#1253079"">in general</a></em>.</p>

<p>These are generally applicable techniques, useful for many tasks that include user input and string manipulation, but are not a good replacement for referring to a good C book to provide a necessary foundation in the basics.</p>
",0
58787016,58777045,1,"<p>OK, I'll play this silly game and make like some nerdy Cyrano de Bergerac!  </p>

<p>Your flow chart does not really work - you have some ""do nothing forever"" dead ends - which seems rather tragic! I have interpreted this to mean rather ""do nothing until..."" which would look like:</p>

<p><a href=""https://i.stack.imgur.com/WlOIp.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/WlOIp.png"" alt=""enter image description here""></a></p>

<p>which may be visually less attractive, but at least does not speak of the death of your marriage!</p>

<p>That being the case then: </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;letter.h&gt;
#include &lt;wife.h&gt;
#include &lt;love.h&gt;

int main()
{
    while( !letterOpen() ) { }

    printf( ""Dear honey,\n\n"" ) ;
    while( !wifeSmiling( ANY ) ){ }

    printf( ""I just wanted to say\n"" ) ;
    while( !wifeSmiling( TEARS_OF_JOY ) ){ }

    printf( ""I love you\n"" ) ;
    while( !wifeSmiling( TEARS_OF_JOY ) ){ }

    printf( ""\nLove your loving husband\n"" ) ;
    while( !wifeSmiling( TEARS_OF_JOY ) ){ }

    doHugs() ;
    doKisses() ;

    return SUCCESS ;
}
</code></pre>

<p>Output:</p>

<pre><code>Dear honey,

I just wanted to say
I love you

Love your loving husband
</code></pre>
",0
58777099,58777045,3,"<blockquote>
  <p>The purpose of this is to write the code on paper for a cute love note to my wife.</p>
</blockquote>

<p>I think you have done this already. Your flowchart is much more charming than any C code could ever be.</p>

<p>My only worry is the ""do nothing"" boxes. You might want to seek feedback on that from your end user, and revise the logic as needed.</p>

<p>This will help teach you the art of debugging, a skill you will need for every programming language you ever use.</p>

<p>In fact I suggest working through the entire chart with her. You never know what might happen!</p>

<p>And you won't need a single line of C code to do it.</p>

<p>One more thing... Keep the old versions of the chart if you revise it. This way you will learn about version control, and you will have a fun story to share with your grandchildren. </p>
",3
49704614,49704569,4,"<p>The problem is not in your code per se.  Rather, there is another function already defined named <code>abs()</code> with a different prototype - probably operating on integers.  Unlike C++, C doesn't permit function overloading.</p>

<p>I suggest using <code>fabs()</code> from <code>math.h</code> instead.  Not only is it already there, but it will typically compile to a single FPU instruction instead of a call and conditional branch.</p>

<p>There is also <code>fabsf()</code> and <code>fabsl()</code> for performing the same operation on <code>float</code> and <code>long double</code> respectively.  To use these, you might need to select C99 or C11 mode, as these functions weren't specified in the original ANSI standard.</p>
",0
49740981,49740932,6,"<p>Your <code>rand_coin()</code> function flips 2000 coins and returns the number of heads that appear. Your <code>main</code> function calls that twice, independently. There's no reason to think that the result will be exactly 2000.</p>

<p>You only need to call the <code>rand_coin()</code> function once to get the number of heads, then subtract from 2000 to get the number of tails.</p>

<pre><code>heads = rand_coin();
tails = 2000 - heads;
printf(""Heads = %d, Tails = %d\n"", heads, tails);
</code></pre>
",0
49740978,49740932,5,"<pre><code>  tails = rand_coin();
</code></pre>

<p>is wrong from an algorithmic point of view. You just need to use:</p>

<pre><code> tails = 2000 - heads;
</code></pre>

<hr>

<p>I would suggest the following improvements:</p>

<ol>
<li>Pass the number of tosses to <code>rand_coin</code> so that the number 2000 is not hard coded in multiple places.</li>
<li>There is no need to keep track of <code>tails</code> in the function.</li>
</ol>

<p>Here's an updated version of your posted code.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;

int rand_coin(int num_tosses);

int main (void) {

   int heads = 0;
   int tails = 0;
   srand(time(NULL));
   int num_tosses = 2000;
   heads = rand_coin(num_tosses);
   tails = num_tosses - heads;
   printf(""Heads = %d, Tails = %d\n"", heads, tails);
   return 0;
} /* end main */

/* implement rand_coin() below: */

int rand_coin(int num_tosses) {
   int value;
   int i; //
   int heads = 0;

   for(i=0; i &lt; num_tosses; i++){
      value = rand() % 2;
      if (value == 1) {
         heads++;
      }
   }
   return heads;
}
</code></pre>
",2
56384482,56382803,0,"<pre><code>int n = strlen(a);
for ( int i=1; i &lt; n; i+=2 ) {
   char c = a[i-1];
   a[i-1] = a[i];
   a[i] = c;
}
</code></pre>
",0
54613169,54613158,3,"<pre><code>if(!a &gt;= 400)
</code></pre>

<p>Since logical not <code>!</code> has higher precedence, this is equivalent to <code>(!a) &gt;= 400</code>. The left side evaluates to <code>0</code> (because a is non-zero, so <code>!a</code> is <code>0</code>) making the entire expression is false. Also note the code indentation isn't significant to the compiler.</p>
",1
50395143,50394546,2,"<p>You are on Windows.  <code>getline</code> is a POSIX function, not required by the C standard, and the C runtime used by your compiler (MinGW) does not implement it.  I am surprised it appears in your <code>stdio.h</code>; you should at least have gotten an ""implicit function declaration"" warning as well as the linker error.</p>

<p>I suggest using <code>fgets</code> instead, it is probably good enough for what you appear to be doing.</p>
",1
50395173,50394546,0,"<p>I suspect that the problem is that you do not have the correct compile environment for using the <code>getline()</code> function.</p>

<p>That would explain the ""undefined reference"" error for <code>getline()</code> you are seeing.</p>

<p>The <code>getline()</code> function was a GNU extension to the Standard library.</p>

<p>See <a href=""http://man7.org/linux/man-pages/man3/getline.3.html"" rel=""nofollow noreferrer"">getline(3) Linux Programmer's Manual</a> which mentions:</p>

<blockquote>
<pre><code>       Since glibc 2.10:
           _POSIX_C_SOURCE &gt;= 200809L
       Before glibc 2.10:
           _GNU_SOURCE
</code></pre>
  
  <p>Both getline() and getdelim() were originally GNU extensions.  They
         were standardized in POSIX.1-2008.</p>
</blockquote>

<p>and the example provided uses:</p>

<pre><code>   #define _GNU_SOURCE
   #include &lt;stdio.h&gt;
   #include &lt;stdlib.h&gt;
</code></pre>
",0
54809622,54809438,1,"<p>The C standard specifies that a directive line has this form.</p>

<pre><code>&lt;maybe spaces&gt; # &lt;maybe spaces&gt; DIRECTIVE-NAME .....
</code></pre>

<p>Before to check for this, you also need to cut out the '\NEWLINE'.  In order for your processing to be conforming with C, so to be able to process any valid file.</p>

<p>So you also need to skip the spaces before and after the <code>#</code> in your code and remve <code>\\\n</code>.</p>
",3
53726318,53726189,4,"<pre><code>// input buffer==&gt; 42foo\n
scanf(""%d"", &amp;a); // returns 1 (not EOF), a is now 42
// input buffer==&gt; foo\n
scanf(""%d"", &amp;a); // returns 0 (not EOF), see comments about a
// input buffer==&gt; foo\n  // no change
scanf(""%d"", &amp;a); // returns 0 (not EOF)
// input buffer==&gt; foo\n  // no change
scanf(""%d"", &amp;a); // returns 0 (not EOF)
// input buffer==&gt; foo\n  // no change
... ... infinite loop
</code></pre>

<p>In short, don't compare the return value from <code>scanf()</code> with EOF; compare with the number of expected assignments.</p>

<pre><code>if (scanf(""%d%s%d%d"", &amp;a, name, &amp;b, &amp;c) != 4) /* error */;
</code></pre>
",2
52909470,52908203,0,"<p><sup><em>Transferring key comments into an answer.</em></sup></p>

<p>What is <code>PORT</code> defined as? POSIX says <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/getaddrinfo.html"" rel=""nofollow noreferrer""><code>getaddrinfo()</code></a> has the prototype</p>

<blockquote>
<pre><code>int getaddrinfo(const char *restrict nodename, const char *restrict servname,
                const struct addrinfo *restrict hints, struct addrinfo **restrict res);
</code></pre>
</blockquote>

<p>and also stipulates:</p>

<blockquote>
  <p>The <code>nodename</code> and <code>servname</code> arguments are either null pointers or pointers to null-terminated strings. One or both of these two arguments shall be supplied by the application as a non-null pointer.</p>
</blockquote>

<p>The OP notes:</p>

<ul>
<li>The PORT is set to 6667 ¡ª <code>#define PORT 6667</code></li>
</ul>

<p>If you have <code>#define PORT 6667</code>, then that does not look like either a null pointer or a null-terminated string. So it isn't a big surprise (to me) that your code is crashing.</p>

<p>It is a surprise that you are not getting compiler warnings telling you that you're doing it wrong. Get the warnings enabled, or get a better compiler. And heed the warnings ¡ª the compiler knows more about C than you do. I rarely run code that doesn't compile cleanly with</p>

<pre><code>gcc -O3 -g -std=c11 -Wall -Wextra -Werror -Wmissing-prototypes -Wstrict-prototypes ¡­ 
</code></pre>

<p>(The <code>-Werror</code> makes sure I deal with the warnings because the compilation fails if there are any!  I sometimes add some more warnings; I rarely remove any of them.)</p>
",0
51295244,51295030,1,"<p>The ways you define your list, <code>insert()</code> and <code>remove()</code> are not consistent. Looking at your function declarations, <code>insert()</code> expects a <code>char *</code> as its second argument where as <code>delete()</code> is declared as <code>void delete (ListNodePtr*, char)</code>. Do you intend to store a <code>char</code> or a string as the key of your list node? </p>

<p>Also, below is a very bad way of comparing (what?)</p>

<pre><code>if (&amp;value == (*sPtr)-&gt;data)
</code></pre>

<p>To compare <code>char</code>, simply use <code>==</code> or <code>!=</code> operators, for string comparison, use <code>strncpy()</code>. Below is not correct</p>

<pre><code> // loop to find the correct location in the list       
      while (currentPtr != NULL &amp;&amp; value &gt; currentPtr-&gt;data) {
</code></pre>

<p>I think, you overused pointers. You <code>typedef</code> an alias for your pointer type, yet you pass your functions a <code>ListNodePtr *sPtr</code>, which is a pointer to pointer to struct listNode. And then within your functions you dereference <code>sPtr</code> to get a <code>struct *listNode</code>. Update your function declarations to accept a <code>ListNodePtr</code> as the first argument rather than a <code>ListNodePtr *</code> and remove dereferencing from the function definitions.</p>

<p>I would use<code>struct *</code> instead of a <code>typedef</code>, which sometimes hides the details and makes the code a bit confusing.</p>
",2
50294836,50294766,2,"<blockquote>
  <p>How GCC compiler resolve the name conflict while linking?</p>
</blockquote>

<p>With only one global variable, there is no conflict for the linker to resolve. The fact that the <code>static</code> variable shares the same name with a global variable does not matter, because static variables are invisible to the linker.</p>

<p>The same name of a static variable or a static function could be used in several translation units without causing linking conflicts. Marking variables <code>static</code> makes them ""local"" to the translation unit in which they are defined. Other translation units cannot access these variables, giving programmers a degree of isolation between their translation units. That is why the two <code>var</code>s in your scenario are located at different addresses.</p>
",0
51815365,51812202,1,"<p>To assign an <code>int</code> value to an <code>int *</code> object, use an explicit cast, as in:</p>

<pre><code>destination = (int *) source;
</code></pre>

<p>Your question says ¡°C will not let me assign my integer to my int pointer¡± but fails to state exactly what the problem is. Presumably you are getting some diagnostic message from the compiler. This would be because assigning an <code>int</code> value to an <code>int *</code> object violates the C standard¡¯s constraints for assignments. The code above shows how to work around that.</p>

<p>That solves the immediate problem of the compiler diagnostic. However, there can be various issues with using <code>int</code> values as containers for pointers, including the possibility of trap values and discrepancies between the sizes of pointers and integers. Provided that <code>int</code> and <code>int *</code> are the same size, using an <code>int</code> to hold an <code>int *</code> is not unlikely to work, but you should be sure of the properties of your C implementation.</p>
",2
48407848,48407597,1,"<ol>
<li><p><code>a</code> and <code>b</code> are grey because the editor is automatically coloring the code to help illustrate the program syntax. This may look funny at first, but, over time, your brain will become accustomed to it, and things that are the wrong colors will stand out. This will help you find mistakes in your program¡ªwhen you make a mistake typing, something that should be a keyword will be colored like a parameter name, and you may notice it is the wrong color and take a closer look at what you typed.</p></li>
<li><p>In <code>printf(""%d"", minus);</code>, the <code>minus</code> is just the function. It is not the value returned by the function. To print the value returned by the function, use <code>printf(""%d"", minus(a, b));</code>.</p></li>
</ol>
",1
48818092,48817426,0,"<p>I'd go through the list and check if the current node's info is the same as the
value. If that's the case, remove the node, update the <code>prev</code> and <code>next</code>
pointers around the current node, free the node and move to the next one. Stop
when <code>NULL</code> has reached. If the current's node <code>prev</code> is <code>NULL</code>, then we have to
update the <code>head</code> as well by setting <code>my_list</code>. The function returns the new
head of the list or <code>NULL</code> when the list is empty or when all nodes of the list
were removed. This is my version:</p>

<pre><code>struct list* remove_elem(struct list *my_list, char value)
{
    int removed_something = 0;

    struct list *current = my_list, *tofree;

    while(current)
    {
        if(current-&gt;info == value)
        {
            if(current-&gt;next)
                current-&gt;next-&gt;prev = current-&gt;prev;

            if(current-&gt;prev)
                current-&gt;prev-&gt;next = current-&gt;next;
            else
                my_list = current-&gt;next; // update head of list

            tofree = current;
            current = current-&gt;next;
            free(tofree);
            removed_something = 1;
        } else
            current = current-&gt;next;
    }

    if(removed_something == 0)
        fprintf(stderr, ""Node with value '%c' not found\n"", value);

    return my_list;
}
</code></pre>

<p>I don't do <code>while(current-&gt;next)</code> because at the end of the loop I would have to
repeat the code in the loop for the last element of the list. By using
<code>while(element)</code> I reach <strong>all</strong> elements of the list inside the loop and don't
have to repeat the removing code after the loop, which is causing you trouble.</p>

<p>I also don't understand what your <code>dispose_list</code> function does. You are just
removing the head but you are not freeing the head and you are returing the rest
of the list. You also are not updating the <code>prev</code> pointer of the new head. This
seems all strange to me. If you want to dispose of the head:</p>

<pre><code>struct list *dispose_list(struct list* my_list)
{
    if(my_list == NULL)
        return NULL;

    struct list *oldhead = my_list;

    my_list = my_list-&gt;next;
    if(my_list)
        my_list-&gt;prev = NULL;

    free(oldhead);

    return my_list;
}
</code></pre>

<p>And if you want to free the whole list:</p>

<pre><code>void free_list(struct list *my_list)
{
    if(my_list == NULL)
        return;

    struct list *tmp;

    while(my_list)
    {
        tmp = my_list;
        my_list = my_list-&gt;next;
        free(tmp);
    }
}
</code></pre>
",0
49621396,49621252,0,"<p>You have <code>struct protein temp;</code> and <code>int temp;</code> in your code which will cause all sorts of confusion (for you and the compiler). </p>

<p>Looks like you only need the struct version. If you do need both rename the int version to <code>temp_index</code> or similar.</p>

<p>Compiling with all warnings enabled would probably highlight this as a problem.</p>
",0
49621396,49621252,0,"<p>You have <code>struct protein temp;</code> and <code>int temp;</code> in your code which will cause all sorts of confusion (for you and the compiler). </p>

<p>Looks like you only need the struct version. If you do need both rename the int version to <code>temp_index</code> or similar.</p>

<p>Compiling with all warnings enabled would probably highlight this as a problem.</p>
",0
55320973,55297099,2,"<blockquote>
  <p>It will have 2 fd[1] after dup(fd[1];,</p>
</blockquote>

<p>No. The value of <code>fd[1]</code> never changes. If it was 4 before the call to <code>dup</code>, it's 4 after the call to <code>dup</code>.</p>

<blockquote>
  <p>why the system closed the second fd[1](4. [write]) in the result? not first fd[1](2. [write])?</p>
</blockquote>

<p>If <code>fd[1]</code> is 4, then <code>close(fd[1]);</code> will close descriptor 4. It will not affect any other descriptors that happen to reference the same endpoint.</p>

<p>Before you call <code>pipe</code>, your process already has file descriptors 0, 1, and 2 as its standard input, standard output, and standard error. You then create two new descriptors for the pipe.</p>

<p>So this is what it looks like when you call <code>fork</code>, more or less:</p>

<blockquote>
  <p>...0...|....1....|.....2....|....fd[0]....|.....fd[1].....<br>
  stdin, stdout, stderr, pipe end, other pipe end</p>
</blockquote>

<p>Then, in the parent, you close <code>fd[0]</code>, so you have:</p>

<blockquote>
  <p>...0...|....1.....|.....2...|....fd[0]................|......fd[1].....<br>
  stdin, stdout, stderr, closed pipe end, open pipe end</p>
</blockquote>

<p>Then you close stdout:</p>

<blockquote>
  <p>...0....|...1....|.....2.....|...fd[0]..|......fd[1].....<br>
  stdin, closed, stderr, closed, open pipe end</p>
</blockquote>

<p>Then you dup the open pipe end:</p>

<blockquote>
  <p>...0....|..................1.............|.....2.....|..fd[0]..|.......fd[1].....<br>
  stdin, dup of open pipe end, stderr, closed, open pipe end</p>
</blockquote>

<p>Then you close fd[1]:</p>

<blockquote>
  <p>...0....|....................1............|.....2...|...fd[0]..|..fd[1].....<br>
  stdin, dup of open pipe end, stderr, closed, closed</p>
</blockquote>

<p>Or, more simply:</p>

<blockquote>
  <p>...0...|...................1...............|....2....<br>
  stdin, dup of open pipe end, stderr</p>
</blockquote>

<p>So when you call <code>execl</code>, the new process will inherit the parent's standard input and standard error but will inherit a copy of one end of its pipe as its standard 
output.</p>
",0
57157998,57157846,2,"<p>There are two things that are involved here: Operator associativity, and <a href=""https://en.wikipedia.org/wiki/Short-circuit_evaluation"" rel=""nofollow noreferrer"">short-circuit evaluation</a> (please see the link for a description of what it is and what it does).</p>

<p>Due to the associativity of the <code>&amp;&amp;</code> operator, the expression <code>++x &amp;&amp; ++y &amp;&amp; ++z</code> is equal to <code>(++x &amp;&amp; ++y) &amp;&amp; ++z</code>.</p>

<p>If we do the sub-expression <code>++x &amp;&amp; ++y</code> then the result is <code>false</code>. What happens is that <code>++x</code> results in <code>0</code>, so we have <code>0 &amp;&amp; ++y</code>. And in C zero is the same as boolean <code>false</code>, and due to the short-circuit evaluation <code>++y</code> never happens. The value of <code>y</code> stays at <code>-1</code>.</p>

<p>So with the result of the first sub-expression, we have <code>false &amp;&amp; ++z</code>. Again due to short-circuit evaluation <code>++z</code> never happens, and the result is again <code>false</code>.</p>

<p>So the result of <code>++x &amp;&amp; ++y &amp;&amp; ++z</code> is <code>false</code>, which is then assigned to <code>z</code>. And in the assignment the boolean <code>false</code> is implicitly converted to the integer value <code>0</code>. Which is the printed value of <code>z</code>.</p>
",6
49188876,49188672,2,"<ul>
<li>If you're after the last occurrence, then you can start your search at the end of the array and work backwards.</li>
<li>C arrays are referenced by a pointer to any element and a length or index upper-bound value, which you have.</li>
<li>One way of looking at recursive functions is asking ""is each step of the algorithm just repeating the whole thing, just on a decreasing subset of the input data?"" - consider problems like processing trees (where each child node is a tree itself) or operations like quicksort (where each pivot gives you two more sub-sections which you pivot again, and so on).</li>
<li>Consider that finding a value in an array of <code>[0...N]</code> is the same as finding the value by checking <code>[0]</code> and then checking <code>[1...N]</code>, then repeating yourself all over again by checking <code>[1]</code> and then checking <code>[2..N]</code>...hopefully you're seeing a pattern emerging.</li>
<li>For working backwards, given the array's start and length <code>N</code>, you'd check <code>[N]</code> first, then repeat with the range <code>[0..(N-1)]</code>, then check <code>[N-1]</code> then repeat with <code>[0...(N-2)]</code>.</li>
</ul>

<p>I hope that will enable you to come to a solution without me just giving you the answer.</p>
",1
49062143,49062063,3,"<p>Yes, you can do this with structures, which may contain arbitrary data fields, as with the following complete program:</p>

<pre><code>#include &lt;stdio.h&gt;

struct tPair {int one; int two;};

struct tPair returnPair(void) {
    struct tPair plugh;
    plugh.one = 7;
    plugh.two = 42;
    return plugh;
}

int main(void) {
    struct tPair xyzzy = returnPair();
    printf(""Pair is %d, %d\n"", xyzzy.one, xyzzy.two);
    return 0;
}
</code></pre>

<p>If you compile and run that, you'll see:</p>

<pre><code>Pair is 7, 42
</code></pre>
",0
49062121,49062063,3,"<p>A function cannot return multiple values.</p>

<p>You can however pass pointers so that a function writes the data through the
pointer:</p>

<pre><code>void foo(int *x, int *y)
{
    *x = 1;
    *y = 2;
}

void bar(void)
{
    int a, b;

    foo(&amp;a, &amp;b);

    printf(""a: %d, b: %d\n"", a, b); // prints a: 1, b: 2
}
</code></pre>

<p>Another option is to create a struct and return that struct:</p>

<pre><code>struct answer {
    int x;
    int y;
};

struct answer foo(void)
{
    struct answer a;
    a.x = 1;
    a.y = -4;

    return a;
}

void bar(void)
{
    struct answer p = foo();

    printf(""p.x: %d, p.y: %d\n"", p.x, p.y);
}
</code></pre>
",2
48856774,48856663,1,"<p>Assuming that you've allocated the memory for the struct members</p>

<pre><code>printf(""Please give semester: "");
scanf(""%d"",p-&gt;semester);
</code></pre>

<p>is the problem, as <code>p-&gt;semester</code> is an <code>int</code>. <code>%d</code> expects a pointer to <code>int</code>, you are passing an uninitialized
integer value as a pointer to <code>scanf</code>.</p>

<p>The correct call would be</p>

<pre><code>scanf(""%d"", &amp;p-&gt;semester);
</code></pre>

<p>Usually once uses <code>malloc</code> because one need objects that live outside the scope
of function, for example with linked lists, trees, etc. But also when you need
an array whose dimension is not known on compiler time.</p>

<p>Your <code>init_record</code> seems to me pointless, because you know the size of the
arrays and they are even small, you could easily change your struct to</p>

<pre><code>struct student {
    char number[6];
    char name[40];
    int semester;
    float grades[5];
};
</code></pre>

<p>and then you wouldn't need to do the <code>malloc</code> calls.</p>

<p>Also, you would need to do the <code>scanf</code> like this:</p>

<p>int c;</p>

<pre><code>scanf(""%39s"", p-&gt;name);
while((c = getchar()) != '\n' &amp;&amp; c != EOF); // clearing the buffer

scanf(""%5s"", p-&gt;number);
while((c = getchar()) != '\n' &amp;&amp; c != EOF); // clearing the buffer

...
</code></pre>

<p>to prevent buffer overflows if the user enters a name/number that are too large
for the buffer.</p>

<hr>

<p><strong>edit</strong></p>

<blockquote>
  <p><em>OP asked in the comments</em></p>
  
  <p>One last thing: I wanted to replace scanf with <code>gets</code> in the case of name, because I want a name and a surname to be saved as one piece(including space). But when I replaced scanf, I got this error: request for member 'name' in something not a structure or union. I searched over here for a similar problem but I didn't find any solution. Can you suggest one?</p>
</blockquote>

<p>Don't use <code>gets</code>, this is a dangerous function because it doesn't take the
size of the array into account and if the entered text is larger than the buffer
size, it will overflow and cause a lot of damage. The error message is due to a
syntax error, as you don't show the code, I cannot say what you did wrong.
However, if you take my advice, you won't have this error.</p>

<p>In general I advice not to use <code>scanf</code> to read from the user, because <code>scanf</code>
was not designed to do so. Specially when you want to read strings that have
empty spaces, it's better to read the whole line with <code>fgets</code> and
parse the line later using other functions like <code>strchr</code>, <code>strstr</code>, <code>strtok</code>,
<code>sscanf</code>, <code>strtol</code>, etc. Which function to use depends on what you are trying to
read from the user. In this case where you are reading strings, <code>fgets</code> would
give better results. So I'd change your whole reading process to this:</p>

<pre><code>int read_record(RECORD *p)
{
    char line[1024];

    printf(""Please give the name: "");
    if(fgets(line, sizeof line, stdin) == NULL)
    {
        fprintf(stderr, ""Could not read name\n"");
        return 0; // error
    }

    line[strcspn(line, ""\n"")] = 0; // removing newline
    strncpy(p-&gt;name, line, sizeof p-&gt;name);
    p-&gt;name[sizeof(p-&gt;name) - 1] = 0; // making sure to get a valid string

    printf(""Please give AM number: "");
    if(fgets(line, sizeof line, stdin) == NULL)
    {
        fprintf(stderr, ""Could not read AM number\n"");
        return 0;
    }

    line[strcspn(line, ""\n"")] = 0; // removing newline
    strncpy(p-&gt;number, line, sizeof p-&gt;name);
    p-&gt;name[sizeof(p-&gt;number) - 1] = 0; // making sure to get a valid string

    // this is ok, this can stay like this
    printf(""Please give semester: "");
    scanf(""%d"", &amp;p-&gt;semester);

    printf(""Please give grades: "");
    if(fgets(line, sizeof line, stdin) == NULL)
    {
        fprintf(stderr, ""Could not read grades\n"");
        return 0;
    }

    if(sscanf(line, ""%f %f %f %f %f"",
                p-&gt;grades, p-&gt;grades + 1, p-&gt;grades + 2, p-&gt;grades + 3,
                p-&gt;grades + 4) != 5)
    {
        fprintf(stderr, ""Could not read 5 grades\n"");
        return 0;
    }

    return 1; // success
}
</code></pre>

<p>I know that it is much more code that you have before, but this code is more
robust, it handles cases where the user did input the wrong format, your code
can react to that, print error messages, retry the user input, whatever. With
your the error manifest themselves when the data printed on screen or a file is
strange.</p>

<p>Note how I copied the string:</p>

<pre><code>strncpy(p-&gt;name, line, sizeof p-&gt;name);
p-&gt;name[sizeof(p-&gt;name) - 1] = 0; // making sure to get a valid string
</code></pre>

<p>Here I assuming that you've changed the struct to hold arrays like I said in the
first part of the answer. If you didn't change that and you are still using the
old way by <code>malloc</code>ing with a hardcoded fixed size, you will have to use the
hardcoded fixed size here as well:</p>

<pre><code>strncpy(p-&gt;name, line, 40);
p-&gt;name[39] = 0; // making sure to get a valid string
</code></pre>

<p>And you see why I prefer when the struct has the array, because with <code>sizeof</code> I
can get the size regardless of the dimension.</p>

<p>The other thing to notice here is that I used <code>strncpy</code> instead of <code>strcpy</code>.
<code>strcpy</code> suffers from the same problems as <code>gets</code>, it doesn't take the size of
the destination buffer into consideration and if the source string is larger
than the destination buffer, it will overflow the buffer.</p>

<p><code>strncpy</code> works like <code>strcpy</code> except that you pass how many bytes there is
available for the destination buffer. If the source is larger than that number,
then <code>strncpy</code> will <strong>not</strong> writing bytes in the destination, thus preventing a
buffer overflow. Of course if the <code>'\0'</code>-terminating byte is not among the
copied bytes, it won't be written in the destination buffer. <code>p-&gt;name[39] = 0;</code>
just makes sure that the string is <code>'\0'</code>-terminated, no matter how long the
source was.</p>
",7
48248605,48247625,0,"<p>While calling <code>IMG_Init()</code> should be optional, you can use it to check that the image format loading has been registered properly. Could be something wrong with your SDL installation and the program not finding <code>libpng</code>.</p>

<p><a href=""https://www.libsdl.org/projects/SDL_image/docs/SDL_image_8.html"" rel=""nofollow noreferrer"">https://www.libsdl.org/projects/SDL_image/docs/SDL_image_8.html</a></p>
",1
48247677,48247625,1,"<p>You have to provide the path without <code>~</code>, eg. <code>/home/thomas/Workspace/learnSDL/red.png</code></p>

<p><code>~</code> is expanded by the shell, you can't use it like that on your own program.</p>

<p>On Windows you also need to have <code>SDL_image.dll</code>, libpng and zlib DLLs in your running directory.</p>
",1
49624200,49624132,0,"<p>In that little piece of code you have <em>multiple</em> problems.</p>

<p>The first, about the error you get, you should have been told by just about any book or tutorial, good or bad. You need to use the ""arrow"" operator <code>-&gt;</code>, as in <code>p-&gt;name</code>.</p>

<p>But then you would get another error, because you can't assign to an array, only <a href=""http://en.cppreference.com/w/c/string/byte/strcpy"" rel=""nofollow noreferrer""><em>copy</em></a> to it.</p>

<p>And when that's done, you still have one more error, and that is your use of an uninitialized pointer. Uninitialized local variables (which is what <code>p</code>) is are really uninitialized. Their values will be <em>indeterminate</em> and seemingly random. Attempting to dereference (what you do with <code>-&gt;</code>) such a pointer will lead to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>.</p>

<p>In short, I recommend you to go back to your text book, and start over from the beginning.</p>
",0
49714208,49713657,1,"<p>The problem is with your inner while() loop - <code>while(curptr-&gt;next!=NULL)</code>.  Namely, it never breaks! It's an infinite loop. To get your code working, you should try this:</p>

<pre><code>    while(curptr-&gt;next!= NULL) {
        prvptr = curptr;
        curptr = curptr-&gt;next;
        if(curptr-&gt;data &gt; NTA) {
            prvptr-&gt;next = newptr;
            newptr-&gt;next = curptr;
            break;
        }
        else if(curptr-&gt;next == NULL){
            curptr-&gt;next = newptr;
            break;
        }
    }
</code></pre>

<p>A few notes:</p>

<ul>
<li>I added two <code>break</code> statements.  Right now the loop will continue until <code>curptr-&gt;next</code> is null, but you insert your node in the first <code>if()</code> statement.  To continue the loop after that would result in double insertion, which is likely NOT what you are wanting.</li>
<li>You are currently executing <code>curptr = curptr-&gt;next;</code> at the start of the while() loop, and then you execute it <em>again</em> in the nestled <code>else</code> block - that would be jumping over two list items, which again is likely NOT what you are wanting.</li>
<li>I strongly suggest you take some time to write out the logic of your program on paper first.  Your <code>head</code> pointer will never have associated data, which is uncommon in linked lists.  You don't handle a situation where the <code>while(curptr-&gt;next!=NULL)</code> loop exists without having made an insertion (which is obviously the intent of the loop), the <code>input</code> argument has no usage in the function, et cetera.</li>
</ul>

<p>Linked lists can be tough to learn, so take it slow.  Right now it's difficult to identify what exactly you're intending each piece of the code to do, and you don't have much error handling.  That makes it difficult to ""fix"" your code, but the code block above should get the code <em>running</em> - from there on out you'll need to address the <em>logic</em> issues in your code.</p>
",0
49868476,49868438,0,"<p>Your <code>index</code> calculation is <code>index = input % 10;</code>. The number 10, mod 10, is 0, so it goes in the first index (index 0) of your table, before 1-9 (which would go in indices 1 through 9). Since your printer prints the buckets in order from index 0 to 9 inclusive, 10 is output first.</p>

<p>The nature of hash tables is to have limited ordering (most languages and hash table libraries give no guarantees at all on the iteration order of a hash table); I wouldn't be bothered by 10 happening to appear first in the output.</p>
",0
48997242,48997202,0,"<p><code>list</code> is a pointer to a pointer. The actual list is in the value it points to, so you need to dereference it.</p>

<p>An empty list is just a null pointer, so you don't need to allocate anything in <code>init()</code>.</p>

<pre><code>void init(SortedList** list)
{
    *list=NULL;
    printf(""%p\n"", *list);
}
void isEmpty(SortedList** list)
{
    printf(""%p\n"", *list);
    if(*list == NULL) printf(""List is empty\n"");]
}
</code></pre>

<p>And in the <code>main</code> function, you don't need a double pointer, you use the <code>&amp;</code> (address-of) operator to get the address of a pointer variable.</p>

<pre><code>int main()  
{
    SortedList *list;
    init(&amp;list);
    printf(""Initialization with succes\n"");
    isEmpty(&amp;list);

    return 0;
}
</code></pre>

<p>You only really need double pointers for functions that modify the list. So you could use an ordinary pointer for <code>isEmpty</code>:</p>

<pre><code>void isEmpty(SortedList* list)
{
    printf(""%p\n"", list);
    if(list == NULL) printf(""List is empty\n"");]
}
</code></pre>

<p>and then call it as:</p>

<pre><code>isEmpty(list);
</code></pre>

<p>But it's probably simplest to be consistent across all your functions.</p>
",1
48703511,48703469,2,"<p>For any array or pointer <code>arr</code> and index <code>i</code>, the expression <code>arr[i]</code> is exactly equal to <code>*(arr + i)</code>.</p>

<p>Now considering that arrays naturally can decay to pointers to their first element, <code>arr + i</code> is a pointer to element <code>i</code>.</p>
",3
50532860,50532818,4,"<p>Yes, you need to read the documentation of <a href=""http://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer"">printf</a>. Read it carefully and several times.</p>

<p>You should compile <a href=""https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html"" rel=""nofollow noreferrer"">with</a> all warnings and debug info, i.e. using <code>gcc -Wall -Wextra -g</code> with <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a>. Improve your code to get no warnings. Then <a href=""https://sourceware.org/gdb/current/onlinedocs/gdb/"" rel=""nofollow noreferrer"">use the <code>gdb</code> debugger</a> to understand the behavior of your program.</p>

<p>On the second example (where I added the missing but mandatory <code>#include &lt;stdio.h&gt;</code>) GCC 8.1 gives on Linux/x86-64/Debian:</p>

<pre><code> % gcc -Wall -Wextra -g m.c -o myprog 
m.c:3:1: warning: return type defaults to ¡®int¡¯ [-Wimplicit-int]
 main()
 ^~~~
m.c: In function ¡®main¡¯:
m.c:6:29: warning: operation on ¡®k¡¯ may be undefined [-Wsequence-point]
  printf(""\n%d %d %d"",k==35,k=50,k&gt;40);
                            ~^~~
m.c:6:29: warning: operation on ¡®k¡¯ may be undefined [-Wsequence-point]
</code></pre>

<p>Also, as explained by <a href=""https://stackoverflow.com/a/50532867/841108"">John's H answer</a> the order of evaluation of arguments is undefined (and the compiler gives some clue). A good way to think of it is to believe it is random and could dynamically change (but few implementations behave like that), and to write your source code in such way that won't change the intended behavior of your program.</p>

<p>In  </p>

<pre><code>printf(""\n%d %d %d"",k==35,k=50,k&gt;40);
//                         ^
</code></pre>

<p>you have an assignment operator. So <code>k</code> is changing. But you don't know exactly when (it could happen after or before the <code>k==35</code> and <code>k&gt;40</code> comparisons). So you have <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><strong>undefined behavior</strong></a>, be very <a href=""https://stackoverflow.com/a/46526702/841108"">scared</a>!</p>

<p>At last, stdout is often buffered (see <a href=""http://man7.org/linux/man-pages/man3/setvbuf.3.html"" rel=""nofollow noreferrer"">setvbuf(3)</a> &amp; <a href=""http://man7.org/linux/man-pages/man3/stdio.3.html"" rel=""nofollow noreferrer"">stdio(3)</a> for more) and usually line buffered. So the buffer could be flushed by the <code>\n</code> which you'll better place at the end of the format control string. Otherwise, ensure flushing by calling <a href=""http://man7.org/linux/man-pages/man3/fflush.3.html"" rel=""nofollow noreferrer"">fflush(3)</a>.</p>
",0
55641681,55641622,2,"<p>Because in <code>RastgeleKarakter.h</code> you declared </p>

<p><code>char RastgeleKarakterOlustur(const RastgeleKarakter);</code></p>

<p>and in <code>RastgeleKarakter.c</code> you defined</p>

<p><code>RastgeleKarakter RastgeleKarakterOlustur() {...}</code></p>

<p>They are of same function name, but with different signature. You may consider to change one of them.</p>
",1
58689148,58688975,-1,"<p>Note that (if you are going to remove all comas from string), the resulting string may be shorter than source one. And there is no real ""string"" type in C - it's only array of chars.</p>

<p>I think, that proper way will be:</p>

<ol>
<li>Count number of commas in source string</li>
<li>Calculate length of resulting string and reserve enough memory for it</li>
<li>Iterate throug characters of source string, and copy them to resulting string, if they are not commas</li>
</ol>
",0
48979475,48979393,2,"<blockquote>
  <p>Is there a way for the Library to know how to iterate and go through member fields and see if there's a pointer to such function and call it available.</p>
</blockquote>

<p>No there is not.</p>

<p>Your best bet is to create a structure in the library that has these members, and pass that structure instead of <code>void*</code>.</p>
",3
48979783,48979393,1,"<p>If the library has 0 information about the possible struct types, then you
cannot do it. The library has to get somehow the information or the offsets.</p>

<p>The only way I can think of is:</p>

<ol>
<li>All <code>register</code> member have the same prototype</li>
<li>Pass the offset to the function.</li>
</ol>

<p>I created an example of this</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdint.h&gt;

// function that does not know anything about any struct
void reg(void *data, size_t offset)
{
    uintptr_t *p = (uintptr_t*) (((char*) data) + offset);

    void (*reg)() = (void(*)()) *p;

    reg();
}


struct A {
    int c;
    void (*reg)();
};

struct B {
    int b;
    int c;
    void (*reg)();
};

void reg_a()
{
    printf(""reg of A\n"");
}

void reg_b()
{
    printf(""reg of B\n"");
}

int main(void)
{
    struct A a;
    struct B b;

    a.reg = reg_a;
    b.reg = reg_b;


    reg(&amp;a, offsetof(struct A, reg));
    reg(&amp;b, offsetof(struct B, reg));
    return 0;
}
</code></pre>

<p>This prints:</p>

<pre><code>$ ./c 
reg of A
reg of B
</code></pre>

<p>I run it with valgrind and I did not get any errors nor warnings. I'm not sure if
this violates somehow strict aliasing rules or yields undefined behaviour
because of the <code>uintptr_t*</code> conversions, but at least it seems to work.</p>

<p>I think however, the more cleaner solution is to rewrite the <code>register</code> (btw. <code>register</code>
is a keyword in C, you cannot use that for a function name) function to
accept a function pointer and possible parameters, something like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void reg(void (*func)(va_list), int dummy, ...)
{
    if(func == NULL)
        return;

    va_list ap;
    va_start(ap, dummy);
    func(ap);
    va_end(ap);
}


void reg1(int a, int b)
{
    printf(""reg1, a=%d, b=%d\n"", a, b);
}

void vreg1(va_list ap)
{
    int a = va_arg(ap, int);
    int b = va_arg(ap, int);
    reg1(a, b);
}

void reg2(const char *text)
{
    printf(""reg2, %s\n"", text);
}

void vreg2(va_list ap)
{
    const char *text = va_arg(ap, const char*);
    reg2(text);
}

int main(void)
{
    reg(vreg1, 0, 3, 4);
    reg(vreg2, 0, ""Hello world"");
    return 0;
}
</code></pre>

<p>This has the output:</p>

<pre><code>reg1, a=3, b=4
reg2, Hello world
</code></pre>

<p>Note that <code>reg</code> has a <code>dummy</code> parameter. I do that because the man page of
<code>stdarg</code> says:</p>

<blockquote>
  <p><em><a href=""https://linux.die.net/man/3/stdarg"" rel=""nofollow noreferrer"">man stdarg</a></em></p>
  
  <p><code>va_start()</code>:</p>

<pre><code>[...]
</code></pre>
  
  <p>Because the address of this argument may be used in the <code>va_start()</code> macro,
  <strong>it should not be declared as a register variable, or as a
  function or an array type.</strong></p>
</blockquote>
",0
48531834,48531444,1,"<p>After reading the original question, I think I understand what you are asking.</p>

<p>So in the other question the input was:</p>

<pre><code>5&lt;ENTER&gt;
1 2 3 4 99&lt;ENTER&gt;
</code></pre>

<p><code>scanf</code> is a function design to read formatted input (the name comes from scan
formatted), it is not design to read random user input.</p>

<p>To quote the man page of scanf:</p>

<blockquote>
  <p><em><a href=""https://linux.die.net/man/3/scanf"" rel=""nofollow noreferrer"">man scanf</a></em></p>

<pre><code>#include &lt;stdio.h&gt;

int scanf(const char *format, ...);
</code></pre>
  
  <p><strong>DESCRIPTION</strong></p>
  
  <p>The <code>scanf()</code> family of functions scans input according to <code>format</code> as described below. This format may contain <code>conversion specifications</code>;
  the results from such conversions, if any, are stored in the locations pointed to by the pointer arguments that  follow  format.   Each
  pointer argument must be of a type that is appropriate for the value returned by the corresponding conversion specification.</p>
</blockquote>

<p>That means that scanf scans the input according to the provided format. The
<strong>conversion specifier</strong> <code>%d</code> matches an optionally signed decimal integer. If
your format contains only <code>""%d""</code> it will consume any white-space characters and
try to convert the next sequence of non-white-space characters into an <code>signed int</code>. If this is possible, <code>scanf</code> will
store the converted integer in the memory pointed to by the passed argument. If
it fails at converting, it stops scanning and any other character in the input
buffer <strong>will remain</strong> in the input buffer.</p>

<p>So let's to this: You enter 3 numbers like this:<br>
<kbd>3</kbd><kbd>SPACE</kbd><kbd>SPACE</kbd><kbd>4</kbd><kbd>SPACE</kbd><kbd>TAB</kbd><kbd>5</kbd><kbd>ENTER</kbd></p>

<p>Your input buffer will look like this:</p>

<pre class=""lang-none prettyprint-override""><code>+---+---+---+---+---+----+---+----+
| 3 | ? | ? | 4 | ? | \t | 5 | \n |
+---+---+---+---+---+----+---+----+
</code></pre>

<p>In the first iteration <code>scanf</code> consume any white-space characters, right now
there is none, so it will read 3 and continue with the next character
which is a space. At that point it stops and converts the 3 and stores it in
<code>&amp;v[i]</code>. The input buffer will look like this:</p>

<pre class=""lang-none prettyprint-override""><code>+---+---+---+---+----+---+----+
| ? | ? | 4 | ? | \t | 5 | \n |
+---+---+---+---+----+---+----+
</code></pre>

<p>In the second iteration it will consume any white-space characters. There are
two spaces there and those are just consumed. Then it will read 4, and then a
white-space character. <code>scanf</code> stops and and converts the 4 and stores it in
<code>&amp;v[i]</code>. The input buffer will look like this:</p>

<pre class=""lang-none prettyprint-override""><code>+---+----+---+----+
| ? | \t | 5 | \n |
+---+----+---+----+
</code></pre>

<p>As you can see, in every iteration <code>scanf</code> didn't wait block and wait for the
user to enter something, because characters were left in the input buffer from
the previous iterations.</p>

<p>And that's why you can have <code>scanf(""%d"", &amp;v[i])</code> in a loop for an input like
this <code>""1 2 3 4 5""</code>.</p>
",2
50980843,50979739,4,"<p>Here's the result of my quick scan of K&amp;R ""The C Programming Language, 2nd Edn"".</p>

<p>Chapter 1 ""A Tutorial Introduction"":</p>

<ul>
<li>1.1 ""Hello world"" ¡ª 0 globals</li>
<li>1.2 ""Fahrenheit to Centigrade"" ¡ª 0 globals</li>
<li>1.3 ""For Loops"" ¡ª 0 globals</li>
<li>1.4 ""Symbolic constants"" ¡ª 0 globals</li>
<li>1.5 ""Character, line, word counting"" ¡ª 0 globals</li>
<li>1.6 ""Arrays"" ¡ª 0 globals</li>
<li>1.7 ""Functions"" ¡ª 0 globals</li>
<li>1.8 ""Arguments"" ¡ª 0 globals</li>
<li>1.9 ""Character arrays"" ¡ª 0 globals</li>
<li>1.10 ""External variables and scope"" ¡ª?3 global variables in an adaptation of the code from ¡ì1.9 where the equivalent functions use no globals</li>
</ul>

<p>Chapter 2 ¡ª Types, operators and expressions</p>

<ul>
<li>2.1¡ª2.12 ¡ª 1 definitively global variable and a number that could be local or global.</li>
</ul>

<p>Chapter 3 ¡ª?Control flow</p>

<ul>
<li>3.1¡ª3.8 ¡ª 0 globals</li>
</ul>

<p>Chapter 4 ¡ª Functions and program structure</p>

<ul>
<li>4.1 ""Basics of functions"" ¡ª 1 global</li>
<li>4.2 ""Functions returning non-integers"" ¡ª 0 globals</li>
<li>4.3 ""External variables"" ¡ª?4 globals</li>
<li>4.4 ""Scope rules"" ¡ª 1 pair of globals, several times over (repeating from 4.3)</li>
<li>4.5 ""Header files"" ¡ª 0 globals</li>
<li>4.6 ""Static variables"" ¡ª 2 file scope <code>static</code> variables (repeating from 4.3 again).</li>
<li>4.7 ""Register variables"" ¡ª 0 globals</li>
<li>4.8 ""Block structure"" ¡ª 2 globals (to make the point that local variables hide global ones)</li>
<li>4.9 ""Initialization"" ¡ª?0 definitively global; 5 could be global or local</li>
<li>4.10 ""Recursion"" ¡ª 0 globals</li>
<li>4.11 ""Preprocessor"" ¡ª 0 globals</li>
</ul>

<p>Chapter 5 ¡ª Pointers and arrays</p>

<ul>
<li>5.1 ""Pointers and addresses"" ¡ª 0 definitively global; 3 could be global or local</li>
<li>5.2 ""Pointers and arguments"" ¡ª 0 globals</li>
<li>5.3 ""Pointers and arrays"" ¡ª 0 definitively global; 2 could be global or local</li>
<li>5.4 ""Address arithmetic"" ¡ª?2 file scope <code>static</code></li>
<li>5.5 ""Character pointers and functions"" ¡ª 0 definitively global; 2 could be global or local</li>
<li>5.6 ""Pointer arrays and pointers to pointers"" ¡ª 1 global</li>
<li>5.7 ""Multi-dimensional arrays"" ¡ª 1 global</li>
<li>5.8 ""Initialization"" ¡ª 0 globals</li>
<li>5.9 ""Pointers vs Multi-dimensional arrays"" ¡ª 0 definitively global; 4 could be global or local</li>
<li>5.10 ""Command line arguments"" ¡ª 0 globals</li>
<li>5.11 ""Pointers to functions"" ¡ª 1 global</li>
<li>5.12 ""Complicated declarations"" ¡ª 5 globals</li>
</ul>

<p>Chapter 6 ¡ª Structures</p>

<ul>
<li>6.1 ""Basics of structures"" ¡ª 0 definitively global; some could be global or local</li>
<li>6.2 ""Structures and functions"" ¡ª 0 definitively global; some could be global or local</li>
<li>6.3 ""Arrays of structures"" ¡ª 1 global; 2 could be global or local</li>
<li>6.4 ""Pointers to structures"" ¡ª 0 globals</li>
<li>6.5 ""Self-referential structures"" ¡ª 0 globals</li>
<li>6.6 ""Table lookup"" ¡ª 1 global</li>
<li>6.7 ""Typedef"" ¡ª 0 definitively global; some could be global or local</li>
<li>6.8 ""Unions"" ¡ª 0 definitively global; 1 could be global or local</li>
<li>6.9 ""Bit-fields"" ¡ª?0 globals</li>
</ul>

<p>Chapter 7 ¡ª Input and output</p>

<ul>
<li>7.1 ""Standard input and output"" ¡ª 0 globals</li>
<li>7.2 ""Formatted output ¡ª printf"" ¡ª 0 globals</li>
<li>7.3 ""Variable-length argument lists"" ¡ª 0 globals</li>
<li>7.4 ""Formatted input ¡ª scanf"" ¡ª 0 definitively global; some could be global or local</li>
<li>7.5 ""File access"" ¡ª 0 globals</li>
<li>7.6 ""Error handling ¡ª stderr and exit"" ¡ª?0 globals</li>
<li>7.7 ""Line input and output"" ¡ª 0 globals</li>
<li>7.8 ""Miscellaneous functions"" ¡ª 0 globals; 1 could be global or local</li>
</ul>

<p>Chapter 8 ¡ª The Unix system interface</p>

<ul>
<li>8.1 ""File descriptors"" ¡ª 0 globals</li>
<li>8.2 ""Low level I/O ¡ª read and write"" ¡ª 0 globals (3 function static variables)</li>
<li>8.3 ""Open, creat, close, unlink"" ¡ª 0 definitively global; 1 might be global but probably isn't</li>
<li>8.4 ""Random access"" ¡ª 0 globals</li>
<li>8.5 ""Example implementation of fopen and getc"" ¡ª 1 global</li>
<li>8.6 ""Listing directories"" ¡ª 0 globals</li>
<li>8.7 ""Storage allocator"" ¡ª 2 globals</li>
</ul>

<p>In my opinion, that is not a lot globals.  Most of the 'could be global or local' variables would be local in practice, but the context isn't quite big enough to make that definitive.  In almost every case where there are globals, there are sound reasons to use those specific globals, though there are also undoubtedly alternative designs that could avoid most of those.</p>
",0
58806681,58806018,0,"<p>First, <code>int a=61,i=-5;</code> gives us <code>a</code> = 61 and <code>i</code> = ?5.</p>

<p>Then the initial clause of the <code>for</code>, <code>int *p=&amp;i</code>, sets <code>p</code> to point to <code>i</code>. From this point on, we may take <code>*p</code> as equivalent to <code>i</code>.</p>

<p>Then the controlling expression of the <code>for</code>, <code>(a++,(*p)++)?(++(*p),(a--)-1):((*p)+=3,a-1)</code>, is evaluated. Its highest/outermost operator is <code>? :</code>. The first operand of that <code>(a++,(*p)++)</code> is evaluated. This sets <code>a</code> to 62 and <code>i</code> to ?4. The result, from the comma operator, is the value of <code>i</code> (<code>*p</code>) before the increment, so it is ?5.</p>

<p>That ?5 is used to select in the <code>? :</code> operation. Since it is not zero, the operand between <code>?</code> and <code>:</code> is evaluated. That is <code>(++(*p),(a--)-1)</code>. This sets <code>i</code> to ?3 and <code>a</code> to 61. The value is <code>a</code> before the increment minus 1, which is 62?1 = 61. Thus the expression is non-zero, indicating the loop should continue.</p>

<p>Program control flows into the body of the <code>for</code>, where <code>--a</code> decrements <code>a</code> to 60.</p>

<p>Then the <code>printf</code> shows us that <code>a</code> is 60 and <code>i</code> is ?3.</p>

<p>The test <code>*p&gt;3</code> is false, since <code>i</code> is ?3, so the <code>continue</code> is executed.</p>

<p>This causes the iteration expression of the <code>for</code> to be evaluated. That is <code>(*p)++</code>, so <code>i</code> is set to ?2.</p>

<p>Then the controlling expression is evaluated. As before, the first operand of <code>? :</code>, <code>(a++,(*p)++)</code>, is evaluated. This sets <code>a</code> to 61 and <code>i</code> to ?1, and the value of the expression is ?2.</p>

<p>Again the second operand,(++(*p),(a--)-1), is evaluated. This sets <code>i</code> to 0 and <code>a</code> to 60, and its value is 59.</p>

<p>Inside the body, <code>--a</code> decrements <code>a</code> to 59.</p>

<p>The <code>printf</code> shows us <code>a</code> is 59 and <code>i</code> is 0.</p>

<p>Again <code>*p&gt;3</code> is false, so the <code>continue</code> is executed.</p>

<p>This takes control to the iteration expression, <code>(*p)++</code>, which sets <code>i</code> to 1.</p>

<p>Then the controlling expression is evaluated, starting with the first operand of <code>? :</code>. Now <code>(a++,(*p)++)</code> sets <code>a</code> to 60 and <code>i</code> to 2, and the expression value is 1.</p>

<p>The second operand of <code>? :</code>,(++(*p),(a--)-1), is evaluated, which sets <code>i</code> to 3 and <code>a</code> to 59, and the expression value is 59, so the loop continues.</p>

<p><code>--a</code> sets a to 58.</p>

<p>The <code>printf</code> shows us <code>a</code> is 58 and <code>i</code> is 3.</p>

<p>Again <code>*p&gt;3</code> is false, so the <code>continue</code> is executed.</p>

<p>This takes control to the iteration expression, <code>(*p)++</code>, which sets <code>i</code> to 4.</p>

<p>Then the controlling expression is evaluated, starting with the first operand of <code>? :</code>. Now <code>(a++,(*p)++)</code> sets <code>a</code> to 59 and <code>i</code> to 5, and the expression value is 4.</p>

<p>The second operand of <code>? :</code>,(++(*p),(a--)-1), is evaluated, which sets <code>i</code> to 6 and <code>a</code> to 58, and the expression value is 58, so the loop continues.</p>

<p><code>--a</code> sets a to 57.</p>

<p>The <code>printf</code> shows us <code>a</code> is 57 and <code>i</code> is 6.</p>

<p>Now <code>*p&gt;3</code> is true, so the statements inside the <code>if</code> are executed.</p>

<p>These start with <code>a=(!(--a)&amp;&amp;a++)?3:2;</code>. Here <code>--a</code> sets <code>a</code> to 56 and evaluates to that value. Then <code>!</code> inverts it logically, producing 0. This causes the <code>&amp;&amp;</code> to produce 0 without evaluating its second operand. So this first operand of <code>? :</code> is 0, which results in the third operand of <code>? :</code> being evaluated. That operand is 2, so that is the value assigned to <code>a</code>.</p>

<p>The final <code>printf</code> shows us the current value of <code>a</code>, 2.</p>
",0
58806081,58806018,0,"<p>The <code>(*p)++</code> statement at the end of the for loop declaration will not be executed on the first iteration. It gets executed only between two consecutive iterations.</p>
",1
50074878,50074855,3,"<p>The <code>%s</code> format specifier requires a pointer to a string. When used with <code>scanf</code>, it must be a <code>char</code> array with enough characters for the word you enter plus the trailing null byte that indicates the end of the string. In <code>printf()</code> it has to be a null-terminated <code>char</code> array.</p>

<p>Using a pointer to a <code>char</code> variable doesn't work, because it doesn't have room for the null byte. You're causing undefined behavior by writing outside the variable.</p>

<pre><code>char word[100];
scanf(""%s"", word);
printf(""%s\n"", word);
</code></pre>

<p>You can use <code>%c</code> to read and write a single character rather than a string of multiple characters. </p>

<pre><code>char letter;
scanf(""%c"", &amp;letter);
printf(""%c\n"", letter);
</code></pre>
",0
48999553,48993408,1,"<p>The problem with your approach:</p>

<pre><code>char asd[31];
strncpy(asd, name, 31);
</code></pre>

<p>is that <code>asd</code> will not exist once the function returns since <code>asd</code> is just a local array. </p>

<p>The solution given by <code>Eziz</code> is also wrong.</p>

<pre><code>struct truck create_truck(const char *name, double length, double weight, struct cargo crg) {
    char *asd;

    if( (asd = malloc( strlen(name)+1 )) == NULL ) {
        printf( ""Memory error!\n"" );
        exit( 0 );
    }
    strcpy(asd, name);

    struct truck lol = { asd, length, weight, crg };

    free(asd); // free here (wrong)

    return lol;
}
</code></pre>

<p>Once we free <code>asd</code> your <code>char * name</code> in
struct truck {</p>

<pre><code>char *name; // POINTER TO A MEMORY
//...
}   
</code></pre>

<p>points to the freed memory!</p>

<p>What you need is to make sure that <code>char *name</code> points to valid memory holding the name, than all what you need is:</p>

<pre><code>struct truck create_truck(char *name, double length, double weight, struct cargo crg)
{
    struct truck lol = { name, length, weight, crg };
    return lol;
}
</code></pre>

<p>The test program is below, let me know if it works for you.</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

//Cargo: what the truck is carrying
struct cargo {
    const char *title;
    int quantity;
    double weight;
};

// Define the truck structure here
struct truck {
    char *name;       // has to point to a valid memory holding the name
    double length;
    double weight;
    struct cargo crg;
};

struct truck create_truck(char *name, double length, double weight, struct cargo crg)
{
    struct truck lol = { name, length, weight, crg };
    return lol;
}

/*This function is just for printing the parts of the data structure I made*/
void print_truck(const struct truck *car) {

    printf(""%s\n"", car-&gt;name);
    printf(""%.1lf\n"", car-&gt;length);
    printf(""%.1lf\n"", car-&gt;weight);
    printf(""%s\n"", car-&gt;crg.title);
    printf(""%d\n"", car-&gt;crg.quantity);
    printf(""%.1lf\n\n"", car-&gt;crg.weight);
}

int main()
{
    struct cargo c = { ""Bananas"", 10000, 1500 };
    //1.    
    char name1[] = { 'F', 'O', 'R','D', 0};
    //2.
    char *name2 = ""TOYOTA""; 
    //3.
    char *name3 = (char[]){'M', 'I', 'N', 'I', 0};
    //4.
    size_t len4 = strlen(""LADA"") + 1;
    char *name4 = malloc(len4*sizeof(char));
    strcpy(name4,""LADA"");  

    //5. warning: strdup is not part of the C or C++ standard, it's a POSIX function.
    char *name5 = strdup(""HONDA"");  

    // 0.
    struct truck t = create_truck(""Mercedes-Benz Actros"", 12.0, 12.5, c);
    print_truck(&amp;t);

    // 1.
    struct truck t1 = create_truck(name1, 12.0, 12.5, c);
    print_truck(&amp;t1);

    // 2.
    struct truck t2 = create_truck(name2, 12.0, 12.5, c);
    print_truck(&amp;t2);

    // 3.
    struct truck t3 = create_truck(name3, 12.0, 12.5, c);
    print_truck(&amp;t3);

    // 4.
    struct truck t4 = create_truck(name4, 12.0, 12.5, c);
    print_truck(&amp;t4);

    // 5.
    struct truck t5 = create_truck(name5, 12.0, 12.5, c);
    print_truck(&amp;t5);


    free(name4);
    free(name5);

    return 0;
}
</code></pre>

<p>Output of the program:</p>

<pre><code>Mercedes-Benz Actros                                                                                                         
12.0                                                                                                                         
12.5                                                                                                                         
Bananas                                                                                                                      
10000                                                                                                                        
1500.0                                                                                                                       

FORD                                                                                                                         
12.0                                                                                                                         
12.5                                                                                                                         
Bananas                                                                                                                      
10000                                                                                                                        
1500.0                                                                                                                       

TOYOTA                                                                                                                       
12.0                                                                                                                         
12.5                                                                                                                         
Bananas                                                                                                                      
10000                                                                                                                        
1500.0 

MINI                                                                                                                         
12.0                                                                                                                         
12.5                                                                                                                         
Bananas                                                                                                                      
10000                                                                                                                        
1500.0                                                                                                                       

LADA                                                                                                                         
12.0                                                                                                                         
12.5                                                                                                                         
Bananas                                                                                                                      
10000                                                                                                                        
1500.0                                                                                                                       

HONDA                                                                                                                        
12.0                                                                                                                         
12.5                                                                                                                         
Bananas                                                                                                                      
10000                                                                                                                        
1500.0    
</code></pre>
",2
48993784,48993408,0,"<p>If you allocate <code>struct truck</code> on the stack in <code>main()</code> you should provide a pointer to it in the call to <code>crate_truck()</code> (and perhaps rename <code>create_truck()</code> to <code>initaialize_truck()</code> since it doesn't actually create it). Something like this:</p>

<pre><code>void initialize_truck(struct truck* lol,const char *name, double length, double weight,struct cargo* crg){
    lol-&gt;name = strdup(name);
    lol-&gt;length = length;
    lol-&gt;weight = weight;
    /* This is kind of a hack, you should either deep copy or just have a pointer to cargo. */
    memcpy(&amp;lol-&gt;crg,crg,sizeof(struct cargo));
}

main(){
    struct cargo c = { ""Bananas"", 10000, 1500 };
    struct truck t;
    initialize_truck(&amp;t, ""Mercedes-Benz Actros"", 12.0, 12.5, &amp;c);
    print_truck(&amp;t);
    return 0;
}
</code></pre>

<p>Or, as an alternative, dymamically allocate <code>struct truck</code> instead of putting it on the stack:</p>

<pre><code>struct truck create_truck(const char *name, double length, double weight,struct cargo* crg){
    struct truck* lol = (struct truck*)malloc(sizeof(struct truck));
    lol-&gt;name = strdup(name);
    lol-&gt;length = length;
    lol-&gt;weight = weight;
    /* This is kind of a hack, you should either deep copy or just have a pointer to cargo. */
    memcpy(&amp;lol-&gt;crg,crg,sizeof(struct cargo));
    return lol;
}

main(){
    struct cargo c = { ""Bananas"", 10000, 1500 };
    struct truck* t = create_truck(""Mercedes-Benz Actros"", 12.0, 12.5, &amp;c);
    print_truck(t);
    return 0;
}
</code></pre>
",1
49110210,49110058,0,"<p>You should include a header which defines malloc().  Usually, this would be stdlib.h.</p>

<p>You can use online help from  cppreference.com or similar sites to get this information, and full documentation for the c libraries. </p>
",0
48634270,48634203,0,"<p><code>%d</code> will print integers. </p>

<p><code>Total</code> is a <code>float</code>, so it will not work.</p>

<p>You must use the proper specifier for a <code>float</code>.</p>

<p><em>(You should research that yourself, rather than have us give you the answer)</em></p>
",1
48682756,48682698,2,"<p>This loop expression:</p>

<pre><code>while(cha=='m'||cha=='M'||cha=='F'||cha=='f')
</code></pre>

<p>is evaluated <em>before</em>  <code>cha</code> is given a value by the call to <code>scanf()</code>. So basically you get random behavior since <code>cha</code> is not initialized when that line is first reached. There's a very low chance that it holds any of the valid characters, to the loop exits immediately.</p>

<p>Also, please note that <code>scanf()</code> can fail; you should always check its return value.</p>
",0
49175102,49174966,0,"<p>Yes, enums are objects that you can take the address of.</p>

<p>The only objects in C without an address are bit-fields and objects declared with the <code>register</code> storage-class specifier.</p>
",0
49175097,49174966,2,"<p>Once you create a variable, you have an object on your hands. You can take the address of that object just fine.</p>

<p>What you may not do however, is to take the address of an enumerator. I.e. nothing like <code>fun(&amp;state1);</code> or <code>fun(&amp;state2);</code>.</p>
",0
48732069,48731972,0,"<p>This expression is very likely incorrect: <code>&amp;(bow-&gt;bag) + bow-&gt;bag_size</code></p>

<p>The address of <code>bow-&gt;bag</code> is inside <code>bag_struct</code> structure. Adding <code>bow-&gt;bag_size</code> to it gives you a pointer that is past the end of <code>bag_struct</code>, causing undefined behavior. What you want is either this <code>&amp;(bow-&gt;bag[bow-&gt;bag_size])</code> or this <code>bow-&gt;bag+bow-&gt;bag_size</code>:</p>

<pre><code>memcpy(bow-&gt;bag+bow-&gt;bag_size, WCS, sizeof(*bag));
</code></pre>
",0
48920858,48920733,1,"<p>Could be several things, but here are some:</p>

<ol>
<li>The line <code>Today is Tuesday</code> is at least 17 characters, but your are reading into <code>line[i]</code> which has at most space for 10 characters. You will none the less read <code>sizeof line</code> characters which will be all of the possible characters, because <code>sizeof line</code> for you is 1280 (which is much bigger than 10)</li>
<li>Lets say you successfully read the first line, you then close the input file with <code>fclose ( inputFile );</code> and try to read from it again. That sounds like undefined behaviour to me.</li>
</ol>

<p><a href=""https://en.wikipedia.org/wiki/Rubber_duck_debugging"" rel=""nofollow noreferrer"">You need a rubber duck to talk to.</a></p>
",0
49180981,49180944,2,"<pre><code>char *con[30];
</code></pre>

<p>declares an array of 30 pointers to strings. This is not what you need. It fails because you then try to copy to the first string, but did not allocate the first string (only a pointer to it)</p>

<p>You need</p>

<pre><code>char con[30];
</code></pre>

<p>and then</p>

<pre><code>strcpy(con, ""1234"");
</code></pre>

<p>Or (as Lee Danial points out) you might have wanted an array , in which case you need</p>

<pre><code> char *con[30];
</code></pre>

<p>then </p>

<pre><code>con[count] = strdup(""1234"")
</code></pre>

<p>or</p>

<pre><code>con[count] = ""1234""
</code></pre>

<p>The first one allocates a string and copies it for you (a combination of malloc and strcpy). The second one just points at the supplied literal, it doesn't make a copy. Hard to say which is 'best' for you.</p>

<p>PS strdup is equivalent to</p>

<pre><code>  x = malloc(strlen(str) + 1);
    strcpy(x, str);
    return x;
</code></pre>
",3
48800242,48799800,7,"<p>The <em>first</em> thing you should do is decide what your function is meant to do.</p>
<p>Its signature and name suggest it's supposed to <em>return</em> the median but the code actually <em>prints</em> it (and, if it just prints it, it should probably have a <code>void</code> return type).</p>
<p>The printing is probably best left to the caller, leaving the function to just calculate and return the median. This makes it a much more general-purpose function.</p>
<p>In any case, it's the use of <code>&gt;</code> rather than <code>&gt;=</code> which is causing your problem here since data sets where two or more numbers are identical will tend to result in none of the <code>if</code> statements being true.</p>
<p>A more &quot;clean&quot; solution (in my opinion) would just be to cover all of the six possibilities in turn:</p>
<pre><code>int median (int a, int b, int c) {
    if ((a &lt;= b) &amp;&amp; (b &lt;= c)) return b;  // a b c
    if ((a &lt;= c) &amp;&amp; (c &lt;= b)) return c;  // a c b
    if ((b &lt;= a) &amp;&amp; (a &lt;= c)) return a;  // b a c
    if ((b &lt;= c) &amp;&amp; (c &lt;= a)) return c;  // b c a
    if ((c &lt;= a) &amp;&amp; (a &lt;= b)) return a;  // c a b
    return b;                            // c b a
}
</code></pre>
<p>Note that I've used <code>&lt;=</code> here, simply because it more closely aligns the conditions with the sequences shown in the comment. The important thing is to use an inclusive comparison operator, whether <code>&gt;=</code> <em>or</em> <code>&lt;=</code>, rather than an exclusive one like <code>&gt;</code>.</p>
<hr />
<p>There is, of course, another option (there almost always is).</p>
<p>Since there are only three values, it's a simple matter to sort them and just return the middle one. It doesn't have to be a complicated sort since you can just use an unrolled bubble sort created from a few conditionals. The code for doing that is shown below:</p>
<pre><code>int median (int a, int b, int c) {
    // Unrolled bubble sort, then return middle one.

    if (a &gt; b) { int t = a; a = b; b = t; }
    if (b &gt; c) { int t = b; b = c; c = t; }
    if (a &gt; b) { int t = a; a = b; b = t; }

    return b;
}
</code></pre>
<p>Personally, I don't think that's as readable as the earlier code but, if you prefer it, it's certainly functional.</p>
",0
52354602,52354495,2,"<p>Inside string and character literals, escape sequences are processed so that (for example) <code>\n</code> and <code>\0</code> become the <em>single</em> characters ""newline"" and ""string terminator"" - they are <em>not</em> two characters each as you seem to think.</p>

<p>This important detail is in <code>C11 5.1.1.2 Translation Phases</code> in phase 5:</p>

<blockquote>
  <p>Each source character set member <strong><em>and escape sequence</em></strong> in character constants and string literals is converted to the corresponding member of the execution character set; if there is no corresponding member, it is converted to an implementation-defined member other than the null (wide) character.</p>
</blockquote>

<p>Also in <code>5.2.1 Character sets /2</code>:</p>

<blockquote>
  <p>In a character constant or string literal, members of the execution character set shall be represented by corresponding members of the source character set <strong><em>or by escape sequences consisting of the backslash \ followed by one or more characters.</em></strong></p>
</blockquote>

<p>The actual escape sequences you are permitted to use are detailed in several places in the standard, I won't show them all here since the answer's probably already big enough.</p>

<hr>

<p>However, based on a careful reading of your question, I suspect your <em>actual</em> problem is misunderstanding why separating your strings using a newline token results in an empty string after ""line 10"".</p>

<p>That can be easily understood if you consider the following string:</p>

<pre><code>A|B|C
</code></pre>

<p>If you separate that based on <code>|</code>, you'll end up with the three values <code>A</code>, <code>B</code> and <code>C</code>. If you do the same thing to the string <code>A|B|</code>, you'll end up with <code>A</code>, <code>B</code> and the empty string.</p>

<p>That's almost certainly what's happening with your string. Because your last few characters are <code>line 10\n</code> and you're using <code>\n</code> as the separator, there's actually an <em>extra</em> empty string following that final <code>\n</code>.</p>

<p>I suspect if you take off the final newline, your problem will go away.</p>
",3
54922931,54922444,0,"<p><code>scanf</code>fills in the array you give it with a string constructed from the input including a null terminator byte. You allocate 51 bytes correctly but when you start adding the digits, you start at index 50 which is the index of the nul byte. The actual digits are from indexes 0 to 49.</p>

<p>This means that you will get a carry into the units digit of your answer at some point because the answer for that digit is calculated as </p>

<pre><code>answer[50] += (str[i][50] - 48) + carry;
//                        ^^^^ correction applied for ASCII
</code></pre>

<p>Another issue is that you forget to reset carry to zero at the beginning of adding each new number. </p>

<p>This might work (not tested) but it still doesn't really handle overflows in the top digits</p>

<pre><code>for(int i = 0; i &lt; STRINGS; i++){
    scanf(""%s"", str[i]);
    carry = 0;            // Reset the carry
    for(int j = NUM - 1; j &gt;=0; j--){
        answer[j] += (str[i][j] - 48) + carry;
        if(answer[j] &gt; 9){
            carry = answer[j] / 10;
            answer[j] %= 10;
        }else{
            carry = 0;
        }
    }
}
</code></pre>
",8
52639852,52639726,-1,"<ol>
<li><p><code>string</code> is allocated on the stack since it is <code>const char[]</code> instead of <code>const char *</code>. What happens is a <code>char</code> array is allocated on the stack, and the string is copied into that array. If you used the <code>const char *</code> form, most compilers will place the string into a read-only section in the binary, causing the program to crash when you actually attempt to write to it. On the stack, there is no such protection.</p></li>
<li><p><code>scanf</code> uses variadic arguments, meaning the compiler does not know that it will modify the array that you pass in (it might do it anyways, but this is not required by the C standard).</p></li>
</ol>
",1
52639926,52639726,1,"<p>It is undefined behavior. The format specifier <code>%s</code> is for <code>char*</code> but you pass a <code>const char*</code> (the array decays).</p>

<p>Undefined behavior means that the standard doesn't define any behavior for your program. It could print what you see, it could print the original string, it could print gibberish, it could crash or anything could happen.</p>

<p>Also please enable compiler warnings. This would have been caught:</p>

<blockquote>
  <p>warning: format specifies type 'char *' but the argument has type
  'const char *' [-Wformat]</p>

<pre><code>scanf(""%s"", string);

       ~~   ^~~~~~

       %7s
</code></pre>
</blockquote>

<p>Regarding writing more than you allocated. Considering the array was not const (mutable) then writing more that 7 characters to it would also be Undefined Behavior.</p>
",1
53182243,53182191,1,"<p>like this</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void peachy(char* str, int a, int b)
{
    printf(""Character: %s\n"", str);
    printf(""First Integer: %d\n"", a);
    printf(""Second Integer: %d\n"", b);

}


int main(void)
{
    peachy(""g"", 7, 6);
    peachy(""foo"", 42, 43); //just to show the use of function args    
}
</code></pre>
",0
48720694,48720570,0,"<p>you can use some ""BigInt"" library
like <a href=""https://gmplib.org/"" rel=""nofollow noreferrer"">https://gmplib.org/</a> just googling ""BigInt C library"" will give a lot of examples.
According to the task as you said it... most probably it indeed was especially composed in such a way that you have not to look for a straightforward answer but cheat somehow</p>
",0
49460815,49460627,0,"<p>Assuming you want your <code>fib</code> function to use a switch statement, here is a possible solution:</p>

<pre><code>int fib(int n)
{
    switch( n ) {
        case 0:
            return 0;
        case 1:
            return 1;
        default:
            return fib( n-1 ) + fib( n-2 );
    }
}
</code></pre>
",0
48747480,48747113,2,"<p>As <em><a href=""https://www.gnu.org/software/libc/manual/html_node/Infinity-and-NaN.html"" rel=""nofollow noreferrer"">cited here</a></em>, <em><a href=""https://wiki.sei.cmu.edu/confluence/display/c/FLP04-C.+Check+floating-point+inputs+for+exceptional+values"" rel=""nofollow noreferrer"">and here</a></em>, `+/-inf, or nan are generated by such operations as:</p>

<p>1/0 = &infin;<br>
log (0) = -&infin;<br>
sqrt (-1) = NaN  </p>

<p>When using ratios, and or exponential operations, checks should always be included in your code to exclude exceptional values from being processed by such operations.  </p>

<p>Walk through the sections of your code where <code>inf</code> or <code>nan</code> values are being generated, identify how the ratios or functions might be assigned incorrect values, and address them. (eg. by surrounding that section of code with a test for illegal value, and set a condition to bypass the operation when such a value is present.)    </p>

<p>Keep in mind the difference between accepting and using the values of <code>+/-¡Þ</code> and <code>NaN</code>.    </p>

<p>When using them, the basic operations and math functions all accept <code>¡Þ</code> and <code>NaN</code> and produce sensible output.  However, ¡Þ propagates through calculations as one would expect: for example, <code>2 + ¡Þ</code> = <code>¡Þ;</code>, <code>4/¡Þ;</code> = <code>0</code>, <code>atan (¡Þ)</code> = <code>pi;/2</code>.     </p>

<p><code>NaN</code>, on the other hand, infects any calculation that involves it. Unless the calculation would produce the same result no matter what real value replaced <code>NaN</code>, the result is <code>NaN</code>. (adapted from 2nd link above).</p>
",5
48746751,48746576,3,"<p>You are calling <code>strcat()</code> with the same string as both arguments, which is an error. See <a href=""https://linux.die.net/man/3/strcat"" rel=""nofollow noreferrer"">the manual page</a>:</p>

<blockquote>
  <p>The strings may not overlap, and the dest string must have enough space for the result. </p>
</blockquote>
",0
48833215,48833085,3,"<blockquote>
<p>1.1 So, if we declare <code>c</code> as <code>char</code> and it's by default <code>signed char</code> on the system then it will still work but it will mess up if we enter a character equal to ASCII 128 and above?</p>
</blockquote>
<p>If <code>char</code> is signed, the bit pattern for characters above 128 would be interpreted as negative signed values. The only true mess-up is going to happen when character <code>255</code> (<code>nbsp</code> in extended ASCII) is entered, because it would be interpreted as <code>EOF</code> on systems where it is represented by -1.</p>
<blockquote>
<p>1.2 In the opposite, if we declare <code>c</code> as <code>char</code> and by default is <code>unsigned char</code> on the system then <code>getchar()</code> will always be NOT equal to <code>EOF</code> no matter what because we cannot store a negative value, right?</p>
</blockquote>
<p>That's correct, it would never be equal to <code>EOF</code>. Any bit pattern inside <code>unsigned char</code> would end up in the range from 0..255, inclusive, when promoted to <code>int</code> for comparison with <code>EOF</code>. Hence, the comparison would be false even when <code>getchar()</code> actually returns <code>EOF</code>.</p>
<blockquote>
<p>We type some characters as input <code>c = getchar()</code> grabs this input and convert it to ASCII number after that it checks to make sure it's not equal to <code>EOF</code>.</p>
</blockquote>
<p>There is no ASCII conversion going on; the character starts as an ASCII character (assuming that the system uses ASCII) or a character in whatever encoding style that your system is using.</p>
<blockquote>
<ol start=""3"">
<li><p>If it is NOT equal to <code>EOF</code>, it displays the input characters as output.</p>
</li>
<li><p>It goes back in a state where we must input new characters to continue the loop.</p>
</li>
</ol>
</blockquote>
<p>Correct on both 3 and 4.</p>
",16
48833299,48833085,5,"<p>The crucial piece of information you are missing is this sentence, from the <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21.7.1"" rel=""noreferrer"">specification of <code>fgetc</code></a> (<code>getchar</code> is defined to be equivalent to <code>fgetc(stdin)</code>):</p>

<blockquote>
  <p>If the end-of-file indicator for the input stream pointed to by stream is not set and a next character is present, the fgetc function [returns] that character <em>as an <code>unsigned char</code> converted to an <code>int</code></em>.  [Otherwise, it returns <code>EOF</code>.]</p>
</blockquote>

<p>Emphasis mine.  What this means is, on the typical implementation where <code>unsigned char</code> can represent the values 0 through 255 inclusive, <code>getchar</code> will always return values in the range 0 through 255 inclusive, or EOF, <em>even if <code>char</code> is signed</em>.</p>

<p>EOF, meanwhile, is not guaranteed to be &minus;1 (although it almost always is), but it <em>is</em> guaranteed to be negative, and to fit in an <code>int</code>.</p>

<p>So, when you do</p>

<pre><code>int c = getchar();
</code></pre>

<p>you can be certain that none of the possible return values collide with each other: <code>c</code> will either be <code>EOF</code>, which is negative, or it will be one of the values representable by <code>unsigned char</code> (0 through 255), which are all nonnegative.  If you convert <code>c</code> back to a <code>char</code> <em>after</em> you have checked that it is not EOF, that's safe; the conversion from <code>unsigned char</code> to <code>char</code> is at worst implementation-defined.</p>

<p>On the other hand, when you do any of these</p>

<pre><code>char c = getchar();          // this is wrong
unsigned char d = getchar(); // also wrong
signed char e = getchar();   // also wrong
</code></pre>

<p>you lose the ability to distinguish EOF from <em>some</em> byte value that could have been in the file. The signedness of the variable is irrelevant, and so is the actual value of EOF; what matters is that <code>char</code>, <code>unsigned char</code>, and <code>signed char</code> can only represent 2<sup>CHAR_BIT</sup> different values, all of those could have been in the file, and EOF is one more.  It's the <a href=""https://en.wikipedia.org/wiki/Pigeonhole_principle"" rel=""noreferrer"">pigeonhole principle</a>.</p>

<p>You should be aware that K&amp;R is very old and no longer considered the best book to learn C from.  (I don't know what the current best book is.)</p>
",1
48955712,48954288,1,"<p>I'll play this silly game.  Your teacher is having a joke with you.</p>

<p>By the magic of <a href=""https://www.naclbox.com/gallery/turboc"" rel=""nofollow noreferrer"">https://www.naclbox.com/gallery/turboc</a> :</p>

<p>Consider:
<a href=""https://i.stack.imgur.com/UtTDS.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/UtTDS.png"" alt=""enter image description here""></a></p>

<p>Then note the hidden macro definition on line 6 (note the column number):
<a href=""https://i.stack.imgur.com/gyI9x.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/gyI9x.png"" alt=""enter image description here""></a></p>

<p>Voila!
<a href=""https://i.stack.imgur.com/hg1Fv.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hg1Fv.png"" alt=""enter image description here""></a></p>
",1
57272715,57262858,0,"<p>if <code>(a != b)</code> does not do what you think it is doing. Check <a href=""https://www.freebsd.org/cgi/man.cgi?query=strncmp"" rel=""nofollow noreferrer"">strncmp()</a> or <a href=""https://www.freebsd.org/cgi/man.cgi?query=memcmp&amp;sektion=3&amp;apropos=0&amp;manpath=FreeBSD%2012.0-RELEASE%20and%20Ports"" rel=""nofollow noreferrer"">memcmp()</a> library functions.</p>

<p>But if you want to find out the first different character in two strings, the code below would do it for you.</p>

<p>Not tested properly, so take it as a quick prototype.</p>

<pre><code>#include &lt;stdio.h&gt;

int strdiff(char *s1, char *s2){
        char *p1 = s1;
        while(*s1++ == *s2++)
                ;
        if (s1 != s2)
                return --s1-p1; /* we have s1++ in the while loop */
        return -1;
}


int main(){
        char *s1=""S00111111   5           6-Jul-19    09-Aug-19"";
        char *s2=""S00111111   3           6-Jul-19    09-Aug-19"";
        int i = strdiff(s1,s2);
        printf(""%d %c\n"",i, s1[i]);
        return 0;
}
</code></pre>

<p>Mind you, <em>comparing two files line by line</em> may turn out to be a bigger mission than it sounds if the two files you are comparing do not have exactly the same lines (with minor differences of course).</p>
",0
49597082,49597015,5,"<p>You're almost there. This seems like an attempt to null-terminate the input, only this particular expression at the end of <code>xgets()</code> has no effect</p>

<pre><code>    a = '\0';
</code></pre>

<p>It sets the value of the <code>a</code> pointer itself to 0.</p>

<p>Just add a <code>*</code> in front of <code>a</code> to set the character pointed-to by <code>a</code> to 0:</p>

<pre><code>    *a = '\0';
</code></pre>

<hr>

<p>&#9888; <sub>Note: Your code is susceptible to a buffer overflow because <code>str</code> has a fixed length of 25, which is not checked in <code>xgets</code>. You should pass the length of <code>str</code> as a second argument to <code>xgets</code> and check it there.</sub></p>
",0
54629707,54629409,1,"<p>You iteration is needlessly obscure and also incorrect. You only need one iterator, but you should increase it by 2 each lap in the loop, since you examine 2 characters. Simplify the code into this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main (void)
{
  char str[] = ""AABBCCDD"";
  char hex[3] = {'\0'};

  unsigned int sum = 0; 
  unsigned int length = strlen(str);
  for (int i = 0; i&lt;length; i+=2)
  {
    hex[0] = str[i];
    hex[1] = str[i+1];
    sum += strtol(hex, NULL, 16);
  }
  printf(""%x"", sum);
}
</code></pre>

<p>Notably this has no error handling for wrong amount of nibbles, incorrect characters etc.</p>
",0
54629623,54629409,2,"<p>You want this:</p>

<pre><code>  char hex[] = { ""00"" };

  int sum = 0;
  for (int i = 0; str[i] != 0; i += 2) {
    hex[0] = str[i];
    hex[1] = str[i + 1];
    sum += (int)strtol(hex, NULL, 16);
  }
  printf(""%x"", sum);
</code></pre>

<p>Keep it simple, and don't make it more complicated than necessary.</p>

<ol>
<li>you don't need two indexes</li>
<li>your end condition is wrong, you want to stop at the end of the input string, not at the end of the input buffer.</li>
</ol>
",3
54219302,54219110,6,"<p>A <code>double</code> cannot exactly encoded all numbers.  It can exactly encoded about 2<sup>64</sup> different values.  <code>-10.754</code> is not one of them.  Instead a nearby value is used just less than expected.</p>

<pre><code>printf(""%.24f"", -10.754);
// -10.753999999999999559463504
</code></pre>

<p>The <code>decpart * 1000</code> part introduces some imprecision yet the product is still below 754.0 and then the <code>(int)</code> cast makes that 753.</p>
",0
50215536,50215293,4,"<p>The extra paren is from the <code>printf</code> itself.</p>

<pre><code>    printf(""\n\n\n)"");
                  ^ right here!  :)
</code></pre>

<hr>

<p>Also, as noted in the comments: you have an uninitialized variable:</p>

<pre><code>$ clang -Wall rfic.c 
rfic.c:18:8: warning: variable 'c' is used uninitialized whenever function 'main' is called
      [-Wsometimes-uninitialized]
  char c;
  ~~~~~^
rfic.c:26:10: note: uninitialized use occurs here
  while (c != EOF) {
         ^
rfic.c:18:9: note: initialize the variable 'c' to silence this warning
  char c;
        ^
         = '\0'
1 warning generated.
</code></pre>

<p>You also have a memory leak.  <code>newptr</code> is assigned the result of an allocation and this pointer is overwritten with each iteration of this loop.</p>
",1
50689017,50688917,2,"<p>You've got the wrong output type on the points printf.  You have it set to <code>""%lf""</code> when it should be <code>""%d""</code> based on the expected integer type of the variable:</p>

<pre><code>void printAllStudents(ps head){
    while (head != NULL){
        printf(""The student %s points is %d \n"", head-&gt;name, head-&gt;nakaz);
        head = head-&gt;next;//printing all dogs
}
</code></pre>
",0
55395293,55394858,1,"<blockquote>
  <p>Instead, could one set errno = 0 at the top of the series of malloc calls, and then test for errno == ENOMEM at the end?</p>
</blockquote>

<p>Yes you could as long as your implementation of <code>malloc</code> is documented to set <code>errno</code> to <code>ENOMEM</code>. The specification in the C11 standard (¡ì 7.22.3.4) only mentions that the pointer returned will be <code>NULL</code>, not that <code>errno</code> will be set, so your code is technically not portable. </p>

<p>The default implementation of <code>malloc</code> in macOS, Windows and in Linux does set <code>errno</code> so that's most of the computers in the World covered. However, if true portability is required, at the end just write </p>

<pre><code>if (a == NULL || b == NULL || c == NULL)
{
    // Handle the failure
}
</code></pre>

<p>Addendum: There's no need to reset <code>errno</code> back to zero after the <code>malloc</code>s.  </p>
",4
54080851,54080668,1,"<p><code>table</code> is an array of 3 arrays of 4 <code>int</code>.</p>

<p>When an array is used in an expression, it is converted to a pointer to its first element, except when:</p>

<ul>
<li>It is the operand of <code>sizeof</code>.</li>
<li>It is the operand of unary <code>&amp;</code>.</li>
<li>It is a string literal used to initialize an array.</li>
</ul>

<p>So, in <code>*(*(table+2)+1)</code>, <code>table</code> is converted to a pointer to its first element, producing <code>&amp;table[0]</code>. Then we have:</p>

<pre><code>*(*(&amp;table[0]+2)+1)
</code></pre>

<p>Next, we have the addition <code>&amp;table[0] + 2</code>. This uses pointer arithmetic. Adding an integer to a pointer (into an array) moves the pointer backward or forward by a number of elements. So <code>&amp;table[0] + 2</code> produces a pointer to <code>table[2]</code>, which is <code>&amp;table[2]</code>. Then we have:</p>

<pre><code>*(*(&amp;table[2])+1)
</code></pre>

<p>The inner parentheses are no longer needed, so we have:</p>

<pre><code>*(*&amp;table[2]+1)
</code></pre>

<p>Then <code>* &amp;table[2]</code> is the thing that <code>&amp;table[2]</code> points to, which means it is <code>table[2]</code>:</p>

<pre><code>*(table[2] + 1)
</code></pre>

<p>Since <code>table</code> is an array of 3 arrays of 4 <code>int</code>, <code>table[2]</code> is an array of 4 <code>int</code>. Since it is an array, it is converted to a pointer to its first element, producing <code>&amp;table[2][0]</code>:</p>

<pre><code>*(&amp;table[2][0] + 1)
</code></pre>

<p>Now we have pointer arithmetic again. <code>&amp;table[2][0]</code> is a pointer to element 0 of the array <code>table[2]</code>, so adding 1 produces a pointer to element 1, <code>&amp;table[2][1]</code>:</p>

<pre><code>*(&amp;table[2][1])
</code></pre>

<p>Again we have parentheses that are no longer needed:</p>

<pre><code>*&amp;table[2][1]
</code></pre>

<p>And, finally, <code>* &amp;table[2][1]</code> is the thing that <code>&amp;table[2][1]</code> points to, so it is just:</p>

<pre><code>table[2][1]
</code></pre>
",0
48832486,48819323,1,"<p>As noted in a <a href=""https://stackoverflow.com/questions/48819323/function-to-dynamically-allocate-matrix-and-treats-all-errors#comment84642904_48819323"">comment</a>, within broad limits, if your code encounters an allocation error, you correctly release all the data that was allocated prior to the error.</p>

<p>You will need a function to release the allocated memory; it will need to know how many rows to release. You could use that in your error recovery, using <code>l</code> as the number of rows to be released.</p>

<pre><code>void deallocate(double **matrix, int rows)
{
    for (int i = 0; i &lt; rows; i++)
        free(matrix[i]);
    free(matrix);
}
</code></pre>

<p>That does not set the pointer passed in to null; you can use a three-star interface if you insist, but it probably isn't worthwhile (IMO ¡ª YMMV).  This can then be used in the allocation code.</p>

<pre><code>void allocate(double ***m, int r, int c)
{
    *m = (double **)malloc(sizeof(double *) * r);
    if (*m == NULL)
        return;
    for (int l = 0; l &lt; r; l++)
    {
        (*m)[l] = (double *)malloc(sizeof(double) * c);
        if ((*m)[l] == NULL)
        {
            deallocate(*m, l);
            *m = NULL;
            return; 
        }
    }
}
</code></pre>

<p>There are those who are fanatical about '<a href=""https://stackoverflow.com/questions/605845/"">no cast on <code>malloc()</code></a>' ¡ª I am not one of those, but I do make sure my code doesn¡¯t compile in my development environment if <code>&lt;stdlib.h&gt;</code> was not included (so there was no declaration of <code>malloc()</code> et al viable when it is called).  That makes it safe for user¡¯s too, even if they don¡¯t compile with the rigorous warning/error options I use.</p>

<p>Note too that <a href=""http://c2.com/cgi/wiki?ThreeStarProgrammer"" rel=""nofollow noreferrer"">Three-star Programmer</a> is not a compliment.  As suggested in the comments, you could use a different interface:</p>

<pre><code>double **allocate(int r, int c)
{
    double **matrix = (double **)malloc(sizeof(double *) * r);
    if (m == NULL)
        return NULL;
    for (int l = 0; l &lt; r; l++)
    {
        matrix[l] = (double *)malloc(sizeof(double) * c);
        if (matrix[l] == NULL)
        {
            deallocate(matrix, l);
            return NULL; 
        }
    }
    return matrix;
}
</code></pre>

<p>Note that because the allocation (and deallocation) functions use <code>int</code> and not <code>size_t</code> for the size parameters, you could get negative values.  You could also get zeros provided ¡ª but if the size is zero, the code will 'work' safely, but the result will be unusable (no space allocated).</p>
",1
48819239,48818886,1,"<p>Sometimes I don't know what teachers are thinking. Instead of teaching how to
use the correct functions properly, they give you assignments where you cannot
use variables, or you cannot return pointers and you cannot even use
functions. For me it's like when the master carpenter tells the young
apprentice <em>nail this nail, but don't use your hammer, use your screwdriver
instead</em>. Enough about my rant...</p>

<p>The problem here is that you want to read content that has meaning (newline for
example) with a function that just reads a block of bytes and doesn't care for
the meaning of the bytes. If the newline is in the middle of the block you've
read, then you've read too much. The best way would be to read one byte at a
time and check if it is the newline.</p>

<pre><code>int get_from_user(char *buffer, size_t size)
{
    size_t cnt = 0;
    char c;

    if(buffer == NULL || size == 0)
        return 0;

    while(read(STDIN_FILENO, &amp;c, 1) == 1 &amp;&amp; cnt &lt; size - 1)
    {
        if(c == '\n')
        {
            buffer[cnt] = 0;
            return 1;
        }

        buffer[cnt++] = c;
    }

    buffer[cnt] = 0; // making sure it's 0-terminated
    return 1;
}
</code></pre>

<p>And when you want to read:</p>

<pre><code>char line[100];
get_from_user(line, sizeof line);
</code></pre>
",4
52741189,52741060,3,"<p>You should keep a count of how many elements have a valid value ... and do not attempt to read the unitialized ones.</p>

<pre><code>int a[7];
int n = scanf(""%d%d%d%d%d%d"", a+0, a+1, a+2, a+3, a+4, a+5);
if (n &gt;= 1) {
    printf(""last one: %d\n"", a[n - 1]);
    //printf(""UB: %d\n"", a[n]);
    //printf(""UB: %d\n"", a[6]); //a[6] is uninitialized / not assigned a value
}
</code></pre>
",2
48634134,48632997,0,"<p>A pointer points to a data, and usually contains the memory address of the data. The pointer is a normal 'c' variable. </p>

<p>operator '*' applied at the time, when the pointer is used, tells the compiler to access data, at the location denoted by the pointer.</p>

<p>Operator '++', applied to the pointer, increments its value so, that it points to the next data element,  adjacent to the previous one. So, for 'char*' pointers, it increments the address by '1' to point to the next char in the string.</p>

<p>In your case <code>*targ++</code> means: access data referenced by the pointer 'targ' and then increment the value of the pointer.</p>

<pre><code>*targ++ = *arg++;
</code></pre>

<p>In the above expression the program takes char pointed by 'arg' and assigns it to the char location referenced by 'targ'. Then it increments values of the pointers 'arg' and 'targ'. </p>
",1
48633153,48632997,4,"<p>A pointer is a variable that stores an address. This address can be the address
of another variable:</p>

<pre><code>int a = 18;
int *pa = &amp;a;
</code></pre>

<p>or it can be the start of a dynamically allocated memory block:</p>

<pre><code>int *p = malloc(sizeof *p);
</code></pre>

<p>The important thing is that pointers allow you access the values behind an
address. You do that by dereferencing the pointer using the <code>*</code>-operator:</p>

<pre><code>int a = 18;
int *pa = &amp;a;

*pa = 10;

printf(""a=%d\n"", a); // will print 10
</code></pre>

<p>For these kind of examples, this might not seem like a big deal, but it is,
because you can pass pointers to functions and those function can then interact
with the memory pointed to by the pointer, depending on the memory block, even
modifiy it.</p>

<p>Pointers can also point to the start of sequence of objects, for example to the
start of an array:</p>

<pre><code>int arr[] = { 1, 3, 5 };
int *p = arr;
</code></pre>

<p>Note <code>p[0]</code> is 1, <code>p[1]</code> is 3 and <code>p[2]</code> is 5. It is also possible to change the
values by doing <code>p[1] = -14;</code>. This is also dereferencing, but you also can use the
<code>*</code>-operator:</p>

<pre><code>p[1] = 12;
// is equivalent to
*(p + 1) = 12;
</code></pre>

<p>And that's what your snippet is using. Forget for a second the loop. Take a look
at this line:</p>

<pre><code>*targ++ = *arg++;
</code></pre>

<p>This can be rewritten as:</p>

<pre><code>targ[0] = arg[0];
targ = targ + 1;  // or targ = &amp;(targ[1])
arg = arg + 1;    // or arg = &amp;(arg[1])
</code></pre>

<p>Now it's more clear what it is doing. It copies the value of first character
pointed to by <code>arg</code> to the position where <code>targ</code> is pointing to. After that both
<code>arg</code> and <code>targ</code> are incremented to advance to the next element in the
sequence.<sup>1</sup></p>

<p>So what the loop is doing is copying <code>len</code> objects pointed to by <code>arg</code> to
<code>targ</code>. This could be used to copy a string into another <code>char</code> array. But it is
not safe, as it is not clear whether the <code>'\0'</code>-terminating byte is is copied
and it is not clear whether the buffers are large enough (meaning larger than
<code>len</code>). If they are not strings but sequences of bytes, then this function would
be OK.</p>

<p>In C a string is just a sequence of characters that ends with the <code>'\0'</code>-terminating  byte.
For that reason they are stored using <code>char</code> arrays and are passed to functions
as pointers of <code>char</code>, that point to the start of the string. We could rewrite
this function in a more safer way like this:</p>

<pre><code>int safe_copy_string(char *dest, char *source, size_t dest_size)
{
    if(dest == NULL || source == NULL)
        return 0;

    if(dest_size == 0)
        return 1; // no space to copy anything

    // copying one element less than dest_size
    // that last element if dest should be \0
    for(size_t i = 0; i &lt; dest_size - 1; ++i)
    {
        *dest++ = *source++;

        if(*(source - 1) == '\0')
            break; // copied sources's 0-terminating byte
    }

    dest[dest_size - 1] = 0; // making sure it is 0-terminated

    return 1;
}
</code></pre>

<hr>

<p><strong>Footenotes</strong></p>

<p><sup>1</sup>It's worth mentioning the <code>++</code>-operator here. This is the post-increment
operator which is used to add 1 to the operand (for integers), in case of a pointer
to advance the pointer by 1 thus making it point to the next object.</p>

<p>When you do:</p>

<pre><code>int a = 6;
int b = a++;
// a == 7, b == 6
</code></pre>

<p><code>a</code> is initialized with 6. When initializing <code>b</code>, the compiler will use the
current value of <code>a</code> for the initialization, however the post-increment
operator has the side effect that it will increment the value of <code>a</code> by 1. When
this exactly happens is define by the rules of <a href=""https://en.wikipedia.org/wiki/Sequence_point"" rel=""nofollow noreferrer"">sequence points</a>. What
matters is that in the initialization of <code>b</code>, the current value of <code>a</code> is used
and after the assignment <code>a</code> will have a the new value.</p>
",2
49241943,49241773,1,"<p>Your program has undefined behavior due to the value of <code>y</code>.</p>

<p><code>y</code> gets incremented in the inner loop but never gets reset to 0 when the outer loop is repeated.</p>

<p>In the second run of the outer loop, the value of <code>y</code> will start at <code>10</code> instead of starting at <code>0</code>.</p>

<p>In the third run of the outer loop, the value of <code>y</code> will start at <code>20</code> instead of starting at <code>0</code>.</p>

<p>That goes on for the remaining iterations of the outer loop.</p>

<p>You can remove the redundant indices <code>x</code> and <code>y</code>. Use <code>attack_grid[i][j]</code> instead of <code>attack_grid[x][y]</code></p>
",0
48651103,48650572,1,"<p>The <em>input stream</em> is a sequence of <em>characters</em> - not integers, not floats, not strings, just characters.  When you type in something like <code>1 2 10</code>, what gets put into the input stream is the character sequence <code>{'1', ' ', '2', ' ', '1', '0', '\n' }</code>.  <code>getchar</code> simply reads the next character from that character sequence.  </p>

<p>Note that in your loop you're calling <code>getchar</code> <em>twice</em> and throwing away every other input, which is why the trailing <code>0</code> doesn't show up.  </p>

<p>If you want to <em>interpret</em> the character sequence <code>'1' '0'</code> as the integer value <code>10</code>, then you'll need to either buffer those characters and convert them to an integer value yourself, or use <code>scanf</code> with the <code>%d</code> conversion specifier:</p>

<pre><code>int value;

putchar( '{' );
while ( scanf( ""%d"", &amp;value ) == 1 )
  printf( ""%d, "", value );
printf( ""}\n"" );
</code></pre>
",2
50448350,50448188,4,"<p>Or you can write this:</p>

<pre><code>int max_of_four(int a,int b,int c,int d) 
{
    int greatest_int = a;
    if (b &gt; greatest_int) {
        greatest_int = b;
    }
    if (c &gt; greatest_int) {
        greatest_int = c;
    }
    if (d &gt; greatest_int) {
        greatest_int = d;
    }
    return greatest_int;
}
</code></pre>

<p>Or something like this...</p>

<pre><code>int max_of_four(int a,int b,int c,int d) 
{
    int greatest_int = a;
    int *iter = (int[]){b, c, d}, *end = iter + 3;
    for (; iter &lt; end; iter ++) {
        if (*iter &gt; greatest_int) {
            greatest_int = *iter;
        }
    }
}
</code></pre>
",0
50345663,50345571,1,"<p><code>srand</code> is defined more or less like this:</p>

<pre><code>void srand(unsigned int seed);
</code></pre>

<p><code>time</code> is defined more or less like this:</p>

<pre><code>__int64 time(__int64 *t);
</code></pre>

<p>Thus you pass an <code>__int64</code> (64 bits) into an <code>unsigned int</code> (32 bits) parameter, which is not possible without potential trunctation. That's what the warning message is telling you.</p>
",2
49090709,49088690,0,"<p>Executing program under debugger and stepping through, would help you understand the problem:</p>

<pre><code> // duration=2.75
 duration_min = (int) duration;
 // duration_min = 2

 // now:        duration_min - duration = 2 - 2.75 = -0.75
 // but 0.75 has to be converted to int value 
 // (int) 0.75 = 0 
 duration_min = duration_min - duration; // get decimal value for min
 // so  `duration_min` = 0  
</code></pre>

<p>Be careful when you mix <code>double</code> and <code>int</code> values.  When <code>double</code> is converted to <code>int</code> it is always truncated.</p>

<p>Your program also has another problem. It does not print anything for duration = 1 hour.</p>

<p>Take a look at the possible solution. Keep separate <code>int</code> value for hours and a <code>double</code> for minutes. Then you have a clear separation between those two.
It makes calculations more obvious. </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void duration_time_min(double duration)
{
    double duration_min;
    int hours;

   if(duration == 1.0)
   {
       printf(""Trip duration: 1 hour\n"");
       return;
   }

   if (duration &lt; 1.0)   //  duration less then hour
   {
        duration_min = duration * 60.0; 
        printf(""Trip duration: 0 hours and %.1f minute(s)\n"", duration_min);
        return;
   }

    // (duration &gt; 1.0) // more than hour

    hours = (int) duration;              // cast double to int, get hours
    duration_min = duration - hours;     // get fraction part for the minutes
    duration_min = duration_min * 60.0;  // calculate minutes

    printf(""Trip duration: %d hours and %.1f minute(s)\n"", hours, duration_min);
 }

int main(void)
{
    duration_time_min(1.0);
    duration_time_min(0.75);
    duration_time_min(2.75);

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>Trip duration: 1 hour
Trip duration: 0 hours and 45.0 minute(s)
Trip duration: 2 hours and 45.0 minute(s)
</code></pre>
",0
49070773,49065791,0,"<blockquote>
  <p>the outputs are always -nan and nan</p>
</blockquote>

<pre><code>scanf(""%f %f %f"",&amp;a,&amp;b,&amp;c);
</code></pre>

<p>is placed too late in the code.
Get the values for <code>a,b,c</code> before the calculations:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;math.h&gt;

int main(void){
    float a,b,c;
    float root1, root2;

    scanf(""%f %f %f"",&amp;a,&amp;b,&amp;c);

    root1 = (-b + sqrt(b*b-4*a*c))/(2*a);
    root2 = (-b - sqrt(b*b-4*a*c))/(2*a);

    printf(""%8.1f %8.1f\n"",root1,root2);
    return 0;
}
</code></pre>

<p>The above formulas work correctly:
For input:</p>

<pre><code>3 -9 6
</code></pre>

<p>Output is:                                                                                                                                         </p>

<pre><code>2.0 1.0
</code></pre>
",6
49937822,49937681,3,"<p>The problem in your code is here:</p>

<pre><code>for (i=0;i&lt;3;i++)
{
    for(j=0;j&lt;3;j++)
    {
        C[i][j]=A[i][j]*B[j][i]+C[i][j];
    }
    // j contains 3 here therefore you acess the C array out of bounds
    printf(""%d   \n "", C[i][j]); //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    getchar();
}
</code></pre>

<p>You probably want this:</p>

<pre><code>  ...

  // Multiplication of A and B
  for (i = 0; i&lt;3; i++)
  {
    for (j = 0; j&lt;3; j++)
    {
      C[i][j] = A[i][j] * B[j][i] + C[i][j];
    }
  }

  // Display C    
  for (i = 0; i&lt;3; i++)
  {
    for (j = 0; j&lt;3; j++)
    {
      printf (""%d "", C[i][j]);
    }

    printf(""\n"");
  }

  getchar();
  ...
</code></pre>

<p>Even better: write a Display3x3Matrix and use it:</p>

<pre><code>void Display3x3Matrix(int m[3][3])
{
  for (int i = 0; i&lt;3; i++)
  {
    for (int j = 0; j&lt;3; j++)
    {
      printf(""%d "", m[i][j]);
    }    
    printf(""\n"");
  }
}

...

printf(""A\n"");
Display3x3Matrix(A);
printf(""\nB\n"");
Display3x3Matrix(B);
printf(""\nC\n"");
Display3x3Matrix(C);
</code></pre>
",0
53116075,53115319,0,"<p>Just as an addition to the other answer I am going to post a <code>aux</code> variable free version of this that works only for integers.
In order to swap two integers there is not need of any additional auxiliary variable.</p>

<pre><code>for (int i=0; i&lt;dim/2; i++)
{
    v[i]           = v[i] ^ v[dim - i - 1];
    v[dim - i - 1] = v[i] ^ v[dim - i - 1];
    v[i]           = v[i] ^ v[dim - i - 1];

}
</code></pre>

<p><a href=""https://wandbox.org/permlink/6Pe3dt1HVjc0yE1I"" rel=""nofollow noreferrer"">Live demo here</a></p>
",0
48995316,48994204,0,"<p><code>printf</code> doesn't work like that - only the first argument is processed to recognize conversion specifiers, and the remaining arguments are formatted accordingly.</p>

<p>This means the <code>%s</code> in <code>""is %s for the health""</code> is not recognized as a conversion specifier - it's only recognized as part of a string.  It also means that the final <code>""good""</code> argument is ignored.  </p>

<p><strong>TL/DR;</strong> - you can't ""chain"" format strings like that in C.  </p>

<p>BTW - C programming is <em>not</em> good for your health.  Trust me. </p>
",0
48994311,48994204,1,"<p>If you insist on 2 arguments then use <code>%s</code> for string twice.</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
    printf(""C programming %s%s"",""is good"" ,"" for health"");
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>C programming is good for health
</code></pre>
",0
48994303,48994204,1,"<pre><code>#include&lt;stdio.h&gt;
int main()
{
    char *good= ""good"";
    char *health = ""health"";
    printf(""C programming is %s for %s"", health, good);

    printf(""C programming is %s for %s"", good, health);
    return 0;
}
</code></pre>
",0
55997223,55954091,1,"<p>The problems are:</p>

<ul>
<li><code>temp_string</code> and longest_string<code>should be defined with a size of</code>input_length + 1`</li>
<li>you should set <code>longest_string</code> to an empty string with <code>*longest_string = '\0';</code> to avoid printing an uninitialized array if there are no letters on the line.</li>
<li>avoid hardcoding ASCII values in your code, it is not readable. You could use <code>(sen[i] &gt;= 'a' &amp;&amp; sen[i] &lt;= 'z') || (sen[i] &gt;= 'A' &amp;&amp; sen[i] &lt;= 'Z')</code> or better use <code>isalpha((unsigned char)sen[i])</code> from <code>&lt;ctype.h&gt;</code>.</li>
<li>you only test for the longest string if you find a byte that is not a letter. This prevents the last word from being included in the search. You should instead first find a letter, then match all subsequent letters and test if you have found a longer word.</li>
<li>the calls to <code>memset</code> are overkill. You should just set the null terminator in <code>temp_string</code> with <code>temp_string[current_len] = '\0';</code> so <code>strcpy</code> can copy it as a C string and get rid of both <code>memset</code> calls.</li>
</ul>

<p>You don't actually need to copy the substrings, just keep track of the offsets for the current and longest word:</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;

void LongestWord(const char *sen) {
    int i, len, best_start, best_len;

    best_start = best_len = 0;
    for (i = 0; sen[i] != '\0'; i++) {
        if (isalpha((unsigned char)sen[i]) {
            // we have a letter: compute the word length
            for (len = 1; isalpha((unsigned char)sen[i + len]; len++)
                continue;
            if (len &gt; best_len) {
                // remember the longest word's offset and length
                best_start = i;
                best_len = len;
            }
            // skip all letters (-1 because of i++ in the for loop)
            i += len - 1;
        }
    }
    // use `%.*s` to print a substring with printf
    printf(""Longest string: %.*s\n"", best_len, sen + best_start);
}
</code></pre>
",1
49078543,49078299,1,"<p>When you take an array as an argument, you have to take the length as well,
because you have to check if you are reading/writing out of bounds. Forget for a
second that the return is at that incorrect position, the user <strong>can</strong> input more
values than the array can hold and you are doing nothing to prevent the buffer overflow.</p>

<p>So to fix your <code>read_data</code> function:</p>

<pre><code>int read_data(int Ar[], size_t len)
{
    if(Ar == NULL || len == 0)
        return 0;

    int i = 0, j, num;

    // imortant to check the bounds
    while (i &lt; len) {
        printf(""Please enter an integer:\n"");

        j = scanf(""%d"", &amp;num);
        if (j != 1) {
            break;
        }

        if (num &lt; 0) {
            continue;
        } else if (num &gt;= 100) {
            break;
        } else {
            Ar[i] = num;
            i++;
        }
    }

    return i;
}
</code></pre>

<p>I removed the <code>flag</code> bit because if <code>num &gt;=100</code>, you would be ending the loop
anyway, so it's much simpler to do a <code>break</code>. Also the intention is more clearer.</p>

<p>Now you can call it:</p>

<pre><code>int main()
{
    int Ar[100];
    int size;
    double avg;
    size = read_data(Ar, sizeof Ar / sizeof *Ar);
    ...
}
</code></pre>
",3
49188756,49187763,1,"<p>The error is that you are trying to read from <code>pdes0[0]</code> and <code>pdes1[0]</code> regardless of whether <code>i</code> is equal to <code>0</code> or <code>1</code>.</p>

<p>Also, you are closing both the descriptors in the first run of the loop. When <code>i</code> is equal to <code>1</code>, the descriptors are no longer valid, the calls to <code>read</code> return with failure and you proceed to use the buffers as though they hold valid data.</p>

<p>Here's an updated version of the parent's side of the code.</p>

<pre><code>/* parent */
if ( i == 0 )
{
   char inbuf0[10];
   close(pdes0[1]);
   read(pdes0[0], inbuf0, 10);
   printf(""Parent0 read: %s\n"", inbuf0);
   close(pdes0[0]);
}

if ( i == 1 )
{
   char inbuf1[10];
   close(pdes1[1]);
   read(pdes1[0], inbuf1, 10);
   printf(""Parent1 read: %s\n"", inbuf1);
   close(pdes1[0]);
}
</code></pre>

<p>With that change, I get the expected output.</p>

<pre class=""lang-none prettyprint-override""><code>Parent pid: 7262
Child0 pid 7263 from parent pid 7262
Child0: child0
Parent0 read: child0
Child1 pid 7264 from parent pid 7262
Child1: child1
Parent1 read: child1
</code></pre>

<hr>

<p>Also, the checks </p>

<pre><code>if(pdes0 &lt; 0)
</code></pre>

<p>and</p>

<pre><code>if(pdes1 &lt; 0)
</code></pre>

<p>are wrong. In those lines, the arrays decay to <code>int*</code> and they will always evaluate to true. Here's what they need to be:</p>

<pre><code>int st0 = pipe(pdes0);
int st1 = pipe(pdes1);
if(st0 &lt; 0)
{
   printf(""Error creating pipe pdes0\n"");
}
if(st1 &lt; 0)
{
   printf(""Error creating pipe pdes1\n"");
}
</code></pre>
",1
51666515,51666441,0,"<p>The increments are not working differently. They're just working on different pointers due to <a href=""https://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer"">operator precedence and associativity</a>.</p>

<p>Specifically :</p>

<pre><code>printf(""%s\n"",++*p);
</code></pre>

<p><code>++*p</code> is the same as <code>++(*p)</code> : <code>*p</code> is the first item in the <code>s</code> array, which is a pointer to <code>""knowledge""</code>. Then the <code>++</code> increments that pointer by one, so it points to ""nowledge"".</p>

<pre><code>printf(""%s\n"",*p++);
</code></pre>

<p><code>*p++</code> is the same as <code>*(p++)</code> : <code>p++</code> makes <code>p</code> point to the second item of the <code>s</code> array, which is a pointer to <code>""is""</code>. But this happens only <em>after</em> the pointer is dereferenced using <code>*</code> (it is a <em>post</em>-increment after all). So, first, <code>""nowledge""</code> is printed again (because the first pointer in the <code>s</code> array was modified in the first step), and then <code>p</code> moves to the second item, <code>""is""</code>.</p>

<pre><code>printf(""%s\n"",++*p);
</code></pre>

<p>This is again the same as the first step (but this time for the second item in the <code>s</code> array), so <code>""s""</code> is printed.</p>
",2
50787957,50787385,1,"<p>I think your FSM needs 4 states plus the end state:</p>

<ol>
<li>Zero digits read (D0).</li>
<li>One digit read (D1).</li>
<li>Two digits read (D2).</li>
<li>Digits are invalid but no more error reporting needed (DI).</li>
</ol>

<p>There are 4 different inputs, too:</p>

<ol>
<li>Digit 1-9.</li>
<li>Digit 0.</li>
<li>Other.</li>
<li>EOF.</li>
</ol>

<p>I've used a switch on state and if/else code in each state, but it leads to somewhat verbose code.  OTOH, I believe it handles inputs correctly.</p>

<pre><code>/*
** FSM
** States: 0 digits (D0), 1 digit (D1), 2 digits (D2), digits invalid (DI)
** Inputs: digit 1-9 (D), digit 0 (0), other (O), EOF.
** Action: S - save, E - error, I - ignore, P - print
** Body of FSM encodes ""action;state""
**
** State    D0      D1      D2      DI
** Input
**     D    S;D1    S;D2    E;D2    I;DI
**     O    I;D0    E;D0    P;D0    I;D0
**     0    E;D2    E;D2    E;D2    I;DI
**   EOF    I;end   E;end   P;end   I;end
*/

#include &lt;assert.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;

enum State { D0, D1, D2, DI };
enum Input { Digit, Zero, Other, End };

static int debug = 0;

static enum Input input(int *rv)
{
    int c = getchar();
    if (debug)
        printf(""Input: %c\n"", (c == EOF) ? 'X' : c);
    *rv = c;
    if (c == EOF)
        return End;
    if (isdigit(c))
    {
        *rv = c - '0';
        return (c == '0') ? Zero : Digit;
    }
    return Other;
}

static void updateMatrix(int matrix[9][9])
{
    char pair[2] = { 0, 0 };
    enum State state = D0;

    int c;
    enum Input value;
    while ((value = input(&amp;c)) != End)
    {
        switch (state)
        {
        case D0:
            if (value == Digit)
            {
                pair[0] = c;
                state = D1;
            }
            else if (value == Zero)
            {
                fprintf(stderr, ""Received zero digit - invalid\n"");
                state = DI;
            }
            else
            {
                assert(value == Other);
            }
            break;

        case D1:
            if (value == Digit)
            {
                pair[1] = c;
                state = D2;
            }
            else if (value == Zero)
            {
                fprintf(stderr, ""Received zero digit - invalid\n"");
                state = DI;
            }
            else
            {
                assert(value == Other);
                fprintf(stderr, ""Received one digit where two expected\n"");
                state = D0;
            }
            break;

        case D2:
            if (value == Digit)
            {
                fprintf(stderr, ""Received more than two digits where two were expected\n"");
                state = DI;
            }
            else if (value == Zero)
            {
                fprintf(stderr, ""Received zero digit - invalid\n"");
                state = DI;
            }
            else
            {
                assert(value == Other);
                printf(""Valid number %d%d\n"", pair[0], pair[1]);
                matrix[pair[0]-1][pair[1]-1] = 1;
                state = D0;
            }
            break;

        case DI:
            if (value == Other)
                state = D0;
            break;
        }
    }

    if (state == D2)
    {
        printf(""Valid number %d%d\n"", pair[0], pair[1]);
        matrix[pair[0]-1][pair[1]-1] = 1;
    }
    else if (state == D1)
        fprintf(stderr, ""Received one digit where two expected\n"");
}

static void dump_matrix(const char *tag, int matrix[9][9])
{
    printf(""%s:\n"", tag);
    for (int i = 0; i &lt; 9; i++)
    {
        for (int j = 0; j &lt; 9; j++)
            printf(""%4d"", matrix[i][j]);
        putchar('\n');
    }
}

int main(void)
{
    int matrix[9][9] = { 0 };

    updateMatrix(matrix);
    dump_matrix(""After input"", matrix);

    return 0;
}
</code></pre>

<p>On your test input, it produces the output:</p>

<pre class=""lang-none prettyprint-override""><code>Received zero digit - invalid
Valid number 33
Valid number 55
Valid number 21
Received more than two digits where two were expected
After input:
   0   0   0   0   0   0   0   0   0
   1   0   0   0   0   0   0   0   0
   0   0   1   0   0   0   0   0   0
   0   0   0   0   0   0   0   0   0
   0   0   0   0   1   0   0   0   0
   0   0   0   0   0   0   0   0   0
   0   0   0   0   0   0   0   0   0
   0   0   0   0   0   0   0   0   0
   0   0   0   0   0   0   0   0   0
</code></pre>

<p>On the mostly-invalid input file:</p>

<pre class=""lang-none prettyprint-override""><code>123345132
bbbb12cccc1dddd011dd
</code></pre>

<p>it produces the output:</p>

<pre class=""lang-none prettyprint-override""><code>Received more than two digits where two were expected
Valid number 12
Received one digit where two expected
Received zero digit - invalid
After input:
   0   1   0   0   0   0   0   0   0
   0   0   0   0   0   0   0   0   0
   0   0   0   0   0   0   0   0   0
   0   0   0   0   0   0   0   0   0
   0   0   0   0   0   0   0   0   0
   0   0   0   0   0   0   0   0   0
   0   0   0   0   0   0   0   0   0
   0   0   0   0   0   0   0   0   0
   0   0   0   0   0   0   0   0   0
</code></pre>

<p>You can argue (easily) that the error messages could be more informative (identifying the erroneous character, and possibly the prior valid digits), but it only produces one error message for each invalid sequence, which is beneficial.</p>
",2
49247787,49247292,1,"<p>On my Mac, this MCVE (<a href=""https://stackoverflow.com/help/mcve"">Minimal, Complete, Verifiable Example</a>) opens the Google main search page in a new tab of an already running default browser (it happens to be Firefox).</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

static void open_url(const char *url)
{
    char launch[255];
    snprintf(launch, sizeof(launch), ""open '%s'"", url);
    system(launch);
}

int main(void)
{
    open_url(""https://www.google.com/"");
    return 0;
}
</code></pre>

<p>The code doesn't ensure that the URL is not truncated (but it does ensure there is no overflow); it should be fixed.</p>

<p>You need to experiment now.</p>

<ul>
<li>Does this code work for you?</li>
<li>If so, you need to find out what's different between this and your non-operational code.</li>
<li>If not, you can start diagnosing from this.

<ul>
<li>Is the browser already running?</li>
<li>If not, does it work when the browser is running?</li>
</ul></li>
</ul>

<p>When I add a newline at the end of the URL string, I get a failure (the URL is presented as <code>https://www.google.com/%0A</code> and I get a 404 error, but the browser does respond to the <code>open</code> command).  However, your code using <code>fgets()</code> should probably use something equivalent to this:</p>

<pre><code>line[strcspn(line, ""\r\n"")] = '\0';
</code></pre>

<p>to remove line endings in the URL.</p>
",1
48931615,48931529,1,"<p><code>duration</code> is of type <code>int</code>, but you want an integer pointer as a parameter for <code>scanf</code>, </p>

<pre><code>scanf(""%d"", &amp;duration);
</code></pre>

<p><code>scanf</code> works by placing the appropriate bytes into a position in memory, so that as a side-effect after <code>scanf</code> completes, the value in memory at the pointer address provided will be the value that was read from the input. Since you want <code>duration</code> itself to contain this value, it means you want to read it into the memory location of <code>duration</code>, which is syntactically expressed as <code>&amp;duration</code> (""address of <code>duration</code>"").</p>

<p>The reason for the segmentation fault is that the integer <code>duration</code> is not initialized and therefore may contain some (undefined) value at the program start time. In terms of trying to reach a memory address by way of an integer, any integer is as good as any other, so the C runtime is happy to attempt to treat whatever value is inside <code>duration</code> as if it is a memory address, but it's a memory address that your program doesn't have permission to alter. (In many cases it will in fact be <code>0</code>, and it would be equivalent to trying to write some data into <code>NULL</code>, but this is not strictly guaranteed, and it is even theoretically possible that <code>duration</code> could randomly be initialized with an integer that does point to a valid memory location ... which could cause an even worse error by writing the result of <code>scanf</code> to that location <em>without</em> producing any visible error or segmentation fault).</p>
",0
52524159,52524105,0,"<p>You probably want to replace <code>strcpy</code> with <code>strcmp</code></p>

<p><code>strcpy(desti, ""HK"")</code> will copy the text ""HK"" into <code>desti</code> the function will succeed and since <code>strcpy</code> returns a pointer to the destination it will be a non-zero value  which wil execute the first if statement everytime.</p>

<p>The man page of <a href=""https://linux.die.net/man/3/strcpy"" rel=""nofollow noreferrer"">strcpy</a></p>

<p>Note that <code>strcmp</code> returns 0 when they are equal.</p>

<p>More information on <a href=""https://linux.die.net/man/3/strcmp"" rel=""nofollow noreferrer"">strcmp</a></p>

<p>Also note that</p>

<ul>
<li>You cannot do <code>strcpy(desti, ""HK"");</code> into a <code>char desti[2]</code>, because you didn't allocate room for the null terminator. You would have to do <code>char desti[3]</code>; if you wish to use it as a string.</li>
</ul>
",0
50236267,50235977,1,"<p>Let's be explicit.</p>

<p>First, this</p>

<pre><code>void multiplied(int *b, int *n)
</code></pre>

<p>returns an int, so say so.</p>

<pre><code>int multiplied(int *b, int *n)
</code></pre>

<p>Next, you initialised variables in main: do the same here.</p>

<pre><code>  int i, vys;
</code></pre>

<p>Like this:</p>

<pre><code>  int i=1, vys=1;
</code></pre>

<p>Now let's look at the loop:</p>

<pre><code>  while (i&lt;=n)
  {
    vys=*b**b;

    i++;
  }
</code></pre>

<p>As it stands, you are setting <code>vys</code> to something over and over again in the loop.
You want to multiply up, e.g. 2, then 2*2, then 2*2*2, .... if you want a power of two:</p>

<pre><code>  while (i&lt;=n)
  {
    vys *= *b;

    i++;
  }
</code></pre>

<p>Now, you don't need to pass pointers.</p>

<pre><code>int multiplied(int b, int n)
{
  int i=1, vys=1;
  while (i&lt;=n)
  {
    vys *= b;

    i++;
  }
  return vys;
}
</code></pre>

<hr>

<p><strong>Edit:</strong> </p>

<p>Watch out for when you call the function:</p>

<pre><code>main(void)
{
   int b=0, n=0, vys;

   //input and checking code as you have it

    multiplied(&amp;b, &amp;n); //&lt;---- return ignored
    printf(""%d"", vys); //&lt;-- print uninitialsed local variable
}
</code></pre>

<p>Change you last two lines:</p>

<pre><code>    vys = multiplied(&amp;b, &amp;n); //&lt;---- return captured
    printf(""%d"", vys); //&lt;-- print returned variable
</code></pre>

<hr>

<p><strong>Edit 2:</strong> </p>

<p>With the change to use <code>int</code> in the function and not pointers, pass the ints not their addresses:</p>

<pre><code>    vys = multiplied(b, n); //&lt;---- pass the ints not their addresses
    printf(""%d"", vys); //&lt;-- print returned variable, which should vary now
</code></pre>
",8
50455116,50454942,2,"<p>When in doubt, simplify.</p>

<pre><code>char* name1 = number_name_surname[0].name;
char* name2 = number_name_surname[1].name;

int res = strcmp(name1, name2);

if (res &lt; 0)
{
   ...
}
</code></pre>
",0
59523632,59523279,0,"<p>You should consider using <code>qsort</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int compare_chars(const void *p1, const void *p2)
  {
  return *(const char *)p1 - *(const char *)p2;
  }

char *PairSortedArrays(char *a, char *b)
  {
  char *c = malloc(strlen(a)+strlen(b)+1);

  strcpy(c, a);
  strcat(c, b);

  qsort(c, strlen(c), sizeof(char), compare_chars);

  return c;
  }

int main()
  {
  printf(""%s"", PairSortedArrays(""acdty"", ""berz""));
  return 0;
  }
</code></pre>
",2
59523356,59523279,1,"<p>When working with strings in C, you will want to be using <code>strlen()</code> to see how long they are, not <code>sizeof</code> (which merely tells you what the size of a pointer is).</p>

<p>Also note that <code>sizeof(char)</code> is 1 by definition, so there's no need to say ""<code>* sizeof(char)</code>"" in your <code>malloc</code></p>
",1
50259854,50259796,1,"<p>The declaration <code>int arr[5]</code> gives an array with five elements numbered from 0 to 4 inclusive. Accessing the 6th element, <code>arr[5]</code>, is undefined.</p>

<p>If you want five elements and a ""sentinel"" (the zero marker), you could define <code>arr</code> as</p>

<pre><code>int arr[6];
</code></pre>

<p>You should probably also initialize <code>result</code> to 0 otherwise its value is undefined since it's a local variable (in fact, the meaning of the whole program is, strictly speaking, undefined in this case).</p>
",5
55082237,55082219,0,"<pre><code>unsigned char pcDestination[] = """";
</code></pre>

<p>This defines a one-byte array on the stack, and initialized it to all zeros.</p>

<p>You don't have enough space allocated for the string you're trying to copy.</p>

<p>Try:</p>

<pre><code>    unsigned char pcDestination[5];
</code></pre>

<p>You have another problem: your function leaves the destination sting not nul-terminated.</p>
",0
53453194,53452913,5,"<p>This is a really dumb way to solve this problem, but it uses neither arrays nor bit vectors:</p>

<pre><code>#include &lt;stdbool.h&gt;
bool numberHasDigit(unsigned n, unsigned digit) {
  while (n) {
    if (n % 10 == digit) return true;
    n /= 10;
  }
  return false;
}
unsigned sumOfUniqueDigits(unsigned n) {
  unsigned sum = 0;
  for (unsigned digit = 1; digit &lt;= 9; ++digit) {
    if (numberHasDigit(n, digit)) sum += digit;
  }
  return sum;
}
</code></pre>

<p>It's dumb because using an array (or bit vector) of flags is much faster, particularly for big numbers, and the code is just as simple:</p>

<pre><code>unsigned sumOfUniqueDigits(unsigned n) {
  bool seen[10] = {false};
  unsigned sum = 0;
  while (n) {
    unsigned digit = n % 10;
    if (!seen[digit]) {
      sum += digit;
      seen[digit] = true;
    }
    n = n / 10;
  }
  return sum;
}
</code></pre>
",2
49882132,49881976,3,"<blockquote>
  <p>and is it the same code as below?</p>
</blockquote>

<p>No its is not the same, that code is logically equal to:</p>

<pre><code>if( pattern[j] == *(char *)(base + i + j) ) found = found &amp; 1;
else found = 0; // or found = found &amp; 0; which has the same effect
</code></pre>
",0
54732497,54730510,0,"<p>In your code, <code>switch(ch)</code> causes control to jump to the <code>case</code> label whose expression matches the value of <code>ch</code> (if there is one). Since <code>ch</code> has the value <code>'a'+'b'</code>, and <code>'a'+'b'</code> equals <code>'b'+'a'</code>, control jumps to the <code>case 'b'+'a'</code>.</p>

<p>Incidentally, when one wants each section of code in a <code>switch</code> statement to be separate, one must put a <code>break;</code> statement at the end of each section (or some other jump statement), as in:</p>

<pre><code>switch (ch)
{
    case 'a':
    case 'b':
        printf(""You entered a or b.\n"");
        break;
    case 'A':
        printf(""A as in ashar.\n"");
        break;
    case 'b'+'a':
        printf(""You entered a and b.\n"");
        break;
}
</code></pre>

<p>Also note that you will not obtain the value <code>'a'+'b'</code> when a user enters the characters ¡°a¡° and ¡°b¡±. In C, <code>'a'+'b'</code> is the sum of the numerical code for the character <code>a</code> and the numerical code for the character <code>b</code>. It is not a string concatenation of the two characters.</p>
",0
49952924,49952852,1,"<p>Read more about C programming (first some good tutorial book, then some <a href=""http://en.cppreference.com/w/c"" rel=""nofollow noreferrer"">reference site</a>, and later refer to the C11 standard <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">n1570</a>). We cannot teach you it in a few paragraphs.</p>

<p>C uses a <a href=""https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value"" rel=""nofollow noreferrer"">call-by-value evaluation strategy</a>.</p>

<p><sup>So, at least for newbies, it is conventionally recommended (but not required) to never use a formal argument as the left-side destination of some assignment, because any change to a formal argument is <em>local</em> to the function having that formal argument and does not impact the caller.</sup></p>

<p>So, <strong>Compile with all warnings and debug info</strong>: <code>gcc -Wall -Wextra -g</code> with <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a>. <strong>Use the debugger</strong> (e.g. <a href=""https://sourceware.org/gdb/current/onlinedocs/gdb/"" rel=""nofollow noreferrer""><code>gdb</code></a>) to understand the behavior of your program (your bug is probably not in the code chunk you show us).</p>

<p><sup>Ability to understand the behavior of an entire program, and to debug it, is an essential skill for developers. Both the compiler's warnings and the debugger can assist you in understanding the behavior of a program. See also <a href=""http://norvig.com/21-days.html"" rel=""nofollow noreferrer"">http://norvig.com/21-days.html</a> for a useful insight.</sup></p>

<p>So the <code>head</code> formal argument in <code>insert</code> is a <em>local copy</em> of the actual argument from the caller.</p>

<p>In </p>

<pre><code>if(head == NULL)
{
    head = p;
    return head;
}
</code></pre>

<p>you modify only that copy, not the original. So the <code>head = p;</code> above is completely useless (and confusing), you'll better just replace the block in braces above with simply <code>return p;</code></p>

<p>We don't know how you call <code>insert</code>, and we cannot help more.</p>

<p>Perhaps <code>insert</code> should get the <em>address</em> of some pointer.... or perhaps your <code>main</code> should use the return value of it...</p>

<p>In your edited question, inside your <code>main</code>, replace</p>

<pre><code>    insert(head,x); //WRONG
</code></pre>

<p>(which does not change the local <code>head</code> declared in <code>main</code>, even if <code>insert</code> is changing its first formal, because of call by value argument passing) with</p>

<pre><code>    head = insert(head, x);
</code></pre>
",5
54600441,54599985,2,"<pre><code>static int Stuff(Color sn_color, Color *color, char *name, char *direction)
{
    set_sensor_mode(sn_color, ""COL-COLOR"");
    get_sensor_value(0, sn_color, color);
    printf(""%s_color is %d\n"", name, *color);
    if (*color == 3)
    {
        printf(""turn %s\n"", direction);
        killMotors(0);
        return 0;
    }
    return 1;
}

¡­
    int DoPidLine;

    if (rx_color &lt;= 60)
        DoPidLine = Stuff(sn_rx_color, &amp;rx_color, ""rx"", ""right"")
    else if (lx_color &lt;= 60)
        DoPidLine = Stuff(sn_lx_color, &amp;lx_color, ""lx"", ""left"")
    else
        DoPidLine = 1;
    if (DoPidLine)
        pidLine(speed);
</code></pre>

<p>The latter part, from the ¡°¡­¡± down, could be a single statement:</p>

<pre><code>if (rx_color &lt;= 60 ? Stuff(sn_rx_color, &amp;rx_color, ""rx"", ""right"") :
    lx_color &lt;= 60 ? Stuff(sn_lx_color, &amp;lx_color, ""lx"", ""left"" ) :
    1)
    pidLine(speed)
</code></pre>

<p>Another alternative is:</p>

<pre><code>static void Stuff(Speed speed, Color sn_color, Color *color, char *name, char *direction)
{
    if (name)
    {
        set_sensor_mode(sn_color, ""COL-COLOR"");
        get_sensor_value(0, sn_color, &amp;color);
        printf(""%s_color is %d\n"", name, color);
        if (color == 3)
        {
            printf(""turn %s\n"", direction);
            killMotors(0);
            return 0;
        }
    }
    pidLine(speed);
}

¡­
    if (rx_color &lt;= 60)
        Stuff(speed, sn_rx_color, &amp;rx_color, ""rx"", ""right"")
    else if (lx_color &lt;= 60)
        Stuff(speed, sn_lx_color, &amp;lx_color, ""lx"", ""left"")
    else
        Stuff(speed, 0, 0, 0, 0);
</code></pre>
",1
48996081,48995950,3,"<p>The problem is in the line</p>

<pre><code>Allouer(debut);
</code></pre>

<p>The value returned from <code>Allouer</code> is not used. Not only do you not see <code>debut</code> set to a valid pointer but also the program suffers from a memory leak. Change it to:</p>

<pre><code>debut = Allouer(debut);
</code></pre>

<hr>

<p>Suggestion for further improvement.</p>

<p><code>Allouer</code> does not use the input argument. It will be better to remove it.</p>

<pre><code>ptr Allouer()
{
   return malloc( sizeof(struct maillon) );
}
</code></pre>

<p>Then, it's usage can be changed to:</p>

<pre><code>debut = Allouer();
</code></pre>
",6
55047536,55047405,3,"<p>The length of a number is based on its logarithm base 10:</p>

<pre><code>#include &lt;math.h&gt; //log10
....
    int len = log10(cardNo) + 1;
...
</code></pre>

<p>Don't forget to link with the math library (<code>gcc ... -lm</code>)</p>
",5
55047574,55047405,0,"<p>Idiom: measure-allocate-generate.</p>

<pre><code>size_t n =0;
for (; i &lt; cardno; ) {
  cardNo /= 10;
  n++;
} 
if(!n)n++;//0
int*digits=malloc(n*sizeof(int));
</code></pre>
",4
49187580,49187487,1,"<p>Problems I see:</p>

<h3>Problem 1</h3>

<p>Don't use <code>gets</code>. It's a security hole. Use <code>fgets</code> instead.</p>

<pre><code>fgets(str[i], 40, stdin);
</code></pre>

<h3>Problem 2</h3>

<p>You are using incorrect size for <code>word</code>. It needs to be of size <code>40</code>.</p>

<pre><code>char word[40];
</code></pre>

<h3>Problem 3</h3>

<p>You are returning a pointer to the first element of <code>word</code> from 
<code>longestStrInArr</code>. However, that memory is invalid once the function returns. Hence, your program has undefined behavior.</p>

<p>You can fix it by returning the index of the longest string in <code>str</code> or by providing an input argument long enough to hold the longest string.</p>

<pre><code>size_t longestStrInAr(char str[N][40], int size, int *length)
{
   size_t index = 0
   size_t i,j=0;
   int len = 0;
   *length = 0;

   for(i=0;i&lt;size;i++){
      while(str[i][j]!='\0'){
         len++;
         j++;
      }
      if(*length&lt;len){
         *length = len;
         index = i;
      }
   }
   return index;
}
</code></pre>

<p>and then use it as:</p>

<pre><code>size_t index = longestStrInAr(str, size, &amp;length);
printf(""longest: %s \nlength: %d\n"", str[index], length);
</code></pre>
",1
50204645,50204536,2,"<p>Here:</p>

<pre><code>double *measurements;
measurements = malloc(num_rep * sizeof(uint32_t));
</code></pre>

<p>should be</p>

<pre><code>double *measurements;
measurements = malloc(num_rep * sizeof(double));
</code></pre>

<p>I also suspect this</p>

<pre><code>double AVG_LPA;

for (int i = 0; i &lt; num_rep; i++)
    AVG_LPA = +measurements[i];
</code></pre>

<p>isn't doing what you think. Perhaps</p>

<pre><code>double AVG_LPA = 0.0;

for (int i = 0; i &lt; num_rep; i++)
    AVG_LPA += measurements[i];
</code></pre>
",1
52750258,52750077,0,"<p>Here is your question converted into an MCVE (<a href=""https://stackoverflow.com/help/mcve"">Minimal, Complete, Verifiable Example</a>):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    char riga_corrente[200] = ""apelle figlio di apollo"";
    char stringa[] = ""pelle"";
    char compresso_s[] = ""$11$"";
    char temp[200];

    strcpy(temp, strtok(riga_corrente, stringa));
    strcat(temp, compresso_s);
    strcat(temp, strtok(NULL, stringa));
    strcpy(riga_corrente, temp);
    printf(""[%s]\n"", riga_corrente);

    return 0;
}
</code></pre>

<p>This produces the following output, which means the library functions are working as designed (but apparently not as you expected):</p>

<pre><code>[a$11$ fig]
</code></pre>

<p>The first call to <code>strtok()</code> stops at the <code>p</code> in <code>apelle</code>, zapping it with a null byte, and returning a pointer to the <code>a</code>, which is copied into <code>temp</code>.  You then append the <code>$11$</code> from <code>compresso_s</code>.  The next call to <code>strtok()</code> skips over the <code>e</code>, <code>l</code>, <code>l</code> and <code>e</code> of <code>apelle</code> and starts the token at the blank.  The letters <code>f</code>, <code>i</code>, <code>g</code> don't match the delimiters, but <code>l</code> does, so the <code>l</code> in <code>figlio</code> is zapped with a null byte and a pointer to the blank is returned.  This string is correctly added to the end of <code>temp</code>, and then <code>temp</code> overwrites <code>riga_corrente</code> because of the <code>strcpy()</code>.</p>

<p>At first glance, you could fix it by changing the delimiter in the second call to <code>strtok()</code>, maybe to just a newline, or even an empty string.  However, that leaves the <code>elle</code> of <code>apelle</code> as part of the output too.  Fixing that requires different technology ¡ª possibly using the underrated (and little known) <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strspn.html"" rel=""nofollow noreferrer""><code>strspn()</code></a> and <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strcspn.html"" rel=""nofollow noreferrer""><code>strcspn()</code></a> functions that have been in Standard C since the 1989 edition, or possibly using <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strstr.html"" rel=""nofollow noreferrer""><code>strstr()</code></a> to find the string <code>pelle</code>.</p>

<p>It's not very elegant (there's probably a function in here trying to escape), but this works:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    char riga_corrente[200] = ""apelle figlio di apollo"";
    char stringa[] = ""pelle"";
    char compresso_s[] = ""$11$"";
    char temp[200];

    char *source = riga_corrente;
    char *p1 = strstr(source, stringa);
    if (p1 == NULL)
        strcpy(temp, source);
    else
    {
        *p1 = '\0';
        strcpy(temp, source);
        source = p1 + strlen(stringa);
    }
    strcat(temp, compresso_s);
    if (p1 != NULL)
    {
        p1 = strstr(source, stringa);
        if (p1 == NULL)
            strcat(temp, source);
        else
        {
            *p1 = '\0';
            strcat(temp, source);
        }
    }
    strcpy(riga_corrente, temp);
    printf(""[%s]\n"", riga_corrente);

    return 0;
}
</code></pre>

<p>There's no buffer overflow protection etc here; it usually won't be needed, but in principle, if <code>pelle</code> never appeared in <code>riga_corrente</code>, you could get a buffer overflow.</p>
",0
54292472,54292411,6,"<p><code>typedef struct tit *TITOLO;</code> defines TITOLO as a pointer type, not a struct type. Get rid of this and typedef the struct instead:</p>

<pre><code>typedef struct {
    char nome[20];
} TITOLO;

TITOLO* titolo = malloc(4*sizeof(*titolo));
</code></pre>
",1
49093130,49093081,3,"<p>The problem is that your declaration is in the wrong place.</p>

<pre><code>if(option==1)
{
    struct student st[9];
    ...
}
</code></pre>

<p>This declaration is only visible inside the <code>if(option==1)</code> clause, but you try and use it inside <code>else if(option == 2)</code></p>

<p>I'm guessing that you should move the declaration to the start of your program</p>

<pre><code>void main()
{
    int option, i;
    struct student st[9];
</code></pre>

<p>You should read about a couple of concepts that are important when you use variables, <em>scope</em> which is the area of your program where the variable is visiable, and <em>extent</em> which is the time for which you variable exists. Both were wrong in the code you wrote.</p>

<p>There are lots of other errors in your code, but I guess you'll find out about those as you go a long.</p>
",5
51446178,51446150,4,"<p>By passing a non-NUL-terminated string to <code>printf(""%s"")</code>, you're invoking <em>undefined behavior</em>.</p>

<p>By its very nature, the result is undefined. It may seemingly ""work"" (like you're seeing).</p>

<hr>

<p>As others have explained, what's probably happening is that there happens to be a zero byte after your string, which stops <code>printf</code> from going further. However, if you were to add more <em>stuff</em> around that variable, you'd probably see different behavior:</p>

<pre><code>#include&lt;stdio.h&gt;

int main(void)
{
    char sentence[8] = ""September"";        // NOT NUL TERMINATED!
    char stuff[] = ""This way is better"";

    printf(""%s\n"", sentence);              // Will overrun sentence
    return 0;
}
</code></pre>
",0
54254744,54254580,0,"<p><code>malloc</code> itself returns a void pointer as it doesn't really know for which type you are allocating memory. So, you need to use the same size which you pass to <code>malloc</code> for clearing the buffer also. </p>

<p>You can use <code>memset</code> and pass the size of the entire buffer to clear it without having to worry about it's type.</p>

<pre><code>void clean_buffer( void *ptr, size_t n)
{
    memset(ptr, 0, n)
}
int main(void)
{
   float  *pf;
   int    *pi;

   pf = (float *) malloc(10*sizeof(float));
   pi = (int *)malloc(10*sizeof(int));


   clean_buffer(pf, 10*sizeof(float));
   clean_buffer(pi, 10*sizeof(int));

    return 0;
}
</code></pre>

<p>Additionally, as others have suggested, you can use <code>calloc</code> if it suits you.</p>
",0
54254661,54254580,0,"<p>You cast <code>ptr</code> to the appropriate type so it can dereferenced to clear what it points to; something you know points to a type that you want to clear <code>i</code> items of.</p>
",0
54254692,54254580,2,"<p><em>void</em> is a non value you cannot use <code>*((void*) x) = v;</code> and to use a <em>cast</em> to use a pointer to an other type is <strong>dangerous</strong> because the size may not be the same</p>

<p>But, in your case you set to 0, so you can use <em>memset</em> or replace the <em>malloc</em> my <em>calloc</em> and it is useless to have <code>clean_buffer</code> :</p>

<pre><code>int main(void)
{
   float  *pf;
   int    *pi;

   pf = calloc(10, sizeof(float));
   pi = calloc(10, sizeof(int));

   return 0;
}
</code></pre>
",4
53323621,53323571,5,"<p>The <code>struct</code> tags live in <em>different</em> namespace - they don't name types. There is also indeed a function named <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/stat.html"" rel=""nofollow noreferrer""><code>stat</code></a>.</p>

<p>You must use</p>

<pre><code>sizeof (struct stat)
</code></pre>

<p>to get the size of the <a href=""http://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/stat.h.html"" rel=""nofollow noreferrer""><code>struct</code> with the tag <code>stat</code></a>.</p>

<p>If you use <code>sizeof (stat)</code> (i.e. <code>sizeof stat</code>), the <code>stat</code> <em>function</em> will be converted to pointer-to-function, and that's what <code>sizeof</code> evaluates, resulting in e.g. 4 or 8, depending on the width of the pointer.</p>

<hr>

<p><em>If</em> there was a <em>typedef</em>, then that could be used instead of <code>struct stat</code> without the <code>struct</code> keyword:</p>

<pre><code>typedef struct stat STAT;

...

sizeof (STAT)
</code></pre>

<hr>

<p>Even better: remove the cast to <code>(void*)</code> - it is needless in C. And use <code>sizeof</code> with the <em>variable instead</em>:</p>

<pre><code>memset(&amp;myStruct, 0, sizeof myStruct);
</code></pre>

<p>Notice that <code>sizeof</code> needs parentheses only for types and not for expressions.</p>
",5
49331063,49331034,0,"<p><code>twenties</code>, <code>tens</code>, etc. are pointer type. You need to dereference the pointer types when you do calculation:</p>

<pre><code>void pay_amount (int dollars, int *twenties, int *tens, int *fives, int *ones)
{

  int reduced_amount;

  printf(""Enter a dollar amount: "");
  scanf(""%d"", &amp;dollars);

  *twenties = dollars / 20;
  reduced_amount = dollars - (20 * (*twenties));

  *tens = reduced_amount / 10;
  reduced_amount = reduced_amount - (10 * (*tens));

  *fives = reduced_amount / 5;

  *ones = reduced_amount - (5 * (*fives));

}
</code></pre>
",1
55652658,55652586,1,"<p>Because <code>c</code> has automatic storage duration (i.e. is a non-static local variable) and is uninitialized, its value is <strong>indeterminate</strong>.  Attempting to print an uninitialized variable that never had its address taken (i.e. was not the subject of the address-of operator <code>&amp;</code>) invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>Even if you did take the address of <code>c</code> you could still have undefined behavior if it contains a trap representation.  If it does not contain a trap representation (and most implementations don't have them), the the value is <strong>unspecified</strong> which simply means the printed value can't be predicted.</p>
",2
49470935,49470783,4,"<p>If you're using <a href=""https://stackoverflow.com/questions/49470783/use-the-letter-%c3%b1-in-c/49470935?noredirect=1#comment85944221_49470783"">High Sierra</a>, you are presumably using a Mac running macOS 10.13.3 (High Sierra), the same as me.</p>

<p>This comes down to code sets and locales ¡ª and can get tricky.  Mac terminals use UTF-8 by default and <code>?</code> is Unicode character U+00F1, which requires two bytes, 0xC3 and 0xB1, to represent it in UTF-8.  And the compiler is letting you know that one byte isn't big enough to hold two bytes of data. (In the single-byte code sets such as ISO 8859-1 or 8859-15, ? has character code 0xF1 ¡ª 0xF1 and U+00F1 are similar, and this is not a coincidence; Unicode code points U+0000 to U+00FF are the same as in ISO 8859-1.  ISO 8859-15 is a more modern variant of 8859-1, with the Euro symbol  and 7 other variations from 8859-1.)</p>

<p>Another option is to change the character set that your terminal works with; you need to adapt your code to suit the code set that the terminal uses.</p>

<p>You can work around this by using <code>wchar_t</code>:</p>

<pre><code>#include &lt;wchar.h&gt;

void function(void);

void function(void)
{
    wchar_t example[1];
    example[0] = L'?';
    putwchar(example[0]);
    putwchar(L'\n');
}

#include &lt;locale.h&gt;

int main(void)
{
    setlocale(LC_ALL, """");
    function();
    return 0;
}
</code></pre>

<p>This compiles; if you omit the call to <code>setlocale(LC_ALL, """");</code>, it doesn't work as I want (it generates just octal byte <code>\361</code> (aka <code>0xF1</code>) and a newline, which generates a <code>?</code> on the terminal), whereas with <code>setlocale()</code>, it generates two bytes (<code>\303\261</code> in octal, aka <code>0xC3</code> and <code>0xB1</code>) and you see <code>?</code> on the console output.</p>
",2
49470930,49470783,2,"<p>You can use ""extended ascii"".  This <a href=""http://www.theasciicode.com.ar/extended-ascii-code/enie-spanish-enye-lowercase-letter-n-tilde-ascii-code-164.html"" rel=""nofollow noreferrer"">chart</a> shows that '?' can be represented in extended ascii as 164.</p>

<pre><code>example[0] = (char)164;
</code></pre>

<p>You can print this character just like any other character</p>

<pre><code>putchar(example[0]);
</code></pre>

<p><em>As noted in the comments above, this will depend on your environment.  It might work on your machine but not another one.</em></p>

<p>The better answer is to use unicode, for example:</p>

<pre><code>wchar_t example = '\u00F1';
</code></pre>
",6
49470956,49470783,1,"<p>This really depends on which character set / locale you will be using. If you want to hardcode this as a latin1 character, this example program does that:</p>

<pre><code>#include &lt;cstdio&gt;

int main() {
    char example[2] = {'\xF1'};
    printf(""%s"", example);
    return 0;
}
</code></pre>

<p>This, however, results in this output on my system that uses UTF-8:</p>

<pre><code>$ ./a.out 
?
</code></pre>

<p>So if you want to use non-ascii strings, I'd recommend not representing them as char arrays directly. If you <em>really</em> need to use char directly, the UTF-8 sequence for <code>?</code> is two chars wide, and can be written as such (again with a terminating '\0' for good measure):</p>

<pre><code>char s[3] = {""\xC3\xB1""};
</code></pre>
",0
49211202,49210968,0,"<p>Your <code>scanf(""%i"", &amp;num)</code> only returns when the user presses return/enter, if they've previously typed some non-whitespace characters into the terminal.  If the user presses return on an empty line, the function will continue to wait for a non-whitespace characters.</p>

<p>If you type a non-numeric value, before you press return, you'll exit the <code>while</code> loop.</p>
",0
49113012,49109072,1,"<p>Several issues should be corrected:</p>

<p>1) Faulty comparisons:</p>

<pre><code>if(gender='M') // always true; should be if(gender=='M')
if((gender = 'F') // always true; should be if(gender=='M')
</code></pre>

<p>2) Logic of the program is faulty, it would print <code>Ideal Weight</code> for female and male
if the height is above <code>152.4</code></p>

<p>3) Lots of the repetitive code which should be encapsulated in the functions.</p>

<p>4) Lack of error handling for wrong gender symbol.</p>

<p>5) Proper spelling and printout is needed. Correct: <code>Idle Wigh</code></p>

<p>6) There is no need to print weight as <code>74.3456789</code>
One digit after <code>.</code> is sufficient.</p>

<p>7) The constant magic numbers should probably be defined outside main, like:</p>

<pre><code>#define MAGIC_HEIGHT 152.4
</code></pre>

<p>8) Clarity of the program can be improved with the use of <code>switch</code> and <code>case</code>:</p>

<p>Example:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;

#define M_MIN         48.0
#define F_MIN         45.0
#define FACTOR         1.1
#define MAGIC_HEIGHT 152.4

void print_ideal_weight(float iw)
{
    printf(""\nYour Ideal weight should be = %.1f"", iw);
}

float calculate_ideal_weight(float m, float height)
{
    float iw;

    if(height &lt; MAGIC_HEIGHT){

        iw = m - (MAGIC_HEIGHT - height) * FACTOR;
    }
    else{
        iw = m + (height - MAGIC_HEIGHT) * FACTOR;
    }            
    return iw;
}

int main()
{
    int age;
    float height, iw;
    char gender;

    printf(""Please Enter your Age, Height(in CM) and Gender(F/M): \n"");

    scanf(""%d\n%f\n%c"", &amp;age, &amp;height, &amp;gender);

    switch (gender)
    {
        case 'M':
            iw = calculate_ideal_weight(M_MIN,height);
            print_ideal_weight(iw);
        break;

        case 'F':
            iw = calculate_ideal_weight(F_MIN,height);
            print_ideal_weight(iw);
        break;

        default:
            printf(""Unknown gender entered!\n"");
        break;
    }

    getch();
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>Please Enter your Age, Height(in CM) and Gender(F/M):                                                             
25                                                                                                                
176                                                                                                               
M                                                                                                                 

Your Ideal weight should be = 74.0  
</code></pre>
",1
54467077,54466960,1,"<p>In the first case, you're attempting to run your C source file as a shell script.  That's not how you run a C program.  You do it by first compiling the program and running the resulting executable.</p>

<p>The reason you're getting a compilation error is because you're using the <code>cos</code> function which resides in the math library which is not linked in by default.  You need to add <code>-lm</code> at the end of your compilation command to link that library in.</p>

<pre><code>gcc -g -Wall -Wextra -o math_functions math_functions.c -lm
</code></pre>

<p>Also, the reason you're getting the warning about return type defaulting to <code>int</code> is is that your main function doesn't have a specified return type. Put an int before the declaration and you'll be fine, ie</p>

<pre><code>int main()
</code></pre>
",0
55869322,55867198,0,"<p>As @KillianG. already answered, it looks like you may have muddied the issue for yourself by defining and using the <code>String</code> type.  In general, it tends to be more harmful than helpful to define types that disguise pointer nature, as that one does.</p>

<p>I think the deepest problem here is that you have defined your data structure differently than you meant to do.  Given the type</p>

<blockquote>
<pre><code>typedef char* String;
</code></pre>
</blockquote>

<p>You might write code like this ...</p>

<pre><code>String a_name = ""Alice"";
</code></pre>

<p>... but your structure is not analogous:</p>

<blockquote>
<pre><code>typedef struct{
  String Name[10];
  String ID[6];
  float yo;
}data;
</code></pre>
</blockquote>

<p>You have defined the <code>Name</code> member to be an array <em>of <code>String</code>s</em>, so ten pointers, whereas it seems likely that you instead want an array of <code>char</code>, suitable for holding one C string:</p>

<pre><code>typedef struct {
  char Name[10];
  char ID[6];
  float yo;
} data;
</code></pre>

<p>Alternatively, perhaps you want <code>Name</code> to be a single string, in which case you should declare it that way:</p>

<pre><code>  String Name;
  // equivalent to: char *Name;
</code></pre>

<p>There is no need or capability to set a maximum string length in the latter case, because such a thing is not an attribute of a <code>char *</code>; the length of a C string is a function of the character data, not of the array containing them.</p>

<p>Let's supposing you go with the first alternative,</p>

<pre><code>  char Name[10];
</code></pre>

<p>Now you have to handle the fact that C does not provide an operator for whole-array copying.  In particular, the left-hand operand of an <code>=</code> operator cannot be a whole array.  Instead, you can populate arrays element-by-element, or via various functions that have that effect (<code>memcpy</code>, <code>memmove</code>).  There is a subfamily of such functions specific to copying string data: <code>strcpy</code>, <code>strncpy</code>, <em>etc</em>..  Given that the string (<em>not <code>String</code>!</em>) <code>""Charles""</code> is known to require only 8 chars, including its terminator, the idiomatic way to copy that data into an existing <code>data</code> object's <code>Name</code> member would be via <code>strcpy()</code>:</p>

<pre><code>data user[3][3];

// This:
strcpy(user[0][0], ""Charles"");
</code></pre>
",0
49153296,49149005,2,"<p>The actual algorithm here is the easy part, simply declare an array of pointers to string literals and use that as look-up table:</p>

<pre><code>const char* TEXTUAL [11] = 
{
  ""zero"",
  ""one"",
  ""two"",
  ""three"",
  ""four"",
  ""five"",
  ""six"",
  ""seven"",
  ""eight"",
  ""nine"",
  ""ten""
};  

printf(""%s"", TEXTUAL[value]);
</code></pre>

<p>The hard part here is all the error checking. You have to read two integers from the user, check that they are valid and in range -10 to 10. Then check that the result is in range as well.</p>

<p>I made an example that you can look at for hints. How to safely read integers in C is a chapter of it's own, I made a function <code>read_2_int</code> that reads user input in a safe manner. If you are a beginner, just ignore that function for now and use <code>scanf(""%d"", &amp;var)</code>. </p>

<p>In order to handle negative numbers I used the function <code>labs</code> to get the absolute value of an integer.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdbool.h&gt;

static void halt_and_catch_fire (const char* err);
static void read_2_int (int* i1, int* i2);

int main (void)
{
  int n1;
  int n2;

  printf(""Enter your two integers: "");
  read_2_int(&amp;n1, &amp;n2);


  if(n1 &gt; 10 || n1 &lt; -10 || n2 &gt; 10 || n2 &lt; -10)
  {
    halt_and_catch_fire(""Only numbers from -10 to 10 supported."");
  }
  if(n1+n2 &gt; 10 || n1+n2 &lt; -10)
  {
    halt_and_catch_fire(""The sum must be from -10 to 10."");
  }


  const char* TEXTUAL [11] = 
  {
    ""zero"",
    ""one"",
    ""two"",
    ""three"",
    ""four"",
    ""five"",
    ""six"",
    ""seven"",
    ""eight"",
    ""nine"",
    ""ten""
  };  


  if(n1 &lt; 0){ printf(""minus ""); }
  printf(""%s + "", TEXTUAL[labs(n1)] ); // labs = absolute value
  if(n2 &lt; 0){ printf(""minus ""); }
  printf(""%s = "", TEXTUAL[labs(n2)] );
  if(n1 + n2 &lt; 0) { printf(""minus ""); }
  printf(""%s\n"", TEXTUAL[labs(n1+n2)] );
}


static void halt_and_catch_fire (const char* err)
{
  /* some manner of error handling here */
  fprintf(stderr, err);
  exit(EXIT_FAILURE);
}

static void read_2_int (int* i1, int* i2)
{
  char input[10];

  if(fgets(input, 10, stdin) == NULL)
  {
    halt_and_catch_fire (""You have to type two integers."");
  }

  char* endptr;
  *i1 = strtol(input, &amp;endptr, 10);
  if(endptr == input)
  {
    halt_and_catch_fire (""Bad number format"");
  }

  char* next = endptr;
  *i2 = strtol(next, &amp;endptr, 10);
  if(endptr == next)
  {
    halt_and_catch_fire (""You have to type two integers."");
  }
}
</code></pre>
",0
50979378,50979357,0,"<p>When macro substitution is done, it creates separate tokens, unless you use the token pasting operator <code>#</code>. So the result after all the macro expansions is</p>

<pre><code>printf(""The value of A is %dn"", - - 5);
</code></pre>

<p>While <code>--5</code> is invalid, <code>- - 5</code> is OK. It negates <code>5</code> twice, and the negations cancel each other out, resulting in <code>5</code>.</p>
",0
49762640,49761167,3,"<p>Your two <code>float</code> variable-length arrays occupy 2*900<sup>2</sup>*4 bytes  - that is a little over 6Mb.  VLAs are typically created on the stack, the size of which will vary between systems and processes, but on a modern desktop system is typically perhaps 2 to 8 Mb.</p>

<p>Creating an array that large on the stack is somewhat unreasonable, and failure unsurprising.</p>
",1
50975253,50975068,1,"<p>A <code>#define</code> performs a symbol substitution prior to the compiler being run.  So after substitution the condition will be exactly equivalent to:</p>

<pre><code>if(numdev &lt; 500)
</code></pre>

<p>It doesn't matter how ""obvious"" the definition of <code>MaxCfgDev</code> is.  If it evaluates to a compile time constant that is 256 or larger the condition will always be true, and the compiler may optimize out the test. </p>
",0
50881088,50881057,6,"<p>Yes you can, but your pointer <code>c</code> doesn't actually point anywhere. That means when <code>scanf</code> will dereference the pointer you will have <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""noreferrer""><em>undefined behavior</em></a>.</p>

<p>This is one place where you use the <em>address-of</em> operator <code>&amp;</code>:</p>

<pre><code>char c;
scanf("" %c"", &amp;c);
</code></pre>

<hr>

<p>And some nitpicking about your phrasing ""create a pointer to a single [anything]"". That's really what <em>all</em> pointers are, pointers to a single something.</p>

<p>A string is typically seen as a pointer to <code>char</code>, but the pointer actually only points to the <em>first</em> character in the string. That the program handles it as a string is just a convention to treat the first character as the first element of an array, which is terminated by a special character.</p>
",5
49464540,49464393,1,"<p>Start by examining the arithmetics behind the problem:</p>

<ul>
<li><code>4*size-1</code> is the length of the top row of <code>#</code>, i.e. the <code>width</code> of your printout</li>
<li>Each row has an offset of spaces</li>
<li>The number of spaces starts at zero for the initial row, and increases by 2</li>
</ul>

<p>These three observations should be enough to construct a program. Start row and column numbers at zero for consistency. Each row should be <code>width</code> characters long. Decide which character to print using this formula:</p>

<pre><code>if (column &gt;= offset &amp;&amp; column &lt; width-offset) {
    printf(""#"");
} else {
    printf("" "");
} 
</code></pre>

<p><a href=""https://ideone.com/bmMK6W"" rel=""nofollow noreferrer"">Demo.</a></p>
",0
48125987,48125763,5,"<p>After</p>

<pre><code>char* s = malloc(5);
</code></pre>

<p>s is <em>pointing</em> to the allocated memory</p>

<p>with</p>

<pre><code>s = ""Hello World !"";
</code></pre>

<p>you set s to <em>point</em> to another place in memory, you are not copying the string to where s is pointing. For that you need to use strcpy or memcpy.</p>
",0
49931748,49931709,0,"<p><code>arr</code> is defined to be an array of <code>int</code>s.  It looks you mean for it to be an array of <code>card_t</code>s.  You probably also want to initialize <code>random_position</code> before you use it in <code>card_t temp = arr[random_position]</code>.</p>

<p>Update:
You also never pass in from or return the <code>arr</code> to your main.  (Is there an array of cards in <code>shoe</code> that you're trying to shuffle?)</p>
",6
51029154,51028463,0,"<p>There is another way just enter the entire numbers and they will be separated:</p>

<pre><code>int number, result;
printf(""Please, enter four numbers: "");
scanf(""%d"", &amp;number);
while (number &gt; 0) {
    result = number % 10;
    number /= 10;
    printf(""%d\n"", result);
}
printf(""\n"");
</code></pre>

<p><strong>The result:</strong> </p>

<p>Please, enter four numbers: 1234<br>
4<br>
3<br>
2<br>
1  </p>
",0
49674051,49673977,3,"<p>This:</p>

<pre><code>scanf("" %c"",&amp;b[i].name);
</code></pre>

<p>looks super wrong, it reads a single character which doesn't make sense as a name, and also doesn't match your usage.</p>

<p>You likely meant:</p>

<pre><code>scanf(""%19s"", b[i].name);
</code></pre>

<p>but that's bad too, since <code>%s</code> will stop at whitespace and book titles can have multiple words. Better to use <code>fgets()</code> to get full lines, then parse them.</p>

<p>Make sure you <em>check the return value</em> of all <code>scanf()</code> calls before relying on them having succeeded! I/O is brittle and can fail.</p>
",1
48150779,48149462,1,"<p>If you are using Windows, the control character 0x1A (Control-Z or SUB) will be treated as an end-of-file indication. </p>

<p>You can avoid that by opening the file in binary mode (using ""rb"" instead of ""r"" in the <code>fopen</code>, but then you will find that all of your lines have a <code>\r</code> (0x0D) at the end. (In text mode, line endings are corrected to a single <code>\n</code>.)</p>
",3
49865144,49864685,0,"<p>It would be better to shift the mask than to modify the original value - that is aan unnecessarily <em>destrictove</em> algorithm, and since that is a known value you can simply use constants:</p>

<pre><code>printf(""%d"", x &amp; 0x20 ? 1 : 0);
printf(""%d"", x &amp; 0x10 ? 1 : 0); 
printf(""%d"", x &amp; 0x08 ? 1 : 0);
printf(""%d"", x &amp; 0x04 ? 1 : 0); 
printf(""%d"", x &amp; 0x02 ? 1 : 0); 
printf(""%d"", x &amp; 0x01 ? 1 : 0);
</code></pre>

<p>Or use a loop and a _alking-one mask:</p>

<pre><code>unsigned mask = 0x20 ;
while( mask != 0 )
{
    printf(""%d"", x &amp; mask ? 1 : 0);  
    mask &gt;&gt;= 1 ;   
}
</code></pre>
",0
49864836,49864685,2,"<p>In each step the code above make a logical and operation between x and 0x80. In binary 0x80 is 10000000. So in each operation we are getting if the current most significant bit of x is 1 or 0. In each iteration x is right shifted to 1 bit. So after all the operations. we get the initial integer in 8 bit binary. To get the value in 6 bit, you need to make a logical and operation between x and 0x20(Which is in binary 100000).</p>
",1
50558631,50558171,0,"<blockquote>
  <p>While (I am not a llama) or (I am not a dog) ...</p>
</blockquote>

<p>Even llamas and dogs will have a true result for <em>one</em> of those sub-clauses so, since true or anything is true, the statement will always result in true.</p>

<p>What you need instead is (reverting back to your <em>actual</em> code rather than my slightly ridiculous example):</p>

<pre><code>while ((strcmp (comando, ""X"") != 0) &amp;&amp; (strcmp (comando, ""x"") != 0)) {
//                                  ^^
//                          and rather than or
</code></pre>

<p>You'll notice I've also ""fixed"" your first clause so that the use of parentheses is consistent, moving the <code>)</code> to <em>after</em> the <code>0</code>.</p>

<p>Of course, if you have any other places where you check <code>comando</code>, it may be worth just making it single case up front, then you only ever need to check the lower case variant.</p>
",0
50055969,50055615,2,"<p>Your array is an array of structs. Within each element of your array are three numeric fields that are set to '\0', which is equal to zero. I'm assuming you're using a simple <code>for</code> loop that iterates over all the elements of the array and prints out each field of each element. However, since your fields are <code>int</code> and <code>double</code>, the function you are using (likely something like <code>printf(""%d\t%d\t%f"", emp[i].id, emp[i].age, emp[i].salary)</code>). Your zeroed out fields are then converted to their character representation, i.e. '0' and printed onto the screen. In order to get the result you want, the simplest way would be to change '\0' to an ""illegal value"", say -1. You can then check for that value each time you attempt to print an entry. Something like <code>if(emp[i].id == -1) continue;</code> should do the trick.</p>
",0
49304043,49303949,5,"<p>You could just advance the inner loop counter, e.g.</p>

<pre><code>for (i = 0; i &lt; col; i++) {
    sumC = 0;
    for (j = 0; j &lt; row; j++)
    {
        sumC += matrix[j][i];

        if (sumC &gt; 1.5) {
            sumC = 0;
            j += 3;            // &lt;&lt;&lt;
        }
    }
}
</code></pre>

<p>NB: this assumes that you don't want to carry over the ""next 3 steps"" into the following column in the case where the threshold is reached near the end of a column.</p>
",0
49466364,49466315,3,"<p>The problem is the <code>-ansi</code> parameter. This is equivalent to <code>-std=c90</code>.</p>

<p>As the <a href=""https://linux.die.net/man/3/powf"" rel=""nofollow noreferrer"">man page for powf</a> states, you need to use <code>-std=c99</code></p>
",0
49466375,49466315,6,"<p><a href=""http://en.cppreference.com/w/c/numeric/math/pow"" rel=""noreferrer""><code>powf</code></a> is added in C99. Option <a href=""https://gcc.gnu.org/onlinedocs/gcc-4.2.4/gcc/C-Dialect-Options.html#C-Dialect-Options"" rel=""noreferrer""><code>-ansi</code></a> is equivalent to <code>-std=c89</code>. You need to use <code>-std=c99</code> flag.  </p>

<pre><code>gcc -o test.exe -std=c99 -Wall test.c -lm
</code></pre>
",0
48230669,48229558,0,"<p>There are many issues and your program is overly complicated.</p>

<p>Here is the corrected and simplified version.</p>

<ul>
<li>consistent indentation</li>
<li>No more <code>typedef song *songPtr;</code> which only adds confusion (read <a href=""https://stackoverflow.com/questions/750178/is-it-a-good-idea-to-typedef-pointers"">this</a> for more details)</li>
<li>correct usage of <code>strtok</code></li>
<li>replaced non standard <code>strsep</code> by the similar <code>strtok</code> (google ""strtok vs strsep"")</li>
<li>correct allocation of memory for songs</li>
<li>correct allocation of strings in songs (title, artist)</li>
<li>no more useless dynamic allocation of <code>buffer</code> which has a fixed size anyway</li>
<li>declaration of variables where they are used (this requires a non totally outdated C compiler)</li>
<li>avoiding useless (and in your case even wrong) copying around of data</li>
<li>etc.</li>
</ul>

<p>There is still room for more improvement, for example there is no error checking for memory allocation.</p>

<hr>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define BUFFSIZE 512
#define _BSD_SOURCE 
typedef struct song {
  char *artist;
  char *title;
  char *albumName;
  float duration;
  int yearRealeased;
  double hotttness;
} song;


int main() {
  FILE *songStream;
  int count = 0;
  int size = 100;

  song** allSongsArray = malloc(size * sizeof(song*));

  songStream = fopen(""data.txt"", ""r"");

  if (songStream == NULL) {
    printf(""Unable to open file"");
    exit(1);

  }
  else {
    printf(""Opened File\n"");

    char buffer[BUFFSIZE + 1];
    while (fgets(buffer, BUFFSIZE, songStream) != NULL) {

      song *newSong = malloc(sizeof(song));

        char *line = buffer;
      int index = 0;
      char *Token;

      while ((Token = strtok(line, "",""))) {
        line = NULL;   // line needs to be set to NULL here, read 
                       // the strtok/strsep documentation for details

        switch (index)
        {
        case 17:
          newSong-&gt;title = malloc(strlen(Token) + 1);
          strcpy(newSong-&gt;title, Token);
          break;
        case 8:
          newSong-&gt;artist = malloc(strlen(Token) + 1);
          strcpy(newSong-&gt;artist, Token);
          break;

          // add the cases for the other columns here
        }

        index++;
      }

      allSongsArray[count++] = newSong;     // store pointer to new song in array

      if (count == size) {
        size = size + 100;
        allSongsArray = realloc(allSongsArray, size * sizeof(song*));
      }
    }

    fclose(songStream);
  }

  // display all songs read (count is the number of songs)
  for (int i = 0; i &lt; count; i++)
  {
    fprintf(stdout, ""%s, %s\n"", allSongsArray[i]-&gt;title, allSongsArray[i]-&gt;artist);
  }

  return 0;
}
</code></pre>

<p>If <code>strdup</code> is available you can replace this:</p>

<pre><code>newSong-&gt;artist = malloc(strlen(Token) + 1);
strcpy(newSong-&gt;artist, Token);
</code></pre>

<p>by:</p>

<pre><code>newSong-&gt;artist = strdup(Token);
</code></pre>

<p>Or you can write your own <code>strdup</code> function (2 line sof code).</p>
",7
52240744,52240730,2,"<p><code>int</code> is a signed value, so it goes to negative too which effectively halves that amount in the positive realm. That warning is telling you that it will overflow into a negative number.</p>
",3
49617631,49614645,0,"<p>Single precision <code>float</code> can represent any <em>real</em> number for 6 decimal digits of precision.  <code>999999982796.800050</code> meets that criteria.</p>

<p>This specific example may be fixed simply by using <code>double</code>, which is good for 15 decimal digits of precision.</p>
",0
49618574,49614645,0,"<p>If you must handle math with arbitrary precision for very large numbers, instead of using a <code>float</code> or <code>double</code>, look into an arbitrary precision library. A common on is called <a href=""https://gmplib.org/"" rel=""nofollow noreferrer"">GMP</a></p>

<p>The idea behind an arbitrary precision library is the same as the idea behind how we do math as humans. A single ""digit"" can only store 10 possible values, but by creating an array of digits we can generate indiscriminately large values without losing accuracy.</p>

<p>Libraries like this utilize arrays and perform math one digit at a time in order to maintain perfect accuracy. They run a <strong>lot</strong> slower than <code>float</code>s or <code>double</code>s, but if you care more about precision than speed then it's definitely the way to go.</p>
",0
55213640,55213558,3,"<p>This is implementation-dependent. The language doesn't say anything about how function calls are implemented, they just have to produce the correct results for valid programs.</p>

<p>In most implementations I'd expect #4. Even if you don't have local variables, it still needs a stack frame to hold the return location.</p>

<p>If your function were tail-recursive, and the compiler optimizes tail calls, then you would avoid stack overflow. For this to work, the function would have to end with:</p>

<pre><code>return main();
</code></pre>
",3
55213646,55213558,0,"<p>Ignoring for a moment that recursively calling <code>main</code> is not a good idea, you'll end up with a stack overflow if you run this code.</p>

<p>Even with no local variables, the stack still needs to keep track of the function's return address.  That return address will add up and eventually blow up the stack.</p>
",5
50858214,50857720,0,"<p>The issue is you create an infinite loop. Since all 3 numbers start out equal, the condition</p>

<pre><code>if((numbers[0] &lt; numbers[1]) &amp;&amp; (numbers[1] &lt; numbers[2]))
</code></pre>

<p>is false, so the body of the <code>if</code> never gets entered, <code>numbers[0]</code> never gets incremented, and <code>while(numbers[0] &lt;= 55){</code> is always true.</p>

<p>You can get (what I think is) the desired output with nested for loops:</p>

<pre><code>int numbers[3] = {'0', '0', '0'};
for (int i = numbers[0]; i &lt;= '9'; i++) {
    for (int j = numbers[1]; j &lt;= '9'; j++) {
        for (int k = numbers[2]; k &lt;= '9'; k++) {
            if (i &lt; j &amp;&amp; j &lt; k) {
                printf(""%c%c%c, "", i, j, k);
            }
        }
    }
}
</code></pre>
",0
50089893,50089324,-1,"<p>Your <a href=""https://imgur.com/a/z1c9t1N"" rel=""nofollow noreferrer"">figure</a> shows places where <code>ref &lt; isb</code> and <code>vcs</code> is not zero. Neither your <code>if</code> nor your <code>else if</code> includes this condition, so program execution does not go through either of their clauses. Hence, for those cases, the code is effectively:</p>

<pre><code>int out;

return out;
</code></pre>

<p>Thus, it returns an uninitialized value. That may have happened to have the effect of returning zero, but the behavior is unreliable.</p>

<p>To remedy this, either initialize <code>out</code> to what you want to return in these cases or add an <code>else</code> clause that sets it.</p>
",8
58254723,58254653,0,"<p>instead of this:</p>

<pre><code>for(i=len; i&gt;=0; i--){
    printf(""%c"",reverseword[i]);
          // I just need here to save the output without printing it. So, that later I can compare it. 

}
</code></pre>

<p>you'd better use just this:</p>

<pre><code>for( i=0; i&lt;len; i++) {
    reverseword[i] = mainword[len-i-1];
}
</code></pre>

<p>And it will magically work.</p>
",5
48737618,48737521,3,"<p>There is no standard way to do this, because two processes are separate entities that do not share anything with each other.</p>

<p>However there are techniques (<a href=""https://en.wikipedia.org/wiki/Inter-process_communication"" rel=""nofollow noreferrer"">IPC</a>, short for interprocess communication) that allow for processes to share memory and/or communicate with each other. This techniques however are not part of the Standard C Library and are dependent on the operating system, Windows, Linux, Mac will give you different options.</p>

<p>For linux and unix base systems in general there are for example: <a href=""https://stackoverflow.com/questions/5656530/how-to-use-shared-memory-with-linux-in-c"">shared memory</a>, sockets( native BSD sockets, network sockets, unix sockets, file sockets, pipes, etc), 0mq, etc.</p>

<p>I'm afraid your question is just too broad and every IPC option is different from the other and has up- and downsides. This cannot be answered broadly here, you have to be more specific here.</p>
",5
59115076,59114211,1,"<p>It is due to the fact that you do the <code>n = n+1</code> instruction before the insertion in <code>masukan()</code>. You must move this instruction at the end of the function. </p>

<p>When the program starts, the value of n is 0. When you insert a new set of values, you first increment n and store thus the values at index 1. The values at index 0 are the default values. </p>

<p>When you print the values, you print the values with index 0 to n-1. This doesn't include the value at index n that you just inserted. </p>

<p>By moving the increment of n at the end of the new value insertion, the first value set will be inserted at index position 0 and n is the number of values in the table. n is also the index of the after last values in the table. This is where you insert the next value after what you increment n.</p>

<p>EDIT: another error is a ; after the <code>for(i=0; i&lt;n; i++)</code> in the <code>tampil</code> function. That is the reason one line is printed regardless of the value of n.  </p>
",8
51962505,51962397,0,"<p>Just implement your own:</p>

<pre><code>#define TO_LOWER(c) ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') ? c - 'A' + 'a' : c)

int my_strcmpi(char* str1, char* str2) {
    while (*str1 &amp;&amp; *str2 &amp;&amp; TO_LOWER(*str1) == TO_LOWER(*str2))
    {
        str1++;
        str2++;
    }
    return TO_LOWER(*str1) - TO_LOWER(*str2);
}
</code></pre>
",16
52421102,52420673,1,"<p>You want this:</p>

<pre><code> int main()
    {
    int x = 0, y = 0  ;
    int height , width, *p ;
    char token[] = ""**   "" ;        /** spaces for formatting **/

    printf("" \n Enter number of rows and columns. separated by a space\t"" );
    scanf(""%d %d"", &amp;height , &amp;width);

    char page[width][height] ; // allocate width x height chars
</code></pre>

<p>in your solution you are basically doing this:</p>

<pre><code>char page[0][0] ;
</code></pre>

<p>which allocates a 2d array of width 0 and height 0 which is not really useful.</p>

<p>Accessing to <code>page[x][y]</code> will then access the array out of bounds for any values of <code>x</code> and <code>y</code> which results in <em>undefined bahaviour</em> (google that).</p>
",4
48870151,48870034,1,"<p>If you have two pointers, both pointing to the same array (or to one beyond the end of the array), then you can subtract them from each other.</p>

<p>For example:</p>

<pre><code>char mening[] = ""tjena pa dig hog"";
char *pointer_to_mening = &amp;mening[10];  // Pointer to the eleventh character

// Should print 10 (which is the index of the eleventh character)
printf(""The distance is %zu\n"", pointer_to_mening - mening);
</code></pre>
",2
49964684,49964041,1,"<p>You may consider using the <code>%n</code> format specifier. It will store the number of characters scanned so far from the input. You can use that to offset past what has already been parsed from your input string.</p>

<pre><code>  int x, n;
  sscanf(argumentos, ""%d%n"", &amp;x, &amp;n);
  printf(""%d\n"", x);    
  printf(""%s"", argumentos + n); // rest of the string
</code></pre>
",0
49588766,49588534,1,"<p>I see no reason for <code>'\'</code> in your C code. Maybe it is some leftover from copying the code since it is consistently proceeding  the <code>]</code> closing brackets. </p>

<p>If you remove <code>'\'</code> from your program it will compile and the function <code>f(a+2)</code>
will give you the sum of <code>third</code> and <code>fifth</code> element in the array <code>a[]</code>. </p>

<pre><code>#include&lt;stdio.h&gt;

int f(int t[])
{
    return t[0] + t[2];
}

int main(void){
    int i,a[] = {-2,-1,0,1,2};

    i = f(a+2); // (a+2) -&gt; { 0, 1, 2 }

    printf(""%d"",i); 

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>2
</code></pre>
",0
49478811,49478669,0,"<p>You are not looping through the password.<br>
After your <code>if (a &gt;= 8)</code> statement, there is no code to loop around and examine the remaining characters in the string.  </p>
",2
49550799,49530526,1,"<p>According to <a href=""https://www.rfc-editor.org/rfc/rfc1071"" rel=""nofollow noreferrer"">RFC 1071</a>, the checksum is calculated using a 16-bit 1's complement sum.</p>
<blockquote>
<p>On a 2's complement machine, the 1's complement sum must be
computed by means of an &quot;end around carry&quot;, i.e., any overflows
from the most significant bits are added into the least
significant bits.</p>
</blockquote>
<p>So you should &quot;reverse&quot; the &quot;end around carry&quot; when updating the checksum.</p>
<p>I.e. subtract 1 for each negative carry and add 1 for each positive carry.</p>
<p>Something like this:</p>
<pre><code>int32_t sum; // or just int, but make sure it's 32-bit or more
unsigned short pseq1, pseq2, pseq3, pseq4
unsigned short prevcheck;

u_char *pkt_data;

prevcheck = (pkt_data[50] &lt;&lt; 8) | pkt_data[51];

pseq1 = (pkt_data[38] &lt;&lt; 8) | pkt_data[39]; 
pseq2 = (pkt_data[40] &lt;&lt; 8) | pkt_data[41];

pkt_data[38] = ((seq_num - offsetResult) &gt;&gt; 24) &amp; 0xFF;
pkt_data[39] = ((seq_num - offsetResult) &gt;&gt; 16) &amp; 0xFF; 
pkt_data[40] = ((seq_num - offsetResult) &gt;&gt; 8) &amp; 0xFF;
pkt_data[41] = (seq_num - offsetResult) &amp; 0xFF;

pseq3 = (pkt_data[38] &lt;&lt; 8) | pkt_data[39];
pseq4 = (pkt_data[40] &lt;&lt; 8) | pkt_data[41];

sum = ~prevcheck - pseq1 - pseq2;

while (sum &gt;&gt; 16)
    sum = (sum &amp; 0xFFFF) + (sum &gt;&gt; 16); // &quot;end around carry&quot;

sum += pseq3 + pseq4;

while (sum &gt;&gt; 16)
    sum = (sum &amp; 0xFFFF) + (sum &gt;&gt; 16); // &quot;end around carry&quot;

sum3 = (short)~sum;

pkt_data[50] = (sum3 &gt;&gt; 8) &amp; 0xFF; 
pkt_data[51] = sum3 &amp; 0xFF;
</code></pre>
",3
49541866,49530526,0,"<p>TCP/IP checksums use 1's complement arithmetic, which is similar to 2's complement plus carry feedback. I.e. if you add two 16bit values, and get a carry, you need to add 1 to the sum.</p>

<p>Your code uses unsigned 16bit integers (BTW, I recommend using <a href=""http://en.cppreference.com/w/c/types/integer"" rel=""nofollow noreferrer"">fixed width integer types</a>, instead of <code>int</code> and <code>short</code>, when the size matters, as in this case), so when adding them the carry is lost.</p>

<p>A better way is to use 32bit variables for the intermediate result, then feeding back the carry. For example:</p>

<p><code>
uint16_t a, b;
...
uint32_t sum = (uint32_t)a + (uint32_t)b;
if (sum &gt; 0x10000u) {
    sum = (sum &gt;&gt; 16) + (sum &amp; 0xffff);
}
</code></p>
",0
55318512,55318385,1,"<p>Your code outputs the numerical code that corresponds to each character your code reads in. Presumably, those are the numerical codes your computer uses to represent the characters you input.</p>

<p>You don't say what you expected or why, but it would have to be a series of integers since that's all your code can possibly output.</p>
",0
49546103,49546061,0,"<blockquote>
  <p>I'm not sure why my program is running the functions (Mammals, Amphibians, Reptiles) twice.</p>
</blockquote>

<p>You are calling the functions twice:</p>

<pre><code>Mammals (weight);  //&lt;-- first time
printf(""For this animal you'll need %f lbs of food a week!\n"", Mammals(weight));
//                                                             ^
//                                                         second time
</code></pre>

<blockquote>
  <p>It is also ignoring my scanf statement before the if statement that would take user input to close</p>
</blockquote>

<p>That's because the newline character is still in the input buffer after this
<code>scanf</code>:</p>

<pre><code>scanf(""%f"", &amp;weight);
</code></pre>

<p><code>%f</code> converts the float but the newline (entered when <kbd>ENTER</kbd> is pressed) is not
part of the float, so it remains in the input buffer. The next <code>scanf</code></p>

<pre><code>scanf(""%c"", &amp;b);
</code></pre>

<p>reads the newline that was in the input buffer, that's why it seems that ""it has
been ignored"". You have to ""clear"" the input buffer, you can use this
function:</p>

<pre><code>void clear_stdin(void)
{
    int c;
    while((c = getchar()) != '\n' &amp;&amp; c != EOF);
}
</code></pre>

<p>and call it after <code>scanf(""%f"", &amp;weight);</code>, like this:</p>

<pre><code>printf(""What is the weight of the animal in pounds?:\n"");
scanf(""%f"", &amp;weight);
clear_stdin();
</code></pre>

<p>Another alternative if you don't want to use the <code>clear_stdin</code> function, would
be to add an empty space in the <code>scanf</code> format like this:</p>

<pre><code>scanf("" %c"", &amp;b);
</code></pre>

<p>with the empty space <code>scanf</code> will ignore the empty spaces, newline and tabs in
the input buffer. For more information about the format string for <code>scanf</code>,
please take a look at the <a href=""https://linux.die.net/man/3/scanf"" rel=""nofollow noreferrer"">documentation of <code>scanf</code></a>.</p>
",2
59529279,59529125,2,"<p>Operator precedence is biting you here with the <code>*</code> and <code>++</code> operators. <code>*sizeRange++</code> means ""get value pointed to, then increase the pointer"". You want <code>(*sizeRange)++</code> instead. Or use a local variable for counting, and store its value at the end of the function.</p>
",0
49547589,49547056,0,"<p>iBug's comment will give you EXACTLY what you asked for above, but otherwise you can use sprintf to store the integer in a string and then manipulate it however you wish from there.  Like:</p>

<pre><code>sprintf(&amp;number_string, ""%d"", int_variable);
</code></pre>

<p>and then if you want to always put text in the middle, something like:</p>

<pre><code>int num_len = strlen(number_string);
int midpoint = len / 2;
char middle_text[6] = "":foo:"";
int mid_text_len = strlen(middle_text);

// allocate space for new string
char *new_string = malloc(len + mid_text_len + 1);

// copy up to the midpoint into the new string
strncpy(new_string, number_string, midpoint);

// then concatenate whatever you want to put in the middle
strcat(new_string, middle_text);

// then concatenate the rest of number_string onto the end
strcat(new_string, number_string+midpoint, num_len-midpoint);

// and make sure it's null terminated.
new_string[len+mid_text_length] = '\0';
</code></pre>

<p>Caveat: I didn't test this code, so it might not work exactly as written...but you get the idea.</p>
",0
59548689,59548672,2,"<p>You are thinking that <code>a</code> is an array of 4 elements.<br>
But it is not.  It is a pointer.</p>

<p>I'm deducing that your system is a 64-bit system with 8-byte pointers.</p>

<p>So <code>sizeof(a)</code> is 8.  And <code>sizeof(a[0])</code> is <code>sizeof(int)</code> is 4 bytes.</p>

<p>So the expression becomes <code>8/4 == 2</code>.</p>

<hr>

<p>If you had declared <code>a</code> as <code>int a[4];</code>
Then you would indeed get 4 for a result.</p>
",0
49810679,49788424,0,"<p>Simplest way to deal with this is to have a static array of the desired values as a look-up table.  Use an integer (byte or whatever natural register size) counting from 0 to 6 to index the table. Very fast on modern (or twenty year old) CPUs.  Seven values of 8-bit values are easily written by hand.</p>

<p>Bit gymnastics working on the current value to obtain the next with shift operators will run slower, and can't work anyway. You don't have a function for relating one value to the next. For behold:</p>

<pre><code>0b10000001
0b01000010  &lt;-- this value
0b00100100  &lt;-- next value
0b00011000
0b00100100
0b01000010  &lt;-- same value again
0b10000001  &lt;-- different next value!
</code></pre>

<p>The same bit pattern appears twice. But the following values are different.  </p>

<p>I'm assuming that in real life, you want to do exactly as stated in the question.  A lookup table of seven byte values is best.</p>

<p>But if the reality is you (or some future Googler finding this question) are working on, perhaps, 4096-bit long strings of bits, and want to generate a series of bit patterns like shown the question, then even if you want to use a lookup table, some poor sap is going to be stuck writing it.  Don't let that be you!  </p>

<p>So another more general solution, appying to any size though I'll describe it in terms of the same old 8-bit bytes, in no particular language:</p>

<pre><code>A = 0b10000000
B = 0b00000001
while A nonzero:
    result = A | B
    shift right A, shift left B
</code></pre>

<p>Simple and elegant, but you get the value where the two bits meet in the middle twice, 0b00011000.  If that's to be avoided, then add code to check for that case and skip ahead to the next iteration.  </p>
",0
49613219,49612805,0,"<p>Your program does not compile and produce warnings. It would not work as you intended. </p>

<p>1) <code>p</code> is a pointer. To access value which it points to you have to dereference it using <code>*</code> dereference opearator.</p>

<p>2)</p>

<pre><code>void change_it(int[]); 
</code></pre>

<p>is not needed in the body of <code>main</code>.</p>

<p>3)</p>

<blockquote>
  <p>the invocation of <code>change_it()</code> seems to have no effect</p>
</blockquote>

<p>If you want to change <code>a[0]</code> element inside the function  <code>change_it</code> name the passing parameter to <code>a</code> and dereference the <code>q</code> pointer,</p>

<p>The working program may look as this:</p>

<pre><code>#include &lt;stdio.h&gt;

void change_it(int a[]);

int main()
{
    int a[5] = {0}; // init all element of `a` to `0` 
    int *p;         // declare int pointer 
    p = a;          // p point to array `a`

    // print the first element of array `a`
    printf(""a[0] has the value %d \n"",(int)*p);

    // call function change_it, pass `a` as the argument
    change_it(a); 

    printf(""a[0] has the value %d \n"",(int)*p);

    return 0;
}

 // change the value of the first element of array `a` to 777
void change_it(int a[]) {

    int i=777, *q;   // declare int i and pointer
    q = &amp;i;          // pointer `q` points to the `i` now 

    a[0] = *q;       // a[0] is assigned value = 777;
}
</code></pre>

<p>Output:</p>

<pre><code>a[0] has the value 0                                                                                                                           
a[0] has the value 777
</code></pre>
",2
51085701,51083902,3,"<p>It is better to supply the file name as command-line argument to your program, because it makes it easier to test and use.</p>

<p>In the file, each line seems to be a separate record. So, it would be better to read each line, then parse the fields from the line.</p>

<p>Consider the following:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

#define  MAX_LINE_LEN  500

int main(int argc, char *argv[])
{
    char  line[MAX_LINE_LEN + 1]; /* +1 for the end-of-string '\0' */
    FILE *in;

    if (argc != 2) {
        fprintf(stderr, ""\n"");
        fprintf(stderr, ""Usage: %s FILENAME\n"", argv[0]);
        fprintf(stderr, ""\n"");
        return EXIT_FAILURE;
    }

    in = fopen(argv[1], ""r"");
    if (!in) {
        fprintf(stderr, ""Cannot open %s: %s.\n"", argv[1], strerror(errno));
        return EXIT_FAILURE;
    }

    while (fgets(line, sizeof line, in) != NULL) {
        char  id[20], code[20], address[50], dummy;

        if (sscanf(line, "" %19s %19s %49s %c"", id, code, address, &amp;dummy) == 3) {
            /* The line did consist of three fields, and they are
               now correctly parsed to 'id', 'code', and 'address'. */

            printf(""id = '%s'\ncode = '%s'\naddress = '%s'\n\n"",
                   id, code, address);

        } else {

            /* We do have a line, but it does not consist of
               exactly three fields. */

            /* Remove the newline character(s) at the end of line. */
            line[strcspn(line, ""\r\n"")] = '\0';

            fprintf(stderr, ""Cannot parse line '%s'.\n"", line);

        }
    }

    if (ferror(in)) {
        fprintf(stderr, ""Error reading %s.\n"", argv[1]);
        return EXIT_FAILURE;
    } else
    if (fclose(in)) {
        fprintf(stderr, ""Error closing %s.\n"", argv[1]);
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
</code></pre>

<p>Above, <code>argc</code> contains the number of command-line arguments, with the program name used as the first (zeroth, <code>argv[0]</code>) argument.  We require two: the program name and the name of the file to be read.  Otherwise, we print out an usage message.</p>

<p>We try to open the file for reading. If <code>fopen()</code> fails, it returns <code>NULL</code>, with the error stored in <code>errno</code>. <code>strerror(errno)</code> yields the human-readable error message.</p>

<p><code>fgets(array, sizeof array, stream)</code> reads a line (unless too long to fit in <code>array</code>) from <code>stream</code>. If it succeeds, it returns a pointer to the first element in <code>array</code>. If it fails -- there is no more to read, for example --, it returns <code>NULL</code>.</p>

<p>Remember that <code>feof(stream)</code> does not check if <code>stream</code> has more data to read. It only reports whether the end of <code>stream</code> has already been encountered. So, instead of reading until <code>feof()</code> returns true, you should simply read data until reading fails, then check why the reading failed. This is what the above example program does.</p>

<p>We want to treat each line as a separate record. Because <code>fscanf()</code> does not distinguish <code>'\n'</code> from spaces (in neither the conversion specification, nor when implicitly skipping whitespace), using <code>fscanf(in, "" %19s %19s %49s"", ...)</code> does not restrict the parsing to a single line: they may be on the same line, or on different lines, or even have empty lines in between.  To restrict our parsing to a single line, we first read each line with <code>fgets()</code>, then try and parse that line, and that line only, using <code>sscanf()</code>. (<a href=""http://man7.org/linux/man-pages/man3/scanf.3.html"" rel=""nofollow noreferrer""><code>sscanf()</code></a> works just like <code>fscanf()</code>, but takes its input from a string rather than a stream.)</p>

<p>To avoid <a href=""https://en.wikipedia.org/wiki/Buffer_overflow"" rel=""nofollow noreferrer"">buffer overflow</a>, we must tell <code>sscanf()</code> how long our buffers can be, remembering to reserve one char for the end-of-string mark (NUL, <code>'\0'</code>). Because <code>id</code> is 20 chars long, we can use up to 19 for the ID string, and therefore we need to use <code>%19s</code> to do the conversion correctly.</p>

<p>The return value from <code>sscanf()</code> is the number of successful conversions.  By adding a dummy character (<code>%c</code>) conversion at the end that we expect to fail in normal circumstances, we can detect if the line contained more than we expected.  This is why the <code>sscanf()</code> pattern has four conversions, but we require exactly the first three of them to succeed, and the fourth, dummy one, to fail, if the input line has the format we expected.</p>

<p>Note that we could try several different <code>sscanf()</code> expressions, if we accept the input in different formats.  I like to call this <em>speculative parsing</em>. You simply need to order them so that you try the most complex ones first, and accept the first one that yields the expected number of successful conversions. For a practical example of that, check out the <a href=""https://stackoverflow.com/a/50988537/1475978"">example C code I used in another answer</a> to allow the user to specify simulation details using name=value pairs on the command line.</p>

<p>The <code>line[strcspn(line, ""\r\n"")] = '\0';</code> expression is a trick, really. <a href=""http://man7.org/linux/man-pages/man3/strcspn.3.html"" rel=""nofollow noreferrer""><code>strcspn()</code></a> is a standard C <code>&lt;string.h&gt;</code> function, which returns the number of characters in the first string parameter, until end of string or any of the characters in the second string are encountered, whichever happens first.  Thus, <code>strcspn(line, ""\r\n"")</code> yields the number of characters in <code>line</code> until end of string, <code>'\r'</code>, or <code>'\n'</code> is encountered, whichever happens first.  We trim off the rest of the string by using that as the index to the line buffer, and making the string end there.  (Remember, NUL or <code>'\0'</code> always ends the string in C.)</p>

<p>After the <code>while</code> loop, we check why the <code>fgets()</code> returned <code>NULL</code>.  If <code>ferror()</code> returns true, then there was a real read error. These are very, very rare nowadays, but not checking them is just like walking around with a weapon without the safety engaged: it is an unnecessary risk with zero reward.</p>

<p>In most operating systems, <code>fclose()</code> cannot even fail if you opened the file read-only, but there are some particular cases on some where it might. (Also, it can fail when you write to streams, because the C library may cache data -- keep it in an internal buffer, rather than write it immediately, for efficiency sake -- and write it out only when you close the stream.  Like any write, that can fail due to a real write error; say, if the storage media is already full.)</p>

<p>Yet, it only costs a couple of lines of C code to check both <code>ferror()</code> and <code>fclose()</code>, and let the user know.  I personally hate, with a deep-burning passion, programs that do not do that, because they really risk losing user data silently, without warning.  The users may think everything is okay, but the next time they try to access their files, some of it is missing... and they usually end up blaming the operating system, not the actual culprits, the bad, evil programs that failed to warn the user about an error they could have detected.</p>

<p>(It is best to learn to do that as early as possible.  Like security, error checking is not something you can really bolt on later: you either design it in, or it won't be reliable.)</p>

<p>Also note that the <a href=""http://man7.org/linux/man-pages/dir_all_alphabetic.html"" rel=""nofollow noreferrer"">Linux man pages project</a> contains a very well maintained list of C library functions (along with POSIX.1, GNU, and Linux-specific functions).  Do not be fooled by its name.  Each of the pages contains a <em>Conforming to</em> section, which tells you which standards the function or functions described on that page conforms to.  If it is C89, then it works in just about all operating systems you can imagine.  If it is C99 or any POSIX.1 version, it may not work in Windows or DOS (or using the ancient Borland C compiler), but it will work in most other operating systems.</p>

<hr>

<p>Because the OP is obviously reading non-ASCII files, I would recommend trying out the localized version of the program, that uses wide characters and wide strings:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;
#include &lt;string.h&gt;
#include &lt;wchar.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

#define  MAX_WLINE_LEN  500

int main(int argc, char *argv[])
{
    wchar_t  line[MAX_WLINE_LEN + 1]; /* +1 for the end-of-string L'\0' */
    FILE *in;

    if (argc != 2) {
        fprintf(stderr, ""\n"");
        fprintf(stderr, ""Usage: %s FILENAME\n"", argv[0]);
        fprintf(stderr, ""\n"");
        return EXIT_FAILURE;
    }

    if (setlocale(LC_ALL, """") == NULL)
        fprintf(stderr, ""Warning: Your C library does not support your currently set locale.\n"");

    if (fwide(stdout, 1) &lt; 1)
        fprintf(stderr, ""Warning: Your C library does not support wide standard output.\n"");

    in = fopen(argv[1], ""r"");
    if (!in) {
        fprintf(stderr, ""Cannot open %s: %s.\n"", argv[1], strerror(errno));
        return EXIT_FAILURE;
    }
    if (fwide(in, 1) &lt; 1)
        fprintf(stderr, ""Warning: Your C library does not support wide input from %s.\n"", argv[1]);

    while (fgetws(line, sizeof line / sizeof line[0], in) != NULL) {
        wchar_t  id[20], code[20], address[50], dummy;

        if (swscanf(line, L"" %19ls %19ls %49ls %lc"", id, code, address, &amp;dummy) == 3) {
            /* The line did consist of three fields, and they are
               now correctly parsed to 'id', 'code', and 'address'. */

            wprintf(L""id = '%ls', code = '%ls', address = '%ls'\n"",
                   id, code, address);

        } else {

            /* We do have a line, but it does not consist of
               exactly three fields. */

            /* Remove the newline character(s) at the end of line. */
            line[wcscspn(line, L""\r\n"")] = L'\0';

            fprintf(stderr, ""Cannot parse line '%ls'.\n"", line);

        }
    }

    if (ferror(in)) {
        fprintf(stderr, ""Error reading %s.\n"", argv[1]);
        return EXIT_FAILURE;
    } else
    if (fclose(in)) {
        fprintf(stderr, ""Error closing %s.\n"", argv[1]);
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
</code></pre>

<p>The above code is pure C99 code, and should work on all OSes who have a standard C library conforming to C99 or later.  (Unfortunately, Microsoft is not willing to implement some C99 features, even though it ""contributed"" to C11, which means the above code may need to have additional Windows-specific code to work on Windows.  It does work fine in Linux, BSDs, and Macs, however.) </p>
",6
49513474,49513307,2,"<p><code>argc</code> is the number of command line parameters (including program call) and <code>*argv[]</code> is a pointer to the parameters.</p>

<p>In other words, considering the command line <code>./ProgName -r /file.txt</code>:</p>

<ul>
<li><code>argc</code> is 3</li>
<li><code>argv[0]</code> is ""./ProgName""</li>
<li><code>argv[1]</code> is ""-r""</li>
<li><code>argv[2]</code> is ""/file.txt""</li>
</ul>

<p>A minimal program showing all command line parameters could be:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    for(int i = 0; i &lt; argc; i++)
    {
        printf(""argv[%d] = %s\n"", i, argv[i]);
    }
    return 0;
}
</code></pre>
",1
49633033,49632738,1,"<p>The main problem is likely to be this line</p>

<pre><code>sprintf(fdname,""data%d.bin"", i);
</code></pre>

<p>If <code>i</code> is between 0 and 9, the line above attempts to fill the buffer with 10 characters e.g. <code>data0.bin\0</code>. If <code>i</code> is any larger, the string is even longer. Unfortuantely, you have only defined <code>fdName</code> to be eight bytes long.</p>

<p>There are some other issues.</p>

<pre><code>for(j=0;j&lt;256*256;j++)
{
    read(fdata,&amp;data_cont,1);
    hisSum[data_cont]++;
}
</code></pre>

<p>You use <code>data_cont</code> uninitialsed if the <code>read</code> fails to read any bytes. Always check the return value of IO functions.</p>

<p>In this code</p>

<pre><code>for(j=0;j&lt;256;j++)
    write(fhist, hisSum+j, 4);
</code></pre>

<p>If <code>j</code> is greater than 252, you read beyond the end of <code>hisSum</code>.</p>

<p>In <code>main</code> you don't check to make sure <code>argc</code> is at least 3.</p>

<p>Also, you leak the <code>fhist</code> read file descriptor when you overwrite it with the write file descriptor. without closing it first.</p>
",0
49633033,49632738,1,"<p>The main problem is likely to be this line</p>

<pre><code>sprintf(fdname,""data%d.bin"", i);
</code></pre>

<p>If <code>i</code> is between 0 and 9, the line above attempts to fill the buffer with 10 characters e.g. <code>data0.bin\0</code>. If <code>i</code> is any larger, the string is even longer. Unfortuantely, you have only defined <code>fdName</code> to be eight bytes long.</p>

<p>There are some other issues.</p>

<pre><code>for(j=0;j&lt;256*256;j++)
{
    read(fdata,&amp;data_cont,1);
    hisSum[data_cont]++;
}
</code></pre>

<p>You use <code>data_cont</code> uninitialsed if the <code>read</code> fails to read any bytes. Always check the return value of IO functions.</p>

<p>In this code</p>

<pre><code>for(j=0;j&lt;256;j++)
    write(fhist, hisSum+j, 4);
</code></pre>

<p>If <code>j</code> is greater than 252, you read beyond the end of <code>hisSum</code>.</p>

<p>In <code>main</code> you don't check to make sure <code>argc</code> is at least 3.</p>

<p>Also, you leak the <code>fhist</code> read file descriptor when you overwrite it with the write file descriptor. without closing it first.</p>
",0
49519054,49518996,1,"<p>Since what you're looking for is text substitution, you need a macro for this:</p>

<pre><code>#define SET_GPIO_BIT(port, reg, bit) ((port)-&gt;reg |= (1 &lt;&lt; (bit)))
</code></pre>

<p>Alternately, since all registers are of the same type, you could instead use a function and pass in the address of the register in question depending on the situation:</p>

<pre><code>void SET_GPIO_BIT(volatile uint32_t *reg, uint32_t bit) {
    *reg |= (1 &lt;&lt; bit);
}
</code></pre>

<p>Then you would call it like this:</p>

<pre><code>if (set_MODER) {
    SET_GPIO_BIT(&amp;GPIOA-&gt;MODER, 7);
} else if (set_OTYPER) {
    SET_GPIO_BIT(&amp;GPIOA-&gt;OTYPER, 7);
...
</code></pre>
",3
49520880,49518996,0,"<p>This is not an answer to the stated question; it is rather a suggestion to solve the underlying problem in a different way.</p>

<p>Rather than having the ""registers"" as separately named members in a structure, use an array instead:</p>

<pre><code>enum {
    IOREG_MODE = 0,
    IOREG_OTYPE,
    /* All registers, in order */
    IOREG_COUNT
};

typedef struct {
    volatile uint32_t  ioreg[IOREG_COUNT];
} ioregs;
</code></pre>

<p>This lets you use either a macro,</p>

<pre><code>#define IOREG_SET(port, reg, bit) (((port)-&gt;ioreg[reg]) |= (1u &lt;&lt; (bit)))
#define IOREG_UNSET(port, reg, bit) (((port)-&gt;ioreg[reg]) &amp;= ~(1u &lt;&lt; (bit)))
#define IOREG_TOGGLE(port, reg, bit) (((port)-&gt;ioreg[reg]) ^= (1u &lt;&lt; (bit)))
</code></pre>

<p>or a static inline function,</p>

<pre><code>static inline uint32_t ioreg_set(regs *const port,
                                 const int reg,
                                 const unsigned char bit)
{
    return port-&gt;ioreg[reg] |= 1u &lt;&lt; bit;
}

static inline uint32_t ioreg_unset(regs *const port,
                                   const int reg,
                                   const unsigned char bit)
{
    return port-&gt;ioreg[reg] &amp;= ~(1u &lt;&lt; bit);
}

static inline uint32_t ioreg_toggle(regs *const port,
                                    const int reg,
                                    const unsigned char bit)
{
    return port-&gt;ioreg[reg] ^= 1u &lt;&lt; bit;
}
</code></pre>

<p>On any modern C compiler, both are equally fast, but the <code>static inline</code> functions provide compile-time type checking, and make it easier to debug cases where wrong data is output (via, for example, duplicating the writes to a debug text stream).</p>

<p>(If your I/O registers supports also 8-bit and/or 16-bit accesses, you can make the structure an union of arrays, with different static inline accessors depending on the size of the register.)</p>
",0
49807750,49807463,3,"<p>You have several problem in your code</p>

<ol>
<li><p>See <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">why <code>while(foef(file))</code> is always wrong</a>. If you are going to read
the file character by characters, it's best to do it this way:</p>

<pre><code>int c;
while((c = getchar()) != EOF)
{
    // do somthing with c
}
</code></pre></li>
<li><p>Reading the values like this <code>fscanf(fin, ""%c"", &amp;array[j][k]);</code> it's ok, but
it has one problem: you are forgetting to take the newline into account. You are
only reading <code>row</code> number of characters, but the whole line (assuming there are
no empty spaces and tabs) has <code>row+1</code> characters, the newline didn't go away, so
when you are finishing reading the last value of a row, the next <code>scanf</code> will
<strong>not</strong> read the next value, it will read a newline. You can fix it by doing
this:</p>

<pre><code>for(j=0; j&lt;lines; j++){
    for(k=0; k&lt;rows; k++){
        fscanf(fin, ""%c"", &amp;array[j][k]);

    getchar(); // consume the newline
}
</code></pre></li>
</ol>

<p>In general you should read the values line by line using <code>fgets</code> and then you
can use <code>sscanf</code> to parse the line.</p>

<p>So, to determine the number of lines:</p>

<pre><code>int lines = 0;
int c, last = '\n';
while((c = fgetc(fin)) != EOF)
{
    last = c;
    if(c == '\n')
        lines++;
}

// in case the last line does not end with \n
// some file editors don't end the last line with \n
if(last != '\n')
    lines++;
</code></pre>

<p>To get the number of rows:</p>

<pre><code>int rows = 0; 
while((c = fgetc(fin)) != EOF)
{
    // based on your example, the file does not
    // contains other characters than +,-,.,X and newlines
    if(ch == '\n')
        break;
    else
        rows++;
}
</code></pre>

<p>and now to read the values:</p>

<pre><code>// assuming that the file has the correct format and that
// all lines have the same length
char line[rows+2];  // +2 because of the newline and the 0 terminating byte

for(int i = 0; i &lt; lines &amp;&amp; i &lt; 1000; ++i)
{
    fgets(line, sizeof line, fin);
    char *tmp = line;
    for(int j = 0; j &lt; rows &amp;&amp; j &lt; 1000; ++j)
        sscanf(tmp++, ""%c"", &amp;array[i][j]);
}
</code></pre>

<p>Note that this code that the file has the proper format and that all lines have
the same length. In order to make the reading more robust (that means that it
can react to format errors) you'll need to check the return value of <code>fgets</code> and
<code>sscanf</code>. I've omitted that for sake of simplicity, but you should add these
checks.</p>

<p>And you don't need to open and close <code>fin</code> every time, you can use <code>rewind(fin)</code>
to set the file at the beginning.</p>
",2
49807026,49806894,1,"<p>I see from comments that you've taken user3121023's advice to use <code>strcmp()</code> rather than '==' for string comparisons.  That's the first issue.</p>

<p>You can't test for end-of-input by comparing with <code>control-D</code>.  <code>Control-D</code> is a way the user can (depending on options) signal end of file on input.  But that character is not conveyed as part of the input; instead the input stream is closed.  Instead  you need to check for end-of-file in the call to <code>getline()</code> and restructure the rest accordingly.</p>

<p>Most likely, the reason <code>strcmp()</code> is not matching is because the input returned by <code>getline</code> ends with a newline character.  Your <code>read_line()</code> function should probably strip any newline from the end of the line.</p>

<p>See <a href=""http://man7.org/linux/man-pages/man3/getline.3.html"" rel=""nofollow noreferrer"">http://man7.org/linux/man-pages/man3/getline.3.html</a></p>
",0
53641966,53641832,2,"<p>Please do read @melpomene's link to Eric Lippert's excellent article on debugging small programs.</p>

<hr>

<p>You have two issues. The first is that your <code>scanf()</code> format string does not allow for the decimals between IP address octets. The presence in the file of unexpected delimiters (the decimals) causes all the scan conversions after the first to fail, so it returns 1, triggering the print you're seeing. Change the format string to <code>""%d.%d.%d.%d %s""</code>.</p>

<p>The second is that in <code>scan_address()</code> you're incrementing <code>i</code> <em>before</em> you test for the terminating line. In other words, when this check runs:</p>

<pre><code>if(adds[i].xx==0 &amp;&amp; adds[i].yy==0 &amp;&amp; adds[i].zz==0 &amp;&amp; adds[i].mm==0)
</code></pre>

<p>You've already incremented <code>i</code> to point to the next record, and you're testing uninitialized memory. This is actually undefined behavior, but it's likely that ""by chance"" this memory contains zeroes, triggering the end-of-input check. You can move the <code>if</code> (and the <code>break</code>) up into the <code>if (status == 5)</code> code block before incrementing <code>i</code>.</p>

<hr>

<p>With these changes I get:</p>

<pre><code>ipaddress.txt was succesfully imported with 8 record

Machines green and red are on the same local network
111 22 3 44  green
111 22 6 77  red

Machines blue and yellow are on the same local network
222 33 4 55  blue
222 33 8 99  yellow

Machines cyan and black are on the same local network
333 44 1 22  cyan
333 44 2 33  black
</code></pre>
",1
51998455,51998097,4,"<p>You currently have this code to insert at the end (of a non-empty list):</p>

<pre><code>if (first == NULL) {
    first = last = student;   // Empty list case
} else {
    last-&gt;next = student;
    last = student;
}
</code></pre>

<p>To insert at the front of a non-empty list, you simply need to make the new student into the first student each time, by making its <code>next</code> pointer point to the current <code>first</code> student, and making the <code>first</code> pointer point at the new student.</p>

<pre><code>if (first == NULL) {
    first = last = student;   // Empty list case
} else {
    student-&gt;next = first;
    first = student;
}
</code></pre>

<p>Draw the boxes; connect them with arrows.  It should become obvious.</p>

<hr>

<p>Also, you could simply use:</p>

<pre><code>student-&gt;next = first;
first = student;
</code></pre>

<p>If <code>first</code> is null, <code>student-&gt;next</code> will be (re)set to null, so there's no need for a special case on <code>first</code>.  Since <code>last</code> was only used within the function for adding to the end of the list, when inserting at the front, there's no need for <code>last</code> at all.  These two observations make the code still simpler than the first version proposed.</p>
",0
49678422,49678255,1,"<blockquote>
  <p>Instead of (i+1), I tried using i, i+2 which returned valid output. But for i+3 onward invalid outputs occur</p>
</blockquote>

<p>For anything greater than <code>i+1</code> (such as <code>i+2</code>, <code>i+3</code>, etc), the resulting index <code>j</code> from:</p>

<pre><code>int j = rand() % (i+2);
</code></pre>

<p>might be, depending on what <code>rand()</code> returns, outside the bounds of the array <code>arr</code> and thus it could result in <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behaviour</a>.</p>

<blockquote>
  <p>Can someone please explain why only a value less than 3 must be added?</p>
</blockquote>

<p>That's not correct conclusion, either. As said you can't add anything greater 1. It's so happens to ""work"" with 2 (as with anything undefined behaviour, you just can't rely on it and should avoid it).</p>

<p>You can print the value of <code>j</code> and see for yourself whether it could be outside the bounds of the array.</p>
",0
52054301,52053990,0,"<p>This is not a 2D array of <code>int</code>s, is an array of pointers to <code>int</code>.</p>

<p>It works because each element of the array points to an address containing an array of <code>int</code>s</p>

<p>A similar code using the stack, just to show why it works:</p>

<pre><code>int a[] = {1, 2};
int b[] = {3, 4};
int *arr[] = {a, b};
</code></pre>

<p>A real 2D array is supposed to work in contiguous areas (without fragmentation), you can use pointers to VLA's to achieve this:</p>

<pre><code>int rows, cols;

scanf(""%d %d"", &amp;rows, &amp;cols);

int (*arr)[cols] = malloc(sizeof(int [rows][cols]));
</code></pre>
",8
49983208,49982704,0,"<p><code>BigInteger</code> has much better bit manipulation functionality that most of the others numerical values.</p>

<pre><code>public static String asPoly(long n) {
    return asPoly(BigInteger.valueOf(n));
}

public static String asPoly(BigInteger b) {
    // Using BigInteger because it has a bitLength.
    List&lt;String&gt; parts = new ArrayList&lt;&gt;();
    for (int p = b.bitLength(); p &gt;= 0; p--) {
        if (b.testBit(p)) {
            switch (p) {
                default:
                    parts.add(""x^"" + p);
                    break;
                case 1:
                    parts.add(""x"");
                    break;
                case 0:
                    parts.add(""1"");
                    break;
            }
        }
    }
    return String.join("" + "",parts);
}

public void test(String[] args) {
    int number = 15;
    System.out.println(Integer.toBinaryString(number));
    System.out.println(asPoly(number));
}
</code></pre>
",0
57989477,57989342,4,"<p>The <a href=""https://en.cppreference.com/w/c/language/union"" rel=""nofollow noreferrer"">union type declaration</a> is</p>

<p><code>union</code> <em><code>OptionalUnionTypeName</code></em> <code>{</code> <code>...</code> <code>}</code></p>

<p>but your full statement is a variable definition of the form</p>

<p><code>type</code> <code>id</code> <code>;</code></p>

<p>(where type is the anonymous union type just declared, since you omitted the name).</p>

<p>So <code>id</code> is a variable of (anonymous) union type.</p>
",1
50226781,50226598,2,"<p>At the simplest, you'd convert the loop fragment into:</p>

<pre><code>void print_and_destroy(size_t count, SomeType ptr[count])
{
    for (size_t i = 0; i &lt; count; i++)
    {
        printf(""\n%s"", ptr[i]-&gt;name);
        printf(""%s"", ptr[i]-&gt;street);
        printf(""%s"", ptr[i]-&gt;citystate);
        printf(""%s"", ptr[i]-&gt;zip);
        free(ptr[i]);
    }
    free(ptr);
}
</code></pre>

<p>The final free is there because the array is now contains no useful pointers (they've all been freed).  You could add <code>ptr[i] = NULL;</code> after the <code>free(ptr[i]);</code> instead.  That indicates that there is no data there any more.</p>

<p>However, as noted in the comments <a href=""https://stackoverflow.com/questions/50226598/how-to-split-a-program-into-multiple-file-format-with-a-h-and-couple-c-files/50226781?noredirect=1#comment87470814_50226781"">1</a> and <a href=""https://stackoverflow.com/questions/50226598/how-to-split-a-program-into-multiple-file-format-with-a-h-and-couple-c-files/50226781?noredirect=1#comment87470903_50226781"">2</a> by <a href=""https://stackoverflow.com/users/5245033/sergeya"">SergeyA</a>, and the clumsy but accurate function name, this isn't a good breakdown of the code.  You need two functions:</p>

<pre><code>void destroy(size_t count, SomeType ptr[count])
{
    for (size_t i = 0; i &lt; count; i++)
    {
        free(ptr[i]);
        ptr[i] = NULL;  // Option 1
    }
    free(ptr);          // Option 2
}
</code></pre>

<p>You would not use option 1 if you use option 2 (though it would do no actual harm).  If you do not use option 2, you should use option 1.</p>

<pre><code>void print(size_t count, const SomeType ptr[count])
{
    for (size_t i = 0; i &lt; count; i++)
    {
        printf(""%s, "", ptr[i]-&gt;name);
        printf(""%s, "", ptr[i]-&gt;street);
        printf(""%s, "", ptr[i]-&gt;citystate);
        printf(""%s\n"", ptr[i]-&gt;zip);
    }
}
</code></pre>

<p>Note that you probably need space between the fields of the address.  You might or might not want one line for name, one line for street address, and one line for city, state and zip code ¡ª choose your format to suit.  Generally, output newlines at the end of output, not at the beginning unless you want double spacing.</p>

<hr>

<blockquote>
  <p>So that would be my separate <code>function.c</code> file and my header file would look something like <code>¡­code omitted¡­</code> right? How would the function call in the main program look like?</p>
</blockquote>

<p>The outline of the header would be:</p>

<pre><code>#ifndef HEADER_H_INCLUDED
#define HEADER_H_INCLUDED

#include &lt;stddef.h&gt;      // Smallest header that defines size_t

typedef struct SomeType
{
    char name[32];
    char street[32];
    char citystate[32];
    char zip[11];        // Allow for ZIP+4 and terminal null
} SomeType;

extern void print_and_destroy(size_t count, SomeType ptr[count]);

#endif /* HEADER_H_INCLUDED */
</code></pre>

<p>Note that the header doesn't include <code>&lt;stdio.h&gt;</code>; no part of the interface depends on anything that's specific to <code>&lt;stdio.h&gt;</code>, such as a <code>FILE *</code> (though <code>&lt;stdio.h&gt;</code> <em>is</em> one of the headers that defines <code>size_t</code>).  A header should be minimal, but self-contained and idempotent.  Not including <code>&lt;stdio.h&gt;</code> is part of being minimal; including <code>&lt;stddef.h&gt;</code> is part of being self-contained; and the header guards are the key part of being idempotent.  It means you can include the header and not have to worry about whether it has already been included before indirectly or is included again later, indirectly, and you don't have to worry about what other headers have to be included ¡ª the header is self-contained and deals with that.</p>

<p>In your <code>main()</code>, you'd have something like:</p>

<pre><code>enum { MAX_ADDRESSES = 20 };
SomeType *data[MAX_ADDRESSES];

¡­memory allocation¡­
¡­data loading¡­

print_and_destroy(MAX_ADDRESSES, data);
</code></pre>
",12
50227034,50226598,2,"<p>There are two different issues involved (I recommend to address the first one, if so needed, before the second one):</p>

<ul>
<li><p>how to split a monolithic <a href=""https://en.wikipedia.org/wiki/Translation_unit_(programming)"" rel=""nofollow noreferrer"">translation unit</a> in several ones, but keeping the <em>same</em> functions</p></li>
<li><p>how to refactor a code to make it more readable and made of ""smaller"" and ""better"" functions. In your case, this is the main issue.</p></li>
</ul>

<hr>

<p>The first question, for example splitting a small single program in a single <code>myprog.c</code> file of a few dozen thousands of lines, is quite easy. The real issue is to organize that cleverly (and then it becomes harder, and opinion based). You just need to  put mostly <em>declarations</em> in your header file, and to put <em>definitions</em> in <em>several</em> translation units, and of course to improve your build process to use and link them together. So you would have first a single common header file <code>myheader.h</code> <em>declaring</em> your types, macros, functions, global variables. You would also <em>define</em> some short <code>static inline</code> functions there, if you need them. Then you would have several C files (technically translation units) <code>foo.c</code>, <code>bar.c</code>, <code>dingo.c</code>, and you'll better put several <em>related</em> functions in each of them. Each such C file has <code>#include ""myheader.h""</code>. You'll better use some <a href=""https://en.wikipedia.org/wiki/Build_automation"" rel=""nofollow noreferrer"">build automation</a> tool, probably <a href=""https://www.gnu.org/software/make/"" rel=""nofollow noreferrer"">GNU make</a> (or <a href=""https://en.wikipedia.org/wiki/List_of_build_automation_software"" rel=""nofollow noreferrer"">something</a> else, e.g. <a href=""https://ninja-build.org/"" rel=""nofollow noreferrer"">ninja</a>) that you would configure with your <code>Makefile</code>. You could later have several header files, but for a small project of only several dozen thousands of source code lines that might be not needed. In <a href=""https://stackoverflow.com/a/49829773/841108"">some cases</a>, you would generate some C file from a higher-level description (e.g. use simple <a href=""https://en.wikipedia.org/wiki/Metaprogramming"" rel=""nofollow noreferrer"">metaprogramming</a> techniques).</p>

<p>The second question (<a href=""https://en.wikipedia.org/wiki/Code_refactoring"" rel=""nofollow noreferrer"">code refactoring</a>) is really difficult, and has no simple universal answer. It really depends of the project. A simple (and very debatable, and over-simplifying) rule of thumb is that you need to have functions ""doing only one thing"" and of at most a few dozen lines each. So as soon as a  function does more than one thing or has more than one or two dozen lines you should <em>consider</em> splitting and refactoring it (but you won't <em>always</em> do that). Obviously your <code>main</code> should be split in several stuff.</p>

<hr>

<p>At last, don't fail into the excessive habit of putting only one function per <code>*.c</code> file, or have lots of small <code>*.c</code> files of only a hundred lines each. This is generally useless, and could increase your build time (because the preprocessor would work a lot), and perhaps even slightly decrease the runtime performance of your executable (because your <a href=""https://en.wikipedia.org/wiki/Optimizing_compiler"" rel=""nofollow noreferrer"">optimizing compiler</a> won't be able to inline, unless you use link-time optimization). My recommendation (opinion-based, so debatable) is to have source files of several thousand lines each containing several (dozen of) functions.</p>

<p>In your case, I believe your program (in your question) is so tiny that you don't need to split it into several translation units (unless your teacher asks you to). But indeed you need to refactor it, perhaps defining some <a href=""https://en.wikipedia.org/wiki/Abstract_data_type"" rel=""nofollow noreferrer"">abstract data type</a> and routines supporting it (see <a href=""https://stackoverflow.com/a/41410503/841108"">this</a>).</p>

<hr>

<p><strong>Study the source code of existing <a href=""https://en.wikipedia.org/wiki/Free_software"" rel=""nofollow noreferrer"">free software</a></strong> (e.g. on <a href=""http://github.com/"" rel=""nofollow noreferrer"">github</a>) related to your project <em>for inspiration</em>, since you'll need to define and follow many <a href=""https://en.wikipedia.org/wiki/Coding_conventions"" rel=""nofollow noreferrer"">coding conventions</a> (and coding rules) which matter a lot with C programming. In your newbie case, I believe that studying the source of any small free software program (of a few dozen thousand lines, see <a href=""https://stackoverflow.com/q/4583746/841108"">this</a>) -in a domain you are understanding or interested in, and in the programming language you are practicing- will profit you a lot.</p>
",0
51622971,51580020,0,"<p>Here's code that sorts the values in 6 simple variables (no structures, no arrays).  My preferred version uses pointers and a function:</p>

<pre><code>#include &lt;stdio.h&gt;

static int test_and_swap(int *p1, int *p2)
{
    if (*p1 &gt; *p2)
    {
        int t = *p1;
        *p1 = *p2;
        *p2 = t;
        return 1;
    }
    return 0;
}

int main(void)
{
    int v1 = 93;
    int v2 = 81;
    int v3 = 63;
    int v4 = 84;
    int v5 = 14;
    int v6 = 87;

    int swap;

    printf(""v1 = %d; v2 = %d; v3 = %d; v4 = %d; v5 = %d; v6 = %d\n"",
           v1, v2, v3, v4, v5, v6);
    do
    {
        swap = 0;
        swap += test_and_swap(&amp;v1, &amp;v2);
        swap += test_and_swap(&amp;v2, &amp;v3);
        swap += test_and_swap(&amp;v3, &amp;v4);
        swap += test_and_swap(&amp;v4, &amp;v5);
        swap += test_and_swap(&amp;v5, &amp;v6);
    } while (swap != 0);
    printf(""v1 = %d; v2 = %d; v3 = %d; v4 = %d; v5 = %d; v6 = %d\n"",
           v1, v2, v3, v4, v5, v6);

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>v1 = 93; v2 = 81; v3 = 63; v4 = 84; v5 = 14; v6 = 87
v1 = 14; v2 = 63; v3 = 81; v4 = 84; v5 = 87; v6 = 93
</code></pre>

<p>A version which doesn't use pointers even doesn't use a function but does use repetitive coding:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int v1 = 93;
    int v2 = 81;
    int v3 = 63;
    int v4 = 84;
    int v5 = 14;
    int v6 = 87;

    int swap;

    printf(""v1 = %d; v2 = %d; v3 = %d; v4 = %d; v5 = %d; v6 = %d\n"",
           v1, v2, v3, v4, v5, v6);
    do
    {
        swap = 0;
        if (v1 &gt; v2) { int t = v1; v1 = v2; v2 = t; swap = 1; }
        if (v2 &gt; v3) { int t = v2; v2 = v3; v3 = t; swap = 1; }
        if (v3 &gt; v4) { int t = v3; v3 = v4; v4 = t; swap = 1; }
        if (v4 &gt; v5) { int t = v4; v4 = v5; v5 = t; swap = 1; }
        if (v5 &gt; v6) { int t = v5; v5 = v6; v6 = t; swap = 1; }
    } while (swap != 0);

    printf(""v1 = %d; v2 = %d; v3 = %d; v4 = %d; v5 = %d; v6 = %d\n"",
           v1, v2, v3, v4, v5, v6);

    return 0;
}
</code></pre>

<p>The output is the same, of course.</p>

<p>I stand by my contention (made in comments) that the exercise is imposing ridiculous limits on your programming.  This is not code that should be used in production ¡ª the requirements imposed on the solution are not sensible.</p>
",0
59165615,59163983,1,"<p>I'm going to go out on a limb here and propose that the memory from <code>malloc</code> is uninitialized, and that's what's going on here.</p>

<p>In the loop (and rewriting into proper array format as suggested by @Gerhardh):</p>

<pre><code>for (int i = 0; i &lt; MAX_FILE_NUM; i++) {
        //update directory info
        if( directory_block_ptr[i].used == 0) {
            // assign stuff
            printf(""%d\n"", directory_block_ptr[i].file_descriptor_count);//correct output 0   
            break;
        }
    }
</code></pre>

<p>The OP says they get the correct value, but we don't know that it's the <code>[0]</code> index, right? If there's junk in position <code>directory_block_ptr[0].used</code>, then that position will not be touched and the loop will move onto the next one. We just don't know which one is being found.</p>

<p>Recommend to OP: change the <code>printf</code> in the loop to be:</p>

<pre><code>printf(""%d set in position [%d]\n"", directory_block_ptr[i].file_descriptor_count, i);
</code></pre>

<p>and see if it's telling you position <code>[0]</code> or <code>[1]</code> or whatever. My guess is not-zero.</p>

<p>Recommend to OP, change your initialization at the top to be:</p>

<pre><code>#define DIRECTORY_BLOCK_SIZE  4096

file_detail *directory_block_ptr = malloc(DIRECTORY_BLOCK_SIZE);

memset(directory_block_ptr, 0, DIRECTORY_BLOCK_SIZE);
</code></pre>

<p>This allocates the same amount of memory, but insures that it's all set to zero, then run it again.</p>

<p>Also, this is more a matter of style than of substance, I'd do the loop this way by defining a much simpler variable name for access throughout the loop, it's easier to follow.</p>

<pre><code>    for(int i = 0; i &lt; MAX_FILE_NUM; i++){
        file_detail *fd = &amp;(directory_block_ptr[i]); // shorthand

        //update directory info
        if(fd-&gt;used == 0){
            strcpy(fd-&gt;file_name, name);
            fd-&gt;size = 0;
            fd-&gt;file_descriptor_count = 0;
            fd-&gt;used = 1;
            fd-&gt;block = -1;
            fd-&gt;block_count = 0;
            printf(""%d set in position [%d]\n"", fd-&gt;file_descriptor_count, i);
            break;
        }
    }
</code></pre>
",0
49661045,49655428,1,"<p><a href=""https://linux.die.net/man/3/printf"" rel=""nofollow noreferrer"">https://linux.die.net/man/3/printf</a></p>

<p>According to the man page, <code>%x</code> or <code>%X</code> accept an <code>unsigned integer</code>. Thus it will read 4 bytes from the stack.</p>

<p>In any case, under most architectures you can't pass a parameter that is less then a <code>word</code> (i.e. <code>int</code> or <code>long</code>) in size, and in your case it will be converted to <code>int.</code></p>

<p>In the first case, you're passing a <code>char</code>, so it will be casted to <code>int</code>. Both are signed, so a signed cast is performed, thus you see preceding <code>FF</code>s.</p>

<p>In your second example, you're actually passing an <code>int</code> all the way, so no cast is performed.</p>

<p>If you'd try:</p>

<pre><code>printf(""%X\n"", (char) 0b10101110);
</code></pre>

<p>You'd see that <code>FFFFFFAE</code> will be printed.</p>
",0
49702464,49655428,0,"<p>This code causes <a href=""https://stackoverflow.com/a/4105123/1505939""><strong>undefined behaviour</strong></a>. The argument to <code>%X</code> must have type <code>unsigned int</code>, but you supply <code>char</code>.</p>

<p>Undefined behaviour means that anything can happen; including, but not limited to, extra F's appearing in the output.</p>
",0
55767890,55767668,1,"<blockquote>
  <p>The  rand()  function returns a pseudo-random integer in the range 0 to
  RAND_MAX inclusive (i.e., the mathematical range [0, RAND_MAX]).</p>
  
  <p>The srand() function sets its argument as the seed for a  new  sequence
  of  pseudo-random  integers  to be returned by rand().  These sequences
  are repeatable by calling srand() with the same seed value.</p>
</blockquote>

<p>So you can do for instance :</p>

<pre><code>#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main()
{
  int v[10]; /* the 'very long' array */
  int i;

  srand(time(0)); /* random seed */

  /* populating */
  for (i = 0; i != sizeof(v)/sizeof(int); ++i)
    v[i] = (rand() &amp; 1) * 255;

  for (i = 0; i != sizeof(v)/sizeof(int); ++i)
    printf(""%d "", v[i]);
  putchar('\n');


  return 0;
}
</code></pre>

<p>Compilation and executions :</p>

<pre><code>pi@raspberrypi:/tmp $ gcc -pedantic -Wextra -Wall r.c
pi@raspberrypi:/tmp $ ./a.out
255 0 0 255 0 0 0 255 255 0 
pi@raspberrypi:/tmp $ ./a.out
0 255 0 0 0 255 0 255 255 0 
pi@raspberrypi:/tmp $ ./a.out
255 255 255 0 0 0 255 0 255 0 
</code></pre>
",1
51182337,51182258,3,"<p>The code is using <code>char i</code>.  The range of (signed) char on most systems is -128 to 127.</p>

<p><code>i</code> will never reach <code>n1</code> if it is greater than 127.  Use <code>int</code> instead.</p>
",0
50721308,50720990,0,"<p>To copy the <code>char **</code> variable, you need to know how many pointers are in the array. It's just like in <code>main</code> where you get an <code>argc</code> that tells you how many pointers are in <code>argv</code>. Once you add that data, you can:</p>

<pre><code>// Added num_commando parameter
job * new_job(pid_t pid, const char * command, char ** commando, size_t num_commando, enum job_state state)
{
    job * aux;
    aux=(job *) malloc(sizeof(job));
    aux-&gt;pgid=pid;
    aux-&gt;state=state;
    aux-&gt;command=strdup(command);
    // Create array of pointers
    aux-&gt;commando = malloc(sizeof(char *) * num_commando); // or sizeof(*aux-&gt;commando)
    // Duplicate every string
    for (size_t i = 0; i &lt; num_commando; i++) {
        aux-&gt;commando[i] = strdup(commando[i]);
    }
    aux-&gt;next=NULL;
    return aux;
}
</code></pre>

<p>You should also add the <code>num_commando</code> parameter to the struct so you know how many strings to <code>free()</code>.</p>
",0
50325097,50324839,0,"<p>Notice that <code>return (dollar, cents);</code> is using the <a href=""https://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow noreferrer"">comma operator</a> (so returns <code>cents</code>).</p>

<p>If you want <code>calculate</code> to return <em>two</em> values you should declare a <code>struct</code> like</p>

<pre><code>struct monetarytwoints_st {
  int mon_dollars;
  int mon_cents;
};
</code></pre>

<p>and have <code>calculate</code> return that type, so code something like</p>

<pre><code>struct monetarytwoints_st calculate(float change) {
   int doll, cnts;
   doll = (int) change;
   cnts = (int) (((change - doll) * 100) + 0.5);
   return (struct monetarytwoints_st) { doll, cnts };
}
</code></pre>

<p>you probably should do input in one function, and computation in another one. Calling <code>scanf</code> from <code>calculate</code> is very bad taste.</p>

<p>BTW, return a small <code>struct</code> of two numbers is very efficient on x86-64; the <a href=""https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI"" rel=""nofollow noreferrer"">x86-64 ABI</a> says that two registers are used for returning such a small <code>struct</code>.</p>

<p>Be aware that C uses a <a href=""https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value"" rel=""nofollow noreferrer"">call-by-value</a> argument passing, so any change of some formal arguments in a called function does not affect the actual arguments at the call site in the calling statement.</p>
",1
51642805,51642579,5,"<p>Properly indenting the code, and turning on warnings, reveals the problem. You're using <code>for</code> and <code>if</code> without blocks. While this is legal, it is very easy to get wrong. In particular...</p>

<pre><code>    for(j=0;j&lt;len;j++)
        if ((isalpha(str[j])!=1) || (j==len-1))
    if(j&lt;len-1)
        k=j-1;
    else
        k=j;
    i=0;
</code></pre>

<p>I'm honestly not sure what the proper bracing is here. My compiler has warned about a <a href=""https://en.wikipedia.org/wiki/Dangling_else"" rel=""nofollow noreferrer"">""dangling else""</a> so something isn't right.</p>

<pre><code>test.c:21:9: warning: add explicit braces to avoid dangling else [-Wdangling-else]
        else
</code></pre>

<p>I suspect you meant this.</p>

<pre><code>    for(j=0;j&lt;len;j++) {
        if((isalpha(str[j])!=1) || (j==len-1)) {
            if(j&lt;len-1) {
                k=j-1;
            }
            else {
                k=j;
            }
        }
    }
</code></pre>

<p>Either way, always use blocks. Always compile with warnings. I use <code>-Wall -Wshadow -Wwrite-strings -Wextra -Wconversion -std=c99 -pedantic</code>.</p>

<hr>

<p>Another issue is this:</p>

<pre><code>len = strlen(str);
</code></pre>

<p>At this point <code>str</code> is uninitialized so it will contain garbage. <code>len</code> will be the length of that garbage.</p>

<p><code>len</code> will also never change, yet the content of <code>str</code> changes with each line read. Instead you need to check the length of <code>str</code> inside the loop just after each <code>fgets</code> call.</p>

<pre><code>while(fgets(str,80, f) != NULL) {
    len = strlen(str);
    ...
}
</code></pre>

<hr>

<p>Your <code>str</code> buffer is 100, but you're only allowing <code>fgets</code> 80 characters. To avoid this, use <code>sizeof(str)</code> instead of hard coding. Note: this only works with stack allocated memory.</p>

<pre><code>while(fgets(str, sizeof(str), f) != NULL) {
    len = strlen(str);
</code></pre>

<p>While you're at it, there's no reason to be stingy with a line buffer. It's only allocated once. 80 or 100 is very small for a line buffer. Give it 4096 bytes to allow for very long lines.</p>

<hr>

<p>With these fixes your code works, but we can improve on it. In particular that whole <code>for</code> loop seems unnecessary. I suspect all it's doing is trying to keep the newline on the end of the reversed string. There's no need to look through the whole string. <code>fgets</code> reads line by line, if there is a newline it will always be on the end.</p>

<pre><code>// Convert the length to an index
k = strlen(str) - 1;

// Leave the trailing newline alone
if( str[k] == '\n' ) {
    k--;
}
</code></pre>

<p>With that, plus better variable names, only declaring variables as needed, and using the proper types, we get...</p>

<pre><code>while(fgets(str, sizeof(str), f) != NULL) {
    // Check if someone snuck a null byte into the file.
    if( !*str ) {
        continue;
    }

    // Convert the length to an index
    size_t back = strlen(str) - 1;

    // Leave the trailing newline alone
    if( str[back] == '\n' ) {
        back--;
    }

    // Swap characters
    size_t front = 0;
    while(front &lt; back) {
        char tmp   = str[front];
        str[front] = str[back];
        str[back]  = tmp;
        front++;
        back--;
    }

    printf(""%s"",str);
}
</code></pre>

<p>This can be simplified even further using pointers instead of indexes.</p>

<pre><code>while(fgets(str, sizeof(str), f) != NULL) {
    // A pointer to the last character of str
    char *back = &amp;str[strlen(str) - 1];

    // Leave the trailing newline alone
    if( *back == '\n' ) {
        back--;
    }

    // Swap characters
    for(
        char *front = str;
        front &lt; back;
        front++, back--
    ) {
        char tmp = *front;
        *front   = *back;
        *back    = tmp;
    }

    printf(""%s"",str);
}
</code></pre>
",4
48263185,48262558,0,"<ul>
<li><p>The most correct way to do this is to use the <code>strto...</code> family of functions from stdlib.h. For example:</p>

<pre><code>printf(""%ld\n"", strtol(str, NULL, 10));
</code></pre></li>
<li><p>The <code>atoi</code> family of functions should never be used for any purpose, since they have broken error handling and can be 100% replaced by the <code>strto...</code> functions.</p></li>
<li><p>You could use the scanf family of functions but they are needlessly slow and notoriously dangerous, so I don't really see the point of using them here.</p></li>
</ul>

<p>If you are interested in implementing the actual copying manually, for learning purposes, it is fairly trivial:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main (void)
{
  const char str[] = ""0013subdivision"";
  char number_part [sizeof(str)];
  char letter_part [sizeof(str)];
  size_t i;

  for(i=0; str[i]!='\0' &amp;&amp; isdigit(str[i]); i++) // find where the letters start
  {}

  memcpy(number_part, &amp;str[0], i);             // copy digit part
  number_part[i] = '\0';                       // append null terminator
  memcpy(letter_part, &amp;str[i], sizeof(str)-i); // copy letter part + null term

  puts(number_part);
  puts(letter_part);
  printf(""%ld\n"", strtol(str, NULL, 10));
}
</code></pre>

<p>If the string is a run-time variable, you have to use <code>strlen(str)+1</code> instead of <code>sizeof()</code>.</p>
",0
54859862,54859824,4,"<p>It's not standard, it's used in some Unixes (mostly BSD) to represent an unsigned quadword (64 bits). Hence the <code>q</code> as a type modifier, like <code>l</code> for long.</p>
",0
54861257,54859824,2,"<p>It's an old BSDism that should not be used, from before C had <code>long long</code> types. From the <a href=""https://www.freebsd.org/cgi/man.cgi?printf(3)"" rel=""nofollow noreferrer"">FreeBSD man page for <code>printf</code></a>, you can see that, at least on FreeBSD, it was corresponding to the nonstandard type <code>u_quad_t</code>, and that it's marked as deprecated. I'm not sure if <code>u_quad_t</code> was ever formally specified as being <code>unsigned long long</code>, but the portable replacement is using the <code>ll</code> modifier with type <code>unsigned long long</code>, or using the <code>PRIu64</code> macro with type <code>uint64_t</code>.</p>
",0
54521455,54521376,3,"<p>One way is to print the length of the last word after the loop is done.</p>

<pre><code>while ((c = getchar()) != EOF){
    ++ length;
    if (c == ' ' || c == '\n' || c == '\t'){
        -- length;
        printf(""length of last word: %d\n"", length);
        length = 0;
    }
}
if (length &gt; 0) {
    printf(""length of last word: %d\n"", length);
}
</code></pre>

<p>Another way is to change your loop condition and break out of the loop after printing.</p>

<pre><code>while (1){
    ++ length;
    if (c == ' ' || c == '\n' || c == '\t' || c == EOF){
        -- length;
        printf(""length of last word: %d\n"", length);
        length = 0;
    }
    if (c == EOF) {
        break;
    }
}
</code></pre>

<p>BTW, instead of incrementing <code>length</code> and then decrementing it in the <code>if</code> block, would simply move the increment into an <code>else</code> block. Or just print <code>length-1</code>.</p>

<p>And it's not idiomatic to put a space between <code>++/--</code> and the variable.</p>
",3
49829624,49829568,1,"<p>The problem can be this</p>

<pre><code>char input;
</code></pre>

<p>Note that <code>getchar</code> returns an <code>int</code> and you may have problems with <code>EOF</code> or values > <code>127</code></p>

<p>Try</p>

<pre><code>int input;
</code></pre>
",9
49873623,49871989,2,"<p>There are a number of ways of writing a generic swap function.  If it will be used for only one type (so it doesn't need to be generic), the size argument is not needed and you can pass pointers of the relevant type (<code>double *</code> in the question) and swap using indirection.</p>

<pre><code>extern void double_swap(double *d1, double *d2);

void double_swap(double *d1, double *d2)
{
    double d = *d1;
    *d1 = *d2;
    *d2 = d;
}
</code></pre>

<p>There might well be advantages to making that into:</p>

<pre><code>static inline void double_swap(double *d1, double *d2)
{
    double d = *d1;
    *d1 = *d2;
    *d2 = d;
}
</code></pre>

<p>This could be placed in a header and used safely.</p>

<p>If it will be used for multiple types, you should use <code>void *</code> in the function arguments (and <code>size_t</code> for the size of the type).</p>

<pre><code>/*
** This declaration belongs in a header if there is more than one
** source file that uses it.  If there is only one file, then it
** should be declared and defined as a static function.  If the
** header doesn't include any other headers that define size_t,
** it should #include &lt;stddef.h&gt; as that's the smallest header
** that does define size_t.  You could make the function static
** inline instead of extern, even if it is in a header.
*/
extern void generic_swap(void *v1, void *v2, size_t size);

/* Implementation 1: Using VLA */
void generic_swap(void *v1, void *v2, size_t size)
{
    char sp[size];
    memmove(sp, v1, size);
    memmove(v1, v2, size);
    memmove(v2, sp, size);
}
</code></pre>

<p>You can use <code>memcpy()</code> if you don't mind living dangerously (you should probably add <code>restrict</code> to the <code>v1</code> and <code>v2</code> pointer types if you do that).  Again, the function could probably be made <code>static inline</code> to good effect ¡ª that also applies to the other implementations below.</p>

<p>If you don't like the idea of large objects being allocated on the stack, you can copy the data in chunks, but you have to work quite a bit harder.</p>

<pre><code>enum { CHUNK_SIZE = 64 };

static inline size_t min_size(size_t x, size_t y) { return (x &lt; y) ? x : y; }

/* Implementation 2: Using a fixed size buffer */
void generic_swap(void *v1, void *v2, size_t size)
{
    unsigned char sp[CHUNK_SIZE];
    unsigned char *p1 = v1;
    unsigned char *p2 = v2;
    size_t chunk;
    while ((chunk = min_size(size, CHUNK_SIZE)) != 0)
    {
        memmove(sp, p1, chunk);
        memmove(p1, p2, chunk);
        memmove(p2, sp, chunk);
        p1 += chunk;
        p2 += chunk;
        size -= chunk;
    }
}
</code></pre>

<p>Notwithstanding anything that GCC permits, the C standard says you can't increment a <code>void *</code> because there is no known size to increment it by.  That's why the pointers are converted to <code>unsigned char *</code>.  Clearly, you can tune the chunk size to suit your system.  Any power of 2 in the range 16..1024 is probably usable, and other values than a power of 2 can be used if you prefer.</p>

<p>If you don't mind the overhead, you can dynamically allocate a buffer:</p>

<pre><code>/* Implentation 3: Using dynamic memory allocation */
void generic_swap(void *v1, void *v2, size_t size)
{
    char *sp = malloc(size);
    if (sp != 0)
    {
        memmove(sp, v1, size);
        memmove(v1, v2, size);
        memmove(v2, sp, size);
        free(sp);
    }
}
</code></pre>

<p>If memory allocation fails, the swap doesn't occur.  That's bad, so you might fall back on the 'fixed size buffer and swap in chunks', but that is probably quicker than this anyway.</p>

<p>I would use Implementation 2 in preference to Implementation 3; dynamic memory allocation is expensive.  I would probably use Implementation 2 in preference to Implementation 1 as the extra cost of the looping is minimal and using a fixed amount of stack works well.  I have not benchmarked any
of these to verify my assertions.  (If you're swapping megabyte sized lumps of data, you should probably think again ¡ª use pointers instead.  If you're only swapping smaller chunks, Implementation 1 is simple and safe.)</p>

<p>With any of the generic swap implementations, your main program becomes:</p>

<pre><code>int main(void)
{
    double a = 1.0;
    double b = 2.0;

    printf(""linea: %d - antes   a(%f) b(%f)\n"", __LINE__, a, b);
    generic_swap(&amp;a, &amp;b, sizeof(double));
    printf(""linea: %d - despues a(%f) b(%f)\n"", __LINE__, a, b);
    return 0;
}
</code></pre>

<p>I'm assuming that at least the declaration of <code>generic_swap()</code> is available before the start of <code>main()</code>.</p>

<p>Note that using either <code>double_swap()</code> or <code>generic_swap()</code> means that no casts are necessary in the code.  Minimizing casts is A Good Idea?.</p>

<p>See also <a href=""https://stackoverflow.com/questions/50559106/"">Universal array element swap in C</a>.</p>
",0
50041926,50039806,0,"<p>You have at least following problems (in decreasing importance):</p>

<ul>
<li>The final <code>}</code> is missing at the very end of the progran</li>
<li>You havce <em>declared</em> the function <code>int admin(int1)</code> but you havent implemented the function.</li>
<li><code>int admin(int1)</code> should be declared <code>int admin(int)</code></li>
<li>the warning for <code>getch</code> is because you forgot to include the <code>conio.h</code> header. This header is Microsoft specific.</li>
</ul>

<p>Consider also platinum95's answer.</p>
",0
53340434,53340290,0,"<p>It's because of how <a href=""https://en.cppreference.com/w/c/language/operator_other#Comma_operator"" rel=""nofollow noreferrer"">the comma operator</a> works.</p>

<p>It evaluates the left and right hand sides, and throws away the left-hand side result. That means the condition <code>*p != '\0'</code> is evaluated, but the result is not used.</p>

<p>Instead its the result of the <a href=""https://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer""><code>printf</code></a> function that will be used as the sole condition in the loop. It will return the numbers of characters printed, <em>including</em> things like space and newline. And since you print a newline, the returned value will <em>always</em> be at least <code>1</code>. And in C only <code>0</code> is considered false, and would have stopped the loop.</p>

<p>You should be using the logical AND operator <code>&amp;&amp;</code> instead of the comma operator:</p>

<pre><code>while (*p!='\0' &amp;&amp; printf(""%s\n"",++p));
</code></pre>

<p>Now when the left-hand side (i.e. <code>*p!='\0'</code>) becomes false, then the loop should stop.</p>

<hr>

<p>What happens without the above change, or the change you made, is that your loop will go out of bounds of the string and even your allocated memory. That leads to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>, which means just about anything could happen.</p>

<p>For you it seems that part of the environment happens to be next in memory to your allocated memory.</p>
",2
48502685,48502532,2,"<p>Taking a look at which codes each letter corresponds to in the ASCII table might be helpful, but not necessary. You can assign character literals to an integer just fine, by using bitwise OR and bit shift:</p>

<pre><code>uint32_t x = ('A' &lt;&lt; 24) | ('B' &lt;&lt; 16) | ('C' &lt;&lt; 8) | 'D';
</code></pre>

<p>This puts <code>'A'</code> in the most significant  byte. Where that is depends on endianess. On little endian, the above would result in <code>""DCBA""</code>.</p>

<p>This should be enough to solve the assignment. Do remember that strings are null terminated, so you need to end the ""string"" with a zero.</p>
",1
55960137,55960120,0,"<p>You can prompt for both at once:</p>

<pre><code>printf(""Enter the city name and distance from previous city: "");
scanf(""%s %d"",city, &amp;distance);
</code></pre>
",4
53132938,53132883,2,"<blockquote>
  <p>I need to start the function add(a,b) ; </p>
</blockquote>

<p>You probably mean that ""you need to <em>call</em> the function <em>named</em> <code>add</code>"".</p>

<p>At runtime, the name of functions in a C or C++ program don't matter anymore (and conceptually do not exist). There is even a Unix utility, called <a href=""https://en.wikipedia.org/wiki/Strip_(Unix)"" rel=""nofollow noreferrer"">strip</a>, to remove every name (and all the symbol tables) inside an <a href=""https://en.wikipedia.org/wiki/Executable"" rel=""nofollow noreferrer"">executable</a>.</p>

<p>So you could do the following: construct a data structure associating names (e.g. strings like <code>add</code>) to <a href=""https://en.wikipedia.org/wiki/Function_pointer"" rel=""nofollow noreferrer""><em>function pointers</em></a>. For instance, you might first define a type for the signature of <code>add</code> and <code>sub</code>:</p>

<pre><code>typedef int sig2t (int, int);
</code></pre>

<p>Then, fill an array with both names and function pointers; first declare its type:</p>

<pre><code>struct funbind_st {
  const char*fname;
  sig2t* faddr;
};
</code></pre>

<p>And the array:</p>

<pre><code>const struct funbind_st funbindings[] = {
 { ""add"", add },
 { ""sub"", sub },
 { NULL, (sig2t*)0 }
};
</code></pre>

<p>Of course, you'll better have <code>doSomething</code> of the <em>same</em> (and common) signature <code>sig2t</code>. And in practice, you probably want something more efficient (perhaps some <a href=""https://en.wikipedia.org/wiki/Hash_table"" rel=""nofollow noreferrer"">hash-table</a> associating names to function pointers).</p>

<p>Then, finding in that <code>funbindings</code> the element of <code>fname</code> the <code>""sub""</code> string is a simple exercise (you'll need <code>strcmp</code> to compare strings).</p>

<hr>

<p>On Linux specifically, there is another way, which uses the <a href=""https://en.wikipedia.org/wiki/Dynamic_linker"" rel=""nofollow noreferrer"">dynamic linker</a> (taking advantage of the <a href=""https://en.wikipedia.org/wiki/Hash_table"" rel=""nofollow noreferrer"">symbol table</a> of your executable), that is the <a href=""http://man7.org/linux/man-pages/man3/dlopen.3.html"" rel=""nofollow noreferrer"">dlopen(3)</a> and <a href=""http://man7.org/linux/man-pages/man3/dlsym.3.html"" rel=""nofollow noreferrer"">dlsym(3)</a> functions from the <code>-ldl</code> library.</p>

<p>You first need to link your entire program with something like <code>gcc -rdynamic *.o -ldl -o yourprog</code></p>

<p>Then you get the program handle (in your C code) using:</p>

<pre><code>void* proghdl = dlopen(NULL, RTLD_NOW);
if (!proghdl) {
  fprintf(stderr, ""dlopen program failed %s\n"", dlerror());
  exit(EXIT_FAILURE);
}
</code></pre>

<p>then, you could get (into some function pointer <code>addptr</code>) the address of the <em>global</em> function named <code>""add""</code> with</p>

<pre><code>sig2t*addptr = (sig2t*) dlsym(proghdl, ""add"");
if (!addptr) {
  fprintf(stderr, ""dlsym add failed %s\n"", dlerror());
  exit(EXIT_FAILURE);
}
</code></pre>

<p>For details, read the documentation and Drepper's <a href=""https://www.akkadia.org/drepper/dsohowto.pdf"" rel=""nofollow noreferrer""><em>How to write shared libraries</em></a> paper.</p>

<p>Read <a href=""https://mitpress.mit.edu/sicp/"" rel=""nofollow noreferrer"">SICP</a>, and read more about <a href=""https://en.wikipedia.org/wiki/Closure_(computer_programming)"" rel=""nofollow noreferrer"">closures</a> (you'll need to define your implementation of closures, since C don't have any) and <a href=""https://en.wikipedia.org/wiki/Callback_(computer_programming)"" rel=""nofollow noreferrer"">callbacks</a>. You probably need to have them.</p>

<hr>

<blockquote>
  <p>I want to do this so I can benchmark my functions using the same large binary file.</p>
</blockquote>

<p>Why does that need to be a binary file. If you want to benchmark a large library with many functions, you are perhaps using the wrong approach. Did you consider instead embedding an interpreter in your program (like <a href=""https://lua.org/"" rel=""nofollow noreferrer"">lua</a> or <a href=""https://www.gnu.org/software/guile/"" rel=""nofollow noreferrer"">guile</a>)? Then your benchmarking file would be some script in that interpreter! Of course that interpreter has its own overhead, so you need to be sure that each function is benchmarked against a large enough case (e.g. every function benchmark needs to take deciseconds, not microseconds, to run).</p>
",6
53132938,53132883,2,"<blockquote>
  <p>I need to start the function add(a,b) ; </p>
</blockquote>

<p>You probably mean that ""you need to <em>call</em> the function <em>named</em> <code>add</code>"".</p>

<p>At runtime, the name of functions in a C or C++ program don't matter anymore (and conceptually do not exist). There is even a Unix utility, called <a href=""https://en.wikipedia.org/wiki/Strip_(Unix)"" rel=""nofollow noreferrer"">strip</a>, to remove every name (and all the symbol tables) inside an <a href=""https://en.wikipedia.org/wiki/Executable"" rel=""nofollow noreferrer"">executable</a>.</p>

<p>So you could do the following: construct a data structure associating names (e.g. strings like <code>add</code>) to <a href=""https://en.wikipedia.org/wiki/Function_pointer"" rel=""nofollow noreferrer""><em>function pointers</em></a>. For instance, you might first define a type for the signature of <code>add</code> and <code>sub</code>:</p>

<pre><code>typedef int sig2t (int, int);
</code></pre>

<p>Then, fill an array with both names and function pointers; first declare its type:</p>

<pre><code>struct funbind_st {
  const char*fname;
  sig2t* faddr;
};
</code></pre>

<p>And the array:</p>

<pre><code>const struct funbind_st funbindings[] = {
 { ""add"", add },
 { ""sub"", sub },
 { NULL, (sig2t*)0 }
};
</code></pre>

<p>Of course, you'll better have <code>doSomething</code> of the <em>same</em> (and common) signature <code>sig2t</code>. And in practice, you probably want something more efficient (perhaps some <a href=""https://en.wikipedia.org/wiki/Hash_table"" rel=""nofollow noreferrer"">hash-table</a> associating names to function pointers).</p>

<p>Then, finding in that <code>funbindings</code> the element of <code>fname</code> the <code>""sub""</code> string is a simple exercise (you'll need <code>strcmp</code> to compare strings).</p>

<hr>

<p>On Linux specifically, there is another way, which uses the <a href=""https://en.wikipedia.org/wiki/Dynamic_linker"" rel=""nofollow noreferrer"">dynamic linker</a> (taking advantage of the <a href=""https://en.wikipedia.org/wiki/Hash_table"" rel=""nofollow noreferrer"">symbol table</a> of your executable), that is the <a href=""http://man7.org/linux/man-pages/man3/dlopen.3.html"" rel=""nofollow noreferrer"">dlopen(3)</a> and <a href=""http://man7.org/linux/man-pages/man3/dlsym.3.html"" rel=""nofollow noreferrer"">dlsym(3)</a> functions from the <code>-ldl</code> library.</p>

<p>You first need to link your entire program with something like <code>gcc -rdynamic *.o -ldl -o yourprog</code></p>

<p>Then you get the program handle (in your C code) using:</p>

<pre><code>void* proghdl = dlopen(NULL, RTLD_NOW);
if (!proghdl) {
  fprintf(stderr, ""dlopen program failed %s\n"", dlerror());
  exit(EXIT_FAILURE);
}
</code></pre>

<p>then, you could get (into some function pointer <code>addptr</code>) the address of the <em>global</em> function named <code>""add""</code> with</p>

<pre><code>sig2t*addptr = (sig2t*) dlsym(proghdl, ""add"");
if (!addptr) {
  fprintf(stderr, ""dlsym add failed %s\n"", dlerror());
  exit(EXIT_FAILURE);
}
</code></pre>

<p>For details, read the documentation and Drepper's <a href=""https://www.akkadia.org/drepper/dsohowto.pdf"" rel=""nofollow noreferrer""><em>How to write shared libraries</em></a> paper.</p>

<p>Read <a href=""https://mitpress.mit.edu/sicp/"" rel=""nofollow noreferrer"">SICP</a>, and read more about <a href=""https://en.wikipedia.org/wiki/Closure_(computer_programming)"" rel=""nofollow noreferrer"">closures</a> (you'll need to define your implementation of closures, since C don't have any) and <a href=""https://en.wikipedia.org/wiki/Callback_(computer_programming)"" rel=""nofollow noreferrer"">callbacks</a>. You probably need to have them.</p>

<hr>

<blockquote>
  <p>I want to do this so I can benchmark my functions using the same large binary file.</p>
</blockquote>

<p>Why does that need to be a binary file. If you want to benchmark a large library with many functions, you are perhaps using the wrong approach. Did you consider instead embedding an interpreter in your program (like <a href=""https://lua.org/"" rel=""nofollow noreferrer"">lua</a> or <a href=""https://www.gnu.org/software/guile/"" rel=""nofollow noreferrer"">guile</a>)? Then your benchmarking file would be some script in that interpreter! Of course that interpreter has its own overhead, so you need to be sure that each function is benchmarked against a large enough case (e.g. every function benchmark needs to take deciseconds, not microseconds, to run).</p>
",6
48436745,48436659,1,"<p><code>unsigned</code> is <code>unsigned int</code>, so a 32 bits value, as well as constant <code>1</code> which is a <em>signed</em> int, so when you're shifting <code>1 &lt;&lt; (high-low + 1)</code> you're doing it on 32 bits integers.</p>

<p>Use <code>ull</code> to transform <em>all</em> your constants to unsigned 64 bits int during the shifts.</p>

<p><code>mask = ((1ull &lt;&lt; (high-low + 1ull))-1ull) &lt;&lt; low</code></p>
",0
49850425,49850319,3,"<p>The <code>8</code> in the format string means to read at most 8 characters from the input. So if the input is <code>0xffffffffff</code> then the input sequence is <code>0xffffff</code> which matches the output you got.  (I assume you used <code>%08x</code> in the printf format string, otherwise you would have not seen the extra zeroes in the output).</p>

<p>Unfortunately there is no combination of <code>scanf</code> options that means ""read 10 characters if it started with <code>0x</code> or <code>0X</code> and read 8 characters otherwise"".  You would have to implement that logic yourself, using other input functions.</p>
",1
49460342,49460307,1,"<p>You need to have enough room for the <code>'\n'</code> to be read or else it will be left in the input buffer and the next iteration it will be read immediately and thus make <code>fgets()</code> return with an empty string and hence <code>strtol()</code> returns <em>0</em>.</p>

<p>Read <a href=""http://man7.org/linux/man-pages/man3/fgets.3p.html"" rel=""nofollow noreferrer"">fgets()</a>'s documentation, it reads until a <code>'\n'</code> or untill the buffer is full. So the first time, it stops because it has no more room to store characters, and then the second time it still has to read <code>'\n'</code> and it stops immediately.</p>

<p>A possible solution is to increase the buffer size, so that the <code>'\n'</code> is read and stored in it. </p>

<p>Another solution, is to read all remaining characters after <code>fgets()</code>.</p>

<p>The second solution could be cleanly implemented by reading one character at a time instead, since you are just interested in the first character you can discard anything else</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() 
{
    int chr;
    while (1) {
        // Read the next character in the input buffer
        chr = fgetc(stdin);
        // Check if the value is in range
        if ((chr &gt;= '0') &amp;&amp; (chr &lt;= '9')) {
            int value;
            // Compute the corresponding integer
            value = chr - '0';
            fprintf(stdout, ""value: %d\n"", value);
        } else {
            fprintf(stderr, ""unexpected character: %c\n"", chr);
        }
        // Remove remaining characters from the
        // input buffer.
        while (((chr = fgetc(stdin)) != '\n') &amp;&amp; (chr != EOF))
            ;
    }
    return 0;
}
</code></pre>
",3
48472897,48472733,1,"<p>In C99 and <a href=""https://port70.net/~nsz/c/c11/n1570.html#5.1.2.2.3"" rel=""nofollow noreferrer"">C11 ¡ì5.1.2.2.3 Program termination</a>, the standard stipulates:</p>

<blockquote>
  <h3>5.1.2.2.3 Program termination</h3>
  
  <p>?1 If the return type of the <code>main</code> function is a type compatible with <code>int</code>, a return from the
  initial call to the <code>main</code> function is equivalent to calling the <code>exit</code> function with the value
  returned by the <code>main</code> function as its argument;<sup>11)</sup> reaching the <code>}</code> that terminates the
  <code>main</code> function returns a value of 0. If the return type is not compatible with <code>int</code>, the
  termination status returned to the host environment is unspecified.</p>
  
  <hr>
  
  <p><sup>11)</sup> In accordance with 6.2.4, the lifetimes of objects with automatic storage duration declared in <code>main</code>
  will have ended in the former case, even where they would not have in the latter.</p>
</blockquote>

<p>There was no similar provision in C90.  If you return from <code>main()</code> in a C90 program by falling off the end (rather than by executing a <code>return</code> with a value), the value returned to the environment is undefined.  The code still worked, but programs such as the shell could not reliably detect whether the program was successful or not.</p>

<blockquote>
  <p>ISO/IEC 9899:1990</p>
  
  <h3>5.1.2.2.3 Program termination</h3>
  
  <p>?1 A return from the initial call to the <code>main</code> function is equivalent to calling the <code>exit</code> function
  with the value returned by the <code>main</code> function as its argument. If the <code>main</code> function executes a return that specifies no value, the termination status returned to the host environment is undefined.</p>
  
  <h3>6.6.6.4 The <code>return</code> statement</h3>
  
  <p>?3 If a return statement without an expression is executed, and the value of the function call is used by the caller, the behavior is undefined. Reaching the <code>}</code> that terminates a function is equivalent to executing a <code>return</code> statement without an expression.</p>
</blockquote>

<p>This paragraph is not present in <a href=""https://port70.net/~nsz/c/c11/n1570.html#6.8.6.4"" rel=""nofollow noreferrer"">C11 ¡ì6.8.6.4 The <code>return</code> statement</a>.</p>

<p>Thus, if your compiler supports C99 or C11, dropping off the end of <code>main()</code> is equivalent to <code>return 0;</code> but this was not the case before C99.  I believe this was done as much for conformity with C++98 (which has essentially the same rule) as for any other reason.</p>

<p>Speaking personally, I dislike the rule and my <code>main()</code> programs normally end <code>return 0;</code>.</p>
",1
48472876,48472733,1,"<p>As of <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf"" rel=""nofollow noreferrer"">C99</a>, it's well-defined.</p>

<p>¡ì 5.1.2.2.3 Program termination</p>

<blockquote>
  <p>reaching the <code>}</code> that terminates the <code>main</code> function returns a value of 0.</p>
</blockquote>
",0
51801717,51801692,1,"<p>There is no concept of table in C programming. Probably you could have asked the interviewer, did he mean by multi-level array OR array of arrays.</p>
",1
50971559,50971467,3,"<p>This:</p>

<pre><code>c.nama
</code></pre>

<p>should be:</p>

<pre><code>c-&gt;nama
</code></pre>

<p>since <code>c</code> is not a struct or union, it's a pointer to a struct.</p>
",0
50971591,50971467,2,"<p><code>c</code> is a pointer to a struct, not a struct itself, so you can't use the <code>.</code> operator on it.  You need to instead use <code>-&gt;</code>, which dereferences the pointer and then gets the member:</p>

<pre><code>strcpy(pembuka.nama,c-&gt;nama);
strcpy(pembuka.id,c-&gt;id);
strcpy(pembuka.password,c-&gt;password);
</code></pre>
",1
51269521,51237678,0,"<p>As noted in <a href=""https://stackoverflow.com/questions/51237678/matrix-by-reference-c?noredirect=1#comment89514768_51237678"">comments</a>:</p>
<blockquote>
<p>My compiler tells me that you don't return a value from <code>preecherMatriz()</code>, which is sad because you use that value when you call <code>matrizComplementar()</code> ¡ª it's probably why your program crashes. Your 4 function calls in a single line are scary. I'd not write code like that, especially where memory allocation is involved. Your <code>printf()</code> also prints the address of the array element (incorrectly): you should drop the <code>&amp;</code>.</p>
<p>One reason for not liking the multiple function calls ¡ª you don't keep track of the allocated memory, so you can't free it. It may not matter here; it does in most programs.</p>
</blockquote>
<p>Here's an MCVE based closely on your code, that runs without crashing and produces the result I expect:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define N 5

static int **preecherMatriz(int **mat)
{
    for (int k = 0; k &lt; N; k++)
    {
        for (int l = 0; l &lt; N; l++)
        {
            printf(&quot;Entre com o Valor [%d][%d]: &quot;, k, l);
            scanf(&quot;%d&quot;, &amp;mat[k][l]);
        }
    }
    return mat;
}

static int **retornarMatrizQuadrada(int tamN)
{
    int **mat;
    mat = (int **)malloc((tamN) * sizeof(int *));
    for (int i = 0; i &lt; tamN; i++)
        mat[i] = (int *)malloc((tamN) * sizeof(int));
    return mat;
}

static void imprimirMatriz(int **m)
{
    printf(&quot;\nMatriz complementar:\n&quot;);
    for (int k = 0; k &lt; N - 1; k++)
    {
        for (int l = 0; l &lt; N - 1; l++)
            printf(&quot; %3d&quot;, m[k][l]);
        printf(&quot;\n&quot;);
    }
}

static int **matrizComplementar(int **matOriginal, int linha, int coluna)
{
    int y = 0;
    int k = 0;

    int **matCompl = retornarMatrizQuadrada(N - 1);

    for (int i = 0; i &lt; N; i++)
    {
        if (i != linha)
        {
            for (int j = 0; j &lt; N; j++)
            {
                if (j != coluna)
                {
                    matCompl[y][k] = matOriginal[i][j];
                    k++;
                }
            }
            y++;
        }
        k = 0;
    }
    return matCompl;
}

int main(void)
{
    imprimirMatriz(matrizComplementar(preecherMatriz(retornarMatrizQuadrada(N)), 1, 2));
}
</code></pre>
<p>The only changes are to make the functions <code>static</code> (to get past my extremely fussy compiler options), plus the extra <code>return</code> and the removed <code>&amp;</code>, and I removed <code>system(&quot;pause&quot;);</code> in the matrix printing function.  I've not added checking for memory allocation failures ¡ª it should be done, but I've not done it.</p>
<p>Sample output (program name <code>mtx29</code>):</p>
<pre><code>$ mtx29
Entre com o Valor [0][0]: 100
Entre com o Valor [0][1]: 101
Entre com o Valor [0][2]: 102
Entre com o Valor [0][3]: 103
Entre com o Valor [0][4]: 104
Entre com o Valor [1][0]: 210
Entre com o Valor [1][1]: 211
Entre com o Valor [1][2]: 212
Entre com o Valor [1][3]: 213
Entre com o Valor [1][4]: 214
Entre com o Valor [2][0]: 320
Entre com o Valor [2][1]: 321
Entre com o Valor [2][2]: 322
Entre com o Valor [2][3]: 323
Entre com o Valor [2][4]: 324
Entre com o Valor [3][0]: 498
Entre com o Valor [3][1]: 497
Entre com o Valor [3][2]: 476
Entre com o Valor [3][3]: 465
Entre com o Valor [3][4]: 454
Entre com o Valor [4][0]: 511
Entre com o Valor [4][1]: 522
Entre com o Valor [4][2]: 533
Entre com o Valor [4][3]: 544
Entre com o Valor [4][4]: 555

Matriz complementar:
 100 101 103 104
 320 321 323 324
 498 497 465 454
 511 522 544 555
$
</code></pre>
<p>So, your code was close to working, but either you were ignoring compiler warnings (don't!) or your compiler wasn't giving you all the help you need ¡ª find out how to turn up the warning level.</p>
<p>The code shown (<code>mtx29.c</code>) compiles cleanly on a Mac running macOS High Sierra 10.13.6 using GCC 8.1.0, and the command line:</p>
<pre><code>$ gcc -O3 -g -std=c11 -Wall -Wextra -Werror -Wmissing-prototypes -Wstrict-prototypes \
&gt;     mtx29.c -o mtx29
$
</code></pre>
",2
49743683,49743478,0,"<p>struct in c is a place in memory which is big enough to keep data for all its fields. As with any other objects in 'c' you have a choice to use it as a variable or use a pointer to it. A pointer is essentially a memory address of this variable.</p>

<p>Also, every variable in 'c' has a type. The latter behaves like a template for creating variables and check their usage.</p>

<p>So, in the following example you create a struct type <code>struct header</code> and describe what it contains.</p>

<pre><code>struct header{
    int count;
    node *first;
};
</code></pre>

<p>Now, using the type, you can create the variable named <code>my_header</code>:</p>

<pre><code>struct header my_header;
</code></pre>

<p>or, as in your example, variable <code>header</code>.</p>

<pre><code>struct header header;
</code></pre>

<p>As in you example you can combine both into a single statement.</p>

<p>Now, if you created a variable of type 'struct header', you can access its members using the <code>.</code> operator. The following operator will cause 'c' to access member count of your struct variable. It will calculate correct place in memory to put '10' into it. </p>

<pre><code>header.count = 10;
</code></pre>

<p>as for pointers, you can create a variable which will keep an address to your object. In 'c' it needs to know what type of object it points to. So, the pointer <code>ptr</code> in the following example is assigned address <code>&amp;</code> of the variable <code>header</code>.</p>

<pre><code>struct header *ptr = &amp;header;
</code></pre>

<p>Now you can use the pointer to access fields in the header, but it requires a different syntax <code>-&gt;</code>. so, the following statement will be equivalent to the previous one:</p>

<pre><code> ptr-&gt;count = 10;
</code></pre>

<p>Note that in both cases '10' was assigned to absolutely the same object, field of the variable 'header'.</p>

<p>Also to make life easier ant to stop typing <code>struct</code> every time, you can use the <code>typedef</code> operator to declare a named type, i.e.</p>

<pre><code>typedef struct node myNodeType;
typedef struct node node;
</code></pre>

<p>now you have to 'named' types: <code>myNodeType</code> and <code>node</code> which are the same. you can use them to declare variables and pointers:</p>

<pre><code> myNodeType var1; // variable
 node *next;  // pointer.
</code></pre>

<p>and as in case with variable declaration, you can combine it with struct declaration as in your example.</p>

<p>And <code>malloc</code> just allocates a chunk of dynamic memory and returns its address, aka pointer to it. so, <code>node* current = (node*)malloc(sizeof(node));</code> just assigns address of allocated memory to the pointer <code>current</code>.</p>

<p>Hope it helps a bit. </p>
",0
49743521,49743478,0,"<p><code>struct header { ... } header;</code> is simultaneously creating the struct type (<code>struct header</code>) as well as creating a global variable (named <code>header</code>, of type <code>struct header</code>). It is equivalent to doing:</p>

<pre><code>struct header { ... };
struct header header;
</code></pre>

<p>When you write <code>header.first = x</code>, what you're doing is just modifying the global object named <code>header</code>.</p>

<p><code>typedef struct node { ... } node;</code> is simultaneously creating the struct type (<code>struct node</code>) as well as a typedef to it (<code>node</code>). It is equivalent to doing:</p>

<pre><code>struct node { ... };
typedef struct node node;
</code></pre>

<p>As for <code>.</code> vs <code>-&gt;</code>: <code>a-&gt;b</code> is equivalent to <code>(*a).b</code>. It's just <a href=""https://en.wikipedia.org/wiki/Syntactic_sugar"" rel=""nofollow noreferrer"">syntactic sugar</a>.</p>
",0
49031399,49030693,1,"<p>I coded up an example that makes use of fopen, fread, and the classic example doubling the buffer size as the content grows.</p>

<pre><code>int main()
{

    const size_t initial_size = 1024;
    char* contents = (char*)malloc(initial_size);
    size_t length = 0;
    size_t allocated = initial_size;

    FILE* file = fopen(""./sbatch_example.sh"", ""r"");
    if (file)
    {
        while (1)
        {
            size_t remaining = allocated - length;
            size_t result = 0;

            if (remaining == 0)
            {
                contents = (char*)realloc(contents, allocated*2);
                allocated = allocated*2;
                remaining = allocated-length;
            }

            result = fread(contents+length, 1, remaining, file);
            length += result;

            if (result==0) /* EOF */
            {
                break;
            }
        }
    }

    if (file)
    {
        fclose(file);
        file = NULL;
    }

    /* at this point, ""contents"" is your file data bytes
       and ""length"" is the number of bytes copied into that array*/

    /*optional: append a null char to the end of the buffer to make  it easier for debugging and print statements */
    contents = (char*)realloc(contents, length+1);
    contents[length] = '\0';


    free(contents);
    return 0;
}
</code></pre>
",1
49161489,49160849,2,"<p>From the documentation for <a href=""http://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer""><code>printf</code></a>:</p>

<blockquote>
  <p>If there are fewer arguments than required by format, the behavior is
  undefined. If there are more arguments than required by format, the
  extraneous arguments are <strong>evaluated</strong> and ignored.</p>
</blockquote>

<p>The output of the program is:</p>

<pre><code>worldhello
</code></pre>

<p>The argument of the first <code>printf</code> is:
   <code>printf(""world"")</code></p>

<p>Since the argument is a function, the function will be called producing word:</p>

<pre><code>word
</code></pre>

<p>Then first <code>printf</code> will print <code>hello</code>. Those prints together will give you:</p>

<pre><code>worldhello
</code></pre>

<p>Try this:</p>

<pre><code>#include&lt;stdio.h&gt;

int main(void)
{
    printf("" hello! %d"",printf(""world""));
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>world hello! 5 
</code></pre>

<p>If <code>printf</code> is successful the total number of characters written is returned. On failure, a negative number is returned.</p>
",0
58187629,58187573,9,"<p>A <code>float</code> is a type that holds a 32-bit floating point number, while the constant <code>4.4e10</code> represents a <code>double</code>, which holds a 64-bit floating point number (i.e. a <em>double</em>-precision floating point number)</p>

<p>When you assign <code>4.4e10</code> to <code>c</code>, the value <code>4.4e10</code> cannot be represented precisely (a rounding error in a parameter called the mantissa), and the closest possible value (44000002048) is stored. When it is passed to <code>printf</code>, it is <a href=""https://stackoverflow.com/questions/6395726/how-does-printf-and-co-differentiate-between-float-and-double"">promoted</a> back to <code>double</code>, including the rounding error. </p>

<p>In the second case, the value is a <code>double</code> the whole time, without narrowing and widening, and it happens to be the case that a <code>double</code> can represent the value exactly.</p>

<p>If this is undesirable behavior, you can declare <code>c</code> as a <code>double</code> for a bit more precision (but beware that you'll still hit precision limits eventually).</p>
",0
58187657,58187573,3,"<p>You're actually printing the values of two different types here.</p>

<p>In the first case you're assigning a value to a variable of type <code>float</code>.  The precision of a <code>float</code> is roughly 6 or 7 decimal digits, so unless the value can be represented exactly you'll see the closest value that can be represented by that type.</p>

<p>In the second case you're passing the constant <code>4.4e10</code> which has type <code>double</code>.  This type has around 16 decimal digits of precision, and the value is within that range, so the exact value is printed.</p>
",2
54982908,54950576,1,"<p>If your problem is that you want to read an input stream of characters, divide that stream into tokens, and then emit only a subset of those tokens, I think <a href=""https://en.wikipedia.org/wiki/Lex_(software)"" rel=""nofollow noreferrer"">Lex</a> is exactly the tool you're looking for.</p>

<p>If I understand your comment correctly, the file you're trying to read in and transform is itself C code. So you will need to build up a Lex definition of the C language rules.</p>

<p>A quick search turned up <a href=""https://www.lysator.liu.se/c/ANSI-C-grammar-l.html"" rel=""nofollow noreferrer"">this Lex specification of the ANSI C grammar</a>. I cannot vouch for its accuracy or speak to its licensing. At first glance it seems to only support C89. But it is probably enough to point you in the right direction.</p>
",0
54073582,54073200,2,"<p>first proposal a priori slow</p>

<p>One way is to process by exchanging the values in the same order you do to you sort the 1D array. When you exchange <code>arr[i]</code> and <code>arr[j]</code> you also exchange <code>mat_1[i]</code> and <code>mat_1[j]</code> </p>

<p>You don't need to duplicate the 3D array but of course it is more CPU consuming, choose a sort in O(n*log(n))</p>

<hr>

<p>Second proposal a priori faster, using the 1D array index = {3,0,1,2}, you add a 1D array memorizing the indexes in the 3D array, so at the beginning matIdx = {0, 1, 2, 3} then you compare them :</p>

<p>index 0 : you want idx[0]=3 but you have matIdx[0] = 0 => you search in matIdx where is 3 and it is at index 3, so you exchange mat[0] and mat[3], you update matIdx becoming {3,1,2,0}</p>

<p>index 1 : you want idx[1]=0 but you have matIdx[1] = 1 => you search in matIdx where is 0 and it is at index 3, so you exchange mat[1] and mat[3], you update matIdx becoming {3,0,2,1}</p>

<p>index 2 : you want idx[2]=1 but you have matIdx[2] = 2 => you search in matIdx where is 1 and it is at index 3, so you exchange mat[2] and mat[3], you update matIdx becoming {3,0,1,2}</p>

<p>Of course for index 2 it can be simplified because they are the last 2 positions, so there are in order or you just need to exchange, I continued without that optimization to explain</p>

<p>In that way you do at worst n exchanges in mat, the complexity is just to search the indexes in matIdx but this is probably nothing compared to the time to exchange the values in mat</p>

<p>Implementation can be (I do not have your function <code>sorted_order</code> so I do not use it) :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define LENGTH 4
#define ROWS 2
#define COLS 4

/*void sorted_order (int *arr, int n, int *idx);*/

/* exchange mat[i] and mat[j] and update matIdx, i &gt; j */
void swap(int mat[][ROWS][COLS], int matIdx[], int i, int j)
{
  int temp[ROWS][COLS];

  memcpy(temp, mat[j], sizeof(mat[0]));
  memcpy(mat[j], mat[i], sizeof(mat[0]));
  memcpy(mat[i], temp, sizeof(mat[0]));
  matIdx[i] = j;
}

/* return the index in matIdx where what is */
int findIdx(int matIdx[], int from , int what)
{
  while (matIdx[from] != what)
    from += 1;

  return from;
}

int main()
{
    int mat[LENGTH][ROWS][COLS] = {{{6,6,6,6},{6,6,6,6}},{{2,2,2,2},{2,2,2,2}},{{1,1,1,1},{1,1,1,1}},{{7,7,7,7},{7,7,7,7}}};
    int idx[LENGTH] = {3,0,1,2}; /* idx is normaly set by your function sorted_order */
    int matIdx[LENGTH];
    int index;

    /* initialize matIdx */
    for (index = 0; index != LENGTH; ++index)
      matIdx[index] = index;

    /* sort except the last element */
    for(index = 0; index != LENGTH - 2; index++){
      if (idx[index] != matIdx[index]) {
        // need to exchange
        swap(mat, matIdx, findIdx(matIdx, index + 1, idx[index]), index);
      }
    }

    /* last 2 elements */
    if (idx[LENGTH - 2] != matIdx[LENGTH - 2]) {
      // need to exchange
      swap(mat, matIdx, LENGTH - 1, LENGTH - 2);
    }

    /* print result */
    for(index = 0; index &lt; LENGTH; index++){
      int row;

      for(row = 0; row &lt; ROWS; row++){
        int col;

        for(col = 0; col &lt; COLS; col++){
          printf(""%d\t"",mat[index][row][col]);
        }
        printf(""\n"");
      }
      printf(""\n"");
    }

    return 0;
}
</code></pre>

<p>Execution writes :</p>

<pre><code>7   7   7   7   
7   7   7   7   

6   6   6   6   
6   6   6   6   

2   2   2   2   
2   2   2   2   

1   1   1   1   
1   1   1   1   
</code></pre>
",4
50236651,50235607,0,"<p>In you function,</p>

<pre><code>bool load(struct dict *root, char *inputfile)
</code></pre>

<p>you pass a <code>root</code> pointer, but then replace it with the result of <code>getNode</code>.
The calling code will not see this change.
You need to pass a pointer to the root pointer,</p>

<pre><code>bool load(struct dict **root, char *inputfile)
</code></pre>

<p>for the calling code to see the change.</p>

<p>More simply, since you throw away the <code>root</code> with</p>

<pre><code>root = getNode();
</code></pre>

<p>right near the top of the function, you could change the <code>load</code> signature:</p>

<pre><code>struct dict * load(char *inputfile)
</code></pre>

<p>Instead of <code>return true;</code> at the end, <code>return root;</code> instead.
You don't have a path returning flase anyway.</p>

<p>Change the calling code too.
Instead of</p>

<pre><code>struct dict *root = malloc(sizeof(struct dict));
load(root, argv[1]);
</code></pre>

<p>try this:</p>

<pre><code>struct dict *root = load(argv[1]);
</code></pre>
",0
54061185,54061073,2,"<p>if I well understand you want something like that :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
  const char *mystring = ""test,blabla,blabla,blabla"";
  int n = 0;
  const char * p1;

  /* compute result length */
  for (p1 = mystring; *p1; ++p1)
    n += (*p1 == ',') ? 2 : 1;

  /* make result string */
  char * r = malloc(n + 1);
  char * p2 = r;

  for (p1 = mystring; *p1; ++p1) {
    if ((*p2++ = *p1) == ',')
      *p2++ = '""';
  }
  *p2 = 0;

  /* show it works */
  printf(""%s\n"", r);
  return 0;
}
</code></pre>

<p>That prints <code>test,""blabla,""blabla,""blabla</code></p>

<hr>

<p>If you want to have also the \ before the "" as you say in the remark :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
  const char *mystring = ""test,blabla,blabla,blabla"";
  int n = 0;
  const char * p1;

  /* compute result length */
  for (p1 = mystring; *p1; ++p1)
    n += (*p1 == ',') ? 3 : 1;

  /* make result string */
  char * r = malloc(n + 1);
  char * p2 = r;

  for (p1 = mystring; *p1; ++p1) {
    if ((*p2++ = *p1) == ',') {
      p2[0] = '\\';
      p2[1] = '""';
      p2 += 2;
    }
  }
  *p2 = 0;

  /* show it works */
  printf(""%s\n"", r);
  return 0;
}
</code></pre>

<p>That prints : <code>test,\""blabla,\""blabla,\""blabla</code></p>
",8
50267819,50266186,3,"<p>If your system supports <a href=""http://man7.org/linux/man-pages/man3/termios.3.html"" rel=""nofollow noreferrer"">termios</a> as standardized in POSIX.1-2001, then you can manipulate the standard input terminal to not buffer your input. Consider the following example:</p>

<pre><code>#define  _POSIX_C_SOURCE  200809L
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;termios.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

/* SIGINT handler */

static volatile sig_atomic_t  done = 0;

static void handle_done(int signum)
{
    if (!done)
        done = signum;
}

static int install_done(const int signum)
{
    struct sigaction  act;
    memset(&amp;act, 0, sizeof act);
    sigemptyset(&amp;act.sa_mask);
    act.sa_handler = handle_done;
    act.sa_flags = 0;
    if (sigaction(signum, &amp;act, NULL) == -1)
        return errno;
    return 0;
}

/* Reverting terminal back to original settings */

static struct termios  terminal_config;

static void revert_terminal(void)
{
    tcsetattr(STDIN_FILENO, TCSAFLUSH, &amp;terminal_config);
}


int main(void)
{
    int  c;

    /* Set up INT (Ctrl+C), TERM, and HUP signal handlers. */
    if (install_done(SIGINT) ||
        install_done(SIGTERM) ||
        install_done(SIGHUP)) {
        fprintf(stderr, ""Cannot install signal handlers: %s.\n"", strerror(errno));
        return EXIT_FAILURE;
    }

    /* Make terminal input noncanonical; not line buffered. Also disable echo. */
    if (isatty(STDIN_FILENO)) {
        struct termios  config;
        if (tcgetattr(STDIN_FILENO, &amp;terminal_config) == 0 &amp;&amp;
            tcgetattr(STDIN_FILENO, &amp;config) == 0) {
            config.c_lflag &amp;= ~(ICANON | ECHO);
            config.c_cc[VMIN] = 1; /* Blocking input */
            config.c_cc[VTIME] = 0;
            tcsetattr(STDIN_FILENO, TCSANOW, &amp;config);
            atexit(revert_terminal);
        }
    }

    /* Set standard input unbuffered. */
    setvbuf(stdin, NULL, _IONBF, 0);

    printf(""Press Ctrl+C to exit.\n"");
    fflush(stdout);

    while (!done) {
        c = fgetc(stdin);
        if (c == EOF)
            printf(""Read EOF%s\n"", ferror(stdin) ? "" as an error occurred"" : """");
        else
            printf(""Read %d = 0x%02x\n"", c, (unsigned int)c);
        fflush(stdout);
    }

    return EXIT_SUCCESS;
}
</code></pre>

<p>The <code>#define</code> line tells your C library headers to expose POSIX.1 features for GNU-based systems.</p>

<p>The <code>done</code> flag is set whenever an INT (<kbd>Ctrl</kbd>+<kbd>C</kbd>), TERM, or HUP signal is received. (HUP signal is sent if you disconnect from the terminal, for example by closing the terminal window.)</p>

<p>The <code>terminal_config</code> structure will contain the original terminal settings, used by <code>revert_terminal()</code> registered as an at-exit function, to revert the terminal settings back to the original ones read at program startup.</p>

<p>The function <code>isatty(STDIN_FILENO)</code> returns 1 if standard input is a terminal. If so, we obtain the current terminal settings, and modify them for non-canonical mode, and ask that each read blocks until at least one character is read. (The  I/O functions tend to get a bit confused if you set <code>.c_cc[VMIN]=0</code> and <code>.c_cc[VTIME]=0</code>, so that if no input is pending, <code>fgetc()</code> returns 0. Typically it looks like an EOF to stdio.h I/O functions.)</p>

<p>Next, we tell the C library to not internally buffer standard input, using <code>setvbuf()</code>. Normally, the C library uses an input buffer for standard input, for efficiency. However, for us, it would mean the C library would buffer characters typed, and our program might not see them immediately when typed.</p>

<p>Similarly, standard output is also buffered for efficiency. The C library should flush all complete lines to the actual standard output, but we can use the <code>fflush(stdout)</code> call to ensure everything we've written to stdout is flushed to the actual standard output at that point.</p>

<p>In <code>main()</code>, we then have a simple loop, that reads keypresses, and prints them in decimal and hexadecimal.</p>

<p>Note that when a signal is delivered, for example the INT signal because you typed <kbd>Ctrl</kbd>+<kbd>C</kbd>, the delivery of the signal to our <code>handle_done()</code> signal handler interrupts the <code>fgetc()</code> call if one is pending. This is why you see <code>Read EOF</code> when you press <kbd>Ctrl</kbd>+<kbd>C</kbd>; if you check <code>ferror(stdin)</code> afterwards, you'll see it returns nonzero (which indicates an error occurred). The ""error"" in this case is <code>EINTR</code>, ""interrupted by a signal"".</p>

<p>Also note that when you press some certain keys, like cursor or function keys, you'll see multiple characters generated, usually beginning with 27 and 91 (decimal; 0x1B 0x5B in hexadecimal; <code>""\033[""</code> if expressed as a C string literal).  These are usually, but not always, ANSI escape sequences. In general, they are terminal-specific codes that one can obtain via <code>tigetstr()</code>, <code>tigetnum()</code>, and <code>tigetflag()</code> using the <a href=""http://man7.org/linux/man-pages/man3/term_variables.3x.html"" rel=""nofollow noreferrer"">terminfo</a> database.</p>

<hr>

<p>A much more portable way to do this, is to use a Curses library; either <a href=""https://invisible-island.net/ncurses/"" rel=""nofollow noreferrer"">ncurses</a> on most systems, or <a href=""https://pdcurses.sourceforge.io/"" rel=""nofollow noreferrer"">PDCurses</a> on Windows machines. Not only do they provide a much easier interface, but it does it in a terminal-specific way, for maximum compatibility across systems.</p>

<p>C programs using the Curses functions can be compiled against any Curses library, so the same C source file can be compiled and run on Linux, Mac, and Windows machines.  However, ncurses does contain quite a few extensions, which may not be provided by other Curses libraries like PDCurses.</p>
",3
51990814,51990590,2,"<p><a href=""http://man7.org/linux/man-pages/man3/isdigit.3.html"" rel=""nofollow noreferrer""><code>isdigit</code></a> function takes an <code>int</code> as argument, not a <code>char *</code>. So you can't pass <code>passCode</code>. You'll have to loop over <code>passCode</code> and test each of the characters in <code>passCode</code> using <code>isdigit</code>.</p>

<p>For example:</p>

<pre><code>bool hasDigit = false;

for (size_t i = 0; passCode[i]; ++i) {
    if (isdigit((unsigned char)passCode[i])) {
        hasDigit = true;
        break;
    }
}

...
</code></pre>

<p>Note that <code>isdigit</code> (and all <code>&lt;ctype&gt;</code> functions) doesn't necessarily return 1, so comparing with <code>true</code> is incorrect. Just check if it returns 0 or non-zero - that's what <code>isdigit</code> is documented to return.</p>

<p>You'll use a similar loop for the second problem and do:</p>

<pre><code>for (size_t i = 0; passCode[i]; ++i) {
   if (isspace((unsigned char)passCode[i])) {
      passCode[i] = '_';
   }
}
</code></pre>
",4
53036585,53036339,1,"<blockquote>
  <p>Any help is appreciated.</p>
</blockquote>

<p>Use <code>isalpha()</code> to detect if a <code>char</code> is part of a <em>word</em>.</p>

<p>Use <code>toupper()</code> to convert to an uppercase character.</p>

<p>Use <code>unsigned char</code> for <code>isalpha()</code>, <code>toupper()</code> to avoid UB with negative <code>char</code> values.</p>

<p>Employ a boolean to keep track if a beginning of a word is possible.</p>

<pre><code>#include &lt;ctpye.h&gt;
#include &lt;stdbool.h&gt;

void convertir(const char *cadena) {
  const unsigned char *s = (const unsigned char *) cadena;
  bool potential_start_of_word = true;

  while (*s) {
    // If next character is not an alpha or we area at the start of a word ...
    if (!isapha(s[1]) || potential_start_of_word) {
      printf(""%c"", toupper(*s));
    } else {
      printf(""%c"", *s);
    }
    potential_start_of_word = !isapha(*s);
    s++;
  }
}
</code></pre>

<p>No need for <code>strlen(cadena)</code></p>
",0
50548345,50548308,1,"<p>The three expressions that you mention produce identical results when passed as parameters to a function taking <code>void*</code>. The reasons why it is so are different:</p>

<ul>
<li><code>&amp;na.array</code> is the address of the array. It matches the address of its initial element, but it has a different type. However, you are passing it to a function taking <code>void*</code>, so the type does not matter.</li>
<li><code>na.array</code> is the array itself. It ""decays"" to a pointer to array's initial element when passed to a <code>void*</code> parameter.</li>
<li><code>&amp;na.array[0]</code> is the address of array's initial element, taken directly. It gets converted to <code>void*</code> when you pass it as a parameter to <code>memset</code>.</li>
</ul>
",0
51342921,51342829,2,"<p><code>char</code> strings in C are really called <strong><em>null-terminated</strong> byte strings</em>. That <em>null-terminated</em> bit is important, and all string functions look for it to know when the string ends.</p>

<p>If you pass an unterminated string to a string function, it will go out of bounds and that will lead to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>.</p>

<p>The terminator is equal to zero, either integer <code>0</code> or the character <code>'\0'</code>.</p>

<p>And of course this null-terminator character needs space in your string. That means a string of 10 character must have space for 11 to fit the terminator.</p>

<p>The simple first would look something like</p>

<pre><code>char letters[11] = { 0 };  // Space for ten character plus terminator
// The above definition also initializes all elements in the array to zero,
// which is the terminator character

memset(letters, 'A', 10);  // Set the ten first characters to the letter 'A'

printf(""%s"", letters);  // Never print a data string directly using printf's first parameter.

printf("" Total buffer len: %d bytes\n"", strlen(letters));
</code></pre>

<p><sub>Note the change to <code>printf</code>. This is because if you ever get the string input from a user, passing it directly as the format string to <code>printf</code> is an incredibly bad security hole. If the string contains formatting code but there are no arguments, that would lead to <em>undefined behavior</em>.</sub></p>

<p><sub>Also note that I changed the <a href=""https://en.wikipedia.org/wiki/Magic_number_(programming)"" rel=""nofollow noreferrer""><em>magic number</em></a> <code>0x41</code> to the <a href=""http://en.cppreference.com/w/c/language/ascii"" rel=""nofollow noreferrer"">ASCII</a> character it corresponds to. Magic numbers is a bad habit that makes code harder to read, understand and maintain.</sub></p>
",0
48878032,48877959,4,"<p>I didn't look thoroughly at your code, but I saw this which doesn't do what you think it does:</p>

<pre><code>void removeChild(node * trash){
    if(trash-&gt;left == NULL &amp;&amp; trash-&gt;right == NULL) { //no parents
            free(trash);
            trash = NULL;
    }
 ...
</code></pre>

<p>The last statement which intends to clear the pointer only does that for the parameter.  The caller's pointer (which is passed to <code>removeChild()</code>) does not have its pointer NULLed.  That is because parameters passed to a function are copied.  They are not passed by reference.</p>

<p>Presumably other code could depend on the pointer being cleared, and so this would not satisfy it.</p>
",4
52012562,52012445,3,"<p>In C, a <em>string</em> is a sequence of character values <em>including the nul terminator</em>.  That terminator is how the various C library routines know where the end of the string is.  If you don't terminate a string properly, library routines like <code>strlen</code> and <code>strcpy</code> and <code>printf</code> with <code>%s</code> will all scan past the end of the string into other memory, resulting in garbled output or runtime errors.  </p>

<p>The reason you got different results for the length of <code>a</code> with the two different compilers is that in the clang case, the byte immediately following the last element of <code>a</code> contained 0, whereas in the gcc case the bytes immediately following <code>a</code> did not contain 0.  </p>

<p>Strictly speaking, the behavior on passing a non-terminated sequence of characters to the string handling routines is <em>undefined</em> - the language specification places no requirements on the compiler or runtime environment to ""do the right thing"", whatever that would be.  You've basically voided the warranty at that point, and pretty much anything can happen.  </p>

<p>Note that the C language specification does not require bounds checks on array accesses - the fact that you got the index out of bounds exception for clang is due to the compiler being extra friendly and going beyond what the language standard actually requires.  </p>
",0
52012577,52012445,5,"<p>Unexpected behavior that you see is called <em>undefined behavior</em> (UB) in the C standard:</p>

<ul>
<li>Calling <code>strlen</code> on <code>aString</code> is UB because there is no null termination</li>
<li>Dereferencing <code>aString</code> at its undefined index is UB, unless the index is 0, 1, or 2</li>
<li>gcc could insert null terminator inadvertently by aligning <code>bString</code> at 4-byte boundary. It doesn¡¯t change the fact that it¡¯s still a UB, though.</li>
</ul>
",0
51353526,51353472,2,"<p>An <a href=""https://en.cppreference.com/w/c/language/escape"" rel=""nofollow noreferrer"">escape sequence</a> isn't the single <code>\</code> character; it's that <em>followed by another character</em>. For example, <code>\""</code> is an escape sequence, as is <code>\n</code>. Under some circumstances you can see more than a single character following the backslash all as the same escape code; this has to do with how the characters are represented internally (ASCII or Unicode value) and can be safely ignored for now.</p>

<p>An escape sequence is used to write a character that is inconvenient/impossible to put into the code directly. For example, <code>\""</code> is the escape sequence for a quotation mark. It is like putting a quote inside the string, which you couldn't otherwise do because it would instead close the string literal. Look at the syntax highlighting of your question to see what I mean; most of the first line is considered part of the string, because you never have an <em>unescaped</em> closing quote.</p>

<p>The most common escape sequence is perhaps <code>\n</code>. Unlike with <code>\""</code>, it doesn't just produce a literal <code>n</code> in the string; you could do that without an escape. Instead it produces a newline. The code</p>

<pre><code>printf(""hii\nthere"");
</code></pre>

<p>prints</p>

<pre><code>hii
there
</code></pre>

<p>to the screen.</p>

<p>The second line of code in your question uses the escape sequence <code>\</code> (backslash space). Thisis not a standard escape sequence; if you compile with warnings your compiler will probably report that it's ignoring it or something.</p>

<p>(If you want to actually print a backslash to the screen, you need to escape a backslash, using <code>\\</code>)</p>
",1
50823394,50823284,3,"<p>The way arguments are passed to a function are implementation dependent.  To read variable arguments in a portable way, you need to use the <code>stdarg</code> family of functions.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void Test1(double first_arg, ...)
{
    printf(""arg[0]=%f\n"", first_arg);

    va_list ap;
    va_start(ap, first_arg);
    double arg1 = va_arg(ap, double);
    printf(""arg[1]=%f\n"", arg1);
    double arg2 = va_arg(ap, double);
    printf(""arg[2]=%f\n"", arg2);
    va_end(ap);
}

int main()
{
    printf(""Test1:\n"");
    Test1(1.0, 2.0, 3.0);
    return 0;
}
</code></pre>
",2
53897881,53897757,0,"<p>In the language C arrays are a bit strange. At array-of-x can degrade in to a pointer-to-x, very easily. For example if passing to another routine, or as in your case when adding to it. So you are correct it is pointer arithmetic. (In pointer arithmetic you can add pointers and integers, to get pointers.)</p>
",0
50548845,50548738,1,"<p>I'm not going to change your code much, as effectively all you really need to do is wrap this up in a loop, and break out of the loop if it's one of the required options.</p>

<pre><code>char tipo[20];
char Equ[] = ""equilatero"";
char Ret[] = ""retangulo"";
char Iso[] = ""isoceles"";
int l,b,h;

while (1) {
    printf(""digite o tipo de triangulo desejado:\n equilatero ou retangulo/isoceles\n"");
    scanf(""%19s"", tipo);
    if (strcmp (tipo,Equ) == 0){
        printf(""digite o valor do lado \n"");
        scanf(""%d"", &amp;l);
        TriaEqui(l);
        break;
    }else if (strcmp (tipo,Ret) == 0){
        printf(""digite a base"");
        scanf(""%d"",&amp;b);
        printf(""digite a altura"");
        scanf(""%d"",&amp;h);
        TriaIsoc(b,h);
        break;      
    }else if(strcmp (tipo,Iso) == 0){
        printf(""digite a base"");
        scanf(""%d"",&amp;b);
        printf(""digite a altura"");
        scanf(""%d"",&amp;h);
        TriaIsoc(b,h);
        break;      
    }else {
        printf(""escolha uma das 3 opcoes!"");
    }
}
</code></pre>
",2
50258341,50258301,4,"<p>Try instead:</p>

<pre><code> hour   = (gap &gt; 0) ? gap/100 : (2400 - gap)/100;
 minute = (gap &gt; 0) ? gap%100 : (2400 - gap)%100;
</code></pre>
",0
50258398,50258301,1,"<p>Since both conditional expressions evaluate the same condition, it would be cleaner to combine assignments in an <code>if</code> statement:</p>

<pre><code>if (gap &gt; 0) {
    hour = gap/100;
    minute = gap%100;
} else {
    hour = (2400 - gap)/100;
    minute = (2400 - gap)%100;
}
</code></pre>

<p>You could further simplify this by adding a new variable:</p>

<pre><code>int numerator = gap &gt; 0 ? gap : 2400-gap;
hour = numerator/100;
minute = numerator%100;
</code></pre>
",0
49025848,49025652,0,"<blockquote>
  <p><code>CheckDup</code> will receive the trial number and the deck of cards as input, and will return back a Boolean.</p>
</blockquote>

<p>which would translate to the following declaration </p>

<pre><code>bool CheckDup( const int trial, const struct singlecard deck[], const unsigned int deckSize );
</code></pre>

<p>And should check the <code>deck</code> if the <code>trial</code> card do not exists yet ( probably <code>true</code> if a duplicate is found ), probably by iterating through the <code>deck</code>.</p>
",0
51541537,51540869,0,"<p>There are two different tests being done here.</p>

<p>The first test is to see if the next character is specifically a newline; if it is, then we increment <code>nl</code> (which keeps track of the number of lines).</p>

<p>The second test is to see whether we're ""inside"" or ""outside"" of a word (which in this program is defined as a sequence of non-whitespace characters).  If the next character is any whitespace character (including a newline), then we're ""outside"" of a word and set <code>state</code> to <code>OUT</code>.  Otherwise, if we're in the <code>OUT</code> state, then we need to change to the <code>IN</code> state and update the number of words.  </p>

<p>It could be written a little more clearly as:</p>

<pre><code>while ((c = getchar()) != EOF) {
    ++nc;
    /**
     * Are we starting on a new line?
     */
    if (c == '\n')
       ++nl;

    /**
     * Are we inside or outside of a word?
     */
    if (c == ' ' || c == '\n' || c == '\t')
       state = OUT;
    else if (state == OUT) {
         state = IN;
         ++nw;
    }
</code></pre>

<p>That's why only one <code>else if</code> is used.  </p>
",2
50968049,50967927,1,"<p>Constant strings are not modifiable. This is a proper way to declare, initialize and modify a string buffer in C:</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
int main() {
   char a[20];
   char *b = ""World"";
   strcpy(a,""Hello"");
   strcat(a,b);
   puts(a);
   return(0);
}
</code></pre>
",0
49032100,49029479,1,"<p>The other answers address adjustments to your <code>fscanf</code> call specific to your stated need.  (Although <code>fscanf()</code> is not generally the best way to do what you are asking.)  Your question is specific about getting 2 words, <code>Penny</code> &amp; <code>Marie</code>, from a line in a file that contains: <code>name Penny Marie</code>.  And as asked in comments, what if the file contains more than 1 line that needs to be parsed, or the name strings contain a variable number of names. Generally, the following functions and techniques are more suitable and are more commonly used to read content from a file and parse its content into strings:  </p>

<p><em><a href=""https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm"" rel=""nofollow noreferrer"">fopen() and its arguments.</a></em><br>
<em><a href=""https://www.tutorialspoint.com/c_standard_library/c_function_fgets.htm"" rel=""nofollow noreferrer"">fgets()</a></em><br>
<em><a href=""https://www.tutorialspoint.com/c_standard_library/c_function_strtok.htm"" rel=""nofollow noreferrer"">strtok()</a></em> (or <a href=""https://linux.die.net/man/3/strtok_r"" rel=""nofollow noreferrer"">strtok_r()</a>)<br>
<em><a href=""https://codereview.stackexchange.com/questions/156477/c-program-to-count-number-of-lines-in-a-file"">How to determine count of lines in a file</a></em> (useful for creating an array of strings)<br>
<em><a href=""https://cboard.cprogramming.com/c-programming/143214-reading-array-strings-text-file.html"" rel=""nofollow noreferrer"">How to read lines of file into array of strings</a></em>.  </p>

<p>Deploying these techniques and functions can be adapted in many ways to parse content from files.  To illustrate, a small example using these techniques is implemented below that will handle your stated needs, including multiple lines per file and variable numbers of names in each line.  </p>

<p>Given File: <code>names.txt</code> in local directory: </p>

<blockquote>
<pre><code>name Penny Marie
name Jerry Smith
name Anthony James
name William Begoin
name Billy Jay Smith
name Jill Garner
name Cyndi Elm
name Bill Jones
name Ella Fitz Bella Jay
name Jerry
</code></pre>
</blockquote>

<p>The following reads a file to characterize its contents in terms of number of lines, and longest line, creates an array of strings then populates each string in the array with names in the file, regardless the number of parts of the name.  </p>

<pre><code>int main(void)
{
    // get count of lines in file:
    int longest=0, i;
    int count = count_of_lines("".\\names.txt"", &amp;longest);

    // create array of strings with information from above
    char names[count][longest+2]; // +2 - newline and NULL
    char temp[longest+2];
    char *tok;

    FILE *fp = fopen("".\\names.txt"", ""r"");
    if(fp)
    {
        for(i=0;i&lt;count;i++)
        {
            if(fgets(temp, longest+2, fp))// read next line
            {
                tok = strtok(temp, "" \n""); // throw away ""name"" and space 
                if(tok)
                {
                    tok = strtok(NULL, "" \n"");//capture first name of line.
                    if(tok)
                    {
                        strcpy(names[i], tok); // write first name element to string.
                        tok = strtok(NULL, "" \n"");
                        while(tok) // continue until all name elements in line are read
                        {   //concatenate remaining name elements
                            strcat(names[i], "" "");// add space between name elements
                            strcat(names[i], tok);// next name element
                            tok = strtok(NULL, "" \n"");
                        }
                    }
                }
            }

        }
    }
    return 0;
}


// returns count, and passes back longest
int count_of_lines(char *filename, int *longest)
{
    int count = 0;
    int len=0, lenKeep=0;
    int c;
    FILE *fp = fopen(filename, ""r"");
    if(fp)
    {
        c = getc(fp);
        while(c != EOF)
        {
            if(c != '\n') 
            {
                len++;  
            }
            else
            {
                lenKeep = (len &lt; lenKeep) ? lenKeep : len;
                len = 0;
                count++;
            }
            c = getc(fp);
        }
        fclose(fp);
        *longest = lenKeep;
    }
    return count;       
}
</code></pre>
",0
56351322,56347829,0,"<p>the following proposed code:</p>

<ol>
<li>cleanly compiles</li>
<li>performs the desired functionality</li>
<li>makes use of the header file: <code>ctype.h</code> function: <code>toupper()</code></li>
<li>uses the proper functions for <code>float</code> values</li>
<li>properly initializes the variable: <code>answ</code></li>
</ol>

<p>and now, the proposed code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;ctype.h&gt;

int main(void) 
{
    float user_input;
    char answ = 'Y';

    while( toupper( answ ) != 'N' ) 
    {
        printf (""Enter a number to find its lower bound, rounded, and upper bound values: "");

        if ( scanf(""%f"", &amp;user_input) == 1 ) 
        {
            float floored_input = floorf( user_input );
            float rounded_input = roundf( user_input );
            float ceiled_input  = ceilf(  user_input );

            printf( ""Lower Bound: %1.0f\n"", floored_input );
            printf( ""Rounded:     %1.0f\n"", rounded_input );
            printf( ""Upper Bound: %1.0f\n"", ceiled_input );
        } 

        do
        {
            printf( ""Do you want to try again? {Y/N}: "" );
            scanf( "" %c"", &amp;answ );
            //printf( ""debug: answ = %x\n"", answ );
        } while( toupper(answ) != 'Y' &amp;&amp; toupper( answ ) != 'N' );
    }
    return 0;
}
</code></pre>
",0
51098633,51098600,5,"<p>That sequence is:</p>

<ul>
<li>A space</li>
<li>A double backslash, which encodes a single backslash in the runtime string</li>
<li>A backslash followed by a space, which is not a standard escape sequence and should give you a diagnostic</li>
</ul>

<p>The C11 draft says (in note 77):</p>

<blockquote>
  <p>The semantics of these characters were discussed in 5.2.2. If any other 
  character follows a backslash, the result is not a token and a diagnostic is 
  required.</p>
</blockquote>

<p>On <a href=""https://godbolt.org/"" rel=""nofollow noreferrer"">godbolt.org</a> I got:</p>

<blockquote>
<pre><code>&lt;source&gt;:8:14: warning: unknown escape sequence '\ ' [-Wunknown-escape-sequence]
</code></pre>
</blockquote>

<p>So you seem to be using a non-conforming compiler, which chooses to implement undefined backslash sequences by just letting the character through.</p>
",0
51098650,51098600,1,"<p>That is printing:</p>

<pre><code>space
slash
escaped space
</code></pre>

<p>The 3rd slash is being interpreted as ""slash space"" </p>
",0
50727129,50727035,1,"<p>You only allocate one node (<code>head</code>) and then change its contents each iteration of the loop. To create a linked list, you need to allocate a new <code>node</code> for each word (each iteration of the loop). Something like this should do it:</p>

<pre><code>int main(){
    FILE *ifp;
    char newword[20];
    node * head = NULL;
    node  *last = NULL;
    node  *current;

    ifp = fopen(""para.txt"",""r"");
    if (ifp == NULL) {
        fprintf(stderr, ""Unable to open file para.txt\n"");
        return EXIT_FAILURE;
    }
    while(fscanf(ifp,""%19s"",newword) != EOF){
         current = malloc(sizeof(node));
         strcpy(current -&gt; word,newword);
         if(last) {
             last-&gt;next = current;
         }
         else {
             head = current;
         }
         last = current;
    }

    return EXIT_SUCCESS;
}
</code></pre>
",4
53839854,53839711,4,"<p>As the error messages state, there is a conflict between the declarations of the functions specified and their definitions.  Specifically:</p>

<ul>
<li><code>vector_append_float</code> has a <code>float</code> for the second parameter but the declaration shows <code>int</code>.</li>
<li><code>vector_get_float</code> returns <code>float</code> but the declaration says it returns an <code>int</code>.</li>
<li><code>vector_set_float</code> taks a <code>float</code> for its third parameter but the declaration says it should be an <code>int</code>.</li>
</ul>

<p>The declaration and definition of a function need to match.  Since the definitions seem to be using the correct type, you need to update the declarations in the header file to match.</p>
",1
50234242,50233329,1,"<p><code>scanf</code> is a poor choice for reading input from the user.</p>

<p>You probably want this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

// Get a number from the user
//    number:        pointer to the number
//    return value:  1 if the user has typed a number
//                   0 if the user ha not typed a number

int GetNumber(int *number)
{
  char inputbuffer[20];

  fgets(inputbuffer, sizeof inputbuffer, stdin);  // read raw line from user
  if (!isdigit(inputbuffer[0]))                   // if first char isn't a digit
    return 0;                                     // it's not a number, return 0

  *number = strtol(inputbuffer, NULL, 10);        // convert to number
  return 1;
}


int main()
{
  int num;

  printf(""Player 1 enter A number between 1 and 1000: "");

  while (!GetNumber(&amp;num) || num &lt; 1 || num &gt; 1000) {
    printf(""please enter different number: "");
  }

  printf(""number = %d\n"", num);

  return 0;
}
</code></pre>

<p>Alternative version of <code>GetNumber</code>:</p>

<pre><code>int GetNumber(int *number)
{
  char inputbuffer[20];

  fgets(inputbuffer, sizeof inputbuffer, stdin);

  char *endptr;
  *number = strtol(inputbuffer, &amp;endptr, 10);
  if (*endptr != '\n')  // if user input ends with somethign else than
    return 0;           // \n it's not a number (e.g: ""123a"")

  return 1;
}
</code></pre>
",4
50252414,50250450,1,"<p>There are three relatively common newline conventions: <code>\r\n</code>, <code>\n</code>, and <code>\r</code>, and a fourth one that can occur when an editor gets confused about the newline convention, <code>\n\r</code>.  If an approach supports <em>universal newlines</em>, it supports all four simultaneously, even if fixed.</p>

<p>Reading files line by line with universal newline support is easy. The only problem is that interactive input from line-buffered sources looks like it is read one line late. To avoid that, one can read lines into a dynamic buffer up to, but not including the newline; and consume the newline when reading the next line. For example:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;

ssize_t  getline_universal(char **dataptr, size_t *sizeptr, FILE *in)
{
    char   *data = NULL;
    size_t  size = 0;
    size_t  used = 0;
    int     c;

    if (!dataptr || !sizeptr || !in) {
        errno = EINVAL;
        return -1;
    }

    if (*sizeptr) {
        data = *dataptr;
        size = *sizeptr;
    } else {
        *dataptr = data;
        *sizeptr = size;
    }

    /* Ensure there are at least 2 chars available. */
    if (size &lt; 2) {
        size = 2;
        data = malloc(size);
        if (!data) {
            errno = ENOMEM;
            return -1;
        }
        *dataptr = data;
        *sizeptr = size;
    }

    /* Consume leading newline. */
    c = fgetc(in);
    if (c == '\n') {
        c = fgetc(in);
        if (c == '\r')
            c = fgetc(in);
    } else
    if (c == '\r') {
        c = fgetc(in);
        if (c == '\n')
            c = fgetc(in);
    }

    /* No more data? */
    if (c == EOF) {
        data[used] = '\0';
        errno = 0;
        return -1;
    }

    while (c != '\n' &amp;&amp; c != '\r' &amp;&amp; c != EOF) {

        if (used + 1 &gt;= size) {
            if (used &lt; 7)
                size = 8;
            else
            if (used &lt; 1048576)
                size = (3 * used) / 2;
            else
                size = (used | 1048575) + 1048577;

            data = realloc(data, size);
            if (!data) {
                errno = ENOMEM;
                return -1;
            }

            *dataptr = data;
            *sizeptr = size;
        }

        data[used++] = c;
        c = fgetc(in);
    }

    /* Terminate line. We know used &lt; size. */
    data[used] = '\0';

    /* Do not consume the newline separator. */
    if (c != EOF)
        ungetc(c, in);

    /* Done. */
    errno = 0;
    return used;
}
</code></pre>

<p>The above function works much like POSIX.1-2008 <a href=""http://man7.org/linux/man-pages/man3/getline.3.html"" rel=""nofollow noreferrer""><code>getline()</code></a>, except that it supports all four newline conventions (even mixed), and that it omits the newline from the line read. (That is, the newline is not included in either the return value or the dynamically allocated buffer. The newline is left in the stream, and consumed by the next <code>getline_universal()</code> operation.)</p>

<p>Unlike standard functions, <code>getline_universal()</code> always sets <code>errno</code>: to zero if successful, and nonzero otherwise.  If you don't like the behaviour, feel free to change that.</p>

<p>As an use case example:</p>

<pre><code>int main(void)
{
    unsigned long  linenum = 0u;
    char          *line_buf = NULL;
    size_t         line_max = 0;
    ssize_t        line_len;

    while (1) {
        line_len = getline_universal(&amp;line_buf, &amp;line_max, stdin);
        if (line_len &lt; 0)
            break;

        linenum++;

        printf(""%lu: \""%s\"" (%zd chars)\n"", linenum, line_buf, line_len);
        fflush(stdout);
    }

    if (errno) {
        fprintf(stderr, ""Error reading from standard input: %s.\n"", strerror(errno));
        return EXIT_FAILURE;
    }

    /* Not necessary before exiting, but here's how to
       safely discard the line buffer: */
    free(line_buf);
    line_buf = NULL;
    line_max = 0;
    line_len = 0;

    return EXIT_SUCCESS;
}
</code></pre>

<p>Note that because <code>free(NULL)</code> is safe, you can discard the buffer (using <code>free(line_buf); line_buf = NULL; line_max = 0;</code>) before any call to <code>getline_universal(&amp;line_buf, &amp;line_max, stream)</code>.</p>
",7
54748321,54747091,7,"<p>This is okay:</p>

<pre><code>int i;
result = someFunc(&amp;i);//it does not matter what value i is, it will 
                      //be assigned in the function.
</code></pre>

<p>where <code>someFunc()</code> is defined:</p>

<pre><code>void someFunc(int *in)
{
    *in = 10;
}
</code></pre>

<p>This is <em>not</em> okay</p>

<pre><code>int i;
int someArray[10];
int a = someArray[i];//it is not known what value 'i' is. Fault if &gt; 9. 
</code></pre>

<p>But as a matter of good programming habits <em>(maintainability, readability, proactive bug prevention)</em>, it is always a good idea to just initialize:</p>

<pre><code>int i = 0;
char *tok = NULL;
char string[] = {""string""};
float array[100] = {0};
... and so on.
</code></pre>
",0
50541269,50541235,2,"<p>No matter if <code>country</code> is an array or a pointer, doing</p>

<pre><code>scanf(""%s"", &amp;country);
</code></pre>

<p>is wrong.</p>

<p>If <code>country</code> is an array, that will give you a pointer to the array, and it will be of type <code>char (*)[SOME_SIZE]</code>. If <code>country</code> is a pointer (which it is in your function) then <code>&amp;country</code> is a pointer <em>to the pointer</em> and will have type <code>char **</code>. Neither are correct types, as the <code>""%s""</code> format expects a pointer to a <code>char</code>, of type <code>char *</code>.</p>

<p>Simple solution, and probably what will solve your crash, is to not use the address-of operator. Simply do</p>

<pre><code>scanf(""%s"", country);  // Note, no address-of operator
</code></pre>

<hr>

<p>There are a couple of other possible causes for the crash though, but it's hard to say anything more specific about them since you don't show us a <a href=""http://stackoverflow.com/help/mcve"">Minimal, Complete, and Verifiable Example</a>.</p>
",0
55172908,55172618,1,"<p>You can simply cast it: <code>(list*)l</code>.</p>

<p>But you should ask yourself whether this makes sense. By making the argument <code>const</code> you have told the compiler to stop you from changing the list. And now you want to change the list.</p>

<p>If you want to change the list, you should just remove <code>const</code>.</p>
",1
52076613,52075838,1,"<p>Because you can't predict during the loop just how many 'z'/'Z' characters your program will receive, you need to count all occurrences of 'z' or 'Z' and then test the count before outputting anything:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int c;
    unsigned long int zbrojz=0;

    while((c = getchar()) != '\n')
      if(c == 'Z' || c == 'z')
            zbrojz++;

    if(zbrojz &gt;= 2)
      printf(""Z ili z je se pojavilo: %lu puta\n"", zbrojz);

    return 0;
}
</code></pre>
",1
52076419,52075838,2,"<p>If I guessed right what the program is supposed to do (show the number of 'Z' or 'z' occuring in your input), the condition is wrong.</p>

<p>It should be:</p>

<pre><code>  while ((c = getchar()) != '\n')
  {
    if ((c == 'Z') || (c == 'z')) {   /// &lt;&lt;&lt; changes on this line
      zbrojz++;
    }
  }
</code></pre>

<p>Input:</p>

<pre><code>abcZzdeZ
</code></pre>

<p>Output:</p>

<pre><code>Z ili z je se pojavilo: 3 puta
</code></pre>
",2
52388808,52388743,2,"<p>Your function <code>int izbaciSveProste(int n, int x[], int y[])</code> requires three arguments. Your code <code>izbaciSveProste(x[i]</code> passes one argument. That's not much enough. The compiler tells you that fact with the error message:</p>

<blockquote>
  <p>error: too few arguments to function 'izbaciSveProste'</p>
</blockquote>
",1
51673078,51671823,0,"<p>Other comments and posts have already addressed the <em><a href=""https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule"">strict aliasing</a></em> problems that accompany casting one type to another, and have detailed other issues as well.  </p>

<p>It is appears from your existing code that you are attempting to reference each member of an array of <code>struct</code> using<code>pointer variables</code>.      </p>

<p>This answer is limited to an illustration of how to do what I think you are trying to do in simple terms:  (read in-line comments for explantions)</p>

<pre><code>typedef struct  { //using struct instead of Struct
  int a;
  int b; 
}FIRST;           //create typedef tag (improved readability throughout code)
typedef struct  {
  int c;
  int d;
  FIRST f_t[2]; // changed from *[] to [] 
}SECOND;        // (the rest of your post indicates that is what you meant) 

int main()
{
  SECOND *p1; //for illustration, create two pointers to reference 2 elements of arr[2]
  SECOND *p2;

  //Create array of SECOND, populate with unique values in each location
  //to provide verification during printf that assignments were made correcly.                                                                                                                                             
  SECOND arr[2] = {{1,2,{3,4,5,6}},{7,8,{9,10,11,12}}}; 
                  //note values are arranged to follow the definitions of 2 elements of SECOND arr[2]. 

  //Create 2 pointers, 1 for each element of SECOND arr[2]
  p1 = &amp;arr[0]; //assigns address of 1st element of SECOND arr[0], to pointer p1

  p2 = &amp;arr[1];//assigns address of 1st element of SECOND arr[1], to pointer p2

  printf(""Elements of p1[0]:\n%d, %d, %d, %d, %d, %d\n"", p1[0].c, p1[0].d, p1[0].f_t[0].a,p1[0].f_t[0].b,p1[0].f_t[1].a,p1[0].f_t[1].b );
  printf(""Elements of p2[0]:\n%d, %d, %d, %d, %d, %d\n"", p2[0].c, p2[0].d, p2[0].f_t[0].a,p2[0].f_t[0].b,p2[0].f_t[1].a,p2[0].f_t[1].b );
  getchar();//stop execution to view result (needed in my environment)

}
</code></pre>
",1
49867710,49867315,4,"<p>The code causes undefined behaviour in 4 different ways; it is certainly not ""correct"" or ""acceptable"" as some of the other answers seem to be suggesting.</p>

<p>Firstly, <code>*ppi = 888;</code> attempts to assign an <code>int</code> to an lvalue of type <code>int *</code> . This violates the <a href=""http://www.iso-9899.info/n1570.html#6.5.16.1"" rel=""nofollow noreferrer"">constraint 6.5.16.1/1</a> of the assignment operator which lists the types that may be assigned to each other;  integer to pointer is not in the list.</p>

<p>Being a constraint violation, the compiler must issue a diagnostic and may refuse to compile the program. If the compiler does generate a binary then that is outside the scope of the C Standard, i.e. completely undefined.</p>

<hr>

<p>Some compilers, in their default mode of operation, will issue the diagnostic and then proceed as if you had written <code>*ppi = (int *)888;</code>. This brings us to the next set of issues.</p>

<p>The behaviour of casting <code>888</code> to <code>int *</code> is <em>implementation-defined</em>. It might not be correctly aligned (causing undefined behaviour), and it might be a trap representation (also causing undefined behaviour).  Furthermore, even if those conditions pass, there is no guarantee that <code>(int *)888</code> has the same size or representation as <code>(int)888</code> as your code relies on.</p>

<p>The next major issue is that the code violates the <a href=""https://stackoverflow.com/a/7005988/1505939"">strict aliasing rule</a>. The object declared as <code>int c;</code> is written using the lvalue <code>*ppi</code> which is an lvalue of type <code>int *</code>; and <code>int *</code> is not compatible with <code>int</code>.</p>

<p>Yet another issue is that the write may write out of bounds. If <code>int</code> is 4 bytes and <code>int *</code> is 8 bytes, you tried to write 8 bytes into a 4-byte allocation.</p>

<p>Another problem from earlier in the program is that <code>ppi = (int**)(&amp;c);</code> will cause undefined behaviour if <code>c</code> is not correctly aligned for <code>int *</code>, e.g. perhaps the platform has 4-byte alignment for <code>int</code> and 8-byte alignment for pointers. </p>
",3
51957828,51954327,2,"<p>The segmentation fault tells you that you are trying to access memory outside the bounds of what you are allowed. Your array is nowhere near big enough for what your program does.</p>

<p>You need to reconsider what you are storing in array. All numbers up to a thousand that are divisible by other numbers, right? But actually it's going to be</p>

<ul>
<li>all of them <strong>and</strong></li>
<li>all the even ones <strong>and</strong></li>
<li>all of them that are divisible by 3 <strong>and</strong></li>
<li>all of them that are divisible by 4 etc.</li>
</ul>

<p>That sounds like a lot more than 100 doesn't it? There will also be many, many repeats which I doubt you intend. For example, you will store 6 three times as it is divisible by 2, 3 and itself. (So, by the way, you should stop looking once j is greater than i.)</p>

<p>Your while loop is also peculiar. It terminates when tmp2 is 1. How is tmp ever going to be equal to 1?</p>

<p>Back to the drawing board, I'm afraid!</p>
",0
50361930,50361728,1,"<p>You check the return value of the <code>scanf</code> call -- it tells you how many conversions succeeded:</p>

<pre><code>if (scanf(""%f"", &amp;i) == 1) {
    // the input is a float
} else {
    // all other cases -- print an error message
}
</code></pre>
",1
50362104,50361728,1,"<p>Read it as a string first:</p>

<pre><code>char message[100+1];
char *end = NULL;
double result = 0.0;
scanf(""%100s"", message);
</code></pre>

<p>Then try a safe conversion to double:</p>

<pre><code>result = strtod(message, &amp;end);
if ((end == message) || errno == ERANGE)) {

    // not a floating point value

}
else {
    // is a floating point value - stored in result
}
</code></pre>
",2
49907223,49907101,1,"<blockquote>
  <p>From what I know ~7 = 11111001 and 0x000f= 00001111</p>
</blockquote>

<p>That's incorrect from two points of view.</p>

<ol>
<li><p>7 is of type <code>int</code>. If you are on a platform where <code>sizeof(int)</code> is 4, <code>7</code> in binary will be <code>00000000 00000000 00000000 0000111</code>. Hence, <code>~7</code> will be <code>1111111 11111111 11111111 1111000</code>.</p></li>
<li><p>Even if you ignore the first 3 bytes, the bits of the last byte are also different.</p></li>
</ol>
",7
52542421,52542367,3,"<p><code>rainfall_condition</code> is an array of <code>char</code>, but you're putting a pointer to a string literal in there when you use <code>""*""</code>. Use <code>'*'</code> for a character literal instead. To be more specific, this line:</p>

<pre><code>        rainfall_condition[n] = ""*"";
</code></pre>

<p>Should be:</p>

<pre><code>        rainfall_condition[n] = '*';
</code></pre>

<p>Turn some warnings on in your compiler; the first line (what you have now) isn't valid C code and you should be seeing a diagnostic message to that effect.</p>

<p>Edit: now that I've read more of the code, it appears you want either a <code>*</code> or an <code>empty</code> in that column? In that case you want to change the variable declaration to:</p>

<pre><code>char *rainfall_condition[50]; // array that contains the *
</code></pre>

<p>And then change the print statement to:</p>

<pre><code>    printf(""%d \t %f \t %s \n"", n + 1, rainfall_array[n], rainfall_condition[n]);
</code></pre>
",3
51804977,51804415,3,"<p>The text representation of the value stored in <code>A</code> is <code>¡±8000¡±</code> - that¡¯s four characters <em>plus</em> the string terminator, so <code>byte_1</code> needs to be <em>at least</em> 5 characters wide.  If you want <code>byte_1</code> to store the representation of any unsigned int, you should make it more like 12 characters wide:</p>

<pre><code>char byte_1[12];
</code></pre>

<p>Two characters is not enough to store the string <code>¡±8000¡±</code>, so when<code>sprintf</code> writes to <code>byte_1</code>, those extra characters are most likely overwriting <code>A</code>.  </p>

<p>Also note that the correct conversion specifier for an unsigned int is <code>%u</code>, not <code>%i</code>.  This will matter when trying to format very large unsigned values where the most significant bit is set.  <code>%i</code> will attempt to format that as a negative signed value.  </p>

<p><strong>Edit</strong></p>

<p>As chrqlie pointed out, the OP had declared <code>A</code> as <code>short int</code> - for some reason, another answer had changed that to <code>unsigned int</code> and that stuck in my head.  Strictly speaking, the correct conversion specifier for a <code>short int</code> is <code>%hd</code> if you want signed decimal output.  </p>

<p>For the record, here's a list of some common conversion specifiers and their associated types:</p>

<pre><code>Specifier        Argument type        Output
---------        -------------        ------
      i,d                  int        Signed decimal integer
        u         unsigned int        Unsigned decimal integer
      x,X         unsigned int        Unsigned hexadecimal integer
        o         unsigned int        Unsigned octal integer
        f        float, double        Signed decimal float
        s               char *        Text string
        c                 char        Single character
        p               void *        Pointer value, implementation-defined
</code></pre>

<p>For <code>short</code> and <code>long</code> types, there are some length modifiers:</p>

<pre><code>Specifier        Argument type        Output
---------        -------------        ------
       hd                short        signed decimal integer
      hhd                 char        signed decimal integer
       ld                 long        signed decimal integer
      lld            long long        signed decimal integer
</code></pre>

<p>Those same modifiers can be applied to <code>u</code>, <code>x</code>, <code>X</code>, <code>o</code>, etc.  </p>
",2
51804481,51804415,0,"<p><code>byte_1</code> is too small for the four digits of ""A"". It only has enough room for a single digit, and the null (<code>\0</code>) terminator. If you make <code>byte_1</code> an array of 5 bytes, one for each digit and the null byte, it will be able to fit ""A"".</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {

    unsigned int A = 8000;

    char byte_1[5], total[4]; 
    sprintf(byte_1, ""%i"", A);
    printf(""%s\n"", byte_1);
    printf(""%i\n"", A);

    return 0;
}
</code></pre>

<p>Basically, messing around with memory and trying to put values into variables that are too small for them, is undefined behavior. This is legal but objectively dangerous in C, and no program should be accessing memory like this.</p>
",1
54682958,54682857,0,"<p>If you want the code to read each line, remove <code>&amp;&amp; ch != '\n'</code> from the condition of the while loop.</p>

<p>Also, the code is reading from stdin instead of a file. Use <a href=""http://www.cplusplus.com/reference/cstdio/fopen/"" rel=""nofollow noreferrer"">fopen</a> to read from a file, i.e. <code>m = inputString(fopen(""filename.txt"", ""r""), 512)</code>.</p>
",0
58467654,58467448,0,"<p>if left internal node have two specific external nodes and with in-order traversal;
you can try it like:</p>

<pre><code>&lt;code&gt;
int  node_height(node* node)
{
    int u, v;

    if (node == NULL)
        return -1;

    u = node_height(node-&gt;left);
    v = node_height(node-&gt;right);

    if (u &gt; v)
        return u + 1;
    else
        return v + 1;
}

void node_print(char* ch, int height)
{
    int i;

    for (i = 0; i &lt; height; i++)
        printf("" "");

    printf(""%c"", ch);
}

void node_show(node* node, int height)
{

    if (node == NULL) {
        node_print('*', node_height(node));

        return;
    }

    node_show(node-&gt;right, node_height(node) + 1);
    node_print(node-&gt;item, node_height(node));
    node_show(node-&gt;left, node_height(node) + 1);
}
&lt;/code&gt;
</code></pre>

<p>call the node_show(node, node_height(node)) function with given height.</p>
",0
50145334,50144768,1,"<p>After reading your question many times, I think I understand your problem and
what you want to do.</p>

<p>The problem I see with you solution is that the inner loop is not correct. You
cannot just run <code>strlen(name)</code> times, it's too inefficient as this is the upper
bound, but you only need to check for all distinct values read so far. This number is on average smaller than <code>strlen(name)</code>.
Also you should first check the read character is already in <code>chars</code> and add it to it only if it
hasn't been found. What you should do is rather something like this:</p>

<pre><code>// pseudo code
for all characters in name:
    found = False
    for all distinct cached values:
        if character is in cached value:
            found = true
            counter++
    if found == False:
        a new distinct value has been found
        add a new cache entry
</code></pre>

<p>So the code could look like this:</p>

<pre><code>Chars chars[50];

size_t len = strlen(name);
size_t dv = 0; // number of distinct values

// initializing to 0
memset(chars, 0, sizeof chars);

for(size_t i = 0; i &lt; len; ++i)
{
    int found = 0;
    for(size_t j = 0; j &lt; dv; ++j)
    {
        if(chars[j].ch == name[i])
        {
            found = 1;
            chars[j].occurs++;
            break; // break inner loop
        }
    }

    if(found == 1)
        continue;

    // checking array bounds
    if(dv == (sizeof chars / sizeof chars[0]) - 1)
    {
        fprintf(stderr, ""Too many distinct values, not enough space\n"");
        return ERROR_VALUE;
    }

    // a new distinct value has been found
    chars[dv].ch = name[i];
    chars[dv].occurs = 1;
    dv++;
}

printf(""The string '%s' has these distinct values:\n"", name);
for(size_t i = 0; i &lt; dv; ++i)
{
    printf(""%c: %d times\n"", chars[i].ch, chars[i].occurs);
}
</code></pre>

<p>But like I said, this is not very efficient, the worst case is in <code>O(n2)</code>.</p>

<p>A better approach would be to declare <code>chars</code> to be an array of dimension 256 of
<code>int</code> values, a <code>chars[i]</code> represent the <code>i</code>-th character in the <a href=""https://www.asciitable.com/"" rel=""nofollow noreferrer"">ASCII</a> code:</p>

<pre><code>int chars[256];

size_t len = strlen(name);

// initializing to 0
memset(chars, 0, sizeof chars);

for(size_t i = 0; i &lt; len; ++i)
    chars[(int) name[i]]++;

printf(""The string '%s' has these distinct values:\n"", name);
for(size_t i = 0; i &lt; 256; ++i)
{
    if(chars[i] &gt; 0)
        printf(""%c: %d times\n"", (char) i, chars[i]);
}
</code></pre>
",2
50066603,50066269,3,"<h3>When the real code is shown</h3>

<p>You have:</p>

<pre><code>FILE *p;
p=fopen(""mytext.txt"",""rt"");
countwords(p);
countchars(p);
fclose(p);
</code></pre>

<p>Since <code>countwords()</code> reads to EOF, <code>countchars()</code> immediately gets EOF.  Use:</p>

<pre><code>FILE *p;
p=fopen(""mytext.txt"",""rt"");
countwords(p);
rewind(p);
countchars(p);
fclose(p);
</code></pre>

<p>This rewinds the file stream to the start of the file after <code>countwords()</code> has reached EOF so that <code>countchars()</code> can reread the file.  Note that this works only on regular disk files; it would not work on pipes, terminals, sockets because you can't seek on those.  There are fairly simple ways to make a single pass over the data to count the characters and words without needing to reread the data.  Those are beyond the immediate scope of this question, though.</p>

<p>This also demonstrates perfectly the importance of an MCVE (<a href=""https://stackoverflow.com/help/mcve"">Minimal, Complete, Verifiable Example</a>).  It makes it trivial to solve your problem ¡ª without the MCVE, there isn't a problem to solve.</p>

<p>Note that the code about <code>getchoice()</code> and the big switch in <code>main()</code> is not material to an MCVE.  I also had to fix the code in the example to get it to compile. </p>

<p>Here's a minimized version of your code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void countwords(FILE *);
void calculatetextstatistics(void);
void countchars(FILE *);

int main(void)
{
    calculatetextstatistics();

    return 0;
}

void calculatetextstatistics(void)
{
    FILE *p = fopen(""mytext.txt"", ""rt"");
    countwords(p);
    rewind(p);
    countchars(p);
    fclose(p);
}

void countwords(FILE *p)
{
    int countw = 0;
    char wordholder[80] = "" "";
    for ( ; (fscanf(p, ""%s"", wordholder)) != EOF; countw++)
        ;
    printf(""%d\n"", countw);
}

void countchars(FILE *p)
{
    char ch;
    int countc = 0;

    for ( ; (fscanf(p, ""%c"", &amp;ch) != EOF); countc++)
        ;
    printf(""%d\n"", countc);
}
</code></pre>

<p>When I link its source to <code>mytext.txt</code>, it gives the output <code>83 695</code>, and <code>wc -wc</code> also gives the same answer.</p>

<h3>First pass</h3>

<p>Given an MCVE like this:</p>

<pre><code>#include &lt;stdio.h&gt;

static void countchars(FILE *p)
{
    char ch;
    int countc = 0;
    for ( ; (fscanf(p, ""%c"", &amp;ch) != EOF); countc++)
        ;
    printf(""%d"", countc);
    putchar('\n');
}

int main(void)
{
    countchars(stdin);
    return 0;
}
</code></pre>

<p>and compiling it to a program <code>cc17</code>, and running it on its own source:</p>

<pre><code>$ gcc -O3 -g -std=c11 -Wall -Wextra -Werror cc17.c -o cc17 
$ ./cc17 &lt; cc17.c
254
$
</code></pre>

<p>This shows that the code you show 'works' ¡ª the problem is in the code you don't show.</p>
",4
51794905,51794883,3,"<p>It tests if <code>ctr</code> is an odd number.  <code>ctr % 2</code> will evaluate to 0 (false) if <code>ctr</code> is even and 1 if it is odd.  Anything non-zero is considered true in the <code>if</code> statement.</p>
",0
51794893,51794883,-1,"<p>It effectively means <em>skip odd numbers</em>.  The condition <code>ctr % 2</code> says that the reminder by the division of <em>ctr</em> and number 2 should be different than 0, but there is only one possible value that meets such criteria and it is number 1. So the condition can be written also as <code>ctr % 2 == 1</code>.</p>
",0
51084073,51083485,0,"<p>What about something like this? Not tested, but it compiles and runs... 
BTW/ take a close look at the use of <code>1.0</code>.  If you use <code>1</code> it is interpreted as an integer and not a float and you division is always rounded to 1 or 0 and you lose all decimal values... </p>

<pre><code>float reihe(int n)
{
    float sum = 0;
    float base = 1.0;
    for (int i = 1; i &lt;= n; i++) {
        if ( i % 2 ) { 
            sum += base/i;
        }
        else {
            sum -= base/i;
        }
    }
        return sum;
}
</code></pre>
",10
50504424,50504344,1,"<p>This is the declaration of <code>strcat</code>:</p>

<pre><code>char *strcat(char *dest, const char *src);
</code></pre>

<p>The first parameter is not a const pointer, because the function is supposed to <em>modify</em> that buffer. But your function pointer accepts that first parameter as a pointer to a const buffer, which is a promise that the pointee will not be modified. Naturally, that's a semantic incompatibility. </p>

<p>Strictly speaking, the C type system doesn't allow implicitly converting <code>strcat</code> to the pointer type you specify. But compilers may accept it in the interest of backward compatibility to older C versions, and emit only a warning. Bumping the standard compliance level in your build can help turn it into an error (and as such, maybe prevent nasty bugs down the line).</p>
",0
54698873,54698851,4,"<p>You're printing a <code>char</code> with <code>%s</code>, so the program is treating your input as a pointer (to a char array). It's not a valid such thing.</p>

<p>You meant <code>%c</code> for a single character.</p>

<p>Your compiler should tell you about this. Turn warnings on!</p>
",2
50145714,50145308,6,"<p>In twos-complement signed arithmetic with wraparound, <code>(~x + 1)</code> is equal to <code>-x</code>, so <code>z + (~x + 1)</code> is equal to <code>z - x</code> is equal to <code>y</code>, no matter what the original values of <code>x</code> and <code>y</code> were.</p>

<p>There are two possible reasons why a C implementation might not use twos-complement signed arithmetic with wraparound.</p>

<ol>
<li><p>The C standard still provides, in principle, for the possibility that the CPU doesn't use a twos-complement representation of negative numbers.  This is  unlikely to be relevant nowadays: the <a href=""https://en.wikipedia.org/wiki/UNIVAC_1100/2200_series"" rel=""nofollow noreferrer"">UNIVAC</a> is the only example I know of that's still in production, and I'm actually surprised to discover that it <em>is</em> still in production.</p></li>
<li><p>The C standard says that signed overflow has <em>undefined behavior</em>.  That means the compiler is allowed to assume it never happens, and generate code that will produce arbitrarily nonsensical output (or even crash) if either addition overflows.  This <em>is</em> likely to be relevant.</p></li>
</ol>

<p>You can avoid both of these possibilities by declaring <code>x</code>, <code>y</code>, and <code>z</code> to be <code>unsigned int</code> instead of <code>int</code>.  Then <code>y + x + (~x + 1)</code> is guaranteed to equal <code>y</code>.</p>
",7
48724502,48724484,4,"<p>Your question has no much meaning in C11 (read <em>carefully</em> <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">n1570</a> for details): the type of a given variable (or value) is known at <em>compile</em> time and <em>forgotten at runtime</em>, because you <em>declare</em> that (global, static, or automatic) variable with some explicit type. Be also aware that <a href=""https://en.wikipedia.org/wiki/Calling_convention"" rel=""nofollow noreferrer"">calling conventions</a> and <a href=""https://en.wikipedia.org/wiki/Application_binary_interface"" rel=""nofollow noreferrer"">ABI</a>s define how data of different types might be handled differently (e.g. passed in various and <em>different</em> <a href=""https://en.wikipedia.org/wiki/Processor_register"" rel=""nofollow noreferrer"">processor registers</a> or on the <a href=""https://en.wikipedia.org/wiki/Call_stack"" rel=""nofollow noreferrer"">call stack</a>).</p>

<p>Likewise, a function has a fixed and well-defined signature (you should give it when <em>declaring</em> the function, e.g. in some header file).</p>

<p>If you pass the <em>address</em> of some data as a <code>void*</code> formal argument (or some data as variadic argument), you need some <em>convention</em> to get its type (often, you'll pass another formal argument describing the type; <a href=""http://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer""><code>printf</code></a> or <a href=""http://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow noreferrer""><code>scanf</code></a> is a typical example). For variadic functions, consider <a href=""http://en.cppreference.com/w/c/variadic"" rel=""nofollow noreferrer""><code>stdarg.h</code></a>  facilities.</p>

<p>Maybe you want to consider <a href=""http://en.cppreference.com/w/c/language/generic"" rel=""nofollow noreferrer"">generic selection</a> with <code>_Generic</code> used in a macro. This is a feature that I very rarely use.</p>

<p>Maybe you want to customize your <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a> compiler thru some <a href=""https://gcc.gnu.org/onlinedocs/gccint/Plugins.html"" rel=""nofollow noreferrer"">GCC plugin</a>. That could take months of work (and is dependent of your particular version of GCC).</p>

<p>Maybe you want some <a href=""https://en.wikipedia.org/wiki/Tagged_union"" rel=""nofollow noreferrer"">tagged union</a> or sum type. You'll typically implement that <a href=""https://en.wikipedia.org/wiki/Abstract_data_type"" rel=""nofollow noreferrer"">abstract data type</a> with a <code>struct</code> containing an enumerator (choosing the type) and a <code>union</code>. For inspiration look into <a href=""https://developer.gnome.org/glib/stable/glib-GVariant.html"" rel=""nofollow noreferrer"">Glib's GVariant</a>, and, since Glib is <a href=""https://en.wikipedia.org/wiki/Free_software"" rel=""nofollow noreferrer"">free software</a>, study its source code.</p>

<p>Perhaps you might want to look into <a href=""https://sourceware.org/libffi/"" rel=""nofollow noreferrer"">libffi</a>.</p>

<p>If you (specifically) use <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a>, consider some of its <a href=""https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions"" rel=""nofollow noreferrer"">C language extensions</a> (outside of the C11 standard). You might want <a href=""https://gcc.gnu.org/onlinedocs/gcc/Typeof.html"" rel=""nofollow noreferrer""><code>typeof</code></a> or some <a href=""https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html"" rel=""nofollow noreferrer"">builtins</a> like <code>__builtin_types_compatible_p</code>.</p>

<p>At last, you might <em>generate</em> some C file, perhaps using your script, another preprocessor like GPP or m4, etc...</p>

<p>You should describe your actual problem in details. In its initial form, your question is typically some <a href=""http://xyproblem.info/"" rel=""nofollow noreferrer"">XY problem</a>.</p>
",1
50542292,50540104,0,"<p>I copied-pasted your program in the online <a href=""https://www.onlinegdb.com/"" rel=""nofollow noreferrer"">https://www.onlinegdb.com/</a>
and run it with no problem. I gave small input numbers like 5 and 12, and it calculated the factorial. So the compilation happened with no issue, and then it moved on to the execution phase.  I also put the -Wall as Command line arguments , and again it compiled and run. The only improvement to your program could be to output a line of instructions, 
""Enter an integer >1 :"" 
and also when you read input by user , first check that it is >1 and then call the function, else terminate execution without calling the function. </p>
",1
50088807,50087865,0,"<blockquote>
  <p>prototype.c: 218: 15: note: previous implicit declaration of 'esObjeto' was here</p>

<pre><code>  verdad = esObjeto (place, hero);
</code></pre>
</blockquote>

<p>According to older C language (not C++) you can call a function without first providing a prototype for the function. The compiler can see the parameter types and assumes that the return value is an <code>int</code>. This is called ""an implicit declaration"". </p>

<p>Kind of works, if the ""guess"" is correct.</p>

<p>However, later in the file it sees </p>

<pre><code>bool esObjeto(int ubicacionMatriz, int * personaje)
</code></pre>

<p>and notices that its previous assumption was not correct. The function actually returns a <code>bool</code> and not an <code>int</code>. So now it has compiled the call in the previous function incorrectly.</p>

<p>Oops!!</p>

<hr>

<p>A solution to this is to move the function declaration to before it is used. Or at least provide a prototype at the beginning of the file, so the compiler can know about the return type.</p>
",0
50546916,50546878,1,"<p>This relies on recursion (in function <code>f1</code>) and dynamic array lookups (in function <code>foo</code>) instead of using either loops or conditionals.</p>

<pre><code>void f2(int x)  //why we have used this fumction
{}
</code></pre>

<p>The <code>f2</code> function does nothing and is called when <code>x &gt;= 100</code>, thus terminating the sequence when the maximum value is reached.</p>

<pre><code>void (*tab[])(int) = { f1, f2 }; // what is this
</code></pre>

<p>That is an array initialization. <code>tab</code> is an array of pointers to functions taking an <code>int</code> parameter. The two elements of the array are pointers to functions <code>f1</code> and <code>f2</code>.</p>

<pre><code>tab[!(x &lt; 100)](x); // what is this
</code></pre>

<p>This does the same thing a conditional would in this scenario. This calls either the first or second function in <code>tab</code>, depending on whether <code>x &lt; 100</code> or not.</p>

<p>When <code>x &lt; 100</code>, the array subscript <code>!(x &lt; 100)</code> equals <code>!true</code>, or <code>0</code> when converted to an <code>int</code>. <code>tab[0]</code> is the first element of the array, the function <code>f1</code>. The <code>f1</code> function prints and increments the number, then recurses by calling <code>foo</code> again, thus continuing the sequence.</p>

<p>When <code>x &gt;= 100</code>, <code>tab[1]</code> is called, which is the second element of the array, <code>f2</code>. Since <code>f2</code> does nothing, the sequence ends when <code>x &gt;= 100</code>.</p>
",4
50546915,50546878,4,"<p><code>tab</code> is an array of two function pointers.</p>

<p>Since you're not allowed to use <code>if</code>, instead you use an array of functions, and index them using the result of the <code>!(x &lt; 100)</code> comparison. When that's true it evaluates to <code>1</code>, so you call the function in <code>tab[1]</code>, which is <code>f2()</code>. When it's false it evaluates to <code>0</code>, so you call <code>tab[0]</code>, which is <code>f1</code>. So it effectively the same as:</p>

<pre><code>if (x &lt; 100) {
    f1(x);
} else {
    f2(x);
}
</code></pre>

<p><code>f1(x)</code> prints <code>x+1</code> and then calls <code>foo(x+1)</code> recursively. <code>f2(x)</code> doesn't do anything, so the recursion ends when you get to this.</p>
",2
51671053,51669142,0,"<p>If you do not set the length to 200 then the compiler will set it to the initialized values.</p>

<pre><code>  u_int16_t test[] = {1,4,6};
  int len = sizeof (test) / sizeof (u_int16_t);   // n = 3
</code></pre>

<p>If you need to set the length of test AND you know your last element is not 0 (!), then you can count the 0s at the end and substract it from 200. Then you know the number of elements too.</p>
",2
52580948,52580932,3,"<p>It's a matter of <a href=""https://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer""><em>operator precedence</em></a>. The expression <code>*test[0]</code> is equal to <code>*(test[0])</code>, not <code>(*test)[0]</code> as you seem to expect.</p>
",0
52580972,52580932,1,"<p>The array index operator has higher precedence than the dereference operator.  You need to add parenthesis:</p>

<pre><code>(*test)[0] = malloc(3); 
(*test)[1] = malloc(3); 
strcpy((*test)[0], ""12""); 
strcpy((*test)[1], ""13""); 
</code></pre>
",0
59083664,59083576,2,"<p>It seems you only store the <em>pointer</em> to the key in the map.</p>

<p>You need to store a <em>copy</em> of the key instead, but only use it in case of hash-collisions. One way to store a copy of the key is to use the non-standard but commonly available <code>strdup</code> function.</p>

<hr>

<p>Using pointer to the key in the map brings other problems besides the one you see. Especially considering that in the code you show you use a <em>local</em> array for the key, which means the pointer will become invalid once the function <code>new</code> returns and <code>newer</code> ends its life.</p>

<p>Also in the code you show you print the contents of <code>newer</code> before it's initialized, and its contents is <em>indeterminate</em>.</p>

<p>This uninitialized contents of <code>newer</code> is also problematic for the <code>strncat</code> call, as it will search for the terminator to know where to append the string. And that could theoretically lead to the function going out of bounds of the array in that search. If you just want to copy a string into <code>newer</code> use <code>strcpy</code> instead.</p>

<p>You also use close to 4 MiB for the array, and considering that the compiler will put it on a very limited stack you waste a lot of space (not to mention that your program won't run on Windows where the default stack is only a single MiB).</p>
",5
49164245,49164198,5,"<p>There is no difference except in how they're used. When you tell your compiler that a variable is <code>signed</code> or <code>unsigned</code>, it knows to use signed or unsigned instructions when performing mathematical operations on it. When you use <code>printf</code>, you explicitly provide format codes that tell the function whether the argument is signed or unsigned (e.g. <code>%u</code> vs. <code>%d</code>). By the time the program is running, yep, just looking at the registers and memory, you can't tell the difference between <code>-1</code> (as a <code>signed char</code>) and <code>255</code> (as an <code>unsigned char</code>) on systems with <code>CHAR_BIT == 8</code> and two's complement math, but the program has baked that knowledge into how it <em>works</em> with the otherwise indistinguishable values.</p>

<p>It's the same way that a pointer width <code>0</code> and <code>NULL</code> behave (or any other equivalent number and pointer pattern); they're both just a bunch of zero bits, but numeric zero is manipulated and used as a number, while <code>NULL</code> is manipulated as a pointer. The bits are the same, the way the compiler and APIs use them is different.</p>
",8
51999084,51999038,9,"<p>Compilation of a C source file is done <a href=""https://en.cppreference.com/w/c/language/translation_phases"" rel=""nofollow noreferrer"">in multiple phases</a>. The phase where the preprocessor runs is done before the phase where the code is compiled.</p>

<p>The ""compiler"" will not even see code that the preprocessor has removed; from its point of view, the function is simply</p>

<pre><code>void fun(void)
{
}
</code></pre>

<p>Now if the function will ""create memory"" depends on the compiler and its optimization. For a debug build the function will probably still exist and be called. For an optimized release build the compiler might not call or even keep (generate boilerplate code for) the function.</p>
",1
52022262,52022236,3,"<p>When you create an array, the compiler will reserve memory for it, and you can store values in that memory.</p>

<p>What is returned by e.g. <code>&amp;data[2]</code> is not a pointer to the integer <code>3</code> but a pointer to the array element where you have opted to store the integer value <code>3</code>.</p>

<p>An array like yours look like this in memory</p>

<pre>
+---------+---------+---------+---------+---------+
| data[0] | data[1] | data[2] | data[3] | data[4] |
+---------+---------+---------+---------+---------+
</pre>

<p>The exact values stored in each element is kind of irrelevant if all you want is a pointer to an element.</p>
",0
51332571,51332492,1,"<p>The issue is the declaration of <code>ptr</code> in your first line. You seem to want it to be</p>

<pre><code>int *ptr; /* NOT void* */
</code></pre>

<p>Otherwise you will have to cast it every time. C/C++ use compile time declarations and the cast on the <code>malloc</code> has no effect after the line on which it appears. In particular</p>

<pre><code>ptr = (int*)malloc(sizeof(int)); /* the (int*) HAS NO EFFECT when ptr is declared void* */
</code></pre>
",0
58694226,58694144,0,"<p>This is the prototype of a <em><a href=""https://www.geeksforgeeks.org/function-pointer-in-c/"" rel=""nofollow noreferrer"">function pointer</a></em> to a <em><a href=""https://stackoverflow.com/questions/824234/what-is-a-callback-function"">callback function</a></em>.</p>

<p>Because it is used as an argument in another function, it implies that that actual function needs to be declared and defined somewhere in your code before it is used in the function as an argument.  I.e. something like this:</p>

<pre><code>//declaration - possibly defined in a header file, or at top of .c file where it is used
int __cdecl handlerFunction(void*,int,char**,char**); 

//definition 
int __cdecl handlerFunction(void *db,int element,char **data1,char **data2)
{
    //code to handle some event that invokes this callback
    return 0
}
</code></pre>
",0
49836278,49836228,0,"<p>C has no choseable default values for <code>struct</code> members, this syntax is just wrong. The only defaults are <code>0</code> initialization that is used when a specific field of a <code>struct</code> is missed in an initializer.</p>

<p>Since you are even using <code>malloc</code>, the storage that is allocated isn't initialized at all.</p>
",0
53049001,53046814,1,"<p>The message ¡°deprecated conversion from string constant to 'char*' [-Wwrite-strings]¡± arises because the code was compiled as C++ code, which has different rules about string literals and pointer conversions from C.</p>

<p>This can be fixed by compiling the code as C code or worked around by inserting an explicit cast to <code>char *</code>.</p>
",0
58847162,58845767,1,"<p>Your <code>z = z - 1</code> determines the value at run-time arithmetically.  It can be determined as a compile time constant without implicit or explicit casts:</p>

<pre><code>unsigned int z = ~0u ;
</code></pre>

<p>That will be what your tutor is looking for if he has any credibility.</p>

<p>Otherwise if you really <em>must</em> provide an ""algorithim"" to get a grade in a clearly flawed assignment, then;</p>

<pre><code>unsigned z = 1 ;
for( unsigned b = 1; 
     b != 0; 
     z = (z &lt;&lt; 1) | 1, b &lt;&lt;= 1 ) ; 

printf( ""z = %u\n"", z ) ;
</code></pre>

<p>That is a somewhat terse way of writing:</p>

<pre><code>unsigned z = 1 ;       // Initial set LSB of max-int to 1
for( unsigned b = 1;   // ""Walk"" a 1 through each bit of an unsigned
     b != 0;           // until the 1 falls of the end
     b &lt;&lt;= 1 )         // move the 1 right
{
     z = (z &lt;&lt; 1) | 1 ; // shift max-int right and set LSB to 1
} 
</code></pre>

<p>Another alternative:</p>

<pre><code>unsigned z = 1 ;
unsigned p = 0 ;
while( z != p )
{
    z = (z &lt;&lt; 1) | 1 ;
    p = (p &lt;&lt; 1) | 1 ;
}
</code></pre>

<p>In this solution <code>p</code> has one fewer bits than <code>z</code> until both are ""all ones"" when they are equal.</p>

<p>The only possible advantage of these loop methods is that by adding a counter you can simultaneously determine the maximum value and the bit width:</p>

<pre><code>unsigned z = 1 ;
unsigned bits = 0 ;
for( unsigned b = 1; 
     b != 0; 
     z = (z &lt;&lt; 1) | 1, b &lt;&lt;= 1, bits++ ) ; 

printf( ""z = %u %u-bits\n"", z, bits ) ;
</code></pre>
",3
58845792,58845767,0,"<p><code>(unsigned int)(-1)</code> or <code>static_cast&lt;unsigned int&gt;(-1)</code> are guaranteed to give the maximum value representable by <code>unsigned int</code>. These are compile-time constants.</p>
",1
58845975,58845767,3,"<p>The simplest way to do this is to simply assign -1 to an <code>unsigned int</code>.  You could also assign <code>~0u</code> to it.</p>

<p>If that's not acceptable, while inefficient, you could do something like this:</p>

<pre><code>unsigned int i = 0;
while (i+1 &gt; 0) 
  i++;
printf(""i=%u\n"", i);
</code></pre>
",17
50840987,50840783,1,"<p>Use bit ops:</p>

<pre><code>#include &lt;stdio.h&gt;
typedef unsigned char uchar;
int main()
{
    uchar m=0xf1;
    uchar l=0x5e;
    unsigned ml=((unsigned)m)&lt;&lt;8|(unsigned)l; 
    //doing it in unsigned (at least 16 bits guaranteed, no sign bit)
    printf(""%06x\n"", ml); //prints 00f15e
}
</code></pre>
",5
48956538,48956506,1,"<p>You simply need to break out of the loop:</p>

<pre><code>if (temp == -99)
  break;
</code></pre>

<p>But there are several other issues with your code, such as the averaging calculation will be wrong if you exit early. Here is a corrected version that also makes use of the other loop control word <code>continue</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    char *buffer;
    size_t buffer_len;
    int hot=0, pleasant=0, cold=0;
    int sum=0, i=0, temp;
    double average;

    while(1)
    {
        printf(""Enter temperature %d&gt; (-99 to stop)"",i);

        buffer = NULL;
        getline(&amp;buffer, &amp;buffer_len, stdin);
        if (buffer_len == 0 || sscanf(buffer, ""%d\n"",&amp;temp) != 1)
        {
            if (buffer)
              free(buffer);
            printf(""Invalid\n"");
            continue;
        }

        free(buffer);

        if(temp == -99)
          break;

        sum +=temp;
        ++i;

        if(temp &gt;= 85)
        {
            ++hot;
            continue;
        }

        if(temp &gt;= 60)
        {
            ++pleasant;
            continue;
        }

        ++cold;
    }

    if (i == 0)
    {
      printf(""No temperatures entered\n"");
      return -1;
    }

    average = (double)sum / i;

    printf(""The Collection of hot days is %d\n"",hot);
    printf(""The Collection of pleasant days is %d\n"",pleasant);
    printf(""The Collection of cold days is %d\n"",cold);
    printf(""The Average temperature is %.2f\n"",average);
    return 0;
}
</code></pre>
",12
48956689,48956643,5,"<p>The <code>'\a'</code> in an escaped representation of the <a href=""https://en.wikipedia.org/wiki/Bell_character"" rel=""noreferrer""><code>BEL</code></a> charcater which has <a href=""http://www.asciitable.com/"" rel=""noreferrer"">ascii</a> code 7.</p>

<p>The <code>\</code> is used to ""escape"" a character that otherwise has no representation and cannot be written in a string by other means. Another examples are the newline <code>'\n'</code> and carriage return <code>'\r'</code>.</p>
",0
53581075,53580797,1,"<pre><code>#include &lt;stdio.h&gt; 

int compareFilles(FILE *fp1, FILE *fp2){
</code></pre>

<p>This function should return a <code>bool</code> since that is the natural data type for expressing a <code>true/false</code> value.</p>

<pre><code>  int word1 = getc(fp1); 
  int word2 = getc(fp2);
</code></pre>

<p>The variable names are wrong. The <code>getc</code> function does not read a word, it only reads a single byte from a file.</p>

<pre><code>  //A loop until the end of the files(EOF)
  while (word1 =! EOF &amp;&amp; word2 != EOF &amp;&amp; word1 == word2){
</code></pre>

<p>As said in one of the comments, the <code>=!</code> means ""assign negative"" instead of the ""unequal"" you meant. To avoid this kind of mistakes in the future, always let an automatic code formatter format your code before it is saved to disk. Then that code would have been shown as <code>word1 = !EOF</code>, which should draw enough attention. Doing this will also protect you from the famous <a href=""https://www.imperialviolet.org/2014/02/22/applebug.html"" rel=""nofollow noreferrer"">goto fail</a> bug, which means you will have a better programming standard than Apple. That sounds like a lot, doesn't it?</p>

<p>Plus, always enable all compiler warnings. The compiler would have warned you about an ""assignment in a condition, which is often not intended"", which is exactly the case here.</p>

<pre><code>    word1 = getc(fp1); 
    word2 = getc(fp2);
  }

  if (word1 != word2){
     return 1;
   }else{
        return 2;
    }
}
</code></pre>

<p>If your function returns <code>bool</code>, that last <code>if</code> statement should simply be replaced with <code>return word1 == word2</code>.</p>

<pre><code>int main(int argc, char* argv[]){
  FILE *fp1 = fopen(argv[0], ""r"");
  FILE *fp2 = fopen(argv[1], ""r"");
</code></pre>

<p>The error checking is missing here. If either of <code>fp1</code> or <code>fp2</code> is NULL, the program must handle this error.</p>

<pre><code>  printf(""%d"", compareFilles(fp1, fp2));

  //closing the files
  fclose(fp1); 
  fclose(fp2);

  return 0;
}
</code></pre>
",1
53580960,53580797,1,"<p>Generally, <code>argv[0]</code> contains the command used to start the program, usually the name of the executable file or part of it. Thus, your program is comparing its own executable file to the file named by the first argument (<code>argv[1]</code>), and they are different.</p>
",1
48973664,48971063,-1,"<p>There is no obvious problem in the code itself. If it works for smaller N's stack overflow can be suspected for N=64.</p>

<p>Using recursion for matrix multiplication is well know approach:</p>

<p><a href=""http://web.eecs.utk.edu/~leparker/Courses/CS581-spring14/Lectures/3-Jan-16-Master-Mthd-Matrix-Mult-no-answers.pdf"" rel=""nofollow noreferrer"">Matrix Multiplication</a></p>

<p><a href=""https://shivathudi.github.io/jekyll/update/2017/06/15/matr-mult.html"" rel=""nofollow noreferrer"">Matrix multiplication using the Divide and Conquer paradigm</a></p>

<p>For practical C solution check:</p>

<p><a href=""https://stackoverflow.com/questions/34994405/matrix-multiplication-using-divide-and-conquer-approach"">Matrix Multiplication using divide and conquer approach</a></p>

<p><a href=""https://github.com/sangeeths/stanford-algos-1/blob/master/strassen-recursive-matrix-multiplication.c"" rel=""nofollow noreferrer"">Strassen-recursive-matrix-multiplication.c</a></p>

<p>BTW: Your code is very similar to posted here: <a href=""http://www.sanfoundry.com/c-program-matrix-multiplication-using-recursion/"" rel=""nofollow noreferrer"">C Program to Perform Matrix Multiplication using Recursion</a>. </p>
",0
54454019,54454004,4,"<p>Conditions are wrong. For example:
Instead of <code>if (a &gt; (b || c ))</code> you need <code>if((a &gt; b) || (a &gt; c))</code>. (Paranthesis are optional)</p>

<p>Note: You actually mean <code>&amp;&amp;</code> and not <code>||</code></p>

<hr>

<p>So what does <code>a &gt; (b || c )</code></p>

<p><code>(b || c)</code> would evaluate to <code>0</code> if both <code>b</code> and <code>c</code> are <code>0</code>. Otherwise it evaluates to <code>1</code>.</p>

<p>If <code>a</code> is greater than the above result, control would enter the condition.</p>
",1
50557337,50556735,1,"<p>Working with strings correctly in C usually involves dynamic allocation and careful thought about when and what to allocate and free. This is tricky to get right, and you really want to make the strings as few as possible.</p>

<p>If you don't want to handle unusually long input lines (seems your case), you can make do with only one string buffer, which only holds the string temporarily, until the following string replaces it:</p>

<pre><code>char strArr[1000];
</code></pre>

<p>Use <code>fgets</code> to fill it. Then use <code>sscanf</code> to get numbers from it:</p>

<pre><code>sscanf(strArr, ""%f %f %f"", &amp;varArr[j], &amp;varArr[j+1], &amp;varArr[j+2]);
</code></pre>

<p>Note: there is no need to extract 3 strings from one string, and convert each string individually to <code>float</code>. Extracting the 3 floats immediately, like in the code above, eliminates the extra strings and their memory management.</p>
",0
55009209,55009170,0,"<p>You didn't allocate the space for <code>""words""</code> (you only allocated the pointer to it), so (apparently) it has been placed some where you are not allowed to modify.</p>
",2
52562374,52561448,2,"<pre><code>while (i != strlen(t)){
    if (t[i] == c) return i;
}
</code></pre>

<p>¡®i¡¯ is not incrementing in the loop. You are indefinitely checking the first element</p>
",0
49541974,49541702,2,"<p>The problem is here:</p>

<pre><code>vx[i+1]= vx[i]+((1/6)*(k1+2*k2+2*k3+k4)*delt);
vy[i+1]= vy[i]+((1/6)*(m1+2*m2+2*m3+m4)*delt);
</code></pre>

<p><code>1/6</code> - both numbers are integers so this will result in <code>0</code> making your statements:</p>

<pre><code>vx[i+1]= vx[i];
vy[i+1]= vy[i];
</code></pre>

<p>Make them floating point. And since you calculate often, make it a constant.</p>

<pre><code>const double one_sixth = 1.0 / 6.0;
</code></pre>

<p>Then</p>

<pre><code>vx[i+1]= vx[i]+(one_sixth * (k1+2*k2+2*k3+k4)*delt);
vy[i+1]= vy[i]+(one_sixth * (m1+2*m2+2*m3+m4)*delt);
</code></pre>
",0
50923390,50923284,3,"<p>You want this:</p>

<pre><code>printf(""Enter a first name and a last name:"");
scanf(""%s %s"", fn, ln);        // you are reading two strings,
                               // not one char and one string
printf(""%s, %c."", ln, fn[0]);  // you print one string and one char
                               // not two chars
</code></pre>

<p>Disclaimer: this is oversimplified code that does not do any error checking for brevity.</p>
",4
58514762,58514208,2,"<p>If <code>arr</code> is really a <code>char**</code>, then you need to dereference twice to get a <code>char</code>.</p>

<p>So, in your statement, <code>arr+i</code> is another <code>char**</code>, pointing at a <code>char*</code> <code>i</code> steps further along from the one <code>arr</code> points at. Hopefully <code>arr</code> points at the beginning of an array of <code>char*</code> at least <code>size</code> long.</p>

<p>Now <code>*(arr+i)</code> dereferences it, fetching the <code>char*</code> pointed to by <code>arr+i</code>, giving you a <code>char*</code>.</p>

<p>Now <code>*(arr+i)+7</code>, for example, is another <code>char*</code>, pointing at a <code>char</code> 7 steps further along from the one <code>*(arr+i)</code> points at. Hopefully <code>*(arr+i)</code> points at the beginning of an array of <code>char</code> at least 15 long.</p>

<p>But you don't dereference it, so you're attempting to print the value of the pointer (i.e. the address it holds), not the value it points to (the <code>char</code>).</p>

<p>Try <code>*(*(arr+i)+7)</code>.</p>
",1
56143383,56143267,3,"<p><code>-&gt;</code> has higher precedence than <code>*</code>.</p>

<p><code>*headref-&gt;next</code> means <code>*(headref-&gt;next)</code>, while <code>pop1-&gt;next</code> is equivalent to <code>(*headref)-&gt;next</code>.</p>

<p>In other words, you don't need <code>pop1</code> if you add a pair of parentheses.</p>
",0
49578904,49578579,0,"<p>The <code>%d</code> format specifier to <code>scanf</code> looks for an integer.  Since a <code>+</code> or <code>-</code> preceding some digits is a valid representation of a number, they are read as part of that number.</p>

<p>So when you input <code>1+2</code>, the <code>1</code> gets picked up on the first loop iteration, then <code>+2</code> gets picked up on the second iteration.  When you then print with <code>%d</code>, the leading <code>+</code> is not printed by default.</p>

<p>If you were to input <code>1-2</code>, you would get the same as output.  However instead of reading <code>1</code>, then <code>-</code>, then <code>2</code>, it reads <code>1</code> then <code>-2</code>.  The <code>-</code> still gets printed because it is relevant.</p>
",1
48996559,48996440,0,"<p>There are a few problems. Learn how to pass variables by pointers. If you do so, you can modify the values inside your functions.</p>

<pre><code> int paper(int comp, int Tie, int Cwon, int Pwon) {
</code></pre>

<p>replace with: </p>

<pre><code>int paper(int comp, int *Tie, int *Cwon, int *Pwon) {
//...
 (*Cwon)++;
//...
}
</code></pre>

<p>You cannot return multiply values like this:</p>

<pre><code> return Tie, Cwon, Pwon;
</code></pre>

<p>As I mention, use pointers and modify the values after pointer is dereferenced by <code>*</code> operator.</p>

<p>This is small example for your consideration. Notice that <code>num</code> does not change outside the function scissors.</p>

<pre><code>#include&lt;stdio.h&gt;

void scissors(int num, int *Tie, int *Cwon, int *Pwon) {

     num++;

     (*Tie)++;
     (*Cwon)++;
     (*Pwon)++;
}

int main() {
    int num = 0;
    int Tie = 1;
    int Cwon= 2;
    int Pwon= 3;

    scissors(num, &amp;Tie, &amp;Cwon, &amp;Pwon);
    printf(""num= %d Tie= %d Cwon= %d  Pwon= %d \n"", num, Tie, Cwon, Pwon );

    scissors(num, &amp;Tie, &amp;Cwon, &amp;Pwon);
    printf(""num= %d Tie= %d Cwon= %d  Pwon= %d \n"", num, Tie, Cwon, Pwon );

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>num= 0 Tie= 2 Cwon= 3  Pwon= 4 
num= 0 Tie= 3 Cwon= 4  Pwon= 5 
</code></pre>
",1
50379129,50378346,2,"<p>Normally, if you have</p>

<pre><code>d = opendir(dirname);
while((dir = readdir(d)) != NULL) {
    some_operation(dir-&gt;d_name);
}
</code></pre>

<p><code>some_operation</code> will fail for <em>every</em> <code>d_name</code>, because the path you should have passed to <code>some_operation</code> is <code>${dirname}/${dir-&gt;d_name}</code>, not just <code>dir-&gt;d_name</code>.</p>

<p>Your program, though, is hardwired to pass the special directory <code>.</code> to <code>opendir</code>; when you do that, it <em>is</em> safe to pass just <code>dir-&gt;d_name</code> to <code>some_operation</code>, since <code>.</code> is always the current working directory.  Your problem is instead that <code>readlink</code> <em>does not</em> fail when applied to a broken symlink, but <em>does</em> fail when applied to a directory entry that isn't a symlink.  It would have been easier to figure this out for yourself if you had included <code>dir-&gt;d_name</code> and <code>strerror(errno)</code> in your error message, like this:</p>

<pre><code>d = opendir(""."");
while ((dir = readdir(d)) != 0) {
   char buff[256];
   if (readlink(dir-&gt;d_name, buff, sizeof buff) {
       printf(""%s: readlink failed: %s\n"", dir-&gt;d_name, strerror(errno));
   } else {
       printf(""%s -&gt; %s\n"", dir-&gt;d_name, buff);
   }
}
</code></pre>

<p>If you had done that, you would have gotten output like this:</p>

<pre><code>.gnome2: readlink failed: Invalid argument
.python_history: readlink failed: Invalid argument
test.s: readlink failed: Invalid argument
bin -&gt; .local/bin
[etc]
</code></pre>

<p>and then it would probably have occurred to you to look at the <code>readlink</code> manpage and discover that it returns <code>EINVAL</code> when applied to something that isn't a symlink.</p>

<p>The proper way to detect a broken symlink is by observing that <code>lstat</code> succeeds but <code>stat</code> fails with <code>ENOENT</code>:</p>

<pre><code>struct stat lst, st;
if (lstat(dir-&gt;d_name, &amp;lst)) {
  /* some other kind of problem */
} else if (!S_ISLNK(lst.st_mode)) {
  /* not a symlink at all */
} else if (stat(dir-&gt;d_name, &amp;st)) {
  if (errno == ENOENT) {
    /* broken symlink */
  } else {
    /* some other kind of problem */
  }
} else {
  /* valid symlink, `lst` tells you about the link,
     `st` tells you about what it points to */
}
</code></pre>

<p>If you don't need any of the other information from <code>lst</code>, and your filesystem supports <code>d_type</code>, you can skip the <code>lstat</code> call:</p>

<pre><code>if (dir-&gt;d_type == DT_LNK) {
   struct stat st;
   if (stat(dir-&gt;d_name, &amp;st)) {
     if (errno == ENOENT) {
       /* broken symlink */
     }
   }
 }
</code></pre>

<p>But don't neglect to do the entire dance with both <code>lstat</code> and <code>stat</code> in the <code>DT_UNKNOWN</code> case, or you'll be sad when you try to run your program on a filesystem that doesn't report d_type information.</p>
",0
50378506,50378346,4,"<p>Your question should have some <a href=""https://stackoverflow.com/help/mcve"">MCVE</a>. See also <a href=""http://man7.org/linux/man-pages/man7/inode.7.html"" rel=""nofollow noreferrer"">inode(7)</a> &amp; <a href=""http://man7.org/linux/man-pages/man7/symlink.7.html"" rel=""nofollow noreferrer"">symlink(7)</a>. Read <a href=""http://www.cse.hcmut.edu.vn/~hungnq/courses/nap/alp.pdf"" rel=""nofollow noreferrer""><em>Advanced Linux Programming</em></a> or something newer.</p>

<p>Consider using <a href=""http://man7.org/linux/man-pages/man3/nftw.3.html"" rel=""nofollow noreferrer"">nftw(3)</a> or <a href=""http://man7.org/linux/man-pages/man3/fts.3.html"" rel=""nofollow noreferrer"">fts(3)</a> (if you need to scan the subdirectories recursively) or at least do a <a href=""http://man7.org/linux/man-pages/man2/stat.2.html"" rel=""nofollow noreferrer"">stat(2)</a> with the file path (since you are scanning the current directory, you don't need to construct that file path).  Remember to skip the entries for <code>.</code> and <code>..</code>; so try perhaps</p>

<pre><code> d = opendir(""."");
 while((dir = readdir(d)) != NULL) {
   struct stat mystat;
   if (!strcmp(dir-&gt;d_name, ""."") || !strcmp(dir-&gt;d_name, "".."")) continue;
   memset (&amp;mystat, 0, sizeof(mystat));
   if (stat(dir-&gt;d_name, &amp;mystat) ||  S_ISLNK(mystat.st_mode))
     continue;
   /// etc...
 } 
</code></pre>

<p>There are many cases that you might want to handle. See also <a href=""http://man7.org/linux/man-pages/man3/errno.3.html"" rel=""nofollow noreferrer"">errno(3)</a>. What about a symlink to self? What about <a href=""http://man7.org/linux/man-pages/man7/unix.7.html"" rel=""nofollow noreferrer"">unix(7)</a> sockets? <a href=""http://man7.org/linux/man-pages/man7/fifo.7.html"" rel=""nofollow noreferrer"">fifo(7)</a>-s? permissions?</p>

<p>(We don't have time and space to explain all the details; you do need to read a lot)</p>
",2
53307397,53307241,3,"<blockquote>
  <p>So the compiler affirms that the size of the array is still 9. How is it able to store the word 'evenlongername' which has a size of 15 bytes(including the string terminator)?</p>
</blockquote>

<p>You are using a dangerous function (see <a href=""https://linux.die.net/man/3/strncpy"" rel=""nofollow noreferrer"">Bugs</a>), <code>strcpy</code>, which blindly copies source string to destination buffer without knowing about its size; in your case of copying 15 bytes into a buffer with size 9 bytes, essentially you have overflown.  Your program <em>may</em> work fine if the memory access is valid and it doesn't overwrite something important.</p>

<p>Because C is a lower-level programming language, a C <code>char[]</code> is ""barebone"" mapping of memory, and not a ""smart"" container like C++ <code>std::vector</code> which automatically manages its size for you as you dynamically add and remove elements. If you are still not clear about the philosophy of C in this, I'd recommend you read <a href=""https://public-inbox.org/git/alpine.LFD.0.999.0709061839510.5626@evo.linux-foundation.org/"" rel=""nofollow noreferrer""><code>*YOU* are full of bullshit</code></a>. Very classic and rewarding.</p>
",6
53307407,53307241,2,"<p>Using <code>sizeof</code> on a char array will return the size of the buffer, not the length of the null-terminated string in the buffer. If you use <code>strcpy</code> to try and overflow the array, and it just happens to work (it's still undefined behavior), <code>sizeof</code> is still going to report the size used at declaration. That never changes.</p>

<p>If what you're interested in is observing how the length of a string changes with different assignments:</p>

<ol>
<li>Use an adequate buffer to store every string you're going to test.</li>
<li>Use the function <code>strlen</code> in <code>&lt;string.h&gt;</code> which will give you the actual length of the string, and not the length of your buffer, which, once declared, is constant.</li>
</ol>
",0
57294856,57294705,0,"<p>If you're targetting x86/ARM and Unix/Linux, you might find libtcc of use:</p>

<pre><code>#include &lt;libtcc.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


int main(void) {
    TCCState *s = tcc_new();
    tcc_set_output_type(s, TCC_OUTPUT_MEMORY);

    if (tcc_compile_string(s,
                           ""#include &lt;stdio.h&gt;\n""
                           ""void hello(void) {\n""
                           ""    printf(\""Hello world\\n\"");\n""
                           ""}\n""
        ) != 0)
    {
        fprintf(stderr, ""Failed to compile the code\n"");
        exit(2);
    }

    tcc_relocate(s, TCC_RELOCATE_AUTO);

    void (*hello)(void) = tcc_get_symbol(s, ""hello"");
    hello();
}
</code></pre>
",0
52680771,52680736,3,"<p>Assuming 2's compliment for integer representation:</p>

<pre><code>int filter = number ?-1 :0;
</code></pre>

<p>or (referring to the question's rev 2))</p>

<pre><code>int filter = !number -1;
</code></pre>

<p>or </p>

<pre><code>int filter = !number + (-1); /* Does not use the - operator. */
</code></pre>

<p>or</p>

<pre><code>int filter = !number + (union {unsigned u; int i;}){UINT_MAX}.i; 
</code></pre>

<p><sup>(Not sure if the latter invoked UB.)</sup></p>

<p>or, reminded by <a href=""https://stackoverflow.com/questions/52680736/how-do-i-set-all-bits-to-1-or-zero-depends-on-original-number#comment92290220_52680771"">Kamil's (deleted) comment</a>:</p>

<pre><code>int filter = !number + ~0;
</code></pre>

<p><sup>(Should work in any case)</sup></p>
",5
51057633,51057597,3,"<p>You don't <em>call</em> the functions, you <em>declare</em> the functions (again).</p>

<p>To call e.g. <code>one_three</code> then you do</p>

<pre><code>one_three();
</code></pre>

<hr>

<p>And speaking about function declarations, in C you must explicitly use <code>void</code> as argument if a function doesn't take any arguments. A declaration such as</p>

<pre><code>int two();
</code></pre>

<p>tells the compiler that the function <code>two</code> returns an <code>int</code>, and takes an unknown number of unspecified arguments. The proper declaration would be</p>

<pre><code>int two(void);
</code></pre>
",0
49060364,49060300,3,"<p>Instead of checking if the value is different to 0, check the return value of
<code>sscanf</code>. It returns the number of conversions it made. In your case it should be 1. Unless the return value is 1, keep asking for a number.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int ret, num;
    char line[1024];

    do {
        printf(""Enter a number: "");
        fflush(stdout);

        if(fgets(line, sizeof line, stdin) == NULL)
        {
            fprintf(stderr, ""Cannot read from stdin anymore\n"");
            return 1;
        }

        ret = sscanf(line, ""%d"", &amp;num);

        if(ret != 1)
            fprintf(stderr, ""That was not a number! Try again.\n"");

    } while(ret != 1);

    printf(""The number you entered is: %d\n"", num);

    return 0;
}
</code></pre>
",0
49060354,49060300,0,"<p>0 (zero) is a number...</p>

<p>But I see what you want to do...
You can check for a valid number, using <a href=""https://www.tutorialspoint.com/c_standard_library/ctype_h.htm"" rel=""nofollow noreferrer"">isdigit</a> or a combination of similar functions</p>

<p>I think its also important to follow the advice of other answers to use the return value from scanf using code such as:</p>

<pre><code>int ret = scanf(""%d"", &amp;num);
</code></pre>

<p>and examining <code>ret</code> for success or failure of scanf.</p>
",0
50429852,50427921,1,"<p>I'm sorry to hear that your teacher isn't much help. Here's a high level overview of what you should do for this project. <strong>Note that I am just recommending these steps given the instructions your teacher gave you for your project. If you were producing this program with the intent that it be used by others (i.e. not as a one-time school project), you would <em>definitely</em> want to use encryption to ensure that the journal contents and the user login information could not be read by others.</strong></p>

<p>In order to store the username and password, you need to store them in a file after the user ""registers"" with your program, and then when you want to allow the user log in at a later time, you need to read the username and password back from the file and compare them to what the user typed in. Remember that the username and password are just strings, so you just need to call the correct functions to write them to a file on your hard drive... you don't need to do anything more difficult than that. The file name can just be something you hardcode into your program (e.g. login.txt).</p>

<p>When you store the username and password in a file, you need to store them in a specific format so that you're able to differentiate between the two. For example, one primitive way of doing so would be the following:</p>

<pre><code>file login.txt: username,password
</code></pre>

<p>When you read the contents of login.txt in your program, you know that everything <em>before</em> the comma is the username and everything <em>after</em> the comma is the password. However, this format is not ideal because if the user includes a comma in his/her username or password, then your program will break. For a better way of storing this information in a file, I encourage you to read about JSON.</p>
",7
50946255,50946203,1,"<p>You're writing the <em>pointer</em> to the file. Pointers point to memory that is specific to the currently running process. If you load the pointer in another process, even one running the same program, then the pointer will not be valid.</p>

<p>So a quick-fix is to not write the pointer, but the <em>structure</em> to the file.</p>

<p><strong><em>However</em></strong> that will lead to the very same problem happening again, since one of the members in the structure is a pointer. What you need to do is to <a href=""https://en.wikipedia.org/wiki/Serialization"" rel=""nofollow noreferrer""><em>serialize</em></a> the structure.</p>
",0
51442126,51442049,0,"<p>Your dynamically allocated arrays are not big enough. For instance, <code>ic</code> has size <code>psize</code></p>

<pre><code>ic = (int *)malloc(sizeof(int)*psize);
</code></pre>

<p>but </p>

<pre><code>ic[i*psize+k] += ...
</code></pre>

<p><code>i*psize+k</code> is bigger than <code>psize</code>.</p>

<p>I guess you need</p>

<pre><code>ic = (int *)malloc(sizeof(int)*psize*psize);
</code></pre>

<p>etc.etc.</p>

<p>You also have a problem with uninitialised data. You are assuming that all your data is initialised to zero, but it isn't.</p>
",2
59546265,59545707,2,"<p>You're correct - your <code>to_lowercase</code> function is doing multiple things wrong:</p>

<ol>
<li>The way this function is currently written <code>newStr</code> is defining an array of <code>char *</code>, not an array of <code>char</code>.</li>
<li>You're then returning <code>newStr</code>, which is an automatic variable defined on the stack. As soon as the function returns <code>newStr</code> is subject to being overwritten by any other subroutine calls which are made.</li>
</ol>

<p>You could choose to define <code>to_lowercase</code> as</p>

<pre><code>const char * to_lowercase(char* str){
    char *newStr = malloc(strlen(str)+1);

    for(int i = 0; str[i]; i++)
      newStr[i] = tolower(str[i]);

    return newStr;
}
</code></pre>

<p>but this means that you'd have to be careful to free the memory allocated in <code>to_lowercase</code> each time you use it.</p>

<p>A better idea might be to write <code>to_lowercase</code> in such a manner that it changes the string it's passed to lower case in-place:</p>

<pre><code>char *to_lowercase(char* str){
    for(char *p = str; *p; p++)
      *p = tolower(*p);

    return str;
}
</code></pre>

<p>This overwrites the original content of <code>str</code> so you'll need to be sure to account for that in your code.</p>
",1
59545796,59545707,5,"<p><code>strcmp</code> returns a value that represents how argument 1 compares to argument 2 alphabetically. If they are equal, it returns 0 which is numerically equivalent to the <code>false</code> boolean. Thus you need to modify your if statements like this:</p>
<pre class=""lang-c prettyprint-override""><code>        if(!strcmp(argv[1],name)){
            printf(&quot;name_key = 1;&quot;);
            name_key = 1;
        }else if(!strcmp(argv[1],key)){
            printf(&quot;name_key = 2;&quot;);
            name_key = 2;
        }
        if (!strcmp(argv[2],cs)){
            printf(&quot;cs_ci = 1;&quot;);
            cs_ci = 1;
        }else if(!strcmp(argv[2],ci)){
            printf(&quot;cs_ci = 2;&quot;);
            cs_ci = 2;
        }
        if (!strcmp(argv[3],ever)){
            printf(&quot;ever_once = 1;&quot;);
            ever_once = 1;
        }else if(!strcmp(argv[3],once)){
            printf(&quot;ever_once = 2;&quot;);
            ever_once = 2;
        }
</code></pre>
<p>This way if the two strings are equivalent alphabetically, then <code>strcmp</code> will return 0 which will be negated to assume the value of <code>true</code> and the program execution will enter the if block. If the two strings are NOT equal, then <code>strcmp</code> will return either a positive or a negative value which is equivalent to the boolean <code>true</code>. Negating this will assume the value of <code>false</code> and the program execution will <strong>not</strong> enter the if block.</p>
<p>Hope this helps!</p>
<hr />
<h1>EDIT:</h1>
<p>To help you understand why your to_lowercase function might not be working properly, you have to understand two things about arrays:</p>
<ol>
<li>Firstly, the array contents are not passed to the function. The C language (and thus all compilers/interpreters) only passes the single value of any variable to a function when it is called. In this case, the array only contains the memory address of the first element of the array. That address is passed to the function instead of the array as a whole.</li>
<li>Secondly, an array declaration is simply a pointer to the first location of a contiguous set of locations in memory. When you reference the first element of an array you are accessing the first memory location pointed to by the pointer. When you reference the second, third, or even fourth element of the array, you are accessing the locations in memory that are exactly 2 or 3 or even 4 memory locations away from the first element.</li>
</ol>
<p>So what can we do with this? What happens when we change the values pointed to by the pointer? Remember, when you modify an array, (without intervention of some memory allocation tricks) <strong>the memory locations pointed to by the pointer do not change.</strong> <em>Only</em> the values in those memory locations change. This is why we cannot copy arrays by simply typing: <code>array1 = array2</code>. All this is doing is copying the pointer in <code>array2</code> to <code>array1</code>. Any modifications you make to <code>array2</code> will have a side effect of also being made in <code>array1</code> because they both now point to the same locations in memory!</p>
<p>So if you think you have an error in your <code>to_lowercase</code> function, try this modification to it. I cannot test your complete code because my GCC compiler is for Linux, but it should work for you:</p>
<pre class=""lang-c prettyprint-override""><code>void to_lowercase(char *str)
{
    for(int i = 0; str[i]; i++)
    {
        str[i] = tolower(str[i]);
    }
}
</code></pre>
<p><strong>HOW DOES THIS WORK?</strong></p>
<p>When we pass an array to a function, we are passing the value of the <em>array <strong>pointer</strong></em>. Thus the function only receives a location in memory. By utilizing this pointer, we can advance through memory to the other locations pointed to by that pointer (via <code>str[i]</code>) and modify them freely without affecting the value of the pointer itself.</p>
<p>Hope this helps.</p>
",7
51958708,51958684,4,"<p>You don't need to use <code>typedef</code> in order to define a new structured type. This is perfectly valid:</p>

<pre><code>struct student_s {
    char* name;
    int age;
    struct student_s* next;   
}; // Remove ""student"". Now you don't have a global variable.
</code></pre>

<p>A consequence of this is that <code>student_s</code> is <em>not</em> a name of your structured type; it is a <em>tag</em> of your structured type. Therefore, declaring objects of structured type corresponding to <code>student_s</code> must start with the keyword <code>struct</code>:</p>

<pre><code>int main(void)
{
    struct student_s student;
    ... // The rest of your code remains the same
}
</code></pre>
",0
49083537,49083375,1,"<p>The names are only of interest to the human reader and the compiler/linker translating that code to machine executable code.  The final object code resolves these to addresses and the names no longer exist.</p>

<p>The compiler distinguishes these the same way you do - by scope; when two identical symbols in the same namespace are in scope simultaneously, the symbol with the most restrictive scope is visible (i.e. may be accessed via the name).</p>

<p>For symbols with external linkage (in your example there are none other then <code>main</code>), the compiler retains the symbol name in order to resolve links between  separately compiled modules.  In the fully linked executable the symbol names cease to exist (except in debug build symbol meta-data).</p>
",1
50498840,50498760,1,"<pre><code>typedef struct llist {
    int valor;
    struct lligada *prox;
} *LInt;
</code></pre>

<p>makes  <code>LInt</code> equivalent to <code>struct llist*</code> (with the star included). 
This practice of typedefing pointers is pretty much discouraged in all modern resources
on C I've come across but it has been used historically, notably the lcc compiler
uses this practice a lot (their convention capitalizes the pointer typedefed name as well).</p>

<p>The problem with typedefing pointers is that it's potentially confusing and
you can suddenly pass 0 (as NULL) with a special value through them, however if you 
have a naming convention (such as capitalizing each pointer typedef) then 
the star is effectively not hidden but just expressed as an upper case letter,
although it might still be confusing to someone foreign to your codebase.</p>

<p>So to summarize, with </p>

<pre><code>typedef struct llist {
    int valor;
    struct lligada *prox;
} *LInt;
</code></pre>

<p>you'd then use it like so:</p>

<pre><code>LInt foo = NULL; 
</code></pre>

<p>whereas without the star in the typedef, the above would be:</p>

<pre><code>LInt *foo = NULL; 
</code></pre>
",6
50995583,50993000,1,"<blockquote>
  <p>But nowhere could I see the issue of operator precedence being addressed in this issue. </p>
</blockquote>

<p>Operator precedence only affects how expressions are <em>parsed</em> (which operands are grouped with which operators) - it has no effect on how expressions are <em>evaluated</em>.  Operator precedence says that <code>a * b + c</code> should be parsed as <code>(a * b) + c</code>, but it <em>doesn't</em> say that either <code>a</code> or <code>b</code> <em>must</em> be evaluated before <code>c</code>.  </p>

<blockquote>
  <p>Now we do not know whether the (i++) in LHS or RHS of '*' operator is going to be evaluated first. But either way it is going produce the same result. So how is it undefined?</p>
</blockquote>

<p>Because the side effect of the <code>++</code> operator does not have to be applied immediately after evaluation.  Side effects may be deferred until the next sequence point, or they may applied before other operations, or sprinkled throughout.  So if <code>i</code> is 2, then <code>i++ * i++</code> may be evaluated as <code>2 * 2</code>, or <code>2 * 3</code>, or <code>3 * 2</code>, or <code>2 * 4</code>, or <code>4 * 4</code>, or <em>something else entirely</em>.  </p>
",2
50993198,50993000,2,"<p>The problem with using</p>

<pre><code>i = i++ 
</code></pre>

<p>is that the order in which the address of <code>i</code> is accessed to read and write is not specified. As a consequence, at the end of that line, the value of <code>i</code> could be <code>3</code> or <code>2</code>.</p>

<p>When will it be <code>3</code>?</p>

<ol>
<li>Evaluate the RHS - <code>2</code></li>
<li>Assign it to the LHS. <code>i</code> is now <code>2</code>.</li>
<li>Increment <code>i</code>. <code>i</code> is now <code>3</code>.</li>
</ol>

<p>When will it be <code>2</code>?</p>

<ol>
<li>Evaluate the RHS - <code>2</code></li>
<li>Increment <code>i</code>. <code>i</code> is now <code>3</code>.</li>
<li>Assign the result of evaluating the RHS to the LHS. <code>i</code> is now <code>2</code>.</li>
</ol>

<p>Of course, if there is a race condition, we don't know what's going to happen.</p>
",0
53166860,53166660,2,"<p><a href=""https://stackoverflow.com/a/3676839/211160"">getchar() is buffered</a>.  So on each keypress, your loop isn't getting an opportunity to increment <code>cnt</code>.  It stays at 0 as you type...and doesn't start getting incremented until until you hit enter or something like Ctrl-D.</p>

<p>When you use Ctrl-D, it goes ahead and flushes through the input--allowing your program to get the characters.  But when you use Ctrl-Z, you are interrupting the in-progress line, and what you've typed so far is discarded.  So your loop doesn't run.</p>

<p>As @JonathanLeffler points out, the fact that your program terminates instead of being suspended is some kind of artifact of your environment.  But you would see the same effect on a typical setup if you just typed <code>fg</code> to resume the program...your in-progress input from the line you were typing is lost.</p>

<p><em>(It would help in situations like this to add more printf() statements, such as inside your loop--with <code>fflush(stdout)</code> to be cautious--just to get your bearings on the state of the system at each step.)</em></p>
",2
53326415,53326096,2,"<p><a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow noreferrer""><code>scanf</code> rapidly gets complicated</a> because it mixes up reading input with processing input. When all you want to do is read a line and do something with it <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_fgets.htm"" rel=""nofollow noreferrer""><code>fgets</code></a> is more appropriate. Read the line, then process it however you like. You can even use <code>sscanf</code> to stay in the scanf family.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
    char userInput[1024];
    char pwd[] = ""pc:~/marcospb19""; // Directory that keeps being printed

    printf(""%s$ "" , pwd);
    while (fgets(userInput, sizeof(userInput), stdin) != NULL)
    {
        if( strcmp(userInput, ""\n"") == 0 ) {
            puts(""Empty input."");
        } 
        else {
            puts(""Some input"");
        }

        printf(""%s$ "" , pwd);
    }

    puts("""");
}
</code></pre>

<p>This also lets you do more complex processing, like look for blank lines.</p>

<pre><code>    if( strspn(userInput, "" \t\r\n"") == strlen(userInput) ) {
        puts(""Blank input."");
    }
</code></pre>

<p>Note that <code>fgets</code> will leave the newline on the end, so you may have to strip the newline off <code>userInput</code> before working on it.</p>
",0
51101168,51093828,0,"<p>C 2011 (draft N1570) clause 6.4.5, paragraph 6 describes how a string literal in source code becomes a static object:</p>

<blockquote>
  <p>The multibyte character sequence is then used to initialize an array of static storage duration and length just sufficient to contain the sequence. For character string literals, the array elements have type <strong>char</strong>, and are initialized with the individual bytes of the multibyte character sequence.</p>
</blockquote>

<p>Thus, in <code>char *str = ""abc"";</code>, <code>str</code> is initialized to point to a static array containing the characters a, b, and c, and a null character.</p>

<p>Then <code>return str;</code> returns the value of this pointer.</p>

<p>Finally, <code>printf(""%s"", getString());</code> passes the value of the pointer to <code>printf</code>. At this point, the <code>str</code> object is gone (in the C model of computation). It no longer exists. We have the value it was used to hold, but the <code>str</code> object itself is gone. However, the value points to a static object, the array of characters, and <code>printf</code> reads that array and prints it.</p>

<p>So, the title of your question is incorrect. The non-static pointer variable declared inside the function was not preserved. All that was preserved was the static array of characters and its address.</p>
",0
51094956,51093828,1,"<p>The address of <code>str</code> may change but the thing it points to (once initialised) will not.</p>

<p>Note that in this simple example you probably won't see changes.  If you call <code>getString</code> a few times from different stack depths and show <code>&amp;str</code> you will see what I mean.</p>

<pre><code>char *getString()
{
    char *str = ""abc"";
    printf(""%p"", &amp;str);
    return str;
}     

    int main()
    {
       printf(""%s"", getString());  

       stackTest();
       getchar();
       return 0;
    }
    void stackTest()
    {
      char blob[200];
      int  x=0;
     printf(""%s"", getString());  
    }
</code></pre>

<p>*(I have not tested this and my unused stack variables might get optimised away depending on your compiler &amp; settings)</p>
",4
51015089,51015066,0,"<p>You want to use <code>==</code>¡ªthe equality operator¡ªinside your <code>if</code> statements.</p>

<p><code>=</code> is the assignment operator¡ªit will set <code>n</code> to be 'o', so your first <code>if</code> statement always returns true ('o' is non-zero).</p>
",0
49153256,49152350,0,"<p>You could extract the data as a single unsigned 32-bit integer and use that almost directly (depending on endianness issues of course).</p>

<p>Perhaps something like this:</p>

<pre><code>uint32_t fileSize;
memcpy(&amp;fileSize, buff[fileLocationOffset + 28], 4);
</code></pre>

<p>Then for the endianness issue, if you're on Linux you could use <code>be32toh</code> (see e.g. <a href=""http://man7.org/linux/man-pages/man3/endian.3.html"" rel=""nofollow noreferrer"">this endian manual page</a>) to convert big-endian to host encoding (and it does nothing if your host system is big-endian):</p>

<pre><code>fileSize = be32toh(fileSize);
</code></pre>

<p>The closest function to this in the Windows API is <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms740069(v=vs.85).aspx"" rel=""nofollow noreferrer""><code>ntohl</code></a>, which could be used in a similar way.</p>

<hr>

<p>It's not hard to implement absolute byte-swapping functions, or even macros, for this:</p>

<pre><code>inline uint16_t byteswap16(uint16_t value)
{
    return (value &amp; 0xff) &lt;&lt; 8 | (value &gt;&gt; 8);
}

inline uint32_t byteswap32(uint32_t value)
{
    return byteswap16(value &amp; 0xffff) &lt;&lt; 16 | byteswap16(value &gt;&gt; 16);
}

...
fileSize = byteswap32(fileSize);
...
</code></pre>
",0
52396835,52396740,3,"<p>You need to declare the function in either a heade file or inline in <code>my_getline.c</code>:</p>

<pre><code>char *my_fgets(char *s,int maxlen,FILE *fp);
</code></pre>

<p>Is the declaration. Either put that before your <code>my_getline</code> function or in <code>my_fgets.h</code> (with include guards) and #include that header in both your <code>.c</code> files. </p>

<p>Without it the compiler assumes any function it sees without a declaration returns <code>int</code></p>
",0
49861673,49861516,1,"<p>In you code </p>

<pre><code>char *s;
char sa[10] , sb[10];
</code></pre>

<p>you can't do much with <code>s</code>.</p>

<pre><code>scanf(""%s"", sa);
</code></pre>

<p>is ok, provided the input fits. You can jump through a few hoops, reading the inputs in chunks in a loop if it might be longer (see <a href=""https://stackoverflow.com/questions/1621394/how-to-prevent-scanf-causing-a-buffer-overflow-in-c"">here</a>)</p>

<p>However, in you ""However"" section of the question you try</p>

<pre><code>scanf(""%s"", s);
</code></pre>

<p>Since <code>s</code> doesn't point to memory - you'd need to have allocated some - you have undefined behaviour, so anything could happen.</p>
",0
54988191,54987815,2,"<ol>
<li>You need <code>#include &lt;cmath&gt;</code></li>
<li>You need to replace <code>abs</code> (integer absolute value) with <code>fabs</code> (floating point absolute value)</li>
<li>You need to check against Epsilon :  <code>if (f(c) &lt;= Epsilon)</code> instead of <code>if (f(c) == 0)</code> which is unlikely to happen.</li>
</ol>

<p>But anyway you still need to check if there <em>is</em> a solution. If there is no solution in the guess interval, the loop in the function never stops. This left as an exercise.</p>
",0
52600061,52600016,6,"<p>In the case of a function parameter (and <strong>only</strong> in that case), they mean the same thing.</p>

<p>Note that C99 dropped the ""implicit <code>int</code>"" rule, so your examples should be something like:</p>

<pre><code>void foo(char* grid){}
</code></pre>

<p>and</p>

<pre><code>void foo(char grid[]){}
</code></pre>

<p>A parameter defined with an array type is ""adjusted"" to become a parameter of pointer type, pointing to the the element type of the array.</p>

<p>Reference: <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">N1570</a> 6.7.6.3 paragraph 7. (This is a freely available draft of the 2011 ISO C standard, PDF, 1.7 MB.)</p>

<p>(In all other contexts, a pointer declaration and an array declaration are different. See section 6 of the <a href=""http://www.c-faq.com/"" rel=""nofollow noreferrer"">comp.lang.c FAQ</a>.</p>

<p>All parameters in C are passed by value, not by reference. In this case, the value being passed happens to be a pointer value, which is the address of a <code>char</code> object.  For example, if you write:</p>

<pre><code>char arr[10];
func(arr);
</code></pre>

<p>then the value being passed is <code>&amp;arr[0]</code> (there's a separate language rule that says that array expressions are converted/adjusted to become pointer expressions in most but not all contexts).  Note that no information about the length of the array is passed; if you want to keep track of that, you'll have to do so explicitly.</p>

<p>C doesn't have pass-by-reference as a language feature.  Passing a pointer value is a way to emulate pass-by-reference.</p>
",3
52527366,52527340,2,"<p>In the first iteration of the outer loop (when value of <code>i</code> is 0), the inner loop becomes an infinite loop, because value of <code>j</code> starts from 0 and keeps increasing. Eventually <code>j</code> becomes large enough for your program to access some unallocated memory, hence causing a segmentation fault.</p>

<p>Also, in the first iteration of the inner loop, value of <code>j</code> is 0, so <code>a[j - 1]</code> will try to access a memory location out of bound for your program.</p>
",1
54736661,54736567,2,"<p>Confusing numbers with representations of those numbers is a very common programming mistake. They are entirely different things. Five is the same number whether we write it as ""five"", ""5"", or ""IIIII"". But those are very different character sequences that represent that number.</p>

<p>The number five, the number of fingers you probably have on each of your hands, is not the same thing as the character '5' commonly used to represent that number. You are reading characters and then outputting them as if they were numbers.</p>
",0
52452691,52452680,4,"<p>You need to declare the return type of your read_double() function in the source file that defines main(), or in an included header.  Otherwise, C doesn't ""know"" it returns a floating point double type.</p>

<pre><code>double read_double(FILE *infile);

int main(void) { ....
</code></pre>
",0
59405714,59405600,0,"<pre><code>typedef struct aaa bbb;
//      ^^^^^^^^^^      source type
//                 ^^^  new identifier
</code></pre>

<p>You can't have the new identifier for an existent type be ""struct something"".</p>

<p>You maybe need to change the code to reflect that the struct you're using is not the same in all versions of the library</p>

<pre><code>#if lib_ver &gt; 20000
#typedef struct x_aaa libaaa
#else
#typedef struct aaa libaaa
#endif

// in your code use `libaaa` instead of `struct aaa`
//struct aaa foo;
libaaa foo;
//struct x_aaa bar;
libaaa bar;
</code></pre>
",0
59405698,59405600,3,"<p>A typedef name must be a single identifier, so you can't do that.<br>
(A typedef has the same form as a variable declaration, with the word ""typedef"" added in front of it.)</p>

<p>You can use a typedef that depends on the version</p>

<pre><code>#if lib_ver &gt; 20000
    typedef struct x_aaa lib_aaa;
#else
    typedef struct aaa lib_aaa;
#endif
</code></pre>

<p>and change your code to use <code>lib_aaa</code> instead of the full struct name.  </p>

<p>You could also use a macro, but it's a good idea to avoid them:</p>

<pre><code>#if lib_ver &gt; 20000
    #define aaa x_aaa;
#endif
</code></pre>

<p>The renaming sounds like it could be a breaking change even if you get your code to compile, though.<br>
I would be very cautious about this.</p>
",0
52458226,52458077,2,"<p>The statement ¡°It is a known fact that it is optional to use &amp; in scanf() while scanning arrays¡± is false, or at least grossly misleading.</p>

<p>When <code>%d</code> is used in <code>scanf</code>, the corresponding argument must be a pointer to an <code>int</code>. Given <code>int n</code>, the argument may be <code>&amp;n</code>. Given <code>int *a = malloc(¡­)</code> and <code>int i</code>, the argument may be <code>&amp;a[i]</code>.</p>

<p>In the latter case, the argument may also be <code>a</code>, because <code>a</code> is a pointer to an <code>int</code>. It points to the first <code>int</code> in the allocated space.</p>

<p>If an array were declared, as in <code>int a[5]</code>, then usually the address of an element, such as <code>&amp;a[i]</code>, ought to used as an argument to <code>scanf</code>. However, <code>a</code> can also be used as an argument. This is because an array is automatically converted to a pointer to its first argument, effectively <code>&amp;a[0]</code>. (This automatic conversion does not happen when the array is the argument of <code>sizeof</code> or unary <code>&amp;</code> or is a string literal used to initialize an array.)</p>

<p>If <code>a</code> were an array and you passed <code>&amp;a</code> to <code>scanf</code> for <code>%d</code>, that would be an error. <code>&amp;a</code> is not a pointer to an <code>int</code>; it is a pointer to an array of <code>int</code>. Even though they point to the same location in memory, they have different types, and the latter is the wrong type to pass to <code>scanf</code>.</p>
",0
53014633,53014543,0,"<p>Are you familiar with the keyword <code>break</code> and its use in the <code>case</code> parts of a <code>switch()</code>?</p>

<p>This:</p>

<pre><code>switch(pos % 3){
 case 0:
     *section1 = pos + 1;
     *section2 = pos + 2;
 case 1:
     *section1 = pos - 1;
     *section2 = pos + 1;
 case 2:
     *section1 = pos - 2;
     *section2 = pos - 1;
 }
</code></pre>

<p>will always execute <em>all</em> the <code>case</code>:s code, since they don't have <code>break</code>s in them. This is known as ""fall-through"" behavior, and can be very handy when intended.</p>

<p>You should add <code>break</code>s, so it looks like this:</p>

<pre><code>switch(pos % 3){
case 0:
    *section1 = pos + 1;
    *section2 = pos + 2;
    break;
case 1:
    *section1 = pos - 1;
    *section2 = pos + 1;
    break;
case 2:
    *section1 = pos - 2;
    *section2 = pos - 1;
}
</code></pre>
",4
52055399,50567942,0,"<p>gcc users can also use non-standard <code>__attribute__ ((packed))</code> attribute for remove padding from the wanted struct:</p>

<pre><code>struct data
{
  double Latitude;            // 00-07
  ...
  unsigned long PacketNumber; // 48-51
  int64_t y;                  // 52-59
  int64_t x;                  // 60-67
} __attribute__ ((packed));
</code></pre>
",0
52601224,52601199,3,"<p><code>sizeof( str )</code> is either 4 or 8 on most modern architectures (on yours, it appears to be 8, given the valgrind output indicates 9 bytes were allocated), no matter how many characters were in the string it pointed to. <code>sizeof</code> is going to tell you the size needed to store the pointer itself, not the length of the string it points to.</p>

<p>Instead, use:</p>

<pre><code>size_t len = strlen(str);
</code></pre>

<p>to compute the length of the <code>NUL</code>-terminated string you were passed.</p>

<p>BTW, many systems provide <a href=""http://man7.org/linux/man-pages/man3/strndup.3.html"" rel=""nofollow noreferrer"">strdup</a>, which does exactly what your <code>duplicate</code> function should do.</p>
",1
54112474,54112287,4,"<p>The <code>int getw(FILE *)</code> function is for reading an integer directly from the bytes of a file, not for reading an integer from the textual contents of a file.</p>

<p>If you wish to read integers from a file, one by one, use <code>fscanf</code> instead:</p>

<pre><code>FILE *in_file = fopen(""file1.txt"", ""r"");
FILE *out_file = fopen(""file2.txt"", ""w"");
int num;
while (fscanf(in_file, ""%d"", &amp;num) == 1) {
    if (is_prime(num)) {
        fprintf(out_file, ""%d\n"", num);
    }
}
fclose(in_file);
fclose(out_file);
</code></pre>
",2
50976148,50975968,2,"<p>In ISO C, the only way to do this is to write out a new copy of the entire file under a temporary name, and then use <code>rename</code> to change its name to the old name.  There is no way to shorten a file in place.  (If you are on Windows you may have to <code>remove</code> the old name before <code>rename</code> will work.)</p>

<p>POSIX adds the <code>ftruncate</code> operation which can be used to make a file shorter (or longer) in place.  Most common operating systems support POSIX features, but Windows doesn't.  Depending on which compiler you have on Windows, you might still have a function named <code>ftruncate</code>, though, because the C runtime on Windows often tries to fake a subset of POSIX functionality -- many of those fakes are unreliable, but I confess I don't see how one could screw up <code>ftruncate</code> given that Windows proper <em>does</em> have an equivalent primitive operation, it just has a different name (<code>SetEndOfFile</code>).</p>
",0
50148274,50132126,0,"<p>The <code>ranking</code> member is supposed to be a single <code>char</code>, so declare it as such and then read it as such and use it as such:</p>

<pre><code>// ...

struct Quest
{
   char nama[100];
   int reward;
   char ranking;  // Single-character rank
};

// ...

scanf("" %c"", &amp;questo[j].ranking);  // Leading space to skip initial white-space
// TODO: Should really check what scanf returns

// ...

printf(""Rank\t: %c\n"",questo[j].ranking);

// ...

switch (questo[j].ranking)
{
case 'S':
    // ...

default:
    // TODO: Handle the case if the rank is incorrect
    break;
}

// ...
</code></pre>
",1
54092659,54092358,3,"<p>If I well understand you want that :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  int mat[4][2][4] = {{{1,2,3,4},{10,20,30,40}},{{11,12,13,14},{110,120,130,140}},{{21,22,23,24},{210,220,230,240}},{{31,32,33,34},{310,320,330,340}}};
  int arr[2];
  int index,idx;

  for (index=0; index&lt;4; ++index) {
    /* only set */
    for (idx=0; idx&lt;2; ++idx) {
      arr[idx] = mat[index][idx][0];
    }

    /* only print */
    for (idx=0; idx&lt;2; ++idx) {
      printf(""%d\t"", arr[idx]);
    }
    printf(""\n"");
  }

  return 0;
}
</code></pre>

<p>Execution produces :</p>

<pre><code>1   10  
11  110 
21  210 
31  310 
</code></pre>

<p>I separated on purpose the assignment and the print loops even they are the same</p>

<hr>

<p>But it is strange to only use the index 0 for the last dimension, so I think in fact you want that :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
  int mat[4][2][4] = {{{1,2,3,4},{10,20,30,40}},{{11,12,13,14},{110,120,130,140}},{{21,22,23,24},{210,220,230,240}},{{31,32,33,34},{310,320,330,340}}};
  int arr[2];
  int idx0, idx1, idx2;

  for (idx2 = 0; idx2 != 4; ++idx2) {
    for (idx0=0; idx0&lt;4; ++idx0) {
      /* only set */
      for (idx1=0;idx1&lt;2;idx1++) {
        arr[idx1] = mat[idx0][idx1][idx2];
      }

      /* only print */
      for (idx1=0;idx1&lt;2;idx1++) {
        printf(""%d\t"", arr[idx1]);
      }
      printf(""\n"");
    }
  }

  return 0;
}
</code></pre>

<p>The execution produces :</p>

<pre><code>1   10  
11  110 
21  210 
31  310 
2   20  
12  120 
22  220 
32  320 
3   30  
13  130 
23  230 
33  330 
4   40  
14  140 
24  240 
34  340
</code></pre>
",2
52562342,52562258,0,"<p>You get the user input here </p>

<pre><code>float temp(void)
{
    float t;

    scanf(""%f"", &amp;t);

    return(t);
}
</code></pre>

<p>But you don't do anything with the returned value </p>

<pre><code> temp();
 speed = calc_speed(tempy);
</code></pre>

<p>So you call Cacl_speed with an uninitialized value 
Try</p>

<pre><code>tempy = temp();
speed = calc_speed(tempy);
</code></pre>
",0
49518307,49517689,1,"<p>You are using (and perhaps abusing, since you probably should not use it like you do) the <a href=""https://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow noreferrer"">comma operator</a>.</p>

<p>That comma operator is binary and works on two expressions ( its left and right operand). !It first evaluates its left operand (for side effects only), then its right operand (which is the result of that comma operator application).</p>

<p>In your code (your 2<sup>nd</sup> example), you don't have an expression, but a declaration, at right of the comma (after <code>clrscr()</code>). So this is a syntax error. </p>

<p>Of course your last <code>printf</code> lacks a semi-colon. I guess it is a typo.</p>

<p>Take the habit of reading documentation (notably of <a href=""http://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer"">printf</a>, but also of <code>clrscr</code> which is non-standard); compile with all warnings and debug info (e.g. <code>gcc -Wall -Wextra -g</code> with <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a>).</p>

<p>Of course, your <code>main</code> is wrong. It should return an <code>int</code>. Look into some <a href=""http://en.cppreference.com/w/c"" rel=""nofollow noreferrer"">reference</a> site, and then into the C11 standard, e.g. <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">n1570</a> (a draft nearly identical to the standard).</p>
",0
52574581,52574441,1,"<p>Providing a minimal set of code around the code shown in the question, and adding diagnostic printing, produces an MCVE (<a href=""https://stackoverflow.com/help/mcve"">Minimal, Complete, Verifiable Example</a> like this:</p>

<pre><code>#include &lt;stdio.h&gt;

static unsigned int ctoi(char in);

int main(void)
{
    char tmp[] = ""0100ed73 ed000032 0100d5dc d5dc0012"";
    FILE *outFilePtr = stdout;
    fprintf(stderr, ""Hex data: [%s]\n"", tmp);

    for (int i = 0; i &lt; 4; i++)
    {
        char *start = tmp + i * 9;
        for (int j = 0; j &lt; 4; j++)
        {
            unsigned char a = ctoi(start[0 + j * 2]) * 16 + ctoi(start[1 + j * 2]);
            fputc(a, outFilePtr);
            fprintf(stderr, ""0x%c%c = 0x%.2X = '%c'\n"", start[0 + j * 2], start[1 + j * 2], a, a);
        }
    }
    putchar('\n');
    return 0;
}

static unsigned int ctoi(char in)
{
    if (in &gt;= '0' &amp;&amp; in &lt;= '9')
    {
        return in - '0';
    }
    else
    {
        return in - 'a' + 10;
    }
}
</code></pre>

<p>And, when run with the output run through a program that translates non-printing characters into <code>\xXX</code> hex escape sequences, the output is:</p>

<pre><code>Hex data: [0100ed73 ed000032 0100d5dc d5dc0012]
0x01 = 0x01 = '\x01'
0x00 = 0x00 = '\x00'
0xed = 0xED = '\xED'
0x73 = 0x73 = 's'
0xed = 0xED = '\xED'
0x00 = 0x00 = '\x00'
0x00 = 0x00 = '\x00'
0x32 = 0x32 = '2'
0x01 = 0x01 = '\x01'
0x00 = 0x00 = '\x00'
0xd5 = 0xD5 = '\xD5'
0xdc = 0xDC = '\xDC'
0xd5 = 0xD5 = '\xD5'
0xdc = 0xDC = '\xDC'
0x00 = 0x00 = '\x00'
0x12 = 0x12 = '\x12'
\x01\x00\xEDs\xED\x00\x002\x01\x00\xD5\xDC\xD5\xDC\x00\x12
</code></pre>

<p>On the face of it, your code produces exactly the output it is supposed to produce, so it is not clear where you have a problem ¡ª except that it is probably not directly in the code shown in the question.</p>
",0
50284757,50284700,1,"<blockquote>
<pre><code>warning: format '%d' expects argument of type 'int', but argument 2 
</code></pre>
  
  <p>has type 'long unsigned int' [-Wformat=]</p>
</blockquote>

<p>This is a warning message, not an error message. This means the compiler has spotted something that looks like a mistake, but it's still able to compile the program.</p>

<p>In this case, it's spotted that you're using the wrong format specifier (<code>%</code> thingy) for the argument you're passing to <code>printf</code>. It should be <code>%zu</code>, since <code>sizeof</code> ""returns"" a <code>size_t</code>.</p>
",1
58089669,58089584,2,"<p>This is due to the <strong>usual arithmetic conversions</strong>.</p>

<p>When the operands of a operator involve both a signed integer and an unsigned integer, and the unsigned type is at least as large as the signed type, the signed value is converted to an unsigned value.  When the signed value is negative, it gets converted to a large positive value.</p>

<p>The rules for integer conversions are spelled out in section 6.3.1.8p1 of the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C standard</a>:</p>

<blockquote>
  <p>If both operands have the same type, then no further conversion is
  needed.</p>
  
  <p>Otherwise, if both operands have signed integer types or both have
  unsigned integer  types,  the  operand  with  the  type  of  lesser 
  integer  conversion  rank  is converted to the type of the operand
  with greater rank.</p>
  
  <p>Otherwise,  if  the  operand  that  has  unsigned  integer  type  has 
  rank  greater  or equal  to  the  rank  of  the  type  of  the  other 
  operand,  then  the  operand  with signed  integer  type  is 
  converted  to  the  type  of  the  operand  with  unsigned integer
  type.</p>
  
  <p>Otherwise, if the type of the operand with signed integer type can
  represent all of the values of the type of the operand with unsigned
  integer type, then the  operand  with  unsigned  integer  type  is 
  converted  to  the  type  of  the operand with signed integer type.</p>
  
  <p>Otherwise,   both   operands   are   converted   to   the   unsigned<br>
  integer   type corresponding to the type of the operand with signed
  integer type</p>
</blockquote>

<p>In this expression:</p>

<pre><code>(d &lt;= TOTAL_ELEMENTS - 2)
</code></pre>

<p>Which expands to:</p>

<pre><code>(d &lt;= (sizeof(array) / sizeof(array[0])) - 2)
</code></pre>

<p>The <code>sizeof</code> operator evaluates to a value of type <code>size_t</code> which is unsigned.  So the types of the operands look like this:</p>

<pre><code>(int &lt;= ((size_t / size_t) - int)
</code></pre>

<p>Both operands of the <code>/</code> operator are of type <code>size_t</code> so the result of that operation is of type <code>size_t</code>.  Then the right operand of <code>-</code> is converted to type <code>size_t</code>.  Since the value 2 fits in that type the value doesn't change.  </p>

<p>Now we have the <code>&lt;=</code> operator with an <code>int</code> on one size and a <code>size_t</code> on the other.  The left operand is converted from <code>int</code> to <code>size_t</code>, however the value -1 doesn't fit in that type so it is converted.  The converted value is actually the largest possible value for a <code>size_t</code> which is therefore greater than the value on the right side, making the result of <code>&lt;=</code> false.</p>

<p>To fix this, you'll want to cast the unsigned value on the right to signed to prevent the left side from being converted:</p>

<pre><code>if (d &lt;= (int)(TOTAL_ELEMENTS - 2))
</code></pre>
",2
52638913,52638731,2,"<p>You should be able to use code like this to read one name and number:</p>

<pre><code>if (scanf(""%24[a-zA-Z]%d"", namax, &amp;hargax) == 2)
    ¡­got name and number OK¡­
else
    ¡­some sort of problem to be reported and handled¡­
</code></pre>

<p>You would need to wrap that in a loop of some sort in order to get three pairs of values.  Note that using <code>&amp;namax</code> as an argument to <code>scanf()</code> is technically wrong.  The <code>%s</code>, <code>%c</code> and <code>%[¡­]</code> (scan set) notations all expect a <code>char *</code> argument, but you are passing a <code>char (*)[25]</code> which is quite different.  A fortuitous coincidence means you usually get away with the abuse, but it is still not correct and omitting the <code>&amp;</code> is easy (and correct).</p>

<p>You can find details about scan sets etc in the POSIX specification of <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/scanf.html"" rel=""nofollow noreferrer""><code>scanf()</code></a>.</p>

<p>You should consider reading a whole line of input with <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/fgets.html"" rel=""nofollow noreferrer""><code>fgets()</code></a> or POSIX 
<a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/getline.html"" rel=""nofollow noreferrer""><code>getline()</code></a>, and then processing the resulting string with <code>sscanf()</code>.  This makes error reporting and error recovery easier.  See also <a href=""https://stackoverflow.com/questions/3975236/how-to-use-sscanf-in-loops"">How to use <code>sscanf()</code> in loops</a>.</p>
",0
52640273,52638731,0,"<p>In addition to using a <em>character class</em> to include the characters to read as a string, you can also use the <em>character class</em> to <em>exclude</em> digits which would allow you to scan forward in the string until the next digit is found, taking all characters as your name and then reading the digits as an integer. You can then determine the number of characters consumed so far using the <code>""%n""</code> format specifier and use the resulting number of characters to offset your next read within the line, e.g.</p>

<pre><code>        char namax[MAXNM],
            *p = buf;
        int hargax,
            off = 0;
        while (sscanf (p, ""%24[^0-9]%d%n"", namax, &amp;hargax, &amp;off) == 2) {
            printf (""%-24s %d\n"", namax, hargax);
            p += off;
        }
</code></pre>

<p>Note how the <code>sscanf</code> format string will read up to 24 character that are <em>not</em> digits as <code>namax</code> and then the integer that follows as <code>hargax</code> storing the number of characters consumed in <code>off</code> which is then applied to the pointer <code>p</code> to advance within the buffer in preparation for your next parse with <code>sscanf</code>.</p>

<p>Putting it altogether in a short example, you could do:</p>

<pre><code>#include &lt;stdio.h&gt;

#define MAXNM   25
#define MAXC  1024

int main (void) {

    char buf[MAXC] = """";

    while (fgets (buf, MAXC, stdin)) {
        char namax[MAXNM],
            *p = buf;
        int hargax,
            off = 0;
        while (sscanf (p, ""%24[^0-9]%d%n"", namax, &amp;hargax, &amp;off) == 2) {
            printf (""%-24s %d\n"", namax, hargax);
            p += off;
        }
    }
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ echo ""car1900food2900ram800"" | ./bin/fgetssscanf
car                      1900
food                     2900
ram                      800
</code></pre>
",0
49663476,49663378,0,"<p>The very first time in your loop, <code>validity</code> does not have a defined value at all.</p>

<p>It might be <code>1</code>, it might be <code>0</code>, it might be <code>65,532</code>.</p>

<p>You should assign it an initial value.</p>

<pre><code>int validity = 0, pos; //validity 0:not valid, repeat the loop; validity 1: valid number
</code></pre>

<hr>

<p>You declared <code>pos</code> as an <code>int</code>; it will never be <code>NULL</code>.  It will have integer values.</p>

<p>This line makes no sense:</p>

<pre><code>if (pos == NULL){
</code></pre>

<p>You should initialize that variable as well.</p>

<pre><code>int validity = 0, pos = 99; //validity 0:not valid, repeat the loop; validity 1: valid number
</code></pre>
",3
52666112,52665663,1,"<p>There are many issues.</p>

<p>This is a corrected version of your program, all comments are mine. Minimal error checking is done for brevity. <code>intarr = malloc(sizeof(int) * 16);</code> will be a problem if there are more than 16 numbers in the file, this should be handled somehow, for example by growing <code>intarr</code> with <code>realloc</code>, similar to what you're doing in <code>readFile</code>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

char *readFile() {
  FILE *fp;

  fp = fopen(""input.txt"", ""r"");
  if (fp == NULL)
  {
    printf(""File is NULL!n"");
    return NULL;      // abort if file could not be opened
  }

#define MAXLINELENGTH 255      // define a constant rather than hardcoding ""255"" at several places

  char* STRING;
  char oneLine[MAXLINELENGTH];
  STRING = malloc(MAXLINELENGTH);
  int count = MAXLINELENGTH;   // count mus be initialized and better declare it here
  assert(STRING != NULL);
  STRING[0] = 0;          // memory pointed by STRING must be initialized

  while (fgets(oneLine, MAXLINELENGTH, fp) != NULL)   // correct usage of fgets
  {
    count += strlen(oneLine);
    STRING = realloc(STRING, count + 1);
    strcat(STRING, oneLine);
  }

  fclose(fp);
  return STRING;
}


int *convert(char *STRING, int *nbofvalues) {   // nbofvalues for returning the number of values
  int *intarr;
  intarr = malloc(sizeof(int) * 16);
  int a = 0;
  char *ptr = strtok(STRING, "" \n"");   // strings may be separated by '\n', or ' '

  *nbofvalues = 0;

  while (ptr != NULL) {
    intarr[a] = atoi(ptr);

    printf(""number = %s\tindex = %d\n"", ptr, a);
    a++;
    ptr = strtok(NULL, "" \n"");  // strings are separated by '\n' or ' '
   }                            // read the fgets documentation which
                                // terminates read strings by \n

  *nbofvalues = a;    // return number of values 
  return intarr;
}


int main(int args, char* argv[]) {
  int *val;

  char *STRING = readFile();

  if (STRING == NULL)
  {
    printf(""readFile() problem\n"");   // abort if file could not be read
    return 1;
  }

  int nbvalues;
  val = convert(STRING, &amp;nbvalues);  // nbvalues contains the number of values

  // print numbers
  for (int i = 0; i &lt; nbvalues; i++)
  {
    printf(""%d: %d\n"", i, val[i]);
  }

  free(val);    // free memory
  free(STRING); // free memory
  return 0;
}
</code></pre>

<p>I'm not sure what your requirement is, but this can be simplified a lot because there is no need to read the file into memory and then convert the strings into number. You could convert the numbers on the fly as you read them. And as already mentioned in a comment, calling <code>realloc</code> for each line is inefficient. There is room for more improvements.</p>
",1
50514555,50513488,0,"<p>START_BUFFER_SIZE is not known at the compile time, and it's not constant as you are able to assign a value to it. Variable size arrays require dynamic memory allocation. You need to know your array size in compile time to be able to use a static array. </p>
",0
52746043,52745942,0,"<p>I will guess the issue</p>

<p><code>fgetc</code> returns an <code>int</code> not a <code>char</code>. see <a href=""https://linux.die.net/man/3/fgetc"" rel=""nofollow noreferrer"">https://linux.die.net/man/3/fgetc</a>
 So this can never be true</p>

<pre><code>while (content != EOF)
</code></pre>

<p>so declare content as <code>int</code>;</p>
",1
53174716,53174624,2,"<p>When you call <code>parse_args</code>, <code>arguments</code> is not initialized.  Then inside of <code>parse_args</code>, you dereference this uninitialized pointer when you assign to <code>args[i]</code>.  Doing so invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>, which in this caes manifests as a crash.</p>

<p>Declare <code>arguments</code> as an array of pointers large enough for your purposes:</p>

<pre><code>char *arguments[100];
</code></pre>

<p>Or, if you don't know how many arguments you'll have you can instead pass the address of a <code>char **</code>  and dynamically allocate memory for it as you read in the arguments:</p>

<pre><code>int parse_args(char ***args, char *line){

   const char s[]= "" \t\n\r"";
   char *token;
   token = strtok(line, s);//separates line with the separators
   int i=0;
   char null[] = ""(null)"";
   *args = malloc(1 * sizeof(char *));
   while( token != NULL ) {
      if (token[0]=='#'){ //if the like begins with ""comment"" I don't care

          (*args)[i]=null;
          return i;
      }else{
          (*args)[i] = token;// else fills each char * of **args with a token
          printf(""Parse_args()--&gt; token %d: "",i);
          printf(""%s\n"",token);
          i++;
      }
      *args = realloc(*args, i * sizeof(char *));
  token = strtok(NULL, s); //separates again
   }
   (*args)[i]=null; //ends with null

   return i;

} 
</code></pre>

<p>And call it like this:</p>

<pre><code>char **arguments;

int i = parse_args(&amp;arguments,line);
</code></pre>
",1
49710695,49710660,3,"<p>When inputting strings, don't use the <code>&amp;</code>.</p>

<pre><code>scanf(""%s"",&amp;v);
</code></pre>

<p>Should be:</p>

<pre><code>scanf(""%s"", v);
</code></pre>

<hr>

<p>C does not use <code>==</code> to compare strings.<br>
Instead, use <code>strcmp</code>:</p>

<pre><code>if( strcmp(v,""addition"") == 0 ){
</code></pre>
",1
51932555,51932150,2,"<p><code>i &lt;= len</code> as you want to deal with the terminating <code>\0</code> inside the loop. And better let <code>block_idx</code> start from 0, so the second loop also has an understandable condition (block_count?).</p>

<p>So: <code>strlen</code> returns the number of chars not including the terminating <code>\0</code>. Maybe better:</p>

<pre><code>block = malloc((block_sizes[traversed] + 1) * sizeof(char));
block[block_sizes[traversed]] = '\0';
</code></pre>
",0
58041600,58041240,3,"<p>Unfortunately, not easily. C is not built for <a href=""https://en.wikipedia.org/wiki/Type_introspection"" rel=""nofollow noreferrer"">introspection</a> and doesn't have features like this-- the name of function <em>foo</em> and the call to function <em>foo</em> are compiled down to just some jump and call instructions in the output; the actual name ""foo"" is essentially a convenience for you when programming and disappears in the compiled output.</p>

<p>The macro <code>__FUNCTION__</code> is a preprocessor macro-- and as you note it only works within a function, because all it does it tell the preprocessor (as its churning through the text) hey, as you're scanning this token just drop in the name of the function you're currently scanning and then continue on. It's very ""dumb"" and is upstream of even the compiler.</p>

<p>There are various ways to get the effective result you want here, including most simply just manually building a table of string literals that have the same names as your functions. You can do this in fairly clean ways (see @nielsen's answer for a useful snippet) using macros. But the preprocessor/compiler can't help you derive or enforce a table from the <em>actual</em> functions so you will always have <em>some</em> risk of an issue at runtime when you make changes to it. Unfortunately C just doesn't have the capability for the kind of elegance you're looking for in this design.</p>
",0
52713121,52712729,0,"<p>How to sum a series of squares in a loop is the easy part</p>

<pre><code>sum = 0;
for (n=0; TBD; n++) {
  sum += n*n;
}
printf(..., n);
</code></pre>

<p>The trick is when to stop given ""sum ... is less than the given number.""</p>

<p>Code could use</p>

<pre><code>for (n=0; sum + n*n &lt; given_number; n++) {
  sum += n*n;
}
n--;
</code></pre>

<p>That works up to a point, yet seems redundant.  It  has a problem in that <code>sum + i*i</code> may overflow.  Perhaps subtract <code>i*i</code> each time as we do not need to report the sum, just <code>n</code>.  </p>

<pre><code>for (n=0; n*n &lt; given_number; n++) {
  given_number -= n*n;
}
n--;
</code></pre>

<p>What it nice about this is that the compare on the right side gets smaller as <code>n*n</code> increases, yet <code>n*n</code> does not overflow.  Note:  <code>n</code> will be <em>about</em> the cubic root of <code>given_number</code></p>

<hr>

<p>If you want to avoid the loop, research <a href=""https://math.stackexchange.com/questions/48080/sum-of-first-n-squares-equals-fracnn12n16"">Sum of First  n  Squares</a></p>

<hr>

<p>As <a href=""https://stackoverflow.com/questions/52712729/beginner-in-c-programming-arithmetic-algorithm/52713121#comment92351361_52712729"">@user4581301</a> commented, use <code>""%u""</code> with <code>unsigned</code>.</p>
",0
58830055,58829593,1,"<p>I cannot doubt your experience but I'm not sure your conclusion is correct.  First we don't run source code, it has to be compiled first.  This leaves open the possibility that you have an old executable, i.e. an executable that doesn't reflect the code.  The same code compiled the same way should produce the same runtime behavior (given that that code logic is correct).</p>

<p>Since all the variables are integer the <code>d</code> variable can become 0 and if this happens before <code>i</code> becomes less than or equal to 1 the <code>i%d</code> would result in a divide by zero error.  Trying your code on repl.it with i = 1000 and d = 77 generates a floating point exception, but different compilers/environments may surface that undefined state differently (though all should produce an error state).</p>

<p>My advice is to delete both your compiled executables and any object files (clean your project), then recompile and compare results.  If you still see different behavior based on the same output, then carefully compare your source files (or 'diff' them if you are on a unix'y system).  If you still find a discrepancy, update your question with both source files (even if you find them identical), the compiler (name/version) and environment (OS/version) you are using.    </p>
",0
59554553,59554278,0,"<p>The following parses the input and produces the correct output.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;

int *nums = NULL;
int num_count = 0;

char save_num(int n)
    {
    nums = realloc(nums, sizeof(int)*(num_count+1));
    nums[num_count++] = n;
    return '\0';
    }

void getString(const char *str) 
    { 
    char* alpha = malloc(strlen(str)+1);
    char* num = malloc(strlen(str)+1);
    size_t i;

    alpha[0] = '\0';
    num[0] = '\0';

    for (i = 0; i &lt; strlen(str); i++) 
        {
        if (isdigit(str[i]))
            strncat(num, str+i, 1);
        else if(isalpha(str[i]))
            {
            strncat(alpha, str+i, 1);
            if(strlen(num) &gt; 0)
                num[0] = save_num(atoi(num));
            }
        }

    if(strlen(num) &gt; 0)
        save_num(atoi(num));

    printf(""str: %s\n"", alpha); 

    for(i = 0 ; i &lt; num_count ; ++i)
      printf(""num%Zu: %02d\n"", i+1, nums[i]);

    free(alpha);
    free(num);
    } 

int main() 
    { 
    char *str = ""one01two02three03""; 
    getString(str); 
    return 0; 
    }
</code></pre>
",0
51768710,51768447,3,"<pre><code>int readInts(int maxNumInts, int nums[])
{
    int count = 0;

    while(scanf(""%d"",&amp;nums[count++]) != EOF &amp;&amp; count &lt; maxNumInts) {
        }   
    return count;   
}
</code></pre>

<p>you are incrementing <code>count</code> even on the call which fails. Also scanf returns the number of items read and thus will return zero not EOF when it doesn't read anything.</p>

<p>Try</p>

<pre><code>int readInts(int maxNumInts, int nums[])
{
    int count = 0;

    while((1 == scanf(""%d"",&amp;nums[count])) &amp;&amp; (count &lt; maxNumInts)) {
           count++;
    }   
    return count;   
}
</code></pre>

<p>I strongly recommend that you get an IDE, such as <a href=""https://www.eclipse.org/cdt/"" rel=""nofollow noreferrer"">Eclipse</a>, <a href=""http://www.codeblocks.org/"" rel=""nofollow noreferrer"">Code::Blocks</a>, <a href=""https://visualstudio.microsoft.com/"" rel=""nofollow noreferrer"">Microsoft Visual Studio</a> or some other which you like.</p>

<p>Then learn about the debugger  </p>

<ul>
<li>how to set breakpoints  </li>
<li>how to examine variables  </li>
<li>how to step though your code line by line  </li>
<li>how to examine the call stack</li>
<li>etc </li>
</ul>

<p><a href=""https://i.stack.imgur.com/sOsYK.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/sOsYK.png"" alt=""enter image description here""></a></p>

<p>Since you seem to be new, be aware of <a href=""https://codereview.stackexchange.com/"">https://codereview.stackexchange.com/</a> When your code is working, post it there and you will get advice on how to improve it (such a <code>n</code> is not a very meaningful variable name)</p>

<p>When you can do that, you will never again have to wait for out help for issues like this, because you can find them easily in the debugger.</p>
",4
54681679,54680129,0,"<p>Neither a ring buffer solution nor a 'shuffle buffer' solution is particularly complex.  Here's one of each.  Note that the ring buffer solution stores 15 values in an array of 16; the shuffle buffer solution use an array of size 15.  The solutions give the same sequence of outputs if you map the entries such as <code>( 1:  30)</code> to <code>(99: 30)</code> to allow for the differences in the way that the data is stored.</p>

<p>Both solutions assume you understand structures (and pointers to structures too).</p>

<h3>Shuffle Buffer</h3>

<p>This corresponds most closely to the code in the question.</p>

<pre><code>#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

enum { SB_SIZE = 15 };

typedef int Data;
#define DATA_PRI_FMT ""d""

struct ShuffleBuffer
{
   size_t sb_last;
   Data   sb_data[SB_SIZE];
};
typedef struct ShuffleBuffer ShuffleBuffer;

static inline void sb_shuffle(ShuffleBuffer *sbp)
{
    if (sbp-&gt;sb_last &gt; 0)
    {
        memmove(sbp-&gt;sb_data, sbp-&gt;sb_data + 1, (SB_SIZE - 1) * sizeof(sbp-&gt;sb_data[0]));
        sbp-&gt;sb_last--;
    }
}

static void sb_insert(ShuffleBuffer *sbp, Data value)
{
    if (sbp-&gt;sb_last == SB_SIZE)
        sb_shuffle(sbp);
    sbp-&gt;sb_data[sbp-&gt;sb_last++] = value;
}

static bool sb_remove(ShuffleBuffer *sbp, Data *valuep)
{
    if (sbp-&gt;sb_last == 0)
        return false;
    *valuep = sbp-&gt;sb_data[0];
    sb_shuffle(sbp);
    return true;
}

static void sb_print(const char *tag, const ShuffleBuffer *sbp)
{
    printf(""%s: (last = %zu)\n"", tag, sbp-&gt;sb_last);
    int nbytes = 0;
    const char *pad = """";
    for (size_t i = 0; i &lt; sbp-&gt;sb_last; i++)
    {
        nbytes += printf(""%s(%2zu: %3"" DATA_PRI_FMT "")"", pad, i, sbp-&gt;sb_data[i]);
        if (nbytes &gt; 40)
        {
            putchar('\n');
            nbytes = 0;
            pad = """";
        }
        else
            pad = "" "";
    }
    if (nbytes != 0)
        putchar('\n');
}

int main(void)
{
    ShuffleBuffer rb = { 0, { 0 } };

    for (Data i = 0; i &lt; 100; i++)
    {
        sb_insert(&amp;rb, i * 7 + 23);
        sb_print(""Post insert"", &amp;rb);
        if ((i &amp; 1) == 1)
        {
            Data value;
            if (sb_remove(&amp;rb, &amp;value))
                printf(""Value %"" DATA_PRI_FMT "" removed\n"", value);
            else
                sb_print(""Ring Buffer Empty"", &amp;rb);
        sb_print(""Post remove"", &amp;rb);
        }
    }

    printf(""Insert/remove loop over\n"");

    Data value;
    while (sb_remove(&amp;rb, &amp;value))
        printf(""Value %"" DATA_PRI_FMT "" removed\n"", value);

    return 0;
}
</code></pre>

<h3>Ring Buffer</h3>

<pre><code>#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

enum { RB_SIZE = 16 };

typedef int Data;
#define DATA_PRI_FMT ""d""

struct RingBuffer
{
   size_t rb_head;
   size_t rb_tail;
   Data   rb_data[RB_SIZE];
};
typedef struct RingBuffer RingBuffer;

static inline size_t rb_nextpos(size_t pos)
{
    return (pos + 1) % RB_SIZE;
}

static void rb_insert(RingBuffer *rbp, Data value)
{
    rbp-&gt;rb_data[rbp-&gt;rb_head] = value;
    rbp-&gt;rb_head = rb_nextpos(rbp-&gt;rb_head);
    if (rbp-&gt;rb_tail == rbp-&gt;rb_head)
        rbp-&gt;rb_tail = rb_nextpos(rbp-&gt;rb_tail);
}

static bool rb_remove(RingBuffer *rbp, Data *valuep)
{
    if (rbp-&gt;rb_head == rbp-&gt;rb_tail)
        return false;
    *valuep = rbp-&gt;rb_data[rbp-&gt;rb_tail];
    rbp-&gt;rb_tail = rb_nextpos(rbp-&gt;rb_tail);
    return true;
}

static void rb_print(const char *tag, const RingBuffer *rbp)
{
    printf(""%s: (head = %zu, tail = %zu)\n"", tag, rbp-&gt;rb_head, rbp-&gt;rb_tail);
    int nbytes = 0;
    const char *pad = """";
    for (size_t i = rbp-&gt;rb_tail; i != rbp-&gt;rb_head; i = rb_nextpos(i))
    {
        nbytes += printf(""%s(%2zu: %3"" DATA_PRI_FMT "")"", pad, i, rbp-&gt;rb_data[i]);
        if (nbytes &gt; 40)
        {
            putchar('\n');
            nbytes = 0;
            pad = """";
        }
        else
            pad = "" "";
    }
    if (nbytes != 0)
        putchar('\n');
}

int main(void)
{
    RingBuffer rb = { 0, 0, { 0 } };

    for (Data i = 0; i &lt; 100; i++)
    {
        rb_insert(&amp;rb, i * 7 + 23);
        rb_print(""Post insert"", &amp;rb);
        if ((i &amp; 1) == 1)
        {
            Data value;
            if (rb_remove(&amp;rb, &amp;value))
                printf(""Value %"" DATA_PRI_FMT "" removed\n"", value);
            else
                rb_print(""Ring Buffer Empty"", &amp;rb);
        rb_print(""Post remove"", &amp;rb);
        }
    }

    printf(""Insert/remove loop over\n"");

    Data value;
    while (rb_remove(&amp;rb, &amp;value))
        printf(""Value %"" DATA_PRI_FMT "" removed\n"", value);

    return 0;
}
</code></pre>

<p>If your compiler is so antiquated that it doesn't recognize <code>inline</code> as a keyword, simply add <code>#define inline /* C99 not available */</code> near the top of the file (or, better, get a compiler that does recognize the almost 20-year old standard).</p>

<h3>Sample output from Ring Buffer</h3>

<pre><code>Post insert: (head = 1, tail = 0)
( 0:  23)
Post insert: (head = 2, tail = 0)
( 0:  23) ( 1:  30)
Value 23 removed
Post remove: (head = 2, tail = 1)
( 1:  30)
Post insert: (head = 3, tail = 1)
( 1:  30) ( 2:  37)
Post insert: (head = 4, tail = 1)
( 1:  30) ( 2:  37) ( 3:  44)
Value 30 removed
Post remove: (head = 4, tail = 2)
( 2:  37) ( 3:  44)
Post insert: (head = 5, tail = 2)
( 2:  37) ( 3:  44) ( 4:  51)
Post insert: (head = 6, tail = 2)
( 2:  37) ( 3:  44) ( 4:  51) ( 5:  58)
Value 37 removed
Post remove: (head = 6, tail = 3)
( 3:  44) ( 4:  51) ( 5:  58)
Post insert: (head = 7, tail = 3)
( 3:  44) ( 4:  51) ( 5:  58) ( 6:  65)
Post insert: (head = 8, tail = 3)
( 3:  44) ( 4:  51) ( 5:  58) ( 6:  65) ( 7:  72)
Value 44 removed
Post remove: (head = 8, tail = 4)
( 4:  51) ( 5:  58) ( 6:  65) ( 7:  72)
Post insert: (head = 9, tail = 4)
( 4:  51) ( 5:  58) ( 6:  65) ( 7:  72) ( 8:  79)
Post insert: (head = 10, tail = 4)
( 4:  51) ( 5:  58) ( 6:  65) ( 7:  72) ( 8:  79)
( 9:  86)
Value 51 removed
Post remove: (head = 10, tail = 5)
( 5:  58) ( 6:  65) ( 7:  72) ( 8:  79) ( 9:  86)
Post insert: (head = 11, tail = 5)
( 5:  58) ( 6:  65) ( 7:  72) ( 8:  79) ( 9:  86)
(10:  93)
Post insert: (head = 12, tail = 5)
( 5:  58) ( 6:  65) ( 7:  72) ( 8:  79) ( 9:  86)
(10:  93) (11: 100)
Value 58 removed
Post remove: (head = 12, tail = 6)
( 6:  65) ( 7:  72) ( 8:  79) ( 9:  86) (10:  93)
(11: 100)
Post insert: (head = 13, tail = 6)
( 6:  65) ( 7:  72) ( 8:  79) ( 9:  86) (10:  93)
(11: 100) (12: 107)
Post insert: (head = 14, tail = 6)
( 6:  65) ( 7:  72) ( 8:  79) ( 9:  86) (10:  93)
(11: 100) (12: 107) (13: 114)
Value 65 removed
Post remove: (head = 14, tail = 7)
( 7:  72) ( 8:  79) ( 9:  86) (10:  93) (11: 100)
(12: 107) (13: 114)
Post insert: (head = 15, tail = 7)
( 7:  72) ( 8:  79) ( 9:  86) (10:  93) (11: 100)
(12: 107) (13: 114) (14: 121)
Post insert: (head = 0, tail = 7)
( 7:  72) ( 8:  79) ( 9:  86) (10:  93) (11: 100)
(12: 107) (13: 114) (14: 121) (15: 128)
Value 72 removed
Post remove: (head = 0, tail = 8)
( 8:  79) ( 9:  86) (10:  93) (11: 100) (12: 107)
(13: 114) (14: 121) (15: 128)
Post insert: (head = 1, tail = 8)
( 8:  79) ( 9:  86) (10:  93) (11: 100) (12: 107)
(13: 114) (14: 121) (15: 128) ( 0: 135)
Post insert: (head = 2, tail = 8)
( 8:  79) ( 9:  86) (10:  93) (11: 100) (12: 107)
(13: 114) (14: 121) (15: 128) ( 0: 135) ( 1: 142)
Value 79 removed
Post remove: (head = 2, tail = 9)
( 9:  86) (10:  93) (11: 100) (12: 107) (13: 114)
(14: 121) (15: 128) ( 0: 135) ( 1: 142)
Post insert: (head = 3, tail = 9)
( 9:  86) (10:  93) (11: 100) (12: 107) (13: 114)
(14: 121) (15: 128) ( 0: 135) ( 1: 142) ( 2: 149)
Post insert: (head = 4, tail = 9)
( 9:  86) (10:  93) (11: 100) (12: 107) (13: 114)
(14: 121) (15: 128) ( 0: 135) ( 1: 142) ( 2: 149)
( 3: 156)
Value 86 removed
Post remove: (head = 4, tail = 10)
(10:  93) (11: 100) (12: 107) (13: 114) (14: 121)
(15: 128) ( 0: 135) ( 1: 142) ( 2: 149) ( 3: 156)
Post insert: (head = 5, tail = 10)
(10:  93) (11: 100) (12: 107) (13: 114) (14: 121)
(15: 128) ( 0: 135) ( 1: 142) ( 2: 149) ( 3: 156)
( 4: 163)
Post insert: (head = 6, tail = 10)
(10:  93) (11: 100) (12: 107) (13: 114) (14: 121)
(15: 128) ( 0: 135) ( 1: 142) ( 2: 149) ( 3: 156)
( 4: 163) ( 5: 170)
Value 93 removed
Post remove: (head = 6, tail = 11)
(11: 100) (12: 107) (13: 114) (14: 121) (15: 128)
( 0: 135) ( 1: 142) ( 2: 149) ( 3: 156) ( 4: 163)
( 5: 170)
Post insert: (head = 7, tail = 11)
(11: 100) (12: 107) (13: 114) (14: 121) (15: 128)
( 0: 135) ( 1: 142) ( 2: 149) ( 3: 156) ( 4: 163)
( 5: 170) ( 6: 177)
Post insert: (head = 8, tail = 11)
(11: 100) (12: 107) (13: 114) (14: 121) (15: 128)
( 0: 135) ( 1: 142) ( 2: 149) ( 3: 156) ( 4: 163)
( 5: 170) ( 6: 177) ( 7: 184)
Value 100 removed
Post remove: (head = 8, tail = 12)
(12: 107) (13: 114) (14: 121) (15: 128) ( 0: 135)
( 1: 142) ( 2: 149) ( 3: 156) ( 4: 163) ( 5: 170)
( 6: 177) ( 7: 184)
Post insert: (head = 9, tail = 12)
(12: 107) (13: 114) (14: 121) (15: 128) ( 0: 135)
( 1: 142) ( 2: 149) ( 3: 156) ( 4: 163) ( 5: 170)
( 6: 177) ( 7: 184) ( 8: 191)
Post insert: (head = 10, tail = 12)
(12: 107) (13: 114) (14: 121) (15: 128) ( 0: 135)
( 1: 142) ( 2: 149) ( 3: 156) ( 4: 163) ( 5: 170)
( 6: 177) ( 7: 184) ( 8: 191) ( 9: 198)
Value 107 removed
Post remove: (head = 10, tail = 13)
(13: 114) (14: 121) (15: 128) ( 0: 135) ( 1: 142)
( 2: 149) ( 3: 156) ( 4: 163) ( 5: 170) ( 6: 177)
( 7: 184) ( 8: 191) ( 9: 198)
Post insert: (head = 11, tail = 13)
(13: 114) (14: 121) (15: 128) ( 0: 135) ( 1: 142)
( 2: 149) ( 3: 156) ( 4: 163) ( 5: 170) ( 6: 177)
( 7: 184) ( 8: 191) ( 9: 198) (10: 205)
Post insert: (head = 12, tail = 13)
(13: 114) (14: 121) (15: 128) ( 0: 135) ( 1: 142)
( 2: 149) ( 3: 156) ( 4: 163) ( 5: 170) ( 6: 177)
( 7: 184) ( 8: 191) ( 9: 198) (10: 205) (11: 212)
Value 114 removed
Post remove: (head = 12, tail = 14)
(14: 121) (15: 128) ( 0: 135) ( 1: 142) ( 2: 149)
( 3: 156) ( 4: 163) ( 5: 170) ( 6: 177) ( 7: 184)
( 8: 191) ( 9: 198) (10: 205) (11: 212)
Post insert: (head = 13, tail = 14)
(14: 121) (15: 128) ( 0: 135) ( 1: 142) ( 2: 149)
( 3: 156) ( 4: 163) ( 5: 170) ( 6: 177) ( 7: 184)
( 8: 191) ( 9: 198) (10: 205) (11: 212) (12: 219)
Post insert: (head = 14, tail = 15)
(15: 128) ( 0: 135) ( 1: 142) ( 2: 149) ( 3: 156)
( 4: 163) ( 5: 170) ( 6: 177) ( 7: 184) ( 8: 191)
( 9: 198) (10: 205) (11: 212) (12: 219) (13: 226)
Value 128 removed
Post remove: (head = 14, tail = 0)
( 0: 135) ( 1: 142) ( 2: 149) ( 3: 156) ( 4: 163)
( 5: 170) ( 6: 177) ( 7: 184) ( 8: 191) ( 9: 198)
(10: 205) (11: 212) (12: 219) (13: 226)
Post insert: (head = 15, tail = 0)
( 0: 135) ( 1: 142) ( 2: 149) ( 3: 156) ( 4: 163)
( 5: 170) ( 6: 177) ( 7: 184) ( 8: 191) ( 9: 198)
(10: 205) (11: 212) (12: 219) (13: 226) (14: 233)
Post insert: (head = 0, tail = 1)
( 1: 142) ( 2: 149) ( 3: 156) ( 4: 163) ( 5: 170)
( 6: 177) ( 7: 184) ( 8: 191) ( 9: 198) (10: 205)
(11: 212) (12: 219) (13: 226) (14: 233) (15: 240)
Value 142 removed
Post remove: (head = 0, tail = 2)
( 2: 149) ( 3: 156) ( 4: 163) ( 5: 170) ( 6: 177)
( 7: 184) ( 8: 191) ( 9: 198) (10: 205) (11: 212)
(12: 219) (13: 226) (14: 233) (15: 240)
Post insert: (head = 1, tail = 2)
( 2: 149) ( 3: 156) ( 4: 163) ( 5: 170) ( 6: 177)
( 7: 184) ( 8: 191) ( 9: 198) (10: 205) (11: 212)
(12: 219) (13: 226) (14: 233) (15: 240) ( 0: 247)
¡­
Post insert: (head = 3, tail = 4)
( 4: 611) ( 5: 618) ( 6: 625) ( 7: 632) ( 8: 639)
( 9: 646) (10: 653) (11: 660) (12: 667) (13: 674)
(14: 681) (15: 688) ( 0: 695) ( 1: 702) ( 2: 709)
Post insert: (head = 4, tail = 5)
( 5: 618) ( 6: 625) ( 7: 632) ( 8: 639) ( 9: 646)
(10: 653) (11: 660) (12: 667) (13: 674) (14: 681)
(15: 688) ( 0: 695) ( 1: 702) ( 2: 709) ( 3: 716)
Value 618 removed
Post remove: (head = 4, tail = 6)
( 6: 625) ( 7: 632) ( 8: 639) ( 9: 646) (10: 653)
(11: 660) (12: 667) (13: 674) (14: 681) (15: 688)
( 0: 695) ( 1: 702) ( 2: 709) ( 3: 716)
Insert/remove loop over
Value 625 removed
Value 632 removed
Value 639 removed
Value 646 removed
Value 653 removed
Value 660 removed
Value 667 removed
Value 674 removed
Value 681 removed
Value 688 removed
Value 695 removed
Value 702 removed
Value 709 removed
Value 716 removed
</code></pre>

<h3>Timing</h3>

<p>With the main loop repeating 100 times, there's not really a measurable difference between the two programs if you disable the printing, and its only barely measurable and not entirely reliable if you enable the printing.</p>

<p>With printing disabled and the buffer size of 15 or 16, looping one million times in the main program took 4.5 ms for ring buffer vs 9.0 ms for shuffle buffer.  Change the buffer size to 2047 or 2048, and the times were 3.7 ms for ring buffer vs 87.3 ms for shuffle buffer.  With the printing enabled, the slight extra work done by ring buffer in the printing swamped the performance gain from not shuffling; the two programs were running in essentially the same time: 4,546.5 ms vs 4,477.2 ms (so shuffle buffer was slightly faster with the printing enabled ¡ª in large part because it produced only 353 MiB of data compared with 368 MiB of data from the ring buffer ¡ª with the data being written to <code>/dev/null</code> with the timing runs).</p>

<p>The measured times were elapsed run time for the executable ¡ª not CPU time per se.  The testing was done an a 15"" MacBook Pro (2017) with 2.9 GHz Intel Core i7 with 16 GiB of 2133 MHz <a href=""https://en.wikipedia.org/wiki/LPDDR"" rel=""nofollow noreferrer"">LPDDR3</a> RAM, running macOS 10.14.3 Mojave and using a home-built GCC 8.2.0.  Speed testing is difficult ¡ª I think the results without printing are meaningful, but <a href=""https://www.acronymfinder.com/YMMV.html"" rel=""nofollow noreferrer"">YMMV</a>.  If you ever needed a demonstration that 'printing is slow', this is quite possibly a good one.</p>
",0
52799718,52799602,3,"<p>To read a <em>line</em>, use <code>fgets()</code>.  Then, if successful,  parse the input string for <code>'\n'</code>, expected a,b,c, or anything else.</p>

<pre><code>//                          c  ' '  c  ' '  d   \n  \0
#define LINE_EXPECTED_SIZE (1 + 1 + 1 + 1 + 11 + 1 + 1)

char buf[LINE_EXPECTED_SIZE * 2]; // let us be generous with size.
while (fgets(buf, sizeof buf, stdin) &amp;&amp; buf[0] != '\n') {
  char a,b;
  int c;
  if (sscanf(buf, ""%c %c %d"", &amp;a, &amp;b, &amp;c) != 3) {
    // Note unexpected input
    fprintf(stderr, ""Unexpected bad input '%s'\n"", buf);
    break;
  }
  printf(""a:'%c', b:'%c', c%d\n"", a,b,c);
}
</code></pre>

<hr>

<p><code>""\n""</code> is rarely correct at the end of a <code>scan()</code> format. <a href=""https://stackoverflow.com/questions/52799602/how-to-exit-a-scanf-loop-with-newline-character-currently-loops-indefinitely/52799718#comment92518878_52799602"">@Jonathan Leffler</a>.</p>

<hr>

<p>The above uses <code>sscanf(...) != 3</code> to detect if 3 specifiers were matched.  This will not detect if <em>extra</em> text was on the line.  An advanced approach uses <code>"" %n""</code> to scan optional following white-space and then note the scan offset at that point.</p>

<pre><code>  // if (sscanf(buf, ""%c %c %d"", &amp;a, &amp;b, &amp;c) != 3) {
  int n = 0;
  sscanf(buf, ""%c %c %d %n"", &amp;a, &amp;b, &amp;c, &amp;n);
  if (n == 0 || buf[n] != '\0') {
    // if scanning did not reach %n or extra text followed ...
</code></pre>
",0
57805273,57805204,5,"<p>I assume you're on Linux, where expansion of special characters such as <code>*</code> is done by the <em>shell</em>. That means that if you execute your program as e.g.</p>

<pre><code>&gt; ./myprog *.txt
</code></pre>

<p>it is the <em>shell</em> which expands <code>*.txt</code> into ""all files in the current directory which end with <code>.txt</code>"" and passes <em>that</em> as command-line arguments to your program. If you want your actual program to get hold of the unexpanded string <code>*.txt</code>, you have to escape/quote it somehow, like this:</p>

<pre><code>&gt; ./myprog '*.txt'
</code></pre>

<p>or</p>

<pre><code>&gt; ./myprog \*.txt
</code></pre>
",1
53139625,53139179,1,"<p>You are reading the first number in the file into <code>num</code> and then attempting to read input this number of times. To me, this looks as if your input starts with the number of items present, and then lists each item.</p>

<p>However, you're calling <code>rewind()</code> one you have read the value of <code>num</code> and then go on to read the input. As you probably know, <code>rewind()</code> takes you back to the beginning of the file. This means that at the point where you are trying to read the first item, you're actually reading the <em>number of items</em> as well as the first item, and your input processing will be thrown off course.</p>

<p>You probably need to remove the <code>rewind()</code> call.</p>
",0
52804262,52804230,3,"<p>Try it like this (or use your debugger, or just think it through maybe with the help of a piece of paper)</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
    int a[5] = {5, 1, 15, 20, 25};
    int i, j, m;
    i = ++a[1]; fprintf(stderr, ""i is %d; a[1] is %d\n"", i, a[1]);
    j = a[1]++; fprintf(stderr, ""j is %d; a[1] is %d\n"", j, a[1]);
    m = a[i++]; fprintf(stderr, ""m is %d, i is %d; a[i] is %d\n"", m, i, a[i]);
    printf(""%d, %d, %d"", i, j, m);
}
</code></pre>

<p>See <a href=""https://ideone.com/AoFzaC"" rel=""nofollow noreferrer"">code running on ideone</a>.</p>
",0
52823263,52823156,1,"<p>The problem is that when you find two items that needs to be swapped you are changing just their charge which is not correct. Instead you should swap whole items directly.</p>

<p>Something like this (only interested part):</p>

<pre><code>if (a[i].avgCharge &gt; a[j].avgCharge)
{
   hotels temp = a[i];
   a[i] = a[j];
   a[j] = temp;
}
</code></pre>

<p>Sidenote: I advice you to name your structure <code>hotel</code>, because that's what really is, no? Afterwards when you declare an array of <code>hotel</code> struct you can name that array <em>hotels</em>.</p>
",2
57974776,57974450,1,"<p>More needs to be known (and posted) about the internals of the function <code>opfGetAll()</code> for a more complete answer.  The 4th argument, <code>void *</code>, means the function is likely set up to handle more than one type of input.  Whether that includes <code>flaot *</code> is not known, but from what you are trying, and without more accurate documentation, the assumption appears you expect that is can.   </p>

<p>However, from your comments following the two ways you have called the functions:</p>

<pre><code> //opfGetAll(opf,type1,attr_inp1, &amp;iform1_tab[0].floatVal);//don't take all data, it fill half of it and the rest is 0 or rubbish
 opfGetAll(opf,type1,attr_inp1, iform1_tab );//this version fill all array
</code></pre>

<p>strongly suggests that the 4th argument of <code>opfGetAll</code> expects some form of <code>struct data *</code>, whether it be a single instance or an array.  If that is the case, this would be why you are seeing unexpected results when attempting to pass it something else.  (i.e. <code>&amp;iform1_tab[0].floatVal</code>, which is a <code>float *</code>) </p>
",7
52449192,52449179,0,"<p>Just consider these numbers as <em>strings</em> of characters (each character happens to be a digit). Then do character processing on them.</p>

<p>For example:</p>

<pre><code>char str[16];
memset (str, 0, sizeof(str));
if (scanf("" %15[0-9]"", &amp;str) &gt; 0) 
  printf(""%.3s"", str); 
</code></pre>

<p>should, if fed with <code>0734327574</code>, output <code>073</code> (notice that your example don't explain what should have happened in that case, and I am <em>guessing</em> one way of doing it. My guess could be wrong if <code>0734327574</code> is actually meant as an <em>octal</em> number for the decimal number 124891004).</p>

<p>The rest is an exercise to the reader. Of course you need to <em>carefully</em> read the documentation of <a href=""https://en.cppreference.com/w/c/string/byte/memset"" rel=""nofollow noreferrer"">memset</a>, of <a href=""https://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow noreferrer"">scanf</a>, of <a href=""https://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer"">printf</a>. Don't forget to end <code>printf</code> format strings with <code>\n</code> or to call <a href=""https://en.cppreference.com/w/c/io/fflush"" rel=""nofollow noreferrer"">fflush</a> on <code>stdout</code> (which is often line-buffered).</p>

<p>Remember that <a href=""https://en.wikipedia.org/wiki/Number"" rel=""nofollow noreferrer"">numbers</a> don't have digits. Only their notation have digits. The number <a href=""https://en.wikipedia.org/wiki/20_(number)"" rel=""nofollow noreferrer"">20</a>, written in Roman notation <em>XX</em>, in English <em>twenty</em>, in French <em>vingt</em>, in hexadecimal <code>0x14</code>, in octal <code>024</code> (or even <code>24</code><sub>8</sub>), in binary 10100, as the simple arithmetic expression 3*7-1, is still the same number (which happens to be twice the number of fingers I have on my hands, and is also the number of <a href=""https://en.wikipedia.org/wiki/Arrondissements_of_Paris"" rel=""nofollow noreferrer"">arrondissements</a> in Paris).</p>
",0
50888818,50888732,0,"<p>The function <code>array()</code> does not modify or print <code>""hello""</code>, but <code>a</code> which got <em>initialised</em> using ""hello"". This initialisation happens again each time <code>array()</code> is called.</p>
",0
50888821,50888732,3,"<p>The text you're quoting is talking about a string literal, such as the argument to <code>printf()</code> here:</p>

<pre><code>printf(""hello"");
</code></pre>

<p>or the string that's used to initialize a pointer variable:</p>

<pre><code>char *p = ""hello"";
</code></pre>

<p>In your code, you're declaring a local array, and the string literal is being used to initialize it. Your code is roughly equivalent to:</p>

<pre><code>char a[6];
strcpy(a, ""hello"");
</code></pre>

<p>The second argument to <code>strcpy()</code> would be allocated statically, but <code>a</code> is local to the function.</p>
",0
54810197,54809608,0,"<p>Arithmetic operators are built into the language grammar - they're not separate library calls like <code>sqrt()</code> or <code>abs()</code> or whatever.  So, they don't need to have any sort of declaration in scope in order to function.  </p>
",0
54809796,54809608,0,"<p>Basic operators are part of the grammar of the language. In a lib there are ""higher functions"" that are composed out of basic operators or other libs. So you can reduce everythink back to the basic constructs of a language ... certainly.</p>
",0
54810709,54809608,0,"<p>Primarily, the reason <code>math.h</code> is needed for some operations and not others is that the people who designed C decided to build some things into the core language and to keep some things in separate sets, including a set of things for math, a set of things for strings, a set of things for time, a set of things for input and output, and so on.</p>

<p>It would be possible to build the things in <code>math.h</code> into the core language. For example, <code>sizeof</code> is built into the language, so building <code>sqrt</code> into the language too would not require any change of grammar. Also, it would be theoretically possible to exclude some operations like <code>*</code> from the core language and require you to include <code>math.h</code> before using them. However, the language provides ways for declaring functions like <code>sqrt</code> but does not provide ways for declaring operators like <code>*</code>, so some changes to the grammar would have to be made to support this.</p>

<p>So, since it is <strong>possible</strong> the core language could include or exclude various things, then the reasons for various things being included or excluded are somewhat a matter of choice. Essentially, the basic arithmetic operations were considered fundamental and very useful, so they were made part of the core language, while other functions were not. There are various factors contributing to this.</p>

<p>One is a desire to avoid cluttering the language. If all of the functions declared in headers were part of the core language, then <code>sqrt</code> could be used only for the <code>sqrt</code> in <code>math.h</code>. A programmer could not use <code>sqrt</code> for their own variable name. This is fine for a few names, but, as the library grows, the chance there will be collisions between a name in a library and a name in regular source code grows.</p>

<p>Additionally, if there is existing source code and somebody has a bright idea for a new routine, adding the new routine name to the language might break existing code that is already using that name for a different purpose.</p>

<p>So, generally, we prefer to implement non-essential routines in separate sets, and then authors can choose to include the ones they want to use and learn, and they can leave out the ones they do not need and avoid problems.</p>

<p>Partitioning the libraries into sets like this also means that library routines not used by a program do not have to be linked into the final program executable, so the executable file can be smaller.</p>

<p>Additionally, it means C can be used in a variety of environments, such as a small machine that is not able to support the full math library. Somebody might want to run simple programs that just work with basic arithmetic on a small processor. If the core language of C is small, they can write such programs. If every C program had to include all of the routines on the libraries, it might not be possible to get C working on very small computers.</p>
",0
54809696,54809608,3,"<p><code>&lt;math.h&gt;</code> contains macro and function definitions for mathematical operations. Some of the functionality in <code>&lt;math.h&gt;</code> is required to be present according to the C Standard, but they still aren't intrinsically part of the grammar of the language, unlike the operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and <code>%</code>.</p>
",0
51157664,51157609,3,"<p>You need this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
  FILE *p = fopen(""data.txt11"", ""r"");
  if (p == NULL)
  {
    printf(""File could not be opened.\n"");
    return 1;
  }

  char ar[150];

  while (fgets(ar, 150, p) != NULL)
  {
    puts(ar);
  }

  fclose(p);
  return 0;
}
</code></pre>
",10
51157664,51157609,3,"<p>You need this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
  FILE *p = fopen(""data.txt11"", ""r"");
  if (p == NULL)
  {
    printf(""File could not be opened.\n"");
    return 1;
  }

  char ar[150];

  while (fgets(ar, 150, p) != NULL)
  {
    puts(ar);
  }

  fclose(p);
  return 0;
}
</code></pre>
",10
51009866,51009821,4,"<p>Compiling your code with warnings enabled should yield the following output:</p>

<blockquote>
  <p>program.c:13:1: warning: control may reach end of non-void function [-Wreturn-type]</p>
</blockquote>

<p>This means that your <code>summ</code> function lacks a <em>base case</em> - i.e. it does not specify what should be returned once <code>n</code> is reached.</p>

<p>Once you fix this problem, your code starts returning the correct value. However, your function would still need some fixing, because you should not be using static variables in it. Any static variable in a function makes the function non-reentrant, which is very bad. In particular, your function can be run only once; second invocation would yield an error, because neither <code>i</code> nor <code>sum</code> could be reset.</p>

<p>Here is a simple recursive implementation of what you are looking to build:</p>

<pre><code>int summ_impl(int a[], size_t i, size_t n) {
    return i != n ? a[i] + summ_impl(a, i+1, n) : 0;
}
int sum(int a[], size_t n) {
    return summ_impl(a, 0, n);
}
</code></pre>
",0
52908870,52908792,2,"<blockquote>
  <p>assignment makes integer from pointer without a cast [-Wint-conversion] tab[k] = argv[I];</p>
</blockquote>

<p>You're getting this warning because you've declared <code>tab</code> as type <code>int *</code>. <code>argv</code> is an array of <code>char *</code>, so you're assigning a pointer (again, <code>char *</code> to an entry in an array of integers.</p>

<blockquote>
  <p>im trying to allocate a new tab that contains argc elements (the inputs) and returns the inputs but in reverse</p>
</blockquote>

<p>OK, but what you're code is actually doing is:</p>

<pre><code>int *tab =malloc(argc*sizeof(char));
</code></pre>

<p>In English: allocate a block of size <code>argc * 1</code> and assign its address to a pointer that's typed as a pointer to integers. It sounds like what you mean to do is to create an array of character pointers, i.e. <code>malloc(argc * sizeof(char*))</code>, but if you do that then <code>tab</code> should also be typed as <code>char **</code>.</p>
",2
52922105,52922016,0,"<p>The problem is in your <code>DisplaySeats</code> function. You have a local <code>Seats[4][10]</code> in your display function, which means your global variable <code>Seats[4][10]</code> will be hidden inside your <code>DisplaySeats</code>. </p>

<p>Every time you call <code>DisplaySeats</code>, you just show a brand new <code>Seats</code>, <b>NOT</b> the one you modified in your <code>ChooseSeat</code> function. So just get rid of <code>int Seats[4][10] = { 0 };</code> in your <code>DisplaySeats</code> function , and you'll be fine.</p>
",2
50574551,50574236,1,"<p>Use printing to help debug your code ¡ª or use a debugger to do printing similarly.  This is the code I came up with.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv)
{
    if (argc != 3)
    {
        fprintf(stderr, ""Usage: %s 'haystack string' 'needle'\n"", argv[0]);
        return 1;
    }
    char *str1, *str2;
    int str1len, str2len;
    str1 = argv[1];
    str2 = argv[2];
    str1len = strlen(str1);
    str2len = strlen(str2);
    printf(""str1 (%d): [%s]\n"", str1len, str1);
    printf(""str2 (%d): [%s]\n"", str2len, str2);

    printf(""strstr() says '%s'\n"", (strstr(str1, str2) == 0) ? ""false"" : ""true"");

    if (str2len &gt; str1len)
    {
        printf(""false\n"");
        return 0;
    }
    char sub1[100];
    if ((size_t)str2len &gt;= sizeof(sub1))
    {
        fprintf(stderr, ""Oops: the needle is too big (%d &gt; %zu)\n"", str2len, sizeof(sub1));
        return 1;
    }
    memset(sub1, 'X', sizeof(sub1)-1);
    sub1[sizeof(sub1)-1] = '\0';        // Demonstrated problem with lack of null terminator
    for (int i = 0; i &lt;= str1len - str2len; i++)
    {
        strncpy(sub1, str1 + i, str2len);
        sub1[str2len] = '\0';           // Null terminator that prevents some problems!
        printf(""Compare [%s] with [%s]\n"", sub1, str2);
        if (strcmp(sub1, str2) == 0)
        {
            printf(""true\n"");
            return 0;
        }
    }
    printf(""false\n"");
    return 0;
}
</code></pre>

<p>When compiled from <code>subs61.c</code> to <code>subs61</code> and run, I get, for example:</p>

<pre><code>$ gcc -m64 -g -O3 -std=c11 -pedantic -Wall -Wextra -Werror -Wshadow \
&gt;     -Wmissing-prototypes -Wpointer-arith  -Wold-style-definition \
&gt;     -Wcast-qual -Wstrict-prototypes subs61.c -o subs61
$ subs61 'I am the Walrus' 'I am the Walrus'
str1 (15): [I am the Walrus]
str2 (15): [I am the Walrus]
strstr() says 'true'
Compare [I am the Walrus] with [I am the Walrus]
true
$ subs61 'He said, ""I am the Walrus"", but did you believe him?' 'I am the Walrus'
'subs61' is up to date.
str1 (52): [He said, ""I am the Walrus"", but did you believe him?]
str2 (15): [I am the Walrus]
strstr() says 'true'
Compare [He said, ""I am ] with [I am the Walrus]
Compare [e said, ""I am t] with [I am the Walrus]
Compare [ said, ""I am th] with [I am the Walrus]
Compare [said, ""I am the] with [I am the Walrus]
Compare [aid, ""I am the ] with [I am the Walrus]
Compare [id, ""I am the W] with [I am the Walrus]
Compare [d, ""I am the Wa] with [I am the Walrus]
Compare [, ""I am the Wal] with [I am the Walrus]
Compare [ ""I am the Walr] with [I am the Walrus]
Compare [""I am the Walru] with [I am the Walrus]
Compare [I am the Walrus] with [I am the Walrus]
true
$
</code></pre>

<p>(Hmmm: I ran this in a different directory from where I normally work on Stack Overflow questions and the compilation options in the <code>makefile</code> are even more stringent than I normally show.)</p>

<p>Note that the copy'n'compare code is doing a lot more work than is strictly necessary; the <code>strstr()</code> solution is much more sensible.  You could rework the loop to avoid copying and use <code>strncmp()</code> ¡ª that would be analogous to what <code>strstr()</code> does.</p>

<pre><code>    printf(""Using strncmp():\n"");
    int spotted = 0;
    for (int i = 0; i &lt;= str1len - str2len; i++)
    {
        printf(""Compare [%.*s] with [%s]\n"", str2len, str1+i, str2);
        if (strncmp(str1+i, str2, str2len) == 0)
        {
            printf(""true\n"");
            spotted = 1;
            break;
        }
    }
    if (!spotted)
        printf(""false\n"");
</code></pre>

<p>The code should be packaged into a function (or several functions) called from the main program, which would simplify some aspects of the code.  For example, the <code>spotted</code> variable wouldn't be needed.  The functions would probably not print <code>true</code> or <code>false</code>; they'd return a value and the calling code would be responsible for the printing.</p>
",1
50825800,50825629,2,"<p>Use <code>malloc</code></p>

<pre><code>typedef struct{
    char comment[40];
    int nbpts;
    float *time;
    float *value;
} trace;

void simuTrace(int tmax, float dt, float params[], trace* uneTrace){
    int i = 0;
    float v = 0, w = 0, dv = 0, dw = 0, t = 0;
    int count = tmax/dt;
    uneTrace-&gt;time = malloc(count * sizeof(float));
    uneTrace-&gt;value = malloc(count * sizeof(float));
    while (i &lt; count){
        dv = (params[0]-v)*(v-1)*v - w;
        dw = params[4]*(params[1]*v-params[2]*w-params[3]);
        v += dv*dt;
        w += dw*dt;
        uneTrace-&gt;time[i] = t;
        uneTrace-&gt;value[i] = v;
        i++;
        t += dt;
    }
    uneTrace-&gt;nbpts = i+1;
    strcpy(uneTrace-&gt;comment, ""CommentaireDeLaTrace"");
}
</code></pre>
",2
52851603,52851455,28,"<p>Your piece of code could be written like this which makes it clearer:</p>

<pre><code>struct card {          // define the struct card
    char *face;
    char *suit;
 };

struct card aCard;     // declare a variable ""aCard"" of type ""struct card ""
struct card deck[52]   // declare an array of 52 variables of type ""struct card""
struct card *cardPtr;  // declare a variable ""cardPtr"" of type ""pointer to struct card""
</code></pre>
",0
52851510,52851455,74,"<p>You are mixing things up. A <code>struct card</code> has the members <code>face</code> and <code>suit</code>. But there are three variables using the <code>struct card</code> type, namely <code>aCard, deck, cardPtr</code>.</p>

<p>Alternatively one could have written:</p>

<pre><code>typedef struct {
    char *face;
    char *suit;
} Card;

Card aCard, deck[52], *cardPtr;
// or even
Card aCard;
Card deck[52];
Card *cardPtr;
</code></pre>

<p>For the <code>typedef</code> have a look at: <a href=""https://stackoverflow.com/questions/252780/why-should-we-typedef-a-struct-so-often-in-c"">Why should we typedef a struct so often in C?</a> (It goes into the <code>typedef struct { ... } Foo;</code> vs <code>struct Foo {...}</code> debate).</p>
",1
57898914,57898268,1,"<p>The loop condition should be:</p>

<pre><code>while( fgets(store,sizeof store, fp) != NULL )
</code></pre>

<p>There is no reason to also check feof at this point. If end of file was reached but some characters were read then you do want to process the string anyway. </p>

<p>You could check <code>feof</code> after the loop to determine whether input failed due to a read error, or due to the end of the file. </p>
",0
50892948,50892824,0,"<p>You are not initializing <code>j</code></p>

<pre><code>   sprintf(c, ""%d"", n[i]);
   leds = 0; //where the numbers of leds needed will be armazened
</code></pre>

<p>should be</p>

<pre><code>   sprintf(c, ""%d"", n[i]);
   j = 0;
   leds = 0; //where the numbers of leds needed will be armazened
</code></pre>
",0
52529679,52528783,0,"<p>The trick you're looking for is that <code>fread</code> returns the number of <strong><em>items</em></strong> read. You're reading 1 buffer full so it will only tell you that you read 0 or 1 buffers. Instead, flip it and reverse it: <strong><em>read a buffer's worth of bytes</em></strong>.</p>

<pre><code>size_t bytes_read = fread(buffer, 1, sizeof(Buffer)-12, fd);
</code></pre>

<p>Now you can know how many bytes were read into your buffer. We can add a <code>size</code> field to the <code>Buffer</code> so each buffer can remember how many bytes it read and only print that many.</p>

<pre><code>const size_t BUFFER_SIZE = 1024;

typedef struct Buffer {
    // I'll explain why I switched to a pointer in a moment
    unsigned char *data;
    size_t size;
    struct Buffer *next;
} Buffer;

void Buffer_print( Buffer *buffer ) {
    for( size_t i = 0; i &lt; buffer-&gt;size; i++ ) {
        printf(""%02hhX "", buffer-&gt;data[i]);
    }
}

Buffer *Buffer_new() {
    Buffer *buffer = malloc(sizeof(Buffer));

    buffer-&gt;size = 0;
    buffer-&gt;data = NULL;
    buffer-&gt;next = NULL;

    return buffer;
}
</code></pre>

<p>Note that I'm careful to initialize all the fields of the buffer, else we risk getting garbage.</p>

<p>Now we've changed our buffer, so our assumption about its size and position is broken. That's ok, we should be reading straight into <code>buffer-&gt;data</code> anyway.</p>

<pre><code>size_t Buffer_read( Buffer *buffer, size_t buffer_size, FILE* fp ) {
    buffer-&gt;data = malloc(buffer_size);
    size_t bytes_read = fread(buffer-&gt;data, 1, buffer_size, fp);
    buffer-&gt;size = bytes_read;
    return bytes_read;
}
</code></pre>

<p>Now that the buffer knows how much data its read, we can allocate any size of the data as we like. There's no need to hard code that into the struct. This makes the code more flexible and efficient. It lets us cheaply allocate empty buffers and that will make things much simpler.</p>

<p>We can also get away with using <code>malloc</code> and leaving <code>buffer-&gt;data</code> initialized with garbage. If <code>fread</code> only partially fills <code>buffer-&gt;data</code> the rest will remain garbage. That's ok, knowing the size of the data we've read means we stop printing before we hit garbage.</p>

<hr>

<p>Now we can construct our loop. When it's read 0 bytes we know it's done reading.</p>

<pre><code>while( Buffer_read( buffer, BUFFER_SIZE, fp ) &gt; 0 ) {
    ... now what ...
}
fclose(fp);
</code></pre>

<p>The way a linked list works, when you add to the list you add to <code>tail-&gt;next</code> and make that the new tail. This is often called ""pushing"".</p>

<pre><code>Buffer *Buffer_push( Buffer *tail, Buffer *new_tail ) {
    tail-&gt;next = new_tail;
    return new_tail;
}

Buffer *head = Buffer_new();
Buffer *tail = head;
while( Buffer_read( tail, BUFFER_SIZE, fp ) &gt; 0 ) {
    tail = Buffer_push( tail, Buffer_new() );
}
fclose(fp);
</code></pre>

<p>Note that we start with an empty <code>head</code> which is also the <code>tail</code>. Starting with these both allocated makes the loop much simpler. There's no need to check <code>if( head )</code> or <code>if( tail )</code>. It does mean that we always have an empty buffer on the end of our list. That's ok. Since we're no longer using a fixed <code>buffer-&gt;data</code> empty buffers are now tiny and cheap.</p>

<hr>

<p>The final step is to print everything. We can already print a single buffer, so we just need to walk the linked list and print each buffer.</p>

<pre><code>void Buffer_print_all( Buffer *head ) {
    for( Buffer *buffer = head; buffer != NULL; buffer = buffer-&gt;next ) {
        Buffer_print(buffer);
    }
}

Buffer_print_all(head);
</code></pre>

<p>That final, empty buffer hanging off the end is fine. It knows its size is 0 so <code>Buffer_print</code> won't actually use the null <code>buffer-&gt;data</code>.</p>
",2
52528987,52528783,2,"<p>You have several problems.</p>

<p>(1) <code>fread</code> returns the number of items read, but it will not return an <code>eof</code> indication.  You need to call <code>feof(stream*)</code> to find out if you've reached the end of file.</p>

<p>(2) You are saying your next pointer is 12 bytes.  This is a very dangerous assumption.  Prefer to read the 1012 bytes you've allocated to the data struct.  In all likelihood you are currently printing stuff that wasn't read in, but is just uninitialized memory.</p>

<p>(3) Use the return value from <code>fread</code> to decide how much memory to copy.</p>
",3
52529284,52528783,1,"<p>Please see the comments in the code below - also consider changing the 1012 to use a #define. </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct Buffer{
  unsigned char data[1012];
  struct Buffer *next; //12 bytes
}Buffer;

// Create a structure to store stuff about a file

typedef struct {
   Buffer *head;
   Buffer *tail;
   size_t length;
} MyFile;

/*
void mymemcpy(void *dest, void *src, size_t length){
  Buffer *buffer_toFill = (Buffer *)dest;
  Buffer *buffer_toAdd = (Buffer *)src;
  int a = 0; 
  for(int i = 0; i &lt; length; i++){
    buffer_toFill-&gt;data[i] = buffer_toAdd-&gt;data[i];
  }
}

Buffer* add_buffer_front(Buffer *head, Buffer *read_buffer, int size){
  Buffer *new_buffer = malloc(sizeof(Buffer));
  mymemcpy(new_buffer, read_buffer, size);
  if(head != NULL){
    new_buffer-&gt;next = head;
  }
  return new_buffer;
}

*/

// Lets make this easier - The buffer has already been ""malloced"" once - why do it again

// And why are you reversing the file

// Perhaps 

void add_buffer(Buffer *to_be_added, MyFile *file, size_t extra_length) {
   if (file-&gt;tail) { // We have one item in the list
     file-&gt;tail-&gt;next = to_be_added;
   } else { // First buffer!
     file-&gt; head = to_be_added;
     file-&gt; tail = to_be_added;
   }
   to_be_added-&gt;next = NULL;  // This is always the case as it is the last one
   file-&gt;length += extra_length;
}

/*
void display_List(Buffer *head, size_t length){
  Buffer *current = head;
  while(current != NULL){
    for(int i = 0; i &lt; length; i++){
      printf(""%02X"",(unsigned)current-&gt;data[i]); //this shows different value compare with  xxd &lt;filename&gt;
      //printf(""%c"", current-&gt;data[i]);  
    }
    Buffer *prev = current;
    free(prev);
    current = current-&gt;next;
  }
}

*/

// Instead pass in the new structure

void display_list(MyFile *file) {
   size_t contents_left = file -&gt; length;
   Buffer * current = file -&gt; head;
   while (current) {
      // At most each chunk has 1012 bytes - Check for that
      size_t chunk_length = contents_left &gt; 1012 ? 1012 : contents_left;
       for(int i = 0; i &lt;chunk_length ; i++){
         printf(""%02X"",(unsigned)current-&gt;data[i]);
       }
       current = current -&gt; next;
   }
}


}
int main(int argc, char **argv){
  FILE *fd;
  MyFile read_file;
  read_file.head = NULL;
  read_file.tail = NULL;
  read_file.length = 0;

  Buffer *head_buffer = NULL;
  int file_length = 0;
  int eof_int = 1;
  if(argc != 2){
    printf(""Usage: readFile &lt;filename&gt;\n"");
    return 1; 
  }

  fd = fopen(argv[1], ""rb"");

  // Check fd
  if (fd == NULL) {
    // error stuff
    return EXIT_FAILURE; // Look up the include for this
 }
  while(eof_int != 0){ 
    Buffer *new_buffer = malloc(sizeof(Buffer));
    eof_int = fread(new_buffer-&gt;data, 1012, 1, fd); // Do not make assumptions on the size of a pointer and store it in the correct location
    if(eof_int == 0) { // Read nothing
       free(new_buffer); // We was too optimistic! Did Not need this in the end 
       break;
    } else {
      add_buffer(&amp;read_file, new_buffer, eof_int);
    }
  }
  display_List(&amp;read_file);
  fclose(fd);
  return 0;
}
</code></pre>
",0
51108768,51108711,7,"<p>A tab-stop is not a fixed-width space (e.g. the same as 4 spaces or 8 spaces), it means that the output device should move the caret (or print-head) to the next column position for tabular data. These column positions are at fixed regular intervals, that's why <code>\t**</code> and <code>**\t</code> have different printed widths:</p>

<pre><code>String        Output:
""\t**a""       ""    **a"" (7 wide)
""**\ta""       ""**  a""   (5 wide)
</code></pre>
",1
51109088,51108711,3,"<p>As others have mentioned, printing a tab character move the cursor to the next tab stop, not a certain number of spaces.</p>

<p>After printing the first set of asterisks, print spaces until you've printed enough characters to space out as far as you need.</p>

<pre><code>    for (int j = 1; j &lt;= 10; j++)
    {
        if (j&lt;i) {
            printf(""*"");
        } else {
            printf("" "");
        }
    }
</code></pre>
",0
54413386,54413352,5,"<p>Wraparound for unsigned char (essentially a byte) is by design.</p>

<p>Your second example, however, is adding two ints.  Converting from 256 in an int to zero in a byte constitutes loss of information; hence the warning.</p>
",2
53135204,53133901,2,"<p>Prior to the 1989 ANSI C standard, the only way to define a function in C did not specify the number and types of any parameters. (This old version of the language is called ""K&amp;R C"", since it's described in the first edition of The C Programming Language by Kernighan and Ritchie.) You're using an old-style function definition:</p>

<pre><code>void func(a)
{
    printf(""%d\n"", a);
}
</code></pre>

<p>Here <code>a</code> is the name of the parameter. It is implicitly of type <code>int</code>, but that information is not used in determining the correctness of a call to <code>func</code>.</p>

<p>C89 added <em>prototypes</em>, which allow you to specify the types of parameters in a way that is checked when the compiler sees a call to the function:</p>

<pre><code>void func(int a)
{
    printf(""%d\n"", a);
}
</code></pre>

<p>So in the 1989 version of the C language, your program is legal (in the sense that there are no errors that need to be diagnosed at compile time), but its behavior is undefined. <code>func</code> will probably grab whatever value happens to be in the location in which it expects the caller to place the value of the argument. Since no argument was passed, that value will be garbage. But the program could in principle do literally anything.</p>

<p>The 1999 version of the language dropped the ""implicit <code>int</code>"" rule, so <code>a</code> is no longer assumed to be of type <code>int</code> even with the old-style definition.</p>

<p>But even the latest 2011 version of C hasn't dropped old-style function definitions and declarations. But they've been officially obsolescent since 1989.</p>

<p>Bottom line: Always use prototypes. Old-style function definitions and declarations are still legal, but there is never (or very rarely) any good reason to use them. Unfortunately your compiler won't necessarily warn you if you use them accidentally.</p>

<p>(You're also using an old-style definition for <code>main</code>. <code>int main()</code> is better written as <code>int main(void)</code>. This is less problematic than it is for other functions, since <code>main</code> is not normally called, but it's still a good habit.)</p>
",0
53133975,53133901,2,"<p>Your program is invalid.</p>

<p>gcc 8.2 complains:</p>

<pre><code>$ gcc -Wall -Wextra -pedantic -std=c17 t.c
test.c: In function ¡®func¡¯:
test.c:3:6: warning: type of ¡®a¡¯ defaults to ¡®int¡¯ [-Wimplicit-int]
 void func(a)
</code></pre>

<p>Since C99, all functions require their arguments to have valid types (there used to be <a href=""https://stackoverflow.com/questions/8220463/c-function-calls-understanding-the-implicit-int-rule"">""implicit int""</a> rule - function argument/return types are assumed <code>int</code> if not specified). But your program is not valid in C89 either because you don't actually pass any argument. So what you see is the result of <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behaviour</a>.</p>
",0
53135204,53133901,2,"<p>Prior to the 1989 ANSI C standard, the only way to define a function in C did not specify the number and types of any parameters. (This old version of the language is called ""K&amp;R C"", since it's described in the first edition of The C Programming Language by Kernighan and Ritchie.) You're using an old-style function definition:</p>

<pre><code>void func(a)
{
    printf(""%d\n"", a);
}
</code></pre>

<p>Here <code>a</code> is the name of the parameter. It is implicitly of type <code>int</code>, but that information is not used in determining the correctness of a call to <code>func</code>.</p>

<p>C89 added <em>prototypes</em>, which allow you to specify the types of parameters in a way that is checked when the compiler sees a call to the function:</p>

<pre><code>void func(int a)
{
    printf(""%d\n"", a);
}
</code></pre>

<p>So in the 1989 version of the C language, your program is legal (in the sense that there are no errors that need to be diagnosed at compile time), but its behavior is undefined. <code>func</code> will probably grab whatever value happens to be in the location in which it expects the caller to place the value of the argument. Since no argument was passed, that value will be garbage. But the program could in principle do literally anything.</p>

<p>The 1999 version of the language dropped the ""implicit <code>int</code>"" rule, so <code>a</code> is no longer assumed to be of type <code>int</code> even with the old-style definition.</p>

<p>But even the latest 2011 version of C hasn't dropped old-style function definitions and declarations. But they've been officially obsolescent since 1989.</p>

<p>Bottom line: Always use prototypes. Old-style function definitions and declarations are still legal, but there is never (or very rarely) any good reason to use them. Unfortunately your compiler won't necessarily warn you if you use them accidentally.</p>

<p>(You're also using an old-style definition for <code>main</code>. <code>int main()</code> is better written as <code>int main(void)</code>. This is less problematic than it is for other functions, since <code>main</code> is not normally called, but it's still a good habit.)</p>
",0
53133975,53133901,2,"<p>Your program is invalid.</p>

<p>gcc 8.2 complains:</p>

<pre><code>$ gcc -Wall -Wextra -pedantic -std=c17 t.c
test.c: In function ¡®func¡¯:
test.c:3:6: warning: type of ¡®a¡¯ defaults to ¡®int¡¯ [-Wimplicit-int]
 void func(a)
</code></pre>

<p>Since C99, all functions require their arguments to have valid types (there used to be <a href=""https://stackoverflow.com/questions/8220463/c-function-calls-understanding-the-implicit-int-rule"">""implicit int""</a> rule - function argument/return types are assumed <code>int</code> if not specified). But your program is not valid in C89 either because you don't actually pass any argument. So what you see is the result of <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behaviour</a>.</p>
",0
55287896,55286110,2,"<p>Are you really sure you want this?</p>

<pre><code>struct decl1 {
    struct decl2 (*function2)();
};

struct decl2 {
    struct decl3 (*function3)();
};

void function3()
{
}

struct decl2 function2()
{
    // ...
    struct decl2 one { function3 };
    return one;
}

struct decl1 function1()
{
    // ...
    struct decl1 one { function2 };
    return one;
}
</code></pre>

<p>But you can't bind any arguments so there is no way for <code>function2</code> to operate on the same object as <code>function</code> unless you pass it again.</p>

<p>If you're willing to dive into a little bit of assembly you can make this work by writing function bodies to the structs. Don't do this. The maintenance programmer will hate your guts.</p>
",0
51057493,51055250,1,"<p>As pointed in comments, you have two problems:</p>
<ul>
<li>Usage of <code>printf</code> instead of <code>sprintf</code>,</li>
<li>Writting to file what you've counted.</li>
</ul>
<h1>Name Creation</h1>
<pre><code>char name = printf(&quot;%s.rle&quot;, argv[1]);
destination = fopen(&amp;name, &quot;wb&quot;);
</code></pre>
<p>The first line will store the number of characters in <code>argv[1]</code> plus 4 into <code>name</code>. Since, from <a href=""https://linux.die.net/man/3/printf"" rel=""nofollow noreferrer""><code>man printf</code></a>:</p>
<blockquote>
<p>Upon successful return, these functions return the number of characters printed (excluding the null byte used to end output to strings).</p>
</blockquote>
<p>The second line is more problematic : you ask <code>fopen</code> to open a file giving it a pointer to char instead of a read string.</p>
<p>One correct way to do what you want is:</p>
<pre><code>/* reserve memory to store file name
   NOTE: 256 here might not large enough*/
char name[256];
/* fill name array with original name + '.rle' 
   The return of sprintf is tested to assert that its size was enough */    
if (snprintf(name, sizeof name, &quot;%s.rle&quot;, argv[1]) &gt;= sizeof name)
{
    fprintf(stderr, &quot;name variable is not big enough to store destination filename&quot;);
}
       
</code></pre>
<h1>Writting to file</h1>
<p>The code</p>
<pre><code>char str[BUF_SIZE];
fwrite(str, sizeof(str), 1, destination);
     
</code></pre>
<p>reserve a big array, and writes it to file, without initializing it. To do what you want, you can have this approach:</p>
<ul>
<li>make a function that will only write two characters in file: the number of character found and the character itself</li>
<li>call this function each time needed (at character changing, but not when one of character is EOF...)</li>
</ul>
<p>Let's look at :</p>
<pre><code>void write_char_to_file(FILE *f, int count, char car)
{
    /* char array to be stored in file */
    char str[2];   
    /* number of repeating characters */
    str[0] = count;
    /* the character */
    str[1] = car;
    /* write it to file */
    fwrite(str, sizeof str, 1, f);    
}
</code></pre>
<p>This function has two potential problems:</p>
<ul>
<li>It doesn't handle <code>char</code> overflow (what if <code>count</code> is over 256?),</li>
<li>It doesn't test the return of <code>fwrite</code>.</li>
</ul>
<p>Then, when this function should be called, when the current character changes:</p>
<pre><code>EOF?A A B C C EOF
</code></pre>
<p>In this example, we have 4 characters changes, but we want only 3 writting in the file, so:</p>
<ul>
<li>Character changing when previous is EOF must be ignored (else we would write something like <code>0 (char)EOF</code> at file starting),</li>
<li>One writting must be added after <code>while</code> loop since, when the last reading gives <code>EOF</code>, we still have <code>2 C</code> to write to file.</li>
</ul>
<p>Let's look at the code:</p>
<pre><code>while((current_character = fgetc(source)) != EOF) {
    if(current_character != previous_character) { 
        /* ignore initial change */            
        if (previous_character != EOF) {  
            write_char_to_file(destination, repeat_count, previous_character);
        }
        previous_character = current_character;
        repeat_count = 1;
    } else {
        repeat_count++;
    }
}
/* write last change */
write_char_to_file(destination, repeat_count, previous_character);
</code></pre>
<p>This code have a problem too: what if the input file is empty? (first read gives <code>EOF</code>)</p>
<hr />
<p>The complete code:</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#define BUF_SIZE 5096

void write_char_to_file(FILE *f, int count, char car)
{
    /* char array to be stored in file */
    char str[2];   
    /* number of repeating characters */
    str[0] = count;
    /* the character */
    str[1] = car;
    /* write it to file */
    fwrite(str, sizeof str, 1, f);    
}

void compress_file(FILE *source, FILE *destination)
{
    int repeat_count = 0;
    int previous_character = EOF;
    int current_character;

    while((current_character = fgetc(source)) != EOF) {
        if(current_character != previous_character) {            
            if (previous_character != EOF) {  
                write_char_to_file(destination, repeat_count, previous_character);
            }
            previous_character = current_character;
            repeat_count = 1;
        } else {
            repeat_count++;
        }
    }
    write_char_to_file(destination, repeat_count, previous_character);
}

int main(int argc, char **argv) {
    if(argc != 2) {
        fprintf(stderr, &quot;Wrong argument number\n&quot;);
        exit(1);
    } 

    FILE *source = fopen(argv[1], &quot;rb&quot;);
    if(source == NULL) {
        fprintf(stderr, &quot;Cannot open the file to be read\n&quot;);
        exit(1);
    }

    FILE *destination;
    /* reserve memory to store file name
       NOTE: 256 here might not large enough*/
    char name[256];
    /* fill name array with original name + '.rle' 
       The return of sprintf is tested to assert that its size was enough */    
    if (snprintf(name, sizeof name, &quot;%s.rle&quot;, argv[1]) &gt;= sizeof name)
    {
        fprintf(stderr, &quot;name variable is not big enough to store destination filename&quot;);
    }
    
    /* while is not needed here, if do the job */
    if((destination = fopen(name, &quot;wb&quot;)) == NULL) {
        fprintf(stderr, &quot;Can't create the file to be written\n&quot;);
        exit(1);
    }
    
    compress_file(source, destination);
    
    int error;
    error = fclose(source);
    if(error != 0) {
        fprintf(stderr, &quot;Error: fclose failed for source file\n&quot;);
    }
    error = fclose(destination);
    if(error != 0) {
        fprintf(stderr, &quot;Error: fclose failed for destination file\n&quot;);
    }
    
    /* main must return a integer */
    return 0;
}
</code></pre>
",2
53162595,53160622,1,"<p>To expand on Osiris' answer a bit...</p>

<p><code>printf</code> is what is known as a <em>variadic</em> function - it takes a variable number of arguments.  The function prototype looks like this:</p>

<pre><code>int printf( const char * restrict format, ... );
</code></pre>

<p>This means that the function takes one fixed parameter (<code>format</code>) and then some unknown number (zero or more) additional parameters.  Now, here's the problem - the only way <code>printf</code> knows that there are additional arguments and what their types are is by what you specify in the <code>format</code> string.  <code>printf</code> doesn't know - it <em>can't</em> know - what you actually pass in the argument list.  It only knows what you <em>claim</em> will be in the argument list based on the conversion specifiers you use in the format string.  </p>

<p>If you write</p>

<pre><code> printf( ""%f\n"", 1.0, 2, ""3"", '4', 5.0 );
</code></pre>

<p>then as far as <code>printf</code> is concerned, you only passed the single additional <code>double</code> argument <code>1.0</code>.  Even though you passed 5 arguments after the format string, <code>printf</code> looks at that single <code>%f</code> and concludes there's only a single additional argument.  Note that this particular situation is well-defined - the additional arguments are evaluated, but otherwise ignored.  This is ""safe"" in the sense that the behavior of your code here is predictable.  </p>

<p>If you write</p>

<pre><code>printf( ""%f\n"" );
</code></pre>

<p>then you have a problem, because <code>printf</code> assumes there's an additional <code>double</code> argument, <em>and it will go looking for it</em> (either in a register or on the stack, depending on the calling convention).  In this case, the behavior is <em>undefined</em> - the end result can be anything, from garbage output to an outright crash.  </p>

<p>If you write</p>

<pre><code>printf( ""%f\n"", 5 / 2 ); // int / int == int 
</code></pre>

<p>you have one of two problems.  If function arguments are passed by registers, then you have the same problem as above (integer arguments are typically passed in a different set of registers than floating point arguments, so <code>printf</code> will look in the wrong register).  If function arguments are passed via stack, then <code>printf</code> will grab the next <code>sizeof (double)</code> bytes off of the stack and interpret them as a <code>double</code>.  In this case, the problem is that the representation of <code>int</code> and <code>double</code> can be <em>radically</em> different.  In a 32-bit <code>int</code>, <code>2</code> is typically represented as <code>0x00000002</code>.  In a 64-bit <code>double</code> (assuming IEEE-754 representation), <code>2.0</code> is represented as <code>0x4000000000000000</code>.  Again, this behavior is <em>undefined</em> - you can't trust any result you get.  </p>
",0
58004507,58004434,1,"<p>(Note: We usually number things starting from 0 in computer science, so I've interpreted your requirements from a zero-based mindset.)</p>

<p>Use a combination of masking and shifting. For example, if you want to be able to recover the NetworkModule value, create a mask that has 1-bits in the positions you want, and 0-bits everywhere else:</p>

<pre><code>#define NetworkModuleMask 0x3E00  // that is, 0011 1110 0000 0000
</code></pre>

<p>Now you can use that to mask out the unwanted bits using bitwise AND:</p>

<pre><code>int address = 0x1144;
int networkModule = address &amp; NetworkModuleMask
</code></pre>

<p>Another way to do it, which is essentially equivalent, is to use division and modulo operators with powers of 2. For example, your NetworkGroup is the </p>

<p>Then, to interpret the value as a number, you'll want to shift it right by 9 bits:</p>

<pre><code>#define NetworkModulePosition 9
networkModule = networkModule &gt;&gt; NetworkModulePosition
</code></pre>

<p>You can use a similar process to construct an address using component values: shift each part into position and then bitwise OR it into the address.</p>

<p>You can also approach the problem arithmetically, using division and modulo operators with powers of 2. Dividing an integer by a power of 2 is the same as shifting it to the right by some number of bits, and modulo by a power of 2 is the same as shifting some number of bits to the right and then clearing some number of bits on the left, so you end up doing pretty much what we did above. For example, your <code>NetworkGroup</code> value is the low 8 bits of the address, so you can recover it by taking the address mod 2^^8, or 256. The <code>NetworkType</code> is the highest 2 bits, and you can recover that by dividing the address by 2^^14, or 16384.</p>
",9
53270556,53270524,3,"<pre><code>#define COLSIZE 4
#define ROWSIZE 5
void creatGameMatrix(int* mat,  int ROWSIZE , int COLSIZE);
</code></pre>

<p>This makes no sense. It expands to</p>

<pre><code>void creatGameMatrix(int* mat,  int 5, int 4);
</code></pre>

<p>Which is clearly not right (specifically function argument names must be identifiers and <code>4</code> and <code>5</code> are not identifiers). Options are either:</p>

<ol>
<li>Don't pass parameters and use the #defines inside the routine</li>
<li>Name the parameters like <code>rowsize</code> and <code>colsize</code> and use those in the routine. Pass the values in using the <code>ROWSIZE</code> and <code>COLSIZE</code> defines. </li>
</ol>
",0
53270581,53270524,2,"<p>You can't use these macros as the names of function parameters. After the macros are expanded, you end up with:</p>

<pre><code>void creatGameMatrix(int* mat,  int 5 , int 4);
void shuffleMatrix(int* mat, int 5 , int 4);
</code></pre>

<p>That makes no sense -- function parameters have to be valid variable names, not numbers.</p>

<p>Use different names for the function parameters, and then use the macros when you call the functions.</p>

<pre><code>void creatGameMatrix(int* mat,  int rowsize , int colsize);
void shuffleMatrix(int* mat, int rowsize , int colsize);
</code></pre>

<p>Or you can simply omit these parameters entirely:</p>

<pre><code>void creatGameMatrix(int* mat);
void shuffleMatrix(int* mat);
</code></pre>
",1
53247393,53247368,1,"<p>You're not setting the <code>c</code> variable. I suspect this line:</p>

<pre><code>userString[i] = *c;
</code></pre>

<p>should be something like:</p>

<pre><code>c = userString + i;
</code></pre>
",1
56865812,56865630,3,"<p>Even if you specify that you want only 2 strings in the <code>scanf</code> call, the other string remains in the buffer when you pass 3 strings, you need to flush/consume it:</p>

<pre><code>while (scanf(""%9s %9s"", r, y) == 2) { // No need to use a space before first %10s
    int c;                            // and you need space for the NUL terminator
    while ((c = fgetc(stdin)) != '\n' &amp;&amp; c != EOF);
    printf(""%s and %s\n"", r, y);
}
</code></pre>
",2
56865812,56865630,3,"<p>Even if you specify that you want only 2 strings in the <code>scanf</code> call, the other string remains in the buffer when you pass 3 strings, you need to flush/consume it:</p>

<pre><code>while (scanf(""%9s %9s"", r, y) == 2) { // No need to use a space before first %10s
    int c;                            // and you need space for the NUL terminator
    while ((c = fgetc(stdin)) != '\n' &amp;&amp; c != EOF);
    printf(""%s and %s\n"", r, y);
}
</code></pre>
",2
54008601,54006966,1,"<p>I've found this a good exercise for myself =D
Pieces of suggestions:</p>

<ul>
<li>A state machine can help with getting the input</li>
<li>In this case (calculator), a linked list should be sufficient to facilitate multiple operations</li>
<li>fill the list up as you gather inputs, and then empty the list in the order of the operator priority</li>
</ul>

<p>I tried put together some code, hope it is of help. Have not get the chance to compile and test though.</p>

<pre><code> #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;

#define MAX_INPUT_SIZE 1000;
struct Node
{
    char operator;
    int result;
    struct Node* left;
    struct Node* right;
};

enum InputState{
    START = 0,
    NUMBER,
    OPERATOR
    };

void pushNodeToList( struct Node**head, struct Node**tail, char op, int result)
{
    struct Node* nodePtr = malloc(sizeof(*nodePtr));
    nodePtr-&gt;operator = op;
    result = result;
    if(!head)
    {
        *head = nodePtr;
        *tail = nodePtr;
        nodePtr-&gt;left = 0;
        nodePtr-&gt;right = 0;
    }
    else{
        nodePtr-&gt;left = *tail;
        (*tail)-&gt;right = nodePtr;
        *tail = nodePtr;
    }
}

void calculateNode( struct Node* nodePtr)
{
    if(nodePtr-&gt;left != 0 &amp;&amp; nodePtr-&gt;right != 0)
    {
        if(nodePtr-&gt;left-&gt;operator == 'n' &amp;&amp; nodePtr-&gt;right-&gt;operator == 'n' )
        {
            //calculate result
            switch(nodePtr-&gt;operator)
            {
                case '+':
                    nodePtr-&gt;result = nodePtr-&gt;left-&gt;result + nodePtr-&gt;right-&gt;result;
                    break;
                case '-':
                    nodePtr-&gt;result = nodePtr-&gt;left-&gt;result - nodePtr-&gt;right-&gt;result;
                    break;
                case '*':
                    nodePtr-&gt;result = nodePtr-&gt;left-&gt;result * nodePtr-&gt;right-&gt;result;
                    break;
                default:
                    printf(""Calculation Error: %d \n"", 5);
                    return;

            }
            //change type of node to 'n'
            nodePtr-&gt;operator == 'n';

            //reduce the numbers consumed
            struct Node* tempLeft = nodePtr-&gt;left;
            struct Node* tempRight = nodePtr-&gt;right;
            nodePtr-&gt;left = tempLeft-&gt;left;
            nodePtr-&gt;right = tempRight-&gt;right;
            free(tempLeft);
            free(tempRight);
        }
        else
        {
            printf(""Calculation Error: %d \n"", 4);
            return;
        }
    }
    else{
        printf(""Calculation Error: %d \n"", 3);
        return;
    }
}

int main(void) {

int ch;
struct Node* head = 0;
struct Node* tail = 0;

//have a state machine to handle the logics related to parsing input
int num = 0;
enum InputState mState = START;

int i = 1;
while ((ch = getchar()) != EOF)
{
    switch(mState)
    {
        case START:
            if (ch &gt;= '0' &amp;&amp; ch &lt;= '9'){
                mState = NUMBER;
                num = 0;
                //initialize state to number
            }
            else if(ch == '+' || ch == '-' || ch == '*'){
                mState = OPERATOR;
                //initilize state to operator
            }
            else{
                //your error code
                printf(""Input Error: %d \n"", 1);
                return 0;
            }
        break;
        case NUMBER:
            if (ch &gt;= '0' &amp;&amp; ch &lt;= '9'){
                num = num * 10 + ch - '0';
            }
            else if(ch == '+' || ch == '-' || ch == '*'){
                mState = OPERATOR;
                //we just got a number recorded
                pushNodeToList(&amp;head,&amp;tail,'n',num);//'n' for number
            }
            else{
                printf(""Input Error: %d \n"", 2);
                return 0;
            }
        break;
        case OPERATOR:
            if (ch &gt;= '0' &amp;&amp; ch &lt;= '9'){
                mState = NUMBER;
                num = ch - '0';
            }
            else if(ch == '+' || ch == '-' || ch == '*'){
                pushNodeToList(&amp;head,&amp;tail,ch,0);//push in operator
            }
            else{
                printf(""Input Error: %d \n"", 3);
                return 0;
            }
        break;
    }
}
//terminal condition to push-in last number
if(mState == NUMBER)
{
    pushNodeToList(&amp;head,&amp;tail,'n',num);//'n' for number
}

//higher prioriety operation
struct Node* workingPtr = head;
while(workingPtr !=tail)//assuming the last input is number (not operator)
{
    if(workingPtr-&gt;operator == '*')
    {
        calculateNode(workingPtr);
    }
}
//lower prioriety operations
workingPtr = head;
while(workingPtr !=tail)
{
    if(workingPtr-&gt;operator == '+' || workingPtr-&gt;operator == '-' )
    {
        calculateNode(workingPtr);
    }
}
//print result
if(head == tail &amp;&amp; head-&gt;operator == 'n')
{
    printf(""Result : %d\n"", head-&gt;result);
}
else
{
    printf(""Error: %d \n"", 7);
    return 0;
}


return 0;
}
</code></pre>
",0
57266455,57266382,1,"<p><code>void (*s)()</code> and <code>void* s</code> are very different things. The first is a pointer to a <em>function</em> returning void (notice the round braces after the declaration), the second one is just a plain pointer to untyped data.</p>

<p>Think of the first pair of braces as a reading hint. ""s is a pointer to a function returning void"" instead of ""s is a pointer to void""</p>
",1
53365190,53361852,0,"<p>Several issues:</p>

<ol>
<li>You never assign a value to <code>sqrfeet</code>, so all your computations with <code>sqrfeet</code> are going to be bad.  You probably want a separate <code>scanf</code> statement to read that when you also read <code>amount</code>.

<li>Your <code>if</code> statements are using <code>=</code> (assignment) instead of <code>==</code> (comparison), which is re-assigning <code>a</code>.  Instead of <code>if ( a = 1 )</code> use <code>if ( a == 1 )</code>.

<li>While it¡¯s not the cause of your problem, avoid using <code>goto</code> when possible.  Your input loop can be better written as<pre><code>int a = -1; // initialize a to a known bad value
do
{
  // print menu options

  /**
   * Check the result of scanf - if it isn't 1, then the the
   * user entered non-numeric input.  Clear the bad input up
   * to the next newline before trying again.
   */
  if ( scanf(""%d"", &a ) != 1 )  
    while ( getchar() != '\n' )
      ; 

} while ( a &lt; 1 && a &gt; 3 );
</code></pre></ol>
",0
54613680,54612952,1,"<p>First off, "" ... conio.h is a C header file used mostly by MS-DOS compilers to provide console input/output. It is not part of the C standard library or ISO C ..""  I was able to get the code to compile without that library file, so you may wish to consider removing it.  As for as the code goes, well here is what I came up with:</p>

<pre><code>#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

int isPrime(int value) {
    int i = 2;
    for(; i &lt; value; i++) {
        if((value % i) == 0) {
            return 0;
        }
    }
    return value &gt; 1;
}

int main(void){

int n=0,i=0, r=0;
char * s;

printf(""\nPlase enter a number to learn if it is prime:"");
scanf(""%d"",&amp;n);
r = isPrime(n);

printf(""\n%d is "", n);
s = (r==0)?  "" not a prime number"" :  ""a prime number"";
puts(s);
return 0;
}
</code></pre>

<p>After the user inputs a number, the code checks whether it is prime by calling the function isPrime(), a function that returns an int. isPrime is a simple function that attempts to factor a number.  </p>

<p>See here for similar <a href=""http://tpcg.io/W0EyVu"" rel=""nofollow noreferrer"">live code</a> that I devised.</p>
",0
58110580,58110168,0,"<p>You can use <code>select()</code> with a zero (not NULL) timeout to check if data is available, and only then call scanf.</p>

<p>Example (without correct error handling):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/select.h&gt;

int main()
{
    int x;
    fd_set fds;
    struct timeval tv = { .tv_sec = 0, .tv_usec = 0 };

    while (1) {
        FD_ZERO(&amp;fds);
        FD_SET(0, &amp;fds);  // Watch stdin (fd 0)
        if (select(1, &amp;fds, NULL, NULL, &amp;tv)) {
            scanf(""%d"", &amp;x);
            printf(""Got %d from stdin"", x);
        }

        printf(""Working..\n"");
        sleep(1);
    }
}
</code></pre>
",7
53505134,53505080,2,"<p>Your code is not wrong but has just a very unusual formatting. Normally you put the line breaks <em>after</em> the <code>;</code> and not before.</p>

<p>Your code should look like this:</p>

<pre><code>#include &lt;unistd.h&gt;

int main()
{
    char a = 'a';

    while (a &lt;= 'z')
    {
        write(1, &amp;a, 1);
        a++;
    }    
    return 0;
}
</code></pre>

<p>BTW: you should not put the return values between () like you did here <code>return (0);</code> but you should write simply <code>return 0;</code>. Putting () is not wrong, but unnecessary nd it makes it look like a function call.</p>

<p>Line breaks are not necessary for a C program you could write this and it would compile:</p>

<pre><code>#include &lt;unistd.h&gt;
int main() {char a = 'a';while (a &lt;= 'z'){
write(1, &amp;a, 1);a++;} return 0;}
</code></pre>

<p>This code snippet, my previous code snippet and <em>your</em> code snippet are equivalent.</p>
",6
53505280,53505080,7,"<p>You simply forgot the semicolons at the end of the previous line, and fixed it by putting it at the beginning of the next line.</p>

<p>C doesn't actually care about where your semicolons are, as long as they are between statements; It doesn't care where new lines are:</p>

<p>Your code here   </p>

<pre><code>#include &lt;unistd.h&gt;

int     main()
{
    char a = 'a'
    ;while (a &lt;= 'z')
    {
        write(1, &amp;a, 1);
        a++;
    }    
    return (0)
;}
</code></pre>

<p>is the same as </p>

<pre><code>#include &lt;unistd.h&gt;

int     main()
{
    char a = 'a';
    while (a &lt;= 'z')
    {
        write(1, &amp;a, 1);
        a++;
    }    
    return (0);
}
</code></pre>

<p>and is also the same as:</p>

<pre><code>#include &lt;unistd.h&gt;

int main() { char a = 'a'; while (a &lt;= 'z') {write(1, &amp;a, 1); a++; } return (0);}
</code></pre>
",0
53505927,53505746,0,"<pre><code>l+1;
r-2;
</code></pre>

<p>Should both be:</p>

<pre><code>l+=1;
r-=2;
</code></pre>

<p>Here your script with slight modifications:</p>

<pre><code>#include &lt;stdio.h&gt;
// v-shape
// gcc -Os -Wall -o 53505746 53505746.c

int main() {

    int l = 0;
    int r = 17;
    int y = 9;
    int x = 0;
    int z = 0;

    for (z=0; z&lt;y; z++) {

        for (x=0; x&lt;l; x++) {
            printf("" ""); // first space
        }

        printf(""****"");

        for (x=0; x&lt;r; x++) {
            printf("" ""); // second space
        }

        printf(""****"");
        printf(""\n"");
        l += 1;
        r -= 2;

    }

    return 0;
}
</code></pre>
",0
53505909,53505746,0,"<p>You are very close to solving this problem. Your error is here:</p>

<pre><code>l+1;
r-2;
</code></pre>

<p>Think about what happens when you use an operation like <code>+</code> or <code>-</code>... where does the result go?</p>
",1
53541139,53540199,6,"<p>As you seem to be in total control of the data, I rather recommend a different approach:</p>

<p>A specific separator character in between forename(s) and surname(s). Then you don't rely on case sensitivity any more, especially the single character name issue appearing in another answer isn't an issue any more.</p>

<p>Separator character should be one that won't ever appear in any name, such as a tab (in contrast to space) character, <code>#</code>, '|', ... Even comma or semicolon should be fine, though the period might appear in abbreviated names and thus should not be used.</p>
",3
53541602,53540199,0,"<p>If you're working with ASCII, here is a charset-specific trick that will help you:</p>

<pre><code>#define TWOUPPER(c0, c1) (!((c0) &amp; 32) &amp;&amp; !((c1) &amp; 32))
</code></pre>

<p>This will work even on single character last names since the null character will fail the 5th bit check, and single character middle names will not be taken as the last name since the following space will not succeed the test.</p>

<p>Works with the following test cases for me by comparing every two characters in the string and stopping on a match:</p>

<pre><code>    char test1[100] = ""Otto VON BISMARK"",
    test2[100] = ""Johannes Diderik VAN DER WAALS"",
    test3[100] = ""Vincent VAN GOGH"",
    test4[100] = ""Govind A B C D P""; // Only the ""P"" is counted as the last name here
</code></pre>
",0
53554412,53554363,0,"<p>First of all, you <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc/"">shouldn't really cast the result of <code>malloc</code></a>. Secondly, that <code>malloc</code> creates a memory leak since you immediately make the pointer variable <code>searcherNode</code> point somewhere else.</p>

<p>And that reassignment is probably what makes your program crash: Since <code>searcherNode</code> will not point to the memory you allocated with <code>malloc</code>, then the call to <code>free</code> will attempt to free something which should not be free'd. In fact, this will attempt to free the last node in the list, without removing it from the list.</p>

<p>If the memory for that last node was not allocated with <code>malloc</code> then you can't pass the pointer to <code>free</code> as that will lead to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>. If the memory was allocated with <code>malloc</code>, then your next attempt to dereference the last (now free'd) node will also lead to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>.</p>

<p>The simple solution: Don't call <code>malloc</code> and most importantly don't call <code>free</code>.</p>

<hr>

<p>What you do with </p>

<pre><code>Node * searcherNode = malloc(sizeof(Node));
searcherNode = listHead;
</code></pre>

<p>is in a way similar to</p>

<pre><code>int myValue = 10;
myValue = 5;
</code></pre>

<p>and then wondering why <code>myValue</code> is not equal to <code>10</code>.</p>
",3
55785818,55785744,0,"<blockquote>
  <p>... but i got an infinite loop.</p>
</blockquote>

<p>just replace</p>

<pre><code>    while (k != 1)
    {
        arr[i] = rand() % 75 + 1;
        for (j = 0; j &lt; 25; j++) {
          ...
        }
    }
    k = 0;
</code></pre>

<p>by</p>

<pre><code>do
{
  k = 0;
  arr[i] = rand() % 75 + 1;
  for (j = 0; j &lt; 25; j++) {
     ...
  }
} while (k != 1);
</code></pre>

<p>Note it is also useless to check looking at all the array including the entries not set by a random value, so can be :</p>

<pre><code>do
{
  k = 0;
  arr[i] = rand() % 75 + 1;
  for (j = 0; j &lt; i; j++)
  {
    if (arr[i] == arr[j])
    {
      k++;
    }
  }
} while (k != 0);
</code></pre>

<p>because now <em>j</em> cannot values <em>i</em> the test is <code>(k != 0)</code> rather than <code>(k != 1)</code></p>

<p>or better because when an identical value is found there is no reason to continue</p>

<pre><code>do
{
  arr[i] = rand() % 75 + 1;
  for (j = 0; j &lt; i; j++)
  {
    if (arr[i] == arr[j])
      break;
  }
} while (j != i);
</code></pre>

<hr>

<p>To see well the values also add a space between them and add a final newline:</p>

<pre><code>for (i = 0; i &lt; 25; i++)
{
    printf(""%d "", arr[i]);
}
putchar('\n');
</code></pre>

<p>AFter these changes, compilation and executions :</p>

<pre><code>pi@raspberrypi:/tmp $ gcc -pedantic -Wextra -Wall r.c
pi@raspberrypi:/tmp $ ./a.out
74 60 16 65 54 19 55 45 41 24 39 59 66 36 27 22 68 49 29 14 28 5 71 56 72 

pi@raspberrypi:/tmp $ ./a.out
16 34 62 29 74 41 3 43 69 17 61 22 28 59 7 65 5 46 60 20 66 14 49 54 45 

pi@raspberrypi:/tmp $ 
</code></pre>

<hr>

<p><strong>edit</strong></p>

<p>The implementation is simple but it can take time to find a not yet used value in that way, and the more the range of allowed values is closer to the number of values to return the higher the needed time is. So that solution is good when there are few values to return compared to the range of allowed values.</p>

<p>It is the reverse concerning the interesting proposal of Weather Vane, the number of call to <em>rand</em> is only equals to number of values to return, but the more the range of allowed values is large the more the array <em>bag</em> is large up to may be overflow the memory size. </p>

<p>Probably for 25 values from 1 to 75 the solution of Weather Vane is better ... even my proposal seems to need just 0.001 sec on my raspberry pi so almost nothing</p>
",0
53584983,53584918,0,"<p>The program is not putting a GPA into <code>gpa[0]</code>.</p>

<p>This is because the first <code>for()</code> loop is looping from 1 to &lt;= <code>N</code>.</p>

<pre><code>for (i = 1; i &lt;= n; i++)
    ...
    scanf_s(""%f"", &amp;gpa[i]);
</code></pre>

<p>This should probably be 0 -> <code>N-1</code>.  It's leaving <code>gpa[0]</code> with some random (undefined) value.</p>

<pre><code>for (i = 0; i &lt; n; i++)
</code></pre>

<p>The bug is because, when calculating the average, you compute from the <code>0th</code> element:</p>

<pre><code>for (i = 0; i &lt; n; i++)
</code></pre>

<p>If the loop constructs were both the same, it would probably be OK.</p>
",0
54009415,54009387,4,"<p>Prior to calling  <code>strtol</code>, set <code>errno</code> to 0.  </p>

<p>Then after the call, check the value of <code>errno</code>.  If it's 0, you know the call was successful.  Addtionally, you'll want to check if <code>*p</code> is 0.  If so, that means the entire string was parsed successfully with no extra characters.</p>

<pre><code>errno = 0;
long conv = strtol(argv, &amp;p, 10);  
if (errno)
{
    perror(""Conversion error"");
    exit(EXIT_FAILURE);
}
else if (*p)
{
    perror(""Not all characters converted"");
    exit(EXIT_FAILURE);
}
</code></pre>

<p>The <a href=""https://linux.die.net/man/3/strtol"" rel=""nofollow noreferrer"">man page</a> also mentions this in the ""Notes"" section:</p>

<blockquote>
  <p>Since strtol() can legitimately return 0, LONG_MAX, or LONG_MIN
  (LLONG_MAX or LLONG_MIN for strtoll()) on both success and failure,
  the calling
         program  should set errno to 0 before the call, and then determine if an error occurred by checking whether errno has a nonzero
  value after the
         call.</p>
</blockquote>
",4
53698294,53697475,2,"<p>Check your return from <code>mmap()</code>.</p>

<p>You tried to <code>mmap()</code> stdin. Barring exotic environments, stdin is some kind of terminal or pipe, neither of which support memory mapped IO.</p>

<p>Try this sample:</p>

<pre><code>int* createSharedMemory(size_t size) {
    int protection = PROT_READ | PROT_WRITE;
    int visibility = MAP_ANONYMOUS | MAP_SHARED;
    int *p = (int*)mmap(0, size, protection, visibility, -1, 0);
    if (p == (int*)(ptrdiff_t)-1) return NULL;
    return p;
}

arr = createSharedMemory(sizeof(int)*size);
if (arr == NULL) {
    perror(""mmap"");
    exit(3);
}
</code></pre>

<p>Incidentally, your read loop will explode if <code>sizeof(int) &lt; 4</code> which is unlikely.</p>
",0
48490525,48490501,4,"<p>You dereference it like any other pointer, with the unary <code>*</code> operator.</p>

<p>However you have to note that <a href=""http://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer""><em>operator precedence</em></a> will play a role here, since the array subscripting operator has higher precedence than the dereference operator. Therefore you have to do e.g.</p>

<pre><code>(*s.p)[x][y]
</code></pre>

<p>Furthermore you use the wrong format to print an integer. The <code>""%p""</code> format is to print an actual pointer, not an integer. Use <code>""%d""</code>.</p>

<hr>

<p>As an alternative, remember that arrays naturally decays to pointers to their first element. That means for your array <code>aa</code>, using it just like that will decay to <code>&amp;aa[0]</code>, which is of type <code>int (*)[2]</code>. That means you could make your variable the same type, and use plain <code>aa</code> in the initialization, and use it like a normal ""2d"" array:</p>

<pre><code>typedef struct
{
  int (*p)[2];
} S;

int main()
{
  int aa[2][2] = {{1, 2}, {3, 4}};
  S s = { .p = aa };  // Note: Not using the address-of operator here
  printf(""Four: %d\n"", s.p[1][1]);  // Using array-indexing works as expected here
  return 0;
}
</code></pre>
",2
55172208,55172052,5,"<p>You can use modulo and division like this. Note that the boundary must be changed too, otherwise the output will not be identical!</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {     
    for (int x = 0; x &lt; 20; x ++) {
        printf(""The integer is %d\n"", x / 5 * 5 + 4 - x % 5);
    }
}
</code></pre>

<p>If you think the code requires explanation then <em>your</em> version is better. At least in my opinion it is.</p>
",1
50074595,50074493,1,"<p>When you initialize the transpose matrix you do it like</p>

<pre><code>transpose_matrix1[j][i] = matrix1[i][j];
</code></pre>

<p>Note the order in which you use <code>j</code> and <code>i</code> in <code>transpose_matrix1[j][i]</code>.</p>

<p>Then when you print you use <code>transpose_matrix1[i][j]</code>. Note that the order of <code>j</code> and <code>i</code> have changed, even though the looping around both are the same. You need to use the same order for <code>j</code> and <code>i</code> in both loops.</p>
",0
54960888,54960717,1,"<p>Note: Isn't it Vigen¨¨re (not Vernam)?</p>

<p>If it's Vigen¨¨re you just have to define properly what is your input alphabet. Actually your code has input alphabet lowercased letters (a-z), so that the Vigen¨¨re code is something like:</p>

<pre><code> abcdefghijklmnopqrstuvwxyz
aabcdefghijklmnopqrstuvwxyz
bbcdefghijklmnopqrstuvwxyza
ccdefghijklmnopqrstuvwxyzab
...
</code></pre>

<p>Just add your digits anywhere you want in the code:</p>

<pre><code> abcdefghijklmnopqrstuvwxyz0123456789
aabcdefghijklmnopqrstuvwxyz0123456789
bbcdefghijklmnopqrstuvwxyz0123456789a
ccdefghijklmnopqrstuvwxyz0123456789ab
...
</code></pre>

<p>--- EDIT ---</p>

<p>You may need to add another small layer that lets you define your input alphabet. So define an array containing all the considered letter in a given order (choose one) say:</p>

<pre><code>Alphabet[] = ""0123456789abcdefghijklmnopqrstuvwxyz"";
</code></pre>

<p>Now imagine you have a function that given a letter will give you its rank in the alphabet : say <code>rank(l)</code>, for example <code>rank('b')=11</code>.</p>

<p>Now compute (there is no need for such structure but let's do it like you did) your permutations:</p>

<pre><code>Perms[][]
   00 01 02 03 04 05 .... 35
00 00 01 02 03 04 05 .... 35
01 01 02 03 04 05 .... 35 00
02 02 03 04 05 .... 35 00 01
...
</code></pre>

<p>Now for a given key letter <code>k</code> and a message letter <code>l</code> you can compute the enciphered letter <code>e</code> as:</p>

<pre><code>e = Alphabet[Perms[rank(l)][rank[k]]
</code></pre>
",7
55742746,55742421,5,"<p>Operator <code>+</code> has <a href=""https://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer"">higher precedence</a> than shift operators. You need to write:</p>

<pre><code>out[0] = (in[0]&lt;&lt;2) + (in[1]&gt;&gt;2);
</code></pre>

<p>Without parentheses it's been evaluated as</p>

<pre><code>out[0] = in[0] &lt;&lt; (2 + in[1]) &gt;&gt; 2;
</code></pre>

<p>GCC shows this warning upon compiling your code with warnings on:</p>

<pre><code>test.c:5:23: warning: suggest parentheses around ¡®+¡¯ inside ¡®&lt;&lt;¡¯ [-Wparentheses]
     out[0] = in[0]&lt;&lt;2 + in[1]&gt;&gt;2;
                       ^
</code></pre>

<p>This is an example of why we should always pay attention to compiler warnings.</p>
",1
50103307,50103161,2,"<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    int i = 0;
    while (i &lt;= 999999 )
    {
        char cmd[100];
        sprintf(cmd, ""./lock %d"", i);
        if (system(cmd) == 0)
        {
            printf(""Success with i = %d\n"", i);
            exit(0);
        }
        ++i;
    }
    return !printf(""Error. Unable to crack file.\n"");
}
</code></pre>
",3
52210614,52210590,4,"<p>The problem is that <code>getline</code> in all-lowercase has since become an actual <a href=""https://en.cppreference.com/w/c/experimental/dynamic/getline"" rel=""nofollow noreferrer"">POSIX C function</a> so that name can't be used in a POSIX-compliant program that includes the <code>&lt;std*</code> headers.  </p>

<p>Your resolution of renaming it to <code>GetLine</code> evades this issue since C is case-sensitive.</p>
",7
50268921,50268722,3,"<p>The bits of integer <code>0x7fffff</code> encode a <code>float</code> value that is very small, less than 2<sup>?126</sup>. The <code>%f</code> conversion specifier does not produce enough digits to show the value. Use <code>%g</code> or <code>%e</code> or specify many more digits, such as <code>%.99f</code>.</p>
",3
54261826,54261257,4,"<p>A solution is :</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

char ** split(const char * str, const char * delim)
{
  /* count words */
  char * s = strdup(str);

  if (strtok(s, delim) == 0)
    /* no word */
    return NULL;

  int nw = 1;

  while (strtok(NULL, delim) != 0)
    nw += 1;

  strcpy(s, str); /* restore initial string modified by strtok */

  /* split */
  char ** v = malloc((nw + 1) * sizeof(char *));
  int i;

  v[0] = strdup(strtok(s, delim));

  for (i = 1; i != nw; ++i)
    v[i] = strdup(strtok(NULL, delim));

  v[i] = NULL; /* end mark */

  free(s);

  return v;
}

int main()
{
  char ** v = split(""bob is  great"", "" "");

  for (int i = 0; v[i] != NULL; ++i) {
    puts(v[i]);
    free(v[i]);
  }

  free(v);
  return 0;
}
</code></pre>

<p>As you see I add a null pointer at the end of the vector as a mark, but it can be changed easily to return the number of words etc</p>

<p>Execution :</p>

<pre><code>bob
is
great
</code></pre>

<hr>

<p>A second solution taking into account the remarks of alk :</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

char ** split(const char * str, const char * delim)
{
  /* count words */
  char * s = strdup(str);

  if ((s == NULL) /* out of memory */
      || (strtok(s, delim) == 0)) /* no word */
    return NULL;

  size_t nw = 1;

  while (strtok(NULL, delim) != 0)
    nw += 1;

  strcpy(s, str); /* restore initial string modified by strtok */

  /* split */
  char ** v = malloc((nw + 1) * sizeof(char *));

  if (v == NULL)
    /* out of memory */
    return NULL;

  if ((v[0] = strdup(strtok(s, delim))) == 0) {
    /* out of memory */
    free(v);
    return NULL;
  }

  size_t i;

  for (i = 1; i != nw; ++i) {
    if ((v[i] = strdup(strtok(NULL, delim))) == NULL) {
      /* out of memory, free previous allocs */
      while (i-- != 0)
        free(v[i]);
      free(v);
      return NULL;
    }
  }

  v[i] = NULL; /* end mark */

  free(s);

  return v;
}

int main()
{
  const char * s = ""bob is still great"";
  char ** v = split(s, "" "");

  if (v == NULL)
    puts(""no words of not enough memory"");
  else {
    for (int i = 0; v[i] != NULL; ++i) {
      puts(v[i]);
      free(v[i]);
    }

    free(v);
  }
  return 0;
}
</code></pre>

<p>When out of memory the return value is NULL ( in a previous version it was the string to split), of course there are other ways to signal that easily</p>

<hr>

<p>Execution under valgrind :</p>

<pre><code>==5078== Memcheck, a memory error detector
==5078== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==5078== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==5078== Command: ./a.out
==5078== 
bob
is
still
great
==5078== 
==5078== HEAP SUMMARY:
==5078==     in use at exit: 0 bytes in 0 blocks
==5078==   total heap usage: 7 allocs, 7 frees, 1,082 bytes allocated
==5078== 
==5078== All heap blocks were freed -- no leaks are possible
==5078== 
==5078== For counts of detected and suppressed errors, rerun with: -v
==5078== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 6 from 3)
</code></pre>
",23
56036316,56034969,0,"<p>Your code has more than 1 problem. But your particular problem is being caused by <code>listSwapStackQueues</code>. </p>

<p>You are allocating some memory for a temp Queue, then you assign the pointer to that memory to <code>q2</code>. Then you use free to deallocate the memory, leaving q2 pointing to something that is no longer there. </p>

<p>In fact, you don't need to allocate any memory here at all, since probably all you want is to swap the pointers. All you need to do in this case is:</p>

<pre><code>struct Queue *temp = stack-&gt;q1;    
stack-&gt;q1 = stack-&gt;q2;
stack-&gt;q2 = temp;
</code></pre>

<p>Are you using a debugger to debug your program? If you don't, you should familiarize yourself with one. Finding memory errors like these can be difficult without a proper debugger.</p>

<p>You will run into more issues like these, so having a good debugger is important. If you are on Windows, I would recommend just getting Visual Studio, since it is free and pretty powerful. </p>

<p>EDIT:</p>

<p>Next to the answers given by the others, there is also the following:
When you add new nodes to the list, initialize next as NULL. i.e., in your function <code>listQueueAddBack</code>:</p>

<pre><code>    struct Link* newLink = (struct Link*) malloc (sizeof (struct Link));
    assert (newLink != NULL);
    newLink-&gt;value = value;
    // Initialize next. 
    newLink-&gt;next = NULL;
</code></pre>
",7
50288143,50287908,0,"<p>These are very basic/fundamental logic operations in programming.</p>

<pre><code>while((ch=fgetc(ptf1))!='\n'&amp;&amp;ch!=EOF)
</code></pre>

<p>Means read a character, if that character is not a newline and it is not the end-of-file character then execute the loop body.</p>

<pre><code>while((ch=fgetc(ptf1))!='\n'||(ch=fgetc(ptf1))!=EOF)
</code></pre>

<p>Means read a character, if that character is not a newline then execute the loop body. Otherwise, read another character and if it is not the end-of-file character then execute the loop body.</p>

<pre><code>while((ch=fgetc(ptf1))!='\n'&amp;&amp;(ch=fgetc(ptf1))!=EOF)
</code></pre>

<p>Means read a character, if that character is not a newline read another character and if the second one is not the end-of-file character then execute the loop body.</p>
",0
56189762,56189146,4,"<p>Supposing <em>n</em> and <em>a</em> cannot be negative :</p>

<pre><code>#include &lt;stdio.h&gt;

/* n == a + (a+1) + (a+2) + ... + (a + m) == a*(m+1) + m*(m+1)/2
   a = (n/(m+1)) - m/2;
   b = (a + m) */

int main(void)
{
  int n;

  if ((scanf(""%d"", &amp;n) != 1)|| (n &lt; 0))
    puts(""invalid value"");
  else {
    for (int m = 0; ; ++m) {
      int a = (n/(m+1)) - m/2;

      if (a &lt; 0)
        break;

      /* check no round problem */
      if ((a*(m+1) + m*(m+1)/2) == n)
        printf(""a=%d b=%d (m=%d)\n"", a, a+m, m);

      if (a == 0)
        break;
    }
  }

  return 0;
}
</code></pre>

<p>Compilation and executions :</p>

<pre><code>pi@raspberrypi:/tmp $ gcc -pedantic -Wall -Wextra f.c
pi@raspberrypi:/tmp $ ./a.out
0
a=0 b=0 (m=0)
pi@raspberrypi:/tmp $ ./a.out
1
a=1 b=1 (m=0)
a=0 b=1 (m=1)
pi@raspberrypi:/tmp $ ./a.out
2
a=2 b=2 (m=0)
pi@raspberrypi:/tmp $ ./a.out
10
a=10 b=10 (m=0)
a=1 b=4 (m=3)
a=0 b=4 (m=4)
pi@raspberrypi:/tmp $ ./a.out
123
a=123 b=123 (m=0)
a=61 b=62 (m=1)
a=40 b=42 (m=2)
a=18 b=23 (m=5)
pi@raspberrypi:/tmp $ 
</code></pre>

<hr>

<p>A version checking all is correct doing the formula, in case you trust on nothing ;-)</p>

<pre><code>#include &lt;stdio.h&gt;

/* n == a + (a+1) + (a+2) + ... + (a + m) == a*(m+1) + m*(m+1)/2
   a = (n/(m+1)) - m/2;
   a == 0 =&gt; n == m*(m+1)/2 =&gt; 
   b = (a + m) */

int f(int a, int b)
{
  int r = 0;
  int m = 0;

  do {
    r += a+m;
  } while ((a + m++) != b);

  return r;
}

int main(void)
{
  int n;

  if ((scanf(""%d"", &amp;n) != 1)|| (n &lt; 0))
    puts(""invalid value"");
  else {
    for (int m = 0; ; ++m) {
      int a = (n/(m+1)) - m/2;

      if (a &lt; 0)
        break;

      if ((a*(m+1) + m*(m+1)/2) == n)
        printf(""a=%d b=%d (m=%d) : %s\n"", a, a+m, m, (n == f(a, a+m)) ? ""ok"" : ""KO"");
      if (a == 0)
        break;
    }
  }

  return 0;
}
</code></pre>

<p>Compilation and execution :</p>

<pre><code>pi@raspberrypi:/tmp $ gcc -g -pedantic -Wall -Wextra f.c
pi@raspberrypi:/tmp $ ./a.out
0
a=0 b=0 (m=0) : ok
pi@raspberrypi:/tmp $ ./a.out
1
a=1 b=1 (m=0) : ok
a=0 b=1 (m=1) : ok
pi@raspberrypi:/tmp $ ./a.out
2
a=2 b=2 (m=0) : ok
pi@raspberrypi:/tmp $ ./a.out
10
a=10 b=10 (m=0) : ok
a=1 b=4 (m=3) : ok
a=0 b=4 (m=4) : ok
pi@raspberrypi:/tmp $ ./a.out
123
a=123 b=123 (m=0) : ok
a=61 b=62 (m=1) : ok
a=40 b=42 (m=2) : ok
a=18 b=23 (m=5) : ok
pi@raspberrypi:/tmp $ 
</code></pre>
",3
56241853,56189146,0,"<p>A possible way to solve this problem, without exploiting the known formula for arithmetic progression and ""using simple C code"" as asked by the OP (well, for some definition of <em>simple</em>), is to use a running total (or partial sum) while exploring the possible values of <code>a</code> and <code>b</code>.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    // Instead of asking a value 'n', test all the values up to 128
    puts(""    n    a    b\n-------------------"");
    for (int n = 0; n &lt;= 128; ++n)
    {
        int a = 0;
        int b = 0;
        int sum = 0;

        while ( a &lt;= b  &amp;&amp;  b &lt;= n )
        {
            if ( sum == n )
            {
                printf(""%5d%5d%5d\n"", n, a, b);     
            }
            if ( sum &lt; n )
            {
                // Add the next highest term to the sum
                ++b;      
                sum += b;
            }
            else
            {
                // Remove the former lowest term from the sum
                sum -= a;
                ++a;
            }
        }    
    }
}
</code></pre>

<p>Testable <a href=""https://wandbox.org/permlink/zQwsp9frnd3e4OFk"" rel=""nofollow noreferrer"">HERE</a>.</p>
",0
58637761,58637646,6,"<p>1481 * 1481 * 1481 = 3 248 367 641, which doesn't fit into <code>signed int</code> (32 bit provided, that's not necessarily the case), which has a maximum value of 2 147 483 647, so overflow occurs (that's undefined behaviour for <em>signed</em> integral types!).</p>

<blockquote>
  <p>I have tried unsigned int, unsigned long and unsigned long long.</p>
</blockquote>

<p>All of these should be large enough (with 32-bit, giving a range up to and including 4 294 967 295). Actually, the types from <code>&lt;stdint.h&gt;</code> (e. g. <code>uint64_t</code>) are preferable, as they come with guaranteed bit-width.</p>

<p>In any case, question is: <em>Where</em> have you tried that? Changing the underlying type of the <em>array</em> to these larger types will eliminate the problem immediately (provided you change the type of <code>mmmsum</code>, too, of course).</p>

<p>If you want or need (for whatever reason) to retain the <code>int</code> array, then you need to cast your operands to the larger type, otherwise <code>m * m * m</code> will still be calculated in (too small) <code>int</code>. So:</p>

<pre><code>uint64_t mmmsum = 0;
// ...
    mmmsum += static_cast&lt;uint64_t&gt;(m[i]) * m[i] * m[i];
</code></pre>

<p>Casting only the first argument suffices, as the other arguments then will be promoted (converted) implicitly.</p>

<p>Using <code>pow</code> does something very similar: As function parameters are of type double, the <code>int</code> values are converted, too, <em>before</em> calculation, and double is large enough to hold the values in question. However, calculations in double can introduce rounding errors, with <code>pow</code> even if you use integral values. Sometimes the result gets (minimally) smaller than actual value, then when casting back to integral you get a bad value (too little by one). If working with integral values only, as in given case, adding 0.5 before casting back solves the issue already...</p>

<p>Side note on signed/unsigned: Don't decide for one bit of range to have signed or unsigned ¨C if you need more range, switch to next larger data type. Decision about using signed or unsigned should only be made of negative values being meaningful or meaningless (apparently the latter in your case).</p>
",11
50684275,50682897,1,"<p>Bug 1: you return the end of the string, not the beginning.<br>
Bug 2: you add 2 null terminators at the end, instead of 1.</p>

<p>The correct implementation should be something along the lines of:</p>

<pre><code>char* sstrcpy (char*restrict dst, const char*restrict src)
{
  char* original = dst;
  for(*dst = *src; *src != '\0'; dst++, src++)
  {
    *dst = *src;
  }
  return original;
}
</code></pre>

<p>where <code>restrict</code> is a contract with the caller that <code>dst</code> and <code>src</code> don't overlap. Please note that this might still be naive implementation - it is fine for small microcontrollers, but when it comes to library implementations of strcpy for 32 bit systems, they will work with aligned chunks of data.</p>

<hr>

<blockquote>
  <p>What are the Advantages of return a pointer to destination and return destination?</p>
</blockquote>

<p>There are no advantages whatsoever; the standard library is filled with oddities. This allows two kinds of pointless obfuscation:</p>

<pre><code>// Bad code, do not use!

/*1*/ str = strcpy(str, src); // pointless and potentially dangerous

/*2*/ strcpy(str2, strcpy(str1, src)); // pointless and potentially dangerous
</code></pre>

<p>This in turn allows side effects in parameter evaluation to cause bugs, so it is dangerous. Don't write crap like that. The correct versions are:</p>

<pre><code>/*1*/ strcpy(str, src);

/*2*/ strcpy(str1, src);
      strcpy(str2, str1);
</code></pre>

<p>The latter versions are safer and easier to read. The resulting machine code will be identical.</p>
",2
53735188,53735082,0,"<p><code>char a[I+1] = {a[I+1] = '\0'}</code> is not valid. Even if it compiles, it is going out of bounds when assigning the <code>'\0'</code> character.  The commonly used convention looks more like this instead:</p>

<pre><code>char a[I+1] = {0};
</code></pre>

<p>Or simply:</p>

<pre><code>char a[I+1] = {};
</code></pre>

<p>That said, <code>q</code> is only 1 <code>char</code> in size, but your <code>scanf()</code> is trying to read a string up to 127 <code>char</code>s into <code>q</code>.  So you are going to trash memory.  To read a single <code>char</code> at a time, use <code>%c</code> instead:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAX_INPUT 5

int main (void) {

    char a[MAX_INPUT+1];
    int i, len;

    for(i = 0; i &lt; MAX_INPUT; i++) {
        printf(""Enter an alphabet:\t"");
        scanf(""%c"", &amp;a[i]);
    }
    a[MAX_INPUT] = '\0';

    printf(""\n"");

    len = strlen(a);
    for(i = 0; i &lt; len; i++)  {
        printf(""Element a[%d]:\t%c\n"", i, a[i]);
    }

    printf(""And the a string:\t%s\n"", a);

    return 0;
}
</code></pre>

<p>Or, you can remove the loop and just use a single call to <code>scanf()</code> using <code>""%5[^\n]""</code> as the format string:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAX_INPUT 5

int main (void) {

    char a[MAX_INPUT+1];
    char fmt[20];
    int i, len;

    sprintf(fmt, ""%%%d[^\n]"", MAX_INPUT);

    printf(""Enter an alphabet:\t"");
    scanf(fmt, a);

    printf(""\n"");

    len = strlen(a);
    for(i = 0; i &lt; len; i++)  {
        printf(""Element a[%d]:\t%c\n"", i, a[i]);
    }

    printf(""And the a string:\t%s\n"", a);

    return 0;
}
</code></pre>
",6
51329796,51328806,1,"<p>No, you can't do that, with <code>atoi</code> or any other function. If a C compiler allows this and generates code to assign from <code>atoi(years)</code> to <code>age</code>, the compiler is broken.</p>

<p>For fun I put this into a little program:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main()
  {
  char *years = ""61"";
  int age;

  atoi(years) = age;

  printf(""%d\n"", age);
  }
</code></pre>

<p>and jammed it through my local C compiler (HP C/aC++ compiler FWIW). The following messages were produced:</p>

<pre><code>$ cc test.c

""test.c"", line 9: error #2137: expression must be a modifiable lvalue
    atoi(years) = age;
    ^

""test.c"", line 9: warning #2549-D: variable ""age"" is used before its value is
          set
    atoi(years) = age;
                  ^

1 error detected in the compilation of ""test.c"".
</code></pre>

<p>Best of luck.</p>
",0
51257915,51257859,1,"<p>The following line is wrong.</p>

<pre><code>printf(""Pointer variable value: %p\n"", *str);
</code></pre>

<p>To print the pointer, the second argument needs to be just <code>str</code>.</p>

<pre><code>printf(""Pointer variable value: %p\n"", str);
</code></pre>

<p>The following line is also wrong.</p>

<pre><code>printf(""%p\n"", str[x]);
</code></pre>

<p>To print the pointer, change the second argument to <code>&amp;str[x]</code>.</p>

<pre><code>printf(""%p\n"", &amp;str[x]);
</code></pre>
",0
51218984,51218921,0,"<p>This line produces undefined behavior:</p>

<pre><code>strcat(cwd, cwd);
</code></pre>

<p>because the source and destination are not allowed to overlap. You can make a copy of <code>cwd</code> so you can concatenate it.</p>

<pre><code>char cwd2[524];
strcpy(cwd2, cwd);
strcat(cwd, cwd2);
</code></pre>

<p>You're not using <code>strtok_r()</code> correctly. The first call to <code>strtok_r()</code> in a loop passes a pointer to the string being parsed as the first argument, and a pointer to some <em>other</em> pointer as the third argument. When you repeat these calls in the loop, the first argument should be <code>NULL</code> -- that tells <code>strtok_r()</code> that you want to continue parsing the same string.</p>

<p>And the pointer to the token is the value returned from the function, not the third argument.</p>

<p>After you find the word <code>double</code>, you need to read the <em>next</em> token to get the word that should be doubled. Your code is doubling the current word, which is just <code>double</code>.</p>

<p>Here's the corrected code.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

int main()
{
    char pch[]=""encrypt galvin;double royal;"";
    char *cmd;
    char *ptr;
    //pch = strtok (dir,"";"");

    for (cmd = strtok_r(pch,"";"",&amp;ptr); cmd; cmd = strtok_r(NULL, "";"", &amp;ptr)) {
        printf(""%s\n"",cmd);

        char *word;
        char *ptr2;
        char cwd[524];
        for (word = strtok_r(cmd, "" "", &amp;ptr2); word; word = strtok_r(NULL, "" "", &amp;ptr2)) {
            if (strcmp(word,""double"")==0) {
                char *word2 = strtok_r(NULL, "" "", &amp;ptr2);
                strcpy(cwd, word2);
                strcat(cwd, word2);
                printf(""Double %s Done.\n"", cwd);
            }
        }
    }
    return  0;
}
</code></pre>
",5
51182068,51181981,0,"<p>The only way I can think of is using a VLA (Variable Length Array):</p>

<pre><code>char *ptr = ""Some string"";
char str[strlen(ptr) + 1];

strcpy(str, ptr);
puts(str);
</code></pre>

<p>But you can not assign a value directly (you need to copy the contents using <code>strcpy</code>), in other words: <a href=""http://c-faq.com/aryptr/arrayassign.html"" rel=""nofollow noreferrer"">an array is not a modifiable lvalue</a>.</p>
",0
54524797,54524735,1,"<p>We don't. </p>

<p>One of the key characteristics of an array is that you know the offset between one element and the next, and you can't do that if the elements are variably-sized.</p>

<p>What you can create is an array of pointers to your flexibly-sized type. How each of the pointed-to objects is allocated is up to you.</p>
",0
54524780,54524735,6,"<p>A <code>struct</code> with a flexible array member cannot be a member of an array.  This is explicitly stated in section 6.7.2.1p3 of the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""noreferrer"">C standard</a>:</p>

<blockquote>
  <p>A structure or union shall not contain a member with incomplete or
  function type (hence, a structure shall not contain an instance of
  itself, but may contain a pointer to an instance of  itself),  except 
  that  the  last  member  of  a  structure  with  more  than  one 
  named  member may  have  incomplete  array  type;  <strong>such  a  structure 
  (and  any  union  containing,  possibly recursively, a member that is
  such a structure) shall not be a member of a structure or an element
  of an array.</strong></p>
</blockquote>

<p>What you would need to do instead is declare the struct with a pointer instead of a flexible array member, and allocate space for each instance.</p>

<p>For example:</p>

<pre><code>struct A {
  int i;
  char *c;
};

struct A arr[100];

for (int i=0; i&lt;100; i++) {
    arr[i].c = malloc(LEN);
}
</code></pre>
",1
50434130,50434053,2,"<p>All your <code>ucinek</code> data members that you want to use to store integers should actually store <code>int</code> instead of <code>int*</code>:</p>

<pre><code>int dan;
int mjesec;
...etc...
</code></pre>

<p>Remember that a pointer tells the compiler where to find some other data, rather than storing a meaningful value itself.</p>

<p>Your <a href=""http://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow noreferrer""><code>fscanf</code></a> line should then change to pass pointers to the integers, which you can get using the <code>&amp;</code> operator:</p>

<pre><code>fscanf(pok, ""%s %s %d %d %d %d %d %d %d %d %d %d %d\n"",
       ucen[i]-&gt;ime, ucen[i]-&gt;prezime, &amp;ucen[i]-&gt;dan, &amp;ucen[i]-&gt;mjesec,
       &amp;ucen[i]-&gt;godina, &amp;ucen[i]-&gt;mat, &amp;ucen[i]-&gt;hrv, &amp;ucen[i]-&gt;eng,
       &amp;ucen[i]-&gt;hidr, &amp;ucen[i]-&gt;fiz, &amp;ucen[i]-&gt;term, &amp;ucen[i]-&gt;oet,
       &amp;ucen[i]-&gt;tehmat);
</code></pre>

<p>Those pointers tell <a href=""http://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow noreferrer""><code>fscanf</code></a> where to store the parsed values.</p>

<p>I never use <a href=""http://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow noreferrer""><code>fscanf</code></a> without checking the returned value either: it says how many values were successfully parsed from the input and stored.  If it's not the number you're expecting, you should print an error message.</p>
",1
51541510,51541021,2,"<p>The 3 highest values from all 40?</p>

<p>This shouldn't be too difficult </p>

<ul>
<li>Create 3 int variables to hold the required values and set them to 0 say a,b and c</li>
<li>Loop through all 5 arrays checking if the current value is greater than a and if it is replace the value of a, when you are finished that a = the largest value.</li>
<li>Loop through all 5 arrays again only this time with b and ignoring a (Or any value greater than or equal to a)</li>
<li>Repeat that step with c ignoring any value greater than or equal to b)</li>
</ul>

<p>It's frowned on here to ask people to do homework and you will get downvoted for it, but if you want to try that out and put your code up and I'll have a look for you.</p>
",5
56724623,56724601,1,"<p>A leading <code>0</code> introduces an octal constant, so <code>010</code> is octal which is 8 in decimal. If you want binary, write <code>0b010</code> (which is 2 in decimal).</p>
",3
50434713,50434674,0,"<p>The problem is you are setting <code>prev = num</code> too early so you are losing the old value of <code>prev</code>, which is what you need to compare against. it looks like you've then hacked around that problem by arbitrarily decreasing prev by one, but then of course it looks to the program like you are always in sequence, which is a nonsensical solution.</p>

<p>You need to fix the actual problem, not try to work around it.</p>
",0
53559351,53557796,0,"<p>One option is <code>strchr</code>. It looks for the occurrence of a specific character inside a string, and is supposedly optimized well.</p>

<pre><code>bool isvowel (char ch)
{
  return strchr(""aeiou"", tolower(ch)) != NULL;
}
</code></pre>

<p>And that's it. Full example:</p>

<pre><code>#include &lt;stdbool.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;

bool isvowel (char ch)
{
  return strchr(""aeiou"", tolower(ch)) != NULL;
}

int main (void)
{
  for(unsigned char i='A'; i&lt;='Z'; i++)
  {
    char ch = (char)i;
    printf(""%c: %s\n"", ch, isvowel(ch) ? ""vowel"" : ""consonant"");
  }
}
</code></pre>
",3
51594056,51591630,0,"<p>In addition to the items mentioned in comments under your post, there are a few other necessary modifications required as well:</p>

<p>In the <code>add(.,.)</code> function, to create a new link change your original from:</p>

<pre><code>void add(ListNode *listtype, element elementtype){
    listtype = (ListNode *)malloc(sizeof(ListNode));
    listtype-&gt;data= elementtype;
    listtype = listtype-&gt;link;
}
</code></pre>

<p>To:  </p>

<pre><code>//create new link in function: newNode, modify its members,
//then set original listtype == newNode 
void add(ListNode **listtype, element elementtype)
{
    ListNode *newNode = calloc(1, sizeof (*newNode));  // add this new Node
    if(newNode)//test that calloc is successful
    {
        newNode-&gt;data = elementtype;
        newNode-&gt;link = *listtype;//these lines 
        (*listtype) = newNode;    //add new link to original
    }
}
</code></pre>

<p>Also, in the <code>get_length()</code> function, change the following line:</p>

<pre><code>nodetype-&gt;link = nodetype;
</code></pre>

<p>To:</p>

<pre><code>nodetype = nodetype-&gt;link;
</code></pre>

<p>And finally, in <code>main</code>, Change: </p>

<pre><code>int main() {
    ListNode *list1=NULL;

    add(list1, 3);
    add(list1, 3);  
</code></pre>

<p>To:</p>

<pre><code>int main(void) { //Note minimum signature of main function
    ListNode *list1=NULL;

    add(&amp;list1, 3);//pass address of object, not object itself
    add(&amp;list1, 3);
</code></pre>
",0
52200673,52200267,0,"<p>Your code has several problems:</p>

<ul>
<li><code>conio.h</code> header is useless,</li>
<li>You do not reserve enough space to store a name,</li>
<li>you do not check for scanf result.</li>
</ul>

<p>Corrected, your code could looks like:</p>

<pre><code>/* only include stdio.h, conio.h is not portable and unnecessary here */
#include &lt;stdio.h&gt;

/* main should return an int*/
int main(void)
{
    int n=0;
    int i,k;
    /* often, a name is composed of several characters */
    char name[128];
    printf(""\t\t Program to find the overtime of 10 workers\n\n"");
    for( i=0; i&lt;10; i++){
        printf(""Enter the name of worker\n"");

        if (1 != scanf(""%s"", name))
        {
            /* on error, exit loop */
            perror(""scanf"");
            break;
        }

        printf(""Enter the number of hours worked\n"");
        if (1 != scanf(""%d"",&amp;n))
        {
            /* scanf did not manage to read one integer, exit loop */
            perror(""scanf"");
            break;
        }
        if (n&gt;10) {
            k=n-10;
            printf(""%s is eligible for overtime for overtime of rs %d\n"", name, k*12); 

        }
        else{
            printf(""%s is not eligible to any overtime in rs 0 \n"",name);
        }
    }
    getchar();

    return 0;
}
</code></pre>

<hr>

<p>And to finish, here: a good reading about <code>scanf</code>: <a href=""http://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html"" rel=""nofollow noreferrer"">http://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html</a></p>
",0
51046806,51046496,0,"<p>You have</p>

<pre><code>struct Node* node = (Node*)...;
</code></pre>

<p>C's type system is a bit less forgiving than it used to be: it won't promote this thing <code>Node*</code> into a <code>struct Node*</code>.</p>

<p>You need</p>

<pre><code>struct Node* node = (struct Node*)...;
</code></pre>

<p>or you could rely on <code>void*</code>'s promotion rules, which on modern compilers will promote to any pointer type.</p>

<pre><code>struct Node* node = ...; /* assuming ... returns a void* */
</code></pre>
",2
51046825,51046496,0,"<p>There seems to be two things wrong with your code.</p>

<p>You're using <code>(Node*)</code> in the cast where it should have been <code>(struct Node*)</code> or you can even omit it.</p>

<pre><code>void Insert(int x){
    struct Node* temp = (Node*)malloc(sizeof(struct Node));
    (*temp).data = x;
    (*temp).next = NULL;
}
</code></pre>

<p>You have an error with your semi-colon in this statement as well:</p>

<pre><code>printf(""How many numbers ?\n"";)
</code></pre>

<p>Replace with </p>

<pre><code>printf(""How many numbers ?\n"");
</code></pre>
",0
51046704,51046496,0,"<p>I believe you want to achieve something like this:</p>

<pre><code>#include &lt;stdlib.h&gt;

typedef struct tag_Node Node;

struct tag_Node {
    int data;
    Node* next;
};

void Insert(Node *to, int x) {
    Node* node = (Node*)malloc(sizeof(Node));
    node-&gt;data = x;
    node-&gt;next = 0;
    to-&gt;next = node;
}
</code></pre>

<p>Assuming that you want to implement a linked list, you should have an additional parameter in your <code>Insert</code> method, which will specify the node you should insert your next value to. You will also need to use struct dereference operator (<code>-&gt;</code>) if you work with pointers.</p>
",5
51608804,51608655,1,"<p>The <code>""%s""</code> format reads <strong><em>space-separated</em></strong> ""words"".</p>

<p>If there isn't a space separating the ""words"" you have to use some other way to parse the input. For example by <a href=""http://en.cppreference.com/w/c/io/fgets"" rel=""nofollow noreferrer"">reading the whole line</a> and then use something like <a href=""http://en.cppreference.com/w/c/string/byte/strtok"" rel=""nofollow noreferrer""><code>strtok</code></a> to ""tokenize"" the string.</p>

<p><em>Or</em> make sure that the input format is space-separated.</p>
",3
58045039,58044981,1,"<p><code>printf(""this is the number %d\n\n"",NUM);</code> passes <code>NUM</code> to <code>printf</code> to be formatted with the <code>%d</code> conversion specifier.</p>

<p><code>NUM</code> is an array. In this use, it is automatically converted to the address of its first element. <code>%d</code> expects an <code>int</code> to be passed. An address is not an <code>int</code>. Because of this mismatch, the behavior of this code is not defined by the C standard. At best, the <code>printf</code> will print the address formatted in decimal.</p>

<p>To print the elements of the arrays, you must write a loop that prints each element, as by passing <code>NUM[i]</code> to <code>printf</code> to be formatted with <code>%d</code>. You could use:</p>

<pre><code>for (int i = 0; i &lt; 8; ++i)
    printf(""NUM[%d] = %d.\n"", i, NUM[i]);
</code></pre>
",0
51404707,51403674,4,"<p>Start with the leftmost identifier and work your way out, remembering the following rules:</p>

<pre><code>T *a[N];   // a is an array of pointer to T
T (*a)[N]; // a is a pointer to an array of T
T *f();    // f is a function returning a pointer to T
T (*f)();  // f is a pointer to a function returning T
</code></pre>

<p>So:</p>

<pre><code>       action                                -- action
      *action                                -- is a pointer to
     (*action)(                       )      -- a function taking
     (*action)(                       )      --   unnamed parameter
     (*action)(                      *)      --   is a pointer to
     (*action)(struct softirq_action *)      --   struct softirq_action
void (*action)(struct softirq_action *);     -- and returning void
</code></pre>
",0
53240196,53239570,0,"<pre><code>switch(expression) {
   case constant-expression  :
...
   default : //Optional
      statement(s);
}
</code></pre>

<blockquote>
  <p>The <em>expression</em> used in a switch statement must have an integral or
  enumerated type, or be of a class type in which the class has a single
  conversion function to an integral or enumerated type.</p>
</blockquote>

<p>In other words, you cannot use the entire input string as expression to the switch statement. A perfectly working example is given by Paul Ogilvie above.</p>
",0
57893946,57893889,9,"<p>Block-scoped variables, along with non-static local variables, have automatic storage duration. What compiler does with it is implementation-defined, though. If the compiler uses stack to manage automatic variables (most compilers do) then block variables end up on the stack. However, it is perfectly valid for the compiler to store these variables in registers, or even to optimize them out at compile time.</p>
",0
51453236,51453187,1,"<p>It's better to divide by 10 as long as the number has no remainder on division by 10.</p>

<p>So in essence:</p>

<pre><code>scanf(""%u"", &amp;num);
while (0 == (num % 10)){
      num/=10;
}
printf(""%u\n"", num); 
</code></pre>

<p>It's also recommended to check for the output value 1 of <code>scanf</code> so that you know you've converted 1 decimal unsigned (<code>%u</code>) number. Of course <code>num</code> should be declared <code>unsigned int num</code> unless you allow for negative inputs. You need no extra variables etc. The usage of <code>^</code>, which is a bitwise xor operator (not a power operator) is nonsensical.</p>
",5
56927354,56927305,0,"<p>Your second <code>int len</code> creates a second, parallel, variable that goes away at the end of the {} block. The original <code>len</code> then returns to life, completely unchanged.  Without the second <code>int</code> the original variable is changed. With it the original <code>len</code> is effectively an unchanged constant and infinite loop.</p>
",2
56927369,56927305,4,"<p>You're not redefining an existing variable, you're defining a new variable.</p>

<p>Consider this example:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    int x = 42;
    printf(""Outside, start.     x (%p) = %d\n"", (void *)&amp;x, x);
    {
        printf(""Inner block, start. x (%p) = %d\n"", (void *)&amp;x, x);
        int x = 123;
        printf(""Inner block, end.   x (%p) = %d\n"", (void *)&amp;x, x);
    }
    printf(""Outside, end.       x (%p) = %d\n"", (void *)&amp;x, x);
    return 0;
}
</code></pre>

<p>Sample output:</p>

<pre class=""lang-none prettyprint-override""><code>Outside, start.     x (0x7ffd6e6b8abc) = 42
Inner block, start. x (0x7ffd6e6b8abc) = 42
Inner block, end.   x (0x7ffd6e6b8ab8) = 123
Outside, end.       x (0x7ffd6e6b8abc) = 42
</code></pre>

<p>[<a href=""https://tio.run/##jY/BDoIwEETv/YoNBkMNEkVvqHdP/oAXbKs04pa0xZAYvr0WMIaDMextZ2dfZtjyxphzM4msrLmAnbFcqqQ4ECLRwiOXGD2V5BReBPx0YgN72KZZv1faK9coONXWSC5iMDbXNulO3heFFfXmkJ8xiKEHwYLOmxgaOvwP1DHpiCg0XErF7l/aFNI43TrdZP/BAnkyMWL7u@iHMLWoFrbWCKuMtMS5Nw"" rel=""nofollow noreferrer"">Live demo</a>]</p>

<p>This program outputs the memory address and value of <code>x</code>. Most uses of <code>x</code> refer to the outer variable declared at the beginning of main. But within the inner block, after <code>int x = 123;</code>, all occurrences of <code>x</code> refer to a second, separate variable that happens to also be called <code>x</code> (but is otherwise independent).</p>

<p>When execution leaves the inner block, the outer <code>x</code> variable becomes visible again.</p>

<p>This is also referred to as <a href=""https://en.wikipedia.org/wiki/Variable_shadowing"" rel=""nofollow noreferrer"">shadowing</a>.</p>

<p>In your code, the outer <code>len</code> is never modified, so <code>while(len &gt; 1)</code> is always true.</p>

<hr>

<p>By the way, shadowing is a very common concept in most languages that support block scoping:</p>

<ul>
<li><a href=""https://tio.run/##K0gtyjH9/7@0OFWhuKQoM7nEmgvELk8sysvMSy@25uLKrVRQqVCwVTAxsuYqKMrMK1FQ8i8tKc5MSdUBakksKtFTAIEKBQ0lHYUYlQodBSVNoHKVipg8JWuuai6QJFSfZ15eapFCUk5@cjZcLw59IF0wmw2NjK1xGpOal6KH2/paDCdD1eN28v//AA"" rel=""nofollow noreferrer"">Perl</a></li>
<li><a href=""https://tio.run/##dZBBT8MwDIXv/RXWOASkrRGD0yp@AFyQKIjjlCaPrZDGVeJN1RC/vbSwIXqYj/bz8/f8bvYm2Vi3sgjs0Pdql0BJYm1FFVnmIdTRHd0ui8xySOyRe95czh53kmqH@aA1UXIaaxTO5tRdFdlnNja0JtUpsiYooQo0eDvaImJ1Gm9F2rTS2mEPzy1i3vCh9t7kHDcaYfFSasc26VdU@mGALX9g9RPeBptgoUsxggZBkh5gL57RtByNXzsYtz5wwPHUhP4@BESqPNuPvwT/6MeNU/Lr5c1v47wBgsun8b/OPOuonD6r778B"" rel=""nofollow noreferrer"">JavaScript</a></li>
<li><a href=""https://tio.run/##y0gszk7Nyfn/PzcxM0/BykrB019BQ5MLzLNVSMnnUgCCnNQShQog18QIzC0oLQkuKfLJU9BQ8i8tKc5MSdVRKC5JLCrRA8mCVSopaGsrFGfklytUaIL1QE1C0@6Zl5dapJCUk5@cDTcCq3ZkVxgaGRM0KzUvRQ@XU7A5H6oem/P//wcA"" rel=""nofollow noreferrer"">Haskell</a></li>
<li><a href=""https://tio.run/##S87JLC74/18jJ7VEQUOjQsHESFOTS0FBIy2/KDexRKFEQcm/tKQ4MyVVR6G4JLGoRE8BBCoUbBXqEutUlRQqwKphug2NjMHaUQzwzMtLLVJIyslPzoboRjMAl32peSl62JT//w8A"" rel=""nofollow noreferrer"">Common Lisp</a></li>
</ul>
",1
51343408,51343178,1,"<p>Now that I have the declaration of <code>struct student_t</code> (and a glass of wine!)</p>

<p>It should be</p>

<pre><code> int c = scanf(""%19[^,], %39[^,], %i"", p-&gt;name, p-&gt;surname, &amp;p-&gt;index);
</code></pre>

<p>And then check if <code>c</code> is 3</p>
",2
50519612,50519087,0,"<p>In the case of:</p>

<pre><code>if(curr == NULL){
    return;
</code></pre>

<p>you return without closing the file. So there is an open file handle on an empty file.  Any future calls to the function will then fail to open the file because the operating system may not allow two different write handles on the same file.</p>

<p>To avoid this problem you could move the above code to before you open the 
file;  or add a <code>fclose</code> call before returning.</p>

<p>Also, you should check the return value of <code>fopen</code> because if it fails then the <code>fprintf</code> commands cause undefined behaviour.  </p>

<p>Technically you should also check the return value of <code>fclose</code> and perhaps abort the program if it fails.</p>
",0
51574765,51572475,1,"<p>Here's a solution that avoids quadratic O(N2) or cubic O(N3) time algorithms ¡ª it is linear time, requiring one access to each character in each of the input strings.  The code uses a pair of constant strings rather than demanding user input; an alternative might take two arguments from the command line and compare those.</p>

<pre><code>#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    int count = 0;
    char bytes[UCHAR_MAX + 1] = { 0 };
    char s1[100] = ""connect"";
    char s2[100] = ""rectangle"";

    for (int i = 0; s1[i] != '\0'; i++)
        bytes[(unsigned char)s1[i]] = 1;

    for (int j = 0; s2[j] != '\0'; j++)
    {
        int k = (unsigned char)s2[j];
        if (bytes[k] == 1)
        {
            bytes[k] = 0;
            count++;
        }
    }

    printf(""%d\n"",count);
    return 0;
}
</code></pre>

<p>The first loop records which characters are present in <code>s1</code> by setting an appropriate element of the <code>bytes</code> array to <code>1</code>.  It doesn't matter whether there are repeated characters in the string.</p>

<p>The second loop detects when a character in <code>s2</code> was in <code>s1</code> and has not been seen before in <code>s2</code>, and then both increments <code>count</code> and marks the character as 'no longer relevant' by setting the entry in <code>bytes</code> back to <code>0</code>.</p>

<p>At the end, it prints the count ¡ª <code>4</code> (with a newline at the end).</p>

<p>The use of <code>(unsigned char)</code> casts is necessary in case the plain <code>char</code> type on the platform is a signed type and any of the bytes in the input strings are in the range 0x80..0xFF (equivalent to <code>-128..-1</code> if the <code>char</code> type is signed).  Using negative subscripts would not lead to happiness.  The code does also assume that you're working with a single-byte code set, not a multi-byte code set (such as UTF-8).  Counts will be off if you are dealing with multi-byte characters.</p>

<hr>

<p>The code in the question is at minimum a quadratic algorithm because for each character in <code>s1</code>, it could step through all the characters in <code>s2</code> only to find that it doesn't occur.  That alone requires O(N2) time.  Both loops also use a condition based on <code>strlen(s1)</code> or <code>strlen(s2)</code>, and if the optimizer does not recognize that the value returned is the same each time, then the code could scan each string on each iteration of each loop.</p>

<p>Similarly, the code in the other two answers as I type (<a href=""https://stackoverflow.com/a/51572642/15168"">Answer 1</a> and <a href=""https://stackoverflow.com/a/51573074/15168"">Answer 2</a>) are also quadratic or worse because of their loop structures.</p>

<p>At the scale of 100 characters in each string, you probably won't readily spot the difference, especially not in a single iteration of the counting.  If the strings were bigger ¡ª thousands or millions of bytes ¡ª and the counts were performed repeatedly, then the difference between the linear and quadratic (or worse) algorithms would be much bigger and more easily detected.</p>

<p>I've also played marginally fast'n'loose with the Big-O notation.  I'm assuming that N is the size of the strings, and they're sufficiently similar in size that treating N? (the length of <code>s1</code>) as approximately equal to N? (the length of <code>s2</code>) isn't going to be a major problem.  The 'quadratic' algorithms might be more formally expressed as O(N??N?) whereas the linear algorithm is O(N?+N?).</p>
",0
51461182,51460855,1,"<p>You don't make sure your variables are properly initialized ¡ª <code>i</code>, <code>c</code>, <code>k</code>, <code>t_factors</code>.  You also don't load the array <code>factors</code> correctly.  A basic set of changes to your code (using the C99 'define a variable almost anywhere' feature) yields:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int range;

    printf(""Enter the total number of figures you want to check: "");
    if (scanf(""%d"", &amp;range) != 1)
        return 1;

    for (int num = 1; num &lt;= range; num++)
    {
        int t_factors = 0;
        int factors[50];
        for (int i = 1; i &lt;= num; i++)
        {
            if (num % i == 0)
                factors[t_factors++] = i;
        }
        int c = 0;
        for (int k = 0; k &lt; t_factors; k++)
            c = c + factors[k];
        int b = 2 * num;
        if (c &lt; b)
            printf(""%d is deficient\n"", num);
        else
            printf(""%d is not deficient\n"", num);
    }
    return 0;
}
</code></pre>

<p>If you type 30 as the response, this produces:</p>

<pre><code>Enter the total number of figures you want to check: 30
1 is deficient
2 is deficient
3 is deficient
4 is deficient
5 is deficient
6 is not deficient
7 is deficient
8 is deficient
9 is deficient
10 is deficient
11 is deficient
12 is not deficient
13 is deficient
14 is deficient
15 is deficient
16 is deficient
17 is deficient
18 is not deficient
19 is deficient
20 is not deficient
21 is deficient
22 is deficient
23 is deficient
24 is not deficient
25 is deficient
26 is deficient
27 is deficient
28 is not deficient
29 is deficient
30 is not deficient
</code></pre>

<p>You can streamline that a bit by avoiding the array of factors and accumulating the terms as you go:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int range;

    printf(""Enter the total number of figures you want to check: "");
    if (scanf(""%d"", &amp;range) != 1)
        return 1;

    for (int num = 1; num &lt;= range; num++)
    {
        int s = 0;
        for (int i = 1; i &lt;= num; i++)
        {
            if (num % i == 0)
                s += i;
        }
        if (s &lt; 2 * num)
            printf(""%d is deficient\n"", num);
        else
            printf(""%d is not deficient\n"", num);
    }
    return 0;
}
</code></pre>

<p>It produces the same output as the first program, which is encouraging.  You'd keep the factors array if you wanted to print out data to justify the determination of 'deficient' vs 'not deficient', but while you're not doing anything more than adding up the elements in the array after finding the factors, you really don't need it.</p>

<p>You could look at <a href=""https://www.encyclopedia.com/education/news-wires-white-papers-and-books/numbers-abundant-deficient-perfect-and-amicable"" rel=""nofollow noreferrer"">Numbers ¡ª abundant, deficient, perfect and amicable</a> and see that you don't need to include <code>num</code> in the checked factors and you don't need the <code>2 * num</code>, and you can 'optimize' by not checking the numbers larger than <code>num / 2</code> since they're not factors, yielding:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int range;

    printf(""Enter the total number of figures you want to check: "");
    if (scanf(""%d"", &amp;range) != 1)
        return 1;

    for (int num = 1; num &lt;= range; num++)
    {
        int s = 0;
        for (int i = 1; i &lt;= num / 2; i++)
        {
            if (num % i == 0)
                s += i;
        }
        if (s &lt; num)
            printf(""%d is deficient\n"", num);
        else if (s &gt; num)
            printf(""%d is abundant\n"", num);
        else
            printf(""%d is perfect\n"", num);
    }
    return 0;
}
</code></pre>

<p>The output from that is:</p>

<pre><code>Enter the total number of figures you want to check: 30
1 is deficient
2 is deficient
3 is deficient
4 is deficient
5 is deficient
6 is perfect
7 is deficient
8 is deficient
9 is deficient
10 is deficient
11 is deficient
12 is abundant
13 is deficient
14 is deficient
15 is deficient
16 is deficient
17 is deficient
18 is abundant
19 is deficient
20 is abundant
21 is deficient
22 is deficient
23 is deficient
24 is abundant
25 is deficient
26 is deficient
27 is deficient
28 is perfect
29 is deficient
30 is abundant
</code></pre>
",2
51460869,51460855,3,"<p>Most probably the cause of your problem is that the <code>i</code> variable is not initialized and when you do <code>num % i</code> is not certain what happens.</p>
",2
53640234,53639674,0,"<p>Before this post closes and for giving me such entertainment, here is a small piece of your puzzle that is missing</p>

<pre><code>char x[500][11];
char b[100];
int a, z, i;
for(z = 0; z &lt; 500; z++)
{
    for(i=0; i&lt;10;i++)
    {
        x[z][i] = '0' + rand() % 10;
    }
    x[z][10] = '\0';
    printf(""%s \n"", x[z]);
}
</code></pre>

<p>This does not check for uniqueness.  You will have to figure that out along with everything else.</p>
",1
52142096,52142043,0,"<p>As far as the comparison itself goes, this should be fine.</p>

<p>You're potentially missing out on some optimisations this way, because the range of your results is not just the real values - but that shouldn't be a huge issue.</p>

<p>Suggestion if you can still change the interface: A more readable solution could be something like:</p>

<pre><code>double result;
int err = foo_fail(&amp;result);
</code></pre>
",1
52142096,52142043,0,"<p>As far as the comparison itself goes, this should be fine.</p>

<p>You're potentially missing out on some optimisations this way, because the range of your results is not just the real values - but that shouldn't be a huge issue.</p>

<p>Suggestion if you can still change the interface: A more readable solution could be something like:</p>

<pre><code>double result;
int err = foo_fail(&amp;result);
</code></pre>
",1
59188689,59188650,1,"<p>In C and C++ the evaluation order of function arguments is undefined. It could be left to right, right to left, or randomized by running on multiple threads.</p>

<p>Also your example is even worse than that because <code>function(x++, x++, x++)</code> modifies x multiple times without a sequence point. Function argument commas are not sequence points. Which means <code>x</code> might be sent into the function call as <code>x</code>, <code>x+1</code>, <code>x+2</code> or <code>x+3</code>. Since it is undefined it could even be <code>0</code> or call <code>abort()</code>.</p>
",10
51928679,51927634,0,"<p>Typically yes, the linker should be capable of this optimization, as this is often the reason to do static linking in the first place (instead of the usually more advisable dynamic linking).</p>
",0
52506543,52506479,6,"<p>Because that's how the language is defined. <code>!</code> is the logical NOT operator and boolean logic in C works on <code>1</code> and <code>0</code>, representing <code>true</code> and <code>false</code>. </p>

<p>C17 6.5.3.3:</p>

<blockquote>
  <p>The  result  of  the  logical  negation  operator
  !
  is  0  if  the  value  of  its  operand  compares
  unequal to 0, 1 if the value of its operand compares equal to 0. The result has type
  int.</p>
</blockquote>

<p>You can think of it as if returning <code>bool</code>, though it actually returns <code>int</code> for backwards-compatibility reasons. Unlike C++ where it does return <code>bool</code>. The same goes for relational and equality operators.</p>
",3
51518334,51517322,0,"<p>The first prints the bytes that represent the integer in the order they appear in memory. Platforms with different endian will print different results as they store integers in different ways.</p>

<p>The second prints the bits that make up the integer value most significant bit first. This result is independent of endian. The result is also independent of how the >> operator is implemented for signed ints as it does not look at the bits that  may be influenced by the implementation.</p>

<p>The second is a better match to the question ""Printing actual bit representation of integers in C"".  Although there is a lot of ambiguity.</p>
",1
52203618,52203587,0,"<p>There are a few issues in your code :</p>

<ul>
<li><p>you're assigning to an array :</p>

<p><code>while((rec=getchar()) != '\n')</code></p>

<p><a href=""https://en.cppreference.com/w/c/io/getchar"" rel=""nofollow noreferrer""><code>getchar</code></a> returns a <code>int</code>, so <code>rec</code> should be defined as such :</p>

<p><code>int rec;</code></p></li>
<li><p>you're printing an <code>int</code> as if it were a string :</p>

<p><code>printf(""Nova recenica je: %s"", zbroj1);</code></p>

<p>This is undefined behavior. Use the correct format specifier :</p>

<p><code>printf(""Nova recenica je: %d"", zbroj1);</code></p></li>
<li><p>your if check does not do what you expect :</p>

<p><code>if(zbroj1&gt;=4 || zbroj1&lt;=8)</code></p>

<p>This covers all values. You probably meant :</p>

<p><code>if(zbroj1&gt;=4 &amp;&amp; zbroj1&lt;=8)</code></p></li>
</ul>
",3
52039433,52039290,1,"<p>Read carefully <a href=""https://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer"">documentation of <code>snprintf</code></a> (and/or the Linux one, <a href=""http://man7.org/linux/man-pages/man3/snprintf.3.html"" rel=""nofollow noreferrer"">snprintf(3)</a>). Notice that it could fail by returning a negative value. And you could be interested by its <code>%n</code>.</p>

<p>You need to know the size of the buffer. A good way is to pass it as a second argument to your <code>get_line_to_buffer</code> function:</p>

<pre><code>ssize_t get_line_to_buffer(char *buffer, size_t siz) {
  char* p = buffer;
  char* start = buffer;
  char* end = buffer + siz;
  int n = 0;
  if (p &lt; end)
     n = snprintf(p, siz, ""%d, %s, %s, %lu"", version, fileName, Id, timestamp);
  else
     n = snprintf(NULL, 0, ""%d, %s, %s, %lu"", version, fileName, Id, timestamp);
  if (n&lt;0) return -1;
  p += n, siz -= n;
  if (siz&lt;0) return -1;
  if (p &lt; end)
     n = snprintf(p, siz, "",%d,%d,%f"", noOfObs, frequency, sum);
  else
      n = snprintf(NULL, 0, "",%d,%d,%f"", noOfObs, frequency, sum);
  if (n&lt;0) return -1;
  p += n; siz -= n;
  return p - start;
}
</code></pre>

<p>Actually, you could consider using <a href=""http://man7.org/linux/man-pages/man3/asprintf.3.html"" rel=""nofollow noreferrer"">asprintf(3)</a> if your system has it.</p>

<p>And you might instead open a in-memory stream with <a href=""http://man7.org/linux/man-pages/man3/fmemopen.3.html"" rel=""nofollow noreferrer"">fmemopen(3)</a> or <a href=""http://man7.org/linux/man-pages/man3/open_memstream.3.html"" rel=""nofollow noreferrer"">open_memstream(3)</a> and use <code>fprintf</code> on it.</p>

<p>BTW, you might simply do a single <code>snprintf</code> but split its format control string in several physical lines:</p>

<pre><code>int n = snprintf(p, siz,  
                 ""%d, %s, %s, %lu""
                 "",%d,%d,%f"",
                 version, fileName, Id, timestamp,
                 noOfObs, frequency, sum);
</code></pre>
",1
50575271,50575058,2,"<p>Your program is not correctly handling word separators.  Instead, it contains the assumption that any word separator marks the end of a word.  So it is counting a word even when no word has started.</p>

<p>There are many ways you might approach this, but the general idea is to maintain some kind of state which represents that you are either in a word, or you are between words.</p>

<p>Here is one such example:</p>

<pre><code>int wordcount = 0;
int betweenwords = 1;
while((ch=getchar())!=EOF)
{
    if (!isspace(ch)) {
        wordcount += betweenwords;
        betweenwords = 0;
    }
    else {
        betweenwords = 1;
    }
}
</code></pre>

<p>This doesn't follow the same criteria for a word as your program (mine is treating all non-space characters as words), but it would be quite simple to adapt.  The point here is to understand that you can use some kind of state variable to determine whether to increment your word count or not.  In my example, the state variable is also used as the increment.</p>
",0
51793716,51793657,8,"<p><code>.1</code> represents one-tenth, the same as <code>0.1</code> does. However, due to a lack of strictness in the C standard, <code>.1</code> and <code>0.1</code> do not necessarily convert to the same internal value, per C 2018 6.4.4.2 5. They will be equal in all compilers of reasonable quality. (6.4.4.2 5 says ¡°All floating constants of the same source form shall convert to the same internal format with the same value.¡± Footnote 77 gives examples of source forms that have the same mathematical values but that do not necessarily convert to the same internal value.)</p>

<p>Floating-point constants in source text are converted to an internal format. Most commonly, a binary-based format is used. Most decimal numerals, including .1, are not exactly representable in binary floating-point. So, when they are converted, the result is rounded (in binary) to a representable value. In typical C implementations, <code>.1</code> becomes 0.1000000000000000055511151231257827021181583404541015625.</p>

<p>All good compilers will convert <code>.1</code> and <code>0.1</code> to the same value. The reason the C standard is lax about this is that other floating-point literals, involving exponents or many digits, were difficult (in some sense) to convert to binary floating-point with ideal rounding. Historically, there were C implementations that fudged the conversions. The C standard accommodated these implementations by not making strict requirements about handling of floating-point values. (Today, good algorithms are known, and any good compiler ought to convert a floating-point literal to the nearest representable value, with ties to the even low digit, unless the user requests otherwise.)</p>

<p>So, the C standard does not guarantee that <code>.1</code> and <code>0.1</code> have the same value. However, in practice, they will.</p>
",9
51795496,51793657,0,"<p>Eric's answer is correct if you're just talking about the baseline C standard, which makes basically no guarantees about floating point; <code>1.0==42.0</code> is a valid implementation choice. But this is not very helpful.</p>

<p>If you want any reasonable floating point behavior in C, you want an implementation that supports Annex F (the alignment of IEEE floating point semantics with C), an optional part of the standard. You can tell if your implementation supports (or claims to support) Annex F by checking for the predefined macro <code>__STDC_IEC_559__</code>.</p>

<p>Assuming Annex F, the interpretation of floating point literals is not up for grabs, and <code>.1</code> and <code>0.1</code> will necessarily be the same.</p>
",7
52280959,52280875,3,"<p>There is no variables here. The macro expands as text in place, so the 2nd excerpt becomes</p>

<pre><code>*(volatile unsigned int *)0x7051 = 0X0003;
</code></pre>

<p>It casts the unsigned integer <code>0x7051</code> into a pointer to volatile unsigned integer, then references this in assignment. Essentially it stores <code>0x0003</code> into the <code>unsigned integer</code>-wide piece of memory that starts from address <code>0x7051</code> (or, however the integer-to-pointer conversion happens to work on your target platform) </p>

<p><code>volatile</code> is required so that the compiler does not just optimize the assignment out - it must be strictly evaluated and considered a side effect (see <a href=""https://stackoverflow.com/a/46455917/918959"">as-if rule</a>).</p>

<p>As for the actual reason why this is done - it is probably some memory-mapped device, check the microcontroller datasheets for more information.</p>
",2
51706237,51705921,1,"<p>Incomplete code, so I am not able to verify, but it looks like the function shift_array_elements is out of bounds:</p>

<pre><code>void shift_array_elements(int *array_data, int size)
{
    int i = 0;
    for(i=size;i&gt;0;i--)
    {
        array_data[i] = array_data[i-1];
    }
}
</code></pre>

<p>You start from i=size which is out of bounds when called from the fir() function:</p>

<pre><code>    if((i &lt; (SAMPLES-1)))
    {
        //printf(""Reached\n"");
        shift_array_elements(inp_real_part,FIR_COEFFICIENT);
        shift_array_elements(inp_imag_part,FIR_COEFFICIENT);
    }
</code></pre>

<p>The last element here is <code>inp_real_part[FIR_COEFFICIENT-1]</code>, but shift_array_elements will assign to <code>inp_real_part[FIR_COEFFICIENT]</code>.</p>

<h2>General tips</h2>

<ul>
<li>Use the debugger (gdb) to figure out where your program crashes. Compile with <code>-g -O2</code> and run the exectuable through gdb to get a stack trace from the crash</li>
<li><code>malloc</code> will return NULL if allocation fails. Always check the returned value before you proceed when using <code>malloc/free</code>.</li>
</ul>
",1
51753943,51753563,3,"<blockquote>
<strong>7.21.3 Files</strong><br>...<br>
3 When a stream is <em>unbuffered</em>, characters are intended to appear from the source or at the
destination as soon as possible. Otherwise characters may be accumulated and
transmitted to or from the host environment as a block. When a stream is <em>fully buffered</em>,
characters are intended to be transmitted to or from the host environment as a block when
a buffer is filled. <strong>When a stream is <em>line buffered</em>, characters are intended to be
transmitted to or from the host environment as a block when a new-line character is
encountered.</strong> Furthermore, characters are intended to be transmitted as a block to the host
environment when a buffer is filled, when input is requested on an unbuffered stream, or
when input is requested on a line buffered stream that requires the transmission of
characters from the host environment. Support for these characteristics is
implementation-defined, and may be affected via the <strong><code>setbuf</code></strong> and <strong><code>setvbuf</code></strong> functions.<br>
...<br>
7 At program startup, three text streams are predefined and need not be opened explicitly
¡ª <em>standard input</em> (for reading conventional input), <em>standard output</em> (for writing
conventional output), and <em>standard error</em> (for writing diagnostic output). As initially
opened, the standard error stream is not fully buffered; the standard input and standard
output streams are fully buffered if and only if the stream can be determined not to refer
to an interactive device.
</blockquote>
<p><sup><em><a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C 2011 online draft</a></em></sup></p>
<p>On most interactive environments, standard input and standard output are <em>line-buffered</em>.  So yeah, output will be buffered until a newline is seen, or the output operation is immediately followed by an input operation (or <code>fflush</code> call).</p>
",0
54959882,54959809,3,"<p>There are a number of problems with this.</p>

<ol>
<li><p>You're <code>printf</code>ing with the wrong format string. <a href=""https://stackoverflow.com/q/2524611/560648"">Use <code>%zu</code> for a <code>size_t</code>, not <code>%d</code></a>.</p></li>
<li><p>Your <code>printf</code> has undefined behaviour because you have <code>*s</code> and <code>*s++</code> in the same expression, with no <a href=""https://stackoverflow.com/q/3575350/560648"">sequence point</a> between them.</p></li>
<li><p>You're recalculating <code>strlen(s)</code> on every iteration of the loop, and that value goes down and down and down because you keep incrementing <code>s</code>. I'd cache <code>strlen(s)</code> into a variable called <code>n</code> (or somesuch) before you start, as <code>n</code> won't change.</p></li>
</ol>

<p>My compiler warned me about all but the third bug.</p>

<p>This program works:</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#define bool int
#define true 1
#define false 0

static bool is_digit(char c){
    return c &gt; 47 &amp;&amp; c &lt; 58;
}


int main(){
    const char *s = ""123456"";
    size_t i;
    const size_t n = strlen(s);
    printf(""len = %zu\n"", n);
    for(i = 0; i&lt;n; ++i){
        printf(""%c : %s\n"", *s, is_digit(*s)? ""true"" : ""false"");
        s++;
    }
    return 0;
}
</code></pre>

<h3>(<a href=""https://coliru.stacked-crooked.com/a/0b621fb5ad533103"" rel=""nofollow noreferrer"">live demo</a>)</h3>

<p>You could also skip the <code>strlen</code> entirely and just look out for a null terminator:</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#define bool int
#define true 1
#define false 0

static bool is_digit(char c){
    return c &gt; 47 &amp;&amp; c &lt; 58;
}


int main(){
    const char *s = ""123456"";
    while (*s) {
        printf(""%c : %s\n"", *s, is_digit(*s)? ""true"" : ""false"");
        s++;
    }
    return 0;
}
</code></pre>

<h3>(<a href=""https://coliru.stacked-crooked.com/a/e81062e7ef175f64"" rel=""nofollow noreferrer"">live demo</a>)</h3>
",0
53874016,53868006,0,"<p>I'm fairly sure it's a bad idea to clear a timer after you've started it running:</p>

<pre><code>while(PORTBbits.RB0==0 );       // RB0 is             connected to Echo pin
T1CONbits.TMR1ON=1;         
TMR1H=0; 
TMR1L=0;        /* Load Timer1 with 0*/ 
</code></pre>

<p>At the very least your final time will be short by the time it takes for the two instructions to execute.  In the worst case, the whole reading could be garbage.</p>
",0
55052506,55052252,2,"<p>The C Standard mandates that the characters <code>'0'</code>, <code>'1'</code>, ..., and <code>'9'</code> be sequential and consecutive. So we know the value of <code>'1'</code> is 1 greater than the value of <code>'0'</code> (and similarly for the other digits).</p>

<p>Taking the above into consideration, we know that</p>

<pre><code>'0' - '0' == 0;
'1' - '0' == 1;
....
'9' - '0' == 9;
</code></pre>

<p>Note that all of the above <strong>must</strong> work as I described, whether running on an ASCII based computer, or EBCDIC, or Klingon, or whatever.</p>

<p>So, to compare digits in character form (<code>'0'</code>, ..., <code>'9'</code>) with integer values (<code>0</code>, ..., <code>9</code>) simply subtract <code>'0'</code> from the char.</p>

<pre><code>if (index == currentChar - '0') /* ... */;
</code></pre>
",0
51751539,51749489,1,"<p><strong>Equivalent code</strong></p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
    static int i = 5;
    i = i - 1;
    if (i != 0){
        printf(""%d "", i);
        main(i);
    }
}
</code></pre>

<p><strong>Stack trace</strong> </p>

<pre><code>i=5, print 4, call main(4) 
    i=4, print 3, call main(3)
        i=3, print 2, call main(2)
            i=2, print 1, call main(1)
                i=1, if(i--) is false, returns
            returns
        returns
     returns
returns
</code></pre>
",0
52042063,52041083,3,"<p>The main issue is that you never update <code>currentRow</code> or <code>currentColumn</code>, so all moves happen from their initial values.</p>

<p>Some other notes: You should avoid ""magic numbers"" - <code>8</code> in this case. If you decide to change the size of the array, you have to search through all the code and find the eights and replace them. Use a <code>define</code> or <code>const int</code>.</p>

<p>You should always check the return value from <code>scanf</code>. What if the user types <code>a</code>, for example?</p>

<p>Array bounds checking is needed. What happens when a move takes the knight off the board - and past the bounds of the array?</p>

<pre><code>#include &lt;stdio.h&gt;

// Avoid magic numbers
#define ROWS 8
#define COLS 8

int main(){

    int board[ROWS][COLS] = {0};
    int currentRow = 4, currentColumn = 4;
    int cont = 0, moveNumber = 0, i, j;

    // Loop forever
    while (1) {
        printf(""Enter a move: "");
        // Make sure user enters a number
        while (1 != scanf(""%d"", &amp;moveNumber)) {
            // clear stdin
            int c;
            while((c = getchar()) != '\n' &amp;&amp; c != EOF);
            // See https://stackoverflow.com/a/6277391/669576
            // for why fgets/sscanf is a better option than scanf

            // Prompt user for new input
            printf(""Enter a valid integer:"");
        }
        // Moved this here
        if (moveNumber &lt; 0 || moveNumber &gt; 7) break;
        cont++;
        // Going to use some temp vars to calculate indices
        int tempRow, tempCol;
        // Calc new indices
        switch (moveNumber) {
            case 0:
                tempRow = currentRow - 1;
                tempCol = currentColumn + 2;
                break;
            case 1:
                tempRow = currentRow - 2;
                tempCol = currentColumn + 1;
                break;
            case 2:
                tempRow = currentRow - 2;
                tempCol = currentColumn - 1;
                break;
            case 3:
                tempRow = currentRow - 1;
                tempCol = currentColumn - 2;
                break;
            case 4:
                tempRow = currentRow + 1;
                tempCol = currentColumn - 2;
                break;
            case 5:
                tempRow = currentRow + 2;
                tempCol = currentColumn - 1;
                break;
            case 6:
                tempRow = currentRow + 2;
                tempCol = currentColumn + 1;
                break;
            case 7:
                tempRow = currentRow + 1;
                tempCol = currentColumn + 2;
                break;
        }
        // Make sure we have valid indices
        if (tempRow &lt; 0 || tempCol &lt; 0 || tempRow &gt;= ROWS || tempCol &gt;= COLS) {
            printf(""Illegal move\n"");
        }
        else {
           // Update the board
           currentRow = tempRow;
           currentColumn = tempCol;
           board[currentRow][currentColumn] = 1;
           // And print
           for(i = 0; i &lt; ROWS; i++){
               for(j = 0; j &lt; COLS; j++){
                   printf(""%d "", board[i][j]);
               }
               printf(""\n"");
           }
           printf(""Total moves: %d\n"", cont);
        }
    }

    return 0;
}
</code></pre>
",2
51866979,51754913,1,"<p>I think you are asking two different questions.</p>

<p><strong>File contents</strong></p>

<p>If the file contains textual data, i.e., lines of characters delimited by newlines, then it is a <em>text</em> file.</p>

<p>Otherwise it is presumed to contain data in some form other than strictly character data, such as binary integers, floating-point numbers, image pixels, music samples, structured binary data, etc., which means that it is a <em>binary</em> file, i.e., a <em>non-text</em> file.</p>

<p>There are many other text file formats, such as <code>.xml</code>, <code>.html</code>, <code>.csv</code>, as well as programming language source code files. These are strictly character text files, but generally have some kind of internal structure based on the syntax of their contents.</p>

<p>That being said, all text files are inherently binary files, in the sense that the characters, newlines, and so forth comprising the textual data in the file are nothing more that a stream of bytes at the lowest level.</p>

<p><strong>File name</strong></p>

<p>Specifically, the filename <em>extension</em> or <em>suffix</em>. By convention, files with a <code>.txt</code> extension are presumed to contain text data, i.e., lines of character data delimited by some kind of newline sequences.</p>

<p>A different filename extension like <code>.bin</code> or <code>.exe</code> (or a hundred others) indicate some kind of binary data file, usually structured in some way. By convention, <code>.bin</code> indicates binary data with no specific format, i.e., just a stream of bytes.</p>

<p>In addition, there are files having an extension like <code>.doc</code> or <code>.pdf</code> (or dozens of others), indicating a <em>word processing document</em> file. These files also contain character text data, but it is typically stored in some kind of strictly binary format that is specific to the word processing software used to create it.</p>
",0
51755286,51754913,8,"<p>@JohnBollinger summarized it best in a comment.</p>

<blockquote>
  <p>text vs. binary is not a fundamental file characteristic on modern operating systems, but rather a differentiation between how files are <em>interpreted</em>.</p>
</blockquote>

<p>Let's say a file contains four bytes with the following hex values of the bytes:</p>

<pre><code>0x41 0x42 0x43 0x44
</code></pre>

<p>If you interpret those bytes as characters in a system that uses ASCII encoding, you will get the characters <code>ABCD</code>.</p>

<p>If you treat those bytes as a 4-byte integer, you will get the value <code>0x41424344</code> (1094861636 in decimal) in a big endian system and <code>0x44434241</code> (1145258561 in decimal) in a little endian system.</p>

<p>As far as the computer is concerned, it's all binary. As to what they mean, it's all a matter of intepretation.</p>
",1
52468940,52468629,0,"<p>It blew right past the <code>gets</code> line. Why? Because <a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow noreferrer"">the scanf family has lots and lots of problems</a>. Avoid them.</p>

<p><a href=""http://c-faq.com/stdio/scanfhang.html"" rel=""nofollow noreferrer"">Specifically it tends to leave input on the buffer</a>. In this case <code>scanf(""%s"", name);</code> read in all the text and left a newline on <code>stdin</code>. Then <code>gets</code> dutifully read that newline... and throws it out because that's how <code>gets</code> behaves. We can see this if we print name and content just before <code>gets</code>.</p>

<pre><code>printf(""name: '%s'\n"", name);
printf(""content: '%s'\n"", content);

name: 'foo'
content: ''
</code></pre>

<p>Then your program dutifully writes nothing to the file.</p>

<p>Instead, use <code>fgets</code> to read entire lines, and <code>sscanf</code> to parse them. This avoids the danger of leaving input on the buffer.</p>

<pre><code>printf(""Enter file name:\n"");
fgets(name, sizeof(name), stdin);

printf(""Enter the content:\n"");
fgets(content, sizeof(content), stdin);
</code></pre>

<p><code>fgets</code> does not strip newlines, so you'll have to do that yourself. <a href=""https://stackoverflow.com/questions/2693776/removing-trailing-newline-character-from-fgets-input#28462221"">There's a variety of ways to do it</a>.</p>

<pre><code>void trim( char *string, char to_trim ) {
    size_t len = strlen(string);
    if( len == 0 ) {
        return;
    }
    size_t last_idx = len -1;
    if( string[last_idx] == to_trim ) {
        string[last_idx] = '\0';
    }
}
</code></pre>

<p>I prefer this approach because it only removes the newline if it's the final character.</p>

<p>Finally, <strong><em>always check your file operations</em></strong>. You're not checking if the <code>fopen</code> succeeded. If it fails for whatever reason you'll get another mysterious error. In my case the name I was using for testing already existed as a directory.</p>

<pre><code>#include &lt;string.h&gt;  // for strerror
#include &lt;errno.h&gt;   // for errno

fp = fopen(name, ""w"");
if( fp == NULL ) {
    fprintf(stderr, ""Could not open '%s' for writing: %s.\n"", name, strerror(errno));
    return 1;
}
</code></pre>
",0
55497831,55497456,0,"<blockquote>
  <p>Why wouldn't a header file be used?</p>
</blockquote>

<p>It doesn't make a real difference, header files are just textual inclusion anyway. It <em>makes sense</em> to put declarations in header files, especially if they're used in several places, but it's not <em>required</em>. As long as every compilation unit agrees on what the name means, things will work fine.</p>

<blockquote>
  <p>Why declare the functions in a different source file with different signatures?</p>
</blockquote>

<p>They don't have <em>different</em> signatures; if they did, there would be a problem. But the declaration in <code>info.c</code> has <em>no</em> parameter list. This is allowed as long as ""the parameter list <em>[in the definition]</em> shall not have an ellipsis terminator and the type of each parameter shall be compatible with the type that results from the default argument promotions"" (N1256 6.7.5.3, which is probably the wrong version of the spec for application to Doom, but it doesn't really matter). In other words, if a function is declared without a signature, the number and types of its parameters will be inferred from how it's called. As long as this inference is <em>correct</em>, you have a valid program that will work correctly. It's just old-fashioned, and because of the lack of explicitness, a bit harder to maintain.</p>
",0
55497500,55497456,3,"<p>This is not good practice I think. But based on my understanding of the C standard, when you declare a function like <code>void A_Pain();</code> basically that function can take any number of parameters, which is different from C++. So in C you need to use <code>void A_Pain(void);</code> to say it has no parameter.</p>

<p>But in C++, <code>void A_Pain();</code> means that it takes no parameters.</p>
",3
55497584,55497456,0,"<p>In C, the declaration <code>T f()</code> does not declare a function <code>f</code> returning <code>T</code> and taking zero parameters; it declares a function <code>f</code> returning <code>T</code> and accepting an unspecified number of parameters.</p>

<p>You can put function declarations in a source file even if the function definition is in a translation unit that your source file is not aware of, since joining it all together is done by the linker, not the compiler.</p>
",0
55497831,55497456,0,"<blockquote>
  <p>Why wouldn't a header file be used?</p>
</blockquote>

<p>It doesn't make a real difference, header files are just textual inclusion anyway. It <em>makes sense</em> to put declarations in header files, especially if they're used in several places, but it's not <em>required</em>. As long as every compilation unit agrees on what the name means, things will work fine.</p>

<blockquote>
  <p>Why declare the functions in a different source file with different signatures?</p>
</blockquote>

<p>They don't have <em>different</em> signatures; if they did, there would be a problem. But the declaration in <code>info.c</code> has <em>no</em> parameter list. This is allowed as long as ""the parameter list <em>[in the definition]</em> shall not have an ellipsis terminator and the type of each parameter shall be compatible with the type that results from the default argument promotions"" (N1256 6.7.5.3, which is probably the wrong version of the spec for application to Doom, but it doesn't really matter). In other words, if a function is declared without a signature, the number and types of its parameters will be inferred from how it's called. As long as this inference is <em>correct</em>, you have a valid program that will work correctly. It's just old-fashioned, and because of the lack of explicitness, a bit harder to maintain.</p>
",0
55497500,55497456,3,"<p>This is not good practice I think. But based on my understanding of the C standard, when you declare a function like <code>void A_Pain();</code> basically that function can take any number of parameters, which is different from C++. So in C you need to use <code>void A_Pain(void);</code> to say it has no parameter.</p>

<p>But in C++, <code>void A_Pain();</code> means that it takes no parameters.</p>
",3
51251098,51251025,0,"<p>You need to pass in a and b to your sum function, and not declare them as local variables.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void sum(int a, int b) {
    int sum = a+b;
    printf(""sum is %d"", sum);
}


int main()
{
    int a, b;
    printf(""Enter a:\n"");
    scanf(""%d"", &amp;a);
    printf(""enter b\n"");
    scanf(""%d"", &amp;b);

    sum(a,b);
}
</code></pre>
",2
52723275,52722961,1,"<p>There's no standard way to do a range check as part of an input operation in C - IOW, you can't tell <code>scanf</code> to reject an integer input that's outside of a specific range.  You will have to add a range check separately:</p>

<pre><code>if ( scanf( ""%d%d"", &amp;x, &amp;y ) == 2 ) // make sure both x and y are read
{
  if ( 0 &lt; x &amp;&amp; x &lt; 1000 &amp;&amp; 0 &lt; y &amp;&amp; y &lt; 1000 )
  {
    z = x + y;
    printf( ""z = %d\n"", z );
  }
  else
  {
    printf( ""Both x and y must be between 0 and 1000\n"" );
  }
}
else
{
  printf( ""At least one bad input for x or y\n"" );
}
</code></pre>
",0
54711377,54711266,3,"<p>Since the C99 standard, if there's no explicit <code>return</code> statement from the <code>main</code> function then an <em>implicit</em> <code>return 0;</code> will be added by the compiler.</p>

<p>Then you can have empty blocks of code using only <code>{}</code>.</p>

<p>Putting it together it could be something like</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    if (printf(""Hello\n""))
    {
    }
}
</code></pre>
",0
54711348,54711266,4,"<p>As long as <code>main</code> is declared with a type compatible with <code>int</code>, it will return 0 at the last <code>}</code> if there is no explicit return statement:</p>

<p><a href=""https://port70.net/~nsz/c/c11/n1570.html#5.1.2.2.3p1"" rel=""nofollow noreferrer""><strong>C Standard, &sect; 5.1.2.2.3</strong></a>, <em>Program Termination</em>:</p>

<blockquote>
  <p>If the return type of the main function is a type compatible with int, a return from the initial call to the main function is equivalent to calling the exit function with the value returned by the main function as its argument; reaching the } that terminates the main function returns a value of 0.</p>
</blockquote>

<p>So this code will work:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    if(printf(""Hello""))
    {

    }
}
</code></pre>

<p>The real question is why you would want to write a program without semicolons. <a href=""https://www.ioccc.org/"" rel=""nofollow noreferrer"">IOCCC</a> submissions are usually a bit more involved than just that.</p>
",4
51865489,51865447,1,"<p>0 is false, ie. not true.</p>

<p>That is why the first if-statement behaves like it does.</p>

<p>And a=0 assigns 0 to a, which is the reason for its value afterwards. </p>
",0
55697325,55695042,1,"<p>You seem to be making the problem harder than it needs to be, at least conceptually.  You have a sorted array, and you have a binary search tree.  An in-order traversal of the tree will visit the nodes in order of the values they hold.  By matching the the node values traversed to the elements of your list, you can detect which values are missing from the tree and which are extra -- even in the presence of multiple elements and / or multiple nodes having the same value, and even if there are the same number of nodes as values.  At each node:</p>

<ul>
<li>if we've exhausted the array, then the node is extra, else</li>
<li>if the current node has the expected value, then it's a match.  We'll expect the next node to have the next value.</li>
<li>if the current node has a value less than expected then it's extra.  We'll expect the next node to have the current expected value.</li>
<li>else the current node has a value greater than expected, so a node with the expected value must have been deleted.  We'll then try again with the same node, expecting it to have the next value.</li>
</ul>

<p>After the traversal is complete, any list elements after the last one matched or considered correspond to deleted nodes.</p>

<p>That's enough to identify the differences, but that approach does not afford updating the tree as you go, because mutating the tree affects traversal order.  You therefore have (at least) these alternatives:</p>

<ol>
<li>when you detect a tree mutation, correct it immediately and then restart from the beginning, or</li>
<li>make a list of the mutations as you go, and fix them all after completing the traversal, or, of course,</li>
<li>after the traversal, just build a new tree from your array.</li>
</ol>
",0
51870988,51870480,1,"<p>Compilers traditionally don't warn for omitting the result of library function calls. Functions like <code>printf</code>, <code>scanf</code> and <code>memcpy</code> do return something, yet someone back in the dark ages of K&amp;R decided to implicitly skip checking the result of the functions. It became de facto standard. Although to this day, skipping the result remains bad practice in many cases (like in the case of <code>scanf</code>).</p>

<p>Compilers do warn if you don't check the result of application functions though, because that's almost always a bug. If you deliberately don't want to check the result, you should write <code>(void) func();</code> to silence such warnings.</p>

<hr>

<p>(Side note: <code>read</code> and <code>close</code> aren't standard C, but Unix API. Still they are library functions.)</p>
",3
58036623,58035891,0,"<p>Answering your question. <code>bex</code> is declared as <code>int bex[10]</code>, array of integers. <code>printf(""%s""...</code> expects a character string, not an array of int.</p>

<ul>
<li><p>A character string is usually an array of chars <code>char bex[10]</code>. Char is a single byte, and an int is usually 4-byte long. So, you see the difference there. In your example you modify the lowest byte of the 'int', leaving other 3 as '0'.  </p></li>
<li><p>printable chars  have corresponding codes. For example a char of '0' has code of <code>48</code> in asccii encoding. All other chars that represent numbers have consecutive codes (48..57). This how the <code>printf</code> and other services know what to print if they see <code>48</code> in the byte.</p></li>
<li><p>the string in 'c' ends with a stray <code>0</code>, so that the <code>printf</code> knows where to stop reading the chars. </p></li>
</ul>

<p>So, if you want to print 'bex' as a string, you need to create it as a string. for example</p>

<pre><code>char bex[10];

 for (i=0; i &lt;8; i++)
     bex[A++] = '0' + i; // code of '0' + a number
 bex[A] = 0; // string terminator
</code></pre>

<p>Just make sure that your 'A' is always less than '8' to avoid  array overflow (string length of 9  plus one character for the terminator. Now you can do this.</p>

<pre><code> printf(""%s"", bex);
</code></pre>

<p>You have to work on the rest of the program, because it does not do anything useful in the current state, but this should help you to get going. </p>
",0
52234425,52234375,1,"<p>I recommend you use the input <em>string</em> to convert to an integer value using base 2 (using e.g. <a href=""http://en.cppreference.com/w/c/string/byte/strtol"" rel=""nofollow noreferrer""><code>strtol</code></a>). Then it's easy to convert that integer value to a character corresponding to the hexadecimal value.</p>

<p>Perhaps something like this:</p>

<pre><code>char nibbleToHex(char *nibble)
{
    int value = strtol(nibble, NULL, 2);

    if (value &lt; 10)
        return value + '0';  // Return a character from '0' to '9'
    else
        return value + 'A';  // Works with ASCII encoding, not portable
}
</code></pre>

<p>With the <code>strtol</code> function you can also add some validation that the input is correct.</p>

<hr>

<p>If you're not allowed to use standard functions (except the input/output functions) then you can use a loop and use bitwise shift and addition.</p>

<p>First of all remember that all strings in C are terminated, which means if the user doesn't enter all four digits you can still loop by checking for the terminator in your condition instead of hard-coding four iterations.</p>

<p>Secondly I still recommend you create an integer value instead of a character directly. Mostly because it's easier.</p>

<p>Then for the actual code:</p>

<pre><code>char nibbleToHex(char *nibble)
{
    int value = 0;  // The value we construct

    // Loop while the character nibble points to is not the terminator
    while (*nibble != '\0')
    {
        value &lt;&lt;= 1;  // Left-shift one bit
        value += *nibble - '0';  // Add the digit

        ++nibble;  // Point to the next character
    }

    if (value &lt; 10)
        return value + '0';  // Return a character from '0' to '9'
    else
        return value + 'A';  // Works with ASCII encoding, not portable
}
</code></pre>
",2
51972858,51972556,5,"<blockquote>
  <p>How is <code>*q</code> accessing the elements of <code>p</code>?</p>
</blockquote>

<p>It does so through a <code>char</code> pointer, using a rule that the address of the <code>struct</code> must match the address of its initial element (i.e. field <code>p.x</code>). However, the standard allows the compiler to insert padding after <code>x</code>, so adding <code>1</code> to <code>((char*)q)</code> may not necessarily yield the address of <code>y</code>.</p>

<p>You can fix your program as follows:</p>

<pre><code>printf(
    ""%c, %c""
,   *((char *)q + offsetof(struct Ournode, y))
,   *((char *)q + offsetof(struct Ournode, z))
);
</code></pre>

<p>Since <code>((char*)q)</code> points to part of <code>int</code> field <code>a</code>, printing <code>%c</code> from these addresses yields implementation-defined re-interpretations of parts of <code>int</code>'s representation as <code>char</code>. As far as printing <code>int</code>s is concerned, you should add the same <code>offsetof</code> trick to counter the results of potential padding.</p>

<p><strong>Note:</strong> I am yet to see a compiler that inserts padding between <code>char</code>s, but I didn't find anything in the standard preventing it from doing so. The situation would be different if instead of <code>char x, y, z</code> you used <code>char x[3]</code>, because padding between array members is not allowed.</p>
",0
53284648,53283705,0,"<p>If using gcc, you should be getting a warning like this:</p>

<blockquote>
  <p>passing argument 1 of 'Charge' from incompatible pointer type | expected <code>float * (*)[10]</code> but argument is of type <code>float (*)[15][10]</code></p>
</blockquote>

<p>Meaning that the prototype should have been <code>void Charge(float (*p)[15][10])</code> - an array pointer to a <code>float [15][10]</code> rather than a 2D array of <code>float*</code> which is not what you wanted.</p>

<hr>

<p>But there's not really a reason to use this array pointer syntax. It is much clearer to do like this:</p>

<pre><code>float arr[15][10];
...
Charge(arr);
...
void Charge (float arr[15][10]);
</code></pre>

<p>Thanks to array decay, this does pass an array pointer to the function. And now you can use it inside the function as <code>arr[i][j]</code> rather than <code>(*p)[i][j]</code>.</p>

<hr>

<p>Using 21th century C, you can also do this:</p>

<pre><code>float arr[15][10];
...
Charge(15, 10, arr);
...
void Charge (size_t x, size_t y, float arr[x][y]);
</code></pre>
",0
51937769,51937358,0,"<p>You have a couple of ways to go with this.  </p>

<p><code>scanf</code> returns the number of successful conversions and assignments.  If you're expecting a single decimal integer input and the first thing you see is <code>'x'</code>, then you have a <em>matching failure</em>, and <code>scanf</code> will return 0.  So, you can do something like</p>

<pre><code>printf( ""Gimme a number: "" );
if ( scanf( ""%d"", &amp;n ) == 1 )
{
  // do something with n
}
else
{
  if ( !feof( stdin ) )
  {
    // user entered something that isn't a decimal digit
  }
  else
  {
    // EOF signaled on input stream (ctrl-D, ctrl-Z, EOF from redirected file, etc.).
  }
}
</code></pre>

<p>The problem is that this leaves unmatched input in the stream to foul up the next read.  A better solution IMO is one that reads everything as text, then uses <code>strtol</code> to convert the text to an integer.  </p>

<pre><code>#include &lt;stdlib.h&gt; // for strtol
#include &lt;ctype.h&gt;  // for isspace

#define MAX_INPUT_LENTH 13 // enough for 10 decimal digits plus sign plus newline plus string terminator

char input[MAX_INPUT_LENGTH+1];

printf( ""Gimme a number: "" );
if ( fgets( input, sizeof input, stdin ) )
{
  char *chk; // will point to first character in input that *isn't* a
             // decimal digit
  int tmp = strtod( input, &amp;chk, 10 );
  if ( !isspace( *chk ) &amp;&amp; *chk != 0 )
  {
    // input is not a valid decimal integer
  }
  else
  {
    n = tmp; // don't assign n until you know you have valid input
  }
}
else
{
  if ( feof( stdin ) )
  {
    // end-of-file signaled on input stream
  }
  else
  {
    // error during input
  }
}
</code></pre>

<p>Neither of these solutions are in a loop, but you should be able to figure out how to integrate them into a looping structure.  </p>
",0
52865882,52865805,1,"<p>The first time you call <code>enQ()</code> it's with a null pointer indicating that a new queue should be created. <code>enQ()</code> creates a new node and returns a pointer to it. </p>

<p>On subsequent calls you are correct that the return value isn't needed as it simply returns back the same <code>Q</code> that was passed in, but the first time the return value is indeed necessary. Without it calling <code>enQ(NULL, i)</code> won't have any way to return the new queue to the caller.</p>
",4
54921707,54921374,7,"<blockquote>
<p>Does it means that for external names, only the 6 leading chars are valid and remaining chars are all ignored? For example, we defined two external variable myexvar1 and myexvar2, the compiler will treat these two variables as one?</p>
</blockquote>
<p>Yes this was true in 1990. Or rather, 6 unique leading characters of external identifiers was what the C90 standard set as <em>minimum</em> limit for a compiler. This was of course madness - which is why this limit was increased to 31 in C99.</p>
<p>In practice, most C90 compilers had at least 31 unique characters for internal and external identifiers both.</p>
<hr />
<blockquote>
<p>If this is true, why they advise us to use longer names for external variables?</p>
</blockquote>
<p>Not sure if they advise it. But the coding style used in K&amp;R is often plain horrible, so it is definitely not a book you should consult for coding style advise.</p>
<hr />
<p>In modern C, it is required (C17 5.2.4.1) that we have:</p>
<blockquote>
<p>63 significant initial characters in an internal identifier or a macro name</p>
<p>31 significant initial characters in an external identifier</p>
</blockquote>
<p>So don't worry too much about which limitations the dinosaurs faced, but follow modern standard C.</p>
<p>As pointed out in another answer, even the restriction of 31 significant initial characters for external identifiers is listed as obsolete, meaning this might get increased even further, to 255, in future standards.</p>
",0
54922045,54921374,2,"<p>This is due to the historical background concerning the length of exported symbols to the linker of the system.</p>
<p>I quote from <a href=""http://www.knosof.co.uk/cbook/cbook.html"" rel=""nofollow noreferrer"">The New C Standard -- An Economic and Cultural Commentary</a>.</p>
<blockquote>
<p>The values of 6 and 10 were chosen so that the encodings \u1234 and
\U12345678 could be used.</p>
<p>The Fortran significant character limit of six was followed by many
suppliers of linkers for a long time. The need for longer identifiers
to support name mangling in C++ ensured that most modern linkers
support many more significant characters in an external identifier.</p>
<p>Common Implementations</p>
<p>Historically, the number of significant
characters in an external identifier was driven by the behavior of the
host vendor-supplied linker. Only since the success of MS-DOS have
developers become used to translator vendors supplying their own
linker. Previously, most linkers tended to be supplied by the hardware
vendor. The mainframe world tended to be driven by the requirements of
Fortran, which had six significant characters in an internal or
external identifier. In this environment it was not always possible to
replace the system linker by one supporting more significant
characters. The importance of the mainframe environment waned in the
1990s. In modern environments it is very often possible to obtain
alternative linkers.</p>
</blockquote>
<p>So the main issue was to be able to link together libraries compiled in C with libraries compiled in Fortran, and Fortran imposed the limit of 6.</p>
<p>You can read more at the given reference.</p>
",0
54921984,54921374,2,"<p>Truth be told K&amp;R is pretty old, so I assume things have changes since then.
I really don't know the reason why the give exactly 6 characters here:</p>

<blockquote>
  <p>For external names, the standard guarantees uniqueness only for 6 characters and a single case.</p>
</blockquote>

<p>But you have to understand that all compiler does is translating a translation unit (usually a <code>*.c</code> file) into an object file (<code>*.o</code>). That's it. Compiler does not produce a ready to run program. </p>

<p>Those object files might contain references to unresolved symbols to be found in other object files as well as a table of their own external symbols, the ones they provide to be referenced from the outside. The symbols do have textual names, which are the names you've given to your external variables.</p>

<p>Linkers and dynamic loaders still have to do their jobs to build the program and get it running. Along the way the have to resolve all unresolved symbols, so they perform textual lookup for those symbols in object files. Linkers and loaders are not compiler. The might have their own rules about treating those names (back in the days of K&amp;R, I guess). That's what this ...</p>

<blockquote>
  <p>because external names may be used by assemblers and loaders over which the language has no control.</p>
</blockquote>

<p>... is about.</p>

<p>These days though all your K&amp;R concerns sound outdated and irrelevant. Pick a newer standard to follow.</p>
",0
53055353,53054945,0,"<p>The issue lies in the following function.  Your if statement only has a single <code>=</code> sign.  This is causing the position <code>0, 0</code> to be set to <code>'_'</code> and return false.</p>

<pre><code>_Bool check_table_full(char board[SIZE][SIZE])
{
int a, b;
for (a=0; a&lt;SIZE; a++) {
    for (b=0; b&lt;SIZE; b++) {
        if (board[a][b]=='_') {  // &lt;==== Fixed the double equal sign
            return false;
        }
        else {
            return true;
        }
    }
}
}
</code></pre>

<p>I would certainly recommend you clean up formatting as you go.  Also, you mentioned above that you were using GCC.  For a simple learning program such as this one, you should probably be compiling with <code>-Wall</code> as an option to show all warnings.  That will flag a few other issues with this code as well.</p>
",1
52096309,52096222,2,"<p>The problem is this:</p>

<pre><code>k = strlen(words[j]);
</code></pre>

<p>You need to <em>increase</em> <code>k</code> by the length of the string:</p>

<pre><code>k += strlen(words[j]);
</code></pre>

<p>Or simply use <a href=""http://en.cppreference.com/w/c/string/byte/strcat"" rel=""nofollow noreferrer""><code>strcat</code></a> to concatenate the strings:</p>

<pre><code>strcat(mem, words[j]);
</code></pre>

<p>Of course, this requires you to initialize <code>mem[0]</code> to the string terminator character <code>'\0'</code> first.</p>
",1
53202205,53202069,2,"<p>This kind of works by accident. <code>p</code> is a char pointer; so <code>*p</code> is always a char. </p>

<ul>
<li><p>You take the address of <code>a</code>, converting it into a <code>long int *</code>. It already was a <code>long int *</code>, because you took an address of a <code>long int</code> - so this doesn't really do anything. Then you stuff it into <code>p</code>, which is a <code>char *</code>. It cannot remain a <code>long int *</code> while in a <code>char *</code> variable; it's now a <code>char *</code>. Now, you are apparently on a machine that uses <a href=""https://en.wikipedia.org/wiki/Endianness#Little-endian"" rel=""nofollow noreferrer"">little-endian</a> architecture, like the majority of us, so the least byte comes first: your <code>long int a</code> is represented as <code>[10, 0, 0, 0]</code>, and <code>*p</code> reads the first byte. Then another idiosyncracy of C comes into play: all integral parameters smaller than <code>int</code> are passed as <code>int</code>; so the byte <code>10</code> gets converted into an <code>int</code> and pushed to the stack (or handed through an integer register in newer architectures' ABI), which is then correctly read off by <code>printf</code> using <code>%d</code> format, expecting an <code>int</code>.</p></li>
<li><p>For <code>char ch</code>, <code>*p</code> doesn't read the <em>first</em> byte, it reads the <em>only</em> byte; and the rest is all the same. Ditto for the rest of integral types, where you were kind enough never to go over <strike>255</strike> 127 [thanks, Antti Haapala!] (or you'd see an unexpected result).</p></li>
<li><p>However, <code>float b</code> is a different story. Floats are represented in memory in a very different way than integers; when <code>*p</code> reads the first byte, it gets something quite unrelated to <code>16.89</code> - kind of like trying to guess a painting while looking through a kaleidoscope. The first byte gets expanded to int and passed to the function. In an older architecture, it would then get read as if it were float, but in <a href=""https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions"" rel=""nofollow noreferrer"">current ABIs</a>, where up to four (MS) or six (UNIX) integral and float parameters get passed through registers, it doesn't even get looked at (since it gets passed through an integral register, but <code>%f</code> will look at a float register). Remember, this is mostly because your pointer ends up as a <code>char *</code>, because of the way you store it.</p></li>
<li><p>In <code>decimal(b)</code>, you do something very different: you cast the pointer <em>where it matters</em>. So here, the value of <code>p</code> gets to be a <code>float *</code> for a bit; then you dereference it, and correctly get <code>16.89</code>; then you convert that to an <code>int</code>, and end up with <code>16</code> (which you print with <code>%d</code>, so all is fine).</p></li>
</ul>

<p>tl;dr: Type of C variables is set in stone. Any casts you do only matter while you're not storing them - as soon as you put them in a variable, the type is the variable's type.</p>
",13
53202266,53202069,0,"<p>it should have worked had the typecast during <code>printf</code> is correct</p>
<pre><code>printf(&quot;Value of b(float): %f\n&quot;, *(float *)p);
</code></pre>
<p>the <code>float</code> types do not represent in a similar as that of any other integral data types essentially they essentially follow <a href=""https://en.wikipedia.org/wiki/IEEE_754"" rel=""nofollow noreferrer"">floating point standard</a></p>
<p>now <code>printf</code> in your code expects a <code>%f</code> on the other hand <code>*p</code> is of type char, already an <em>undefined behavior</em> is induced in here</p>
",0
52533388,52533290,0,"<p>C uses braces to form blocks, your <code>power()</code> function looks like it's wanting to use indentation like in Python.</p>

<p>It should probably be:</p>

<pre><code>int power(int x, int y)
{
    int la, ans;
    if(y==0)
        return 1;
    else
    {
        la= (x*power(x, y-1));  
        ans+=la;
        return ans;
    }
}
</code></pre>

<p>Of course since the first <code>if</code> has a <code>return</code>, the <code>else</code> is pointless, and you can simplify the code:</p>

<pre><code>int power(int x, int y)
{
    if (y==0)
        return 1;
    return x * power(x, y-1);
}
</code></pre>

<p>The variable <code>ans</code> was never assigned to, that looked broken so I simplified it out.</p>

<p>Of course this is susceptible to integer overflow.</p>
",2
52533649,52533290,1,"<p>Some problems in your code.</p>

<ol>
<li><p>As pointed in another answer, your <code>power</code> function was broken:</p>

<ul>
<li><code>ans</code> was not initialized</li>
<li><code>{</code> <code>}</code> were missing after the <code>else</code></li>
</ul></li>
<li><p>in the <code>while</code>, you compute <code>x^x</code>, but you forget the result, whearas you
should sum it.</p></li>
<li><p>first thing you do in <code>while</code> loop is to decrease <code>n</code> and to compute <code>power(n-1, n-1)</code>
that sound not logical.</p></li>
</ol>

<p>Hence, your corrected code could be:    </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int power(int x, int y)
{
    if(y==0)
        return 1;
    else
        return x*power(x, y-1);  
}
int main()
{
    int t;
    scanf(""%d"", &amp;t);
    while(t--)
    {
        int n, m, b, a = 0;
        scanf(""%d%d"", &amp;n, &amp;m);
        while(n&gt;1)
        {
            --n;
            b = power(n, n);
            a += b;
            printf(""%d^%d -&gt; %3d\n"",n, n, b);                
        }
        printf(""sum= %d"", a);
    }
    return 0;
}
</code></pre>

<p>Gives for n = 6:</p>

<pre><code>5^5 -&gt; 3125
4^4 -&gt; 256
3^3 -&gt;  27
2^2 -&gt;   4
1^1 -&gt;   1
sum=3413
</code></pre>
",3
52372461,52372274,2,"<blockquote>
  <p>I have no Idea how to implement the required DListCreate</p>
</blockquote>

<p>Your <code>DListCreate()</code> function will probably create an empty list, right? That means no actual nodes, just the dummy head and tail nodes. So... ask yourself, what should <code>head-&gt;next</code> point to if there are no actual nodes? Likewise, what should <code>tail-&gt;prev</code> point to? All you need to do to create an empty list is to create one of your <code>d_list</code> structures, and then set the <code>head</code> and <code>tail</code> pointers appropriately.</p>

<p>Hint: the address of <code>myDList.tail</code> is <code>&amp;(myDList.tail)</code>.</p>
",0
53890030,53889933,5,"<p>This function takes a character corresponding to one of the digits <code>'0'</code> to <code>'9'</code>.  The C standard dictates that the character codes for these digits have consecutive values.  </p>

<p>So when <code>'0'</code>, i.e. the character code for <code>0</code> is subtracted from the given character code, you end up with a value between 0 and 9.</p>

<p>For example, in ASCII the codes for <code>'0'</code> to <code>'9'</code> are 48, 49, 50, 51, 52, 53, 54, 55, 56, 57.  So if you pass in <code>'4'</code> to this function it performs <code>'4' - '0'</code>, which is the same as <code>52 - 48</code>, which is 4.</p>
",0
55289952,55289888,5,"<pre><code>char* GetString() 
{ 
    char Hello[] = ""Hello""; 
    return Hello; 
}
</code></pre>

<p>would return a pointer to a stack allocated string.</p>

<pre><code>char* GetString() 
{ 
    char* Hello = ""Hello""; 
    return Hello; 
}
</code></pre>

<p>returns a pointer to a static string. (And you should really make it a <code>char const*</code> pointer because string literals are effectively (but not formally) const).</p>

<p>Even if you wrote </p>

<pre><code>char* GetString() 
{ 
    char Hello[] = ""Hello""; 
    return Hello; 
} 
</code></pre>

<p>however, the compiler is under no obligation to warn you about this. C is not Rust.</p>
",2
54637229,54637146,2,"<p>The <code>a</code> is an integer, so its size is 4.  </p>

<p>Its <em>location</em>(address) and <em>value</em> are not currently known.<br>(it is <code>extern</code> somewhere at some other location)<p>
But the <em>size</em> is well defined.</p>
",0
54637205,54637146,3,"<p>You're able to get away with it here because <code>a</code> is never actually used.  The expression <code>sizeof(a)</code> is evaluated at compile time.  So because <code>a</code> is never referenced, the linker doesn't bother looking for it.</p>

<p>Had you done this instead:</p>

<pre><code>printf(""%d\n"", a);
</code></pre>

<p>Then the program would have failed to link, printing ""undefined reference to `a'""</p>
",0
54637207,54637146,2,"<p>The size of a variable is the size of its data type, whether it is presently only an <code>extern</code> or not. Since <code>sizeof</code> is evaluated at compile time, whereas symbol resolution is done at link time, this is acceptable.</p>

<p>Even with <code>-O0</code>, gcc doesn't care that it's <code>extern</code>; it puts <code>4</code> in <code>esi</code> for the argument to <code>printf</code>: <a href=""https://godbolt.org/z/Zv2VYd"" rel=""nofollow noreferrer"">https://godbolt.org/z/Zv2VYd</a></p>

<p>Without declaring <code>a</code>, however, any of the following will fail:</p>

<pre><code>a = 3;
printf(""%d\n"", a);
int *p = &amp;a;
</code></pre>
",0
52042549,52042102,1,"<p>You observe the effect of <em>undefined behavior</em>. You are using a check for an already allocated place in the board and an incomplete range change. This leads to an access out of bounds of the <code>board</code> array.</p>

<p>You can watch this if you dump the interesting information instead of the board. Add a line</p>

<pre><code>printf(""moveNumber: %d board[%d][%d]: %d\n"", 
    moveNumber, currentRow, currentColumn, board[currentRow][currentColumn]);
</code></pre>

<p>before each assignment before of a board cell. The gives you an output like this:</p>

<pre><code>moveNumber: 1 board[2][5]: 0
moveNumber: 3 board[1][3]: 0
moveNumber: 6 board[3][4]: 0
moveNumber: 4 board[4][2]: 0
moveNumber: 1 board[2][3]: 0
moveNumber: 4 board[3][1]: 0
moveNumber: 6 board[5][2]: 0
moveNumber: 6 board[7][3]: 0
moveNumber: 0 board[6][5]: 0
moveNumber: 1 board[4][6]: 0
moveNumber: 1 board[2][7]: 0
moveNumber: 3 board[1][5]: 0
moveNumber: 1 board[-1][6]: -858993460
moveNumber: 3 board[-2][4]: 3
</code></pre>

<p>The last two lines shows access with invalid index. This causes undefined behavior.</p>

<p>You can improve your program in different ways. You can extend your range change and check for negative numbers. You can also change the type of <code>currentRow</code> and <code>currentColumn</code> to unsigned, in that case your check is sufficient.</p>

<p>If your pseudo random generator creates a sequence that you reach all fields of the board depends on the implementation. I doubt that the usual pseudo ramdom generator allows you to fill the entire board.</p>
",0
53906605,53906274,5,"<p>Flushing an <em>output</em> stream (such as <code>stdout</code>) causes any buffered data to be ""flushed"" to the output. For example, flushing <code>stdout</code> is often used to ensure that the output becomes visible even if it is not followed by a newline, since <code>stdout</code> may be line-buffered.</p>

<p>Flushing an <em>input</em> stream (such as <code>stdin</code>) is undefined behaviour in standard C, and should not be used. Some implementations do define it as a <em>non-standard</em> extension to clear any unread input, but I would strongly recommend against exploiting this (in particular as a workaround for improper use of <code>scanf</code>). The code in the question falls into this category.</p>
",0
55816776,55816636,4,"<p>You can use popen, like this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    FILE * fp = popen(""ls -l"", ""r"");
    char buf[1024];
    while (fgets(buf, 1024, fp)) {
        printf(""returned: \""%s\""\n"", buf);
    }
    return 0;
}
</code></pre>

<p>This only shows reading each line from the command, you'll still need to split the text to do what you want.</p>

<p>And just because it is fun, here it is with a simple function to grab fields out of a string buffer:</p>

<pre><code>char * get_field(char *buffer, int field)
{
    int white = 1; // simple state machine
    char *p;
    char *first = NULL;
    for (p=buffer; *p; p++) {
        if (white) {
            if (*p &gt; ' ') {
                white = 0;
                first = p;
            }
        } else {
            if (*p &lt;= ' ') {
                white = 1;
                field--;
                if (!field &amp;&amp; first)
                    return strndup(first, p-first);
            }
        }
    }
    return NULL;
}

int main()
{
    FILE * fp = popen(""ls -l"", ""r"");
    char buf[1024];

    while (fgets(buf, 1024, fp)) {
        char *month = get_field(buf, 6);
        if (month) {
            printf(""  month: \""%s\""\n"", month);
            free(month);
        }
        char *file = get_field(buf, 9);
        if (file) {
            printf(""  file: \""%s\""\n"", file);
            free(file);
        }
    }
    return 0;
}
</code></pre>

<p>This is a simple brute force method, suitable for simple programs, and does not provide the functionality of a typical split() function. But it illustrates one way to do this sort of thing in C.</p>
",4
58250254,58248455,1,"<blockquote>
  <p>Can we check the date input form dd-mm-yyyy and also check how many digits that users input?</p>
</blockquote>

<p>Sure, how about using some helper functions?</p>

<p>Divide the task in conceptual parts and write code for each. Divide and conquer.</p>

<pre><code>// return 0: fail
// return 1: success
static int scan_int(int *dest, const char *s, int min, int max, int digits,
    char endchar) {
  *dest = 0;
  for (int i = 0; i &lt; digits; i++) {
    if (*s &lt; '0' || *s &gt; '9')
      return 0;
    *dest = *dest * 10 + *s - '0';
    s++;
  }
  return *dest &gt;= min &amp;&amp; *dest &lt;= max &amp;&amp; *s == endchar;
}

static int isleapyear(int year) {
  if (year % 4) return 0;
  if (year &gt; 1582) {  // see https://en.wikipedia.org/wiki/Gregorian_calendar
    if (year % 100 == 0 &amp;&amp; year % 400) return 0;
  }
  return 1;
}

static int eom(int year, int month) {
  static char eoms[1 + 12] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
  if (month != 2) {
    return eoms[month];
  }
  return eoms[month] + isleapyear(year);
}
</code></pre>

<p>Now armed with some helper functions, the task is directly coded.</p>

<pre><code>// dd-mm-yyyy
#define YEAR_MIN 1919
#define YEAR_MAX 2019
int dateCheck(void) {
  int day, month, year;
  char inputValue[20] = {0};
  printf(""Enter date : "");
  fgets(inputValue, sizeof inputValue, stdin);

  if (scan_int(&amp;year, &amp;inputValue[3 + 3], YEAR_MIN, YEAR_MAX, 4, '\0')
      &amp;&amp; scan_int(&amp;month, &amp;inputValue[3], 1, 12, 2, '-')
      &amp;&amp; scan_int(&amp;day, inputValue, 1, eom(year, month), 2, '-')) {
    printf(""Valid. %02d-%02d-%04d\n"", day, month, year);
    return 1;
  }
  printf(""Invalid.\n"");
  return 0;
}
</code></pre>

<p>Nifty trick:  Code validates <code>day</code> after fetching a valid <code>year, month</code>.</p>
",1
58249549,58248455,0,"<p>Unless you are prohibited from using the functions provided in <code>string.h</code>, they can make you date check a bit easier. For example, you can verify that only allowable characters are present in the input using <code>strchr()</code>. You can also use <code>strchr()</code> to locate each <code>'-'</code> when checking that each <code>dd mm yyyy</code> group is the correct number of characters. You can use <code>strlen()</code> to verify the final <code>yyyy</code> group is 4-characters, and you can use <code>strcspn()</code> to trim the trailing <code>'\n'</code> at the end of any input read using <code>fgets()</code>. The rest is simple ariithmetic.</p>

<p>For example, you could write a <code>chkdate(const char *s)</code> function to check that the string <code>s</code> is in your desired format, returning <code>1</code> if it is, or <code>0</code> otherwise, e.g.:</p>

<pre><code>#define DATEGRP 3   /* if you need a constant, #define one (or more) */
#define DATELN 10
#define DATEC 128

/* check if given date format is dd-mm-yyyy
 * returns 1 on success, zero otherwise
 */
int chkdate (const char *s)
{
    const char *datechars = ""-0123456789"",  /* valid characters */
            *p = s,                         /* pointer &amp; end-pointer */
            *ep = p;
    size_t  group = 0;                      /* group counter, dd mm yyyy */
    int groups[] = { 2, 2, 4 };             /* req'd chars per group */

    for (int i = 0; s[i]; i++)              /* verify only datechars in s */
        if (!strchr (datechars, s[i]))
            return 0;

    /* loop over dd mm groups using strchr to locate '-' */
    while (group &lt; DATEGRP - 1 &amp;&amp; (ep = strchr(p, *datechars))) {
        if ((ep - p) != groups[group])      /* verify correct no. of chars */
            return 0;
        p = ++ep;       /* update p to following char */
        group++;        /* increment groups counter */
    }
    /* check chars in final group and all digits */
    if (strlen (p) != (size_t)groups[group] || strchr (p, '-'))
        return 0;

    return 1;       /* if you made it here, valid date, return 1 */
}
</code></pre>

<p>You can also make a trivial solution using <code>sscanf</code> alone, that behaves in the exact same manner simply by using a proper <em>format string</em> with appropriate <em>field-width</em> modifiers on each integer conversion checking the return of <code>sscanf</code> against <code>3</code>, <strong>except</strong> the <code>sscanf</code> trivial solution will fail for any case where <code>yyyy</code> begins with an integer and then contains an invalid character) e.g.</p>

<pre><code>int chkdate (const char *s)
{
    int d, m ,y;
    return sscanf (s, ""%2d-%2d-%4d"", &amp;d, &amp;m, &amp;y) == 3;
}
</code></pre>

<p>Adding the required headers and a short example program that will validate user input using the function above you could do:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define DATEGRP 3   /* if you need a constant, #define one (or more) */
#define DATELN 10
#define DATEC 128

/* check if given date format is dd-mm-yyyy
 * returns 1 on success, zero otherwise
 */
int chkdate (const char *s)
{
    const char *datechars = ""-0123456789"",  /* valid characters */
            *p = s,                         /* pointer &amp; end-pointer */
            *ep = p;
    size_t  group = 0;                      /* group counter, dd mm yyyy */
    int groups[] = { 2, 2, 4 };             /* req'd chars per group */

    for (int i = 0; s[i]; i++)              /* verify only datechars in s */
        if (!strchr (datechars, s[i]))
            return 0;

    /* loop over dd mm groups using strchr to locate '-' */
    while (group &lt; DATEGRP - 1 &amp;&amp; (ep = strchr(p, *datechars))) {
        if ((ep - p) != groups[group])      /* verify correct no. of chars */
            return 0;
        p = ++ep;       /* update p to following char */
        group++;        /* increment groups counter */
    }
    /* check chars in final group and all digits */
    if (strlen (p) != (size_t)groups[group] || strchr (p, '-'))
        return 0;

    return 1;       /* if you made it here, valid date, return 1 */
}

int main (void) {

    char buf[DATEC] = """";
    size_t len;

    fputs (""enter date (dd-mm-yyyy): "", stdout);    /* prompt */
    if (!fgets (buf, DATEC, stdin)) {               /* read/validate input */
        fputs (""(user canceled input)\n"", stderr);
        return 1;
    }

    buf[(len = strcspn(buf, ""\n""))] = 0;    /* trim trailing '\n', save len */
    if (len != DATELN) {                    /* if not DATELN chars, invalid */
        fputs (""error: invalid date format,\n"", stderr);
        return 1; 
    }

    if (chkdate (buf))  /* check dd-mm-yyyy format */
        puts (""date is valid"");
    else    /* otherwise, invalid format */
        fputs (""date is invalid.\n"", stderr);
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<p>Wrong number of digits:</p>

<pre><code>$ ./bin/chkdate
enter date (dd-mm-yyyy): 7-7-2000
error: invalid date format,
</code></pre>

<p>Invalid character <code>'a'</code> included:</p>

<pre><code>$ ./bin/chkdate
enter date (dd-mm-yyyy): 07-7a-2000
date is invalid.
</code></pre>

<p>Good date:</p>

<pre><code>$ ./bin/chkdate
enter date (dd-mm-yyyy): 07-07-2000
date is valid
</code></pre>

<p>There are literally dozens of ways to approach this with many combinations of loops, counters, pointers, character classification, etc... There isn't any ""right"" way, so long as it is reasonably efficient and does the validation. So experiment, write it several different ways and choose the one that is most readable and understandable to you.</p>
",0
55518082,55517958,4,"<p>Running with compiler warnings, or a good editor like <a href=""https://atom.io"" rel=""nofollow noreferrer"">Atom.io</a>, reveals the problem.</p>

<pre><code>cc -Wall -Wshadow -Wwrite-strings -Wextra -Wconversion -std=c99 -pedantic -g `pkg-config --cflags glib-2.0`   -c -o test.o test.c
test.c:8:30: warning: '&amp;&amp;' within '||' [-Wlogical-op-parentheses]
    printf(""%d "", ++i || ++j &amp;&amp; ++k);
                      ~~ ~~~~^~~~~~
test.c:8:30: note: place parentheses around the '&amp;&amp;' expression to silence this warning
    printf(""%d "", ++i || ++j &amp;&amp; ++k);
                             ^
                         (         )
1 warning generated.
</code></pre>

<p>It's a precedence issue. Operators in an expression are not evaluated left-to-right but rather in precedence order. <code>++i || ++j &amp;&amp; ++k</code> is being evaluated as <code>++i || (++j &amp;&amp; ++k)</code> because <a href=""https://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer""><code>&amp;&amp;</code> has a higher precedence than <code>||</code></a>.</p>

<p>To avoid these issues, turn on compiler warnings and make it a habit to put parens around anything that might be ambiguous.</p>
",2
55518057,55517958,18,"<p>The logical AND operator <code>&amp;&amp;</code> has higher precedence than the logical OR operator <code>||</code>.  So the expression is actually parsed as:</p>

<pre><code>++i || (++j &amp;&amp; ++k)
</code></pre>

<p><code>++i</code> evaluates to true so the entire right side of the <code>||</code>, i.e. <code>++j &amp;&amp; ++k</code>, is not evaluated.  This results in neither <code>j</code> nor <code>k</code> being incremented.</p>

<p>It can be difficult to remember all the precedence rules, both for yourself and for others who read your code.  So when in doubt, use parenthesis to clarify your intentions.</p>
",6
58733035,58732847,1,"<p>Converting my comment:</p>

<p>Usually, these kind of algorithms do not stop at the last one, but an element before. In fact, at that point, the nth-1 element is already sorted with respect of the nth one. So, both works, but the ""-1"" is more efficient because you skip a useless iteration.</p>
",0
56142642,56142544,2,"<p>The primary difference between the <code>int</code> version that works and the <code>char</code> version that doesn't is that you use <code>%d</code> and <code>%c</code> ¡ª and <code>%d</code> skips white space but <code>%c</code> does not.</p>

<p>Change the <code>""%c""</code> to <code>"" %c""</code> and you're in with a fighting chance.</p>

<p>Three <code>scanf()</code> ¡ª or <code>scanf_s()</code> if you're working on Windows ¡ª conversions do not skip white space.  They are <code>%c</code>, <code>%[¡­]</code> (scan sets), and <code>%n</code>.</p>
",0
54181437,54181412,5,"<p>No they are not equal.</p>

<p>The first create an array of two elements. You can modify the contents of the array as you will (it's mutable).</p>

<p>The second creates a pointer and make it point to the first element of an array containing two elements. The contents of the array that <code>b</code> is currently pointing to is <em>not</em> mutable, you can not change the contents of that array. Literal strings in C are, in essence, read-only. You can however change the pointer <code>b</code> itself, to make it point somewhere else. If you make it point to something which is not a literal string and is not marked <code>const</code>, like for example <code>a</code>, then the contents can be modified.</p>

<hr>

<p>In memory it would be something like this</p>

<p>For <code>a</code>:</p>

<pre>
+-----+------+
| 'a' | '\0' |
+-----+------+
</pre>

<p>The array is a single entity.</p>

<p>And for <code>b</code>:</p>

<pre>
+---+     +-----+------+
| b | --> | 'a' | '\0' |
+---+     +-----+------+
</pre>

<p>Here you have two entities, the variable <code>b</code> and the array it points to.</p>
",2
57333043,57332208,2,"<blockquote>
  <p>Example of an extended integer type?<br>
  Does any implementation actually implement an extended integer type?</p>
</blockquote>

<p>Various processors have a 24-bit width for instructions and constant memory.</p>

<p>Compilers supporting such Microchip processors offer 
<a href=""https://www.microchip.com/forums/m1081917.aspx"" rel=""nofollow noreferrer""><code>(u)int24_t</code></a>.</p>

<blockquote>
  <p>int24_t types added to C99 The int24_t and uint24_t types (along with the existing __int24 and __uint24 types) are now available when using the C99 library and when CCI is not active.</p>
</blockquote>

<hr>

<p>Even though some compilers do offer  128-bit integer types, if that type was an <em>extended integer type</em>, the C library would require <code>(u)intmax_t</code> to be at least that width.  C11dr 7.20.1.5</p>

<p>C also requires ""preprocessor arithmetic done in <code>intmax_t/uintmax_t</code>"".</p>

<p>I suspect compilers offering <code>intN</code> (N > 64) do so as a <em>language extension</em>.</p>

<p>I  know of no compiler where <code>(u)int128_t</code> exist (as an <em>extended integer type</em>).</p>
",0
50958498,50958241,0,"<p>to clarify your issue. In c</p>

<pre><code>str1[i]=s[j];
</code></pre>

<p>means</p>

<p>'copy the jth character from s and put it in the ith character of str1'</p>

<p>You mean the other way round</p>

<pre><code>s[i]=str1[j];
</code></pre>
",0
56591336,56591259,5,"<p>Your code has <em>undefined behavior</em>.</p>

<pre><code>a[0] = a[0]  - (a[0] = a[1]);
</code></pre>

<p>By itself, the subexpression <code>(a[0] = a[1])</code> is valid. It assigns the value of <code>a[1]</code> to <code>a[0]</code>, and yields the value that was assigned.</p>

<p>The problem is that <code>a[0]</code> is modified <em>twice</em> in a single expression, and the two modifications are unsequenced, meaning that the language doesn't tell us which one happens first. (In C90/C99 terms, the two modifications are not separated by a <em>sequence point</em>.)</p>

<p>A simpler example of this:</p>

<pre><code>x = 2 + (x = 1);
</code></pre>

<p>Here <code>x</code> is modified twice. The language doesn't just say that the two modifications can happen in either order; it says that the behavior is undefined. In other words, the language says nothing about what will happen. It could crash, it could give you some garbage results, or, worst of all, it could do just what you expect it to do. (That's the worst case because it means you still have a serious bug that's going to be difficult to detect and diagnose it.)</p>

<p>Bottom line: Whatever that line of code was <em>intended</em> to do, there is certainly a clearer and less ambiguous way to do it. The code in your question, not to be too harsh, might as well not even be C.</p>
",0
51775146,51775056,1,"<p>Make an array before you begin, then create a variable that increments while each prime is found. It might look something like this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    int primes[25];
    primes[0] = 2;
    int count = 1;

    for (int i = 3; i &lt; 100; i += 2) {
        int k;
        for (k = 2; k &lt; i; k++) {
            if (i % k == 0) break;
        }
        if(i == k) {
            primes[count] = i;
            count++;
        }
    }
}
</code></pre>
",3
56385946,56385648,0,"<ol>
<li><p><em>I do not understand why I can't just write this in my parent process</em> -- that is exactly what you have done and it should work. There is nothing wrong with it. </p></li>
<li><p>The <a href=""http://man7.org/linux/man-pages/man2/read.2.html"" rel=""nofollow noreferrer""><code>read</code></a> and the <a href=""http://man7.org/linux/man-pages/man2/write.2.html"" rel=""nofollow noreferrer""><code>write</code></a> functions take the address of the buffer as the second argument. You have tried to pass the value of the variables. Change the following lines as - </p></li>
</ol>

<pre><code>read(fd[0], sumBuf, sizeof(int));
</code></pre>

<p>to</p>

<pre><code>read(fd[0], &amp;sumBuf, sizeof(int));
</code></pre>

<p>and</p>

<pre><code>write(fd[1], numArray[i], sizeof(int));
</code></pre>

<p>to</p>

<pre><code>write(fd[1], &amp;(numArray[i]), sizeof(int));
</code></pre>

<p>This should solve the problem for you. Also, your compiler must have warned you about these. Please treat all warnings as errors. </p>

<ol start=""3"">
<li>You can access the child's process id in the parent by looking at the return value of <a href=""http://man7.org/linux/man-pages/man2/fork.2.html"" rel=""nofollow noreferrer""><code>fork</code></a>. In your case, the variable <code>p</code>. </li>
</ol>

<p>You also seem to be having a confusion between PID and the value the process returns. PID is a process identifier. It is unique to a process. The return value is what the main function of that process returns. This can be integer (two processes can also return the same value). The parent can access the value it's child returns using the <a href=""http://man7.org/linux/man-pages/man2/wait.2.html"" rel=""nofollow noreferrer""><code>wait</code></a> function. </p>
",0
56428137,56427970,4,"<p>Some issues with your code:</p>

<ul>
<li><p>The algorithm is wrong (off by one): If the array contains all numbers from 1 to N except for one missing number, then it has N-1 elements. Your code reads N elements. (Alternatively, if the array actually has N elements, then the target sum is <code>(N + 1) * (N + 2) / 2</code> (sum of numbers from 1 to N+1), not <code>N * (N + 1) / 2</code>.)</p></li>
<li><p>Includes are missing (in particular, <code>#include &lt;stdio.h&gt;</code>). That means the calls to <code>printf</code> / <code>scanf</code> have undefined behavior.</p></li>
<li><p><code>int main()</code> should be <code>int main(void)</code>.</p></li>
<li><p>None of the <code>scanf</code> calls check their return value. That means your code doesn't realize when reading input fails, producing garbage output.</p></li>
<li><p>If <code>n</code> is bigger than 20, your code silently writes outside the bounds of <code>ar</code>. That's a classic buffer overflow.</p></li>
<li><p>The previous point is especially unfortunate because your code doesn't even need the array. All you do with the input numbers is to add them up in <code>sum</code>, which doesn't require a separate array.</p></li>
<li><p>Your formatting is inconsistent in <code>for(int i = 0; i&lt;n;i++){</code>. Why is there no space in <code>for(int</code> and <code>i&lt;n;i++){</code>, but there are spaces around <code>i = 0;</code>?</p></li>
<li><p>Depending on how big <code>N</code> is, <code>n*(n+1)</code> could overflow.</p></li>
<li><p>The last line of output produced by your code is missing its terminating newline: <code>printf(""missing num=%d\n"", ...);</code></p></li>
</ul>
",3
56689215,56689153,4,"<p>You can¡¯t assign to the <code>struct</code> object, you need to assign to its member:</p>

<pre><code>cmd[i].argv = APPS[i].app;
</code></pre>
",2
56689539,56689153,3,"<p>This</p>

<pre><code>struct command cmd [] = { APPS[0].app, APPS[1].app }; 
</code></pre>

<p>in fact is the sloppy version of the correct</p>

<pre><code>struct command cmd [] = {
 {APPS[0].app}, 
 {APPS[1].app}
};
</code></pre>

<p>which initialises the array of <code>struct command</code> <code>cmd</code> with two <code>struct</code>s, which each in turn are initialised using <code>APPS[0].app</code> and <code>APPS[1].app</code>.</p>

<p>So to mimic the initialisation's behaviour as an assignment do the following:</p>

<pre><code>  for(i=0;i&lt;pipecount+1;i++)
  {
    cmd[i]=(struct command){APPS[i].app};
  }
</code></pre>
",1
51745544,51744878,0,"<p>There is nothing special about pointers.</p>

<p>Regardless of its type, assigning a new value to a parameter has no effect on any variable whose value you passed in.<br>
(What do you expect to happen if you <code>buildBinTree(NULL);</code>?)</p>

<p>If you want a function to modify something, you need to pass it the address of the thing that's going to change.<br>
So if you want the function to modify a pointer, you need to pass it the address of a pointer.</p>

<pre><code>int x = 0;
void fail(int* p) { p = &amp;x; }
void succeed(int** p) { *p = &amp;x; }

int main()
{
    int *p = NULL;
    fail(p);
    /* p is still null */
    succeed(&amp;p);
    /* p is not null any more */
    return 0;
}
</code></pre>
",0
52600182,52599986,2,"<p>Among the things wrong in your code:</p>

<ul>
<li>You're skipping the first character with prejudice.</li>
<li>The type of <code>ch</code> should be <code>int</code>, not <code>char</code></li>
<li>You should be consuming characters in two groups: those that are whitespace, and those that are not.</li>
<li>You should be printing only characters from the second group (those that are not whitespace characters), further filtering them to <em>not</em> include <code>','</code> or <code>'.'</code>. Currently you're printing <em>everything</em> that is read (except the first character)</li>
</ul>

<p>The result looks something like the following code (the content of my index.dat is the body of your question).</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

int main()
{
    FILE *f = fopen(""index.dat"",""r"");
    if (f == NULL)
    {
        perror(""index.dat"");
        exit(EXIT_FAILURE);
    }

    int ch = fgetc(f);
    while (ch != EOF)
    {
        // skip any leading whitespace
        while (ch != EOF &amp;&amp; isspace((unsigned char)ch))
            ch = fgetc(f);

        // on a non-white-space character
        if (ch != EOF)
        {
            while (ch != EOF &amp;&amp; !isspace((unsigned char)ch))
            {
                if (ch != ',' &amp;&amp; ch != '.')
                    putchar(ch);
                ch = fgetc(f);
            }
            fputc('\n', stdout);
        }
    }

    fclose(f);
    return 0;
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>I
have
a
simple
c
program
that
reads
from
a
file
and
is
supposed
to
print
one
word
per
line
remove
all
punctuations
and
blank
lines
I
am
stuck
at
detecting
and
removing
blank
lines
</code></pre>

<p>At least that is what you appear to be trying to accomplish</p>
",2
51861106,51861023,7,"<p>In effect, <code>%d</code> tells <code>printf</code> to look in a certain place for an integer argument. But you passed a <code>float</code> argument, which is put in a different place. The C standard does not specify what happens when you do this. In this case, it may be there was a zero in the place <code>printf</code> looked for an integer argument, so it printed ¡°0¡±. In other circumstances, something different may happen.</p>
",0
51861194,51861023,2,"<p>Using an invalid format specifier to <code>printf</code> invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.  This is specified in section 7.21.6.1p9 of the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C standard</a>:</p>

<blockquote>
  <p>If a conversion specification is invalid, the behavior is
  undefined.282) If any argument is not the correct type for the
  corresponding conversion specification, the behavior is undefined.</p>
</blockquote>

<p>What this means is that you can't reliably predict what the output of the program will be.  For example, the same code on my system prints -1554224520 as the value.</p>

<p>As to what's most likely happening, the <code>%d</code> format specifier is looking for an <code>int</code> as a parameter.  Assuming that an <code>int</code> is passed on the stack and that an <code>int</code> is 4 bytes long, the <code>printf</code> function looks at the next 4 bytes on the stack for the value given.  Many implementations don't pass floating point values on the stack but in registers instead, so it instead sees whatever garbage values happen to be there.  Even if a <code>float</code> is passed on the stack, a <code>float</code> and an <code>int</code> have very different representations, so printing the bytes of a <code>float</code> as an <code>int</code> will most likely not give you the same value.</p>
",1
51033602,51033423,0,"<p>your problem is that you are returning the end of your buffer, You need to keep a copy of linePtr or to index it. (You are incrementing it in your loop);</p>
",0
51033595,51033423,2,"<p>The problem is that <code>linePtr</code> points to the <em>end</em> of the string containing the input line, not the beginning, because you do <code>linePtr++</code> during the loop.</p>

<p>Instead of incrementing <code>linePtr</code>, use <code>linePtr[i++]</code> to store each character during the loop.</p>

<pre><code>char *getstring(unsigned int len_max)
{
    char *linePtr = malloc(len_max + 1); // Reserve storage for ""worst case.""
    if (linePtr == NULL) { return NULL; }
    int c = 0;
    unsigned int i = 0;
    while (i &lt; len_max &amp;&amp; (c = getchar()) != '\n' &amp;&amp; c != EOF){
        linePtr[i++] = (char)c;
    }

    linePtr[i] = '\0';

    return linePtr;
}
</code></pre>

<p>If you really need to do it by incrementing a pointer, you need to save the original value of <code>linePtr</code> in another variable, and return that rather than the one that you increment.</p>
",0
51883744,51882861,1,"<p>Function parameters have <code>auto</code> storage class.</p>
<blockquote>
<strong>6.9.1 Function definitions</strong><br>
...<br>
<strong>Constraints</strong><br>
...<br>
5 If the declarator includes a parameter type list, the declaration of each parameter shall
include an identifier, except for the special case of a parameter list consisting of a single
parameter of type <strong><code>void</code></strong>, in which case there shall not be an identifier. No declaration list
shall follow.<br><br>
6 If the declarator includes an identifier list, each declaration in the declaration list shall
have at least one declarator, those declarators shall declare only identifiers from the
identifier list, and every identifier in the identifier list shall be declared. An identifier
declared as a typedef name shall not be redeclared as a parameter. The declarations in the
declaration list shall contain no storage-class specifier other than <strong><code>register</code></strong> and no
initializations.<br>
<br>
<strong>Semantics</strong><br>
...<br>
9 Each parameter has automatic storage duration; its identifier is an lvalue.<sup>164)</sup> The layout
of the storage for parameters is unspecified.<br>
...<br>
<hr>
<sup>164) A parameter identifier cannot be redeclared in the function body except in an enclosed block.</sup>
</blockquote>
<p><sup><em><a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C 2011 Online Draft</a></em></sup></p>
<p>There's actually a bit to unpack here.  First, remember that C allows two styles of function definitions.  The 1989 standard introduced what's called prototype syntax, where both parameter names and their types are specified in the argument list:</p>
<pre><code>void foo( int bar, double bletch )
{
  // body of foo
}
</code></pre>
<p>Clause 5 refers to this style of function definition.</p>
<p>There's also the older (and no longer recommended) K&amp;R style of function definition, where the argument list only contains the identifiers, with a separate set of declarations before the function body:</p>
<pre><code>foo( bar, bletch ) // K&amp;R didn't have the void datatype, use implicit int
  int bar;
  double bletch;
{
  // body of foo
}
</code></pre>
<p>Clause 6 refers to this style of definition.</p>
<p>Per clause 9, function parameters have <code>auto</code> storage class; however, per clause 6, you <em>may</em> use <code>register</code> storage class for parameters declared using K&amp;R syntax:</p>
<pre><code>foo( bar, bletch )
  register int bar;
  double bletch;
{
  ...
}
</code></pre>
<p>But since this style of function definition is no longer recommended (prototype syntax allows the compiler to check for agreement of parameters between function calls and function definitions, and it's also just plain easier to read), you really don't have to worry about it.</p>
<p>Note that the <code>register</code> keyword is largely vestigial, and dates from a time when C compilers weren't all that good at optimization.  About the only practical effect of using it with modern compilers is that you won't be able to take the address of the thing you declared with it.</p>
<p><strong>EDIT</strong></p>
<p>Missed this critical bit:</p>
<blockquote>
<strong>6.7.6.3 Function declarators (including prototypes)</strong><br>
...<br>
<strong>Constraints</strong><br>
...<br>
2 The only storage-class specifier that shall occur in a parameter declaration is <strong><code>register</code></strong>.
</blockquote>
<p>Unless you use the <code>register</code> keyword in a parameter declaration, a function parameter will have <code>auto</code> storage duration - there is no need to explicitly write <code>auto</code> (and, per the clause above, isn't allowed anyway).</p>
",2
51883540,51882861,1,"<p>Per C 2018 6.2.4 5:</p>

<blockquote>
  <p>An object whose identifier is declared with no linkage and without the storage-class specifier <strong>static</strong> has <em>automatic storage duration</em>,¡­</p>
</blockquote>

<p>Per 6.2.2 6, a function parameter has no linkage:</p>

<blockquote>
  <p>The following identifiers have no linkage: an identifier declared to be anything other than an object or a function; an identifier declared to be a function parameter; a block scope identifier for an object declared without the storage-class specifier <strong>extern</strong>.</p>
</blockquote>

<p>Per 6.7.6.3 2, a function parameter cannot be declared with <code>static</code>:</p>

<blockquote>
  <p>The only storage-class specifier that shall occur in a parameter declaration is <strong>register</strong>.</p>
</blockquote>

<p>So a function parameter has no linkage and is not declared with <code>static</code>, and therefore it has automatic storage duration.</p>

<p>Regarding your question ¡°Is it necessary for a variable to have a storage class in c?¡±, a variable consists of an object (a region of storage that can represent values) and an identifier (a name). Objects necessarily have storage durations, per 6.2.4 1:</p>

<blockquote>
  <p>An object has a storage duration that determines its lifetime.</p>
</blockquote>
",0
53243521,53243449,1,"<p>Your code in <code>OUT</code> is:</p>

<pre><code>void OUT(int *p,int str,int col)
{
  for(int i=0;i&lt;str;i++)
  {
    p=p+str*i;
    for(int j=0;j&lt;col;j++)
    {
       printf(""%d "",*(p+j));
    }
    printf(""\n"");
  }
}
</code></pre>

<p>To get to the next row, you can either add one row to the previous pointer or you can add an increasing number of rows to the original pointer. You, however, add an increasing number of rows to the original pointer, which won't work.</p>

<p>To get to the next row, you need to add on the number of columns. If the array has 8 columns, then to get to the next row, you need to 8 to the previous row to skip over each of the 8 columns in that row.</p>

<p>Possible fixes:</p>

<pre><code>void OUT(int *op,int str,int col)
{
  for(int i=0;i&lt;str;i++)
  {
    int *p = op + col * i;
    for(int j=0;j&lt;col;j++)
    {
       printf(""%d "",*(p+j));
    }
    printf(""\n"");
  }
}
</code></pre>

<p>Or:</p>

<pre><code>void OUT(int *p,int str,int col)
{
  for(int i=0;i&lt;str;i++)
  {
    for(int j=0;j&lt;col;j++)
    {
       printf(""%d "",*(p+j));
    }
    printf(""\n"");
    p=p+col;
  }
}
</code></pre>

<p>Or even:</p>

<pre><code>void OUT(int *p,int str,int col)
{
  for(int i=0;i&lt;str;i++)
  {
    for(int j=0;j&lt;col;j++)
    {
       printf(""%d "",*p);
       p++;
    }
    printf(""\n"");
  }
}
</code></pre>
",7
53066511,53065422,0,"<p>OP's formula mis-calculates the terms.</p>

<pre><code>// int j=2,k=1;
int j=2,k=3;  // The loop's later calculation expect this to be initially 3

// in the loop
    // add
    a *= k;  // undo the prior terms /k

    for(;j&lt;=i;j++) {
      // this part OK
    }

    // temp = a/(k*k);
    temp = a/k*;  // Only need /k
</code></pre>

<p>Other simplifications possible.</p>
",0
52068054,52068024,0,"<p>You don't specify the return type of a function when you call it, only when it's defined or declared.</p>

<pre><code>totalLoanBalance = pow(interestRateAndPrincipal, yearsOutstanding) * LoansTaken;
</code></pre>
",3
52120753,52120508,2,"<p>To look for a sequence in a stream, increment an index to the trigger sequence every time a character matches the current indexed character.  On a mismatch reset the counter.  If the index gets to the end of the trigger sequence, you are done:</p>

<pre><code>int quit_index = 0 ;
const char* quit_trigger = ""quit"" ;

// read up to 100 characters from stdin, print each word on a line
// until the quit trigger sequence is read.
while( quit_trigger[quit_index] != 0
       n &lt; MAXC &amp;&amp; 
       (c = getchar ()) != EOF &amp;&amp; c != '\n')
{
    if (c == ' ')
        printf (""\n"");
    else
        printf (""%c"", c);
    n++;

    // While sequence matches the trigger sequence, increment index, 
    // otherwise reset to zero on mismatch.
    quit_index = (c == quit_trigger[quit_index]) ? quit_index + 1 : 0 ;
}
</code></pre>
",0
52141903,52141857,2,"<p>The declaration of <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_strcat.htm"" rel=""nofollow noreferrer""><code>strcat()</code></a> returns a pointer to char (<code>char *</code>).  So your function <code>screen()</code> must also.</p>

<p>Another thing is, you can't do this <code>char b[] = ""Hallo"";</code>, because then the character array <code>b</code> is only large enough to handle <code>Hallo</code>.  You'll need it larger than <code>Hallo</code>, and the rest will be filled with <code>0x00</code>, or <code>NUL</code>.  Like so:</p>

<p><code>48 61 6C 6C 6F 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00</code></p>

<p>And then after you <code>strcat()</code> the characters <code>world</code> onto the end:</p>

<p><code>48 61 6C 6C 6F 20 77 6F 72 6C 64 00 00 00 00 00 00 00 00 00</code></p>

<p>The first left over <code>0x00</code> will act as a null terminator when passed to <code>printf()</code>. </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char* screen(char c[])
{
    strcat(c, ""world"");
    return c;
}

int main()
{
    char b[20] = ""Hallo "";
    screen(b);
    printf(""%s"",b);

    return 0;
}
</code></pre>
",2
52141903,52141857,2,"<p>The declaration of <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_strcat.htm"" rel=""nofollow noreferrer""><code>strcat()</code></a> returns a pointer to char (<code>char *</code>).  So your function <code>screen()</code> must also.</p>

<p>Another thing is, you can't do this <code>char b[] = ""Hallo"";</code>, because then the character array <code>b</code> is only large enough to handle <code>Hallo</code>.  You'll need it larger than <code>Hallo</code>, and the rest will be filled with <code>0x00</code>, or <code>NUL</code>.  Like so:</p>

<p><code>48 61 6C 6C 6F 20 00 00 00 00 00 00 00 00 00 00 00 00 00 00</code></p>

<p>And then after you <code>strcat()</code> the characters <code>world</code> onto the end:</p>

<p><code>48 61 6C 6C 6F 20 77 6F 72 6C 64 00 00 00 00 00 00 00 00 00</code></p>

<p>The first left over <code>0x00</code> will act as a null terminator when passed to <code>printf()</code>. </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char* screen(char c[])
{
    strcat(c, ""world"");
    return c;
}

int main()
{
    char b[20] = ""Hallo "";
    screen(b);
    printf(""%s"",b);

    return 0;
}
</code></pre>
",2
52380614,52380209,2,"<p>The code posted is fairly buggy and doesn't work as intended. Supposedly it should add CR+VT at the end of a line, CR meaning carriage return and VT meaning vertical tab.</p>

<p>However, the line <code>char CRVT[2] = ""\r\v"";</code> does not allocate room for the null terminator, so upon calling <code>strcat</code>, the program will crash and burn.</p>

<p>Casting a <code>const char*</code> to <code>char*</code> and then writing to it is highly questionable practice and might invoke poorly-defined behavior.</p>

<p>As for <code>Value = crc8table[Value ^ *string];</code> it is simply some CRC table look-up with pre-calculated FCS (frame check sequence) values for some CRC-8 algorithm. The <code>^</code> is the XOR operator, which is used when calculating a CRC. What it does in this code, as part of the table look-up, is anyone's guess. It doesn't make any sense.</p>

<p>The <code>static</code> qualifier of <code>Value</code> fills no purpose, since that variable is reset in run-time. </p>

<p>Overall I wouldn't use this code, since it has such low quality. It was not written by a professional, but some beginner.</p>
",3
52340873,52340780,0,"<ol>
<li>Use <code>int ch</code> instead of <code>char ch</code> because <code>getchar</code> returns <code>int</code>. You should compare <code>ch</code> with <code>EOF</code> and handle that case.</li>
<li>Your code doesn't handle the case where a user enters a lower-case letter (e.g. <code>'a'</code> instead of <code>'A'</code>). You can correct this by using <code>ch = toupper(ch);</code></li>
<li>You don't need to repeat each <code>switch()</code> statement.</li>
<li><code>num_vowels</code> isn't being modified.</li>
<li><code>printf(""%c"", num_vowels)</code> should be <code>printf(""%d"")</code> as <code>num_vowels</code> represents a human-readable number, not a character value.</li>
<li><code>printf(...</code> should be after your <code>while</code> loop, not inside it.</li>
<li>You cannot use <code>getchar</code> and <code>putchar</code> to supplant user-input (i.e. disable local input echo), that requires platform-specific APIs. I recommend prompting the user to input a whole line of text first (into a <code>char*</code>), then process the line of text.</li>
</ol>
",1
52340864,52340780,0,"<p>You may have misunderstood the <code>switch</code> statement. While your usage does perform correctly, you only need one statement with multiple cases:</p>

<pre><code>switch (ch) {
    case 'A': case 'B': case 'C':
        putchar('2');
        break;
    case 'D': case 'E': case 'F':
        putchar('3');
        break;
    case 'G': case 'H': case 'I':
        putchar('4');
        break;
    /*   ...   */
}
</code></pre>

<p>Note that nothing happens when the input doesn't match any of the cases. That's why only capital letters are transformed and sent to the output. One simple solution would be adding a <code>default</code> case. This way, when the input character is not any capital letter it is sent straight to output. Add this to the end of your <code>switch</code>:</p>

<pre><code>switch(ch) {
    case 'A': case 'B':
    /* ... */
    default:
        putchar(ch);
        break;
}
</code></pre>

<p>You could perform other checks as well, only printing certain characters for example.</p>

<p>As for <code>printf(""%c"", num_vowels);</code> there is nothing wrong with it, except that <code>num_vowels</code> is never used. So you should expect it to print a null character (<code>'\0'</code>) after every character sent to output. I'm not sure about your intentions, but if it was a counter, you should increment the variable and print it only after reading input, outside the <code>while</code> loop.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int
main(int argc, char **argv)
{
    char ch;
    int num_letters = 0;

    printf(""Please Enter a phone number: "");
    while ((ch = getchar()) != '\n')
    {
        if (isupper(ch)) num_letters++;

        switch (ch) {
            case 'A': case 'B': case 'C':
                putchar('2');
                break;
            case 'D': case 'E': case 'F':
                putchar('3');
                break;
            case 'G': case 'H': case 'I':
                putchar('4');
                break;
            case 'J': case 'K': case 'L':
                putchar('5');
                break;
            case 'M': case 'N': case 'O':
                putchar('6');
                break;
            case 'P': case 'Q': case 'R': case 'S':
                putchar('7');
                break;   
            case 'T': case 'U': case 'V':
                putchar('8');
                break; 
            case 'W': case 'X': case 'Y': case 'Z':
                putchar('9');
                break; 
            default:
                putchar(ch);
                break;
        }

    }
    printf(""\n-- %d alphabetic letters used.\n"", num_letters);

    return 0;
}
</code></pre>
",0
58126130,58126115,3,"<p>The memory allocated with <code>malloc</code> or related routines will not be automatically freed when your function returns. (In general-purpose multi-user operating systems, all memory used by your program will be released by the system when your program ends.)</p>

<p>The routine that calls this function is responsible for freeing the memory (or must pass that obligation on to its caller). The documentation of your routine <code>sub_str</code> should clearly state that it allocates memory and that the caller is responsible for freeing it.</p>
",0
58126173,58126115,0,"<blockquote>
  <p>When you allocate memory in a function, does it automatically free when you return?</p>
</blockquote>

<p>It depends how you allocate memory.</p>

<p>If you use <code>malloc()</code>, <code>calloc()</code> or <code>realloc()</code> to allocate memory then it won't be freed until/unless the program explicitly frees it (e.g. by calling <code>free()</code> somewhere).</p>

<p>If you use local variables (e.g. <code>char new_str[length];</code>) to allocate the memory, then it will be freed when the function returns.</p>
",0
52886340,52886304,2,"<blockquote>
  <p>I am looking to make a simple spreadsheet application</p>
</blockquote>

<p><strong><a href=""https://en.wikipedia.org/wiki/Spreadsheet"" rel=""nofollow noreferrer"">Spreadsheets</a> cannot be a <em>simple</em> application</strong>. They have two related components which are complex:</p>

<ul>
<li><p>a nice GUI presenting a table of cells (you could also consider a terminal interface, using something like <a href=""https://www.gnu.org/software/ncurses/"" rel=""nofollow noreferrer"">ncurses</a>, but that won't be simpler than providing a simple GUI). If your program don't provide some tabular interface, don't call it a spreadsheet.</p></li>
<li><p>a lazy ""functional"" interpreter, running in each spreadsheet cell (or interpreting a 2D array of formulas); you have some scripting language involved, and your spreadsheet has conceptually some matrix of <a href=""https://en.wikipedia.org/wiki/Formula"" rel=""nofollow noreferrer"">formula</a>e.</p></li>
</ul>

<p>You could look (for inspiration) into the source code of existing <a href=""https://en.wikipedia.org/wiki/Free_software"" rel=""nofollow noreferrer"">free software</a> spreadsheets, e.g. <a href=""http://www.gnumeric.org/"" rel=""nofollow noreferrer"">Gnumeric</a></p>

<p>For the GUI part, use some existing GUI toolkit. Since you want to code that in C, consider <a href=""http://gtk.org/"" rel=""nofollow noreferrer"">GTK</a>.</p>

<p>For the interpreter part, read first the <a href=""https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools"" rel=""nofollow noreferrer"">Dragon Book</a> (after having read <a href=""https://mitpress.mit.edu/sicp/"" rel=""nofollow noreferrer"">SICP</a>), something like <a href=""https://www.cs.rochester.edu/~scott/pragmatics/"" rel=""nofollow noreferrer""><em>Programming Languages Pragmatics</em></a> and probably <a href=""https://en.wikipedia.org/wiki/Lisp_in_Small_Pieces"" rel=""nofollow noreferrer""><em>Lisp In Small Pieces</em></a>. If you want to parse your own formula language, read more about <a href=""https://en.wikipedia.org/wiki/Parsing"" rel=""nofollow noreferrer"">parsing</a> techniques, <a href=""https://en.wikipedia.org/wiki/Recursive_descent_parser"" rel=""nofollow noreferrer"">recursive descent parsing</a>, and look into bison <a href=""https://www.gnu.org/software/bison/manual/html_node/Infix-Calc.html"" rel=""nofollow noreferrer"">infix calc</a> example.</p>

<p>You need at least several months, and perhaps several years, of work.</p>

<p>You might embed some <em>existing</em> interpreter (instead of designing and implementing your own one). Consider using <a href=""http://lua.org/"" rel=""nofollow noreferrer"">Lua</a> or <a href=""https://www.gnu.org/software/guile/"" rel=""nofollow noreferrer"">Guile</a>.</p>

<p>Your incomplete code is conceptually wrong: what a spreadsheet needs to have is some matrix of <em>formulae</em>, not just of numbers (like your <code>n</code> array). Each cell contains a formula (or a <a href=""https://en.wikipedia.org/wiki/Tagged_union"" rel=""nofollow noreferrer"">tagged union</a> of formula and plain number), and you want to keep the <a href=""https://en.wikipedia.org/wiki/Abstract_syntax_tree"" rel=""nofollow noreferrer"">AST</a> of that formula. A cell apparently containing a number is a degenerate case of a formula reduced to a constant number.</p>

<p>This <a href=""https://stackoverflow.com/a/47235897/841108"">answer</a> shows how to implement a numerical matrix as some abstract data type. It could inspire you to represent a spreadsheet as some matrix of formulae. Of course you need to also have a type for the AST of your formulae.</p>
",9
52699629,52692204,0,"<p>The only correct way to reverse a doubly linked list is to modify your iteration code so that (depending on whether a ""current direction"" flag is set or clear) it will use ""next"" or ""last"".</p>

<p>If you actually modify each element of the doubly linked list, then you might as well rip the cache out of your CPU and flush it down the toilet.</p>
",0
54535625,54535531,2,"<p>Your compiler should be warning you about this line:</p>

<pre><code>printf_s(""%s"", *input);
</code></pre>

<p>If not, you need to enable an ""all warnings"" setting. (On gcc and clang, add <code>-Wextra</code> to the command line.)</p>

<p>Essentially, you have a mismatch between the type of the argument (<code>char</code>) and the type expected by the format string (<code>const char*</code>). <code>*input</code> dereferences the character pointer, and so evaluates to the first character in the string. <code>""%s""</code> expects a pointer to a nul-terminated array of characters.</p>

<p>It should work if you remove the <code>*</code>:</p>

<pre><code>printf_s(""%s"", input);
</code></pre>
",0
54535832,54535531,1,"<p>You are using <code>scanf_s(""%s"", ...</code> wrongly.</p>

<p>Verbatim from <a href=""https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/fscanf-s-fscanf-s-l-fwscanf-s-fwscanf-s-l?view=vs-2017"" rel=""nofollow noreferrer"">the docs</a>:</p>

<blockquote>
  <p>The main difference between the more secure functions (that have the <strong>_s</strong> suffix) and the other versions is that the more secure functions require the size in characters of each <strong>c</strong>, <strong>C</strong>, <strong>s</strong>, <strong>S</strong>, and <strong>[</strong> type field to be passed as an argument immediately following the variable. </p>
</blockquote>

<p>So if <code>input</code> points to the 1st character of a sequence of 20 <code>char</code> then it should be:</p>

<pre><code>  scanf_s(""%s"", input, 20); 
</code></pre>

<p>Lessons learned: If in doubt, (re-)read the documentation!</p>
",0
54535636,54535531,1,"<p>You probably want this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  char *input;

  input = malloc(20 * sizeof(char)); // (char *) is not needed here (but doesn't harm either)
  puts(""Enter the string you wish to display"");
  scanf(""%s"", input);
  printf(""%s"", input);  // *input is wrong here
  free(input);
  return 0;
}
</code></pre>

<p>Don't use the <code>_s</code> verions as they are not standard on every platform and more or less pointless, just use <code>scanf</code> and <code>printf</code>.</p>
",3
58456486,58456428,1,"<p>You want the character <code>\n</code>.</p>

<p>If you're calling something like</p>

<pre><code>printf(""hello"");
</code></pre>

<p>you can either include the <code>\n</code> character in the string:</p>

<pre><code>printf(""hello\n"");
</code></pre>

<p>or you can print it with a separate call to <code>printf</code>:</p>

<pre><code>printf(""hello"");
printf(""\n"");
</code></pre>

<p>or you can print it using <code>putchar</code>:</p>

<pre><code>printf(""hello"");
putchar('\n');
</code></pre>

<p>It's up to you, and there are other ways to do it, too.</p>

<p>(But notice that in the last example I used single quotes around <code>'\n'</code>, because <code>putchar</code> prints a single character, not a string.)</p>
",1
56298154,56298102,4,"<p>Your code uses <code>a</code> as a loop counter in <code>fora=i;a&lt;=j;a++)</code> and uses <code>a</code> as a value in the computed sequence when it sets <code>a=3*a+1</code> or <code>a=a/2</code>. When the loop for the sequence ends (due to <code>while(a&gt;1)</code>), <code>a</code> has the value one. So it never reaches <code>j</code> in the <code>for</code> loop.</p>

<p>Use different objects for different purposes. Inside the <code>for</code> loop, set a different object to <code>a</code>, such as <code>int b = a;</code>, and use <code>b</code> to evaluate the sequence.</p>

<p>You will also want to reset <code>count</code> to one before each trial.</p>
",1
50083456,50083425,6,"<p>You can put <code>const</code> in the brackets of an array-looking pointer parameter to prevent reassignment to it:</p>

<pre><code>int main(const int argc, const char* const argv[<b>const</b>]) {</code></pre>

<p>People don¡¯t typically bother with this.</p>
",11
53562325,53560654,0,"<p>FWIW, here's an example using the GNU regex library (which you may or may not have available, depending on your platform).  It's probably overkill for what you're trying to do, but it's an alternative to the methods the other people have shown you.  Depending on the complexity of the pattern you're trying to match, it can come in handy.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;regex.h&gt;

int main( void ) 
{
    /**
     * Text we want to search.
     */
    const char *text = ""Svnsv am /apple/ rv dbndkbrb am /orange/ rv dbundib am /bestfruit/ rv drbrnboie am /watermelon/ rv"";

    /**
     * The following pattern will isolate the strings between the '/'
     * characters.  "".*"" matches any sequence of characters, so basically
     * the pattern reads, ""skip over any characters until we see an opening
     * '/', then match everything up to the next '/', then repeat 3 more
     * times"".  
     */
    const char *ptn = "".*/(.*)/.*/(.*)/.*/(.*)/.*/(.*)/.*"";

    /**
     * Regular expression type.
     */
    regex_t regex;

    /**
     * Compile the regular expression
     */
    if ( regcomp(&amp;regex, ptn, REG_EXTENDED) != 0 )
    {
        fprintf( stderr, ""regcomp failed on %s\n"", ptn );
        exit( 0 );
    }

    /**
     * Set up an array to store the start and end positions of the
     * matched substrings within text.  
     */
    fprintf( stdout, ""Number of subexpressions: %zu\n"", regex.re_nsub );
    size_t matchCount = regex.re_nsub + 1;
    regmatch_t pmatch[matchCount];

    int ret;
    /**
     * Execute the regular expression, then print out the matched expressions
     */
    if ( ( ret = regexec( &amp;regex, text, matchCount, pmatch, 0)) != 0 )
    {
        fprintf( stderr, ""%s does not match %s, return code %d\n"", text, ptn, ret );
    }
    else
    {
        fprintf( stdout, ""Sucessful match\n"" );
        for ( size_t i = 0; i &lt; matchCount; i++ )
        {
            if ( pmatch[i].rm_so &gt;= 0 )
            {
                fprintf( stdout, ""match %zu (start: %3lu; end: %3lu): %*.*s\n"", i,
                    (unsigned long) pmatch[i].rm_so,
                    (unsigned long) pmatch[i].rm_eo,
                    (int) ( pmatch[i].rm_eo - pmatch[i].rm_so ),
                    (int) ( pmatch[i].rm_eo - pmatch[i].rm_so ),
                    text + pmatch[i].rm_so );
            }
        }
    }
    return 0;
}
</code></pre>

<p>And here's the output:</p>

<pre><code>Number of subexpressions: 4
Sucessful match
match 0 (start:   0; end:  98): Svnsv am /apple/ rv dbndkbrb am /orange/ rv dbundib am /bestfruit/ rv drbrnboie am /watermelon/ rv
match 1 (start:  10; end:  15): apple
match 2 (start:  33; end:  39): orange
match 3 (start:  56; end:  65): bestfruit
match 4 (start:  84; end:  94): watermelon
</code></pre>

<p>If you want to copy the matched strings, you'll need to use <code>strncpy</code> and make sure you terminate the string properly:</p>

<pre><code>char matched_string[MAX_STRING_LENGTH + 1] = {0};
...
size_t length = pmatch[1].rm_eo - pmatch[1].rm_so;
strncpy( matched_string, text + pmatch[1].rm_so, length );

 /**
  * Make sure string is 0 terminated
  */
 matched_string[ length ] = 0;
</code></pre>
",0
53561523,53560654,0,"<p>You are only finding the first match because of your use of <code>strtok</code>. Try: </p>

<pre><code>char string[] = ""Svnsv am /apple/ rv dbndkbrb am /orange/ rv dbundib am /bestfruit/ rv drbrnboie am /watermelon/ rv"";

for (char *i = string; i != NULL; i = strstr(i, ""am"")) {
  char *start;
  char *end;
  char *match;

  if (start = strstr(i, ""/"")) {
    if (end = strstr(start + 1, ""/"")) {
        int start_index = start - string;
        int end_index = end - string;
        printf(""%.*s\n"", end_index - start_index - 1, string + start_index + 1);
    }
  }

  i += 2;
}
</code></pre>
",0
53402709,53402659,1,"<p>If I compile the your program but change the format specifier in <code>printf</code> to be <code>%.8X</code> (base 16) rather than <code>%d</code> (base 10), the output is:</p>

<pre><code>Key is: 00000000
Key is: 01010101
Key is: 02020202
Key is: 03030303
Key is: 04040404
Key is: 05050505
Key is: 06060606
Key is: 07070707
Key is: 08080808
Key is: 09090909
Key is: 0A0A0A0A
Key is: 0B0B0B0B
Key is: 0C0C0C0C
Key is: 0D0D0D0D
Key is: 0E0E0E0E
Key is: 0F0F0F0F
Key is: 10101010
Key is: 11111111
Key is: 12121212
Key is: 13131313
</code></pre>

<p>Do you see the pattern and the mistake now? </p>

<p>The second argument to <code>memset</code> is cast to an <code>unsigned char</code> (i.e. a byte) even though it has type <code>int</code>, as documented <a href=""http://www.cplusplus.com/reference/cstring/memset/"" rel=""nofollow noreferrer"">here</a>. This means that every single byte (not every <code>uint32_t</code>) will get populated with the value of <code>i</code> cast to a byte.</p>

<p>Use this code to write to your array:</p>

<pre><code>memset(mock_sector, 0, 512);

for (uint32_t i = 0; i &lt; 20; i++) 
{
    mock_sector[i * sizeof(uint32_t)] = i;
}
</code></pre>
",3
48493387,48491951,2,"<p>The behavior of the code you show is not defined by the C standard for two reasons. One, it violates the rules about pointer conversion. Two, it violates the rules about pointer arithmetic.</p>

<p>First, consider <code>(int *) A</code> in the call to <code>Print</code>. In this code, the array <code>A</code> is automatically converted to a pointer to its first member, which is an array of 3 <code>int</code>. This conversion is permitted by C 2011 [N1570] clause 6.3.2.3, paragraph 7, which says ¡°A pointer to an object type may be converted to a pointer to a different object type. If the resulting pointer is not correctly aligned for the referenced type, the behavior is undefined. Otherwise, when converted back again, the result shall compare equal to the original pointer.¡± However, this is all the standard says about the converted pointer. When you use the pointer in <code>Print</code>, in the expression <code>A[i * n + j]</code>, the behavior is not defined because nothing in the C standard tells us what this converted pointer is, other than that it can be converted back to the original type. Although the pointer was converted to an <code>int *</code>, we do not know that the result of the conversion is actually a usable pointer to the <code>int</code> that is <code>A[0][0]</code>.</p>

<p>Second, even if this pointer were a valid pointer to <code>A[0][0]</code>, the standard does not define what the behavior is when you use it to index beyond the array of 3 <code>int</code>. In the expression <code>A[i * n + j]</code>, the subscript expression is defined to be equivalent to <code>*((A) + (i * n + j)</code> by 6.5.2.1 2. When <code>i * n + j</code> is added to <code>A</code>, the semantics is governed by 6.5.6 8, which says that pointer arithmetic can be used to add to or subtract from a pointer as long as the result points to another element in the same array or to one beyond the last element. If you have a pointer to the first <code>int</code> of an array of 3 <code>int</code> and you add enough to move the pointer into the next array of 3 <code>int</code>, you have gone beyond the limit, and the behavior is undefined. (Since it is legal to point one past the last element, you can add 3 to a pointer to <code>A[0][0]</code> to get a pointer to one beyond <code>A[0][2]</code>, but you are not allowed to apply <code>*</code> to this pointer, because the paragraph says ¡°If the result points one past the last element of the array object, it shall not be used as the operand of a unary * operator that is evaluated.¡±)</p>

<p>That said, some C implementation will support these pointer conversions and this arithmetic. But the code is not portable; it is not strictly conforming C code.</p>
",13
48492137,48491951,-3,"<p>In C language arrays are always laid out contiguously in memory:</p>

<pre><code>int A[2][3] = {{1, 2, 3}, {4, 5, 6}};
</code></pre>

<p>In memory looks like this:</p>

<pre><code>1 2 3 4 5 6
</code></pre>

<p>exactly the same as:</p>

<pre><code>int A[6] = { 1, 2, 3, 4, 5, 6 };
</code></pre>

<p>Your approach is appropriate. </p>

<p>Edit:</p>

<p>There are some interesting theoretical arguments against the validity of this approach base on the pointer arithmetics. Yet, it seems to me that it would be quite hard to construct a compiler which on one hand has to conform to 3.1.2.5 and could not resolve the pointer arithmetics for objects of the same type/size.
It may mean nothing but I shell mention the code compiled and run properly on:</p>

<pre><code>GCC 4.6.3;  GCC 5.3.0; GCC 5.4.0; GCC 6.3; C99 Strict GCC 6.3; Zapcc 5.0.0; GCC 7.1.1;
GCC 7.2.0; clang 3.8.0; gcc 5.0.4
Microsoft (R) C/C++ Optimizing Compiler Version 19.00.23506 for x64; 
</code></pre>

<p>For what is worth, I have not encountered a compiler which would had difficulties with <code>August Karlstrom's</code> code.</p>
",4
55946872,55946793,6,"<p>Assuming there are always six columns, you can do the calculation by using the above initializer in a compound literal.</p>

<pre><code>#define WHITELIST_DEVICE_LENGTH ( sizeof ((int[][6])WHITELIST_DEVICE) / sizeof ((int[][6])WHITELIST_DEVICE[0]) ) 
</code></pre>

<p>or</p>

<pre><code>#define WHITELIST_DEVICE_LENGTH ( sizeof ((int[][6])WHITELIST_DEVICE) / sizeof (int[6]) /* a ""row"" */ ) 
</code></pre>

<p><code>(int[][6])WHITELIST_DEVICE</code> - Would normally creates an anonymous object in the scope it appears in. But when the literal is an operand to <code>sizeof</code> (expression variant) it will not create any object, instead only doing calculation on the types in question during compilation.</p>

<p>The <code>sizeof</code> trick for getting an array size needs no explaining I hope. It also makes the choice of <code>int</code> as array element immaterial, since that size will be canceled out during division. I chose that type to avoid any potential issues with your literal numbers not fitting in the array elements.</p>
",12
52224799,52224534,3,"<p><code>scanf</code> has a return value that indicates success:</p>

<p><strong>C Standard; ¡ì7.19.6.4.3</strong>:</p>

<blockquote>
  <p>The scanf function returns the value of the macro EOF if an input failure occurs before
  any conversion. Otherwise, the scanf function returns the number of input items
  assigned, which can be fewer than provided for, or even zero, in the event of an early
  matching failure.</p>
</blockquote>

<p>If you have a format string in your call to <code>scanf</code> that has one format specifier, then you can check that <code>scanf</code> succeeded in receiving an input of that type from the <code>stdin</code> by comparing its return value to 1.</p>

<p>Your compiler is warning you about this not specifically because <code>scanf</code> returns a value, but because it's important to inspect the result of <code>scanf</code>. A standard-compliant implementation of <code>printf</code>, for example, will also return a value (¡ì7.19.6.3.3), but it's not critical to the soundness of your program that you inspect it.</p>
",0
52160307,52160089,3,"<p>A <code>bool</code> in C is basically an integer underneath, which maps <code>0</code> to <code>false</code> and <code>1</code> to <code>true</code>1. Using <code>printf(""%d"", z)</code> on that value, will give you the numerical representation.</p>

<p>If you want a textual representation, you will have to provide that yourself, an example would be:</p>

<pre><code>printf(""%s"", z?""true"":""false"");
</code></pre>

<p>but there are many ways to do this.</p>

<p>1 Of course, it is not that simple, check out <a href=""https://en.cppreference.com/w/c/language/arithmetic_types#Boolean_type"" rel=""nofollow noreferrer"">these</a> <a href=""https://en.cppreference.com/w/c/types/boolean"" rel=""nofollow noreferrer"">links</a> for more information.</p>
",2
52314175,52313938,3,"<p>Your <code>itos</code> returns the address of the buffer passed to it.</p>

<p>Since you pass the same buffer to both <code>stoi</code> calls in this line:</p>

<pre><code>printf(""%s\n%s\n"",itos(~a,bstring),itos(~b,bstring));
</code></pre>

<p>The second call will overwrite the buffer content. <code>printf</code> then prints the same buffer (with the content written by the second call) twice, therefore you'll get the same output twice.</p>

<p>If you <em>split</em> the output to two different <code>printf</code> calls like this, it should work:</p>

<pre><code>printf(""%s\n"", itos(~a, bstring));
printf(""%s\n"", itos(~b, bstring));
</code></pre>

<p>Alternatively you can use two different buffers:</p>

<pre><code>char astring[sizeof(int) * 8 + 1];
char bstring[sizeof(int) * 8 + 1];
printf(""%s\n%s\n"", itos(~a, astring), itos(~b, bstring));
</code></pre>
",0
56163938,56163742,2,"<p>The left operand of an assignment does not have to be a variable. For example, the following assignments should and do work perfectly fine (and I assume you know that and just misspoke):</p>

<pre><code>array[index] = value;
*ptr = value;
</code></pre>

<p>I think what's confusing you about <code>*y++ = *z++;</code> is that you think that it's assigning to the result of an increment operation, which would indeed make no sense. But that's not the precedence of that expression: <code>*y++</code> is equivalent to <code>*(y++)</code>, not <code>(*y)++</code>. So you're dereferencing the result of <code>y++</code> and then assign a value to that dereferenced memory location, just as if you had written:</p>

<pre><code>int *ptr = y++;
*ptr = *z++;
</code></pre>
",0
56164453,56163742,2,"<blockquote>
  <p>left operand should be a variable and not an expression</p>
</blockquote>

<p>This is a misunderstanding. The term you are looking for is <em>lvalue</em>. This a C standard gibberish term originating from the term ""left value"". The definition of the term <em>lvalue</em> is roughly: an expression that designates an object.</p>

<p>The rules for the various operators discussed here are:</p>

<ul>
<li>The left operand of the assignment operators must always be a lvalue.</li>
<li>The result of the unary <code>*</code> operator is defined to always be a lvalue, so you can use it as if it was an object, and we can assign to it. </li>
<li>The result of the ++ operators however, is <em>not</em> an lvalue, so it cannot be used as the left operand of assignment.</li>
</ul>

<p>Examples:</p>

<pre><code>int x; int* y;

x = 5;   // Here x is both an object and an lvalue, so the code is valid
y = &amp;x;  // y is both a (pointer) object and an lvalue, code is valid.
*y = 0;  // *y is an lvalue designating the object y, code is valid
y++ = 1; // y++ is not an lvalue, the code is invalid
</code></pre>

<p>As for why <code>*y++</code> works, it is just a matter of operator precedence. The ++ is applied first, but since it is postfix, the change doesn't take place until the end of the expression. So <code>*</code> is applied to <code>y</code> and the result is a lvalue.</p>

<p>Had you written <code>++*y = 0;</code> then operator associativity had caused the <code>*</code> to execute first, the result <code>*y</code> being an lvalue. And then when you use <code>++</code> on that lvalue, the result of ++ is not an lvalue so the code is invalid. <code>++*y</code> in itself is valid code, but it can't be the left operand of assignment.</p>
",0
53021955,53021804,1,"<p>Compilers generally optimize the code they generate, when invoked with optimization features enabled. Any good compiler will produce the same code for simple routines that use <code>item</code> after <code>Type item = *pItem;</code> as they do for routines that just use <code>*pItem</code> without saving it in <code>item</code>.</p>

<p>However, suppose the routine is not simple. Suppose you have:</p>

<pre><code>void aFunction(Type *pItem, Type *qItem)
{
     Type item = *pItem;
     *qItem = SomeValue;
     printf(""%Format\n"", item);
     printf(""%Format\n"", *pItem);
}
</code></pre>

<p>In this case, the compiler cannot know that <code>*pItem</code> is the same as <code>item</code>, because <code>pItem</code> and <code>qItem</code> might point to the same object, so <code>*qItem = SomeValue</code> might have changed <code>*pItem</code>. Therefore, to implement the second <code>printf</code>, the compiler must load <code>*pItem</code> after executing the <code>*qItem = SomeValue</code>.</p>

<p>For this reason, using <code>Type item = *pItem;</code> may actually be better than not creating a new local object if you know that <code>pItem</code> and <code>qItem</code> will always point to different objects, because it allows the compiler to load <code>*pItem</code> once and keep it in a processor register instead of reloading it, perhaps multiple times if <code>*pItem</code> and <code>*qItem</code> are accessed multiple times throughout the routine.</p>

<p>In this case, there is a way to tell the compiler that this potential equality of pointers does not occur. The <code>restrict</code> qualifier will tell the compiler that the object <code>pItem</code> points to is accessed <strong>only</strong> through the <code>pItem</code> pointer:</p>

<pre><code>void aFunction(restrict Type *pItem, Type *qItem)
</code></pre>

<p>However, in general, these situations can become very complicated. <code>Type</code> might be a structure that contains pointers to other objects of type <code>Type</code>. For example, <code>Type</code> might be a tree node that contains members <code>left</code> and <code>right</code> that point to subtrees. For the most part, you should write code in a way that is clear and let the compiler optimize it. If it is convenient for you to save <code>*pItem</code> in a local object and use that, then do so. As you gain experience, you will come to learn more about how compilers behave and how you can write code that allows a compiler to optimize.</p>
",1
58141646,58141571,5,"<p>The type of your <code>swap</code> variable (currently <code>int</code>) needs to match the type of the values you are swapping (currently <code>double</code>)</p>

<p>So anytime you swap two values, the one that is assigned to <code>swap</code> is currently being downcast to type <code>int</code>.</p>
",0
52488581,52488535,4,"<p>You are passing <code>""%d""</code> in the <em>first</em> parameter of <code>print()</code>, so it (and the compiler, since you are clearly using one that validates printf-style parameters at compile-time) will interpret the <em>second</em> parameter as an integer, but you are passing <code>""%lf""</code> in the <em>second</em> parameter.  A string literal is a <code>char[]</code> in C and a <code>const char[]</code> in C++, and will decay to a <code>char*</code> and <code>const char*</code>, respectively.  Hence the error.</p>

<p>You need to put ALL of your format specifiers in the <em>first</em> parameter only, eg:</p>

<pre><code>printf(""%d %lf %c %s"", userInt, userDouble, userChar, userString);
</code></pre>

<p>Or, if you really wanted to separate the values with quotes and commas in the output:</p>

<pre><code>printf(""\""%d\"", \""%lf\"", \""%c\"", \""%s\"""", userInt, userDouble, userChar, userString);
</code></pre>
",1
58407075,58406493,-1,"<p>You can overwrite previous struct values and set individual members by using <em>compound literals</em>:</p>

<pre><code>typedef struct{
  float FirstValue[3];
  float LastValue[3];

} VALUES;

int main()
{
  VALUES v;
  v = (VALUES) { .FirstValue = {1,2,3} };
}
</code></pre>

<p>This is similar to <code>memset</code> all zeroes, followed by <code>memcpy</code>.</p>
",1
58406621,58406493,5,"<p>Well, you can't.</p>

<p>The general syntax</p>

<pre><code> SomeArrayVariable = {1,2,3};
</code></pre>

<p>is valid only as initialization - not as assignment.</p>

<p>Example:</p>

<pre><code>int arr[3];
arr = {1, 2, 3}; // Error - invalid assignment

int arr[3] = {1, 2, 3}; // Fine - valid initialization
</code></pre>

<p>Instead you can do:</p>

<pre><code>VALUES.FirstValue[0] = 1;
VALUES.FirstValue[1] = 2;
VALUES.FirstValue[2] = 3;
</code></pre>

<p>or you can do like:</p>

<pre><code>struct{
  float FirstValue[TOTAL_NUMBER];
  float LastValue[TOTAL_NUMBER];

} VALUES = {{1, 2, 3}, {0, 0, 0}};
</code></pre>

<p>to make it an initialization.</p>

<p>That said.. it's more common to make a typedef'ed struct and then make instances of that type where you need it. This will also allow you to use initialization. Like:</p>

<pre><code>#include &lt;stdio.h&gt;

#define TOTAL_NUMBER 3

typedef struct{
  float FirstValue[TOTAL_NUMBER];
  float LastValue[TOTAL_NUMBER];    
} values_t;

int main(void) {
    values_t values = {{1,2,3}, {0, 0, 0}};
    printf(""%f\n"", values.FirstValue[1]);
    printf(""%f\n"", values.LastValue[1]);
    return 0;
}
</code></pre>
",0
58406658,58406493,1,"<p>You can't assign array as you do for normal variable.</p>

<p>But you can use <code>memcpy</code> to copy the compound literals as below.</p>

<pre><code>memcpy(VALUES.FirstValue, (float[]){1,2,3}, sizeof VALUES.FirstValue);
</code></pre>
",0
54170947,54170773,1,"<p>A quick google search discovered <a href=""https://gnutls.org/manual/html_node/Common-types.html"" rel=""nofollow noreferrer"">this link</a> with the internal structure of <code>gnutls_datum_t</code>:</p>

<pre><code> typedef struct
 {
   unsigned char *data;
   unsigned int size;
 } gnutls_datum_t;
</code></pre>

<p>As you can see, this structure has two fields, <code>data</code> and <code>size</code>. This is why when they initialize <code>key</code>, they pass two variables, split by the comma in the middle.</p>

<p>The first one, setting the value of <code>data</code> is:</p>

<pre><code>(void *)
  ""\xaa\xf4\xc6\x1d\xdc\xc5\xe8\xa2\xda\xbe""
  ""\xde\x0f\x3b\x48\x2c\xd9\xae\xa9\x43\x4d""
</code></pre>

<p>The second one, setting the value of <code>size</code> is:</p>

<pre><code>20
</code></pre>

<hr>

<p>Regarding your other question:</p>

<p>You can read more about initialization of variable in C using list initializers <a href=""https://en.cppreference.com/w/c/language/initialization"" rel=""nofollow noreferrer"">here</a>. There are multiple different scenarios.</p>
",0
54231844,54231817,1,"<p><code>args[1]</code> is an array of arrays, and an array of arrays is <em>not</em> the same as a pointer to a pointer.</p>

<p>It can however decay to a pointer to arrays. In your case <code>args[1]</code> will decay to the type <code>char (*)[3]</code>. Which is the type you need to use for the argument:</p>

<pre><code>struct MateMessage newMate(char (*cr)[3]){ ...... }
</code></pre>
",0
52159888,52158984,2,"<p>Here's an alternative approach, that should be a bit more robust. It uses C99's flexible array member.</p>

<p>Instead of fixed-size arrays, put the character data to the flexible array member. The first name is stored first, followed by (an end of string NUL, <code>\0</code> and) the last name (and an another end of string NUL).</p>

<p>To avoid having to find where the first name starts, we can store either a pointer, or an offset. I prefer the offset, but as long as you (the programmer!) are careful, the pointer will work fine as well:</p>

<pre><code>struct patron {
    char *last_name;    /* Points to within the first_name member */
    char  first_name[]; /* Flexible array member */
};
</code></pre>

<p>Usually, you write helper functions to allocate and initialize, as well as free, such structures:</p>

<pre><code>void free_patron(struct patron *p)
{
    if (p) {
        /* ""Poisoning"" the structure, to help detect possible use-after-free bugs. */
        p-&gt;last_name = NULL;
        p-&gt;first_name[0] = '\0';

        /* Both names reside in the same dynamically allocated part. */
        free(p);
    }
}

struct patron *new_patron(const char *first, const char *last)
{
    const size_t   firstlen = (first) ? strlen(first) : 0;
    const size_t   lastlen = (last) ? strlen(last) : 0;
    struct patron *newpatron;

    /* Don't allow unnamed patrons. */
    if (firstlen + lastlen &lt; 1) {
        fprintf(stderr, ""new_patron(): NULL or empty name.\n"");
        exit(EXIT_FAILURE);
    }

    /* Allocate enough memory for the structure. */
    newpatron = malloc(sizeof (struct patron) + firstlen + 1 + lastlen + 1);
    if (!newpatron) {
        fprintf(stderr, ""new_patron(): Not enough memory.\n"");
        exit(EXIT_FAILURE);
    }

    /* First name goes first. */
    if (firstlen &gt; 0)
        memcpy(newpatron-&gt;first_name, first, firstlen);
    newpatron-&gt;first_name[firstlen] = '\0';

    /* Last name follows. */
    newpatron-&gt;last_name = newpatron-&gt;first_name + firstlen + 1;
    if (lastlen &gt; 0)
        memcpy(newpatron-&gt;last_name, last, lastlen);
    newpatron-&gt;last_name[lastlen] = '\0';

    return newpatron;
}
</code></pre>

<p>To manage an array of patrons, this time each entry is a pointer to a struct patron. This means you can choose whether you use a fixed-size array, where you locate a vacant seating by locating a NULL pointer.</p>

<pre><code>struct seating {
    size_t           seats;
    struct patron  **seat;
};

#define  NO_VACANCIES  (~(size_t)0)

void free_seating(struct seating *s)
{
    if (s) {
        free(s-&gt;seat);
        s-&gt;seats = 0;
        s-&gt;seat = NULL;
    }
}

void init_seating(struct seating *s, const size_t n)
{
    size_t  i;

    if (!s) {
        fprintf(stderr, ""init_seating(): NULL pointer to struct seating.\n"");
        exit(EXIT_FAILURE);
    }

    /* No seats wanted at all? */
    if (n &lt; 1) {
        s-&gt;seats = 0;
        s-&gt;seat  = NULL;
        return;
    }

    s-&gt;seat = malloc(n * sizeof s-&gt;seat[0]);
    if (!s-&gt;seat) {
        fprintf(stderr, ""init_seating(): Not enough memory.\n"");
        exit(EXIT_FAILURE);
    }
    s-&gt;seats = n;

    /* Initialize all seats as vacant. */
    for (i = 0; i &lt; n; i++)
        s-&gt;seat[i] = NULL;

    /* Done. */
}

/* Find a vacant/unused seating.
   Returns the seat index, or NO_VACANCIES if all taken. */
size_t vacant_seating(struct seating *s)
{
    size_t  i;

    if (!s || s-&gt;seats &lt; 1)
        return NO_VACANCIES;

    for (i = 0; i &lt; s-&gt;seats; i++)
        if (!s-&gt;seat[i])
            return i; /* Seat i is vacant. */

    return NO_VACANCIES;
}

/* Removes a patron from a seating.
   You'll usually want to call
       free_patron(release_seating(&amp;my_threatre, place));
   to free the structure naming the patron as well.
   This is safe to do even if the seat was vacant. */
struct patron *release_seating(struct seating *s, size_t i)
{
    if (s &amp;&amp; i &lt; s-&gt;seats) {
        struct patron *old_patron = s-&gt;seat[i];
        s-&gt;seat[i] = NULL;
        return old_patron;
    } else
        return NULL;
}
</code></pre>

<p>In your program, using these is simple:</p>

<pre><code>struct seating  my_theatre;
size_t          place;

/* Small venue with 50 seats. */
init_seating(&amp;my_theatre, 50);

/* Find a vacant seat. */
place = vacant_seating(&amp;my_theatre);
if (place == NO_VACANCIES) {
    fprintf(stderr, ""Sorry, the theatre is full.\n"");
    return EXIT_FAILURE;
}

/* Seat DanielN there. */
my_theatre.seat[place] = new_patron(""Daniel"", ""N"");
</code></pre>

<p>Note that because <code>my_theatre.seat</code> is an array, <code>my_theatre.seat + place</code> is a pointer to the <code>place</code>th element in the array, exactly like <code>&amp;(my_theatre.seat[place])</code>.</p>

<p>Also note that when allocating arrays, say <code>struct something *foo;</code>, you can use the sizeof operator: <code>foo = malloc(n * sizeof foo[0]);</code> tries to allocate enough memory for <code>n</code> elements of whatever type <code>foo[0]</code> is. Note that to help us programmers remember that <code>sizeof</code> is an operator, and not a function. Even when <code>foo</code> is undefined or NULL, <code>sizeof foo[0]</code> is valid, because the sizeof operator only examines the <em>type</em> of its argument to determine the size of the type.</p>

<p>The <code>NO_VACANCIES</code> macro evaluates to the largest <code>size_t</code> value (that the type can describe in binary on non-binary computers). That expression works for all unsigned integer types, and <code>size_t</code> is an unsigned (nonnegative) integer type.  It would be better to include <code>&lt;limits.h&gt;</code> and use the <code>SIZE_MAX</code> (similar to <code>CHAR_MAX</code>, <code>UCHAR_MAX</code>, <code>INT_MAX</code>, and so on that that header file defines), but I'm not sure if all (well, Microsoft; they like to do things their own way) define <code>SIZE_MAX</code>.</p>
",4
51898503,51898272,1,"<p>An Armstrong number N is where the sum of the individual digits (say, A, B, C), raised to the power of the number of digits, equals the number itself.</p>

<pre><code>N = A^3 + B^3 + C^3
</code></pre>

<p>So to calculate this for 0-999, you need a loop. In each iteration of the loop you need to start the summation over again from 0. Take <code>i=10</code> and <code>i=11</code> from your loop as an example. Neither is an Armstrong number, but they should be:</p>

<pre><code>i=10: 1^2 + 0^2 = 1
i=11: 1^2 + 1^2 = 2
</code></pre>

<p>Without resetting <code>sum</code>, you're using the results of the previous numbers calculation:</p>

<pre><code>i=10: 1^2 + 0^2 + 9^1 (+ 8^1 + 7^1 + ...) ¡Ù 1
i=11: 1^2 + 1^2 + (1^2 + 0^2 + 9^1) + ... ¡Ù 2
</code></pre>
",2
54618970,54618687,0,"<p>Your attempt is a reasonable attempt but it reveals some misconceptions about how objects in C work. That's all right. Yours is a good teaching example and I believe that you will be glad that you have made it. Now try this:</p>

<pre><code>static const int NO_ROWS    = 3;
static const int NO_COLUMNS = 4;

int *create_matrix(
  int *const matrix, const int no_rows, const int no_columns
) {
    int k = 0;
    for (int i = 0; i &lt; no_rows; i++) {
        for (int j = 0; j &lt; no_columns; j++) {
            matrix[no_columns*i+j] = k++;
        }
    }
    return matrix;
}

int main(void) {
    // Creating a custom matrix.
    int m[NO_ROWS][NO_COLUMNS];
    create_matrix(m[0], NO_ROWS, NO_COLUMNS);
    return 0;
}
</code></pre>

<p>Your matrix is constructed as an array of arrays. However, in C, an array is just a region of storage in which a sequence of objects of the same type (in your case, <code>int</code>) can be kept. The symbol <code>m</code> is interpreted by the C compiler as</p>

<ul>
<li>meaning the address of the matrix's initial element&mdash;or, more precisely, because your matrix is an array of arrays, the address of the matrix's initial row; and</li>
<li>referring to the type of the matrix's initial row, which is itself an array type, <code>int[NO_COLUMNS]</code>.</li>
</ul>

<p>The problem is that there exists no really neat, direct way to specify to a precompiled function the type <code>int[NO_COLUMNS]</code> unless you are willing to hard-code the type. Therefore, one relatively straightforward way to treat the matrix within <code>create_matrix()</code> would be as a single, linear array, as shown.</p>

<p>One point to grasp here is that C does not understand the shape of your matrix. Rather than rows and columns, C sees a linear region of storage.</p>

<p>Another point to grasp is that function to which an array is passed receives only the array's initial address. If it needs the size, that must be separately passed.</p>
",1
53242170,53241650,0,"<p>The problem is that you're setting your seen number using <code>i</code> instead of <code>j</code>.</p>

<pre><code>    for (i = 0; i &lt; m; i++) {
        for (j = 0; j &lt; m; j++) {
            if (want[j] == input[i]) {
                seen[i] = seen[i] + 1;  // HERE
            }
        }
    }
</code></pre>

<p>If you input <code>2 2 2</code> then it'll match when <code>i</code> is 0. Then it will match when <code>i</code> is 1. And it will match when <code>i</code> is 2. So you get a 1 in each spot. <code>i</code> is the position of the number seen. Instead you want to increment <code>j</code>, the number being examined - 1.</p>

<pre><code>    for (i = 0; i &lt; m; i++) {
        for (j = 0; j &lt; m; j++) {
            if (want[j] == input[i]) {
                seen[j] = seen[j] + 1;
            }
        }
    }
</code></pre>

<p>Which points out a way to make the whole thing much more efficient. <code>want</code> is not necessary. Since we want numbers from 1 to n we can use the array index + 1 of <code>seen</code>. And you don't need to rescan the whole array each time, <code>seen</code> can be built up as you read.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    int size;
    scanf(""%d"",&amp;size);

    int seen[size];
    int input;

    // Initialize seen
    for(int i = 0; i &lt; size; i++) {
        seen[i] = 0;
    }

    // Read input and store how many integers we've seen
    for(int i = 0; i &lt; size; i++) {
        scanf(""%d"", &amp;input);
        seen[input-1] += 1;
    }

    // Print the counts
    for (int i = 0; i &lt; size; i++) {
        printf(""%d: %d "", i+1, seen[i]);
    }
    puts("""");
}
</code></pre>
",0
52345304,52345234,-3,"<p>This sounds like a problem with unsigned integer subtraction: If you subtract the ""higher"" pointer from the ""lower"", you'll get a negative difference. If you represent a negative number as an unsigned number, it will look like a very big number...  </p>
",1
57940526,57940452,1,"<p>The following line allocates memory space in the stack but after the function ends everything is gone:</p>

<pre><code>char result[1000];
</code></pre>

<p>You need to allocate memory in the heap like that:</p>

<pre><code>char *result = malloc(sizeof(char) *1000);
</code></pre>

<p>Note: don't forget to free that memory space by <code>free</code> function.</p>
",6
57940734,57940452,2,"<p><code>char* result[1000];</code> creates an array of 1000 pointers. That's wrong in a number of ways.</p>

<ol>
<li>You want a block of 1000 chars, not pointers.</li>
<li>Actually, 1000 is not the number of characters you want. You usually want a smaller number, but you could also want a larger number.</li>
<li>You don't want to store the result in automatically allocated memory, because that will be freed as soon as you exit the function. Use <code>malloc</code> (or something that does a <code>malloc</code> such as <code>strdup</code>).</li>
</ol>

<p>Fix:</p>

<pre><code>// Returns a copy that needs to be freed.
char* find_word_start(const char* src) {
   while (*src == ' ')
      ++src;

   size_t len = 0;
   while (str[len] != '\0')
      ++len;

   ++len;  // Include NUL
   result = malloc(len);

   char* dst = result;
   while (len--)
      *(dst++) = *(src++);

   return result;
}
</code></pre>

<p>Well, I was avoiding using string functions above like you did, but they greatly simplify the solution.</p>

<pre><code>// Returns a copy that needs to be freed.
char* find_word_start(const char* src) {
   while (*src == ' ')
      ++src;

   return strdup(src);
}
</code></pre>

<p>That said, since you return the tail end of the string, you could simply return a pointer into the existing string.</p>

<pre><code>// Returns a pointer into the provided string.
const char* find_word_start(const char* str) {
   while (*str == ' ')
      ++str;

   return str;
}
</code></pre>
",0
56059772,56059253,5,"<p>You seem to think <code>(int *)1</code> produces the address where the value 1 is stored. It does not.</p>
<p>When a cast such as <code>(int *)</code> is used to convert an integer to a pointer, the result is generally that the value is made into an address.<sup>1</sup></p>
<p>Thus <code>int *i = (int *)1;</code> sets <code>i</code> to point to the address 1. Then, when attempting to print <code>*i</code>, your program crashed because 1 was not a valid memory address. (Quite commonly, the first page of memory is kept unmapped so that incorrect uses of the null pointer will crash and reveal a problem rather than allowing the program to continue executing with incorrect data.)</p>
<p>To set <code>i</code> to point to an <code>int</code> with the value 1, you must set it to the address of an <code>int</code> object that has the value 1. One way to do this is:</p>
<pre><code>int n = 1;
int *i = &amp;n;
</code></pre>
<p>You can also create an unnamed <code>int</code> with the value 1 using a compound literal:</p>
<pre><code>int *i = &amp; (int) { 1 };
</code></pre>
<p>The <code>(int) { 1 }</code> creates a compound literal with the value 1, and the <code>&amp;</code> takes its address, and then <code>i</code> is initialized to that address.</p>
<h2>Footnote</h2>
<p><sup>1</sup> According to the C standard, the result is implementation-defined. So a compiler could define any result it wants. However, every C compiler I have seen makes the integer value into an address, in one way or another. The resulting address is not necessarily valid to use for accessing an object.</p>
",0
56059376,56059253,3,"<blockquote>
<pre><code>printf(""The value that i pointer points to is %d\n"", *i);
</code></pre>
</blockquote>

<p>You try to dereference the pointer <code>i</code>, but it's value (the value of the pointer) is some value, you set yourself. Can you guarantee that at address <code>0x0001</code> is an integer you own? All you can do with such a pointer is print it's pointer value (not the value it points to):</p>

<pre><code>printf(""The value of pointer i is %p\n"", i);
</code></pre>
",0
52780004,52779571,4,"<p>You must</p>

<ol>
<li>initialize <code>S_n</code></li>
<li>take in account the size of the window to integrate on.</li>
</ol>

<p>Thus the correct code is:</p>

<pre><code>  double x,y,S_n;
  int n = 10000;
  int i;

  S_n = 0;
  srand ( time ( NULL));

  for (i = 0; i &lt; n; i++){
    x = (double)rand()/RAND_MAX*2.0-1.0;   //generate double in range -1 to 1
    if(x &lt; 0){
      y = sin(M_PI/x);
    }
    else {
      y = 0.5;
    }
    S_n = S_n + y * (1.0 - -1.0);
  }
  S_n = S_n/n;
  printf ( ""%f\n"", S_n);
</code></pre>
",4
52842185,52842110,5,"<p>The statement</p>

<pre><code>while ((to[i] = from[i]) != '\0')
    ++i;
</code></pre>

<p>first assigns the value of <code>from[i]</code> to <code>to[i]</code> and <em>then</em> compares the assigned value to <code>\0</code> - if it was the null terminator that was just copied, the loop ends.</p>

<p>Thus</p>

<pre><code>to[i] = '\0';
</code></pre>

<p>is unnecessary, but not otherwise incorrect here. </p>

<p>However, having unnecessary code around is not good style because it makes refactoring and reasoning about the other code <em>harder</em>. Just the presence of that last assignment could then confuse a future reader into thinking that the loop in itself is not sufficient to properly terminate the string.</p>

<p>Additionally, should someone come and edit the code into </p>

<pre><code>while ((*to++ = *from++));
</code></pre>

<p>as suggested by WhozCraig, they could then mistakenly think that they <em>do</em> need to add the null terminator, this time potentially writing out of bounds:</p>

<pre><code>*to++ = 0;
</code></pre>
",2
51518833,51512180,5,"<p>The answer can be computed with simple arithmetic without any iteration. Many Project Euler questions are intended to make you think about clever ways to find solutions without just using the raw power of computers to chug through calculations.</p>

<p>Given positive integers <em>N</em> and <em>F</em>, the number of positive multiples of <em>F</em> that are less than <em>N</em> is floor((<em>N</em>-1)/<em>F</em>). (floor(<em>x</em>) is the greatest integer not greater than <em>x</em>.) For example, the number of multiples of 5 less than 1000 is floor(999/5) = floor(199.8) = 199.</p>

<p>Let <em>n</em> be this number of multiples, floor((<em>N</em>-1)/<em>F</em>).</p>

<p>The first multiple is <em>F</em> and the last multiple is <em>n</em>?<em>F</em>. For example, with 1000 and 5, the first multiple is 5 and the last multiple is 199?5 = 995.</p>

<p>The multiples are evenly spaced, so the average of all of them equals the average of the first and the last, so it is (<em>F</em> + <em>n</em><i>F</i>)/2.</p>

<p>The total of the multiples equals their average multiplied by the number of them, so the total of the multiples of <em>F</em> less than <em>N</em> is <em>n</em> ? (<em>F</em> + <em>n</em>?<em>F</em>)/2.</p>

<p>As we have seen in other answers and in comments, adding the sum of multiples of 3 and the sum of multiples of 5 counts the multiples of both 3 and 5 twice. We can correct for this by subtracting the sum of those numbers. Multiples of both 3 and 5 are multiples of 15.</p>

<p>Thus, we can compute the requested sum using simple arithmetic without any iteration:</p>

<pre><code>#include &lt;stdio.h&gt;


static long SumOfMultiples(long N, long F)
{
    long NumberOfMultiples = (N-1) / F;
    long FirstMultiple = F;
    long LastMultiple = NumberOfMultiples * F;

    return NumberOfMultiples * (FirstMultiple + LastMultiple) / 2;
}


int main(void)
{
    long N = 1000;
    long Sum = SumOfMultiples(N, 3) + SumOfMultiples(N, 5) - SumOfMultiples(N, 3*5);

    printf(""%ld\n"", Sum);
}
</code></pre>

<p>As you do other Project Euler questions, you should look for similar ideas.</p>
",0
51512632,51512180,2,"<p>Direct translation of your python code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
  int sum = 0;

  for (int x = 0; x &lt; 1000; x++)
  {
    if (x % 5 == 0 || x % 3 == 0)
      sum += x;
  }

  printf(""%d"", sum);
}
</code></pre>
",0
54022970,54022943,4,"<p>You're reading past the end of your array:</p>

<pre><code>for(i = 0 ; i&lt;10 ; i++){
   if(vet[i] &gt; max) max=vet[i];
}
</code></pre>

<p>If you enter in 3 for <code>aux1</code>, then <code>vet</code> is an array of 3 numbers, but here you loop through 10 array elements.  This reads past the end of the array, invoking <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined beahvior</a>.</p>

<p>Fix the loop to be within the size of the array:</p>

<pre><code>for(i = 0 ; i&lt;aux1 ; i++){
   if(vet[i] &gt; max) max=vet[i];
}
</code></pre>

<p>You have a similar issue here when counting the max element:</p>

<pre><code>while(j&lt;=aux1){
    if(max==vet[j]){
        cont++;
    }
    j++;
}
</code></pre>

<p>You have an off-by-one error here, your loop condition should instead be:</p>

<pre><code>while(j&lt;aux1){
</code></pre>
",1
54022970,54022943,4,"<p>You're reading past the end of your array:</p>

<pre><code>for(i = 0 ; i&lt;10 ; i++){
   if(vet[i] &gt; max) max=vet[i];
}
</code></pre>

<p>If you enter in 3 for <code>aux1</code>, then <code>vet</code> is an array of 3 numbers, but here you loop through 10 array elements.  This reads past the end of the array, invoking <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined beahvior</a>.</p>

<p>Fix the loop to be within the size of the array:</p>

<pre><code>for(i = 0 ; i&lt;aux1 ; i++){
   if(vet[i] &gt; max) max=vet[i];
}
</code></pre>

<p>You have a similar issue here when counting the max element:</p>

<pre><code>while(j&lt;=aux1){
    if(max==vet[j]){
        cont++;
    }
    j++;
}
</code></pre>

<p>You have an off-by-one error here, your loop condition should instead be:</p>

<pre><code>while(j&lt;aux1){
</code></pre>
",1
52229032,52229001,3,"<p>Remember that <code>""\n""</code> and <code>'\n'</code> are two entirely different things, the first being <code>char*</code> and the second being <code>char</code>. Fix that and your code works.</p>

<p>If you enable warnings you get this:</p>

<pre><code>getch.cpp:9:15: warning: result of comparison against a string literal is unspecified (use strncmp instead) [-Wstring-compare]
    while (ch != ""\n"") {
              ^  ~~~~
getch.cpp:9:15: error: comparison between pointer and integer ('int' and 'const char *')
    while (ch != ""\n"") {
           ~~ ^  ~~~~
1 warning and 1 error generated.
</code></pre>

<p>A compiler like <code>clang</code> will alert you to simple mistakes like this if you ask it to, like with <code>-Wall</code>.</p>
",0
51744143,51744050,1,"<p>C is a procedural language, so the lines execute one after the other. You have to use the values after you read them in</p>

<pre><code>int main ()
{
  int pq1, pq2;
  float ptq;

  ptq = pq1 + pq2; // this is undefined as you have not set a value for pq1, pq2

  printf (""\t-Prelims-\n"");
  printf (""Grade from Quiz #1?\n"");
  printf (""Grade from Quiz #2?\n"");

  gotoxy (36, 4);
  scanf (""%d"", &amp;pq1);
  gotoxy (36, 5);
  scanf (""%d"", &amp;pq2);

  // now you have values for pq1 and pq2, so this is where you should be using them

  printf (""Your grades from prelims is %.2f"", &amp;ptq); // here you should be using the value of ptq not its address, as we are outputting it not asking the function to fill it in.

  return 0;
}
</code></pre>
",0
52361619,52361553,4,"<p><a href=""https://code.visualstudio.com/"" rel=""nofollow noreferrer"">Visual studio code</a> has nothing to do with your issue, you are <em>not</em> compiling with it. Because it is an <a href=""https://en.wikipedia.org/wiki/Integrated_development_environment"" rel=""nofollow noreferrer"">IDE</a> (or source code editor), not a compiler. I guess you are using it on some Linux or POSIX system. BTW my preferred <a href=""https://en.wikipedia.org/wiki/Source_code_editor"" rel=""nofollow noreferrer"">source code editor</a> is GNU <a href=""https://www.gnu.org/software/emacs/"" rel=""nofollow noreferrer"">emacs</a>. So your IDE is running some compilation commands (and you <em>need</em> to understand which ones and what these commands are doing). You could run these commands in a terminal (and that actually might be simpler).</p>

<p>As your console logs shows, you are compiling with <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a>. Some <code>gcc</code> command has been started (by Visual studio code probably).</p>

<p>Read carefully about <a href=""https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html"" rel=""nofollow noreferrer"">Invoking GCC</a>. Order of arguments matters a lot!</p>

<p>You should compile your code with</p>

<pre><code>gcc -Wall -Wextra -g q2.c -lm -o q2
</code></pre>

<p>Let me explain this a bit:</p>

<ul>
<li><p><code>gcc</code> is your compiler front-end (the actual compiler <a href=""https://en.wikipedia.org/wiki/GNU_Compiler_Collection"" rel=""nofollow noreferrer"">is <code>cc1</code></a> but you never use it directly; you ask <code>gcc</code> to run it)</p></li>
<li><p><code>-Wall</code> asks for almost all warnings</p></li>
<li><p><code>-Wextra</code> asks for extra warnings. You'll be happy to get them</p></li>
<li><p><code>-g</code> asks for debugging information in <a href=""https://en.wikipedia.org/wiki/DWARF"" rel=""nofollow noreferrer"">DWARF</a>. You really want to be able to <a href=""https://sourceware.org/gdb/current/onlinedocs/gdb/"" rel=""nofollow noreferrer"">use the <code>gdb</code> debugger</a>, and <code>gdb</code> practically needs debugging information.</p></li>
<li><p><code>q2.c</code> is the source file of your sole <a href=""https://en.wikipedia.org/wiki/Translation_unit_(programming)"" rel=""nofollow noreferrer"">translation unit</a></p></li>
<li><p><code>-lm</code> is for your math library. You are using <a href=""http://man7.org/linux/man-pages/man3/log.3.html"" rel=""nofollow noreferrer"">log(3)</a> and its documentation mention that.</p></li>
<li><p><code>-o q2</code> tells <code>gcc</code> to put the executable in <code>q2</code> (the actual work is done by the <code>ld</code> linker invoked by <code>gcc</code>)</p></li>
</ul>

<p>How to configure visual studio code to use that command is your business. You could otherwise type the above command in a terminal. Then you can run your <code>q2</code> program by typing <code>./q2</code> in a terminal for your <a href=""https://en.wikipedia.org/wiki/Unix_shell"" rel=""nofollow noreferrer"">shell</a> (and you could use <code>gdb</code> <a href=""https://stackoverflow.com/a/14495000/841108"">on it</a>).</p>

<p>Notice that <code>gcc</code> is starting other programs (like <code>cc1</code>, <code>as</code>, <code>ld</code>). If you want to understand which ones, insert <code>-v</code> after <code>gcc</code> in the command above.</p>

<p>Be sure to read the <a href=""https://en.cppreference.com/w/c"" rel=""nofollow noreferrer"">documentation</a> of <em>every</em> function you are using (so read <a href=""http://man7.org/linux/man-pages/man3/printf.3.html"" rel=""nofollow noreferrer"">printf(3)</a>, <a href=""http://man7.org/linux/man-pages/man3/scanf.3.html"" rel=""nofollow noreferrer"">scanf(3)</a>, <a href=""http://man7.org/linux/man-pages/man3/log.3.html"" rel=""nofollow noreferrer"">log(3)</a> at least...) and of every program you are using (e.g. <a href=""https://gcc.gnu.org/onlinedocs/gcc/"" rel=""nofollow noreferrer"">of <code>gcc</code></a> and <a href=""https://code.visualstudio.com/docs"" rel=""nofollow noreferrer"">of Visual studio code</a>).</p>

<p>Once you'll write bigger programs made of <em>several</em> translation units (e.g. <code>foo.c</code>, <code>bar.c</code>, <code>gee.c</code>), you would want to use some <a href=""https://en.wikipedia.org/wiki/Build_automation"" rel=""nofollow noreferrer"">build automation</a> tool (because compiling all of them every time with <code>gcc -Wall -Wextra -g foo.c bar.c gee.c -lm -o qqq</code> is possible, but <em>inconvenient</em>). You could learn to use <a href=""https://www.gnu.org/software/make/"" rel=""nofollow noreferrer"">GNU make</a> (or <a href=""http://ninja-build.org/"" rel=""nofollow noreferrer"">ninja</a>).</p>

<p>Read <a href=""https://ericlippert.com/2014/03/05/how-to-debug-small-programs/"" rel=""nofollow noreferrer""><em>How to debug small programs</em></a>. Don't expect your program to work as you want at first.</p>

<p>BTW, study the source code of some <em>existing</em> <a href=""https://en.wikipedia.org/wiki/Free_software"" rel=""nofollow noreferrer"">free software</a> programs (but start with simple projects, e.g. on <a href=""http://github.com/"" rel=""nofollow noreferrer"">github</a>, of less than a hundred thousand lines). This could teach you many useful things.</p>
",1
51875600,51875403,0,"<p>Creating a ring buffer/FIFO with hardcopies of generic type is highly questionable design for embedded systems. You shouldn't need that high level of abstraction for code so close to the hardware.</p>

<p>Either you make a ring buffer with a data type tag (like an enum) plus a <code>void*</code> to data allocated elsewhere, or you make a ring buffer where all data is of the same type. Everything else is most likely confused program design (""XY problem"").</p>

<p>You need some means to lock access to the ring buffer internally, to make it thread-safe/interrupt-safe. This, as well as the time stamp, has to be handled internally by the ring buffer ADT.</p>
",2
54122179,54121909,3,"<p>Save time. Enable all complier warnings.</p>

<blockquote>
  <p>warning: format '%d' expects argument of type 'int *', but argument 3 has type 'int' [-Wformat=]</p>
</blockquote>

<p>The <code>*printf</code> specifier <code>""%d""</code> expects a matching <code>int</code>. But this is not <code>printf()</code>.<br>
The <code>*scanf</code> specifier <code>""%d""</code> expects a matching <code>int *</code>, not an <code>int</code>.</p>

<pre><code>    // fscanf(BLZ1, ""%d;%50[^\n]\n"", Bank[i].banknumber, Bank[i].bankname);
    fscanf(BLZ1, ""%d;%49[^\n]\n"", &amp;Bank[i].banknumber, Bank[i].bankname);
    //    Add &amp; here -------------^
</code></pre>

<p>Also:  Use 49 to limit the scanning to 49 characters, allowing those 49 and the <em>null character</em> to be saved in <code>char bankname[50];</code>  <a href=""https://stackoverflow.com/questions/54121909/reading-mixed-values-from-a-file-and-storing-them-in-a-structure-array/54122179#comment95075781_54121909"">@David C. Rankin</a></p>

<hr>

<p>Advanced issues:</p>

<p>Better code would test the return value from <code>fscanf()</code>, than use <code>feof()</code>.</p>

<pre><code>// while (!feof(BLZ1)){
while (fscanf(BLZ1, ""%d;%49[^\n]\n"" , &amp;Bank[i].banknumber , Bank[i].bankname) == 2) {
  printf(""%d , %s\n"" , Bank[i].banknumber , Bank[i].bankname);
  i++;
  if (i &gt;= size){
    size +=10;
    Bank = realloc(Bank , sizeof(Bankdata)*size);
  }
}
</code></pre>

<p>The final <code>""\n""</code> in <code>""%d;%49[^\n]\n""</code> is OK, but not needed here.</p>

<p>With <em>line</em> orientated data, best to read the <em>line</em> with <code>fgets()</code> and then parse it.  Much easier to cope with malformed input.</p>
",0
52094995,52094918,3,"<pre>
   while (fscanf(in, ""%6s%4s%3s%3s"", name, faculty, mark1, mark2) != EOF)
</pre>

<p>Remove <code>;</code> in the end.</p>
",1
51985465,51985176,2,"<p>You're almost there. I think you're just struggling with initial values for <code>sum</code> and <code>sum2</code>.</p>

<p>Leave <code>sum</code> for addition/subtraction (needs to be initialised to 0) and leave <code>sum2</code> for multiplication/division (needs to be initialised to 1.) </p>

<pre><code>float sum = 0;
float sum2 = 1.;
</code></pre>

<p>Then addition becomes</p>

<pre><code>sum += numbers[i]
</code></pre>

<p>subtraction becomes</p>

<pre><code>sum -= numbers[i]
</code></pre>

<p>multiplication becomes</p>

<pre><code>sum2 *= numbers[i]
</code></pre>

<p>and division becomes</p>

<pre><code>sum2 /= numbers[i]
</code></pre>

<p>And make sure you get your order right for <code>printf</code>, <code>scanf</code> and the maths operation.</p>
",0
54750725,54750524,3,"<p>In C (and many related programming languages), the curly braces often mean:</p>

<p><code>{</code> this is where the code starts<br>
<code>}</code> this is where the code ends</p>

<p>They can also have several different meanings though. They don't only refer to code, but also to data structures:</p>

<pre><code>struct point {
    int x;
    int y;
};
</code></pre>

<p>In this case they define where the data structure begins and ends.</p>

<pre><code>struct point pythagoras = {
    .x = 3,
    .y = 4
};
</code></pre>

<p>And in this case they define where the initial contents of the variable begins and ends.</p>

<p>In conclusion, the <code>{</code> means begin, and the <code>}</code> means end. Nothing more.</p>

<p>The ""code"" that initializes your <code>struct test</code> is not really code, although it really looks like it. Here it is again:</p>

<pre><code>struct test hello = (struct test) {
    .i = 0, 
    .t = 1
};
</code></pre>

<p>Usually, the <code>(type)</code> means a type cast. But, in this case the <code>(struct test)</code> is followed by an opening brace <code>{</code>, and this combination is called a <a href=""https://en.cppreference.com/w/c/language/compound_literal"" rel=""nofollow noreferrer"">compound literal</a>. It's a literal for a variable of a compound data type.</p>
",1
54750691,54750524,7,"<p><code>struct test hello = (struct test) { .i = 0, .t = 1 };</code> uses two features of C called <em>compound literals</em> and <em>designated initializers</em>.</p>

<p>The general form of a compound literal is: <code>(</code> <em>type-name</em> <code>)</code> <code>{</code> <em>initializer-list</em> <code>}</code>. (There may also be a comma after the list.) For example, these are compound literals:</p>

<pre><code>(int) { 3 }
(int []) { 0, 1, 2 }
(union { float f; unsigned int u; }) = { 3.4 }
</code></pre>

<p>A compound literal is an object with no name.</p>

<p>In a plain initializer list, you simply list values for the items in the object being initialized. However, you can also use designated initializers. A designated initializer uses either the name of a structure member or the index of an array element to specify which part of the object is to be given the indicated value:</p>

<pre><code>{ struct { int a, b, c; }) = { .b = 4, .c = 1, .a = 9 }
(int a[1024]) = { [473] = 1, [978] = -1 }
</code></pre>

<p>So, in <code>struct test hello = (struct test) { .i = 0,  .t = 1 };</code>, we are creating <code>struct test</code> with <code>i</code> initialized to 0, and <code>t</code> initialized to 1. Then this <code>struct test</code> is used to initialize another struct test named <code>hello</code>.</p>

<p>That particular use is pointless, since it creates a temporary object for the purpose of something that could have been done directly. Nominally, it creates a temporary <code>struct test</code> which is initialized and then copied into the <code>struct test hello</code>. Then the temporary <code>struct test</code> has no further use. The effect is the same as simply writing <code>struct test hello = { .i = 0, .t = 1};</code>. That initializes <code>hello</code> without using a temporary object. However, a good compiler will optimize them to the same code.</p>
",12
54164770,54164679,3,"<p>The <code>sum</code> and <code>count</code> variables aren't resetting after each iteration of the <code>do...while</code> loop because you don't explicitly do so.  You do set them to 0 at the start of the function where they're first defined, but you don't reset them again anyplace else.</p>

<p>You need to set both to 0 before entering the <code>do...while</code> loop:</p>

<pre><code>   for (i = 1; i &lt;= 4; ++i)
    {
        sum = 0;
        count = 0;
        do
        {
           ...
</code></pre>

<p>Even better, define <code>sum</code> and <code>count</code> at this point (as well as <code>avg</code> and <code>score</code>) since they're not used outside of the <code>for</code> loop:</p>

<pre><code>   for (i = 1; i &lt;= 4; ++i)
    {
        float sum = 0, count = 0, avg, score;
        do
        {
           ...
</code></pre>
",1
53022990,53022877,0,"<p>You need to assign a number to <code>number</code> before using it in the condition.</p>

<p>You have two options: a) use a dummy initial value, or b) scanf before test</p>

<pre><code>// a) dummy value
int number = 42;
while (number != 0) { /* ... */ }
</code></pre>

<p>or</p>

<pre><code>// b) scanf before test
int number; // uninitialized
do {
    if(scanf(""%i"", &amp;number) != 1) exit(EXIT_FAILURE);
} while (number != 0);
</code></pre>
",0
53023071,53022877,2,"<p>Hopefully it's not too late to bring my two cents to the party.</p>

<p>The solution which others suggest is definitely possible and working solution, however, I think it can be done in a slightly neater way. For cases like this, <code>do while</code> statement exists:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    int number; // Doesn't need to be initialized in this case
    do {
        printf(""Introduce a number: "");
        if (scanf(""%i"", &amp;number) != 1) { // If the value couldn't be read, end the loop
            number = 0;
        }
    } while (number != 0);

    return 0;
}
</code></pre>

<p>The reason I think this solution is better is just that it doesn't bring any other magic constants to the code, hence it should be better readable.</p>

<p>If someone saw <code>int number = 42;</code>, for example, he'd be asking - Why 42? Why is the initial value 42? Is this value used somewhere? The answer is: No, it is not, thus it's not necessary to have it there.</p>
",3
52131664,52131644,12,"<p>Using <code>getchar()</code> etc is efficient because the standard I/O library uses buffering to read many bytes at once (saving them in a buffer) and doles them out one at a time when you call <code>getchar()</code>.</p>

<p>Using <code>read()</code> to read a single byte at a time is much slower, typically, because it makes a full system call each time.  It still isn't catastrophically slow, but it is nowhere near as fast as reading 512, or 4096, bytes into a buffer.</p>

<p>Those are broad, sweeping statements.  There are many caveats that could be added, but they are a reasonable general outline of the performance of <code>getchar()</code>, etc.</p>
",0
54306038,54305799,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main()
{
  double x;
  unsigned n;

  fprintf(stderr, ""enter x and n :"");
  /* enter x as a double and x as an unsigned number, both on the same line, and check 2 values are enter */
  if (scanf(""%lg %u"", &amp;x, &amp;n) != 2)
    puts(""invalid or missing values"");
  else {
    double r = 0; /* sum initialization */
    int p = 1; /* the power to apply, 1 then 4 then 7 etc */

    while (n--) { /* have to sum n times */
      r += pow(x, p); /* x^1+x^4+x^7+... */
      p += 3; /* next power value */
    }

    printf(""%g\n"", r);
  }
  return 0;
}
</code></pre>

<p>if I well understand <em>n</em> terms <code>x^y</code> must be added rather than the last pow is <code>x^n</code>, I use double for <em>x</em> and of course the result ( <em>r</em> )</p>

<hr>

<p>Executions :</p>

<pre><code>enter x and n :1.2 3
6.85678

enter x and n :2 1
2
</code></pre>

<hr>

<p>Check with <em>bc</em> :</p>

<pre><code>% bc
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'. 
scale=6
1.2 + 1.2^4 + 1.2^7
6.856780
</code></pre>
",2
56330843,56330659,1,"<p><code>i &amp; i-1</code> turns off the lowest set bit in <code>i</code> (if there are any set). For example, consider <code>i</code>=200:</p>

<ul>
<li>200 in binary is 1100 1000. (The space is inserted for visual convenience.)</li>
<li>To subtract one, the zeros cause us to ¡°borrow¡± from the next position until we reach a one, producing 1100 0111. Note that, working from the right, all the zeros became ones, and the first one became a zero.</li>
<li>The <code>&amp;</code> produces the bits that are set in both operands. Since <code>i-1</code> changed all the bits up to the first one, those bits are clear in the <code>&amp;</code>¡ªnone of the changed bits are the same in both <code>i</code> and <code>i-1</code>, so none of them is a one in both. The other ones in <code>i</code>, above the lowest one bit, are the same in both <code>i</code> and <code>i-1</code>, so they remain ones in <code>i &amp; i-1</code>. The result of <code>i &amp; i-1</code> is 1100 0000.</li>
<li>1100 0000 is 1100 1000 with the lowest set bit turned off.</li>
</ul>

<p>Then the <code>% 3</code> is selecting which pole in Towers of Hanoi to use as the source. This is discussed in <a href=""https://stackoverflow.com/questions/2209860/how-does-this-work-weird-towers-of-hanoi-solution"">this question</a>.</p>

<p>Similarly <code>i | i-1</code> turns on all the low zeros in <code>i</code>, all the zeros up to the lowest one bit. Then <code>(i | i-1) + 1</code> adds one to that. The result is the same as adding one to the lowest one bit in <code>i</code>. That is, the result is <code>i + x</code>, where <code>x</code> is the lowest bit set in <code>i</code>. Using our example value:</p>

<ul>
<li><code>i</code> is 1100 1000 and <code>i-1</code> is 1100 0111.</li>
<li><code>i | i-1</code> is 1100 1111.</li>
<li><code>(i | i-1) + 1</code> is 1101 0000, which equals 1100 1000 + 0000 1000.</li>
</ul>

<p>And again, the <code>% 3</code> selects a pole.</p>
",1
54180673,54180135,3,"<p>One answer is <code>#define printf(...) puts(""1 1 1"")</code></p>

<p>The prove :</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{

#define printf(...) puts(""1 1 1\n"")
  printf (""% ld% ld% ld \ n"", lol, &amp; lol, * lol);

  return 0;
}
</code></pre>

<p>execution :</p>

<pre><code>1 1 1
</code></pre>

<p>as requested that prints out 3 identical numbers on stdout</p>
",2
54584327,54583759,1,"<p>To answer your question: yes, that is no problem at all. In terms of <em>what you can do</em> with a variable (in terms of assignment, addition, etc), C does not care whether the variable you use is local or global. A global variable will keep its value after the function returns. Here is an example:</p>

<pre><code>#include &lt;stdio.h&gt;

char * last_value = ""none"";  /* this is global */

void foo(int type)
{
    switch (type) {
        case 1:
            last_value = ""one"";
            break;
        default:
            last_value = ""other"";
            break;
    }
}

int main()
{

    printf(""last: %s\n"", last_value);

    foo(1);
    printf(""last: %s\n"", last_value);

    foo(39);
    printf(""last: %s\n"", last_value);

    return 0;
}
</code></pre>

<p>The output will be:</p>

<pre><code>last: none
last: one
last: other
</code></pre>
",1
56040485,56040278,2,"<p>In any normal multi-user operating system, the addresses in your process will be virtual addresses. This is because, in normal multi-user operating systems, the operating system uses virtual address spaces to keep programs independent of each other.</p>

<p>The address space of your program is set up in part by a process called the loader, which loads the initial data and code of your program into memory. A simple loader will start the stack of a new program at a fixed location¡ªit will use the same starting location every time it loads a program. Then, when your program runs, <code>a</code> will always be at the same address. Loaders operated this way for many years.</p>

<p>Because malicious people can sometimes take advantage of known stack addresses to attack and subvert software, some loaders now use random addresses when loading programs. This is called address space layout randomization (ASLR). When your program is loaded with a loader using ASLR, the address of <code>a</code> will vary from run to run.</p>
",0
54192466,54191907,0,"<blockquote>
  <p>if condition if I enter value more than 8 it'll bring garbage value to tot.</p>
</blockquote>

<p>This is as expected.  When <code>z &gt; 8</code>, code attempts to access outside <code>price[]</code> range.  Result: <em>undefined behavior</em> (UB).  The prior <code>if (z &lt; 1 || z &gt; 8)</code> did not steer code away from <code>price[z - 1]</code>.  Rest of code including <code>g_tot = p_tot + tot;</code> is now questionable.</p>

<pre><code>int price[8] = {180, 120, 65, 55, 70, 70, 110, 200};
...
if (z &lt; 1 || z &gt; 8) {
  printf(""Invalid food code\n"");
}

tot = tot + price[z - 1];  // UB here
...
g_tot = p_tot + tot;
</code></pre>

<p>Do not access <code>price[z - 1]</code> unless <code>z</code> in the range [1...8].</p>

<hr>

<p>Other problems exist:  Best to enable all compilers warnings and seem them (12+) yourself.</p>
",3
54309969,54308683,0,"<p>This very simplistic program shows how you could approach the problem:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;

// Read an integer value from the user
// returns false if input stream cannot be read (usually EOF)
// Any non digit characters are discarded:
// Examples:
// ""123abc"" =&gt; 123
// ""123.456"" =&gt; 123
// """" =&gt; 0
// ""abc"" =&gt; 0

bool ReadIntFromUser(int *value)
{
  char inputbuffer[100];

  if (fgets(inputbuffer, sizeof inputbuffer, stdin))
  {
    *value = (int)strtoul(inputbuffer, NULL, 10);
    return true;
  }
  else
    return false;
}


int main(void) {
  int x = - 1;

  while (ReadIntFromUser(&amp;x))
  {
    printf(""Input was %d\n"", x);
  }
}
</code></pre>

<p>Improving the <code>ReadIntFromUser</code> is left as an exercise to the reader.</p>
",0
52954993,52950508,1,"<p>Let's take a look at your loop:</p>

<pre><code>for(i=0;n&gt;=10;i++)
{
  v=n%10;
  m[i]=pow(v,x);
  z=z+m[i];
  y=y*10;
}
</code></pre>

<p>What's the value of <code>n</code> at this point?  You've set it in the previous call to <code>Num_amount</code> like so:</p>

<pre><code>while(n&gt;=10)
{
  amount++;
  n=n/10;
  if(n&lt;10)
    amount++;
}
</code></pre>

<p>So, after <code>Num_amount</code> has finished executing, <code>n</code> <em>must</em> be less than 10, meaning the loop in <code>Armstrong</code> won't execute.  </p>

<p>This is a big reason why you shouldn't use globals, even in a toy program like this.  If you use it for different purposes in different places, you just create headaches like this.  </p>

<p>At the very least, you should change your code such that <code>n</code> is passed as a parameter to <code>Num_amount</code> and <code>Armstrong</code>.  </p>
",0
53273230,53273197,4,"<p>You never actually opened the file:</p>

<pre><code>FILE *paid = (""paid.txt"", ""w"");
</code></pre>

<p>This evaluates <code>(""paid.txt"", ""w"")</code> as an expression, with the comma operator discarding the left operand ""paid.txt"" and evaluating the right operand ""w"", and then assigning that to <code>paid</code>.</p>

<p>You need to call <code>fopen</code> here:</p>

<pre><code>FILE *paid = fopen(""paid.txt"", ""w"");
</code></pre>
",2
53837591,53837105,2,"<p>This is a fun little problem.</p>

<p>I threw together a quick, simple solution:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int a, b;
    int d[10]={0};
    scanf(""%d %d"", &amp;a, &amp;b);

    while(a)
    {
        d[a%10] = 1;
        a /= 10;
    }

    while(b)
    {
        if (d[b%10]) d[b%10]=2;
        b /= 10;
    }

    for(a=0;a&lt;10;++a) if (d[a]==2) printf(""%d "", a);

    return 0;
}
</code></pre>

<p>Link to <a href=""https://ideone.com/iJwjsR"" rel=""nofollow noreferrer"">IDE One code</a></p>

<hr>

<p>Here's a short version that does not use arrays:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int a, b, c;
    scanf(""%d %d"", &amp;a, &amp;b);

    while(a)
    {
        c = b;
        while(c)
        {
            if (c%10 == a%10)
            {
                printf(""%d "", c%10);
                break;
            }
            c /= 10;
        }
        a /= 10;
    }

    return 0;
}
</code></pre>

<p>This version runs slower than my first one, and does not print out the numbers in ascending order.</p>
",3
53914647,53914562,3,"<p>The function <code>function</code> always returns the same value, namely a pointer pointing to the start of the static array <code>B</code>.</p>

<p>In the first code snippet, you call <code>funtion</code> three times as part of a call to <code>printf</code>.  When calling a function, each of its parameters must be evaluated before the function is called.  This means that <code>function</code> is called 3 times before <code>printf</code> is called, so <code>B</code> only contains the most recent value stored there.  This means you end up printing the same thing 3 times.  </p>

<p>Also, the order in which arguments to a function are evaluated is unspecified, so you don't which call to <code>function</code> will be last.  The value printed three times could be either 1, 2, or 3.</p>

<p>In the second snippet, since you only call <code>function</code> once in each <code>printf</code> call, there is no ambiguity regarding what will be printed.</p>
",2
52520860,52520653,1,"<p>I think it's because you don't have <code>_TASKING_C_TRICORE_</code> defined so it can't evaluate that expression.  Try something like this;</p>

<pre><code>#if defined (_TASKING_C_TRICORE_)
#if (_TASKING_C_TRICORE_ == 1U) //line 82

#ifndef IFX_INTERRUPT
#define IFX_INTERRUPT(isr, vectabNum, prio) \
                    void __interrupt(prio) __vector_table(vectabNum) isr(void)
#endif

#endif /* (_TASKING_C_TRICORE_ == 1U) */
#endif /* defined(_TASKING_C_TRICORE_) */
</code></pre>
",6
55846609,55846564,2,"<pre><code>for (i = 0; i &lt;= size; i++)
{
    for (j = i + 1; j &lt;= size; j++)
</code></pre>

<p>You should <em>almost certainly</em> use <code>&lt;</code> instead of <code>&lt;=</code> here. You¡¯re running over the array bounds and into undefined behaviour. You simply got incredibly lucky that your code worked before you changed the sort order.</p>
",1
52767274,52766539,0,"<h1>Preamble</h1>

<p>The function in the question, f(<em>x</em>) = (4-2<i>x</i>)/3 for <em>x</em> in [0, 1], is a <em>probability density function</em>, not a <em>cumulative distribution function</em>. If the distribution were drawn as a curve with unit area between the <em>x</em> axis and the curve, the probability density function is the slope of that curve, while the cumulative distribution function is the amount of area under the curve up to a certain <em>x</em>.</p>

<p>We can see (4-2<i>x</i>)/3 is not a cumulative distribution function because the cumulative distribution must be 1 at the end of the distribution (¡Þ in general, but 1 here since the function is zero beyond 1, but (4-2<i>x</i>)/3 is 2/3 at 1. We can see it is a probability density function because its integral (shown below) is 1 at the end of the distribution.</p>

<p>The <a href=""https://www.sanfoundry.com/c-program-generate-random-numbers-using-probability-distribution-function/"" rel=""nofollow noreferrer"">link given in the question</a> uses a cumulative distribution function. In fact, it is a cumulative distribution function for a uniform distribution over [0, 360]. Because of that, solving the necessary equation (see below) is merely a matter of scaling. This is trivial and does not serve as a general example for generating samples for an arbitrary distribution.</p>

<h1>Solution</h1>

<p>Given a probability density function, f(<em>x</em>), the corresponding cumulative distribution function, F(<em>x</em>), is the integral of f from ?¡Þ to <em>x</em>. We can use the cumulative distribution function to convert a uniform distribution to the desired distribution.</p>

<p>The integral of (4-2<i>x</i>)/3 is (4<i>x</i>?<em>x</em><sup>2</sup>)/3 (plus a constant). Since this is zero at <em>x</em>=0 and f(<em>x</em>) is zero for <em>x</em> &lt; 0, F(<em>x</em>) is also (4<i>x</i>?<em>x</em><sup>2</sup>)/3 in [0, 1].</p>

<p>If we have a sample <em>p</em> from a uniform distribution in [0, 1], the point <em>x</em> where the amount of the desired distribution at or below <em>x</em> equals the amount of the uniform distribution at or below <em>p</em> satisfies F(<em>x</em>) = <em>p</em>.</p>

<p>Thus (4<i>x</i>?<em>x</em><sup>2</sup>)/3 = <em>p</em>, so <em>x</em> = 2 + sqrt(4?3<i>p</i>).</p>

<p>Thus, given <em>p</em> generated with <code>p = (double) rand() / RAND_MAX</code>, we can find the sample for the desired distribution as <code>2 + sqrt(4-3*p)</code>.</p>
",0
52766778,52766539,1,"<p>First, you're not returning the range of random numbers you think you are:</p>

<pre><code>p = (double)(rand() % 100)/100;
</code></pre>

<p>The right hand size will give you a number in the range ( 0.00, 0.01, 0.02 ... 0.99 ).  But then you assign that value to <code>p</code>, which is of type <code>int</code>.  The fractional part is truncated, so the assigned value will always be 0.</p>

<p>Change the type of <code>p</code> to <code>double</code> to store the proper values.  Also, if you want a wider range of random values, use this instead:</p>

<pre><code>p = (double)rand() / RAND_MAX;
</code></pre>

<p>As for this:</p>

<pre><code>printf(""%f "", p * (4-2*0.1)/3);
</code></pre>

<p>Compared to the linked code:</p>

<pre><code>printf(""%f "", p * 0.1 / 360);
</code></pre>

<p>Their code isn't putting 0.1 in place of <code>x</code>.  <code>p</code> is the same as <code>x</code>, but for some reason they're adding the extra 0.1 factor.</p>

<p>For you to be doing <code>f(x) = (4-2x)/3</code>, you need this:</p>

<pre><code>printf(""%f "", (4-2*p)/3);
</code></pre>
",5
56446832,56445486,1,"<p><strong><code>float</code></strong> </p>

<p>There are 2 ways to <code>printf</code> a float and 1 way to <code>scanf</code> them.</p>

<pre><code>printf(""%f"",  my_float);
printf(""%lf"", my_float); // works fine but bad style

scanf(""%f"",  &amp;my_float);
</code></pre>

<p>(In the oldest C standard, <code>printf</code> didn't allow <code>%lf</code>)</p>

<hr>

<p><strong><code>float*</code></strong> </p>

<p>There is one way to <code>printf</code> the pointer itself: </p>

<pre><code>printf(""%p"", ptr);
</code></pre>

<p>It doesn't make sense to read a pointer with <code>scanf</code>, but you can read to the memory pointed-at by the pointer <code>ptr</code> as:</p>

<pre><code>scanf(""%f"",  ptr); // no &amp; needed, it is already a pointer
</code></pre>

<hr>

<p>Everything else from your examples doesn't make much sense. Printing an address is not printing a <code>float</code>. Applying various forms of arithmetic on the pointer such as <code>&amp;B[i]</code> versus <code>*(B+i)</code> have nothing whatsoever to do with the the printing. </p>
",1
56445661,56445486,9,"<p>Your understanding of which answers are correct are flawed.</p>

<p>To print a value of type <code>float</code> using <code>printf</code>, you need to use the <code>%f</code> format specifier and pass a value of type <code>float</code>.   To read a value of type <code>float</code> with <code>scanf</code>, you also use the <code>%f</code> format specifier but pass a value of type <code>float *</code>.</p>

<p>Regarding array indexing, the notation <code>A[N]</code> is exactly equivalent to <code>*(A + N)</code> and has the type of the array element, and <code>&amp;A[N]</code> is exactly equivalent to <code>A + N</code> and has type pointer to array element.</p>

<p>Based on that, we have the following:</p>

<pre><code>printf(""%f"",B[i]);    // Correct
printf(""%f"",&amp;B[i]);   // Incorrect, passing a float *, expected float
printf(""%f"",B+i);     // Incorrect, passing a float *, expected float (same as prior)
printf(""%p"",*(B+i));  // Incorrect, %p is used to print a pointer (expects a void *)
printf(""%f"",*(B+i));  // Correct

scanf(""%f"", B[i]);    // Incorrect, passing a float, expected float *
scanf(""%f"", B+i);     // Correct
scanf(""%p"", B+i);     // Incorrect, %p is used to read a pointer (expects a void *)
scanf(""%f"", &amp;B[i]);   // Correct
scanf(""%f"", *(B+i));  // Incorrect, passing a float, expected a float *
</code></pre>
",0
52783465,52783172,1,"<p>You have an outer loop using the variable <code>i</code> and an inner loop also using (and modifying) the same variable <code>i</code>. When the inner loop has completed I assume <code>i</code> is left greater than <code>t</code> so the outer loop also ends. This bug might have been easier to avoid if you had used more meaningful variable names.</p>

<p>Here is your code trimmed down to show the problem:</p>

<pre><code>for (i = 1; i &lt;= t; i++)
{
    for (i = 1; i &lt;= n; i++)
    {
    }
}
</code></pre>
",0
54471699,54471680,1,"<pre><code>ptr[i]=malloc(sizeof(ptr));
</code></pre>

<p>You're allocating the wrong size here. This should be</p>

<pre><code>ptr[i]=malloc(sizeof(*ptr[i]));
</code></pre>

<p>Or</p>

<pre><code>ptr[i]=malloc(sizeof(Hash));
</code></pre>

<p>Because of this, you're subsequently overrunning your buffer and invoking undefined behavior.</p>

<p>You should consider compiling your program with <code>-g</code> (to enable debug symbols), and running it under <code>valgrind</code>. Errors like this will be immediately identified. </p>
",0
53380715,53380456,1,"<pre><code> for (i=0;i &gt; gridsize;i++)
   for (j=0;j &gt; gridsize;j++)
     matrix[i][j] = getchar();
       putchar('.');
</code></pre>

<p>should be</p>

<pre><code> for (i=0;i &gt; gridsize;i++)
   for (j=0;j &gt; gridsize;j++)
   {
     matrix[i][j] = getchar();
     putchar('.');
   }
</code></pre>

<p>or even</p>

<pre><code> for (i=0;i &gt; gridsize;i++)
 {
   for (j=0;j &gt; gridsize;j++)
   {
     matrix[i][j] = getchar();
     putchar('.');
   }
 }
</code></pre>

<p>for more clarify and safety</p>
",0
55068891,55068486,0,"<p>For C89 and earlier, the array dimensions in an array declaration must be <em>constant expressions</em>, meaning they must be evaluable at compile time (numeric constants, <code>sizeof</code> expressions, expressions involving numeric constants and/or <code>sizeof</code> expressions, or macros that expand to any of the previous).  </p>

<p>C99 introduced ""variable-length arrays"", where array dimensions determined using runtime expressions (which places some restrictions on where VLAs may be used):</p>

<pre><code>int blocks = some_value();
int seg = some_other_value();

int memory[blocks][segs];
</code></pre>

<p>Unfortunately, Microsoft's Visual Studio implementation does not support variable-length arrays (or much else beyond C89).  </p>

<p>So, you have a choice - you can either use a different compiler that supports C99 or later (such as MinGW), or you will need to use dynamic memory allocation.  If you want to keep <code>BLOCKS</code> constant but <code>SEG</code> variable, you would need to do something like this:</p>

<pre><code>int *memory[BLOCKS];
int seg;
...
scanf( ""%d"", &amp;seg );
...
for ( int i = 0; i &lt; BLOCKS; i++ )
{
  memory[i] = malloc( sizeof *memory[i] * seg );
  if ( !memory[i] )
    // handle memory allocation failure
}
</code></pre>

<p>When you're done, you'll need to <code>free</code> that memory:</p>

<pre><code>for ( int i = 0; i &lt; BLOCKS; i++ )
  free( memory[i] );
</code></pre>

<p>The main drawback to this method is that the rows of the array won't be contiguous in memory - there will be a gap between <code>memory[i][seg-1]</code> and <code>memory[i+1][0]</code>.  If that matters, you may have to allocate memory as a single block, then fake 2D indexing:</p>

<pre><code>int *memory = malloc( sizeof *memory * BLOCKS * seg );
if ( !memory )
  // handle memory allocation failure
...
memory[i * BLOCKS + j] = some_value();
</code></pre>

<p><strong>EDIT</strong></p>

<p>Here¡¯s an (untested!) example based on the snippet in your question - you¡¯re trying to read a .csv file with a fixed number of rows (<code>BLOCKS</code>) and a variable number of columns (<code>SEG</code>):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define BLOCKS 20

int *memory[BLOCKS];

int main( void )
{
  int seg;
  FILE *stream = fopen( ¡°file.csv¡±, ¡°r¡± );
  if ( !stream )
    // print error and exit

  printf( ¡°Please enter a number: ¡°);
  if ( scanf( ¡°%d¡±, &amp;seg ) != 1 )
    // print error and exit

  for ( size_t b = 0; b &lt; BLOCKS; b++ )
  {
    /**
     * Allocate memory for a block (row)
     */
    memory[b] = malloc( sizeof *b * seg );
    if ( !memory[b] )
      // print error and exit

    /**
     * Read that row from the file - since it has 
     * a .csv extension, I am assuming it is
     * comma-delimited.  Note that malloc is not
     * required to initialize memory to any specific
     * value - the initial value of each memory[b][s]
     * is indeterminate.
     */
    for ( size_t s; s &lt; seg; s++ )
      if ( fscanf( stream, ¡°%d%*c¡±, &amp;memory[b][s] )) != 1 )
        // print error and exit
  }
  fclose( stream );

  /**
   * Do stuff with memory here
   */

  /**
   * After you¡¯re done with memory, free it
   */
  for ( size_t b = 0; b &lt; BLOCKS; b++ )
    free( memory[b] );

  return EXIT_SUCCESS;
}
</code></pre>
",4
55068691,55068486,0,"<p>A <code>#define</code> preprocessor directive's value must be known at compile time, and cannot wait for runtime.  Likewise, declaring an array is usually something to be known at compile time.</p>

<p>What you need to do is malloc some memory.  (Remember to free it when you are done.)  Then address the memory as a two dimensional array.</p>

<pre><code>int *memory = (int *)malloc(BLOCKS * input * sizeof(int))
</code></pre>

<p>You can address block 2, seg 3 as</p>

<pre><code>memory[ 3 * BLOCKS + 2]
</code></pre>

<p>or</p>

<pre><code>memory[ seg * BLOCKS + block]
</code></pre>

<p>Alternatively, if you want to use the two dimensional array notation, and you are not fussy about what order to have the dimensions in, you can declare a pointer to an array,</p>

<pre><code>typedef int (*memseg_t)[BLOCKS];
memseg_t memory = (memseg_t)malloc(BLOCKS * input * sizeof(int));
</code></pre>

<p>referenced by:</p>

<pre><code>memory[seg][block]
</code></pre>
",0
52670522,52670263,1,"<blockquote>
  <p>I solved a problem getting correct output on my PC but online judge is directly saying wrong answer.</p>
</blockquote>

<p>Insufficient testing.  Code is correct when <code>t ==1</code>, yet not for <code>t &gt; 1</code>.</p>

<hr>

<p>Code needs to reset the minimum for each test case.</p>

<pre><code>// int min=INT_MAX;
scanf(""%d"",&amp;t);
while(t&gt;0){
  int min = INT_MAX; // add
</code></pre>

<hr>

<p>Other short-comings exists too, yet the above is key.<br>
Robust code would: </p>

<ol>
<li><p>Check the return value of <code>scanf()</code></p></li>
<li><p>Check that <code>malloc()</code> succeeded and then later free it.</p></li>
<li><p>Address potential; overflow in <code>abs(s[i]-s[j])</code></p></li>
</ol>

<p>Also</p>

<ol start=""4"">
<li><p>Consider delaying variable declaration to the block that needs it.  Had OP done this, the above problem would not have occurred.</p></li>
<li><p>Format code more uniformly and use <code>{}</code> even with single line blocks with <code>for, if, ...</code>.</p></li>
</ol>

<p>Efficiency</p>

<p>Sort the array first (<code>qsort()</code>) and then walk the array noting difference between elements.  O(n*lg(n))</p>
",0
55350118,55349646,1,"<p>My refactoring...</p>

<p>Changes made:</p>

<ul>
<li><p>made <code>MergeList</code> return the list, so the caller can do things like <code>resultList = MergeList(...</code> to make it a lot more obvious what was effected.</p></li>
<li><p>changed variable names so they're more descriptive</p></li>
<li><p>added ""space before left brace"" everywhere</p></li>
<li><p>added ""space after comma"" everywhere</p></li>
<li><p>added ""space around operators"" everywhere</p></li>
<li><p>replaced pointer calculations with array lookups (see Jeremy Friesner's comment)</p></li>
<li><p>replaced excessively complex <code>for()</code> shenanigans (use of comma, empty pieces) with simpler/easier to read loops</p></li>
<li><p>added documentation (before start of function)</p></li>
<li><p>added comments in function</p></li>
<li><p>added <code>const</code> to source lists</p></li>
</ul>

<p>Code:</p>

<pre><code>// Construct a new list sorted by descending order of ""elem"" by merging data from
// two existing lists that are already sorted by descending order of ""elem"".
//
// WARNINGS:
//   If both source lists are not sorted the resulting list will not be sorted.
//   Caller MUST ensure that enough memory is allocate for the resulting list before calling this function.

sqList *MergeList(const sqList list_a, const sqList list_b, sqList *result_list) {
  int j, k, n = 0;

  // Do entries from both source lists until there's nothing left in at least one of the source lists

  j = list_a.length - 1;
  k = list_b.length - 1;
  while(j &gt;= 0 &amp;&amp; k &gt;= 0) {
    if (list_a.elem[j] &gt; list_b.elem[k]) {
      result_list-&gt;elem[n] = list_a.elem[j];
      j--;
    } else if(list_a.elem[j] &lt; list_b.elem[k]) {
      result_list-&gt;elem[n] = list_a.elem[k];
      k--;
    } else {
      result_list-&gt;elem[n] = list_a.elem[j];
      j--;
      k--;
    }
    n++;
    result_list-&gt;length++;
  } 

  // If all entries in list_a haven't been consumed, copy the remaining entries to the result list

  while(j &gt;= 0) {
    result_list-&gt;elem[n] = list_a.elem[j];
    result_list-&gt;length++;
    j--;
  }

  // If all entries in list_b haven't been consumped, copy the remaining entries to the result list

  while (k &gt;= 0) {
    result_list-&gt;elem[n] = list_b.elem[k];
    result_list-&gt;length++;
    k--;
  }

  return result_list;
}
</code></pre>
",13
55672558,55672469,2,"<p>Here's a modified version of your code to print out the floating point value in IEEE-754 format as its stored in memory.  Notice the quick and dirty test for big-endian vs little-endian, and that influences how we print:</p>

<pre><code>int main()
{
    unsigned int test = 0x01020304;
    int isBigEndian = (1 == *(char*)&amp;test);
    float num = 3.14;

    // breaking the rules here, but this will work for demonstration purposes
    unsigned char* ptr = (unsigned char*)&amp;num

    // we're assuming sizeof(float) == 4
    if (isBigEndian)
        printf(""0x%02x%02x%02x%02x\n"", ptr[0], ptr[1], ptr[2], ptr[3]);
    else
        printf(""0x%02x%02x%02x%02x\n"", ptr[3], ptr[2], ptr[1], ptr[0]);

    return 0;

}
</code></pre>
",3
52727560,52727509,4,"<p>The product is actually of <code>int</code> type. You should explicitly convert it to long type by suffixing all the multipliers by <code>LL</code>.</p>

<pre><code>9 * 9 .. =&gt; is of type int
9LL * 9LL .. =&gt; is of type long long
</code></pre>
",6
52802163,52802115,1,"<blockquote>
  <p>why does it ask him the question two times when he enters y</p>
</blockquote>

<p>The enter key the user hits is taken as another character (a new-line: <code>\n</code>)  as well.</p>
",2
53642886,53642787,0,"<p>You can use pointers ?</p>

<pre><code>int *arrop[3]; 
</code></pre>

<p>example </p>

<pre><code>int *arrop[3];
    int a = 10, b = 20, c = 50, i;

    arrop[0] = &amp;a;
    arrop[1] = &amp;b;
    arrop[2] = &amp;c;

    for(i = 0; i &lt; 3; i++)
    {
        printf(""Current = %d\t Value = %d\n"", arrop[i], *arrop[i]);
    }
</code></pre>
",0
57914579,57914548,6,"<p>It's not equal: you forgot the terminating zero. It's present in ""JKW"", but not in the array initializer. As for why it prints ""JKW"" twice? By not zero-terminating the string, you've stumbled on undefined behavior. Your code can do pretty much anything at that point.</p>
",1
54056967,54056942,4,"<p>The second clause of the loop will evaluate to the value of the assignment and then use this value to determine whether to continue looping, so both loops will copy <code>s2</code> to <code>s1</code> until <code>*s1 == 0</code>. If <code>s1</code> and <code>s2</code> are the same type of pointer, then this occurs when <code>*s2 == 0</code>. If they are not the same type, then this is tricky code that is quite possibly incorrect.</p>

<p>The second loop contains an entirely redundant body, since it just repeats what the second clause of the loop does already.</p>
",0
54057141,54056942,1,"<p>If <code>s1</code> and <code>s2</code> are of type <code>char*</code>, then the code implements a <code>strcpy</code>. The end-condition of a <code>strcpy</code> is ""stop after having assigned the <code>'\0'</code>-string termination character. </p>

<p>So a third version would be...</p>

<pre><code>for ( ; ; s1++, s2++ ) {
   *s1=*s2;
   if (!*s1) {
      break;
   }
} 
</code></pre>

<p>Now let's dive into the meaning of an assignment like <code>*s1 = *s2</code>, which does actually two things: (1) it assigns <code>*s2</code> to <code>*s1</code>, and (2) the expression result is the value of <code>*s1</code> <em>after</em> the assignment;</p>

<p>In <code>for ( ; *s1 = *s2; s1++, s2++ ) { ;}</code>, where <code>*s1 = *s2</code> is used in the loop-end-condition, two things happen (1) the assignment and (2) the check if <code>'\0'</code> got assigned (in which case the loop ends).</p>

<p>In <code>for ( ; *s1 = *s2; s1++, s2++ ) {*s1=*s2;}</code>, the loop's body is simply superfluous; the assignment has already taken place when evaluating the ""condition"".</p>

<p>BTW: you could also write it as <code>while((*s1++=*s2++));</code>...</p>
",0
54056975,54056942,0,"<p>Did you mean to use == in the loop condition? Regardless,</p>

<p>Right now it performs an assignment - the result of the expression is the assigned value and is ¡°true¡± until the value is 0.</p>

<p>Since the assignment is done in the loop condition, at the top of each loop, the assignment inside the loop is redundant as the same assignment has already occurred before the loop body executes.</p>
",2
52689495,52689358,1,"<p>your Code is fine its just your break condition. should be something like:</p>

<pre><code>while (divisor != 0){
    if(dividend % divisor == 0)
        break;
    else divisor++;
}
</code></pre>
",1
54597828,54597612,1,"<p>In typical C implementations, changing <code>float</code> to <code>double</code> and <code>scanf(""%f"", &amp;num1);</code> to <code>scanf(""%lf"", &amp;num1);</code> will provide sufficient precision to get the desired output in this case.</p>

<p>In general, you should expect small rounding errors in floating-point operations (which may grow to large errors with complicated sequences of numerous operations).</p>
",1
52900905,52900827,0,"<p>Obvious error -- you're not ignoring whitespace (like newlines) in your scanf calls, so you're code will get confused and thrown off by them.  You want to put spaces before the <code>%c</code> directive in your format strings to ignore whitespace:</p>

<pre><code>scanf("" %c"", &amp;choice);
</code></pre>

<p>and</p>

<pre><code>scanf("" %c %c"", &amp;pt1, &amp;pt2);
</code></pre>
",0
54500136,54500127,0,"<p>The way you are attempting right now is not going to work since <code>buffer</code> is on the stack for that function and no longer exists once the function returns.</p>

<p>If you want to return an array from a function, you can either declare it to be <code>static</code>, so it goes in the process¡¯ data section rather than on the stack, or allocate it with <code>malloc(100)</code>, and later <code>free</code> it in the calling code when you¡¯re done with it.</p>
",0
54501249,54501095,1,"<p>To complement @jxh's comment, let's say your array has 6 elements.</p>

<p>When you want to insert one element at the beginning (index 0), you need to move <strong>five</strong> elements upwards, not six.</p>

<pre><code>// assuming `int a[6];`
a[5] = a[4]; // move
a[4] = a[3]; // just
a[3] = a[2]; // five
a[2] = a[1]; // items
a[1] = a[0];
a[0] = 42; // new value
</code></pre>

<p>Of course you can do this with <code>memmove()</code></p>

<pre><code>memmove(a + 1, a, 5 * sizeof *a); // move just five items
a[0] = 42; // new value
</code></pre>
",2
54383482,54383467,1,"<p>Only the <code>main</code> function runs by itself. To run another function, you have to call it.</p>

<p>For example:</p>

<pre><code>void not_main() {

}

int main() {
   not_main();
   return 0;
}
</code></pre>
",2
54742037,54737814,1,"<p>The infinite loop in your input function seems to be designed to skip over white space before you try reading a number with <code>scanf(""%lf"", &amp;coeff[i])</code>.  That's moderately pointless ¡ª the numeric formats all skip leading white space, including newlines, automatically.  Only three format specifiers do not skip white space; they are <code>%c</code>, <code>%[¡­]</code> (scan sets) and <code>%n</code>.</p>

<p>You probably need to capture the return value from <code>scanf()</code> so that you can distinguish between EOF and bogus inputs:</p>

<pre><code>int rc;
int i = 0;
while (i &lt; capacity &amp;&amp; (rc = scanf(""%lf"", &amp;coeff[i])) == 1)
    i++;

if (i == capacity)
{
    /* Too many values; remainder ignored */
}
else if (rc == 0)
{
    /* Report format error */
}
else if (rc == EOF &amp;&amp; i &lt; 4)
{
    /* Insufficient valid data */
    /* Needed x-min, x-max, coeff[0] (constant term) and coeff[1] (linear term */
}
return i;
</code></pre>

<p>The <code>evaluate()</code> function evaluates the polynomial at a given value of <em>x</em>.  The best process is known as <a href=""https://en.wikipedia.org/wiki/Horner%27s_method"" rel=""nofollow noreferrer"">Horner's Rule</a> or Horner's Method.  Given the input format with the constant term read before the <em>x</em> term and the <em>x</em>2 term, you need to work backwards from the highest coefficient.</p>

<pre><code>double evaluate(double x, int terms, double coeff[])
{
    double r = coeff[terms - 1];
    int i = terms - 1;
    while (i &gt; 0)
        r = (r * x) + coeff[--i];
    return r;
}
</code></pre>

<p>The function calling the <code>evaluate()</code> function needs arguments:</p>

<pre><code>x_min   ¡ª starting value
x_max   ¡ª ending value
x_steps ¡ª number of values to print (101 in this case)
n_coeff ¡ª number of coefficients
coeff   ¡ª the array of coefficients
</code></pre>

<p>It could become:</p>

<pre><code>static void print_values(double x_min, double x_max, int x_steps, int n_coeff, double coeff[n_coeff])
{
    const char *pad = """";
    for (int i = 0; i &lt; x_steps; i++)
    {
        double x = (x_max - x_min) * i / (x_steps - 1) + x_min;
        double r = evaluate(x, n_coeff, coeff);
        printf(""%s%3d: P(%5.3f) = %10.6f"", pad, i, x, r);
        if (i % 3 == 2)
            pad = ""\n"";
        else
            pad = ""; "";
    }
    putchar('\n');
}
</code></pre>

<p>And the <code>main()</code> function could become:</p>

<pre><code>enum { MAX_COEFF = 10 };

int main(void)
{
    double coeff[MAX_COEFF];

    int n_coeff = readPoly(MAX_COEFF, coeff);
    double x_min = coeff[0];
    double x_max = coeff[1];
    int n_values = 101;
    print_values(x_min, x_max, n_values, n_coeff - 2, &amp;coeff[2]);
    return 0;
}
</code></pre>

<p>And, for the given data:</p>

<pre class=""lang-none prettyprint-override""><code>0.0 6.0
25.00 -47.50 25.17 -5.00 0.33
</code></pre>

<p>the generated output is:</p>

<pre class=""lang-none prettyprint-override""><code>  0: P(0.000) =  25.000000;   1: P(0.060) =  22.239536;   2: P(0.120) =  19.653876
  3: P(0.180) =  17.236694;   4: P(0.240) =  14.981767;   5: P(0.300) =  12.882973
  6: P(0.360) =  10.934295;   7: P(0.420) =   9.129817;   8: P(0.480) =   7.463726
  9: P(0.540) =   5.930312;  10: P(0.600) =   4.523968;  11: P(0.660) =   3.239189
 12: P(0.720) =   2.070572;  13: P(0.780) =   1.012818;  14: P(0.840) =   0.060730
 15: P(0.900) =  -0.790787;  16: P(0.960) =  -1.546724;  17: P(1.020) =  -2.211969
 18: P(1.080) =  -2.791311;  19: P(1.140) =  -3.289431;  20: P(1.200) =  -3.710912
 21: P(1.260) =  -4.060232;  22: P(1.320) =  -4.341766;  23: P(1.380) =  -4.559788
 24: P(1.440) =  -4.718468;  25: P(1.500) =  -4.821875;  26: P(1.560) =  -4.873973
 27: P(1.620) =  -4.878625;  28: P(1.680) =  -4.839591;  29: P(1.740) =  -4.760529
 30: P(1.800) =  -4.644992;  31: P(1.860) =  -4.496433;  32: P(1.920) =  -4.318202
 33: P(1.980) =  -4.113545;  34: P(2.040) =  -3.885606;  35: P(2.100) =  -3.637427
 36: P(2.160) =  -3.371946;  37: P(2.220) =  -3.092000;  38: P(2.280) =  -2.800322
 39: P(2.340) =  -2.499544;  40: P(2.400) =  -2.192192;  41: P(2.460) =  -1.880693
 42: P(2.520) =  -1.567371;  43: P(2.580) =  -1.254444;  44: P(2.640) =  -0.944031
 45: P(2.700) =  -0.638147;  46: P(2.760) =  -0.338704;  47: P(2.820) =  -0.047512
 48: P(2.880) =   0.233722;  49: P(2.940) =   0.503393;  50: P(3.000) =   0.760000
 51: P(3.060) =   1.002144;  52: P(3.120) =   1.228527;  53: P(3.180) =   1.437957
 54: P(3.240) =   1.629342;  55: P(3.300) =   1.801693;  56: P(3.360) =   1.954124
 57: P(3.420) =   2.085853;  58: P(3.480) =   2.196198;  59: P(3.540) =   2.284582
 60: P(3.600) =   2.350528;  61: P(3.660) =   2.393665;  62: P(3.720) =   2.413722
 63: P(3.780) =   2.410532;  64: P(3.840) =   2.384029;  65: P(3.900) =   2.334253
 66: P(3.960) =   2.261343;  67: P(4.020) =   2.165542;  68: P(4.080) =   2.047197
 69: P(4.140) =   1.906755;  70: P(4.200) =   1.744768;  71: P(4.260) =   1.561889
 72: P(4.320) =   1.358875;  73: P(4.380) =   1.136585;  74: P(4.440) =   0.895980
 75: P(4.500) =   0.638125;  76: P(4.560) =   0.364186;  77: P(4.620) =   0.075434
 78: P(4.680) =  -0.226760;  79: P(4.740) =  -0.540922;  80: P(4.800) =  -0.865472
 81: P(4.860) =  -1.198732;  82: P(4.920) =  -1.538918;  83: P(4.980) =  -1.884145
 84: P(5.040) =  -2.232425;  85: P(5.100) =  -2.581667;  86: P(5.160) =  -2.929678
 87: P(5.220) =  -3.274162;  88: P(5.280) =  -3.612720;  89: P(5.340) =  -3.942852
 90: P(5.400) =  -4.261952;  91: P(5.460) =  -4.567315;  92: P(5.520) =  -4.856131
 93: P(5.580) =  -5.125488;  94: P(5.640) =  -5.372373;  95: P(5.700) =  -5.593667
 96: P(5.760) =  -5.786151;  97: P(5.820) =  -5.946503;  98: P(5.880) =  -6.071297
 99: P(5.940) =  -6.157006; 100: P(6.000) =  -6.200000
</code></pre>

<p>The code doesn't print the polynomial for validation; it should.  Clearly, the output when <code>x</code> is 0 should be <code>25</code> and it is, which gives some reassurance.  In the limit, the 0.33x^4 term should dominate, so the result tends towards infinity as x increases towards infinity.  The final 0 of the polynomial given is at an <code>x</code> value just less than 7.</p>
",2
56537887,56537819,3,"<ul>
<li>Call <code>srand</code> once somewhere in the beginning of your program.</li>
<li>Store all possible values of the enum in an array with size <code>n</code>.</li>
<li>Call <code>rand(n)</code> and use the result as array index, to return the value stored there.</li>
</ul>
",6
55149507,55147956,1,"<p>You have an array of strings in <code>argv</code> that looks like this:</p>

<pre><code>{ ""./cnp"", ""cut"", ""13"", ""5"", ""copy"", ""33"", ""7"", ""paste"", ""1"", ""input-b.txt"", ""output.txt"" }
</code></pre>

<p>On the assumption that the last two arguments are always the input and output files, I would loop through the arguments from 1 to <code>arc - 3</code> to process the commands e.g. the below sketch is not a complete solution but should give you some ideas.</p>

<pre><code>if (argc &lt; 3) 
{
    // Handle the fact that there were not enough arguments.
}
else 
{
    int commandArgs = argc - 2;
    for (int i = 1 ; i &lt; commandArgs ; ++i) // Start at 1 to omit program name
    {
        if (strcmp(argv[i], ""cut"") == 0) 
        {
            if (commandArgs - i &lt; 2)
            {
                // Handle not enough args to cut
            }
            else 
            {
                // You have a cut command, call cut or save it to call cut later       
                i += 2; // Skip the two parameters 
            }
        }
        else if (strcmp(argv[i], ""copy"") == 0)
        {
            // similar pattern to above
        }
        else if (strcmp(argv[i], ""paste"") == 0)
        {
            // similar pattern to above
        }  
        else 
        {
            // Handle invalid command error
        }          
    }
}
</code></pre>
",0
52762627,52762376,1,"<p>You're returning the address of a local variable.</p>

<p><code>mat1</code> contains pointers to element of <code>mat</code>.  When <code>matrica1</code> returns, <code>mat</code> goes out of scope, so pointers to its elements no longer point to valid memory.  Dereferencing these pointers invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>Other problems:</p>

<ul>
<li>The memory you're assigning to <code>mat1</code> is not the right size.  Because it is an array of <code>int *</code>, you should be allocating <code>size*sizeof(int *)</code> bytes, not <code>size*sizeof(int)</code> bytes.</li>
<li><code>matrica1</code> is defined to return a <code>int *</code> but you're returning an <code>int **</code> and assigning the result to an <code>int **</code>.  The return type of the function must match what you're returning.</li>
</ul>

<p>Rather than having <code>mat1</code> be an array of <code>int *</code>, make it an array of <code>int</code> and copy the <em>values</em> of <code>mat</code> rather than the <em>addresses</em>:</p>

<pre><code>#include &lt;stdio.h&gt;
int *matrica1(int n);

int main(){
    int n;
    printf(""Unesite dimenziju matrice:"");
    scanf(""%d"", &amp;n);

    // Have p match return type of function
    int *p = matrica1(n);


    printf(""Matrix \n\n"");

    int i;
    n = n*n;
    for(i=0; i&lt;n; i++){
        // print array elements
        printf("" %d "", *(p+i));
    }
    return 0;
}

int *matrica1(int n){
    int mat[n][n];
    int i, j;
    int k=0;
    for(i=0; i&lt;n; i++){
        for(j=0; j&lt;n; j++){
            mat[i][j] = j+k;
        }
        k++;
    }

    int size = n*n;
    // change type of mat1 from int ** to int *, keep size the same
    int *mat1 = malloc(size*sizeof(int));

    int m = 0;
    for(i=0; i&lt;n; i++){
        for(j=0; j&lt;n; j++){
            // assign values of mat instead of addresses
            mat1[m] = mat[i][j];
            m++;
        }
    }
    printf(""\n\n*mat1 = %d"", *mat1);

    return mat1;
}
</code></pre>

<p>Output:</p>

<pre class=""lang-none prettyprint-override""><code>Unesite dimenziju matrice:5


*mat1 = 0Matrix 

 0  1  2  3  4  1  2  3  4  5  2  3  4  5  6  3  4  5  6  7  4  5  6  7  8
</code></pre>
",3
57032714,57032701,5,"<p><code>printf</code> format string <code>%.*s</code> takes two arguments, <code>*</code> for the number and finally <code>s</code> for a string, so it prints the first 7 characters of the string pointer <code>s</code>. In general, anytime there is a number, you may use <code>*</code> instead to read it as an argument.</p>

<p><code>%7s</code> would print seven characters or more if the string were longer, while <code>%.7s</code> would print up to seven characters. So sometimes one would write <code>""%*.*s"", 7, 7, s</code> to print exactly 7 characters.</p>
",0
54566931,54566812,0,"<p>You're building your results into uninitialized string arrays:</p>

<pre><code>char result[200];
</code></pre>

<p>...</p>

<pre><code>strcat(result, ...);
</code></pre>

<p>Uninitialized variables may have any content in them. You can add a null character as a first character right after declaring the variable:</p>

<pre><code>char result[200];
result[0] = '\0';
</code></pre>

<p>this way the first character will be a string terminator and string functions will work as expected.</p>
",1
56486847,56486816,5,"<pre><code>if(n==sum){
</code></pre>

<p>What is <code>n</code>? You initialize it to <code>999*999</code> at the top of the program and then never change it again. Perhaps you mean <code>i</code>?</p>

<pre><code>if(i==sum){
</code></pre>

<p>Now the program prints <code>997799</code>, a proper palindrome.</p>

<hr>

<p>Note, though, that there's no check that <code>sum</code> is the product of two three-digit numbers. Your current approach of starting at a high number and decrementing <code>i</code> by 1 each iteration won't really work. You really need two variables and two loops to iterate over the two three-digit numbers.</p>

<p>But two loops will make it noticeably more difficult to find the <em>largest</em> palindrome. Oh dear.</p>

<pre><code>for (int a = 100; a &lt;= 999; a++) {
    for (int b = 100; b &lt;= 999; b++) {
        int n = a * b;

        // n is the product of two three digit numbers.
        // check: is it a palindrome?
        // check: is it the *largest* palindrome?
    }
}
</code></pre>
",2
54566939,54566920,1,"<p><strong>C</strong> <code>for loop</code> structure:</p>

<pre><code>for ( init; condition; increment )
</code></pre>

<p>You have actually added <code>i++</code> in the place of condition and <code>i&lt;100</code> in the place of increment.</p>

<p>Flow Control of <code>for loop</code> in C:</p>

<ul>
<li>init step is executed first and only once. </li>
<li>Condition is evaluated next and if it is True, the body of the loop is executed. If False, the body of the loop doesn't execute and the flow jumps to the next statement after the for loop.</li>
<li>After the body of the loop executes once, the flow control jumps to increment statement and then condition is evaluated again.</li>
<li>Body of loop, Condition and increment steps are repeated in the same order till the condition becomes False after which the for loop terminates.</li>
</ul>

<p>Your loop is:</p>

<pre><code>for(int i = 0;i++;i&lt;100)
</code></pre>

<p>In this, you have <code>i++</code> as the condition. Now, in this <code>i</code> is evaluated first followed <code>++</code>. Since, <code>i is 0</code>, it leads to the loop exiting as the condition evaluates to <code>False</code>. But, if you change <code>i to 1</code>, the condition (i.e. i) evaluates to <code>True</code> and it enters the loop.</p>

<p>If you have not done this deliberately, you need the loop like below:</p>

<pre><code>for (int i = 0; i &lt; 100; i++)
</code></pre>
",0
52823674,52823633,1,"<p>Your parameters are in the wrong place.  Your function</p>

<pre><code>float amount_charged (char vehicle_type,int total_hour_parked)
</code></pre>

<p>but when you print it out</p>

<pre><code>printf(""Cost %f"",amount_charged(total_hour_parked(hour_in,hour_left),vehicle_type));
</code></pre>
",2
54597797,54597606,3,"<p>Whatever tutorial this is, throw it out.</p>

<p>First, you need to check whether your file operations succeeded, otherwise the program will blindly continue along. Likely the <code>fopen</code> failed. It returns <code>NULL</code> on failure so you can check for that and get an error message with <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_perror.htm"" rel=""nofollow noreferrer""><code>perror</code></a>.</p>

<pre><code>FILE *x = fopen(""cisla.txt"",""r"");
if( x == NULL ) {
    perror(""Could not open the file"");
    exit(1);
}
</code></pre>

<p>Then, as others have mentioned, <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">you don't check for end of file</a>. Instead do the IO operation and check whether it succeeded or failed. In this case, <code>fscanf</code> returns the number of matched items which should be 1.</p>

<pre><code>while ( fscanf(x, ""%d"", &amp;i) == 1 ) {
    printf(""%d"",i);
}
</code></pre>

<p>Note that <a href=""http://c-faq.com/stdio/scanfprobs.html"" rel=""nofollow noreferrer"">the <code>scanf</code> family is fraught with gotchas</a>. But you'll get to them later.</p>

<p>Finally, that <code>UNUSED</code> stuff is very clever and totally unnecessary. Just declare <code>main</code> with no arguments. <a href=""https://stackoverflow.com/questions/12146594/definition-of-main-in-c"">This is perfectly valid</a>.</p>

<pre><code>int main() {
</code></pre>
",7
55152594,55152550,0,"<p><code>operandTop</code> is a pointer variable of type <code>int*</code>. You initialize it to <code>0</code> (a null pointer) and never assign a different value to it. Any attempt to dereference it will cause undefined behavior, likely a segmentation fault.</p>

<p>I ran your program under a debugger with no command-line arguments, and it died on line 61, <code>while (*operandTop != 0){</code></p>
",0
58846536,58846489,1,"<p>Neither points to anything in the example you've given. This code is just the declaration of the structure type itself. You could break the typedefs out into maybe simpler form:</p>

<pre><code>struct StackElement
{
    int value;
    struct StackElement *next;
};

typedef struct StackElement StackElement;
typedef struct StackElement *Stack;
</code></pre>

<p>That is, there is a declaration of the structure itself, which contains a field <code>next</code> to be used by the implementation code of this stack. That field, when filled in, will point to another <code>struct StackElement</code> structure.</p>

<p>The <code>typedef</code> parts just make convenience names - <code>StackElement</code> can be used in place of <code>struct StackElement</code>, and <code>Stack</code> can be used instead of <code>struct StackElement *</code>.</p>
",1
54786824,54754704,1,"<p>There are several problems with using macros the way you are.  The idea behind macros is to make coding simpler however because there are no type checks it's fraught with peril:</p>

<h2>Problem - No type checks:</h2>

<pre><code>#include &lt;stdio.h&gt;

#define max(a,b)  ((a) &gt; (b) ? (a):(b))
int main()
{
    int a = -1;
    unsigned int b = 2;
    printf(""The max is: %d\n"", max(a,b));

    return 0;
}
</code></pre>

<p>Output is rather undefined. gcc outputs <code>-1</code></p>

<h2>Problem - Double evaluation</h2>

<p>Double evaluation happens when your macro parameters are NOT simple variables, for instance:</p>

<pre><code>#include &lt;stdio.h&gt;

#define max(a,b)  ((a) &gt; (b) ? (a):(b))

int main() {
     int a = 1, b = 2;
     printf(""max(%d, %d) = %d\n"", a, b, max(a, b));
     printf(""max(%d, %d) = %d\n"", a, b, max(a++, b++));
     printf(""max(%d, %d) = %d\n"", a, b, max(a, b));
     return 0;
 }
</code></pre>

<p>If you are looking at the <code>mid(a,b,c)</code> that's even worse.</p>

<h2>Conclusion</h2>

<p>Please don't write code like this.</p>

<p>If you are sticking to a compiler where there is no <em>non-standard</em> <code>typeof</code> operator, then it's better to use stdtypes.h and stdint.h and declare functions:</p>

<pre><code>#define __declare_min(__type) __inline__ static __type min_ ## __type(__type a, __type b) { return a &lt; b ? a : b;  } 

__declare_min(uint32_t)
__declare_min(int64_t)
</code></pre>

<p>and you can use them explicitly:</p>

<pre><code>int main() {
     printf(""%u"", min_uint32_t(3, -5));
     printf(""%d"", min_int64_t(-1, -5));
} 
</code></pre>

<p>If you have a compiler that has a <code>typeof</code> type operator then you can use: </p>

<pre><code>#define max(a,b) \
  ({ typeof (a) _a = (a); \
      typeof (b) _b = (b); \
    _a &gt; _b ? _a : _b; })
</code></pre>

<h1>GCC specific</h1>

<p>If you are using a new enough version of gcc¡ªchances are if you are using gcc, that you are¡ªyou should use <code>__auto_type</code> instead of <code>typeof</code>:</p>

<pre><code>#define max(a,b) \
  ({ __auto_type _a = (a); \
      __auto_type _b = (b); \
    _a &gt; _b ? _a : _b; })
</code></pre>

<p>Per gcc typeof manual page]<a href=""https://gcc.gnu.org/onlinedocs/gcc/Typeof.html"" rel=""nofollow noreferrer"">1</a>:</p>

<p>Using <code>__auto_type</code> instead of <code>typeof</code> has two advantages:</p>

<ol>
<li><p>Each argument to the macro appears only once in the expansion of the
macro. This prevents the size of the macro expansion growing
exponentially when calls to such macros are nested inside arguments
of such macros. </p></li>
<li><p>If the argument to the macro has variably modified
type, it is evaluated only once when using __auto_type, but twice if
typeof is used.</p></li>
</ol>

<h2>C++</h2>

<p>That's a whole other discussion :-)  </p>
",0
54675492,54675424,1,"<p>In your definition of <code>struct node</code>:</p>

<pre><code>typedef struct node {
        int data;
        struct node_t* next;
    } node_t;
</code></pre>

<p>You define <code>next</code> as a pointer to <code>struct node_t</code>, but there is no such type.  You want <code>struct node</code>:</p>

<pre><code>typedef struct node {
        int data;
        struct node* next;
    } node_t;
</code></pre>
",0
53027323,53027188,0,"<p>It's saying that the pointer variable node_ptr is null but you're trying to access a field inside the structure that is expected to be at the memory location, but the memory location is invalid (the pointer is not initialized to a valid value). You either need to make sure your code doesn't have a mistake that makes it end up with a null pointer as the process goes along, or you need to have it point to a valid memory location by setting it to a memory allocated the memory using new (if you're using C++) or malloc (which you can use in C or C++).  It's also not clear what the variable ""first"" is here...that's probably part of the problem... hope this helps!</p>
",0
52812389,52812338,4,"<p>Notwithstanding the fact that <code>998 / 999</code> is <code>0.998999...9</code>, if you want to <em>truncate</em> on the 3rd significant figure, then one way is to write, from C99 onwards</p>

<pre><code>truncf(998.f / 999 * 1000) / 1000;
</code></pre>

<p>or</p>

<pre><code>floorf(998.f / 999 * 1000) / 1000;
</code></pre>

<p>You might find that the second way is more likely to be available pre-C99, if not then use say <code>(long)</code> in place of <code>floorf</code>, and replace the final division with <code>1000.f</code>.</p>

<p>These can introduce joke digits from about the 7th significant figure, but the formatting choice you already use will obviate that.</p>
",0
53230257,53228093,1,"<p>If OP's code is indeed correct, then vertex labels <em>k</em> are not unique, and many different vertices can have the same label.</p>

<p>Let's say you have an array <em>n</em> of 100,002 unsigned integers, numbered from 0 to 100,001 inclusive, and each capable of representing values from 0 to 5,000. Initialize them all to zeroes.</p>

<p>When you add a vertex labeled <em>k</em>, increment unsigned integer <em>n</em>[<em>k</em>]. If <em>n</em>[<em>k</em>-1] + <em>n</em>[<em>k</em>+1] is nonzero, adding this vertex created that many new edges.</p>

<p>If you count how many edges you create, you have the result immediately after you add the last vertex.</p>

<hr>

<p>If the vertex labels were unique, but there might be (erroneously) duplicate labels <em>k</em> that are to be ignored, then:</p>

<p>Let's say you have an array of 100,002 flags, numbered from 0 to 100,001 inclusive, and initialized to all clear.</p>

<p>Whenever you see vertex labeled <em>k</em>, check if flag <em>k</em> is already set. If it is, then this is a duplicate flag to be ignored.</p>

<p>Otherwise, set the flag, and examine flags <em>k</em>-1 and <em>k</em>+1. If one of them is set, you created one new edge; if both flags are set, you created two new edges. If both are clear, no new edges were created.</p>

<p>If you count how many edges you create, you have the result immediately after you add the last vertex.</p>
",4
52595332,52593516,0,"<p>If <code>Char</code> is just a typo for <code>char</code>, then this becomes relatively simple - set up a second array, indexed by character code, that keeps track of the number of occurrences of each character:</p>

<pre><code>#include &lt;limits.h&gt;
#include &lt;ctype.h&gt;
...
int charCount[SCHAR_MAX+1] = {0}; // We're only going to worry about non-negative
                                  // character codes (i.e., standard ASCII)
                                  // [0..127]
...
/**
 * This assumes that canvas is *not* a 0-terminated string, and that
 * every element of the array is meaningful.  If that's not the case,
 * then loop on the length of the string instead of MAX_SIZE.
 */
for ( int i = 0; i &lt; MAX_SIZE; i++ )
{
  if ( canvas[i] &gt;= 0 &amp;&amp; canvas[i] &lt;= SCHAR_MAX )
  {
    charCount[canvas[i]]++;  // index into charCount by the value of canvas[i]
  }
}
</code></pre>

<p>Then you can walk through the <code>charCount</code> array and print all the character values that occurred more than once:</p>

<pre><code>for ( int i = 0; i &lt;= SCHAR_MAX; i++ )
{
  if ( charCount[i] &gt; 1 )
  {
    /**
     * If the character value is a printable character (punctuation, alpha,
     * digit), print the character surrounded by single quotes - otherwise,
     * print the character code as a decimal integer.
     */
    printf( isprint( i ) ? ""'%c': %d\n"" : ""%d: %d\n"", i, charCount[i] );
  }
}
</code></pre>

<p>What's that <code>SCHAR_MAX</code> all about, any why am I yammering about non-negative character codes in the comments?</p>

<p>In C, characters the <em>basic execution character set</em> (digits, upper and lowercase letters, common punctuation characters) are guaranteed to have non-negative encodings (i.e., the <code>[0..127]</code> range of standard ASCII).  Characters outside of that basic execution character set may have positive or negative values, depending on the implementation.  Thus, the range of <code>char</code> values may be <code>[-128..127]</code> on some platforms and <code>[0..255]</code> on others.  </p>

<p>The <code>limits.h</code> header defines constants for various type ranges - for characters, it defines the following constants:</p>

<pre><code>UCHAR_MAX - maximum unsigned character value (255 on most platforms)
SCHAR_MIN - minimum signed character value (-128 on most platforms)
SCHAR_MAX - maximum signed character value (127 on most platforms)
CHAR_MIN  - minimum character value, either 0 or SCHAR_MIN depending on platform
CHAR_MAX  - maximum character value, either UCHAR_MAX or SCHAR_MAX depending on value
</code></pre>

<p>To keep this code simple, I'm only worrying about character codes in the range <code>[0..127]</code>; otherwise, I'd have to map negative character codes onto non-negative array indices, and I didn't feel like doing that. </p>

<p>Both this method and the nested loop solution require some tradeoffs.  The nested loop solution trades time for space, while this solution trades space for time.  In this case, the additional space is fixed regardless of how large <code>canvas</code> becomes.  In the nested loop case, time will increase with the square of the length of <code>canvas</code>.  For short inputs, there's effectively no difference, but if <code>canvas</code> gets large enough, you will notice a significant decrease in performance with the nested loop solution.  </p>
",0
58869469,58869373,2,"<p>You're writing 16 bytes from a much shorter string (i.e. reading memory you should not be). That's undefinable behavior.</p>

<p>Beware the nasal demons.</p>

<p>What you really want is something like this:</p>

<pre><code>char buffer[16] = { 0 };
strcat(buffer, ""one"");
write(fd,buffer,16);
</code></pre>

<p>Now you are writing 16 chars out of a 16 char buffer which is perfectly ok.</p>
",0
52576372,52576293,1,"<p>Try these steps</p>

<blockquote>
  <p>step 1 :    run in background</p>
</blockquote>

<pre><code>bash# ./a.out &amp;
[1] 4338 
# PID: 4338 
</code></pre>

<blockquote>
  <p>step 2:    issue SIGUSR1 from bash to the pid</p>
</blockquote>

<pre><code>   bash# kill -10 4338
   10 is for SIGUSR1
</code></pre>
",5
56725024,56725018,2,"<p>Yes, there is an implicit conversion (no such thing as an ""implicit cast""; a ""cast"" is an explicit conversion) from <code>int</code> (the 3) to <code>int*</code>.</p>

<p>You are forming a pointer to the <code>int</code> at memory address 0x03, which probably doesn't exist, so don't do this.</p>

<p>The feature can be useful in some low-level settings, such as when memory mapping some hardware register in embedded circumstances. You get the address from the hardware's manual/documentation then write it into your code.</p>

<p>But, in general, if your compiler did not warn you away from such antics, turn up your warnings.</p>
",6
52981203,52981137,1,"<p><strong>UPDATE:</strong> this is pre-edit where <code>levels[5]</code> was changed to <code>levels[]</code>, which does not fix the problem. You still have a confusion between an array and an element thereof. Another update below.</p>

<p>This line here:</p>

<pre><code>update_level(pts,levels[5]);
</code></pre>

<p>The second argument is the sixth element of the <code>levels</code> array not the array itself. Your function is defined to require an array, not a scalar, and you're passing in a scalar.</p>

<p>Try either, define the function as:</p>

<pre><code>void update_level (int pts, int a_level) {
</code></pre>

<p>Or pass in the entire array in the call, as:</p>

<p><code>update_level(pts,levels);</code> <strong>// UPDATE: note absence of ""[]""</strong></p>

<p>This line here:</p>

<pre><code>display_level(k,levels[5]);
</code></pre>

<p>Same problem.</p>

<p>Note that this only solves the immediate problem. I have not analyzed your code to find a ""correct"" solution.</p>
",0
53553540,53553173,0,"<p>You can not meet your expectation for a couple of reasons.
By altering the code you adjust the machine instructions being used in subtle ways that will impact the final value.
For instance if originally it was using fused multiplies and adds and this is no longer happening it will change the result.
You don't mention the target architecture. Some architectures retain more than 64bits in the floating point pipeline.  These extra bits get rounded when forced into 64bit memory.  Again altering how this works will have minor effects on the final output.</p>
",1
54726364,54726345,2,"<p>The format specifier <code>""%s""</code> expects a pointer to an array of characters, not the address of a single <code>char</code> - but since arrays decay to pointers when passed to a function, <code>scanf</code> doesn't know the difference and tries to write the entire string to <code>&amp;anotherOne</code>, which is undefined behavior, since you don't know what in your process' or system's memory will be overwritten.</p>

<p>What you need to do is use the format specifier <code>""%c""</code> instead if you want to read a single character.</p>
",0
53097859,53097652,4,"<p>You did get a warning, which you chose to ignore. Codeblocks default installation is a gcc/mingw one, which does give the following warning:</p>

<blockquote>
  <p>warning: 'return' with a value, in function returning void</p>
</blockquote>

<p>If you compile with <code>-pedantic-errors</code>, it will turn into an error.</p>

<hr>

<p>The recommended setting for beginners is to go Settings -> Compiler, check the following options:</p>

<ul>
<li>Enable all common compiler warnings (-Wall)</li>
<li>Enable extra compiler warnings (-Wextra)</li>
<li>Treat as errors the warnings demanded by strict ISO C (-pedantic-errors)</li>
</ul>

<p>Preferably you should also add an option <code>-std=c11</code> which I don't think exists by default in Codeblocks.</p>
",3
52917124,52917059,-1,"<p><code>word</code> is <em>not</em> a c-string as it does not have a ""NUL"" terminator.</p>

<p>Doing <code>strlen</code> might invoke <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">UB</a> as <code>word</code> does not have a <code>\0</code>.</p>

<blockquote>
  <p>Could you please explain to me how I can get a string from the user?</p>
</blockquote>

<p>One way is to use the <code>fgets</code> function to read in strings easily.</p>
",0
52918620,52918536,3,"<p>The question appears to be asking how to implement a logical AND using nested <code>if</code> statements rather than <code>&amp;&amp;</code> operators.</p>

<p><code>if (X &amp;&amp; Y) foo;</code> is equivalent to <code>if (X) if (Y) foo;</code>.</p>
",0
53176053,53175948,2,"<p>It looks like the (i+1)-st element is created from the i-th by adding an increasing number:</p>

<ul>
<li>a<sub>0</sub> = 2, d<sub>0</sub> = 3</li>
<li>a<sub>1</sub> = 2+3 = 5, d<sub>0</sub> = 4</li>
<li>a<sub>2</sub> = 5+4 = 9, d<sub>0</sub> = 5</li>
<li>a<sub>3</sub> = 9+5 = 14, d<sub>0</sub> = 6</li>
<li>a<sub>4</sub> = 14+6= 20, d<sub>0</sub> = 7</li>
<li>a<sub>5</sub> = 20+7= 27, d<sub>0</sub> = 8 </li>
<li>...and so on</li>
</ul>

<p>You can compute this result by incrementing <code>d</code> as you walk through the loop, and adding it to the previous value of <code>a</code>.</p>

<p>According to the <a href=""https://oeis.org/search?q=2%2C%205%2C%209%2C%2014%2C%2020%2C%2027%2C%2035%2C%2044%2C%2054%2C%2065&amp;language=english&amp;go=Search"" rel=""nofollow noreferrer"">Online Encyclopedia of Integer Sequences</a>, elements of this sequence could be computed using this closed-form expression:</p>

<pre><code>n*(n+3)/2
</code></pre>

<p><strong>Note:</strong> The above division always produces an integer value because one of <code>n</code> or <code>n+3</code> will be even.</p>
",0
52514313,52514115,4,"<p>Code contains <em>constraint violation</em> and is not valid C code. This means that there is no guarantee that your code will compile or work correctly.</p>

<blockquote>
  <h2>6.9 External definitions</h2>
  
  <p><strong>Constraints</strong></p>
  
  <ol start=""2"">
  <li>The storage-class specifiers <code>auto</code> and <code>register</code> shall not appear in the declaration specifiers in an
  external declaration.</li>
  </ol>
</blockquote>

<p>So answers to your questions are:</p>

<ul>
<li>Variable is not part of any function block, since it's external declaration.</li>
<li>Properties of the variable <code>z</code> are undefined, because the code is invalid.</li>
</ul>
",0
52517708,52517623,2,"<p>The argument is of type <code>Fls_AddressType TargetAddress</code>, yet you pass in <code>Test_ProgData</code> which is <strong>an array of <code>Fls_AddressType</code></strong>, and decays to a <strong>pointer to the first element of the array</strong>, hence the error is that your function requires <code>Fls_AddressType TargetAddress</code>, yet you're passing in <code>Fls_AddressType *</code>.</p>

<p>As for <em>how</em> you can solve this - well, I have no idea as I do not know what the program is <em>supposed to do</em>.</p>
",2
58775799,58775766,2,"<p>This line isn't doing what you think:</p>

<pre><code> *lines[i] = (char*)malloc(64*sizeof(char));
</code></pre>

<p>The array index operator <code>[]</code> has higher precedence than the unary dereference operator <code>*</code>.  So it attempts to access <code>lines</code> as an array (which it isn't), then dereference the array member.  This ends up working when <code>i</code> is 0 because it will point to the first allocated array element, but when <code>i</code> is larger you access memory past <code>lines</code> in the calling function.</p>

<p>You need to use parenthesis to make sure you dereference <code>lines</code> first, then index the array elements.</p>

<pre><code> (*lines)[i] = malloc(64*sizeof(char));
</code></pre>

<p>Also, don't cast the return value of <code>malloc</code>.  It's unnecessary and can mask subtle bugs. </p>
",1
53668892,53667613,1,"<p>No, it is not good practice. <code>volatile</code> informs the C implementation (largely the compiler) that an object may be changed by something outside of the C implementation or that accesses to the object within the C implementation may have desired effects outside the C implementation. As long as your global object is only used and modified inside your own program, it has no volatile effects, and declaring it with <code>volatile</code> causes the compiler to suppress optimization and to generate unnecessary accesses to it within your program.</p>
",0
59406509,59406249,4,"<p>By default output to <code>stdout</code> (which is where <code>printf</code> writes) is <em>line-buffered</em>. That means output is actually written to the terminal when</p>

<ol>
<li>The buffer is full</li>
<li>The buffer is explicitly flushed with the <a href=""https://en.cppreference.com/w/c/io/fflush"" rel=""nofollow noreferrer""><code>fflush</code></a> function</li>
<li>Or when you print a newline</li>
</ol>

<p>That's why it seems to work when you print a newline, the buffer is actually written to the terminal.</p>

<p>If you don't want to print the newline, you could explicitly flush the buffer using <code>fflush(stdout)</code>.</p>

<hr>

<p>And you should really fix that array issue.</p>
",1
54664658,54664236,0,"<p>As john said:</p>

<p>A solution in the code is to</p>

<pre><code>#pragma warning disable(4100)
</code></pre>

<p>(or other <a href=""https://stackoverflow.com/questions/3020584/avoid-warning-unreferenced-formal-parameter?r=SearchResults&amp;s=1%7C138.1909"">solutions</a> or <code>[[maybe_unused]]</code> in C++17). You can also add <code>/Wd4100</code> in the makefile to the compiler command line.</p>
",0
57881359,57881328,0,"<pre><code>    if (array[i] == 0)
    {
        array[i-1] = 0;
    }
</code></pre>

<p>I don't understand why this block is there. It's not possible to get inside the if statement.</p>

<p>With your expected output and given this is an array of <code>int</code>s, I suspect the solution is to only output four values in your print statement, but if the last element of the array should be zero, you can just do this after your <code>for</code> loop:</p>

<pre><code>array[size-1] = 0;
</code></pre>
",1
57881466,57881328,0,"<pre><code>#include &lt;stdio.h&gt;

#define ARRAY_SIZE 10

void order_array(int size, int* array) {
    for (int i = 0; i &lt; size; i++) {

        if (!array[i]) {
            continue;
        }

        if (i + 1 &lt; size)
            array[i] = array[i + 1];
    }
}

int main() {
    int array[ARRAY_SIZE] = {1, 2, 3, 4, 5};
    printf(""intput: "");
    for (int i = 0; i &lt; ARRAY_SIZE; i++) {
        printf(""%d"", array[i]);
    }
    printf(""\n"");

    order_array(ARRAY_SIZE, array);

    printf(""output: "");
    for (int i = 0; i &lt; ARRAY_SIZE; i++) {
        printf(""%d"", array[i]);
    }
    printf(""\n"");

    return 0;
}
</code></pre>

<p>Maybe you should consider the last value that not equal to default value 0.</p>

<p>Execute in shell:</p>

<p>gcc -o a.out a.c &amp;&amp; ./a.out </p>

<pre><code>intput: 1234500000
output: 2345000000
</code></pre>
",2
53424130,53424031,8,"<p>This is explained by the sequence of events:</p>

<pre><code>i = 1; // for init
i++ &lt;= 1 ? true // for condition, i evaluates as 1 but is made into i = 2 after the expression
i++; // inside for body, makes i = 3
i++; // for increment, makes i = 4
i++ &lt;= 1 ? false // for condition again, i evaluates as 4 but is made into i = 5 after the expression
// condition is false, for loop ends, i = 5
</code></pre>

<p>Perhaps you are forgetting that the <code>for</code> condition, although false, is still executed to verify that before the program decides the loop is terminated.</p>
",0
53415132,53415043,2,"<p>From the <strong><a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf"" rel=""nofollow noreferrer"">C Standard</a>, ¡ì 6.7.2.2:2-3</strong>:</p>

<blockquote>
  <p>The identifiers in an enumerator list are declared as constants that have type int and
  may appear wherever such are permitted.) An enumerator with = defines its
  enumeration constant as the value of the constant expression. <strong>If the first enumerator has
  no =, the value ... is 0</strong>. Each subsequent enumerator with no =
  defines its ... value ... by
  <strong>adding 1 to the value of the previous enumeration constant</strong>.</p>
</blockquote>

<p>Emphasis mine.</p>
",0
56246791,56246469,1,"<p>There are a couple problems that were pointed out in the comments:</p>

<ol>
<li><p>In the third loop, the code uses <code>cutindex + 1</code> to index into the <code>argv</code> array. But the loop doesn't change <code>cutindex</code>, so the first argument after ""cut"" (""amy"" in the example) is repeated for the entire array.</p></li>
<li><p>The output arrays <code>argv1</code> and <code>argv2</code> should be arrays of pointers. </p></li>
</ol>

<p>One solution to the first problem is to use a separate index for each array. That way you can increment each index as needed, and don't need to attempt to compute indexes mathematically.</p>

<p>The added benefit is that when the code is finished, the final value of each output index is the count of elements in the corresponding output array.</p>

<p>Another added benefit is that you can limit the number of elements written to the array. Note that in the code below, any arguments after the first 10 are silently dropped. In real code, you might want to alert the user that they entered too many arguments.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define MAX_ARG 10

int main(int argc, char *argv[])
{
    char *argv1[MAX_ARG];   // first array of arguments
    int n1 = 0;             // index into first array

    char *argv2[MAX_ARG];   // second array of arguments
    int n2 = 0;             // index into second array

    // copy pointers into the first array until ""cut"" is found
    int i;
    for (i = 1; i &lt; argc; i++)
    {
        if (strcmp(""cut"", argv[i]) == 0)
            break;
        if (n1 &lt; MAX_ARG)
            argv1[n1++] = argv[i];
    }

    // copy any remaining pointers into the second array
    for (i++; i &lt; argc; i++)
    {
        if (n2 &lt; MAX_ARG)
            argv2[n2++] = argv[i];
    }

    // print the arrays
    for (int i = 0; i &lt; n1; i++)
        printf(""argv1[%d] = '%s'\n"", i, argv1[i]);
    putchar('\n');
    for (int i = 0; i &lt; n2; i++)
        printf(""argv2[%d] = '%s'\n"", i, argv2[i]);
}
</code></pre>

<p>When run with the command line</p>

<pre><code>./a.out andy bob charlie ned cut amy sophie anna
</code></pre>

<p>the output of this code is</p>

<pre><code>argv1[0] = 'andy'
argv1[1] = 'bob'
argv1[2] = 'charlie'
argv1[3] = 'ned'

argv2[0] = 'amy'
argv2[1] = 'sophie'
argv2[2] = 'anna'
</code></pre>
",0
53396816,53396579,0,"<p>There are a few ways to interpret ""I want to change content of array to NULL"". </p>

<p>If you just want to change the pointer to <code>NULL</code>, just assign  it the value <code>NULL</code> without using <code>strcpy</code>.</p>

<p>If you just want to invalidate the null-terminated string contained in the array, set the first element of the array to <code>'\0'</code>: <code>args[i][0] = '\0';</code></p>

<p>If you want to populate the entire array with null values, use <code>memset(args[i], 0, &lt;size of args[i] array&gt;)</code></p>
",0
53459290,53459213,0,"<p>You need to learn how to use a debugger.</p>

<p>Here's the output when you use a debugger to run your C program (gdb, in this case). I named your compiled program <code>t</code>:</p>

<pre><code>$ gdb ./t
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type ""show copying""
and ""show warranty"" for details.
This GDB was configured as ""x86_64-linux-gnu"".
Type ""show configuration"" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type ""help"".
Type ""apropos word"" to search for commands related to ""word""...
Reading symbols from ./t...done.
(gdb) r
Starting program: /home/youruser/t 
 number of characters 3
a

Program received signal SIGSEGV, Segmentation fault.
0x00000000004006ba in chartoint (c=0x7fffffffe540 ""\na\n"", x=0x602010) at t.c:6
6       while(c[i]!='.'||c[i]!='\0'){
(gdb) bt
#0  0x00000000004006ba in chartoint (c=0x7fffffffe540 ""\na\n"", x=0x602010) at t.c:6
#1  0x0000000000400884 in main () at t.c:29
(gdb) 
</code></pre>

<p>It's basically saying that you are getting a segmentation fault (<code>SIGSEGV</code>) when running line 6. The reason is probably that <code>i</code> it's being used without being initialized first.</p>

<p>If you are using an IDE to do this (Visual Studio, Visual Studio Code) you will probably have and embedded debugger.</p>
",0
53121614,53121200,3,"<p>Just reading the code and guessing about what it is supposed to do I can see these things:</p>

<pre><code>new_plane = &amp;plane_name_arr[i];
</code></pre>

<p>The above code writes the address of the element in the array to new_plane and
throws away the pointer that you just allocated. You probably want to copy the values from plane_name_arr[i] to the new memory.</p>

<pre><code>*new_plane = plane_name_arr[i];
</code></pre>

<p>You mention you call the method with NULL from main. This won't work either as you write to that memory at the end of the method.</p>

<pre><code>*plane_input_output = list;
</code></pre>

<p>This requires there to be some memory it can write to.</p>

<p>Calling it like:</p>

<pre><code>int main(int argc, char *argv[]) {
  plane *head = NULL;
  CreateAirplaneList(&amp;head);
}
</code></pre>

<p>Makes sure that the write at the end of <em>CreateAirplaneList</em> can actually write the result somewhere.</p>

<p>Your method <code>int CreateAirplaneList(plane **plane_input_output)</code>
takes a pointer to a pointer as an argument. 
If you call it like you do with:</p>

<pre><code>plane **x = NULL;
CreateAirplaneList(x);
</code></pre>

<p>You will pass in the value NULL. Which means the write at the end tries to write to NULL. Since you want to pass the linked list outside of the method you want to provide the method with an address where it can write the result.</p>

<p>So you create a variable of the type you want. In this case <code>plane *head;</code> and then you pass the address of that variable to the method <code>CreateAirplaneList(&amp;head)</code> so that when the <code>*plane_input_output = list</code> it writes it to the memory of <code>head</code> in <code>main</code>.</p>

<p>There might be more errors in there I haven't seen while quickly looking at it. Good luck.</p>
",4
53121631,53121200,2,"<p>With:</p>

<pre><code>new_plane = (plane*)malloc(sizeof(plane));
</code></pre>

<p>you are allocating room for a plane. Then with:</p>

<pre><code>new_plane = &amp;plane_name_arr[i];
</code></pre>

<p>you throw away the memory and replace with a pointer into the planes array. Probably you intend:</p>

<pre><code>*new_plane = plane_name_arr[i];
</code></pre>

<p>which copies the plane data from the array to the allocated memory.</p>

<p>(In your version, the array was a local array, i.e. on the stack, which does not exist anymore after the function returns. Its memory will be reused and your linked list shows garbage.)</p>

<p>In your <code>main</code> you must call the function with the address of your list head:</p>

<pre><code>  plane *x = NULL;         //  x is the list
  CreateAirplaneList(&amp;x);  // &amp;x is the address of the list
</code></pre>

<p>The create function can now modify the list in <code>x</code>.</p>
",6
52658265,52658155,0,"<p>This is due to <a href=""https://en.wikipedia.org/wiki/Integer_overflow"" rel=""nofollow noreferrer"">integer overflow</a>:</p>

<blockquote>
  <p>In computer programming, an integer overflow occurs when an arithmetic
  operation attempts to create a numeric value that is outside of the
  range that can be represented with a given number of digits ¨C either
  larger than the maximum or lower than the minimum representable value.</p>
</blockquote>

<p>In other words, the data type your using can't store numbers larger than a certain value. Choose another type to store larger numbers (<code>unsigned long long</code> instead of <code>int</code> for example). There also exist libraries that provide types that can store arbitrarily large numbers, usually at the cost of processing speed.</p>

<p>Another reason that you should use an unsigned integer of some kind is because the answer simply will never be negative. That releases the bit that signifies the sign of the number and doubles the positive range of values that can be stored.</p>
",1
53473003,53472897,2,"<p>How about a function to ask a question, and return a response?</p>

<pre><code>#include &lt;stdio.h&gt;

/*
 * Prompt the user with the given question, return their
 * input in answer, up to max_answer_length bytes 
 * returns 1 for ok, 0 on error.
 */
int askQuestion(const char *question, char *answer, const size_t max_answer_length)
{
    int input_ok = 1;  

    // Show the user the question
    printf( ""%s: "", question );

    // Throw away any existing input in the user's input-queue
    // (like if they answered with a really-long string previously)
    fflush(stdin);

    // Read a line of input from the user into &lt;answer&gt;, but not more
    // than &lt;max_answer_length&gt;-1 bytes are accepted (see fgets() for details)
    // If the fgets() returns EOF or an error, make sure we remember it
    if ( fgets( answer, max_answer_length, stdin ) == NULL )
        input_ok = 0;

    // return whether there was an error on input
    return input_ok;
}

int main(void)
{
    char answer_buffer[200];

    askQuestion( ""What is your favourite fruit?"", answer_buffer, sizeof(answer_buffer) );
    printf( ""&gt;&gt; %s\n"", answer_buffer );

    askQuestion( ""How long have you been programming C?"", answer_buffer, sizeof(answer_buffer) );
    printf( ""&gt;&gt; %s\n"", answer_buffer );

    return 0;
}
</code></pre>
",6
53618334,53618156,3,"<p>These two functions are not equivalent due to operator precedence rules.</p>

<p>Remember a <code>#define</code> macro does <em>inline substitution</em> and the arguments themselves are replaced as-is:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int oper_fn(int x, int y) {
    return x/y + x;
}

#define oper_def(x, y) x / y + x

int main() {
    int i = -6, j = 3;
    printf (""oper_fn=%d "",oper_fn( i + j , 3));
    printf (""oper_def=%d\n"",oper_def( i + j , 3));
}
</code></pre>

<p>What this ends up doing is evaluating:</p>

<pre><code>i + j / 3 + i + j
</code></pre>

<p>Due to order of operations, this evaluates as:</p>

<pre><code>i + (j / 3) + i + j
</code></pre>

<p>That's not what you want, instead you want:</p>

<pre><code>(i + j) / 3 + (i + j)
</code></pre>

<p>Which means you need the macro:</p>

<pre><code>#define oper_def(x, y) ((x) / (y) + (x))
</code></pre>

<p>That's how macros are written normally to avoid ambiguity and inconsistency like this.</p>
",2
53618350,53618156,0,"<p>when you define </p>

<pre><code> #define foo(x, y) x / y + x
</code></pre>

<p>and then do</p>

<pre><code> foo( i + j , 3));
</code></pre>

<p>you get</p>

<pre><code> i + j / 3 + i + j
</code></pre>

<p>which is</p>

<pre><code> -6 + 3/ 3 + 3 -6 = -6 + 1 + 3 - 6 = -8
</code></pre>

<p>when you call the function foo the i+j is evaluated first</p>

<p>if you want the correct define behavior then do </p>

<pre><code>#define foo(x, y) ((x / y) + x)
</code></pre>

<p>You have just discovered why <code>define</code>d functions are a bad idea</p>
",2
53618317,53618156,5,"<p>If you preprocess the call to the macro <code>foo</code>, you get:</p>

<pre><code>i + j / 3 + i + j
</code></pre>

<p>With your values, that's </p>

<pre><code>(-6) + 3 / 3 + (-6) + 3
</code></pre>

<p>Which evaluates to <code>-8</code>.</p>

<p>When you undefine the macro <code>foo</code>, you get the function <code>foo</code> instead, where the line <code>return x + y / x</code> is executed.</p>

<p>With <code>i = -6</code> and <code>j = 3</code>, you get:</p>

<pre><code>(-3) / 3 + -3
</code></pre>

<p>Which is <code>-4</code>.</p>

<p>Further reading: </p>

<ul>
<li><a href=""https://en.cppreference.com/w/c/language/operator_precedence"" rel=""noreferrer"">Operator Precedence in C</a></li>
<li><a href=""https://hbfs.wordpress.com/2009/11/17/defines-are-evil/"" rel=""noreferrer"">#defines are EVIL</a></li>
</ul>
",2
54611104,54611095,5,"<p>Yes.  Since that pointer you reassigned (e.g. arr[5]) is no longer accessible it's memory can't be free'd and it is a memory leak.</p>
",6
53121693,53121630,2,"<p>When you calculate <code>sum/num</code>, both arguments are of type <code>int</code> so integer division is performed, which means any fractional portion is truncated.  This happens <em>before</em> the result is assigned to <code>avg</code>.</p>

<p>You need to cast at least one argument to <code>float</code> to perform floating point division:</p>

<pre><code>avg = (float)sum/num;
</code></pre>
",0
53057530,53057327,1,"<p>The data you're sorting is an array of <code>char *</code>, pointers to character strings. To reorder the array you just need to swap the pointers. You don't need to move the string contents. In fact you can't move the string contents in this case because they are <strong>string literals</strong>. You get a segfault when you try to write to read-only values.</p>

<p>I've slightly rewritten your function to just swap pointers and it seems to work now.</p>

<pre><code>void SortString(char *strings[], int size)
{
    char *temp;
    for(int i = 0; i &lt; size - 1; i++) {
        for(int j = i + 1; j &lt; size; j++) {
            if (strcmp(strings[i], strings[j]) &gt; 0) {
                temp = strings[i];
                strings[i] = strings[j];
                strings[j] = temp;
            }
        }
    }
}
</code></pre>

<p><a href=""https://ideone.com/kYCDSl"" rel=""nofollow noreferrer"">Live demo on Ideone.com</a></p>
",0
57278759,57275845,0,"<p>In the context of C:</p>
<blockquote>
<strong>6.3.2.1 Lvalues, arrays, and function designators</strong><br><br>
1 An <em>lvalue</em> is an expression (with an object type other than <code><strong>void</strong></code>) that potentially
designates an object;<sup>64)</sup> if an lvalue does not designate an object when it is evaluated, the
behavior is undefined. When an object is said to have a particular type, the type is
specified by the lvalue used to designate the object. A <em>modifiable lvalue</em> is an lvalue that
does not have array type, does not have an incomplete type, does not have a const-qualified type, and if it is a structure or union, does not have any member (including,
recursively, any member or element of all contained aggregates or unions) with a const-qualified type.<br><br>
2 Except when it is the operand of the <strong><code>sizeof</code></strong> operator, the <strong><code>_Alignof</code></strong> operator, the
unary <strong><code>&</code></strong> operator, the <strong><code>++</code></strong> operator, the <strong><code>--</code></strong> operator, or the left operand of the <strong><code>.</code></strong> operator
or an assignment operator, an lvalue that does not have array type is converted to the
value stored in the designated object (and is no longer an lvalue); this is called <em>lvalue
conversion</em>. If the lvalue has qualified type, the value has the unqualified version of the
type of the lvalue; additionally, if the lvalue has atomic type, the value has the non-atomic
version of the type of the lvalue; otherwise, the value has the type of the lvalue. If the
lvalue has an incomplete type and does not have array type, the behavior is undefined. If
the lvalue designates an object of automatic storage duration that could have been
declared with the <strong><code>register</code></strong> storage class (never had its address taken), and that object
is uninitialized (not declared with an initializer and no assignment to it has been
performed prior to use), the behavior is undefined.<br><br>
3 Except when it is the operand of the <strong><code>sizeof</code></strong> operator, the <strong><code>_Alignof</code></strong> operator, or the
unary <strong><code>&</code></strong> operator, or is a string literal used to initialize an array, an expression that has
type ¡®¡®array of <em>type</em>¡¯¡¯ is converted to an expression with type ¡®¡®pointer to <em>type</em>¡¯¡¯ that points
to the initial element of the array object and is not an lvalue. If the array object has
<strong><code>register</code></strong> storage class, the behavior is undefined.
<hr>
<sup>64) The name ¡®¡®lvalue¡¯¡¯ comes originally from the assignment expression <strong><code>E1 = E2</code></strong>, in which the left
operand <strong><code>E1</code></strong> is required to be a (modifiable) lvalue. It is perhaps better considered as representing an
object ¡®¡®locator value¡¯¡¯. What is sometimes called ¡®¡®rvalue¡¯¡¯ is in this International Standard described
as the ¡®¡®value of an expression¡¯¡¯.<br><br>
An obvious example of an lvalue is an identifier of an object. As a further example, if <strong><code>E</code></strong> is a unary
expression that is a pointer to an object, <strong><code>*E</code></strong> is an lvalue that designates the object to which <strong><code>E</code></strong> points.</sup>
</blockquote>
<p><sup><em><a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C 2011 Online Draft</a></em></sup></p>
<p>Summarizing:</p>
<p>An array <em>expression</em> (that is, any expression of array type) is indeed an lvalue; however, unless it is the operand of the <code>sizeof</code>, <code>_Alignof</code>, or unary <code>&amp;</code> operators, that expression gets converted (&quot;decays&quot;) to an expression of pointer type whose value is the address of the first element of the array, and that converted pointer expression is <em>not</em> an lvalue, and thus cannot be the target of an assignment.</p>
<p>That is, if you declare <code>a</code> as</p>
<pre><code>T a[N]; // for any type `T`
</code></pre>
<p>then the <em>expression</em> <code>a</code> has type &quot;N-element array of <code>T</code>&quot;.  If <code>a</code> is not the operand of the <code>sizeof</code>, unary <code>&amp;</code>, or <code>_Alignof</code> operators, it will be converted to an expression of type &quot;pointer to <code>T</code>&quot;, and its value will be the same as <code>&amp;a[0]</code>, and that value cannot be the target of an assignment (it's logically the same as writing <code>2 = 3</code> - you're trying to assign a value to a value, not an object, which doesn't work).</p>
",0
57277375,57275845,1,"<blockquote>
  <ol>
  <li>is an array name l-value?</li>
  </ol>
</blockquote>

<p>Yes, in both C and C++.</p>

<blockquote>
  <ol start=""2"">
  <li>Is there any difference between what means l-value in c and c++?</li>
  </ol>
</blockquote>

<p>Yes, but not of great significance.  Here is the definition from C11, paragraph 6.3.2.1/1:</p>

<blockquote>
  <p>An lvalue is an expression (with an object type other than void) that potentially designates an object</p>
</blockquote>

<p>C also includes a footnote (#64) expanding on that, which includes:</p>

<blockquote>
  <p>The name ''lvalue'' comes originally from the assignment expression <code>E1 = E2</code>, in which the left operand <code>E1</code> is required to be a (modifiable) lvalue. It is perhaps better considered as representing an object
  ''locator value''. [...] An
  obvious example of an lvalue is an identifier of an object.</p>
</blockquote>

<p>Here is the definition from C++14, paragraph 3.10/1:</p>

<blockquote>
  <p>An <em>lvalue</em> (so called, historically, because lvalues could appear on
  the left-hand side of an assignment expression) designates a function
  or an object.</p>
</blockquote>

<p>If you read carefully, you will notice that in C, an lvalue only <em>potentially</em> designates an object, whereas in C++, no room is left for unfulfilled potential -- an lvalue does designate an object or function.  You'll also then notice that C++ includes function designators among its lvalues, whereas C does not.  In practice, these distinctions are more technical than deeply meaningful.  And neither of them affects the answer to your question (1).</p>

<p>You'll also note that neither definition is written in terms of how or where an lvalue can be used.  That <em>follows from</em> the definition and other specifications; it is not a defining characteristic.</p>

<p>In both C and C++, an array's identifier designates an object -- the array -- and it is therefore an lvalue.  Whether such an lvalue may in fact appear as the left operand in an assignment expression is an entirely separate question.</p>
",2
52895373,52893847,1,"<p>Your function is terribly convoluted and wrong.</p>

<p>Use this instead and let the C library do the dirty work:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;ctype.h&gt;

// The function you're interested in

int convert(const char string[]) {
  char *endptr;
  if (!isdigit((unsigned char)string[0]))
    return -1;

  errno = 0;    // need to set errno to 0 (see errno documentation)
  long value = strtol(string, &amp;endptr, 10);
  if (errno != 0 || value &lt;= 0 || value &gt; 2147483647 || *endptr != 0)
  {
    return -1;
  }
  return value;
}

int main() {
  // Test different cases:

  struct {
    const char *input;
    int expected;
  } testcases[] =
  {
    // OK cases
    ""123"", 123,
    ""1234"", 1234,
    ""2147483647"", 2147483647,

    // fail cases
    ""-1234"", -1,      // number is negatif
    ""12.3"", -1,       // contains non digit '.'
    ""123y"", -1,       // contains non digit 'y'
    ""2147483648"", -1, // out of range
    "" 123"", -1,      // starts with a space

    // wrong test case on purpose
    ""1234"", 1245,
  };

  // Test all test cases

  for (int i = 0; i &lt; sizeof(testcases) / sizeof(testcases[0]); i++)
  {
    int value = convert(testcases[i].input);
    if (value != testcases[i].expected)
    {
      printf(""convert(\""%s\"") failed, returned value = %d, expected value = %d\n"", testcases[i].input, value, testcases[i].expected);
    }
    else
    {
      printf(""convert(\""%s\"") passed\n"", testcases[i].input);
    }
  }
  return 0;
}
</code></pre>

<p>The program prints every test case. The last test case is wrong on purpose.</p>

<p>The for loop loops through a number of test cases and for each test case that fails it prints the values involved.</p>

<p>Output:</p>

<pre><code>convert(""123"") passed
convert(""1234"") passed
convert(""2147483647"") passed
convert(""-1234"") passed
convert(""12.3"") passed
convert(""123y"") passed
convert(""2147483648"") passed
convert(""1234"") failed, returned value = 1234, expected value = 1245
</code></pre>
",0
52730067,52730027,0,"<pre><code>int performTask(struct npc**sums)
{
// to hit sums 5
    sums[5]-&gt;thingy = 42;
}
</code></pre>

<p>note that you will also have to pass in a size argument. There is no way to determine the size of the array in <code>performTask</code></p>
",0
52730201,52730027,1,"<p>If you need to pass an array of struct (or an array of anything), simply pass a pointer. An array, on access, is converted to a pointer<sup>1</sup>.</p>

<p>The only caveat is if you are passing the address for a linked list to a function where the list address may change (in that case you must pass the <strong>address of</strong> the pointer so that the list address may be changed if the first node is changed)</p>

<p>Otherwise, in your case, as long as there has been storage allocated for the array of struct prior to passing to the function, simply passing a pointer is fine, e.g.</p>

<pre><code>#include &lt;stdio.h&gt;

#define NS 4

typedef struct {    /* structure */
    int a, b;
} ints;

void change (ints *s)   /* function taking pointer to struct */
{
    for (int i = 0; i &lt; NS; i++)
        s[i].a = i+1, s[i].b = i+1;
}

int main (void) {

    ints arr[NS] = {{0}};   /* array of struct initialized zero */

    change (arr);           /* passed to function */

    for (int i = 0; i &lt; NS; i++)    /* changes output */
        printf (""arr[%d]: (%d, %d)\n"", i, arr[i].a, arr[i].b);
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/structpass
arr[0]: (1, 1)
arr[1]: (2, 2)
arr[2]: (3, 3)
arr[3]: (4, 4)
</code></pre>

<p><strong>footnotes:</strong></p>

<p><strong>[1]</strong> <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.3.2.1p3"" rel=""nofollow noreferrer"">C11 Standard - 6.3.2.1 Other Operands - Lvalues, arrays, and function designators(p3)</a></p>
",2
55487171,55487055,3,"<p>The operator <code>-&gt;</code> has lower precedence and so is evaluated first. <code>channel</code> is a void pointer so, when <code>channel-&gt;</code> de-references it, you obtain a value of type <code>void</code> instead of the expected <code>struct channel</code>.</p>

<p>Add parenthesis around the cast and <code>channel</code> (or pass <code>channel</code> around as a <code>struct channel *</code> rather than <code>void*</code> to avoid repeated casting):</p>

<pre class=""lang-cpp prettyprint-override""><code>((struct channel *)channel)-&gt;qtail-&gt;next = head;
</code></pre>
",0
55487172,55487055,3,"<p>It's not valid to de-reference a <code>void*</code> pointer.  The de-referencing is basically a numerical off-set from the base-pointer.  If the compiler does not know what type the pointer is, how can it know the offset amount, nor is it able to decide whether the member reference is actually valid.</p>

<p>In your function it is cast,   It looks like there's a stray <code>&amp;</code>.</p>

<pre><code>void sendChannel(void *channel, void *fetchAddress)
{
    struct channel *chan = (struct channel *)channel;

    if( capChannel( chan ) == lenChannel( chan ) )
    {
        chan-&gt;qtail-&gt;next = head;
    }
}
</code></pre>

<p>But your cast is not applied to anything.  I prefer to make the cast explicit, by assigning it to a temporary local variable.  I feel this makes the resultant code more readable, as it's not full of type-casts here &amp; there.</p>
",0
52947160,52945368,2,"<p>Okay, so you say the <code>write</code> call fails with errno of ""Invalid argument"", i.e. <code>EINVAL</code>. In the posted code you don't actually observe that, but for the sake of argument let's say you are actually running a program which is identical other than checking errno.</p>

<p><a href=""http://man7.org/linux/man-pages/man2/write.2.html"" rel=""nofollow noreferrer"">The manpage for <code>write</code></a> clearly says:</p>

<blockquote>
  <p><strong>EINVAL</strong><br>
  <code>fd</code> is attached to an object which is unsuitable for writing; or the file was opened with the <code>O_DIRECT</code> flag, and either the address specified in <code>buf</code>, the value specified in <code>count</code>, or the file offset is not suitably aligned.</p>
</blockquote>

<p>Don't use <code>O_DIRECT</code> unless you know what you're doing and why. Remove it. And read the documentation!</p>
",8
53109600,53107369,0,"<p>do this </p>

<pre><code>fp = fopen (""input.txt"", ""r"");
if(fp == NULL)
{
   perror(""failed to open file "");
   exit(1);
}
</code></pre>

<p>THis will tell you why the file failed to open</p>
",0
54067457,54060240,1,"<p>The basic (simplest) method is ""place your left (or right) hand on a wall"". What this means is a loop that does these steps:</p>

<ul>
<li><p>determine which direction to move based on the direction you're facing from the last time you moved, using a clockwise order (e.g. if you moved north, then check if you can go west, then north, then east, then south).</p></li>
<li><p>move in the first direction you determined that you can move</p></li>
<li><p>check if you've been to this location before and discard part of the path you've taken if you have. For example, if you move north into a dead-end and have to move back to the south, modify the path taken so far so that it looks like you never went north in the first place. This is easiest done by numbering your steps - each time you move to a location that you haven't been before, store a ""number of times I've moved so far"" value at that location so that you can use that value later to make it easier to discard that part of the previously taken path. The previously taken path can be an array of ""location or discarded"" values with ""number of each move"" as the index.</p></li>
<li><p>check if you've reached the exit, and if you haven't loop back to the start.</p></li>
</ul>

<p>After you've implemented this loop (without recursion) and checked to make sure it works correctly; you just need to way to make the code suck (slower, harder to read and more likely to crash by running out of stack space) by ramming unnecessary recursion into it somehow. The simplest way to do that is to modify the loop so that the last thing (""check if you've reached the exit, and if you haven't loop back to the start"") becomes a function call (""check if you've reached the exit, and if you haven't call yourself"").</p>

<p><strong>WARNING:</strong> <em>Your questions says ""find a path"" and this algorithm will do that. However, if there are multiple possible paths, this algorithm may not find the shortest path (or the longest path). For this reason (assuming it's a uni assignment or something) I'd recommend checking the requirements to make sure that ""any path"" is acceptable.</em></p>
",0
53598797,53598731,1,"<p>The <code>%s</code> format specifier prints a string, which is a NUL terminated sequence of characters in an array.  Your <code>key</code> array just has a character, and no NUL terminator, so you get Undefined Behavior.</p>

<p>To legally print a string with <code>%s</code> you need to pass (a pointer to) an array containing a NUL-terminated sequence, which you can do by declaring it as <code>char key[2];</code> and setting <code>key[1] = '\0'</code>.  Alternately, you can use <code>%c</code> to print a single character (in which case you need to pass the character, not an array -- eg <code>printf(""%c\n"", key[0]);</code>)</p>
",1
53598797,53598731,1,"<p>The <code>%s</code> format specifier prints a string, which is a NUL terminated sequence of characters in an array.  Your <code>key</code> array just has a character, and no NUL terminator, so you get Undefined Behavior.</p>

<p>To legally print a string with <code>%s</code> you need to pass (a pointer to) an array containing a NUL-terminated sequence, which you can do by declaring it as <code>char key[2];</code> and setting <code>key[1] = '\0'</code>.  Alternately, you can use <code>%c</code> to print a single character (in which case you need to pass the character, not an array -- eg <code>printf(""%c\n"", key[0]);</code>)</p>
",1
54683203,54683158,1,"<p>You declare <code>length</code> without initializing it.</p>

<p>Then you declare <code>len</code>, with initialization.</p>

<p>Then you <em>use</em> the uninitialized <code>length</code>, which leads to undefined behavior.</p>

<p>Turn up your warning flags when compiling (consult your compiler docs for those) and don't declare variables so far from the point you actually need them.</p>
",1
54683197,54683158,3,"<p>The variable <code>length</code> is used to limit iterations of both your loops but is never assigned a value.  This is undefined behaviour and a bus error is definitely a possible outcome of it.</p>

<p>Did you intend to use <code>len</code> for this purpose? </p>

<p>EDIT: <code>strlen</code> already does not include the null terminator in its return value. <code>strlen(buf) - 1</code> is probably not what you want.</p>
",2
52985403,52985266,5,"<p>Nope.</p>

<p>The best you can do involves an array of function pointers</p>

<pre><code>#include &lt;stdio.h&gt;

typedef int (*fx)(void); // fx is pointer to function taking no parameters and returning int

int foo_1(void) { printf(""%s\n"", __func__); return 1; }
int foo_2(void) { printf(""%s\n"", __func__); return 2; }
int foo_three(void) { printf(""%s\n"", __func__); return 3; }

int main(void) {
    fx foo[3] = { foo_1, foo_2, foo_three };
    for (int k = 0; k &lt; 3; k++) {
        printf(""foo[%d]() returns %d\n"", k, foo[k]());
    }
}
</code></pre>

<p><a href=""https://ideone.com/dUaFjR"" rel=""noreferrer"">see code running on ideone</a></p>
",4
52985373,52985266,7,"<p>You cannot have the compiler or runtime do this automatically in C, but you can manually list the function pointers and invoke them in a loop, i.e.:</p>

<pre><code>// create your function prototype, which all functions must use
typedef void(*VoidFunc)(void);

// create the array of pointers to actual functions
VoidFunc functions[] = { foo_1, foo_2, foo_3 };

// iterate the array and invoke them one by one
int main(void)
{
    for (int i = 0; i &lt; sizeof(functions) / sizeof(*functions); i++)
    {
        VoidFunc fn = functions[i];
        fn();
    }

    return 0;
}
</code></pre>

<p>Keep in mind that <code>void func()</code> is not the same as <code>void func(void)</code> in C.</p>
",0
55282646,55282505,4,"<p>There's nothing automatic. Check whether the input ends with newline. If it doesn't, call <code>getchar()</code> in a loop until you get newline or EOF.</p>

<pre><code>while(1){
    printf(""prompt&gt; "");
    if (fgets(input, INPUT_MAX, stdin) == NULL) {
        break;
    }
    printf(""\n%s\n"", input);
    if (input[strlen(input)-1] != '\n') {
        for (int c; (c = getchar()) != EOF &amp;&amp; c != '\n';)
            ;
}
</code></pre>
",0
56468094,56468044,4,"<blockquote>
<pre><code>int *const *p
</code></pre>
</blockquote>

<p><code>p</code> is a pointer to a <strong>constant</strong> pointer to <code>int</code>.</p>

<p>You can change <code>p</code> itself;<br>
You cannot change <code>*p</code>;<br>
You can change <code>**p</code>.</p>

<pre><code>void foo(int *const *p) 
{ int j = 10;
*p = &amp;j; // nope
printf(""%d "", **p);
}
</code></pre>
",0
58695719,58695269,1,"<p>To answer the general question in the title - yes, it's okay not to use all the parameters passed to a function, although it may be confusing to future maintainers.</p>

<p>For this specific case, instead of passing an argument count, I'd recommend using special names for the input and output files to indicate standard streams.  It's a common convention among *nix command line utilities to use <code>""-""</code> to specify reading from standard input:</p>

<pre><code>xmllint --format some_ugly_wad_of_xml | vi -
</code></pre>

<p>The above command pretty prints some XML and then passes the pretty-printed version to vi to edit (something I've had to do a lot lately).  So instead of passing an <code>argc</code>, just pass the filenames and examine them to determine what to do:</p>

<pre><code>if ( !strcmp( inputFile, ""-"" ) )
  inputStream = stdin;
else
  inputStream = fopen( inputFile, ""r"" );
</code></pre>

<p>This way you're not leaving any parameters ""unused"".  </p>
",0
58695389,58695269,1,"<blockquote>
  <p><em>Is it ok to have unused parameters in C function?</em></p>
</blockquote>

<p>Yes.</p>

<p>Still, why not have <code>encoder()</code> take two <code>FILE*</code> instead of the names, then do (pseudo code):</p>

<pre><code>main(argc, argv)
  FILE * fp_in, * fp_out

  if argc == 2
    fp_in = open argv[1], ""r""
  else
    f = stdin

  if argc == 3
    fp_out = open argv[3], ""w""
  else
    fp_out = stdout

  encoder fp_in, fp_out
</code></pre>
",3
58229737,58229351,0,"<p>Your strings are wrongly sized for the inputs.</p>

<p>string in C are zero-terminated, meaning that they will contain the desired content plus an ending zero character (so that most function would understand where your string end).</p>

<p>Your array will be allocated contiguously onto the stack, meaning that before your first loop your memory would look like this:</p>

<pre><code>000011112222333344445555
</code></pre>

<p>content will be arbitrary, but for ease of understanding your array would look like this</p>

<ol>
<li><code>[[0,0,0,0],[1,1,1,1],[2,2,2,2],[3,3,3,3],[4,4,4,4],[5,5,5,5]]</code></li>
<li><code>[['t','h','i','s'],['\0',1,1,1],[2,2,2,2],[3,3,3,3],[4,4,4,4],[5,5,5,5]]</code></li>
<li><code>[['t','h','i','s'],['i','s','\0',1][2,2,2,2],[3,3,3,3],[4,4,4,4],[5,5,5,5]]</code></li>
</ol>

<p>in a contiguous view </p>

<pre><code>'t','h','i','s','i','s','\0',12222333344445555
</code></pre>

<p>resulting in the observed behavior</p>

<p>You can fix the issue in 2 ways</p>

<ul>
<li>limit the string output by using <code>%4s</code> in the output format.</li>
<li>limit the input to 3 chars <code>%3s</code> so that input would not overlap when writing the terminating zero char.</li>
<li>grow the size of your string to accommodate the terminating zero character.</li>
</ul>
",0
52541354,52541245,1,"<p>Ignoring the fact that rand_word is 100% wrong lets just deal with the error message.</p>

<p>YOu have a function that is declared as taking at char array (char[]) as an argument. You are passing it and array of pointers to a char array. Thats not valid.</p>

<p>Change rand_word to accept <code>char *ARR[]</code></p>

<p>now rand_word is wrong</p>

<p>a) sizeof (ARR) will always be 4 or 8. Its the size of a pointer. you cannot inspect a pointer to an array and determine the length of the array. Pass in a second argument with the length</p>

<p>b) The function returns an int. It should return a pointer to a string</p>
",0
53128321,53128281,2,"<p>You have two <em>very</em> different errors that you really should have asked about in two different question, but I'll be nice and answer both anyway.</p>

<ol>
<li><p>In the <code>main</code> function you have a variable named <code>cmd</code>. It is of type <code>char</code>. You pass it to the <code>call</code> function, which expects an argument of type <code>char *</code> (i.e. a null-terminated string).</p>

<p>To fix this you first need to make sure that <code>cmd</code> is the correct type (i.e. <code>char *</code> instead of plain <code>char</code>). Secondly you need to make sure this pointer is actually pointing to a valid null-terminated byte string.</p>

<p>In other words, something like this:</p>

<pre><code>char *cmd = ""open"";
call(cmd);
</code></pre></li>
<li><p>C really only cares about <a href=""https://en.wikipedia.org/wiki/Translation_unit_(programming)"" rel=""nofollow noreferrer""><em>translation units</em></a>. A translation unit is a single source files with all included header files.</p>

<p>The problem here is that variables can only be <strong>defined</strong> in a single translation unit. And since you define the variable <code>file_cmd</code> in a header file that is included in multiple source files, it will be defined in both translation units created from those two source files.</p>

<p>The solution here is to only <strong>declare</strong> the variable in the header file, and <em>define</em> it in a single source file.</p>

<p>For example, do something like this in the header file</p>

<pre><code>struct command_struct
{
    char *cmd_name;
    void (*cmd_pointer)(void);
};

extern struct command_struct file_cmd[];
</code></pre>

<p>Then in one source file (like your ""function file"")</p>

<pre><code>struct command_struct file_cmd[] = {
    // Your initialization...
};
</code></pre></li>
</ol>

<hr>

<p>There are also other problems with your code, some of them will lead to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>.</p>

<p>For example the <code>sizeof</code> operator returns the size <em>in bytes</em>, not the number of elements in an array. To get the number of elements in an array you need to divide the byte-size of the full array with the byte-size of a single element. For example <code>sizeof file_cmd / file_cmd[0]</code>.</p>

<p>Do note that the division only works for <em>real</em> arrays, not pointers, and that arrays very easily decays to pointers (to their first element).</p>
",0
53128321,53128281,2,"<p>You have two <em>very</em> different errors that you really should have asked about in two different question, but I'll be nice and answer both anyway.</p>

<ol>
<li><p>In the <code>main</code> function you have a variable named <code>cmd</code>. It is of type <code>char</code>. You pass it to the <code>call</code> function, which expects an argument of type <code>char *</code> (i.e. a null-terminated string).</p>

<p>To fix this you first need to make sure that <code>cmd</code> is the correct type (i.e. <code>char *</code> instead of plain <code>char</code>). Secondly you need to make sure this pointer is actually pointing to a valid null-terminated byte string.</p>

<p>In other words, something like this:</p>

<pre><code>char *cmd = ""open"";
call(cmd);
</code></pre></li>
<li><p>C really only cares about <a href=""https://en.wikipedia.org/wiki/Translation_unit_(programming)"" rel=""nofollow noreferrer""><em>translation units</em></a>. A translation unit is a single source files with all included header files.</p>

<p>The problem here is that variables can only be <strong>defined</strong> in a single translation unit. And since you define the variable <code>file_cmd</code> in a header file that is included in multiple source files, it will be defined in both translation units created from those two source files.</p>

<p>The solution here is to only <strong>declare</strong> the variable in the header file, and <em>define</em> it in a single source file.</p>

<p>For example, do something like this in the header file</p>

<pre><code>struct command_struct
{
    char *cmd_name;
    void (*cmd_pointer)(void);
};

extern struct command_struct file_cmd[];
</code></pre>

<p>Then in one source file (like your ""function file"")</p>

<pre><code>struct command_struct file_cmd[] = {
    // Your initialization...
};
</code></pre></li>
</ol>

<hr>

<p>There are also other problems with your code, some of them will lead to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>.</p>

<p>For example the <code>sizeof</code> operator returns the size <em>in bytes</em>, not the number of elements in an array. To get the number of elements in an array you need to divide the byte-size of the full array with the byte-size of a single element. For example <code>sizeof file_cmd / file_cmd[0]</code>.</p>

<p>Do note that the division only works for <em>real</em> arrays, not pointers, and that arrays very easily decays to pointers (to their first element).</p>
",0
57808879,57808735,1,"<p>The question can't be answered without clarifying what ""get around this"" means. If you just want the example case to round the way you've shown as expected, though, use <code>double</code> instead of <code>float</code>. (In general, don't use <code>float</code> at all except for bulk storage of samples where total size will become a limiting factor; it's a pathological type.)</p>
",1
53159484,53159451,5,"<p>The original <code>int</code> declaration establishes variables. The subsequent ones create ""shadow"" variables that have the same name but are not the same variable.</p>

<p>Here's a demonstration:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
  int x = 1;

  if (x == 1) {
    int x = 2;
    printf(""x=%d\n"", x);
  }

  printf(""x=%d\n"", x);

  return 0;
}
</code></pre>

<p>This prints:</p>

<pre><code>x=2
x=1
</code></pre>

<p>The top-level <code>x</code> never gets modified, so it appears to revert to the original value.</p>

<p>You should remove the <code>int</code> prefix from those, just assign to the existing variable.</p>

<p>When you say <code>int x = y;</code> in C you are <em>declaring a variable</em> and assigning a value. To assign to an existing variable <code>x = y;</code> is sufficient.</p>

<p>The <code>int</code> prefix is only necessary on the first instance of the variable so the compiler knows what type to use for that and all subsequent references <em>inside the same scope</em>.</p>

<p>Now normally the compiler would complain about creating another variable with the same name if it's done in the same scope. In your case because you're doing it inside an <code>if</code>, technically that's a different scope so you can have duplicates.</p>
",1
58660943,58660861,12,"<p>This code is deeply, perhaps deliberately, confusing.  It contains a narrowly-averted instance of the dread <em>undefined behavior</em>.  It's hard to know whether the person who constructed this question was being very, very clever or very, very stupid.  And the &quot;lesson&quot; this code might purport to teach or quiz you about -- namely, that the unary plus operator doesn't do much -- is not one that's important enough, I would think, to deserve this kind of subversive misdirection.</p>
<p>There are two confusing aspects of the code, the strange condition:</p>
<pre><code>while(+(+k--)!=0)
</code></pre>
<p>and the demented statement it controls:</p>
<pre><code>k=k++;
</code></pre>
<p>I'm going to cover the second part first.</p>
<p>If you have a variable like <code>k</code> that you want to increment by 1, C gives you not one, not two, not three, but four different ways to do it:</p>
<ol>
<li><code>k = k + 1</code></li>
<li><code>k += 1</code></li>
<li><code>++k</code></li>
<li><code>k++</code></li>
</ol>
<p>Despite this bounty (or perhaps because of it), some programmers get confused and cough out contortions like</p>
<pre><code>k = k++;
</code></pre>
<p>If you can't figure out what this is supposed to do, don't worry: no one can.  This expression contains two different attempts to alter <code>k</code>'s value (the <code>k =</code> part, and the <code>k++</code> part), and because there's no rule in C to say which of the attempted modifications &quot;wins&quot;, an expression like this is formally <em>undefined</em>, meaning not only that it has <em>no</em> defined meaning, but that the whole program containing it is suspect.</p>
<p>Now, if you look <em>very</em> carefully, you'll see that in this particular program, the line <code>k = k++</code> doesn't actually get executed, because (as we're about to see) the controlling condition is initially false, so the loop runs 0 times.  So this particular program might not <em>actually</em> be undefined -- but it's still pathologically confusing.</p>
<p>See also <a href=""https://stackoverflow.com/questions/949433"">these canonical SO answers</a> to all questions concerning Undefined Behavior of this sort.</p>
<p>But you didn't ask about the <code>k=k++</code> part.  You asked about the first confusing part, the <code>+(+k--)!=0</code> condition.  This looks strange, because it <em>is</em> strange.  No one would ever write such code in a real program.  So there's not much reason to learn how to understand it.  (Yes, it's true, exploring the boundaries of a system can help you learn about its fine points, but there's a line in my book between imaginative, thought-provoking explorations versus dunderheaded, abusive explorations, and this expression is pretty clearly on the wrong side of that line.)</p>
<p>Anyway, let's examine <code>+(+k--)!=0</code>.  (And after doing so, let's forget all about it.)  Any expression like this has to be understood from the inside out.  I presume you know what</p>
<pre><code>k--
</code></pre>
<p>does.  It takes <code>k</code>'s current value and &quot;returns&quot; it to the rest of the expression, and it more or less simultaneously decrements <code>k</code>, that is, it stores the quantity <code>k-1</code> back into <code>k</code>.</p>
<p>But then what does the <code>+</code> do?  This is <em>unary</em> plus, not binary plus.  It's just like unary minus.  You know that binary minus does subtraction: the expression</p>
<pre><code>a - b
</code></pre>
<p>subtracts b from a.  And you know that unary minus negates things: the expression</p>
<pre><code>-a
</code></pre>
<p>gives you the negative of a.  What unary <code>+</code> does is... basically nothing.  <code>+a</code> gives you <code>a</code>'s value, after changing positive values to positive and negative values to negative.  So the expression</p>
<pre><code>+k--
</code></pre>
<p>gives you whatever <code>k--</code> gave you, that is, <code>k</code>'s old value.</p>
<p>But we're not done, because we have</p>
<pre><code>+(+k--)
</code></pre>
<p>This just takes whatever <code>+k--</code> gave you, and applies unary <code>+</code> to it again.  So it gives you whatever <code>+k--</code> gave you, which was whatever <code>k--</code> gave you, which was <code>k</code>'s old value.</p>
<p>So in the end, the condition</p>
<pre><code>while(+(+k--)!=0)
</code></pre>
<p>does exactly the same thing as the much more ordinary condition</p>
<pre><code>while(k-- != 0)
</code></pre>
<p>would have done.  (It also does the same thing as the even more complicated-looking condition <code>while(+(+(+(+k--)))!=0)</code> would have done.  And those parentheses aren't really necessary; it also does the same thing as <code>while(+ +k--!=0)</code> would have done.)</p>
<p>Even figuring out what the &quot;normal&quot; condition</p>
<pre><code>while(k-- != 0)
</code></pre>
<p>does is kind of tricky.  There are sort of two things going on in this loop: As the loop runs potentially multiple times, we're going to:</p>
<ol>
<li>keep doing <code>k--</code>, to make <code>k</code> smaller and smaller, but also</li>
<li>keep doing the body of the loop, whatever that does.</li>
</ol>
<p>But we do the <code>k--</code> part right away, before (or in the process of) deciding whether to take another trip through the loop.  And remember that <code>k--</code> &quot;returns&quot; the old value of <code>k</code>, before decrementing it.  In this program, the initial value of <code>k</code> <em>is</em> 0.  So <code>k--</code> is going to &quot;return&quot; the old value 0, then update <code>k</code> to -1.  But then the rest of the condition is <code>!= 0</code> -- and it's not true that <code>0 != 0</code>.  That is, 0 <em>is</em> equal to 0, so we won't make any trips through the loop, so we won't try to execute the problematic statement <code>k=k++</code> at all.</p>
<p>In other words, in this particular loop, although I said that &quot;there are sort of two things going on&quot;, it turns out that thing 1 happens one time, but thing 2 happens zero times.</p>
<p>At any rate, I hope it's now adequately clear why this poor excuse for a program ends up printing -1 as the final value of <code>k</code>.  Normally, I don't like to answer quiz questions like this -- it feels like cheating -- but in this case, since I fundamentally disagree with the whole point of the exercise, I don't mind.</p>
",4
59547247,59547011,2,"<p>You never check <code>head</code> for <code>NULL</code> prior to enumeration of the list. If there is no ""there"" there, this:</p>

<pre><code>SinglyLinkedListNode* insertNodeAtTail(SinglyLinkedListNode* head, int data) {
    SinglyLinkedListNode *newNode = (SinglyLinkedListNode*)malloc(sizeof(SinglyLinkedListNode));
    SinglyLinkedListNode *p = head;

    // HERE. If head was NULL then so is p, therefore p-&gt;next is BAD
    while (p-&gt;next != NULL) {
        p = p-&gt;next;
    }
    newNode-&gt;data = data;
    newNode-&gt;next = p-&gt;next;
    p-&gt;next = newNode;
    return head;
}
</code></pre>

<p>There are multiple ways to address this, one simple to understand, one efficient to code. Among the things to consider:</p>

<ol>
<li>Use either a prev-pointer or a pointer-to-pointer solution to acquire the last node in the list.</li>
<li>This is C code. <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">Don't cast <code>malloc</code> in C code</a></li>
</ol>

<p>One possible solution is the following. Though it is easier to understand what is going on, it takes more code than an alternate solution which I'll show in a moment:</p>

<pre><code>SinglyLinkedListNode* insertNodeAtTail(SinglyLinkedListNode* head, int data)
{
    SinglyLinkedListNode *prev = NULL;
    SinglyLinkedListNode *p = head;
    while (p)
    {
        prev = p;
        p = p-&gt;next;
    }

    p = malloc(sizeof *p);
    p-&gt;data = data;
    p-&gt;next = NULL;

    if (prev)
        prev-&gt;next = p;
    else
        head = p;

    return head;
}
</code></pre>

<p>An alternative involves using a pointer to pointer, and utilizing the address of pointers within the list itself, rather than walking by pointer-value. It's more difficult to understand, but considerably less code.</p>

<pre><code>SinglyLinkedListNode* insertNodeAtTail(SinglyLinkedListNode* head, int data)
{
    SinglyLinkedListNode **pp = &amp;head;
    while (*pp)
        pp = &amp;(*pp)-&gt;next;

    *pp = malloc(sizeof **pp);
    (*pp)-&gt;data = data;
    (*pp)-&gt;next = NULL;

    return head;
}
</code></pre>

<p>Note that if <code>head</code> contains <code>NULL</code> on entry, the loop immediately terminates, <code>pp</code> still holds the address of the <code>head</code> pointer, populates it with a new node, then returns whatever <code>head</code> contains (the new node address). If <code>head</code> did <em>not</em> contain <code>NULL</code> on entry then <code>pp</code> contains the address of the last <code>next</code> pointer in the list (which will contain <code>NULL</code>) and the new node is hung right there. In that case <code>head</code> remains unchanged and the original <code>head</code> is simply returned.</p>

<p>Hope it helps.</p>
",1
53146639,53146489,0,"<p>Try</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
  int tabAges[] = {25, 22, 14, 19, 36, 17};
  int tabCoffee[] = {0, 4, 1, 3, 5, 2}; 
  int nbElements = sizeof(tabAges) / sizeof(int);
  int i, j, minCoffee = INT_MAX;

  for(i = 0; i &lt; nbElements; i += 1) {
    if(tabAges[i] &lt; 18)
      if(tabCoffee[i] &lt; minCoffee)
         minCoffee = tabCoffee[i];
  }
  if(minCoffee == INT_MAX) {
    minCoffee = 0;
  }

  printf(""the minimum of coffee drunk by minor is %d"", minCoffee);
  return 0;
}
</code></pre>

<p>Edited per Matt suggestion.</p>
",2
54752980,54752861,4,"<p>The term <em>anonymous struct</em> is already used for something else: in nested structs (or unions) that don't have a name at all and whose fields are referred to as if they were entries in the parent.</p>

<p>The actual question about when to use one or the other is that you have to use the first form if you want to add a pointer to its own type inside it like so: </p>

<pre><code>typedef struct Foo { struct Foo* Child; ... } Foo;
</code></pre>

<p>However, what I would prefer is to do that with a typedef like so:</p>

<pre><code>typedef struct Foo Foo;
struct Foo {Foo* Child;};
</code></pre>
",0
54752954,54752861,7,"<p>It doesn't really matter much. If you use the tagged form you can
have pointers to <code>struct Foo</code> inside <code>struct Foo</code> (AKA Bar)</p>

<pre><code>typedef struct Foo{
  int a;
  struct Foo *foop;
} Bar;
</code></pre>

<p>but there's no way to do that with the second form</p>

<pre><code>typedef struct {
  int a;
  //Baz *p; not valid here since Baz isn't a typename yet
} Baz;
</code></pre>

<p>Some codebases prefer not to use <code>typedef</code>s at all and simply spell out <code>struct Foo</code> with the struct keyword every time.</p>

<p>Also, with the first form, you can refer to the type either via the tag (<code>struct Foo</code>) or with <code>typedefs</code> (<code>Bar</code> or any future/previous <code>typedef</code>s (you can do <code>typedef struct Foo PreviousTypedef;</code> before you provide the definition).</p>

<p>With the second form, on the other hand, you can only use the <code>Baz</code> <code>typedef</code> and possible future <code>typedef</code>s (you can't forward-<code>typedef</code> the struct since it doesn't have a tag).</p>

<p>(Note that <code>typedef</code> doesn't really define types in C. The <code>struct optional_tag { /*...*/ }</code> part does. Rather, <code>typedef</code> provides type aliases (so perhaps it should have been named <code>typealias</code>).)</p>
",0
54752958,54752861,5,"<p>One time where the former is required is if you're making a linked list:</p>

<pre><code>typedef struct list {
    int data;
    struct list *next;
} list;
</code></pre>

<p>The typedef <code>list</code> is not visible inside of the struct definition, so you need to use  the actual struct name to create a pointer to it.</p>

<p>If you don't have such a structure, you can use either one.</p>

<p>What you shouldn't do however is use a tag name that starts with an underscore, i.e.:</p>

<pre><code>typedef struct _list {
    int data;
    struct list *next;
} list;
</code></pre>

<p>Because names starting with a underscore are reserved by the implementation.</p>
",1
54754500,54752861,2,"<p>A lot of other people are focusing on the self referential aspect of this, but another reason to avoid doing this is that due to the lack of namespaces in C. In some circles it is standard practice to <strong>not <code>typedef</code> structs to avoid <code>struct</code> qualifier</strong> and instead refer to structs with the full specifier (eg <code>void foo(struct Foo* foo_ptr)</code>).  So if you wanted to maintain such a style, you wouldn't have the option to abuse anonymous structs, so this:</p>

<pre><code>typedef struct {
  int a;
} Bar;

Bar bar1 = {5};
</code></pre>

<p>should always instead be </p>

<pre><code>struct Bar{
  int a;
};

struct Bar bar1 = {5};
</code></pre>

<p>otherwise you couldn't even compile bar1's instantiation with out <code>typedef</code>ing away the <code>struct</code> qualifier</p>
",7
54642285,54642166,3,"<p><code>DESC(x)</code> is a function-like preprocessor macro.  In your case, it ignores its input and always replaces it with an integer literal <code>1</code>.</p>

<p>I don't know for certain <em>why</em> it's being used this way, but I suspect the author wanted:</p>

<ol>
<li>To add descriptions to sections of code.</li>
<li>To clearly delimit what sections those descriptions apply to (via <code>#if</code> ... <code>#endif</code>).</li>
</ol>

<p>(Most people would use comments for #1, but with just comments sometimes #2 is unclear.)</p>
",4
56451681,56448605,1,"<p>To pass an <em>array</em> to a function, just specify the array name<sup>1</sup>:</p>

<pre><code>arrangef( a );
...
arrangeb( a );
</code></pre>

<p><code>a[n]</code> specifies a single element of the array, and it's one past the <em>last</em> element in the array, so you're passing an expression of the wrong type (the <code>arrange*</code> functions expect <code>int *</code>, you're passing <code>int</code>) and it's outside the bounds of the array, so the value isn't known.  </p>

<p>Except when it is the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, or is a string literal used to initialize a character array in a declaration, an <em>expression</em> of type ""N-element array of <code>T</code>"" is converted (""decays"") to an expression of type ""pointer to <code>T</code>"", and the value of the expression is the address of the first element of the array.</p>

<p>So when you call</p>

<pre><code>arrangef( a );
</code></pre>

<p>the expression <code>a</code> is implicitly converted from ""<code>n</code>-element array of <code>int</code>"" to ""pointer to <code>int</code>"", and the value of the expression is the address of <code>a[0]</code>, so what <code>arrangef</code> actually receives is a pointer value.</p>

<p>In a function parameter declaration, <code>T a[N]</code> and <code>T a[]</code> are ""adjusted"" to <code>T *a</code> - all three declare <code>a</code> as a pointer to <code>T</code>.  </p>

<p>Since all the function receives is the address of the first element of the array, you must also either pass the number of elements as a separate parameter, or one element will have to contain a sentinel value that marks the end of the data (such as the 0 terminator in strings).  In your case, you need to pass the size separately:</p>

<pre><code>void arrangef( int *a, size_t n ) // or int a[]
{
  for ( int i = 0; i &lt; n; i++ ) // don't loop past the last element in the array
  {
    for ( int j = i; j &lt; n; j++ ) 
    {
      int tmp = a[i];
      a[i] = a[j];
      a[j] = tmp;
    }
  }
}
</code></pre>

<p><code>arrangeb</code> will look the same, just with the different ordering.</p>

<p><code>for( i = 0; ; i++ )</code> will loop ""forever"" - it will loop past the end of your array and eventually into memory that you don't own, leading to a runtime error.  <code>i</code> will also eventually overflow, and the behavior on signed integer overflow isn't well-defined.  Basically, that loop <em>will</em> blow up.  </p>

<p><hr>
<sup></p>

<ol>
<li>Actually, you would pass any <em>expression</em> of array type, which gets converted to a pointer type, but for now we'll just stick with the name.
</ol>

<p></sup></p>
",0
56448690,56448605,1,"<pre><code>for (j=1;;j++){
</code></pre>

<p>This line will loop forever and will access <code>*(a+j)</code> in <code>a[i] = a[j]</code> outside the bounds of <code>a</code>.  Similarly with three other loops in your code.  Specify an upper bound:</p>

<pre><code>for (j = 1; j &lt; n; j++) {
</code></pre>

<p>You'll need to pass the size of the array to the function too, and call it with <code>arrangef(a, n);</code>.  At the moment, you are passing the value one after the end of the array to the function, which is expecting a pointer, not a value.</p>
",3
55387408,55385984,3,"<p>Simply make a bit array and set the nth-bit. Then divide by 10 as if the bit array were a little-endian 
number and print the remainders in reverse to get the base-10 representation of your nth-power of two.</p>

<p>This quick program below does it and it's giving me the same results as <code>bc</code>, so I guess it works.
The printing routine could use some tuning.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

uint_least32_t div32(size_t N, uint_least32_t Z[/*N*/], uint_least32_t X[/*N*/], uint_least32_t Y)
{
    uint_least64_t carry; size_t i;
    for(carry=0, i = N-1; i!=-1; i--)
        carry = (carry &lt;&lt; 32) + X[i], Z[i] = carry/Y, carry %= Y;
    return carry;
}

void pr10(uint_least32_t *X, size_t N)
{
    /*very quick and dirty; based on recursion*/
    uint_least32_t rem=0;
    if(!X[N?N-1:0]) return;
    rem = div32(N,X,X,10);
    while(N &amp;&amp; !X[N-1]) N--;
    pr10(X,N);
    putchar(rem+'0');
}
int main(int C, char **V)
{
    uint_least32_t exp = atoi(V[1]);
    size_t nrcells = exp/32+1;
    uint_least32_t *pow  = calloc(sizeof(uint_least32_t),nrcells);
    if(!pow) return perror(0),1;
    else pow[exp/32] = UINT32_C(1)&lt;&lt;(exp%32);
    pr10(pow,nrcells);

}
</code></pre>

<p>Example run:</p>

<pre><code>$ ./a.out 100
1267650600228229401496703205376
</code></pre>
",3
56953504,56953173,1,"<pre><code>`sdl2-config --cflags` head.h
</code></pre>

<p>These bits are suspect. Passing a header file to the compiler is almost certainly wrong.</p>

<p>The rest of the line has linking options, but <code>--cflags</code> spits out compile options. From the looks of it, compiling's already complete.</p>
",1
53179153,53179080,1,"<p>You're not allocating enough space in your matrixes:</p>

<pre><code>matA = (int**)malloc(sizeof(int)*3);
matB = (int**)malloc(sizeof(int)*2);
matC = (int**)malloc(sizeof(int)*3);
</code></pre>

<p>You're allocating space for an array <code>int</code> but you need an array of <code>int *</code>.  Most likely, pointers are larger than integers on your system which means your arrays aren't large enough to hold what you want and you run of the end of the array.  Doing so invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>Allocate space for arrays of <code>int *</code>.  Also, <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">don't cast the return value of <code>malloc</code></a>:</p>

<pre><code>matA = malloc(sizeof(int *)*3);
matB = malloc(sizeof(int *)*2);
matC = malloc(sizeof(int *)*3);
</code></pre>

<p>You're also adding to elements of <code>matC</code> without initializing them.  You should set them to 0 before doing so:</p>

<pre><code>        matC[j][i] = 0;
        for(k = 0; k &lt; 2; k++)
        {
            matC[j][i] += matA[j][k]*matB[k][i];
        }
</code></pre>

<p>You also don't need a cast here:</p>

<pre><code>printf(""%i "",(int**)matC[i][j]);
</code></pre>

<p>Since each <code>matC[i][j]</code> has type <code>int</code> and you're printing an <code>int</code>.  This also invokes undefined behavior because the type of the expression doesn't match the type for the format specifier.</p>
",1
53301416,53300872,1,"<p>If your goal is to sort <code>hand2-&gt;cards</code>, which is of type <code>card_t **</code>, then you need to pass <code>sizeof(card_t*)</code> to <code>qsort</code>, and make sure your comparison function accepts <code>card_t **</code> as inputs.</p>

<p>I.e.</p>

<pre><code>qsort(hand2-&gt;cards, hand2-&gt;n_cards, sizeof *hand2-&gt;cards, card_ptr_comp);
</code></pre>

<p>and</p>

<pre><code>int card_ptr_comp(const void * a, const  void * b)
{
    const card_t* card_a = *(const card_t**)a;
    const card_t* card_b = *(const card_t**)b;

    return card_a-&gt;suit - card_b-&gt;suit;
}
</code></pre>

<p>(Update) </p>

<p>Perhaps this diagram can clarify what you have allocated, after calling <code>add_card_to</code> three times. You will have <code>deck-&gt;cards</code> point to a chunk in memory containing three pointers, and each of the pointers will point to a separately allocated card.</p>

<p>The <code>qsort</code> call is currently reordering the array of pointers, i.e. <strong>swapping the order of pointers inside the array pointed by <code>deck-&gt;cards</code></strong>. It also works by accident, because <code>sizeof(card_t)</code> is equal to <code>sizeof(card_t*)</code> on your 64-bit machine.</p>

<pre><code>                 card_t**
 *deck           .cards  .n_cards 
 +------+       +--------+----+
 |  x---|------&gt;|  x     | 3  |
 +------+       +--------+----+   YOU ARE REORDERING THIS:
                   |              card_t* card_t* card_t*
                   |              +-----+-----+-----+
                   +-------------&gt;|  x  |  y  |  z  |
                                  +-----+-----+-----+
                  .value .suit       |     |     |
                    +----+---+       |     |     |
                    |    |   |&lt;------+     |     |
                    +----+---+             |     |
                                           |     |
                  .value .suit             |     | 
                    +----+---+             |     |
                    |    |   |&lt;------------+     |
                    +----+---+                   |
                                                 |
                  .value .suit                   | 
                    +----+---+                   |
                    |    |   |&lt;------------------+
                    +----+---+                   
</code></pre>

<p>Your <code>add_card_to</code> function is also <strong>copying</strong> struct values to the heap-allocated space. This means that the cards added to the deck are not the same cards as in your main program.</p>

<p>If you are also allocating the cards outside this function, then you need to change the function to simply:</p>

<pre><code>void add_card_to(deck_t * deck, card_t * c)
{
    deck-&gt;n_cards++;
    deck-&gt;cards = realloc(...);
    deck-&gt;cards[deck-&gt;n_cards - 1] = c;
}
</code></pre>
",4
53745045,53744585,1,"<ul>
<li>you don't need <code>atoi()</code> since you are dealing with single characters, not with strings</li>
<li>getc()returns an int [0 .. 255 for actual characters, -1 for EOF]</li>
<li>you can avoid a lot of <code>{}</code> braces by using <code>break</code> and <code>continue</code></li>
</ul>

<hr>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main() {
    int arr[10] = {0};
    int text, num;
   while(1) {
        text = getchar();
        if (text == EOF) break;
        if (!isdigit(text)) continue;
        printf(""text is %c "", text);
        num = text - '0'
        printf(""num is %d\n "",num);
        arr[num]++;
        //printf(""arr[%d] is %d\n"", num, arr[num]);
    }
    for(int i=0; i&lt;10;i++)
    {
        printf(""%d "",arr[i]);
    }

    return 0;
}
</code></pre>
",1
53382831,53382675,1,"<p>You can rewrite your loop to not scan for the final element in your array, and fill that out with the hard-coded value of 100 in your code:</p>

<pre><code>int n[5];
n[4] = 100;
for(i = 0; i &lt; 4; i++)
{
    printf(""Please enter value %d: \n"",i+1);
    scanf("" %d"", &amp;n[i]);
}
</code></pre>

<p>Note that since your <code>for</code> loop no longer asks for a value for <code>n[4]</code> from the user, it doesn't matter whether the line <code>n[4] = 100;</code> comes before or after your loop.</p>
",0
53158513,53158412,1,"<p>This is not correct:</p>

<pre><code>printf(""%d"", ""Enter a number and I will tell you the absolute value: "", a);
</code></pre>

<p>The first argument to <code>printf</code> is a format string, and the following arguments are values that fulfill that format string.  Your format string is  <code>""%d""</code> which means you intend to print an <code>int</code>, but the next argument is a string.</p>

<p>Since you just want to print a string, make that the format:</p>

<pre><code>printf(""Enter a number and I will tell you the absolute value: "");
</code></pre>

<p>This is also a problem:</p>

<pre><code>printf(""My absolute value of %d is %lf\n"", a, absolute(a));
</code></pre>

<p>Because the <code>%lf</code> format specifier expects a <code>double</code> but <code>absolute</code> returns an <code>int</code>.  Because of the variardic nature of <code>printf</code>, the <code>int</code> is not implicitly converted to a <code>double</code>, so you have a format string argument mismatch.  You should use <code>%d</code> instead:</p>

<pre><code>printf(""My absolute value of %d is %d\n"", a, absolute(a));
</code></pre>
",1
54096450,54096374,1,"<p>you're using <code>strcat(path, ""\\"");</code> for both Linux and windows. The path seperator is not the same.</p>

<pre><code>const char separator =
#ifdef _WIN32
                        '\\';
#else
                        '/';
#endif
</code></pre>
",1
53202889,53202844,3,"<p>If you read e.g. <a href=""https://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer"">this <code>printf</code> reference</a> you will see that all floating points format without any modifiers (including plain <code>""%e""</code>) is for the type <code>double</code>.</p>

<p>If you want to print the value of a <code>long double</code> you need the <code>L</code> modifier prefix, as in <code>""%Le""</code>.</p>

<p>Mismatching format specifier and type leads to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>.</p>
",1
54289222,54287492,6,"<p>It is impossible to pass ¦Ð/2 to <code>tan</code> or <code>tanf</code> because ¦Ð is irrational, so any floating-point number, no matter how precise, will be at least slightly different from ¦Ð/2. Therefore, <code>tanf(ValValue)</code> returns the tangent of some value close to ¦Ð/2, and that tangent is large but not infinite.</p>

<p>In the common format used for <code>float</code>, IEEE-754 basic 32-bit binary floating-point, the closest representable number to ¦Ð/2 is 1.57079637050628662109375. The tangent of that number is approximately ?22877332.4289, and the closest value representable in <code>float</code> is ?22877332, which is the result you got. So your <code>tanf</code> is giving you the best possible result for the input number you gave it.</p>
",7
54287550,54287492,3,"<p>The C standard, or indeed the common but by no means ubiquitous IEEE754 floating point standard, give no guarantee of the accuracy of <code>tan</code> (<em>Cf</em> <code>sqrt</code>). An implementation will make a compromise in getting a good result out in a reasonable number of clock cycles.</p>

<p>In particular, the behaviour of the trigonometric function near an asymptote is particularly unpredictable; and that's the case here.</p>

<p>Accepting that the fault is not due to your value of <em>pi</em> (worth a check although note that because <em>pi</em> is transcendental it can't be represented exactly in any floating point system), if you want a well-behaved <code>tan</code> function across the whole domain, you'll be better off using a third party mathematics library.</p>

<p>Finally, note that under IEEE754, you <em>might</em> get more consistent behaviour around an asyptote if you let floating point division deal with the pole, and use</p>

<pre><code>double c = cos(x); tan(x) = sqrt(1 / c / c  - 1);
</code></pre>

<p>This might be more numerically stable, as IEEE754 <em>defines</em> a division by zero.</p>
",5
56099528,56099427,1,"<p>This is not supported by standard C.</p>

<p>For a function parameter type list terminated with an ellipsis, there must be at least one named parameter.</p>

<p>For a function defined with an identifier list, the number of arguments in the call must match the number of parameters in the definition; varying numbers of arguments are not supported.</p>

<p>If you will call a function with a varying number of <code>char *</code> arguments, and that number may be zero, you could declare the function with a dummy first argument that is always passed but never used, as with:</p>

<pre><code>void foo(int dummy,...);
</code></pre>

<p>Note that passing no arguments is a troublesome design. Normally, routines that accept varying numbers of arguments infer the number of arguments from one or more arguments. For example, the first argument might contain the number of remaining arguments, or it might be a format string (as with <code>printf</code>) from which the number and types of remaining arguments can be deduced. If you want a function to accept zero arguments in some situations, it has to have a way of knowing whether it was called with zero arguments or more. That would require information in some global state, which is typically a bad design.</p>
",0
56099562,56099427,0,"<p>C does not provide any mechanism to allow a called function to determine how many arguments were provided. The mechanism must be part of the calling interface.</p>

<p>For example, <code>printf</code> relies on the <code>%</code> format specifications, while <code>execv</code> requires the caller to place a null pointer as the last argument. </p>

<p>A varargs function can be called with no variable arguments, but the caller must not attempt to access any variable argument in that case. For example, the <code>mode</code> argument to the Posix <a href=""http://man7.org/linux/man-pages/man2/open.2.html"" rel=""nofollow noreferrer"">open()</a> function is only consulted in the case that a new file is created, so it need not be supplied if the <code>flags</code> argument doesn't contain the <code>O_CREAT</code> flag (or some other extension flag, such as <code>O_TMPFILE</code> in Linux, which requests file creation).</p>

<p>The variable-length part of the prototype must follow at least one fixed argument. So it is not possible fir a varargs function to be called with no arguments at all.</p>
",0
56099553,56099427,1,"<p>A function with variable arguments must have at least one names argument in order to read the others.</p>

<p>For your particular case, since you want to pass a list of <code>char *</code> arguments you can use NULL to denote the end of the argument list.  So in the case where there is nothing to pass, you just pass a singe NULL argument.</p>
",1
56099678,56099427,0,"<blockquote>
  <p>Can you have in C variable length arguments functions with cases when you don't want to pass any variable?</p>
</blockquote>

<p>Yes. In modern C, Code cannot <em>define</em> a <code>...</code> function with no arguments, yet you can call such a function with no arguments by <em>declaring</em> the a function without function signature. In that way the function can be called with zero arguments.</p>

<hr>

<p>The function still needs some way to understand the count of arguments.  This is often done with the first argument as a count (or <em>format</em>) or a final argument as a sentinel.</p>

<p>Given ""will have passed only <code>char*</code>""...</p>

<pre><code>int foo_count(int counter, ...);    
// zero usage example
foo_count(0);    

int foo_sentinel(char *s);    
// zero usage example
foo_sentinel((char*) NULL);    
</code></pre>

<p>To do so with passing <strong>no</strong> arguments, the count needs to be conveyed in some other fashion, perhaps with a global variable - although this is not recommended.  (Better to simply pass the count.)</p>

<p><em>Declare</em> function:</p>

<pre><code>int foo_count;
int foo(); // no prototype
</code></pre>

<p><em>Call</em> function</p>

<pre><code>foo_count = 0; foo()
foo_count = 1; foo(""one"")
foo_count = 2; foo(""one"", ""two"")
</code></pre>

<p><em>Define</em> the function</p>

<pre><code>int foo(char *s1, ...) {
  if (foo_count &gt; 0) {
    va_list ap;
    va_start(ap, s1);
    puts(s1);
    for (int i=1; i &lt; foo_count; i++) {
      puts(va_arg(ap, char *));
    }
    va_end(ap);
  }
}
</code></pre>
",0
53189453,53189369,2,"<p>Some problems: </p>

<ul>
<li><code>for (i; strlen(str); i++)</code> should be <code>for (i; i&lt;strlen(str); i++)</code>. Though preferably the <code>strlen</code> call should just be made once, before the loop.</li>
<li><code>if (*p == ' ')</code> should result in <code>str2[i] = '-';</code>, <code>else</code> ... <code>str2[i] = *p;</code>.</li>
<li><code>printf(""%s"", &amp;str2);</code> should be <code>str2</code>.</li>
</ul>

<p>Enable compiler warnings, then read &amp; fix them when you encounter them.</p>
",1
54937078,54936938,0,"<p>size of float usually is 32 bit, which is 4 bytes. 'int' is usually 4 bytes  as well, so I assume that what you have.</p>

<p>So, in your case the union consists of a 4 bytes float and 16 bytes of int array. only first 4 bytes (value1[0]) of the array overlaps with the float member.</p>

<p>your union then looks like the following in memory</p>

<pre><code>  addr     int value1[4]    float value2
 00000000  [0]  4 bytes       4 bytes
 00000004  [1]  4 bytes       ---
 00000008  [2]  4 bytes       ---
 0000000C  [3]  4 bytes       ---
</code></pre>

<p>where addr here represents an offset from the stack location provided to you, </p>

<p>When you initialize the float, you also initialize value1[0]. The rest remains uninitialized and is just trash.</p>

<p><code>float</code> is usually represented by encoding defined in IEEE 754 standard (<a href=""https://en.wikipedia.org/wiki/Single-precision_floating-point_format"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Single-precision_floating-point_format</a>) and the bits of it are interepreted by the cpu and the print services. Same bits for <code>int</code> are interpreted differently.</p>

<p>So, your result shows value1[0] which is an <code>int</code> representation of the <code>float</code> bits, and uninitialized values for other members of the array.</p>
",3
54953811,54953796,1,"<p>You're using the function before it's declared. Either forward declare it and declare it after or move the declaration to before <code>main()</code>.</p>

<p>What you've done in your code is forward declare it and then declare it <em>inside <code>main()</code></em> which is not the correct place for that code.</p>

<p>It should be <em>outside</em> of the main function.</p>

<p>The easiest fix here is to eliminate the forward declaration and declare the function right there instead:</p>

<pre><code>#include &lt;stdio.h&gt;

double Calculate_charge(double y)
{
    if (kwh &lt;= 300) {
        y = .09 * kwh;  
    }
    else if (kwh &gt; 300 &amp;&amp;  kwh &lt;= 600){
        y = .08 * kwh;
    }
    else if (kwh &gt; 600 &amp;&amp; kwh &lt;= 1000){
        y = .06 *kwh;
    }
    else {
        y = .05 * kwh;
    }
    return y;
}

int main() {
  // ...

  return 0;
}
</code></pre>
",3
58822324,58819846,3,"<p><em>...""I need to divide the box into grids of length 1, So for 52.1 or 52.9, I need 53, also negative numbers are not my concern.""</em> (from comments)  </p>

<p>Given the corner cases you are willing to accept, this macro will work:</p>

<pre><code>#define CEIL(x) (((x)-(int)(x)) &gt; 0 ? (int)((x)+1) : (int)(x))
</code></pre>

<p>Tested for the following small sample size:</p>

<pre><code>int main(void)
{
    // float num = 4.0;
    // float num = 4.999;
    float num = 4.001;
    int iNum = CEIL(num);

    printf( ""This is a float to int conversion: %d\n"", iNum);

    return 0;
}
</code></pre>
",4
54976439,54975988,2,"<p>Your program has undefined behavior, where you attempt to copy a string into memory referenced by a pointer that was never initialized.  It happens here:</p>

<pre><code>ptrNew = (SolmuTulos*)malloc(sizeof(SolmuTulos));
if (ptrNew == NULL) {
    perror(""Muistin varaus ep?onnistui"");
    exit(1);
}

strcpy(ptrNew-&gt;nimi, nimi);
</code></pre>

<p>Since the <code>nimi</code> member is of type <code>char*</code>, you must allocate sufficient memory to receive the string <code>nimi</code>.  This can be achieved as follows:</p>

<pre><code>ptrNew-&gt;nimi = malloc(strlen(nimi) + 1);
if (ptrNew-&gt;nimi)
    strcpy(ptrNew-&gt;nimi, nimi);
</code></pre>

<p>Alternatively, you could define the <code>nimi</code> member in your struct as <code>char nimi[20]</code>.  I suggest this in response to your comment that states you defined <code>uusinimi</code> as a 20-byte <code>char</code> array.  So, you could change the definition of <code>struct NodeTulos</code> to:</p>

<pre><code>struct NodeTulos {
    char nimi[20];
    float nimia, pitmin, pitmax, pitKA;
    struct NodeTulos *NextTulos;
};
</code></pre>

<p>Which approach you take will depend entirely on your program's requirements.</p>
",0
53168630,53168329,1,"<p>As hellow mentioned, This is bad code and if you are a student, stay away from such programming style (Not just student, everyone should stay away).</p>

<p>What this code does is it creates sort of ""Look-up"" table.
Whenever a number is entered, it increases a count at that array instance.</p>

<p>e.g. If I input 3.2, it increments <code>a[3002]</code> th location. Code for this is:</p>

<pre><code>scanf(""%d.%d"", &amp;x, &amp;y);
        a[x*1000+y]++;
</code></pre>

<p>x = 3 and y = 2 so a[3*1000+2]++ --> a[3002] = 1</p>

<p>(Note: Code assumes that array <code>a</code> is initialized with 0 - another bad habit)</p>

<p>Now say I entered 1.9, code will increment <code>a[1009]</code>. If I enter 3.2 again, <code>a[3002]</code> will be incremented again.</p>

<p>This was input part.</p>

<p>Now code parses entire array <code>a</code> starting from 0. At first it will encounter 1009, code will print <code>1.9</code> and keep on parsing array.
When it finds 7 non=zero locations, loop exits.</p>

<p>When you enter same number again, like 3.2, <code>while(a[i])</code> executes twice printing same number again.</p>

<p>As smaller number will be at lower location in array and array parsing starts from 0, it prints smallest 7 numbers. If you reverse the for loop, you can print 7 biggest numbers.</p>
",0
53168585,53168329,0,"<p>The answer here is how the input data is being stored. </p>

<p>User entered values populate array <code>a</code>. It does not store actual entered numbers, but a COUNT how many times the value was entered (code makes lots of assumptions about data sanity, but lets ignore that)</p>

<p>The data is naturally Sorted from smallest to largest, so to find 7 smallest inputs you just take first 7 values (iterations tracked by index <code>i</code>, <code>c</code> tracks how many values we already did print out) where the COUNT is not zero (<code>a[i]</code>, non zero value indicates how many times user entered corresponding value)</p>
",0
55073115,55072961,0,"<p>So you have 6obvious mistakes.</p>

<ol>
<li>Indent your code.</li>
<li>Only call dup2 in the child processes.</li>
<li>1 not stdout, 0 not stdin.</li>
<li>If execvp fails, call _exit.</li>
<li>wait(NULL) is before the second fork not after</li>
<li>arguments to dup2 are swapped</li>
</ol>

<p>Because this is homework I'm not going to just give you the answer. Get this into shape and ping me and I'll see what more I can find.</p>
",2
53186470,53186394,0,"<p>You are quite close, but the inner loop seems pointless. Once you've found a factor, just store it and keep track of how many you've found:</p>

<pre><code> int factors(int n, int *factors)
 {
  int j = 0;
  for (int i = 2; i &lt; n; ++i)
  {
    if (n % i == 0)
    {
      factors[j++] = i;
    }
  } 
  return j;
}
</code></pre>

<p>I ran this on <code>471113</code>, and got <code>[193, 2441]</code> which checks out.</p>

<p>Do note that this is quite limited by the max precision of <code>int</code> (and should use <code>unsigned long</code> and be safer for real code).</p>
",4
53844398,53844384,2,"<pre><code>    if (characters == ' '){
        while ((characters = getchar()) == ' ');
        putchar(' ');
    }
</code></pre>

<p>This code will keep eating characters until it eats a non-space. But you don't want to eat any non-spaces. A simple fix:</p>

<pre><code>    if (characters == ' '){
        while ((characters = getchar()) == ' ');
        putchar(' ');
        putchar(characters);
    }
</code></pre>

<p>Now you eat characters until you eat a non-space, then you output one space, then you output the non-space character you ate.</p>
",2
52709581,52709508,1,"<p>Strings in C are terminated by a null byte.  So the string ""hello"" actually needs 6 bytes to store: 5 for the letters in ""hello"" and one for the null byte.</p>

<p>The variable <code>x</code> is only 5 bytes wide, so it's not big enough to store the string ""hello"".  As a result, attempting to write this string to <code>x</code> writes past the end of the array.  This invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>, which in this case manifests as writing to an adjacent variable.</p>

<p>Increase the size of <code>x</code> to prevent overrunning the array.  You should also use a field width in the format specifier to specify the maximum number of characters to read:</p>

<pre><code>char x[6];
char y[10];
scanf(""%5s"",x);
scanf(""%9s"",y);
</code></pre>
",0
52709672,52709508,2,"<p>When you declare </p>

<pre><code>char x[5];
char y[10];
</code></pre>

<p>In memory, you have something like:</p>

<pre><code>                     1 1 1 1 1 
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 
+---------+-------------------+
|. . . . .|. . . . . . . . . .| 
+---------+-------------------+
 ^         ^
 \-- x     \-- y
</code></pre>

<p>After the first <code>scanf</code>, you write <code>hello\0</code> in <code>x</code></p>

<pre><code>                     1 1 1 1 1 
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 
+---------+-------------------+
|h e l l o|0 . . . . . . . . .| 
+---------+-------------------+
</code></pre>

<p>After the second <code>scanf</code>, you write <code>world\0</code> in <code>y</code></p>

<pre><code>                     1 1 1 1 1 
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 
+---------+-------------------+
|h e l l o|w o r l d 0 . . . .| 
+---------+-------------------+
</code></pre>

<p>When you type <code>printf(""%s"", x);</code> you ask to type to write from <code>x</code> to
the first <code>\0</code>, so <code>""helloworld""</code> is printed.</p>

<p>When you type <code>printf(""%s"", y);</code> you ask to type to write from <code>y</code> to
the first <code>\0</code>, so <code>""world""</code> is printed.</p>

<p><em>Note:</em></p>

<p>The memory arrangement is not deterministic, you should have all kind of other results, even crashes...</p>

<p>You can find a good tutorial to use <code>scanf</code> here: <a href=""http://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html"" rel=""nofollow noreferrer"">http://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html</a></p>
",0
53281284,53280564,0,"<pre><code>int i=0,j=0,N=4;
int M[N][N];

//for(i; i &lt; N; i++) {
    //for (j; j &lt; N; j++) {
        scanf(""%d"", &amp;M[i][j]); // i = 0; j = 0
    //}
//}


        j++;
        scanf(""%d"", &amp;M[i][j]); // i = 0; j = 1
        j++;
        scanf(""%d"", &amp;M[i][j]); // i = 0; j = 2
        j++;
        scanf(""%d"", &amp;M[i][j]); // i = 0; j = 3
        i++;
        scanf(""%d"", &amp;M[i][j]); // i = 1; j = 3
        i++;
        scanf(""%d"", &amp;M[i][j]); // i = 2; j = 3
</code></pre>
",1
53665288,53664862,0,"<p>You can't return arrays in C. And unfortunately, you cannot return a pointer to VLA either.</p>

<p>This is because the function is declared at file scope and you can't have a VLA there, as it would need to have static storage duration. C doesn't allow this:</p>

<pre><code>// illegal C, syntax error:
int (*create_2D_array(size_t ROW, size_t COL))[ROW][COL]; 
</code></pre>

<p>The solution is to use a pointer to a pointer to an array, then pass that as parameter:</p>

<pre><code>void create_2D_array (size_t ROW, size_t COL, int(**arr)[ROW][COL]);
</code></pre>

<p>Example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void create_2D_array (size_t ROW, size_t COL, int(**arr)[ROW][COL])
{
  *arr = malloc( sizeof(int[ROW][COL]) );

  int(*a)[COL] = **arr; // use tmp pointer to allow a[i][j] syntax
  for(size_t i=0; i&lt;ROW; i++)
  {
    for(size_t j=0; j&lt;COL; j++)
    {
      a[i][j] = i*COL + j;
    }
  }
}

int main (void)
{
  const size_t row = 3;
  const size_t col = 2;

  int(*arr)[row][col];
  create_2D_array(row, col, &amp;arr);

  int(*a)[col] = *arr;
  for(size_t i=0; i&lt;row; i++)
  {
    for(size_t j=0; j&lt;col; j++)
    {
      printf(""%d "", a[i][j]);
    }
    printf(""\n"");
  }

  free(arr);
  return (0);
}
</code></pre>
",6
54365967,54365913,1,"<p>It's fine so long as <code>array</code> has at least <code>asize + 1 + 1</code> bytes allocated to it.</p>

<p>If not then the behaviour of the program will be undefined. In your case, the behaviour <strong>is</strong> undefined as <code>arrayd</code> is a 13 byte array.</p>

<p>Personally I'd like to see the length of <code>array</code> passed as a parameter to the function so you could check at the point of use.</p>

<p>You <em>could</em> build in <code>realloc</code> capabilities into the function, but then you'd need to pass <code>array</code> as a <code>char**</code> so you can modify the pointer and you'd need to concern yourself with the risk of consumers of the original pointer being invalidated.</p>

<p>Finally, passing NUL for <code>c</code> is essentially a no-op; I'd deal with that explicitly if I were you.</p>
",0
52713658,52713221,0,"<p><code>x1=arr[0];</code> does not establish a relationship.  It does the assignment at that point, not based on some later value of <code>arr[0]</code>.</p>

<p>Move the following earlier in code:</p>

<pre><code>printf(""Please enter value of your three vertex x1 y1 x2 y2 x3 y3: \n"");
for(i=0; i&lt;6; i++) {
  scanf(""%f"", &amp;arr[i]);
}
</code></pre>

<p>Then assign</p>

<pre><code>x1=arr[0];
y1=arr[1];
x2=arr[2];
y2=arr[3];
x3=arr[4];
y3=arr[5];
</code></pre>
",0
52770240,52770206,1,"<p>As with a lot of things in C, you de-reference the pointer, and the easiest way is by treating it as an array:</p>

<pre><code>char** arguments = argv;
char* first_argument = argv[0];
char first_letter = argv[0][0];
</code></pre>

<p>This is also equivalent to:</p>

<pre><code>char first_letter = first_argument[0];
</code></pre>

<p>And you can go in reverse by assigning the address of something to a pointer:</p>

<pre><code>char* argument = &amp;first_letter;
</code></pre>

<p>Your attempt is this:</p>

<pre><code>argv[1[2]]
</code></pre>

<p>Which implies there's some value like this:</p>

<pre><code>int i = 1[2];
argv[i];
</code></pre>

<p>Where <code>1[2]</code> is not something C can deal with.</p>
",0
55020744,55020533,4,"<p>Despite shoving all the logic into one line, the problem is actually in one expression (pardon me for adding spaces):</p>

<pre><code>(n%2) ? n=3*n+1 : n/=2
</code></pre>

<p>The <a href=""https://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer"">precedence rules for C expressions</a> are like that. Assignment (and that includes compound assignment) binds less tightly than <code>?:</code>. So the compiler has to interpret what you wrote as:</p>

<pre><code>((n%2) ? n=3*n+1 : n) /=2
</code></pre>

<p>Since <code>?:</code> doesn't produce an lvalue (something that can appear on the left of an assignment), you get an error. Your use of parentheses forces the precedence to match what you wanted.</p>

<p>But an even better way to write that is to not be ""clever"" and think there is some ""elegance"" in using as much tokens as possible in a single expression. Here's another version, which is far more readable, and easier to verify as correct:</p>

<pre><code>if (n%2) {
    n = 3*n+1;
} else {
    n /= 2;
}
</code></pre>

<p>And it's no less efficient than using a conditional expression.</p>
",0
53554698,53554498,2,"<p>The typedef defines a function type. It is not terribly useful in itself, but it allows us to declare a function pointer to that type, just as we declare a normal object pointer. And that's what <code>string * stringptr;</code> does - declaring a function pointer to a function of the form <code>void string(char * str,int num);</code></p>
",3
52808720,52808624,0,"<p>I help teach people how to code, this is a common problem.</p>

<p>The answer is... to just start.</p>

<p>You know roughly where to start, you know the basic structures, that's all you need.</p>

<p>Don't try to do it all in one go, just take a small step, test that it worked, then take another one.</p>

<p>You will make mistakes, things won't work, that is entirely normal and expected. Learning to code is a bit like learning to walk by doing a marathon, you stumble, you fall flat on your face but you just have to pick yourself up and throw yourself forward again. Every time you try you will be able to run a bit further, the progress can be exhilarating.</p>

<p><strong>Edit:</strong> Responding to the Q's edit, specifically asking how to reroll.</p>

<p>So to roll the second dice, you have the following line of code:</p>

<pre><code>die2 = rand() % 6 + 1;
</code></pre>

<p>To reroll it, use the same line.</p>

<p>Eventually you are going to want to transition the code to using an array for the six dice. This will allow for more dynamic and smarter code with less repetition. But that is version two, small steps, get something working, then get something else working, then tweak them to work better etc.</p>
",4
55315833,55315748,2,"<p>A ""flag"" variable is simply a boolean variable whose contents is ""true"" or ""false"".</p>

<p>You can use either the <code>bool</code> type with <code>true</code> or <code>false</code>, or an integer variable with zero for ""false"" and non-zero for ""true"".</p>
",0
59323428,59323373,6,"<p>""<code>long</code> stores much more information"" is simply incorrect. If <code>long</code> is 32-bit (which I believe it is on Windows/MSVC), it stores far less information, and if it's 64-bit, it stores the same amount of information, since <code>double</code> is 64-bit, but uses/interprets that information in a different way (as sign/exponent/mantissa).</p>

<p>However this is largely aside from the point. C does not define the behavior if the actual argument types to <code>printf</code> mismatch the format specifiers, and in practice mismatching them will not produce reasonable/meaningful results. Don't do it. Either use the right format specifier matching the type you have, or cast to the type you want it formatted as (being aware that the cast may lose information).</p>
",0
59323483,59323373,3,"<p>The reason it's not strictly a warning is because <code>printf</code> is a variadic function where the types of all arguments after the first are not specified.  </p>

<p>Because <code>printf</code> is a known function with well defined semantics, the compiler can do additional optional checks of the arguments against the format string.  The compiler is not required to perform these checks hence it generates a warning instead of an error.  </p>

<p>Also, there are cases where you can ""get away"" with a mismatch if two types have the same size and representation, for example <code>long</code> and <code>long long</code> on systems where both are 8 bytes in size.</p>

<p>That being said, parameters must match the format specifier.  Failing to do so invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.  This is mainly because the variadic nature of the <code>printf</code> function means that its arguments can't be implicitly converted from one type to another.</p>

<p>As an example, take an x64 Linux system where both <code>double</code> and <code>long</code> are 8 bytes.  The way these two types represent values is very different so the value that might be printed would not be what you expect.  Also, in this environment integer values are typically passed to functions on the stack while floating point values are passed via floating point registers, so if you pass a <code>double</code> when the function is expecting a <code>long</code> or vice versa it won't even be reading in the right place.</p>
",0
53519917,53512115,2,"<p>The goal you have requested is a Bad Idea, and there is almost certainly a better way of achieving the actual goal that motivated this notion.</p>

<p>That said, one way of implementing this that is less bad than some others is to use an array of offsets as <a href=""https://stackoverflow.com/users/1553090/paddy"">paddy</a> suggested:</p>

<pre><code>struct tindex
{
    char* fcode;
    char* fdesc;
    int fstartidx;
    int fsize;
    char* ftype;
    char* precision;
    char* fcons;
    char* notnull;
    char* ronly;
    char* wdth;
    char* res2;
    char* cel;
    char* flr;
};


#include &lt;stddef.h&gt;


void *LookupField(struct tindex *p, int index)
{
    static const size_t Offsets[] =
    {
        offsetof(struct tindex, fcode),
        offsetof(struct tindex, fdesc),
        offsetof(struct tindex, fstartidx),
        offsetof(struct tindex, fsize),
        offsetof(struct tindex, ftype),
        offsetof(struct tindex, precision),
        offsetof(struct tindex, fcons),
        offsetof(struct tindex, notnull),
        offsetof(struct tindex, ronly),
        offsetof(struct tindex, wdth),
        offsetof(struct tindex, res2),
        offsetof(struct tindex, cel),
        offsetof(struct tindex, flr),
    };

    return (char *) p + Offsets[index];
}


#include &lt;stdio.h&gt;


int main(void)
{
    struct tindex t;
    printf(""%p = %p.\n"", (void *) &amp;t.fcode, LookupField(&amp;t, 0));
    printf(""%p = %p.\n"", (void *) &amp;t.fcons, LookupField(&amp;t, 6));
    printf(""%p = %p.\n"", (void *) &amp;t.flr, LookupField(&amp;t, 12));
}
</code></pre>

<p>Note that the address is returned only as a <code>void *</code> because there are different types in the structure. You still need some mechanism to handle the different types.</p>
",0
52808866,52808754,0,"<p>There are many compiler error in your code. Here is my first try to fix it</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#define TRUE 1
#define FALSE 0
#define N 25 //number of lines

typedef struct CHANNEL_ {
    char name[50];
    double n;//roughness coefficient
    double S;//channel slope
    double B;//width
    double D;//maxDepth
} CHANNEL;

double computeVelocity(CHANNEL, double);
void getPositiveValue(CHANNEL);
void displayTable(CHANNEL);

int main(void) {
    CHANNEL CHAN;

    printf(""Enter the name of the channel: "");
    fgets(CHAN.name, 50, stdin);
    getPositiveValue(CHAN);
    printf(""Channel data for %s\n Coefficient of roughness: %lf\n Slope: %lf\n Width: %lf\n Maximum depth: %lf\n"", CHAN.name, CHAN.n, CHAN.S, CHAN.B, CHAN.D);
    printf(""Depth    Average Velocity\n"");
    displayTable(CHAN); //function call to display the table with values
}

void getPositiveValue(CHANNEL CHAN) {
    int Flag; //sentinel
    do {
        Flag = FALSE;
        printf(""Give the coefficient for roughness: \n Give the slope: \n Give the channel width: \n Give the maximum depth of the channel: "");
        scanf(""%lf %lf %lf %lf"", &amp;CHAN.n, &amp;CHAN.S, &amp;CHAN.B, &amp;CHAN.D);
        if(CHAN.n &lt; 0 || CHAN.S &lt; 0 || CHAN.B &lt; 0 || CHAN.D &lt; 0) {
            Flag = TRUE;
            printf(""The values must be positive.\n"");
        }
    } while(Flag == TRUE);
}

void displayTable(CHANNEL CHAN) {
    double increment = CHAN.D/N;
    double H = 0; //depth
    double arraydepth[N];
    double arrayvelocity[N];
    int i;
    for ( i = 0; i &lt; N; i++) {
        H += increment;
        arrayvelocity[i] = computeVelocity(CHAN, H);
        arraydepth[i] = H;
        printf(""%lf %lf\n"", arraydepth[i], arrayvelocity[i]);
    }
}

double computeVelocity(CHANNEL CHAN, double H)
{
    double U;
    U = CHAN.B / H;
    U = U / (CHAN.B + (2 * H));
    U = pow(U, (2 / 3));
    U = U / CHAN.n;
    U = U * (sqrt(CHAN.S));

    return U;
}
</code></pre>

<p>The first error would be <code>struct</code> definition. In C, you can define the <code>struct</code> and at the same time define a variable. But you should not use the same name to confuse yourself and the compiler. Also you need to understand <code>void</code> function does not return a value and cannot be on the right side of an <code>=</code> expression. </p>

<p>Use <code>typedef</code> can save you to type <code>struct</code> keyword each time you need it. You also need to use <code>%s</code> to output a string. Also typos here and there.</p>
",4
53594458,53594278,2,"<p><code>srand</code> wants an <code>unsigned int</code> as argument, but <code>time</code> returns a <code>time_t</code> which is a larger type than <code>unsigned int</code> on your platform, hence the warning <em>possible loss of data.</em></p>

<p>In this case the warning can be ignored, because you actually just want to give a seemingly random value to <code>srand</code>.</p>

<p>To get rid of the warning you can cast the value returned by <code>time</code> to <code>unsigned int</code>:</p>

<pre><code>srand((unsigned int)time(NULL));
</code></pre>
",0
53594458,53594278,2,"<p><code>srand</code> wants an <code>unsigned int</code> as argument, but <code>time</code> returns a <code>time_t</code> which is a larger type than <code>unsigned int</code> on your platform, hence the warning <em>possible loss of data.</em></p>

<p>In this case the warning can be ignored, because you actually just want to give a seemingly random value to <code>srand</code>.</p>

<p>To get rid of the warning you can cast the value returned by <code>time</code> to <code>unsigned int</code>:</p>

<pre><code>srand((unsigned int)time(NULL));
</code></pre>
",0
53482414,53482342,5,"<p>The compiler knows!</p>

<pre><code>$ gcc -Wall temp.c
temp.c:9:23: warning: format specifies type 'float *' but the argument has type 'double *' [-Wformat]
scanf(""%1f %1f, %1f"", &amp;n1, &amp;n2, &amp;n3);
       ~~~            ^~~
       %1lf
temp.c:9:28: warning: format specifies type 'float *' but the argument has type 'double *' [-Wformat]
scanf(""%1f %1f, %1f"", &amp;n1, &amp;n2, &amp;n3);
           ~~~             ^~~
           %1lf
temp.c:9:33: warning: format specifies type 'float *' but the argument has type 'double *' [-Wformat]
scanf(""%1f %1f, %1f"", &amp;n1, &amp;n2, &amp;n3);
                ~~~             ^~~
                %1lf
3 warnings generated.
</code></pre>
",1
53376994,53376810,5,"<p>The statements <code>if ( ""string2 = yes"" )</code> and <code>while ( ""string2 = yes"" )</code> are indeed the problems.  <code>""string2 = yes""</code> is simply a string, and in a boolean context such as above evaluates to <code>true</code> (or, more accurately, <code>not false</code>).  </p>

<p>To compare string values, you have to use the library function <code>strcmp</code> (neither the <code>=</code> assignment nor <code>==</code> comparison operators are defined for strings or any other array expressions):</p>

<pre><code>if ( strcmp( string2, ""yes"" ) == 0 ) // strcmp returns 0 if the arguments are equal
{
  // do something if string2 is equal to yes
}

do
{
  // loop at least once, repeat if string2 is equal to ""yes""
} while( strcmp( string2, ""yes"" ) == 0 );
</code></pre>

<p>You could also write those as <code>if ( !strcmp( string2, ""yes"" ) )</code> and <code>while ( !strcmp( string2, ""yes"" ) )</code>.  </p>
",4
53384530,53384055,3,"<p>It's actually a bit of a leading question, because it presumes that everything will be in memory.</p>

<p>Local variables, as well as temporary values without a name, are only placed on the stack <em>if necessary</em>. There are different reasons why that might be necessary, for example:</p>

<ul>
<li>The compiler is dumb or made to act dumb by compiling at the lowest possible optimization level.</li>
<li>The target machine has an odd architecture without (or very few) registers (rare).</li>
<li>There are too many local variables and temporary values live simultaneously to fit them all into registers at that point in the program, so some of them get ""spilled"". Being spilled is not a property of a variable exactly, but rather of a specific live range. In some sense a variable can therefore move around (if it has multiple associated live ranges and they get allocated differently) and even be in multiple places simultaneously (depending on how you count temporary copies, or unambiguously when loop unrolling is involved).</li>
<li>The address of the local variable is taken and used in such a way that the compiler cannot prove that the variable does not need to be in memory (may induce live range splitting so the variable is only actually in memory temporarily).</li>
</ul>

<p>Most likely none of the above apply (the last item definitely does not apply, the address is not taken) so we should expect <code>cPtr</code> to spend its entire lifetime in registers.</p>

<p>Testing it out on <a href=""https://gcc.godbolt.org/z/ssYXfj"" rel=""nofollow noreferrer"">clang</a> targeting x64 we might get code like this:</p>

<pre><code>main:                                   # @main
    push    rbx
    mov     edi, 23
    call    malloc
    mov     rbx, rax

    ; at this point, rbx roughly corresponds to cPtr
    ; it's also still in rax but rax is overwritten by the next operation

    movabs  rax, 32777976875610985 ; btw this weird number is a piece of string
    mov     qword ptr [rbx + 15], rax
    movups  xmm0, xmmword ptr [rip + .L.str]
    movups  xmmword ptr [rbx], xmm0

    ; rbx (cPtr) is copied to rdi in order to give it to puts as argument

    mov     rdi, rbx
    call    puts
    mov     rdi, rbx
    call    free
    xor     eax, eax
    pop     rbx
    ret
.L.str:
    .asciz  ""Good luck on this test""
</code></pre>

<p>Targeting MIPS or ARM or PowerPC with eg GCC shows a similar pattern of <code>cPtr</code> not being on the stack but in a register (or several registers, depending on how you count), though of course the code looks pretty different.</p>

<p>A fun detail of the code above is that while the entire string does appear in a data segment (rodata), a piece of it also appears in the code segment as the immediate operand of that <code>movabs</code>.</p>
",0
54832160,54832080,2,"<p>The expression <code>958657431*100</code> is evaluated as an <code>int</code>, not as a <code>long long int</code>.</p>

<p>It seems that on your platform, an <code>int</code> cannot hold the value <code>95865743100</code>. Hence you get something else.</p>

<p>Use </p>

<pre><code>x = 958657431LL * 100;
</code></pre>

<p>to get the multiplication to be done on <code>long long int</code> instead of <code>int</code>.</p>
",6
58630664,58630270,6,"<p><code>sleep(0)</code> and probably <code>nanosleep</code> with zero provide a mechanism for a thread to surrender the rest of its timeslice. This effectively is a thread yield. So when calling <code>sleep(0)</code> we enter kernel mode and places the thread onto the ""runnable"" queue. The thread then is scheduled to resume when the next available timeslot comes available. When this happens is left entirely up to the operating system.</p>

<p>One usecase (maybe not the best usecase) for this is a userspace spinlock. When ""spinning while waiting for a resource, we call sleep(0). This allows the task that may release the resource to be scheduled allowing the lock to be released quicker.</p>
",1
53489292,53489231,3,"<p>I think you meant this;</p>

<pre><code>scanf(""%d"" ,&amp;n); --&gt;  scanf(""%d"" ,&amp;choice);
</code></pre>
",0
53508824,53508753,7,"<pre><code>struct USER {
   int human_id_number;
   char first_name_letter;
   int minutes_since_sneezing;
} *administrator;
</code></pre>

<p>This isn't just a struct declaration, it's also a variable declaration... it's the same as:</p>

<pre><code>struct USER {
   int human_id_number;
   char first_name_letter;
   int minutes_since_sneezing;
};

struct USER *administrator;
</code></pre>

<p>So, when you subsequently use <code>sizeof(administrator)</code>, you'll get ""<em>the size of a pointer</em>""... which is most likely <em>not</em> what you want.</p>

<p>You <em>probably</em> wanted to do something more like this:</p>

<pre><code>struct USER {
   int human_id_number;
   char first_name_letter;
   int minutes_since_sneezing;
};

int main(void) {
    struct USER *administrator;

    administrator = malloc(sizeof(*administrator));
    /* - or - */
    administrator = malloc(sizeof(struct USER));

    /* check that some memory was actually allocated */
    if (administrator == NULL) {
        fprintf(stderr, ""Error: malloc() returned NULL...\n"");
        return 1;
    }

    /* ... */

    /* don't forget to free! */
    free(administrator)

    return 0;
}
</code></pre>

<p><code>sizeof(*administrator)</code> and <code>sizeof(struct USER)</code> will both give you ""<em>the size of the USER structure</em>"", and thus, the result of <code>malloc()</code> will be a pointer to enough memory to hold the structure's data.</p>
",4
59342920,59342900,2,"<p>The line:</p>

<p><code>char* addr = text;</code></p>

<p>in this line <code>addr</code> is a <strong>local variable</strong> <em>shadowing</em> the global variable. So, no, you are not changing the global one. Replace the line with</p>

<p><code>addr = text;</code></p>

<p>for changing the global variable.</p>
",0
53569642,53569239,1,"<blockquote>
  <p>[...] functions of the form void func() take infinitely many arguments.</p>
</blockquote>

<p>Nope.</p>

<p>Functions used without a prototype <strong>must</strong> be called according to their definition.</p>

<pre><code>void foo(); // not a prototype
int main(void) {
    // foo() must be called according to its definition
    foo(12, 4, ""bar"", -42); // error (undetected by compiler)
    foo(""---"", 12, 4, ""bar"", -42); // no error
}
void foo(const char *msg, int n, ...) { /* ... */ }
</code></pre>

<p>Note that pre-C89 function definitions had a different way of defining arguments. Desire for backwards compatability still allows for this syntax. I believe the same restrictions apply as above</p>

<pre><code>void bar() /* pre-C89 syntax */
const char *msg;
int n;
{ /* ... */ }
</code></pre>
",0
52917625,52917279,1,"<p>Rather than printing little by little, try and print all numbers in one statement.</p>

<p>For that you may need to rewrite your function a little bit.</p>

<p>Here's my attempt</p>

<pre><code>#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

void printCombs2(int n, int k) {
    int limit = ceil(sqrt(n));
    for (int i = 1; i &lt; limit; i++) {
        for (int j = i; j &lt; limit; j++) {
            if (i*i + j*j == n) {
//                printf(""%d, %d, %d\n"", i, j, k);
                printf(""%d, %d, %d ==&gt; %d+%d+%d=%d\n"", i, j, k, i*i, j*j, k*k, i*i+j*j+k*k);
            }
        }
    }
}

void printCombs(int n) {
    printf(""combs(%d):\n"", n);
    int limit = ceil(sqrt(n));
    for (int i = 1; i &lt; limit; i++) {
        for (int j = i; j &lt; limit; j++) {
            if (i*i + j*j == n) {
//                printf(""%d, %d\n"", i, j);
                printf(""%d, %d ==&gt; %d+%d=%d\n"", i, j, i*i, j*j, i*i+j*j);
                printCombs2(i*i, j);
                printCombs2(j*j, i);
            }
        }
    }
    puts("""");
}

int main(void) {
    printCombs(100);
    printCombs(1000);
    printCombs(10000);

    return 0;
}
</code></pre>

<p>see it <a href=""https://ideone.com/wjd59G"" rel=""nofollow noreferrer"">running on ideone.com</a></p>

<pre>combs(100):
6, 8 ==> 36+64=100

combs(1000):
10, 30 ==> 100+900=1000
6, 8, 30 ==> 36+64+900=1000
18, 24, 10 ==> 324+576+100=1000
18, 26 ==> 324+676=1000
10, 24, 18 ==> 100+576+324=1000

combs(10000):
28, 96 ==> 784+9216=10000
60, 80 ==> 3600+6400=10000
36, 48, 80 ==> 1296+2304+6400=10000
48, 64, 60 ==> 2304+4096+3600=10000</pre>
",2
55068221,55067457,0,"<p>This is working code for <code>fill_array</code>.:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define NUMBERTHRESHOLD 5

int *fill_array(int *nbvalues)
{
  int *array_ptr = NULL;  // hint: read up the specs of realloc
  int actualsize = 0;    // actual size of dynamic array
  int index = 0;         // index of next number to be stored in array

  // initially the array is ""full"", it contains zero numbers
  // and there is there is space left for zero numbers

  while (1)          // loop forever
  {
    int v;
    scanf(""%d"", &amp;v);

    if (v == 0)
      break;           // user entered 0 =&gt; we stop the loop

    if (actualsize == index)
    {
      // the array is full, we need to allocate space for NUMBERTHRESHOLD more numbers
      actualsize += NUMBERTHRESHOLD;
      array_ptr = realloc(array_ptr, actualsize * sizeof(int));   // reallocate memory
    }

    array_ptr[index++] = v; // store number entered by user
  }

  *nbvalues = index - 1;   // index - 1 is the actual number of numbers in array
  return array_ptr;        // return the pointer to first element of array
}

int main(void)
{
  int nbvalues;
  int *array_ptr = fill_array(&amp;nbvalues);
}
</code></pre>

<p>Things that need to be done:</p>

<ul>
<li>you need to write the <code>print_array</code> function and call it</li>
<li>you need to free the memory</li>
<li>there is absolutely no error checking done (which is fine for a first shot)</li>
</ul>
",0
55067696,55067457,3,"<p>This function doesn't make sense:</p>

<pre><code>void *add_memory(int a)
{

  void *array_ptr = realloc(array_ptr, a * sizeof(int));
  return array_ptr;
}
</code></pre>

<p>You may call <code>realloc</code> only upon a pointer that has been previously allocated by <code>malloc</code>, <code>calloc</code>, or another <code>realloc</code> or upon a <code>NULL</code> pointer. In your code <code>array_ptr</code> hasn't been initialized, and calling <code>realloc</code> with an uninitialized pointer will not end well.</p>

<p>But the overall structure of your program is very poor and there are certainly other issues than the one in the answers. </p>
",2
53433534,53433366,0,"<p>As other people suggested you should be using <code>==</code> to compare, <code>=</code> is used to assign values to variables. As it seems to me, <code>A</code>, <code>B</code> and <code>C</code> are angles and the first check that you do is that you check if it is the case of valid triangle. If that's the case simply apply the suggested modification:</p>

<pre><code>if (A + B + C == triagolnik)
    printf(""DA\n"");
</code></pre>

<p>In the second check, thanks to the same language, I seem to understand that you want to check whether the triangle is <code>right</code> one. If that's the case I don't see why you are mentioning the number 80, as the correct one should be 90. The correct check for <code>right</code> triangle would be:</p>

<pre><code>if (A + B + C == triagolnik &amp;&amp; (A == 90 || B == 90 || C == 90))
    printf(""PRAVOAGOLEN\n"");
</code></pre>
",3
52990716,52989470,4,"<p>In addition to other answers,</p>

<pre><code>unsigned int d = {1,2,3};
</code></pre>

<p>(after macro substitution)</p>

<p>is not valid in C. It violates <a href=""https://port70.net/~nsz/c/c11/n1570.html#6.7.9p2"" rel=""nofollow noreferrer"">6.7.9 Initialization</a>:</p>

<blockquote>
  <p>No initializer shall attempt to provide a value for an object not contained within the entity being initialized.</p>
</blockquote>

<p>With stricter compilation options (<code>gcc -std=c17 -Wall -Wextra -pedantic test.c</code>), gcc produces:</p>

<pre><code>warning: excess elements in scalar initializer
     unsigned int d = {1,2,3};
                         ^
</code></pre>

<p>However, note that </p>

<pre><code>unsigned int d = {1};
</code></pre>

<p>is valid because <a href=""https://port70.net/~nsz/c/c11/n1570.html#6.7.9p11"" rel=""nofollow noreferrer"">initializing scalar with braces</a> is allowed. Just the extra initializer values that's the problem with the former snippet.</p>
",0
52991172,52989470,1,"<p>For <code>c</code>, the initializer is an expression, and its value is 3. For <code>d</code>, the initializer is a list in braces, and it provides too many values, of which only the first is used.</p>

<p>After macro expansion, the definitions of <code>c</code> and <code>d</code> are:</p>

<pre><code>unsigned int c = (1,2,3);
unsigned int d = {1,2,3};
</code></pre>

<p>In the C grammar, the <em>initializer</em> that appears after <code>unsigned int c =</code> or <code>unsigned int d =</code> may be either an <em>assignment-expression</em> or <code>{</code> <em>initializer-list</em> <code>}</code> (and may have a final comma in that list). (This comes from C 2018 6.7.9 1.)</p>

<p>In the first line, <code>(1,2,3)</code> is an <em>assignment-expression</em>. In particular, it is a <em>primary-expression</em> of the form <code>(</code> <em>expression</em> <code>)</code>. In that, the <em>expression</em> uses the comma operator; it has the form <em>expression</em> <code>,</code> <em>assignment-expression</em>. I will omit the continued expansion of the grammar. Suffice it to say that <code>1,2,3</code> is an expression built with comma operators, and the value of the comma operator is simply its right-hand operand. So the value of <code>1,2</code> is 2, and the value of <code>1,2,3</code> is 3. And the value of the parentheses expression is the value of the expression inside it, so the value of <code>(1,2,3)</code> is 3. Therefore, <code>c</code> is initialized to 3.</p>

<p>In contrast, in the second line, <code>{1,2,3}</code> is <code>{</code> <em>initializer-list</em> <code>}</code>. According to the text in C clause 6.7.9, the <em>initializer-list</em> provides values used to initialize the object being defined. The <code>{</code> ¡­ <code>}</code> form is provided to initialize arrays and structures, but it can be used to initialize scalar objects too. If we wrote <code>unsigned int d = {1};</code>, this would initialize <code>d</code> to 1.</p>

<p>However, 6.7.9 2 is a constraint that says ¡°No initializer shall attempt to provide a value for an object not contained within the entity being initialized.¡± This means you may not provide more initial values than there are things to be initialized. Therefore, <code>unsigned int d = {1,2,3};</code> violates the constraint. A compiler is required to produce a diagnostic message. Additionally, your compiler seems to have gone on and used only the first value in the list to initialize <code>d</code>. The others were superfluous and were ignored.</p>

<p>(Additionally, 6.7.9 11 says ¡°The initializer for a scalar shall be a single expression, optionally enclosed in braces.¡±)</p>
",0
53005029,53004680,1,"<p>First: a ""3D character array"" is better thought of as a ""2D string matrix"" in this case.</p>

<p>And yes, of course it's very possible.</p>

<p>There are some weaknesses with your code that might trip it up, hard to say since you don't show a full test case with the input data you provide.</p>

<ol>
<li><code>scanf()</code> can fail, in which case you cannot rely on the variables having values</li>
<li><code>scanf()</code> with <code>%s</code> will stop on the first whitespace character, which might cause your scanning code to become very confused</li>
<li>You don't limit the size of string you scan, but only provide 10 bytes of buffer space per string, so easy to get buffer overruns.</li>
</ol>

<p>A better solution would be to check that the scanning succeeded, and make each string be on a line on its own, and read full lines using <code>fgets()</code> into an appropriately-sized buffer, then perhaps copy the part you want to keep into place in the matrix.</p>
",0
53551380,53551362,1,"<p><code>|</code> is bitwise or, <code>&lt;&lt;</code> is left shift.</p>

<p>Wikipedia has an article on <a href=""https://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B"" rel=""nofollow noreferrer"">Operators in C and C++</a> which might be worth a look.  It's the first result I got when searching for ""c operators"" (without the quotes)¡­</p>
",0
53659288,53659223,3,"<p><code>¨d</code> is a character with code <code>0xCC</code> in the OEM 850 codepage.</p>

<p>In debug builds, Visual C initializes uninitialized data with <code>0xCC</code> to help you detect uninitialized data.</p>

<p>You should initialize the array.</p>

<pre><code>char pol[100] = {0};
</code></pre>

<p>or</p>

<pre><code>char pol[100] = ""test data"";
</code></pre>
",3
53659250,53659223,1,"<p><em>When I intialize a string:</em>...  </p>

<p>The variable <code>pol</code> has not been initialized, only declared, and as such, because of the definition of <em><a href=""https://www.tutorialspoint.com/cprogramming/c_strings.htm"" rel=""nofollow noreferrer"">C string</a></em>, may or may not even be a <code>string</code> at this point. Using it in this state (eg. in a <code>printf()</code> statement) is dangerous as it can invoke <em><a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a></em>.  </p>

<p>Change this:</p>

<pre><code>char pol[100];
</code></pre>

<p>to This</p>

<pre><code>char pol[100] = {0};//initializes entire array to `0`.
</code></pre>

<p>or this for example:</p>

<pre><code>char pol[100] = {""temporary""};//initializes to |t|e|m|p|o|r|a|r|y|0|?|?|?|?|
                              //which is a null terminated string
</code></pre>
",0
54697241,54696992,1,"<p>You don't initialize your variables so initially they contain random bogus values.
That's not a problem for <code>andrewGrapes</code>, <code>dmitryGrapes</code>, <code>michalGrapes</code>, <code>greenGrapes</code>, <code>purpleGrapes</code> and <code>blackGrapes</code> because they will each be assigned a value by <code>scanf</code> (assuming each call succeeds).</p>

<p>However, <code>andrewCheck</code> will only be assigned a value when <code>if (greenGrapes &gt;= andrewGrapes)</code> is true. <code>dmitryCheck</code> will only be assigned a value if <code>if (greenGrapes + purpleGrapes &gt;= dmitryGrapes)</code> is true.</p>

<p>If any or both conditions are not true the respective variable will retain it's random bogus value and when you proceed to test those variables the result will be as such.</p>
",0
53873939,53873836,0,"<p>Capitalization is important to C. You have a <code>struct Node</code>, which you define. Inside, it has a pointer to a different type, <code>struct node</code>, which the compiler knows nothing about. You should use consistent capitalization and it should work better </p>

<p>By the way, I would expect <code>gcc</code> to print a warning in the .h file where you reference the new <code>struct node</code> for the first time. Be sure to compile with <code>-Wall -Wextra -pedantic</code> so it can help you catch a lot of errors.</p>
",6
55735908,55735329,0,"<p>You need to specify the size of <code>allocbuf</code> so it can hold the entire result:</p>

<pre><code>char allocbuf[SIZE * (SIZE + 1)];
</code></pre>

<p>There's no need for <code>allocp</code>, because the array name will decay to a pointer when used in calculations. In <code>MakeString</code>, you need to loop over the rows and characters of <code>matrix</code>, copying them to <code>allocbuf</code>.</p>

<pre><code>char *MakeString()
    for (int i = 0; i &lt; SIZE; i++) {
        memcpy(allocbuf + i * SIZE, matrix + i, SIZE);
        if (i &lt; SIZE - 1) {
            // write space between rows
            *(allocbuf + i * SIZE + SIZE) = ' ';
        } else {
            // write null at end
            *(allocbuf + i * SIZE + SIZE) = 0;
        }
    }
    return allocbuf;
}
</code></pre>

<p>The instructions don't mention the <code>n</code> argument to <code>MakeString()</code>, so I removed it.</p>
",4
53601497,53584598,0,"<p>Each shift is the same as dividing the value by 2. Shifting to the right four times is like dividing by 2 four times. It's integer math so any fractional portions are truncated.</p>

<p>Assuming <code>00001010</code> (10) is binary notation, the results are as follows:</p>

<p>Shift 1: <code>00000101</code> (5)<br>
Shift 2: <code>00000010</code> (2)<br>
Shift 3: <code>00000001</code> (1)<br>
Shift 4: <code>00000000</code> (0) </p>

<p>So the result is indeed 0.</p>
",0
53584665,53584598,0,"<p>Your notes are wrong. <code>printf(""%d\n"", strtol(""00001010"", 0, 2) &gt;&gt; 4)</code> produces ¡°0¡±.</p>
",0
53601497,53584598,0,"<p>Each shift is the same as dividing the value by 2. Shifting to the right four times is like dividing by 2 four times. It's integer math so any fractional portions are truncated.</p>

<p>Assuming <code>00001010</code> (10) is binary notation, the results are as follows:</p>

<p>Shift 1: <code>00000101</code> (5)<br>
Shift 2: <code>00000010</code> (2)<br>
Shift 3: <code>00000001</code> (1)<br>
Shift 4: <code>00000000</code> (0) </p>

<p>So the result is indeed 0.</p>
",0
53790528,53790389,0,"<p>The recursion statements are inside <code>if (T != NULL)</code>. So clearly none of that code will run when the null condition is encountered. This is what prevents infinite recursion: when you get to the leaves of the tree, it just returns <code>NULL</code> without doing any more copying.</p>

<p>All non-null nodes are copied by calling the function recursively.</p>
",0
53029367,53028433,0,"<p>I don't get a segfault, and I don't see anything which would cause one. Instead, I get an empty result.</p>

<pre><code>$ ./test
String with space is :  this is a test for me
Sting with no space is: 
</code></pre>

<p>The issue is <code>NoSpacer</code> returns a pointer to NULL.</p>

<pre><code> *cs = '\0';
 return cs;
</code></pre>

<p><code>NoSpacer(test)</code> modifies <code>test</code> in place. It should return nothing. Instead, use <code>test</code> again.</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;ctype.h&gt;

void NoSpacer(char* s)
{
     char* cs = s;
     while (*s != '\0')
     {
         if(isspace(*s))
         {
             s++;
             continue;
         }
         *cs = *s;
         cs++;
         s++;
     }
     *cs = '\0';
}

int main ()
{
     char test[] = "" this is a test for me"";
     printf(""String with space is : %s\r\n"", test);
     NoSpacer(test);
     printf(""Sting with no space is: %s\r\n"", test);
     return 0;
}
</code></pre>

<p>Also note I'm using <a href=""https://en.cppreference.com/w/c/string/byte/isspace"" rel=""nofollow noreferrer"">the standard <code>isspace</code> function</a> from <a href=""https://www.wikiwand.com/en/C_character_classification"" rel=""nofollow noreferrer"">ctypes.h</a>.</p>
",0
58713526,58713441,1,"<p>As you've discovered, no it's not valid.</p>

<p>C lacks the support for default values, so the arguments would be quite useless. The solution to this particular problem is to use magic <code>FILE *</code> ""files"" that map to the standard input/output channels, i.e. <code>stdin</code> and <code>stdout</code> from <a href=""http://man7.org/linux/man-pages/man3/stdio.3.html"" rel=""nofollow noreferrer""><code>&lt;stdio.h&gt;</code></a>.</p>
",1
58713511,58713441,1,"<blockquote>
  <p>Is it ok to leave the parameters unused?</p>
</blockquote>

<p>No, all arguments must be present and correct.</p>

<p>You should also be careful that you do not provide different prototypes for a function (or any symbol) within a given application.</p>

<hr>

<p>If you really want to call it with no arguments, then the best approach is to have two functions and call the one you're after:</p>

<pre class=""lang-c prettyprint-override""><code>void encoder(void) {
    encoder2(0, stdin, stdout);
}

void encoder2(int argc, FILE* inputFP, FILE* outputFP) {
    /* ... */
}
</code></pre>

<hr>

<p>If you want to have a variable number of arguments, then you could look at using the macros in <a href=""https://en.wikipedia.org/wiki/Stdarg.h"" rel=""nofollow noreferrer""><code>stdarg.h</code></a> (like <code>printf()</code> and friends), though you still won't be able to get away with <em>zero</em> arguments, and you'll need to be very careful with your usage.</p>
",6
53781335,53780083,0,"<p>You do one more <code>str++</code> than you should.</p>

<pre><code>int SumStr(const char *str) {                        // added const
    int sum = 0, digit = 0;                          // removed i
    while (*str) {
        digit = 0;
        while (*str &amp;&amp; *str &gt;= '0' &amp;&amp; *str &lt;= '9') { // swapped order of conditions
            digit = digit * 10 + (*str - '0');
            str++;
        }
        if (digit &gt; 0) sum += digit;
        else str++;                                  // added else
    }
    return sum;
}
</code></pre>

<p>see <a href=""https://ideone.com/Aerrh5"" rel=""nofollow noreferrer"">https://ideone.com/Aerrh5</a></p>
",0
53780358,53780083,1,"<p><em>How can I optimize it?</em>.  I am not sure how the following will optimize in terms of speed or memory size, but it does make the code a little simpler, and more readable:</p>

<p>The following uses the <code>isdigit()</code> function and <em><a href=""http://www.asciitable.com/"" rel=""nofollow noreferrer"">ASCII values</a></em> to count numbers:</p>

<pre><code>int main(void)
{
    char buf[] = {""abc23jrt5""};//sum of integers: 23 + 5 = 28
    int count = int SumStr(buf);

    return 0;   
}

//Edited to sum instances of numbers embedded in string.
//adjacent digits such as `11` in the string `avf11e5` are treated
//as the integer value `11`, not `1 + 1`.
int SumStr(char *buf)
{
    int i = 0;
    int sum = 0;
    while( *buf != 0 )
    {
        i = 0;
        while(isdigit(*buf))
        {
            i *= 10, i += *buf - '0';
            if(*buf != 0) buf++;
        }
        sum += i;
        if(*buf != 0) buf++;
    }
    return sum;
};
</code></pre>
",3
53570019,53569939,1,"<p>The <code>bptr</code> <code>printf</code> is missing a comma. The resulting source code, <code>b *bptr</code>, attempts to multiply a <code>float</code> by a pointer, which causes the error message.</p>
",1
54420119,54419324,3,"<blockquote>
  <p>this code that is supposed to work for normal array, but not sure if it's right for stack as we might using dynamic memory</p>
</blockquote>

<p>Whether your code is correct for stacks is nothing to do with dynamic allocation, and everything to do with the interface of a stack. Do you know what that is? It's absolutely essential to solving your problem, and I don't see any hint that you either know how a stack behaves, or tried to research it.</p>

<p>Here you are, the <a href=""https://en.wikipedia.org/wiki/Stack_(abstract_data_type)"" rel=""nofollow noreferrer"">stack abstract datatype</a>:</p>

<ul>
<li>preserves last-in first-out order</li>
<li>allows you to push a new element onto the top of the stack</li>
<li>allows you to pop the most recently pushed element (that wasn't already popped) from the top of the stack.</li>
</ul>

<p>That's everything, and there is no random access (ie, <code>stack[j]</code> will never be a valid expression), so it is <em>obviously</em> impossible for the algorithm you showed to work.</p>

<p>If you don't have a stack implementation already - write one! You're going to need a stack to compile and test your algorithm anyway. The definitions you show describe the storage, but not the interface.</p>

<p>There are only two functions to code (plus the two to create and destroy a stack, and optionally one to query the size).</p>

<p>Now for the algorithm - you can only ever access the top element of a stack, so you need to think about what to with the elements you <code>pop</code> that <em>aren't</em> duplicates. They have to go somewhere, because you can't see below them while they're on your main stack, and you mustn't lose them.</p>

<hr>

<p>Your edit shows you do have a stack datatype, sort of: it uses three global variables which you have to take care not to break, and you can't reuse any of the functions for your temporary stack, because they operate on those globals.</p>

<p>Even in C, I'd expect to see something like this (untested, un-compiled sample code based on yours above)</p>

<pre><code>struct Stack {
    int size;
    int sp;
    int data[];
};

struct Stack* stack_create(int elements) {
    struct Stack *s = malloc(sizeof(*s) + elements * sizeof(int));
    s-&gt;size = elements;
    s-&gt;sp = -1;
    return s;
}

bool stack_isEmpty(struct Stack *s) { return s-&gt;sp == -1; }
bool stack_isFull(struct Stack *s) { return s-&gt;sp == s-&gt;size - 1; }
void stack_push(struct Stack *s, int x)
{
    assert(!stack_isFull(s));
    s-&gt;data[++s-&gt;sp] = x;
}
int stack_pop(struct Stack *s)
{
    assert(!stack_isEmpty(s));
    return s-&gt;data[(s-&gt;sp)--];
}
</code></pre>

<p>because then you can use the same operations on your main and temporary stacks.</p>

<p>If the <code>removeDuplicates</code> message is <em>supposed</em> to be implemented in terms of the stack abstraction, you need an algorithm you can implement in terms of <code>stack_push</code>, <code>stack_pop</code> etc.</p>

<p>If the <code>removeDuplicates</code> message is <em>supposed</em> to be an internal function operating directly on the stack implementation, rather than being implemented in terms of the stack abstraction - then your basic approach is probably OK (if very far from optimal), and you just need to learn to <em>debug</em> your code.</p>

<p>I still don't know which one of those is true (so I won't vote to re-open yet), but they are completely different questions.</p>
",3
53578660,53578329,0,"<p>As mentioned by @JonathanLeffler in the comments, you have a bug. The line</p>

<pre><code>printf(""%d "", firstNum*(pow( ratio, i)));
</code></pre>

<p>is wrong because <code>pow</code> returns a double but in the printf specifications <code>%d</code> expects an integer.
So, you can either change the specifier in your printf to a floating point one, i.e., <code>%f, %g, %e, %F, %G, %E</code> et cetera or cast pow's output to int by doing <code>(int)pow(ratio, i)</code>.</p>

<p>In the first case, as @JadMrad said, if you are printing a double and you don't want to have decimal numbers, you can specify the number of digits at the right of the decimal point using <code>""%.Nf""</code> instead of <code>""%f""</code> where N is the number of decimal points that you want.</p>

<p>Nevertheless, in your case it seems to me that you are expecting always integer numbers. Then, </p>

<pre><code>printf(""%d "", firstNum*((int)pow( ratio, i)));
</code></pre>

<p>sounds like a better solution to me.</p>
",0
53585085,53583175,1,"<p>Obviously homework so I'm not doing it for you, but: You can do it on paper well enough to ask a clear question, so just figure out how to implement that in code.</p>

<ul>
<li>A counter for each letter `int a=0; int b=0; int z=0;... (one variable per letter? there has to be a better way...)</li>
<li>set your counters based on the input word</li>
<li>check if the word you are searching can satisfy all of the counters</li>
<li>There are a couple of easily identified common routines here.</li>
</ul>
",0
53156197,53156113,0,"<p>First of all you need to find the location where <code>array[i][j] == a * b</code>. You can do that right after the assignment to <code>array[i][j]</code>.</p>

<p>Then you need to save that position.</p>

<p>And after you print the newline, you need to print another line <strong>if</strong> the value was found, placing the ""marker"" at the correct position.</p>
",2
59162527,59162365,1,"<p>There is no syntax to accomplish your direct ask in C. The closest you can come is to create temporary variables.</p>

<pre><code>int *xptr = &amp;longAndExpressiveName-&gt;x;
int vel_x = longAndExpressiveName-&gt;vel.x;

*xptr += vel_x;
</code></pre>

<hr>

<p>Your desire to use <code>longAndExpressiveName</code> is misplaced in this case, because in C++, you are coming from a syntax where <code>longAndExpressiveName</code> is not passed as a parameter, and the parameter is implicitly hidden by the implicit <code>this-&gt;</code>. The C++ syntax for the caller would be:</p>

<pre><code>longAndExpressiveName-&gt;func();
</code></pre>

<p>And you are translating that into:</p>

<pre><code>func(longAndExpressiveName);
</code></pre>

<p>And then you propagate that same name to the parameter name. While it may be appropriate for the caller to refer to the pointer with a long and expressive name, it is not really helpful to the ""member"" function. But, what would be helpful is if the function is named so that you know it is meant to do something to a particular kind of structure.</p>

<pre><code>void func_Data(Data * const d) {
    d-&gt;x += d-&gt;vel.x;
}
</code></pre>

<p>Which better captures the original C++ syntax:</p>

<pre><code>void Data::func () {
    x += vel.x;
}
</code></pre>
",3
56875223,56875002,4,"<p>This has nothing to do with global variables. There are multiple problems here but the most pressing error is that you are attempting to use uninitialised pointers. <strong>This never works</strong>. You need to understand pointers before you can use them properly.</p>

<p>In particular, if you have a declaration like this:</p>

<pre><code>int *x;
</code></pre>

<p>Then, <em>no matter what you do</em>, you first need to assign a valid pointer to <code>x</code><sup>1</sup>.</p>

<p>In your case the error is compounded by the fact that you¡¯re using <code>scanf</code> wrong. Luckily the solution here is very easy: Don¡¯t declare pointers. Instead, declare <code>int</code> variables.</p>

<pre><code>#include &lt;stdio.h&gt;

int q;
int u;
int p;

void test () {
    printf(""Insert #1?\t""); scanf(""%d"", &amp;u); 
    printf(""Insert #2?\t""); scanf(""%d"", &amp;p); 
}

int main () {
    test();
    printf(""%d\n"", u); 
    printf(""%d\n"", p);
    printf(""%d\n"", q);
}
</code></pre>

<p>Ironically the comments in your original code already point out the issue, they just suggest a wrong solution. It¡¯s a bit of a mystery where these comments are from. ;-)</p>

<hr>

<p><sup>1</sup> Technically the only exception is for statically allocated pointers, which are correctly zero-initialised and can therefore be used in null pointer comparisons.</p>
",1
56875179,56875002,1,"<p>Pointers need to point to something, such as another variable, or memory allocated dynamically with <code>malloc()</code>.</p>

<p>You can't use <code>scanf()</code> to read directly into a pointer. You can use it to read into what the pointer points to.</p>

<p>So you can write something like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
int q;
int *qp = &amp;q;
int *up;
int p;
int *pp = &amp;p;
void test () {
    printf(""Insert #1?\t""); scanf(""%d"", up); 
    printf(""Insert #2?\t""); scanf(""%d"", pp); 
}
int main () {
    up = malloc(sizeof(*up));
    test ();
    printf(""%d\n"", *up); 
    printf(""%d\n"", p);
    printf(""%d\n"", q);
}
</code></pre>
",0
56875223,56875002,4,"<p>This has nothing to do with global variables. There are multiple problems here but the most pressing error is that you are attempting to use uninitialised pointers. <strong>This never works</strong>. You need to understand pointers before you can use them properly.</p>

<p>In particular, if you have a declaration like this:</p>

<pre><code>int *x;
</code></pre>

<p>Then, <em>no matter what you do</em>, you first need to assign a valid pointer to <code>x</code><sup>1</sup>.</p>

<p>In your case the error is compounded by the fact that you¡¯re using <code>scanf</code> wrong. Luckily the solution here is very easy: Don¡¯t declare pointers. Instead, declare <code>int</code> variables.</p>

<pre><code>#include &lt;stdio.h&gt;

int q;
int u;
int p;

void test () {
    printf(""Insert #1?\t""); scanf(""%d"", &amp;u); 
    printf(""Insert #2?\t""); scanf(""%d"", &amp;p); 
}

int main () {
    test();
    printf(""%d\n"", u); 
    printf(""%d\n"", p);
    printf(""%d\n"", q);
}
</code></pre>

<p>Ironically the comments in your original code already point out the issue, they just suggest a wrong solution. It¡¯s a bit of a mystery where these comments are from. ;-)</p>

<hr>

<p><sup>1</sup> Technically the only exception is for statically allocated pointers, which are correctly zero-initialised and can therefore be used in null pointer comparisons.</p>
",1
56875179,56875002,1,"<p>Pointers need to point to something, such as another variable, or memory allocated dynamically with <code>malloc()</code>.</p>

<p>You can't use <code>scanf()</code> to read directly into a pointer. You can use it to read into what the pointer points to.</p>

<p>So you can write something like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
int q;
int *qp = &amp;q;
int *up;
int p;
int *pp = &amp;p;
void test () {
    printf(""Insert #1?\t""); scanf(""%d"", up); 
    printf(""Insert #2?\t""); scanf(""%d"", pp); 
}
int main () {
    up = malloc(sizeof(*up));
    test ();
    printf(""%d\n"", *up); 
    printf(""%d\n"", p);
    printf(""%d\n"", q);
}
</code></pre>
",0
53797024,53796943,0,"<p>You want an array of strings (<code>const char *</code>) and not characters (<code>char</code>), i.e:</p>

<pre><code>const char *types[] = {
</code></pre>

<p>With that in place, you won't get any warnings/errors regarding the <code>%s</code> in your printf (which should be in there).</p>
",0
56218961,56217798,-1,"<p>In the general case, converting a value from an integral type to a pointer and dereferencing the pointer only makes sense when those both conditions are true:</p>

<ul>
<li>the architecture allows the integral type to represent the value of a pointer</li>
<li>the value was obtained from the address of a struct of same type.</li>
</ul>

<p>For example on a 32 bit architecture, this is legal C:</p>

<pre><code>StructA *a;
StructA other {};
uint32_t b;
...
b = (uint32_t) &amp;other;
a = (StructA*) b;
</code></pre>

<p>The other valid use case is even more constraining. Some architecture may have specific <em>registers</em> mapped at well known addresses. In that case, this is also legal:</p>

<pre><code>StructA *a;
StructA other {};
uint32_t b;
...
b = (uint32_t) ...;  // well known address on a specific machine and a specific compiler
a = (StructA*) b;
</code></pre>

<p>The requirements are:</p>

<ul>
<li>the machine has specific <em>registers</em> starting at that well known address</li>
<li>the specific implementation maps those registers to a struct of type <code>*StructA</code>, with no padding problems</li>
</ul>
",2
53125404,53123841,1,"<p>Your problem is that an array of arrays of <code>char</code> is not the same as an array of pointers to <code>char</code>.  That may seem pedantic, but underlying structure is different.</p>

<p>In fact, your compiler should be issuing a warning (if it's not, you should increase your warning levels).</p>

<p>More specifically, if <code>a</code> is an array of array of chars, then <code>a[i]</code> is an address relative to the start of your array that can only be calculated because the compiler knows how large each sub array is (e.g. <code>256</code> in your case).</p>

<p>Whereas, if <code>a</code> is an array of pointers to <code>char</code>, no calculation is required, <code>a[i]</code> contains the value of the pointer itself.</p>

<p>By passing an array of arrays where an array of pointers is expected, you are causing the compiler to calculate the address incorrectly (i.e. undefined behavior) and hence your segfault.</p>

<p>If you want to be consistent and use an array of pointers everywhere, your code might look more like:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void print_array(char* arr[]) {
    for (int i = 0; arr[i]; i++) {
        printf(""%s\n"", arr[i]);
    }
}

void copy_array(char* dest[], char* src[]) {
    int i;
    for (i = 0; src[i]; i++) {
      dest[i] = malloc(strlen(src[i]) + 1);
      strcpy(dest[i], src[i]);
    }
    dest[i] = NULL;
}

int main(int argc, char* argv[]) {
    if (argc &lt; 2)
        return 1;
    char *args[argc + 1];
    copy_array(args, argv);
    print_array(&amp;args[2]);
    return 0;
}
</code></pre>
",1
53123879,53123841,1,"<p>It seems the copy_array loop execute after the actual length of the array</p>

<pre><code>void copy_array(char* dest[], const char* src[]) {
    for (int i = 0; src[i]; i++) {
        strcpy(dest[i], src[i]);
    }
}
</code></pre>

<p>should be changed to</p>

<pre><code>void copy_array(char* dest[], const char* src[], int count) {
    for (int i = 0; i &lt; count; i++) {
        strcpy(dest[i], src[i]);
    }
}
</code></pre>

<p>Also print array should be changed to:</p>

<pre><code>void print_array(const char* arr[], int count) {
    for (int i = 0; i &lt; count; i++) {
        printf(""%s\n"", arr[i]);
    }
}
</code></pre>
",2
53244263,53244213,1,"<p>The main problem with <code>scanf</code> is that it's pattern language doesn't always allow enough control, particularly if you want to restrict input to a line-oriented format. A secondary problem, which can be overcome by specifying size limits, is that by default string fields are of unlimited size and can therefore overflow their destination buffers.</p>

<p><code>getchar</code> does not suffer from either of those issues,, for reasons which I hope are obvious.</p>
",0
54223559,54219720,0,"<p>With no code... my best guess would be you don't have <code>int main()</code> at the beginning of your program OR <code>main()</code> is named something other than <code>main</code>.</p>
",0
58617680,58617610,0,"<p><code>scanf()</code> returns the number of input items successfully assigned. That is, in your example, <code>1</code> if a number is entered, or <code>0</code> otherwise. (Unless an input error occurs prior to the first input item, in which case it returns <code>EOF</code>.)</p>

<p>In case a string is entered, this fails to match <code>%d</code>, <code>scanf()</code> returns zero, the loop is entered, <code>""Do something""</code> is printed, and <code>scanf()</code> is called again.</p>

<p><em>But the string has not been consumed by any input function.</em></p>

<p>So the string fails to match, <code>""Do something""</code> is printed... you get the idea.</p>

<p>Be happy you do not access <code>num</code>, because if you haven't initialized that beforehand, accessing it would be undefined behaviour (as it <em>still</em> isn't initialized)...</p>

<p>Generally speaking, do not use <code>scanf()</code> on potentially malformed (user) input. By preference, read whole lines of user input with <code>fgets()</code> and then parse them in-memory with e.g. <code>strtol()</code>, <code>strtof()</code>, <code>strtok()</code> or whatever is appropriate -- this allows you to backtrack, identify exactly the point where the input failed to meet your expectations, and print meaningful error messages including the full input.</p>
",0
58618112,58617610,0,"<blockquote>
  <p>How can I stop the loop only when End of line occurs, but ignore string inputs and only perform my logic if integer inputs have occured?</p>
</blockquote>

<p>When <code>scanf("" %d"", &amp;num)</code> returns 0, read a single character and toss it.</p>

<pre><code>int count;
while ((count = scanf(""%d"", &amp;num)) != EOF) {
  if (count &gt; 0) printf(""Do something with %d\n"", num);
  else getchar();
}
</code></pre>
",0
53857175,53856784,0,"<p>Rather than criticize, let me show you a couple of counterexamples. Consider the following:</p>

<pre><code>struct intrange {
    int   minimum;
    int   maximum;
};
</code></pre>

<p>These limits are inclusive. You can pass structures by value, and assign them just like any other type. To split such a structure, you could use</p>

<pre><code>struct intrange  intrange_split(const struct intrange  range,
                                const int              half)
{
    /* Midpoint of the range, rounding towards zero */
    const int        midpoint = (range.minimum + range.maximum) / 2;
    struct intrange  result;

    if (half &gt; 0) {
        /* Upper half, including midpoint. */
        result.minimum = midpoint;
        result.maximum = range.maximum;
    } else
    if (half &lt; 0) {
        /* Lower half, excluding midpoint. */
        result.minimum = range.minimum;
        result.maximum = midpoint - 1;
    } else {
        /* No change. */
        result = range;
    }

    return result;
}
</code></pre>

<p>The above <code>intrange_split()</code> function takes an intrange structure <code>range</code> as a parameter, and an int <code>half</code> to indicate how to split it. There are no error checks.</p>

<p>If you wanted to operate on a structure passed by reference, you could use say</p>

<pre><code>int intrange_split(struct intrange *range, int half)
{
    int midpoint;

    /* No range? Invalid range? */
    if (!range || range-&gt;maximum &lt; range-&gt;minimum)
        return -1; /* Invalid range. */

    /* Note: This could overflow. */
    midpoint = (range-&gt;minimum + range-&gt;maximum) / 2;

    if (half == 1) {
        /* Upper half, including midpoint. */
        range-&gt;minimum = midpoint;
    } else
    if (half == -1) {
        /* Lower half, excluding midpoint. */
        range-&gt;maximum = midpoint - 1;
    } else {
        /* Invalid operation. */
        return -1;
    }

    /* Verify range is valid (non-empty). */
    if (range-&gt;maximum &lt; range-&gt;minimum)
        return -1;

    /* Range is valid, and not empty. */
    return 0;
}
</code></pre>

<p>It is more common to use the return value to represent success/error in C, because unlike C++, there are no exceptions.  (You could also use assertions, or print an error message and <a href=""http://man7.org/linux/man-pages/man3/abort.3.html"" rel=""nofollow noreferrer""><code>abort()</code></a> or <a href=""http://man7.org/linux/man-pages/man3/exit.3.html"" rel=""nofollow noreferrer""><code>exit(EXIT_FAILURE)</code></a>, depending on whether the error is recoverable or not.)</p>

<p>In all above cases, I used the logic that <code>midpoint</code> is halfway between <code>minimum</code> and <code>maximum</code>, rounded towards zero; and that <code>midpoint</code> belongs to the upper range. It is up to you to choose <em>how</em> you define it, as long as you make the choice explicitly, and document it.  See how much simpler these approaches are?</p>

<p>It is also common to use preprocessor macros or static inline functions for initializing variables. In this case, for example</p>

<pre><code>#define  INTRANGE_INIT(min, max)  { min, max }

static inline struct intrange intrange_define(const int minimum,
                                              const int maximum)
{
    struct intrange  result = { minimum, maximum };
    return result;
}
</code></pre>

<p>so that in your code, you can declare a range using e.g. <code>struct intrange  my_range = INTRANGE_INIT(0, 100);</code>. Sure, you can also initialize it using <code>struct intrange my_range = { 0, 100 };</code>, or even <code>struct intrange my_range; my_range = intrange_define(0, 100);</code>.</p>

<p>As long as the implementation is readable and easy to understand, it is fine.  I tend to prefer the preprocessor macro style myself, but that is purely a style issue.</p>

<p>Remember to write comments that describe your design and intent, not what the code does. That skill is as important as programming itself. You'll find that in most cases, code that can only be written and not maintained, is not worth the electricity to run it on.</p>

<p>(And never ever get into the habit of thinking you'll add error checking and security stuff later. Because you won't. Nobody ever does. If they try, they invariably fail. This is because robustness and security can only be designed in, not added afterwards.)</p>
",1
53574120,53573795,0,"<p>One option is to use:</p>

<pre><code>$ ./a.out input.txt     # No shell I/O redirection
</code></pre>

<p>You then open (each of) the command line argument(s) for reading, read it, and close it.  When you're done, you can read from <code>stdin</code> until EOF.</p>

<p>On a Unix-like system, you could also support:</p>

<pre><code>$ ./a.out &lt; input.txt   # Shell I/O redirection
</code></pre>

<p>and read from standard input to EOF, and then do one of a number of things to read from the keyboard:</p>

<ul>
<li>Open <code>/dev/tty</code> and read from that.</li>
<li>Open <code>/dev/tty</code> and duplicate it to <code>stdin</code> (<code>freopen()</code>).</li>
</ul>

<p>There are some less kosher possibilities too; one is to use the standard output or standard error file descriptor as an input file descriptor, using <code>fdopen()</code>.  This will often work if the streams are connected to a terminal.  The classic way to start a shell is to open <code>/dev/tty</code> for reading and writing, and then duplicate the read/write descriptor to standard input, output and error.  If the output is piped to another program, or redirected to a file, this won't work, of course.  You could use <code>isatty()</code> to check whether the file descriptors are associated with a terminal or not.</p>

<p>There are probably other ways to do it too ¡ª different ones if you're on Windows.</p>

<p>Personally, I'd go with the 'read command line arguments as files, then read standard input' option, but YMMV.</p>
",0
54836761,54836632,0,"<p>Barmar's comment above is correct. In addition to that, your program depends on the user entering a string that consists entirely of characters. What do you think will happen in your inner while loop if your string contains, say, a ""1""?</p>
",2
54836717,54836632,2,"<p>You need to set <code>k</code> back to zero every time you search <code>characters</code>. Since you don't do this, you start your search from the position that the last search ended. If the next character is earlier in the alphabet, you won't find it and the search will read outside the array.</p>

<p>Also, if any of the input characters aren't letters, the search will never find it. The loop has no check for this.</p>

<p>A simpler method would be to first check <code>isalpha()</code> to make sure that the input is a letter, and then calculate <code>input[i] - 'A'</code> and use that as the index into <code>morse</code>.</p>

<p>When processing <code>input</code> you should stop when you get to the null terminator, not go all the way to <code>i = 24</code>.</p>

<pre><code>int i = 0;
while (input[i]) {
    if (isalpha(input[i])) {
        input[i] = toupper(input[i]);
        output[i] = morse[input[i] - 'A'];
    } else {
        output[i] = NULL;
    }
    i++;
}
</code></pre>
",0
54536584,54535945,1,"<blockquote>
  <p><em>I don't know how to pass the pointer size so the empty function can free the data pointer space.</em></p>
</blockquote>

<p><code>free()</code> does not take the size, but just the pointer. So there is no need to pass the size of memory <code>data</code> points to <code>empty_list</code>.</p>

<hr>

<p>To access the memory <code>data</code> points to you want to cast the pointer to the appropriate type and then dereference it.</p>

<p>If you for example did</p>

<pre><code>Node * head = init_list(1, sizeof (int));
</code></pre>

<p>You could access the head's data by doing</p>

<pre><code>*((int*) head-&gt;data) = 42;
</code></pre>
",5
53136265,53136137,2,"<pre><code>int maxPos=0;    

for (k = index; k &lt; size; k++){
        if (maxVal &lt; array[k]){
            maxVal = array[k];
            maxPos = k;
        }
    }    

    printf(""The maximum value is %d at position   %d \n"", 
maxVal, maxPos);
</code></pre>
",1
53136265,53136137,2,"<pre><code>int maxPos=0;    

for (k = index; k &lt; size; k++){
        if (maxVal &lt; array[k]){
            maxVal = array[k];
            maxPos = k;
        }
    }    

    printf(""The maximum value is %d at position   %d \n"", 
maxVal, maxPos);
</code></pre>
",1
53195164,53194948,0,"<p>Your encryption logic and decryption logic are the same, i.e. for decryption you're adding the key when you should be subtracting.  You also need to change the overflow check for going below <code>'a'</code>:</p>

<pre><code>case 'd':
    {
        for(int i = 0; phrase[i] != '\0'; i++){
                //~ phrase[i] = phrase[i] + 3;
            ph = phrase[i];
                if(ph &gt;= 'a' &amp;&amp; ph &lt;= 'z'){
                    ph = ph - key;   // subtract

                    if(ph &lt; 'a'){    // switch wraparound check
                        ph = ph + 'z' - 'a' - 1;
                    }
                    phrase[i] = ph;
                } // end of if
                else if(ph &gt;= 'A' &amp;&amp; ph &lt;= 'Z'){
                    ph = ph - key;   // subtract


                    if(ph &lt; 'a'){    // switch wraparound check
                        ph = ph + 'Z' - 'A' - 1;
                    } // end of if
                    phrase[i] = ph;
                } // end of else if
            } // end of for
            printf(""Decrypted message: %s\n"", phrase);
                break;
            } // end of case 'd'
</code></pre>
",2
56515213,56515071,1,"<pre><code>int (*f(float (*)(long),char *))(double)
</code></pre>

<p><em>f</em> is a function that has 2 parameters of type </p>

<pre><code>float (*)(long),  &lt;&lt; pointer to function long=&gt;float
char *            &lt;&lt; string
</code></pre>

<p>and returns </p>

<pre><code>(int)(*)(double) &lt;&lt; a pointer to a function double=&gt;int
</code></pre>
",2
53714367,53714252,3,"<p>Lets take a look at a simple two ""dimensional"" array (array of arrays) and how it looks like in memory.</p>

<p>First the array:</p>

<pre><code>int a[2][2];
</code></pre>

<p>And how it looks like in memory (with some pointers):</p>

<pre>
+---------+---------+---------+---------+
| a[0][0] | a[0][1] | a[1][0] | a[1][1] |
+---------+---------+---------+---------+
^
|
&a
|
&a[0]
|
&a[0][0]
</pre>

<p>Looking at this it should be easy to understand why the pointers are the same.</p>

<p>To continue don't forget that all arrays can decay to a pointer to its first element. That is, for the array <code>a</code> above, then <code>a</code> is equal to <code>&amp;a[0]</code>. That means <code>*a</code> is equal to <code>*&amp;a[0]</code>, which since the <code>*</code> and <code>&amp;</code> operators cancel each other out, will be equal to <code>a[0]</code>. And since <code>a[0]</code> is an array it will decay to a pointer to its first element which is equal to <code>&amp;a[0][0]</code>. That is, <code>*a</code> is equal to <code>&amp;a[0][0]</code>.</p>
",0
53919469,53919462,2,"<p>You should initialize the values of the current and birth year <em>before</em> computing the age:</p>

<pre><code>currentyr = 2018;
birthyr = 2000;
age = currentyr - birthyr;

printf(""I am %d years old"", age);
</code></pre>

<p>Most likely what is happening now is that your age difference is being computed with undefined or possibly random values.</p>
",3
53716966,53716531,0,"<p>A minor modification that may help prevent a <code>strcmp</code> on <code>NULL</code></p>

<pre><code>for(i = 1; i &lt; 4; i++) {
  bzero(filebuf, 500);
  sprintf(filebuf, "".%s.%d"",filebuf2, i);
  strcpy(fileslist2, fileslist);
  tok = strtok(fileslist2, ""|"");
  while(tok != NULL) {
      // tok = strtok(NULL, ""|""); // moved down
      if(strcmp(tok, filebuf) == 0) {
          printf(""Equal!\n"");
          i = 5;
          break;
      }
      tok = strtok(NULL, ""|""); // to here
  }
}
</code></pre>
",0
53866238,53865895,1,"<p>There are following problems in the code:</p>

<ol>
<li><code>malloc</code> does not insert NULL at the end of allocated memory. So a check <code>if(*bufferN == NULL)</code> will not work. The pointer would dereference the memory and probably get a garbage value.</li>
<li>The error <code>rev_S3_ptr.c:14:16: error: comparison between pointer and integer [-Werror] if(*bufferN == NULL){</code> occur because you're comparing value (<code>*bufferN</code>) address against NULL (used for a nil address).</li>
<li>The code <code>rev_S3_ptr.c:19:4: error: value computed is not used [-Werror=unused-value]
*bufferN++;</code> throws an error because only an increment of address was needed. The deference does not help.</li>
<li>The statement <code>bufferP[i]</code> means <code>*(bufferP+i)</code> hence the error while comparing against NULL.</li>
</ol>
",0
53268450,53268412,0,"<p>Within <code>main</code>, <code>number</code> is a global variable which is an array.  So <code>sizeof(number)</code> gives you the size of the whole array in bytes.</p>

<p>In the <code>average</code> function however, <code>number</code> is a parameter to the function and has type <code>int *</code>.  So <code>sizeof(number)</code> in that case gives you the size of the pointer, not the size of the array.</p>

<p>Either don't pass a parameter and just use the global, or pass the size of the array as a separate parameter to the function.</p>
",2
53762245,53761758,0,"<p>You are passing the <code>struct game</code> to the functions by value, meaning they operate on a <em>copy</em>. Hence the ""original"" <code>struct game gamecp</code> in <code>main</code> is never initialized. Pass by reference (as a <code>struct game *</code> pointer argument) instead.</p>
",2
54015535,54014894,0,"<p>Simply process one character of the password at a time; there is no need to have it all in memory at once.</p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;


int main(void)
{
    printf(""Enter password: "");

    bool SawDollar = false;
    bool SawDigit  = false;
    bool SawUpper  = false;

    while (1)
    {
        int c = getchar();
        if (c == EOF || isspace(c))
            break;

        if (c == '$')
            SawDollar = true;
        else if (isdigit(c))
            SawDigit = true;
        else if (isupper(c))
            SawUpper = true;
    }

    if (SawDollar &amp;&amp; SawDigit &amp;&amp; SawUpper)
        printf(""Good password!\n"");
    else
        printf(""Bad password.\n"");
}
</code></pre>
",0
53826121,53825984,5,"<p>In the context of a declaration, <code>{</code> and <code>}</code> just mean ¡°here is a group of things.¡± They do not represent an object or an address or an array. (Note: Within initializations, there are expressions, and those expressions can contain braces in certain contexts that do represent objects. But, in the code shown in the question, the braces just group things.)</p>

<p>In <code>char* m[] = { ""Excellent"",""Good"", ""bad"" };</code>, three items are listed to initialize <code>m</code>: <code>""Excellent""</code>, <code>""Good""</code>, and <code>""bad""</code>. So each item initializes one element of <code>m</code>.</p>

<p><code>""Excellent""</code> is a string literal. During compilation, it becomes an array of characters, terminated by a null character. In some situations, an array is kept as an array:</p>

<ul>
<li>When it is used as the operand of <code>sizeof</code>.</li>
<li>When it is used as the operand of unary <code>&amp;</code> (for taking an address).</li>
<li>When it is a string literal used to initialize an array.</li>
</ul>

<p>None of these apply in this situation. <code>""Excellent""</code> is not the operand of <code>sizeof</code>, it is not the operand of <code>&amp;</code>, and it is initializing just one element of <code>m</code>, not the entire array. So, the array is not kept as an array: By a rule in C, it is automatically converted to a pointer to its first element. Then this pointer initializes <code>m[0]</code>: <code>m[0]</code> is a pointer to the first element of <code>""Excellent""</code>.</p>

<p>Similarly, <code>m[1]</code> is initialized to a pointer to the first element of <code>""Good""</code>, and <code>m[2]</code> is initialized to a pointer to the first element of <code>""bad""</code>.</p>

<p>In <code>int* x[] = { {1,2,3},{4,5,6} };</code>, two things are listed to initialize <code>x</code>. Each of these things is itself a group (of three things). However, <code>x</code> is an array of <code>int *</code>. Each member of <code>x</code> should be initialized with a pointer. But a group of three things, <code>{1,2,3}</code>, is not a pointer.</p>

<p>The C rules on interpreting groups of things when initializing arrays and structures are a bit complicated, because they are designed to provide some flexibility for omitting braces, so I have to study the standard a bit more to explain how they apply here. Suffice it to say that the compiler interprets the declaration as using <code>1</code> to initialize <code>x[0]</code>. Since <code>1</code> is an <code>int</code> and <code>x[0]</code> is an <code>int *</code>, the compiler complains that the types do not match.</p>

<h1>Supplementary Notes</h1>

<p><code>char *m[]</code> does not declare a two-dimensional array. It is an array of pointers to <code>char</code>. Because of C¡¯s rules, it can generally be used syntactically the same way as a two-dimensional array, so that <code>m[i][j]</code> picks out character <code>j</code> of string <code>i</code>. However, there is a difference between <code>char *m[]</code> and <code>char a[3][4]</code>, for example:</p>

<ul>
<li>In <code>m[i][j]</code>, <code>m[i]</code> is a pointer. That pointer is loaded from memory and use as the base address for <code>[j]</code>. Then <code>j</code> is added to that address, and the character there is loaded from memory. <strong>There are two memory loads in this evaluation.</strong></li>
<li>In <code>a[i][j]</code>, <code>a[i]</code> is an array. The location of this array is calculated by arithmetic from the start of <code>a</code>. Then <code>a[i][j]</code> is a <code>char</code>, and its address is calculated by adding <code>j</code>, and the character there is loaded from memory. <strong>There is one memory load in this evaluation.</strong></li>
</ul>

<p>There is a syntax for initialization an array of <code>int</code> pointers to point to an array of <code>int</code>. It is called a <em>compound literal</em>. This is infrequently used:</p>

<pre><code>int *x[] = { (int []) {1, 2, 3}, (int []) {4, 5, 6} };
</code></pre>

<p>A crucial difference between these string literals and compound literals is that string literals define objects which exist for the lifetime of program execution, but compound literals used inside functions have an automatic storage duration¡ªit will vanish when your function returns, and possibly earlier, depending on where it is used. Novice C programmers should avoid using compound literals until they understand the storage duration rules.</p>
",7
55506817,55506756,1,"<p>Assuming you're in an x64 environment with packing and without alignment, then <code>sizeof( struct node ) == 20</code> because <code>8 + 8 + 4 == 20</code>:</p>

<pre><code>sizeof( struct example* ) == 8        // Remember this struct member is a pointer, not a value
sizeof( struct example* ) == 8        // Ditto
sizeof( int             ) == 4        // `int` is usually 4 bytes
</code></pre>

<blockquote>
  <p>what does this malloc actually do? I know it's supposed to allocate memory so that example_node can point to an address somewhere that contains enough bytes for a whole struct node</p>
</blockquote>

<p>This is correct.</p>

<p>In a typical desktop operating system's userland, your code will runs in a process' memory space. Memory (often) comes in large chunks called ""pages"" provided by the operating system and the C runtime's <code>malloc</code> will request these pages and then manage the allocation of data <em>within</em> these pages.</p>

<p>In a desktop OS environment, <code>malloc( 20 )</code> does something like this:</p>

<ul>
<li>Do we have enough space in an available page for a contiguous 20 bytes?

<ul>
<li>Yes? Then use our internal memory map to find a contiguous 20 byte area and return the address of the first byte of that area.</li>
<li>No? Then request a new page from the operating system, add it to our internal memory map, and return the address of an area in that new page

<ul>
<li>If the new page request failed, then return <code>NULL</code>.</li>
</ul></li>
</ul></li>
</ul>

<blockquote>
  <p>a) Is it enough space for a blank template of a structure is initiated</p>
</blockquote>

<p>Short answer: yes - because you did <code>malloc( sizeof( struct node ) )</code>, <em>however</em> <code>malloc</code> can fail (in which case it returns <code>NULL</code> (<code>0</code>) and it's important that you check this after every allocation. This can happen due to running out of memory, excessive fragmentation, etc.</p>

<pre><code>struct node *example_node = malloc(sizeof(struct node));
if( !example_node ) {
    puts( ""Allocation failed. Exiting."" );
    exit( 1 );
}
</code></pre>

<blockquote>
  <p>b) are the two structures inside of struct node also initiated? So can I start doing stuff like example_node->left->foo?</p>
</blockquote>

<p>No. Those members are pointers. You need to initialize them yourself. You can initialize them by making further <code>malloc</code> calls or by assigning them to other existant <code>struct node</code> objects in memory.</p>

<blockquote>
  <p>c) Is the struct example *foo for left and right also initiated?</p>
</blockquote>

<p>No. Se my above answer.</p>

<p>Your <code>struct node</code> and <code>struct example</code> cases can be populated recursively indefinitely - how far deep you go depends on you.</p>

<p>To create a simple binary tree that's 3 nodes deep:</p>

<pre><code>struct node* allocateNode() {
    struct node* newNode = malloc( sizeof( struct node ) );
    if( !newNode ) exit( 1 ); // fast-fail
    newNode.left  = NULL; // zero-out the pointer members because `malloc` does not zero out memory for you!
    newNode.right = NULL;
    return newNode;
}

void initializeNode( struct node* parent ) {

    parent.left  = malloc( sizeof( struct node ) );
    parent.right = malloc( sizeof( struct node ) );
}

void createTree( struct node* parent, int depth ) {

    if( depth &lt;= 0 ) return NULL;

    parent.left  = allocateNode();

    createTree( parent.left, depth - 1 );

    parent.right = allocateNode();

    createTree( parent.right, depth - 1 );
}

void destroyTree( struct node* node ) {

    if( node == NULL ) return;

    destroyTree( node.left );
    destroyTree( node.right );

    free( node );
}

int main( int argc, char* argv[] ) {

    struct node* root = allocateNode();

    createTree( root, 3 );

    // (do stuff here)

    destroyTree( root );

    return 0;
}
</code></pre>

<p>I note that you could do it more efficiently by using <code>calloc</code> and allocating all nodes at once:</p>

<pre><code>int main( int argc, char* argv[] ) {

    const size_t n = 7; // a tree 3 layers deep has 7 nodes: 1, 2L, 2R, 3LL, 3LR, 3RL, 3RR
    struct node[] allNodes = calloc( n, sizeof(struct node) ); 
    if( !allNodes ) exit( 1 );

    // Binary heap array representation algorithm:
    size_t lastParent = 3;
    for( size_t i = 0; i &lt; n; i++ ) {

        if( i &lt; lastParent ) {
            allNodes[i].left  = allNodes[ ( 2 * i ) + 1 ];
            allNodes[i].right = allNodes[ ( 2 * i ) + 2 ];
        }
        else {
            allNodes[i].left  = NULL;
            allNodes[i].right = NULL;
        }
    }

    return 0;
}
</code></pre>

<h2>IMPORTANT NOTE!!!!!!11111!</h2>

<p>Never forget to call <code>free</code> for every successful <code>malloc</code> or <code>calloc</code> call! Otherwise you will leak memory!</p>
",9
55506816,55506756,1,"<p>Your code will allocate enough memory to store two pointers and one integer. It will not allocate memory for the two pointers to point at.</p>

<blockquote>
  <p>Then how come I was able to write example_node->left = NULL; right away instead of having to allocate memory for left?</p>
</blockquote>

<p>This would change the pointer, by writing <code>NULL</code> to the memory allocated to the pointer, just like <code>example_node-&gt;whatever = 0</code> would write <code>0</code> to the memory allocated to the integer. It does not do anything with any memory outside the node struct itself. However, if you were to say <code>example_node-&gt;left-&gt;foo = NULL</code>, you would be doing a Bad Thing (tm).</p>

<hr>

<p><strong>EDIT</strong>: I think you still have issues about memory of pointer and memory under pointer. Let's try an analogy. Imagine you live in an apartment building, where you can rent storage space in the basement. Imagine also that every apartment comes pre-furnished, part of which is a key rack next to the entrance. The key rack has a hook with a label ""Storage Key"".</p>

<p>If you have rented a storage room, you can put its key on the appropriate rack hook. If you have no storage room, then the hook is empty. Whether or not you have a storage room, you have allocated space for a storage room <em>key</em> (the rack hook), that is separate from the storage room itself. The key hook exists independently of the storage space.</p>

<p>Trying to open a storage room using no key is illegal.</p>

<p>Trying to open a stranger's storage room with a key you happened to find the building garage is illegal.</p>

<p>You can only open a room you <em>own</em>.</p>

<hr>

<p><code>node</code> is your apartment: if you have allocated <code>node</code> (if you have the apartment) you have space for the pointer <code>left</code> (you have the storage room key rack hook). <code>node-&gt;left</code> has memory allocated for it as part of <code>node</code> allocation (you get the storage key hook whether you rent storage or not).</p>

<p>You can assign <code>NULL</code> to <code>left</code> (putting nothing on the hook), or you can assign a pointer value (putting a key on the hook).</p>

<p>If <code>left</code> is <code>NULL</code>, you <em>can't</em> do <code>example_node-&gt;left-&gt;foo = ...</code> because a null pointer explicitly says it is not pointing to any allocated memory (can't open any storage rooms without a key).</p>

<p>You <em>can</em> do <code>example_node-&gt;left = 0xdeadbeef</code> (put someone else's storage room key on your hook), but you <em>can't</em> then <code>example_node-&gt;left-&gt;foo = ...</code> because the space at <code>0xdeadbeef</code> is likely not yours to tamper with (using someone else's storage room).</p>

<p>You <em>can</em> do <code>example_node-&gt;left = malloc(...)</code> (rent a storage room and place its key on the storage room hook), and after that you <em>can</em> do <code>example_node-&gt;left-&gt;foo = ...</code> (because you own the room and the key, and you can put in new stuff there if you want to).</p>
",2
55506810,55506756,2,"<p>Consider this</p>

<ul>
<li><code>sizeof(struct node)</code> gives the size of the <code>node</code> structure</li>
<li><code>malloc( N )</code> allocates N bytes from memory</li>
</ul>

<p>Thus <code>malloc(sizeof(struct node))</code> allocates at least the number of bytes needed to store a <code>struct node</code>.</p>

<p>Inside the structure <code>node</code></p>

<pre><code>struct example *left;
struct example *right;
int whatever;
</code></pre>

<p>these are two <em>pointers</em> to the structure <code>example</code> and an integer.</p>

<p>Thus the allocated memory space is big enough to contain these 2 pointers, and an <code>int</code>. Not the whole <code>example</code> structures, only pointers.</p>

<p>In order to complete the allocation, you probably want to allocate the two internal structures as well, like</p>

<pre><code>struct node *example_node = malloc(sizeof(struct node));

example_node-&gt;left  = malloc(sizeof(struct example));
example_node-&gt;right = malloc(sizeof(struct example));
</code></pre>

<hr>

<p>You free these allocations in reverse order, </p>

<ol>
<li>start to free <code>left</code> and <code>right</code></li>
<li><em>Then</em> free the <code>node</code> structure</li>
</ol>

<p>As soon as you free something, it's no longer available. That <em>might</em> work, but this is undefined behavior.</p>

<p>So if you free first the <code>node</code>, you cannot reliably reach the <code>left</code> and <code>right</code> members which are dependent on <code>node</code> (being inside).</p>

<pre><code>free (example_node-&gt;left);
free (example_node-&gt;right);

free (example_node);
</code></pre>
",6
53171253,53171157,2,"<p><s>First off, <code>memset</code> can be used to set a range of bytes to any value, so:</p>

<pre><code>memset(prime, '\xff', (number1-1) * sizeof(*prime));
</code></pre>

<p>should set all bits to 1 in the array; any non-zero value is true, and <code>\xff</code> is the byte pattern of all 1s, so it's as truthy as any other non-zero value.</s></p>

<p>It looks like <code>memset</code> may be inappropriate here, so the only unambiguously correct solution with no changes to program logic is a straight loop:</p>

<pre><code>for (size_t i = 0; i &lt; number1-1; ++i) {
    primes[i] = true;
}
</code></pre>

<p>That said, there is a slightly more clever way to do this: Reverse the definition of the array. Instead of the array being true when prime, make it true when not prime. That way, initialization can simplify to:</p>

<pre><code>bool *notprime = calloc(number1-1, sizeof(*prime));
</code></pre>

<p>Now you can benefit from the cheap zeroing <code>calloc</code> typically provides (when sieving large enough ranges that the OS is tapped for already zeroed memory) and avoid the need to initialize them to some other value at all.</p>

<p>Note: When you allocated the array, you wanted <code>sizeof(*prime)</code>, not <code>sizeof(prime)</code>; I fixed that in the equivalent <code>calloc</code> call.</p>
",9
54304039,54303711,0,"<p>if you do want to read the data as a file during the execution and do not want to make again the executable each time you modify the data, the only possibility seems to put the data in a <em>dynamic library</em>. Doing that you just have to redo the dynamic library each time you modify the data and start again your executable without having to build it. Of course the signature of <code>_binary_bin_data_start</code> and <code>_binary_bin_data_end</code> must not change and stay <code>char[]</code></p>
",1
57868521,57868471,2,"<p>You're wrong in that <a href=""https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html"" rel=""nofollow noreferrer""><code>execv</code></a> is blocking.</p>

<p>If <a href=""https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html"" rel=""nofollow noreferrer""><code>execv</code></a> works, it will <em>never</em> return. It <em>replaces</em> your program. You need to <a href=""https://pubs.opengroup.org/onlinepubs/9699919799/functions/fork.html"" rel=""nofollow noreferrer""><code>fork</code></a> a new process for <a href=""https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html"" rel=""nofollow noreferrer""><code>execv</code></a>:</p>

<pre><code>if (fork() == 0)
{
    // In child process, first setup the file descriptors
    dup2(fifo_out, STDOUT_FILENO);  // Writes to standard output will be written to the pipe
    close(fifo_out);  // These are not needed anymore
    close(fifo_in);

    // Run the program with execv...
}
else
{
    // Unless there was an error, this is in the parent process
    close(fifo_out);

    // TODO: Read from fifo_in, which will contain the standard output of the child process
}
</code></pre>

<hr>

<p>Another thing, you seem have two different and unconnected named pipes. You should open only <em>one</em> pipe, for reading in the parent process, and for writing in the child process:</p>

<pre><code>int fifo_in  = open(""fifo_1"", O_RDONLY| O_NONBLOCK);
int fifo_out = open(""fifo_1"", O_WRONLY| O_NONBLOCK);
</code></pre>

<p>But if you only want to communicate internally, you don't need named pipes. Instead use anonymous pipes as created by the <a href=""https://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html"" rel=""nofollow noreferrer""><code>pipe</code></a> function.</p>
",12
55875157,55874740,1,"<p>The function <code>Show_Numbers()</code> has a number of issues:</p>

<pre><code>void Show_Numbers(FILE*file)  //&lt;&lt;&lt; WHY IS file AN ARGUMENT?
{
    person user;                         // &lt;&lt;&lt;&lt; DELETE THIS
    char s[100];
    file = fopen(""contacts.txt"", ""a+"");  // &lt;&lt;&lt;&lt; OPEN FOR READ-ONLY
    printf(""%s"", user.firstName);        // &lt;&lt;&lt;&lt; DELETE THIS
</code></pre>

<p>The variable <code>user</code> is unitialised, and then only used in the attempt to print an initialised value.  As such the two lined indicated serve no purpose whatsoever and is the cause of the junk output.</p>

<p>The file is opened for appending but never written to.</p>

<p>Passing <code>file</code> as an argument serves no purpose if you are opening and closing the file locally.  Use:</p>

<pre><code>     FILE* file = fopen( ""contacts.txt"", ""r"" ) ;
</code></pre>

<p>instead, and pass no argument.</p>

<p>Then later:</p>

<pre><code>     while (fgets(s,1000,file)!=NULL)
     {
         printf(""%s"",s);
     }
</code></pre>

<p>You are reading chunks of 1000 characters into a 100 character array array.</p>

<p>Finally but less critically, at the end of the function you unnecessarily close the file that is already closed earlier in the function.</p>

<pre><code>  fclose(file);
}
</code></pre>
",0
55874986,55874740,0,"<p><code>user.firstName</code> is uninitialized in <code>Show_Numbers</code> when it is printed. Accessing uninitialized memory is undefined behavior. In this case your program interpreted whatever values were lying around in those memory addresses as a character string and printed that. It just so happened to be ""¡Á¨ª=?p¡ö`"".</p>

<pre><code>person user;
printf(""%s"", user.firstName); // uninitialized, may print garbage
</code></pre>

<p>Also, <code>fgets(s,1000,file)</code> may write outside of the buffer. <code>s</code> is only 100 chars big, not 1000.</p>
",2
58440738,58440678,0,"<p>You write a loop inside your loop and add a scanf. </p>

<pre><code>int i, j;
int sum = 0;
for (int i = 0; i &lt;= 27; i++) { 
    for (j = 0; j &lt; 10; j++) {
       int x= 0;
       scanf (""%d"", &amp;x); 
       sum += x;
    }
}
</code></pre>
",0
53361550,53361461,1,"<p>The variable called <code>Max</code> in <code>findMax</code> hides the global <code>Max</code>, so setting <code>Max</code> in the function doesn't affect the global.  You do return this value from the function, however you don't do anything with that return value:</p>

<pre><code>case 1  : findMax(); 
        printf(""%f"",Max);
</code></pre>

<p>You need to assign the return value to <code>Max</code>:</p>

<pre><code>case 1  : Max = findMax(); 
        printf(""%f"",Max);
</code></pre>

<p>Also, you should define <code>Max</code> in <code>findMax</code> as a <code>float</code>, otherwise you'll get truncated values.</p>
",0
53194402,53193417,0,"<p>the reason your code is failing is because you are trying to modify a character constant</p>

<pre><code>int main() {
    char *str1 = ""Hallo"";

..
int sicmp = stringICmp(str1, cmpstring);
..

int stringICmp(char *s1, char *s2) {
    char *s1cpy = s1, *s2cpy = s2;
    while(*s1cpy != '\0' &amp;&amp; *s2cpy != '\0'){
        if(*s1cpy &gt;= 65 &amp;&amp; *s1cpy &lt;= 90) {
            (*s1cpy) += 32; &lt;&lt;&lt;&lt; right here you try to overwrite your inpout
</code></pre>

<p>THis is not allowed. You should operate on a copy of the string (also you are destroying your input, not a polite thing to do)</p>

<p>Use strdup to copy the input string.</p>

<pre><code>int stringICmp(char *s1, char *s2) {
    char *s1cpy = strdup(s1), *s2cpy = strdup(s2);
    while(*s1cpy != '\0' &amp;&amp; *s2cpy != '\0'){
        if(*s1cpy &gt;= 65 &amp;&amp; *s1cpy &lt;= 90) {
            (*s1cpy) += 32;
....
free(s1cpy);
free(s2cpy);
</code></pre>
",0
53363856,53363559,3,"<p>Your logic for the inner loop is flawed. The condition <code>initial[i]!=final[k]</code> would be satisfied when elements are different which is not what you want. You want to check if <code>initial[i]</code> is present in the <code>final</code> array.</p>

<pre><code>for (int i = 1; i &lt; 15; ++i)
{
    bool found = false;
    for (int k = 0; k &lt; nf ; ++k)
    {
        if (initial[i]==final[k]) {
            found = true;
            break; // Found a dup, no need to continue further.
        }
    }

    // Not present in final array, so include it.
    if (!found) final[nf++] = initial[i];
}
</code></pre>
",0
54595419,54584800,1,"<p>For many of these online judge problems, a key is to think of a better way to calculate the result. They are not challenging you just to write code but to think about how better algorithms can be designed.</p>

<pre><code>#include &lt;stdio.h&gt;


int main(void)
{
    long positions = 0; //  Count positions where Bessie may be standing.
    long opens = 0;     //  Count number of times ""(("" has been seen.
    char previous = 0;  //  Remember previous character.

    //  Loop reading characters.
    while (1)
    {
        //  Get next character.
        int next = getchar();

        //  If there was no next character or the line ended, we are done.
        if (next == EOF || next == '\n') break;

        //  Count the number of times ""(("" has been seen.
        if (next == '(' &amp;&amp; previous == '(')
            ++opens;

        //  When we see ""))"", add one position for each ""(("" that precedes it.
        if (next == ')' &amp;&amp; previous == ')')
            positions += opens;

        //  Remember the character for the next iteration.
        previous = next;
    }

    //  Show the result.
    printf(""%ld\n"", positions);
}
</code></pre>
",6
56313709,56313665,2,"<p>IN</p>

<blockquote>
<pre><code>   for(i=0;i&lt;R1;i++)
   {
           for(j=0;j&lt;C1;j++)
           {
                   scanf(""%d"",&amp;mat1[R1][C2]);
           }
   }
   printf(""Enter 2nd matrix(%dX%d) :"",R2,C2);
   for(i=0;i&lt;R2;i++)
   {
           for(j=0;j&lt;C2;j++)
           {
                   scanf(""%d"",&amp;mat1[R1][C2]);
           }
   }
</code></pre>
</blockquote>

<p>you do not set the indexes and matrix you want, must be</p>

<pre><code>    for(i=0;i&lt;R1;i++)
    {
            for(j=0;j&lt;C1;j++)
            {
                    scanf(""%d"",&amp;mat1[i][j]); /* correct indexes */
            }
    }
    printf(""Enter 2nd matrix(%dX%d) :"",R2,C2);
    for(i=0;i&lt;R2;i++)
    {
            for(j=0;j&lt;C2;j++)
            {
                    scanf(""%d"",&amp;mat2[i][j]); /* correct matrix and indexes */
            }
    }
</code></pre>

<p>I also encourage you to verify your <em>scanf</em> returns 1 to check the use enter valid inputs</p>
",1
53742797,53742745,4,"<p>Terminals are, by default, designed to emit progressively more and more lines of text in a buffer. Text gets added to the end, and previous lines remain visible (up to the limit of the terminal's configured buffer size).</p>

<p>It is possible to get more of a ""GUI"" feel by changing terminal modes, and this is usually done using a library like <em>curses</em> or <em>ncurses</em>. This will permit you to show text at specific parts of the window, and remove said text. Upon ending the program, <em>curses</em> ""resets"" the terminal such that the whole ""GUI"" disappears (although some terminals will still show the user the ""final state"" of the GUI if they scroll up a page).</p>

<p>A code example would be a tutorial on how to use <em>ncurses</em>, which is a bit too broad for this medium, but not difficult to find.</p>

<p>Since you're on a beginner course, it's likely that you are being encouraged to do the next best thing, which is either:</p>

<ol>
<li>""Faking"" disappearing text by streaming a carriage return then overwriting the old line with spaces or replacement text (support for this effect varies), or</li>
<li>""Faking"" disappearing text by streaming backspace characters (support for this effect varies), or</li>
<li>Not doing it at all but instead just moving on to the next line</li>
</ol>

<p>In all cases described above except for #3, the responsibility of implementing a ""timer"" shall be yours.</p>
",1
55679753,55679199,0,"<p>Although the simplest change is to change the notation from <code>matrix[i][j]</code> to <code>*(*(matrix + i) + j)</code>, you can make more streamlined code with many fewer functions by noting that all the elements of an array are contiguous, so you can simply iterating over the elements of an array with a pointer and never adding an offset.</p>

<p>That leads to code like this:</p>

<pre><code>#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define SIZE 4
#define ROWS 3
#define COLS 20

void matRandomChar(char *mat, int rows, int cols);
void printMat(const char *tag, char *base, int rows, int cols);

void matRandomChar(char *mat, int rows, int cols)
{
    char *end = mat + rows * cols;
    while (mat &lt; end)
        *mat++ = 'A' + rand() % ('Z' - 'A' + 1);
}

void printMat(const char *tag, char *base, int rows, int cols)
{
    int i;
    printf(""%s (%dx%d):\n"", tag, rows, cols);
    for (i = 0; i &lt; rows; i++)
    {
        int j;
        for (j = 0; j &lt; cols; j++)
            printf("" %c"", *base++);
        putchar('\n');
    }
}

int main(void)
{
    char smallMat[SIZE][SIZE];
    char mat[ROWS][COLS];

    srand((unsigned int)time(NULL));

    matRandomChar(&amp;mat[0][0], ROWS, COLS);
    printMat(""Big matrix"", &amp;mat[0][0], ROWS, COLS);

    matRandomChar(&amp;smallMat[0][0], SIZE, SIZE);
    printMat(""Small matrix"", &amp;smallMat[0][0], SIZE, SIZE);

    return 0;
}
</code></pre>

<p>In both the auxilliary functions, the code simply steps through the array data one character at a time.</p>

<p>Sample output:</p>

<pre><code>Big matrix (3x20):
 P L J T B F Y L W K C P Q X B P K V D V
 K B Q P V X S B K O X C Z S U K T G F I
 E X O X H C W B K W V E F U L S O F Q G
Small matrix (4x4):
 U C R P
 A R F U
 N K Q L
 Y W R M
</code></pre>

<p>This code will work with compilers that only accept C90 as well as those that accept C99 or later.</p>

<p>I'd probably use variable length array (VLA) notation to avoid duplicating the code, but then it would be sensible to use subscripts rather than pointers.  However, the same general technique can be applied ¡ª though using subscripts is far more sensible.  The following code can be compiled with or without <code>-DNO_PRINTING_SUBSCRIPTS</code> ¡ª the output has the same organization (but the <code>- A</code> or <code>- B</code> notation tells you which printing code was used).</p>

<pre><code>#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

#define SIZE 4
#define ROWS 3
#define COLS 20

void matRandomChar(int rows, int cols, char mat[rows][cols]);
void printMat(const char *tag, int rows, int cols, char mat[rows][cols]);

void matRandomChar(int rows, int cols, char mat[rows][cols])
{
    char *ptr = &amp;mat[0][0];
    char *end = &amp;mat[0][0] + rows * cols;
    while (ptr &lt; end)
        *ptr++ = 'A' + rand() % ('Z' - 'A' + 1);
}

#ifdef NO_PRINTING_SUBSCRIPTS

void printMat(const char *tag, int rows, int cols, char mat[rows][cols])
{
    printf(""%s (%dx%d) - A:\n"", tag, rows, cols);
    char *ptr = &amp;mat[0][0];
    for (int i = 0; i &lt; rows; i++)
    {
        for (int j = 0; j &lt; cols; j++)
            printf("" %c"", *ptr++);
        putchar('\n');
    }
}

#else

void printMat(const char *tag, int rows, int cols, char mat[rows][cols])
{
    printf(""%s (%dx%d) - B:\n"", tag, rows, cols);
    for (int i = 0; i &lt; rows; i++)
    {
        for (int j = 0; j &lt; cols; j++)
            printf("" %c"", mat[i][j]);
        putchar('\n');
    }
}

#endif /* NO_PRINTING_SUBSCRIPTS */

int main(void)
{
    char smallMat[SIZE][SIZE];
    char mat[ROWS][COLS];

    srand((unsigned int)time(NULL));

    matRandomChar(ROWS, COLS, mat);
    printMat(""Big matrix"", ROWS, COLS, mat);

    matRandomChar(SIZE, SIZE, smallMat);
    printMat(""Small matrix"", SIZE, SIZE, smallMat);

    return 0;
}
</code></pre>

<p>Compiled with <code>-DNO_PRINTING_SUBSCRIPTS</code></p>

<pre><code>Big matrix (3x20) - A:
 R K Y W Y J U T C O F N Z V H Q X T P W
 Q Z R T B A O A W J O D I K F I C A R E
 V X X C R P C V H E S K G C M T Y B Z D
Small matrix (4x4) - A:
 V R E M
 P T D G
 U C Q F
 D Q B F
</code></pre>

<p>Compiled with <code>-UNO_PRINTING_SUBSCRIPTS</code></p>

<pre><code>Big matrix (3x20) - B:
 L C K V S P C T L V B P G U I O Q L E B
 N S C Y B I L Y G S F Z C H L Z M G A E
 B P A I H E M X H V C M B Z U Y S D W A
Small matrix (4x4) - B:
 O N U T
 H X X P
 P L M L
 K R S F
</code></pre>
",3
53913980,53913570,3,"<ol>
<li><p>Since <code>head</code> is defined as <code>char head[i]</code>, its last element is <code>head[i-1]</code>. Attempting to access <code>head[i]</code> has behavior not defined by the C standard.</p></li>
<li><p>Since <code>w</code> is defined as <code>char w[i]</code>, its last element is <code>w[i-1]</code>. Attempting to access <code>w[i]</code> has behavior not defined by the C standard.</p></li>
<li><p>Since <code>v</code> is defined as <code>char v[strlen(arg) - i]</code>, its last element is <code>v[strlen(arg) - i - 1]</code>. Attempting to access <code>v[strlen(arg) - 1]</code> has behavior not defined by the C standard.</p></li>
<li><p>Since <code>w</code> is defined inside a brace-enclosed block of statements without <code>extern</code> or <code>static</code>, it is has automatic storage duration associated with the block, so it exists only while the function is block. When the <code>return</code> statement is executed, <code>w</code> ceases to exist (in C¡¯s abstract machine). The statement <code>return w;</code> attempts to return a pointer to the first element of <code>w</code> (because, in this use, an array is automatically converted to a pointer to its first element). When this <code>return</code> statement is executed, the pointer becomes invalid.</p></li>
<li><p>Since <code>v</code> is defined inside a brace-enclosed block of statements without <code>extern</code> or <code>static</code>, it has automatic storage duration associated with the block, so <code>v</code> exists only while the statement is executing. When <code>return v;</code> is executed, execution of the block ends, and the returned pointer becomes invalid.</p></li>
<li><p><code>head[i]</code> is a character, but <code>""\0""</code> is a string containing one character, so <code>head[i] = ""\0"";</code> is an improper assignment. The string will be converted to a pointer to its first element, resulting in an attempt to assign a pointer to a <code>char</code>. This is a constraint violation, and your compiler should produce a warning for it. The same problem occurs in <code>w[i] = ""\0"";</code> and <code>v[strlen(arg)-i] = ""\0"";</code>. The proper code would be <code>head[i] = '\0';</code> (once the size of <code>head</code> is fixed to include an element <code>head[i]</code>).</p></li>
</ol>

<p>Remedies include:</p>

<ul>
<li>Define each array to be large enough for all the elements to be written into it.</li>
<li>To return strings created inside a function, either dynamically allocate space for them (as with <code>malloc</code>), create the strings inside arrays provided by the caller, or use arrays with static storage duration. If you use the first option, dynamically created arrays, you should make provisions for the space to be released (as by the caller passing them to <code>free</code> when done with them). You should avoid using arrays with static storage duration, as it has limited and troublesome use (such as the fact that only one such array exists for each definition, yet a function may be called multiple times by callers that each want their own separate data).</li>
</ul>
",4
53398907,53398680,0,"<p>There are a few problems with your code.</p>

<ol>
<li><p><code>scanf</code> should just contain the format specifier you're scanning for, in addition to a prepended space for ignoring whitespace in <code>stdin</code>. </p>

<pre><code>printf(""Please enter an integer: "");
scanf("" %d\n"", &amp;choosen_number);
</code></pre></li>
<li><p>In your second <code>while</code> loop where you process the number digit-by-digit, you only decrement <code>count</code> if the digit you're currently processing is equal to 1. This means that for any number that isn't composed entirely of 1s, you will have an infinite loop.</p></li>
</ol>
",0
56334854,56334633,1,"<blockquote>
  <p>Trying to overloading a function in C programming language</p>
</blockquote>

<p><strong><a href=""https://en.wikipedia.org/wiki/C11_(C_standard_revision)"" rel=""nofollow noreferrer"">C11</a> does not have any <a href=""https://en.wikipedia.org/wiki/Function_overloading"" rel=""nofollow noreferrer"">function overloading</a></strong> and <strong><code>_Generic</code> is for <a href=""https://en.wikipedia.org/wiki/Generic_programming"" rel=""nofollow noreferrer"">genericity</a></strong>, <em>not</em> for overloading, check that by reading <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">n1570</a>. Consider switching to C++ (or even better, <a href=""https://www.rust-lang.org/"" rel=""nofollow noreferrer"">Rust</a>) which provides function overloading. Notice that it is illegal to have a <code>void</code> (not <code>void*</code>, just <code>void</code>) argument to a C function, so there is no any <a href=""https://en.wikipedia.org/wiki/Lattice_(order)"" rel=""nofollow noreferrer"">""top""</a> super-type in C, which would be a super type of other types (and this because of <a href=""https://en.wikipedia.org/wiki/Calling_convention"" rel=""nofollow noreferrer"">calling conventions</a> and <a href=""https://en.wikipedia.org/wiki/Application_binary_interface"" rel=""nofollow noreferrer"">ABI</a> considerations making C a <em>low-level</em> programming language, sometimes even called a ""<a href=""https://en.wikipedia.org/wiki/Software_portability"" rel=""nofollow noreferrer"">portable</a> assembler""). Read more about <a href=""https://en.wikipedia.org/wiki/Abstract_interpretation"" rel=""nofollow noreferrer"">abstract interpretation</a> and <a href=""https://en.wikipedia.org/wiki/Type_system"" rel=""nofollow noreferrer"">type systems</a> please.</p>

<p>If <code>_Generic</code> was for overloading, the members of the C11 standard committee - all programming language experts and good enough English writers -  would have named it like <code>_Overload</code>, but they wisely did not.</p>

<p><strong>Food for thought</strong> (assuming both <code>stderr</code> and <code>stdin</code> works like you want them to work) <strong>:</strong> <br/> <strong>what about some hypothetical <code>display(stderr)</code> or <code>display(*stdin)</code> or <code>display(""abc"")</code> ?</strong></p>

<p><sup>(a wrong suggestion below, followed by a better advice)</sup></p>

<h3>bad approach</h3>

<p>(<strong>this does not work!</strong>)</p>

<p>Your  <code>display_void</code> should take some argument, e.g.</p>

<pre><code>void display_void(void*p) { printf(""p@%p\n"", p);
</code></pre>

<p>Then you might have:</p>

<pre><code>#define display_anything(P) display_void((void*)(&amp;(P)))
</code></pre>

<p>with</p>

<pre><code>#define display(x) _Generic((x), \
      float: display_float, \
      int: display_int,  \
      default: display_anything  \
)(x)
</code></pre>

<h2>better advice</h2>

<p>Since that does not work (and it does not), <strong>design your code in some other way</strong>. For example, consider having some <a href=""https://en.wikipedia.org/wiki/Tagged_union"" rel=""nofollow noreferrer"">tagged union</a>, like <a href=""https://stackoverflow.com/a/53978380/841108"">here</a>. Look into <a href=""https://developer.gnome.org/glib/stable/glib-GVariant.html"" rel=""nofollow noreferrer"">GVariant</a> (from Glib) implementation for inspiration.</p>
",2
53946133,53945332,0,"<p>You're not reallocating what you think you are.</p>

<p>When you do this:</p>

<pre><code>*x = (int**)realloc(*x,nNew*sizeof(int*));
</code></pre>

<p>for(int i=0;i

<p>Since <code>x</code> has type <code>int **</code>, <code>*x</code> has type <code>int *</code>.  Also, <code>*x</code> is the same as <code>x[0]</code>.  So you're not reallocating the array of pointers on the first line but the first array of <code>int</code>.  You need to call <code>realloc</code> on the original pointer, <em>and</em> you need to pass the address of that pointer so that the change is visible in the calling program.</p>

<p>Then for the reallocation of the individual arrays, you need to call <code>realloc</code> on the original <code>n</code> to grow or shrink them, then either <code>free</code> the extra rows if growing or <code>malloc</code> the newly added rows.  In the growing case you want to <code>realloc</code> the array of pointers fisrt, and in the shrinking case you want to do that last.</p>

<p>So after those changes your <code>update</code> function should look like this:</p>

<pre><code>void update(int ***x, int n, int nNew)
{
    if(n&gt;nNew) {
        // shrink each row to be kept
        for(int i=0;i&lt;nNew;i++)
           (*x)[i] = realloc((*x)[i],nNew*sizeof(int));

        // free the extra rows
        for(int i=nNew;i&lt;n;i++)
            free((*x)[i]);

        // shrink the list of rows
        *x = realloc(*x,nNew*sizeof(int*));

    } else if(n&lt;nNew) {
        // grow the list of rows
        *x = realloc(*x,nNew*sizeof(int*));

        // grow the existing rows
        for(int i=0;i&lt;n;i++)
            (*x)[i] = realloc((*x)[i],nNew*sizeof(int));

        // create the new rows
        for(int i=n;i&lt;nNew;i++)
            (*x)[i] = malloc(nNew*sizeof(int));
    }
}
</code></pre>

<p>And you call it like this:</p>

<pre><code>update(&amp;x,n,nNew);
</code></pre>
",0
53449327,53449118,2,"<p>The language does not prevent you from using negative numbers in indexing of an array or a pointer. This does not meant that it is always correct. i.e. in your example it would access an array element which is 1 position <strong>before</strong> the beginning of the array. in other words you access invalid memory addres.</p>

<p>However in the situation like the following, where p1 points to a non-0 element of the array, you can use negative indexes:</p>

<pre><code>int p[] = {1,2,3,4};
int *p1 = &amp;p[1];

int x = *(p1-1);
int y = p1[-1]; // equivalent to the previous one
</code></pre>

<p>In both cases 'x' and 'y' will become '1';</p>
",0
55094554,55094424,2,"<p>The error messages:</p>

<pre><code>./bin/compare_money_descending.o: In function `compare_money_ascending':
compare_money_descending.c:(.text+0x0): multiple definition of `compare_money_ascending'
</code></pre>

<p>say that the source file <code>compare_money_descending.c</code> contains a definition of <code>compare_money_ascending</code> although a prior definition of it already exists. Since the file name <code>compare_money_descending.c</code> suggests it contains a function named <code>compare_money_descending</code> but we are getting an error about <code>compare_money_ascending</code>, it is likely the mistake is that <code>compare_money_descending.c</code> contains a definition using a function name of <code>compare_money_ascending</code> where <code>compare_monehy_descending</code> was intended. Quite likely you copied and pasted source code to use as a new function but forget to change the name.</p>

<p>The second message:</p>

<pre><code>sortMe.c:(.text+0x59f): undefined reference to `compare_money_descending'
</code></pre>

<p>tells us the program does not contain a definition of <code>compare_money_descending</code>, which tends to confirm the above hypothesis.</p>
",0
53710451,53709904,0,"<p>I fixed the direct issues in your program.
The deeper point here though is how to get to the pointer you want.</p>

<p><code>array[4]</code> gets the value of the 4th element.
<code>array</code> gets the pointer to the first element
<code>&amp;array[4]</code> gets the pointer to the 4th element
<code>array + 4</code> gets the pointer to the 4th element
<code>*(array + 4)</code> gets the value of the 4th element
<code>*array[4]</code> gets the value, treats it as a pointer and tries to get a value from the pointers target - this would require extra fiddling to convince the compiler what type that would be. In most cases this is likely meaningless.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

typedef struct humans {
    char sname[20];
}human;


void MyStrCpy(char * dst, int dst_n, char * src, int src_n)
{
    for (int n = 0; n &lt; dst_n &amp;&amp; n &lt; src_n; ++n)
    {
        dst[n] = src[n];
        if (src[n] == 0) break;
    }
    dst[dst_n] = 0;
}


int main() {
    human *person = (human *)malloc(sizeof(human) * 1);

    int i, k, z;
    for (i = 0; i&lt;5; i++) {
        person = (human *)realloc(person, sizeof(human)*(i + 1));
        //I replace strcpy so it compiles on my machine
        MyStrCpy(person[i].sname, 20, ""john"", 5);
        person[i].sname[20] = 0;
    }

    for (i = 0; i&lt;5; i++) {
        printf(""%s\n"", person[i].sname);
    }
    return 0;
}
</code></pre>
",0
53709959,53709904,0,"<p>Where you have <code>*person[i].sname</code>, you want <code>person[i].sname</code> instead. When you put <code>*</code> before it, you force the array to decay to a pointer to its first element which, when dereferenced, gives you the value of the first element.</p>

<p>Also:</p>

<pre><code>    person=(human *)realloc(person,sizeof(human)*1);
</code></pre>

<p>This <code>1</code> should be <code>i + 1</code>.</p>
",1
54238406,54233802,0,"<blockquote>
<p>I have been asked to write a code that receives a type of data without being specific about what type (example, int, float, double ect..) and its certainly a number.</p>
<p>So how can i use all types of data?</p>
</blockquote>
<p>You can't. More specifically, the CPU itself can't. To compare 2 numbers, the CPU has to know what size the numbers are, if the numbers are integer or floating type, and (if it's not just comparing for equality) if the number is signed or not.</p>
<p>There are 3 ways around this:</p>
<p>a) Code duplication (including templates in C++ where the compiler automatically generates N versions of the code for N types, and using macros in C to do similar).</p>
<p>b) Only support the largest type (e.g. maybe <code>double</code> in C) and convert everything to the largest type so that you only need one function for one type.</p>
<p>c) Abuse variable arguments and have run-time branches based on a &quot;what type is it&quot; argument (and increased risk of programmer mistakes); like <code>int findselectnum(char *data_type, int size, ...)</code>. This mostly ends up being code duplication in disguise (e.g. you'd duplicate the loop in each <code>case</code> of a <code>switch(data_type)</code>).</p>
<p>Depending on the actual situation; I'd use a mixture of the first 2 options - e.g. find out why the software has been so poorly designed that it needs to do the same work on multiple different types, then try to change the design so it only needs to care about a small number of different types; then have a small number of different functions for the types that are &quot;unavoidably necessary&quot; (e.g. maybe an <code>int findselectnum_int(int num, int array[], int size)</code> and a separate <code>int findselectnum_double(double num, double array[], int size)</code>; with nothing for <code>float</code> or <code>short</code> or whatever because they were avoidable).</p>
",0
54931378,54931215,1,"<p>You're passing the old <code>sum</code> to <code>cvtdigit</code>, you should add to that, not use an uninitialized local variable.</p>

<p>You get the numeric value of a digit by subtracting <code>'0'</code> from it.</p>

<pre><code>int cvtdigit(int sum, char c)
{
    int d = c - '0';
    sum += d;
    return sum;        
}
</code></pre>
",0
54931407,54931215,1,"<p>The problem is in your sum function:</p>

<pre><code>int cvtdigit(int d, char c)
{
    int sum;
    sum=sum+d;
    return (sum);        
}
</code></pre>

<p>The original <code>sum</code> from <code>main</code> is stored in <code>d</code>.  What you end up doing is creating a new variable named <code>num</code> that is not initialized, adding the value of <code>d</code> (i.e. <code>sum</code> in <code>main</code>) to the uninitialized <code>sum</code> and returning that value.  That's why you're getting strange numbers.</p>

<p>Change the function to remove <code>sum</code> and add the value of <code>d</code> (which you should rename to <code>sum</code>) and <code>c</code>, first subtracting <code>'0'</code> i.e. the character code for the character 0 from <code>c</code> so you get a value from 0 to 9.</p>

<pre><code>int cvtdigit(int sum, char c)
{
    sum=sum+(c-'0');
    return sum;
}
</code></pre>
",2
55264707,55264390,1,"<p>The main issue is explained in my comment:</p>

<blockquote>
  <p>You're not passing a valid pointer to the thread function.  You sort of, mostly, almost get away with the misuse of it in the <code>printf()</code> call in <code>robotAct()</code>; you emphatically do not get away with it in the call to <code>Learning()</code> where you dereference the invalid non-pointer.</p>
</blockquote>

<p>A solution is to create an array of integers in the main program which holds robot ID numbers (<code>int id[N];</code>). Then, initialize each element and pass <code>&amp;id[i]</code> to <code>pthread_create()</code>.  </p>

<p>You should not print addresses with the <code>%d</code> format (even though it works on 32-bit systems; it does not work on 64-bit systems). The correct technique is to use <code>%p</code> to format the address. Or, in this case, print the integer and not the address using <code>*robot_id</code>.</p>

<p>The code that follows has minimal adaptations to the original code and has not been compiled or tested (there could be problems outside the lines changed):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;

#define N 5
#define M 3
#define LEFT (robot_id - 1) % N
#define RIGHT (robot_id + 1) % N

pthread_t robots_id[N];
sem_t simulations[M];
pthread_mutex_t sever_mutex;

void Learning(int robot_id)
{
    printf(""learning robot = %d\n"", robot_id);
}

void *robotAct(void *id)
{
    int *robot_id = id;
    printf(""robot id = %d\n"", *robot_id);        // Changed
    Learning(*robot_id);
    return 0;                                    // Added
}

int main(int argc, char *argv[])
{
    int E, T;
    int id[N];                                   // Added

    E = atoi(argv[1]);
    T = atoi(argv[2]);

    printf(""Initializing Robot!\n"");

    //Initializes the simulations
    for (int i = 0; i &lt; M; i++)
    {
        sem_init(&amp;simulations[i], 0, 0);
    }

    //Initializes the robots
    for (int i = 0; i &lt; N; i++)
    {
        printf(""Robot %d is created\n"", i + 1);
        id[i] = i + 1;                                          // Added
        pthread_create(&amp;robots_id[i], NULL, robotAct, &amp;id[i]);  // Changed
    }

    sleep(T);

    printf(""Terminating Robots\n"");
    for (int i = 0; i &lt; N; i++)
    {
        pthread_cancel(robots_id[i]);
    }
    printf(""Termination is completed!\n"");
    printf(""-------Report-------------\n"");
    //getReport();
    return 0;
}
</code></pre>

<p>Avoid using <code>pthread_cancel()</code> for ending the threads; the threads should terminate under control.  For example, there might be a flag that you set in the main thread to indicate that the threads should cease, and they'd check that periodically. Normally, <code>pthread_join()</code> is used to clean up the completed threads.</p>

<p>For future posts, please read about how to create an MCVE (<a href=""https://stackoverflow.com/help/mcve"">Minimal, Complete, Verifiable Example</a>).  There are parts of the code shown that are not relevant to the problem ¡ª the mutex and the semaphores, for example, are not really used.</p>
",0
54297880,54297540,-1,"<p>Your macro definition isn't defined correctly.  You also use it to define two functions with the same which isn't allowed.</p>

<p>This:</p>

<pre><code>finder(funcfind, int array[], int %d\t, int %d\t);
</code></pre>

<p>Expands to:</p>

<pre><code>void funcfind(int %d\t int array[][], int %d\t, int size)
...
</code></pre>

<p>And this:</p>

<pre><code>finder(funcfind, int array[] ,double %f, int %d\t)
</code></pre>

<p>To this:</p>

<pre><code>void funcfind(double %f int array[][], double %f, int size)
...
</code></pre>

<p>Which is invalid syntax.</p>

<p>Define the macro as follows to create a separate function for each type, then you can use a <code>_Generic</code> to choose which function to call:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define finder_impl(type)\
void find_ ## type(type array[], type num, int size)\
{\
    int location = 0, i;\
    for (i = 0; i &lt; size; i++)\
    {\
        location++;\
        if (array[i] == num)\
            break;\
    }\
    if (location &lt; size)\
        printf(""Location of the number is at %d place\n"", location);\
    else\
        printf(""Location of number not found\n"");\
}

finder_impl(int)
finder_impl(double)

#define findfunc(array, num, type) \
    _Generic ((num), \
              int: find_int,\
              double: find_double\
             )(array, num, type)

int main()
{
    int array[] = { 5,6,7,88,12,3,20 }, num;
    int size;
    size = sizeof(array) / sizeof(array[0]);
    scanf(""%d"", &amp;num);
    findfunc(array, num, size);

    double array2[] = { 2.5, 4, 3.25, 7 }, num2;
    size = sizeof(array) / sizeof(array[0]);
    scanf(""%lf"", &amp;num2);
    findfunc(array2, num2, size);
}
</code></pre>
",2
54297669,54297540,0,"<p>If I pass the pre processing (gcc -E) the result is :</p>

<pre><code>void funcfind(int %d\t int array[][], int %d\t ,int size){ int location = 0, i; for (i = 0; i &lt; size; i++) { location++; if (int array[][i] == num) break; } if (location != arry[0] printf(""Location of the number is at %d place\n"", result); else printf(""Location of number not found\n"");};
void funcfind(double %f int array[][], double %f ,int size){ int location = 0, i; for (i = 0; i &lt; size; i++) { location++; if (int array[][i] == num) break; } if (location != arry[0] printf(""Location of the number is at %d place\n"", result); else printf(""Location of number not found\n"");}
</code></pre>

<p><em>type</em> is <code>int %d\t</code> so the first parameter is wrong, why that <code>int %d</code> rather than <code>int v</code> for instance ?</p>

<p>because it is difficult to guess what you want I let you continue to fixe the problems</p>

<p>anyway in the macro 
- <code>void find_num(type array[], type ,int size)</code> is strange and perhaps must be <code>void find_num(type array[], type num,int size)</code> and the calls <code>void find_num(type array[], type ,int size);</code> and <code>finder(funcfind, array ,double, int %d\t)</code> 
- <code>if (location != arry[0]\</code> must be <code>if (location != array[0])\</code></p>

<p>that gives :</p>

<pre><code>void funcfind(int array[], int num ,int size){ int location = 0, i; for (i = 0; i &lt; size; i++) { location++; if (array[i] == num) break; } if (location != array[0]) printf(""Location of the number is at %d place\n"", result); else printf(""Location of number not found\n"");};
void funcfind(double array[], double num ,int size){ int location = 0, i; for (i = 0; i &lt; size; i++) { location++; if (array[i] == num) break; } if (location != array[0]) printf(""Location of the number is at %d place\n"", result); else printf(""Location of number not found\n"");}
</code></pre>

<p>if I indent the first function :</p>

<pre><code>void funcfind(int array[], int num ,int size){
  int location = 0, i;
  for (i = 0; i &lt; size; i++) {
    location++;
    if (array[i] == num)
      break;
  }
  if (location != array[0])
    printf(""Location of the number is at %d place\n"", result); 
  else
    printf(""Location of number not found\n"");
};
</code></pre>

<p>so there are some few error like <em>result</em> unknown etc, but I think you can solve easily</p>
",4
53575120,53574786,2,"<p>In C, when two real<sup>1</sup> arithmetic operands are added, they are converted to a common type:</p>

<ul>
<li>If either operand is <code>long double</code>, the other is converted to <code>long double</code>, and the result is <code>long double</code>.</li>
<li>Otherwise, if either operand is <code>double</code>, the other is converted to <code>double</code>, and the result is <code>double</code>.</li>
<li>Otherwise, if either operand is <code>float</code>, the other is converted to <code>float</code>, and the result is <code>float</code>.</li>
<li>Otherwise, both operands are integers, and additional rules for integer operands apply.</li>
</ul>

<p>So, in your <code>i + f</code>, <code>i</code> is converted to a <code>float</code>, the values are added, and the result is a <code>float</code>.</p>

<p>You then assign it to an <code>int</code>. In assignment, the value is converted to the type of the destination. So the <code>float</code> sum is converted to <code>int</code>.</p>

<p>The rules for converting arithmetic operands are called ¡°the usual arithmetic conversions¡± and are specified in C 2018 6.3.1.8. The rules for assignment are specified in C 6.5.16.1.</p>

<h1>Note</h1>

<p><sup>1</sup> Complex numbers are handled similarly.</p>
",0
58477919,58477780,-1,"<p>Capital letters in ASCII are in the range 65-90, 65 being 'A', 66 being 'B' etc. Lowercase letters are in the range 97-122, 97 being 'a', 98 being 'b', etc.</p>

<p>Hence, in order to convert from capital to lowercase, you need to add 32 <em>('a' - 'A')</em> to the capital letter's ASCII equivalent.</p>

<p>Here is a function that takes a char array as input and converts each uppercase letter to lowercase:</p>

<pre><code>void toLower(char string[]) {
    // Looping through each character in string
    for (int i = 0; i &lt; strlen(string); i++) {
        // Checking if character is a capital letter (range 65-90)
        if (string[i] &lt;= 'Z' &amp;&amp; string[i] &gt;= 'A') {
            //Add difference between lowercase and uppercase.
            string[i] += 'a' - 'A';
        }
    }
}
</code></pre>
",1
53535676,53535547,1,"<p>You can use a global header including all files</p>

<pre><code>/* glob.h */

#ifndef GLOB_H
#define GLOB_H

#include ""header1.h""   
#include ""header2.h""   

#endif /* GLOB_H */
</code></pre>

<p>and in your main file</p>

<pre><code>#include ""glob.h""
</code></pre>

<p>Even if this is considered bad style, there are several projects using this approach, i.e. <a href=""https://github.com/GNOME/gtk/blob/master/gtk/gtk.h"" rel=""nofollow noreferrer"">gtk</a></p>
",3
54135786,54135677,3,"<p>You can not, <code>void *</code> is generic and there is no way to know the original type, consider using an <code>union</code></p>

<pre><code>enum type {TYPE_INT, TYPE_CHAR);

struct mytype {
    enum type;
    union {
        int *as_int;
        char *as_char;
    } data;
};
</code></pre>

<p>and pass it to the function:</p>

<pre><code>int func(struct mytype *mydata) {
  if (mydata-&gt;type == TYPE_INT) {
      return *(mydata-&gt;data.as_int);
  } else {
      //Process
  }
  ...
</code></pre>

<p>Under C11 you can use anonymous <code>union</code>s, then you can ommit the <code>union</code> name:</p>

<pre><code>struct mytype {
    enum type;
    union {
        int *as_int;
        char *as_char;
    };
};
...
  if (mydata-&gt;type == TYPE_INT) {
      return *(mydata-&gt;as_int);
</code></pre>
",3
54137465,54135677,3,"<blockquote>
  <p>How can I do this without the programmer calling this function having to pass a further variable to tell the function what value it is processing(?)</p>
</blockquote>

<p>If you can pass something other than only <code>void*</code>, use <code>_Generic</code> (since C11) to unburden the caller and steer code to call the needed function.  This approach uses a macro to steer the code, akin to <a href=""https://stackoverflow.com/questions/54135677/determine-what-a-function-has-been-passed-with-a-void-pointer-char-int-ore-fail/54137465#comment95102843_54135677"">@tadman</a> comment.</p>

<hr>

<pre><code>void func_int(int x) {
  printf(""int: %d\n"", x);
}

void func_char(char x) {
  printf(""char: %c\n"", x);
}

#define func(X) _Generic((X), \
  int: func_int, \
  char: func_char \
)(X)
</code></pre>

<p>Usage.  No need for the caller to specify one of the implemented types: <code>int</code>, <code>char</code>.  Just use <code>func()</code>.</p>

<pre><code>int main() {
  int i = 42;
  char c = 'X';
  func(i);
  func(c);
}
</code></pre>

<p>Output</p>

<pre><code>int: 42
char: X
</code></pre>
",0
53393707,53393541,7,"<p>In this case you can use the bitwise AND-operator (&amp;) instead:</p>

<pre><code>if(opt &amp; 1)
{
  // option 1 or 3 chosen
}
if(opt &amp; 2)
{
  // option 2 or 3 chosen
}
</code></pre>

<p>The decimal numbers <code>1</code>, <code>2</code> and <code>3</code> are in binary <code>01</code>, <code>10</code> and <code>11</code> respectively. (Denoted as <code>0b01</code>, <code>0b10</code> and <code>0b11</code> below to distinguish from decimal numbers).</p>

<p>The <em>bitwise AND-operator</em> yields a <code>1</code> if and only if both bits are <code>1</code>.<br>
I.e. <code>1 &amp; 1 = 1</code>, <code>0 &amp; 1 = 0</code>, <code>1 &amp; 0 = 0</code> and <code>0 &amp; 0 = 0</code>.</p>

<p>Truth-table:</p>

<pre><code>&amp;   0  1
   -----
0 | 0  0
1 | 0  1
</code></pre>

<p>When <code>opt</code> equals 1 then only the first if-statement is true.<br>
<code>0b01 &amp; 0b01 = 0b01</code> (<strong>true</strong>) and <code>0b01 &amp; 0b10 = 0b00</code> (<strong>false</strong>)  </p>

<p>When <code>opt</code> equals 2 then only the second if-statement is true.<br>
<code>0b10 &amp; 0b01 = 0b00</code> (<strong>false</strong>) and <code>0b10 &amp; 0b10 = 0b10</code> (<strong>true</strong>)</p>

<p>When <code>opt</code> equals 3 then both if-statements are true.<br>
<code>0b11 &amp; 0b01 = 0b01</code> (<strong>true</strong>) and <code>0b11 &amp; 0b10 = 0b10</code> (<strong>true</strong>)</p>

<p>Anything not zero is true so all your conditions are met accordingly.</p>
",0
54067392,54067315,2,"<p>Erik, you should define your array in a coherent way. To allow the necessary number of elements, try defining a numeric constant. You could use it for both define the number of iterations of your cycle and the size of your grade array. You can also avoid a new cycle to calculate the sum of the array, you can do this operation while reading the grades, using only one for loop. Try this way:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_GRADES 100

int main()
{
    int j,sum=0,i;
    float average;
    int grade[MAX_GRADES];

    for(j = 0 ; j &lt; MAX_GRADES; j++)
    {
        printf(""Type a grade:\t"");
            scanf(""%d"",&amp;i);

       if ( (i&lt;10) || (i&gt;20) )
        break;

      grade[j] = i;
      sum += i;
    }

  if (j &gt; 0)
    average = (float)sum/j;
  else
    average = 0;

  printf(""The average is: %d, %d, %.2f\n"",sum, j, average);
  system(""pause"");
  return 0;
}
</code></pre>
",5
54026355,54026145,1,"<p>This is a very simple solution.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

int letter_sort(const void* a, const void* b)
{
    return tolower(*(const char*)a) - tolower(*(const char*)b);
}

char* sentence_sort(char* s)
{
    char _[strlen(s)+1];
    strcpy(_,s);

    for(char* w = strtok(_, "" .""); w; w = strtok(NULL, "" .""))
    {
        qsort(w, strlen(w), !!w, letter_sort);
        memcpy(s+(w-_), w, strlen(w));
    }
    return(s);
}


int main(void) {
    char sent[101];

    printf(""Input a sentence with no more than 100 characters \n"");
    scanf(""%[^\n]"", sent);

    printf(""Sentence before sorting: %s\n"", sent);
    printf(""Sentence after  sorting: %s\n"", sentence_sort(sent));

    return 0;
}
</code></pre>

<h1>Output</h1>

<pre><code>Success #stdin #stdout 0s 9424KB
Input a sentence with no more than 100 characters 
Sentence before sorting: The quick Brown fox Jumped over the Lazy Dogs.
Sentence after  sorting: ehT cikqu Bnorw fox deJmpu eorv eht aLyz Dgos.
</code></pre>
",5
54026355,54026145,1,"<p>This is a very simple solution.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

int letter_sort(const void* a, const void* b)
{
    return tolower(*(const char*)a) - tolower(*(const char*)b);
}

char* sentence_sort(char* s)
{
    char _[strlen(s)+1];
    strcpy(_,s);

    for(char* w = strtok(_, "" .""); w; w = strtok(NULL, "" .""))
    {
        qsort(w, strlen(w), !!w, letter_sort);
        memcpy(s+(w-_), w, strlen(w));
    }
    return(s);
}


int main(void) {
    char sent[101];

    printf(""Input a sentence with no more than 100 characters \n"");
    scanf(""%[^\n]"", sent);

    printf(""Sentence before sorting: %s\n"", sent);
    printf(""Sentence after  sorting: %s\n"", sentence_sort(sent));

    return 0;
}
</code></pre>

<h1>Output</h1>

<pre><code>Success #stdin #stdout 0s 9424KB
Input a sentence with no more than 100 characters 
Sentence before sorting: The quick Brown fox Jumped over the Lazy Dogs.
Sentence after  sorting: ehT cikqu Bnorw fox deJmpu eorv eht aLyz Dgos.
</code></pre>
",5
54864671,54861815,0,"<p>As you're reading the number from the user, read a string.</p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {
    char buf[999];
    while (fgets(buf, sizeof buf, stdin)) { // read a string rather than scanf an integer
        buf[strcspn(buf, ""\n"")] = 0; // remove trailing newline
        char *p = buf;
        int invalidflag = (*p == 0);
        unsigned sum = 0;
        unsigned product = 1;
        while (*p) {
            if (isdigit((unsigned char)*p)) {
                sum += *p - '0';
                product *= *p - '0';
            } else {
                invalidflag = 1;
                break;
            }
            p++;
        }
        if (invalidflag) {
            printf(""input = \""%s\"" ==&gt; INVALID INPUT\n"", buf);
        } else {
            printf(""input = \""%s\""; sum = %d; product = %d\n"", buf, sum, product);
        }
    }
    return 0;
}
</code></pre>

<p><a href=""https://ideone.com/ZLkOfJ"" rel=""nofollow noreferrer"">See ideone.com/ZLkOfJ</a></p>
",0
54861869,54861815,1,"<p><code>%</code> is the modulus operation, i.e. it gives you the reminder of the division by the divisor. In your case the operation <code>% 10</code> effectively returns the last digit of the number. You sum this digit to the <code>prod</code> variable which represents the total sum of digits. Once you have summed the current digit you perform the next main operation <code>/ 10</code> which is integer divison and just removes the last digit of the number.</p>
",0
53600367,53599821,1,"<p>Your function is defined to return an <code>int</code>; and it will return an integer value, if and <em>only if</em> <code>size == 1</code>. </p>

<p>If size has another value, it will not return anything at all!<br>
Where is a second return statement?</p>

<p>There are other substantial problems, such as the size of Array <code>b</code> is not well defined, and you overwrite memory there.</p>
",0
53600367,53599821,1,"<p>Your function is defined to return an <code>int</code>; and it will return an integer value, if and <em>only if</em> <code>size == 1</code>. </p>

<p>If size has another value, it will not return anything at all!<br>
Where is a second return statement?</p>

<p>There are other substantial problems, such as the size of Array <code>b</code> is not well defined, and you overwrite memory there.</p>
",0
53436220,53436191,3,"<p><a href=""https://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer"">This will print:</a></p>

<ul>
<li><code>%d</code>, i.e. the decimal value of <code>int n</code></li>
<li><code>! =</code>, i.e. the literal character sequence</li>
<li><code>%ld</code>, i.e. the decimal value of <code>long f</code></li>
</ul>
",0
53436293,53436191,1,"<p>printf() allows you to print a string with variables inside of it. Let's say you have a variable <code>i</code>, containing an integer, 7.</p>

<pre><code>printf(""My variable is %d"", i);
</code></pre>

<p>Will print</p>

<pre><code>My variable is 7
</code></pre>

<p>to the console! That's because %d is how you tell printf(), ""Hey, put an integer variable here!"". The integer is then supplied as the next argument to the function. In your case, %d represents the integer <code>n</code>, and %ld represents the <em>long</em> integer <code>f</code>. Since f might be really big, we make it a long, which means more bytes are allocated to it internally on your computer. So for example, if we wanted to get the factorial of 5 and print it, we might do the following:</p>

<pre><code>printf(""Factorial of %d equals %ld\n"", 5, factorial(5))
// this will print ""Factorial of 5 is 120"" then a newline
</code></pre>

<p>Oh, and <code>\n</code> just means print a newline afterwords!</p>
",0
53440561,53436813,0,"<p>I'm going to give an answer because you have posted your current code as your effort. As other answers you should use <code>isdigit(x)</code> function.</p>

<pre><code>...
else if (strlen(telNum) == 10)
{
    int i;
    char err = 0;
    for (i = 0; i &lt; 10; i++) {
        if (!isdigit(telNum[i])) {
             // Your error here
             printf(""Non-digit character found"");
             err = 1;
             break;
        }
    }
    if (err == 0) {
        return telNum;
    }
}
...
</code></pre>
",0
54071942,54071862,2,"<p>You can do this:</p>

<pre><code>int main(){
int n, count =0;
printf(""enter an integer = "");
scanf(""%d"", &amp;n);
printf(""your number %d has "", n);
while (n!=0){
n/=10;
count++;
}
printf(""%d digits"", count);
return 0;
} 
</code></pre>

<p>Of course, you may have to do some error checks..</p>
",0
54071903,54071862,1,"<p>You can keep a copy of the original variable and use that copy of the variable while printing.</p>
",0
53772291,53772230,5,"<p>Look hard at the parentheses in these two lines:</p>

<pre><code>if((word[strlen(word - 1)] == ',')){
    word[strlen(word) - 1] == '\0';
}
           Here    ^   ^
</code></pre>

<p>The asymmetry is wrong.  Starting your search before the word starts is undefined behaviour.  I think the second line is more nearly correct, but you need to replace the <code>==</code> with <code>=</code> to assign the new value (as pointed out by <a href=""https://stackoverflow.com/users/14860/paxdiablo"">paxdiablo</a> in a <a href=""https://stackoverflow.com/questions/53772230/checking-for-special-charecters-in-string-in-c/53772291#comment94396371_53772291"">comment</a>).  This problem also affects the previous paragraph of code.</p>

<pre><code>if (word[strlen(word) - 1] == ',')
    word[strlen(word) - 1] = '\0';
</code></pre>

<p>Also, you technically have undefined behaviour with <code>strncpy(word, word + 1, strlen(word));</code> ¡ª the source and target arrays are not allowed to overlap (the formal prototype for <code>strncpy()</code> is <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.24.2.4"" rel=""nofollow noreferrer""><code>char *strcat(char * restrict s1, const char * restrict s2);</code></a>, where the <code>restrict</code> means 'no overlap between <code>s1</code> and <code>s2</code>).  Use <code>memmove()</code> ¡ª that does allow overlapping copies ¡ª but you'll need to know how long the string is and remember to copy the null byte so the output is a string too.</p>
",2
53916515,53916315,0,"<p>C compilers often default to earlier-than-the-last C language standard, and go easy with errors that were historically tolerated by the language. </p>

<p>Your error is one of those that used to be regular legal code 30 years ago.</p>

<p>You want to specifically and explicitly instruct your compiler to be strict with your code by supplying appropriate options. For a reasonably recent build of gcc it would be <code>-std=c11 -Wall -Werror</code> or a similar set of options. </p>

<p>The online IDE in question doesn't appear to support passing user-specified options to the underlying compiler, so you're out of luck here. Use your own computer to run a compiler, or find a better online IDE. </p>
",3
53738309,53738226,6,"<p>The <code>total_marks</code> array holds all the marks that people got in the test (assuming it is a test, of course).</p>

<p>What:</p>

<pre><code>marks_count[total_marks[i]]++;   
</code></pre>

<p>does is to increment an array element corresponding to the mark somebody got. In other words, it's counting the number of results of each mark.</p>

<p>In more details:</p>

<pre><code>// Initialise all counts to zero.

for(i = 0; i &lt; 101; i++) {   
    marks_count[i] = 0;   
}   

// For each of forty results, increment the
// count corresponding to the result.

for(i = 0; i &lt; 40; i++) {   
    marks_count[total_marks[i]]++;   
}   
</code></pre>

<p>If, for example, the array was simply <code>{42, 7, 42}</code> (and the size corrected to three rather than forty), you'd end up with an array of mostly zeros, other than:</p>

<pre><code>marks_count[7]  = 1
marks_count[42] = 2
</code></pre>
",0
53874839,53874005,0,"<p>You have a <code>CARD_TYPE* temp</code> you need to (name better and) populate. You're walking through your buffer, and you check if the card in the buffer is black. So you'd set the values of your card.So:</p>

<pre><code>while (read != NULL)
{
  if (strcmp (read, ""BLACK"" ) == 0 )
  {
    temp-&gt;color = // what goes here?
    counter_black ++;
</code></pre>

<p>And then you need to find out what card rank it is. You need more information from the file. How do you do that?    (And what if the information doesn't make sense? How does this thing fail?). For now the prev and next pointers are just NULL.</p>

<p>Then you need to add this temporary card to a doubly linked list.   You should probably have a list declared somewhere. Let's call it</p>

<pre><code>CARD_TYPE* deck;
</code></pre>

<p>The deck can simply be set to the first card once you make it. But it's a list. So the second card you read from the file would be set to.... what? Where does the card go?     (You're going to want to make a separate function for adding cards to a list. Something that mallocs some space and updates a list and leaves it in a valid state.)</p>

<p>And your teacher reminded you to free all your memory when you're done with it. It's good practice to walk through the list and free it all one by one before exiting the program. That way you can pick this code up and use it elsewhere, where it won't live at the top of main.c</p>
",0
54565035,54564991,2,"<p>The code</p>

<pre><code>while( (scanf(""%c"", &amp;name[i])) == 1 ){
    i++;
}
</code></pre>

<p>will read <em>all</em> characters that it can, it will <em>not</em> stop at the end of <code>mark</code>.</p>

<p>Hence, the entire four lines are being read by that loop into <code>name</code>, then the <code>scan</code> calls <em>following</em> that are failing because there's no more input, meaning that the <code>age</code>, <code>department</code> and <code>key</code> values are left at whatever arbitrary value they had when they were created.</p>

<p>In other words, your output can be explained thusly:</p>

<pre><code>mark  \
20     \
A       &gt;-- name
3.154  /
      /
32766    -- age (and probably nul for department)
?       -- key
</code></pre>

<p>If you want to do line-based input, <a href=""https://stackoverflow.com/questions/2430303/disadvantages-of-scanf/2430310#2430310"">this answer</a> provides a handy function for doing so, with buffer overflow protection and so on. For the strings, you just use them as entered, while the non-strings can be converted using <code>sscanf</code> on the buffer.</p>
",0
54565060,54564991,1,"<p>Your first loop with <code>while (scanf(""%c"", &amp;name[i]) == 1)</code> should read all of standard input, quite probably overflowing the <code>name</code> array.  The <code>scanf()</code> calls afterwards should fail ¡ª you should be checking the return value from each of those.  That you get the input reprinted is because you first print <code>name</code>; the rest then is from the uninitialized (or overwritten) variables.  It might be easier to see if you used <code>printf(""[[%s]]\n"", name);</code> instead of <code>puts(name);</code> ¡ª you'd see the square brackets around all your input.</p>

<p>You could fix it by adding:</p>

<pre><code>if (name[i] == '\n')
    break;
</code></pre>

<p>inside that initial while loop.</p>
",0
54154465,54154236,-1,"<p>This is user error. Do not hit enter after the number of employees. Do not hit enter after an ID unless it's the last employee. The code expects to read the next input immediately after each numerical input, so that's what the user should supply.</p>

<p>For example, say you have two employees, Jeff is employee 1 and Eric is employee 2. You should enter ""2Jeff"" followed by ""1Eric"". Since the code doesn't expect the input to be a line, the user should not enter a line in response.</p>

<p>For example:</p>

<blockquote>
  <p>Please enter the number of employee :<strong>2Jeff</strong><br>
   Employee 1 :<br>
  Enter an employee name:<br>
  ID:<strong>1Eric</strong>  </p>
  
  <hr>
</blockquote>

<p>User inputs are bolded. The software behaved precisely as expected.</p>

<p>However, to provide better user guidance, it might be more helpful to tell the user this. For example, ""Please enter the number of employee :"" makes the user think they should respond with a line. So the code should probably say something like ""Please enter the number of employee followed by the first employee's name with no space in-between"". Similarly, ""ID:"" should be changed to ""ID, followed by the next employee's name (if any) with no space in-between"".</p>

<p>That way the user knows what the code expects.</p>
",1
54154285,54154236,1,"<p>This is happening because you're mixing <code>fgets</code> and <code>scanf</code> calls.</p>

<p>The <code>%d</code> format specifier for <code>scanf</code> reads digits.  Anything after those digits, <em>including a newline</em>, gets left in the input buffer.  Then when <code>fgets</code> is called, it reads everything up to the next newline.  The next character in the buffer is a newline, so it immediately reads that.</p>

<p>Replace the <code>fgets</code> call with <code>scanf</code> to be consistent with the rest of the input:</p>

<pre><code>scanf(""%59s"", name);
</code></pre>
",1
54154552,54154236,3,"<p><code>fgets()</code> is reading the <kbd>Enter</kbd> , the left over <code>'\n'</code>, from the previous <code>scanf(""%d"", &amp;emp);</code> <a href=""https://stackoverflow.com/questions/54154236/getting-problem-of-escaping-fgets-in-for-loop/54154552#comment95139535_54154236"">@xing</a>. </p>

<p><code>""%d""</code> only reads up to the last digit, it does not consume characters after the last digit.  Those characters, such as <code>'\n'</code>, remain in <code>stdin</code> for the next input operation, which happened to be <code>fgets()</code>.  So <code>fgets()</code> then reads that lone <code>'\n'</code> as a short line.</p>

<p>The following name is then attempted to be read with <code>scanf(""%d"", &amp;id);</code>.</p>

<p>It is a mess to mix <code>scanf()</code> with <code>fgets()</code>.</p>

<hr>

<p>Instead drop using <code>scanf()</code> and use <code>fgets()</code> for all user input.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main (void) {
  int emp;
  int i;
  char ibuffer[42];
  char name[60];
  int id;

  printf(""Please enter the number of employee :"");
  fgets(ibuffer, sizeof ibuffer, stdin);
  emp = atoi(ibuffer); 
  // For better error detection, check fgets return value and use strtol()

  for (i=1; i&lt;emp; i++) {
    printf("" Employee %d : \n"",i++);

    printf(""Enter an employee name:"");
    fgets(name, sizeof name, stdin);
    name[strcspn(name, ""\n"")] = '\0'; // lop off potential \n

    printf(""\nID:"");
    fgets(ibuffer, sizeof ibuffer, stdin);
    id = atoi(ibuffer); 

    printf("" ------------------------------------- "");
    printf(""\nID:%3d  employee name:&lt;%s&gt;\n"", id, name);
  }
}
</code></pre>
",0
53678212,53678008,0,"<p>The syntax you are using is not valid in C. You can get pretty close to this syntax in context of <em>assignment operator</em> by using a <em>compound literal</em> </p>

<pre><code>tfrac multf(tfrac a, tfrac b)
{
  tfrac res;
  res = (tfrac) { a.num * b.num, a.den * b.den };
  return res;
}
</code></pre>

<p>Note the <code>(tfrac)</code> part before the <code>{}</code>.</p>

<p>But in your case you can simply use initialization instead of assignment</p>

<pre><code>tfrac multf(tfrac a, tfrac b)
{
  tfrac res = { a.num * b.num, a.den * b.den };
  return res;
}
</code></pre>

<p>However, returning to compound literals again, if you prefer, you can use a compound literal to turn the whole thing into an one-liner</p>

<pre><code>tfrac multf(tfrac a, tfrac b)
{
  return (tfrac) { a.num * b.num, a.den * b.den };
}
</code></pre>
",0
54679685,54661422,0,"<p>One of the <a href=""https://stackoverflow.com/questions/54661422/code-with-nested-struct-whats-the-right-way-to-allocate-memory/54679685#comment96142701_54661422"">comments</a> says:</p>

<blockquote>
  <p>I need to allocate space for <code>size1</code> products for each of <code>size</code> clients and then enter the details of products for each client.</p>
</blockquote>

<p>First things first:</p>

<ul>
<li>Separate the I/O finding sizes from the code that uses them.  This is a fundamental technique in programming.</li>
</ul>

<p>A function should do one job ¡ª yours does (at least) two: get the sizes, and allocate the space for the data given those sizes (and probably then goes on to fill in the space with more I/O operations).</p>

<p>That means your code should be split into at least two functions, the second of which becomes something like <code>bool InitCashReg(size_t n_client, size_t n_prod, Cart **pdata)</code>, returning success/true or failure/false status, and taking what you called <code>size</code> and <code>size1</code> as arguments instead of trying to read them.  I'm not going to replicate the I/O code; I'll just concentrate on the memory allocation code.</p>

<pre><code>enum { CLIENT_DEFAULT_ID = -1 };

bool InitCashReg(size_t n_client, size_t n_prod, Cart **pdata)
{
    Cart *cart = malloc(sizeof(*cart) * n_client);
    if (cart == 0)
        return false;
    for (size_t i = 0; i &lt; n_client; i++)
    {
        cart[i]-&gt;pProd = calloc(sizeof(*cart[i]-&gt;pProd), n_prod);
        if (cart[i].pProd == 0)
        {
            // Release already allocated space
            for (size_t j = 0; j &lt; i; j++)
                free(cart[j]-&gt;pProd);
            free(cart);
            return false;
        }
        cart[i].numProd = n_prod;
        cart[i].id = CLIENT_DEFAULT_ID;
    }
    *pdata = cart;
    return true;
}
</code></pre>

<p><sup><em>This code has not been compiled, much less tested.</em></sup></p>

<p>I used <code>calloc()</code> to allocate the array of products so that the data is all zeroed; you could use <code>malloc()</code> instead and set the <code>name</code>, <code>amount</code> and <code>price</code> variables to <code>0</code> some other way.  Note that this, along with the invented <code>CLIENT_DEFAULT_ID</code> ensures that all the allocated memory is initialized to known values.</p>

<p>(C++ has constructors which can be used to ensure proper initialization.  C doesn't have constructors, so you have to ensure your allocated data is appropriately initialized.)</p>
",0
56980483,56979957,0,"<p>The answer from adeishs contains the solution to your problem. I just wanted to, if I may, make a few observations that may be helpful.</p>

<h2>Use of <code>goto</code></h2>

<p>First is the use of the <code>goto</code> keyword. It is generally considered bad practice to use it on a loop in the way that you have. You would be better off not using it, and using another conditional structure. For example (<a href=""https://ideone.com/xM15y8"" rel=""nofollow noreferrer""><strong><em>see here</em></strong></a>),</p>

<pre><code>// See it in action here https://ideone.com/xM15y8
do
{
    printf(""Enter the number of the cell y...."");
    scanf(""%d"", &amp;position);
    const bool input_is_valid = (position == -1) || ((position &gt; 0) &amp;&amp; (position &lt; 10));
    if (input_is_valid)
        break;
    printf(""\nInput invalid, try again\n""); 
} while(true);
</code></pre>

<p>I have added a check for the input of a zero as this is also an invalid input to your program, as far as I can see.</p>

<h2>Use of <code>scanf()</code></h2>

<p>There is a further improvement you could make too. There is a problem with <code>scanf()</code>... the standard says this:</p>

<blockquote>
  <blockquote>
    <p>...the result of the conversion is placed in the object pointed to by the first argument following the format argument that has not already received a conversion result. If this object does not have an appropriate type, or if the result of the conversion cannot be represented in the object, the behaviour is undefined...</p>
  </blockquote>
</blockquote>

<p>So if a user were to type something like 8589934592, although they'd clearly be rather silly to, the is no telling what the variable <code>position</code> may hold as the value entered cannot be represented by an <code>int</code> because it is too large. A safer way might be to use <code>fgets()</code> to read stdin into a small buffer and then use <code>strtol()</code> to parse the input.</p>

<h2>Board Size Is Restricted</h2>

<p>One other limitation of the function <code>CreateBoard()</code> is that is accepts a board of any dimension, but the function only allows positions 1 - 9 to be input. The <code>switch</code> statement can't do anything more than this. You could deal with this in two ways.</p>

<p>The row index into your board is integer division of <code>zero_indexed_position/num_cols</code>. This translates to <code>(position - 1) / n</code>.</p>

<p>The column index is the remainder of the above - <code>(position - 1) % n</code>.</p>

<p>So we could write, intead of the <code>switch</code> (<a href=""https://ideone.com/L30oHE"" rel=""nofollow noreferrer""><strong><em>tested here</em></strong></a> ),</p>

<pre><code>const int row = (position - 1) / n;
const int col = (position - 1) % n;
scanf("" %c"", &amp;board[row][col]);
</code></pre>

<p>The other way would be to index the board using <code>*((int *)board + (position -1))</code>, taking advantage of how the array is laid out in memory.</p>
",0
54356973,54356937,6,"<p>Remove the <code>=</code> from all the <code>#define</code> statements. They are preprocessor macro definitions, not assignment statements, and they do not use equal signs.</p>

<p>Change <code>int value</code> to <code>double value</code>, to use floating-point instead of integers.</p>

<p>Add a <code>;</code> after <code>value =sqrt((G/M)/(r+h))</code>. Statements in C generally end with a semicolon.</p>

<p>Change <code>printf(""This is the tangential speed:"") value;</code> to <code>printf(""This is the tangential speed:  %g.\n"", value);</code>. <code>printf</code> is a function call, not a statement, so you pass everything it needs inside a set of parentheses. The string is a format string; it contains both literal text you want printed and conversion specifications like <code>%g</code> that tell it to convert an argument to a string. <code>%g</code> tells it to convert a <code>double</code> argument to a general floating-point display form.</p>
",1
54356968,54356937,3,"<p>I see two problems:</p>

<ol>
<li><p>Smallest problem, but might be significant, is that I assume you want value to be a float or double instead of an int, thus replace</p>

<p>int value;</p></li>
</ol>

<p>by</p>

<pre><code> float value;
</code></pre>

<ol start=""2"">
<li><p>The print statement is incorrect:</p>

<p>printf(""This is the tangential speed:"") value;</p></li>
</ol>

<p>Assuming value is a float, change it to</p>

<pre><code> printf(""This is the tangential speed: %f\n"", value);
</code></pre>

<p>\n makes a new line.</p>

<p>And of course don't forget the remark by chux.</p>
",0
55981462,55981330,1,"<p>You can use <em>two</em> arrays:</p>

<pre><code>char real_args[6][10];  // Six strings of up to nine characters each
...
char *args[] = {
    real_args[0],
    real_args[1],
    real_args[2],
    real_args[3],
    real_args[4],
    real_args[5],
    NULL  // Must be terminated by a null pointer
};
</code></pre>

<p>Use <code>real_args</code> for the actual arguments, and then pass <code>args</code> to <code>execvp</code>.</p>
",1
55981434,55981330,3,"<p>An array of arrays of <code>char</code> is not the same as an array of pointers to arrays of <code>char</code>. <code>execvp()</code> expects the latter, with a null pointer as its last element, passing the former has undefined behavior.</p>

<p>You must construct an array of pointers, either allocated from the heap or defined with automatic storage (<em>on the stack</em>), initialize it with pointers to argument strings and pass this array to <code>execvp()</code>.</p>

<p>Note also that <code>echo</code> is both a shell internal command and an executable file in the path.</p>

<p>Here is your code fragment modified accordingly (without the parse code, which is still yours to write):</p>

<pre><code>    //input ""echo hello there what is"";
    //arguments array
    char *args[6];

    /*
     * Here you should iterate over the input, storing each string you find 
     * on the command line into `args` and terminate with a null pointer...
     */

    args[0] = ""echo"";
    args[1] = ""hello"";
    args[2] = ""there"";
    args[3] = ""what"";
    args[4] = ""is"";
    args[5] = NULL;

    execvp(args[0], args);
</code></pre>
",2
54455636,54455558,8,"<p><sup><em>The original version of the question listed only <code>""%s""</code> in the format; it was updated to ask about <code>""%s %d""</code> as the record format.</em></sup></p>

<p>An odd requirement in many ways.  You can use assignment suppression, but be cautious as it limits your error checking.  Note that the <code>%s</code> conversion specification reads white-space delimited words ¡ª presumably, that's what you mean by 'records' since that's the function and format you're using.</p>

<pre><code>size_t count = 0;
while (fscanf(in, ""%*s"") == 0)
    count++;

printf(""There are %zu words in the input\n"", count);
</code></pre>

<p>You could use a fixed store like this:</p>

<pre><code>int offset = 0;
size_t count = 0;

while (fscanf(in, ""%*s%n"", &amp;offset) == 0 &amp;&amp; offset != 0)
{
    count++;
    offset = 0;
}
</code></pre>

<p>The <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/scanf.html"" rel=""nofollow noreferrer""><code>scanf()</code></a> manual page repays careful reading, and re-reading, and re-re-reading.</p>

<hr>

<p>The same basic idea of assignment suppression applies to the <code>""%s %d""</code> record format.  The problem is that suppressed conversions are not counted in the return value from <code>fscanf()</code> ¡ª and the <code>%n</code> conversion specifications aren't counted either.  So, you can use:</p>

<pre><code>int offset = 0;
size_t count = 0;

while (fscanf(in, ""%*s %*d%n"", &amp;offset) == 0 &amp;&amp; offset != 0)
{
    count++;
    offset = 0;
}
</code></pre>

<p>which is only a trivial modification of what went before.  If either the <code>%*s</code> or <code>%*d</code> conversions fails, the <code>%n</code> won't be executed, so <code>offset</code> won't be changed.  If both are successful, then <code>offset</code> will be assigned a value larger than zero (because the string must be at least one character, and the number must be at least one character, and there must be at least one blank between the string and the number).  So, the code shown detects whether the read was successful.</p>
",1
54027288,54023639,1,"<blockquote>
  <p>each letter must have 8 pointers around it.</p>
</blockquote>

<p>That means your letter structure should be something like</p>

<pre><code>struct letter {
    struct letter  *up_left;
    struct letter  *up;
    struct letter  *up_right;
    struct letter  *left;
    struct letter  *right;
    struct letter  *down_left;
    struct letter  *down;
    struct letter  *down_right;
    int             letter;
};
</code></pre>

<p>You don't need the letter soup either. Because you read the characters in order, you can read them directly into the graph.  The trick is that you'll want to keep one <code>struct letter</code> pointer to the top left letter in the graph; one <code>struct letter</code> pointer to the first letter on each row; and one <code>struct letter</code> pointer for each new letter you add.</p>

<p>Here is the logic in <a href=""https://en.wikipedia.org/wiki/Pseudocode"" rel=""nofollow noreferrer"">pseudocode</a>:</p>

<pre><code>Function ReadGraph(input):

    Let  topleft  = NULL     # Top left letter in the graph
    Let  leftmost = NULL     # Leftmost letter in current line
    Let  previous = NULL     # Previous letter in current line
    Let  current  = NULL     # Current letter
    Let  letter = ''

    Do:
        Read next letter from input
    While (letter is not a letter nor EOF)
    If letter is EOF:
        # No letters at all in the input, so no graph either.
        Return NULL
    End If

    topleft = new struct letter (letter)
    leftmost = topleft
    current = topleft

    # Row loop. First letter is already in current.
    Loop:

        # Loop over letters in the current line
        Loop:
            Read new letter from input
            If letter is EOF, or newline:
                Break
            End If

            previous = current
            current = new struct letter

            current-&gt;left = previous
            previous-&gt;right = current

            If current-&gt;left-&gt;up is not NULL:
                current-&gt;up_left = current-&gt;left-&gt;up
                current-&gt;up_left-&gt;down_right = current

                If current-&gt;up_left-&gt;right is not NULL:
                    current-&gt;up = current-&gt;up_left-&gt;right
                    current-&gt;up-&gt;down = current

                    If current-&gt;up-&gt;right is not NULL:
                        current-&gt;up_right = current-&gt;up-&gt;right
                        current-&gt;up_right-&gt;down_left = current
                    End If
                End If
            End If

        End Loop

        If letter is not EOF:
            While (letter is not EOF) and (letter is not a letter):
                Read new letter from input
            End While
        End If
        If letter is EOF:
            Break
        End If

        # We have a first letter on a new line.
        current = new letter structure

        current-&gt;up = leftmost
        leftmost-&gt;down = current

        If current-&gt;up-&gt;right is not NULL:
            current-&gt;up_right = current-&gt;up-&gt;right
            current-&gt;up_right-&gt;down_left = current
        End If

        leftmost = current

    End Loop

    Return topleft
End Function
</code></pre>

<p>Note how the first character in the input stream is handled differently (at the very beginning), and how the first character on each subsequent line is handled differently (near the end of the function). This may feel logically or structurally odd, but doing it this way keeps the code simple.</p>

<p>Also note how the bidirectional links are constructed. Because we read from top to bottom, left to right, we establish the link left first, then up-left, then up, then up-right; with the backwards link immediately after the forward link.</p>

<p>This requires a bit of thought, to understand why it works. Consider:</p>

<pre><code>  up_left ©¦  up  ©¦   up_right
©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©à©¤©¤©¤©¤©¤©¤©à©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤
     left ©¦ curr ©¦      right
©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©à©¤©¤©¤©¤©¤©¤©à©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤
down_left ©¦ down ©¦ down_right
</code></pre>

<p>When we are constructing <code>curr</code>, we know if <code>left</code> exists or not, because we handle the first letter on each line separately.</p>

<p>If <code>curr-&gt;left</code> is non-NULL, and <code>curr-&gt;left-&gt;up</code> is non-NULL, we know there was a previous line, and we can point <code>curr-&gt;up_left</code> to point to it. Its <code>-&gt;down_right</code> should point back to <code>curr</code>, of course, for the links to be consistent.</p>

<p>If <code>curr-&gt;up_left</code> is non-NULL, and <code>curr-&gt;up_left-&gt;right</code> is non-NULL, we know the previous line had a letter in the same column. We can set <code>curr-&gt;up</code> to point to it, and its <code>-&gt;down</code> to point back to <code>curr</code>.</p>

<p>If <code>curr-&gt;up</code> is non-NULL, and <code>curr-&gt;up-&gt;right</code> is non-NULL, we know the previous line had a letter in the next column. We can set <code>curr-&gt;up_right</code> to point to it, and its <code>-&gt;down_left</code> to point back to <code>curr</code>.</p>

<p>Now, because we read each line from left to right, all columns on each line are filled up to the rightmost column. If you proceed using the above logic, you'll find out that the second line fills the rest of the links from first lines letters to the second line letters, and so on.</p>

<p>It also means that if the input file contained a special character, say <code>'*'</code> for a non-letter node, you should create those while constructing the graph, just like they were ordinary letters, to ensure the above logic of linking works.</p>

<p>After the entire graph is read, you can then remove those non-letter nodes from the graph, one by one. To remove a node, you first set the back links to it (from its neighboring letters) to NULL, then <code>free()</code> it.</p>

<p>I personally ""poison"" the structure before <code>free()</code>ing it, setting <code>letter</code> to a known impossible value (<code>WEOF</code>, for wide end-of-input), and all links to <code>NULL</code>, so that if some other code uses the structure after it was freed (which would be an <em>use after free bug</em>), for example because it cached the pointer somehow, it is easier to detect.</p>

<p>(When you <code>free()</code> a pointer, the C library usually does not return it immediately to the operating system, or clear it; usually, the dynamically allocated region is just added to the internal free heap, so that a future allocation can just reuse that memory. Unfortunately, it means that if you do not ""poison"" freed structures, sometimes they can still be accessible afterwards. Such use-after-free bugs are very annoying, and it is definitely worth the ""unnecessary work"" of poisoning the structures just to help debugging those.)</p>

<p>To facilitate the poisoning, and also to make it easy to remove the poisoning if it turns out to be unnecessary slowdown at some point, it is best to use helper functions for creating and destroying the structures:</p>

<pre><code>static inline struct letter *new_letter(const int letter)
{
    struct letter *one;

    one = malloc(sizeof *one);
    if (!one) {
        fprintf(stderr, ""new_letter(): Out of memory.\n"");
        exit(EXIT_FAILURE);
    }

    one-&gt;up_left    = NULL;
    one-&gt;up         = NULL;
    one-&gt;up_right   = NULL;
    one-&gt;left       = NULL;
    one-&gt;right      = NULL;
    one-&gt;down_left  = NULL;
    one-&gt;down       = NULL;
    one-&gt;down_right = NULL;

    one-&gt;letter = letter;

    return one;
}

static inline void free_letter(struct letter *one)
{
    if (one) {
        one-&gt;up_left    = NULL;
        one-&gt;up         = NULL;
        one-&gt;up_right   = NULL;
        one-&gt;left       = NULL;
        one-&gt;right      = NULL;
        one-&gt;down_left  = NULL;
        one-&gt;down       = NULL;
        one-&gt;down_right = NULL;
        one-&gt;letter     = EOF;
        free(one);
    }
}
</code></pre>

<p>I usually include these functions in the header file that defines <code>struct letter</code>; because they are then tiny macro-like functions, I mark them <code>static inline</code>, telling the C compiler that they only need to be accessible in the same compilation unit, and that it does not need to generate the functions and call to those functions, but can <em>inline</em> the code into wherever they are called.</p>

<hr>

<p>Personally, I wrote and verified the above pseudocode using</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;
#include &lt;wchar.h&gt;
#include &lt;stdio.h&gt;

struct letter {
    struct letter  *chain;  /* Internal chain of all known letters */

    struct letter  *up_left;
    struct letter  *up;
    struct letter  *up_right;
    struct letter  *left;
    struct letter  *right;
    struct letter  *down_left;
    struct letter  *down;
    struct letter  *down_right;

    wint_t          letter;
};

static struct letter *all_letters = NULL;

struct letter *new_letter(wint_t letter)
{
    struct letter *one;

    one = malloc(sizeof *one);
    if (!one) {
        fprintf(stderr, ""new_letter(): Out of memory.\n"");
        exit(EXIT_FAILURE);
    }

    one-&gt;letter = letter;

    one-&gt;chain = all_letters;
    all_letters = one;

    one-&gt;up_left    = NULL;
    one-&gt;up         = NULL;
    one-&gt;up_right   = NULL;
    one-&gt;left       = NULL;
    one-&gt;right      = NULL;
    one-&gt;down_left  = NULL;
    one-&gt;down       = NULL;
    one-&gt;down_right = NULL;

    return one;
}
</code></pre>

<p>I prefer to use wide input, because in conforming operating systems you can use any glyphs your locale treats as letters, not just ASCII A-Z. All you need to do, is have</p>

<pre><code>    if (!setlocale(LC_ALL, """"))
        fprintf(stderr, ""Warning: Current locale is not supported by your C library.\n"");
    if (fwide(stdin, 1) &lt; 1)
        fprintf(stderr, ""Warning: Wide standard input is not supported by your C library for current locale.\n"");
    if (fwide(stdout, 1) &lt; 1)
        fprintf(stderr, ""Warning: Wide standard output is not supported by your C library for current locale.\n"");
</code></pre>

<p>at the start of your <code>main()</code>, and use the wide I/O functions (<code>fwprintf()</code>, <code>fgetwc()</code>, and so on), assuming you have a standard C environment.  (Apparently, some Windows users have issues with UTF-8 support in Windows. Complain to Microsoft; the above behaviour is per the C standard.)</p>

<p>The <code>chain</code> member is used to link all created letters into a single linked list, so that we can use a function (below) to draw the entire graph in Graphviz Dot language. (<a href=""https://www.graphviz.org/"" rel=""nofollow noreferrer"">Graphviz</a> is available for all operating systems, and in my opinion, is an excellent tool when developing or debugging code that uses linked lists or graphs.)  The <code>circo</code> utility seems to be quite good at drawing such graphs, too.</p>

<pre><code>int letter_graph(FILE *out)
{
    struct letter  *one;

    /* Sanity check. */
    if (!out || ferror(out))
        return -1;

    /* Wide output. */
    if (fwide(out) &lt; 1)
        return -1;

    fwprintf(out, L""digraph {\n"");
    for (one = all_letters; one != NULL; one = one-&gt;chain) {
        fwprintf(out, L""    \""%p\"" [ label=\""%lc\"" ];\n"",
                      (void *)one, one-&gt;letter);
        if (one-&gt;up_left)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¨I\"" ];\n"",
                          (void *)one, (void *)(one-&gt;up_left));
        if (one-&gt;up)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¡ü\"" ];\n"",
                          (void *)one, (void *)(one-&gt;up));
        if (one-&gt;up_right)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¨J\"" ];\n"",
                          (void *)one, (void *)(one-&gt;up_right));
        if (one-&gt;left)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¡û\"" ];\n"",
                          (void *)one, (void *)(one-&gt;left));
        if (one-&gt;right)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¡ú\"" ];\n"",
                          (void *)one, (void *)(one-&gt;right));
        if (one-&gt;down_left)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¨L\"" ];\n"",
                          (void *)one, (void *)(one-&gt;down_left));
        if (one-&gt;down)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¡ý\"" ];\n"",
                          (void *)one, (void *)(one-&gt;down));
        if (one-&gt;down_right)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¨K\"" ];\n"",
                         (void *)one, (void *)(one-&gt;down_right));
    }
    fwprintf(out, L""}\n"");

    return 0;
}
</code></pre>

<p>If the input file is</p>

<pre><code>ABC
DEF
GHI
</code></pre>

<p>the Dot description of the graph is</p>

<pre><code>digraph {
    ""0x1c542f0"" [ label=""I"" ];
    ""0x1c542f0"" -&gt; ""0x1c54170"" [ label=""¨I"" ];
    ""0x1c542f0"" -&gt; ""0x1c541d0"" [ label=""¡ü"" ];
    ""0x1c542f0"" -&gt; ""0x1c54290"" [ label=""¡û"" ];
    ""0x1c54290"" [ label=""H"" ];
    ""0x1c54290"" -&gt; ""0x1c54110"" [ label=""¨I"" ];
    ""0x1c54290"" -&gt; ""0x1c54170"" [ label=""¡ü"" ];
    ""0x1c54290"" -&gt; ""0x1c541d0"" [ label=""¨J"" ];
    ""0x1c54290"" -&gt; ""0x1c54230"" [ label=""¡û"" ];
    ""0x1c54290"" -&gt; ""0x1c542f0"" [ label=""¡ú"" ];
    ""0x1c54230"" [ label=""G"" ];
    ""0x1c54230"" -&gt; ""0x1c54110"" [ label=""¡ü"" ];
    ""0x1c54230"" -&gt; ""0x1c54170"" [ label=""¨J"" ];
    ""0x1c54230"" -&gt; ""0x1c54290"" [ label=""¡ú"" ];
    ""0x1c541d0"" [ label=""F"" ];
    ""0x1c541d0"" -&gt; ""0x1c54050"" [ label=""¨I"" ];
    ""0x1c541d0"" -&gt; ""0x1c540b0"" [ label=""¡ü"" ];
    ""0x1c541d0"" -&gt; ""0x1c54170"" [ label=""¡û"" ];
    ""0x1c541d0"" -&gt; ""0x1c54290"" [ label=""¨L"" ];
    ""0x1c541d0"" -&gt; ""0x1c542f0"" [ label=""¡ý"" ];
    ""0x1c54170"" [ label=""E"" ];
    ""0x1c54170"" -&gt; ""0x1c53ff0"" [ label=""¨I"" ];
    ""0x1c54170"" -&gt; ""0x1c54050"" [ label=""¡ü"" ];
    ""0x1c54170"" -&gt; ""0x1c540b0"" [ label=""¨J"" ];
    ""0x1c54170"" -&gt; ""0x1c54110"" [ label=""¡û"" ];
    ""0x1c54170"" -&gt; ""0x1c541d0"" [ label=""¡ú"" ];
    ""0x1c54170"" -&gt; ""0x1c54230"" [ label=""¨L"" ];
    ""0x1c54170"" -&gt; ""0x1c54290"" [ label=""¡ý"" ];
    ""0x1c54170"" -&gt; ""0x1c542f0"" [ label=""¨K"" ];
    ""0x1c54110"" [ label=""D"" ];
    ""0x1c54110"" -&gt; ""0x1c53ff0"" [ label=""¡ü"" ];
    ""0x1c54110"" -&gt; ""0x1c54050"" [ label=""¨J"" ];
    ""0x1c54110"" -&gt; ""0x1c54170"" [ label=""¡ú"" ];
    ""0x1c54110"" -&gt; ""0x1c54230"" [ label=""¡ý"" ];
    ""0x1c54110"" -&gt; ""0x1c54290"" [ label=""¨K"" ];
    ""0x1c540b0"" [ label=""C"" ];
    ""0x1c540b0"" -&gt; ""0x1c54050"" [ label=""¡û"" ];
    ""0x1c540b0"" -&gt; ""0x1c54170"" [ label=""¨L"" ];
    ""0x1c540b0"" -&gt; ""0x1c541d0"" [ label=""¡ý"" ];
    ""0x1c54050"" [ label=""B"" ];
    ""0x1c54050"" -&gt; ""0x1c53ff0"" [ label=""¡û"" ];
    ""0x1c54050"" -&gt; ""0x1c540b0"" [ label=""¡ú"" ];
    ""0x1c54050"" -&gt; ""0x1c54110"" [ label=""¨L"" ];
    ""0x1c54050"" -&gt; ""0x1c54170"" [ label=""¡ý"" ];
    ""0x1c54050"" -&gt; ""0x1c541d0"" [ label=""¨K"" ];
    ""0x1c53ff0"" [ label=""A"" ];
    ""0x1c53ff0"" -&gt; ""0x1c54050"" [ label=""¡ú"" ];
    ""0x1c53ff0"" -&gt; ""0x1c54110"" [ label=""¡ý"" ];
    ""0x1c53ff0"" -&gt; ""0x1c54170"" [ label=""¨K"" ];
}
</code></pre>

<p>(It is in reverse order because I insert each new letter at the beginning of the linked list). <code>circo</code> draws the following graph from that:</p>

<p><img src=""https://www.nominal-animal.net/answers/letter-grid-8way.svg"" alt=""3¡Á3 letter grid, 8-way links""></p>

<p>During development, I also check if the linkage is consistent:</p>

<pre><code>    for (one = all_letters; one != NULL; one = one-&gt;chain) {

        if (one-&gt;up_left &amp;&amp; one-&gt;up_left-&gt;down_right != one)
            fprintf(stderr, ""'%c'-&gt;up_left is broken!\n"", one-&gt;letter);
        if (one-&gt;up &amp;&amp; one-&gt;up-&gt;down != one)
            fprintf(stderr, ""'%c'-&gt;up is broken!\n"", one-&gt;letter);
        if (one-&gt;up_right &amp;&amp; one-&gt;up_right-&gt;down_left != one)
            fprintf(stderr, ""'%c'-&gt;up_right is broken!\n"", one-&gt;letter);
        if (one-&gt;left &amp;&amp; one-&gt;left-&gt;right != one)
            fprintf(stderr, ""'%c'-&gt;left is broken!\n"", one-&gt;letter);
        if (one-&gt;right &amp;&amp; one-&gt;right-&gt;left != one)
            fprintf(stderr, ""'%c'-&gt;right is broken!\n"", one-&gt;letter);
        if (one-&gt;down_left &amp;&amp; one-&gt;down_left-&gt;up_right != one)
            fprintf(stderr, ""'%c'-&gt;down_left is broken!\n"", one-&gt;letter);
        if (one-&gt;down &amp;&amp; one-&gt;down-&gt;up != one)
            fprintf(stderr, ""'%c'-&gt;down is broken!\n"", one-&gt;letter);
        if (one-&gt;down_right &amp;&amp; one-&gt;down_right-&gt;up_left != one)
            fprintf(stderr, ""'%c'-&gt;down_right is broken!\n"", one-&gt;letter);
    }
</code></pre>

<p>By consistent linkage, I mean that if <code>a-&gt;left == b</code>, then <code>b-&gt;right == a</code>. Of course, the check cannot tell if <code>a-&gt;left</code> or <code>b-&gt;right</code> is wrong; it can only detect if they are consistent or not.</p>
",2
54027288,54023639,1,"<blockquote>
  <p>each letter must have 8 pointers around it.</p>
</blockquote>

<p>That means your letter structure should be something like</p>

<pre><code>struct letter {
    struct letter  *up_left;
    struct letter  *up;
    struct letter  *up_right;
    struct letter  *left;
    struct letter  *right;
    struct letter  *down_left;
    struct letter  *down;
    struct letter  *down_right;
    int             letter;
};
</code></pre>

<p>You don't need the letter soup either. Because you read the characters in order, you can read them directly into the graph.  The trick is that you'll want to keep one <code>struct letter</code> pointer to the top left letter in the graph; one <code>struct letter</code> pointer to the first letter on each row; and one <code>struct letter</code> pointer for each new letter you add.</p>

<p>Here is the logic in <a href=""https://en.wikipedia.org/wiki/Pseudocode"" rel=""nofollow noreferrer"">pseudocode</a>:</p>

<pre><code>Function ReadGraph(input):

    Let  topleft  = NULL     # Top left letter in the graph
    Let  leftmost = NULL     # Leftmost letter in current line
    Let  previous = NULL     # Previous letter in current line
    Let  current  = NULL     # Current letter
    Let  letter = ''

    Do:
        Read next letter from input
    While (letter is not a letter nor EOF)
    If letter is EOF:
        # No letters at all in the input, so no graph either.
        Return NULL
    End If

    topleft = new struct letter (letter)
    leftmost = topleft
    current = topleft

    # Row loop. First letter is already in current.
    Loop:

        # Loop over letters in the current line
        Loop:
            Read new letter from input
            If letter is EOF, or newline:
                Break
            End If

            previous = current
            current = new struct letter

            current-&gt;left = previous
            previous-&gt;right = current

            If current-&gt;left-&gt;up is not NULL:
                current-&gt;up_left = current-&gt;left-&gt;up
                current-&gt;up_left-&gt;down_right = current

                If current-&gt;up_left-&gt;right is not NULL:
                    current-&gt;up = current-&gt;up_left-&gt;right
                    current-&gt;up-&gt;down = current

                    If current-&gt;up-&gt;right is not NULL:
                        current-&gt;up_right = current-&gt;up-&gt;right
                        current-&gt;up_right-&gt;down_left = current
                    End If
                End If
            End If

        End Loop

        If letter is not EOF:
            While (letter is not EOF) and (letter is not a letter):
                Read new letter from input
            End While
        End If
        If letter is EOF:
            Break
        End If

        # We have a first letter on a new line.
        current = new letter structure

        current-&gt;up = leftmost
        leftmost-&gt;down = current

        If current-&gt;up-&gt;right is not NULL:
            current-&gt;up_right = current-&gt;up-&gt;right
            current-&gt;up_right-&gt;down_left = current
        End If

        leftmost = current

    End Loop

    Return topleft
End Function
</code></pre>

<p>Note how the first character in the input stream is handled differently (at the very beginning), and how the first character on each subsequent line is handled differently (near the end of the function). This may feel logically or structurally odd, but doing it this way keeps the code simple.</p>

<p>Also note how the bidirectional links are constructed. Because we read from top to bottom, left to right, we establish the link left first, then up-left, then up, then up-right; with the backwards link immediately after the forward link.</p>

<p>This requires a bit of thought, to understand why it works. Consider:</p>

<pre><code>  up_left ©¦  up  ©¦   up_right
©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©à©¤©¤©¤©¤©¤©¤©à©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤
     left ©¦ curr ©¦      right
©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©à©¤©¤©¤©¤©¤©¤©à©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤©¤
down_left ©¦ down ©¦ down_right
</code></pre>

<p>When we are constructing <code>curr</code>, we know if <code>left</code> exists or not, because we handle the first letter on each line separately.</p>

<p>If <code>curr-&gt;left</code> is non-NULL, and <code>curr-&gt;left-&gt;up</code> is non-NULL, we know there was a previous line, and we can point <code>curr-&gt;up_left</code> to point to it. Its <code>-&gt;down_right</code> should point back to <code>curr</code>, of course, for the links to be consistent.</p>

<p>If <code>curr-&gt;up_left</code> is non-NULL, and <code>curr-&gt;up_left-&gt;right</code> is non-NULL, we know the previous line had a letter in the same column. We can set <code>curr-&gt;up</code> to point to it, and its <code>-&gt;down</code> to point back to <code>curr</code>.</p>

<p>If <code>curr-&gt;up</code> is non-NULL, and <code>curr-&gt;up-&gt;right</code> is non-NULL, we know the previous line had a letter in the next column. We can set <code>curr-&gt;up_right</code> to point to it, and its <code>-&gt;down_left</code> to point back to <code>curr</code>.</p>

<p>Now, because we read each line from left to right, all columns on each line are filled up to the rightmost column. If you proceed using the above logic, you'll find out that the second line fills the rest of the links from first lines letters to the second line letters, and so on.</p>

<p>It also means that if the input file contained a special character, say <code>'*'</code> for a non-letter node, you should create those while constructing the graph, just like they were ordinary letters, to ensure the above logic of linking works.</p>

<p>After the entire graph is read, you can then remove those non-letter nodes from the graph, one by one. To remove a node, you first set the back links to it (from its neighboring letters) to NULL, then <code>free()</code> it.</p>

<p>I personally ""poison"" the structure before <code>free()</code>ing it, setting <code>letter</code> to a known impossible value (<code>WEOF</code>, for wide end-of-input), and all links to <code>NULL</code>, so that if some other code uses the structure after it was freed (which would be an <em>use after free bug</em>), for example because it cached the pointer somehow, it is easier to detect.</p>

<p>(When you <code>free()</code> a pointer, the C library usually does not return it immediately to the operating system, or clear it; usually, the dynamically allocated region is just added to the internal free heap, so that a future allocation can just reuse that memory. Unfortunately, it means that if you do not ""poison"" freed structures, sometimes they can still be accessible afterwards. Such use-after-free bugs are very annoying, and it is definitely worth the ""unnecessary work"" of poisoning the structures just to help debugging those.)</p>

<p>To facilitate the poisoning, and also to make it easy to remove the poisoning if it turns out to be unnecessary slowdown at some point, it is best to use helper functions for creating and destroying the structures:</p>

<pre><code>static inline struct letter *new_letter(const int letter)
{
    struct letter *one;

    one = malloc(sizeof *one);
    if (!one) {
        fprintf(stderr, ""new_letter(): Out of memory.\n"");
        exit(EXIT_FAILURE);
    }

    one-&gt;up_left    = NULL;
    one-&gt;up         = NULL;
    one-&gt;up_right   = NULL;
    one-&gt;left       = NULL;
    one-&gt;right      = NULL;
    one-&gt;down_left  = NULL;
    one-&gt;down       = NULL;
    one-&gt;down_right = NULL;

    one-&gt;letter = letter;

    return one;
}

static inline void free_letter(struct letter *one)
{
    if (one) {
        one-&gt;up_left    = NULL;
        one-&gt;up         = NULL;
        one-&gt;up_right   = NULL;
        one-&gt;left       = NULL;
        one-&gt;right      = NULL;
        one-&gt;down_left  = NULL;
        one-&gt;down       = NULL;
        one-&gt;down_right = NULL;
        one-&gt;letter     = EOF;
        free(one);
    }
}
</code></pre>

<p>I usually include these functions in the header file that defines <code>struct letter</code>; because they are then tiny macro-like functions, I mark them <code>static inline</code>, telling the C compiler that they only need to be accessible in the same compilation unit, and that it does not need to generate the functions and call to those functions, but can <em>inline</em> the code into wherever they are called.</p>

<hr>

<p>Personally, I wrote and verified the above pseudocode using</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;
#include &lt;wchar.h&gt;
#include &lt;stdio.h&gt;

struct letter {
    struct letter  *chain;  /* Internal chain of all known letters */

    struct letter  *up_left;
    struct letter  *up;
    struct letter  *up_right;
    struct letter  *left;
    struct letter  *right;
    struct letter  *down_left;
    struct letter  *down;
    struct letter  *down_right;

    wint_t          letter;
};

static struct letter *all_letters = NULL;

struct letter *new_letter(wint_t letter)
{
    struct letter *one;

    one = malloc(sizeof *one);
    if (!one) {
        fprintf(stderr, ""new_letter(): Out of memory.\n"");
        exit(EXIT_FAILURE);
    }

    one-&gt;letter = letter;

    one-&gt;chain = all_letters;
    all_letters = one;

    one-&gt;up_left    = NULL;
    one-&gt;up         = NULL;
    one-&gt;up_right   = NULL;
    one-&gt;left       = NULL;
    one-&gt;right      = NULL;
    one-&gt;down_left  = NULL;
    one-&gt;down       = NULL;
    one-&gt;down_right = NULL;

    return one;
}
</code></pre>

<p>I prefer to use wide input, because in conforming operating systems you can use any glyphs your locale treats as letters, not just ASCII A-Z. All you need to do, is have</p>

<pre><code>    if (!setlocale(LC_ALL, """"))
        fprintf(stderr, ""Warning: Current locale is not supported by your C library.\n"");
    if (fwide(stdin, 1) &lt; 1)
        fprintf(stderr, ""Warning: Wide standard input is not supported by your C library for current locale.\n"");
    if (fwide(stdout, 1) &lt; 1)
        fprintf(stderr, ""Warning: Wide standard output is not supported by your C library for current locale.\n"");
</code></pre>

<p>at the start of your <code>main()</code>, and use the wide I/O functions (<code>fwprintf()</code>, <code>fgetwc()</code>, and so on), assuming you have a standard C environment.  (Apparently, some Windows users have issues with UTF-8 support in Windows. Complain to Microsoft; the above behaviour is per the C standard.)</p>

<p>The <code>chain</code> member is used to link all created letters into a single linked list, so that we can use a function (below) to draw the entire graph in Graphviz Dot language. (<a href=""https://www.graphviz.org/"" rel=""nofollow noreferrer"">Graphviz</a> is available for all operating systems, and in my opinion, is an excellent tool when developing or debugging code that uses linked lists or graphs.)  The <code>circo</code> utility seems to be quite good at drawing such graphs, too.</p>

<pre><code>int letter_graph(FILE *out)
{
    struct letter  *one;

    /* Sanity check. */
    if (!out || ferror(out))
        return -1;

    /* Wide output. */
    if (fwide(out) &lt; 1)
        return -1;

    fwprintf(out, L""digraph {\n"");
    for (one = all_letters; one != NULL; one = one-&gt;chain) {
        fwprintf(out, L""    \""%p\"" [ label=\""%lc\"" ];\n"",
                      (void *)one, one-&gt;letter);
        if (one-&gt;up_left)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¨I\"" ];\n"",
                          (void *)one, (void *)(one-&gt;up_left));
        if (one-&gt;up)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¡ü\"" ];\n"",
                          (void *)one, (void *)(one-&gt;up));
        if (one-&gt;up_right)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¨J\"" ];\n"",
                          (void *)one, (void *)(one-&gt;up_right));
        if (one-&gt;left)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¡û\"" ];\n"",
                          (void *)one, (void *)(one-&gt;left));
        if (one-&gt;right)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¡ú\"" ];\n"",
                          (void *)one, (void *)(one-&gt;right));
        if (one-&gt;down_left)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¨L\"" ];\n"",
                          (void *)one, (void *)(one-&gt;down_left));
        if (one-&gt;down)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¡ý\"" ];\n"",
                          (void *)one, (void *)(one-&gt;down));
        if (one-&gt;down_right)
            fwprintf(out, L""    \""%p\"" -&gt; \""%p\"" [ label=\""¨K\"" ];\n"",
                         (void *)one, (void *)(one-&gt;down_right));
    }
    fwprintf(out, L""}\n"");

    return 0;
}
</code></pre>

<p>If the input file is</p>

<pre><code>ABC
DEF
GHI
</code></pre>

<p>the Dot description of the graph is</p>

<pre><code>digraph {
    ""0x1c542f0"" [ label=""I"" ];
    ""0x1c542f0"" -&gt; ""0x1c54170"" [ label=""¨I"" ];
    ""0x1c542f0"" -&gt; ""0x1c541d0"" [ label=""¡ü"" ];
    ""0x1c542f0"" -&gt; ""0x1c54290"" [ label=""¡û"" ];
    ""0x1c54290"" [ label=""H"" ];
    ""0x1c54290"" -&gt; ""0x1c54110"" [ label=""¨I"" ];
    ""0x1c54290"" -&gt; ""0x1c54170"" [ label=""¡ü"" ];
    ""0x1c54290"" -&gt; ""0x1c541d0"" [ label=""¨J"" ];
    ""0x1c54290"" -&gt; ""0x1c54230"" [ label=""¡û"" ];
    ""0x1c54290"" -&gt; ""0x1c542f0"" [ label=""¡ú"" ];
    ""0x1c54230"" [ label=""G"" ];
    ""0x1c54230"" -&gt; ""0x1c54110"" [ label=""¡ü"" ];
    ""0x1c54230"" -&gt; ""0x1c54170"" [ label=""¨J"" ];
    ""0x1c54230"" -&gt; ""0x1c54290"" [ label=""¡ú"" ];
    ""0x1c541d0"" [ label=""F"" ];
    ""0x1c541d0"" -&gt; ""0x1c54050"" [ label=""¨I"" ];
    ""0x1c541d0"" -&gt; ""0x1c540b0"" [ label=""¡ü"" ];
    ""0x1c541d0"" -&gt; ""0x1c54170"" [ label=""¡û"" ];
    ""0x1c541d0"" -&gt; ""0x1c54290"" [ label=""¨L"" ];
    ""0x1c541d0"" -&gt; ""0x1c542f0"" [ label=""¡ý"" ];
    ""0x1c54170"" [ label=""E"" ];
    ""0x1c54170"" -&gt; ""0x1c53ff0"" [ label=""¨I"" ];
    ""0x1c54170"" -&gt; ""0x1c54050"" [ label=""¡ü"" ];
    ""0x1c54170"" -&gt; ""0x1c540b0"" [ label=""¨J"" ];
    ""0x1c54170"" -&gt; ""0x1c54110"" [ label=""¡û"" ];
    ""0x1c54170"" -&gt; ""0x1c541d0"" [ label=""¡ú"" ];
    ""0x1c54170"" -&gt; ""0x1c54230"" [ label=""¨L"" ];
    ""0x1c54170"" -&gt; ""0x1c54290"" [ label=""¡ý"" ];
    ""0x1c54170"" -&gt; ""0x1c542f0"" [ label=""¨K"" ];
    ""0x1c54110"" [ label=""D"" ];
    ""0x1c54110"" -&gt; ""0x1c53ff0"" [ label=""¡ü"" ];
    ""0x1c54110"" -&gt; ""0x1c54050"" [ label=""¨J"" ];
    ""0x1c54110"" -&gt; ""0x1c54170"" [ label=""¡ú"" ];
    ""0x1c54110"" -&gt; ""0x1c54230"" [ label=""¡ý"" ];
    ""0x1c54110"" -&gt; ""0x1c54290"" [ label=""¨K"" ];
    ""0x1c540b0"" [ label=""C"" ];
    ""0x1c540b0"" -&gt; ""0x1c54050"" [ label=""¡û"" ];
    ""0x1c540b0"" -&gt; ""0x1c54170"" [ label=""¨L"" ];
    ""0x1c540b0"" -&gt; ""0x1c541d0"" [ label=""¡ý"" ];
    ""0x1c54050"" [ label=""B"" ];
    ""0x1c54050"" -&gt; ""0x1c53ff0"" [ label=""¡û"" ];
    ""0x1c54050"" -&gt; ""0x1c540b0"" [ label=""¡ú"" ];
    ""0x1c54050"" -&gt; ""0x1c54110"" [ label=""¨L"" ];
    ""0x1c54050"" -&gt; ""0x1c54170"" [ label=""¡ý"" ];
    ""0x1c54050"" -&gt; ""0x1c541d0"" [ label=""¨K"" ];
    ""0x1c53ff0"" [ label=""A"" ];
    ""0x1c53ff0"" -&gt; ""0x1c54050"" [ label=""¡ú"" ];
    ""0x1c53ff0"" -&gt; ""0x1c54110"" [ label=""¡ý"" ];
    ""0x1c53ff0"" -&gt; ""0x1c54170"" [ label=""¨K"" ];
}
</code></pre>

<p>(It is in reverse order because I insert each new letter at the beginning of the linked list). <code>circo</code> draws the following graph from that:</p>

<p><img src=""https://www.nominal-animal.net/answers/letter-grid-8way.svg"" alt=""3¡Á3 letter grid, 8-way links""></p>

<p>During development, I also check if the linkage is consistent:</p>

<pre><code>    for (one = all_letters; one != NULL; one = one-&gt;chain) {

        if (one-&gt;up_left &amp;&amp; one-&gt;up_left-&gt;down_right != one)
            fprintf(stderr, ""'%c'-&gt;up_left is broken!\n"", one-&gt;letter);
        if (one-&gt;up &amp;&amp; one-&gt;up-&gt;down != one)
            fprintf(stderr, ""'%c'-&gt;up is broken!\n"", one-&gt;letter);
        if (one-&gt;up_right &amp;&amp; one-&gt;up_right-&gt;down_left != one)
            fprintf(stderr, ""'%c'-&gt;up_right is broken!\n"", one-&gt;letter);
        if (one-&gt;left &amp;&amp; one-&gt;left-&gt;right != one)
            fprintf(stderr, ""'%c'-&gt;left is broken!\n"", one-&gt;letter);
        if (one-&gt;right &amp;&amp; one-&gt;right-&gt;left != one)
            fprintf(stderr, ""'%c'-&gt;right is broken!\n"", one-&gt;letter);
        if (one-&gt;down_left &amp;&amp; one-&gt;down_left-&gt;up_right != one)
            fprintf(stderr, ""'%c'-&gt;down_left is broken!\n"", one-&gt;letter);
        if (one-&gt;down &amp;&amp; one-&gt;down-&gt;up != one)
            fprintf(stderr, ""'%c'-&gt;down is broken!\n"", one-&gt;letter);
        if (one-&gt;down_right &amp;&amp; one-&gt;down_right-&gt;up_left != one)
            fprintf(stderr, ""'%c'-&gt;down_right is broken!\n"", one-&gt;letter);
    }
</code></pre>

<p>By consistent linkage, I mean that if <code>a-&gt;left == b</code>, then <code>b-&gt;right == a</code>. Of course, the check cannot tell if <code>a-&gt;left</code> or <code>b-&gt;right</code> is wrong; it can only detect if they are consistent or not.</p>
",2
56586998,56586904,6,"<p>This is referring to the rules of <strong>integer promotion</strong>.  Anytime an integer value with a type smaller than <code>int</code> (i.e. <code>char</code>, <code>short</code>) is used in a context where an <code>int</code> can be used, the value is promoted to an <code>int</code>.</p>

<p>In the case of a variadic function, the type of the arguments to a function are not known at compile time, so this promotion applies.</p>

<p>For example, suppose you had the following functions:</p>

<pre><code>void f1(char c);
void f2(int count, ...);
</code></pre>

<p>They are called like this:</p>

<pre><code>char x = 1;
f1(x);       // x is passed as char
f2(1, x);    // x is passed as int
</code></pre>

<p>This behavior is documented in section 6.3.1.1p2 of the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""noreferrer"">C standard</a>:</p>

<blockquote>
  <p>The following may be used in an expression wherever an int or unsigned
  int may be used:</p>
  
  <ul>
  <li>An object  or  expression  with  an  integer  type  (other  than int or unsigned int ) whose  integer  conversion  rank  is  less  than
  or  equal  to  the  rank  of int and unsigned int .</li>
  <li>A bit-field of type
  _Bool , int , signed int ,or unsigned int . </li>
  </ul>
  
  <p>If  an int can  represent  all  values  of  the  original  type  (as  restricted  by  the  width,
  for  a bit-field),  the  value  is  converted  to  an int ; otherwise,
  it  is  converted  to  an unsigned int . These  are  called  the
  integer promotions .  All  other  types  are  unchanged  by  the
  integer promotions.</p>
</blockquote>
",0
54503497,54503450,1,"<p>When scanning a string, the <code>%s</code> format specifier expects an argument of type <code>char *</code>.  It is used like this:</p>

<pre><code>char str[100];
scanf(""%99s"", str);
</code></pre>

<p>We don't need to use <code>&amp;</code> here because <code>str</code>, when used in a expression <em>decays</em> to a pointer to its first element and has type <code>char *</code>.  So there's no need to take the address since you already have a `char *.</p>

<p>If you're using dynamically allocated memory:</p>

<pre><code>char *str = malloc(100);
scanf(""%99s"", str);
</code></pre>

<p>You explicitly have a <code>char *</code> already, so again no need to take the address.  If you did, you'd get the address of the pointer variable instead of the address of the allocated memory.  <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">Bad things will happen</a> if you do this.</p>
",0
56619302,56618655,0,"<p>Specify <em>octal</em> output with <code>""%o""</code> (not <code>""%d""</code>)</p>

<pre><code>printf(""%o %03o\n"", 9, 9); // 11 011
</code></pre>

<p>See <a href=""https://ideone.com/Yy5yNA"" rel=""nofollow noreferrer"">ideone.com/Yy5yNA</a></p>
",0
56618736,56618655,3,"<p><a href=""https://en.cppreference.com/w/c/language/integer_constant"" rel=""nofollow noreferrer"">Integer constants</a> that begin with the digit 0 are <strong>octal</strong> (base 8). The literals 010 and 011 are the values 8 and 9.</p>
",0
53801280,53801210,5,"<p>You can't use <em>simple</em> variables for inter thread communication. As is stands, the compiler will see that in the loop</p>

<pre><code>while (1 != startb); /*block here*/
</code></pre>

<p>the value of <code>startb</code> never is modified, and hence will <em>legally</em> rewrite it internally to</p>

<pre><code>if( 1 != startb ){
    while( true );
}
</code></pre>

<p>A loop waiting for some externally set flag is called a <em><a href=""https://en.wikipedia.org/wiki/Spinlock"" rel=""noreferrer"">Spinlock</a></em> and a proper spinlock implementation must take care to use <em><a href=""https://en.wikipedia.org/wiki/Atomic_semantics"" rel=""noreferrer"">Atomic Semanticity</a></em> and <em><a href=""https://en.wikipedia.org/wiki/Memory_barrier"" rel=""noreferrer"">Memory Barriers</a></em>.</p>

<p>However for what you intend to do, the right choice is the use of a <em><a href=""https://en.wikipedia.org/wiki/Monitor_(synchronization)#Condition_variables_2"" rel=""noreferrer"">Condition Variable</a></em>, a construct that's perfectly well supported by pthreads, which you're already attempt do use, but do it improperly.</p>
",1
55053346,55052815,0,"<p>Here is a summary of issues and fixes:</p>

<h1>Making sure you use the correct types for floats/doubles</h1>

<p>Suggest that you make a function:</p>

<pre><code>double f2c(double f) {
     return (f - 32.0) * 5/9;
}

int main() {
      printf(""%g¡ãF = %g¡ãC\n"", 100.0, f2c(100.0));
}
</code></pre>

<h1>Counting from 0 to 99</h1>

<p>for(i = 0; i &lt; 100; i++) {
   }</p>

<h1>pretty printing 0-99 every with new line for 10s</h1>

<p>for(i = 0; i &lt; 100; i++) {
         print(""%3d%1c"", i, (1+i) % 10? ' ' : '\n');
   }</p>

<h1>Putting it all together</h1>

<pre><code>#include &lt;stdio.h&gt;

double f2c(double f) {
     return (f - 32) * 5/9;
}

int main() {
    int i;
    for(i = 0; i &lt; 213; i++) {
        printf(""%3d¡ãF =&gt; %3.0f¡ãC%s"", i, f2c(i), (1+i) % 10? "" | "" : ""\n"");
    }
}
</code></pre>
",1
59393044,59392704,3,"<p>Can you try something like this in your struct definitions </p>

<pre><code>typedef struct 
{
    char* description;
    char* alternativeAnswer[4];
    int rightAnswer;
}question;

typedef struct 
{
    struct question* questions;
    int size;
    int max;
}questionList;
</code></pre>

<p>Consider the following sample code </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct student_college_detail
{
    int college_id;
    char college_name[50];
};

struct student_detail 
{
    int id;
    char name[20];
    float percentage;
    // structure within structure
    struct student_college_detail clg_data;
}stu_data;

int main() 
{
    struct student_detail stu_data = {1, ""Alex"", 90.5, 71145,
                                       ""UCB""};
    FILE *outfile; 

    // open file for writing 
    outfile = fopen (""student_detail.dat"", ""w""); 
    if (outfile == NULL) 
    { 
        fprintf(stderr, ""\nError opend file\n""); 
        exit (1); 
    } 

    // stu_data to file 
    fwrite (&amp;stu_data, sizeof(struct student_detail), 1, outfile); 

    if(fwrite != 0)  
        printf(""contents to file written successfully !\n""); 
    else 
        printf(""error writing file !\n""); 

    // close file 
    fclose (outfile); 

    return 0;
}
</code></pre>
",1
59393615,59392704,4,"<p>Note that, as mentioned in a comment, this does not work due to the fact that you are using pointers for the question list.  For the char strings the program will read characters until a <code>\0</code> is found.  But for anything else, only the value of the pointer variable will be written; that is, just the memory address.  </p>

<p>(By the way, it is a bit strange that you use a double pointer for a list of questions.  I will assume that this is a mistake, and you meant <code>question * questions</code>.)</p>

<p>My recommendation is to write, for each structure, a <code>write_&lt;structure&gt;</code> function, and use those for internal components in the functions of more external ones, following the structures' hierarchy from inside out.  Here you have only one level of indirection, and only one list of items, but this approach can be very useful for a multilevel, multilists problem.</p>

<p>Note, however, that since you are using pointers, you will end up having to pre-allocate them at reading time.  And, since you did not specify the length of those strings at declaration time (you can allocate 10 or 10000 chars for the same pointer), you will not know how many characters to read for each string.  For this reason, I would also use predefined maximum lengths for the char strings; otherwise, you will end up having to pre-allocate them at reading time.  Doing so, in addition, you can write the entire structure at once.  The declarations would look like this:</p>

<pre><code>#define NUM_OF_QUESTIONS    10
#define MAX_STRING_LEN     256
#define NUM_OF_ALT_ANSWERS   4

typedef struct {
    char description[MAX_STRING_LEN];
    char alternativeAnswer[NUM_OF_ALT_ANSWERS][MAX_STRING_LEN];
    int rightAnswer;
} question;

typedef struct  {
    question questions[NUM_OF_QUESTIONS];
    int size;
    int max;
} questionList;
</code></pre>

<p>Doing so, <em>you can now</em> use a single <code>fwrite</code> and a single <code>fread</code> to write and read in one single go the entire list of questions.  For this particular case, you will be done.</p>

<p>Note that I fixed the number of questions.  If you don't want to do this (that is if you still have <code>question * questions</code>), my recommendation is to use the former (more extensible) suggested approach, that is, having something like this:</p>

<pre><code>int write_question(FILE * fHdl, question * q, int items) {
    return fwrite((void*)(q), sizeof(question), items, fHdl);
}

int write_questionList(FILE * fHdl, questionList * qList, int numOfQuestions) {
    int nBytes = write_question(fHdl, qList-&gt;questions, numOfQuestions);
    if (0 != nBytes) { 
        nBytes += fwrite((void*)(&amp;(qList-&gt;size)), sizeof(int), 1, fHdl);
        nBytes += fwrite((void*)(&amp;(qList-&gt;max)), sizeof(int), 1, fHdl);
    }
    return nBytes;
}
</code></pre>

<p>And the same for reading.</p>
",2
54606284,54606221,6,"<p>If you will use the array as a <em>string</em>, it must include the terminating null character. The terminating null character is part of the array and must be included in its size.</p>

<p>Many of the standard C library routines take arguments that are <em>strings</em>, which are arrays of characters terminated by a null character.</p>

<p>It is also possible to use an array of characters for your own purposes, without passing it to a standard library function that requires a string. If this is how you will use the array, it does not need to include a terminating null character.</p>

<p>When you are initializing such an array with string literals, you do not need to include space for the terminating null character in the size of the array. The terminating null character in the string literal will be used to initialize an array element only if there is room for it.</p>
",2
54565365,54565274,3,"<p>The problem is in this line near the end:</p>

<pre><code> printf(""%lf"", *(list.ballPtr).x);
</code></pre>

<p>The member selection operator <code>.</code> has higher precedence than the dereference operator <code>*</code>.  So the compiler thinks you're trying to access a pointer as a struct.  You can fix this by moving the parenthesis:</p>

<pre><code> printf(""%lf"", (*list.ballPtr).x);
</code></pre>

<p>Or by using the pointer to member operator <code>-&gt;</code> instead:</p>

<pre><code> printf(""%lf"", list.ballPtr-&gt;x);
</code></pre>
",0
58470545,58470508,2,"<p>You are printing the value as a character with <code>%c</code>, try using <code>%d</code>.</p>

<p>Those boxes are one way to represent unprintable characters.</p>
",0
55356513,55353451,1,"<p>The second clause of the <code>for</code> statement is for the loop termination condition, so you can't put anything unrelated there. Use a separate <code>if</code> statement inside the loop body:</p>

<pre><code>for(i=0; i&lt;6; i++)
{
  if(i != 2)
  {
    /* do stuff */
  }
}
</code></pre>
",0
55332643,55330017,1,"<p>Easiest way is to match the delimeter in the fmt string and CHECK THE RETURN VALUE OF scanf!!!!</p>

<pre><code>printf(""Please enter date (dd-mm-yy or dd/mm/yy):"");
while ((cnt == scanf(""%u/%u/%u"", &amp;day, &amp;mon1, &amp;year1)) != 3) {
    if (cnt == 1 &amp;&amp; scanf(""-%u-%u"", &amp;mon1, &amp;year1) == 2) break;
    if (scanf(""%*[^\n]"") == EOF) {   // discard the rest of the line
        exit(1);  // alternately clearerr(stdin); if you want to try
        // again despite the error or eof
    }
    printf(""Invalid input, please enter date (dd-mm-yy or dd/mm/yy):"");
}
</code></pre>
",1
54619792,54619758,6,"<p>This textbook is erroneous; the code is not valid C.</p>

<p>Per <em>6.7.9 Initialization</em>, ?3:</p>

<blockquote>
  <p>The type of the entity to be initialized shall be an array of unknown size or a complete object type that is not a variable length array type.</p>
</blockquote>

<p>The array <code>pergjigjet</code> is a variable-length array because the expression for the number of elements, <code>n</code>, is not an <em>integer constant expression</em>. <code>const</code>-qualified objects are not constants; they are simply objects for which attempts to modify them are either (depending on the method used) constraint violations or undefined behavior.</p>

<p>You could fix it by replacing <code>const int n=20, d=11;</code> with <code>enum { n=20, d=11 };</code> or use of preprocessor macros (<code>#define n 20</code>) but this is generally considered bad style.</p>

<p>As noted by Mike Christensen in a comment, it seems this textbook is rather bad. It's likely that the author was actually writing in a C-like subset of C++, not in C. This code would be valid in C++, since in C++, such <code>n</code> is a constant.</p>
",0
53884126,53883915,1,"<p>You are trying to execute the C source file directly in the shell, as if it was a shell script.  C needs to be compiled, and then you execute the file created by the compiler.</p>

<p>The default name for this that GCC produces is <code>a.out</code>, so execute it with <code>./a.out</code></p>
",5
55358536,55357835,-1,"<p>Something like this maybe:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;

typedef struct player
{
    char name[100];
    char color[6];
}Player;

typedef struct piece
{
    Player plaVar;
}Piece;

int main()
{
    Piece player1,player2;


    printf(""\nChess\n"");

    printf(""\nInput Player 1 name:"");
    scanf(""%s"",&amp;player1.plaVar.name);

    printf(""\nPlayer 1 color:(black or white):"");
    scanf(""%s"",&amp;player1.plaVar.color);
    fflush(stdin);
    if(!strcmp(player1.plaVar.color, ""black""))
    {
        printf(""\nPlayer 2  is black\n"");
        fflush(stdin);
    }
    else if(!strcmp(player1.plaVar.color, ""white""))
    {
        printf(""\nPlayer 2 color is black\n"");
        fflush(stdin);
    }

    printf(""\nInput Player 2 name:"");
    scanf(""%s"",&amp;player2.plaVar.name);   
    return 0;
}
</code></pre>
",0
54731003,54724004,0,"<blockquote>
  <p>?I don't know it's format</p>
</blockquote>

<p>Hmm .. it seems to me that You know the format exactly:</p>

<blockquote>
  <p>The file will contain int(1-999) and char: ""OL""=overloaded, ""ND""=noData, ""LB""=lowBattery</p>
</blockquote>

<p>Your file contains a whitespace separated sequence of tokens, each of which is either OL, ND, LB or an integer in the specified range.</p>

<p>So to parse that file read one character at a time. Whitespace? Ignore and continue with the next. A digit? Now should come up to 2 more digits. Read them and convert to an integer. <code>'O'</code>, <code>'N'</code> or <code>'L'</code>? Look for the next character to be the correct one. Everything else? Parse error!</p>

<p>To save each token create a structure like:</p>

<pre><code>struct Token
{
  enum
  {   TokenOverLoad
    , TokenNoData
    , TokenLowBattery
    , TokenData
  } kind;
  short data; // only if kind == TokenData
};
</code></pre>

<p>Then store these in either a list or dynamic array during parsing. Afterwards You can iterate over that list/array to implement any required functions like sum ...</p>
",0
55446476,55445250,0,"<p>Given that the C implementation is known to use IEEE-754 basic 32-bit binary floating-point for its <code>float</code> type, the following code shows how to take apart the bits that represent a <code>float</code>, adjust the exponent, and reassemble the bits. Only simple multiplications involving normal numbers are handled.</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;


int main(void)
{
    float f = 6.125;

    //  Copy the bits that represent the float f into a 32-bit integer.
    uint32_t u;
    assert(sizeof f == sizeof u);
    memcpy(&amp;u, &amp;f, sizeof u);

    //  Extract the sign, exponent, and significand fields.
    uint32_t sign        = u &gt;&gt; 31;
    uint32_t exponent    = (u &gt;&gt; 23) &amp; 0xff;
    uint32_t significand = u &amp; 0x7fffff;

    //  Assert the exponent field is in the normal range and will remain so.
    assert(0 &lt; exponent &amp;&amp; exponent &lt; 254);

    //  Increment the exponent.
    ++exponent;

    //  Reassemble the bits and copy them back into f.
    u = sign &lt;&lt; 31 | exponent &lt;&lt; 23 | significand;
    memcpy(&amp;f, &amp;u, sizeof f);

    //  Display the result.
    printf(""%g\n"", f);
}
</code></pre>
",1
55446119,55445250,0,"<p>Maybe not exactly what you are looking for, but C has a library function <a href=""https://en.cppreference.com/w/c/numeric/math/ldexp"" rel=""nofollow noreferrer""><code>ldexp</code></a> which does exactly what you need:</p>

<pre><code>double x = 6.5;
x = ldexp(x, 1); // now x is 13
</code></pre>
",0
54993158,54992934,0,"<p>In above program, the whitespace between array elements in <code>tabuleiro.txt</code> is not being read. Space read only while reading first row in </p>

<pre><code>fscanf(fp,""%d %d"",&amp;lines,&amp;columns);
</code></pre>

<p>Modifying the nested <code>for</code> loops, with an additional declaration before, as follows:</p>

<pre><code>    char whitespace;
    for(i=1;i&lt;=lines;i++){
        for(j=1;j&lt;=columns;j++){
            fscanf(fp, ""%c"", &amp;matrix[i][j]);
            fscanf(fp, ""%c"", &amp;whitespace);
            printf(""%c"", matrix[i][j]);
            printf(""%c"", whitespace);
        }
    }
</code></pre>

<p>prints the required result</p>

<pre><code>
X . . X
. O . X
. . O .
</code></pre>
",0
54697560,54697525,3,"<p>Note:  The code you posted probably should have flagged you with compile errors, or warnings.  Do you have them turned on?</p>

<p>Change the following:</p>

<pre><code> printf(""You have lost %d minutes to cigarettes. "", ComputeMinutesLost);
</code></pre>

<p>To:</p>

<pre><code> printf(""You have lost %d minutes to cigarettes. "", ComputeMinutesLost(userCigarettes));
                                                                       ^------------^  // forgot to include argument
</code></pre>

<p>By the way, the numeric value you <em>are</em> seeing is an integer representation of the address of the function <code>ComputeMinutesLost</code>.</p>

<p>Also, (thanks to @unimportant's comment)</p>

<p>in the following code section: //read the comments...</p>

<pre><code>const int MIN_CONST = 7;  // one of these...

int ComputeMinutesLost(int userCigarettes) {
   int minLost;
   int MIN_CONST;        // is not necessary, and masks the other
                         // remove one or the other
                         // (as is, this one invokes undefined behavior.)
</code></pre>
",3
54702089,54702074,2,"<p>An array declared <code>[2]</code> can hold 2 elements, at position <code>[0]</code> and position <code>[1]</code>.</p>

<p>When you try to put something in position <code>[2]</code>, you are corrupting memory, and the results are undefined / unpredictable.</p>
",0
56425783,56425651,2,"<p>As per you 2nd problem description you need to use <code>fgetc</code> and <code>fputc</code>, with that you don't need any buffer.</p>

<p><strong>Syntax's:</strong></p>

<pre><code>int fputc(int char, FILE *pointer)
int fgetc(FILE *pointer)
</code></pre>

<blockquote>
  <p><code>fgetc()</code> reads the next character from stream and returns it as an unsigned char cast to an <code>int</code>, or <code>EOF</code> on end of file or error.</p>
</blockquote>

<p>That is why <code>c</code> is declared as <code>int</code> instead of <code>char</code>.</p>

<p><strong>Example:</strong></p>

<pre><code>static void copy (FILE *input, FILE *output)
{
    int c;
    while ((c = fgetc(input)) != EOF){
        fputc(c, output);
    }
} 
</code></pre>
",4
56426084,56425651,2,"<p>There are problems in both answers:</p>

<ul>
<li><p>in the first code, you test if <code>fscanf()</code> returns non zero. You should instead test if it returns <code>1</code>, indicating a character was successfully read. Indeed at the end of the file <code>fscanf()</code> will return <code>EOF</code>, which is also non zero.</p></li>
<li><p>in the second code, you should use <code>fgetc()</code> and <code>fputc()</code>, not <code>fgets()</code> and <code>fputs()</code>. A single <code>int c;</code> is required for this approach.</p></li>
</ul>

<p>Here are corrected versions:</p>

<p>First question:</p>

<pre><code>static void copy(FILE *input, FILE *output) {
    char c;
    while (fscanf(input, ""%c"", &amp;c) == 1) {
        fprintf(output, ""%c"", c);   
    }
}
</code></pre>

<p>Second question:</p>

<pre><code>static void copy(FILE *input, FILE *output) {
    int c;
    while ((c = fgetc(input)) != EOF) {
        fputc(c, output);
    }
}
</code></pre>

<p>Note how <code>c</code> must be defined as <code>char</code> for the <code>fscanf()</code> version and <code>int</code> for the <code>fgetc()</code> approach. <code>fgetc()</code> returns an <code>int</code>, either with the negative value <code>EOF</code> indicating end of file or input error, or the value of the byte read from the stream as an <code>unsigned char</code>.</p>
",0
55495721,55495511,2,"<p><code>scanf(""%c"",&amp;command);</code> returns 1 if you read a character, 0 on end of file, so it cannot be 'y'</p>

<p>warning also with the newline you will read doing char by char (without a space before the <em>%c</em> in the format)</p>

<p>you can do :</p>

<pre><code>char command[4];

do{
    ...
    printf(""Do you want to run the program Again? \n Type y or n \n"");
    if (scanf(""%3s"",command) != 1) {
      /* EOF */
      break;
    } 
} while(*command == 'y');
</code></pre>

<p>As you can see in the <em>scanf</em> I limit the length of the read string to 3 (allowing yes/no in case ;-) ), that allows to not take the risk to write out of <em>command</em> having size 3+1 to be able to memorize the null char.</p>
",0
55530504,55529878,1,"<p>You do not have to <em>remove multiple occurrences</em> but to sum the values associated to each character.</p>

<p>The key in the couples is just a character so the possible values are limited and it is possible to use them as the index in an array containing the sum of the associated values and an other one indicating if the character was used. In case the numbers associated to a character are always positive it is possible to have only one array initializing the count to -1.</p>

<p>After by definition iterating on the consecutive indexes to write the counts produces them sorted on the character.</p>

<p>For instance :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

int main()
{
  int n, i;
  int count[1 &lt;&lt; CHAR_BIT] = { 0 };
  char used[1 &lt;&lt; CHAR_BIT] = { 0 };

  /* read inputs */
  puts(""enter number of couples:"");
  if ((scanf(""%d"", &amp;n) != 1) || (n &lt;= 0)) {
    fprintf(stderr, ""invalid number"");
    return -1;
  }

  puts(""enter couples"");
  for (i = 0; i != n; ++i) {
    unsigned char c;
    int v;

    if (scanf("" %c %d"", &amp;c, &amp;v) != 2) {
      fprintf(stderr, ""invalid couple"");
      return -1;
    }
    used[c] = 1;
    count[c] += v;
  }

  /* write result */
  puts(""result :"");
  for (i = 0; i != (1 &lt;&lt; CHAR_BIT); ++i) {
    if (used[i])
      printf(""%c %d\n"", (char) i, count[i]);
  }

  return 0;
}
</code></pre>

<p>Some remarks :</p>

<ul>
<li>I do not suppose how many bits there are in a char, I use <code>CHAR_BIT</code>.</li>
<li>In the format <code>"" %c %d""</code> the space before <code>%c</code> allows to bypass the spaces/newline</li>
<li>I force the character <em>c</em> to be <em>unsigned</em> because I use it as an index and do not want to take the risk to have a negative index</li>
<li><em>of course</em> when I do a <em>scanf</em> I check it success</li>
</ul>

<p>Compilation and execution :</p>

<pre><code>/tmp % gcc -pedantic -Wextra -Wall c.c
/tmp % ./a.out
enter number of couples:
5
enter couples
M 25 A 50 
      O 70 A 45 L 100
result :
A 95
L 100
M 25
O 70
</code></pre>
",3
56063748,56062934,0,"<p>You are allocating using <code>sizeof(array)</code> which is not the correct unit of allocation that you want.</p>

<p>It looks like what you want are two different kinds of memory allocations or objects.</p>

<p>The first is an array of pointers to character strings since the file data is a series of character strings.</p>

<p>The second kind of memory allocation is for the memory to hold the actual character string.</p>

<p>The first kind of memory allocation, to an array of pointers to character strings would be:</p>

<pre><code>char **pArray = malloc (100 * sizeof(char *));  // allocate the array of character string pointers
</code></pre>

<p>The second kind of memory allocation, to a character string which is an array of characters would be:</p>

<pre><code>char *pString = malloc ((256 + 1) * sizeof(char));  // allocate a character array for up to 256 characters
</code></pre>

<p>The <code>256 + 1</code> is needed in order to allocate space for 256 characters plus one more for the end of string character.</p>

<p>So to allocate the entire needed space, you would do the following:</p>

<pre><code>int  iIndex;
int  nMax = 100;
char **pArray = malloc (nMax, sizeof(char *));  // allocate array of rows

for (iIndex = 0; iIndex &lt; nMax; iIndex++) {
    pArray[iIndex] = malloc ((256 + 1) * sizeof (char));  // allocate a row
}

// now use the pArray to read in the lines of text from the file.
// for the first line, pArray[0], second pArray[1], etc.
</code></pre>

<p><strong>Using <code>realloc()</code></strong></p>

<p>A question posed is using the <code>realloc()</code> function to adjust the size of the allocated memory.</p>

<p>For the second kind of memory, memory for the actual character string, the main thing is to use <code>realloc()</code> as normal to expand or shrink the amount of memory. However if memory is reduced, you need to consider if the text string was truncated and a new end of string terminator is provided to ensure the text string is properly terminated with and end of string indicator.</p>

<pre><code>// modify size of a text string memory area for text string in pArray[i]
// memory area. use a temporary and test that realloc() worked before
// changing the pointer value in pArray[] element.
char *p = realloc (pArray[i], (nSize + 1) * sizeof (char));
if (p != NULL) {
    pArray[i] = p;     // valid realloc() so replace our pointer.
    pArray[i][nSize] = 0;   // ensure zero terminator for string
}
</code></pre>

<p>If you ensure that when the memory area for <code>pArray]</code> is set to NULL after allocating the array, you can just use the <code>realloc()</code> function as above without first using <code>malloc()</code> since if the pointer in the argument to <code>realloc()</code> is NULL then <code>realloc()</code> will just do a <code>malloc()</code> for the memory.</p>

<p>For the first kind of memory, you will need to consider freeing any memory whose pointers may be destroyed when the allocated array is shortened. This means that you will need to do a bit more management and keeping management data about the allocated memory area. If you can guarantee that you will only be increasing the size of the array and never shortening it then you don't need to do any management and you can just use the same approach as provided for the second kind of memory above.</p>

<p>However if the memory allocated for the first kind of memory will need to be smaller as well as larger, you need to have some idea as to the size of the memory area allocated. Probably the easiest would be to have a simple <code>struct</code> that would provide both a pointer to the array allocated as well as the max count of items the array can hold.</p>

<pre><code>typedef struct {
    size_t   nCount;
    char   **pArray;
} ArrayObj;
</code></pre>

<p><strong>Warning:</strong> the following code has not been tested or even compiled. Also note that this only works for if the memory allocation will be increased.</p>

<p>Then you would wrap the <code>realloc()</code> function within a management function. This version of the function only handles if <code>realloc()</code> is always to expand the array. If making it smaller you will need to handle that case in this function.</p>

<pre><code>ArrayObj ArrayObjRealloc (ArrayObj obj, size_t nNewCount)
{
    // make the management a bit easier by just adding one to the count
    // to determine how much memory to allocate.
    char **pNew = realloc (obj.pArray, (nNewCount + 1) * sizeof (char *));

    if (pNew != NULL) {
        size_t   ix;

        // realloc() worked and provided a valid pointer to the new area.
        // update the management information we are going to return.
        // set the new space to NULL to have it in an initial and known state.
        // initializing the new space to NULL will allow for knowing which array
        // elements have a valid pointer and which don't.
        obj.pArray = pNew;
        for (ix = nNewCount; ix &gt;= obj.nCount; ix--) {
            obj.pArray[ix] = NULL;
        }
        obj.nCount = nNewCount;
    }

    return obj;
}
</code></pre>

<p>and use this function something like</p>

<pre><code>AnyObj obj = {0, NULL};

// allocate for the first time

obj = ArrayObjRealloc (obj, 100);

// do stuff with the array allocated
strcpy (obj.pArray[i], ""some text"");

// make the array larger
obj = ArrayObjRealloc (obj, 150);
</code></pre>
",2
56101130,56099432,0,"<p>The program below works as expected:</p>

<hr>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/wait.h&gt;


int main(void)
{
int rc;

rc=execlp(""/bin/date"", ""deet"", (char*) NULL);

printf(""Rc=%d,%d(%s)\n"", rc, errno, strerror(errno));

return 0;
}
</code></pre>

<hr>

<p>Next step: add some arguments. (next step: fix the plumbing)</p>

<hr>

<pre><code>rc=execlp(""/bin/ls"", ""ls"", ""-li"", (char*) NULL);
</code></pre>
",0
55560910,55560900,3,"<p>Assign to the variable <code>bit</code> a value of <code>1</code> if the result of evaluating <code>(dec &amp; 0x8000)</code> is not equal to <code>0</code>; and a value of <code>0</code> otherwise.</p>
",0
55561271,55560900,0,"<p>It tests if the single bit set in the constant <code>0x8000</code> is set in <code>dec</code> or not. <code>&amp;</code> is the <em>bitwise and</em> operator.</p>

<p>The result of <code>(dec &amp; 0x8000) != 0</code> (which is either 0 or 1) is assigned to <code>bit</code>.</p>

<p>Personally I prefer <code>bit = !!(dec &amp; 0x8000)</code>.</p>
",0
55568733,55568675,3,"<p>Loading an integer from a smaller type does not preserve the bits that the smaller type didn't have; they are cleared (or set by sign-extension, for signed types).</p>

<p>So:</p>

<pre><code>int x = 0xfeefd00d;
x = (char) 1;
</code></pre>

<p>leaves the value <code>1</code>, as an integer, in <code>x</code>, <em>not</em> <code>0xfeedf001</code>.</p>
",0
55568758,55568675,1,"<p>When a variable is used in an expression together with variables of different types (like in the assignment in the loop condition), there's an <a href=""http://en.cppreference.com/w/c/language/conversion"" rel=""nofollow noreferrer""><em>implicit conversion</em></a> being made. Conversions only convert between <em>types</em>, but if possible keeps the value.</p>

<p>So when you reach the null-terminator in <code>str</code>, it's converted (<a href=""https://en.cppreference.com/w/c/language/conversion#Integer_promotions"" rel=""nofollow noreferrer"">promoted</a> actually) to an <code>int</code>, keeping the value <code>0</code>. And <code>0</code> is always ""false"", which ends the loop.</p>
",0
55637918,55634311,5,"<p>I learned something new today.  I've never used the <code>_s</code> functions and always assumed they were vendor-supplied extensions, but they are actually defined in the language standard under Annex K, &quot;Bounds-checking Interfaces&quot;.  With respect to <code>printf_s</code>:</p>
<blockquote>
<strong>K.3.5.3.3 The <code>printf_s</code> function</strong><br><br>
<strong>Synopsis</strong><br><br>
<pre>1 <code>#define _ _STDC_WANT_LIB_EXT1_ _ 1
  #include &lt;stdio.h&gt;
  int printf_s(const char * restrict format, ...);</code></pre>
<strong>Runtime-constraints</strong><br><br>
2 <code><strong>format</strong></code> shall not be a null pointer. The <strong><code>%n</code></strong> specifier<sup>394)</sup> (modified or not by flags, field
width, or precision) shall not appear in the string pointed to by <code><strong>format</strong></code>. Any argument
to <code><strong>printf_s</strong></code> corresponding to a <code><strong>%s</strong></code> specifier shall not be a null pointer.<br><br>
3 If there is a runtime-constraint violation, the <strong><code>printf_s</code></strong> function does not attempt to
produce further output, and it is unspecified to what extent <code><strong>printf_s</strong></code> produced output
before discovering the runtime-constraint violation.<br><br>
<strong>Description</strong><br><br>
4 The <strong><code>printf_s</code></strong> function is equivalent to the <strong><code>printf</code></strong> function except for the explicit
runtime-constraints listed above.<br><br>
<strong>Returns</strong><br><br>
5 The <strong><code>printf_s</code></strong> function returns the number of characters transmitted, or a negative
value if an output error, encoding error, or runtime-constraint violation occurred.
<hr>
<sup>394) It is not a runtime-constraint violation for the characters <strong><code>%n</code></strong> to appear in sequence in the string pointed
at by format when those characters are not a interpreted as a <strong><code>%n</code></strong> specifier. For example, if the entire
format string was <strong><code>%%n</code></strong>.</sup>
</blockquote>
<p><sup><em><a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""noreferrer"">C 2011 Online Draft</a></em></sup></p>
<p>To summarize, <code>printf_s</code> performs additional runtime validation of its arguments not done by <code>printf</code>, and will not attempt to continue if any of those runtime validations fail.</p>
<p>The <code>_s</code> functions are <em>optional</em>, and the compiler is not required to support them.  If they are supported, the macro <code>__STDC_WANT_LIB_EXT1__</code> will be defined to 1, so if you want to use them you'll need to so something like</p>
<pre><code>#if __STDC_WANT_LIB_EXT1__ == 1
    printf_s( &quot;%s&quot;, &quot;This is a test\n&quot; );
#else
    printf( &quot;%s&quot;, &quot;This is a test\n&quot; );
#endif
</code></pre>
",1
55682124,55682056,2,"<p>The <code>strcmp</code> function returns 0 if the strings are equal.  You're checking if they are unequal.  You instead want:</p>

<pre><code>if (strcmp(win1, play1) == 0) {
    p1++; 
} else if(strcmp (win1, play2) == 0) {
    p2++;
}
</code></pre>
",0
55764284,55763379,0,"<p>Your problem seems to come from the <code>while(no_digits&gt;0)</code> loop.</p>

<p>Indeed, you only handle when <code>no_digits_page</code> is in 1..9 range.</p>

<p>One simple correction could be:</p>

<pre><code>int no_of_pages(long no_digits)
{
    long no_pages=0,no_digits_page;

    while(no_digits&gt;0)
    {
        no_pages++; // count number of pages
        long  aux=no_pages;
        long no_digits_pages=0; // count how many digits are on a page

        while(aux)
        {
            aux=aux/10;
            no_digits_page++;
        }

        /**
         * CORRECTION'S?HERE
         * instead of using a complicated if / else for each case, simplify with: 
         */
        no_digits = no_digits - no_digits_page ;

    }

    if (no_digits&lt;0)
    {
        return no_pages-1;
    }
    else
        return no_pages;
}
</code></pre>

<hr>

<p>That said, I'm not sure this piece of code will address your entire problem. </p>

<pre><code>* What is the code supposed to do?
* What is the problem you want to solve?
</code></pre>
",0
55765506,55765417,0,"<p>You need to do the conversion from string to number after getting the input. I mean: first input, then check and convert.</p>

<pre><code>// 1st: input
if (!fgets(buf, sizeof buf, stdin)) /* error */;
// 2nd: check and convert
if (sscanf(buf, ""%d"", &amp;tab1[c]) != 1) /* error */;
</code></pre>

<p><code>scanf()</code> is already doing that on its own, but you maybe want something more powerful.</p>

<p>You want to use the return value of <code>scanf()</code> to know whether it converted successfully:</p>

<pre><code>if (scanf(""%d"", &amp;tab1[c]) != 1) /* error */
</code></pre>
",0
56228568,56228196,0,"<p>Don't read more than you need to.  One character at a time will do:</p>

<pre><code>#include &lt;stdio.h&gt;

/* Print lines that do not start with '-' */
int
main(int argc, char **argv)
{
        int first_char=1;
        int print;
        int c;

        FILE *fp = argc &gt; 1 ? fopen(argv[1],""r"") : stdin;
        if( fp == NULL ) {
                perror(argv[1]);
                return 1;
        }

        while( (c = fgetc(fp)) != EOF ) {
                if( first_char )
                        print = c != '-';
                if( print )
                        putchar(c);
                first_char = c == '\n';
        }
        return ferror(fp);
}
</code></pre>
",0
56228987,56228196,0,"<p>@Corot Another approach to solving your problem is the following code:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

/* Path to the file you are reading */
#define FILENAME  ""save_projeo.txt""

/* Set the maximum length of text line in the input file */
#define MAX_LENGTH    92

/**************
 * Main Driver
 **************/
 int main()
 {
     FILE *fp;
     char buffer[MAX_LENGTH+1]; // buffer to hold data read from input file
     const char *str = ""-"";  // String (here char) to be searched
     size_t num = 1;

     fp = fopen(FILENAME, ""r"");

     // Is the file opened to read?
     if( !fp){
         fprintf(stderr, ""Unable to open file &lt;%s&gt;\n"", FILENAME);
         exit(EXIT_FAILURE);
     }
     while(fgets(buffer, MAX_LENGTH, fp)){
          // If the first num bytes of buffer does not match the first num byte of str
          // then print the content of buffer
          if(memcmp(buffer, str, num) != 0)
              printf(""%s\n"", buffer);
     }
     fclose(fp);
     return EXIT_SUCCESS;
 }
</code></pre>
",0
58250637,58245666,0,"<p>If the intent of the posted code is to calculate the <a href=""https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions_:_I%CE%B1,_K%CE%B1"" rel=""nofollow noreferrer"">modified Bessel function I</a>, there are some pitfalls and useful semplifications to be aware of. Given</p>

<p><img src=""https://latex.codecogs.com/svg.latex?I_k(x)&space;=&space;%5Csum_%7Bm=0%7D%5E%7B%5Cinfty%7D%7B%5Cfrac%7B1%7D%7Bm!&space;%5C&space;%5CGamma&space;(m&space;&plus;&space;k&space;&plus;&space;1)%7D%7D%5Cleft(%5Cfrac%7Bx%7D%7B2%7D&space;%5Cright&space;)%5E%7B2m&space;&plus;&space;k%7D"" title=""I_k(x) = \sum_{m=0}^{\infty}{\frac{1}{m! \ \Gamma (m + k + 1)}}\left(\frac{x}{2} \right )^{2m + k}"" /></p>

<p>Trying to calculate the factorial, the value of the Gamma function, their product and the powers <em>separately</em> for each term of the sum leads to integer overflow sooner than later.</p>

<p>It's better to <em>update</em> the value of each addend of the sum instead. </p>

<p>Also, given that <code>k</code> is a whole, we have ¦£(n) = (n - 1)!</p>

<p><img src=""https://latex.codecogs.com/svg.latex?I_k(x)&space;=&space;%5Cfrac%7B1%7D%7Bk!%7D%5Cleft(%5Cfrac%7Bx%7D%7B2%7D&space;%5Cright&space;)%5Ek&space;&plus;&space;%5Cfrac%7B1%7D%7Bk!%7D%5Cfrac%7B1%7D%7Bk&plus;1%7D%5Cleft(%5Cfrac%7Bx%7D%7B2%7D&space;%5Cright&space;)%5Ek%5Cleft(%5Cfrac%7Bx%7D%7B2%7D&space;%5Cright&space;)%5E2&space;&plus;&space;..."" title=""I_k(x) = \frac{1}{k!}\left(\frac{x}{2} \right )^k + \frac{1}{k!}\frac{1}{k+1}\left(\frac{x}{2} \right )^k\left(\frac{x}{2} \right )^2 + ..."" /></p>

<p>The addends are increasingly smaller and, after some iterations, too small to be added to the sum, given the limited precision of type <code>double</code>.</p>

<pre><code>// Evaluates x^k / k! trying not to overflow
double power_over_factorial(double x, int k)
{
    double result = 1.0;
    for ( int i = 1; i &lt;= k; ++i )
    {
        result *= x / i;
    }
    return result;
}

#define MAX_ITERS 20

double modified_Bessel_I(int k, double x)
{
    x /= 2;
    const double xx = x * x;
    double partial = power_over_factorial(x, k);
    double old_sum, sum = partial;
    int m = 1;
    do
    {
        old_sum = sum;
        partial *= xx / ((m + k) * m);
        sum += partial;   
    }
    while ( old_sum != sum  &amp;&amp;  ++m &lt; MAX_ITERS );

    return sum;
}
</code></pre>

<p>Testable <a href=""https://wandbox.org/permlink/qQxa6k7kr5Bdhstu"" rel=""nofollow noreferrer"">here</a>.</p>
",3
56148275,56147948,-1,"<p>Change your code as follows:</p>

<pre><code>typedef struct
{
  match matches[30];
  team teams[6];
  int teamno;
  int played;
} championship;

championship *newchampionship(){
    championship *temp = malloc(sizeof championship);
    temp-&gt;played=0;
    temp-&gt;teamno=0;
    return temp;
}

int main(){
   championship *ch1=newchampionship();
   ...
}
</code></pre>
",2
56080052,56079941,3,"<p>Given the declaration <code>int uj_esemeny(meccs m, bajnoksag b)</code>, <code>b</code> is passed to the function by value, meaning only a copy of the caller¡¯s <code>bajnoksag</code> is passed to the function.</p>

<p>Within the function, all the statements such as <code>b.meccsek[b.jatszott++]=m;</code> change only the copy. They do not change the <code>bajnoksag</code> in the calling routine.</p>

<p>To fix this, pass a pointer to a <code>bajnoksag</code>:</p>

<ul>
<li>Change the function declaration to <code>int uj_esemeny(meccs m, bajnoksag *b)</code>.</li>
<li>Inside the function, change <code>b.</code> to <code>b-&gt;</code>, to refer to the pointed-to structure instead of to the copy.</li>
<li>Where the function is called, use <code>&amp;</code> to pass the address of a <code>bajnoksag</code> instead of a copy.</li>
</ul>
",5
57315944,57315412,6,"<p><code>0x80000000</code> is of course hexadecimal for the number 2,147,483,648, and this is the value it has in source code.</p>

<p>When <code>int</code> is 32 bits, it cannot represent 2,147,483,468, so <code>0x80000000</code> cannot be an <code>int</code> value. The C standard says that, instead of <code>int</code>, the type of <code>0x80000000</code> is <code>unsigned int</code>. (This is different for constants written in hexadecimal than in decimal. For <code>2147483648</code>, the type would be <code>long int</code> instead of <code>unsigned int</code>¡ªa decimal constant is the first signed integer type it fits in, starting with <code>int</code>, but a hexadecimal constant is the first integer type it fits in, either signed or unsigned.)</p>

<p>So, in <code>b[i] = 0x80000000;</code>, we are assigning an <code>unsigned int</code> to an <code>int</code>. Assignment converts the value on the right to the type on the left. However, the value on the right cannot be represented in an <code>int</code>. In this case, the C standard says the result is implementation-defined. The binary value for <code>0x80000000</code> is of course 10000000000000000000000000000000. In the two¡¯s complement system for representing signed 32-bit integers, the bit pattern for the smallest representable value, ?2<sup>31</sup>, is also 10000000000000000000000000000000. Thus, the author of this code is relying on the conversion to produce the <code>int</code> value that has the same bit pattern as the unsigned value <code>0x80000000</code>.</p>

<p>As this is not guaranteed by the C standard, this code is not portable. The author might better have used <code>INT_MIN</code> instead of <code>0x80000000</code> or simply <code>(-2147483647-1)</code>.</p>

<p>In <code>((signed)0x80000000 - d) / 10</code>, consider what would happen if we instead wrote <code>(0x80000000 - d) / 10)</code>. Since <code>0x80000000</code> is an <code>unsigned int</code>, the subtraction would be evaluated by converting <code>d</code> to an <code>unsigned int</code> and dividing by 10. For example, if <code>d</code> were <code>?1</code>, it would be converted to <code>0xFFFFFFFF</code> (because conversion to <code>unsigned int</code> is defined by the C standard to wrap), and <code>0x80000000 - 0xFFFFFFFF</code> would produce <code>0x80000001</code>, which is 2,147,483,649, and division by 10 would produce 214,748,364. However, since the author cast to <code>signed</code>, meaning <code>signed int</code> or <code>int</code>, the <code>(signed)0x80000000</code> evaluates to an <code>int</code> value of ?2,147,483,648, and the subtraction is evaluated with <code>int</code> arithmetic. Then we have <code>-2147483648 - -1</code>, which produces ?2,147,483,647, and division by 10 produces ?214,748,364.</p>

<p>So, in the assignment, implicit conversion produces the result the author desires (relying on implementation-defined behavior). In the arithmetic expression, there is no implicit conversion, so the author had to insert one explicitly. This is bad design for several reasons:</p>

<ul>
<li>It needlessly relies on implementation-defined behavior.</li>
<li>It uses subtleties of C semantics that can easily go wrong when somebody modifies the expressions or writes new ones that attempt to use <code>0x80000000</code> as if it were the minimum <code>int</code> value.</li>
<li>It does not document what it is doing or why.</li>
</ul>
",4
57315548,57315412,2,"<p>If we assume a compiler with 32 bit <code>int</code>, the constant <code>0x80000000</code> is out of range for that type. Therefore, it gets the type <code>unsigned int</code>. If we cast it to <code>signed</code> (which is a shorthand for <code>signed int</code>, which is a long-hand for just <code>int</code>) we then invoke an implementation-defined conversion that the author of the code is relying upon to produce the most negative <code>int</code> value.</p>
",2
57316131,57315412,0,"<p>The constant <code>0x80000000</code> has type <code>unsigned int</code> because it does not fit into type <code>int</code>.  This means conversions may take place when used in expressions with values of type <code>int</code>.</p>

<p>First let's take this case:</p>

<pre><code>b[i] = 0x80000000; 
</code></pre>

<p>Since <code>b[i]</code> has type <code>int</code>, the <code>unsigned int</code> value is converted in an implementation defined way to <code>int</code>.  Assuming a common implementation such as gcc or MSVC on x64, this results in the value -2147483648 being assigned to <code>b[i]</code>.  No cast is required here due to how the conversion happens.</p>

<p>Now lets look at the second case:</p>

<pre><code>    if ((x &gt; 0 &amp;&amp; k &gt; (0x7fffffff - d) / 10) ||
        (x &lt; 0 &amp;&amp; k &lt; ((signed)0x80000000 - d) / 10)) {
</code></pre>

<p>To understand why the cast is necessary, let's see what happens without it:</p>

<pre><code>    if ((x &gt; 0 &amp;&amp; k &gt; (0x7fffffff - d) / 10) ||
        (x &lt; 0 &amp;&amp; k &lt; (0x80000000 - d) / 10)) {
</code></pre>

<p>First we have <code>0x80000000 - d</code>  Because the first operand is <code>unsigned int</code> and the second is <code>signed int</code>, the latter is converted to <code>unsigned int</code> and the resulting expression has type <code>unsigned int</code>.  Since the value of <code>d</code> is in the range -9 to 0 subtracting this from 0x80000000 == 2147483648 gives you a range of 2,147,483,648 to 2,147,483,639, and dividing by 10 gives you a range of 214,748,364 to 214,748,363.  <code>k</code> is 0 on the first iteration of the loop, so if <code>x</code> is negative then you have <code>0 &lt; 214,748,363</code> which is false, causing the function to think there's an overflow and return 0.</p>

<p>By casting 0x80000000 to <code>signed</code>, the expression <code>((signed)0x80000000 - d) / 10</code> evaluates to a value from -2,147,483,648 to -2,147,483,639, which is what we want to compare <code>k</code> with.</p>
",0
58708534,58708222,0,"<p>The fgets function receives a string from the input stream.  The relation between keystrokes and the input stream is entirely up to your operating system.</p>

<p>If the features provided by the OS are not suitable for you then you can use a console input library such as <code>ncurses</code>.</p>
",1
56413633,56411452,0,"<p>It may or may not make a difference here, because I/O is the slowest thing that should be happening here, but all those casts don't help performance and may even result in buggy code. A cast tells a compiler ¡°I'm doing something weird here¡±, and that tends to tell the compiler not to optimize.</p>

<p>For example, on most platforms, the size of <code>float</code> is 4 bytes, and it's faster to assign a 4-byte value at an address that's a multiple of 4 than at an arbitrary address. When the compiler sees a variable of type <code>float</code> or array of <code>float</code>, it will align this variable correctly in memory to be able to use the fast-4-byte-assignment method. When the compiler sees <code>(float *) (weights+j*0x04)</code>, it isn't sure whether this is a multiple of 4, so it might generate code that is sure to copy what you expect, but is slower because it copies the individual bytes one by one. (The compiler doesn't have to generate slower code: it can be nasty and assume that <code>weights</code> is correctly aligned, and generate code that doesn't copy what you expect if <code>weights</code> is not correctly aligned.)</p>

<p>The body of the loop should be just</p>

<pre><code>fscanf(fp, ""%f"", weights[j]);
</code></pre>

<p>(Assuming that you know that the input file is well-formed, otherwise you need to add error checking.)</p>
",0
54735541,54735487,4,"<p>Output from <code>printf</code> and other functions that write to <code>stdout</code> and other files may be buffered, so they may appear to print only when the buffer is flushed.</p>

<p>You can add the line <code>fflush(stdout)</code> inside your loop to force the buffer to be flushed to the stream, guaranteeing that any pending output currently in the buffer will be written out.</p>
",2
54751963,54751906,2,"<pre><code>if(oldmax&lt;Newmax){
</code></pre>

<p>Don't compare newmax and oldmax. Compare <code>max</code> and <code>value</code>. Same with <code>min</code>.</p>

<p>I'm not even sure about the purpose of <code>Newmax</code> and <code>oldmax</code>. Remove these variables all-together, as it will just confuse you.</p>

<p>Just use min, max, and value. It will sort out.</p>
",0
53928873,53928652,0,"<p>You write that the file is <em>new</em> - then it it will be simple to write <code>n-1</code> blank lines first (error checking omitted ...):</p>

<pre><code>void write_line(const char * fname, const char * line, size_t blank_lines) {
    FILE stream = fopen(fname, ""w"");

    for (size_t i=0; i &lt; blank_lines; i++) 
        fputs(""\n"", stream);

    fprintf(stream, ""%s\n"", line);          
    fclose(stream);
}
</code></pre>

<p>But - this seems like a somewhat weird function?</p>
",2
53932112,53928652,0,"<p>As explained by Andrew below, fseek sets the position indicator associated with the stream to a new position. 
Check the reference.
<a href=""http://www.cplusplus.com/reference/cstdio/fseek/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/cstdio/fseek/</a></p>

<p>Reproducing the example in the above reference </p>

<pre><code>#include &lt;stdio.h&gt;

int main ()
{
  FILE * pFile;
  pFile = fopen ( ""example.txt"" , ""wb"" );
  fputs ( ""This is an apple."" , pFile );
  fseek ( pFile , 9 , SEEK_SET );
  fputs ( "" sam"" , pFile );
  fclose ( pFile );
  return 0;
}
// After this code is successfully executed, the file example.txt contains: 
// This is a sample.
</code></pre>

<p>For the problem you mentioned, simply writing into the file from beginning to end will suffice. </p>

<p>Get hold of a good book on C programming. 
For now,</p>

<pre><code>    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;

int main()
{
    int i;

    FILE *fconfig = fopen(""config_new.txt"",""w"");
    if(fconfig == NULL)
    {
        perror(""Error!\n""); // print error message
        exit(1);
    }

    for (i = 0; i &lt; 5; i++) // line numbers from 0 ? 
    {
            if(i % 2 == 0)
            {
                fprintf(fconfig, ""%d\n"", i+17 );
            }
            else 
            {
                fprintf(fconfig, ""\n"" ); // blank lines on odd numbered lines
            }

    }
    fclose( fconfig ); // close the file after you finish writing.
    exit(0);
}
</code></pre>
",1
55282388,54776034,1,"<p>It may help to recall that there are no arrays in C, only pointers and blocks of memory. The rest is compiler fakery.</p>

<p>Your main program allocates a block of memory for 5 <code>*int</code> pointers (called <code>x</code>) on the stack and 5 blocks of 5 <code>int</code>s on the heap. It calls the function with a pointer to the beginning of x, and relies on the function to perform the correct pointer arithmetic to access the other blocks correctly.</p>

<p>The first two functions are equivalent in this case (that's not always true), and the pointer arithmetic correctly matches the allocations. The third function incorrectly performs pointer arithmetic to address 25 ints arranged 5x5, so the first 5 stores overwrite a <code>*int</code> by an <code>int</code> and the 6th access is out of bounds (assuming <code>int</code> and <code>*int</code> are the same size).</p>

<p>I've explained it this way to emphasise the necessity to understand the relationship between arrays and pointer arithmetic in C. If you really understand this you won't need to ask questions like this again.</p>
",0
54809990,54809911,2,"<p>You¡¯re not initializing <code>sum</code> with  </p>

<pre><code>int sum, a, b = 0;
</code></pre>

<p>Only <code>b</code> is being initialized.  You need to add an initializer for <code>sum</code> as well.</p>

<pre><code>int sum=0, a=0, b = 0;
</code></pre>
",0
54810033,54809911,0,"<p>The operator <code>+=</code> adds the right side value to the left side value, and then stores the sum back into the left side value.</p>

<p>If <code>sum</code> is uninitialized, the operation <code>sum += X</code> invokes undefined behavior; the result depends on the previous value of <code>sum</code>.</p>
",0
56322127,56322091,2,"<p>First have a look at <a href=""https://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer"">Operator Precedence</a>.</p>

<p>Then, regarding the working of logical OR operator, from <code>C11</code>, chapter ¡ì6.5.14 (<em>emphasis mine</em>)</p>

<blockquote>
  <p>[...] the <code>||</code> operator <strong>guarantees left-to-right evaluation</strong>; if the
  second operand is evaluated, there is a sequence point between the evaluations of the first
  and second operands. <strong>If the first operand compares unequal to 0, the second operand is
  not evaluated.</strong></p>
</blockquote>

<p>and regarding the result:</p>

<blockquote>
  <p>The <code>||</code> operator shall yield <code>1</code> if either of its operands compare unequal to <code>0</code>; otherwise, it
  yields <code>0</code>. The result has type <code>int</code>.</p>
</blockquote>

<p>So, in your code</p>

<pre><code> d = ++c || ++a &amp;&amp; ++b  ;
</code></pre>

<p>is the same as</p>

<pre><code> d = (++c) || (++a &amp;&amp; ++b);
</code></pre>

<p>which evaluates to</p>

<pre><code> d = 1 || (++a &amp;&amp; ++b);         // short circuit, RHS not evaluated
</code></pre>

<p>which is finally same as</p>

<pre><code>d = 1;  // 1 is not the value computation of `++c`, rather result of the `||` operation.
</code></pre>
",3
54840252,54840228,6,"<pre><code>""~/Desktop/notes""
</code></pre>

<p>There is no directory named <code>~</code> in there. Some programs (most notably shells like <code>bash</code>) expand <code>~</code> to the home directory of the current user, but <code>open</code> is not a shell and will not do that.</p>

<p>If you need a path relative to the home directory, you may do something like:</p>

<pre><code>char* home = getenv(""HOME"");
if (home) {
     strcpy(datafile, home);
     strcat(datafile, ""/Desktop/notes"");
     ...
} else {
    ... report an error
}
</code></pre>
",1
54874147,54873609,0,"<p>There are two main issues here.</p>

<p>First, you're not reallocating as much space as you think you are.  You do the initial allocation here:</p>

<pre><code>int *primes = malloc(100*sizeof(int));
</code></pre>

<p>Then reallocate here:</p>

<pre><code>primes = realloc(primes, 100*sizeof(int));
</code></pre>

<p>The amount of space you're reallocating is the same as the original size.  You're not making the array any bigger.  You can fix this by keeping track of the current capacity and increasing it as needed.  So the initial allocation would look like this:</p>

<pre><code>int capacity = 100;
int *primes = malloc(capacity*sizeof(int));
</code></pre>

<p>And the reallocation like this:</p>

<pre><code>timesRealloc++;
availableSlots = 100;
capacity += availableSlots;
primes = realloc(primes, capacity*sizeof(int));
</code></pre>

<p>The second issue is that you start <code>arraySize</code> at 1 and write to <code>primes[arraySize]</code>, but <code>availableSlots</code> is initilaized to 100.  So when you hit the current capacity you're actually writing to one element past the end.</p>

<p>Initialize <code>availableSlots</code> to 99 instead of 10:</p>

<pre><code>int availableSlots = 99;
</code></pre>

<p>Also, don't forget to <code>free(primes)</code> at the end so you don't have a memory leak.</p>
",0
54893406,54891800,2,"<p>While this is not impossible, it is usually impractical, as there are significant hurdles, including:</p>

<ul>
<li>The memory containing machine instructions is usually marked non-writable, so you must change the protection settings before it can be changed. (On Unix systems, look into <code>mprotect</code>.)</li>
<li>The changes that need to be made are architecture-dependent¡ªeach processor architecture has its own instructions and its own encodings of those instructions. You have to figure out what new instructions to write and how to encode them.</li>
<li>There is widely available software to encode instructions, namely an assembler. To turn instructions into encodings on the fly, one might embed an assembler in a program or invoke one in another process. Then there is the problem of how to extract the instructions from the output of the assembler (an object file). An assembler can also be used in the ordinary way to prepare a given instruction sequence, rather than on the fly in a running program.</li>
<li>Instructions just after they have been encoded by an assembler are generally represented in an intermediate form, where references to specific places in memory are either symbolic or are relative to certain reference points. Before putting them into a running program, these references must be resolved to the actual addresses in the program.</li>
<li>Once you know what instructions you want to replace in the function, there is the problem that they might be bigger than the instructions to be replaced, so they will not fit. Then you need a workaround, such as finding an alternate place for your instructions and, instead of putting your instructions in the function, putting in a small instruction that jumps to your instructions. Note that the memory you use for your instructions must be marked as executable.</li>
<li>After you change main memory, the instruction cache might hold an old copy of the instructions, so you need to flush the instruction cache.</li>
</ul>

<p>A simple change of subtraction to addition might be accomplished by finding the pertinent subtract instruction, changing the memory protection, writing an add instruction over the subtract, and flushing instruction cache. Anything beyond that will be more complicated.</p>
",1
55264316,55247475,0,"<p>Yeah that doesn't work so good. Here are the bugs:</p>

<pre><code>return -1;
</code></pre>

<p>Does not compile. Did you mean</p>

<pre><code>return (char*)-1;
</code></pre>

<p>Also, leaks memory. Do:</p>

<pre><code> if (f1) fclose(f1);
 if (f2) fclose(f2);
 return (char*)-1;
</code></pre>

<p>Oops you read from <code>file1</code> twice:</p>

<pre><code>while (fgets(line1, sizeof(line1), file1) != NULL &amp;&amp; fgets(line2, sizeof(line2), file1) != NULL)
</code></pre>

<p>should be</p>

<pre><code>while (fgets(line1, sizeof(line1), file1) != NULL &amp;&amp; fgets(line2, sizeof(line2), file2) != NULL)
</code></pre>

<p>Memory trashing:</p>

<pre><code>line3=strcat(line1,line2);
</code></pre>

<p>Should be:</p>

<pre><code>strcat(strcpy(a,line1),line2);
</code></pre>

<p>Only ever checks first line because early return:</p>

<pre><code>else
{
    return NULL;
}
</code></pre>

<p>Just eliminate that block.</p>

<p>Oops forgot to check for errors:</p>

<pre><code>char* diff = difference(""testifile.c"", ""testifile2.c"");

char* diff = difference(""testifile.c"", ""testifile2.c"");
if (diff == (char *)-1) {
    /* handle file open error */
}
else if (diff == NULL) {
    /* handle no difference */
}
else {
     /* your message */
     free(diff);
}
</code></pre>
",0
55627435,55627218,2,"<p>Let's re-write the code to be less terse and more readable:</p>

<pre><code>void tokenize(char *line, char **words, int *nwords)
{
  *nwords=1;
  words[0]=strtok(line,"" \t\n"");
  while (*nwords &lt; MAX_WORDS) {
    words[*nwords] = strtok(NULL, "" \t\n"");
    if (!words[*nwords])
      break;
    *nwords = *nwords + 1;
  }
}
</code></pre>

<p>One thing which also makes this code a bit harder to understand is the fact that it always accesses the number of words indirectly, via the <code>nwords</code> pointer. Here's one more rewrite, without this shorthand:</p>

<pre><code>void tokenize(char *line, char **words, int *nwords)
{
  int wordCount = 1;
  words[0]=strtok(line,"" \t\n"");
  while (wordCount &lt; MAX_WORDS) {
    words[wordCount] = strtok(NULL, "" \t\n"");
    if (!words[wordCount])
      break;
    wordCount = wordCount + 1;
  }
  *nwords = wordCount;
}
</code></pre>

<p>Finally, for a pointer <code>p</code>, testing <code>!p</code> is the same as testing <code>p == NULL</code>. So the check <code>if (!words[wordCount])</code> means ""if the currently last element in <code>words</code> is a null pointer."" That can happen when <code>strtok</code> returns a null pointer, indicating it has finished parsing.</p>

<p>Hopefully, it's a bit clearer now.</p>

<p>In general, the function uses <code>strtok</code> to extract words from <code>line</code> and store them into successive elements of the array <code>words</code>, with the number of words stored returned in <code>nwords</code>.</p>

<p>It will repeatedly extract one word, store it, and increment the word count. This continues until either:</p>

<ul>
<li><code>MAX_WORDS</code> are extracted, or</li>
<li><code>strtok</code> returns a null pointer, meaning there are no more words left in <code>line</code>.</li>
</ul>
",3
56389093,56388963,1,"<p>Let's add a little more code into the while loop body to show the difference:</p>

<pre><code>while (a != EOF &amp;&amp; b != EOF) 
{
    a = getc(f1);
    b = getc(f2);

    if(a != b)
    {
        /* print info about this difference */
    }
}
</code></pre>

<p>And after this let's add an information about difference of of file length:</p>

<pre><code>if (a == EOF || b == EOF) 
{
    /* print other characters of the longer file */
}
</code></pre>

<p>Please add comments here if you see any problems in these small steps.</p>

<p>And the last step will be simple: save the difference in file (but before compliting of both first steps I'd recommend you to use <code>printf</code> for printing of everything).</p>
",4
54968214,54967998,-1,"<p>in the following solution, there is a single pass over the line. If a comment was found (<code>//</code>), we terminate and print it. supporting (<code>/* */</code>) requires more work.</p>

<pre><code>while (fgets(line, LINE_LENGTH, file) != NULL)
{
    size_t len = strlen(line);
    size_t i;

    for (i=0; i&lt;len; i++)
    {
        if (line[i]=='/' &amp;&amp; line[i + 1]=='/')
        {
            line[i] = '\0';
            break;
        }
    }
    fprintf(output, ""%s"", line);
}
</code></pre>

<p>note to two points in addition to the logic:</p>

<ul>
<li><p>when printing using <code>printf</code>, always use a format string. If the line contains % it might do unexpected things.</p></li>
<li><p>do not put <code>strlen</code> in the condition of a loop. It generates a lot of unnecessary loops to calculate the length.</p></li>
</ul>
",5
54968214,54967998,-1,"<p>in the following solution, there is a single pass over the line. If a comment was found (<code>//</code>), we terminate and print it. supporting (<code>/* */</code>) requires more work.</p>

<pre><code>while (fgets(line, LINE_LENGTH, file) != NULL)
{
    size_t len = strlen(line);
    size_t i;

    for (i=0; i&lt;len; i++)
    {
        if (line[i]=='/' &amp;&amp; line[i + 1]=='/')
        {
            line[i] = '\0';
            break;
        }
    }
    fprintf(output, ""%s"", line);
}
</code></pre>

<p>note to two points in addition to the logic:</p>

<ul>
<li><p>when printing using <code>printf</code>, always use a format string. If the line contains % it might do unexpected things.</p></li>
<li><p>do not put <code>strlen</code> in the condition of a loop. It generates a lot of unnecessary loops to calculate the length.</p></li>
</ul>
",5
53933277,53932643,6,"<p>This is an ugly cludge that will be specific to this function, but you can do it like this:</p>

<pre><code>#define num_sys_convert(x, b1, b2) \
    ((void)(struct digits { \
        int d1:(( (x)             %10 &gt;= (b1) ? -1 : 1)); \
        int d2:((((x) /        10)%10 &gt;= (b1) ? -1 : 1)); \
        int d3:((((x) /       100)%10 &gt;= (b1) ? -1 : 1)); \
        int d4:((((x) /      1000)%10 &gt;= (b1) ? -1 : 1)); \
        int d5:((((x) /     10000)%10 &gt;= (b1) ? -1 : 1)); \
        int d6:((((x) /    100000)%10 &gt;= (b1) ? -1 : 1)); \
        int d7:((((x) /   1000000)%10 &gt;= (b1) ? -1 : 1)); \
        int d8:((((x) /  10000000)%10 &gt;= (b1) ? -1 : 1)); \
        int d9:((((x) / 100000000)%10 &gt;= (b1) ? -1 : 1)); \
        int da:((((x) /1000000000)%10 &gt;= (b1) ? -1 : 1)); \
    }){0}, num_sys_convert_real(x, b1, b2))


char * num_sys_convert_real(int num_value,  int old_base, int targeted_base) {
    ...
}
</code></pre>

<p>The real function is wrapped by a call to the above macro.  This macro defines a struct with a number of bitfields, where the length of each bitfield is dependent on a specific decimal digit of the first argument.  If that digit is greater than or equal to the value of the second argument (i.e. the base), the size of the bitfield is set to -1, which is invalid and produces a compliation error.</p>

<p>If the number does look like a valid number for the given base, the end result is that an temporary object of the given struct type is created via a compound literal and used in an expression as the left side of the comma operator, meaning its value is discarded, and the actual function call is the right side of the comma operator.</p>

<p>This works under the assumption that:</p>

<ul>
<li>The first argument to the function is <strong>decimal integer literal</strong></li>
<li>The second argument to the function is an <strong>integer literal</strong></li>
<li>The literal has type <code>int</code>, i.e. no type suffix</li>
<li>An <code>int</code> is 32 bits in length</li>
</ul>

<p>It will <strong>always</strong> fail to compile if you do this:</p>

<pre><code>int value = 101;
num_sys_convert(value, 2, 10);
</code></pre>

<p>Or this:</p>

<pre><code>int base = 2;
num_sys_convert(101, base, 10);
</code></pre>

<p>Because an expression used to set the size of a bitfield must be a compile time constant expressions.</p>

<p>Also, this would fail the check:</p>

<pre><code>num_sys_convert(0x10, 2, 10);
</code></pre>

<p>Because the hex value 0x10 has the decimal value 16.</p>

<p>And this would pass the check:</p>

<pre><code>num_sys_convert(0xa, 2, 10);
</code></pre>

<p>Because the hex value 0xa has the decimal value 10.</p>

<hr>

<p>As this is such a cludge, <strong>don't do this</strong>!  </p>

<p>Rather than attempting to check parameters at compile time, the proper thing to do is to validate the parameters at run time inside of the function and to return some sort of error code if the parameters are invalid.</p>
",5
56459827,56459421,1,"<p>Here's another approach, more similar to your idea than other answers</p>

<pre><code>f = 0; // start with 0 equals
for(i=0;i&lt;n;++i)
{
    if(a[0] == a[i])
    {
        f += 1; // add 1 when finds pair of equals
        // break; // don't break: look at **ALL** elements
    }
}
if(f == n) /* if total pairs is total elements */
printf(""All elements are same"");
</code></pre>

<p>Note: this approach has to look at <strong>ALL</strong> elements. It is much more efficient to use an approach that minimizes the number of elements to compare.</p>
",0
56459483,56459421,-1,"<pre><code>f = 1;
...
if(a[0] != a[i])
{
  f = 0;
  break;
}
...
if(f == 1)
    printf(""All elements are same"");
</code></pre>
",7
56459476,56459421,3,"<p>Just invert the logic, really. And you can start iterating from 1, since you're comparing to <code>a[0]</code>:</p>

<pre><code>f = 1;
for (i = 1; i &lt; n; ++i)
  if (a[i] != a[0]) {
    f = 0;
    break;
  }

if (f == 1)
  printf(""All elements are the same"");
</code></pre>
",1
53915356,53914527,0,"<p>The return value of function is returned by <em>copy</em>.  In the first example, you get a copy of the integer variable from the function.  In the second you get a copy of the <em>char pointer</em>, not a copy of the string.  </p>

<p>The pointer references the string data that has automatic storage, so is no longer valid after the function returns.  The space becomes available for use by other code and many be modified - any attempt to access it has undefined behaviour.</p>

<p>The point is, it is a pointer that is returned, not a string; in C a strings (and more generally arrays) are not a first-class data types.  </p>

<p>Depending on your needs there are a number of valid ways of returning the string data; for example the following is valid:</p>

<pre><code>char* func() 
{
    static char c[] = ""Hey there!"";
    return c;
}
</code></pre>

<p>because here although the local variable goes out of scope the static data is not destroyed or de-allocated, and any reference to it remains valid.  </p>

<p>Another alternative is to embed the string in a struct which <em>is</em> a first-class data type:</p>

<pre><code>typedef struct
{
    char content[256] ;
} sString ;

sString func() 
{
    sString c = {""Hey there!""};
    return c;
}
</code></pre>

<p>Or more conventionally to <em>copy</em> the data to a caller buffer:</p>

<pre><code>char* func( char* buffer ) 
{
    char c[] = ""Hey there!"";

    strcpy( buffer, c ) ;

    return buffer ;
}
</code></pre>

<p>I have omitted code to mitigate the possibility of buffer overrun above for clarity in this last example, such code is advised.</p>
",0
53914579,53914527,3,"<p>In the first case, you return the <code>int</code> value 5 from the function.  You can then print that value.</p>

<p>In the second case however, you return a value of type <code>char *</code>.  That value points to an array that is local to the function <code>func</code>.  After that function returns the array goes out of scope, so the pointer points to invalid memory.</p>

<p>The difference between these two cases is a value that you use directly, versus a pointer value that no longer points to valid memory.  Had you returned a pointer to memory allocated by <code>malloc</code>, then the pointer would point to valid memory.</p>
",1
54967466,54967436,0,"<p>To call a function, the compiler needs to know its <em>declaration</em>, i.e. what's it called, that it's a function, and what the parameters and return type are:</p>

<pre><code>void viewSellMenu(void); // declaration of viewSelMenu

// *definition* of viewMenu also serves as declaration
void viewMenu(){

//code

viewSellMenu();  // can be called because compiler knows declaration

}

// *definition* of viewSelMenu
void viewSellMenu(){

//code

viewMenu();

}
</code></pre>
",2
54967466,54967436,0,"<p>To call a function, the compiler needs to know its <em>declaration</em>, i.e. what's it called, that it's a function, and what the parameters and return type are:</p>

<pre><code>void viewSellMenu(void); // declaration of viewSelMenu

// *definition* of viewMenu also serves as declaration
void viewMenu(){

//code

viewSellMenu();  // can be called because compiler knows declaration

}

// *definition* of viewSelMenu
void viewSellMenu(){

//code

viewMenu();

}
</code></pre>
",2
55014396,55013745,0,"<p>Make an array of ""strings"" (that is, pointers to char arrays) and sort the array with <a href=""http://man7.org/linux/man-pages/man3/qsort.3.html"" rel=""nofollow noreferrer""><code>qsort</code></a>. Then you can print it in order.</p>

<p>You can populate your aray with the pointers returned from <a href=""http://man7.org/linux/man-pages/man3/strtok.3.html"" rel=""nofollow noreferrer""><code>strtok</code></a>; there's no need to copy the words. But please note that <code>strtok</code> will destroy the string passed as an argument, so it might have been a good idea to have copied that string before unleashing <code>strtok</code> on it. That would let you define your function to take a <code>const char*</code> argument, allowing you to call it with a string literal. In general, it's better interface design to always use <code>const char*</code> as the prototype for a function taking a string(unless the purpose of the function is to modify the string.)</p>
",0
56642675,56642400,2,"<p>The expected value exceeds 32 bits, what you get is the actual result trimmed to 32 bits:</p>

<pre><code>1932053504 equals (6227020800 &amp; 0xFFFFFFFF)
</code></pre>

<p>You'll have to verify capacity of <code>int</code> and <code>long int</code> in your environment, e.g. with <code>print</code>-ing their <code>sizeof</code>.</p>
",0
55460673,55460360,0,"<p>First of all, you can't use <code>switch</code> on a <em>string</em> - the argument must be integral.  You can switch on individual characters like so:</p>

<pre><code>switch( c[0] ) // or switch ( *c )
{
  case '2': // note single quote instead of double quote
    ...
  case '3': 
    ... 
</code></pre>

<p>You cannot return an array from a function, nor can you initialize an array with a function call.  Honestly, your best option is to pass the target array as an argument:</p>

<pre><code>void findCombination( int number, char *combo, size_t combo_size )
{
  switch( number )
  {
    case 2:
      strcpy( combo, ""abc"" );
      break;

    case 3:
      strcpy( combo, ""def"" );
      break;
    ...
  }
}

int main( void )
{
  int number;
  char combo[5];

  scanf( ""%d"", &amp;number );
  getCombo( number, combo, sizeof combo );
  ...
}
</code></pre>
",0
55460607,55460360,0,"<p>The problem here is that you're creating a local array and then returning a pointer to it.  The array then goes out of scope.  When you then try to access that out of scope array, you invoke <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>This is also invalid:</p>

<pre><code>char array[] = findCombination(number);
</code></pre>

<p>Because an array must be initialized with a constant expression.</p>

<p>You also can't pass a <code>char *</code> as the condition of a <code>switch</code>, since it only looks at the numeric value.</p>

<p>Assuming you don't want to modify the array you pass back, and given that the arrays you return are actually strings, you can return string constants from the function.  String constants have a lifetime of the full runtime of the program, so they're safe to return.  You would then assign the return value to a pointer.</p>

<p>You should also change the function to accept a single <code>char</code> and check that.</p>

<pre><code>const char * findCombination(char c)
{
    switch(c)
    {
    case '2':
        return ""abc"";
    case '3':
        return ""def"";
    case '4':
        return ""ghi"";
    case '5':
        return ""jkl"";
    case '6':
        return ""mno"";
    case '7':
        return ""pqrs"";
    case '8':
        return ""tuv"";
    case '9':
        return ""wxyz"";
    default:   // you need to return something in the default case as well.
        return """";
    }
}

int main()
{
    char number;
    scanf("" %c"",&amp;number);
    const char *array = findCombination(number);
    printf(""returned %s\n"", array);
    return 0;
}
</code></pre>
",0
54464600,54464304,1,"<p>You're reading from <code>id</code> which is uninitialized.</p>

<p>The <code>|=</code> operator performs a bitwise OR of the left and right operands and stores the result in the left operand.  That means this:</p>

<pre><code>x |= y;
</code></pre>

<p>Is the same as:</p>

<pre><code>x = x | y;
</code></pre>

<p>In your code, you have <code>id</code> as the left side of the <code>|=</code> operator, but you never initialized <code>id</code>.  That means you're reading an uninitialized value.  This invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>You need to either initialize <code>id</code> with some known value or simply use <code>=</code> instead of <code>|=</code>.</p>
",0
54168883,54168808,7,"<blockquote>
  <p>Why can't I just use 51 &lt;= j &lt;= 55</p>
</blockquote>

<p>Because that's a ""special case"" in parsing that is obvious to your mind because you are used to it, but is not obvious at all in C expressions syntax.</p>

<p>If you apply the parsing and precedence rules of C you will get an expression that it's likely not what you want:</p>

<pre><code>51 &lt;= j &lt;= 55
</code></pre>

<p>is parsed as</p>

<pre><code>(51 &lt;= j) &lt;= 55
</code></pre>

<p><code>51 &lt;= j</code> is a boolean expression that evaluates to either 1 (if 51 is indeed less or equal than <code>j</code>) or 0 otherwise. Both 0 and 1 are less than 55, so the expression result is always 1 (true).</p>

<p>To make it do what you want, you have to explicitly transform this to</p>

<pre><code>(51 &lt;= j) &amp;&amp; (j &lt;= 55)
</code></pre>

<hr>

<p>Other languages such as Python are instead able to make a more ""human"" sense of such an expression, introducing the concept of <a href=""https://docs.python.org/3/reference/expressions.html#comparisons"" rel=""nofollow noreferrer"">chained comparisons</a>, that specifies how to convert a sequence of multiple chained comparisons to a sequence of single comparisons ANDed together, but it's a trick that's outside how ""classical"" expression evaluators work (and that <a href=""https://stackoverflow.com/q/49893766/214671"">can</a> <a href=""https://stackoverflow.com/q/6074018/214671"">lead</a> <a href=""https://stackoverflow.com/q/48944267/214671"">to</a> <a href=""https://stackoverflow.com/q/9284350/214671"">surprises</a>).</p>

<hr>

<p>Incidentally, it looks like you are trying to use floating point numbers to store/manipulate the 16 digits of a credit card number. That's a terrible idea, as <code>double</code> has 53 bits of mantissa, which are slightly less than 16 digits of decimal precision. This means that, for credit card numbers ""on the bigger side"", the last digit may not be stored correctly. More precisely, every credit card number beyond 9007 1992 5474 0992 with last digit odd will be mangled and rounded to an even number.</p>

<p>So, just use an array of integers and you'll avoid nasty surprises.</p>

<p>More in general, avoid <code>double</code> and floating point if you are interested in the exact values of digits, unless you know exactly what you're doing.</p>
",1
54168915,54168808,1,"<p>Use <code>(51 &lt;= j) &amp;&amp; (j &lt;= 55)</code>.</p>

<p>The <code>&lt;=</code> operator produces a boolean result (ie either 1 or 0). If you want to check that <code>j</code>  is within the bounds of a range, you need produce a boolean value for both ends, then 'and' the result.</p>

<p>When you chain comparison operators like '&lt;=', they get evaluated from left to right. For what your tried, it doesn't matter what <code>j</code> is as the result of the first <code>&lt;=</code> operator is either 1 or 0, which is always less than 55. Thus the final result is always true.</p>

<p>Some languages may have different rules for chaining comparison operators which is more in line with the way they are used mathematically, but definitely not C!</p>
",0
54249192,54249156,3,"<p><strong><em>Buffering</em></strong>.</p>

<p>Output to <code>stdout</code> (which is where <code>printf</code> writes) is by default <em>line buffered</em>. That means the text written to <code>stdout</code> is put into a buffer only, and is not <em>flushed</em> (actually written to the device) unless either the buffer is full, or a newline is written.</p>

<p>Information about this should be in any good book, tutorial or class.</p>
",0
54279445,54279133,0,"<p>Here's a bit more compact version. You don't need <code>j</code>.</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int *buff = malloc(sizeof(int) * 512);

    for (int i = 0; i &lt; 512; i++)
    {
        buff[i] = i;
        if (i % 64 == 63)
        {
            printf(""completed %d part out of total %d parts ints\n"", (i / 64) + 1, 512 / 64);
        }
    }

    printf(""filling completed\n"");

    return EXIT_SUCCESS;
}
</code></pre>
",0
54827410,54827361,0,"<p>The pointer you are getting is a pointer to <code>var</code> local variable. And that variable is stored in the <strong>STACK</strong> (not in heap). </p>

<p>So, a couple of things:</p>

<ol>
<li>Relying on pointers to <strong>STACK</strong> variables after the function call ended is just <strong>WRONG</strong>. Don't do that. Never.</li>
<li>The second <code>printf</code> is printing something in the stack that was overwritten when you called <code>anotherFunction</code>. This worked in this case, but this behavior is UNDEFINED (it could also lead to a SEGMENTATION FAULT).</li>
</ol>
",0
54827437,54827361,1,"<p>This function is totally pointless and wrong:</p>

<pre><code>int *getPointer(int var) {
  int *ptr = &amp;var;
  return ptr;
}
</code></pre>

<p><code>ptr</code> points to the local variable <code>var</code> (yes function parameters are more or less the same as local variables). But as soon as the function returns, that variable doesn't exist anymore. So the pointer returned by <code>getPointer</code> points basically to junk.</p>
",0
54367653,54367606,4,"<blockquote>
  <p>Why do Control don't enter repeat() function?</p>
</blockquote>

<p>Because <code>main()</code> does not call it.</p>

<p>The <code>repeat()</code> function is defined inside <code>main()</code>. Which is non standard. Moving it out makes things clearer:</p>

<pre><code>#include &lt;stdio.h&gt;

int num ;

int repeat()
{  
    scanf(""%d"", &amp;num);
    if(num != 42)
    {
        printf(""\n%d"", num);

        repeat();
    }
    else
    {
        return num ;
    }

    getch();
}

int main() {
    return 0;
}
</code></pre>

<p>From the above it is obvious that <code>main()</code> in fact does nothing.</p>
",0
58576522,58576514,1,"<p>C is a pass-by-value language. There is no way to pass something by reference except explicitly. For your case that means expecting a pointer-to-a-pointer:</p>

<pre><code>void set(char **str)
{
  *str = malloc(10);
  strcpy(*str, ""dog"");
  printf(""str = %s\n"", *str);

}
</code></pre>

<p>And calling with the address of the pointer you want to 'fill in':</p>

<pre><code>int main(void)
{
  char *s;
  set(&amp;s);

  printf(""%s\n"", s);
  return 0;
}
</code></pre>
",0
58576533,58576514,1,"<blockquote>
  <p>Why isn't this function(char*) pass by ref?</p>
</blockquote>

<p>C doesn¡¯t have pass-by-reference. Everything is pass-by-value ¨C it¡¯s just that some values are also pointers to other values. Your uninitialized variable <code>s</code> is read when you call <code>set(s)</code> (which is undefined behaviour) in order to provide a value for its parameter <code>str</code>, then <code>str = malloc(10)</code> throws that value away to assign a new value to the local <code>str</code>.</p>

<p>You can pass a pointer to the pointer:</p>

<pre><code>void set(char** str){
  *str = malloc(10);
  strcpy(*str, ""dog"");
  printf(""\nstr = %s"", *str);

}
int main(){
  char* s;
  set(&amp;s);

  printf(""\n%s"", s);
  return 0;
}
</code></pre>

<p>or return a pointer:</p>

<pre><code>char* set(void) {
  char* str = malloc(10);
  strcpy(str, ""dog"");
  printf(""\nstr = %s"", str);
  return str;
}
int main(){
  char* s = set();

  printf(""\n%s"", s);
  return 0;
}
</code></pre>
",2
58576573,58576514,1,"<p>You are passing an unasigned pointer to your set function, here a copy of the pointer is made and you use malloc on that copy. The original pointer in main is never updated with the new memory address.
To achieve what you want could be done this way:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

void set(char** str){
  *str = malloc(10);
  strcpy(*str, ""dog"");
  printf(""\nstr = %s"", *str);

}
int main(){
  char* s;
  set(&amp;s);

  printf(""\n%s"", s);
  return 0;
}
</code></pre>

<p>I used a pointer to a pointer in set, and pass the memory address of the pointer <em>s</em> to it.</p>
",0
54387837,54387039,0,"<p>This task is easy if you use the functions that comes with the C library:</p>

<pre><code>void ReplaceString(char *pTarget, const char *pPattern)
{
    char *p;
    size_t PatternLength = strlen(pPattern);

    // for all occurances of the pattern..      
    while (p = strstr(pTarget, pPattern))
    {
        // The function strstr found an occurance of the pattern.
        // So it must be sufficient space in the target starting at the pointer p..

        // replace the characters in the target
        memset(p, '*', PatternLength);
    }
}
</code></pre>

<p>If you should avoid functions for some academic purposes, you can implement your own versions of <code>strlen</code>, <code>strstr</code>, and <code>memset</code>. Your example shows a function <code>string_in</code> that looks like such version of `strstr.</p>
",0
59025327,59025283,4,"<p>You have a couple of problems.</p>

<p>First, this code:</p>

<pre><code>uint32_t number = 1268;
void* ptrAddress = &amp;number;
</code></pre>

<p>Doesn't make a pointer to memory address <code>1268</code>, like you seem to indicate you want it to. It makes a pointer to the integer where that <code>1268</code> is stored. You then overrun that storage by a lot, causing undefined behaviour, so after that it's game over.</p>

<p>If you want a pointer to a specific memory address:</p>

<pre><code>void *ptrAddress = (void *)0x1268;
</code></pre>

<p>Make sure that address is legit in your environment/address space, though!</p>

<p>Second, <code>strcpy</code> works on null-terminated strings. You should probably use <code>memcpy</code> if you plan to work with a 4096 byte (non-null terminated) buffer. Note that means you can't print using printf (at least the way you're trying).</p>

<pre><code>printf(""%-4096s"");
</code></pre>

<p>Should do it though.</p>
",2
53987999,53984638,2,"<p>Generally, the processor does not know that an object is declared <code>const</code> in C.</p>

<p>Systems commonly have regions of memory that are marked read-only after a program is loaded, and static <code>const</code> objects are stored in such memory. For these objects, the processor enforces the read-only property.</p>

<p>Systems generally do not have read-only memory used for stack. This would be inherently difficult¡ªthe memory would need to be read-write when a function is starting, so that its stack frame can be constructed, but read-only at other times. So the program would be frequently changing the hardware memory protection settings. This would impair performance and is generally not considered worth while.</p>

<p>So programs generally have only a read-write stack available. When you declare an automatic (rather than static) <code>const</code> object, where can the compiler put it? As you note, it is often optimized into an immediate operand in instructions. However, when you take its address, it must have an address, so it must be in memory.</p>

<p>One idea might be that, since it is <code>const</code>, it will not chamge, so we only need one copy, so it can be stored in the static read-only section instead of on the stack. However, the C standard says that each different object has a different address. To comply with that requirement, the compiler has to create a different instance of the object in memory each time it is created in the C code. Putting it on the stack is an easy way to do this.</p>
",0
54453477,54453389,1,"<p><code>free(): invalid next size</code> is the error message you frequently get when you have corrupted the memory arena used by <code>malloc</code>, such as writing beyond the end of an allocated block, destroying in-line accounting information used by the memory allocation functions.</p>

<p>Given the scarcity of actual <em>code</em> in your question (or, after your update, the huge <em>volume</em> of code which you appear not to have slimmed down to more accurately pinpoint the problem), that's about as much detail as I can provide. My suggestion is to examine your code for areas where you don't properly use allocated memory.</p>
",3
53959030,53955650,1,"<h1>Question 1</h1>

<p><code>char arr[][4] = {""abc"",""def""};</code> defines <code>arr</code> to be an array of arrays. With other objects, such as a structure, one structure, say <code>C</code>, could be assigned to another structure, say <code>B</code>, of the same type, using <code>B = C;</code>. However, C has special rules for arrays.</p>

<p>When an array is used in an expression, it is automatically converted to a pointer to its first element, except when it is the operand of <code>sizeof</code> or unary <code>&amp;</code> or is a string literal used to initialize an array. So, when we write:</p>

<pre><code>x = arr;
</code></pre>

<p>the automatic conversion makes it as if we had written:</p>

<pre><code>x = &amp;arr[0];
</code></pre>

<p>Then, since <code>&amp;arr[0]</code> is a pointer to an array of 4 <code>char</code>, <code>x</code> must also be a pointer to an array of 4 <code>char</code> (or something compatible, perhaps a pointer to an array of an unknown number of <code>char</code>).</p>

<p>Note that <code>char **x;</code> declares a pointer to a pointer. That is, it is a pointer, and, at the memory it points to, there must be another pointer. In contrast, <code>&amp;arr[0]</code> is a pointer to an array. It is a pointer, and, at the memory it points to, there is an array of 4 <code>char</code>. If you tried to use <code>**x</code>, the compiler would look at the memory that <code>x</code> points to and expect to find a pointer there. If, instead, there is not a pointer but rather four arbitrary <code>char</code> values, the program would be broken. So <code>char **x</code> is not compatible with a pointer to an array of 4 <code>char</code>.</p>

<p>A proper declaration for <code>x</code> would be <code>char (*x)[4];</code>. After such a declaration, the assignment <code>x = arr;</code> would be proper.</p>

<h1>Question 2</h1>

<p>Your code <code>t-&gt;text = { ""IF WE COULD TAKE THE TIME"", ""TO LAY IT ON THE LINE"", ""I COULD REST MY HEAD"" };</code> is not strictly conforming C and does not compile in typical compilers.</p>

<h1>Question 3</h1>

<p>Consider the code (adjusted to allow compilation):</p>

<pre><code>struct document
{
    char **text;
    int numOfLines;
} t;

char *arr[3] = {
    ""IF WE COULD TAKE THE TIME"",
    ""TO LAY IT ON THE LINE"",
    ""I COULD REST MY HEAD"" };
t.text = arr;
</code></pre>

<p><code>char *arr[3]</code> declares <code>arr</code> to be an array of 3 pointers to <code>char</code>. It is then initialized to contain three pointers to (the first characters of) strings.</p>

<p>So each element of <code>arr</code>, <code>arr[i]</code> is a pointer to <code>char</code>. By C¡¯s rule about automatic conversion of arrays, in <code>t.text = arr;</code>, <code>arr</code> is converted to a pointer to its first element. So we have <code>t.text = &amp;arr[0];</code>. Then <code>&amp;arr[0]</code> is a pointer to a pointer to a <code>char</code>, and <code>t.text</code> is a pointer to a pointer to a <code>char</code>, so the types are compatible.</p>
",0
54827817,54827322,1,"<p><code>scanf</code> is a poor choice for interactive user input. Especially because if the user types something that <code>scanf</code> does not expect, that input stays in the internal input buffer and will most likely cause trouble in the following <code>scanf</code>s further in the program.</p>

<p>I'd go for something like this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char * argv[])
{
  float n;
  char input[100];
  for (;;) {
      fgets(input, sizeof(input), stdin);
    if (sscanf(input, ""%f"", &amp;n) != 1)
      break;

    printf(""User input = %f\n"", n);
  }

  printf(""Last line entered by user: %s"", input);  
}
</code></pre>
",0
54503454,54503382,4,"<p>The <code>%[</code> format specifier to <code>scanf</code> will match a sequence of characters matching those that are listed between <code>[</code> and <code>]</code>.  If the first character is <code>^</code>, then it matches characters <em>excluding</em> those characters.</p>

<p>In your case <code>%[^s]</code> means ""match any character besides the characters <code>'s'</code>.  <code>s</code> is <strong>not</strong> a variable in this case.</p>
",4
54505076,54504935,1,"<p>You're starting from 0 instead of 1 and adding instead of subtracting in the denominator of your term, you're calculating the new value of <code>increment</code> using integer operations instead of floating point, and your <code>while</code> loop never gets entered because <code>increments</code> starts at 0.</p>

<p>The correct formula is:   pi / 4 = sum(k->inf) ((-1)^(k+1))/(2k-1)</p>

<p>So you would do this as:</p>

<pre><code>double get_Pi(double accuracy)
{
    double Pi_estimate = 0;
    double increment;
    double i = 1;    // start at 1
    int s = 1;       // start with positive factor

    do {    // do the check at the bottom instead of the top
        increment = s*(1.0/(2.0*i-1));    // use floating point constants to prevent integer division
        Pi_estimate = Pi_estimate + increment;
        s = -s;
        i++;
    } while(fabs(increment) &gt; accuracy);

    // no need to add an offset
    return 4*Pi_estimate;
}
</code></pre>
",0
54505076,54504935,1,"<p>You're starting from 0 instead of 1 and adding instead of subtracting in the denominator of your term, you're calculating the new value of <code>increment</code> using integer operations instead of floating point, and your <code>while</code> loop never gets entered because <code>increments</code> starts at 0.</p>

<p>The correct formula is:   pi / 4 = sum(k->inf) ((-1)^(k+1))/(2k-1)</p>

<p>So you would do this as:</p>

<pre><code>double get_Pi(double accuracy)
{
    double Pi_estimate = 0;
    double increment;
    double i = 1;    // start at 1
    int s = 1;       // start with positive factor

    do {    // do the check at the bottom instead of the top
        increment = s*(1.0/(2.0*i-1));    // use floating point constants to prevent integer division
        Pi_estimate = Pi_estimate + increment;
        s = -s;
        i++;
    } while(fabs(increment) &gt; accuracy);

    // no need to add an offset
    return 4*Pi_estimate;
}
</code></pre>
",0
54506252,54506205,4,"<p>Because <code>sizeof()</code> returns the memory size of <code>a</code> which is 1000.</p>

<p><code>a</code> is created on the stack and its contents is undefined. After the <code>scanf()</code> only the first part of this stack garbage is overwritten.</p>

<p>You need to do <code>write(fd, a, strlen(a))</code>, or with <code>strlen(a) + 1</code> if you want to also write the C string delimiter <code>\0</code>, which is added to the end of <code>a</code>.</p>

<p>Please check the return values op <code>open()</code>, <code>scanf()</code>, and <code>write()</code>, to make sure all steps are executed without error. See the manual pages for their return values.</p>
",0
54506252,54506205,4,"<p>Because <code>sizeof()</code> returns the memory size of <code>a</code> which is 1000.</p>

<p><code>a</code> is created on the stack and its contents is undefined. After the <code>scanf()</code> only the first part of this stack garbage is overwritten.</p>

<p>You need to do <code>write(fd, a, strlen(a))</code>, or with <code>strlen(a) + 1</code> if you want to also write the C string delimiter <code>\0</code>, which is added to the end of <code>a</code>.</p>

<p>Please check the return values op <code>open()</code>, <code>scanf()</code>, and <code>write()</code>, to make sure all steps are executed without error. See the manual pages for their return values.</p>
",0
54612559,54612471,1,"<p>This statement is always true.</p>

<pre><code>while (c != '\n' || c != EOF)
</code></pre>

<p>Hence an infinite loop.</p>
",0
54612553,54612471,2,"<p><code>c != '\n' || c != EOF</code> is always true. </p>

<p>It could only be false if both conditions were false, which would mean that both <code>c == '\n'</code> and <code>c == EOF</code> were true. Obviously, those two cannot both be true (unless <code>EOF</code> were the same as <code>'\n'</code>, which it isn't).</p>

<p>You need to use <code>&amp;&amp;</code>, not <code>||</code>.</p>
",5
56684225,56683323,7,"<p>I have never encountered this in ""real code"" (i.e., outside of intentionally obfuscated things and puzzles with artificial limitations) so it would seem that it is quite universally agreed that this shouldn't be done.</p>

<p>However, I can come up with a contrived example where it might be considered by some (not necessarily me) a nicer syntax: if you have multiple pieces of data related to a single entity in a column, and you represent the rows as different arrays:</p>

<pre><code>enum { ADA, BRIAN, CLAIRE };
const char *name[] = { ""Ada"", ""Brian"", ""Claire"" };
const unsigned age[] = { 30, 77, 41 };

printf(""%s is %u years old\n"", ADA[name], ADA[age]);
</code></pre>

<p>I will be the first to agree that this obfuscates the syntax by making it look like the people are the arrays instead of being the indexes, and I would prefer an array of <code>struct</code> in most cases. I think a case could be made for this being nicer-looking, though, or perhaps in some cases it would be a way to swap the rows and columns (arrays and indexes) with minimal edits elsewhere.</p>
",3
56683392,56683323,2,"<p>Yes, the pointer arithmetic is commutative because addition is commutative.  References like <code>a[n]</code> are converted to <code>*(a+n)</code> but also <code>n[a]</code> is converted to <code>*(n+a)</code>, which is identical. If you want to win ioccc competitions you must use this.</p>
",1
54660064,54659756,1,"<pre><code>#include &lt;inttypes.h&gt;

uint16_t foo = -75;
printf(""==&gt; %"" PRId16 "" &lt;==\n"", foo); // type mismatch, undefined behavior
</code></pre>
",1
54660344,54659756,1,"<p>If a 16-bit negative integer was stored in a <code>uint16_t</code> called <code>x</code>, then the original value may be calculated as <code>x-65536</code>.</p>
<p>This can be printed with any of<sup>1</sup>:</p>
<pre><code>printf(&quot;%ld&quot;, x-65536L);

printf(&quot;%d&quot;, (int) (x-65536));

int y = x-65536;
printf(&quot;%d&quot;, y);
</code></pre>
<p>Subtracting 65536 works because:</p>
<ul>
<li>Per C 2018 6.5.16.1 2, the value of the right operand (a negative 16-bit integer is converted to the type of the assignment expression (which is essentially the type of the left operand).</li>
<li>Per 6.3.1.3 2, the conversion to an unsigned integer operates by adding or subtracting ¡°one more than the maximum value that can be represented in the new type¡±. For <code>uint16_t</code>, one more than its maximum is 65536.</li>
<li>With a 16-bit negative integer, adding 65536 once brings it into the range of a <code>uint16_t</code>.</li>
<li>Therefore, subtracting 65536 restores the original value.</li>
</ul>
<h2>Footnote</h2>
<p><sup>1</sup> <code>65536</code> will be <code>long</code> or <code>int</code> according to whether <code>int</code> is 16 bits or more, so these statements are careful to handle the type correctly. The first uses <code>65536L</code> to ensure the type is <code>long</code>. The rest convert the value to <code>int</code>. This is safe because, although the type of <code>x-65536</code> could be <code>long</code>, its value fits in an <code>int</code>¡ªunless you are executing in a C implementation that limits <code>int</code> to ?32767 to +32767, and the original value may be ?32768, in which case you should stick to the first option.</p>
",2
54679097,54659756,0,"<p>If <code>u</code> is an object of unsigned integer type and a negative number whose magnitude is within range of <code>u</code>'s type is stored into it, storing <code>-u</code> to an object of <code>u</code>'s type will leave it holding the magnitude of that negative number.  This behavior does not depend upon how <code>u</code> is represented.  For example, if <code>u</code> and <code>v</code> are 16-bit <code>unsigned short</code>, but <code>int</code> is 32 bits, then storing -60000 into <code>u</code> will leave it holding <code>5536</code> [the implementation will behave as though it adds 65536 to the value stored until it's within range of <code>unsigned short</code>].  Evaluating <code>-u</code> will yield -5536, and storing -5536 into <code>v</code> will leave it holding 60000.</p>
",0
54659815,54659756,1,"<p>If an <code>int</code> is 32 bits on your system, then the correct format for printing a 16-bit int is <code>%hu</code> for unsigned and <code>%hd</code> for signed.</p>

<p>Examine the output of:</p>

<pre><code>uint16_t n = (uint16_t)-75;

printf(""%d\n"", (int)n); // Output: 65461
printf(""%hu\n"", n); // Output: 65461
printf(""%hd\n"", n); // Output: -75
</code></pre>
",26
54603230,54602702,1,"<p>You need to be very much more careful with the sizes you use.  This code works, fixing a variety of issues with the size of the arrays.  Note that there is a limit to how big an array you can create on the stack.  On Unix systems, 1 MiB has ample margin for error (the limit is normally 8 MiB); on Windows, the limit is normally 1 MiB so the limit imposed here is probably a little to large ¡ª maybe <code>(1000 * 1000)</code> would be safe; maybe a smaller value would be better, such as <code>(1024 * 1024 * 15 / 16)</code>.</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;

#define MAX_FILE_SIZE (1024 * 1024)

static int compare(const void  *r1, const void *r2)
{
    return(strcmp(r1, r2));
}

int main(int argc, char *argv[])
{
    assert(argc == 3);
    FILE *file = fopen(argv[1], ""r"");
    struct stat fs;
    stat(argv[1], &amp;fs);
    int file_size = fs.st_size;
    if (file_size &gt; MAX_FILE_SIZE)
    {
        fprintf(stderr, ""file %s is too big to be sorted by this program\n"", argv[1]);
        exit(EXIT_FAILURE);
    }
    int number_of_records = file_size / 100;
    char AllRecords[number_of_records][100];
    fread(AllRecords, 100, file_size, file);
    fclose(file);
    qsort(AllRecords, number_of_records, 100, compare);
    FILE *file2 = fopen(argv[2], ""w"");
    fwrite(AllRecords, 100, number_of_records, file2);
    fclose(file2);
    return(0);
}
</code></pre>

<p>One of the problems is then generating sample data.  I used a random data generator to generate 99 character 'lines' terminated by null bytes (so that the string comparison would have null terminated strings.</p>

<p>Input:</p>

<pre><code>LLWNMGWMIQECKYLWFFIHWSZVYBQLLYTDAXNQNCQRBJZMZNFMMNCBAFYIIXUKXEBGSQHIYVCDVWCUHLXLOCOETLRPZRSGWDERQAZ
YNWEULRIMNODDAKABCKVAXTWLMPFOFIGRIJLKPVTWCFJGXAZEWKZFWCIZVQZYPADMBQOOHITVPEVWOIUSZISJOQTHQHCXEADIHW
YSHUYAQTPVTBKKHXQQXZMJIQVJRFJSNZSXKMHNJRAPNYWVSJRIHVHUBJJJAMRVBJZWWEACTUXLDXEFIDALHJBOKXJBAQJFABKLR
UWXIJELISTPAFXSKEGQHHJYPKWGLBXJSQWFHCAPRJTLQHRZEEEJAELOMKDAQIDIBZKZMCYNCMVLTXDUKLYGEIBVXTXNKPOUGMQE
NFUVXYBDQYMIEVWEQUYPTEASNSOQHZRLLLKXSBSQJFJBNRLSPUELCYTWDLLMTQKKHWFVFCQXNEBBMAPASRZSIOELSZGGFDDWJSK
OXQGGDODECBRVSXUAMZSLIHUJRAUFGMMORRBBGHECQLRWSVZGZWTSSBJVPTTRUIDJVGKTFGJFMSOHHTBIAEFIMUSYXMJAIRIZTU
XRRQOOBLDYLQQMKVFSOIZNTXAARKUZRBFCAEJDGCZGXHUTWHHOHERWPKOLDBCEHCUXPHVJMEUEJVTUDCQFXWAEWMPZPROKSOKAE
LURFJLTYKIIWTMWJLXZGOGCPMMRWZEOCSODVRSQDFTMJJILCIZNQWITWFJSCSAZTTJBYEGAWXBAYGQVQOMQTKTEHGUTOOMOCFAZ
NGBPRHOEICRLXPVTMHULNYJNNRJYVZDDGHDFHJFKELHUGGYWHSMBPCRTAAVHOKAITDPTPGWOOMSHHGLRNVQBMTHCFCPQGDRTCAV
ZJRHMYEPSWTRPGNFZMGPHOSFAFADGTDMISIWGSOCLSYGBURDJEKYYYLZXHHXIYYUVTYNXYBKJLSPNVXIKDZNSIZDITIOWGODJNL
</code></pre>

<p>Converted using <code>tr '\0' '\n'</code> (or vice versa to convert newlines to null bytes).</p>

<p>Output:</p>

<pre><code>LLWNMGWMIQECKYLWFFIHWSZVYBQLLYTDAXNQNCQRBJZMZNFMMNCBAFYIIXUKXEBGSQHIYVCDVWCUHLXLOCOETLRPZRSGWDERQAZ
LURFJLTYKIIWTMWJLXZGOGCPMMRWZEOCSODVRSQDFTMJJILCIZNQWITWFJSCSAZTTJBYEGAWXBAYGQVQOMQTKTEHGUTOOMOCFAZ
NFUVXYBDQYMIEVWEQUYPTEASNSOQHZRLLLKXSBSQJFJBNRLSPUELCYTWDLLMTQKKHWFVFCQXNEBBMAPASRZSIOELSZGGFDDWJSK
NGBPRHOEICRLXPVTMHULNYJNNRJYVZDDGHDFHJFKELHUGGYWHSMBPCRTAAVHOKAITDPTPGWOOMSHHGLRNVQBMTHCFCPQGDRTCAV
OXQGGDODECBRVSXUAMZSLIHUJRAUFGMMORRBBGHECQLRWSVZGZWTSSBJVPTTRUIDJVGKTFGJFMSOHHTBIAEFIMUSYXMJAIRIZTU
UWXIJELISTPAFXSKEGQHHJYPKWGLBXJSQWFHCAPRJTLQHRZEEEJAELOMKDAQIDIBZKZMCYNCMVLTXDUKLYGEIBVXTXNKPOUGMQE
XRRQOOBLDYLQQMKVFSOIZNTXAARKUZRBFCAEJDGCZGXHUTWHHOHERWPKOLDBCEHCUXPHVJMEUEJVTUDCQFXWAEWMPZPROKSOKAE
YNWEULRIMNODDAKABCKVAXTWLMPFOFIGRIJLKPVTWCFJGXAZEWKZFWCIZVQZYPADMBQOOHITVPEVWOIUSZISJOQTHQHCXEADIHW
YSHUYAQTPVTBKKHXQQXZMJIQVJRFJSNZSXKMHNJRAPNYWVSJRIHVHUBJJJAMRVBJZWWEACTUXLDXEFIDALHJBOKXJBAQJFABKLR
ZJRHMYEPSWTRPGNFZMGPHOSFAFADGTDMISIWGSOCLSYGBURDJEKYYYLZXHHXIYYUVTYNXYBKJLSPNVXIKDZNSIZDITIOWGODJNL
</code></pre>

<p>Of course, with this data, the string comparisons would not need to find a null byte, but if there were repeated lines in the file, then it would be crucial.</p>
",5
56825210,56825114,0,"<p><code>""abcdef\0abcdefg\0""</code>, the string literal, is effectively a <code>static</code>, <code>const</code> (for all intents an purposes) <code>char</code> array and so it has an associated size that the compiler maintains:</p>

<pre><code>#include &lt;stdio.h&gt;
#define S ""abcdef\0abcdefg\0"" 
//^string literals implicitly add a(nother) hidden \0 at the end
int main()
{
    printf(""%zu\n"", sizeof(S)); //prints 16
}
</code></pre>

<p>But arrays are treated specially in C and passing them as a parameter to a function or almost any operator converts them to a pointer to their first element.</p>

<p>Pointers do not have an associated size.</p>

<p>When you pass a <code>char const*</code> to a function (e.g., <code>printf</code>), the function receives just one number--the address of the first element.</p>

<p>The way <code>printf</code> and most string functions in C obtain the size is by counting character until the first <code>'\0'</code>.</p>

<p>If you pass a pointer to the first element of a <code>char</code> array that has explicit embedded zeros in it, then for a function that counts until the first <code>'\0'</code>, the string effectively ends at the first <code>'\0'</code>.</p>
",2
56105376,56105361,6,"<p><a href=""https://linux.die.net/man/3/getyx"" rel=""noreferrer""><code>getyx</code> is not a function, but a macro.</a></p>

<p><sup>(Ignore the very confusing <code>void</code> return type on that manpage; the prose underneath tells us the truth!)</sup></p>

<blockquote>
  <h3>Notes</h3>
  
  <p>All of these interfaces are macros. A ""<code>&amp;</code>"" is not necessary before the variables <code>y</code> and <code>x</code>.</p>
</blockquote>

<p>It does not introduce or use a new scope, so has direct ""access"" to <code>x</code> and <code>y</code> as they are.</p>

<p>As an analogy, consider how the following works without a <code>&amp;</code>:</p>

<pre><code>#define doubleIt(x) x *= 2

int main()
{
   int x = 1;
   doubleIt(x);
}
</code></pre>
",1
54642349,54642334,3,"<p>CGI programs do not run in your browser. They run on the web server. They have to be compiled with compiler that targets the environment on the web server, and the server has to be configured to be willing to run them rather than serving them as data files.</p>
",3
57241200,57240832,0,"<p>There were several issues with the program function. I presume you do not want the newlines appearing in the strings, so they must be removed.<br>
When using <code>fgets</code> the buffer size must be less or equal to the string size, otherwise you risk issues.<br>
More in the commented program code below.</p>

<pre><code>void init()
{
  char tournamentOrNot;
  char letter;
  char name[100]; // &lt;-- make name 100 char long
  char golfClub[40];
  char tournament[60];

  printf(""What is your name? "");
  fgets(name, 100, stdin); //Input works &lt;-- buffer same as name
  // begin remove newline
  int index = 0;
  while (name[index] != '\n')
    index++;
  name[index] = '\0';
  // end remove new line
  // getchar(); &lt;-- Not needed I think
  printf(""%s\n"", name);

  printf(""Where are you playing golf at? NO SPACES\n"");
  fgets(name, 100, stdin); //Input works &lt;-- buffer same as name
  // begin remove newline
  index = 0;
  while (name[index] != '\n')
    index++;
  name[index] = '\0';
  // end remove newline
  // getchar(); &lt;-- Not needed I think

  printf(""Are you competing in a tournament? (Y/N) "");
  tournamentOrNot = getchar();

  if (tournamentOrNot == 'Y' || tournamentOrNot == 'y')
  {
    printf(""Enter the name for the tournament NO SPACES: "");
    scanf(""%s"", tournament); // &lt;-- tournament instead of &amp;tournament
    printf(""Initializing score board..."");
    printf(""\n"");
    //drawScoreBoard(name, golfClub, tournament); &lt;-- does this function know the sizes of the strings ?
    printf(""socre board is drawn here\n"");
  }
  else if (tournamentOrNot == 'N' || tournamentOrNot == 'n')
  {
    //tournament[7] = ""Practice""; &lt;-- that is wrong in C
    strcpy(tournament, ""Practice""); // &lt;-- string copied with strcpy
    printf(""Initializing score board..."");
    printf(""\n"");
    // drawScoreBoard(name, golfClub, tournament); &lt;-- does this function know the sized of the strings ?
    printf(""socre board is drawn here\n"");
  }
}
</code></pre>
",3
54681886,54681860,3,"<p>For a start,</p>

<pre><code>students[i].firstName = (char *)malloc(sizeof(char*));
</code></pre>

<p>allocates enough space for a character <em>pointer,</em> typically four or eight bytes.</p>

<p>While there are some names that <em>will</em> fit in that (such as <code>Pax</code> or <code>Bob</code>), the vast majority probably won't.</p>

<p>You need to allocate enough space for the largest name (and string terminator), such as with:</p>

<pre><code>#define MAX_NAME_LEN 100
students[i].firstName = malloc(MAX_NAME_LEN + 1);
</code></pre>
",0
54681917,54681860,5,"<p><code>malloc</code> returns a block of uninitialized memory.  So <code>students[i].firstName</code> is an uninitialized pointer which you attempt to dereference.  Reading and dereferencing an uninitialized pointer invokes undefined behavior, which in this case manifests as a crash.</p>

<p>When you <em>do</em> allocate space for the <code>firstName</code> member, you only allocate <code>sizeof(char*)</code> bytes for it which is the size of a pointer, not necessarily the length of a string you would want to read.</p>

<p>Create a buffer to read strings into that's big enough for what you might need, then use <code>strdup</code> to create a copy to assign to the relevant pointer.</p>

<pre><code>student *students = NULL;
int i = 0;
char str[100];

scanf(""%99s"", str);
while (str[0] != '.'){
    students = realloc(students, sizeof(*students) * (i+1));
    students[i].firstName = strdup(str);
    i++;

    scanf(""%99s"", str);
}
</code></pre>
",1
57329785,57327639,1,"<p>In C, <code>{0}</code> is the ""universal zero initializer"" that can be used to initialize any object in the same way it would be initialized if it had static storage duration and did not have an explicit initializer. There are a few places in the standard library (<code>mbstate_t</code>) and third-party libraries where a zero-initialized object is required but the object is semantically opaque, such that it would be non-portable or anti-idiomatic to explicitly initialize members by name or even to assume that it has members (e.g. it might just be defined as a bare integer or pointer type). <code>{0}</code> works for all of these.</p>

<p>One special case of this is use to create dummy compount literals, i.e. <code>(type){0}</code>. These are useful to pass to functions that don't accept null pointers when you want to throw the output away, since you can pass <code>&amp;(type){0}</code>.</p>

<p>Otherwise, I'm not aware of anywhere <code>{0}</code> is useful.</p>

<p>Defining a macro for this, and naming it <code>VAR</code>, is rather unusual, and it's not clear what the author meant by that without more context.</p>
",0
54731958,54731832,2,"<p>You are using a GCC extension called <a href=""http://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html"" rel=""nofollow noreferrer"">Nested Functions</a>.</p>

<p>In that documentation, you can discover that what you are doing is not allowed:</p>

<blockquote>
  <p>But this technique works only so long as the containing function (hack, in this example) does not exit.</p>
</blockquote>

<p>The ""containing function"" is <code>funfun</code> in your case.</p>

<blockquote>
  <p>If you try to call the nested function through its address after the containing function exits, <strong>all hell breaks loose</strong>. </p>
</blockquote>

<p>C does not really have higher-order functions (with closures etc.). This extension to C doesn't really provide those either.</p>
",0
55552411,55552322,1,"<p>The are several issues with your code, including (but not necessarily limited to):</p>

<ol>
<li><p>Your code in <code>trier()</code> will dereference a NULL pointer at the last element - since its <code>suivant</code> is NULL, and you're doing:</p>

<pre><code>ptr = ptr-&gt;suivant;
if(strcmp(prec-&gt;nom,ptr-&gt;nom) &lt; 0) { ... }
</code></pre></li>
<li><p>I think you're trying to sort in the wrong order: When <code>strcmp(prec-&gt;nom,ptr-&gt;nom)</code> is negative, that means the first patient's name is lexicographically earlier than the following patient name - in which case they <em>should not</em> be exchanged.</p></li>
</ol>

<hr>

<p>PS - for those not fluent in French, here's a little glossary for OP's program...</p>

<p>tete = head<br>
suivant = next<br>
nom = last/family name<br>
prenom = first/given name<br>
echange = change (or replace)<br>
chaine = list (or cain)</p>
",4
57041614,57032757,0,"<p><strong>It¡¯s just a matter of convention.</strong> If you wanted to, you could totally write code that handled array termination (for arrays of any type) via some sentinel value. Here¡¯s an example that does just that, arbitrarily using -1 as the sentinel:</p>

<pre><code>int length(int arr[]) {
    int i;
    for (i = 0; arr[i] != -1; i++) {}
    return i;
}
</code></pre>

<p>However, this is obviously utterly unpractical: You couldn¡¯t use -1 in the array any longer.</p>

<p>By contrast, for C strings the sentinel value <code>'\0'</code> is less problematic because it¡¯s expected that normal test won¡¯t contain this character. This assumption is <em>kind of</em> valid. But even so there are obviously many strings which <em>do</em> contain <code>'\0'</code> as a valid character, and null-termination is therefore by no means universal.</p>

<p>One very common alternative is to store strings in a struct that looks something like this:</p>

<pre><code>struct string {
    unsigned int length;
    char *buffer;
}
</code></pre>

<p>That is, we explicitly store a length alongside a buffer. This buffer isn¡¯t null-terminated (although in practice it often has an <em>additional</em> terminal <code>'\0'</code> byte for compatibility with C functions).</p>

<p>Anyway, the answer boils down to: For C strings, null termination is a convenient convention. But it is <em>only a convention</em>, enforced by the C string functions (and by the C string literal syntax). You could use a similar convention for other array types but it would be prohibitively impractical. This is why other conventions developed for arrays. Notably, <strong>most functions that deal with arrays expect both an array and a <em>length</em> parameter</strong>. This length parameter determines where the array terminates.</p>
",0
57032822,57032757,2,"<p>C doesn't provide any protections or guarantees to you about 'knowing the array is ended.' That's on you as the programmer to keep in mind in order to avoid accessing memory outside your array.</p>
",1
57032825,57032757,7,"<p>C does not perform bounds checking on arrays.  That's part of what makes it fast.  However that also means it's up to you to ensure you don't read or write past the end of an array.  So the language will allow you to do something like this:</p>

<pre><code>int arr[5];
arr[10] = 4;
</code></pre>

<p>But if you do, you invoke <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""noreferrer"">undefined behavior</a>.  So you need to keep track of how large an array is yourself and ensure you don't go past the end.</p>

<p>Note that this also applies to character arrays, which can be treated as a string if it contains a sequence of characters terminated by a null byte.  So this is a string:</p>

<pre><code>char str[10] = ""hello"";
</code></pre>

<p>And so is this:</p>

<pre><code>char str[5] = { 'h', 'i', 0, 0, 0 };
</code></pre>

<p>But this is not:</p>

<pre><code>char str[5] = ""hello"";  // no space for the null terminator.
</code></pre>
",0
54829006,54828953,3,"<p>In standard C there are no local functions. You need to move the <code>Data</code> function out of <code>main</code>.</p>

<p>You probably want this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct TestData {
  int * a;
};

void Data(struct TestData * addstruct) {
  int b;
  addstruct-&gt;a = &amp;b;
}

int main() {
  struct TestData * p1 = (struct TestData *)malloc(sizeof(struct TestData));

  Data(p1);
  printf(""%p"", (void*)p1);  // %p needs casting to (void*)
  free(p1);
  return 0;
}
</code></pre>

<p>This code compiles correctly, but there is another problem:</p>

<pre><code>void Data(struct TestData * addstruct) {
  int b;
  addstruct-&gt;a = &amp;b;
}
</code></pre>

<p>You put the pointer to the <em>local</em> variable <code>b</code> into <code>addstruct-&gt;a</code>, but as soon as the <code>Data</code> is finished, <code>b</code> no longer exists and <code>addstruct-&gt;a</code> therefore points to junk.</p>

<p>Read also following SO articles:</p>

<ul>
<li><a href=""https://stackoverflow.com/q/8743411/898348"">Return address of local variable in C</a> </li>
<li><a href=""https://stackoverflow.com/q/6441218/898348"">Can a local variable&#39;s memory be accessed outside its scope?</a></li>
</ul>
",4
54830569,54829416,0,"<p>Some things to remember about <code>scanf</code>:</p>

<ul>
<li><p>Most conversion specifiers like <code>%s</code>, <code>%d</code>, and <code>%f</code> will skip over leading whitespace - <code>%c</code> and <code>%[</code> will not.  If you want to read the next single non-whitespace character, use <code>"" %c""</code> - the leading blank tells <code>scanf</code> skip over any leading whitespace before reading the next non-whitespace character;</p></li>
<li><p>For what you are trying to do, you should not use <code>\n</code> in your format strings - it will cause <code>scanf</code> to block until you enter a non-whitespace character;  </p></li>
<li><p>You do not need to use the <code>&amp;</code> operator on array expressions like <code>area</code>; under most circumstances, array expressions are converted to pointer expressions<sup>1</sup>.  Honestly, you should read <code>area</code> the same way you read <code>name</code>, using <code>fgets</code> (and you should always check the result of <code>fgets</code>), or you should specify the maximum field width in the specifier: <code>scanf( ""%9s"", area );</code> (a 10-element array can hold up to a 9-character string, since one element has to be reserved for the string terminator);  </p></li>
<li><p>You should get in the habit of checking the result of <code>scanf</code> - it will return the number of successful conversions and assignments.  For example, <code>scanf( ""%d %d"", &amp;x, &amp;y )</code> will return 2 if both <code>x</code> and <code>y</code> are read successfully.  It will return <code>EOF</code> if end-of-file is signaled or there's a read error.  </p></li>
<li><p><code>scanf</code> will read up to the next character that doesn't match the conversion specifier - IOW, if you're using <code>%d</code>, then <code>scanf</code> will skip over any leading whitespace, then read up to the next character that isn't a decimal digit.  That character is left in the input stream.  This means if you're using <code>%d</code> and type in <code>123e456</code>, <code>scanf</code> will read up to that <code>'e'</code> character and assign <code>123</code> to the target.  If you try to read again with <code>%d</code>, <code>scanf</code> will immediately stop reading on that <code>e</code> and return 0 without assigning anything to the target (this is called a matching failure).  This will continue until you remove that <code>'e'</code> from the input stream (such as with <code>getchar</code> or <code>fgetc</code> or <code>scanf</code> with the <code>%c</code> specifier, etc.</p></li>
<li><p>You need to make sure the types of the arguments match the format specifier.  <code>%s</code> expects an argument of type <code>char *</code>, <code>%d</code> expects <code>int *</code>, <code>%f</code> expects <code>float *</code>. <code>%x</code> expects <code>unsigned int *</code>, <code>%lf</code> expects <code>double *</code>, etc.  </p></li>
</ul>

<p><hr>
<sup></p>

<ol>
<li>This is one of the ""deeply unintuitive"" aspects of C I was talking about in my comment.
</ol>

<p></sup></p>
",0
54829927,54829416,1,"<p>You use <code>fgets</code> correctly when reading <code>name</code>. I'd recommend also using <code>fgets</code> for all your other inputs, and then parsing the intended values out of them.  For example:</p>

<pre><code>char age_str[20];
fgets(age_str, 20, stdin);
age = strtol(age_str, NULL, 10);
</code></pre>

<p>This is preferable to using <code>scanf</code> directly for non-string inputs since if input fails to match a format string, it will remain in <code>stdin</code> and screw up the other <code>scanf</code> calls.</p>

<p>If you would like to use <code>scanf</code> correctly:</p>

<ul>
<li>Check its return value to see if it matches the number of format specifiers in the string. If not, some inputs were not successfully read. You may want to use a <code>do</code>/<code>while</code> loop for this.</li>
<li>Begin your format strings with a space, as in <code>"" %c""</code>, so that any whitespace remaining in <code>stdin</code> will be skipped over.</li>
<li><a href=""http://c-faq.com/stdio/scanfhang.html"" rel=""nofollow noreferrer"">Don't end your format strings with a newline</a>.</li>
</ul>
",0
56583580,56583013,1,"<p>I see no problem in the function.</p>

<hr>

<pre><code>#include&lt;stdio.h&gt;
int f_char(char a[], char l)
{
    int pos= 0;
    for(int i=0; a[i]!='\0'; i++)
    {
        if(a[i]==l){
            pos= i+1;
            break;
        }
    }
    return pos;
}

int main(){
    char *sen= ""abcd"";
    char x = 'c';
   printf(""%d"", f_char(sen, x));   

    return 0;
}
</code></pre>

<hr>

<p>output : 3</p>
",2
57899552,57899378,4,"<p>This is essentially equivalent to:</p>

<pre><code>int abc = 50, xyz = 100;
abc = abc + 1;
if (abc != 0) {
    printf(""%d %d"", abc, xyz);
} else {
    xyz = xyz + 1;
    if (xyz != 0) {
        printf(""%d %d"",abc, xyz);
    }
    else {
        printf(""Chitkara University"");
    }
}
</code></pre>

<p><code>++var</code> is a pre-increment. This means the variable is incremented, then its value is used in the <code>if</code> condition expression. But because <code>||</code> is a short-circuiting logical operator, it only executes the second expression if the first expression is false. So <code>xyz</code> only gets incremented and tested if incrementing <code>abc</code> results in <code>0</code>.</p>
",0
56530959,56530702,3,"<p>An object of automatic storage duration, such as an <code>int x</code> defined inside a function, <strong>cannot</strong> be stored in an object file, in general. This is because a function may be called recursively (directly or indirectly) any number of times, and a different instance of the object must exist for each such call, and therefore a single location in the object file (allowing that parts of the object file might be mapped to memory in one sense or another during program execution) cannot serve as memory for the object.</p>

<p>It is possible in particular circumstances for one copy of data in an object module to serve for an object of automatic storage duration, as when the compiler can determine the function is not called recursively and therefore only one instance of the object can exist at a time.</p>

<p>However, to implement an object that is initialized, the compiler does have to provide for setting the object to its initial value. The actual object used during program execution might be on the stack or in a register, but the compiler has to set its initial value. For some initial values, such as zero or small constants, the compiler may create the initial value ¡°on the fly¡± during program execution, possibly using immediate operands in instructions. (In this case, the initial value is effectively stored in the code section of the object module.) For constants that are not easily constructed on the fly, the compiler may store the value as data in the object module, typically in a read-only (constant) data section. Of course, since this data is for the compiler¡¯s internal use (it is something the compiler is saving to use for the initial value; it is not the object itself), it will not be labeled with the name of the object. The compiler will identify it with an internal name or a numeric offset from some location.</p>

<p>Also, objects of automatic storage duration may be initialized with non-constant values. These of course are not stored in the object module at all; they are computed during program execution.</p>

<p>All of the above is subject to modification by optimization and the ¡°as if¡± rule of the C standard¡ªan automatic object might not exist at all in program memory during execution if the compiler can get the same required <em>observable behaviors</em> by other means, such as folding the use of the object into other computations.</p>

<p>What this means is there is no single location where either an object of automatic storage duration or the initial value for it is always stored.</p>
",0
56530919,56530702,2,"<p>Automatic variables don't (and can't) have a location assigned in the object file, because they exist in one instance per live instance of the block scope they're declared in, not a single instance like static storage objects. If initialized, they must be initialized for each instance of the function, and the compiler is free to emit whatever code it likes to set their initial values. When the values are constant expressions, this <em>could</em> be done as a <code>memcpy</code> from a section in the program image (thus existant in the object/executable file), but it could and usually does just involve immediate operands inline with the executable code.</p>
",0
55753118,55752965,2,"<p>It seems in addition to the single character matches, you also want to match against a string. So, you are trying to read a string as input. Simple error handling is illustrated, you may want something fancier.</p>

<pre><code>if (scanf(""%4s"", dnevi) != 1) {
    strcpy(dnevi, ""?""); /* simple error handling */
}
scanf(""%*[^\n]"");       /* get the rest of the input */
</code></pre>

<p>However, as the error states, you need to provide an integer to <code>switch</code>. You can do so on the first character.</p>

<pre><code>switch(dnevi[0])
</code></pre>

<p>However, you now have to deal with the fact you have two <code>P</code> choices and two <code>S</code> choices. Handle that with special cases in those particular cases. String literals are surrounded by <code>""</code>.</p>

<pre><code>case 'P': 
    if (dnevi[1] == '\0')
        printf(""To je ponedeljek"");
    else if (strcmp(dnevi, ""Pet"") == 0)
        printf(""To je petek"");
    else
        printf(""Vnos je bil napacen!"");
    break;
...
case 'S': 
    if (dnevi[1] == '\0')
        printf(""To je sreda"");
    else if (strcmp(dnevi, ""Sob"") == 0)
        printf(""To je sobota"");
    else
        printf(""Vnos je bil napacen!"");
    break;
...
default: 
    printf(""Vnos je bil napacen!"");
</code></pre>
",2
55550109,55549995,1,"<p>With the input ¡°2.0 0.5¡±, <code>a</code> is set to 2, and <code>x</code> is set to .5. Then <code>advancedpower</code> is called with arguments 2 and .5. In turn, <code>advanceddpower</code> calls <code>power</code>, also with arguments 2 and .5.</p>

<p><code>power</code> is a recursive function. When <code>x</code> and <code>y</code> are not zero, it calls <code>power(x, y - 1)</code>. This results in calling <code>power</code> with arguments 2 and ?.5. Then it executes the same code again, which calls <code>power</code> with arguments 2 and ?1.5.  Then again with 2 and ?2.5. This continues until the stack is exhausted, and the program crashes.</p>

<p>This code has not been written to handle these values. You need to rethink the design.</p>
",1
55550308,55550027,0,"<p>Use loops:</p>

<pre><code>int x;
scanf(""%d"", &amp;x);
int i;
for (i = 0; i &lt; 5; i++) {
    x++;
}
printf(""%d\n"", x);
for (i = 0; i &lt; 5; i++) {
    x--;
}
printf(""%d"", x);
</code></pre>
",1
54043105,54043000,1,"<p>You need a conversion specifier for each argument:</p>

<pre><code>scanf( ""%d %d"", &amp;a, &amp;b );
</code></pre>

<p>You should check the result of <code>scanf</code> to make sure you successfully read two items:</p>

<pre><code>if ( scanf( ""%d %d"", &amp;a, &amp;b ) == 2 )
{
  // process a and b
}
else
{
  // at least one entry was not an integer, print error message and exit
}
</code></pre>

<p>If you want to give the user a chance to enter two numbers correctly, use a loop, and clear out any unread input before prompting again:</p>

<pre><code>while ( scanf( ""%d %d"", &amp;a, &amp;b ) != 2 )
{
  // clear out input stream up to the next newline:
  while ( getchar() != '\n' )
    ; // empty loop

  printf( ""Error on input, try again: "" );
}
</code></pre>
",0
54043037,54043000,1,"<p>to read two numbers :</p>

<pre><code>if (scanf(""%d %d"", &amp;a, &amp;b) == 2)
    printf(""a = %d, b = %d\n"", a, b);
else
    fprintf(stderr, ""failed to read two integers\n"");
</code></pre>

<p>if the number of numbers to read is variable read them one by one in a loop</p>
",0
55237010,55236021,1,"<p><code>void* ptr=malloc(10);</code> creates 10 bytes of raw, uninitialised data on the heap. That data does not at this point have a type. </p>

<p>It does <em>not</em> ""create a pointer called ptr of 10 bytes"". The variable <code>ptr</code> is of <code>sizeof(void*)</code> bytes and allocated as ""automatic storage"" (likely on the stack), regardless of where you let it point.</p>

<p>See <a href=""https://stackoverflow.com/a/52855916/584518"">A program uses different regions of memory for static objects, automatic objects, and dynamically allocated objects</a> for an explanation of where different variables are likely allocated on mainstream computers.</p>
",0
55236381,55236021,1,"<p>No, they're not completely unrelated. <code>void</code> is a type that (<a href=""http://port70.net/~nsz/c/c11/n1570.html#6.2.5p19"" rel=""nofollow noreferrer"">C11 6.2.5p19</a>)</p>

<blockquote>
  <p>comprises an empty set of values; it is an incomplete object type that cannot be completed.</p>
</blockquote>

<p>And <code>void *</code> is a pointer type that points to an object of the said type.</p>

<p>Any object pointer type can be converted to another object pointer type with an <em>explicit cast</em>, given that the pointer is suitably aligned; the only conversion between pointer types that can happen <em>without</em> a cast in C are conversions to <code>void *</code> and back again; hence the <code>void *</code> status as the generic pointer type.</p>

<p>The <code>void</code> type in itself can be used for other tasks - for example an expression can be cast to <code>void</code> to signal that the value is being deliberately ignored, or used as the return value type to signal that the function does not return a value. The only semantic overload is the use of <code>void</code> in a prototype: <code>int func(void)</code>  to signal that the function does not take any arguments.</p>
",2
59151358,59150947,3,"<p>It sounds like you don't actually want to call the function during initialization (which you can't do for static storage variables anyway, as you've discovered). It sounds like you are building a dispatch table. What you want is called a function pointer.</p>

<p>This how one uses function pointers:</p>

<pre><code>int foo(void) { ... }

int main(void) {
   int (*bar)(void) = foo;
   bar();  // Calls foo
}
</code></pre>

<p>Since the parameters vary based on the type of the event, a 2d array doesn't make much sense. I'd use the following in your case:</p>

<pre><code>S16 fsm_hdrl_idle_param_req(void)                { ... }
S16 fsm_hdrl_idle_param_rsp(ParamRsp *param_rsp) { ... }
S16 fsm_hdrl_conf_param_req(void)                { ... }
S16 fsm_hdrl_conf_param_rsp(ParamRsp *param_rsp) { ... }

typedef S16 (*FsmReqHdlr)(void);
typedef S16 (*FsmRspHdlr)(ParamRsp*);

typedef struct {
   FsmReqHdlr fsm_req_hdlr;
   FsmRspHdlr fsm_rsp_hdlr;
} FsmHdlrs;

FsmHdlrs fsm_hdlrs_by_state[MAX_STATE] = {
   { fsm_hdrl_idle_param_req, fsm_hdrl_idle_param_rsp },
   { fsm_hdrl_conf_param_req, fsm_hdrl_conf_param_rsp },
};
</code></pre>

<p>Later:</p>

<pre><code>fsm_hdlrs_by_state[state].fsm_req_hdlr();

fsm_hdlrs_by_state[state].fsm_rsp_hdlr(param_rsp);
</code></pre>
",2
54934728,54934701,2,"<p>You're using an uninitialized variable. That size parameter is not necessary if you're using C strings. Skip it and:</p>

<pre><code>fwrite(output, strlen(output), 1, file);
</code></pre>

<p><code>fwrite</code> needs to know the length of the buffer which can come in many forms, often raw, so the length parameter cannot be inferred. You must supply it, but as you're using C strings, you can use <code>strlen()</code> to compute.</p>
",1
55746365,55746182,1,"<p>I think the problem comes from </p>

<pre><code>data[i].country = malloc(strlen(str) + 2);  //allocating memory for country name
</code></pre>

<p>Which is never freed.</p>

<p>To correct this, modify the <code>Q</code> statement:</p>

<pre><code>case 'Q':
{
    int j;
    for (j = 0; j &lt; i; ++j)
    {
        free(countrydata[i].countryname);
    }
    free(line);
    free(countryname);
    free(countrydata);
    return(EXIT_SUCCESS);    
}
</code></pre>

<p>But your code has other problem:</p>

<ul>
<li>you don't test for <code>*alloc</code> functions return,</li>
<li>you use <code>feof</code> which is counter productive (testing the <code>fgets</code> return is enough) </li>
<li>you use dynamic memory where static is enough (line, countryname)</li>
</ul>
",1
54060249,54060125,0,"<p><em>fflush(stdin);</em> probably does not work after <code>printf(""\nEnter the New File Name:"");</code> so the <code>scanf(""%[^\n]"", name);</code> has a '\n' in input and does nothing and <em>name</em> is not set and is empty, after</p>

<pre><code>    fp = fopen(name, ""wb"");
    fp1 = fopen(fname, ""rb"");
</code></pre>

<p>because name is non valid the fopen doesn't work so after <em>fp</em> and <em>fp1</em> are null, which produces the assertion fail.</p>

<p>Do not use <em>fflush</em>, and after your <em>fopen</em> check all the time you don't get a null pointer.</p>

<p>Just replace </p>

<pre><code>fflush(stdin);
scanf(""%[^\n]"", name);
</code></pre>

<p>by</p>

<pre><code>scanf(""%s"", name);
</code></pre>

<p>and all will be ok</p>
",10
54071430,54069778,2,"<p><code>/lib/ld-linux.so.2</code> is the 32-bit dynamic linker; that's why you get the confusing ""no such file or directory"" when the shell tries to <code>execve()</code>.</p>

<p>Use one of these commands to assemble+link 64-bit asm:</p>

<ul>
<li><strong><code>gcc -g -static -nostdlib start.s</code></strong> (no CRT or libc, static executable).  Use this for your Hello World that uses <code>syscall</code> directly, with no <code>call</code>s to glibc functions.</li>
<li><strong><code>gcc -g -no-pie -nostartfiles start.s</code></strong> (no CRT, but <em>does</em> link libc, making a dynamic executable.  Dynamic linker tricks on Linux allow the glibc init functions to run before execution reaches your <code>_start</code> entry point, so you can still <code>call printf</code>.  Unlike if you made a static executable that linked libc.)</li>
<li><strong><code>gcc -g -no-pie main.s</code></strong>  (you write a <code>main</code> instead of a <code>_start</code>, exactly like a C compiler would produce)</li>
</ul>

<p>Add a <code>-o myprog</code> option if you want a name other than <code>a.out</code>.</p>

<p>To assemble + link 32-bit code, add <code>-m32</code> to any of these.</p>

<p><strong>Add a <code>-v</code> option to see what commands the gcc front-end uses under the hood</strong>, if you for some reason want to invoke <code>as</code> and <code>ld</code> manually.  <code>gcc</code> on your system will know the right paths for libc and the dynamic linker.  These will be different for 32 vs. 64-bit code.</p>

<p><code>-g</code> is there to create debug info, to make it easier to use GDB if you're using source view instead of asm view.  See the bottom of <a href=""https://stackoverflow.com/tags/x86/info"">the x86 tag wiki</a> for asm gdb tips.</p>

<hr>

<p>That said, this works on my system, and I think that dynamic linker path is pretty standard for modern x86-64 Linux systems.  It's equivalent to <code>gcc -no-pie -nostartfiles start.s</code></p>

<pre><code>as -o file.o file.s &amp;&amp;
ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o file -lc file.o
</code></pre>

<hr>

<p>If you were using NASM or any other method to create a <code>.o</code>, pass it to gcc instead of an asm source file.  (e.g. <code>nasm -felf64 foo.asm &amp;&amp; gcc -static -nostdlib foo.o -o foo</code>).  See also <a href=""https://stackoverflow.com/questions/36861903/assembling-32-bit-binaries-on-a-64-bit-system-gnu-toolchain"">Assembling 32-bit binaries on a 64-bit system (GNU toolchain)</a> for a lot more details.</p>

<hr>

<p><a href=""https://stackoverflow.com/questions/43367427/32-bit-absolute-addresses-no-longer-allowed-in-x86-64-linux""><code>-no-pie</code> allows 32-bit absolute addresses to work</a> in 64-bit mode, so code like <code>mov     $message, %rsi</code> (which assembles to <code>movq $sign_extended_imm32, %r64</code>, not <code>movabsq $imm64, %r64</code>) to work.  <a href=""https://stackoverflow.com/questions/40315803/difference-between-movq-and-movabsq-in-x86-64"">Difference between movq and movabsq in x86-64</a></p>

<p><code>-no-pie</code> also lets you write <code>call puts</code> instead of <code>call puts@plt</code> or a memory-indirect call like <code>gcc -fno-plt</code> would use: <code>call puts@GOTPCREL(%rip)</code>.  The linker will take care of rewriting <code>call puts</code> to <code>call puts@plt</code> when it finds <code>puts</code> in <code>-lc</code>.</p>

<hr>

<p>There's no reason you should ever write <code>mov $message, %rsi</code>: either use <code>mov $message, %esi</code> to take advantage of static addresses being in the low 32 bits of virtual address space, or use <code>lea message(%rip), %rsi</code> to make position-independent code that works efficiently even if your code is loaded outside the low 32.</p>

<p>If you were compiling C, you'd want to use <code>-fno-pie -no-pie</code> so compiler code-gen can take advantage of <code>mov $message, %esi</code> and <code>mov array(,%rax,4), %ecx</code>.</p>

<hr>

<p>This answer only attempts to answer the question about how to build the code, which the screenshots show.  For reading the compiler output to understand what it's doing, see <a href=""https://stackoverflow.com/q/38552116"">How to remove ""noise"" from GCC/clang assembly output?</a>.</p>

<p>And in this specific case of <code>%100</code>, <a href=""https://stackoverflow.com/questions/41183935/why-does-gcc-use-multiplication-by-a-strange-number-in-implementing-integer-divi"">Why does GCC use multiplication by a strange number in implementing integer division?</a></p>
",0
54757212,54757110,0,"<p>Because this is homework, I'm not going to actually post any code:</p>

<p>To reallocate your array of arrays 1 entry (one whole row or column) smaller:</p>

<ol>
<li>Go into your outer array to the index/entry to be deleted and call free() on that pointer.  This will free all data associated with that row/column/list.</li>
<li>If you are expected to keep the array contiguous (you probably are), you need to either call memmove (not memcpy), or use for loop copy the pointers in the outer loop from 1 past the delete entry to the end of the outer loop into the gap created by the deleted entry.</li>
<li>Finally, you then need to call realloc on the outer array, decreasing the needed size by 1 pointer.</li>
</ol>

<p>You will also probably need to track the state of this array by storing at least the number of entries in your outer array of pointers to pointers - to prevent you from reading past the end of the newly sized list when it comes time to print the size again or resize it or whatever.</p>

<p>In case you are trying to remove entries in the other direction (1 entry per allocation from the outer loop), the process is similar:</p>

<p>Visit each entry in the outer loop and do the following:</p>

<ol>
<li>Call memmove() or for loop copy from 1 beyond the entry to delete to the entry (beware not to read past end of array).</li>
<li>call realloc() on that entry with the new, 1 smaller size. </li>
</ol>
",5
55516129,55516100,2,"<p>This is not possible: the case labels must be compile time evaluable integral types in C.</p>

<p>If you need anything else, then use an <code>if</code> block, using <code>strcmp</code> &amp;c.</p>

<p>(Although some folk when writing non-portable code might use multicharacter constants as case labels: see <a href=""https://stackoverflow.com/questions/45550674/this-source-code-is-switching-on-a-string-in-c-how-does-it-do-that"">This source code is switching on a string in C. How does it do that?</a>)</p>
",4
57852564,57852215,3,"<p>It's self-documenting code. <code>1</code> could mean anything, while <code>1 &lt;&lt; 0</code> is most definitely a bit mask. Note that the shift is evaluated at compile-time, since it is an integer constant expression.</p>

<p>A bit more code formatting would have made it all neater:</p>

<pre><code>#define FT_LS_LONG      (1 &lt;&lt; 0)
#define FT_LS_RECURSIVE (1 &lt;&lt; 1)
#define FT_LS_HIDDEN    (1 &lt;&lt; 2)
#define FT_LS_REVERSE   (1 &lt;&lt; 3)
#define FT_LS_TIME      (1 &lt;&lt; 4)
#define FT_LS_LINE      (1 &lt;&lt; 5)
</code></pre>

<p>There's no doubt that these are bit masks used to mask different bits of data from the same byte.</p>

<p>Equivalent code could also have been written using hex literals too, it is just a matter of style:</p>

<pre><code>#define FT_LS_LONG      0x01u
#define FT_LS_RECURSIVE 0x02u
#define FT_LS_HIDDEN    0x04u
#define FT_LS_REVERSE   0x08u
#define FT_LS_TIME      0x10u
#define FT_LS_LINE      0x20u
</code></pre>
",3
57852384,57852215,-1,"<p>Without looking at the original code it's hard to tell but this seems to be defining flags in a way that is readable. The alternative would be use #defines set to 0000001, 0000010,0000100 etc. which is less readable and error prone (if you miss a 0 or a 1 it will be hard to tell where the program is failing)</p>

<p>In the implementation I'd expect to see bit wise ands trying to figure out which flags are On or Off.</p>
",0
57852458,57852215,3,"<p>These constructs are typically used in flags that are combined into a single word. They can be combined using the bit-wise OR-operator, e.g.:</p>

<pre><code>int flags = FT_LS_LONG | FT_LS_HIDDEN;
</code></pre>

<p>In the code above, the <code>flags</code> variable will be set to 0000 0101.
The <code>flags</code> variable can then be tested using the bit-wise AND-operator, e.g.:</p>

<pre><code>if (flags &amp; FT_LS_LONG) { foo(); }
</code></pre>

<p>The if-statement will evaluate as true, and the foo() function will be called.</p>

<pre><code>if (flags &amp; FT_LS_TIME) { bar(); }
</code></pre>

<p>The if-statement will evaluate as false, and the bar() function will not be called.</p>
",0
57852509,57852215,-1,"<p>As other answers suggest this is typically because of using flags, however that's not necessarily the only reason.</p>

<p>For microcontrollers for example address space is extremely precious so they pack multiple properties in a single byte, sometimes they are just boolean flags, sometimes they might be something else, for example a clock division factor, and might consist of a few bits, but because the address space is extremely limited it is stored in the same peripheral configuration register as other flags and/or values so they might be for example 5 bits starting at bit 2 and you might find values such as <code>0b10101 &lt;&lt; 2</code> or in hex <code>0x15 &lt;&lt; 2</code>.</p>

<p>In the microcontroller case it makes it easier to find in the documentation, you just look at the register and which bit it is in it... as in you don't have to count 0s in binary representation or convert it from hex or even worse from decimal to figure out the corresponding value.</p>
",0
54116090,54116058,3,"<p>An uninitialized variable contains garbage value, and using it may become <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>. Be <a href=""https://stackoverflow.com/a/46526702/841108"">scared</a>.</p>

<p>The memory location or register holding these variables have some content (which cannot be predicted in general), even before the bitwise operation. Consider that content as at least random (or ""buggy"").</p>

<p>BTW, you should enable all warnings and debug info when compiling. With <a href=""https://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a>, use <code>gcc -Wall -Wextra -g</code>. Your source code would probably trigger some warning. I recommend to <em>always</em> initialize your <a href=""https://en.wikipedia.org/wiki/Automatic_variable"" rel=""nofollow noreferrer"">automatic variables</a> (perhaps the <a href=""https://en.wikipedia.org/wiki/Optimizing_compiler"" rel=""nofollow noreferrer"">optimizing compiler</a> would figure out that the initialization is useless, then it skips it, per the <a href=""https://en.wikipedia.org/wiki/As-if_rule"" rel=""nofollow noreferrer"">as-if rule</a>; but you are sure that the variable has some well known value).</p>

<p>Imagine that you compile and run the same program on some very different computer (with another operating system, another compiler, another processor). You are very likely to observe different program behavior.</p>
",2
54121635,54121532,2,"<p>Missing return between <code>#endif</code> and <code>}</code>.</p>

<blockquote>
  <p>But there is return word in the bottom of the function. </p>
</blockquote>

<p>No there isn't a <code>return</code>. </p>

<p>The following is one big comment with <code>#if 0</code></p>

<pre><code>   #if 0
    if (!ToolsCore_LoadPlugins(state)) {
      return 1;
    }
    #if defined(__linux__)
    if (state-&gt;mainService) {
      ToolsCore_InitVsockFamily(state);
    }  
    #endif
    if (state-&gt;ctx.errorCode == 0 &amp;&amp;
       (state-&gt;ctx.isVMware ||
        ToolsCore_GetTcloName(state) == NULL ||
        state-&gt;debugPlugin != NULL)) {
        ToolsCore_RegisterPlugins(state);

        if (g_signal_lookup(TOOLS_CORE_SIG_IO_FREEZE,
                      G_OBJECT_TYPE(state-&gt;ctx.serviceObj)) != 0) {
          g_signal_connect(state-&gt;ctx.serviceObj,
                      TOOLS_CORE_SIG_IO_FREEZE,
                      G_CALLBACK(ToolsCoreIOFreezeCb),
                      state);
        }

        state-&gt;configCheckTask = g_timeout_add(CONF_POLL_TIME * 1000,
                                         ToolsCoreConfFileCb,
                                         state);

        #if defined(__APPLE__)
            ToolsCore_CFRunLoop(state);
        #else
            g_main_loop_run(state-&gt;ctx.mainLoop);
        #endif
        }
        ToolsCoreCleanup(state);
        return state-&gt;ctx.errorCode;
        #endif
</code></pre>

<p>A better formatting will show things clearer.</p>

<pre><code>static int ToolsCoreRunLoop(ToolsServiceState *state) {

  if (!ToolsCore_InitRpc(state)) {
    return 1;
  }

  if (state-&gt;ctx.rpc &amp;&amp; !RpcChannel_Start(state-&gt;ctx.rpc)) {
    return 1;
  }

  if (state-&gt;ctx.rpc) {
    ToolsCoreReportVersionData(state);
  }

  //return 0; Here is what I add

#if 0
  if (!ToolsCore_LoadPlugins(state)) {
    return 1;
  }
#if defined(__linux__)
  if (state-&gt;mainService) {
    ToolsCore_InitVsockFamily(state);
  }
#endif
  if (state-&gt;ctx.errorCode == 0 &amp;&amp;
      (state-&gt;ctx.isVMware ||
          ToolsCore_GetTcloName(state) == NULL ||
          state-&gt;debugPlugin != NULL)) {
    ToolsCore_RegisterPlugins(state);

    if (g_signal_lookup(TOOLS_CORE_SIG_IO_FREEZE,
            G_OBJECT_TYPE(state-&gt;ctx.serviceObj)) != 0) {
      g_signal_connect(state-&gt;ctx.serviceObj,
          TOOLS_CORE_SIG_IO_FREEZE,
          G_CALLBACK(ToolsCoreIOFreezeCb),
          state);
    }

    state-&gt;configCheckTask = g_timeout_add(CONF_POLL_TIME * 1000,
        ToolsCoreConfFileCb,
        state);

#if defined(__APPLE__)
    ToolsCore_CFRunLoop(state);
#else
    g_main_loop_run(state-&gt;ctx.mainLoop);
#endif
  }
  ToolsCoreCleanup(state);
  return state-&gt;ctx.errorCode;
#endif

// Missing return

}
</code></pre>
",1
54296945,54296744,1,"<p>if you move <code>int A_new[N + 1][N + 1];</code> and <code>int B_new[N + 1][N + 1];</code> before the if you can use <em>A</em> and <em>B</em> in the two branches of the <em>if</em> without problem, and they are available after the <em>if</em> too of course. You do not use all the cells in the <em>else</em> branch but that has no consequences </p>

<pre><code>  int A_new[N + 1][N + 1];
  int B_new[N + 1][N + 1];

  if (N &gt; 1 &amp;&amp; N % 2 != 0) {
    int i, j;
    for (i = 0; i &lt; N + 1; i++) {
      if (i == N) {
        for (j = 0; j &lt; N + 1; j++) {
          A_new[i][j] = 0;
          B_new[i][j] = 0;
        }

      } else {
        for (j = 0; j &lt; N + 1; j++) {
          if (j == N) {
            A_new[i][j] = 0;
            B_new[i][j] = 0;
          } else {
            A_new[i][j] = A[i][j];
            B_new[i][j] = B[i][j];
          }
        }
      }
    }

    for (i = 0; i &lt; N + 1; i++) {
      for (j = 0; j &lt; N + 1; j++) {
        C[i][j] = 0;
      }
    }

  } else {
    int i, j;
    for (i = 0; i &lt; N; i++) {
      for (j = 0; j &lt; N; j++) {
        A_new[i][j] = A[i][j];
      }
    }

    for (i = 0; i &lt; N; i++) {
      for (j = 0; j &lt; N; j++) {
        B_new[i][j] = B[i][j];
      }
    }

    for (i = 0; i &lt; N; i++) {
      for (j = 0; j &lt; N; j++) {
        C[i][j] = 0;
      }
    }
  }
</code></pre>

<p>As chux says in a remark you missed an else (or you just <em>return</em> if <em>N == 1</em> ?) and the code can be</p>

<pre><code>  int A_new[N + 1][N + 1];
  int B_new[N + 1][N + 1];

  if (N == 1) {
    C[0][0] = A[0][0] * B[0][0];
  }
  else if (N &gt; 1 &amp;&amp; N % 2 != 0) {
    int i, j;
    for (i = 0; i &lt; N + 1; i++) {
      if (i == N) {
        for (j = 0; j &lt; N + 1; j++) {
          A_new[i][j] = 0;
          B_new[i][j] = 0;
        }

      } else {
        for (j = 0; j &lt; N + 1; j++) {
          if (j == N) {
            A_new[i][j] = 0;
            B_new[i][j] = 0;
          } else {
            A_new[i][j] = A[i][j];
            B_new[i][j] = B[i][j];
          }
        }
      }
    }

    for (i = 0; i &lt; N + 1; i++) {
      for (j = 0; j &lt; N + 1; j++) {
        C[i][j] = 0;
      }
    }

  } else {
    int i, j;
    for (i = 0; i &lt; N; i++) {
      for (j = 0; j &lt; N; j++) {
        A_new[i][j] = A[i][j];
      }
    }

    for (i = 0; i &lt; N; i++) {
      for (j = 0; j &lt; N; j++) {
        B_new[i][j] = B[i][j];
      }
    }

    for (i = 0; i &lt; N; i++) {
      for (j = 0; j &lt; N; j++) {
        C[i][j] = 0;
      }
    }
  }
</code></pre>
",2
58783149,58782831,1,"<pre><code>test.c:65:14: warning: 'sor' may not be used as an array element due to flexible array member
      [-Wflexible-array-extensions]
    sor sorok[32];
             ^
</code></pre>

<p><code>rendeles rendelesek[];</code> is a <a href=""https://en.wikipedia.org/wiki/Flexible_array_member"" rel=""nofollow noreferrer"">flexible array member</a> meaning since it's at the end of the struct you can, in theory, allocate as much memory for the array as you like. However this means the size of any given <code>sor</code> will vary.</p>

<p>Each element of an array in C must be of a fixed size, going from one element to another is simply <code>start-of-array-memory + (i * sizeof(element))</code>. Since <code>sor</code> can be of different sizes it can't be put into an array.</p>

<p>You could use an array of pointers to <code>sor</code>, or you can change <code>sor</code> to contain a pointer to <code>rendeles **rendelesek;</code>. Or both, getting used to working with pointers is good.</p>

<hr>

<p>The real problem is <code>sor.rendelesek</code> is never allocated. Whichever you choose, you still have to allocate memory to <code>sor.rendelesek</code> else you're writing into someone else's memory. As a flexible array member, you have to use a pointer array and allocate sufficient memory as part of <code>sor</code>.</p>

<pre><code>typedef struct {
    char futarkod;
    int datum;
    int rendelesCount;
    rendeles rendelesek[];
} sor;

sor *sorok[32];
for( size_t i = 0; i &lt; 32; i++) {
    sorok[i] = malloc(sizeof(sor) + (sizeof(rendeles) * 32));
}
</code></pre>

<p>Or you can use a <code>rendelesek **</code> instead and allocate that directly. Combining both is probably the best option.</p>

<pre><code>typedef struct {
    char futarkod;
    int datum;
    int rendelesCount;
    rendeles *rendelesek;
} sor;

sor *new_sor(const size_t num_rendeles) {
    sor *new = malloc(sizeof(sor));
    new-&gt;rendelesek = malloc(sizeof(rendeles) * num_rendeles);

    return new;
}

int main()
{
    sor *sorok[32];
    for( size_t i = 0; i &lt; 32; i++) {
        sorok[i] = new_sor(32);
    }
</code></pre>

<hr>

<p>Reading inputs into statically allocated structures like this is risky and wasteful because you have to allocate what you <em>think</em> is the most possible elements. It's very easy to allocate way too much or not enough. Instead they should be dynamically allocated as needed, but that's another thing.</p>
",0
55828589,55827583,2,"<p>The line <code>memset(*cards[i], 0, strlen(*cards[i]));</code> is wrong. First, <code>cards</code> was allocated with <code>calloc</code>, so it is filled with zero bytes, which act as empty strings. So, if <code>*cards[i]</code> pointed to something in <code>cards</code>, <code>strlen</code> returns zero, and <code>memset</code> sets zero bytes to zero.</p>

<p>Unfortunately, <code>*cards[i]</code> is valid only when <code>i</code> is zero. Since <code>cards</code> is a pointer to a <code>deck_t</code>, <code>cards[0]</code> is the first <code>deck_t</code>, which is an array of array of <code>char</code>. As an array, it is automatically converted to a pointer to its first, element, an array of <code>char</code>. Then <code>*cards[0]</code> is that array of <code>char</code>. As an array, it is automatically converted to a pointer to its first element, which is passed to <code>strlen</code>. However, when <code>i</code> is one (or greater), <code>cards[i]</code> would be the second (or greater) <code>deck_t</code>. But space for only one <code>deck_t</code> was allocated. So <code>*cards[i]</code> is invalid; it attempts to access space that was not allocated.</p>

<p>Since this line is not needed (due to <code>calloc</code>), remove it and the loop it is in.</p>

<p>In <code>strcat(*cards[j]</code>, the same problem exists¡ª<code>*cards[j]</code> is valid only when <code>j</code> is zero. A correct expression is <code>(*cards)[j]</code>.</p>

<p>In <code>(*cards)[j]</code>, <code>cards</code> is a pointer to a <code>deck_t</code>, so <code>(*cards)</code> is a <code>deck_t</code>, which is an array of array of <code>char</code>. Then <code>(*cards)[j]</code> is element <code>j</code> of that array, so it is an array of <code>char</code>.</p>

<p>Similarly, in <code>print_deck</code>, change <code>*deck[i]</code> to <code>(*deck)[i]</code>.</p>

<p>(The code can be changed so that <code>deck[i]</code> can be used instead of <code>(*deck)[i]</code> by changing the type of <code>deck</code> to <code>char (*MyType)[S_MAXLEN + V_MAXLEN + OFLEN]</code>. However, you may wish to make the above changes first and understand them before changing types.)</p>
",2
54135596,54135572,0,"<p>You need to put your <code>printf</code> lines outside your inner loop.</p>

<p>Like this:</p>

<pre><code>int main (void)
{
    int p, d;
    _Bool isprime;
    for (p=2;p&lt;=50;++p){
        isprime = 1;
        for (d=2;d&lt;p;++d){
            if (p%d == 0) {
                isprime = 0;
                break;
            }
        }
        if (isprime)
            printf(""%i "", p);
    }
    return 0;
}
</code></pre>
",1
55562367,55562033,0,"<p>Should work better if you simplify the code a bit:</p>

<pre class=""lang-c prettyprint-override""><code>int InputData(student **p_array, FILE *fp)
{
    student *arr;
    char buf[80];
    int i = 0;

    arr = (student *)malloc(sizeof(student));
    if (!arr) {
        printf(""no"");
        _getch();
        exit(1);
    }

    while (fscanf(fp, ""%s %d %d %d"", arr[i].name, &amp;arr[i].grades[0], &amp;arr[i].grades[1], &amp;arr[i].grades[2]) != EOF) {
        i++;
        arr = (student *)realloc(arr, (i + 1) * sizeof(student));
        if (!arr)
            err(errno, ""Failed realloc() array"");
    }

    arr = (student *)realloc(arr, i * sizeof(student));
    *p_array = arr;

    return i;       /* return number of students */
}
</code></pre>
",0
57867120,57867079,2,"<p>This line is the problem:</p>

<pre><code>identities[i].name = tempName
</code></pre>

<p>Here you make <em>all</em> structures <code>name</code> member point to the first element of <code>tempName</code>.</p>

<p>I suggest you make the <code>name</code> member an array, and copy the string into it instead.</p>
",3
57935308,57933334,0,"<p>I am baffled by the comments on this post suggesting that fgets is easier to use.  Using fgets unnecessarily complicates the issue.  Just do:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;

int
main(int argc, char **argv)
{
        int c;
        while( ( c = getchar() ) != EOF ) {
                if(isdigit(c) &amp;&amp; (putchar(c) == EOF)) {
                        perror(""stdout"");
                        return EXIT_FAILURE;
                }
        }
        return ferror(stdin);
}
</code></pre>

<p>There is absolutely no reason to use any additional buffering, or read the input one line at a time.  Maybe you'll want to output newlines as they come in, but that would be an implementation detail that is left unspecified in the question.  Either way, it's utterly trivial (<code>if(( c == '\n' || isdigit(c)) &amp;&amp; (putchar(c) == EOF))</code>).  Just read a character and decide if you want to output it.  The logic is much easier if you don't think about the input as being more complicated than it is. (It's not line-oriented...it's just a stream of bytes.)</p>

<p>If, for some unknown reason you want to make this tool usable only in an interactive setting and load up your output with excess verbosity, you can easily do something like:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;


int
main(int argc, char **argv)
{
        int c;
        do {
                int want_header = 1;
                printf(""Please enter your string: "");

                while( ( c = getchar() ) != EOF &amp;&amp; c != '\n' ) {
                        if(! isdigit(c)) {
                                continue;
                        }
                        if(want_header) {
                                want_header=0;
                                printf(""Your output of only integers is: "");
                        }
                        if(putchar(c) == EOF) {
                                perror(""stdout"");
                                return EXIT_FAILURE;
                        }
                }
                if( c == '\n')
                        putchar(c);
                want_header = 0;
        } while(c == '\n');
        return ferror(stdin);
}
</code></pre>

<p>but, please, don't do that.  (Imagine if <code>grep</code> started by emitting a prompt that said ""please enter the regex you would like to search for""!)</p>
",5
54233281,54232548,0,"<p>In this case it doesn't make much sense to use a switch statement, since you are looking at doing several string comparisons.</p>

<p>What you could do instead is a table look-up, based on a table sorted in alphabetic order:</p>

<pre><code>const char* STR_TABLE[] =  // must be sorted in alphabetic order
{
  ""exit"",
  ""history"",
  ""parse"",
  ...
};

const size_t STR_TABLE_SIZE = sizeof(STR_TABLE) / sizeof(STR_TABLE[0]);
</code></pre>

<p>You can then search through the table for the correct string. The naive implementation being a for loop:</p>

<pre><code>for(size_t i=0; i&lt;STR_TABLE_SIZE; i++)
{
  if(strcmp(STR_TABLE[i], user_input)==0)
  {
    // found, do something
    break;
  }
}
</code></pre>

<p>This is the best option when the number of strings in the table are limited. For larger tables, you would use binary search instead. Something like this:</p>

<pre><code>int strcmp_wrapper (const void* obj1, const void* obj2)
{
  return strcmp(obj1, *(const char**)obj2);
}

const char** result = bsearch(user_input, 
                              STR_TABLE,
                              STR_TABLE_SIZE,
                              sizeof(const char*),
                              strcmp_wrapper);

if(result != NULL)
{
  printf(""User picked option %s at index %d."", *result, (int)(result - STR_TABLE));
}                               
</code></pre>
",0
54233329,54232548,0,"<p>currently your code is like :</p>

<blockquote>
<pre><code>  if(command_line[0] == '!')
   {
       &lt;recall&gt;
   }
   else if(strcmp(command_line, ""exit"") == 0)
   {
       &lt;exit&gt;
   }
   else if(strcmp(command_line, ""history"") == 0)
   {
       &lt;historic&gt;
   }
   else if(strncmp(command_line, ""parse"", 5) == 0)
   {
       &lt;parse&gt;
   }
   else
   {
       &lt;other&gt;
   }
</code></pre>
</blockquote>

<p>to use a switch will give something like that :</p>

<pre><code>   switch (command_line[0]) {
    case '!':
        &lt;recall&gt;
        break;
    case 'e':
       if(strcmp(command_line + 1, ""xit"") == 0)
       {
         &lt;exit&gt;
       }
       else
       {
         &lt;other&gt;
       }
       break
    case 'h':
       if(strcmp(command_line + 1, ""istory"") == 0)
       {
         &lt;historic&gt;
       }
       else
       {
         &lt;other&gt;
       }
       break
    case 'p':
       if(strncmp(command_line + 1, ""arse"", 4) == 0)
       {
         &lt;parse&gt;
         break;
       }
       // no fallthrough
    default:
      {
         &lt;other&gt;
      }
    }
</code></pre>

<p>This is less readable, facilitates the introduction of a bugs if it has to be modified, and has no benefic effect on the speed if this what you expected</p>

<p>For me <strong>don't do that</strong> ... but ask yourself about the <em>strcmp</em> but <em>strncmp</em> in one case</p>
",1
54495763,54495448,0,"<p>To give environment variables to a child process you can</p>

<ul>
<li>create the <em>envp</em> vector of char * to give it to <code>int execvpe(const char *file, char *const argv[],char *const envp[]);</code> or equivalent function, each entry in the vector having the form ""a=b""</li>
<li>or if it is not a problem for the current program to set the environment using <code>int setenv(const char *name, const char *value, int overwrite);</code> for all the required variables then create your child process</li>
</ul>
",4
58702526,58702181,1,"<p>The difference is that <code>int main()</code> doesn't specify a prototyped declaration for <code>main</code>. As a <em>definition</em> of the function, the two are equivalent, and define the function in mutually compatible ways. However, <code>int main()</code> introduces less compile-time information into the scope.</p>

<p>In C (unlike C++), <code>main</code> is allowed to recurse. Thus we can consider the following silly program:</p>

<pre><code>int main(void)
{
   main(42);
}
</code></pre>

<p>because <code>main</code> is declared completely, the <code>main(42)</code> call is a constraint violation, requiring a diagnostic. If we change the program to:</p>

<pre><code>int main()
{
   main(42);
}
</code></pre>

<p>then the function hasn't changed: it's still one that takes no arguments. But that information is not declared as part of the <code>main</code> identifier's type information, and so the call doesn't require a diagnostic. (If translated and executed, it invokes undefined behavior; but that may happen even if there is a diagnostic.)</p>

<p>This is an old style, before C had function prototype declarations, which were first standardized in 1989's ANSI C and in widespread use before that.</p>
",0
58030424,58029909,0,"<p>This is a somewhat corrected version of your program. It compiles almost with no errors.</p>

<p>Read carefully the comments starting with <code>***</code>.</p>

<p>Probably there are more errors, but it's a start.</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

#define LAT_1 -78.98214
#define LONG_1 -7.31600

#define R_PI 3.14159       // *** correct and put PI with more decimals
#define DEGREES 180

int read_file(int i);
double toRadian(double theta);   // *** correct declaration
double distance(double d);    // *** correct declaration

int main()
{
  int i = 0;
  return read_file(i);
}

double toRadian(double theta)
{
  double x;   // *** no need to initialize with 0
  x = R_PI / DEGREES;  // *** something is missing here: up to to find what
                       //     Hint: you need to use the theta parameter
  return x;
}

double distance(double d)   // ** correct prototype
{
  /* This function is designed to calculate the distance between the check-in
  POI and the reference point provided*/
  double dist, angle_distance, chord_length;
  double lat_2, long_2;  // *** double here

  char length[256];
  char* token[6];

  if (fgets(length, 256, stdin) != NULL)
  {
    token[0] = strtok(length, "" "");
    int i = 0;
    double dist;
    for (i = 1; i &lt; 6; i++)     // *** what's the purpose of this for loop???
    {
      lat_2 = atof(token[1]);   // *** using atof here
      long_2 = atof(token[2]);
    }

    chord_length = pow(sin(toRadian(lat_2 - LAT_1) / 2) + cos(toRadian
    (LAT_1)) * cos(toRadian(lat_2)) * pow(sin(toRadian(long_2 -
      LONG_1))));   // *** no idea what the formula should be , but pow needs 2 arguments

    angle_distance = 2 * atan2(sqrt(chord_length), sqrt(1 - chord_length)); // *** using chord_length

    dist = 6371 * angle_distance;   // *** using angle_distance
    return dist;    // *** the function must return something.
  }
}    // *** this } was missing

int read_file(int i)  // *** what's the purpose if the i parameter?
{
  /* This function takes the data from the input file,reading and printing the
  User ID, Location (longitude and latitude), Date, Time, and Distance*/
  char length[256];
  char* token[6];

  if (fgets(length, 256, stdin) != NULL)
  {
    token[0] = strtok(length, "" "");
    int i = 0;
    double dist;
    for (i = 1; i &lt; 6; i++)
      token[i] = strtok(NULL, "" ""); /*C programming is fun*/

    printf(""Stage 1\n==========\n"");
    printf(""User: #%s\n"", token[0]);
    printf(""Location: &lt;%s, %s&gt;\n"", token[1], token[2]);
    printf(""Date: %s\n"", token[3]);
    printf(""Time: %s\n"", token[4]);
    printf(""Distance to reference: %2.2f\n"", distance(dist));
  }
  else
  {
    printf(""Error opening file. Check file and try again."");
     exit(EXIT_FAILURE);
  }
  return 0;
}
</code></pre>
",1
55392569,55392224,0,"<p>In case you're trying to measure ""CPU time used"" (and not ""wall clock time spent waiting for user to press a key""), then...</p>

<p>Imagine if the OS has a timer that generates an IRQ 10 times per second, and the IRQ handler just does <code>ticks++</code>; and <code>clock()</code> is just <code>return ticks;</code>. In this case, <code>CLOCKS_PER_SEC</code> would be 10.</p>

<p>Now, if you call <code>clock()</code> once just before the timer IRQ occurs and again immediately after the timer IRQ occurs, the difference between the values returned might be 1 (equal to 100 ms) even significantly less time passed between calls to <code>clock()</code>.</p>

<p>Alternatively; if you call <code>clock()</code> once immediately after the timer IRQ occurs and again just before the timer IRQ occurs again, the difference between the values returned might be 0, even significantly more time passed between calls to <code>clock()</code>.</p>

<p>Essentially, the difference between values returned by <code>clock()</code> is ""up to <code>1/CLOCKS_PER_SEC</code> sooner than you think"" and ""up to <code>1/CLOCKS_PER_SEC</code> longer than you think"".</p>

<p>Note that the value of <code>CLOCKS_PER_SEC</code> is implementation defined. Depending on various things (which version of which OS running on which hardware, with which C library) <code>CLOCKS_PER_SEC</code> can be anything, and could be as low as 10 and could be as high has 4 billion.</p>
",0
54980484,54978143,3,"<p><code>EOF</code> isn¡¯t a character, and it isn¡¯t read from the stream.  It¡¯s just the return value indicating that there is no more input on that stream.  You can signal an <code>EOF</code> by typing <kbd>Ctrl</kbd><kbd>D</kbd> on *nix or <kbd>Ctrl</kbd><kbd>Z</kbd> on Windows.</p>
",2
58046723,58046500,0,"<p>Your semicolon is in the wrong place, move it to the far left just inside the parentheses.</p>

<p>Loop syntax is:</p>

<p>for (intializer; break condition; iterator)</p>
",0
54244648,54244461,1,"<p>Crashing upon a call to <code>free</code> is a sign of incorrect memory management somewhere else in your code. When you set a pointer to <code>NULL</code> then <code>free</code> it, you are not going to crash, because <code>free(NULL)</code> is guaranteed to be benign by the C Standard &sect; 7.22.3.3:</p>

<blockquote>
  <p>7.22.3.3 The free function</p>
  
  <p>...
  If ptr is a null pointer, <strong>no action occurs</strong>. Otherwise, if
  the argument does not match a pointer <strong>earlier returned by a memory management
  function</strong>, or if the space has been deallocated by a call to free or realloc, the
  behavior is undefined.</p>
</blockquote>

<p>Emphasis mine.</p>

<p>As other answers have noted, you are trying to call <code>free</code> on memory that you didn't explicitly allocate with <code>malloc</code>-family functions (since you overwrote <code>arr[i]</code> pointers with pointers to string literals)</p>
",0
54352389,54352166,1,"<p>If the length is unknown until runtime (i.e. because it is given by a user input), dynamic allocation is an option:</p>

<pre><code>char *input = malloc(len + 1);
fgets(input, len + 1, stdin);

// use `input`...

free(input);
input = NULL;
</code></pre>

<p>Also, <strong><a href=""https://stackoverflow.com/questions/1694036/why-is-the-gets-function-so-dangerous-that-it-should-not-be-used"">never use <code>gets</code></a></strong>; it is dangerous and not supported by the latest C standard.</p>
",1
54292850,54292586,1,"<p>Your <code>first()</code> function scans the whole array presented to it, all <code>size</code> bytes, without regard to the presence of a string terminator within.  Therefore, if an input line is shorter than the previous one, your function blithely scans the overlay of the second line on the first.</p>

<p>To stop your scan at the end of the line, break from the loop when you see the terminator:</p>

<pre><code>    for (j = 0; spaces[j] != '\0'; j++)
</code></pre>

<p>You may also break on the condition that <code>j</code> reaches or exceeds <code>size</code> (as an <em>additional</em>, not alternative condition), but it's not really necessary in your case because you can rely on <code>fgets()</code> to provide that terminator within the number of bytes specified to it.</p>
",0
54330916,54329743,0,"<p>Something like this might work.<br>
Create an array of valid characters.<br>
Read a character from the file into <code>znak</code>.<br>
<code>strchr</code> will check to see if <code>znak</code> is one of the valid characters.<br>
If so, set a zero. If not, set a one.<br>
Increment <code>j</code>. If <code>j</code> is equal to <code>c</code>, reset <code>j</code> to zero and increment <code>i</code>.<br>
Read another character.<br>
When <code>i</code> is equal to <code>a</code>, the array is full. <code>Break</code> out of the loop.</p>

<pre><code>char valid[] = ""aBcDeFgHiJkLmNoPqRsTuVwXyZ"";
while ( (znak = fgetc(plik2)) != EOF) {
    if ( strchr ( valid, znak)) {
        tab_a[i][j] = 0;
    }
    else {
        tab_a[i][j] = 1;
    }
    j++;
    if ( j &gt;= c) {
        j = 0;
        i++;
        if ( i &gt;= a) {
            break;
        }
    }
}
</code></pre>
",0
58107724,58107647,0,"<p>Use recursion. E.g. something vaguely like:</p>

<pre><code>int findCount(int *array, int length, int N1, int N2) {
   int count = 0;

   if(N1 == 1) {
       for(int i = 0; i &lt; length; i++) {
           if(array[i] == N2) {
               count++;
           }
       }
   } else {
       for(int i = 0; i &lt; length; i++) {
           count += findCount(&amp;array[i+1], length-i-1, N1 - 1, N2 - array[i]);
       }
   }
   return count;
}
</code></pre>

<p>Note: If the array can't contain zeros or negative numbers you can improve this with an <code>if(array[i] &lt; N2) count += findCount(&amp;array[i+1], length-i-1, N1 - 1, N2 - array[i]);</code>.</p>
",0
54430841,54430683,2,"<p>A function like <code>void function(char*s)</code> expects a pointer to a correctly allocated object (or NULL to make explicit that nothing valid has been passed). There are several ways of allocating an object, one is <code>malloc</code>, another is an object with automatic or static storage duration.</p>

<p>But there is at least one thing that you must not do: pass a pointer that is not initialized; this pointer might point to ""somewhere"" and yields undefined behaviour then:</p>

<pre><code>void function(char*s) {
   if (s != NULL) {  // valid?
      strcpy(s,""Hello world!"");
   }
}

int main() {
   char s1[20];  // automatic storage duration
   char s2[] = ""some initil value""; // automatic storage duration
   static char s3[30]; // static storage duration
   char *s4 = malloc(30); // dynamic storage duration

   function(s1);
   function(s2);
   function(s3);
   function(s4);
   function(NULL); // explicitly something NOT pointing to a valid object

   free(s4); // deallocate object with dynamic storage duration

   // don't do that:
   char* s5;  // s5 is not initiaized
   function(s5);  // -&gt; undefined behaviour
} 
</code></pre>
",5
58784577,58784333,1,"<p>This depends on the operating system you are using (if any).</p>

<p><strong>Systems that provides a <a href=""https://en.wikipedia.org/wiki/Virtual_machine"" rel=""nofollow noreferrer"">process virtual machine</a> abstraction - that is to say any *nix variant, Windows, some RTOSs such as QNX</strong></p>

<p>In these systems, there is a distinction between virtual memory (address space) and committed physical pages.  The process gains physical pages when the writes occurs to the associated virtual address space. Thus it is possible to allocate a larger heap-block than there is physical memory on the system, and the heap can grow on demand.  The system may use <a href=""https://en.wikipedia.org/wiki/Paging"" rel=""nofollow noreferrer"">paging</a> to maintain a working set of pages backed by real memory,  and write those that can't be accommodated to disk.  This is what many people (incorrectly) describe as 'virtual memory'. Notably, iOS, Android and many embedded systems don't have a pager. </p>

<p>The operating system is likely to kill your process if it uses memory abusively  - for instance, allocating a huge heap-block and then writing randomly to all of it.  An operating system might apply a limit to the virtual address space or number of physical pages a process can have and will terminate the process when this is exceeded. </p>

<p>Overrunning the end of a heap-block is <em>undefined behaviour</em> in C. This may generate an exception - or any other unexpected consequence.  It's a moot point whether you have overrun the entire heap as well at this point.</p>

<p>All of these operating systems will prevent trashing of system memory by a process.</p>

<p><strong>Bare-metal systems, some embedded operating systems</strong></p>

<p>These systems lack the process virtual machine abstraction and memory protection that goes with it; they lack paging and will typically not allow an allocation of a larger heap-block than can be accommodated in physical pages.  Overwriting the end of an allocated block will have undefined behaviour. </p>
",6
54932333,54931844,0,"<p>You can move parts of your code into functions:</p>

<pre><code>bool mayGoUp(int ro, int co)
{
    return ro &gt; 0;
}

bool mayGoDown(int ro, int co)
{
    return ro &lt; NUMROWS - 1;
}

bool mayGoLeft(int ro, int co)
{
    return co &gt; 0;
}

bool mayGoRight(int ro, int co)
{
    return co &lt; NUMCOLS - 1;
}
</code></pre>

<p>Note: I changed the logic a bit: from <code>co &lt; NUMROWS - 1</code> to <code>co &lt; NUMCOLS - 1</code>; not sure which one is the correct one.</p>

<p>Then you can combine them in a straightforward way:</p>

<pre><code>bool mayGoUpLeft(int ro, int co)
{
    return mayGoUp(ro, co) &amp;&amp; mayGoLeft(ro, co);
}
</code></pre>

<p>Then, using them in your code will make your code clearer:</p>

<pre><code>    switch (direction) {
    case 0:
        if (MayGoRight(ro, co) &amp;&amp; island[ro][co + 1] == ...
        {  //move right
            co++;
            break;
        }
...
    case 99:
        if (MayGoUpRight(ro, co) &amp;&amp; ...
        {  // move up and right
            ro--;
            co++;
            break;
        }
</code></pre>
",0
56050219,56042667,1,"<p>It's not the same compiler. You use a Linux C compiler to compile programs for Linux (such as gcc or clang). You use a Windows C compiler to compile programs for Windows (such as Microsoft Visual Studio, but also the Windows versions of gcc or clang). </p>

<p>There are a lot of standard C functions that you can call that work on Windows and Linux (for example <code>fopen</code> or <code>printf</code>), but if you call any Windows-specific or Linux-specific functions (such as <code>CreateWindow</code> or <code>gettimeofday</code>) then your program won't compile on other operating systems.</p>
",2
54561872,54561636,1,"<p>You're not opening the file correctly:</p>

<pre><code>in = fopen(argv[1], ""rw"");
</code></pre>

<p><code>rw</code> is not a valid mode.  If you want to open for reading and writing, use <code>r+</code> instead.  Also, don't forget to check if <code>fopen</code> failed.</p>

<pre><code>in = fopen(argv[1], ""r+"");
if (!in) {
    perror(""fopen failed"");
    exit(1);
 }
</code></pre>
",5
54732842,54732758,2,"<p>Compilers and other software generally do not enforce differences between files named with ¡°.c¡± and files named with ¡°.h¡±. A convention humans use is:</p>

<ul>
<li>file.c contains <strong>definitions</strong> of objects and functions, preferably a small set of related things (such as a collection of routines to work with objects of one type).</li>
<li>file.h contains <strong>declarations</strong> of objects and functions that are in file.c, but only those objects and functions that we intend other source files to use.</li>
</ul>

<p>The definitions supply the actual content of the objects and functions. The compiler uses definitions to generate data and code for those objects and functions.</p>

<p>The declarations tell other source files about the objects and functions, such as specifying their types, so that other source files are able to use the objects and functions.</p>

<p>Generally, file.c should include file.h with <code>#include</code>. Even though this may seem redundant, because file.c already knows about the objects and functions it defines, it provides a check for errors: If file.c includes file.h, and the declarations in file.h are not consistent with the definitions in file.c, the compiler will provide warning or error messages. If file.c did not include file.h, the compiler would not be able to perform this check.</p>
",0
54732885,54732758,0,"<p>In a <code>.h</code>/header file you place <a href=""https://stackoverflow.com/a/1410632/1971013"">declarations (<strong>not</strong> definitions)</a> you want to share between <code>.c</code>/source files.</p>

<p>Only <code>.c</code> files are compiled <em>directly</em> by passing them to the compiler. <code>.h</code> files are compiled too but <em>indirectly</em>, by <code>#include</code>-ing them in one or more <code>.c</code> files.</p>

<p>Place as much of your code, including declarations in <code>.c</code> files. Only place/move the stuff (that belongs to a <code>.c</code> file) to a <code>.h</code> file if it needs to be know/used by another <code>.c</code> file.</p>
",0
54496730,54496650,0,"<p>You could do the <code>*(array[0][1]) = *(array[1][0]);</code> to copy a struct-object, yet you'll have to ensure that <code>array[0][1]</code> already points to some memory allocated properly. So if <code>array[0][1]</code> has not been initialized so far, you'd write</p>

<pre><code>array[0][1] = malloc(sizeof(*array[0][1]));
*(array[0][1]) = *(array[1][0]);
</code></pre>
",0
54497335,54496650,1,"<p>To copy a <em>struct</em>, a simple assignment is fine.  <code>memcpy()</code> is not necessary - nor is that function call preferred.</p>

<pre><code>struct {
  int piece;
  int color;
} chessman;

chessman p1, p2;
...
p1 = p2;
</code></pre>

<p>With an array of pointers to a <code>struct</code>, it is OK too.</p>

<pre><code>chessman *array[8][8] = { 0 };

array[1][0] = malloc(sizeof *(array[1][0]));
assign_data(array[1][0]);

array[0][1] = malloc(sizeof *(array[0][1]));
assign_data(array[0][1]);
...
chessman empty = { 0 };
*array[0][1] = *array[1][0];
*array[1][0] = empty;
</code></pre>

<p>Recall that such a copy is a shallow copy.  The below assignment copies the pointer in member <code>other_data</code>, not the contents of what <code>other_data</code> references.</p>

<pre><code>struct {
  int piece;
  int color;
  foo *other_data;
} chessman2;

chessman q1, q2;

q1 = q1; 
</code></pre>
",1
55858287,55858200,0,"<p>You should never test a <em>binary</em> floating-point number for <em>exact</em> equality to a <em>decimal</em> real value.  A 32-bit float can represent a finite number of discrete values few of which coincide with an exact decimal value die to the binary rather then decimal floating-point encoding.</p>

<p>It is probably a bad idea to to floating point values for ""menu selection"" in any event, but if you insist, your code can be fixed thus:</p>

<pre><code>if( fabs(input1 - 1.1) &lt; 0.01 )
</code></pre>

<p>It also happens to work if you avoid the unnecessary implicit conversion from <code>float</code> to <code>double</code>:</p>

<pre><code>if( input1 == 1.1f )
</code></pre>

<p>but that is still ill-advised in general - it will not work for all values.</p>
",0
55231278,55231244,3,"<p>Your format string must be the first argument of <code>printf</code> and your inputs must be the following ones. For example:</p>

<pre><code>printf(""The sum of %d and %d is %d"", first, second, first + second);
</code></pre>
",0
52619019,13551017,1,"<p>Even though this is a generic C question, it gets pretty high hits when looking this question up for C++. Not only was I in C/C++ territory, I also had to be mindful of Microsoft's <a href=""https://msdn.microsoft.com/en-us/library/bb288454.aspx"" rel=""nofollow noreferrer"">Security Development Lifecycle (SDL) Banned Function Calls</a> for a specific project which made <code>strlen</code> a no-go due to,</p>

<blockquote>
  <p><em>For critical applications, such as those accepting anonymous Internet connections,</em> <code>strlen</code> <em>must also be replaced</em>...</p>
</blockquote>

<p>Anyway, this answer is basically just a twist on the answers from the others but with approved Microsoft C++ alternative function calls and considerations for wide-character handling in respect to <a href=""https://stackoverflow.com/a/5351964/3543437"">C99's updated limit</a> of 65,535 bytes.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
int wmain()
{
    //  1 byte per char, 65535 byte limit per C99 updated standard
    //  https://stackoverflow.com/a/5351964/3543437
    const size_t ASCII_ARRAY_SAFE_SIZE_LIMIT = 65535; 

    //  Theoretical UTF-8 upper byte limit of 6; can typically use 16383 for 4 bytes per char instead:
    //  https://stijndewitt.com/2014/08/09/max-bytes-in-a-utf-8-char/
    const size_t UNICODE_ARRAY_SAFE_SIZE_LIMIT = 10922;

    char ascii_array[] = ""ACSCII stuff like ABCD1234."";
    wchar_t unicode_array[] = L""Unicode stuff like ¡ú ¡Þ ¡Æ ¦²? ¦Ã¦Í¦Ø¦Ñ?¦Æ¦Ø ¦Ó?¦Í ?? ???."";

    char * ascii_array_ptr = &amp;ascii_array[0];
    wchar_t * unicode_array_ptr = &amp;unicode_array[0];

    std::cout &lt;&lt; ""The string length of the char array is: "" &lt;&lt; strnlen_s(ascii_array_ptr, ASCII_ARRAY_SAFE_SIZE_LIMIT) &lt;&lt; std::endl;
    std::wcout &lt;&lt; L""The string length of the wchar_t array is: "" &lt;&lt; wcsnlen_s(unicode_array_ptr, UNICODE_ARRAY_SAFE_SIZE_LIMIT) &lt;&lt; std::endl;

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>The string length of the char array is: 27
The string length of the wchar_t array is: 47
</code></pre>
",0
57336328,57336284,0,"<p>Your understanding of parts 1 and 2 is correct (with some simplifications).  For the questions in part 3:</p>

<ol>
<li>why do I need to keep a count of the number of references to the page?</li>
</ol>

<p>You wrote it just above: it is so that when the reference count is 1 you know you don't need to copy it because no one else is looking at it.</p>

<ol start=""2"">
<li>why can the allocation be skipped if there is only one reference? I assume ref_cnt would be 0 in the parent process, 1 in the child process.</li>
</ol>

<p>Reference counting has to be global, not per-process.</p>
",4
57336623,57336284,0,"<ol>
<li><p>yes, <strong>if</strong> the compiler decided to place <code>a</code> in memory.</p></li>
<li><p>yes, but it is <em>write</em>, not <code>write</code> (if you style it the latter way, people think you mean the <code>write</code> system call that reads from memory and writes to a file instead of writing to memory)</p></li>
<li><p>the reference count means exactly the count of how many places the same <em>page frame</em> (physical page) has been mapped to. 1 means it is mapped to one virtual address somewhere, 2 that it has been mapped to 2 virtual addresses and so forth. </p>

<p>If it is marked ""copy-on-write"" and the reference count is > 1 then a copy must be made on <em>write</em> and then the reference count to the original be decreased. The fresh copy will be mapped in its place in this process and its reference count would be set to 1.</p>

<p>If the reference count of original page is 1 then there is no need to copy, just mark it read-write because <em>this</em> virtual address in this process was the only place that is still mapping that location. </p></li>
</ol>

<p>The reference counts <strong>must</strong> be global <strong>and</strong> per <em>page frame</em> (physical page) for the scheme to be useful. When you <code>fork</code> you will have <strong>2</strong> processes so per-process reference counts to page frames wouldn't be useful.</p>
",0
54608438,54608399,0,"<p>A <code>for</code> loop <code>for(init; cond; step) { loop-body; }</code> is equivalent to:</p>

<pre><code>init;
while(cond)
{
     loop-body;
     step;
}
</code></pre>
",0
55828871,55828738,2,"<p>You have</p>

<pre><code>if (status = STILL_ALIVE) 
</code></pre>

<p>which sets <code>status</code> to <code>STILL_ALIVE</code> which is zero, so it never enters the loop.
try </p>

<pre><code>if (status == STILL_ALIVE) 
</code></pre>

<p>instead.</p>
",0
54611134,54610637,2,"<p>Your stacks can only hold 4 items (because of <code>#define MAX 4</code> and <code>int stackN[MAX];</code>) but you don't protect properly against overflow.  For example, if you manipulate stack A and push 37, <code>topA</code> is 0; push 41 and <code>topA</code> is 1; push 43 and <code>topA</code> is 2; push 47 and <code>topA</code> is 3 (and the stack is full), but when you push 51, you don't hit the <code>topA == MAX</code> condition, so you overflow your stack ¡ª overwriting who knows what!  (It might be one of the <code>topN</code> values; it might be part of another stack; neither is good, and neither is what you intended.)</p>

<p>I've got a web site for you ¡ª <a href=""https://stackoverflow.com/"">Stack Overflow</a>!</p>

<p>The simplest fix is probably to change the semantics of <code>topN</code> so that it is initialized to 0 instead of <code>-1</code>.  You then have to adjust the edge conditions in all the functions.</p>

<p>You really need to avoid having so many functions (5 copies of each of 3 functions).  That's a more major rewrite.  You should also use a structure to describe each stack.  You're excused if you've not learned structures yet (but then you should use an array of <code>top</code> values a 2D array for the stack data.  That would make the fixes needed much easier; you'd have 1/5th as many places to edit systematically.</p>
",0
54622351,54622081,2,"<p>Run-Time check failure #3 mean something was used without being initialized. There is more information which you are not seeing. The error message should be ""Run-Time check failure #3: The variable 'XXX' is being used without being initialized"", where XXX is a variable in your code.</p>

<p>In any case you have a lot of uninitialized variables, those should be initialized to some default value:</p>

<pre><code>double resistance = 0.0, thirdband = 0.0;
char color1 = 0, color2 = 0, color3 = 0;
int val1 = 0, val2 = 0, val3 = 0;
FILE *inp = nullptr, *outp = nullptr;

</code></pre>

<p>and for the function:</p>

<pre><code>int col_to_num(char color, int choice) {
    int num = -1;
</code></pre>

<p>Most likely it is <code>int num</code> from the col_to_num function, which will never hit a case if you didn't pass in one of those values. You need to break to exit the switch statement, usually after your condition is hit, however you can group cases together by not breaking allowing you to easily do the same action for different cases. Think of it as falling through starting at the case that is matched. You also need a default case to handle if no cases are matched like this:</p>

<pre><code>int col_to_num(char color, int choice) {
    int num = -1;
    switch (color) {
    case 'B':
    case 'b':
        if (choice == 1) num = 0;
        else if (choice == 2) num = 1;
        else if (choice == 3)num = 6;
        break;
    case 'G':
    case 'g':
        if (choice == 1) num = 5;
        else if (choice == 2) num = 8;
        else if (choice == 3)num = -1;
        break;
    case 'R':
    case 'r':
        num = 2;
        break;
    case 'O':
    case 'o':
        num = 3;
        break;
    case 'Y':
    case 'y':
        num = 4;
        break;
    case 'V':
    case 'v':
        num = 7;
        break;
    case 'W':
    case 'w':
        num = 9;
        break;
    case 'S':
    case 's':
        num = 10;
        break;
    default:
        printf(""Invalid input: %c\n"", color);
    }
    return num;
}
</code></pre>
",1
54687978,54687838,2,"<pre><code>ptr = (Matrix *)malloc(sizeof(int) * 2 + sizeof(double) * rows * cols);
</code></pre>

<p>you should do this for <code>ptr-&gt;data</code>, not for <code>ptr</code>.</p>

<p>Dereferencing <code>data</code> fails because you never allocated memory for it, so it's pointing nowhere (undefined behavior, to be precise).</p>

<p>So first allocate a <code>Matrix</code>, then allocate what's needed for <code>data</code></p>

<pre><code>ptr = malloc(sizeof(Matrix));
ptr -&gt; data = malloc(sizeof(int) * 2 + sizeof(double) * rows * cols);
</code></pre>
",0
56084649,56081172,0,"<p>I'm not clear what problems you were having, but this minor adaptation of your code works for me (and is closely based on what I suggested in my <a href=""https://stackoverflow.com/questions/56081172/how-to-use-scanf-with-pointerarrays-inside-function#comment98800784_56081172"">comment</a>).</p>

<pre><code>#include &lt;stdio.h&gt;

static void testFun(int *arr)
{
    for (int i = 0; i &lt; 2; i++)
    {
        printf(""%d element: "", i + 1);
        scanf(""%d"", &amp;arr[i]);
    }
}

int main(void)
{
    int arr[2];
    testFun(arr);
    for (int i = 0; i &lt; 2; i++)
        printf(""%d: %d\n"", i + 1, arr[i]);
    return 0;
}
</code></pre>

<p>Sample run:</p>

<pre><code>1 element: 234512
2 element: 872390
1: 234512
2: 872390
</code></pre>

<p>There are various unfixed deficiencies in the code, including:</p>

<ul>
<li>Not passing the size of the array to the function.</li>
<li>Not checking the result from <code>scanf()</code> ¡ª it should be one; if it isn't, there's a problem.</li>
</ul>

<p>I used C99 style <code>for</code> loops; if you're stuck with C90, declare <code>i</code> outside the loops.</p>

<p>You could also use:</p>

<pre><code>scanf(""%d"", arr + i);
</code></pre>
",0
56081211,56081172,1,"<p><code>scanf(""%d"", *arr+i);</code></p>

<p>You need a pointer to the ith element of the array</p>

<p>So</p>

<p><code>scanf(""%d"", &amp;arr[i]);</code></p>

<p>should work</p>
",2
57212973,57212190,0,"<ol>
<li>please declare a proper <code>main</code> entry point: <code>int main( int argc, const char* argv[] )</code></li>
<li>Use <a href=""https://linux.die.net/man/3/fgets"" rel=""nofollow noreferrer""><code>fgets</code></a> instead of <code>gets</code>, as gets does not check the bound of your string ( what happened when you enter a 120 chars line)</li>
<li>pass the <code>length</code> of the expected string to <code>LongestWord</code></li>
<li>if available prefer using <a href=""https://linux.die.net/man/3/strnlen"" rel=""nofollow noreferrer""><code>strnlen</code></a> to plain <code>strlen</code>, there might be scenario where your string is not properly terminated.  </li>
<li>Better yet use the suggested <code>length</code> parameter to limit your loop and break when a terminating char is encountered.</li>
<li>your <code>Solution</code> is a stack allocated array, returning it as it is might depend on your implementation, you might be better returning a heap allocated array (using malloc).</li>
</ol>

<p>Suggested changes</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char* getLongestWord(char* input, size_t input_length, size_t *result_length);

int main( int argc, const char* argv[] ) 
{
    const size_t max_length = 100;
    char input[max_length]; // consider using LINE_MAX from limits.h
    printf(""please give a string:\n"");
    if ( fgets( input, max_length, stdin ) == NULL ) return EXIT_FAILURE; // some failure happened with fgets.
    size_t longestWord_length = 0;
    char* longestWord = getLongestWord(input, max_length , &amp;longestWord_length);
    printf(""longest Word is %.*s\n"",longestWord_length, longestWord );
    return EXIT_SUCCESS;
}

char* getLongestWord(char* input, size_t input_length, size_t *result_length) {
    char* result = NULL;
    size_t length = 0;

    size_t word_start = 0, word_end = 0;

    for(int i = 0; i &lt; input_length; ++i) {
        if( (input[i] == ' ') || (input[i] == 0) ) {
            if( i == 0 ) { // first space
                word_start = 1;
                continue;
            }
            word_end = i-1;
            size_t word_length = word_end - word_start+1;
            if( word_length &lt;= length ) {
                word_start  = i + 1; // next word start
                continue;
            }
            // new max length
            length = word_length;
            result = &amp;input[word_start];

            word_start  = i + 1; // next word start
        }
        if( input[i] == 0 ) break; // end of string
    }
    *result_length = length;
    return result;
}
</code></pre>
",0
54775899,54775577,1,"<p>I cleaned up your compiler warnings. Seems the code now works as expected. In the future, clean up your compiler warnings and learn to use <code>gdb</code> or other debugger.</p>

<p>Also, before you use argv[] you MUST check to make sure enough arguments are actually provided on the command line.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char hexForm(int current_byte);
char binForm(int current_byte);



int main(int argc, char *argv[]){
    int i;
    int counter = 0;
    char *addy;
    char buffer[16];

    if(argc &lt; 2 )  /* the actual correct usage here is left up to OP */
    {
        printf(""Invalid parameters\n"")
        return(0);
    }


    //If the user wishes for binary output command arg 2 will be '-b'
    if(strcmp(argv[1], ""-b"") == 0){
        FILE *f = fopen(argv[2], ""r"");
        addy = (char*) f;
        //Check for valid file
        if(f == NULL){
            printf(""Error: File Empty.\n"");
            return(-1);
        }
        //print starting address, faults before this print
        printf(""%p: "", (void*)&amp;f);
        while((i = fgetc(f)) != EOF){
            //While there are contents in the file, dump in binary groups of 6 chars
            if(counter == 6){
                //print human readable string here
                printf("" "");
                for(int i = 0; i &lt; 6; i++){
                    printf(""%c"", buffer[i]);
                }
                printf(""\n"");
                printf(""%p: "", (void*)&amp;addy);
                counter = 0;
            }
            buffer[counter] = binForm(i);
            counter++;
            addy++;
        }
        fclose(f);
    }
    //If not binary, output will be in Hex
    else{
        FILE *f = fopen(argv[1], ""r"");
        //addy = (char*) f;
        //Check for valid file
        if(f == NULL){
            printf(""Error: File Empty.\n"");
            return(-1);
        }
        //Print starting address, faults before this print
        printf(""%p: "", (void*)&amp;f);
        while((i = fgetc(f)) != EOF){
            //While file has contents, dump in hex groups of 16 chars
            if(counter == 16){
                printf("" "");
                //print human readable string here
                for(int i = 0; i &lt; 16; i++){
                    printf(""%c"", buffer[i]);
                }
                printf(""\n"");
                printf(""%p: "", (void*)&amp;addy);
                counter = 0;
            }
            if(counter%2 == 1){
                buffer[counter] = hexForm(i);
                printf("" "");
            }
            else{
                buffer[counter] = hexForm(i);
            }
            counter++;
            addy++;
        }
        fclose(f);
    }
}

char hexForm(int current_byte){
    //Print hex digits for one byte
    printf(""%X"", current_byte);
    //If unprintable, convert to '.'
    if(current_byte &lt; 33)
        current_byte = 46;
    return (char)current_byte;
}
char binForm(int current_byte){
    //Print binary digits for one byte
    while (current_byte) {
    if (current_byte &amp; 1)
        printf(""1"");
    else
        printf(""0"");

    current_byte &gt;&gt;= 1;
    }
    //If unprintable, convert to '.'
    if(current_byte &lt; 33)
        current_byte = 46;
    return (char)current_byte;
}
</code></pre>
",0
55557378,55557320,1,"<p>in </p>

<pre><code>void trier(){
  struct patient *ptr = tete;
  struct patient*prec=NULL;
  int echange;

  do{
    echange=0;

    while(ptr-&gt;suivant!=NULL){
      prec=ptr;
      ptr=ptr-&gt;suivant;
      if(strcmp(prec-&gt;nom,ptr-&gt;nom)&lt;0){
        echangedeNom(prec,ptr);
        echangedePrenom(prec,ptr);
        echangedesentiers(prec,ptr);
        echangedesannes(prec,ptr);
        echange=1;
      }
    }
  }while(echange==1);
  printf(""\n\n Trie Avec Succes ! \n"");
}
</code></pre>

<p>when you finish the internal <em>while</em> you missed to set <em>ptr</em> back to the head of the list for the next turn, so <code>ptr-&gt;suivant!=NULL</code> is false and <code>echange</code> stay 0 and you stop to sort</p>

<p>can be :</p>

<pre><code>void trier(){
  int echange;

  do{
    struct patient *ptr = tete;
    struct patient*prec=NULL;

    echange=0;

    while(ptr-&gt;suivant!=NULL){
      prec=ptr;
      ptr=ptr-&gt;suivant;
      if(strcmp(prec-&gt;nom,ptr-&gt;nom)&lt;0){
        echangedeNom(prec,ptr);
        echangedePrenom(prec,ptr);
        echangedesentiers(prec,ptr);
        echangedesannes(prec,ptr);
        echange=1;
      }
    }
  }while(echange==1);
  printf(""\n\n Trie Avec Succes ! \n"");
}
</code></pre>

<p>Note an other way was to exchange the cells rather that to exchange their contents</p>
",3
55034484,55034431,0,"<blockquote>
  <p>If there are fewer than 20 inputs, the printf output displays the remaining values with garbage</p>
</blockquote>

<p>What else did you expect?</p>

<p>If you have fewer than 20 inputs, then the remaining inputs have not been given any value. You say ""partial array input"" but you literally asked the computer to loop over the entire array.</p>

<p>It's really not clear what else you expected to happen here.</p>

<p>Perhaps loop to <code>count</code> the second time instead.</p>
",8
55446068,55445969,1,"<p>The format ""%s"" (of printf() function) has ""qualifiers"". You are able to ajust a string inside a fixed space:</p>

<pre><code>printf(""'%15s'"", ""abc"");
Print: '            abc'

printf(""'%-15s'"", ""abc"");
Print: 'abc            '
</code></pre>

<p>Using a loop (like for(;;)) you are able to print all elements.</p>
",0
54996952,54996529,2,"<p>This code works with positive numbers:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

static void itov(char vigesimalStr[], int n);

int main(void)
{
    int tests[] = { 30, 0, 1, 19, 20, 21, 399, 400, 401, 379341, };
    enum { NUM_TESTS = sizeof(tests) / sizeof(tests[0]) };

    printf(""Hello world!\n"");

    for (int i = 0; i &lt; NUM_TESTS; i++)
    {
        char result[32];
        itov(result, tests[i]);
        printf(""%6d = %5s base 20\n"", tests[i], result);
    }

    return 0;
}

static void itov(char vigesimalStr[], int n)
{
    char base_digits[20] =
    {
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
    };

    int index = 0;
    int base = 20;

    do
    {
        vigesimalStr[index++] = base_digits[n % base];
        n = n / base;
    } while (n != 0);

    vigesimalStr[index--] = '\0';
    for (int i = 0; i &lt; index; i++, index--)
    {
        char t = vigesimalStr[i];
        vigesimalStr[i] = vigesimalStr[index];
        vigesimalStr[index] = t;
    }
}
</code></pre>

<p>The output is:</p>

<pre><code>Hello world!
    30 =    1A base 20
     0 =     0 base 20
     1 =     1 base 20
    19 =     J base 20
    20 =    10 base 20
    21 =    11 base 20
   399 =    JJ base 20
   400 =   100 base 20
   401 =   101 base 20
379341 = 27871 base 20
</code></pre>

<p>Note that the conversion function does not do any printing ¡ª that makes it more nearly generally usable.  The function interface doesn't provide a mechanism to ensure no overflow of the target string; the onus is on the user to provide a big enough string to hold the result.</p>

<p>Handling negative numbers is trickier ¡ª perfectly doable, but trickier because on the normal two's-complement systems, you can't negate <code>INT_MIN</code> and get a positive value.  You can negate any positive value, though, and then process that.</p>
",0
55005083,55004615,0,"<p>In the second loop <code>k</code> needs to be <code>&gt;= i</code> and not <code>&gt;= 0</code>. I replaced the <code>get_int</code> with <code>5</code>.</p>

<pre><code>int main(void){
int height, i, j, k;
bool check = false;

while (check == false)
{
    height = 5;

    if (height &gt;= 1 &amp;&amp; height &lt;= 8)
    {
        for (i = 0; i &lt; height; i++)
        {
          for (k = height -2; k &gt;= i; k--)
          {
            printf(""."");
          }
          for (j = 0; j &lt;= i; j++)
          {
            printf(""#"");
          }
          printf(""\n"");
    }
    check = true;
}
}}
</code></pre>

<p>Output:</p>

<pre><code>....#                                                                                                                                                                                        
...##                                                                                                                                                                                        
..###                                                                                                                                                                                        
.####                                                                                                                                                                                        
#####
</code></pre>
",4
55377472,55377363,4,"<p>You can't.</p>

<p>You are trying to fight against the very definition of what a stack frame is, and you are losing.</p>

<p>And you will always lose!</p>

<p>Instead, properly structure your program to pass data around in the way you need, in accordance with the rules and specifications of the language.</p>
",2
55377997,55377363,0,"<p>Somewhat off topic, but you probably simply want this:</p>

<pre><code>#include &lt;stdio.h&gt;

void fib(int num, int *arr);

int main()
{
  int num;
  printf(""Enter any number : \n"");
  scanf(""%d"", &amp;num);

  int arr[num] = { 0, 1 } ;
  fib(num, arr);

  for (int i = 0; i &lt; num; i++)
    printf(""%d "", arr[i]);
}

void fib(int num, int *arr)
{
  for (int i = 0; i &lt; num; i++)
  {
    arr[i + 2] = arr[i] + arr[i + 1];
  }  
}
</code></pre>

<p>Using recursion is pretty pointless here.
This is untested code, there may be bugs.</p>
",4
55081736,55081685,0,"<p>The one thing I noticed is the first call to strtok should have the string to tokenise, then subsequent ones having NULL, but all yours have NULL.</p>
",0
55104211,55103955,1,"<p>I ran this on <a href=""https://ideone.com/t10Nrc"" rel=""nofollow noreferrer"">IDEOne</a>, and found that if I don't <code>#include &lt;stdlib.h&gt;</code>, I got incorrect results</p>

<pre><code>#include &lt;stdio.h&gt;
//#include &lt;stdlib.h&gt;            // &lt;== This line is crucial

int main(void) {
    char* temp   = ""6.345e-2"";
    float result = atof(temp);

    printf(""%f\n"", result);

    return 0;
}
</code></pre>

<h3>With <code>stdlib.h:</code></h3>

<pre><code>Success #stdin #stdout 0s 9424KB
0.063450
</code></pre>

<hr>

<h3>Without <code>stdlib.h</code>:</h3>

<pre><code>Success #stdin #stdout 0s 9424KB
0.000000
</code></pre>
",1
56400446,56400337,6,"<p>When declaring a variable, it's not valid code without an array size.</p>

<pre><code>a.c: In function ¡®main¡¯:
a.c:2:11: error: array size missing in ¡®a¡¯
    float *a[];
</code></pre>

<p>With an array size, it creates an array of pointers.</p>

<p>Test:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
   printf(""float:           %zu\n"", sizeof(float));
   printf(""pointer:         %zu\n"", sizeof(void*));

   float *a[100];
   printf(""float *a[100]:   %zu\n"", sizeof(a));

   float (*b)[100];
   printf(""float (*b)[100]: %zu\n"", sizeof(b));
   printf(""*b:              %zu\n"", sizeof(*b));

   return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>float:           4
pointer:         8
float* a[100]:   800       // a is an array of 100 float pointers.
float (*b)[100]: 8         // b is a pointer to an array of 100 floats.
*b:              400
</code></pre>

<hr>

<p>Note that there's a special case in C where a <code>[]</code> does not declare an array, but a pointer. When declaring a function parameter:</p>

<pre><code>void f(float *a[], size_t n) {
   // ...
}
</code></pre>

<p>The <code>[]</code> is treated as a pointer declaration, so it's equivalent to:</p>

<pre><code>void f(float **a, size_t n) { // ...
</code></pre>

<p>Since an array decays to a pointer to its first element when passing it as an argument to a function, the function can accept arrays:</p>

<pre><code>int main() {
   int n = 100;
   float *a[n];
   // ... Initialize the array here ...
   f(a, n);
   return 0;
}
</code></pre>

<p>This is a quirk of the C language.</p>
",6
56400866,56400337,1,"<pre><code>float *a[];
</code></pre>

<p>is an <em>incomplete</em> declaration of an array of pointers to <code>float</code> since it has no size.  At some point there also needs to be a defining declaration that specifies the number of elements, either explicitly or using an initializer:</p>

<pre><code>float *a[];
...
float *a[N];
</code></pre>

<p>or</p>

<pre><code>float *a[];
...
float *a[] = {&amp;a, &amp;b, &amp;c, ...};  // where a, b, c, ..., are objects of type float
</code></pre>

<p>As a member of a <code>struct</code> type, such as</p>

<pre><code>struct foo {
  int something;
  int something_else;
  float *a[];
};
</code></pre>

<p>it's a <em>flexible array member</em> - if you just declare an instance of <code>struct foo</code> like</p>

<pre><code>struct foo bar;
</code></pre>

<p>then it isn't part of the object (you can't acess <code>bar.a[i]</code>).  However, if you allocate the object dynamically, you can specify extra space for the array:</p>

<pre><code>struct foo *p = malloc( sizeof *p + sizeof *(p-&gt;a) * N );
</code></pre>

<p>which is equivalent to defining the struct type as</p>

<pre><code>struct foo { 
  int something;
  int something_else;
  float *a[N];
};
</code></pre>
",0
56400657,56400337,4,"<p>An empty array size can be given if the compiler does not need to know the size of the array.</p>

<p>This is the case in two situations:</p>

<ul>
<li><code>extern</code> declarations</li>
<li>function argument types</li>
</ul>

<p><strong>Example 1:</strong></p>

<pre><code>extern float *a[];
</code></pre>

<p>Using the line above you tell the C compiler that there is an array of <code>float *</code> elements named <code>a</code> in some C file.</p>

<p><strong>Example 2:</strong></p>

<pre><code>void someFunction(float *a[])
</code></pre>

<p>Using that line you specify that the argument type is an array of <code>float *</code> elements.</p>

<p>Both will work because the compiler does not need to know the size of an array to access it. The compiler only needs to know the size to reserve memory for the array.</p>

<p>In both cases (<code>extern</code> and function argument) you will only reference to an existing array (that already occupies memory). Therefore no memory needs to be reserved and the compiler does not need to know the size of the array.</p>
",0
55141769,55141333,0,"<p>You want to convert an IP address in binary form, but this is not what you've been asked to do.</p>

<p>The question you have could be reduced to ""what are the first three bits of this 32bits integer?""</p>

<pre><code>void start_of_ip(int32_t ip4) {

    /* testing if first bit is not set 
    0x80000000 is 1000 0000 0000 0000 0000 0000 0000 0000 */
    if (!(ip4 &amp; 0x80000000)) {
        /* class A IP*/
        puts(""start with b0"")
    } else {    
        /* in this block, we know that first bit is set */

        /* testing if second bit is not set */          
        if (!(ip4 &amp; 0x40000000)) {
            /* class B IP*/
            puts(""start with b10"");
        } else {                
            /* in this block, we know that first two bits are set */

            /* testing if third bit is not set */           
            if (!(ip4 &amp; 0x20000000)) {
                /* class C IP*/
                puts(""start with b110"");
            } else {
                /* the rest */
                puts(""other case"");
            }               
        }
    }
}
</code></pre>
",1
55168012,55167311,6,"<p>Your push and pop functions are overly complicated and totally wrong:</p>

<p>You want this:</p>

<pre><code>void push(int **sp, int value) {
  **sp = value;   // put value onto top of the stack
  (*sp)++;        // increment stack pointer
}

int pop(int **sp) {
  (*sp)--;        // decrement stack pointer
  return **sp;    // return value which is on nthe op of the stack
}
</code></pre>

<p>Your wrong code for push with explanations in comments:</p>

<pre><code>void push(int **sp, int value) {
  int *pt; 
  pt=&amp;value; // here you put the pointer to the local variable value
             // into pt, but local variables disappear as soon
             // as the function has finished

  //  the printf is the only thing one more or less correct
  //  but you could just print directly 'value' like this:
  //    printf(""Pushed value is %d\r\n"", value);
  //
  printf(""Push value is is %d\r\n"", *pt);

  sp = &amp;pt;  // this only assigns the pointer to the local variable pt to 
             // the local variable sp

  ++(*pt);   // here you increment actually the local variable
             // value which is pointless 
}
</code></pre>

<p>By the way: the initialisation to zero of the whole stack is not necessary, although it might help during the debugging process. So you can write the declaration of the stack like this:</p>

<pre><code>int stack[10];  // no initialisation necessary
</code></pre>

<p><strong>Exercise for you:</strong></p>

<p>Explain the exact reason why it is not necessary to initialize all elements of the stack to zero.</p>
",2
55291355,55291265,1,"<p>The first printf prints the first element of arr, and leaves the pointer p alone.  The second printf prints the first element again, and then increments the pointer p after printing, so now p points to the second element of arr.  The third printf gets the second element of p, and then increments it, but leaves p unchanged.  The final printf, increments p, so it is now pointing past the end of arr, and then tries to print out the contents of that address.  There's no way of knowing what will be there.  </p>
",2
55427594,55427556,1,"<p>The number of digits will be the smallest integer greater than <code>log10(value)</code>. So you know exactly what elements of your array will be filled.</p>

<p>Alternately, you could form your array incrementally and then reverse it if you want it in the opposite order.</p>
",1
55782744,55782011,1,"<p>Your code has a lot of problems.</p>

<p>First, you can only <code>free</code> something that was allocated with <code>malloc</code>, <code>calloc</code>, or <code>realloc</code>.  This doesn¡¯t apply to <code>s[i][j]</code>.</p>

<p>But that¡¯s only one issue.  You allocate <code>a</code> to hold <code>m</code> elements:</p>

<pre><code>int * a = (int*) malloc(m*sizeof(int));
</code></pre>

<p>but then you try to write past the end of the array here:</p>

<pre><code>int all=k*m;
for(i=m;i&lt;all;i++)
{
    a[i] = 0;
}
</code></pre>

<p>You need to resize <code>a</code> before attempting that, otherwise you are writing over memory you don¡¯t own:</p>

<pre><code>int *tmp = realloc(a, sizeof *a * all );
if ( !tmp )
{
  // resize failed, exit with error
}
a = tmp;
for( i = m; i &lt; all; i++ )
{
  a[i] = 0;
}
</code></pre>

<p>Then there¡¯s this:</p>

<pre><code>int j;
int n=0;
int s[i][j];
</code></pre>

<p>What is the value of <code>j</code> at this point?  For that matter, what is the value of <code>i</code>?  Are you sure you don¡¯t mean <code>s[m][k]</code>?</p>
",0
55302111,55301438,2,"<p>For the data shown with no space before the commas, you could simply use:</p>

<pre><code>while (fscanf(fp1, ""%d,"", &amp;num) == 1 &amp;&amp; i &lt; 300)
    list[i++] = num;
</code></pre>

<p>This will read the comma after the number if there is one, silently ignoring when there isn't one.  If there might be white space before the commas in the data, add a blank before the comma in the format string.  The test on <code>i</code> prevents you writing outside the bounds of the <code>list</code> array.  The <code>++</code> operator comes into its own here.</p>
",0
54472765,54472112,0,"<p>The documentation and observed behavior of GCC are consistent with each other.</p>

<p><a href=""https://gcc.gnu.org/onlinedocs/gcc-8.2.0/gcc/Structure-Layout-Pragmas.html#Structure-Layout-Pragmas"" rel=""nofollow noreferrer"">GCC Docs</a>:</p>

<blockquote>
  <p>For compatibility with Microsoft Windows compilers, GCC supports a set of #pragma directives that change the maximum alignment of members of structures</p>
  
  <p>[...]</p>
  
  <p>#pragma pack(n) simply sets the new [maximum] alignment</p>
</blockquote>

<p>The resulting size of the struct shows that GCC on Linux is aligning the <code>double</code> on a four-byte (or less) boundary.  Four is less than 8.</p>

<hr>

<p>The documentation and observed behavior of VS are consistent with each other.</p>

<p><a href=""https://docs.microsoft.com/en-us/cpp/preprocessor/pack?view=vs-2017"" rel=""nofollow noreferrer"">VS Docs</a>:</p>

<blockquote>
  <p>Specifies packing alignment for structure, union, and class members.</p>
  
  <p>[...]</p>
  
  <p><code>n</code>
  [...] The alignment of a member will be on a boundary that is either a multiple of <code>n</code> or a multiple of the size of the member, whichever is smaller.</p>
</blockquote>

<p>The size of a <code>double</code> is 8, and the specified maximum alignment is 8.  The size of the structure shows that VS on Windows aligns the double on an 8-byte boundary, just as it should.</p>

<hr>

<blockquote>
  <p>On linux, the alignment seems like 4, not 8. From the doc, it's ""For compatibility with Microsoft Windows compilers"".</p>
</blockquote>

<p>Both compilers accept your pragma.  It has no practical effect on either one.  This is source compatibility with respect to the pragma.</p>

<p>That the default alignment rules for the two compilers differ could be taken as an incompatibility, but that's not an issue of the pragma.  And in this case you can use the pragma to get the same (weaker) alignment of both structures by specifying maximum alignment 4.  Or you should be able to get the stronger alignment with GCC on x86 Linux by via the <code>-malign-double</code> compiler option.</p>

<p>But note well that by looking at VS <em>on Windows</em> and GCC <em>on Linux</em>, you are comparing apples and oranges.  There is no binary compatibility consideration across those platforms.  Consider trying your experiment with a Windows build of GCC, such as MinGW's.  I'm not in a position to test at the moment, but I anticipate that GCC on Windows will conform to Windows alignment conventions by default, and that <code>pragma pack</code> will affect the layout exactly the same way on the GCC/Windows as it does on VS/Windows.</p>
",2
54567788,54567775,3,"<p>An expression like:</p>

<pre><code>bmi &gt;= 18.5 &lt;= 24
</code></pre>

<p>does <em>not</em> do what you think it does. It should be written as:</p>

<pre><code>bmi &gt;= 18.5 &amp;&amp; bmi &lt;= 24
</code></pre>

<hr>

<p>In more detail, the erroneous expression is treated something like<sup>(1)</sup>:</p>

<pre><code>(bmi &gt;= 18.5) &lt;= 24
</code></pre>

<p>where <code>bmi &gt;= 18.5</code> gives you a <code>true/false</code> value represented as <code>1/0</code>. This <code>1</code> or <code>0</code> is then used to compare against <code>24</code>, which is why you seem to be getting bizarre results.</p>

<hr>

<p>In fact, you don't really <em>need</em> to check both ends of the range since the possibilities cover the entire set of input values. I would suggest something like (with common stuff factored out):</p>

<pre><code>printf(""Your health status is "");
if      (bmi &lt;= 18.5) puts(""underweight"");  // [-inf, 18.5]
else if (bmi &lt;= 24.0) puts(""normal"");       // (18.5, 24.0]
else                  puts(""overweight"");   // (24.0, +inf]
</code></pre>

<hr>

<p><sup>(1)</sup> I say ""something like"" since it depends on the evaluation order which I couldn't be bothered looking up at the moment. Firstly, it just decides <em>which</em> of the possible bizarre behaviours you'll see and, secondly, you don't need to worry about it if you just use the correct expression :-)</p>
",1
54567806,54567775,0,"<p>Condition like below:</p>

<pre><code>if (bmi &gt;= 18.5 &lt;= 24)
</code></pre>

<p>should  be </p>

<pre><code>if ((bmi &gt;= 18.5) &amp;&amp; (bmi &lt;= 24))
</code></pre>

<p>Please check through-out your code.</p>
",0
55744270,55742426,2,"<p>The question is what good <code>strtok</code> does in this case. Instead of complicating things you can just do the parsing manually with <code>strchr</code>. Soon as you find the delimiter <code>&amp;</code>, you can expect a trailing space and print that space and the end, not the beginning. Example:</p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
  const char str[256] = ""sleep 5 &amp; echo Hello &amp; sleep 5; echo Hello"";
  size_t length = strlen(str);

  const char* s1 = str;
  const char* s2;
  const char delim = '&amp;';

  while(s1 &lt; str+length)
  {
    s2 = strchr(s1, delim);
    if(s2 == NULL)
    {
      s2 = &amp;str[length]; // point at null term
    }
    else
    {
      s2++; // point at space
    }
    printf(""%.*s\n"", s2-s1, s1); // print (s2-s1) characters
    s1 = s2+1; // point at next char after space, or 1 past null term
  }
}
</code></pre>

<p>Output:</p>

<pre><code>sleep 5 &amp;
echo Hello &amp;
sleep 5; echo Hello
</code></pre>

<p>(Note that it is fine in C to point 1 item past the end of the array, but not to de-reference that address.)</p>
",0
54501389,54501318,0,"<p>To swap strings you need <code>strcpy()</code> (prototype in <code>&lt;string.h&gt;</code>)</p>

<pre><code>            //swap[1][28] = caseName[d][28];
            //caseName[d][28] = caseName[d + 1][28];
            //caseName[d + 1][28] = swap[1][28];
            strcpy(swap[0], caseName[d]);
            strcpy(caseName[d], caseName[d + 1]);
            strcpy(caseName[d + 1], swap[0]);
</code></pre>

<p>Also note that <code>swap[1]</code> as well as <code>casename[j][28]</code> do not exist.</p>

<hr>

<p>Let me add a suggestion (a bit too long for a comment): sort the indexes instead.</p>

<pre><code>int indexes[] = { 0, 1, 2, 3 };
// sort indexes &lt;== YOUR TASK
// indexes now is { 1, 0, 2, 3 }
for (i = 0; i &lt; 4; i++) {
    printf(""%f for %s\n"", year2010Cases[indexes[i]], caseName[indexes[i]]);
}
</code></pre>
",1
55182385,55181995,0,"<p>I am not sure if you are using LilyPad or Leonardo.</p>

<p>I am assuming from the code above that it's LilyPad.  Change the TCCR3B to 256 and see if it corrects the problem for you.</p>

<pre><code>       TCCR3B = 0x0C; // prescaler = 256
</code></pre>
",1
55193679,55193411,0,"<p>There's two main things going on here:</p>

<ol>
<li>When you declare a pointer, e.g. <code>int* x</code>, this creates a global variable to store the <em>location</em> of an array of ints, but it does not create the actual array of ints themselves.  If you just make that declaration and then do <code>*x = 0;</code>, you will get a segfault (probably).  Actually creating the array requires allocating memory with a call to <code>malloc</code>.  <a href=""https://www.programiz.com/c-programming/c-dynamic-memory-allocation"" rel=""nofollow noreferrer"">This article</a> describes the basics.</li>
<li>Multi-dimensional array types are a little funny in C when you use pointers. The way I generally write such code is by representing a matrix as type <code>int**</code>.  A value <code>x</code> of type <code>int**</code> is a pointer to a pointer to a value.  You can write <code>x[2][3]</code> to get the value of the 2nd row/3rd column of the matrix, and similarly assign using <code>x[1][0] = 5</code> (for example).</li>
</ol>

<p>Therefore, I would change the declarations at the beginning to be:</p>

<pre><code>int mul(int** a, int** b);
int i,j,k,**c,**a,**b;
</code></pre>

<p>Then I would write a function to allocate a 3x3 matrix.</p>

<pre><code>int** alloc_matrix(int rows, int cols)
  int** matrix = (int**)malloc(sizeof(int*)*rows);
  for(int i = 0; i &lt; rows; i++) {
    matrix[i] = (int*)malloc(sizeof(int)*cols);
  }
  return matrix;
}
</code></pre>

<p>Then your main function looks like</p>

<pre><code>int main() {
  a = alloc_matrix(3,3);
  b = alloc_matrix(3,3);
  c = alloc_matrix(3,3);
  ...
</code></pre>

<p>You also need to remove the extra dereference operator <code>*</code> in several places to make this work.  That's a homework problem for you :-)</p>

<p>There are also other ways to do this, but this is the most intuitive solution using pointers to me.  You can also do this without pointers at all, by just statically allocating <code>a</code>, <code>b</code>, and <code>c</code> as 3x3 arrays.</p>
",0
57817080,57816226,2,"<p>It is common for a variable of type <code>float</code> to be an IEEE-754 32-bit floating point number.</p>

<p>The number <code>3.14159</code> cannot be stored exactly in an IEEE-754 32-bit float - the closest value is approximately <code>3.14159012</code>.  <code>150 * 150 * 3.14159012</code> is <code>70685.7777</code>, and the closest value to <em>this</em> that can be represented in a 32-bit float is <code>70685.78125</code>, which you are then printing with <code>%.4f</code> so you see <code>70685.7812</code>.</p>

<p>Another way of thinking about this is that your <code>n</code> value only ends up being accurate to the sixth significant figure, so - as you are just calculating a series of multiplications - your result is also only acccurate to the sixth significant figure (ie <code>70685.8</code>).  (In the general case this can be worse - for example subtraction of two close values can lead to a large increase in the relative error).</p>

<p>If you switch to using variables of type <code>double</code> (and change the <code>scanf()</code> to use <code>%lf</code>), then you will likely get the answer you are after.  <code>double</code> is typically a 64-bit float, which means that the error in the representation of your <code>n</code> values and the result is small enough not to affect the fourth decimal place.</p>
",2
55381912,55381682,0,"<p>You probably want this:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

typedef struct lligada {    
  int valor;
  struct lligada *prox;    
} *LInt;

void imprimeL(LInt l) {    
  LInt aux;

  while (l != NULL) {
    printf(""%d\n"", l-&gt;valor);
    aux = l-&gt;prox;
    free(l);
    l = aux;
  }    
}

int main() {    
  LInt l = malloc(sizeof(struct lligada));
  l-&gt;valor = 1;

  LInt l1 = malloc(sizeof(struct lligada));
  l-&gt;prox = l1;

  l1-&gt;valor = 2;
  l1-&gt;prox = NULL;

  imprimeL(l);

  printf(""Ola\n"");
  return 0;
}
</code></pre>

<p>There is also a bug in your <code>imprimeL</code> function.</p>

<p>The next step for you is to create the linked list dynamically with a loop.</p>
",2
58876077,58874183,0,"<p>You are reading 4 or 8 bytes at a time (depending on whether your program is compiled as 32-bit or 64-bit) and checking if the group of 4 or 8 bytes is 10. The only way that can happen is if 1 of the bytes is 10 (either the first or last, depending on the type of computer) and all the rest of the bytes are 0. 0 bytes are not valid in text files so presumably this never happens.</p>

<p>You should read a char at a time from the file instead of an int.</p>
",0
55250212,55250078,4,"<p>The string literal <code>""Hello World""</code> has ""static storage duration"". Practically this means it is not on the ""stack"".  The Standard doesn't specify whether identical string literals are ""collapsed"" into one instance or not.</p>

<p>From C11 6.4.5: String Literals</p>

<blockquote>
  <ol start=""6"">
  <li>... The multibyte character
  sequence is then used to initialize an array of static storage duration and length just
  sufficient to contain the sequence. 
  ...<br>
  7 It is unspecified whether these arrays are distinct provided their elements have the
  appropriate values. If the program attempts to modify such an array, the behavior is
  undefined</li>
  </ol>
</blockquote>

<hr>

<p>""Stack"" is in quotes above, because the standard doesn't ever mention ""Stack"" or ""Heap"" or ""ROM"".  There's only ""automatic"" or ""allocated"" or ""static"" storage duration.  Most compilers do have a one-to-one mapping of the concepts.</p>
",0
56590536,56590299,1,"<p>Your logic is flawed, as you won't be counting the last ""word"" (<code>hi8</code>) as a word. Similarly you won't count ""numbers"" if they are last in the string. This could be found out through some <a href=""https://ericlippert.com/2014/03/05/how-to-debug-small-programs/"" rel=""nofollow noreferrer"">debugging</a>.</p>

<p>One possible solution is to use <em>states</em>. One state that tells if you are in a word or not, and another state that tells if the current word is all digits or not.</p>

<p>Using states, when looping over the string you check if the current character <a href=""https://en.cppreference.com/w/c/string/byte/isalnum"" rel=""nofollow noreferrer"">is an alpha-numeric character</a>. If it is, and the is-a-word state is not set then set that state. When changing the state, then also check if the current character <a href=""https://en.cppreference.com/w/c/string/byte/isdigit"" rel=""nofollow noreferrer"">is a digit</a> and if it is then set the is-number state. Continuing the loop, if is-a-word state is set, and the current character is <em>not</em> a digit, then you clear the is-number state. When reaching something that <a href=""https://en.cppreference.com/w/c/string/byte/isspace"" rel=""nofollow noreferrer"">is a space</a> then you check your states: If is-a-word is set, then clear it and increase the word counter; If is-number state is set, then increase the number counter and clear the state.</p>

<p>In <em>pseudo</em> code it could be something like this:</p>

<pre><code>is-a-word-state = false
is-a-number-state = false

for each character in string
{
    if (current-character is alphanumeric and is-a-word-state == false)
    {
        // Started a new word
        is-a-word-state = true

        if (current-character is digit)
        {
            // Could be a number
            is-a-number-state = true
        }
    }

    if (current-character is not digit)
    {
        // Current word (if any) is not a number
        is-a-number-state = false
    }

    if (current-character is space)
    {
        if (is-a-word-state == true)
        {
            // End of the current word
            word-counter++

            if (is-a-number-state == true)
            {
                // Word is a number
                number-counter++
            }
        }

        is-a-word-state = false
        is-a-number-state = false
    }
}
</code></pre>
",2
55967423,55967234,5,"<p>You do not show us enough. However, I assume:</p>

<pre><code>void myFunction(...)
{
    char topick []=""/mqtt_topic/myID/"";
    char* topic=topick;
    mqtt_subscribe(module_inst, topic, 0, SubscribeHandler);
    //...
}
</code></pre>

<p>or something like this, i.e. <code>topick</code> is declared inside a function. Then it is a local variable that ceases to exist when the function returns. The pointer to a string you passed does no longer point to a valid string.</p>

<p>On the other hand:</p>

<pre><code>char* topic=""/mqtt_topic/myID/"";
mqtt_subscribe(module_inst, topic, 0, SubscribeHandler);
</code></pre>

<p>Here <code>topic</code> points to a literal and the literal remains to exist after the function returns. So the <code>mqtt_..</code> function receives a valid string that also exists after the caller returns.</p>
",0
55401842,55399820,1,"<p>Taking the question as posed in the title literally,</p>

<blockquote>
  <p>Why is the statement ¡°f == (float)(double)f;¡± wrong?</p>
</blockquote>

<p>the statement is ""wrong"" not in any way related to the representation of floating point values but because it is trivially optimized away by any compiler and thus you might as well have saved the electrons used to store it. It is exactly equivalent to the statement</p>

<pre><code>1;
</code></pre>

<p>or, if you like, to the statement (from the original question)</p>

<pre><code>x == (int)(double)x;
</code></pre>

<p>(which has exactly the same effect as that in the title, regardless of the available precision of the types <code>int</code>, <code>float</code>, and <code>double</code>, i.e. none whatsoever).</p>

<p>Programming being somewhat concerned with precision you should perhaps take note of the difference between a <em>statement</em> and an <em>expression</em>. An <em>expression</em> has a value which might be true or false or something else, but when you add a semicolon (as you did in the question) it becomes a <em>statement</em> (as you called it in the question) and in the absence of side effects the compiler is free to throw it away.</p>
",2
55400814,55399820,11,"<p>Assuming <a href=""https://en.wikipedia.org/wiki/IEEE_754"" rel=""nofollow noreferrer"">IEC 60559</a>, the result of <code>f == (float)(double) f</code> depends on the type of <code>f</code>.</p>

<p>Further assuming <code>f</code> is a <code>float</code>, then there's nothing ""wrong"" about the expression - it will evaluate to <code>true</code> (unless <code>f</code> held <a href=""https://en.cppreference.com/w/c/numeric/math/isnan"" rel=""nofollow noreferrer""><code>NaN</code></a>, in which case the expression will evaluate to <code>false</code>).</p>

<p>On the other hand, <code>x == (int)(double)x</code> (assuming <code>x</code> is a <code>int</code>) is (potentially) problematic, since a double precision IEC 60559 floating point value only has 53 bits for the significand<sup>1</sup>, which cannot represent all possible values of an <code>int</code> if it uses more than 53 bits for its value on your platform (admittedly rare). So it will evaluate to <code>true</code> on platforms where <code>int</code>s are 32-bit (using 31 bits for the value), and might evaluate to <code>false</code> on platforms where <code>int</code>s are 64-bit (using 63 bits for the value) (depending on the value).</p>

<p>Relevant quotes from the C standard (6.3.1.4 and 6.3.1.5) :</p>

<blockquote>
  <p>When a value of integer type is converted to a real floating type, if the value being converted can be represented exactly in the new type, it is unchanged.</p>
</blockquote>

<p>&nbsp;</p>

<blockquote>
  <p>When a finite value of real floating type is converted to an integer type other than <code>_Bool</code>, the fractional part is discarded (i.e., the value is truncated toward zero). If the value of the integral part cannot be represented by the integer type, the behavior is undefined.</p>
</blockquote>

<p>&nbsp;</p>

<blockquote>
  <p>When a value of real floating type is converted to a real floating type, if the value being converted can be represented exactly in the new type, it is unchanged.</p>
</blockquote>

<p>&nbsp;</p>

<hr>

<p><sup>1</sup> a double precision IEC 60559 floating point value consists of 1 bit for the sign, 11 bits for the exponent, and 53 bits for the significand (of which 1 is implied and not stored) - totaling 64 (stored) bits.</p>
",8
55412752,55399820,0,"<p><code>NaN</code>s are retained through float => double => float, but they not equal themselves.</p>

<pre><code>#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

int main(void) {
    float f = HUGE_VALF;
    printf(""%d\n"", f == (float)(double) f);
    f = NAN;
    printf(""%d\n"", f == (float)(double) f);
    printf(""%d\n"", f == f);
}
</code></pre>

<p>Prints</p>

<pre><code>1
0 
0
</code></pre>
",0
58177271,58176356,0,"<p>To see the data that encodes a floating-point object, one can use:</p>

<pre><code>#include &lt;inttypes.h&gt; // For printf format PRIx32.
#include &lt;stdint.h&gt;   // For uint32_t.
#include &lt;string.h&gt;   // For memcpy.
...
// Copy bytes of float num into bytes of uint32_t x.
uint32_t x;
_Static_assert(sizeof x == sizeof num, ""num must be 32 bits.""); // Check size.
memcpy(&amp;x, &amp;num, sizeof x);

// Print x as a hexadecimal numeral.
printf(""0x%"" PRIx32 ""\n"", x);
</code></pre>

<p>The value in <code>x</code> is a number. Whether it is printed as hexadecimal or decimal, the same value is printed, just in different bases. This does not change the number in <code>x</code>. Printing it in hexadecimal is more useful for humans to be able to see the components of the floating-point format in the display. But the value is the same regardless of whether it is shown in hexadecimal or decimal.</p>
",0
58177219,58176356,0,"<blockquote>
  <p>... to get the hexadecimal representation of a floating point value</p>
</blockquote>

<p>Simply use <code>""%a\n""</code></p>

<pre><code>printf(""%a\n"", 263.3f);  // May print `0x1.074cccp+8
</code></pre>
",1
58635602,58634957,2,"<p>An integer comprised of only <em>decimal</em> 1 and 0 digits is not <em>binary</em>.  An <code>int</code> on a computer is already binary; the <code>%d</code> format specifier creates a <em>character string representation</em> of that value in <em>decimal</em>.  It is mathematically nonsensical to generate a binary value that when represented as a decimal looks like some other binary value.  Not least because that approach is good for only a 10 bit value (on a 32 bit int), or 19 bits using a 64bit int.  </p>

<p>Moreover, the solution requires further consideration (and more code) to handle negative integer values - although how you do that is ambiguous due to the limited number of bits you can represent. </p>

<p>Since the <code>int</code> is already a binary value, it is far simpler to present the binary bit pattern directly than to calculate some decimal value that happens to resemble a binary value:</p>

<pre><code>    // Skip leading zero bits
    uint32_t mask = 0x80000000u ;
    while( mask != 0 &amp;&amp; (integer &amp; mask) == 0 ) mask &gt;&gt;= 1 ;

    // Output remaining significant digits 
    printf(""The integer in binary is "");
    while( mask != 0 )
    {
        putchar( (integer &amp; mask) == 0 ? '0' : '1' ) ;
        mask &gt;&gt;= 1 ;
    }
    putchar( '\n' ) ;
</code></pre>
",0
56781427,56779250,0,"<p>First of all, this statement is flat-out wrong:</p>

<pre><code>printf(""\n Float in hex: %x"",uninObj.flotVal);
</code></pre>

<p><code>%x</code> expects its corresponding argument to be <code>unsigned int</code>, and passing an argument of a different type (as you do here) results in undefined behavior - the output could literally be anything.  </p>

<p>As of C99, you can use the <code>%a</code> or <code>%A</code> specifiers to print a hexadecimal representation of the floating-point <em>value</em> (<code>[+|-]<em>x</em>.<em>xxxx</em>...</code>, where each <em><code>x</code></em> is a hex digit).  This is not the same thing as the value's binary representation in memory, though.  </p>

<p>For the union, I'd suggest you use <code>unsigned char</code> for <code>chrArray</code> and use <code>%hhx</code> to print out each byte:</p>

<pre><code>union unin
{
    unsigned char chrArray[sizeof (float)];
    float flotVal;
}uninObj;

printf(""%hhx %hhx %hhx %hhx"",uninObj.chrArray[0], uninObj.chrArray[1], 
       uninObj.chrArray[2], uninObj.chrArray[3]);    
</code></pre>

<p>The <code>hh</code> length modifier in <code>%hhx</code> says that the corresponding argument has type <code>unsigned char</code>, rather than the <code>unsigned int</code> <code>%x</code> usually expects.  </p>
",0
55473506,55473121,0,"<blockquote>
  <p>Would the CRC resulting from all of these chars be called via <code>crc16(someChars, sizeof(someChars)/sizeOf(someChars[0]))</code>..?</p>
</blockquote>

<p>If <code>someChars</code> is a <code>char</code> array then most likely yes (once you fix the code, <code>sizeOf</code> ¡ú <code>sizeof</code>). Note that you don¡¯t need to divide by <code>sizeof(someChars[0])</code> since the size of a <code>char</code> in C is defined to be 1.</p>

<blockquote>
  <p>Also, would I have to use <code>uint8_t</code> type for my array?</p>
</blockquote>

<p>The function you posted doesn¡¯t, so it makes no sense to pass a <code>uint8_t</code> buffer to it. That said, it would definitely be better to use an array of <code>uint8_t</code> for raw bytes, and to modify the function accordingly.</p>
",2
55473651,55473121,0,"<blockquote>
  <p>byte is an integer value used to update the current CRC. Only the lowest 8 bits of the parameter are used.</p>
</blockquote>

<p>CRC doesn't work like that. Function like the one you posted expect to be given a full data package. There's two options of how to use such a function: </p>

<ul>
<li>Either the package contains only data in which case the function will calculate the FCS (frame check sequence) that should be stored in the end of the package.</li>
<li>Or the package contains data + FCS, in which case you can call the very same function and get a boolean value 0 if successful, or non-zero in case of errors.</li>
</ul>

<p>Calling the function ""to update the current CRC"" doesn't make any sense, because the function doesn't retain the previous FCS but starts at blank data, all ones = 0xFFFF, as required by CRC16-CCITT. If you wish to continuously update the FCS, you would have to save it then pass it to the function with each call.</p>

<p>In addition, the algorithm itself got a bug, <code>char</code> should not be used for raw data since it might be signed. Indeed you should be using <code>uint8_t</code> instead.</p>

<p>For some reason this code is written in obsolete K&amp;R style. Given the low quality of this code... be wary of lots of rotten and incorrect implementations of CRC16-CCITT floating around on the internet. I was using a rotten one for many years which looked a lot like this one. Until I found out it wasn't actually CRC16-CCITT but non-standard.</p>

<p>It sounds like what you actually want is a lookup-table version, which does 16/8/4 bit look-ups, depending on how much ROM memory you can afford for it.</p>
",1
55473378,55473121,3,"<p>There are many alternative algorithms to compute this CRC: some use lookup tables, some use bit operations, some flip some bits, some flip some other bits...</p>

<p>The <code>CRCname.put(int byte)</code> function you mention most likely is an update to the CRC being calculated. That is, it computes a single iteration of your inner <code>do/while</code> loop, using the passed byte (actually a <code>unsigned char</code> instead of an <code>int</code>) as the value for your <code>data</code> local variable.</p>

<p>In the unknown <code>CRCname</code> type there is probably a member variable that stores your <code>crc</code> variable, a constructor that sets it to its intitial value and a <code>int CRCname.getFinalCrcValue()</code> that does the final computation.</p>

<p>Anyway, if you do not have any example to compare your output with, it is quite unlikely you'll get it right. Too many things that can go wrong.</p>

<p>About the <code>uint8_t</code> type, it does not matter too much, unless your <code>CHAR_BITS</code> value is different from <code>8</code>, and if that is the case you have bigger problems!</p>
",0
55871917,55870743,1,"<p>Your format specifiers are correct, but you are multiplying <code>num1</code> with <code>num2</code> before initializing either with the call to <code>scanf</code>. If you move the initialization of <code>total_multi</code> after your call to <code>scanf</code>, you do not have this problem.</p>

<p>Also, when using <code>scanf</code> to read user input it is strongly recommended that you check that its return value matches the number of format specifiers in the format string:</p>

<pre><code>double num1, num2;
double total_multi;

if(scanf(""%lf %c %lf"", &amp;num1, &amp;symbol, &amp;num2) != 3)
{ 
     /* Handle scanf failure */ 
}
total_multi = num1 * num2;
</code></pre>

<p>On a less urgent note, <code>%lf</code> in a <code>printf</code> (rather than <code>scanf</code>) format string is redundant because <code>%f</code> applies to the type <code>double</code> and <code>float</code> values are automatically promoted to <code>double</code>.</p>
",0
55872634,55870743,0,"<p>You are using the correct format, if you pretend to work with <code>long</code> and <code>float</code> values. </p>

<p>But you must move your code to multiply numbers inside the case for <code>*</code>. In that moment, you already have the values read.</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdio.h&gt;

int main() {
    char symbol;
    double num1, num2, total_multi;

    scanf(""%lf %c %lf"", &amp;num1, &amp;symbol, &amp;num2);


    switch(symbol){
        case '*':
            total_multi = num1*num2;
            printf(""The answer is: %lf * %lf = %lf"", num1, num2, total_multi);
            break;
    }
    return 0;
}
</code></pre>
",0
54692482,54692322,3,"<p>You are breaking your <code>result.data</code> pointer by incrementing it in <code>loadMatrix</code>. It no  longer points to start of the allocated memory when you try to print or free it.</p>

<p>Replace pointer arithmetric nonsense with array indexing to avoid messing the pointer and making the code more simple:</p>

<pre><code>for(int i = 0; i &lt; rows * cols; i++) {
  result.data[i] = elements[i];
}
</code></pre>

<p>Note that you have the same problem in <code>printMatrix</code> function, but since you don't return the modified copy, it has no effect further in the code. Still I would recommend using array indexing there too.</p>
",0
54692526,54692322,3,"<p>In this loop:</p>

<pre><code>  for(int i = 0; i &lt; rows * cols; i++) {
    *result.data = *elements; //copy each element to Matrix instance
    result.data++;
    elements++;
  }
</code></pre>

<p>You're changing what <code>result.data</code> points to on each iteration of the loop.  When the loop ends, it points to the <em>end</em> of the allocated array.</p>

<p>When you subsequently print the array:</p>

<pre><code>  for(int i = 0; i &lt; m.rows; i++) {
    for(int j = 0; j &lt; m.cols; j++) {
      printf(""%.0lf "", *m.data);
      m.data++;
    }
    printf(""\n"");
  }
</code></pre>

<p>You read past the end of the array <em>and</em> move <code>m.data</code> further past the end of the array.  This invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.  You further invoke undefined behavior when you call <code>free</code> because <code>m.data</code> no longer points to the value returned by <code>malloc</code>.</p>

<p>You can fix this by using array indexing syntax in both places instead of modifying the pointer value.</p>

<p>In <code>loadMatrix</code>:</p>

<pre><code>  for(int i = 0; i &lt; rows * cols; i++) {
    result.data[i] = elements[i];
  }
</code></pre>

<p>In <code>printMatrix</code>:</p>

<pre><code>  for(int i = 0; i &lt; m.rows; i++) {
    for(int j = 0; j &lt; m.cols; j++) {
      printf(""%.0lf "", m.data[i*m.rows+j);
    }
    printf(""\n"");
  }
</code></pre>
",0
55328231,55328191,0,"<pre><code> char letter1 =""i"";
</code></pre>

<p>Unfortunately, <code>""i""</code> is a string. Use <code>'i'</code> for characters or <code>""i""[0]</code> if you really want to.</p>

<p>If your compiler didn't give you a warning, it's either a terrible compiler or you don't have appropriate warnings turned on. If you got a warning and you ignored it ...</p>
",0
56741043,56740395,1,"<p>It's a <a href=""https://en.wikipedia.org/wiki/Data_structure"" rel=""nofollow noreferrer"">data structure</a> because it's collection of data and the tools to work it.</p>

<p>Primary features:</p>

<ul>
<li>Extremely fast lookup by index.</li>
<li>Extremely fast index-order traversal.</li>
<li>Minimal memory footprint (not so with the optional modifications I mentioned).</li>
</ul>

<p>Insertion is normally O(N) because you may need to copy the array when you reallocate the array to make space for new elements. However, you can bring the cost of appending down to amortized O(1) by over-allocating (i.e. by doubling the size of the array every time you reallocate).<sup>[1]</sup></p>

<p>Deletion is O(N) because you will need to shift N/2 elements on average. You could keep track the number of unused elements at the start and end of the array to make removals from the ends O(1).<sup>[1]</sup></p>

<p>Lookup by index is O(1). It's a simple pointer addition.</p>

<p>Lookup by value is O(N). If the data is ordered, one can use a binary search to reduce this to O(log N).</p>

<hr>

<ol>
<li>Keeping track of the first used element and the last used element would technically qualify as a different data structure because the functions to access the data structure are different, but it would still be called an array.</li>
</ol>
",0
54717921,54717866,0,"<p>There is lots of nonsense in there. <code>vector_print</code> does not return anything so its return type should be <code>void</code>. Same for <code>vector_add</code>.</p>

<p><code>vector_print</code> <em>prints</em> the value. The <code>{ }</code> brace block is nonsense, too. Try this:</p>

<pre><code>printf(""z is "")
vector_print(z);
printf(""\n"");
</code></pre>

<p>To add space after the components and cut decimals, use <code>""%g ""</code></p>
",0
58692454,58687294,0,"<p>Recursion FTW!!</p>

<pre><code>int minimum(int *array, size_t len) {
    assert(len &gt; 0);
    if (len == 1) {
        return *array;
    } else {
        int tmp = minimum(array + 1, len - 1);
        return tmp &lt; *array ? tmp : *array;
    }
}
</code></pre>

<p>and similar for <code>maximum()</code></p>
",0
58692376,58687294,1,"<p>Unrolling it and use <code>max</code> in a switch-case.<br>
This is a Duff's device without loop.</p>

<pre><code>i=max;
switch (max) 
{
case 8:
    arr[i]= arr[i-1];    ArrMin = ArrMin.min(arr[i]);    ArrMax = ArrMax.max(arr[i]);
    i--;
case 7:
    arr[i]= arr[i-1];    ArrMin = ArrMin.min(arr[i]);    ArrMax = ArrMax.max(arr[i]);
    i--;
case 6:
    arr[i]= arr[i-1];    ArrMin = ArrMin.min(arr[i]);    ArrMax = ArrMax.max(arr[i]);
    i--;
case 5:
    arr[i]= arr[i-1];    ArrMin = ArrMin.min(arr[i]);    ArrMax = ArrMax.max(arr[i]);
    i--;
case 4:
    arr[i]= arr[i-1];    ArrMin = ArrMin.min(arr[i]);    ArrMax = ArrMax.max(arr[i]);
    i--;
case 3:
    arr[i]= arr[i-1];    ArrMin = ArrMin.min(arr[i]);    ArrMax = ArrMax.max(arr[i]);
    i--;
case 2:
    arr[i]= arr[i-1];    ArrMin = ArrMin.min(arr[i]);    ArrMax = ArrMax.max(arr[i]);
    i--;
    arr[i]= arr[i-1];    ArrMin = ArrMin.min(arr[i]);    ArrMax = ArrMax.max(arr[i]);
    i--;
}
</code></pre>
",0
58305506,58305170,0,"<p>Well, in your description you say that you need to take <strong>one</strong> input. However, your program reads <strong>two</strong> inputs.</p>

<p>Maybe this is what you need:</p>

<pre><code>#include &lt;stdio.h&gt;
int sum(int x, int y)
{
 return y == 0 ? x : sum(x+1, y-1);
}
int main(void)
{
 int x;
 if (scanf(""%d"", &amp;x) != 1)  // Only 1 input
 {
    // Input error
    return -1;
 }
 int z = sum(x, x);    // Use x for both arguments
 printf(""%d\n"", z);
 return 0;
} 
</code></pre>

<p>This works because the <code>sum</code> functions increments one argument and decrements the other in the recursive call and continues doing that until one of the arguments reach zero. In this way the end result will be <code>2 * x</code></p>

<p>Let's say the input is 3. Then you'll have these calls:</p>

<pre><code>sum(3, 3)
sum(4, 2)
sum(5, 1)
sum(6, 0) // Which will end the recursion and return 6 all the way up
</code></pre>
",1
55445299,55444603,1,"<p>The source code you show gets a warning about an incompatible definition of <code>exit</code> because:</p>

<ul>
<li><code>exit</code> is a reserved identifier; it should be used only for the standard library routine named <code>exit</code>.</li>
<li>Your program does not include the <code>&lt;stdlib.h&gt;</code> that would provide a declaration of <code>exit</code>.</li>
<li>Your program uses <code>exit</code> without a declaration for it. When a routine is used without a declaration, your compiler supplies a default declaration.</li>
<li>The default declaration is for a function returning <code>int</code>, but the correct declaration for <code>exit</code> is a function returning nothing (<code>void</code>), so the compiler warnings you the declaration (provided by default) is incompatible with the built-in standard function.</li>
</ul>

<p>To fix this, insert <code>#include &lt;stdlib.h&gt;</code> in your program.</p>
",3
56497992,56493496,1,"<p>First of all, remember that the binary representations of <code>int</code> and <code>float</code> values are <em>very</em> different from each other.  The representations for the integer value <code>1</code> and the floating point value <code>1.0</code> don't look <em>anything</em> like each other.  Assuming 32-bit <code>int</code> and <code>float</code> and IEEE-754 representation, we get:</p>

<pre><code>  1: 0000 0000 0000 0000 0000 0000 0000 0001 (0x00000001)
1.0: 0111 1111 1000 0000 0000 0000 0000 0000 (0x3f800000)
</code></pre>

<p>Assigning a <code>float</code> value to an <code>int</code> object <em>truncates</em> the fractional portion - if you write something like</p>

<pre><code>int b = 1.2f; // 0x3f99999a
</code></pre>

<p>the value stored in <code>b</code> is <code>1</code> (<code>0x00000001</code>).  If you try to assign <code>b</code> back to a <code>float</code>, such as</p>

<pre><code>float f = b;  
</code></pre>

<p>then the value stored in <code>f</code> is <code>1.0</code> (<code>0x3f800000</code>), <em>not</em> <code>1.2</code> (<code>0x3f99999a</code>)</p>

<p>So you cannot store a <code>float</code> <em>value</em> in an <code>int</code> object through simple assignment.</p>

<p>You can store the <em>bit pattern</em> for a floating-point value in an <code>int</code> object <em>if</em> the <code>int</code> is at least as wide as the <code>float</code>, either by using <code>memcpy</code> or some kind of casting gymnastics (as other answers have shown).  However, if you try to print that value using <code>printf</code> with the <code>%d</code> conversion specifier, the output won't be a representation of that <code>float</code> value (<code>1.2</code>), it will be a representation of the <em>integer</em> value represented by that bit pattern (<code>1067030938</code>).  </p>

<p>There is no safe, well-defined, standard way of storing a floating point <em>value</em> in an integer object and have it be treated like any other floating point object.  C may not be as strongly typed as other languages, but it's strong <em>enough</em> such that you have to rely on unsafe hacks to get around it (as have been demonstrated in other answers).  </p>
",0
56493586,56493496,4,"<p>If you want to see the bit pattern of your <code>float</code> variable you could do this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;string.h&gt;

int main(void) {
    uint8_t bitpattern[sizeof (float)];
    float f = 3.1414;
    memcpy(bitpattern, &amp;f, sizeof (float));

    for (int i = 0; i &lt; sizeof (float); i++)
      printf(""%02x "", bitpattern[i]);
}
</code></pre>
",13
56340982,56340571,0,"<p>The realloc code you wrote will destroy the strings stored previously. e.g. in case of data size increase from 2 to 4, the first 2 strings will be lost. </p>

<p>You can modify the realloc portion as follows.</p>

<pre><code>int prevcapacity;
if (vec-&gt;size == vec-&gt;capacity)
{
    prevcapacity = vec-&gt;capacity;    
    if (vec-&gt;capacity == 0)
        vec-&gt;capacity = 1;
    else
        vec-&gt;capacity *= 2;

    vec-&gt;elements = (char **)realloc(vec-&gt;elements, vec-&gt;capacity *sizeof(char *));
    for (int i = prevcapacity; i &lt; vec-&gt;capacity; i++)
    {
        vec-&gt;elements[i] = malloc(vec-&gt;elements[i], 100*sizeof(char));
    }
}
</code></pre>

<p>In this case, you can use <code>malloc</code> on the extra strings allocated. The previous strings will be preserved. </p>
",0
55597089,55596967,0,"<p>Where you have:</p>

<pre><code>int main();

  const char *animalArray[] = {
</code></pre>

<p>you should have:</p>

<pre><code>int main()
{
  const char *animalArray[] = {
</code></pre>
",2
55597106,55596967,1,"<p>The error is saying you didn't provide a <code>main()</code> function. Looking at your code I see the following:</p>

<pre><code>int main();
</code></pre>

<p>This is a function declaration not a definition. It looks like you've forgotten the curly braces around the body of your <code>main()</code> function.</p>

<p>I also see you keep putting a semicolon after the closing bracket of all your functions. This isn't required and makes me wonder what terrible resource you're using to learn C.</p>

<p>Edit:</p>

<p>Your <code>fillWordsearch()</code> function has unbalanced curly braces. It's missing a <code>}</code> brace somewhere.</p>
",9
55147801,55147440,1,"<p>You would need to rewrite the expression:</p>

<pre><code>if(*pInput == (' ' || '\t' || '\n'))
</code></pre>

<p>as</p>

<pre><code>if(*pInput ==' ' || *pInput =='\t' || *pInput =='\n'))
</code></pre>

<p>or </p>

<pre><code>if ( strchr("" \t\n"" , *pInput) != NULL)
</code></pre>
",0
55148836,55147440,0,"<p>The <code>||</code> operator evaluates its second operand only if the first operand evaluates to 0.</p>

<p>So in <code>' ' || '\t' || '\n'</code> the last operand is never evaluated because <code>' ' || '\t'</code> is non-zero.</p>

<p>On the other hand, you want to write something like</p>

<pre><code>(*pInput == ' ') || (*pInput == '\t') || (*pInput == '\n')
</code></pre>

<p>Other mistake you did, you forgot to insert the final <code>0</code> in the string <code>input</code></p>

<pre><code>while((c = fgetc(pFile)) != EOF){
    *pInput = c;
    ++pInput;
}

fclose(pFile);
pFile = NULL;
*pInput = 0;       /* THIS IS IMPORTANT */
pInput = input;  

while(*pInput)
</code></pre>
",0
55147686,55147440,4,"<p>It's not saying that the statement will not be executed, just specific expressions within it. The warning message looks like this:</p>

<pre><code>testcompare.c:67:35: warning: code will never be executed [-Wunreachable-code]
    if(*pInput == (' ' || '\t' || '\n'))
                                  ^~~~
testcompare.c:67:27: warning: code will never be executed [-Wunreachable-code]
    if(*pInput == (' ' || '\t' || '\n'))
                          ^~~~
</code></pre>

<p>Notice the arrows pointing to <code>'\n'</code> and <code>'\t'</code>, those are what it's saying will never be executed.</p>

<p>The <code>||</code> operator is a short-circuiting operator, it only executes the right operand if the left operand is falsey.</p>

<p>In this case, since the <code>' '</code> is a constant, and it's known to be truthy (any <code>char</code> other than <code>'\0'</code> is truthy), the other two operands do not need to be executed to determine the result.</p>
",0
55422981,55422918,2,"<p>It's been a while since I've written C or C++, but I believe you can use memcpy to do what you desire.  </p>

<pre><code>memcpy(c, &amp;value, 4);
</code></pre>

<p>This should copy 4 bytes from the address of value into the bytes you allocated from c.  If you wanted to be sure about the size of the integer, you could use sizeof(int) instead of 4.  So that would be</p>

<pre><code>memcpy(c, &amp;value, sizeof(int));
</code></pre>
",0
59114744,59114723,0,"<p>The file you're looking for is actually called <a href=""https://github.com/spotify/linux/blob/master/include/linux/kmalloc_sizes.h"" rel=""nofollow noreferrer"">kmalloc_sizes.h</a>.</p>

<p>You can get it by installing the Linux kernel headers:</p>

<pre><code>sudo apt-get install linux-headers-$(uname -r)
</code></pre>

<p>Ref: <a href=""https://askubuntu.com/questions/75709/how-do-i-install-kernel-header-files"">https://askubuntu.com/questions/75709/how-do-i-install-kernel-header-files</a></p>
",3
55558027,55557936,2,"<p>Here:</p>

<pre><code>char* temp;
strncpy(temp, decode_structure[0], 20);
</code></pre>

<p>you are using as the destination of the copy, an uninitialized pointer, which invokes Undefined Behavior (UB).</p>

<p>Use <code>char temp[20];</code> instead, or if you really want a pointer, then use malloc to dynamically allocate memory, that will be pointed by the pointer, like this: <code>char* temp = malloc(sizeof(char) * 20);</code>.</p>
",0
54940215,54939962,1,"<p>The floating point representation in Standard C is decomposed in 3 groups: sign, mantissa, exponent.  <a href=""https://stackoverflow.com/questions/588004/is-floating-point-math-broken"">Here</a> you can see how to print it, reading it bit with bit and other informations about the floating point implemented by the C standard.</p>
",0
56015581,56015037,0,"<p>If you want to read back and print then try to capture the start position of the file before writing the file with <code>fpos_t</code> and <code>fgetpos()</code> . Later after writing to file set back the initial position using <code>fsetpos()</code> and use <code>fget()</code> to read the content and print them. Check the modified code as below-</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

struct person
{
    int id;
    char lastName[15];
    char firstName[15];
    char age[4];
};


int main(void) {
  //create new file
  FILE *fp = fopen(""file.dat"", ""wb+"");
  fpos_t position;


  struct person a = {10, ""Smith"", ""John"", ""25""};
  fwrite(&amp;a, sizeof(a), 1, fp);

  struct person b = {2, ""Ali"", ""Jon"", ""12""};
  fwrite(&amp;b, sizeof(b), 1, fp);

  struct person c = {19, ""Walter"", ""Martha"", ""82""};
  fwrite(&amp;c, sizeof(c), 1, fp);

  fseek(fp, 0, SEEK_SET);

  struct person p; 
  while(fread((void *)&amp;p, sizeof(p),1,fp)==1)
  {
    printf(""%d\n"",p.id);
    printf(""%s\n"",p.lastName);
    printf(""%s\n"",p.firstName);
    printf(""%s\n"",p.age);    
    printf(""\n"");
  }
}
</code></pre>
",5
55531022,55530965,0,"<p>Because on the left you have a variable and on the right a constant the result is to set all the corresponding 1 bits from the constant in the variable. In this case you¡¯re right: it sets the last bit. No bit count increase occur!</p>
",2
56062377,56062216,2,"<p><code>char names[LINE][LENGH]</code> is a 2D array of characters. <code>char* names[LENGH]</code> is a 1D array of character pointers. Like your compiler is telling you if you bother reading the warnings/errors: the types are not compatible.</p>

<p>Change the functions to <code>void print_names(char names[LINE][LENGH], int line)</code>.</p>
",1
54357521,54357425,1,"<pre><code>while(value[i] != '\0');
</code></pre>

<p>This is your most <em>obvious</em> problem, it basically means:</p>

<pre><code>while value[i] != '\0':
    do nothing
end while
</code></pre>

<p>In other words, if it <em>enters</em> the loop, it will <em>never</em> exit it, because nothing changes that would affect the condition under which the loop continues.</p>

<hr>

<p>There are <em>other</em> problems as well such as the fact that you will only process the first line rather than the whole file. The whole idea of using <code>fgets</code> and processing a line is unnecessary when you can just start with the following filter skeleton:</p>

<pre><code>int ch;
while ((ch = getchar()) != EOF) {
    /* process ch */
}
</code></pre>

<p>This will process an entire file character by character until all characters are done (or until an error occurs) so you can just tailor the body loop to do what you need - you've basically done that bit in your code with the loop over the line characters.</p>

<p>I would suggest <em>not</em> using the following code (since this is classwork) but you can also make better use of flow control constructs and library functions (from <code>ctype.h</code> and <code>string.h</code>), something like:</p>

<pre><code>while ((ch = getchar()) != EOF) {
    // Lib functions to detect upper/lower-case letters.

    if (isupper(ch)) {
        ++upper;
    } else if (islower(ch))
        ++lower;
    }

    // And to detect letter/digit type.

    if (strchr(""aeiouAEIOU"", ch) != NULL) {
        ++vowel;
    } else if (isalpha(ch)) {
        ++consonant;
    } else if (isdigit(ch)) {
        ++digits;
    }

    ++total;
}
</code></pre>

<p>This is <em>particularly</em> important since there's no actual guarantee that non-digit characters will be consecutive.</p>
",1
54357464,54357425,4,"<p>Remove the semicolon after the while statement. :-)</p>
",3
54444073,54442970,1,"<p>If your structure does not contain any members that are pointers (or containing structs that do), then you can simply assign one to the other.</p>

<pre><code>second = first;
</code></pre>

<p>If however your structs do contain pointers, then with a simple assignment you end up with two struct that contain pointers to the same memory, and changing one will affect the other.  If that's not what you want then you need to do a deep copy.</p>

<p>For example:</p>

<pre><code>struct book {
    char *name;
    int cost;   // in cents, so you don't have to deal with floating point issues
};

struct book first;
first.name = strdup(""title1"");
first.cost = 500;

struct book second;
second.name = strdup(first.name);
second.cost = first.cost;
</code></pre>
",0
55002321,55001991,0,"<p>In the <code>addpic</code> function you do</p>

<pre><code>int *newpics = realloc(array[i].pic, ...);
</code></pre>

<p>One problem is that if you do it for one of the two elements you have initialized in <code>array</code>, then <code>array[i].pic</code> is pointing to the first element of an <em>array</em> (the array <code>test</code> in the <code>main</code> function).</p>

<p>Arrays can not be reallocated. If you want to reallocate the memory you need to allocate the original memory dynamically as well.</p>
",1
54446590,54446524,2,"<p>in</p>

<pre><code> concatena(input1, input2, output);
 printf(""%s\n"", output);
</code></pre>

<p>the value of <em>output</em> is unchanged by <em>concatena</em> so you print an uninitialized char * => crash or any other undefined behavior</p>

<p>you need to make output an output var, so <code>void concatena(char *input1, char *input2, char **output)</code> etc like that :</p>

<pre><code>int main(void){
    char *input1, *input2, *output;
    input1 = ""sdaeteruiop"";
    input2 = ""eiyearteoiana"";
    concatena(input1, input2, &amp;output);
    printf(""%s\n"", output);
    free(output);
    return 0;
}

void concatena(char *input1, char *input2, char **output){
    int num_cons1 = 0, num_cons2 = 0, dim_input1, dim_input2;
    conta_consonanti(input1, &amp;num_cons1);
    conta_consonanti(input2, &amp;num_cons2);
    if(num_cons1 &lt; num_cons2){
        dim_input1 = strlen(input1) + strlen(input2);
        *output = malloc(dim_input1 + 1);
        strcpy(*output, input1);
        strcat(*output, input2);
    }else {
        dim_input2 = strlen(input2) + strlen(input1);
        *output = malloc(dim_input2 + 1);
        strcpy(*output, input2);
        strcat(*output, input1);
    }
}
</code></pre>

<p>I also fixed your malloc, you missed 1 char for the null terminator </p>

<p>warning if <code>num_cons2 == num_cons1</code> *output is not set and you still print it not initialized, you need to set it to NULL and test that case before to printf it, or more probably to replace <code>else if(num_cons2 &lt; num_cons1)</code> by <code>else</code> (this is what I did above)</p>

<p>note also <code>dim_input1</code> and <code>dim_input2</code> have the same value, it is useless to distinguishes them</p>

<p>and the first call of <code>copy_string</code> can be replaced by <code>strcpy</code> and the second by <code>strcat</code>, <strong>except that <code>copy_string</code>miss to add a final null character</strong>. I removed the use of <code>copy_string</code></p>

<p>warning the declaration <code>void concatena(char *, char *, char *);</code> must be updated to be <code>void concatena(char *, char *, char **);</code></p>

<p>Execution :</p>

<pre><code>eiyearteoianasdaeteruiop
</code></pre>

<p>Under <em>valgrind</em> :</p>

<pre><code>pi@raspberrypi:~ $ valgrind ./a.out
==15629== Memcheck, a memory error detector
==15629== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==15629== Using Valgrind-3.13.0 and LibVEX; rerun with -h for copyright info
==15629== Command: ./a.out
==15629== 
eiyearteoianasdaeteruiop
==15629== 
==15629== HEAP SUMMARY:
==15629==     in use at exit: 0 bytes in 0 blocks
==15629==   total heap usage: 2 allocs, 2 frees, 1,049 bytes allocated
==15629== 
==15629== All heap blocks were freed -- no leaks are possible
==15629== 
==15629== For counts of detected and suppressed errors, rerun with: -v
==15629== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 6 from 3)
</code></pre>
",1
55542736,55542137,0,"<p>So what it looks like from your code is that your trying to generate a set of substrings, so if your array was <code>abc</code> then the substrings would be <code>a, ab, abc, b, bc, c</code>. You then try and count the number of times a character appears, so if <code>ch = 'b'</code> then the result would be 4.  So you are counting the number of strings that contain ch.</p>

<p>So one way to solve this problem with fewer loops would be to recognise for each value of <code>i</code> you create the strings by adding a character to the last string, and if the previous string contained <code>n</code> copies of <code>ch</code> then the next string contains <code>n</code> or <code>n+1</code> copies depending on the actual value.</p>

<p>Another possible approach to get down to just one loop would be loop through the array once and each time you find the character <code>ch</code> calculate how many sub-strings will contain the character at that position. So for the <code>abc</code> example 2 of the 3 strings starting at position 0 and 2 of the strings starting at position 1 will contain the value.</p>
",2
58663004,58662861,1,"<p>You can't write to a non-existent portion of a file via <code>mmap()</code>.</p>

<p>This truncates the file:</p>

<pre><code>int dfd = open(comms-&gt;destination, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
</code></pre>

<p>This <code>mmap()</code>'s the truncated file:</p>

<pre><code>void* destination = mmap(NULL, fileSize, PROT_READ | PROT_WRITE, MAP_PRIVATE,  dfd, 0);
</code></pre>

<p>This tries to copy to a non-existent part of the file:</p>

<pre><code>memcpy(destination, content, fileSize);
</code></pre>

<p>Per the <a href=""http://man7.org/linux/man-pages/man2/mmap.2.html"" rel=""nofollow noreferrer"">Linux <code>mmap()</code> man page <strong>ERRORS</strong></a>:</p>

<blockquote>
  <p><strong>ERRORS</strong></p>
  
  <p>...</p>
  
  <p>Use of a mapped region can result in these signals:</p>
  
  <p>... </p>
  
  <p><code>SIGBUS</code> Attempted access to a portion of the buffer that does not
                correspond to the file (for example, beyond the end of the
                file, including the case where another process has truncated
                the file).</p>
</blockquote>

<p>Per <a href=""https://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html"" rel=""nofollow noreferrer"">the POSIX <code>mmap()</code> specification</a>:</p>

<blockquote>
  <p>... References within the address range starting at pa and continuing for len bytes to whole pages following the end of an object shall result in delivery of a <code>SIGBUS</code> signal.</p>
  
  <p>An implementation may generate <code>SIGBUS</code> signals when a reference would cause an error in the mapped object, such as out-of-space condition.</p>
</blockquote>

<p>The fix is to call <code>ftruncate()</code> to set the file length on the output file:</p>

<pre><code>ftruncate( dfd, fileSize );
void* destination = mmap(NULL, fileSize, PROT_READ | PROT_WRITE, MAP_SHARED,  dfd, 0);
</code></pre>

<p>Note that you also have to replace the <code>MAP_PRIVATE</code> flag with <code>MAP_SHARED</code>.  <a href=""https://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html"" rel=""nofollow noreferrer"">Per POSIX again</a> (bolding mine):</p>

<blockquote>
  <p><code>MAP_SHARED</code> and <code>MAP_PRIVATE</code> describe the disposition of write references to the memory object. <strong>If <code>MAP_SHARED</code> is specified, write references shall change the underlying object. <code>If MAP_PRIVATE</code> is specified, modifications to the mapped data by the calling process shall be visible only to the calling process and shall not change the underlying object.</strong> It is unspecified whether modifications to the underlying object done after the <code>MAP_PRIVATE</code> mapping is established are visible through the <code>MAP_PRIVATE</code> mapping. Either <code>MAP_SHARED</code> or <code>MAP_PRIVATE</code> can be specified, but not both. The mapping type is retained across <code>fork()</code>.</p>
</blockquote>
",14
57245592,57245462,0,"<pre><code>e_t *set[SZ] = { 0 }, *e;
</code></pre>

<p>is a <em>declaration</em> of two objects; <code>set</code> is an array of pointers to <code>e_t</code>, while <code>e</code> is a pointer to a single <code>e_t</code>.  It may also be written as:</p>

<pre><code>e_t *set[SZ] = {0};
e_t *e;
</code></pre>
",0
57245697,57245462,0,"<p><code>e_t *set[SZ] = { 0 }, *e;</code> should be read as ""the programmer hereby declares that the following are of type <code>e_t</code>: the objects <em>pointed to by</em> each <code>SZ</code> elements in <code>set</code>; <strong>and</strong> the object <em>pointed to by</em> <code>e</code>.""</p>

<p><code>= {0}</code> causes each element in <code>set</code> to be initialized to null pointers - the first explicitly and the remaining implicitly.</p>
",0
55551563,55551516,0,"<p>This is because in your first example, loosely speaking, <code>p</code> is a so called double pointer or a pointer to a pointer because it is defined as a pointer to an array. So when you de-reference it, <code>*p</code> you get a pointer, not the object of type uint8_t.</p>

<p>So the size of a pointer on ARM M4 is actually 4 bytes.</p>
",0
56236097,56235869,1,"<p>I would have written it this way, remarks are where changes been made</p>

<pre><code>#include &lt;stdio.h&gt;
int sum(int n);
int main() {

int n, input, sum;
// sum = 0;  // no need for this
scanf(""%d"", &amp;n);
/* the next for has no use
for (n = 0; n &lt;= input; n++) {
    sum += n;
} */
// I would be adding some input sanitazing if possible here
printf(""%d"", sum(n));
   return 0;
}

int sum(int n) {
  int i, /*n, */ rsum = 0; // n is already a parameter, rsum for running sum

  // scanf(""%d"", &amp;n);   // nope nope, scanf and printf should be avoided in functions
  for (i = 1; i &lt;= n; i++){    // changed i +=1 with i++ , easier to read
     for (j=1;j&lt;=i;j++) // need this other loop inside  
          rsum += j;
   }   
 return rsum;
}
</code></pre>
",0
55035328,55035241,5,"<p>It appears that you are using <code>n</code> before you set it, in the declaration of <code>board</code>.  Because this is undefined behavior, absolutely anything is permitted to happen; in this case, that is disrupting the value of other variables.</p>

<p>To fix this, you should probably wait until after initializing <code>n</code> in <code>scanf</code> to declare <code>board</code>, like so:</p>

<pre><code> int main(void) {
     int n;
     printf(""Enter the board dimension: "");
     scanf(""%d"", &amp;n);
     char board[n][26];
     ...
  }
</code></pre>

<p>As has been pointed out in the comments, this still will cause problems if <code>n &gt; 26</code>, and can be wasteful for <code>n != 26</code>.  Due to the way that arrays work in C, fixing that would probably require rethinking how the board is stored altogether.</p>
",2
55502185,55501953,0,"<p>A few notes:</p>

<ol>
<li>Since you can't change the prototype you must cast away the const in the <code>return</code>: <code>return (char *) &amp;str[idx];</code>.</li>
<li>Your implementation has a bug, consider happens if <code>strchr("""", 'a')</code> is called. You increment <code>idx</code> inside the body of the loop, before NUL-checking so it will step beyond the end of the string.</li>
</ol>
",0
55502185,55501953,0,"<p>A few notes:</p>

<ol>
<li>Since you can't change the prototype you must cast away the const in the <code>return</code>: <code>return (char *) &amp;str[idx];</code>.</li>
<li>Your implementation has a bug, consider happens if <code>strchr("""", 'a')</code> is called. You increment <code>idx</code> inside the body of the loop, before NUL-checking so it will step beyond the end of the string.</li>
</ol>
",0
55552601,55552550,1,"<p>I changed your program like this and everything looks good:</p>

<pre><code>int main()
{
    float temp;

    printf(""Input temperature in degrees Fahrenheit:"");
    scanf(""%f"", &amp;temp);
    temp = (5.0f/9.0f)*(temp-32.0f);
    printf(""The temperature in Celsius is %.2f."", temp);
    return 0;
}
</code></pre>

<p>Pay attention to compiler warnings too. For example for your code compiler says <code>warning: C4476: 'scanf' : unknown type field character '.' in format specifier</code> so I removed <code>.</code> from <code>scanf</code> parameter.</p>
",3
55553028,55552550,5,"<blockquote>
  <p>Why isn't my equation working for converting Fahrenheit to Celsius?</p>
</blockquote>

<p>Compiler warnings not fully enabled.</p>

<hr>

<p><code>scanf(""%f"", ...);</code> expects a <code>float *</code>, not the <code>double *</code> provided.</p>

<p><code>""%.2f""</code> --> Precision in <code>scanf()</code> is <em>undefined behavior</em>.  Simple drop that.  <code>scanf()</code> does not provide limiting input on precision.</p>

<pre><code>double temp;
printf(""Input temperature in degrees Fahrenheit:"");
// scanf(""%.2f"", &amp;temp);

scanf(""%lf"", &amp;temp);
</code></pre>

<hr>

<p>I suggest a trailing <code>'\n'</code> in your <code>printf()</code>.</p>

<pre><code>// printf(""The temperature in Celsius is %.2f."", temp);
printf(""The temperature in Celsius is %.2f.\n"", temp);
</code></pre>
",0
54522380,54522313,3,"<p>You initialize <code>charPosition</code> at 0 and then test that <code>charPosition</code> does <em>not</em> equal zero in your while loop. The loop is never entered.</p>

<p>Your condition should be:</p>

<pre><code>while ((firstText[charPosition] != '\0') &amp;&amp; (charPosition &lt; LENGTH_OF_STRING + 1)) {
</code></pre>

<p>If you just had the latter test you would print every character in your buffer, even after the null terminator.</p>
",2
55699414,55699375,1,"<p>You are only ever looking at <code>*num_ptr</code> and <code>*(num_ptr+1)</code>. You should be using <code>i</code> or ""moving"" the pointer as you go.</p>
",0
59234187,59234088,2,"<p>Your answer is correct, but your explanation is not. </p>

<p>The effect of the post increment operation is to increment the variable AFTER the expression evaluation. </p>

<p>Thus </p>

<pre><code>c = (a++) + b;
</code></pre>

<p>is equivalent to </p>

<pre><code>c = a + b;
a = a + 1;
</code></pre>

<p>Operator precedence does not come into play here.</p>
",0
55573909,55573723,1,"<p>Operator precedence and evaluation order are not the same thing.</p>

<p>For most operators, C makes no assumption in which order their arguments are evaluated. A compiler may even have different strategies during the same compilation, depending, e.g, on optimization opportunities.</p>

<p>The only operators that have a predefined ordering are those were there is a logical dependency from the left operannd to the right operand(s), e.g <code>||</code>, <code>&amp;&amp;</code>, <code>?:</code> and <code>,</code>.</p>

<p>And if your are refering to the code at the end of your question, the answer is not ""undefined"" but ""unspecified"".</p>
",4
55574733,55573723,2,"<p>I'm going to go out on a limb and claim that the exam's answer is wrong.</p>

<p>Starting with the first expression to be evaluated,</p>

<pre><code>f() + g()
</code></pre>

<p>The ordering of the function calls is unspecified but they can't be interleaved, so there are two cases;</p>

<ol>
<li><p><code>f()</code>, then <code>g()</code><br>
<code>f()</code> returns <code>0 + 1</code> which is 1, then <code>g()</code> returns the value of <code>x</code>, which is 0, and increments <code>x</code>.
The result is 1, which gets converted to <code>true</code>. </p></li>
<li><p><code>g()</code>, then <code>f()</code><br>
<code>g()</code> returns 0 and increments <code>x</code>, then <code>f()</code> returns <code>x - 1</code> (because <code>x</code> is 1 now), which is 0.<br>
This result is 0, which is <code>false</code>.</p></li>
</ol>

<p><code>x</code> is incremented to 1 in both cases.</p>

<p>In case 1, evaluation stops, <code>i</code> is 1, and <code>x</code> is 1.</p>

<p>In case 2, evaluation continues with <code>g()</code>, which returns 1 and increments <code>x</code> to 2.</p>

<p>Thus, regardless of the evaluation order, <code>i</code> is 1.<br>
<code>x</code>, on the other hand, may be either 1 or 2.</p>

<p>For <code>j</code>, you have <code>g()</code> first, which returns either 1 or 2.</p>

<p>Since both 1 and 2 are truthy, <code>j</code> must be 1.</p>
",1
55574138,55573723,3,"<p>Let's analyse <code>i</code>. Note that the second argument of <code>||</code> is <em>only</em> evaluated if the left hand argument is 0.</p>

<p><code>i</code> is always 1 even if the approach by which this result is attained is <em>unspecified</em>.</p>

<p>There's no undefined behaviour here. (Formally this is due to the fact that a function call is a <em>sequenced step</em>.)</p>

<p>The language does not <em>specify</em> the order in which <code>f()</code> and <code>g()</code> are called in the evaluation of the left hand side. That is left to the implementation. Formally it is <strong>not</strong> even <em>implementation defined</em> since an implementation is not required to document the behaviour. If <code>f()</code> is called first then the value of <code>f() + g()</code> is non-zero. If <code>g()</code> is called first then <code>f() + g()</code> is zero, so <code>g()</code> is called again, and that is also non-zero as <code>x</code> is 1 at that point.</p>

<p><code>j</code> drops out trivially as 1 since only the left hand side of <code>||</code> is evaluated.</p>

<p>A more interesting variant would be</p>

<pre><code>int f(){
  if(x == 0) return ++x;
  else return --x;
}
</code></pre>

<p>where actually different implementations could return 0 or 1 for <code>i</code> or <code>j</code>.</p>
",7
56401727,56401499,4,"<p>Problem 1:</p>

<p>You are calling <code>calc()</code> recursively without a base case. This means that you will inevitably cause the stack to overflow when you call that function.</p>

<p>Solution:
Remove the recursive call to <code>calc()</code> in <code>calc()</code>.</p>

<p>Problem 2:</p>

<p><code>scanf_s</code> requires that the string argument satisfying a <code>%s</code> format specifier comes immediately before an integer variable giving the length of the buffer. See its documentation on <a href=""https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/scanf-s-scanf-s-l-wscanf-s-wscanf-s-l?f1url=https%3A%2F%2Fmsdn.microsoft.com%2Fquery%2Fdev15.query%3FappId%3DDev15IDEF1%26l%3DEN-US%26k%3Dk(STDIO%2Fscanf_s);k(scanf_s);k(DevLang-C%2B%2B);k(TargetOS-Windows)%26rd%3Dtrue&amp;view=vs-2019"" rel=""nofollow noreferrer"">MSDN</a>.</p>

<p>Solution: pass the length of the string as well:</p>

<pre><code>scanf_s(""%s"", input, 100);
</code></pre>

<p>Side note: checking the return value of <code>scanf</code>-family functions is usually a good idea.</p>
",2
55597993,55597726,0,"<p>I would do so:</p>

<pre><code>#include &lt;stdio.h&gt;

int
checkPalindrome(char * inputString) {
  char *temp = inputString+strlen(inputString)-1;
  while (temp&gt;inputString)
    if (*temp--!=*inputString++)
      return 0;
  return 1;
}


void main()
{
  char text[100];
  int count=0;

  while(count++ != 5)
  {
     printf(""Enter word: \n"");
     scanf(""%s"", text);
     if (checkPalindrome(text)
       printf(""This word is a Palindrome.\n"");
  }
}
</code></pre>
",0
55644475,55644439,4,"<p><code>strdup</code> makes a copy of the given char array. It only allocates enough memory to hold that string. You can¡¯t <code>strcat</code> anything to it since it goes out of bounds and undefined behavior happens. </p>

<p>You need to allocate enough memory for the whole string, then <code>strcpy</code> the first part and <code>strcat</code> the latter. Only that way the behavior is defined. </p>

<p>For example:</p>

<pre><code>char path[256];
strcpy(path, argv[1]);
strcat(path,""/mynewfile.txt"");
FILE *f=fopen(path,""w"");
</code></pre>

<p>Note that you should still make sure the allocated memory is enough. </p>
",0
56229506,56229458,0,"<p>Assuming that you want the user should enter the file number only once, you should probably move</p>

<p><code>printf(""Enter a number: "");
 scanf(""%d"", &amp;user_numbr);</code> </p>

<p>above the while loop. </p>
",5
59112607,59112415,3,"<p>When string literals have only whitespace (or nothing) between them, the preprocessor combines them into a single string literal, but this does not ""merge"" escape sequences. So you can just write your desired string using two strings:</p>

<pre><code>char arr[] = ""\xFF"" ""98"";
</code></pre>

<p>This is four bytes including the terminating <code>'\0'</code>.</p>
",1
56309308,56309286,2,"<p>The code gives you the right answer, even if it is not the answer you expect.</p>

<p>The problem is that you expect it to count graphemes (like <code>¨¢</code>, while it counts bytes / code-units (<code>¨¢</code> consists of two code-units in utf-8 normal form composed).</p>

<p>A first approximation would be to count code-points instead, by skipping continuation-bytes (>0x7f and &lt;0xc0). To actually count graphemes, you would have to use a proper unicode-library with all the character-information like <a href=""https://de.wikipedia.org/wiki/International_Components_for_Unicode"" rel=""nofollow noreferrer"">international components for unicode (ICU)</a>, and accept their decisions.</p>

<p>Read up on character-sets, especially <a href=""/questions/tagged/unicode"" class=""post-tag"" title=""show questions tagged &#39;unicode&#39;"" rel=""tag"">unicode</a> and the <a href=""/questions/tagged/utf-8"" class=""post-tag"" title=""show questions tagged &#39;utf-8&#39;"" rel=""tag"">utf-8</a> encoding.</p>

<p><sub>As an aside, <code>cnt</code> always mirrors <code>i</code>. While an optimizing compiler will remove this duplication, it shouldn't even be there.</sub></p>
",2
55644182,55643662,0,"<p>This is nothing more than a revamp of Gardener's answer, without <em>technically</em> using pointers (because there are no little <code>*</code> thingies).</p>

<pre><code>#include &lt;stdio.h&gt;

void recursive_print(char array[]) {
  if (array[0] != '\0') {
    recursive_print(array + 1); //pointer arithmetic, but no '*', so not a pointer supposedly
    printf(""%c"", array[0]);
  }
  else {
    printf(""\n"");  // send a new line at the end to make it look better.
  }
}

int main() {
  char string[] = ""Hello"";
  recursive_print(string);
  return 0;
}
</code></pre>

<p>Although, I would add that if your instructor is making this (counter-productive) distinction about the use of pointers, you might want to remember that just as all books about C are not equally good, the same thing can be said of instructors.</p>
",0
55659148,55658900,1,"<p>Use <code>%hhx</code> and cast the argument to <code>unsigned char</code>:</p>

<pre><code>printf( ""%c - 0x%hhx"", start[0], (unsigned char) start[0] );
</code></pre>

<p><code>%x</code> expects its corresponding argument to have type <code>unsigned int</code>.  You need to use the <code>hh</code> length modifier to tell it that you're dealing with an <code>unsigned char</code> value.  </p>
",1
55658934,55658900,3,"<p>Because <code>%x</code> means display as an unsigned integer (4 bytes) as hexadecimal. See <a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/cstdio/printf/</a></p>

<p>As noted there, you could use <code>%hhx</code> (added in C99) to get the behavior you were expecting (see more in <a href=""https://stackoverflow.com/a/41638772/1518546"">this answer</a>).</p>
",0
55989913,55989692,2,"<p>Here is the specification from the C17 Standard:</p>

<blockquote>
  <p><strong>7.24.2.3 The <code>strcpy</code> function</strong></p>
  
  <p><strong>Synopsis</strong></p>

<pre><code>    #include &lt;string.h&gt;
    char *strcpy(char * restrict s1,
                 const char * restrict s2);
</code></pre>
  
  <p>The <code>strcpy</code> function copies the string pointed to by <code>s2</code> (including the terminating null character) into the array pointed to by <code>s1</code>. If copying takes place between objects that overlap, the behavior is undefined.</p>
  
  <p><strong>Returns</strong></p>
  
  <p>The <code>strcpy</code> function returns the value of <code>s1</code>.</p>
</blockquote>

<p>Copying the string at <code>tt + 3</code>, which comprises 8 bytes, to <code>tt</code> will indeed cause copying between overlapping objects and thus has <strong>undefined behavior</strong>.</p>

<p>Yet since the destination is in front of the source, it is probable that the copy will take place as expected and the first 8 bytes of <code>tt</code> will be overwritten with <code>""1726354""</code> and a null byte. The byte at offset <code>9</code> is not changed and still has the value <code>'4'</code> so your <code>printf</code> statement may produce <code>7 - '4' + '5'</code>, that is <code>8</code>, but the C Standard does not guarantee this behavior.</p>

<p>In fact you have another instance of undefined behavior as you are passing a value of type <code>size_t</code> for a conversion specifier <code>%d</code>. <code>size_t</code> has a different size from <code>int</code> on 64-bit systems, hence the type mismatch has undefined behavior too. You can detect this kind of mistake by increasing the compiler warning level: <code>gcc -Wall -Wextra -Werror</code> or <code>clang -Weverything -Werror</code>.</p>

<p>Here is a corrected version that reliably outputs <code>8</code>:</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {
    char tt[20] = ""9081726354"";
    memmove(tt, tt + 3, strlen(tt + 3) + 1);
    printf(""%d\n"", (int)strlen(tt) - tt[9] + '5');
    return 0;
}
</code></pre>

<p>Note that <code>size_t</code> values can be passed to <code>printf</code> with a conversion specifier <code>%zu</code> or <code>%zd</code> but many legacy systems do not support this C99 extension.</p>
",0
55212165,55211122,0,"<p>You need to use <code>setvbuf</code> to set the buffer mode, size, and location:</p>

<pre><code>buffer = malloc(1024);
setvbuf(stdout, buffer, _IOFBF, 1024);
</code></pre>

<p>You need to ensure your buffer is large enough that it will never flush due to capacity if you want total control over flushing.</p>
",0
56417342,56417279,0,"<p>You can use the string set specifier <code>%[]</code> which stops scanning where you tell it. Note that <code>fgets()</code> retains the trailing newline so it is convenient to stop there, and filter it out.</p>

<pre><code>char name[50];
if(sscanf(buffer, ""%c %i %i %i %49[^\n]"", &amp;a, &amp;b, &amp;c, &amp;x, name) != 5)
    {
    // handle error
    }
printf(""%s\n"", name);
</code></pre>

<p>Note the type error for <code>%c</code> as commented.</p>
",0
56101426,56100770,0,"<p>Your <code>getCM()</code> function has a potentially endless loop waiting for an echo.  If your hardware is not working correctly or there is no object in range with a sufficiently string reflection, <code>getCM()</code> will never exit.</p>

<p>You should have a timeout in <code>getCM()</code>.  For example if you want a maximum range of say three meters, the maximum time to echo will be about 18ms - i.e. (distance x 2) / <em>speed-of-sound</em>.  After that you need to give up and send another ping:</p>

<p>Given :  </p>

<pre><code>#define MIN_RANGE_CM 4
#define MAX_RANGE_METRES 3
#define SPEED_OF_SOUND_M_PER_SEC 343
#define MAX_TIME_OF_FLIGHT_US (MAX_RAMGE_METRES * 2000000) / SPEED_OF_SOUND_M_PER_SEC
#define MIN_TIME_OF_FLIGHT_US (MAX_RAMGE_CM * 20000) / SPEED_OF_SOUND_M_PER_SEC
</code></pre>

<p>Your <code>getCM()</code> might look like:</p>

<pre><code>int getCM() 
{
    int distance = -1 ;
    long startTime = micros() ;
    long elapsed_time = 0 ;

    // Send ping pulse
    digitalWrite(TRIG, HIGH);
    delayMicroseconds(20);
    digitalWrite(TRIG, LOW);

    // Wait for ping end
    while( digitalRead(ECHO) == LOW &amp;&amp; 
           elapsed_time &lt; MIN_TIME_OF_FLIGHT_US )
    {
        elapsed_time = micros() - startTime ;
    }

    // If not timed out waiting...
    if( elapsed_time &lt; MIN_TIME_OF_FLIGHT_US )
    {
        // Wait for echo
        elapsed_time = 0 ;
        while( digitalRead(ECHO) == HIGH &amp;&amp; 
               elapsed_time &lt; MAX_TIME_OF_FLIGHT_US )
        {
            elapsed_time = micros() - startTime ;
        }

        // If not timed out, get distance in cm
        if( elapsed_time &lt; MAX_TIME_OF_FLIGHT_US )
        {
            distance = (elapsed_time * SPEED_OF_SOUND_M_PER_SEC) / 20000 ;
        }
    }

    return distance ; 
}     
</code></pre>

<p>Note that each loop has a timeout.  Note also that your comments and timing did not seem correct.  You are waiting for end of the ping and the start of the echo, not the start and end of the echo. The time of flight is the period from the <em>start</em> of the ping, to the <em>first</em> detected echo.  Your implementation does not start timing until the <em>end</em> of the ping.  In your case a 20us ping is only a few millimetres, so it probably does not matter.  The implementation above uses a ""minimum range"" as a timeout for waiting for the end of the ping - arbitrarily 5cm - if the input has not gone low in that time there is an issue - hardware fault or someone jangling their keys (that can really mess up an ultrasonic sensor - try it!).</p>

<p>For this application your distance will need to be measured continuously.  To that end I suggest:</p>

<pre><code>int main(void) 
{
    setup();

    for( ;; )
    {
        printf( ""Distance: "" ) ;

        int distance = getCM() ;
        if( distance &gt;= 0 )
        {
            printf( ""%dcm        \r"", distance ) ;
        }
        else
        {
            printf( ""Out-of-range\r"" ) ;
        }

        fflush( stdout ) ;
        delay( 200 ) ;
    }

    return 0;
}
</code></pre>

<p>The <code>\r</code> will reuse the same line to display the distance, preventing the terminal from scrolling.  The space padding ensures the previous output is overwritten.  The <code>fflush()</code> call ensures that buffered output is output immediately.</p>
",2
56451905,56451754,0,"<blockquote>
<pre><code>p += size;
</code></pre>
</blockquote>

<p>C knows the size. You need</p>

<pre><code>p += 1 /* C multiplies by size automagically */;
</code></pre>
",0
55537049,55536909,2,"<p>Files (that is <code>FILE*</code> handles) from <a href=""https://en.cppreference.com/w/c/io"" rel=""nofollow noreferrer""><code>&lt;stdio.h&gt;</code></a>  don't have any record structures. They are just a stream of bytes. Even <a href=""https://en.cppreference.com/w/c/io/fread"" rel=""nofollow noreferrer"">fread</a> is reading bytes (in some multiple of  given<code>size</code>), but <em>conventionally</em>, <em>you</em> could <em>decide</em> they are ""records"".</p>

<p>You need to define and specify on paper (or at least in some comment) your <a href=""https://en.wikipedia.org/wiki/File_format"" rel=""nofollow noreferrer"">file format</a>. You might use <a href=""https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form"" rel=""nofollow noreferrer"">EBNF</a> notation for that specification. Then you could use <a href=""https://en.wikipedia.org/wiki/Recursive_descent_parser"" rel=""nofollow noreferrer"">recursive descent parsing</a> techniques to read that file. You may prefer to use some <a href=""https://en.wikipedia.org/wiki/Plain_text"" rel=""nofollow noreferrer"">plain text</a> format because it is easier to debug. Then you could read every line (with <a href=""https://en.cppreference.com/w/c/io/fgets"" rel=""nofollow noreferrer"">fgets</a> or <code>getline</code>) and parse each of them (perhaps also having your <a href=""https://en.wikipedia.org/wiki/Lexical_analysis"" rel=""nofollow noreferrer"">lexer</a>). Read about <a href=""https://en.wikipedia.org/wiki/Serialization"" rel=""nofollow noreferrer"">serialization</a>, it is likely to be relevant.</p>

<p>Remember that computers are very fast, and RAM is always much faster than your disk (even if it is an SSD). You might prefer using <em>existing</em> textual formats such as <a href=""https://json.org/"" rel=""nofollow noreferrer"">JSON</a>, <a href=""https://yaml.org/"" rel=""nofollow noreferrer"">YAML</a>, XML because you'll easily find existing libraries to deal with these. Remember that the cost of data processing is quite often much smaller than the cost of I/O.</p>

<p>If <a href=""https://en.wikipedia.org/wiki/Random_access#Direct_access"" rel=""nofollow noreferrer"">direct access</a> inside your file is a concern, consider using something like <a href=""https://sqlite.org/"" rel=""nofollow noreferrer"">sqlite</a> or <a href=""https://www.gnu.org.ua/software/gdbm/"" rel=""nofollow noreferrer"">GDBM</a>. It could be easier to code.</p>

<p>In many cases, the cost (or monetary value) of data is more important that the cost of the software handling it. Don't forget to backup your data.</p>

<p>I don't understand exactly your application, but I would recommend using <a href=""https://json.org/"" rel=""nofollow noreferrer"">JSON</a> or <a href=""https://sqlite.org/"" rel=""nofollow noreferrer"">sqlite</a> in it, using <em>existing</em> appropriate libraries. Since your development time (and cost) matters a lot.</p>

<p>Of course, if your data is huge (e.g. much bigger than your RAM, so terabytes) you'll have different concerns and different approaches. Given your topic (some kind of data  about people; then you may be concerned about <a href=""https://en.wikipedia.org/wiki/General_Data_Protection_Regulation"" rel=""nofollow noreferrer"">GDPR</a> and you certainly have some ethical questions about such data, since it is unethical to collect data about persons without them knowing about data concerning them), it is unlikely: we are less than ten billion persons on earth, and each of your records is very probably less than 200 bytes, so all information about every living person fits on a single hard disk.</p>

<p>Be also aware of <a href=""https://en.wikipedia.org/wiki/C_dynamic_memory_allocation"" rel=""nofollow noreferrer"">C dynamic memory allocation</a>. You probably need it.</p>

<p>PS. <a href=""https://en.wikipedia.org/wiki/Record-oriented_filesystem"" rel=""nofollow noreferrer"">Record-oriented files</a> existed in the mainframe era (e.g. <a href=""https://en.wikipedia.org/wiki/MVS"" rel=""nofollow noreferrer"">MVS</a>, <a href=""https://en.wikipedia.org/wiki/OpenVMS"" rel=""nofollow noreferrer"">VMS</a>) in the 1970s or 1980s. Current operating systems (read <a href=""http://pages.cs.wisc.edu/~remzi/OSTEP/"" rel=""nofollow noreferrer""><em>Operating Systems: three easy pieces</em></a>) such as Linux, Windows, Unix, Android, MacOSX all provide a byte stream abstraction for their files and also <a href=""https://en.wikipedia.org/wiki/Directory_(computing)"" rel=""nofollow noreferrer"">directories</a> in their <a href=""https://en.wikipedia.org/wiki/File_system"" rel=""nofollow noreferrer"">file systems</a>. Many have <a href=""https://en.wikipedia.org/wiki/Database#Database_management_system"" rel=""nofollow noreferrer"">DBMS</a> above that, or perhaps some kind of key-value abstraction (e.g. GDBM, <a href=""https://fallabs.com/kyotocabinet/"" rel=""nofollow noreferrer"">Kyoto Cabinet</a>, <a href=""https://redis.io/"" rel=""nofollow noreferrer"">REDIS</a>, ...)</p>
",0
56549212,56549150,2,"<p><code>""%s""</code> capture only word and the capture stop if a white space retrieved. So the capture will stop in the first space found that's why you got only 1 word
Use the following pattern instead:</p>

<pre><code>scanf(""%[^\n\r]"", str);
</code></pre>

<p><code>""%[^\n\r]""</code> means capture all characters till retrieving <code>""\r""</code> or <code>""\n""</code></p>

<p>To prevent your source code from buffer overflow you have to specify the maximum number of characters of the capture. Use the following pattern</p>

<pre><code>char str[500];
scanf(""%499[^\n\r]"", str);
</code></pre>
",2
56403629,56403577,2,"<p>It's a pointer-to-pointer-to-pointer-to-<code>char</code>.  In this case, it's very likely to be an <em>output</em> parameter.  Since C passes arguments by value, output parameters require an extra level of <a href=""https://en.wikipedia.org/wiki/Indirection"" rel=""nofollow noreferrer"">indirection</a>.  That is, the <code>read_lines</code> function wants to give the caller a <code>char**</code>, and to accomplish that via an output parameter, it needs to take a <em>pointer</em> to a <code>char**</code>.  Likely all you'd need to do to invoke it is:</p>

<pre class=""lang-c prettyprint-override""><code>char** lines = null;
int num_lines;
read_lines(fp, &amp;lines, &amp;num_lines);
</code></pre>

<p>Also see <a href=""https://stackoverflow.com/questions/2838038/c-programming-malloc-inside-another-function/2838207#2838207"">C Programming: malloc() inside another function</a>.</p>
",0
56403689,56403577,2,"<blockquote>
  <p>I need help understanding what char*** means ...</p>
</blockquote>

<p>The <code>char***</code> type is a pointer.  A pointer to a <code>char **</code>.  <a href=""https://cdecl.org/?q=char***+p%3B"" rel=""nofollow noreferrer"">p as pointer to pointer to pointer to char</a></p>

<pre><code>char*** p;
</code></pre>

<blockquote>
  <p>... and how do I initialize a variable that is of type char***.</p>
</blockquote>

<pre><code>char*** p1 = NULL;  // Initialize p with the null pointer constant.

char *q[] = { ""one"", ""two"", ""three"" };
char*** p2 = &amp;q;  // Initialize p2 with the address of q

char ***p3 = malloc(sizeof *p3);  // Allocate memory to p3.  Enough for 1 `char **`.
....
free(p3); // free memory when done.
</code></pre>
",1
56552889,56552850,1,"<p>You have two <em>different</em> <code>a</code> variables of type <code>ng</code>, one in each function.</p>

<p>You need to pass the <code>main</code> one into <code>print</code>, such as with:</p>

<pre><code>void print(Ng *a) {
    printf(""Username: %s"",a-&gt;username);
}
</code></pre>

<p>and call it with:</p>

<pre><code>print(&amp;a);
</code></pre>
",2
55692244,55692102,2,"<p>Because you have a 2's complement computer.</p>

<ul>
<li>5 | 8 gives binary <code>0101 | 1000 = 1101</code> = 13 dec. </li>
<li>Invert this with <code>~</code> and you get <code>1111....0010</code>. </li>
<li>Representing that as a signed type, then in 1's complement this would have been -13 dec. </li>
<li>But for 2's complement we subtract 1 and get -14 dec.</li>
</ul>

<p>For the same reason as <code>~0</code> gives 2's complement <code>-1</code> and not <code>-0</code>.</p>
",0
55692259,55692102,0,"<p>This is due to two's complement representation of negative numbers.  Two's complement is performed by inverting all bits then adding one.</p>

<p>First, you have <code>a|b</code> (for simplicity's sake I'll show only the low order 8 bits):</p>



<pre><code>  a  00000101  5
| b  00001000  8
 ------------
     00001101  13
</code></pre>

<p>Then the bitwise NOT:</p>



<pre><code>   ~ 00001101  13
   ----------
     11110010  -14
</code></pre>

<p>Performing a bitwise NOT on a positive value does not give you its negative value, it gives you one <em>less</em>.</p>
",0
55272143,55272124,0,"<p>Change:</p>

<pre><code>for( ctr = 0; ctr &lt; 6; ctr++ ) (randnums[ctr] == nums[ctr]) ? win = 1 : win = 0;
</code></pre>

<p>to:</p>

<pre><code>for( ctr = 0; ctr &lt; 6; ctr++ ) win = (randnums[ctr] == nums[ctr]) ? 1 : 0;
</code></pre>
",5
55997088,55996853,2,"<p><code>isprint()</code> returns a Boolean result - zero if the character is not ""printable"", and non-zero if it is.  As such <code>isprint(ch) != '\n'</code>makes no sense. Your complete expression in the question makes even less sense, but I'll come on to that at the end.</p>

<p><code>isprint()</code> on its own returns true (non-zero) for all printable characters, so you need no other tests.  Moreover you increment <code>count</code> unconditionally and in every conditional block, so you are counting every character and some twice.  </p>

<p>You just need:</p>

<pre><code>if( isprint(ch) )
{ 
    count++; 
}
putc( ch, stdout ) ;
</code></pre>

<p>While your code is clearly an incomplete fragment, it is not clear where or how your are reading <code>ch</code>.  You need a <code>getc()</code> or equivalent in there somewhare. </p>

<pre><code>while( (ch = getc(fp)) != EOF ) 
{
    if( isprint(ch) )
    { 
        count++; 
    }
    putc( ch, stdout ) ;
}
</code></pre>

<p>It is not clear whether you need to count all whitespace (including space, tab and newline) or just ""spaces"" as you stated.  If so be clear that <code>isprint()</code> will match space, but not control characters newline or tab.  <code>isspace()</code> matches all these, but should not be counted separately to <code>isprint()</code> because 'space' is in both white-space and printable sets.  If newline and tab are to be counted (and less likely; ""vertical tab"") then:</p>

<pre><code>while( (ch = getc(fp)) != EOF ) 
{
    if( isprint(ch) || isspace(ch) )
    { 
        count++; 
    }

    putc( ch, stdout ) ;
}
</code></pre>

<p>Another aspect of C that you seem to misunderstand is how Boolean expressions work.  To test a single variable for multiple values you must write:</p>

<pre><code>if( var == x || var == y || var == z )
</code></pre>

<p>You have written:</p>

<pre><code>if( var == x || y || z )
</code></pre>

<p>which may make sense in English (or other natural language) when you read it out aloud, but in C it means:</p>

<pre><code>if( var == (x || y || z ) )
</code></pre>

<p>evaluating <code>(x || y || z )</code> as either <code>true</code> or <code>false</code> and comparing it to <code>var</code>.</p>

<p>It is probably worth considering the semantics of your existing solution to show why it actually compiles, but produces the erroneous result it does.</p>

<p>Firstly,</p>

<pre><code>  isprint(ch) != '\n' || '\t' || '\0' 
</code></pre>

<p>is equivalent to <code>isprint(ch) != true</code>, for the reasons described earlier. So you increment the counter for <em>all</em> characters that are <em>not</em> printable.</p>

<p>Then here:</p>

<pre><code>  isspace(ch) == NULL
</code></pre>

<p><code>NULL</code> is a macro representing an invalid pointer, and <code>isspace()</code> does not return a pointer.  However <code>NULL</code> will implicitly cast to zero (or false).  So here you increment the counter for <em>all</em> printable characters that are <em>not</em> spaces.</p>

<p>Finally, you <em>unconditionally</em> count every character here:</p>

<pre><code>    putc(ch,stdout);  // same as putchar(ch);
    count++;
</code></pre>

<p>So your result will be: </p>

<pre><code>number-of-non-printing-characters + 
number-of-printing-characters - number-of-spaces +
total-number-of-characters
</code></pre>

<p>which is I think <code>(2 x file-length) - number-of-spaces</code></p>

<p>Finally note that if you open a text file that has CR+LF line ends (conventional for text files on Windows) in ""binary"" mode, <code>isspace()</code> will count two characters for every new-line.  Be sure to open in ""text"" mode (regardless of the platform). </p>
",0
55275855,55275315,3,"<p><code>%s</code> reads data until white character is encountered. So your data can't use space if you are using such data format.</p>

<p>One way to fix it is to update data format and use advanced format string (C style code):</p>

<pre><code>int StudentWrite(FILE *f, Student *student) {
    return 2 == fprintf(f, ""%s\n%s\n"", student-&gt;name, student-&gt;pass);
}

int StudentRead(FILE *f, Student *student) {
    return 2 == fscanf(f, ""%[^\n]%*c%[^\n]%*c"", student-&gt;name, student-&gt;pass);
}
</code></pre>

<p>Where this format string works like this:</p>

<ul>
<li><code>%[^\n]</code> read all characters, until end line <code>\n</code></li>
<li><code>%*c</code> read single character and discard it. Since previous format reads all but not end line character, end line character is read and discarded.</li>
</ul>

<p>To protect data from buffer overflow scanning format string can look like this: <code>%80[^\n]%*c%80[^\n]%*c</code> where <code>80</code> indicates capacity of target like <code>student-&gt;name</code> (remembered that you have to count terminating zero, so actual size of buffer must be by one greater then this value).</p>
",2
58966934,58966908,1,"<p>Because <code>newArray</code> is a pointer <code>sizeof(newArray)</code> gives you the size of the pointer, <strong>not</strong> the size of the buffer it points to.</p>

<p>When allocating memory you need to keep track of the size of that memory yourself as the language does not give you a way to find that out.</p>
",10
56620556,56620349,1,"<p>You read it from stdin and use in place of <code>"".""</code>. Here is the full example</p>

<pre><code>#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;dirent.h&gt;

int main(){

        struct dirent *de;
        char dirbuf[BUFSIZ] = {0};
        DIR *dr;
        int i = 1;

        puts(""Chose the directory: "");
        if (fgets(dirbuf, BUFSIZ, stdin) == NULL) {
                perror(""fgets"");
                exit(-1);
        }
        dirbuf[strlen(dirbuf)-1] = '\0'; // remove \n

        dr = opendir(dirbuf); // need to get directory through stdin insted of this 

        if (dr == NULL) {
                perror(""opendir"");
                exit(-1);
        }

        while(((de = readdir(dr)) != NULL))
        {

                printf(""\t%d. %s\n"", i, de -&gt; d_name);
                i++;
        }

        closedir(dr);

        return 0;

}
</code></pre>
",2
57130515,57130415,1,"<p>The problem lies in how you have the loop set up. See my comments below:</p>

<pre class=""lang-c prettyprint-override""><code>    while (x &lt; 9)
    {
        y = 0;
        while (y &lt; 9)
        {
            if (sudoku[x][y] == 0) //Here I'm getting the error. 
            {
                set_point(&amp;coord, x, y);
                return (0);
            }
            x++; // This increments the x index while you're inside the y loop
        }
        y++; // This increments the y index when you meant to increment the x
    }
</code></pre>

<p>If you swap both lines, that should work fine and will resolve your out-of-bounds error.</p>

<p>What would also help you write this better is instead of using a <code>while</code> loop, use a <code>for</code> loop. If you haven't covered that topic yet, it's really straightforward:</p>

<pre class=""lang-c prettyprint-override""><code>    for(int x = 0; x &lt; 9 ; ++x)
    {
        for (int y = 0; y &lt; 9; ++y)
        {
            if (sudoku[x][y] == 0) //Here you won't get the error anymore! 
            {
                set_point(&amp;coord, x, y);
                return (0);
            }
        }
    }
</code></pre>

<p>What the <code>for</code> loop line means there is this: Start the loop by setting it to <code>0</code>, at the end of an iteration, increment it. On the next iteration, check if <code>x</code> is still less than <code>9</code>. If so, proceed with the next iteration.</p>
",2
58635555,58635508,2,"<p>In your first block of code, there are several problems:</p>

<ol>
<li><code>x</code> is uninitialized (you did not give it a value)</li>
<li><code>1 &lt; x &lt; 10</code> is not valid C</li>
<li>your printf statement expects 2 integer values to accompany the ""%d%d"", but you are only passing 1</li>
</ol>

<p>I think this is what you want:</p>

<pre><code>int x = &lt;some valid value&gt;;
int b;
b = ((1 &lt; x) &amp;&amp; (x &lt; 10)); // expression is true if x is between [2..9]
printf(""%d"",b);
</code></pre>

<p>This line</p>

<pre><code>(c==' ') || (c='\t') || (c=='\n');
</code></pre>

<p>Should be</p>

<pre><code>(c==' ') || (c=='\t') || (c=='\n');
</code></pre>

<p>Note the double equals when comparing to <code>\t</code> (the tab character). Otherwise, you wind up assigning a tab char to <code>c</code>.</p>
",3
56472594,56471208,1,"<p>depends on whether the compiler/interpreter implemented the algorithm of <a href=""https://compileroptimizations.com/category/constant_propagation.htm"" rel=""nofollow noreferrer"">constant propagation</a> or not.</p>

<p>C standard does not impose not to use constant propagation. If one detects that that variable is not mutated it can be replaced with the precomputed value.  The <a href=""https://en.wikipedia.org/wiki/As-if_rule"" rel=""nofollow noreferrer"">as-if rule</a> says that one can do whatever optimization we want as time as the result is the expected one.</p>
",0
54394535,54394482,1,"<p>Computing platforms¡ªsets of hardware and software working together¡ªdefine how arguments should be passed to functions. This specification of how arguments are passed is part of a specification typically called the application binary interface (ABI).</p>

<p>The details about how an argument should be passed may depend on several factors, including:</p>

<ul>
<li>its size,</li>
<li>its alignment requirement,</li>
<li>its fundamental type (integer, floating-point, pointer, et cetera),</li>
<li>whether it is an aggregate of some sort, such as a structure or union, and</li>
<li>whether all the details about the argument are known at compile time.</li>
</ul>

<p>The means by which an argument should be passed may include:</p>

<ul>
<li>whether it is passed in a register, on the stack, or in memory,</li>
<li>how it is aligned in memory, and</li>
<li>which set of processor register it is passed in.</li>
</ul>

<p>The expression <code>3 / 2</code> has an <code>int</code> type. It will be passed in the way the ABI specifies for an <code>int</code> argument. When you specify <code>%f</code> in a <code>printf</code> format, <code>printf</code> expects a <code>double</code>, and <code>printf</code> looks for the argument in the place the ABI specifies for a <code>double</code>.</p>

<p>Thus, in <code>printf(""%f"" , 3 / 2);</code>, there is no guarantee that <code>printf</code> even sees the <code>int</code> value that was passed. It may get data from the wrong memory or register entirely.</p>

<p>If <code>printf</code> does get the data for the <code>int</code> value, it will interpret those bytes as if they were <code>double</code> value. The values of bytes have different meanings when they are encoding an <code>int</code> than when they are encoding a <code>double</code>. So the values in the bytes that encode an <code>int</code> value of 1 do not encode a 1 when they are encoding a <code>double</code> value. So, even if <code>printf</code>, when it is formatting a <code>double</code> for <code>%f</code>, gets the bytes for the <code>int</code> value of 1, the characters it produces are not likely to be ¡°1¡±.</p>

<p>The C standard defines how you should use <code>printf</code> and its format specifiers so that the ABI can work. When you violate the C rules about matching argument types with format specifiers, the C standard does not define what behavior results. It leaves you at the mercy of the C implementation. Historically, this meant you were violating the ABI, and the program would break for the reasons I describe above. Over time, compilers have become more aggressive about optimization and other program transformations, with the result that violating the rules of the C standard can transform program behavior in more surprising ways.</p>
",0
54394508,54394482,1,"<p>In the first case, you pass an expression of type <code>double</code> when the format specifier expects an <code>int</code>, and in the second case you pass an expression of type <code>int</code> when the format specifier expects a <code>double</code>.</p>

<p>Using the wrong format specifier invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a> as dictated by the C standard, meaning you can't reliably predict how your program will behave.  Different compilers may manifest undefined behavior in different ways, as well as different optimizations settings on the same compiler.</p>

<p>Attempting to reason away undefined behavior serves no purpose.  Just make sure your program is well behaved, which in this case means using the correct format specifier.</p>

<p>That being said, compilers for x86 systems typically pass floating point parameters in floating point registers while integers are passed on the stack.  So when <code>printf</code> tries to read a parameter of a given type it ends up reading whatever garbage happened to be where it was looking because the actual parameter isn't there at all.</p>
",0
57059528,57058848,6,"<p>The GNU C Library's mathematical functions are fully implemented within the <a href=""https://sourceware.org/git/?p=glibc.git"" rel=""nofollow noreferrer"">""glibc"" source tree</a>.  They don't rely on the operating system kernel for anything.  The word ""kernel"" in this context refers to a <em>computational</em> kernel ¡ª the core of some mathematical algorithm, the part you might want to write in hand-optimized assembly language.</p>

<p>The function <code>__kernel_standard_f</code> is badly named.  It contains common code for handling errors in the math functions; it would be better to have named it something like <code>__math_domain_error</code>.  In this case, <code>__sqrtf</code> calls <code>__kernel_standard_f</code> when its argument is negative; <code>__kernel_standard_f</code> will then take care of setting <code>errno</code> to <code>EDOM</code>, possibly calling the SVID <a href=""http://man7.org/linux/man-pages/man3/matherr.3.html"" rel=""nofollow noreferrer""><code>matherr</code></a> callback, and returning a NaN.  (The mysterious code 126 tells <code>__kernel_standard_f</code> which function called it and why.  The implementation of <code>__kernel_standard_f</code> is in <code>sysdeps/ieee754/k_standardf.c</code> and <code>sysdeps/ieee754/k_standard.c</code>.)</p>

<p>The condition <code>_LIB_VERSION != _IEEE_</code> has to do with whether or not POSIX and/or SVID math error handling is enabled; modern mathematical algorithms would really rather just look for NaN in the result and not have the library waste time setting <code>errno</code> or calling <code>matherr</code>, so there's a mechanism to turn the latter two off.</p>

<p>If the argument to <code>__sqrtf</code> is <em>not</em> negative, it tail calls <code>__ieee754_sqrtf</code>, which performs the actual calculation of the square root. There are several alternative implementations of this function within the glibc source tree; its generic, C-only version is in <code>sysdeps/ieee754/flt-32/e_sqrtf.c</code>.  (The names of the files that implement math functions are cryptic even by glibc's standards.  I don't bother trying to understand them, I just do <code>find sysdeps -name '*sqrtf*'</code> or whatever.)  This function <em>also</em> starts with logic to detect a negative argument (also zero, infinity, and NaN) and return the appropriate values, but it doesn't touch <code>errno</code>.  If you want to understand the mathematical technique used to calculate square roots, this is the file to look at.</p>

<p>If you run the above <code>find</code> command yourself you will discover several other files named <code>e_sqrtf.c</code>; these are all in directories named after specific CPUs, whose floating-point units have hardware support for computing square roots, so for instance <code>sysdeps/x86_64/fpu/e_sqrt.c</code> reads</p>

<pre><code>double
__ieee754_sqrt (double x)
{
  double res;

  asm (""sqrtsd %1, %0"" : ""=x"" (res) : ""xm"" (x));

  return res;
}
</code></pre>

<p>because the x86 <code>sqrtsd</code> instruction does the whole job.</p>

<p>Glibc's build process will select one of these files, instead of the generic C version, when building for one of these CPUs.  This mechanism is complex and not completely documented, but <a href=""https://gnu.org/software/libc/manual/html_node/Maintenance.html"" rel=""nofollow noreferrer"">the ""Maintenance"" appendix to the glibc manual</a>, particularly its ""Source Layout"" and ""Porting"" sections, gives a decent overview of it.</p>

<hr>

<p><code>libm_alias_float (__sqrt, sqrt)</code> arranges for <code>__sqrtf</code> to also have the name <code>sqrtf</code>, but as a <em><a href=""https://stackoverflow.com/questions/15525537/what-are-practical-applications-of-weak-linking"">weak alias</a></em>.  This is necessary for standards compliance.  Please ask a separate question if you want more detail.</p>
",0
57115572,57115530,1,"<ol>
<li>Give the variables initial values</li>
</ol>

<p>i.e.</p>

<pre><code>int heightBody = 0, weightBody = 0, heightAndWeightResult;
</code></pre>

<ol start=""2"">
<li><p>Check the return value from <code>scanf_s</code> - Read the manual page for that</p></li>
<li><p>Do not need the variable in the first two <code>printf</code></p></li>
</ol>

<p>i.e. </p>

<pre><code> printf(""Enter Body Weight: ""); 
 printf(""Enter Body Height: "");
</code></pre>

<ol start=""4"">
<li>Need a format specifier in the last <code>printf</code></li>
</ol>

<p>i.e.</p>

<pre><code> printf(""Body Result: %d"", heightAndWeightResult);
</code></pre>

<p><em>Perhaps it would be worthwhile for you to read the manual pages for <code>printf</code> and <code>scanf_s</code></em></p>
",2
54410967,54410894,5,"<p>There is no way to achieve function overloading akin to what is available in C++ since, unlike in C++, function signatures are not mangled in a way that permits overloading.  What you <em>can</em> do is use the <a href=""https://en.cppreference.com/w/c/keyword/_Generic"" rel=""noreferrer""><code>_Generic</code></a> keyword to map a macro into whichever function call best suits the argument type.  For example:</p>

<pre><code>#include &lt;math.h&gt;
#include &lt;float.h&gt;
#define sqrt(X) _Generic((X), \
            long double: sqrtl, \
            default: sqrt, \
            float: sqrtf \
)(X)
</code></pre>
",6
54443773,54442918,0,"<p>Yes, it is valid, provided <code>uint8</code> and <code>name</code> are types that have been defined previously.</p>

<p>The declaration <code>typedef uint8 (*Funcptr) (name);</code> says <code>Funcptr</code> is a type for a pointer to a function that takes a <code>name</code> as an argument and returns a <code>uint8</code>.</p>

<p>In general, a C declaration such as <code>uint8 (*Funcptr) (name)</code> gives a type (in this case <code>uint8</code>) and a sample expression (in this case <code>(*Funcptr) (name)</code>) and means ¡°When I use <code>Funcptr</code> this way, the expression has type <code>uint8</code>. So we have:</p>

<ul>
<li><code>(*Funcptr) (name)</code> is a <code>uint8</code>.</li>
<li>Therefore, <code>(*Funcptr)</code> must be a function taking a <code>name</code> and returning a <code>uint8</code>.</li>
<li>Therefore, <code>Funcptr</code> must be a pointer to a function taking a <code>name</code> and returning a <code>uint8</code>.</li>
</ul>

<p>Then, since it is a <code>typedef</code>, we know that <code>Funcptr</code> is the name of this type, rather than being an object that is a pointer to a function taking a <code>name</code> and returning a <code>uint8</code>.</p>
",1
55417878,55417773,6,"<p>You can rewrite it like this:</p>

<pre><code>for(i=0;i&lt;n;i++) {
    if (i == 0) {
        a[i] = random()%100;
    } else {
        a[i] = a[i-1] + random()%100;
    }
}
</code></pre>

<p>So, you see that the value at <code>a[1]</code> is <code>a[0] + random()%100</code> and so on. The <code>if</code> is needed because when <code>i</code> is 0, you haven't a previous values to use (<code>a[-1]</code> would be an error). The ternary operator <code>condition ? a : b</code> can be read as ""if condition is true, a; else b"".</p>
",2
55417881,55417773,1,"<p>You can look at it on this way: </p>

<pre><code>srandom(time(NULL));

for (i = 0; i &lt; n; i++){
    if (i == 0){
        a[i] = random() % 100; // random number module 100 will give number between 0 and 99 inclusive
    }
    else{
        a[i] = a[i - 1] + random() % 100; // a[i] will get value equal to sum of previous array value a[i - 1] and new random number between 0 and 99
    }
}
</code></pre>

<p>In for loop you have i++ which is increasing index by one. </p>
",1
54987910,54987852,5,"<p>The issue is that something like <code>res1= freq1/1000</code> is first computed as an integer as both arguments are integers and then converted to float.  Use instead something like <code>res1= freq1/1000.0</code> so that at least one argument is a floating point, the second will be converted to floating point automatically.</p>
",0
57252447,57252079,12,"<p>You can simplify the code by reducing the comparisons:</p>

<pre><code>maximum = a;
if(maximum &lt; b) { maximum = b; }
if(maximum &lt; c) { maximum = c; }
</code></pre>

<p>This would be same as loop unroll optimization, if you'd do the search on array.</p>
",1
57252351,57252079,0,"<p>The best you can do I think is to reduce it to an if-elseif statement (i.e. removing the else block) by initialising <code>maximum</code> to <code>c</code>:</p>

<pre><code>int main()
{
    int a, b, c, maximum;
    printf(""Enter three numbers:"");
    scanf(""%d%d%d"", &amp;a, &amp;b, &amp;c);
    maximum = c;
    if ((a &gt; b) &amp;&amp; (a &gt; c))
    {
        maximum = a;
    } 
    else if ((b &gt; a) &amp;&amp; (b &gt; c)) 
    {
        maximum = b;
    }
    printf(""The Maximum among three is = %d"", maximum);
    return 0;
}
</code></pre>

<p>Edit: I wouldn't necessarily recommend this though - your original code in my opinion is easier to understand.</p>
",0
57258289,57252079,2,"<blockquote>
  <p>m just asking that is it possible to reduce the if statement. can i
  code all the conditions in the single if statement ?</p>
</blockquote>

<p>If you must use only <code>if</code> statements to determine the maximum, not ternary expressions, arithmetic, or any other flow-control statement, then you cannot do it by executing fewer than two <code>if</code> statements. Each one selects between two outcomes, and you must provide for three different possible outcomes.</p>

<p>You can write <em>simpler conditions</em>, as some other answers demonstrate, but you cannot execute fewer <code>if</code> statements.</p>

<p>Alternatively, if you are permitted to loop, then you can have one <code>if</code> statement that is executed twice:</p>

<pre><code>for (int i = 0; i &lt; 2; i++) {
    if (a &lt; b) a = b;
    b = c;
}
maximum = a;
</code></pre>

<p>Or if you are permitted to use a <code>switch</code> statement then you can do it with zero <code>if</code> statements, using the fact that conditional expressions evaluate to either 0 or 1:</p>

<pre><code>switch (((a &gt;= b) &lt;&lt; 2) | ((a &gt;= c) &lt;&lt; 1) | (b &gt;= c)) {
    case (1 &lt;&lt; 2) | (1 &lt;&lt; 1) | 0:
    case (1 &lt;&lt; 2) | (1 &lt;&lt; 1) | 1:
        // (a &gt;= b) and (a &gt;= c) both evaluate to 1, so a is the maximum
        maximum = a;
        break;
    case (1 &lt;&lt; 0):
        // a is not the maximum, and (b &gt;= c) evaluates to 1, so b is the maximum
        maximum = b;
        break;
    default:
        maximum = c;
        break;
}
</code></pre>

<p>Note that the <code>switch</code> expression evaluates <em>three</em> conditional sub-expressions, not just two, but there are no <code>if</code> statements. The expressions in the case labels are evaluated at compile time, not runtime; they could be manually precomputed, but giving them in the above form better shows how the values are related to the <code>switch</code> expression.</p>

<p><a href=""https://stackoverflow.com/a/57253126/2402272"">Another answer</a> hints at how you could use arithmetic alone to arrive at your result without any <code>if</code> statements (but nevertheless executing at least two conditional expressions).</p>
",0
58357561,58357028,0,"<p><s>You have missed an <code>&amp;</code> in the line with <code>scanf</code> before <code>num</code>. Correct code should be:</p>

<pre class=""lang-c prettyprint-override""><code>scanf(""%s"", &amp;num);
</code></pre>

<p>When you are scanning for the value, you need to provide the <strong>address</strong> of the variable. That is you let your program know where to put the value. <strong><code>&amp;num</code></strong> points to the address of the variable <code>num</code>. But if you just write <code>scanf(""%s"",num)</code> you are providing value of the <code>num</code> variable, which you don't care at all. You'll be overwriting that value anyway.</s></p>

<hr>

<p>At the end of the string, computer puts a null character <code>\0</code> whose ASCII value is 0, to denote that this is the end of the string. Kind of like a '.' but for a computer. So you check until you find the null character in the for loop like: <code>num[j] != '\0'</code> [Not EOF]</p>
",2
56100827,56100766,3,"<p>If this is your C file, then there are two things to note:</p>

<ol>
<li><p>You must declare the function (i.e. a prototype) <em>before</em> you can use it.</p></li>
<li><p>You cannot have executable code on the global level.</p></li>
</ol>

<p>Try:</p>

<pre><code>typedef struct state {
  char trans[100];
  bool final;
  struct state *next;
} STATE;

STATE *stu = NULL;

STATE* createList (STATE *stu, char trans, int states) {
    for (int i = states; i &gt; 0; i--) {
        printf(""%d"", i); /*ccode check*/
    }
    return stu;
}

int main (void)
{
    stu = createList(stu, trans, states);
    return 0;
}
</code></pre>

<p>Note that I didn't give a prototype in this example because the complete function is defined before it's used, so the compiler knows all about it.</p>
",6
54657773,54657708,0,"<p>After you chose a menu choice for the second time, you don't attempt to do anything with it.  You just leave the <code>switch</code> and hit the <code>return</code> at the end.</p>

<p>You need to add another loop, and only show the menu at the top of the loop:</p>

<pre><code>int main(void) {
    int userChoice = 0;
    char userInput[100];
    int index = 0;

    while (1) {
        userChoice = mainMenu();

        switch (userChoice) {
            case 1:
                printf(""Enter EXIT anytime to quit out of loop.\n"");
                do {
                    printf(""-&gt;"");
                    scanf(""%s"", userInput);
                } while (strcmp(userInput, ""EXIT"") != 0);
                break;
        }
    }
    return 0;
}
</code></pre>
",3
55784457,55784331,0,"<p>If you want to receive from the standard input varying numbers of values, you have to use several <code>scanf</code> statements. This is the general code:</p>

<pre><code>int a, b, c, d;

if (scanf(""%d %d %d %d"", &amp;a, &amp;b, &amp;c, &amp;d) == 4) /* 4 items supplied */
    . . . 
else if (scanf(""%d %d %d"", &amp;a, &amp;b, &amp;c) == 3) { /* 3 supplied */
    d = 0; /* zero out an unused value */
    . . .
}
else if (scanf(""%d %d"", &amp;a, &amp;b) == 2) { /* 2 supplied */
    c = d = 0; /* zero out an unused value */
    . . .
}
else if (scanf(""%d"", &amp;a) == 1) { /* 1 supplied */
    b = c = d = 0; /* zero out an unused value */
    . . .
}
else
    fprintf(stderr, ""Bad input"");
</code></pre>

<p>Note we start from the case with the greatest number of items. Then we work our way down. If we had started from the fewest number, then that case would test true even if more arguments were actually supplied.</p>
",3
56131956,56131754,1,"<p><code>while (!feof(..))</code> is normally not a good idea, instead write</p>

<pre><code>while (fgets(readLine,sizeof(readLine), fpointer) != NULL)
{
}
</code></pre>

<p>it seems ptr is superfluous in this context, if you want to check for words in the line you should move it forward in the line?</p>

<p>alt. use instead the runtime function strtok:</p>

<pre><code>for (ptr = strtok(readLine, "" ""); ptr != NULL; ptr = strtok(NULL, "" "")
{
   // now ptr will point to each word in the line, then you just check
   // if the first character is upper case.
 }    
</code></pre>
",0
56169443,56169074,0,"<p>A typical 32-bit long tops out at 4,294,967,295.<br>
You gave it 600,851,475,143, which is much much larger.</p>

<p>Be sure you compile on x64, and use <code>unsigned long long</code>.<br>
Then check for overflows.</p>
",0
58548788,58548710,0,"<p>If you're using a seekable file, you can store the current position using <code>ftell</code> and then try to read the next number - if scanf was successful, <code>fseek</code> back to the position returned by <code>ftell</code> and call the function.</p>

<p>If you're just reading from a generic stream that might not be seekable, you can peek <strong>one character</strong> forward. I.e. you can use a space at the <em>end</em> of the <code>*scanf</code> format to eat the white space, and then try to read one more character using <code>getchar</code>/fgetc<code>- if this looks like a digit, you can use</code>ungetc` to push it back to the stream.</p>
",2
58548786,58548710,0,"<p>Use a loop instead of an extra <code>scanf()</code> to check if you've reached the end.</p>

<pre><code>while (fscanf(fp, ""%d %d"", &amp;Head, &amp;Arms) == 2) {
    ...
}
</code></pre>
",0
58617800,58617713,0,"<p>Variables in C have a value (content) and they have a memory address (location) - the address may be optimized away by the compiler when not in use.</p>

<p>C passes arguments to functions by value (always), so the arguments (variables) in the function occupy a different memory location (even if they are initialized with the same value).</p>

<p>The value of the pointer can be manipulated (<code>p++</code>), effecting its data (changing the location to which <code>p</code> is pointing).</p>

<p>Pointers can also be dereferenced (<code>*p</code>), effecting the data in the location they point to.</p>

<p>In the function <code>test(int* p)</code>, the argument <code>p</code> is placed in the scope of the function. It can't accessed by other functions and it isn't available outside of the function (unless it's location is known by someone else, then they can access it).</p>

<p>When you edit the content of the <code>p</code> variable, it only effects the value of <code>p</code> within the function - it changes the location to which <code>p</code> is pointing.</p>

<p>However, when you <strong>dereference</strong> the value of <code>p</code>, you read / write to the location to which <code>p</code> is pointing (the location in the memory that holds the variable in <code>main</code>).</p>

<p>This is why the <code>p++</code> in <code>test</code> doesn't effect the value in <code>main</code>.</p>

<p>On the other hand, in the <code>swap</code> function, you were writing to the memory that held the variables in <code>main</code>, which has side effects in <code>main</code>.</p>
",9
57049854,57049672,1,"<p>You can't use <code>strtok</code> with two different strings at the same time.</p>

<p><code>strtok(string, delim)</code> stores its position in string internally for future calls to <code>strtok (NULL, delim)</code>. It can only remember one at a time. <code>strtok (tmpMsgBootForce, "" "")</code> says to look through <code>tmpMsgBootForce</code> and then <code>motdico = strtok (dicoActuel, "" "")</code> overwrites that with <code>dicoActuel</code>.</p>

<hr>

<p>What to use instead depends on your compiler. The <a href=""https://en.cppreference.com/w/c/string/byte/strtok"" rel=""nofollow noreferrer"">C standard defines <code>strtok_s</code></a>, but that's from the 2011 standard and <a href=""https://stackoverflow.com/questions/372980/do-you-use-the-tr-24731-safe-functions"">has proven to be controversial</a>. <a href=""https://pubs.opengroup.org/onlinepubs/9699919799/functions/strtok.html"" rel=""nofollow noreferrer"">POSIX defines <code>strtok_r</code></a>, most Unix compilers will understand that. Finally, <a href=""https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/strtok-s-strtok-s-l-wcstok-s-wcstok-s-l-mbstok-s-mbstok-s-l?view=vs-2019"" rel=""nofollow noreferrer"">Visual Studio has their own slightly different <code>strtok_s</code></a>.</p>

<p>They all work basically the same way. You manually store the position in each string you're iterating through.</p>

<p>Here it is using <code>strtok_r</code>. <code>next_tmpMsgBootforce</code> and <code>next_dicoActuel</code> hold the position for parsing <code>tmpMsgBootForce</code> and <code>dicoActuel</code> respectively.</p>

<pre><code> char *next_tmpMsgBootforce;
 char *next_dicoActuel;

 strcpy(tmpMsgBootForce, msgBootforce);

 mot = strtok_r(tmpMsgBootForce, "" "", &amp;next_tmpMsgBootforce);

 while (mot != NULL) {
      motdico = strtok_r(dicoActuel, "" "", &amp;next_dicoActuel);

      while (motdico != NULL) {
          if (strcmp(mot,motdico) == 0)   ++i;
          motdico = strtok_r(NULL, "" "", &amp;next_dicoActuel);
      }

      mot = strtok_r(NULL,"" "", &amp;next_tmpMsgBootforce);  
}
</code></pre>

<p>Because this is all such a mess, I recommend using a library such as <a href=""https://developer.gnome.org/glib/2.60/glib-String-Utility-Functions.html"" rel=""nofollow noreferrer"">GLib</a> to smooth out these incompatibilities and unsafe functions.</p>

<hr>

<p>As a side note, the <code>strcpy</code> and <code>strcat</code> are not safe. If their destination does not have enough space it will try to write outside its memory bounds. As with <code>strtok</code> the situation to do this safely is a mess. There's the non-standard but ubiquitous <code>strlcpy</code> and <code>strlcat</code>. There's the standard but not ubiquitous <a href=""https://en.cppreference.com/w/c/string/byte/strcpy"" rel=""nofollow noreferrer""><code>strcpy_s</code></a> and <a href=""https://en.cppreference.com/w/c/string/byte/strcat"" rel=""nofollow noreferrer""><code>strcat_s</code></a>. Thankfully for once Visual Studio follows the standard.</p>

<p>On POSIX systems you can use <code>strdup</code> to duplicate a string. It will handle the memory allocation for you.</p>

<pre><code>char *tmpMsgBootForce = strdup(msgBootForce);
</code></pre>

<p>The caveat is you have to <code>free</code> this memory at the end of the function.</p>

<p>Doing a <code>strcat</code> safely gets complicated. Let's simplify this by splitting it into two functions. One to do the searching.</p>

<pre><code>int theSearching(
    const char *msgBootforce,
    const char *dicoActuel
) {
     int i = 0;
     char *next_tmpMsgBootforce;
     char *next_dicoActuel;

     char *tmpMsgBootForce = strdup(msgBootforce);
     char *tmpDicoActuel = strdup(dicoActuel);

     char *mot = strtok_r(tmpMsgBootForce, "" "", &amp;next_tmpMsgBootforce);

     while (mot != NULL) {
          char *motdico = strtok_r(tmpDicoActuel, "" "", &amp;next_dicoActuel);

          while (motdico != NULL) {
              if (strcmp(mot,motdico) == 0) {
                  ++i;
              }
              motdico = strtok_r(NULL, "" "", &amp;next_dicoActuel);
          }

          mot = strtok_r(NULL,"" "", &amp;next_tmpMsgBootforce);  
    }

    return i;
}
</code></pre>

<p>And one to do the appending. This function ensures there's enough space for the concatenation.</p>

<pre><code>char *tryAppend( char *dest, const char *src, int *maxCorrepondance, const int numFound ) {
    char *new_dest = dest;

    if (numFound &gt; *maxCorrepondance) {
        *(maxCorrepondance) = numFound;

        // Allocate enough memory for the concatenation.
        // Don't forget space for the null byte.
        new_dest = realloc( dest, strlen(dest) + strlen(src) + 1 );
        strcat( new_dest, src);
    }

    // Return a pointer to the reallocated memory,
    // or just the old one if no reallocation was necessary.   
    return new_dest;
}
</code></pre>

<p>Then use them together.</p>

<pre><code>int numFound = theSearching(msgBootforce, dicoActuel);
bonResultatBootforce = tryAppend(bonResultatBootforce, msgBootforce, &amp;maxCorrepondance, numFound);
</code></pre>
",6
57049731,57049672,2,"<p>You can't have two uses of <code>strtok()</code> on two different strings being done at the same time.; <code>strtok()</code> has an internal pointer where it stores the address of the current string being processed. If you call <code>strtok()</code> with a string and then call <code>strtok()</code> with a different string then when you do <code>strtok(NULL, delim)</code> it will continue with the last string that was specified.</p>

<p>See <a href=""https://en.cppreference.com/w/c/string/byte/strtok"" rel=""nofollow noreferrer"">https://en.cppreference.com/w/c/string/byte/strtok</a></p>

<blockquote>
  <p>This function is destructive: it writes the '\0' characters in the
  elements of the string str. In particular, a string literal cannot be
  used as the first argument of strtok.  Each call to strtok modifies a
  static variable: is not thread safe.  Unlike most other tokenizers,
  the delimiters in strtok can be different for each subsequent token,
  and can even depend on the contents of the previous tokens.  The
  strtok_s function differs from the POSIX strtok_r function by guarding
  against storing outside of the string being tokenized, and by checking
  runtime constraints.</p>
</blockquote>

<p>There is a new version of the <code>strtok()</code> function <code>strtok_s()</code> which has an additional argument of an address for a pointer variable to use instead of the internal pointer variable that <code>strtok()</code> uses.</p>
",0
56316516,56316289,1,"<p>It only has to work in the range of an unsigned long long.</p>

<pre><code>const char *eptr;
unsigned long long numeric = strtoull(str, &amp;eptr, 16);
if (eptr == str || numeric == 0) {
    /* handle error */
}
sprintf(str, ""0x%llx"", numeric - 1);
</code></pre>

<p>We can't do this for signed hex in place because decrementing 0 or certain negative numbers would make the string longer.</p>

<p>In theory, 0 should work for the third argument to strtoull, but it's buggy in our libc right now so it doesn't.</p>
",13
54835116,54834969,2,"<p>You are allocating space for <code>arr</code>, which is a pointer to a pointer to <code>char</code>, but not allocating any individual <code>char *</code> pointers within <code>arr</code>.</p>

<p>Since you allocated <code>arr</code> with the size of <code>100 * sizeof(char *)</code>, I assume you want 100 sub-entries in <code>arr</code>. Sure:</p>

<pre><code>for(i = 0; i &lt; 100; i++)
     arr[i] = malloc(80 * sizeof(char));
</code></pre>

<p>Then, when you free <code>arr</code>:</p>

<pre><code>for(i = 0; i &lt; 100; i++)
    free(arr[i]);

free(arr);
</code></pre>

<p>Note that it is good practice to always check <code>malloc</code> for failure (return value of <code>NULL</code>) and handle it, and to set pointers to <code>NULL</code> after freeing them once to avoid double-free bugs.</p>
",0
55606897,55605991,1,"<p>According to <a href=""https://www.gnu.org/software/make/manual/make.html#Running"" rel=""nofollow noreferrer"">this GNU <code>make</code> documentation</a>, the GNU make program will try to use <code>GNUMakefile</code>, <code>makefile</code> or <code>Makefile</code>.</p>

<p>The <code>make</code> program will <em>not</em> try <code>makefile.mk</code>, which means that e.g. <code>make linked</code> will use no makefile and only the default rules.</p>

<p>You can solve this by either renaming your makefile as <code>Makefile</code> (the most common) or <code>makefile</code>; Or by using the <code>-f</code> option to specify the makefile</p>

<pre><code>$ make -f makefile.mk linked
</code></pre>
",1
58519740,58519619,1,"<p>Use dynamic memory allocation in a linked list. Look at <code>malloc</code>. Your list structure could look like:</p>

<pre><code>typedef struct COURSES {
    int courseCode;
    int courseDay;
    int courseTime;
    struct COURSES *next;
} t_Courses;
</code></pre>

<p>You allocate a list element as follows:</p>

<pre><code>    t_Courses *pCourse= malloc(sizeof(t_Courses));
</code></pre>

<p>and then read the data as you do now, e.g.:</p>

<pre><code>    scanf_s(""%d"", &amp;pCourse-&gt;courseCode);
</code></pre>

<p>Managing a linked list is not simple. I leave it to you as part of the homework. There are numerous examples on the internet and on Stack Exchange.</p>
",2
55714169,55713996,3,"<p>Your program is not fully responsive to the prompt, which says</p>

<blockquote>
  <p>[...] <em>Write a program that will <strong>initialize the variable in the declaration</em></strong> [...]</p>
</blockquote>

<p>.  Doing as instructed will simplify your code somewhat, just as you are looking to do.  For example:</p>

<pre><code>struct student student1 = { .name = ""C,Joe"", .id_no = 999, .quiz = { 10.0, 9.5, 0.0, 10.0 }};
</code></pre>

<p>As long as you provide initializers in member-declaration order, without skipping, you can abbreviate that further by omitting the member designators and providing only the initialization values.  I prefer to use the designators, though, as I find it clearer.</p>

<blockquote>
  <p>Further, I coded the values for each student separately, but struggled
  to get a single print statement to work for all the students, and
  instead had to include separate print statements for each student. I
  suspect there's a better way to do this by looping, but I cannot get
  it to work.</p>
</blockquote>

<p>If you want to loop, then you need some kind of data structure that supports iteration.  Arrays are the obvious kind, but a linked list could work, too.  Taking the array route, you might avoid individual variables for the students, like so:</p>

<pre><code>struct student students[] = {
    { .name = ""Alice"", .id_no = 42, .quiz = { 1.0, 2.5, 3.0, 0.0 }},
    { .name = ""Bob"", .id_no = 99, .quiz = { 10.0, 9.5, 8.0, 7.0 }},
    // ...
};
</code></pre>

<p>You can then loop over the array, operating at each iteration on <code>students[i]</code>, for <code>i</code> in the range of valid indices of <code>students</code>.</p>
",2
55830116,55830039,4,"<p><code>team1</code> is not an <code>int</code>, it is an array of <code>int</code> of size <code>4</code>. Arrays <em>""decay""</em> to pointers when passed to functions, which explains why you're seeing that error message.</p>

<p>You need to individually print all elements, for example with a <code>for</code> loop.</p>

<hr>

<p>Your <code>scanf</code> calls are also incorrect - you are reading a single elements outside of the bounds of the <code>team1</code> array, which is undefined behavior. You need to scan each element with a loop.</p>
",0
56194092,56194020,1,"<p>You simply need to count the iterations and on every 50th, the the ""work"":</p>

<pre><code>int count = 0 ;
for(;;)
{
     // do xxxx on array element on every iteration
     xxxx(  array[count] ) ;

     if( count == N - 1 )
     {
         count = 0 ;

         // Do yyyy this every N iterations
         yyyy() ;
     }

     count++ ;
}
</code></pre>

<p>An alternative interpretation of your question:</p>

<pre><code>int count = 0 ;
for(;;)
{
     // Process whole array on every iteration
     for( int i = 0; i &lt; sizeof(array)/sizeof(*array); i++ )
     {
         xxxx( array[i] ) ;
     }

     if( count == N - 1 )
     {
         count = 0 ;

         // Do yyyy this every N iterations
         yyyy() ;
     }

     count++ ;
}
</code></pre>
",5
58526696,58526306,1,"<p>Writing a back space in a file won't erase the last character written to the file, it just will write the <code>\b</code> value (which is 8 I think) to the file.</p>

<p>Also your code writes a NUL character after each character written, which is strange (if not wrong) for a text file. I suppose you want to write a text file because you open the file with <code>""wt""</code>.</p>

<p>You probably want this:</p>

<pre><code>FILE *fout;
fout = fopen(FILENAME, ""wt"");  // you probbaly want fopen here, not fopen_s
if (fout == NULL)              // fopen can fail
{
  // show error message and abort
  ...
}
char data[3] = {'A', 'B', 'C'};

for (int i = 0; i &lt; 3; i++){
    fputc(data[i], fout);   // write character
    if (i &lt;= 2)
      fputc('\n', fout);    // write a line ending if we're not on the last line
}

fclose(fout);
</code></pre>

<p>The file will contain 3 lines, and the last line won't end with a <code>\n</code>.</p>

<p>It will look like this:</p>

<pre><code>A
B
C
</code></pre>
",1
57779805,57779741,3,"<p>As mentioned in the comments, you are using <code>int</code> instead of <code>float</code> or <code>double</code>, therefore you won't get the precision that you require. Also your conversion for miles to km is incorrect; there are <code>1.60934</code> kilometers for every <code>1</code> mile.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {

double kilometers;
double miles;

printf(""\nPlease enter the distance in miles: "");
scanf(""%lf"", &amp;miles);
printf(""\n"");

kilometers = 1.60934 * miles;

printf(""%.2lf miles is equal to "", miles);
printf(""%.2lf kilometers\n\n"", kilometers);

return 0;

}
</code></pre>
",0
58310767,58309549,1,"<p>There are multiple problems with your question:</p>

<ol>
<li><blockquote>
  <p>So I try to use Arbitrary Precision Arithmetics</p>
</blockquote></li>
</ol>

<p><code>long double</code> is not arbitrary precision, it's simply <em>extended</em> precision. Arbitrary precision is a mechanism to get arbitrarily many significant digits (up to memory available), while here you only have 64.</p>

<ol start=""2"">
<li><blockquote>
  <p><code>long            mant:64;</code></p>
</blockquote></li>
</ol>

<p>On a 32-bit system this won't compile, because <code>long</code> will likely be 32-bit. You should use <code>unsigned?long?long</code> or <code>uint64_t</code> (note the unsignedness: signed bit fields can lead to surprises). And actually, this doesn't have to be a bit field if you use <code>uint64_t</code>: the type itself is exactly 64 bit wide.</p>

<ol start=""3"">
<li>In the x87 80-bit format, as in all IEEE 754 binary formats, exponent is biased. In particular, in the 80-bit extended precision x87 format the biased exponent to represent <code>1.0</code> is <code>0x3fff</code>. So you can't simply put a <code>0</code> in this field and expect the number to be r¡Á2?.</li>
</ol>

<p>With this in mind we can write an example with your definitions amended:</p>

<pre><code>#include &lt;stdint.h&gt;
#include &lt;math.h&gt;

typedef struct  s_arith
{
    uint64_t        mant;
    uint16_t        exp:15;
    uint8_t         sign:1;

}               t_arith;

union u_dbl
{
    t_arith         arith;
    long double     ldbl;
};

#include &lt;stdio.h&gt;

int main()
{
    const uint64_t mant=0xc000000000000000;
    const int expo=5;
    const union u_dbl d={mant,0x3fff+expo,0};
    printf(""%Lg\n"", d.ldbl);
}

</code></pre>

<p>This outputs <code>48</code> on my system (32-bit x86 Linux with gcc), as expected?¡ª because highest two bits of the significand are set, and others cleared, and the value is 1.5¡Á2?.</p>

<p>But actually, to portably load a floating-point number from an integer significand and an exponent, you should use the already existing function from <code>&lt;math.h&gt;</code> header: <code>ldexp</code>. Here's how you could do this:</p>

<pre><code>#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

int main()
{
    const uint64_t mant=0xc000000000000000;
    const int expo=5;
    const long double x=ldexp(mant, expo-63);
    printf(""%Lg\n"", x);
}
</code></pre>

<p>The <code>-63</code> shift here compensates for the fact that the first argument of <code>ldexp</code> is taken as the value to be multiplied by <code>2^(second_argument)</code>, instead of simply being put into the significand field of the resulting number representation.</p>

<p>Note also that even on x86 architecture, not all compilers have 80-bit <code>long?double</code>: e.g. Microsoft ones have 64-bit <code>long?double</code>?¡ª same as simply <code>double</code>.</p>
",4
54632874,54632282,0,"<p>Standard timing methods including <code>clock()</code> are provided in time.h.  One function that might be used is <code>time()</code>:</p>

<pre><code>time_t start = time(NULL) ;

// Something that takes time here...

// Elapsed time in minutes+seconds.
int f = time(NULL) - start ;
int min = f / 60 ;
int sec = f % 60 ;
</code></pre>

<p>Non-standard means may be provided by your platform such as Windows performance counters.</p>

<p>Strictly the return value from <code>time()</code> need not be in seconds and the <code>difftime()</code> function should be used rather than <code>time(NULL) - start</code>, but you are unlikely to encounter a system where <code>time_t</code> is not in seconds, and <code>difftime()</code> returns a <code>double</code> which may not be desirable in some cases:</p>

<pre><code>int f = (int)difftime( time(NULL), start ) ;
int min = f / 60 ;
int sec = f % 60 ;
</code></pre>
",1
56417030,56416733,0,"<p>You should create the struct object like this:</p>

<pre><code>const Header FileHeader = { filesize, 0, argv[i] };
</code></pre>

<p>Just the way you created the global object above.</p>
",0
56652617,56652525,1,"<p>You can send the port number to the client the same way you send the IP address of the server.</p>

<p>In order to connect over TCP, the client needs to know the IP address and the non-zero port number of the server.</p>

<p>If the client and the server are running on the same computer, it's typical to use files, environment variables or the clipboard to communicate the IP address and the port number.</p>

<p>In your example, you can add a <em>printf</em> to server.c to print the IP address and the port number (get them using the function <em>getsockname</em>). Then you can add code to client.c to get the IP address from <code>argv[1]</code> and the port number from <code>argv[2]</code>. Once done with the code changes above, you start the server first, copy the printed IP address and port number to the clipboard, and paste it to the command-line of the client, then you press <em>Enter</em> to start the client, and it will get these 2 parameters in its <code>argv</code>.</p>
",4
56305711,56305687,2,"<p>You did not initialise any of your variables, nor perform any error checking.</p>

<p>Do this:</p>

<pre><code>int numstu = 0, count = 0, a = 0;
int sum1 = 0, sum2 = 0, sum3 = 0, sum4 = 0, sum5 = 0;
</code></pre>

<p>and check the result of <code>scanf</code>.</p>

<p><em>(declarations split up for readability)</em></p>
",0
57249150,57249116,0,"<p>The size of the ""inner"" array can not be deduced, you must specify its size explicitly:</p>

<pre><code>static const XCHAR sNo[3][4] = { ... };  // 4 to fit three characters plus terminator
</code></pre>
",1
56400592,56400418,0,"<p>You could think of the list as a stack. Then you could easily reverse such a list by ""popping"" the nodes and ""pushing"" them into a new list.</p>

<p>The above could be done both destructively (destroying the old list) and non-destructively (creating the new list as a reversed copy of the original list).</p>
",0
58350148,58350125,2,"<p>Take a moment to examine the table of modes in the <a href=""https://en.cppreference.com/w/c/io/fopen"" rel=""nofollow noreferrer"">documentation for fopen</a>.</p>

<p>You'll see that the <code>w+</code> mode will create a new file if one doesn't exist, or destroy the contents if the file exists.</p>

<p>So, after your call to <code>fopen</code>, you are guaranteed to have an empty file.  The next thing you attempt to do is read data from it, which of course will fail.  Your program has bogus output (undefined behavior) because you don't even test whether the operation succeeded and you output an uninintialized value.</p>

<p>Perhaps what you were wanting is to use the <code>a+b</code> open mode.  That's evident by the fact you immediately call <code>rewind</code>.  Of course, you still need to deal with the failed call to <code>fread</code> when this file is first created.</p>
",0
56497364,56497237,2,"<pre><code>#include &lt;limits.h&gt;
if (P2 &gt; INT_MAX - P1) {
   printf(""Overflow would occur\n"");
}
</code></pre>

<h2>Explanation:</h2>

<p><code>INT_MAX - P1</code> is the biggest value you can add to <code>P1</code> without overflow.<br>
If <code>P2</code> is bigger than that value, then it is too big, and overflow would occur.</p>

<hr>

<p>If you need to check for an underflow as well, the math idea is the same:</p>

<pre><code>if ( -P2 &lt; P1 - INT_MIN) {
    printf(""Underflow would occur\n"");
} 
</code></pre>

<h2>Explanation</h2>

<p><code>(P1 - INT_MIN)</code> is the biggest* value that could be subtracted from <code>P1</code> without underflowing.  If <code>-P2</code> is even more negative than that, then underflow would occur on addition.</p>

<p>* Biggest by magnitude, not by value.</p>
",4
56419507,56419404,0,"<p>First, you have no error checking. That makes your program difficult to use.</p>

<p>Second, you output every character unconditionally and then output newlines an extra time. What you want to do is output every character once, unless it's a newline right after a newline (as that would create an empty line) in which case you don't want to output it.</p>

<p>Here's the code fixed up:</p>

<pre><code>#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;

int main(int argc, char **argv)
 {
    if (argc &lt; 2)
    {
         fprintf (stderr, ""An argument is required\n"");
         return -1;
    }

    char *name = argv[1];

    FILE *f = fopen(name, ""r"");
    if (f == NULL)
    {
        fprintf (stderr, ""Unable to open file for reading\n"");
        return -1;
    }

    char x, px = '\n';

    while(fscanf(f, ""%c"" , &amp;x) &gt; 0)
    {
            // don't output a newline after a newline
            if ((x != '\n') || (px != '\n'))
                printf(""%c"", x);

            // keep track of what character was before the next one
            px = x;
    }
}
</code></pre>

<p>It really would be much easier to just read each line in and then output the line if it's non-empty.</p>
",0
55976596,55976469,3,"<p>If you know ahead of time exactly how many items will be in your list, then you're probably better off using an array rather than a list. The whole point of a linked list is to be able to grow to an unknown size at runtime, and that requires dynamic memory allocation (i.e., malloc).</p>
",2
56008990,56008131,1,"<p>Take notice of your compiler warnings.</p>

<pre><code>bool even(long long x){
    int checkv = 0;
    int pal = x;            // compiler warning here
    int con = 0;            // used to take value from pal
</code></pre>

<p>You are immediately losing the significance in the <code>long long x</code> by assigning it to <code>int pal</code>. The same mistake is in another function too:</p>

<pre><code>bool odd(long long  x){
    int checkv = 0;
    int pal = x;            // compiler warning here
    int con = 0;            // used to take value from pal
</code></pre>
",3
57953252,57953140,1,"<p>Your comparison function has two problems:</p>

<p>1) Since the parameters are <code>const</code>, you need a pointer to <code>const</code>:</p>

<pre><code>Station_t *pleft = (Station_t *)p1;
</code></pre>

<p>should be</p>

<pre><code>const Station_t *pleft = p1;  // There is no need to cast
</code></pre>

<p>2) Is not enough to return <code>a &gt; b</code></p>

<p>Return value meaning:</p>

<pre><code>&lt;0 The element pointed by p1 goes before the element pointed by p2

0  The element pointed by p1 is equivalent to the element pointed by p2

&gt;0 The element pointed by p1 goes after the element pointed by p2
</code></pre>

<p>You want:</p>

<pre><code>return pleft-&gt;distance &lt; pright-&gt;distance ? -1  : pleft-&gt;distance &gt; pright-&gt;distance;
</code></pre>

<p>In this way it returns <code>-1</code>, <code>0</code> or <code>1</code> depending on <code>a &lt; b</code>, <code>a == b</code> or <code>a &gt; b</code></p>
",3
56200928,56200878,0,"<blockquote>
  <p>From my understanding modulus just prints out whether or not it has a remainder but I'm apparently wrong here.</p>
</blockquote>

<p>You are right, but only in so far as you recognize that you are wrong.</p>

<p>You think too complicated: modulus is not the decision if there is a remainder or not, but it just <em>is</em> the remainder. 0 thus means ""no reminder"", and so the modulo operation can be used in a boolean context.</p>

<p>This obviously leaves opwn what is meant by ""division remainder"".</p>

<p>Division per se is the question ""If I have X objects and distribute it to Y targets, how many will each recipient get?""</p>

<p>The result differs whenther or nit I can divide a single object.</p>

<p>Assume I have 25  (or $ or whatever) and want to distribute them to 4 people. Then we all assume that each is entitled to 6,25 . But what happens if I oby have 1  coins? Then I can distribute only 6  to each, and I will have 1  left which cannot be distributed in a fair way.</p>

<p>So this shows the two possible results of 25 / 4:</p>

<ul>
<li>In floating point division, I get 6.25, and the reverse operation 6.25 * 4 gets 25 again, the original value.</li>
<li>In integer division, I get 6. But the reverse operation 6 * 4 doesn't get 25, but 24, so I have a remainder of 1.</li>
</ul>

<p>On other words: The remainder of <code>x / y</code> is the result of <code>x - (x / y) * y</code>.</p>

<p>If any doubts are still open, Wikipedia has a lemma about the <a href=""https://en.wikipedia.org/wiki/Modulo_operation"" rel=""nofollow noreferrer"">modulo operation</a> as well.</p>
",1
56089081,56088320,3,"<p>To be clear, there is nothing ""broken"" about <code>strcpy()</code>; if it has <em>""has caused some problems in the past""</em> for you, that that is because of errors in your usage, not any intrinsic issue with <code>strcpy()</code>, and you should perhaps post a question about that so your misconceptions can be corrected.</p>

<p>The semantics between <em>string pointer assignment</em> and <em>string copy</em> differ, so it depends what you are trying to do.</p>

<p><code>x</code> is an array of pointers.  The assignment:</p>

<pre><code>x[0] = q[0];
</code></pre>

<p>Does <em>not</em> copy the string pointed to by <code>q[0]</code> to the memory pointed to by <code>x[0]</code>.  rather it changes the value of <code>x[0]</code> to the address of the string referred to by <code>q[0]</code>. So they both refer to the <em>same string</em> in memory.  No string data is <em>moved</em> or <em>copied</em>, only the reference to the string literals in this case:</p>

<pre><code>q[0] --&gt; ""Hello""
          ^
          |
x[0] -----
</code></pre>

<p>In this sense <code>x</code> is not <em>""a new array of strings""</em> as you describe, but an array of pointers to the <em>same strings</em>.  So is perhaps not the semantic behaviour you intended. </p>

<p>If you were to attempt:</p>

<pre><code>strcpy( x[0], q[0] ) ;
</code></pre>

<p>That would be a semantic error since in your fragments <code>x[0]</code> does not point to any defined memory, so the string data referred to by <code>q[0]</code> will be <em>copied</em> to some undefined location with undefined results - none good, even if it superficially <em>appears</em> to work.</p>

<p>If <code>x[0]</code> referred to some validly allocated space by for example either being declared as an array thus:</p>

<pre><code>char x[2][128] ;
</code></pre>

<p>or being dynamically allocated:</p>

<pre><code>x[0] = malloc( 128 ) ;
</code></pre>

<p>or by first being assigned to some other valid space:</p>

<pre><code>char a[120]
x[0] = a ;
</code></pre>

<p>Or by dynamically allocating <code>a</code> as in the example in your question.</p>

<p>Then <code>strcpy( x[0], q[0] )</code> is a valid operation and would <em>copy</em> the string referred to by <code>q[0]</code> to the space referred to by <code>x[0]</code>:</p>

<pre><code>q[0] --&gt; ""Hello""

x[0] --&gt; ""Hello""
</code></pre>

<p>Critically in this case the strings do not refer to the same space in memory.</p>

<p>Note that if you actually wanted <em>string pointer assignment</em> semantics (which is probably less likely), and <code>q</code> refers to <em>literal string constants</em>, then for safer code it is important that you declare the arrays as pointers to <code>const</code> data:</p>

<pre><code>const char* q[2] ;
const char* x[2] ;
</code></pre>

<p>The <code>q</code> array should be declared <code>const</code> in this case in any event, but clearly <code>x</code> should not be const if you want <em>string-copy</em> semantics.  </p>

<p>Helpfully by declaring it <code>const</code>, any attempt to <code>strcpy()</code> to it will fail deterministicly at compilation rather than having some undefined and erroneous and possibly latent run-time behaviour.  So it enforces the intended semantics if that is indeed what you intended.  Equally it stops you from attempting to modify the data referred to by <code>q[n]</code> which would also be undefined behaviour (but will generally cause a runtime error on a modern desktop OS).</p>
",0
58924736,58923798,1,"<p>Before adapting your solution to generate the desired output, it would help to see the wood for the trees by removing the redundancy from your current solution:</p>

<p>In this solution, <code>n == i</code> is invariant  so <code>n</code> is redundant, and the array <code>ini[]</code> is entirely redundant, because you only ever read/write <code>ini[i]</code> and <code>ini[i] == i</code> is invariant, so all instances of <code>n</code> and <code>ini[i]</code> can be replaced with <code>i</code>.  <code>j</code> is just unused.  Then neither <code>i</code> nor <code>d</code> are used before or after the loops they control, so can be localised by declaring them in the loop thus minimising the scope (just good practice).</p>

<p>Then your code reduces to the following equivalent:</p>

<pre><code>int main() {
    for( int i = 1; i &lt;= 100; i++){
        for( int d = 1; d &lt;= i; d++){
            if (i % d == 0)
                printf(""%d: %d\n"", i, d);
        }    
    }    

    return 0 ;
}
</code></pre>

<p>Now to obtain the required output, you don't know the number of factors until you have determined the list of factors, so the solution is to generate the list first while counting, then print the output.  </p>

<p>That can be done in a second loop printing an array of stored factors, or even a second loop that recalculates the factors a second time - but those answers have already been given. Instead you could directly generate the list string as you go, then append it to the number/count output:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() 
{
    for( int i = 1; i &lt;= 100; i++ )
    {
        char factor_list_out[80] = """" ;
        int factor_count = 0 ;
        int factor_out_index = 0 ;

        for( int d = 1; d &lt;= i; d++)
        {
            if( i % d == 0)
            {
                factor_count++ ;
                factor_out_index += sprintf( &amp;factor_list_out[factor_out_index], ""%d,"", d ) ;
            }
        }

        factor_list_out[factor_out_index - 1] = 0 ; // remove trailing comma
        printf( ""%3d:(%2d) %s\n"", i, factor_count, factor_list_out ) ;
    }

    return 0 ;
}
</code></pre>

<p>Output:</p>

<pre><code>  1:( 1) 1
  2:( 2) 1,2
  3:( 2) 1,3
  4:( 3) 1,2,4
  5:( 2) 1,5
  6:( 4) 1,2,3,6
  7:( 2) 1,7
  8:( 4) 1,2,4,8
  9:( 3) 1,3,9
 10:( 4) 1,2,5,10
 11:( 2) 1,11
 12:( 6) 1,2,3,4,6,12
 13:( 2) 1,13
 14:( 4) 1,2,7,14
 15:( 4) 1,3,5,15
 16:( 5) 1,2,4,8,16
 17:( 2) 1,17
 18:( 6) 1,2,3,6,9,18
 19:( 2) 1,19
 20:( 6) 1,2,4,5,10,20
 21:( 4) 1,3,7,21
 22:( 4) 1,2,11,22
 23:( 2) 1,23
 24:( 8) 1,2,3,4,6,8,12,24
 25:( 3) 1,5,25
 26:( 4) 1,2,13,26
 27:( 4) 1,3,9,27
 28:( 6) 1,2,4,7,14,28
 29:( 2) 1,29
 30:( 8) 1,2,3,5,6,10,15,30
 31:( 2) 1,31
 32:( 6) 1,2,4,8,16,32
 33:( 4) 1,3,11,33
 34:( 4) 1,2,17,34
 35:( 4) 1,5,7,35
 36:( 9) 1,2,3,4,6,9,12,18,36
 37:( 2) 1,37
 38:( 4) 1,2,19,38
 39:( 4) 1,3,13,39
 40:( 8) 1,2,4,5,8,10,20,40
 41:( 2) 1,41
 42:( 8) 1,2,3,6,7,14,21,42
 43:( 2) 1,43
 44:( 6) 1,2,4,11,22,44
 45:( 6) 1,3,5,9,15,45
 46:( 4) 1,2,23,46
 47:( 2) 1,47
 48:(10) 1,2,3,4,6,8,12,16,24,48
 49:( 3) 1,7,49
 50:( 6) 1,2,5,10,25,50
 51:( 4) 1,3,17,51
 52:( 6) 1,2,4,13,26,52
 53:( 2) 1,53
 54:( 8) 1,2,3,6,9,18,27,54
 55:( 4) 1,5,11,55
 56:( 8) 1,2,4,7,8,14,28,56
 57:( 4) 1,3,19,57
 58:( 4) 1,2,29,58
 59:( 2) 1,59
 60:(12) 1,2,3,4,5,6,10,12,15,20,30,60
 61:( 2) 1,61
 62:( 4) 1,2,31,62
 63:( 6) 1,3,7,9,21,63
 64:( 7) 1,2,4,8,16,32,64
 65:( 4) 1,5,13,65
 66:( 8) 1,2,3,6,11,22,33,66
 67:( 2) 1,67
 68:( 6) 1,2,4,17,34,68
 69:( 4) 1,3,23,69
 70:( 8) 1,2,5,7,10,14,35,70
 71:( 2) 1,71
 72:(12) 1,2,3,4,6,8,9,12,18,24,36,72
 73:( 2) 1,73
 74:( 4) 1,2,37,74
 75:( 6) 1,3,5,15,25,75
 76:( 6) 1,2,4,19,38,76
 77:( 4) 1,7,11,77
 78:( 8) 1,2,3,6,13,26,39,78
 79:( 2) 1,79
 80:(10) 1,2,4,5,8,10,16,20,40,80
 81:( 5) 1,3,9,27,81
 82:( 4) 1,2,41,82
 83:( 2) 1,83
 84:(12) 1,2,3,4,6,7,12,14,21,28,42,84
 85:( 4) 1,5,17,85
 86:( 4) 1,2,43,86
 87:( 4) 1,3,29,87
 88:( 8) 1,2,4,8,11,22,44,88
 89:( 2) 1,89
 90:(12) 1,2,3,5,6,9,10,15,18,30,45,90
 91:( 4) 1,7,13,91
 92:( 6) 1,2,4,23,46,92
 93:( 4) 1,3,31,93
 94:( 4) 1,2,47,94
 95:( 4) 1,5,19,95
 96:(12) 1,2,3,4,6,8,12,16,24,32,48,96
 97:( 2) 1,97
 98:( 6) 1,2,7,14,49,98
 99:( 6) 1,3,9,11,33,99
100:( 9) 1,2,4,5,10,20,25,50,100
</code></pre>
",0
58923990,58923798,2,"<p>Aw, c'mon, let's have a little fun here. Everyone else is suggesting the ""usual"" way. But Back In The Day (tm) we didn't have memory to waste on things like keeping track of stuff. We just used the paper as our memory! :-)</p>

<p>I suggest looping over the values to be tested (1 - 100), then inside the first loop have another loop which counts from from 1 to n, printing the divisor values which give a remainder of zero. At the end of the loop I'd overprint the <code>n</code> value and then add in the number of factors found, then loop back for the next value.</p>

<p>In code this looks a lot like:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
  {
  int n, d, i;
  int factor_count;

  for (n = 1 ; n &lt;= 100 ; n += 1)
    {
    printf(""%3d(   ): "", n);

    factor_count = 0;

    for (d = 1 ; d &lt;= n ; d += 1)
      {
      if (n % d == 0)
        {
        printf(""%c%d"", (factor_count &gt; 0 ? ',' : ' '), d);
        factor_count += 1;
        }
      }

    printf(""\r%3d(%3d)\n"", n, factor_count); 
    }
  }
</code></pre>

<p>This code takes advantage of the fact that <code>\r</code> returns the print carriage (or the cursor on video terminals) to the left margin without advancing the roller (or the cursor - really, the cursor is <em>far</em> too busy and needs a rest! :-) to the next line, in order to avoid having to keep an array to store the factors in. It would be a lot of fun to watch run on an old ASR-33 Teletype - anybody got one to test with?</p>

<p>:-)</p>
",5
58923922,58923798,0,"<p>Put all the divisors in an array. Then print the elements of the array in the format required. You can also count the number of divisors as you're finding them.</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    for (int i = 1; i &lt;= 100; i++){
        int divisors[100];
        int counter = 0;
        for (int d = 1; d &lt;= i; d++){
            if (i % d == 0) {
                divisors[counter] = d;
                counter++;
            }
        }
        printf(""%d (%d): "", i, counter);
        for (int j = 0; j &lt; counter; j++) {
            printf(""%s%d"", (j == 0 ? """" : "",""), divisors[j]);
        }
        printf(""\n"");
    }
}
</code></pre>
",0
55873650,55873588,2,"<p>The return type of <code>getc()</code> is <code>int</code>, but your <code>str</code> variable is <code>char</code>. It might be the case that your system uses a value of <code>EOF</code> that is outside the range of a <code>char</code>.</p>
",0
55875403,55873588,1,"<p>line 13, getc() returns an int.  you need to convert it to char</p>

<p>since the int is not possible you are getting a NULL</p>

<p>fgetc() is a more likely answer. 
look at;
 <a href=""http://better%20Explained"" rel=""nofollow noreferrer"">https://stackoverflow.com/questions/1835986/how-to-use-eof-to-run-through-a-text-file-in-c</a>  </p>

<p>it better explains the return</p>
",0
58143250,58143229,0,"<p>Your problem is on this line:</p>

<pre><code>if (p2==p1)
</code></pre>

<p>You're comparing the memory addresses to see if they are equal, but NOT the contents stored at (i.e. pointed to in) them. To compare the passwords, instead use:</p>

<pre><code>if (strcmp(p2, p1) == 0)
</code></pre>

<p>See: <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_strcmp.htm"" rel=""nofollow noreferrer"">https://www.tutorialspoint.com/c_standard_library/c_function_strcmp.htm</a></p>
",4
58157961,58157852,1,"<p>The first step of debugging a problem is validating you have the problem you're considering fixing.</p>

<pre><code>for (int i = 0; i &lt; numberOfNumbers; i++) {
    scanf(""%d"", &amp;num);
    numbers[i] = num;
}
</code></pre>

<p>Is the loop that you are thinking of fixing.</p>

<pre><code>printf(""entering loop\n"");
for (int i = 0; i &lt; numberOfNumbers; i++) {
    printf(""i is %d, numberOfNumbers is %d\n"", i, numberOfNumbers);
    scanf(""%d"", &amp;num);
    numbers[i] = num;
}
printf(""loop finished\n"");
</code></pre>

<p>is the code you would would need to completely validate that your guess about the loop is correct (or wrong).</p>

<p>I hope this helps, even if it is not a direct answer.  Your code looks good, but could be wrong based on a lot of items (including the user input).</p>
",1
54657512,54657498,0,"<p>The idiomatic way to swap two variables is indeed to add a <code>temp</code> variable:</p>

<pre><code>void swap(T *a, T *b)
{
    T temp = *a;
    *a = *b;
    *b = temp;
}
</code></pre>

<p>Now, to sort three values into ascending order, a full fledged sorting algorithm would indeed be overkill. You can do this just with a few compares and <code>swap</code>s.</p>
",0
56534834,56533887,3,"<p>There are several possible solutions, none of which satisfy all of your requirements.</p>

<p>A call to <code>malloc</code> is the obvious solution; that's what it's for. You've said you don't want to use <code>malloc</code>, but you haven't explained why.</p>

<p>C does support variable-length arrays -- more or less. VLAs did not exist in C90, were introduced in C99, and were made optional in C11. So if you want portable code, you can't assume that they're supported. If they are, you can do something like this:</p>

<pre><code>int size;
// get value of size from input
int vla[size];
</code></pre>

<p>There are some restrictions. If there isn't enough memory (stack size can be more restrictive than heap size), the behavior is undefined. On the other hand, the same is true for ordinary fixed-size arrays, and VLAs can let you allocate a smaller amount of memory rather than assuming a fixed upper bound. VLAs exist only at block scope, so the object will cease to exist when control leaves the enclosing block (typically when the function returns).</p>

<p>You could define an array (probably at file scope, outside any function definition) that you know is big enough for your data. You'll have to specify some upper bound. For example, you can define <code>int arr[10000];</code> and then reject any input bigger than 10,000. You could then use an initial subset of that array for your data.</p>

<p>You say you want to create a ""variably-sized array"", but you ""do not want to use malloc/other dynamic array methods"". It sounds like you want to create a dynamic array, but you don't want to create a dynamic array. It's like saying you want to drive a screw, but you don't want to use a screwdriver.</p>
",0
56535460,56533887,0,"<p>Any language which supports variable length arrays uses dynamic memory allocation mechanism underneath to implement the functionality. 'C' does not have a syntactic sugar which supports true variable length arrays, but it provides all the mechanics needed to mimic one. </p>

<p><code>malloc</code>, <code>realloc</code>, <code>free</code>, and others can easily be used to handle dynamic allocations and deallocations for arrays of any size and types of elements. You can allocate data in memory and use a pointer to return the reference to caller functions or pass to other functions. ('C' VLAs on the other hand are of limited use and cannot be returned to the caller if allocated on stack).</p>

<p>So, your best option (unless you are in embedded software development) is to start using 'c' dynamic memory allocation.</p>
",0
56534735,56533887,0,"<p>What you can do is read the array length, and then generate the source code of a program:</p>

<pre><code>fprintf(outfile, ""int main(void) { static int arr[%d]; ...}\n"", size);
</code></pre>

<p>Then execute the compiler on the generated program (e.g. using the <code>system</code> function), and run the resulting executable.</p>
",1
58548787,58548302,1,"<p>You are confusing the construct</p>

<pre><code>if ( some_condition ) {
     // Do something 
}
else {  
     // I'm here because some_condition is false
}
</code></pre>

<p>with</p>

<pre><code>if ( some_condition ) {
    // Do something
}
else if ( another_condition )
{
    // Here some_condition is false AND another_condition is true
}
else
{
    // Both are false
}
</code></pre>

<p>The <code>else</code> clause in the former doesn't expect a condition at all, if you put an expression like <code>(a &lt; b);</code> after that, its result is ignored.</p>

<p>Consider the following alternative</p>

<pre><code>double min = a;    // Make an assumption. It would be correct even if a == b,
double max = b;    // but not if...

if ( b &lt; a )
{
    max = a;
    min = b;
}

if ( c &lt; min )    // Note that using 'if (c &lt; min) { min = c; } else { max = c; }' 
{                 // here, would be an error.
    min = c;      // Consider e.g. a = 2, b = 1, c = 1. After the previous statements   
}                 // We would have min = 1 and max = 2, so that, beeing c equal to min,
if ( c &gt; max )    // the 'else' clause would be incorrectly chosen.
{
    max = c;
}
</code></pre>
",1
58227851,58226231,1,"<p>The input will be buffered and <code>scanf()</code> will continue from where it left off, so you can use multiple <code>scanf()</code> calls in a loop to read the input one number at a time.</p>

<p>Also in this case there is no need to store all the input values is separate variables (or even more plausibly an array), you can evaluate the odd/even-ness of each input as they are entered, then discard the value:</p>

<pre><code>int inchk = 0 ;
do
{
    int inp = 0 ;
    inchk = scanf( ""%d"", &amp;inp ) ;

    if( inchk == 1 )
    {
        if( &lt;test inp for even here&gt; ) even++ ;
        else odd++
    }
} while( inchk == 1 ) ;
</code></pre>

<p>This loop will continue until something that is not a decimal integer is entered.  It is not clear how your input is to be terminated or entered, so the loop will need modification to cope with that perhaps.</p>
",2
54659390,54658919,0,"<p>Here is the basic approach to condense your array, removing outliers, and then resize it.</p>

<p>First I noticed your logic for testing outliers is wrong.  The measurement can't be less than <code>0.5*median</code> AND greater than <code>1.5*median</code>...  Unless <code>median</code> is negative.  Let's clean that up by allowing both:</p>

<pre><code>// Choose stable lower and upper bounds
const float low =  (median &lt; 0.f ? 1.5f : 0.5f) * median;
const float high = (median &lt; 0.f ? 0.5f : 1.5f) * median;
</code></pre>

<p>This ensures that <code>low &lt;= high</code> <em>always</em> (except if <code>low</code> or <code>high</code> end up to be NaN).</p>

<p>Now you need to remove the outliers.  The simplest way to do this is to keep a second index that records how many non-outliers you have seen so far.  Walk through the array, and if any outlier has been found, you will also shuffle values as you go.</p>

<pre><code>// Remove outliers
int num_clean = 0;
for(int i = 0; i &lt; size; i++)
{
    float value = measurements[i];
    if(value &gt;= low &amp;&amp; value &lt;= high)
    {
        ++num_clean;
        if (i != num_clean)
            measurements[num_clean] = value;
    }
}
</code></pre>

<p>At the end of this, <code>num_clean</code> represents the number of values that remain.  It's up to you whether to resize the array or not.  You could use the following logic:</p>

<pre><code>// Resize array
if (num_clean &lt; size)
{
    float *new_measurements = realloc(measurements, num_clean * sizeof float);
    if (new_measurements)
        measurements = new_measurements;
    *new_size = num_clean;
}
</code></pre>

<p>Note that you may need some extra handling in the case that <code>num_clean</code> ends up as 0.  You must decide whether to free your array or not.  In the above, there's also a silent handling of the case where <code>realloc</code> fails -- we'll keep the original array pointer but update <code>new_size</code>.</p>

<p>If you are not too concerned about a little bit of extra memory, it should be fine to avoid reallocation completely.  Simply return the number of clean samples, and leave any remaining memory at the end of the array unused.</p>
",2
58558661,58557041,0,"<pre><code>FILE *testData = fopen(""C:\\path\\file.txt"", ""r+"");
lineCounter = 0;
char *lineFileTest = new char[1024];
char *lineFileTestTemp = new char[1024];
while( fgets(lineFileTestTemp, 1024, testData) != NULL ) {
    if((lineCounter&amp;1)==0?1:0){
        lineFileTest = lineFileTestTemp;
    }
    else{
        lineFileTest += lineFileTestTemp;
        printf(""%s"", lineFileTest);
    }
    lineCounter++;
}
fclose(testData);
if(lineFileTest || lineFileTestTemp){
    free(lineFileTest);
    free(lineFileTestTemp);
}
</code></pre>
",0
56902146,56866727,0,"<p>Your calculation of the inverse doesn't quite correspond to the algorithm described e. g. for <a href=""https://www.mathsisfun.com/algebra/matrix-inverse-minors-cofactors-adjugate.html"" rel=""nofollow noreferrer"">Inverse of a Matrix
using Minors, Cofactors and Adjugate</a>, even taken into account that you for now omitted the adjugate and division step. Compare your outermost <code>for</code> loop in <code>inverse()</code> to this working implementation:</p>

<pre><code>double Rdata[(n-1)*(n-1)];              // remaining data values
struct m R = { n-1, n-1, Rdata };       // matrix structure for them
for (count = 0; count &lt; n*n; count++)   // Create n*n Matrix of Minors
{
    int row = count/n, col = count%n;
    for (i_count = i = 0; i &lt; n; i++)
        if (i != row)                   // don't copy the current row
        {
            for (j_count = j = 0; j &lt; n; j++)
                if (j != col)           // don't copy the current column
                    Rdata[i_count*R.col+j_count++] = A-&gt;data[i*A-&gt;col+j];
            i_count++;
        }
    // transpose by swapping row and column
    C.data[col*C.col+row] = pow(-1, row&amp;1 ^ col&amp;1) * determinant(n-1, &amp;R) / det;
}
</code></pre>

<p>It yields for the given input data the correct inverse matrix</p>

<pre><code>1  2 -4.5
0 -1  1.5
0  0  0.5
</code></pre>

<p>(already transposed and divided by the determinant of the original matrix).</p>

<p>Minor notes:</p>

<ul>
<li>The <code>*A = C;</code> at the end of <code>inverse()</code> loses the original data pointer of <code>*A</code>.</li>
<li>The formatting function <code>f()</code> is wrong for negative values, since the <em>fraction</em> is also negative in this case. You could write <code>if (fabs(f)&lt;.00001)</code>.</li>
</ul>
",4
58686398,58685004,0,"<p>So, on first inspection, you have initialized the variable <code>initialSize</code>, but when you want to recompute it, you are missing an assignment. Since you want to repeat the query for the value until it is non-negative, you should use a loop.</p>

<pre><code>   int initialSize = getInitialSize();

   while (initialSize &lt; 0) {
      printf(""Initial size must be greater than or equal to 0"");
      initialSize = getInitialSize();
   }
</code></pre>
",0
58685110,58685004,1,"<p>I recommend also adding a test to be sure that the user actually entered a valid number <em>at all</em>, because if they entered garbage, then the <code>startingAmount</code> variable won't have a reasonable value at all.</p>

<pre><code>int getInitialSize() {

   int startingAmount;

   do
   {
     printf(""Enter initial size: "");
   } while (scanf(""%d"", &amp;startingAmount) &lt; 1  || startingAmount &lt; 0);

   return startingAmount;
}
</code></pre>

<p>Now it loops asking the user for input <em>either</em> if they didn't type a valid number <em>or</em> the number they entered is not to your satisfaction.</p>
",0
56738532,56737605,1,"<p>The correct solution is almost certainly to rewrite the code using a loop:</p>

<pre><code>int sum[n] = ... ;
int result = 0;

for(size_t i=0; i&lt;n; i++)
{
  if(sum[i] &gt; 15)
  {
    result = sum[i];
    break;
  }
}
</code></pre>
",0
58245148,58245038,1,"<p>The core of your problem is on this line:</p>

<pre><code>for( int i = 0; i &lt; width; i++)
</code></pre>

<p>It should be:</p>

<pre><code>for( int i = 0; i &lt; width/2; i++)
</code></pre>

<p>Otherwise, you wind up mirroring the image twice, arriving back where you started.</p>

<p><strong>Updated</strong></p>

<p>The second problem is that your loop itself has hardcoded references to <code>height</code> and <code>width</code>, when really meant to use <code>i</code> or '<code>j</code>.  Also, that <code>imageA</code> buffer is not needed at all and is probably another bug by itself, so we can take that out.</p>

<p>And finally, let's swap your inner row loop with the outer column loop.  It makes the algorithm more obvious as ""mirroring each line"".</p>

<p>Here's the final loop as it should be:</p>

<pre><code>void mirror(int height, int width, RGBTRIPLE image[height][width])
{
    for( int j = 0; j &lt; height; j++)
    {
        // mirror the line at row j
        for(int i = 0; i &lt; width/2; i++)
        {
           // swap the left side pixel with the right side pixel
           RGBTRIPLE temp = image[j][width-1-i];  // temp = right side pixel
           image[j][width-1-i] = image[j][i];     // right side pixel = left side pixel
           image[j][i] = temp;                    // left side pixel gets original right pixel value
        }
    }
}
</code></pre>
",2
57127763,57127613,0,"<p>OK, this seems to work:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;

void disable_veof(void) {
    struct termios t;
    int r;

    r = tcgetattr(STDIN_FILENO, &amp;t);
    if(r)
        exit(EXIT_FAILURE);
    t.c_cc[VEOF] = _POSIX_VDISABLE;
    r = tcsetattr(STDIN_FILENO, TCSANOW, &amp;t);
    if(r)
        exit(EXIT_FAILURE);
}

void echo_lines(void) {
    char buffer[4096];
    const size_t buffer_len = sizeof buffer;
    ssize_t bytes;
    while( 0 != (bytes = read(STDIN_FILENO, buffer, buffer_len)) ) {
        bytes = write(STDOUT_FILENO, buffer, bytes);
        if(bytes &lt;= 0)
            exit(EXIT_FAILURE);
    }
}

int main() {

    disable_veof();
    echo_lines();
    return EXIT_SUCCESS;
}
</code></pre>
",0
57127787,57127613,0,"<p>If the input is a terminal in canonical mode, <code>EOF</code> in raw io (as opposed to stdio where it is) is <em>not sticky</em>.</p>

<p><a href=""https://pubs.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap11.html#tag_11_01_09"" rel=""nofollow noreferrer"">https://pubs.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap11.html#tag_11_01_09</a></p>

<blockquote>
  <p>Special character on input, which is recognized if the ICANON flag is
  set. When received, all the bytes waiting to be read are immediately
  passed to the process without waiting for a newline, and the EOF is
  discarded. Thus, if there are no bytes waiting (that is, the EOF
  occurred at the beginning of a line), a byte count of zero shall be
  returned from the read(), representing an end-of-file indication. <strong>If
  ICANON is set, the EOF character shall be discarded when processed.</strong></p>
</blockquote>

<p>The next <code>read()</code> should return a positive value unless the user keeps pressing <code>Ctrl+D</code>.</p>
",0
58733370,58733176,2,"<p>In the expression,</p>

<pre><code>i=(1,2,0)
</code></pre>

<p>you're using the <a href=""https://port70.net/~nsz/c/c11/n1570.html#6.5.17"" rel=""nofollow noreferrer"">comma operator</a>, which evaluates all its operands and yields the result of its rightmost operand - which is 0 here.
So 0 is assigned to <code>i</code>.</p>

<p>So it's equivalent to <code>if (i = 0)</code>, which assigns <code>0</code> to <code>i</code> and yields the value of <code>i</code> which is false and thus it prints the string in the else branch.</p>
",0
56007438,56007334,2,"<p>You can't <code>sizeof</code> an unbounded array. You want <code>sizeof(fptr)/sizeof(fptr[0])</code> as Eugene pointed out in comments.</p>
",0
56012469,56007334,0,"<p>You can compute the size of an array of function pointers just like any other array:</p>

<ul>
<li>the size in bytes is <code>sizeof(fptr)</code> or simply <code>sizeof fptr</code></li>
<li>the number of elements is <code>sizeof(arr) / sizeof(arr[0])</code>.</li>
</ul>

<p>Beware however that <code>sizeof</code> evaluates (at compile time) to a value of type <code>size_t</code> which is different from <code>int</code>. To print it, use:</p>

<pre><code>    int (*fptr[])(int) = { get_square, get_cube, get_square_root };

    printf(""size = %zu bytes\n"", sizeof fptr);
    printf(""size = %zu elements\n"", sizeof(fptr) / sizeof(fptr[0]));
</code></pre>

<p>Or possibly cast to <code>unsigned</code> if your C library does not support the C99 size modifiers:</p>

<pre><code>    printf(""size = %u bytes\n"", (int)sizeof fptr);
    printf(""size = %u elements\n"", (int)(sizeof(fptr) / sizeof(fptr[0])));
</code></pre>
",0
57086169,57085745,1,"<p>You need to assign the result of <code>atoi()</code> to a variable and print that.</p>

<pre><code>    while ((len = get_line(line, MAXLINE)) &gt; 0) {
        int num = atoi(line);
        printf(""%d\n"", num);
    }
</code></pre>
",2
56399443,56399312,0,"<blockquote>
  <p>If head is a struct type pointer, pointing to the first node in link list then what does while(head) means? </p>
</blockquote>

<p>to have </p>

<blockquote>
<pre><code>while(head)
</code></pre>
</blockquote>

<p>is like to have</p>

<pre><code>while(head != NULL)
</code></pre>

<blockquote>
  <p>Does While loop runs till the head is not equal to NULL?</p>
</blockquote>

<p>yes (supposing there is nothing allowing to go out of the loop in its body)</p>

<blockquote>
  <p>Also what does if(!head) means while checking the condition</p>
</blockquote>

<p>to have </p>

<blockquote>
<pre><code> if(!head)
</code></pre>
</blockquote>

<p>is like to have</p>

<pre><code>if(head == NULL)
</code></pre>
",0
56953802,56951091,0,"<blockquote>
  <p>When using scanf for arrays, it seem that the function works fine whether I use '&amp;' operator or not. </p>
</blockquote>

<p>""Seems"" being the operative word.</p>

<p>Except when it is the operand of the <code>sizeof</code> or unary <code>&amp;</code> operators, or is a string literal used to initialize a character array in a declaration, an <em>expression</em> of type ""N-element array of <code>T</code> will be converted (""decay"") to an expression of type ""pointer to <code>T</code>"", and the value of the expression will be the address of the first element of the array.</p>

<p>If you call <code>scanf</code> as</p>

<pre><code>scanf( ""%s"", s );
</code></pre>

<p>the <em>expression</em> <code>s</code> is converted from type ""100-element array of <code>char</code>"" (<code>char [100]</code>) to ""pointer to <code>char</code>"" (<code>char *</code>) and its value is the address of the first element of the array (<code>&amp;s[0]</code>).</p>

<p>If you call <code>scanf</code> as</p>

<pre><code>scanf( ¡°%s¡±, &amp;s );
</code></pre>

<p><code>s</code> is the operand of unary <code>&amp;</code>, so the conversion doesn¡¯t occur, and the <em>expression</em> <code>&amp;s</code> has type ""pointer to 100-element array of <code>char</code>"" (<code>char (*)[100]</code>).  This is a problem, since the <code>%s</code> conversion specifier expects an argument of type <code>char *</code>.  Passing an argument of any other type results in <em>undefined behavior</em> - the operation may work as expected, or it may crash outright, or it may corrupt data, or it may leave the program in a bad state such that it crashes later, etc.  </p>

<p>Both expressions <code>s</code> and <code>&amp;s</code> resolve to the same <em>value</em> - the address of an array is the same as the address of its first element - but their <em>types</em> are different, and in C different pointer types may have different representations (IOW, the way the address value is stored for a <code>char *</code> may be different from the way an address value is stored for a <code>char (*)[100]</code>).  So </p>

<pre><code>scanf( ""%s"", &amp;s );
</code></pre>

<p>could fail on some platforms.   </p>

<blockquote>
  <p>My exact question is when I use &amp;ch(while ch is string) do we create double pointer?</p>
</blockquote>

<p>No. If <code>ch</code> is declared as <code>char ch</code>, then <code>&amp;ch</code> has type <code>char *</code>.  If <code>ch</code> is declared as <code>char ch[N]</code>, then <code>&amp;ch</code> has type <code>char (*)[N]</code>.  </p>
",0
54874845,54874798,1,"<p>Place the %s inline like:</p>

<pre><code> printf(""The lowest positive divisor is: %s"", dividend);
</code></pre>

<p>But in this case use %d because it's an integer:</p>

<pre><code>printf(""The lowest positive divisor is: %d"", dividend);
</code></pre>
",0
54874833,54874798,2,"<pre><code>printf(""%s"",""The lowest positive divisor is: "",dividend);
</code></pre>

<p>You only have one format specifier specified in your string but you pass 2 variables to <code>printf</code>. You should specify the <code>dividend</code> specifier too:</p>

<pre><code>printf(""%s %d"",""The lowest positive divisor is: "",dividend);
</code></pre>
",2
54890908,54890850,2,"<p>This line here tries to assign a single number to <code>vals[i]</code></p>

<p><code>vals[i]=(l+i)*(l-r)/(P-1);</code></p>

<p><code>vals[i]</code> is an instance of point, which whould need 2 numbers and to be assigned differently.  eg. </p>

<p><code>vals[i].x=(l+i)*(l-r)/(P-1);</code></p>
",1
56508913,56508657,1,"<p>This seems to be homework, so I will only sketch an answer. You will have to code it yourself.</p>

<p>First, are the slopes the same? If not, they only have one point in common; stop. Assuming the coordinates are integers, you can avoid floating-point errors by computing each <em>dx</em> and <em>dy</em>, and cross-multiplying (h/t to Weather Vane¡¯s comment above).</p>

<p>Second, do the extended lines have a point in common? Can do this by finding y-intercepts or various other ways. If not, they¡¯re parallel; stop.</p>

<p>Having reached this point, we know the segments are on the same line, so now we have to test the intervals. If they¡¯re horizontal, look at <em>x</em>; if vertical, look at <em>y</em>; if slanted, pick one coordinate, either one will work.</p>

<p>Sort each pair of endpoints to get <em>a</em> and <em>b</em> such that <em>a</em> &lt; <em>b</em>. Then, simply compare the leftmost endpoints of each segment, and the rightmost. Remember that either or both might be equal.</p>
",0
57016048,57016038,2,"<blockquote>
  <p>Is memory being dynamically allocated here or something?</p>
</blockquote>

<p>No.</p>

<blockquote>
  <p>This code works fine. It prints the string I enter. How is it possible to treat char *name[20] just like char name[20]?</p>
</blockquote>

<p>The behaviour of the program is undefined.</p>

<p>It is undefined, because it violates the requirements of the <code>scanf</code> and <code>printf</code> functions.</p>

<p>The C standard says of <code>%s</code> specifier for both <code>scanf</code> and <code>printf</code> (quoting the standard draft document N1570):</p>

<blockquote>
  <p>the  corresponding  argument  shall  be  a pointer  to  the  initial  element  of  a  character  array ...</p>
</blockquote>

<p><code>name</code> is <strong>not</strong> a pointer to the initial element of a character array. It is (actually an array, but) after decaying, a pointer to an initial pointer to character in an array of pointers to characters. Thus the requirements are violated and behaviour of the program is undefined.</p>

<blockquote>
  <p>what did you mean by ""behaviour is undefined""?</p>
</blockquote>

<p>It means that nothing about the behaviour of the program is guaranteed. As far as the language is concerned, the program might:</p>

<ul>
<li>Produce output that you expect.</li>
<li>Produce output that you didn't expect.</li>
<li>Produce output that you want to be produced.</li>
<li>Produce some output that you didn't want.</li>
<li>Not produce output at all.</li>
<li>Crash</li>
<li>Not crash</li>
<li>Behave differently on another system.</li>
<li>Behave differently on the same system.</li>
<li>Behave differently when you're debugging it.</li>
<li>Behave differently only when you are on vacation.</li>
<li>Behave differently for any reason possible.</li>
<li>Behave differently for seemingly no reason at all.</li>
<li>Behave the same always</li>
<li>Behave exactly the same as if you had used <code>char name[20]</code> despite not having used it.</li>
<li>Not behave like that.</li>
<li>Have any behaviour whatsoever.</li>
</ul>

<p>Undefined behaviour is to be avoided.</p>
",12
55746483,55726915,0,"<p>You call <code>save_file(countrydata, filename, i);</code> without having set <code>filename</code>. Change to <code>save_file(countrydata, line, i);</code> since for whatever reason you expect the command character <code>W</code> to precede the name.</p>

<p>Then in <code>save_file()</code> the condition in <code>while (data[a].country[0] != 0)</code> is unusable, since the data element after the last one is not initialized. Use <code>while (a &lt; i)</code> instead.</p>
",0
54953287,54953237,2,"<p>The first thing you're doing wrong is this:</p>

<pre><code>char *sentence[300];
</code></pre>

<p>It looks like you're trying to create a buffer of 300 characters, but what you're really doing is creating an array of 300 character pointers.  Change that to:</p>

<pre><code>char sentence[300];
</code></pre>

<p>Then you want to change this:</p>

<pre><code>fgets(*sentence,300,stdin);
</code></pre>

<p>to</p>

<pre><code>fgets(sentence,sizeof(sentence),stdin);
</code></pre>

<p>Then you want to change</p>

<pre><code>int length=strlen(*sentence);
</code></pre>

<p>to</p>

<pre><code>int length=strlen(sentence);
</code></pre>

<p>You need to have a good understanding of how strings work in C.  If you haven't read a good introductory book for C, start there.  C is not something you're going to pick up by just reading random pages on the web and StackOverflow.</p>
",0
54955049,54954978,1,"<p>For <code>int (*p)(char (*a)[]);</code>:</p>

<ul>
<li><code>(*p)(char (*a)[])</code> is an <code>int</code>.</li>
<li>So <code>(*p)</code> is a function returns an <code>int</code> and takes a parameter of type <code>char (*a)[]</code>. (More on the latter below.)</li>
<li>So <code>*p</code> is that same function.</li>
<li>So <code>p</code> is a pointer to that function.</li>
<li>In <code>char (*a)[]</code>, <code>(*a)[]</code> is a <code>char</code>.</li>
<li>So <code>(*a)</code> is an array of <code>char</code>, with unknown size.</li>
<li>So <code>*a</code> is that same array.</li>
<li>So <code>a</code> is a pointer to an array of <code>char</code> with unknown size.</li>
<li>So <code>p</code> is a pointer to a function returning <code>int</code> that takes a parameter that is a pointer to an array of <code>char</code> with unknown size.</li>
</ul>

<p>For <code>int *p(char (*a)[]);</code>:</p>

<ul>
<li><code>*p(char (*a)[])</code> is an <code>int</code>.</li>
<li>So <code>p(char (*a)[])</code> is a pointer to an <code>int</code>.</li>
<li>So <code>p</code> is a function that returns a pointer to an <code>int</code> and takes a parameter of type <code>char (*a)[]</code>.</li>
<li>From above, we know that parameter is a pointer to an array of <code>char</code> of unknown size.</li>
<li>So <code>p</code> is a function that returns a pointer to an <code>int</code> and takes a parameter that is a pointer to an array of <code>char</code> with unknown size.</li>
</ul>
",0
56635093,56635013,1,"<p>Because <code>feof()</code> does not return true until an attempt to read past the end of the file.</p>
<p>Per the documentation:</p>
<blockquote>
<p>Checks whether the end-of-File indicator associated with stream is set, returning a value different from zero if it is.</p>
<p>This indicator is generally set by a previous operation on the stream that attempted to read at or past the end-of-file.</p>
</blockquote>
",0
56546876,56546651,0,"<p><code>fflush()</code> normally isn't needed  when you're reading and writing the same <code>stdio</code> stream. <code>fputs()</code> and <code>fgets()</code> both access the same I/O buffer, so flushing isn't usually necessary in this case.</p>

<p>There are some restrictions, though. Even though the same buffer is used, you have to do something to synchronize between writing and reading. This can be <code>fflush()</code>, but it will also synchronize if you use <code>fseek()</code>. And if you want to read what you just wrote, you have to use <code>fseek()</code> to move back to the place where you started writing; that will synchronize without the need for <code>fflush()</code>.</p>

<p>But <code>fflush()</code> is really needed if some <em>other</em> process tries to read the file while this process is writing it. You need to call <code>fflush()</code> to force the data from your I/O buffer to the actual file, so the other process will see the changes.</p>
",6
57208942,57208702,4,"<p>Changing <code>char s[10]</code> to <code>char *s</code> is the correct way to address the compile error.  <code>strtol</code>'s second argument is supposed to be a pointer to a <em>pointer variable</em>, which it will initialize to point somewhere <em>within</em> the string that is its first argument.  <code>char s[10]</code> does not declare a pointer variable, <code>char *s</code> does.</p>

<p>The only explanation I can think of, why this program might crash, is that you didn't pass it any arguments.  In that case <code>argc</code> will be less than 2 and <code>argv[1]</code> will be a null pointer (or possibly not even initialized).  You need to do something like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc,char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, ""usage: %s integer\n"", argv[0]);
        return 1;
    }

    char *s;
    long x = strtol(argv[1], &amp;s, 10);
    printf(""x: %ld\n"", x);
    printf(""s: '%s'\n"", s);
    return 0;
}
</code></pre>

<p>Incidentally, in C, for historical reasons, preferred style is to put the opening curly brace of a function definition on its own line, even if all other opening curly braces are ""cuddled"".</p>
",0
58525034,58524957,1,"<p>When using a struct you need to write</p>

<pre><code>struct PipeReadThreadData data;
</code></pre>

<p>or typedef the struct like so</p>

<pre><code> typedef struct
 {
    LPCWSTR pipename;
    HANDLE handle;
 } PipeReadThreadData;
</code></pre>

<p>and then you can use it with</p>

<pre><code>PipeReadThreadData data;
</code></pre>
",0
58660629,58660537,2,"<p>It is because <code>\n</code> is left out in the input stream because of your first <code>scanf</code>.</p>

<p>Clear the stream after first <code>do...while</code> as below.</p>

<pre><code>int c;
while ((c = getchar()) != '\n' &amp;&amp; c != EOF) { }
</code></pre>
",2
57131002,57130975,1,"<p>You are not <em>calling</em> the function. You put the declaration of the function where you are expected to call it. You should call it as</p>

<pre><code>entropy_syst(dataset, 14, 5, ""some string"");
</code></pre>

<p>You are supposed to get a <code>double</code> value from the call, you may choose to store it in some variable.</p>
",3
56520723,56520636,1,"<p>There are a couple of errors, but one that messes up your output is here:</p>

<pre><code>while((ch = fgetc(fp) != EOF)) {
</code></pre>

<p>Here you are assigning to <code>ch</code> the value of <code>fgetc(fp) != EOF</code>. It should be;</p>

<pre><code>while((ch = fgetc(fp)) != EOF) {
</code></pre>
",0
55092273,55092175,-1,"<p>I could not see all your code (it seemed to be cut off at the bottom), however the basically procedure to get an average, max and min in C is as follows:</p>

<pre><code>int running_total = 0;
int count_grades  = 0;
int max_so_far    = 0;
int min_so_far    = 999;
while( -1 ){ // infinite loop
    // get input (a grade)
    // if input is done, break
    count_grades++;
    running_total += iCurrentGrade; // (iCurrentGrade should be defined during input phase)
    if( iCurrentGrade &gt; max_so_far ) max_so_far = iCurrentGrade;
    if( iCurrentGrade &lt; min_so_far ) min_so_far = iCurrentGrade;
}
printf( ""avg: %d  min: %d  max: %d\n"", (int)(running_total / count_grades), min_so_far, max_so_far );
</code></pre>
",1
56532719,56532648,3,"<p>Change this line:</p>

<pre><code>bool isTrue=true;
</code></pre>

<p>Which declares a brand new variable, and hides the previous variable, to this line:</p>

<pre><code>isTrue=true;  // Remove the ""bool""
</code></pre>

<p>Which only assigns a value, but does not create a new variable.</p>
",1
56532898,56532648,0,"<p>Let's just focus on the loop here. This is what I came up with:</p>

<pre><code>for(i=0; str[i] != 0; i++){
    if(sub[0] == str[i]){
        isTrue = true;
        for(j=0, t=i; sub[j] != 0; j++, t++){
            if(sub[j]!=str[t]){
                isTrue=false;
                break;
            }
        }
        if(isTrue) break;
    }
}
</code></pre>

<p>First, you don't want to be re-defining isTrue to true every time in the second loop. You only need to do it once, before the second loop. Second, once it's no longer a substring, you can break out of the second loop. It's not going to magically become true again.</p>

<p>Third, once you've found a substring, you don't need to keep checking. So you can just put that as a check at the end of the first loop.</p>
",0
56581447,56580541,0,"<p>You need to cast to float.  Otherwise the arithmetic conversions will convert only the integer result to float.</p>

<pre><code>float x = positive / array_size
</code></pre>

<p>You want</p>

<pre><code>float x = (float) positive / array_size
</code></pre>

<p>The full algorithm of conversions is presented in <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"" rel=""nofollow noreferrer"">ISO 9899, chapter 6.3.1.8  Usual arithmetic conversions</a> </p>
",2
59227063,59227024,7,"<p>On Ubuntu, run <code>man gets</code> in a terminal. It should show you <a href=""http://man7.org/linux/man-pages/man3/gets.3.html"" rel=""nofollow noreferrer"">this <code>gets(3)</code></a> man page.</p>

<p>That documentation states, in written English:</p>

<blockquote>
  <p><strong>Never use this function.</strong></p>
</blockquote>

<p>More generally, <strong>before programming, read documentation.</strong> For C on Linux,  consider reading <a href=""http://man7.org/linux/man-pages/"" rel=""nofollow noreferrer"">the man pages</a>, this <a href=""https://en.cppreference.com/w/c"" rel=""nofollow noreferrer"">C reference</a>, many C programming <a href=""https://www.tutorialspoint.com/cprogramming/index.htm"" rel=""nofollow noreferrer"">tutorials</a>, and the C11 standard <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">n1570</a>.</p>

<p>English wikipedia also <a href=""https://en.wikipedia.org/wiki/C_file_input/output#gets"" rel=""nofollow noreferrer"">mentions <code>gets</code></a></p>

<p>At last, </p>

<blockquote>
  <p>warning: 'implicit declaration of function ¡®gets¡¯; did you mean ¡®fgets¡¯? [-Wimplicit-function-declaration]</p>
</blockquote>

<p>Seems quite clear to me, since written in English. As a rule of thumb, ensure that your program compiles without warnings. Read also <a href=""https://ericlippert.com/2014/03/05/how-to-debug-small-programs/"" rel=""nofollow noreferrer""><em>How to debug small programs</em></a>.</p>

<p>You could be interested in understanding the acronyms <a href=""https://en.wikipedia.org/wiki/RTFM"" rel=""nofollow noreferrer"">RTFM and STFW</a>.</p>

<p>I learned C and Unix programming (in 1985) by reading SunOS3 man pages (at that time on paper, at work, sold with the Sun3/160 workstation I had the privilege to use then), from section 1 to section 9.</p>

<p>You could read <a href=""http://www.makelinux.net/alp/"" rel=""nofollow noreferrer""><em>Advanced Linux Programming</em></a> before the man pages.</p>

<hr>

<blockquote>
  <p>I have just begun my programming journey.</p>
</blockquote>

<p>Then I recommend reading <a href=""https://mitpress.mit.edu/sites/default/files/sicp/index.html"" rel=""nofollow noreferrer"">SICP</a>. In my grand-father's eyes, it is still the best introduction to programming, even in 2019. See also <a href=""http://starynkevitch.net/Basile/guile-tutorial-1.html"" rel=""nofollow noreferrer"">these hints</a>. It does not matter if SICP is using some programming language which is not very used in professional real life (but look into <a href=""https://www.gnu.org/software/guile/"" rel=""nofollow noreferrer"">Guile</a>): programming is about concepts, not about coding. The concepts you will learn with SICP surely will help you to write better C code later. Of course read <a href=""http://norvig.com/21-days.html"" rel=""nofollow noreferrer"">http://norvig.com/21-days.html</a> </p>

<hr>

<p>NB. I am French (born in 1959) so not a native English speaker. But I was taught to read, including during my PhD studies, and of course during high school and by my own parents. And when I taught at university some CS stuff, the first thing I told to students is <strong>read</strong>. Never be ashamed of reading.</p>
",0
59227236,59227024,9,"<p><code>gets</code> was removed in C11, because it is <a href=""https://stackoverflow.com/questions/1694036/why-is-the-gets-function-so-dangerous-that-it-should-not-be-used"">impossible to use correctly</a>. <code>gets</code> does not know how many characters it can store into the array and continues to write as many as the user provides, which leads to the program to have <em>undefined behaviour</em> - crashes, modification of unrelated data etc.</p>
<p>The fix is to use <code>fgets</code> instead, though keeping in mind that it leaves a newline in the buffer:</p>
<pre><code>#include &lt;stdio.h&gt;

// example of multi char i/p function
int main(void)
{
    char loki[10];
    fgets(loki, 10, stdin);

    // now loki will have the new line as the last character
    // if less than 9 characters were on the line

    // we can remove the extra with `strcspn`:
    loki[strcspn(loki, &quot;\n&quot;)] = 0;

    // this will print the given string followed by an extra newline.
    puts(loki);
}
</code></pre>
",0
55229963,55229930,4,"<p>Expressions in C are not formulas.  This:</p>

<pre><code>int age = CurrentYear - BornYear;
</code></pre>

<p>Does not mean that the value of <code>age</code> will <em>always</em> be <code>CurrentYear - BornYear</code>.  It means that <em>at that point in the code</em>, <code>age</code> is set to <code>CurrentYear - BornYear</code> based on the current value of those variables.  Both of those variables are uninitialized, so their values are indeterminate.</p>

<p>You need to move the calculation of <code>age</code> to <strong>after</strong> you've read in <code>CurrentYear</code> and <code>BornYear</code>:</p>

<pre><code>int CurrentYear;
int BornYear;
int age;

printf(""What year is it?\n"");
scanf(""%d"", &amp;CurrentYear);
printf(""What year you were born?\n"");
scanf(""%d"", &amp;BornYear);

age = CurrentYear - BornYear;
printf(""You are %d years old\n"", age);
</code></pre>
",2
56620342,56620199,3,"<p>You scanf a number in main(). That leaves the ENTER in the input buffer which is read by the scanf inside the function.</p>

<p>Ask scanf to ignore whitespace (unlike <code>""%c""</code>, <code>""%d""</code> already ignores whitespace on its own)</p>

<pre><code>scanf("" %c"", ...);
//     ^ ignore whitespace
</code></pre>

<p>Better yet. Use <strong>only</strong> <code>fgets()</code> for user input. It's a safe alternative, with good error reporting and recovery.</p>
",3
55309658,55309516,3,"<p>As others pointed out, you can't initialize a Variable Length Array with a pointer, like you are doing. However, you don't actually need a VLA at all. Use this instead :</p>

<pre><code>int *arr = augs -&gt; one;
</code></pre>

<p>You want to act directly on the array that is passed into the thread, not make a copy of it.</p>

<p>That being said, I see another problem. In the loop that spawns the sorting threads, you are not allocating a new <code>args</code> on the last loop iteration, it reuses the allocated <code>args</code> from the previous iteration, which can cause disaster for the 2nd-to-last thread. You need to move the <code>malloc()</code> call above the <code>if</code>.</p>

<p>Also, the <code>malloc()</code> is allocating more memory than your threads actually use. You only need to allocate enough memory for just the struct by itself, not for any integers following the struct.</p>

<p>Also, when each thread is done using the allocated <code>args</code> that it is given, it needs to <code>free()</code> the <code>args</code> to avoid leaking memory.</p>
",1
55309610,55309570,1,"<p>You're passing <code>&amp;matchArray[5]</code>, which is the address of the 5th element of matchArray as the <code>matchArray</code> argument of match6.  Since match's matchArray only has 6 elements, this is a slice of only 1 element, which is too small.</p>

<p>You probably want to pass <code>matchArray</code> -- a pointer to the 0th element, in which case you'll get a slice of all 6 elements.  Then you also probably want to declare the argument to match6 as <code>int matchArray[6]</code></p>
",0
55309592,55309570,0,"<p><code>matchArray</code> is an array of 6 elements but the parameter is declared as having only 5 <code>int matchArray[5]</code>. So the assignment within the called function <code>matchArray[5] = 0</code> appears to be out of bounds given how the parameter is declared.</p>
",0
56713618,56713550,1,"<p>You subtracted <code>term</code> here by '0', which means your digits are now no longer ASCII '0' to ASCII '9', but rather numeric char 0 to char 9, which corresponds to a bunch of ASCII control characters. </p>

<pre><code>    if(isdigit(term))
    {
        oprn = term - '0';
        post[++k] = oprn;
    }
</code></pre>
",1
55412956,55398414,0,"<p>You can find in <a href=""https://jansson.readthedocs.io/en/latest/gettingstarted.html#windows-visual-studio"" rel=""nofollow noreferrer"">documentation</a> how to build this library for windows:</p>

<ul>
<li>Get CMake and Visual Studio</li>
<li>unpack source</li>
</ul>

<p>In a command line</p>

<ul>
<li><code>cd .../jansson-2.12</code></li>
<li><code>mkdir build</code></li>
<li><code>cd build</code></li>
<li><code>cmake -G ""Visual Studio XX 20XX"" ..</code></li>
</ul>

<p>You should be done</p>

<hr>

<p><a href=""https://jansson.readthedocs.io/en/latest/gettingstarted.html#other-systems"" rel=""nofollow noreferrer"">Alternate method</a></p>

<p>You can also edit manually the <code>jansson_config.h.in</code>, ommitting to define <code>HAVE_CONFIG_H</code> which cause the <code>jansson_private_config.h</code> to be included in .c files.</p>

<p>Note that this <code>#ifdef HAVE_CONFIG_H</code> test has been forgetten in <code>test_dump.c</code>, which won't compile if you don't fix it.</p>

<p>Fix proposal (not tested):</p>

<pre><code>+#ifdef HAVE_CONFIG_H
 #include ""jansson_private_config.h""
+#endif
</code></pre>
",0
58160955,58160751,1,"<blockquote>
  <p>Is there a way to set a limit for the time in C?</p>
</blockquote>

<p>For ""pure standard portable C"", no.</p>

<p>For ""C extended by other standards"" (e.g. POSIX, Win32), some of the possibilities are:</p>

<ul>
<li><p>use many very small delays, checking for user input between each very small delay (e.g. 1000 delays at 10 milliseconds each)</p></li>
<li><p>use <code>alarm()</code> to get a signal (<code>SIGALARM</code>) after 10 seconds, so that your ""wait for user input"" gets interrupted by the signal if/when the time-out expires</p></li>
<li><p>use something like <code>select()</code> to wait for input (to read from the <code>stdin</code>) with a time-out.</p></li>
</ul>
",0
57272404,57272143,3,"<p>With <code>hello(5,""i am fine"");</code> in main.c, one of three things should be true:</p>

<ul>
<li>You compiled without (many) warning messages enabled in your compiler. If so, turn on warning messages in your compiler.</li>
<li>The compiler warns you that <code>hello</code> is not declared (and perhaps that it assumes a declaration/type for it). If so, insert a declaration of <code>hello</code> in main.c (or put it in a header named hello.h and insert <code>#include &lt;hello.h&gt;</code> in main.c).</li>
<li>main.c contains code you did not show us in the question, either a declaration of <code>hello</code> or an include of a header file, and the declaration of <code>hello</code> in main.c or the header file differs from its definition in hello.c. If so, show the full code in the question.</li>
</ul>

<p>Once you fix the problems above, there should be a declaration of <code>hello</code> in main.c (explicitly or included in a header file) that matches its definition in hello.c:</p>

<pre><code>int hello(int argc, char *argv[]);
</code></pre>

<p>Once that declaration is in main.c, the compiler should warn you that the call <code>hello(5,""i am fine"");</code> does not match the declaration. This is because <code>""i am fine""</code> is an array of characters and, when used in this way, is automatically converted to a pointer to its first element. So the argument passed is a pointer to a <code>char</code>, also called a <code>char *</code>. But the parameter is a <code>char **</code>.</p>

<p>So you need to pass a <code>char **</code>. An easy way to do this is to make an array of <code>char *</code>:</p>

<pre><code>char *Arguments[] = { ""i am fine"" };
</code></pre>

<p>Then you can pass the array to <code>hello</code>:</p>

<pre><code>hello(1, Arguments);
</code></pre>

<p>As with the array of <code>char</code>, this array of <code>char *</code> will be automatically converted to a pointer to its first argument, so a <code>char **</code> will be passed.</p>

<p>Also note that I changed <code>5</code> to <code>1</code>. The first argument is the number of strings pointed to by the second argument, and you are passing only one string.</p>

<p>To pass five strings, you should have five strings in the array, and, to match how the arguments to <code>main</code> are specified, there should be an additional element in the array that is a null pointer:</p>

<pre><code>char *Arguments[] = { ""i am fine"", ""two"", ""three"", ""four"", ""five"", 0 };
hello(5, Arguments);
</code></pre>

<p>After you have that working, you could use a compound literal instead of a named array. A compound literal is a way of creating an object in an expression, and it uses a type name in parentheses followed by values for the object in braces:</p>

<pre><code>hello(5, (char *[]) { ""i am fine"", ""two"", ""three"", ""four"", ""five"", 0 });
</code></pre>
",1
57273947,57272143,0,"<p>In your code you call function <em>hello</em> with a string instead of an array of strings. Here is a corrected version:</p>

<pre><code>#include &lt;stdio.h&gt;

#define LEN(arr) (sizeof (arr) / sizeof (arr)[0])

void hello(int argc, const char **argv)
{
    int i = 0;
    printf(""%d\n"", argc);
    for (i = 0; i &lt; argc; i++) {
        printf(""%s\n"", argv[i]);
    }
}


int main(void)
{
    const char *args[] = {""i"", ""am"", ""fine""};

    hello(LEN(args), args);
    return 0;
}
</code></pre>

<p>I have also added a <code>const</code> qualifier to indicate that the strings will not be modified.</p>
",0
55388717,55388258,0,"<p>The most obvious problem is your word count only has a single loop, but you need to scan every character in every movie - that suggests two <em>nested</em> loops.</p>

<p>Then the idea of returning two types of information in a single array is ill-advised - a structure would be more appropriate.  Then in C you cannot pass or return arrays by value, so it is usual to have the caller pass an array by reference for the function to place the results.</p>

<p>Consider:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct sMovie
{
    char title[40] ;
    int title_stats[40] ;
} ;

void getWordCount( struct sMovie* movies, int number_of_movies );

int main ()
{
    struct sMovie movies[] = { {""Jurassic World""}, 
                               {""Captain America""}, 
                               {""I spit on your grave""} } ;

    const int number_of_movies = sizeof(movies) / sizeof(*movies) ;
    getWordCount( movies, number_of_movies ) ;

    for( int m = 0; m &lt; number_of_movies; m++ )
    {
        printf( ""\""%s\"" has %d words of lengths"",
        movies[m].title,
        movies[m].title_stats[0] ) ;
        for( int w = 1; w &lt;= movies[m].title_stats[0]; w++ )
        {
            printf( "" %d"", movies[m].title_stats[w] ) ;
        }
        printf( ""\n"" ) ;
    }

    return 0;
}

void getWordCount( struct sMovie* movies, int number_of_movies )
{
    // For each movie...
    for( int m = 0; m &lt; number_of_movies; m++)
    {
        memset( movies[m].title_stats, 0, sizeof(movies[m].title_stats) ) ;
        movies[m].title_stats[0] = 1 ;

        // For each character
        for( int i = 0; movies[m].title[i] != 0; i++ )
        {
            int word = movies[m].title_stats[0] ; 
            movies[m].title_stats[word]++ ;

            if( movies[m].title[i] == ' ' )
            {
                movies[m].title_stats[word]-- ;
                movies[m].title_stats[0]++ ;
            }
        }
    }
}
</code></pre>

<p>Output:</p>

<pre><code>""Jurassic World"" has 2 words of lengths 8 5                                                                                                              
""Captain America"" has 2 words of lengths 7 7                                                                                                             
""I spit on your grave"" has 5 words of lengths 1 4 2 4 5                                                                                                  
</code></pre>
",7
56937766,56937669,3,"<p>The root problem is </p>

<ul>
<li><p><code>double extractDigit1(x)</code> is not a correct function prototype, it should be <code>double extractDigit1(double x)</code></p>

<p>Wiht what your write, x was considered as <code>int</code> which is not compatible with the rest of code.</p></li>
</ul>

<p>Note that</p>

<ul>
<li><p>Your functions return nothing whereas their prototypes tell so </p>

<p>It's an undefined behavior that can lead to anything </p></li>
</ul>

<p>Finally</p>

<ul>
<li>You use <code>scanf_s</code> function, with is almost like <code>scanf</code> but handle strings differently and is less portable (see <a href=""https://stackoverflow.com/q/21434735/1212012"">Difference between scanf and scanf_s</a>). I advice you not to use it.</li>
</ul>

<p>Corrected code:</p>

<pre><code>#include &lt;stdio.h&gt;

double extractDigit1(double x){
    double userFloatValue = x;
    (userFloatValue &gt;= 0) ? 
        printf("" %f is a positive value."", userFloatValue) :
        printf("" %f is a negative value."", userFloatValue);
    return 0;
}

int main(){
   double userValue;
   scanf(""%lf"", &amp;userValue);
   extractDigit1(userValue);
   return 0;
}
</code></pre>
",8
56937768,56937669,-2,"<pre><code>double userFloatValue = x;
int my_var = (int)userFloatValue ;
         (userFloatValue &gt;= 0) ? printf("" %d is a positive value."",   my_var ) :
                                 printf("" %d is a negative value."",  my_var ) ;
</code></pre>

<p>Use  scanf rather  than scanf_s 
scanf(""%f"", &amp;a);</p>
",1
57047265,57047171,3,"<p>In the argument context of your code <code>char list[][MaxNamebuffer]</code> is 100% identical to <code>char (*list)[MaxNamebuffer]</code> and both mean <code>list</code> is a <strong>pointer</strong> to arrays of <code>MaxNamebuffer</code> bytes.</p>
",0
57789028,57788856,2,"<p>You need to block the compiler from spewing non-standard crap into standard headers. You are using some compiler which has defined a non-standard <code>getline</code> function inside the standard library header <code>stdio.h</code>, which is non-conforming.</p>

<p>With gcc you should compile as for example <code>gcc -std=c17 -pedantic-errors</code> to prevent this from happening.</p>
",7
56090048,56089899,1,"<p>Apart from the unnecessary double-nested loop, this line</p>

<pre><code>scanf(""%s\n"", temp);
</code></pre>

<p>should be</p>

<pre><code>scanf(""%s"", temp);
</code></pre>

<p>Usually, you should not try to match trailing whitespace with <code>scanf</code>, and the format specifier <code>%s</code> automatically filters out leading whitespace (but note that <code>%c</code> does not).</p>

<p>There are other faults and the code presented was originally incomplete, but notably the input length for <code>%s</code> must be restricted to prevent buffer overflow.</p>
",0
59131776,59131450,1,"<p>As mentionned in the comments:</p>

<ul>
<li>we have little understanding about what is guaranteed about <code>q</code> (or what <code>qNode</code> or <code>Queue</code> look like) </li>
<li><code>root</code> is allocated at the start of the function but the pointer value get replaced by <code>q-&gt;front</code>, causing a memory leak, could probably be detected by your compiler by enabling warnings.</li>
<li>is <code>q</code> or <code>q-&gt;front</code> not <code>NULL</code> ?</li>
<li>please check if <code>root</code> is not <code>NULL</code> before checking <code>root-&gt;next</code></li>
<li>ending if <code>root-&gt;next</code> is <code>NULL</code> would mean that the last node ( with content ) will be skipped because it does not have a <code>next</code> ( trace your algorithm by hand to verify )</li>
</ul>

<p>suggested fixes (file output skipped for brevity):</p>

<pre><code>void findFlight(Queue *q, int flightNum){
  if( q == NULL ) return;
  qNode *current = q-&gt;front;
  if( current == NULL ) return;
  while(current != NULL) {
      if( current-&gt;flightNum == flightNum ) {
          // we assume that current-&gt;fullName is actually set, but feel free to verify
          fprintf(stdout, ""%s is taking flight %d"", current-&gt;fullName, current-&gt;flightNum);
      }
      current = current-&gt;next;
  }
}
</code></pre>
",2
56090046,56089960,2,"<p>When you write <code>something++</code> or <code>++something</code> it's roughly equivalent to</p>

<pre><code>something = something + 1
</code></pre>

<p>(the difference between <code>something++</code> and <code>++something</code> is in what you get when you assign the result to something else).</p>

<p>Because of this, the operand of <code>++</code> has to be something you can assign to.</p>

<p><code>8++</code> is equivalent to <code>8 = 8 + 1</code>, but you can't assign to a number.</p>

<p><code>++x++</code> would be equivalent to something like <code>(x = x + 1) = (x = x + 1) + 1</code>, I can't even fathom what this could be intended to mean.</p>

<p><code>(x+y)--</code> is equivalent to <code>(x + y) = (x + y) - 1</code>. You can't assign to an addition expression (which variable would you be setting)?</p>

<p>You should only use <code>++</code> or <code>--</code> when you actually want to update a variable. It's not a general replacement for <code>+ 1</code> or <code>- 1</code>. So your program should be:</p>

<pre><code>x = 8 + 1;
y = 1 + x + 1;
z = (x + y) - 1;
</code></pre>

<p>This will print </p>

<pre><code>x = 9, y = 11, z = 19
</code></pre>
",0
58702702,58702655,2,"<pre><code>char* ret=malloc(totalLength+1);
...
ret[totalLength+1]='\0';
</code></pre>

<p>The highest index of an array is one less than the size. A buffer of size <code>totalLength+1</code> has indices from <code>0</code> to <code>totalLength</code>. The misplaced <code>\0</code> explains the trailing junk (<code>o</code>) on line 2.</p>

<pre><code>for(i=left;i&lt;strlen(s)+1;i++)
//                    ^^
for(i=strlen(s)+left;i&lt;totalLength;i++)
//             ^^^^^
</code></pre>

<p><code>+1</code> and <code>+left</code> should be the same to ensure the later loop picks up where the earlier one left off. The mismatch is a sign that one of them is wrong, and it's causing there to be a gap of uninitialized characters, which is why you're seeing garbage (<code>©¸</code>) in the middle of line 3.</p>
",0
58017072,58016962,1,"<p>Your math is wrong.  Change</p>

<pre><code> total_payment = hours_worked * total_payment;
</code></pre>

<p>to:</p>

<pre><code> total_payment = hours_worked * hourly_rate;
</code></pre>

<p>Also you're not initializing these values correctly, try:</p>

<pre><code>int hours_worked = strtol(argv[2], NULL, 10);
double hourly_rate = strtof(argv[3], NULL);
</code></pre>
",0
58017359,58016962,1,"<p>Convert <code>argv[2]</code> and <code>argv[3]</code> using either <code>atof()</code>. Using <code>atof()</code> for both numeric values in case one can work half an hour.</p>

<p>Check that the at least four arguments are passed to the program. Note <code>argc</code> will be one if no arguments are passed - for <code>argv[0]</code> which holds the program name. So <code>argc</code> will be at least 5 when the correct number of arguments are provided.</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
    if (argc &lt; 5)
    {
        fprintf(stderr, ""%s: Insufficient arguments\n"", argv[0]);
        exit(1);
    }

    char* first_name = argv[1];
    char* last_name = argv[2];
    int hours_worked = atof(argv[3]);
    double hourly_rate = atof(argv[4]);
    double total_payment = hours_worked * hourly_rate;

    printf(""%s, %s: %.2lf\n"", last_name, first_name, total_payment);
    return 0;
}
</code></pre>
",0
58774481,58774260,3,"<p>You should be able to use <a href=""https://en.cppreference.com/w/cpp/types/offsetof"" rel=""nofollow noreferrer""><code>offsetof</code></a> macro to get the offset to the member you want to compare, then use pointer arithmetic to get the value of the member. Note you won't get any type information for that member, just the offset into the struct so you'll want to ensure you know the sizes of the member fields.</p>

<p>So to do your compares, you could do this:</p>

<pre><code>void sort_arr(example_struct a[5], const char* usr_field) {
    size_t offset;
    if (strcmp(usr_field, ""id"") == 0)
        offset = offsetof(example_struct, id);
    else if (strcmp(usr_field, ""year"") == 0)
        offset = offsetof(example_struct, year);
    else if (strcmp(usr_field, ""price"") == 0)
        offset = offsetof(example_struct, price);

    ...
    if (*((int*)((char*)&amp;a[j])+offset) &gt; *((int*)((char*)&amp;a[j+1])+offset)) {
        ...
</code></pre>

<p>It may help to define some macros to make the member access a little more pleasant to work with.</p>

<pre><code>#define memberat(ref, offset, membertype) *((membertype*)((char*)ref)+(size_t)offset)

if (memberat(&amp;a[j], offset, int) &gt; memberat(&amp;a[j+1], offset, int))
</code></pre>

<p>If you're dealing with members of different types, you'll have to use function pointers to handle the comparisons since how they are compared will differ.</p>
",2
56248135,56248025,0,"<p>At the start of your function, you initialize <code>rec = count</code> - but at that point <code>count</code> is undefined (as far as can be determined, because you haven't provided the full code - are they both global variables?).</p>

<p>In addition, you're reading from stdin for some parts, but from an open file descriptor (<code>fp</code>) for others - but there's no association between them.</p>

<p>Please rethink your example and update the post - the structure is confusing and salient details are missing.</p>
",1
56249566,56248025,0,"<p>your count and rec is undefined and as they were not initialised.</p>

<p>Do read Id first before comparing it.</p>

<pre><code> fread(&amp;temp-&gt;id, sizeof(int), 1, fp); 
  printf(""\niD: %d\n"", temp-&gt;id);
  if (choice == temp-&gt;id) {

}
</code></pre>
",1
56151890,56151521,3,"<p>Indeed 2's complement is such that the complement to your number <code>n</code> (which algebraically is <code>-n</code>) is derived by <em>reflecting</em> the bit pattern of <code>n</code> then adding 1 to that number. Note that in a 2's complement scheme, -1 has all its bits set to 1.</p>

<p>The problem with reflecting the bit pattern using <code>~</code> is that it can cause unwanted type promotion which ruins the result.</p>

<p>One solution is to mask the the result of <code>~</code>, another is to cast the result. Of course, on a 2's complement platform, you can write simply <code>-n</code>, taking care to ensure that <code>n</code> is not already the smallest possible negative.</p>
",0
57183924,57183546,3,"<p>The operating system is allowed to deliver only one <code>SIGCHLD</code> signal to tell you that several child processes have exited.  That means you need to loop calling <code>waitpid</code> inside the signal handler, something like this:</p>

<pre><code>void sigchld_handler(int unused)
{
    pid_t pid;
    int status;
    for (;;) {
        pid = waitpid(-1, &amp;status, WNOHANG);
        if (pid == -1) {
            if (errno != ECHILD)
                printf(""waitpid failure: %s\n"", strerror(errno);
            return;
        }
        printf(""child %d exit status %d\n"", (int)pid, status);
    }
}
</code></pre>

<p>You need to use <code>WNOHANG</code> so that <code>waitpid</code> will fail and set <code>errno</code> to <code>ECHILD</code> when there are no more processes to wait for, instead of blocking (possibly forever).</p>

<p>Also, in order to make it safe to call <code>printf</code> from inside the signal handler, you need to use <code>sigprocmask</code> and <code>sigsuspend</code> in your main function, so that the signal can only be delivered when normal execution is blocked on <code>sigsuspend</code>.  Also also, never use <code>signal</code>, only <code>sigaction</code>; the specification of <code>signal</code> doesn't cover several important details that <em>will</em> bite you.</p>

<pre><code>int main(void)
{
   sigset_t sigchld_set;
   sigemptyset(&amp;sigchld_set);
   sigaddset(&amp;sigchild_set, SIGCHLD);

   sigset_t unblock_sigchld_set;
   if (sigprocmask(SIG_BLOCK, &amp;sigchld_set, &amp;unblock_sigchld_set)) {
       perror(""sigprocmask"");
       return 1;
   }
   sigdelset(SIGCHLD, &amp;unblock_sigchld_set);

   struct sigaction sa;
   sigfillset(&amp;sa.sa_mask);
   sa.sa_handler = sigchld_handler;
   sa.sa_flags = SA_RESTART;
   if (sigaction(SIGCHLD, &amp;sa, 0)) {
       perror(""sigaction"");
       return 1;
   }

   /* fork loop goes here */

   for (;;)
       sigsuspend(&amp;unblock_sigchld_set);

   return 0;
}
</code></pre>

<p>Making <code>main</code> exit when all child processes have been waited for is left as an exercise.  (Hint: you need C11 <a href=""https://en.cppreference.com/w/c/atomic"" rel=""nofollow noreferrer"">atomic types</a>.)</p>
",2
56148474,56148391,4,"<p>Even if the strings contain numbers, they are still <strong><em>strings</em></strong>, and you need to print them using the <code>""%s""</code> format:</p>

<pre><code>printf(""Compare between str1 and str2: %s, %s"", string1, string2);
//                                     ^^  ^^
// Note the format specifier being different
</code></pre>

<p>As for the ""numbers"" that are printed, remember that arrays decay to pointers to their first element. It's the decimal value of those pointers you're printing.</p>

<p>It should be noted that using mismatching format specifier and argument (like using <code>""%d""</code> to print a string) leads to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>.</p>

<hr>

<p>If you want to use <em>actual</em> numbers, and compare them with e.g. <code>&lt;</code> or <code>&gt;</code>, then you should have a numeric type instead, as in</p>

<pre><code>int number1 = 1;
int number2 = 2;
</code></pre>

<p>Then you can print them with the <code>""%d""</code> format specifier, as it expects an argument of type <code>int</code>:</p>

<pre><code>printf(""Compare between number1 and number2: %d, %d"", number1, number2);
</code></pre>
",0
55502936,55502742,0,"<p>That code runs fine here on my Mac, at least with the mergeSort commented out. You're not running on Windows, are you? If so the file may look empty because it's missing carriage returns. </p>
",6
55502936,55502742,0,"<p>That code runs fine here on my Mac, at least with the mergeSort commented out. You're not running on Windows, are you? If so the file may look empty because it's missing carriage returns. </p>
",6
55817208,55804149,1,"<p>What about a low-tech solution that works even with K&amp;R C and any compiler past and present?</p>

<p>Place the right comment in the right place:</p>

<pre><code>/*
 * If this type is changed, don't forget to change the macro in
 * if (fail_count &lt; UINT32_MAX - 1) below (or file foobar.c)
 */
uint32_t fail_count = 0;
</code></pre>

<p>With a proper encapsulation this should refer to exactly one place in the code.
Don't tell me you increment the fail count in many places. And if you do, what
about a</p>

<pre><code>#define FAIL_COUNT_MAX  UINT32_MAX
</code></pre>

<p>right next to the declaration? That's more proper and clean code anyway.
No need for all the assertion magic and rocket sciencery :-)</p>
",0
56196691,56196567,3,"<p>In C, anything within single quotes are integer character constants.</p>

<p>As specified in the standard.</p>

<blockquote>
  <p>An integer character constant is a sequence of one or more multibyte characters enclosed
  in single-quotes, as in 'x'. A wide character constant is the same, except prefixed by the
   letter L. With a few exceptions detailed later, the elements of the sequence are any
  members of the source character set; they are mapped in an implementation-defined
   manner to members of the execution character set.</p>
</blockquote>

<p>Since there are multiple bytes in <code>'word[i][1]'</code>, behavior is implementation defined.</p>

<p>What you probably wanted was</p>

<pre><code>word[i][0] = toupper(word[i][0]);
</code></pre>

<p>In C, indexing starts from <code>0</code> and not <code>1</code>.</p>

<p>And <code>toupper()</code> just returns a value. The original array element value is not modified. You can assign the value returned by <code>toupper()</code> back to <code>word[i][0]</code>.</p>

<p>You should also include the <code>ctype.h</code> header file for the <code>toupper()</code> function.</p>

<hr>

<p>And <code>strlwr()</code> is a non-standard function. You could use a loop and the <code>tolower()</code> function instead. See <a href=""https://stackoverflow.com/q/2661766/5375464"">How do I lowercase a string in C?</a>.</p>

<hr>

<p><code>scanf()</code> is not the best way to read user input and even if you use it, you should check the return value to see if it succeeded. </p>

<p>Instead you could use <code>fgets()</code>-<code>sscanf()</code> combination.</p>
",7
58621666,58621584,3,"<p>The problem is, in both code and snippet provided, the variable assigned by <code>malloc</code>'s return value lives until the function returns. So you need to use pointer-to-pointer. Moreover, in the first snippet, if you <code>free</code> the area allotted already, you can't use the space anymore.</p>

<pre><code>void create_array(double **x, unsigned long n) {
    *x = malloc(n *sizeof(double));
    if(*x == NULL){
        printf(""Sorry Memory Not Available. Program Terminated.\n"");
        exit(1);
    }
}
</code></pre>

<p>In main, you can call it as <code>create_array(&amp;array, n);</code>.</p>
",1
58931761,58906995,0,"<p>Consider these 3 lines in the order they're executed:</p>

<pre><code>List list = { NULL, 0 };  // in `main`

insertAtTail( &amp;list, val ); // in `main`

Node **link = &amp;( list-&gt;head ); // in `insertAtTail`
</code></pre>

<p>Since <code>list-&gt;head</code> is <code>NULL</code>, <code>*link</code> is <code>NULL</code>.</p>

<p>Then once the <code>n-&gt;next-&gt;value = (*link)-&gt;value;</code> line is executed, you're dereferencing a null pointer.</p>
",0
57918445,57918353,7,"<p>The presence of <code>main()</code> instead of <code>int main (void)</code> means you are using an ancient version of C known as C90, instead of using standard C, since <code>main()</code> will only compile cleanly in ancient C90.</p>

<p>C90 did not support <code>%lf</code> for <code>printf</code> other than as a compiler extension. It only supported <code>%f</code> for all floating point types. This could explain why you get weird output. See <a href=""https://stackoverflow.com/questions/4264127/correct-format-specifier-for-double-in-printf"">Correct format specifier for double in printf</a>.</p>

<p>Solve this by getting an updated compiler and an updated source of learning C.</p>
",6
59141530,59141273,2,"<p>Your program start the loop with <code>i</code> = 0 and test the first character in email. If this first character is not a punctuation, your program asks for a new email. So your program keeps testing only the first character and it requires that it¡¯s a punctuation.</p>

<p>You should accumulate the result of the <code>ispunct</code> test and test the result.</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
int main()
{
    char email[100];
    int i;
    printf(""Input username (email)    :"");
    scanf(""%s"", email);
    for () {
        int done = 0;
        for (i = 0; email[i] != '\0'; ++i)
            done |= ispunct(email[i]);
        if (done != 0)
            break;
        printf(""Please input a correct username (email)    :"");
        scanf(""%s"", email);  
    }
    return 0;
}
</code></pre>
",0
58147686,58147631,0,"<p>No, this isn't possible in the stack.</p>

<p>You can use a variable-length array to allocate a local array whose size comes from an expression. But once it's allocated, you can't change the size.</p>

<p>If you need to resize the array, you have to use dynamic allocation with <code>malloc()</code> and <code>realloc()</code>.</p>
",0
55559777,55559577,1,"<p>The problem is with the condition of your inner if in else block.</p>

<pre><code>if(min2 = 0)
</code></pre>

<p>One equal sign is assignment operator, you have to use == for equality check.</p>

<pre><code>if(min2 == 0)
</code></pre>
",0
56311016,56310981,1,"<p>Your buffer isn¡¯t stored in two places. You¡¯re just copying the data yourself in your code. There¡¯s the input that¡¯s given to <code>main</code> and then your buffer where you copy the input. That¡¯s two copies of it but only one is your buffer.</p>

<p>Using gdb to show where <code>argv[1]</code> is stored will also show this:</p>

<pre><code>p argv[1]
$1 = 0x7ffffffee2ce 'A' &lt;repeats 600 times&gt;
</code></pre>

<p>The address will of course be different on different systems.</p>
",11
58583512,58582132,1,"<p>This line</p>

<pre><code>char* q = (message + (strlen(message));
</code></pre>

<p>Does it point to the last character.</p>

<p>Consider a message of one character - <code>strlen(message)</code> will by one. But the first character would be <code>char * q = message</code> </p>

<p>So the line should read</p>

<pre><code>char* q = (message + strlen(message) - 1;
</code></pre>

<p>Also the swap is a be awry</p>

<p>Try</p>

<pre><code>char temp;
</code></pre>

<p>Instead then instead of</p>

<pre><code>*p = *q; 
*q = *temp;
p++;
q--;
temp = p;  
</code></pre>

<p>Use</p>

<pre><code>temp = *p;  // We got the temp
*p = *q;    // Old p is safe - it is now temp.
*q = temp;

p++;
q++;
</code></pre>

<p>With this code the null character is not reversed! Hence in the right place!</p>

<p>Finalluy,</p>

<pre><code>while( p != q){
</code></pre>

<p>Should be</p>

<pre><code>while( p &lt; q){
</code></pre>
",0
58582863,58582132,0,"<p>regarding:</p>

<pre><code>p++;
q--;
</code></pre>

<p>After the above statements, the pointers can have passed each other.  Then the loop keeps running until the seg. fault occurs</p>
",0
55636094,55635943,3,"<p>Assuming <code>LCH</code> and <code>CCH</code> are defined as <code>char</code>, change the format strings to consume the newline (<code>\n</code>) character.  </p>

<p>From:</p>

<pre><code>scanf(""%*c%c"",&amp;LCH);
printf(""Enter the Vehicle type: "");
    scanf(""%*c%c"",&amp;CCH);
</code></pre>

<p>To:</p>

<pre><code>scanf("" %c"",&amp;LCH);
printf(""Enter the Vehicle type: "");
    scanf("" %c"",&amp;CCH);
    //     ^  space prior to format specifier is to consume newline 
    //     which is inserted when user hits return key.
</code></pre>

<p>Consider avoiding caps when defining your variables.  They are conventionally used for <code>#define</code> constants and other pre-processor constants, as well as some standard <code>struct</code> names, eg <code>FILE</code>.  <code>camelCase</code>, or <code>lowercase</code> are among the better options.</p>
",0
58370772,58365919,1,"<p>It doesn't really answer your question about columns, but outputting text on the terminal is really limited for any kind of scientific work. Instead, consider outputting to a <code>tsv</code> or <code>csv</code> and graphing with a more complex tool.</p>

<pre><code>#include &lt;stdlib.h&gt; /* EXIT bsearch strtol */
#include &lt;stdio.h&gt; /* [f]printf */
#include &lt;limits.h&gt; /* INT_MAX */
#include &lt;errno.h&gt; /* errno */

/* This seems hard, and it's not part of your question, so I've dowloaded
 a static list from &lt;https://oeis.org/A007770/list&gt;. */
static const unsigned happy10[] = {
    1,7,10,13,19,23,28,31,32,44,49,68,70,79,82,86,91,
    94,97,100,103,109,129,130,133,139,167,176,188,190,
    192,193,203,208,219,226,230,236,239,262,263,280,
    291,293,301,302,310,313,319,320,326,329,331,338
};
static const size_t happy10_size = sizeof happy10 / sizeof *happy10;

static int compare(const int *const a, const int *const b) {
    return (*a &gt; *b) - (*b &gt; *a);
}

static int compar(const void *a, const void *b) {
    return compare(a, b);
}

static int happy(unsigned num) {
    return bsearch(&amp;num, happy10, happy10_size, sizeof *happy10, &amp;compar)
        ? 1 : 0;
}

int main(int argc, char **argv) {
    char *end;
    unsigned liminf, limsup, num;
    long l;
    int success = EXIT_FAILURE;

    /* Get command line parameters. */
    if(argc != 3) goto catch;
    if((!(l = strtol(argv[1], &amp;end, 0)) &amp;&amp; errno) || *end != '\0') goto catch;
    if(l &lt;= 0 || l &gt; 338 || l &gt; INT_MAX) { errno = ERANGE; goto catch; }
    liminf = l;
    if((!(l = strtol(argv[2], &amp;end, 0)) &amp;&amp; errno) || *end != '\0') goto catch;
    if(l &lt;= liminf || l &gt; 338 || l &gt; INT_MAX) { errno = ERANGE; goto catch; }
    limsup = l;

    /* Output all 10-happy numbers in the range. */
    printf(""# 10-happy numbers in the range [%u, %u]\n"", liminf, limsup);
    for(num = liminf; num &lt;= limsup; num++)
        if(happy(num) == 1) printf(""%d\n"", num);

    success = EXIT_SUCCESS;
    goto finally;

catch:
    if(errno) perror(""happy"");
    else fprintf(stderr, ""usage: &lt;inferior&gt; &lt;superior&gt;\n"");

finally:
    return success;
}
</code></pre>

<p>Running this:</p>

<pre><code># 10-happy numbers in the range [1, 10]
1
7
10
</code></pre>

<p>If we use a <a href=""http://gnuplot.info/"" rel=""nofollow noreferrer"">gnuplot</a> script <code>happy.gnu</code>,</p>

<pre><code>set term postscript eps enhanced
set output ""happy.eps""
set grid
set boxwidth 0.5
set style fill solid
set style line 1 lc rgb ""#0060ad""
set xlabel ""n""
set ylabel ""F_{2,10}(n)""
set autoscale xfixmin
set autoscale xfixmax
plot ""happy.data"" using 1 notitle with boxes ls 1;
</code></pre>

<p>Then do,</p>

<pre><code>./a.out 1 100 &gt; happy.data
gnuplot happy.gnu
</code></pre>

<p>It gives <code>happy.eps</code>, which is probably prettier then terminal output.</p>

<p><a href=""https://i.stack.imgur.com/TtSx5.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/TtSx5.png"" alt=""F_{2,10} for [1, 100]""></a></p>
",0
55656305,55655912,0,"<p>You are not that far from your target:</p>

<pre><code>struct my_struct {
    float array[2][3];
    char* (*function)(int);
};
</code></pre>

<p>""Real numbers"" and ""strings"" can be represented in C in many ways, but <code>float</code> and <code>char*</code> are probably the most popular options. Two dimensional array also can be represented in several ways, but your approach is okay.</p>
",1
56260141,56260102,1,"<p>Backslash is the escape character, you need to use a double-backslash to make a character literal containing a single backslash:</p>

<pre><code>if (c=='\\')
</code></pre>

<p>Without the extra backslash, the single backslash escapes the closing single quote, so the character literal doesn't end, and the code will not compile (on the rare occasions it does, it's likely compiling garbage).</p>

<p>As for <code>\t</code>, if you want to compare to an actual tab, <code>if (c=='\t')</code> works just fine. But if you want to recognize a literal backslash followed by a <code>t</code>, you'll need to recognize it in two pieces, first the backslash, then read another character to see the <code>t</code>, e.g.:</p>

<pre><code>int main()
{
    int c;
    while((c=getchar())!=EOF)
    {
        if (c == '\\') {
            printf(""Found escape beginning\n"");
            if ((c = getchar()) == EOF) break;
            if (c == 't')
                printf(""Found backslashed 't'\n"");
        }
    }
    return 0;
}
</code></pre>

<p>Note: Your <code>printf</code> was also wrong, as it passed a character literal to <code>printf</code>, not a string literal. I've fixed it in the expanded code above; your original code would change <code>printf('x');</code> to <code>printf(""x"");</code></p>
",1
58691054,58690594,0,"<p>You probably want something like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;

int main(int argc, char* argv[]) {
  printf(""Enter size of input:\n"");

  char input[100];
  fgets(input, sizeof input, stdin);

  if (!isdigit(input[0]))
  {
    printf(""Invalid Size\n"");
  }
  else
  {
    int inputsize = strtol(input, NULL, 10);
    printf(""%d\n"", inputsize);
  }
}
</code></pre>
",0
58884935,58882032,0,"<p>Adding to Jonathan Leffler's and my earlier comments.</p>

<p>Each iteration reads some lines from the file. The first iteration works fine but the second picks up where the first left of so you blow through a lot of lines quickly. </p>

<p>What is needed is to rewind the file to the beginning at the start of each iteration. The fseek() function will do this for you.  The trouble is you will also repeat questions if <code>rand() % 7</code> returns the same number again. A static array initialized to all zeros to check if an question has already been used would be needed. Or use a bit map. rewind() is a special case of fseek() that returns to the start of the file (think old-style magnetic tapes).</p>

<p>Also, <code>if(arqgeo == NULL)</code> is wrong as the value of apqgeo does not change on troubles. Look at the ferror() and feof() functions to test eof/error conditions.  scanf() also returns the count of the fields converted with EOF indicating some type of trouble where these ""f"" functions would be useful. At any rate returns of &lt;= 0 indicate time to get out (EOF is usually (-1)).</p>

<p>While it's annoying to have to test each and every input statement for troubles it is good practice. If you don't you need to be hyper alert for behaviors caused by silent errors.</p>

<p>Challenge: arrange question file and and it's handling to get rid of the <code>r == 0</code> test. If you have 8 questions you really don't need it.</p>
",0
59242920,59242736,0,"<p>If you need to initialize a character array, write: <code>char S[N] = {0};</code> -- it will be initialized with zero characters, that could be used as a string terminator if you need them to.</p>

<p>If you need to read a string, just do that with <code>fread(buf, 1, N, stdin);</code></p>

<p>All in all, your code might look like this:</p>

<pre><code>char S[N] = {0};
fread(buf, 1, N, stdin);
</code></pre>
",1
59242780,59242736,4,"<p>This should work, and you don't have to add the NUL (not NULL, it's ASCII) at the end because you're treating it as an array of N distinct characters and not as a string. If you wanted to <code>printf</code> it with <code>%s</code> or call <code>strlen</code> on it, then you'd have to add the NUL (and allocate N+1 characters for the array).</p>

<p>You should add <code>\n</code> at the end of your <code>printf</code> format string.</p>

<p>Note that you will have to type the N characters all on one line. If you press return after the first one, for example, the linefeed will be taken as the second character.</p>
",2
55751293,55751187,1,"<p>You put a sensible value into each entry in the array:</p>

<pre><code>users[r] = malloc((n+1) * sizeof(char));
</code></pre>

<p>But then you overwrite it with a nonsensical value (a pointer into <code>line</code>):</p>

<pre><code>users[counter] = username;
</code></pre>

<p>What you presumably wanted to do was copy the string pointed to by <code>username</code> into the space allocated at <code>users[counter]</code>. The <code>strcpy</code> function can do this.</p>
",0
55751450,55751187,-1,"<p>I would just like to add to David's answer that you should also check the username string is null terminated before using <code>strcpy()</code>.  I can't remember if <code>strtok()</code> null terminates but you shouldn't rely on it anyway.</p>
",1
57102583,57102190,2,"<p>As Eric and Eugene has said in the comments, <strong><em>there is no way to convert a hexidecimal number to a decimal number</em></strong>.  Hexidecimal or decimal only exist in the code you write.  Once a compiler sees a number it will store it in memory in it's own representation.</p>

<p>Here's an example of how you can write numbers in different representations in your code.  All the numbers I write in the following code are the same.  The program does not change, no matter which one you use.</p>

<pre><code>int x = 0x10;
// stored in memory as:
// |0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|0|0|0|0|

int x = 16;
// stored in memory as:
// |0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|0|0|0|0|

int x = 0b00000000000000000000000000010000;
// stored in memory as:
// |0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|0|0|0|0|

int x = 020;
// stored in memory as:
// |0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|0|0|0|0|
</code></pre>

<p>So for your example you <code>block</code> can be represented in either of these ways</p>

<pre><code>uint8_t block_hex[8] = {0xb,0xb,0xb,0xa,0xa,0xa,0xa,0xa};
uint8_t block_dec[8] = {11,11,11,10,10,10,10,10};
</code></pre>

<p>Changing between hexidecimal and decimal will not change the behavior of your program.</p>
",0
55784016,55783976,4,"<p>You can't ""test"" if they have successfully been freed, trying to access any memory that has been freed is undefined behavior, instead of testing just accept and move on.</p>
",0
58308981,58308793,1,"<p>Analogies between real life and the inner workings of software, or anything technological for that matter, are generally avoided for good reason: they might seem enticing when you look at them superficially, but they break down in all sorts of horrible ways as soon as you dive in a bit deeper than the surface.  Also, they are so treacherous that even at the superficial level they do not help at all: the amount of mental housekeeping that you have to do in order to maintain the analogy is like adding one more dimension to the complexity of the problem at hand.  So, my advice is: forget the real life analogies, think technically and only technically.</p>

<p>The concept of a ""connection"" exists because the underlying system (the Internet Protocol stack) needs it for housekeeping purposes. In the ""connection"" the system keeps various things like the IP address of the remote party, a buffer in which it is receiving data from the remote party until an entire packet has been completed so that the packet can then be delivered to you as one piece, error-correcting information such as a packet id so that the stack knows whether it has missed a packet or is receiving a duplicate packet, etc.  </p>

<p>All this information is crucial, and it pertains to communication with only that one specific remote party.  When another party comes in, they will have a different IP address, you don't want their data mixed with the previous guy's data, and you want a new packet sequence for error correction.  In other words, you need a new connection.  That's what connections are all about, and that's why a different connection must be established with each individual remote party.</p>
",0
58965846,58965754,2,"<p>The first iteration of the <code>while</code> loop uses <code>data</code> before it has read the line. It should be:</p>

<pre><code>    while(fgets(data, sizeof data, x)) {
        parse(data,&amp;acct,&amp;amnt);
    }
</code></pre>

<p>You don't need to subtract 1 from the size of <code>data</code> when calling <code>fgets()</code>.</p>

<p>There's no reason to copy <code>data</code> to <code>record</code>. You can simply parse <code>data</code> (the <code>parse()</code> function will ignore the newline). <code>fgets()</code> ends the string with a null terminator, you don't need to add it yourself.</p>

<p><code>#include</code> should only be used for <code>.h</code> files, not <code>.c</code> files. You combine object files using the linker. So get rid of <code>#include ""ssv.c""</code>, replace it with <code>#include ""ssv.h""</code>. This file should just contain a declaration of <code>parse()</code>.</p>

<pre><code>void parse(char record[], int *acct, float *amnt);
</code></pre>

<p>Compile the two programs using:</p>

<pre><code>gcc main.c ssv.c
</code></pre>

<p>Or you can compile each file separately then link them:</p>

<pre><code>gcc -c main.c
gcc -c ssv.c
gcc main.o ssv.o
</code></pre>
",3
58988503,58987245,3,"<blockquote>
  <p>We shouldn't bother how compiler is behaving in certain cases unless
  it is incorrect as per standard.</p>
</blockquote>

<p>As per C standard, the uninitialized local variables can have any garbage value. Better to initialize them and don't be dependent on compiler.</p>
",0
58900296,58900226,4,"<p>Working from inside to outside, each step is the reciprocal of <code>i</code> plus the previous step, where <code>i</code> runs from 103 to 1 in steps of ?2, and we start with a ¡°previous step¡± of 0:</p>

<pre><code>#include &lt;stdio.h&gt;


int main(void)
{
    double x = 0;
    for (int i = 103; 1 &lt;= i; i -= 2)
        x = 1/(i + x);
    printf(""%g\n"", x);
}
</code></pre>
",1
58694749,58694473,3,"<p>A bunch of ways!</p>

<ol>
<li><p>Study C for many years well enough to write your own elaborate set of functions and structures (but not classes), such that you create something more or less useful for you, but that nobody else will ever be able to use.</p></li>
<li><p>Switch to C++.</p></li>
<li><p>Wish upon a star.</p></li>
</ol>

<p>Really, as comments above have noted, C <em><strong>does not support this</strong></em> and there's simply no way to pretend that it does.  Efforts such as my #1 above would be a huge amount of work, and entirely counterproductive.</p>

<p>It's a totally fair question to wish for, but you really need to take ""no"" for an answer here.</p>
",0
58054978,58052061,0,"<p>The only way to make this faster is with a lookup table.  The main thing that makes this not the fastest possible is that the code devolves to a bunch of comparisons, something like:</p>

<pre><code>if(ch == 'A') goto isvowel;
else if(ch == 'E') goto isvowel;
else if(ch == 'I') goto isvowel;
.
.
.
isvowel: putchar(ch);
</code></pre>

<p>but that's so inconsequential that in real life, who'd care?</p>

<p>But the way to make it faster is to use a a table:</p>

<pre><code>int isvowel[] = {1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0};
</code></pre>

<p>Now you just need to change your letter to a number from 0 to 26.  First, if you look at the ASCII internals, you see that a lowercase letter differs from an uppercase letter by only a single letter.  So you can make something upper case always like this:</p>

<pre><code>ch &amp; 0xFFDF;
</code></pre>

<p>To convert to a number, you just subtract the value of the first letter:</p>

<pre><code>(ch &amp; 0xFFDF) - 'A'.
</code></pre>

<p>Then, to see if it is a value, you just test of the array at that position is <code>1</code>:</p>

<pre><code>if(isvowel[(ch &amp; 0xFFDF) - 'A')
</code></pre>

<p>Note that if <code>ch</code> is not a character, our math won't work, so we need to guard against that.</p>

<p>So the full code becomes something like:</p>

<pre><code>#include &lt;stdio.h&gt;    
int main(){
    char ch = 0;

    int isvowel[] = {1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0};
    while(ch != '\n'){

        ch = getchar();

        unsigned int ord = (ch &amp; 0xFFDF) - 'A';
        if( ord &lt; 26 &amp;&amp; isvowel[ord])
             putchar(ch);
    }
    putchar('\n');
}
</code></pre>

<p>The reason this is (very slightly) faster (but not fastest possible) is that you are doing only two comparisons, and not ten.  If you look at the old version, internally, it's something like:</p>

<pre><code>compare to 'A'
compare to 'E'
compare to 'I'
compare to 'O'
compare to 'U'
compare to 'a'
compare to 'e'
compare to 'i'
compare to 'o'
compare to 'u'
</code></pre>

<p>With the table, it becomes</p>

<pre><code>and with 0xFFDF
subtract 'A'
compare with 26
dereference table
compare
</code></pre>

<p>So about half the operations.  But with modern processors, we're talking nanoseconds in either case, so I really wonder why this would come up in an intro assignment.</p>

<p>Note that this is exactly how standard library methods like <a href=""https://www.programiz.com/c-programming/library-function/ctype.h/isalpha"" rel=""nofollow noreferrer"">isalpha()</a> are usually implemented.  For <code>isalpha()</code>, there is a 256 entry table with every value that is alphabetic in ASCII set to true, every value that is not set to false.  This makes these extremely fast, faster than my implementation here as they don't need to convert to upper case or check for out of bounds.</p>

<p>But I want to emphasize: <strong>You should not worry about such inconsequential differences.</strong>  This is the kind of thing you do after spending weeks with a profiler in production code, not in student assignments!.</p>

<p><strong>Addendum:</strong></p>

<p>If you are using gcc, you can generate ASM code with <code>gcc -S</code>.  This is useful for seeing the raw code a program compiles down to.  The switch in your original looks like this in ASM:</p>

<pre><code>    movsbl  -5(%rbp), %eax
    movl    %eax, %edx
    subl    $65, %edx
    movl    %eax, -12(%rbp)         ## 4-byte Spill
    movl    %edx, -16(%rbp)         ## 4-byte Spill
    je  LBB0_3
    jmp LBB0_7
LBB0_7:                                 ##   in Loop: Header=BB0_1 Depth=1
    movl    -12(%rbp), %eax         ## 4-byte Reload
    subl    $69, %eax
    movl    %eax, -20(%rbp)         ## 4-byte Spill
    je  LBB0_3
    jmp LBB0_8
LBB0_8:                                 ##   in Loop: Header=BB0_1 Depth=1
    movl    -12(%rbp), %eax         ## 4-byte Reload
    subl    $73, %eax
    movl    %eax, -24(%rbp)         ## 4-byte Spill
    je  LBB0_3
    jmp LBB0_9
LBB0_9:                                 ##   in Loop: Header=BB0_1 Depth=1
    movl    -12(%rbp), %eax         ## 4-byte Reload
    subl    $79, %eax
    movl    %eax, -28(%rbp)         ## 4-byte Spill
    je  LBB0_3
    jmp LBB0_10
LBB0_10:                                ##   in Loop: Header=BB0_1 Depth=1
    movl    -12(%rbp), %eax         ## 4-byte Reload
    subl    $85, %eax
    movl    %eax, -32(%rbp)         ## 4-byte Spill
    je  LBB0_3
    jmp LBB0_11
LBB0_11:                                ##   in Loop: Header=BB0_1 Depth=1
    movl    -12(%rbp), %eax         ## 4-byte Reload
    subl    $97, %eax
    movl    %eax, -36(%rbp)         ## 4-byte Spill
    je  LBB0_3
    jmp LBB0_12
LBB0_12:                                ##   in Loop: Header=BB0_1 Depth=1
    movl    -12(%rbp), %eax         ## 4-byte Reload
    subl    $101, %eax
    movl    %eax, -40(%rbp)         ## 4-byte Spill
    je  LBB0_3
    jmp LBB0_13
LBB0_13:                                ##   in Loop: Header=BB0_1 Depth=1
    movl    -12(%rbp), %eax         ## 4-byte Reload
    subl    $105, %eax
    movl    %eax, -44(%rbp)         ## 4-byte Spill
    je  LBB0_3
    jmp LBB0_14
LBB0_14:                                ##   in Loop: Header=BB0_1 Depth=1
    movl    -12(%rbp), %eax         ## 4-byte Reload
    subl    $111, %eax
    movl    %eax, -48(%rbp)         ## 4-byte Spill
    je  LBB0_3
    jmp LBB0_15
LBB0_15:                                ##   in Loop: Header=BB0_1 Depth=1
    movl    -12(%rbp), %eax         ## 4-byte Reload
    subl    $117, %eax
    movl    %eax, -52(%rbp)         ## 4-byte Spill
    jne LBB0_4
    jmp LBB0_3
LBB0_3:                                 ##   in Loop: Header=BB0_1 Depth=1
    jmp LBB0_1
LBB0_4:                                 ##   in Loop: Header=BB0_1 Depth=1
</code></pre>

<p>With the table, it looks like this:</p>

<pre><code>    movsbl  -117(%rbp), %eax
    andl    $65503, %eax            ## imm = 0xFFDF
    subl    $65, %eax
    movl    %eax, -124(%rbp)
    cmpl    $26, -124(%rbp)
    jae LBB0_5
## %bb.3:                               ##   in Loop: Header=BB0_1 Depth=1
    movl    -124(%rbp), %eax
    movl    %eax, %ecx
    cmpl    $0, -112(%rbp,%rcx,4)
    je  LBB0_5
## %bb.4:                               ##   in Loop: Header=BB0_1 Depth=1


</code></pre>
",0
56484774,56484591,0,"<p>If you're directly running the .exe from Windows, it'll automatically close because once the application finishes, Windows closes the window. You can run it from the command prompt or put something at the end of your code to hold the session open (like <code>getchar()</code>).</p>
",6
59048444,59047274,1,"<p>You're looking for something like this?</p>

<pre><code>extern uint64_t rng(void); // produced an b6-bit random number

void make_salt(uint64_t i1, uint64_t i2, uint64_t i3, uint64_t i4, uint8_t * salt)   
{
  memcpy(salt, &amp;i1, 8);
  memcpy(salt + 8, &amp;i2, 8);
  memcpy(salt + 16, &amp;i3, 8);
  memcpy(salt + 24, &amp;i4, 4);
}

uint8_t salt[28];
make_salt(rng(), rng(), rng(), rng(), salt);
</code></pre>
",0
57132229,57124581,0,"<p>I'm assuming that your <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> are some kind of input lines from a keyboard and you want to check which key was pressed.</p>

<p>If that is the case, and they can only take values <code>0</code> and <code>1</code> I think it is clearer if you combine these bits into a single value and then just check with a constant:</p>

<pre><code>#define KEY_1 0b1100
#define KEY_2 0b1010
#define KEY_3 0b1001
//...

unsigned char key = (A &lt;&lt; 3) | (B &lt;&lt; 2) | (C &lt;&lt; 1) | D; // or the other way around
//now you can even use a switch
switch (key)
{
    case KEY_1:
        send_text1(...);
        break;
    case KEY_2:
        send_text2(...);
        break;
    case KEY_3:
        send_text3(...);
        break;
    //...
}
</code></pre>
",2
57838864,57833746,1,"<blockquote>
  <p>SOLVED: Tried the code on a 32 bit vm and all was well, although not entirely sure as to why this maybe, but has been my work around for the moment.</p>
</blockquote>

<p>This is likely because the code makes assumptions about the size of integers and other types which it should not. For example...</p>

<pre><code>int userid;
... 
userid = getuid();
...
if (write(file_descriptor, &amp;userid, 4) == -1)
    fatal(""in main() while writing userid to file"");
</code></pre>

<p>There's two mistakes there. <code>getuid</code> returns a <code>uid_t</code>, not an <code>int</code>. They might be the same size so it might work.</p>

<p>More important, they've hard coded the size of <code>userid</code> as 4 bytes. <code>userid</code> is an <code>int</code> which is only guaranteed to be at least 2 bytes. On 32 bit machines it is typically 4 bytes (32 bits). On 64 bit machines it is 8 bytes (64 bits).</p>

<p>It works on a 32-bit VM because there <code>int</code> is 4 bytes.</p>

<p>Instead, use the proper types and <code>sizeof</code> to get the size.</p>

<pre><code>uid_t userid;
... 
userid = getuid();
...
if (write(file_descriptor, &amp;userid, sizeof(userid)) == -1)
    fatal(""in main() while writing userid to file"");
</code></pre>

<hr>

<p>Overall the quality of this code is very poor. I'm hoping it's written this way for illustrative purposes.</p>

<ul>
<li><code>strcpy(buffer, argv[1])</code> and <code>strcpy(search_string, argv[1])</code> risk a buffer overflow.</li>
<li>There's a number of places they fail to check that file operations succeed. </li>
<li>There is a deceptive <code>if</code> condition.</li>
</ul>

<pre><code>    if (search_note(note_buffer, search_string))
        printf(""------ [ note data ] ------\n"");
        printf(note_buffer);
        printf(""\n"");
</code></pre>

<p>The indentation makes it look like it's all inside an <code>if</code>, but the lack of braces means it's really this:</p>

<pre><code>    if (search_note(note_buffer, search_string)) {
        printf(""------ [ note data ] ------\n"");
    }
    printf(note_buffer);
    printf(""\n"");
</code></pre>
",0
57833716,57833708,1,"<p>Because there are too many arguments for format; nothing in the format string is preceded by a <code>%</code>, so it doesn't take <em>any</em>.</p>
",4
58503334,58502687,0,"<p>What you are trying to do is get <code>stdin</code> back to your control (terminal input) after a redirection. According to the <a href=""http://c-faq.com/stdio/devtty.html"" rel=""nofollow noreferrer"">C-FAQ</a> you can't do it in a portable way:</p>

<blockquote>
  <p>There is no portable way of doing this. <strong>Under Unix, you can open the special file /dev/tty</strong>. Under MS-DOS, you can try opening the ``file'' CON, or use routines or BIOS calls such as getch which may go to the keyboard whether or not input is redirected. </p>
</blockquote>

<p>But, if portability is not an issue, we can try a little work around (not optimal):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[])
{
    char buf[1001], fname[10];
    FILE *fp;
    int i = 0;

    while(1) {
        if(fgets(buf, 1000, stdin)) {
            sprintf(fname, ""mf%d"", i++);

            if(!(fp = fopen(fname, ""w""))) {
                perror(""fopen"");
                continue;
            }

            fprintf(fp, buf);
            fclose(fp);
        }

        if(!(stdin = fopen(""/dev/tty"", ""r""))) {
            perror(""stdin"");
            exit(0);
        }
    }


    return 0;
}
</code></pre>

<p>The thing is, when you run the program, go to another terminal and get it's PID (<code>ps aux | grep myprog</code>). Say the PID is 12345 Then you do <code>ls -la /proc/12345/fd</code> and you'll see that the descriptor 0 is a pipe (done by the shell). So you need another stdin... and in Linux you can use <code>fopen(""/dev/tty"", ""r"")</code>, but again, not portable.</p>
",0
57840316,57840007,0,"<p>Your algorithm, as is, offers quite some opportunities to optimise:</p>

<pre><code>for(int k=0;k&lt;m &amp;&amp; ifBreak==0;k++)
{
    for(int l=0;l&lt;m;l++)
    {
        if(...)
        {
            ifBreak = 1;
            break;
        }
    }
}
</code></pre>

<p>This code results in additional conditional branches in outer loop for every loop run. You can avoid this by using <code>goto</code>:</p>

<pre><code>for(int k=0; k&lt;m; k++)
{
    for(int l=0; l&lt;m; l++)
    {
        if(...)
        {
            goto LoopExitN;
        }
    }
}
LoopExitN:
// next loop...
</code></pre>

<p>Then you have multiple loops, each running one after another ¨C and each of having its own comparisons for stop conditions. If you combine all these loops into single loops, you spare many of these checks:</p>

<pre><code>for(int k=0; k&lt;m; k++)
{
    for(int l=0; l&lt;m; l++)
    {
        // check for lines:       board[k][l]
        // check for columns:     board[l][k]
    }
    // check for first diagonal:  board[k][k]
    // check for second diagonal: board[k][m-k]
}
</code></pre>

<p>Solely, having an early exit condition gets more difficult; you might keep track for every row, column and the two diagonals if there was a failure, and if all these tracks get falsified, you'd exit. To get this more efficient, you'd have a total count of <code>2*m + 2</code> getting decremented every time you falsify one of the tracks ¨C and exit the loop as soon as this count gets zero. If you really get faster with, you'd yet have to evaluate, though.</p>

<p>But now let's step back once again: Did you notice that with your algorithm, as is, you are re-evaluating every row, every column and every diagonal with every newly chosen number? That is pretty much of work to be done. And it is exactly here where you can safe most of the time: You should avoid these re-calculations! How? Pretty simple: Keep track of how many numbers are yet missing to complete the row/column/diagnoal:</p>

<pre><code>for(int k=0; k&lt;m; k++)
{
    for(int l=0; l&lt;m; l++)
    {
        if(board[k][l] == number)
        {
            if
            (
                --rows[k] == 0 || --columns[l] == 0
                || (l == k &amp;&amp; --diagnoal1 == 0)
                || (l == m - k - 1 &amp;&amp; --diagnoal2 == 0)
            )
            {
                // we have a winner!
                goto CurrentPlayerCompleted;
            }
        }
    }
}
</code></pre>

<p>Of course, you'd initialise all these rows/columns/diagonals with <code>m</code>...</p>

<p><em>Edit:</em> As these modifications don't seem to be enough: Change the representation of your boards! Instead of having a <code>[m][m]</code> array (which effectively maps position to number), have a lookup table number to position!</p>

<p>This way you won't need the double loop inside (but you'll keep the rows/columns/diagonals fields from above!):</p>

<pre><code>for(int i = 0; i &lt; m * m &amp;&amp; winCount == 0; i++)
{
    for(int j = 0; j &lt; n; j++)
    {
        // possibly need to check if the number is contained in board at all

        // possibly need to apply some hash function, for now, assuming
        // that an array for all numbers is sufficient, leaving the rest to you
        struct position pos = board[number];

        if
        (
            --rows[pos.row] == 0 || --columns[pos.column] == 0
            || (pos.column == pos.row &amp;&amp; --diagonal1 == 0)
            || (pos.column == m - pos.row - 1 &amp;&amp; --diagnoal2)
        )
        {
            // we have a winner!
        }
    }
}
</code></pre>
",2
59223583,59222872,0,"<p>I'm not certain how you are configuring your socket for non-blocking. But the steps are different between Windows and Unix. If you can tell me the OS, I can give more details on non-blocking socket configuration.</p>

<p>Below is a more platform neutral way to poll a socket in a non-blocking way without having explicitly configured the socket for non-blocking.  Either use the <code>MSG_DONTWAIT</code> flag (if available) or the <code>MSG_PEEK</code> flag as hint to see if the call can be made.</p>

<p>Also, let's just use <code>recv</code> instead of <code>read</code> since this is a socket.</p>

<pre><code> #ifdef MSG_DONTWAIT
    int reader = recv(socket_fd, server_response, sizeof(server_response), MSG_DONTWAIT);
#else
    int reader = recv(socket_fd, server_response, sizeof(server_response), MSG_PEEK);
    if (reader &gt; 0)
    {
        reader = recv(socket_fd, server_response, sizeof(server_response), 0);
    }
#endif
</code></pre>
",0
58193251,58193228,2,"<p>Those warnings are not just warnings - they are the reasons your program doesn't work. Change <code>""a""</code> to <code>'a'</code> in both places in your program to use character literals instead of strings and you'll be set.</p>
",0
58189330,58189268,1,"<p><code>name[i][0]</code> is the first <em>character</em> of the array <code>name[i]</code>. You need a <em>pointer</em> to that first character, which you can get with the address-operator <code>&amp;</code> as in <code>&amp;name[i][0]</code>.</p>

<p>Or since array naturally decays to pointers to their first element, just <code>name[i]</code>.</p>
",0
59087708,59087447,0,"<p>The <code>orders()</code> function is appending records to the <code>delivery.txt</code> file, then the <code>receipt()</code> function reads the <em>first</em> record and checks that the record id matches the passed id. If it matches it continues, but otherwise it exits with <code>""no delivery pending""</code>.</p>

<p>If you want the <code>receipt()</code> function to look at further records, then you need something like:</p>

<pre class=""lang-c prettyprint-override""><code>void receipt(int id) {
    float total, mon, change; //mon -&gt; money given by user
    int c = 0;
    fptr = fopen(""delivery.txt"", ""r+"");
    if (fptr == NULL) {
        printf(""error opening file\n\n"");
        exit(0);
    }

    int found = 0;
    while (fread(&amp;g, sizeof(struct grocery), 1, fptr) == 1) {
        if (g.number == id) {
            found = 1;
            break;
        }
    }

    if (found) {
        printf(""\tdelivery total: \n"");
        printf(""\t%s\t%20.2f\n"", g.prod1, g.price1);
        printf(""\t%s\t%20.2f\n"", g.prod2, g.price2);
        printf(""\t%s\t%20.2f\n"", g.prod3, g.price3);
        printf(""\t%s\t%20.2f\n"", g.prod4, g.price4);
        total = g.price1 + g.price2 + g.price3;
        g.ttl = total;
        printf(""\t-----------------------------\n"");
        printf(""\ttotal                   $%.2f\n"", total);
        do {
            printf(""\tcash :               $"");
            scanf(""%f"", &amp;mon);
            if (mon &lt; total) {
                c = 0;
                printf(""\n\t insufficient amount...try again\n\n"");
            }
            else {
                g.status = 'r'; //changes status to ""received""
                c = 1;
                change = mon - total;
                printf(""\tchange:       $%.2f\n"", change);
            }

        } while (c == 0); 
    } else {
        printf(""no delivery pending. \n\n"");
        exit(0);
    }
}
</code></pre>

<p>(please note that the code seems to have also other problems besides this).</p>
",3
55941365,55941209,4,"<p>You can do this using <a href=""https://stackoverflow.com/questions/7553750/what-is-an-opaque-pointer-in-c"">opaque pointers</a>. The idea is:</p>

<ul>
<li>You define a struct somewhere and you define all of its operations in terms of a pointer to that struct. That would probably be a standalone compilation unit.</li>
<li>The consumers of your struct only get a declaration but not the full definition of that struct, which means that they don't know the layout or even the size of the struct. It follows that they are able to receive, store, and pass around any <em>pointers</em> to that struct, but not <em>values</em> of it.</li>
</ul>
",0
59202351,59202118,0,"<p>Pro tip for linked lists like this, they are a lot easier to modify with double pointers. Example code:</p>

<pre><code>void append(struct node **list, int a) {
  // skip to the end of the list:
  while (*list != NULL) {
    list = &amp;(*list)-&gt;next;
  }
  *list = malloc(sizeof(struct node));
  (*list)-&gt;data = a;
  (*list)-&gt;next = NULL;
}

void display(struct node *list) {
  while (list) {
    printf(""%d\n"", list-&gt;data);
    list = list-&gt;next;
  }
}

void remove(struct node **list, int index) {
  while (*list) {
    if (--index == 0) {
      struct node *temp = *list;
      *list = temp-&gt;next;
      free(temp);
      break;
    }
  }
}  

int main() {
  struct list *mylist;
  append(&amp;mylist, 3);
  append(&amp;mylist, 4);
  append(&amp;mylist, 5);
  display(mylist); // prints 3 4 5
  remove(&amp;mylist, 1);
  display(mylist); // prints 3 5
  remove(&amp;mylist, 0);
  remove(&amp;mylist, 0);
  // mylist is NULL again, all memory free'd
}
</code></pre>

<p>Note that this code needs no special cases for ""is the list empty?"", which makes it less complex than yours.</p>
",0
59202203,59202118,4,"<p>The problem is in this code:</p>

<pre><code>struct node *temp1=head;
while(temp1!=NULL)
{
    temp1=temp1-&gt;next;
}
temp1-&gt;next=temp;
</code></pre>

<p>... the while loop won't end until <code>temp1</code> is NULL, so after the loop ends, it is guaranteed that <code>temp1</code> is a NULL pointer ... and then you dereference that NULL pointer (via <code>temp1-&gt;next</code>), which causes a crash.  Probably what you want to do instead is <code>while(temp1-&gt;next != NULL) {...}</code></p>
",0
56695979,56695826,2,"<p>The usual idiom is to use an <code>extern</code> declaration in a header file and include that wherever the global is needed.</p>

<pre><code>// foo.h
// Make the global visible in any C file that includes this header.
extern int my_global_var;
</code></pre>

<pre><code>// foo.c
#include ""foo.h"" // Not really needed here, but fine.
int my_global_var;
...
</code></pre>

<pre><code>// bar.c
#include &lt;stdio.h&gt;
#include ""foo.h"" // This one makes the global visible in the rest of the file.

void do_something(void) {
  printf(""my global var's value is: %d\n"", my_global_var);
}
</code></pre>

<p>Note that using globals like this in a program of any significant size or complexity can lead to messy, bug-prone, and hard-to-change code.  Not a great pattern to follow.</p>
",0
56696276,56695826,0,"<p>I would like to offer an alternative to Gene's answer.  In my experience there are two main ways to share variables <em>across modules</em> (compilation units):</p>

<p>1) ""Getters and Setters"".</p>

<p>2) Externs.</p>

<p>Depending on what kind of team you're working with, they'll have a preference for one or the other.  C functions by default have external linkage; you need to force internal linkage via the <strong>static</strong> keyword in front of the function name if you don't want this.</p>

<p>1) Getters and Setters:</p>

<pre><code>// foo.c
#include &lt;stdio.h&gt;
int my_global_var = 0;
...
</code></pre>

<p>Then you can follow it with externally-linked getters and setters.  i.e.:</p>

<pre><code>int get_my_global_var(void)
{
  return my_global_var;
}

void set_my_global_var(int var)
{
  my_global_var = var;
}
</code></pre>

<p>This is done <strong>within</strong> the c file (module).  It will be the getters and setters will be able to be called from any other module and they will get and set the global variable <code>my_global_var</code>.</p>

<p>2) Externs:</p>

<pre><code>// foo.c
#include &lt;stdio.h&gt;
int my_global_var = 0;
...
</code></pre>

<p>An alternative to getters and setters is to use externs.  In this case you add nothing extra to the module that contains the global variable you wish to access/modify (<code>my_global_var</code>).</p>

<pre><code>// bar.c
#include &lt;stdio.h&gt;
extern int my_global_var;
...
</code></pre>

<p>Notice the syntax here; when we use the <strong>extern</strong> keyword, we don't initialize it as anything.  We are simply infoming the compiler that the global variable <code>my_global_var</code> has external linkage.</p>
",0
58257833,58257609,0,"<p>Your loop should look like:</p>

<pre><code>while((c = getchar()) != EOF){
    if(c == 32 &amp;&amp; lastc == 32)
        ;
    else
        putchar(c);
    lastc = c;
}
</code></pre>

<p>In your version you get a char with getchar while checking the condition for the while loop and then as a next step you again get a char with getchar. So the first one is not used in your code. Therefore it is taking away every second character.</p>
",0
58686106,58686060,2,"<p>You have your upper bounds written with greater than or equal to <code>&gt;=</code> instead of less than or equal to <code>&lt;=</code>:</p>

<pre><code>if(weight &gt; 2 &amp;&amp; weight &gt;= 6){
if(weight &gt; 6 &amp;&amp; weight &gt;= 10){
</code></pre>

<p>This should have been</p>

<pre><code>if(weight &gt; 2 &amp;&amp; weight &lt;= 6){
if(weight &gt; 6 &amp;&amp; weight &lt;= 10){
</code></pre>
",0
56820492,56820378,6,"<p>No.</p>

<p>File descriptors are not part of standard C.  There is no obligation from the C standard for a system to implement the standard I/O library using file descriptors.  Consequently, there's no way to get the file descriptor from a file stream using standard C; the concept of file descriptor is just not a part of the C standard.  That's why <code>fileno()</code> is not a standard C function.</p>

<p>The C11 standard <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21"" rel=""nofollow noreferrer"">¡ì7.21 Input/output <code>&lt;stdio.h&gt;</code></a> does not specify any functions using file descriptors.</p>

<blockquote>
  <p>If <code>fileno()</code> is not a standard function, what's the value that the function <code>open()</code> returns?</p>
</blockquote>

<p>The <code>open()</code> function is not a part of standard C either; none of the functions using file descriptors are part of standard C. The <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/toc.htm"" rel=""nofollow noreferrer"">POSIX standard</a> does provide functions using file descriptors ¡ª lots of them, including <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/open.html"" rel=""nofollow noreferrer""><code>open()</code></a> and <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/fileno.html"" rel=""nofollow noreferrer""><code>fileno()</code></a>. Most systems provide extension functions that are not defined by POSIX but that do use file descriptors.</p>
",2
55983468,55983219,2,"<p>The way I see this usually done is by providing a ""dispatch"" function:</p>

<pre><code>void get(password * pw) {
  pw-&gt;get(pw-&gt;string, 10);
}
</code></pre>

<p>Then, after setting <code>userPassword.get</code> to your function, you call just:</p>

<pre><code>get(userPassword);
</code></pre>

<p>Obviously this adds some boilerplate code when done for multiple functions.  Allows to implement further funny ""class like"" things, though.</p>
",2
55983568,55983219,1,"<p>You can do this in Clang using the ""Blocks"" language extension. As commented, <a href=""https://stackoverflow.com/questions/18147676/why-doesnt-c11-support-lambda-functions/18155495#18155495"">there have been attempts to standardize this</a> (and it's not been received with hostility or anything), but they're moving slowly.</p>

<p>Translated to use Blocks, your example could look like this:</p>

<pre><code>#include &lt;stdlib.h&gt;

#include &lt;Block.h&gt;

typedef void (^GetPw)(int);             // notice how Block pointer types are used
typedef void (*GetPw_Impl)(char*, int); // the same way as function pointer types

typedef struct
{
    GetPw get;
    char string[10];
} password;

extern void hiddenStringInput(char*, int);

extern void setPw(char dst [static 10], char * src);

GetPw bindPw (GetPw_Impl get_impl, char * pw)
{
  return Block_copy (^ (int key) {
    get_impl (pw, key);
  });
}

int main()
{
    password userPassword;

    setPw(userPassword.string, ""secret"");

    userPassword.get = bindPw(hiddenStringInput, userPassword.string); 

    userPassword.get(10);

    return EXIT_SUCCESS;
}
</code></pre>

<p>There are some subtleties to the way arrays are captured that might confuse this case; the example captures the password by normal pointer and assumes <code>userPassword</code> is responsible for ownership of it, separately from the block.</p>

<p>Since a block captures values, it needs to provide and release dynamic storage for the copies of the captured values that will be created when the block itself is copied out of the scope where it was created; this is done with the <code>Block_copy</code> and <code>Block_release</code> functions.</p>

<p>Block types (syntactically function pointers, but using <code>^</code> instead of <code>*</code>) are <em>just</em> pointers - there's no way to access the underlying block entity, just like basic C functions.</p>

<hr>

<p>This is the Clang API - standardization would change this slightly, and will probably reduce the requirement for dynamic memory allocation to copy a block around (but the Clang API reflects how these are currently most commonly used).</p>
",3
55985097,55984802,3,"<blockquote>
  <p>I am getting the error that there are few values declared in Min or Max.</p>
</blockquote>

<p>because you define the Min/Max functions with <strong>3</strong> parameters but in <code>(2.0 * (float)Min(x, y)) / ((float)Max(x, (float)Min(y, z)));</code> you only give <strong>2</strong> arguments.</p>

<p>Just define them with 2 parameters, for instance</p>

<pre><code>int Max (int x, int y)
{
   return (y &gt; x) ? y : x;
}

int Min(int x, int y)
{
   return (y &lt; x) ? y : x;
}
</code></pre>

<p>There is no interest to have more than 2 parameters, else why only 3 rather than 4 or 5 etc ? To have 2 parameters allows to manages all the cases just placing the calls as argument to an other</p>

<p><code>max(a1,a2 ... ,an)</code> is <code>max(a1, max(a2, ... max(an-1, an))...)</code></p>

<p>and of course same for <em>min</em></p>

<hr>

<p>Out of that I encourage you to check <code>scanf(""%d %d %d"", &amp;x, &amp;y, &amp;z);</code> returns 3 to be sure 3 valid values was entered </p>
",0
55992141,55991982,1,"<p>I think you have some off-by-1 errors and comparing to the wrong element (compared to:</p>

<pre><code>i ¡û 1
while i &lt; length(A)
    j ¡û i
    while j &gt; 0 and A[j-1] &gt; A[j]
        swap A[j] and A[j-1]
        j ¡û j - 1
    end while
    i ¡û i + 1
end while
</code></pre>

<p>from: <a href=""https://en.wikipedia.org/wiki/Insertion_sort#Algorithm"" rel=""nofollow noreferrer"">https://en.wikipedia.org/wiki/Insertion_sort#Algorithm</a>)</p>

<p>Try the following:</p>

<pre class=""lang-c prettyprint-override""><code>#include&lt;stdio.h&gt;
void insertion (int arr[],int y)
{
    int h,z,temp,x;
    for(z = 1; z &lt; y; z++)
    {
        for(x=z; x &gt; 0 &amp;&amp; arr[x-1] &gt; arr[x]; x--)
        {
            temp=arr[x];
            arr[x]=arr[x-1];
            arr[x-1]=temp;
        }
    }
    for(h=0;h&lt;y;h++)
    {
        printf(""\n %d"",arr[h]);
    }
}
void main()
{
    int arr[50];
    int x;
    printf(""Enter the numbers of elemnts: "");
    scanf(""%d"",&amp;x);
    printf(""Enter the elements\n"");
    for(int z=0;z&lt;x;z++)
        scanf(""%d"",&amp;arr[z]);
    insertion(arr,x);
}
</code></pre>
",1
58577013,58576938,3,"<p>Your description of <code>planets</code> is accurate; it's defined as an array of pointers. Stress the <em>array</em> part of that, because that means using its id is disqualified for lvalue operations like post-increment.</p>

<p>If you want to walk that array of pointers using pointer notation, it can be done using a proper pointer-to-pointer keyed to the type of the array. If the array is an array of <code>const char*</code>, then a pointer to <code>const char *</code> (i.e. a <code>const char **</code>) is appropriate. </p>

<p>Like this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    const char *planets[] = {
        ""Mercury"", ""Venus"", ""Earth"", ""Mars"", ""Jupiter"",
        ""Saturn"", ""Uranus"", ""Neptune"", ""Pluto""
    };


    int count = 0;
    for(const char **p = planets; p != planets + 9; ++p)
    {
        if(**p == 'M'){
            count++;
        }// if
    }// for

    printf(""%d\n"",count);
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>2
</code></pre>
",7
58577036,58576938,1,"<p>As stated in the other answers, <code>char *planets[]</code> defines a an array of strings.  The compiler will consider <code>planets</code> as a label afixed to the array, and will (generally) not allow that label to be moved.  So, the best options are (as shown in the other answers here) to index through the array, or use an auxiliary pointer to walk the array.  </p>

<p>I like to add an ending <code>NULL</code> to arrays, which provides a stopping point when walking them with an auxiliary pointer.  For example:</p>

<pre><code>  #include &lt;stdio.h&gt;

  int main()
    {
    char *planets[] = {""Mercury"", ""Venus"", ""Earth"",""Mars"",""Jupiter"",
                        "" Saturn"", ""Uranus"", ""Neptune"", ""Pluto"", NULL};
    char **planet;

    int count = 0;
    for(planet = planets; *planet; planet++)
      {
      if(**planet == 'M')
            count++;
      }

    printf(""%d\n"",count);
    }
</code></pre>
",2
58577168,58576938,0,"<p>regarding:   </p>

<pre><code>for(planets; planets &lt;= planets + 8;planets++){  
</code></pre>

<p>this results in the following message from the compiler: </p>

<pre><code>:11:48: error: lvalue required as increment operand
</code></pre>

<p>However, the variable <code>planets</code> is located at the address, fixed in memory, so cannot be changed.  Suggest </p>

<p>for( char *string = planets; string &lt;= planets+8; string++ )</p>

<p>then use the variable <code>string</code> within the body of the <code>for()</code> loop</p>
",3
58576970,58576938,1,"<p>The variable <code>planets</code> is an array so you can't increment it.</p>

<p>Instead use an integer as index in the loop:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{

    char* planets[] = {""Mercury"", ""Venus"", ""Earth"",""Mars"",""Jupiter"",
                        "" Saturn"", ""Uranus"", ""Neptune"", ""Pluto""};


    int count = 0;
    for(int i = 0; i &lt; 9; i++){
        if(planets[i][0] == 'M'){
            count++;
        }// if 

    }// for

    printf(""\n%d"",count);

}
</code></pre>
",0
59013849,59012286,1,"<p>Yes it will, since your program created <code>array</code> pointer using <strong>malloc</strong> function, and  it does not manipulate that pointer, according to C99 standard (ISO/IEC 9899:1999):
7.20.3.2 The free function (p: 313):</p>

<blockquote>
  <p>The <strong>free</strong> function causes the space pointed to by <strong>ptr</strong> to be deallocated, that is, made available for further allocation. If <strong>ptr</strong> is a null pointer, no action occurs. Otherwise, if the argument does not match a pointer earlier returned by the <strong>calloc</strong>, <strong>malloc</strong>, or <strong>realloc</strong> function, or if the space has been deallocated by a call to <strong>free</strong> or <strong>realloc</strong>, the behavior is undefined.</p>
</blockquote>
",0
59201813,59199583,1,"<p>Use a signal handler for your alarm. In that handler, <code>kill()</code> the child process and <code>wait()</code> for it to terminate.</p>

<p>For example:</p>

<pre><code>#define _POSIX_SOURCE
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;

pid_t kill_pid = -1;
int done_flag = 0;

void handle_alarm(pid_t sig)
{
    if (sig == SIGALRM &amp;&amp; kill_pid &gt;= 0)
    {
        kill(kill_pid, SIGTERM);
        int status;
        wait(&amp;status);
        done_flag = 1;
    }
}

int main()
{
    alarm(4);   //alarm in 4 seconds and terminates the program

    pid_t pid = fork();    //forks a child
    if (pid == 0)
    {
        while (1)
        {
            printf(""I am the child \n"");
            sleep(1);
        }
    }
    else
    { //parent process
        kill_pid = pid;
        signal(SIGALRM, handle_alarm);

        while (!done_flag)
        {
            printf(""I am the parent, child pid=%d\n"", pid);
            sleep(1);
        }

        printf(""Child has been terminated, parent is complete.\n"");
    }
}
</code></pre>

<p>You could put a signal handler in the child process and make it terminate more gracefully. I've used <code>SIGTERM</code> here, which you can handle. <code>SIGKILL</code> cannot be handled by your program.</p>
",1
57898120,57897445,1,"<p>The likely sequence of events in your C implementation is:</p>

<ul>
<li>In <code>unsigned char c = -1;</code>, <code>-1</code> is converted to <code>unsigned char</code>, producing 255, and <code>c</code> is initialized to this value.</li>
<li><code>char</code> is signed in the C implementation you are using, so <code>char d = -1;</code> initializes <code>d</code> to ?1.</li>
<li><code>int i = -1;</code> of course initializes <code>i</code> to ?1.</li>
<li>In <code>printf(""c=%u,d=%u,i=%u\n"", c, d, i);</code>, the <code>unsigned char</code> and <code>char</code> values of <code>c</code> and <code>d</code> are automatically promoted to <code>int</code>, and you pass the values 255, ?1, and ?1 to <code>printf</code>.</li>
<li>The bits that represent these <code>int</code> values 255 (24 zeros and eight ones), ?1 (32 ones), and ?1 (32 ones) are passed to <code>printf</code>, but your <code>%u</code> conversion specifiers tell <code>printf</code> to expect <code>unsigned int</code> values. <code>printf</code> responds by interpreting these bits as if they were <code>unsigned int</code>.</li>
<li>In <code>unsigned int</code> in your C implementation, 24 zero bits followed by eight one bits represents 255, so <code>printf</code> prints that for the first conversion.</li>
<li>32 one bits represents 4294967295, so <code>printf</code> prints that for the second and third conversion.</li>
<li>In <code>printf(""c=%d,d=%d,i=%d\n"", c, d, i);</code>, all the arguments after the format string are <code>int</code> after automatic promotion, and <code>%d</code> tells <code>printf</code> to expect <code>int</code>, so everything works as expected, and <code>printf</code> prints 255, ?1, and ?1.</li>
</ul>

<p>Because your argument types in the first <code>printf</code> do not match the conversion specifiers, the C standard does not define the resulting behavior. Although the above is likely what happened in your C implementation, the C standard does not guarantee this will happen in other C implementations or even in other programs doing this in this C implementation.</p>
",0
59471042,59470430,1,"<p>Simply don't backspace past the beginning the <code>password</code> array.  i.e. do not decrement <code>f</code> is <code>f</code> is already zero.  </p>

<p>Equally, you should add a check to prevent incrementing <code>f</code> past the end of the <code>password</code> array less one character of the terminating NUL.</p>

<p>To support input redirection and prevent getting stuck in an endless loop, it is useful to also check for end-of-file.</p>

<pre><code>    char password[25] ;
    int f = 0 ;
    int ch = 0 ;

    printf(""Enter the password : "");
    for(;;)
    {
        ch  = getch();
        if( ch == EOF || ch == '\n' )
        {
            password[f] = '\0' ;
            break ; 
        }
        else if( ch == '\b' )
        {
            if( f &gt; 0 )
            {
                printf(""\b \b"");
                f--;
            }
        }
        else if( f &lt; sizeof(password) - 1 )
        {
            password[f] = ch ;
            printf( ""*"" ) ;
            f++;
        }
    }
</code></pre>
",0
58286091,58285529,2,"<p><code>pow(1,anything)</code> is always 1. <code>pow(3, 3)</code> is 27. These are both quite small numbers and easily fit into a 32 bit integer. <code>pow(13,16)</code> is (approximately) 6.65 x 10<sup>17</sup>. This is too big for a 32 bit integer to contain. It will go into a 64 bit integer (although <code>pow(14, 17)</code> will not). It's likely that your compiler treats a <code>long</code> as a 32 bit value, which is not uncommon. You could try <code>long long</code> which is likely to be 64 bits or <code>int64_t</code> which is explicitly 64 bits long.</p>

<p>Note though that the prototype for <code>pow()</code> is </p>

<pre><code>double pow(double x, double y);
</code></pre>

<p>which means that it is returning a double precision floating point number and then coercing it into the type of your variable. <code>double</code> (a 64 bit floating point number) only has 53 bits of precision in its mantissa, which means you are not going to get the exact number when you cast it back to even a 64 bit integer. You could use <code>powl()</code> whose prototype is </p>

<pre><code>long double powl(long double x, long double y);
</code></pre>

<p>But <code>long double</code> might be defined as 80 bits or 128 bits or even only 64 bits (Microsoft). It might give you the precision you need, but such is the nature of power operations, your input numbers won't have to get much bigger to overflow the precision of even the longest <code>long double</code>. </p>

<p>If you really need to raise large numbers to large powers, you are going to need a big integer library.</p>
",0
58288292,58285529,0,"<p>Rather than use floating point <code>pow()</code>  and friends with their potential limited precision for an integer problem within 64 bits (13<sup>16</sup> needs 60 bits), use an integer power function.</p>

<pre><code>unsigned long long upow(unsigned  x, unsigned y) {
  unsigned long long z = 1;
  unsigned long long xx = x;
  while (y) {
    if (y % 2) {
      z *= xx;
    }
    y /= 2;
    xx *= xx;
  }
  return z;
}

int main() {
  printf(""%llu\n"", upow(3, 3));
  printf(""%llu\n"", upow(13, 16));
}
</code></pre>

<p>Output</p>

<pre><code>27
665416609183179841
</code></pre>

<p>If code needs to handle answers more the 64 bits, consider <code>long double</code> (with potential loss of precision)  or big_integer libraries.</p>
",0
59551338,59551227,1,"<p>There are multiple problems with your code. The size of <code>HiddenMessage</code> reported by @paxdiablo is just one of them. </p>

<ul>
<li><p>You should use <code>fgets</code> instead of <code>scanf</code> because scanf won't consume the newline. You will be stuck on the second iteration.</p></li>
<li><p>You increment <code>Tries</code> and test it against <code>MaxTries</code> before testing if the guess was correct. As a consequence the program will tell that the user lost before testing the validity of the last guess.</p></li>
<li><p><s>Once the user guessed the word and won, you must break from the while loop and terminate the program. With your code, after the program reported that the user won, it will ask for another guess if it wasn't the last guess.</s></p></li>
</ul>
",3
59551253,59551227,2,"<p>You should have received a warning about:</p>

<pre><code>char HiddenMessage[7] = ""Cameron"";
</code></pre>

<p>if your compiler was doing its job properly :-)</p>

<p>Seven characters is <em>not</em> enough to store <code>Cameron</code> <em>and</em> the end-of-string marker. Try it again with:</p>

<pre><code>char HiddenMessage[] = ""Cameron"";
</code></pre>

<p>This will make sure enough characters are set aside for the full string.</p>

<hr>

<p>If you're interested, this is covered in <code>C11 6.7.9 Initialization /14</code> (emphasis added):</p>

<blockquote>
  <p>An array of character type may be initialized by a character string literal or UTF?8 string literal, optionally enclosed in braces. Successive bytes of the string literal (including the terminating null character <strong><em>if there is room</em></strong> or if the array is of unknown size) initialize the elements of the array.</p>
</blockquote>

<p>So what your code will give you is the sequence of characters <code>{ 'C', 'a', 'm', 'e', 'r', 'o', 'n' }</code> but with <em>no</em> <code>\0</code> at the end to make it a C string. That means <code>strcmp</code> cannot be guaranteed to give you the results you want (it will possibly run off the end of the array during the comparison).</p>

<hr>

<p>And, as an aside, <code>scanf</code> with the unbounded <code>%s</code> format specifier is considered rather dangerous in non-trivial code, since there's no way to protect against buffer overflow.</p>

<p>If you're looking for a fairly bullet-proof user input function that can detect and mitigate this, have a look at <a href=""https://stackoverflow.com/questions/4023895/how-do-i-read-a-string-entered-by-the-user-in-c/4023921#4023921"">this earlier answer</a> of mine.</p>

<p>It allows prompting, prevents buffer overflow, properly handles line-based user input (no half lines delivered to user) and so on.</p>

<p>It's what I use for simple console applications (where no better user input method is available).</p>
",7
58054060,58053800,0,"<p>You are using <code>fscanf()</code> on <code>stdin</code> which is equivalent to <code>scanf()</code>.  If your 8000 character input does not end in a newline, <code>fscanf()</code> will not return until there is a newline, and whatever has been input after the 8000 characters will be accepted into <code>case1</code> in the final <code>scanf()</code> call.</p>

<p>That is the <code>scanf()</code> call is not ""skipped"", rather it reads a character already in the buffer.  If that character is not whitespace, the ""fixes"" you tried will be inadequate.</p>

<pre><code>for (i = 0; i &lt; SIZE; i++)
{
    fscanf(stdin, ""%c"", &amp;data[i]);
}

// Flush all remaining input up-to next newline
int c ;
do {} while( data[SIZE-1] != `\n` &amp;&amp; 
             (c = getchar()) != `\n` &amp;&amp; 
             c != EOF ) ;
</code></pre>
",0
58757890,58757834,2,"<p>The problem is how you make this call:</p>

<pre><code>fileview(*C_p);
</code></pre>

<p>The function <code>fileview</code> expects a <code>double *</code> but <code>*C_p</code> is a <code>double</code>.</p>

<p>But you have an even bigger problem. <code>C_p</code> is uninitialised and you're dereferencing it here - this is <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined</a>.
In <code>filevew()</code>, it writes to <code>*C</code> as if it points to valid memory.</p>

<p>You could simply write your <code>main</code> as:</p>

<pre><code>int main(void) {
    double C = 0;

    fileview(&amp;C);

    printf(""%f"", C);
    return 0;
}
</code></pre>

<p>which ensures a valid pointer is passed to <code>fileview()</code>.</p>

<p>Your <code>fileview</code> contains an issue too: <code>fscanf()</code> returns the number of <em>items</em> successfully scanned. So you should be checking it against 1 when you scan for a single <code>double</code> value:</p>

<pre><code>  if( 1! = fscanf(infile,""%lf"",C) ) {
      ...
  }
</code></pre>
",0
58757906,58757834,1,"<p><code>fileview()</code> expects a pointer to a double variable as its argument. <code>C_p</code> is a <code>double *</code>, so <code>*C_p</code> is just a <code>double</code>, not a <code>double *</code>.</p>

<p>You need to set the pointer to point to valid memory, so it needs to hold the address of <code>C</code> <em>before</em> you call <code>fileview()</code>.</p>

<pre><code>void fileview(double *C);

int main(void) {
    double C;
    double *C_p = &amp;C;

    fileview(C_p);

    printf(""%f"", C);
    printf(""%p"", C_p);
    return 0;
}

void fileview(double *C) {
   FILE *infile;
   if(!(infile=fopen(""input.txt"",""r""))) {
       printf(""Error opening file\n"");
       exit(1);
   }
   if(5!=fscanf(infile,""%lf"",C)) {
       printf(""Error reading parameters from file\n"");
       exit(1);
   }
   fclose(infile);
}
</code></pre>
",0
58766286,58766226,2,"<p>You need to dereference properly.  eg</p>

<pre><code>int open_file(FILE **fr) {
    if ((*fr = fopen(""soldcars.txt"", ""r"")) == NULL) {
        perror( ""soldcars.txt"" );
        return 1;
    }
</code></pre>

<p>Note <code>*fr = open</code> instead of <code>fr = open</code>.  And, in that function, always use <code>*fr</code>, as in <code>fgetc(*fr)</code> vice <code>fgetc(fr)</code>.  Similarly in the other functions.  Because <code>fr</code> is not a <code>FILE *</code>, but <code>*fr</code> is.</p>
",0
59469203,59469086,0,"<p>If I understand you right, you want to <em>obtain the numbers</em> which you can do with a help of <code>string.Split</code> and <em>Linq</em>:</p>

<pre><code>  int[] numbers = File
    .ReadLines(@""c:\MyFile.txt"")
    .SelectMany(line =&gt; line.Split(
       new char[] { ' ', '\t', '\r', '\n' }, 
       StringSplitOptions.RemoveEmptyEntries))
    .Select(item =&gt; int.Parse(item))
    .ToArray();
</code></pre>

<p>If tiy want to store the numbers in a file:</p>

<pre><code> File
   .WriteAllLines(@""c:\SomeOtherFile.txt"", numbers);
</code></pre>
",0
56092197,56091987,1,"<p>As said in remark your arrays are not terminated by a null character, this is why <em>printf</em> continues after them.</p>

<p>You get that result because your arrays are placed in memory one after one by the compiler, and finally there is a null character for an other reason</p>

<p>So the minimal changes are </p>

<pre><code>unsigned char mydata1[] = {0x41,0x42,0x43, 0};
unsigned char mydata2[] = {0x44,0x45,0x46, 0};
unsigned char mydata3[] = {0x47,0x48,0x49,0x4A, 0}
</code></pre>

<p>but that way to do supposes your compiler uses ASCII code and this is not readable, better to do</p>

<pre><code>unsigned char mydata1[] = {'A', 'B', 'C', 0};
unsigned char mydata2[] = {'D', 'E', 'F', 0};
unsigned char mydata3[] = {'G','H','I','J', 0};
</code></pre>

<p>or more simple :</p>

<pre><code>unsigned char mydata1[] = ""ABC"";
unsigned char mydata2[] = ""DEF"";
unsigned char mydata3[] = ""GHIJ"";
</code></pre>

<hr>

<p>Out of that</p>

<ul>
<li>doing <code>for(i = 0; i &lt; 3; i++)</code> is <em>dangerous</em> because if you modify the number of elements into <em>charPtr</em> you need to also modify the <em>for</em>, one way is to add a NULL pointer to mark the end of the pointer list and to iterate up to a NULL pointer, an other is to iterate while <code>i &lt; (sizeof(charPtr)/sizeof(charPtr[0]))</code>. </li>
<li>it is better to not use <em>int</em> to type <em>i</em> but <code>size_t</code> because this is the natural type for an index</li>
</ul>
",0
56092219,56091987,0,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

/* String are NULL terminated, you might have read comments in question */
unsigned char mydata1[] = {0x41, 0x42, 0x43, 0x00};
unsigned char mydata2[] = {0x44, 0x45, 0x46, 0x00};
unsigned char mydata3[] = {0x47, 0x48, 0x49, 0x4A, 0x00};

/* Here I have used a NULL terminated array so that we can traverse 
 * even if we do not know the length of array 
 */
unsigned char *charPtr[] = 
{
        mydata1,
        mydata2,
        mydata3,
        NULL
};

int main()
{
        int i;

        for (i = 0; charPtr[i] != NULL; i++) {
                printf(""%s\n"", charPtr[i]);
        }

        return 0;
}
</code></pre>
",0
58077488,58077387,4,"<p>Had you indented your code correctly, the problem would become obvious:</p>

<pre><code>while (1)
{
    printf(""What program would you like to open, %s?\n"", name);
    scanf(""%s"", input);

    if (strcmp(input, ""google"") == 0)
    {
        printf(""Opening Google Chrome for you!\n"");
        ShellExecute(NULL, ""open"", ""chrome.exe"", NULL, NULL, SW_SHOWNORMAL);
        printf(""Done!\n"");
    }

    if (strcmp(input, ""outlook"") == 0)
    {
        printf(""Opening Microsoft Outlook for you!\n"");
        ShellExecute(NULL, ""open"", ""Outlook.exe"", NULL, NULL, SW_SHOWNORMAL);
        printf(""Done\n"");
    }

    if (strcmp(input, ""putty"") == 0)
    {
        printf(""Opening Putty for you!\n"");
        ShellExecute(NULL, ""open"", ""Putty.exe"", NULL, NULL, SW_SHOWNORMAL);
        printf(""Done\n"");
    }
    else
    {
        if (input &lt; 0 || input &gt; 0)
        {
            printf(""no program entered, please enter another program\n"");
        }
    }
}
</code></pre>

<p>The problem becomes very clear - the <code>else</code> applies ONLY to the last <code>if</code> statement.</p>

<p>Instead of the above, implement <code>else if</code> in the code to ensure that the final <code>else</code> applies only if ANY of the other conditions are not met.</p>
",3
59341811,59341140,0,"<blockquote>
  <p>However It seems to not use all of the data in the array to find the average change in sea level.</p>
</blockquote>

<p><code>avg = (float)avg/n;</code> is same as <code>avg = (float)(level[n-1][1] - level[0][1])/n</code>.  </p>

<p>Only the end-points matter.<br>
The loop that accumulates the differences is canceling out the in-between year's values.</p>

<p>In a mid-year, if you add +100, it makes one year difference +100 more, and the next year difference 100 less.  The running sum of the differences is not affect by that +100 in the end. </p>

<p>All the mid-year values could be 0 and one would get the same <em>average</em>.</p>
",0
57178406,57178328,3,"<p>In <code>c</code> the difference between single and double quotes has semantic meaning. Single quote indicates a char value and double quotes indicates string literal. The warning you get is indicative of this. </p>
",0
58928374,58927525,0,"<p>Almost right, here are some changes to make it work 
First open the file in binary mode, this allows you to move in the file with fseek. the rb+ means you can read/write to the file.
Added some error handling if file is not there, always have error handling.
When you write back to the disk, make sure to flush it out to disk since fgetc et al work on a buffer.
fputc is better in this case, since you are anyway just writing one char.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
int main() 
{
  char filename[] = ""some_text.txt"";
  FILE* input_file = fopen(filename, ""rb+""); // open in binary mode
  if ( input_file == NULL ) // some error handling
  {
    perror(filename);
    return -1;
  }

  int c = fgetc(input_file); // return value is int
  int charc = 0;
  int alpha = 0;

  do
  {
    if(isalpha(c))
    {
      alpha = alpha + 1;
    }
    charc = charc + 1;

    // if alpha, then go back one character and rewrite it
    if(isalpha(c)) 
    {
      fseek(input_file, -1, SEEK_CUR);
      fputc(toupper(c),input_file); // use fputc instead of fprintf
      fflush(input_file);
    }
    // read next
    c = fgetc(input_file);
  }
  while (c != EOF);

  // at end of file, add some more
  fprintf(input_file,""\nTotal Characters: %d, Total alphabetical characters: %d"",charc,alpha);

  fclose(input_file);
  return 0;
}
</code></pre>
",1
57150504,57150417,2,"<p>This code:</p>

<pre><code> while(*a)
 {
  a++;
 }
</code></pre>

<p>finds the <em>null-termination character</em> in string <code>a</code>.  It works, because <code>*a</code> retrieves the character at the current pointer position.  When <code>*a</code> becomes zero, the <code>while</code> condition becomes false, and <code>a</code> will contain the address of the null-termination character.</p>

<p>The first time through this loop:</p>

<pre><code> while(*b) 
 {
  *a = *b;
  b++;
  a++;
 }
</code></pre>

<p>the null termination character in string <code>a</code> will be overwritten by the first character in string <code>b</code>.  After that, the loop marches through all of the characters in <code>a</code> and copies them to <code>b</code>.  It doesn't appear to copy the null termination character, though; you'd have to add code that does this.</p>
",1
57150451,57150417,1,"<p><code>a</code> needs to keep being incremented because <code>a</code> is a pointer to the character you're about to write to. If you don't increment <code>a</code> after writing to the location it points to, you end up copying <em>every</em> character in <code>bb</code> into the <em>same</em> location in <code>aa</code> (namely, the location that previously held the <code>NUL</code> terminator).</p>

<p>Note that your code has a flaw if you attempt to adapt it to the general case of writing to any legal C-style string known to have additional space for the additional data being concatenated. While <code>char aa[10] = ""John"";</code> is guaranteed to initialize indices 4-9 to the <code>NUL</code> character, strings written to uninitialized arrays won't be padded with <code>NUL</code>s for you. By not explicitly copying the <code>NUL</code> from <code>bb</code>, code that initializes <code>aa</code> with a form like this:</p>

<pre><code>char aa[10];  // or char *aa = malloc(10);
strcpy(aa, ""John"");
</code></pre>

<p>will end up producing a string without a reliable <code>NUL</code> terminator; when your loop is done, <code>aa[8]</code> would be the final <code>r</code> from <code>""Meyer""</code>, but <code>aa[9]</code> would have unknown contents; any C-style string oriented API that tried to read from it would potentially run off into unrelated memory following the array, triggering undefined behavior. To fix, you can make the entire operation conditional on <code>b</code> being non-empty in the first place, then use a <code>do</code>/<code>while</code>:</p>

<pre><code>if (*b)
{
  while(*a)
  {
    a++;
  }
  do
  {
    *a = *b;
    a++;
  } while(*b++); // Post increment required to test what we copied, then increment, so we stop after copying NUL
}
</code></pre>

<p>or explicitly <code>NUL</code> terminate after the loop:</p>

<pre><code>while(*b) 
{
  *a = *b;
  b++;
  a++;
}
*b = '\0';
</code></pre>
",2
59499687,59499621,1,"<p>In C, macros are filled into your code upon compilation. Let's consider what happens in your case:</p>

<p>Your macro is:</p>

<pre class=""lang-c prettyprint-override""><code>#define sqr(x) x*x
</code></pre>

<p>When it gets filled into this:</p>

<pre class=""lang-c prettyprint-override""><code>int x = 16/sqr(4);
</code></pre>

<p>You would get:</p>

<pre class=""lang-c prettyprint-override""><code>int x = 16/4*4;
</code></pre>

<p>Operator precedence being equal for <code>/</code> and <code>*</code>, this gets evaluated as <code>(16/4)*4 = 16</code>, that is, from left to right.</p>

<p>However, if your macro were this:</p>

<pre class=""lang-c prettyprint-override""><code>#define sqr(x) (x*x)
</code></pre>

<p>then you would get:</p>

<pre class=""lang-c prettyprint-override""><code>int x = 16/(4*4);
</code></pre>

<p>... and that reduces to <code>1</code>.</p>

<p>However, when the argument for your macro is more complex than a simple number, e.g. <code>2+3</code>, it would still go wrong. A better macro is:</p>

<pre class=""lang-c prettyprint-override""><code>#define sqr(x) ((x)*(x))
</code></pre>
",3
58208760,58208718,3,"<p>In</p>

<pre><code>scanf(""%s"", &amp;check1);
</code></pre>

<p>you can not use the string format specifier (<code>""%s""</code>) to scan a <code>char</code>, switch to</p>

<pre><code>scanf(""%c"", &amp;check1);
</code></pre>

<p>or better yet</p>

<pre><code>scanf("" %c"", &amp;check1); // The leading whitespace will consume the previous newline
</code></pre>
",0
59509850,59499628,0,"<p>You function <code>test</code> should return 1 if the string contains only lowercase letters, and 0 otherwise. Unfortunately, it is not doing that. </p>

<p>You should first test if the character is a letter and then if it's a lowercase letter. Or more efficiently, you test if the character is in the range 'a' to 'z'.</p>

<p>Another problem of your code is the use of <code>do</code> <code>while</code> loops which makes the code difficult to understand and executes the loop once. </p>

<p>Here is a better implementation of the <code>test</code> function:</p>

<pre class=""lang-c prettyprint-override""><code>int test(char *T){
    // reject empty strings
    if(T[0] == '\0')
        return 0;
    // reject strings containing non lowercase letter
    for(int i = 0; T[i] != '\0'; i++)
        if((T[i] &lt; 'a') || (T[i] &gt; 'z'))
            return 0;
    // string is not empty and contains only lowercase letters
    return 1;
</code></pre>

<hr>

<p>Counting the different letters can be made more readable by using a <code>for</code> loop instead of a <code>go</code> <code>while</code> loop. </p>

<pre class=""lang-c prettyprint-override""><code>int nd = 0;
for(int i = 0; T[i] != '\0'; i++) {
    for(int j = 0; j &lt; i; j++) {
        if(T[j] == T[i])
            break; // quit inner loop
        nd++;
    }
}
</code></pre>

<p>This code examine each letter and see if it has been seen before. It is thus different from yours.</p>

<p>A problem in your code is the test <code>(T[i]!=T[j])||((T[j])!='\0')</code>. It should be &amp;&amp; instead of ||, and testing if the end of string is reached should be performed first. The test should be <code>(T[j]!='\0')&amp;&amp;(T[i]!=T[j])</code>.</p>
",0
58300451,58299651,0,"<p>Besides other things, here</p>

<pre><code>printf(""c=%6.2f\ns1=%6.2f"",&amp;c,&amp;s1);
//                         ^  ^ 
</code></pre>

<p>The code is trying to print the <strong>addresses</strong> of the two <code>float</code> variables (the result beeing undefined behavior, due to the wrong format specifier), not the variables themselves.</p>

<p>Just remove remove the <code>&amp;</code>.</p>

<pre><code>printf(""c=%6.2f\ns1=%6.2f"", c, s1);
</code></pre>

<p>It would also be better to check the return value of <code>scanf</code>, to be sure that the extraction of those values actually succeeded.</p>
",3
56895051,56894985,4,"<ol>
<li><p>If you compiled this program with a C compiler, the compiler is required to warn you that the types are wrong in <code>a = &amp;b;</code>, because it violates the constraints for assignment. Did you get that warning? Did you ignore it?</p></li>
<li><p>After the compiler warned you, it presumably generated code for <code>a = &amp;b;</code> to convert <code>&amp;b</code>, which has type <code>int *</code>, to the type <code>int</code>. In some C implementations, an <code>int</code> can hold all the information of an <code>int *</code>, and the conversion works in a simple way. In some C implementations, an <code>int</code> is too small to hold all the information of an <code>int *</code>.</p></li>
<li><p><code>printf(""%u  %u"",a,&amp;b);</code> uses the wrong specifiers. <code>%u</code> is for an <code>unsigned int</code>, but <code>a</code> is an <code>int</code>, and <code>b</code> is an <code>int *</code>. The C standard does not define the resulting behavior when the wrong specifiers are used.</p></li>
<li><p>In spite of the lack of definition, quite likely, your C implementation printed the value of <code>a</code> as if it had been converted to an <code>unsigned int</code>, and it may have done the same with <code>&amp;b</code>. This would result in the output of two identical numbers. This result is not reliable, due to the violation of the rules about specifiers mentioned above.</p></li>
<li><p>If your implementation does define the conversion of a pointer to an <code>int</code> in the common way and an <code>int</code> is wide enough to hold all the information of an <code>int *</code>, then a proper way to write your program is:</p></li>
</ol>



<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int a, b;
    a = (int) &amp;b;
    printf(""%#x %p\n"", (unsigned) a, (void *) &amp;b);
}
</code></pre>

<p>This is not guaranteed to show the same output strings for the two values, particularly because <code>%p</code> is flexible¡ªthe precise format is implementation-defined, so it may vary among C implementations. But they will be the same or similar in many C implementations.</p>

<p>Generally, pointers should not be converted to integers. However, there are times when this is necessary, as when writing kernel code that must deal with addresses in special ways or when writing high-performance code that must deal with alignment issues. In this situation, a better solution than using <code>int</code> is to include <code>&lt;stdint.h&gt;</code> and use <code>uintptr_t</code>. <code>uintptr_t</code> is an unsigned integer type that is suitable for converting to from pointers.</p>
",5
56895718,56894985,1,"<blockquote>
  <p>Can a normal variable hold address of another variable?</p>
</blockquote>

<p>Yes (maybe).</p>

<p>A compiler typically converts source code into machine code for the target CPU. For the CPU's machine code (for almost all CPUs) there are no types - everything (all instructions, all pointers, all integers, all floating point numbers, ...) are just patterns of bits; and the CPU has no idea if a pattern of bits (in memory or in a register) is an address or an integer or something else.</p>

<p>What this means is that if you can convince the compiler to store a pointer into an integer the CPU itself won't know or care.</p>

<p>For C; it's fairly easy to convince the compiler to store a pointer in an <code>int</code>, either by doing <code>a = &amp;b;</code> and ignoring any warning; or by doing <code>a = (int)&amp;b;</code> to suppress the warning. Of course this will not be portable, and the value may be mangled to fit (e.g. if a pointer is 64 bits and an <code>int</code> is 32-bits, then you can expect that half of the pointer will be discarded to make the value fit into the <code>int</code>).</p>
",0
57243874,57243776,1,"<p>TL;DR</p>

<p>Your code (<em>both</em> cases) is invoking undefined behavior by sending an <code>int</code> to a function expecting a <code>double</code>.</p>

<hr>

<p>Your code invokes <em>undefined behavior</em>.  This:</p>

<pre><code>2+2*3/2
</code></pre>

<p>is an <code>int</code> expression. While it is acceptable to assign this to a <code>float</code> as you did to <code>d</code> in the first example, and allow automatic conversion to take place (buyer beware; know what you're doing), it is <em>not</em> acceptable to send an <code>int</code> to a variadic (or otherwise) function requiring something different.</p>

<p>This:</p>

<pre><code>printf(""%f\n"",d);
</code></pre>

<p>is implicitly promoting <code>d</code> to a <code>double</code> value per the rules of variadic functions in the C langauge. Within <code>printf</code>, the <code>%f</code> format specifier is used to determine there should be a <code>double</code> in the variadic argument list, and sure enough there is. Note: the promotion to <code>double</code> has <em>nothing</em> to with <code>%f</code>. The latter expects a <code>double</code>, but the variadic nature of <code>printf</code> is what instigates the <code>float</code> to <code>double</code> promotion. </p>

<p>This, on the other hand:</p>

<pre><code>printf(""%f"",2+2*3/2);
</code></pre>

<p>is sending an <code>int</code> to <code>printf</code>, which in turn is <em>still</em> expecting a <code>double</code>, but no longer receiving one. Basically, you're lying to <code>printf</code>, and the result is a spin of the whacky wheel of mayhem.</p>
",5
58032479,58032445,2,"<ol>
<li><code>^</code> is XOR in C, not exponentiation.</li>
<li>If you do math on <code>int</code>s you're going to get <code>int</code> results. You'll need to cast some of those <code>a[i]</code> to <code>float</code> or <code>double</code> to get floating point arithmetic.</li>
</ol>
",0
56745419,56351738,0,"<p>You need to make a couple of changes to have the triangle aligned to the left as in the expected output. </p>

<p>First, you are adding 3 extra spaces in the first loop with the <code>printf(""   "")</code>, that is fixed using <code>&lt;</code> instead of <code>&lt;=</code> in the loop condition.</p>

<p>Second, there are 4 extra chars added due to the <code>""%5d ""</code> in the second <code>printf</code> call, you need to avoid that for the first iteration (when <code>r == 0</code>) using just <code>""%d ""</code>.</p>

<p>Here's how the <code>triangle()</code> function will look like after the changes:</p>

<pre><code>void triangle(int numOfRows) {
    for(int n = 0; n &lt; numOfRows; n++) {
        for(int i = 1; i &lt; numOfRows-n; i++) {
            printf(""   "");
        }
        for(int r = 0; r &lt;= n; r++) {
           printf(r == 0 ? ""%d "" : ""%5d "", choose(n, r));
        }
        printf(""\n"");
    }
}
</code></pre>

<p>And some example output (works up to 13 without a problem, at least on my 64-bit Linux with both gcc and clang):</p>

<pre><code>Enter the number of rows: 3
      1 
   1     1 
1     2     1 
Enter the number of rows: 4
         1 
      1     1 
   1     2     1 
1     3     3     1 

Enter the number of rows: 5
            1 
         1     1 
      1     2     1 
   1     3     3     1 
1     4     6     4     1 
Enter the number of rows: 13
                                    1 
                                 1     1 
                              1     2     1 
                           1     3     3     1 
                        1     4     6     4     1 
                     1     5    10    10     5     1 
                  1     6    15    20    15     6     1 
               1     7    21    35    35    21     7     1 
            1     8    28    56    70    56    28     8     1 
         1     9    36    84   126   126    84    36     9     1 
      1    10    45   120   210   252   210   120    45    10     1 
   1    11    55   165   330   462   462   330   165    55    11     1 
1    12    66   220   495   792   924   792   495   220    66    12     1 

</code></pre>
",0
57290002,57289130,1,"<p>1) Most commonly, C implementations store regular local objects of functions on a stack. (The C standard permits any implementation that achieves the required effects.<sup>1</sup>)</p>

<p>2) Most commonly, C implementations use a general data segment for global objects. Such data segments are created by the program loader from information in the executable file. There are various formats for executable files, but they commonly contain segments with read-only data, segments with data that will be writeable in the program but that has initial values, and segments for data that will be writeable but that is initialized to zero or perhaps uninitialized. The software that loads the program into memory in preparation for execution reads the executable file, requests memory from the operating system, and lays out all the segments. (Again, the C standard permits any implementation that achieves the required effects.)</p>

<p>3) A local pointer can refer to a global object because they share a single address space within the process. The local and global objects are merely put in different places within the address space, not in different spaces.</p>

<p>4) The scope of the name of a global object is the translation unit in which its declaration appears, starting at the place where it is declared and extending to the end of the translation unit. (A translation unit is a source file along with any other files it includes with the <code>#include</code> directive.)</p>

<h2>Footnote</h2>

<p><sup>1</sup> Some people make a hullabaloo of the C standard not requiring a stack. However, the C standard does specify stack semantics for function calls: The behavior of objects local to functions is last-in-first-out, which is the behavior of a stack. Because a hardware stack provides the required features of a stack data structure and hence matches the needs of the C standard, it is the natural way to implement function calls and their objects. Aside from the fact that optimization may actually eliminate local objects or put them in registers instead of memory, essentially the only time you would see a C implementation without a stack is in a very constrained special-purpose environment.</p>
",1
56409747,56409586,0,"<p>Question: What does <code>struct A</code> look like? Answer: Your compiler has no idea because you never defined it. </p>

<p>You're assuming forward-declaring a structure type, then formally declaring a typedef alias to a structure where the alias <em>name</em> (but not tag) is the same as the structure <em>tag</em> (with no name) will resolve. It won't. You have to do that yourself.</p>

<p>Start with simple. Get rid of the type aliases entirely. And get rid of any unnecessary forward decls as well (B and C) What would it look like?</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct A; // fwd decl

struct C 
{
    int element;
    struct A *pointer3; // uses fwd decl
};

struct B
{
    struct A *pointer1; // uses fwd decl 
    struct C *pointer2; // uses prior def
};

struct A // resolves fwd decl
{
    int element;
    struct B *pointer0; // uses prior def
};

int main() 
{
    struct A a;
    a.pointer0 = malloc(sizeof(struct B));
}
</code></pre>

<p>That works (in the most optimistic definition of the term). If you want to use typedef aliases, you can add them in now. For example, here is all three structures both tagged and aliased.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct A;
typedef struct A A;

typedef struct C 
{
    int element;
    A *pointer3;
} C;

typedef struct B
{
    A *pointer1;
    C *pointer2;
} B;

struct A 
{
    int element;
    B *pointer0;
};

int main() 
{
    A a;
    a.pointer0 = malloc(sizeof(B));
}
</code></pre>
",1
58112804,58110709,0,"<blockquote>
  <p>Can any one explain to my why, in this case, I cannot use x[2][2] as a parameter to receive arr.</p>
</blockquote>

<p>Because you are using wildly different types. <code>int *arr[2];</code> is an array of 2 <code>int*</code>, each of them assigned to an allocated chunk of memory. That's a lookup table or ""jagged array"" if you will, not a proper 2D array. See <a href=""https://stackoverflow.com/questions/42094465/correctly-allocating-multi-dimensional-arrays"">Correctly allocating multi-dimensional arrays</a> for details.</p>

<p>Correct code for allocating a 2D array is this:</p>

<pre><code>#include &lt;stdlib.h&gt;

void setArr(int a, int b, int x[a][b])
{
    for (int i = 0; i &lt; a; i++)
        for (int j = 0; j &lt; b; j++)
            x[i][j] = 0;
}

int main(void)
{
    int (*arr)[2] = malloc(sizeof(int[2][2])); 
    setArr(2, 2, arr);
    free(arr);
}
</code></pre>

<p>Here <code>arr</code> in main is a pointer to the first element of an <code>int[2][2]</code>. The first element of that 2D array is <code>int[2]</code>, and a pointer to such an element is <code>int(*)[2]</code>.</p>
",0
57806177,57805759,4,"<p>Set up a look-up table with forbidden digits, then check each digit of the number against it, no matter the number's size. Essentially what your code is already doing.</p>

<pre><code>#include &lt;stdbool.h&gt;

bool has_forbidden_digit (unsigned int n)
{
  const bool FORBIDDEN [10] =
  {
    [3] = true,
    [6] = true,
    [9] = true,
  };

  do
  {
    if( FORBIDDEN[(n % 10)] )
    {
      return true;
    }
    n/=10;
  } while(n != 0);

  return false;
}
</code></pre>

<p>For example:</p>

<pre><code>for(int i=0; i&lt;100; i++)
{
  if(!has_forbidden_digit(i))
  {
    printf(""%d\n"", i);
  }
}
</code></pre>
",4
59584878,59584828,1,"<p>This line is wrong:</p>

<pre><code>scanf(""%f"", user);
</code></pre>

<p>You are not storing the input into <code>user</code>. You can fix it like this:</p>

<pre><code>scanf(""%f"", &amp;user);
</code></pre>
",0
59584890,59584828,1,"<p>Here's your error:</p>

<pre><code>scanf(""%f"", user);
</code></pre>

<p>The <code>%f</code> format specifier to <code>scanf</code> expects the <em>address</em> of a <code>float</code>, i.e. a <code>float *</code>.  All function parameters in C are pass by value, meaning that changing a parameter isn't reflected in the calling function.  By passing a pointer, the function can dereference the pointer to write to the location it points to.  </p>

<p>So change the function call to pass in the address of <code>user</code>:</p>

<pre><code>scanf(""%f"", &amp;user);
</code></pre>
",1
59399293,59399006,2,"<blockquote>
  <p>As I said, quite bold to ask someone to comb this and explain it to me but I am stumped. If not, I'd be happy just understanding why my simplified approach conks out at ack(4, 1) (which is quite demanding but I have a fairly modern ThinkPad).</p>
</blockquote>

<p>I¡¯ll use Python to illustrate, because it has a built-in dict type.</p>

<pre><code>import sys
sys.setrecursionlimit(16392)

cache = {}


def ackermann(m, n):
    if m == 0:
        return (n + 1, 1)

    if (m, n) in cache:
        return cache[(m, n)]

    if n == 0:
        r = cache[(m, n)] = ackermann(m - 1, 1)
        return r

    r1, e1 = ackermann(m, n - 1)
    r2, e2 = ackermann(m - 1, r1)
    r = cache[(m, n)] = (r2, e1 + e2)
    return r


print(ackermann(4, 1))
</code></pre>

<p>The code is a bit of a mess ¨C simplifying with <code>functools.lru_cache</code> runs afoul of the C stack on my platform ¨C but the important thing is that it evaluates A(4, 1) <em>and</em> keeps track of how many calls to <code>ackermann</code> it would have produced without the cache.</p>

<blockquote>
  <p>(65533, 1431459240)</p>
</blockquote>

<p>1,431,459,240 is a lot of calls, even for a fairly modern ThinkPad.</p>

<p>As for the C code: it¡¯s doing the same thing, keeping a mapping of (m, n) to A(m, n) to avoid the blowup in number of calls, but because C doesn¡¯t have a built-in hash table, it keeps things simple by using one big block of memory as a two-dimensional array, where each index¡¯s least significant <code>n_storageBits</code> bits represent n and the rest represent m. That¡¯s what the bit shifting does.</p>

<ul>
<li>A(4, 1) is evaluated</li>
<li>(4, 1) is converted to an index in such a way that every supported (M, N) pair produces a distinct result, in this case with 2<sup>b</sup> M + N with b chosen such that N &lt; 2<sup>b</sup> for any supported N</li>
<li>The index is used to look up and store the result in an array with size 2<sup>b</sup> M + N + 1 for the maximum supported M.</li>
</ul>
",4
58715243,58713349,0,"<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int x;
    scanf(""%d"",&amp;x);

    return (x%111)? !printf(""0.%03d...\n"", x) : !printf(""0.%d...\n"", x/111);
}
</code></pre>

<h2>Input:</h2>

<pre><code>57
222
</code></pre>

<h2>Output:</h2>

<pre><code>0.057...
0.2...
</code></pre>
",0
56585689,56585637,12,"<p>With C strings, which are really obnoxious to use and can usually be avoided in C++, you <strong>must</strong> NUL terminate your character buffers:</p>

<pre><code>char *temp = new char[k + 1];
for (int i = 0; i &lt; k; i++)
{
  temp[i] = '_';
}
temp[k] = 0; // Terminated
</code></pre>

<p>Without that you'll read on into random memory and see all sorts of garbage.</p>

<p>This would be a lot easier with <code>std::string</code>:</p>

<pre><code>std::string temp;
for (int i = 0; i &lt; k; ++i) {
  temp += '_';
}
</code></pre>

<p>You don't have to remember to NUL terminate because <code>std::string</code> doesn't need it, the Standard Library uses a different method internally and it's handled for you automatically.</p>

<p><strong>But wait, there's more!</strong></p>

<p>If you act now and use <code>std::string</code> you have access to amazing tools like this:</p>

<pre><code>std::string temp(k, '_');
</code></pre>

<p>Even easier!</p>
",2
56620353,56615934,0,"<p>My solution to the problem was remarkably simple.</p>

<p>The binary contained</p>

<pre><code>const char *serial = ""XY-00000"";
</code></pre>

<p>I then wrote a short program that boiled down to:</p>

<pre><code>char uniqueserial [8];
/* Generate serial - this was an SQL call to the manufacturing DB */
char *array;
/* Read binary into array */
memcpy(memmem(array, ""XY-00000"",8), uniqueserial,8);
/* Write array to temp bin file for flashing */
</code></pre>

<p>Depends on the serial template string being unique in the binary. Use strings command to check. I disable crc protected object files due to taste. I like my embedded binaries being exact memory dumps.</p>
",0
56639299,56639178,3,"<pre><code>IntNode* newNode = (IntNode*)malloc(sizeof(newNode));//will alocate every person node dinamically
</code></pre>

<p>That doesn't allocate enough space. It should be <code>sizeof(*newNode)</code> or <code>sizeof(IntNode)</code>.</p>
",0
58951862,58951732,0,"<pre><code>struct Person *a1 = malloc(sizeof(struct Person));
char is[] = ""nameee"";
strcpy(a1-&gt;name,is);
</code></pre>

<p><code>strcpy</code> copies a string into a memory location (in this case, <code>a1-&gt;name</code>); it needs to be allocated. <code>a1-&gt;name</code>'s value is uninitialized, thus you are writing in an undefined location in memory.</p>

<p>You need to allocate space for it, for example like:</p>

<pre><code>struct Person *a1 = malloc(sizeof(struct Person));
char is[] = ""nameee"";
a1-&gt;name = malloc(strlen(is) + 1);
strcpy(a1-&gt;name,is);
</code></pre>

<p>or, use <code>strdup</code>.</p>
",0
59586200,58191611,0,"<pre><code>#include &lt;stdio.h&gt;

void decompress(const char* code)
{
    while(*code)
    {
        char c = *code++;   // Get the letter to be repeated
        int rep = 0;
        while(isdigit(*code))
        {
            rep = rep*10 + *code++ - '0';  // Get the number of times to repeat the letter
        }
        char set[rep];
        printf(""%.*s"", rep, memset(set, c, rep));  // Print letter [c], repeated [rep] times
    }
}


int main(void)
{
    char* code = ""A4B5C6"";
    decompress(code);   
    return 0;
}
</code></pre>
",0
58969791,58969449,1,"<p>You could write a function that initializes your struct:</p>

<pre><code>void InitializePerson(struct Person *person, const char* name, int number, const char* var)
{
  person-&gt;name = strdup(person);
  person-&gt;var = strdup(var);
  person-&gt;numb = number;
}

int main()
{
  struct Person* per1 = malloc(sizeof(struct Person));
  InitializePerson(per1, ""leo"", 12, ""Twitter"");
}
</code></pre>

<p>This is just one of many possibilities. Also note that there is no error checking whatsoever for brevity.</p>

<p>if <a href=""https://en.cppreference.com/w/c/experimental/dynamic/strdup"" rel=""nofollow noreferrer""><code>strdup</code></a> is not available on your platform, you can write your own, it's basically 3 lines of code.</p>
",0
58784775,58783824,1,"<blockquote>
  <p>Why aren't all of them checked?</p>
</blockquote>

<p>People have given you answers in terms of the definition of the C language, but that doesn't really tell you <em>why</em> an if-else chain behaves the way it does.  The designers of C decided it should be that way: why did they do that?  Also, in literally every other programming language that has <code>else if</code> at all, the designers made the same decision; why is that?</p>

<p>The answer is that it's more <em>useful</em> to have an else-if chain execute at most one of the clauses.  Let's take the infamous ""fizzbuzz"" programming exercise: here's one way to do it in C, using an if-else chain:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    for (int i = 1; i &lt; 101; i++) {
        if (i % 15 == 0)
            puts(""fizzbuzz"");
        else if (i % 5 == 0)
            puts(""buzz"");
        else if (i % 3 == 0)
            puts(""fizz"");
        else
            printf(""%d\n"", i);
   }
   return 0;
}
</code></pre>

<p>This code <em>relies</em> on only one of the four clauses being executed.  Any number that is evenly divisible by 15 is also evenly divisible by 3 and 5; if the second and third clauses were also checked when the first was true, you'd get ""fizzbuzz\nbuzz\nfizz\n"" for all multiples of 15, instead of just ""fizzbuzz\n"" as you wanted.</p>

<p>But if you <em>want</em> a series of conditions to be tested independently, you can do that too: write a series of <code>if</code> statements <em>without</em> using <code>else</code>.  Here's another fizzbuzz implementation that uses that mechanism:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(void)
{
    for (int i = 1; i &lt; 101; i++) {
        if (i % 3 == 0 || i % 5 == 0) {
            if (i % 3 == 0)
                fputs(""fizz"", stdout);
            if (i % 5 == 0)
                fputs(""buzz"", stdout);
            putchar(""\n"");
        } else
            printf(""%d\n"", i);
   }
   return 0;
}
</code></pre>

<p>Now we're relying on <code>i % 3 == 0</code> and <code>i % 5 == 0</code> being tested independently.</p>
",0
58783875,58783824,5,"<blockquote>
  <p>Is it because after each if, the following else virtually considers everything that's beneath it like a single statements and acts like it (like putting everything that follows an else into curly braces?</p>
</blockquote>

<p>Yes.</p>

<hr>

<p>EDIT:</p>

<p>When an <code>if</code>, <code>else</code>, <code>while</code>, <code>for</code> statement is encountered, the thing that is conditionally (or repeatedly in the case of a loop) executed is the <em>block</em> that follows the statement. If you have a single command, then that command is the <em>block</em>. If you want multiple commands to be conditionally executed together, then you need to tie them together inside curly braces, but you don't need the braces for a single atomic command.</p>

<p>Now, an <code>if</code> statement, along with the block that it controls, is considered to be an atomic entity, i.e., a <em>block</em>. This includes its <code>else</code> statement and respective controlled block - it wouldn't make sense to treat them separately. So each time you write <code>else if</code>, you are starting an <code>else</code> block, which is made up of an <code>if</code> statement and all the code that the <code>if</code> clause controls. If you want to see it clearly, then you can wrap curly braces around that whole block, and it will end up looking like the reformatted code in the answers from @chqrlie and @ulricheckhardt.</p>

<p>That's the crude description of how it works, if you want something more accurate I suggest you read the standard.</p>
",8
58783893,58783824,2,"<p>Let me reformat that code for you:</p>

<pre><code>if (a == 5) {
    printf(""Condition is false"");
} else {
    if (a == 6) {
        printf(""Condition is also false"");
    } else {
        if (a == 7) {
            printf(""Condition is also false"");
        } else {
            if (a == 10) {
                printf(""Condition is true"");
            } else {
                if (a == 9) {
                    printf(""Condition is also false"");
                } else {
                    printf(""Condition is still false"");
                }
            }
        }
    }
 }
</code></pre>
",0
56659681,56659654,2,"<p>At first glance, yes, barring subtle bugs, both of these are bubble sorts. There's nothing special about which way the bubbling goes; most implementations bubble ""up"" from left to right, but there is no hard and fast rule that bans bubbling ""down"" from right to left.</p>

<p>As a general rule, if the question is ""Is there more than one way to do it?"", in programming, the answer is ""Yes"".</p>
",0
56659787,56659654,0,"<p>What you have there is not Bubble Sort. Bubble Sort looks like this:</p>

<pre><code>do {
   sorted = true
   sweep through the array, swapping adjacent elements into sorted order
   if we swap any elements, set sorted = false
} while (sorted == false)
</code></pre>

<p>The true Bubble Sort doesn't have an outer limit with a fixed number of iterations, and it doesn't have an inner loop that performs fewer operations with increasing numbers of iterations of the outer loop.  Yes; those design aspects are silly, but that's what Bubble Sort is.</p>

<p>There is a more serious algorithm related to Bubble Sort called Insertion Sort. Insertion sort is this:</p>

<pre><code>dest_array = []   // start with empty destination array
for each element in source_array
   insert element at appropriate spot in dest_array
</code></pre>

<p>Insertion Sort can be implemented within a single array. Originally the entire array consists of source_array[] and dest_array[] is a zero-length area at the end of source_array[]:</p>

<pre><code>[...source_array...][] &lt;- dest array
</code></pre>

<p>. We begin the sort by removing an element <em>e</em> of source_array[] right at the boundary where dest_array[] starts:</p>

<pre><code>[...source_array...][e][]   &lt;- [e] is removed from source_array

[...source_array...][   ]   &lt;- dest_array acquires an empty spot

[...source-array...][e]     &lt;- [e] is inserted into dest_array, in order
</code></pre>

<p>We keep repeating this: <code>source_array</code> keeps shrinking, and the sorted <code>dest_array</code> grows, until it takes up the entire space.</p>

<p>Insertion Sort has a structure resembling your code: a triangular iteration with an outer loop that has a fixed number of iterations corresponding to the  number of elements, and an inner loop which gets longer (since <code>dest_array</code> grows longer). Inserting each element into the correct spot in <code>dest_array</code> can be carried out by a series of swaps of adjacent elements.</p>

<p><strong>What you have implemented is called Selection Sort.</strong> You're repeatedy selecting the highest (or lowest) element of the remaining <code>source_array</code> partition and moving it to the end, thereby building up the <code>dest_array</code> partition in order.  You have two variations of Selection Sort: repeatedly moving the highest element into the upper partition, or repeatedly moving the lowest item into a lower partition. Either way, that upper or lower partition will take over the entire array, leaving it sorted.</p>

<p>Selection Sort, Insertion Sort and Bubble Sort are distinct algorithms. Bubble Sort is a kind of joke on the other two. There is never any reason to implement Bubble Sort instead of Selection or Insertion sort. These two are respectable: they have their uses, like sorting a small number of things in a tiny space. (Say you had to sort some small table of values in a tiny piece of boot loader machine code or whatever.)</p>
",0
58166862,58162765,0,"<p>It's a bug in the MinGW compiler. In <code>_O_U16TEXT</code> mode its <code>fgetws</code> function reads the newline character twice even though you type it once. You may want to skip every other line (check that the line you are skipping is empty, just in case). </p>
",1
58406825,58406785,3,"<p>When you pass arrays to functions, they are passed as <em>pointers</em>. More specifically pointer to the arrays first element.</p>

<p>So for the argument declaration <code>unsigned char space[241][47][48]</code> the compiler really sees it as <code>unsigned char (*space)[47][48]</code>.</p>
",1
56713531,56713491,0,"<p>Use the ternary operator</p>

<p>e.g.</p>

<pre><code>printf(""Total of the %s row Marks is = %.2f\n\n"", (i == 0? ""Assignment Marks"" : ""Examination Marks""), sum);
</code></pre>

<p>Similar for the other <code>printf</code></p>
",1
59169832,59168503,1,"<p>This code logs most frequently used words, but be aware, it has limitations on the number of words it can process (without crashing,) and number of matches. Also note it does not handle tiebreakers. You can replace ""word"" with a substring is that's what you are after.
Note: your original request to find ""a string"" is not useful because ""a string"" could be the entire string, entire string - 1 character, - 2 characters, etc. You need to resolve what you mean by ""a string"".
Hopefully, this code gives you a starting point.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;malloc.h&gt;

int main(void)
{
    char test[] = ""This question is too broad for Stackoverflow. There are many possible answers dependent on your exact requirements, how efficient the solution needs to be, what data structures you have already been taught or can be expected to know, etc. A simple solution would be to have a list that stores unique strings and the count of each string. Then read each string from the file, find it in the list and increment the count, if not found then create a new list entry and set count to 1. It's not a very efficient solution but it's a start and hopefully can lead you to better things."";
    char *word[256];
    char most[32];
    int times=0, ndx=0, ix,jx;
    char* cp, *token;
    char* delim = ""- . ;,"";
    int distribution[256]={0};

    cp = strlwr(test);  // lower case to normalize

    // split text into words
    token = strtok(test, delim); 
    while (token != NULL) { 
        word[ndx] = malloc (strlen(token)+1); 
        strcpy(word[ndx++],token);
        token = strtok(NULL, delim); 
    } 

    // count how many times a word is used
    for(ix=0; ix &lt; ndx-1; ix++)
    {
        for(jx=ix+1; jx &lt; ndx;jx++)
            if (strcmp(word[ix], word[jx]) == 0)
                distribution[ix]++;
    }

    // now find the most frequently used word
    for(ix=0; ix &lt; ndx; ix++)
    {
        if (distribution[ix] &gt; times)
        {
            times++;
            strcpy(most,word[ix]);
        }
    }

    printf(""most frequently used word was \""%s\"", used %d times.\n"", most, times);

    return 0;
}
</code></pre>

<p>Sample output:</p>

<p>most frequently used word was ""a"", used 4 times.</p>
",4
56755982,56755480,3,"<p>Functions that set the error status of a <code>FILE</code> (as reported by <code>ferror</code>) do not clear it even if later called successfully. Likewise if you encounter the end of file while reading, it will not be cleared automatically even if the file later has more data available.</p>

<p>Basically this means that <em>if</em> you are using <code>ferror</code> to check for an error state and you have some way of recovering from it, the <code>ferror</code> will keep indicating an error until you use <code>clearerr</code>.</p>

<p>In your example, if you just use the return value of <code>fread</code> as the condition for terminating the read (i.e., EOF and any type of error are considered final), there is no need to <code>clearerr</code>: just fall through to <code>fclose</code> (and perhaps use <code>ferror</code> to determine whether to print an error message).</p>

<p>On the other hand, if the <code>FILE</code> is in fact a stream on which read can later succeed, and you detect (or assume) that specific condition and retry, you should <code>clearerr</code> before retrying or you will keep seeing the old error condition on future attempts.</p>

<p>Likewise, as pointed out in comments, <code>clearerr</code> also clears the end of file state, so this also applies when using <code>feof</code> to check for the end of file. (Note, however, that you generally <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feoffile-always-wrong"">shouldn't use <code>!feof(file)</code> as the loop condition</a> when reading.)</p>
",1
58388680,58387442,3,"<blockquote>
  <p>Is it better to write like that?</p>
</blockquote>

<p>I'd say no.</p>

<p>For performance; either it doesn't matter (likely for modern compilers), or it shouldn't be a separate function (and should be built into the code used for sorting), or you shouldn't be sorting at all (e.g. data sorted at creation and not sorted after creation).</p>

<p>For readability (code maintenance, chance of seeing errors in the original version, risk of introducing errors later) I'd prefer your original version; especially when working in a team, and especially when other team members are more familiar with 10 other programming languages that each has very different rules to C.</p>

<p>Specifically; I like this (because casts in actual code make things harder to read):</p>

<pre><code>    int a = *(int*)x;
    int b = *(int*)y;
</code></pre>

<p>..and I would rewrite the rest to look like this:</p>

<pre><code>    if (a &gt; b) {
        return 1;
    }
    if (a &lt; b) {
        return -1;
    }
    return 0;
}
</code></pre>

<p>..or to look like this:</p>

<pre><code>    if (a &gt; b) return 1;
    if (a &lt; b) return -1;
    return 0;
}
</code></pre>

<p>..because <code>else</code> is unnecessary after a <code>return</code>; and because ""if without braces followed by statement on its own line"" creates a risk of someone accidentally inserting a new line without realizing it and breaking everything (for an example, see <a href=""https://dwheeler.com/essays/apple-goto-fail.html"" rel=""nofollow noreferrer"">https://dwheeler.com/essays/apple-goto-fail.html</a> ).</p>
",0
57024251,57024221,1,"<p>If you just assign the pointers, then the structure contains a pointer to the caller's string. If the caller's string goes out of scope, or the caller frees it, the pointer will no longer be valid. And if they modify their string, it will also modify the string in the structure.</p>

<p>Making a copy of the string ensures that it is not dependent on the caller's string once it's put into the structure.</p>
",0
58210269,58210181,2,"<p>The way to approach a problem like this is to step back from your code and describe a solution in English. So let's think through some examples:</p>

<ol>
<li><p>If the stairs has 1 step, then there's one way to go up: take 1 step</p></li>
<li><p>If the stairs has 2 steps, then you have two choices:</p>

<ul>
<li>Go up 1 step and then you have 1 step remaining (refer to case 1)</li>
<li>Go up 2 steps and then you are finished</li>
</ul></li>
<li><p>If the stairs has 3 steps, then you have three choices:</p>

<ul>
<li>Go up 1 step, and then you have 2 steps remaining (refer to case 2)</li>
<li>Go up 2 steps, and then you have 1 step remaining (refer to case 1)</li>
<li>Go up 3 steps, and then you are finished.</li>
</ul></li>
<li><p>If the stairs has more than 3 steps, call this number <code>n</code>.</p>

<ul>
<li>Go up 1 step, and then you have <code>n-1</code> steps remaining. (refer to case 1, 2, 3, or 4, depending on the value of <code>n-1</code>.</li>
<li>Go up 2 step, and then you have <code>n-2</code> steps remaining. (refer to case 1, 2, 3, or 4, depending on the value of <code>n-2</code>.</li>
<li>Go up 3 step, and then you have <code>n-2</code> steps remaining. (refer to case 1, 2, 3, or 4, depending on the value of <code>n-3</code>)</li>
</ul></li>
</ol>

<p>This description leads us to see a recursive relationship. The number of ways to traverse <code>n</code> steps is the same as the number of ways to traverse <code>n-1</code> steps plus the number of ways to traverse <code>n-2</code> steps the number of ways to traverse <code>n-3</code> steps.</p>

<p>To translate this all into code, I would write a function <code>go_up(n)</code> that implements the rules described above.</p>
",0
58229323,58229180,0,"<p>You did not print a new line:</p>

<pre><code>if (result == 1)
  printf(""min is: %d max is: %d"",min,max);

printf(""%d\n"",result);
</code></pre>

<p>When <code>result</code> is 1, you first print <code>min is: 2 max is: 6</code>, and then you print <code>1</code>.</p>

<p>Change the first part to:</p>

<pre><code>if (result == 1)
    printf(""min is: %d max is: %d\n"", min, max);
</code></pre>
",0
58252042,58251833,4,"<p><code>fread(buffer,16,1,inputfile);</code> attempts to read one block of 16 bytes. If it fails, <code>fread</code> returns zero, indicating that zero complete blocks were read.</p>

<p>You do not want this; you want to know how many characters were read. So use this code, which attempts to read 16 blocks of one byte each:</p>

<pre><code>bytesread = fread(buffer, 1, 16, inputfile);
</code></pre>

<p>After this code, <code>bytesread</code> contains the number of bytes read. You can use this to put an end-of-string marker after the last byte read:</p>

<pre><code>buffer[bytesread] = '\0';
</code></pre>

<p>Then <code>printf(""Read in line: \""%s\""\n"", buffer);</code> will print the bytes just read and no more.</p>
",0
58257810,58257770,0,"<p>Pressing <code>Enter</code> key is also considered a new character or <code>\n</code>. That's why <code>b</code> goes to <code>c</code> instead.</p>
",0
58257818,58257770,0,"<p>If you stop and look at what your resultant variable <em>num</em> contains:</p>

<p>0A 62 0A 61</p>

<p>and recognize that Character 0x0A is <strong>Line-Feed</strong> Then you'll realize that you are dealing with 4 characters.  You need to remove the Linefeed character from your Scanf buffer before retrieving each new character (otherwise its still there)</p>
",0
58071820,58071797,2,"<pre><code>/* display values */
for (i = 0; i &lt; count; i++ ) {
    printf (""%ld "", sorted[i]);
}
</code></pre>

<p>This outputs a space after each number. If that's not what you want, don't do it. Maybe you want this:</p>

<pre><code>/* display values */
if (count &gt; 0)
    printf (""%ld"", sorted[0]);
for (i = 1; i &lt; count; i++ ) {
    printf ("" %ld"", sorted[i]); // space before every number but first
}
</code></pre>
",0
59184900,59184245,0,"<p><em>...but why is the second output the same?</em>  </p>

<p>Because your original code:</p>

<pre><code>float add(int *x, int y)
{
    static float s = 100.f;
    s=s+y;
    x=x+y; // changing the pointer
    return s;
}
</code></pre>

<p>Does not change the value pointed to by the address of x.<br>
Change the code as shown to allow the value to be updated:</p>

<pre><code>float add(int *x, int y)
{
    static float s = 100.f;
    s=s+y;
    *x=*x+y; //changing the value pointed to by the pointer
             //(i.e., the value exposed via the de-referenced pointer is 
             //modified to a new value.)
    return s;
}
</code></pre>

<p>Given:  </p>

<pre><code> int g=25;
 ...
 add(&amp;g,35.2);
</code></pre>

<p>Results after change:  </p>

<blockquote>
  <p>25<br>
  81feb8<br>
  81feb8<br>
  60  </p>
</blockquote>

<p>Note:  Because the type of the 2nd argument: <code>float add(int *x, int y)</code><br>
       is <code>int</code>, <code>35.2</code> is truncated to <code>30</code>, resulting the in the sum being<br>
       <code>60</code> instead of <code>60.2</code></p>
",0
55156291,55156128,2,"<p>The fact that the conditional operator associates to the right means that <code>x?y:a?b:c</code> will be parsed as if it had been written <code>x?y:(a?b:c)</code>. If it associated to the left, it would have been parsed as <code>(x?y:a)?b:c</code>, which would almost certainly have been a surprise (unless you are used to PHP).</p>

<p>But neither of these parentheses change execution <em>order</em>. The conditional operator's first operand is always evaluated first.</p>
",0
58420128,58418980,1,"<p>The expression <code>&amp;i</code> yields a value of type <code>int *</code> (pointer to <code>int</code>), which is the address of <code>i</code>.  Similarly, <code>&amp;a</code> yields a value of type <code>double *</code> (pointer to <code>double</code>).  </p>

<p>With the exception of the <code>void *</code> type, C does not allow you to assign pointer values of one type to an object of a different pointer type - IOW, you can't assign a <code>int *</code> or a <code>double *</code> value to a <code>char *</code> object directly.  You must use a <em>cast expression</em> to tell the compiler to treat the value as a different type:</p>

<pre><code>ii = (char *) &amp;i;
</code></pre>

<p>means ""treat the result of <code>&amp;i</code> as a pointer to <code>char</code> and assign the result to <code>ii</code>"".  The <code>(char *)</code> expression is a <em>cast</em>, and it tells the compiler to treat the value of the following expression as that type.  </p>

<p>So, why would you want to do this?  </p>

<p>Except for bitfields, any object can be mapped onto an array of <code>char</code> or <code>unsigned char</code> - IOW, the integer value <code>0x01234567</code> can be treated as the array of <code>char</code> values <code>{0x01, 0x23, 0x45, 0x67}</code>.  You can use this property perform some useful tests, or to determine how certain values are being represented.  For example, if you want to know if your system is big- or little-endian, you can take the <code>int</code> value <code>0x00000001</code>, treat it as an array of <code>char</code>, and test the 0'th and last elements:</p>

<pre><code>int val = 0x00000001;        // assumes 32-bit integers!
char *varr = (char *) &amp;val;  // pretends val is an array of char

if ( varr[0] == 0x01 )
  // little endian
else if ( varr[ sizeof val - 1 ] == 0x01 )
  // big endian
else
  // something else
</code></pre>

<p>Note that casting pointer values to different types isn't necessarily <em>safe</em> - you can enable some truly nasty bugs by doing this.  </p>
",0
57167363,57166448,1,"<p>You probably want something like this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
  int nbOfTests;               // use a self explaining name rather than ""T""
  char str[1001];

  scanf(""%d"", &amp;nbOfTests);
  getchar();   // absorb \n

  for (int t = 1; t &lt;= nbOfTests; t++) {
    for (i = 0; ; i++) {
      str[i] = getchar();     // no scanf needed, just use `getchar`directly
      if (str[i] == '\n')
        break;                // Enter = &gt; end the loop
    }

    for (int i = 0; ; i++) {  // declare i here
      if (str[i] == 'f' || str[i] == 'F' || str[i] == '\n')
        break;                // f F or Enter =&gt; end the loop
      else
        printf(""%c"", str[i]);
    }

    printf(""\n"");             // makes it more readable for the user
  }

  return 0;
}
</code></pre>

<p>Disclaimer: this code is still pretty poor, but close to the original code, for example it would be better and simpler to use <code>fgets</code> to read a line of text.</p>
",0
58497959,58497609,0,"<p>Running this:</p>

<pre><code>const char* dlmtrs = ""(),"";
char str[3][128] = {""L(42,13,12)L\n"", ""L(0,0,12)L\n"", ""L(42,0,0)L\n"" }; 


for( int i = 0; i &lt; 3; ++ i )
{
    char* token = strtok(str[i], dlmtrs); 

    while (token != NULL) 
    { 
        printf(""%s\n"", token); 
        token = strtok(NULL, dlmtrs); 
    }
}
</code></pre>

<p>Still gives the correct output for each input string, see <a href=""https://onlinegdb.com/SkxLZIpFH"" rel=""nofollow noreferrer"">here</a></p>

<p><strong>EDIT: I changed the snippet to be called in a loop with different values.</strong></p>
",1
57881660,57881510,1,"<p>The <code>alarm()</code> function causes <code>SIGALRM</code> to be raised, but you have to use the <a href=""https://linux.die.net/man/2/signal"" rel=""nofollow noreferrer""><code>signal()</code></a> function first to register a handler for this signal.  Your program never registers a handler so there's nothing to run when the signal is raised.</p>
",2
57931319,57931230,0,"<p>I tested the code above and these are the types of errors I encountered (VC++ command line)</p>

<blockquote>
  <p>error C2371: 'getString': redefinition; different basic types</p>
</blockquote>

<p>Moved the functions above <code>main()</code> as functions should be declared before being used.</p>

<blockquote>
  <p>error C2065: 'SIZE': undeclared identifier</p>
</blockquote>

<p>I replaced <code>SIZE</code> with <code>1024</code> for testing for this.</p>

<p>Also warnings:</p>

<blockquote>
  <p>warning C4553: '==': result of expression not used; did you intend '='?</p>
</blockquote>

<p>For these</p>

<pre><code>else if (buf[i] == 10){
buf[i] == 32;
i++;
}
</code></pre>

<p>Complete and formatted and changed code I used for testing</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int getUserChoice()
{
    int userchoice = 0;
    char dump = 0;
    printf(""--------------------------------\n"");
    printf(""| 1) Change Shift (Default 3) |\n"");
    printf(""| 2) Encrypt a message |\n"");
    printf(""| 3) Decrypt a message |\n"");
    printf(""| 4) Quit) |\n"");
    printf(""--------------------------------\n"");

    printf(""Option: "");
    scanf("" %d%c"", &amp;userchoice, &amp;dump);

    return userchoice;
}

int getShift()
{
    int newshift = 0;
    char dump = 0;
    printf(""Enter a new shift value:"");
    scanf(""%d,%c"", &amp;newshift, &amp;dump);

    return newshift;
}

void getString(char buf[])
{
    printf("" Input: "");
    fgets(buf, 1024, stdin);
}

void encrypt(char buf[], int shift)
{
    int i = 0;

    while (buf[i] != '\0')
    {
        if (buf[i] == 32)
        {
            buf[i] = buf[i];
            i++;
        }
        else if (buf[i] == 10)
        {
            buf[i] = 32;
            i++;
        }
        else
        {
            buf[i] -= shift;
            i++;
        }
    }
    printf(""Output: %5s\n"", buf);
}

void decrypt(char buf[], int shift)
{
    int i = 0;

    while (buf[i] != '\0')
    {
        if (buf[i] == 32)
        {
            buf[i] = buf[i];
            i++;
        }
        else if (buf[i] == 10)
        {
            buf[i] = 32;
            i++;
        }
        else
        {
            buf[i] += shift;
            i++;
        }
    }
    printf(""Output: %5s\n"", buf);
}

int main()
{
    int shift = 3;
    char stringresponse[1024];

    while (1 || 2 || 3)
    {
        switch (getUserChoice())
        {
            case 1:
                shift = getShift();
                break;
            case 2:
                getString(stringresponse);
                encrypt(stringresponse, shift);
                break;
            case 3:
                getString(stringresponse);
                decrypt(stringresponse, shift);
                break;
            default:
                printf(""Exiting the program"");
                exit(0);
        }
    }
    return 0;
}
</code></pre>
",1
58152046,58151924,3,"<p><code>int (*pt)[4]</code> declares <code>pt</code> as a pointer to an array. </p>

<p>C doesn't allow assigning arrays; e.g. you can't do:</p>

<pre><code>int a[4] = {1, 2, 3, 4};
int b[4];
b = a;
</code></pre>

<p>If you want to copy an array, you need to use a loop, or you can use <code>memcpy</code>:</p>

<pre><code>memcpy(pt, target[0], sizeof target[0]);
</code></pre>
",0
58920825,58920697,4,"<p><code>char **arr = {""abc"", ""def""};</code> defines <code>arr</code> to be a pointer to a pointer to a <code>char</code>. Note that it is <strong>a</strong> pointer¡ªjust one. So it should be initialized with one pointer, and that should be a pointer to a pointer to <code>char</code>.</p>

<p><code>{""abc"", ""def""}</code> is a list of two things, so it is wrong for initializing one thing.</p>

<p><code>""abc""</code> is a string literal. Used in this way, it is automatically converted to a pointer to its first element. That results in a pointer to <code>char</code>, which is the wrong type to initialize a pointer to a pointer to <code>char</code>.</p>

<p>You can provide a single pointer of the correct type by using a compound literal:</p>

<pre><code>char **arr = (char *[]) { ""abc"", ""def"" };
</code></pre>

<p>That form, that looks like a cast (but is not) in front of a list, creates an object of the type given in parentheses and initializes it with the things inside braces. So the code above creates an array of <code>char *</code> and initializes them with the string literals (which are converted to <code>char *</code>). Then that array is automatically converted to a pointer to its first element, and that pointer initializes <code>arr</code>.</p>

<p>Once you have done this, however, <code>sizeof(arr) / sizeof(*arr);</code> will be the size of a <code>char **</code> (because that is what <code>arr</code> is) divided by a <code>char *</code> (because that is what <code>*arr</code> is).</p>

<p>In contrast, <code>char *arr[] = {""abc"", ""def""};</code> defines an array of pointers to <code>char</code> and initializes it with the two pointers that result from the string literals. That simpler definition is usually what one wants.</p>

<blockquote>
  <p>Since arrays decay into pointers, isn't **arr the same?</p>
</blockquote>

<p>The fact that an array <strong>used in an expression</strong> (other than as the operand of <code>sizeof</code> or unary <code>&amp;</code>) is converted to a pointer does not mean the array is a pointer. An array is an array. The address of the array is where the array is (the same, except for type, as the address of its first element)¡ªit is not the address of a pointer.</p>
",0
58544556,58544405,3,"<p>The argument <code>input</code> of the function <code>getData</code> is a <strong>copy of</strong> passed value.</p>

<p>Therefore, change to <code>input</code> in the function <code>getData</code> won't affect
the variable <code>input</code> in the function <code>main</code>.</p>

<p>For that reason, the variable <code>input</code> in the function <code>main</code> remain uninitialized
when it is passed to function <code>fclose</code>.</p>

<p>This will invoke <em>undefined behavior</em> and have a big chance to get Segmentation fault.</p>

<p>To avoid Segmentation fault, you should remove this <code>fclose(input);</code> in the <code>main</code> function.</p>

<p>(Even if change in arguments would affect caller variables, calling <code>fclose</code> for already closed stream seems also bad.)</p>

<p>You are using the argument <code>input</code> not as an argument but as an local variable,
so removing the argument <code>input</code> and declaring it as a local variable will improve your code more.</p>

<p>Another point to improve your code is to use standard <code>int main(void)</code>
instead of implementation-defined <code>void main(void)</code>
unless you have some special reasons to use the implementation-defined one.</p>
",0
58002516,58002180,0,"<p>Assumption: <code>length(B)</code> isn't actually a function but you didn't post what it is. If it is a function, capture it in a local variable outside the <code>for</code> loop and read it once; else you have a Schlemiel the Painter's Algorithm.</p>

<p>I think the best we can do is <A HREF=""https://en.wikipedia.org/wiki/Duff%27s_device"" rel=""nofollow noreferrer"">Duff's Device</A> aka loop unrolling. I also made some trivial optimizations the compiler can normally make, but I recall the compiler's loop unrolling isn't <em>quite</em> as good as Duff's device. My knowledge could be out of date and the compiler's optimizer could have caught up.</p>

<p>Probing may be required to determine the optimal unroll number. 8 is traditional but your code inside the loop body is larger than normal.</p>

<p>This code is destructive to the pointers <code>A</code> and <code>B</code>. Save them if you want them again.</p>

<pre><code>float *A = []; # old array
int *B = []; # index array
float *C;
int ln = length(B);
int n = (ln + 7) % 8;
switch (n % 8) {
case 0: do { *C++ = A[*B++];
case 7:      *C++ = A[*B++];
case 6:      *C++ = A[*B++];
case 5:      *C++ = A[*B++];
case 4:      *C++ = A[*B++];
case 3:      *C++ = A[*B++];
case 2:      *C++ = A[*B++];
case 1:      *C++ = A[*B++];
    } while (--n &gt; 0);
}
</code></pre>

<p>With this much scope I can do no better, but with a larger scope a better choice might exist involving redesigning your data structures.</p>
",0
58083078,58082386,2,"<p>You probably want something like this:</p>

<pre><code>...
int i=0;
int num;
int integers [256];
char linebuffer[100];
while(fgets(linebuffer, sizeof linebuffer, stdin) != NULL)
{
  if (sscanf(linebuffer, ""%d"", &amp;num) == 1)
  {
    integers[i] = num;
    i++;
  }
}
...
</code></pre>

<p>This is untested code, there may be errors, but you should get the idea. Especially if the file has more than 256 lines you may get an array index overflow and hence undefined behaviour.</p>
",3
59457605,59457522,1,"<p>Your last print says to print the character pointed to by <code>str</code> as a decimal, which is exactly what it did (for a memory location you just deallocated, making this <em>undefined behavior</em>).</p>
",3
59331207,59330495,0,"<p>Just read each character and record if you've already seen it: </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int
main(void)
{
        int seen[10] = {0};
        int sum = 0;
        int c;
        while( ( c = getchar()) != EOF ) {
                int v = c - '0';
                if( isspace(c)) {
                        continue;
                }
                if( v &lt; 0 || v &gt; 9 ) {
                        fprintf(stderr, ""Invalid input\n"");
                        return 1;
                }
                if( ! seen[v]++ )
                        sum += v;
        }
        printf(""%d\n"", sum);
        return 0;
}
</code></pre>
",0
58931250,58931143,0,"<p>The question is a bit broad, but anyway maybe this helps:</p>

<pre><code>char our_thread[20];

for (int i = 0; i &lt; 100; i++)
{
  sprintf(out_thread, ""thread%d"", rand() % 100);
  printf(""thread name %s\n"", our_thread);
}
</code></pre>

<p>You should be able to figure out the rest.</p>

<p>Read the documentation of <a href=""http://www.cplusplus.com/reference/cstdlib/rand/"" rel=""nofollow noreferrer""><code>rand</code></a> and <a href=""http://www.cplusplus.com/reference/cstdio/sprintf/"" rel=""nofollow noreferrer""><code>sprintf</code></a>.</p>
",0
58055013,58053571,2,"<p>From what I can tell it looks like your program (both here and on repl.it) are doing exactly what you have programmed.  When I read the description of your data it says ""Lastname, Firstname, <strong>Payrate</strong> and <strong>Hours</strong>""  However, when you read the data in your program you are reading: ""emp[i].lastName, emp[i].firstName, &amp;emp[i].<strong>hours</strong>, &amp;emp[i].<strong>payrate</strong>"".  You have reversed the payrate and hours fields in your read.  It's a simply mistake and easy to make.  My experience is the easiest problems are often to hardest to spot.  I've certainly spend my share of hours puzzled over similar bugs.</p>
",1
59548604,59548243,0,"<p>Your example isn't reproducible and I'm not certain exactly what you're trying to do, but this is the obvious error:</p>

<pre><code>for (int a = 0 ; a &gt; game_size - i ; ++a) 
  {
    if(grid[a][j]!=0)
    {
      num=grid[a][j];
      replace=a;

    }
}
</code></pre>

<p>This loop will never run, <code>a</code> is zero and will never be greater than <code>game_size - 1</code>.</p>
",2
59341614,59341191,3,"<p>You can use a different test, and perhaps a different area formula. If you use Heron's formula, then once you have the lengths of the sides <em>a</em>, <em>b</em>, and <em>c</em>, you can compute:</p>

<pre><code>double p = (a + b + c)/2;
double area = sqrt(p*(p-a)*(p-b)*(p-c));
</code></pre>

<p>You can detect if the triangle is valid by checking that <em>p</em> is greater than each of the sides.</p>

<pre><code>double p = (a + b + c)/2;
if ((p &gt; a) &amp;&amp; (p &gt; b) &amp;&amp; (p &gt; c)) {
    double area = sqrt(p*(p-a)*(p-b)*(p-c));
    printf(""Area of triangle is %lf\n"", area);
} else {
    printf(""I don't consider that a triangle.\n"");
}
</code></pre>

<p><a href=""https://tio.run/##ZVLfb5swEH7nr7hlSmZ3pgPU7SVrJZLXak@b1CnLg3FssEQMw44abeq/PnbGJKDWEue7737ynUVcCtH377UR9ekg4at1B93cVg/RBB25qzwSHZpTUUtom@cMyGicKfyFTrpTZ@B8c17DyzWulqZ01TXyaZftGYzGTzQwMwI8Y7b93Tnia5OnXbKHGGMSjPkII5YGLN1Tuo6wizYOjlwbQqNQR1S8g@KkdtnnL/v1AD1XGpsRVUpnCboYWP1HNsrrFA38WUPh3T18@/H4eJnHn3HMfJh5M8gtyvXrAM6gYCDe4C0D3kk@4dYKblSYYUGWKJeKwhtlwa4Z41nlSAPzV@qvTbA2wdoGa@tZmXpxuB/JJzlOP/MUk2eDfzTziMmzZZDPPC16CMc9FPgJ@imbXFoBIS08AKewWsGgFpMq6JzSYTLkBMuFVd@QNubUy2KQgs66Dp073LEii9xnNQpcp7kpkV1tYVmrX2YRWJ6lvYCsrXzV9VLne8XdB4v0WNdxXVYOam3kLdaZV4gmOb7MBN9b35OExXe4qZQlKO9YmtEoXBcsBPwTqual7eP6@B8"" rel=""nofollow noreferrer"" title=""C (gcc) ¨C Try It Online"">Try it online!</a></p>
",0
57771902,57771837,4,"<blockquote>
<p>The output</p>
<pre><code>1 2 3 4 5 0 0 0 0 0
</code></pre>
</blockquote>
<p>No, the actual output is</p>
<pre class=""lang-none prettyprint-override""><code>1234500000
</code></pre>
<hr />
<p>Your code has undefined behavior. The first iteration of the loop (with <code>i = -1</code>) tries to assign to <code>arr[-1]</code>, which does not exist:</p>
<pre><code>    arr[i] = arr[i + 1];
</code></pre>
<p>Similarly, the last iteration (with <code>i = 9</code>) tries to read from <code>arr[10]</code>, which also does not exist.</p>
<p>I'm not sure why you think your code will move the first element back.</p>
",0
58476344,58476301,2,"<p>The problem is the condition <code>(y - x) == 0 &amp;&amp; x&gt;=1 || x&lt;=5</code>, which is evaluated as <code>((y - x) == 0 &amp;&amp; x&gt;=1) || x&lt;=5</code>.</p>

<p>Since <code>x&lt;=5</code> is true, then the whole condition is true.</p>

<p>The reason for this is that the <a href=""https://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer"">operator precedence</a> of the logical and operator <code>&amp;&amp;</code> is higher than logical or operator <code>||</code>.</p>

<p>You need to explicitly add parentheses around the range-check: <code>(y - x) == 0 &amp;&amp; (x&gt;=1 || x&lt;=5)</code>.</p>

<hr>

<p>Actually, that range-check is flawed as well, as it will allow values larger than <code>5</code> (then <code>x&gt;=1</code> will make it all true) or values less than or equal to zero (because then <code>x&lt;=5</code> will be true). If either of the sides of the logical or operator <code>||</code> is true, then the whole condition is true.</p>

<p>You need to use <code>&amp;&amp;</code> here too: <code>x&gt;=1 &amp;&amp; x&lt;=5</code>.</p>

<p>If you fix this then you don't need the extra parentheses, and <code>(y - x) == 0 &amp;&amp; x&gt;=1 &amp;&amp; x&lt;=5</code> will work fine.</p>
",1
58193568,58193523,0,"<p><code>i</code> is off by one, so you are accessing elements <code>bitC[8]</code> to <code>bitC[1]</code> (even though <code>bitC[8]</code> is out of bounds), and you are printing bits 8 to 1 instead of bits 7 to 0.</p>

<p>Replace</p>

<pre><code>for(int i = 8; i &gt;= 1; i--){
</code></pre>

<p>with </p>

<pre><code>for(int i = 8; i--; ){
</code></pre>
",11
59417856,59417812,0,"<p>Look at your <code>if..else</code>:</p>

<pre><code>if (UserGuess == 'e') {
  printf(""You Guessed One Of The Letters\n"");
  printf(""_ _ _e\n"");
  Completion++;
}
else {
  printf(""You Guessed The Letter Wrong try again\n"");
  Guesses++;
}
</code></pre>

<p>This will print ""You Guessed The Letter Wrong"" if you enter any letter besides 'e'.</p>

<p>You need to add an <code>if..else..if</code> chain for all your conditions:</p>

<pre><code>if (UserGuess == 'f') {
  printf(""You Guessed One Of The Letters\n"");
  printf(""f_ _ _\n"");
  Completion++;
} else if (UserGuess == 'i') {
  printf(""You Guessed One Of The Letters\n"");
  printf(""_i_ _\n"");
  Completion++;
} else if (UserGuess == 'r') {
  printf(""You Guessed One Of The Letters\n"");
  printf(""_ _r_ \n"");
  Completion++;
} else if (UserGuess == 'e') {
  printf(""You Guessed One Of The Letters\n"");
  printf(""_ _ _e\n"");
  Completion++;
} else {
  printf(""You Guessed The Letter Wrong try again\n"");
  Guesses++;
}
</code></pre>
",3
59414559,59414207,1,"<p>It is returning a code for the next alphabetic character read from stdin:</p>

<pre><code>int getcc() {
  int c, haveSpace = 0;
  //Read characters until you get one that is not white space. If any white space read, remember it
  while(isspace(c=getchar())) haveSpace = 1;
  //if a space was read, put the non-space back to stdin, and return 26.
  if(haveSpace) return (ungetc(c,stdin),C_SPACE);
  //if the character is a lower-case letter, return the index into the alphabet: a=0, b=1, etc.
  else if(c&gt;=¡¯a¡¯ &amp;&amp; c&lt;=¡¯z¡¯) return c-¡¯a¡¯;
  //if the character is an upper-case letter, return the index into the alphabet: A=0, B=1, etc.
  else if(c&gt;=¡¯A¡¯ &amp;&amp; c&lt;=¡¯Z¡¯) return c-¡¯A¡¯;
  //If the character is a comma, return 27
  else if(c==¡¯,¡¯) return C_COMMA;
  //If the character is a period, return 28
  else if(c==¡¯.¡¯) return C_STOP;
  //if at end of file, return EOF
  else if(c==EOF) return EOF;
  //if any other character, skip it by calling the function again and returning the result.
  else return getcc();
}
</code></pre>
",0
59502992,59502554,1,"<p><code>error_function()</code> is called when <code>(r = sscanf(temps, "" %s"", to_be_written)) != buffer_size</code> is <code>false</code>.  You pass <code>temps</code>, <code>r</code> and <code>""sscanf""</code> to <code>error_function()</code>, and the error output indicates that <code>temps</code> is an empty string or contains only whitespace, and that <code>r == -1</code> which indicates an input failure as expected when <code>temps</code> is empty or only whitespace.</p>

<p>The problem occurs due to the earlier <code>scanf()</code> call with the <code>%d</code> format specifier.  When you type:</p>

<pre><code>1&lt;newline&gt;
</code></pre>

<p>the <code>%d</code> consumes only the <code>1</code> digit, leaving the <code>&lt;newline&gt;</code> buffered and later extracted by the subsequent <code>fgets()</code> call.</p>

<p>To ensure you consume (and discard) any non-digit characters following the <code>selection</code> entry - read all characters until the <code>&lt;newline&gt;</code>:</p>

<pre><code>scanf( ""%d"", &amp;selection ) ;
int discard = 0;
do{ discard == getchar() ; } while( discard != '\n' &amp;&amp; discard != EOF ) ;
</code></pre>
",1
59429841,59428738,0,"<p>Let us walk through</p>

<pre><code>printf(""Enter your age: "");
</code></pre>

<p>User input <kbd>6</kbd> <kbd>6</kbd> <kbd>Enter</kbd></p>

<pre><code>scanf_s(""%d"", &amp;age);
</code></pre>

<p><code>scanf()</code> reads <code>""66""</code>, <em>leaving</em>  the <code>'\n'</code> in <code>stdin</code>.</p>

<pre><code>....
printf(""Enter your name: "");
</code></pre>

<p><code>scanf_s()</code> attmepts to read the <code>'\n'</code>, which does not meet the criteria of <code>""%[^\n]""</code>, so <code>scanf_s()</code> stops right away and does not return a 1 - still <em>leaving</em>  the <code>'\n'</code> in <code>stdin</code>.</p>

<pre><code>scanf_s(""%[^\n]%*c"", name, 20)
</code></pre>

<p>Code did not check <code>scanf_s()</code> results, Tsk, tsk, and so does not know that <code>name[]</code> remains unchanged.</p>

<hr>

<p>Using a space as in <code>"" %[^\n]%*c""</code> helps, to first consume the left-over <code>'\n'</code>, but the best advice is to not use <code>scanf(), scanf_s()</code> at all. Use <code>fgets()</code> to read a <em>line</em> into a <em>string</em> and then parse the string with <code>sscanf()</code>, <code>strtol()</code>, etc.</p>

<p>In all cases, check the return value of input functions.</p>
",0
58585531,58585478,2,"<p>Changing the value of a function's variable (including those declared as parameters) has no effect on the caller.</p>

<pre><code>void bad1(int i) {
   i = 1;  // No effect on the caller.
}

void bad2(void* p) {
   p = NULL;  // No effect on the caller.
}
</code></pre>

<p>If you want to change a variable in the caller, you will need to pass a pointer to it.</p>

<pre><code>void good1(int* i_ptr) {
   *i_ptr = 1;
}

void good2(void** p_ptr) {
   *p_ptr = NULL;
}
</code></pre>

<p>If you want to modify <code>mainMap</code>, you'll need to pass a pointer to it (<code>&amp;mainMap</code>) and modify the pointed value (<code>*ptr = ...;</code>).</p>

<p>Alternatively, you could simply return the pointer (<code>mainMap = track_heatmap(...);</code>).</p>
",0
58298985,58295277,0,"<p>There are several problems in this line:</p>

<pre><code>int **Matrix1 = malloc(cols1 * sizeof(int));
</code></pre>

<p>First, the argument of <code>malloc()</code> tells the reader you intend to store in it <code>cols1</code> integer values (<code>int</code>). But later on you store <code>int *</code> in the elements of <code>Matrix</code>.</p>

<p>You allocate memory for <code>int</code> and store <code>int *</code> instead. These two types can have different sizes in memory and definitely have different types. The code has undefined behaviour.</p>

<p>You should allocate memory to store <code>cols1</code> pointers to integer (<code>int *</code>). The argument of <code>malloc()</code> should be <code>cols1 * sizeof(int *)</code>.</p>

<p><strong>But wait. There is more!</strong></p>

<p><a href=""https://en.cppreference.com/w/c/memory/malloc"" rel=""nofollow noreferrer""><code>malloc()</code></a> allocates a block of memory of the size it receives as argument. Passing it <code>n * s</code> does not guarantee that the memory block it allocates can accommodate <code>n</code> objects of size <code>s</code><sup>1</sup>.<br>Because of <a href=""https://en.cppreference.com/w/c/language/object#Alignment"" rel=""nofollow noreferrer"">memory alignment</a> requirements, an object may occupy in memory more space than the sum of the sizes of its members and there may be gaps between consecutive objects of the same type.</p>

<p><strong>What's the solution?</strong></p>

<p>The C standard library provides the <a href=""https://en.cppreference.com/w/c/memory/calloc"" rel=""nofollow noreferrer""><code>calloc()</code></a> function to be used to allocate memory for arrays. It receives two arguments (the number of elements and the size of one element) and takes the alignment into account when it computes the amount of memory to allocate.</p>

<p>The code above must be:</p>

<pre><code>int **Matrix1 = calloc(cols1, sizeof(int *));
</code></pre>

<p>The other calls to <code>malloc()</code> must be rewritten the same way using <code>calloc()</code> and the size of the objects that are to be stored in the memory returned by it (<code>int *</code> for <code>Matrix2</code>, <code>int</code> for <code>Matrix1[i1]</code> and <code>Matrix2[i1]</code>.</p>

<hr>

<p><sup>1</sup> The value computed by the <a href=""https://en.cppreference.com/w/c/language/sizeof"" rel=""nofollow noreferrer""><code>sizeof</code></a> operator includes the internal and external paddings. Using <code>malloc(cols1 * sizeof(T))</code> to allocate memory for <code>cols1</code> objects of type <code>T</code> is as safe as using <code>calloc(cols1, sizeof(T))</code>.<br>
<code>calloc()</code> is preferred though because it tells the reader you allocate memory for an array, not for a single object. As a bonus, it fills the allocated memory with zero, which is a good default value for integral types (and integral types only).</p>
",0
58590375,58590307,1,"<p>Simple <a href=""https://www.freecodecamp.org/news/state-machines-basics-of-computer-science-d42855debc66/"" rel=""nofollow noreferrer""><em>state machines</em></a>?</p>

<p>Read byte by byte. If the first byte is <code>0xff</code> then enter a specific state. If the next byte is also <code>0xff</code> then enter another state. And if the next byte is <code>0xff</code> then call function A, else if it's <code>0xfe</code> call function B etc. After the third byte, go back to the original starting state.</p>
",0
58192096,58192026,0,"<p>You can't. It's impossible.</p>

<p>Once upon a time a certain heap manager exposed this information by providing another function that would indeed return the real size. (It's padded up to the next block size.) They took it out after it was discovered to have caused more bugs than it prevented.</p>

<p>On most heap managers, the real size in bytes can be found at a small negative offset, but not all of them. Don't write this code. You will regret it if you have to maintain it. The heap manager can be swapped out from under you and you won't know what went wrong.</p>
",0
57949114,57948994,1,"<p>Taken at face value, the problems include:</p>

<p><strong>Q1</strong> <code>struct abc *ptr; printf(""%d\n"", ptr-&gt;field);</code></p>

<ol>
<li>The structure type is not complete so we have no way of knowing whether the structure has a member <code>field</code>.</li>
<li>The variable <code>ptr</code> is not initialized, so it cannot safely be dereferenced even if the type is known.</li>
<li>Because we don't know the type of <code>field</code>, we can't say whether the <code>printf()</code> format is OK or not.</li>
</ol>

<p><strong>Q2</strong> <code>char *ptr = malloc(sizeof(ptr));</code></p>

<ol>
<li>The space allocated for the 'string' is the size of a pointer, which is probably not the wanted size.</li>
<li>One common idiom is <code>SomeType *ptr = malloc(sizeof(*ptr));</code> to allocate enough space for a single object of type <code>SomeType</code>.  This is close but not quite there.</li>
<li>Adapting the idiom for an array of <code>N</code> objects (where <code>N</code> is a suitable integer value), you'd use <code>SomeType *ptr = malloc(N * sizeof(*ptr));</code> instead.</li>
</ol>

<p><strong>Q3</strong> <code>char *ptr = malloc(1000); memset(&amp;ptr, 0, 1000);</code></p>

<ol>
<li>The allocation isn't checked.</li>
<li><p>The <code>memset()</code> should be passed the pointer value, not the address of the pointer:</p>

<p><code>memset(ptr, '\0', 1000);</code></p>

<p>but why not have the data zeroed by the memory allocation code using:</p>

<p><code>char *ptr = calloc(1000, sizeof(*ptr));</code> </p></li>
</ol>
",0
58295840,58295706,-1,"<pre><code> scanf(""%s\n"", &amp;answer);
</code></pre>

<p>Here you used the <code>%s</code> flag in the format string, which tells <code>scanf</code> to read as many characters as possible into a pre-allocated array of <code>char</code>s, then a null terminator to make it a C-string.</p>

<p>However, <code>answer</code> is a single <code>char</code>. Just writing the terminator is enough to go out of bounds, causing <em>undefined behaviour</em> and strange mishaps.</p>

<p>Instead, you should have used <code>%c</code>. This reads a single character into a <code>char</code>.</p>
",0
58295913,58295706,0,"<p>Whitespace in <code>scanf</code> format strings, like the <code>\n</code> in <code>""%c\n""</code>, tries to match any amount of whitespace, and <code>scanf</code> doesn¡¯t know that there¡¯s no whitespace left to skip until it encounters something that isn¡¯t whitespace (like the second character you type) or the end of input. You provide it with <code>=\n</code>, which fills in the <code>%c</code> and waits until the whitespace is over. Then you provide it with another <code>=</code> and <code>scanf</code> returns. The second time around, the character could be anything and it¡¯d still work.</p>

<p>Skip <em>leading</em> whitespace instead (and use the correct specifier for one character, <code>%c</code>, as has been mentioned):</p>

<pre><code>scanf("" %c"", &amp;answer);
</code></pre>

<p>Also, it¡¯s good practice to make sure you actually succeeded in reading something, especially when failing to read something means leaving it uninitialized and trying to read it later (another example of undefined behaviour). So check <code>scanf</code>¡¯s return value, which should match the number of conversion specifiers you provided:</p>

<pre><code>if (scanf("" %c"", &amp;answer) != 1) {
    return EXIT_FAILURE;
}
</code></pre>
",0
58056617,58056533,0,"<p>It is a defined part of the C language that a function designator (that's what you have when you use <code>fun</code> in an expression) that is <em>not</em> the operand of the <code>sizeof</code>, <code>_Alignof</code> or unary-<code>&amp;</code> operators evaluates to a pointer to the function.  So your <code>void (*fun_ptr)(int) = fun;</code> declaration is perfectly fine.</p>

<p><code>fun</code> can't be re-used as another declarator at file scope, regardless of whether that's a variable or another function.  You <em>can</em> shadow it with a variable declaration in block scope, if you want (this would equally apply to a file-scope variable declaration too).</p>
",0
58056599,58056533,0,"<p>Functions, like arrays, naturally decays to pointers. Using <code>fun</code> when a pointer to a function is expected causes the compiler to treat it as <code>&amp;fun</code>.</p>

<p>And no you can't use <code>fun</code> as the variable name, as that will <em>hide</em> the function by the same name, meaning you can't use the function <code>fun</code> (as in that scope all uses of <code>fun</code> references the variable). This hiding happens in compilation.</p>
",0
58021334,58021326,4,"<p>The <code>i</code> in <a href=""http://www.manpagez.com/man/3/atoi/"" rel=""nofollow noreferrer""><code>atoi(3)</code></a> means <code>integer</code>. That means you're converting your string to an integer, which as you're seeing, doesn't have a fractional part. Use <a href=""http://www.manpagez.com/man/3/strtof/"" rel=""nofollow noreferrer""><code>strtof(3)</code></a> or <a href=""http://www.manpagez.com/man/3/strtod/"" rel=""nofollow noreferrer""><code>strtod(3)</code></a> to get a <code>float</code> or <code>double</code> respectively.</p>
",0
58233755,58233620,1,"<p>Check the <code>QUERY_STRING</code> environment variable</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main (int argc, char **argv) {

    fputs(""Content-Type: text/html\r\n\r\n"", stdout);
    printf(""%s&lt;br&gt;"", getenv(""QUERY_STRING""));
    fputs(""test"", stdout);

    return 0;
}
</code></pre>
",0
58236843,58235979,1,"<p>The error string is printed to stderr, you need to redirect it to stdout since that is what your web server is sending back to the browser.</p>

<p>Redirect stderr to stdout in your program, like this:</p>

<pre><code>fprintf(stderr, ""To stderr\n"");
dup2(1, 2);  
fprintf(stderr, ""To stdout\n"");
</code></pre>

<p>Or simply:</p>

<pre><code>popen(""ls /test_3/ 2&gt;&amp;1"",""r"");
</code></pre>
",0
58315774,58314914,0,"<p>While it is quite unclear why you are tokinizing each environment variable with a <code>delimiter= "".:;"";</code>, there is nothing wrong with it (I would add <code>""*""</code> as well). Instead of looping over the environment variables twice (once to count the number to allocate pointers, the next time to tokenize variables into individual tokens), you can simply iterate over <code>envp</code> once and <code>realloc</code> pointers as needed.</p>

<p>Start with some number of pointers (say <code>2</code>) and then compare your <code>used</code> pointers against  the number available (<code>avail</code>) and when they are equal, double the number of pointers available with <code>realloc</code>.</p>

<p>One other consideration. <code>strtok</code> modifies the original string when tokenizing. So instead of tokenizing <code>envp[x]</code> directly and thus modifying what is in <code>envp</code>, you can (optional) simply copy the environment before tokenizing the copy.</p>

<p>A short implementation that allocates and reallocates pointers, and then allocates storage for each token could be:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define NPTRS 2     /* if you need a constant, #define one (or more) */
#define MAXC 8192

int main (int argc, char *argv[], char *envp[])
{
    size_t i = 0, used = 0, avail = NPTRS;  /* counters */
    const char *delim = "".:;*"";             /* delimiters */
    char **tarray = NULL;                   /* pointer to pointer */

    /* allocate/validate NPTRS pointers initially */
    if (!(tarray = malloc (avail * sizeof *tarray))) {
        perror (""malloc-tarray"");
        return 1;
    }

    while (envp[i]) {               /* loop over each env var */
        char envstr[MAXC];          /* array to hold current env var */
        size_t envlen = strlen (envp[i]);   /* get env var len */
        /* tokenize envp[i] */
        if (envlen &gt;= MAXC - 1) {   /* check env fits in envstr */
            fputs (""error: envstr exceeds MAXC chars.\n"", stderr);
            continue;
        }
        /* strtok modifies original, make copy of env var before strtok */
        memcpy (envstr, envp[i], envlen + 1);
        /* tokenize env var based on delim */
        for (char *p = strtok (envstr, delim); p; p = strtok (NULL, delim)) {
            size_t len = strlen (p);/* length of token */
            if (used == avail) {    /* check if realloc of pointers req'd */
                /* always realloc using a temporary pointer */
                void *tmp = realloc (tarray, 2 * avail * sizeof *tarray);
                if (!tmp) {     /* validate reallocation */
                    perror (""realloc-tarray"");
                    goto done;  /* tarray still good, break nested loops */
                }
                tarray = tmp;   /* assign realloc'ed block to tarray */
                avail *= 2;     /* update avaialble no. of pointers */
            }
            /* allocate/validate storage for token */
            if (!(tarray[used] = malloc (len + 1))) {
                perror (""malloc tarray[used]"");
                goto done;  /* goto req'd to break nested loops */
            }
            memcpy (tarray[used++], p, len + 1);    /* copy to new memory */
        }
        i++;    /* advance to next environment variable */
    }
    done:;

    for (i = 0; i &lt; used; i++) {    /* output all tokens */
        printf (""tarray[%3zu] : %s\n"", i, tarray[i]);
        free (tarray[i]);   /* free storage of strings */
    }
    free (tarray);  /* free pointers */

    (void)argc, (void)argv;     /* suppress unused varaible warnings */
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/main_envp
tarray[  0] : XDG_VTNR=7
tarray[  1] : LESSKEY=/etc/lesskey
tarray[  2] : bin
tarray[  3] : MANPATH=/usr/local/man
tarray[  4] : /usr/share/man
tarray[  5] : /opt/kde3/share/man
tarray[  6] : NNTPSERVER=news
tarray[  7] : XDG_SESSION_ID=1
tarray[  8] : SSH_AGENT_PID=3195
tarray[  9] : KDE_MULTIHEAD=false
tarray[ 10] : HOSTNAME=wizard
tarray[ 11] : DM_CONTROL=/var/run/xdmctl
&lt;snip&gt;
</code></pre>

<p><strong>Memory Use/Error Check</strong></p>

<p>In any code you write that dynamically allocates memory, you have 2 <em>responsibilities</em> regarding any block of memory allocated: (1) <em>always preserve a pointer to the starting address</em> for the block of memory so, (2) it can be <em>freed</em> when it is no longer needed.</p>

<p>It is imperative that you use a memory error checking program to insure you do not attempt to access memory or write beyond/outside the bounds of your allocated block, attempt to read or base a conditional jump on an uninitialized value, and finally, to confirm that you free all the memory you have allocated. </p>

<p>For Linux <code>valgrind</code> is the normal choice. There are similar memory checkers for every platform. They are all simple to use, just run your program through it.</p>

<pre><code>$ valgrind ./bin/main_envp
==16243== Memcheck, a memory error detector
==16243== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.
==16243== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info
==16243== Command: ./bin/main_envp
==16243==
tarray[  0] : XDG_VTNR=7
tarray[  1] : LESSKEY=/etc/lesskey
tarray[  2] : bin
tarray[  3] : MANPATH=/usr/local/man
tarray[  4] : /usr/share/man
tarray[  5] : /opt/kde3/share/man
tarray[  6] : NNTPSERVER=news
tarray[  7] : XDG_SESSION_ID=1
tarray[  8] : SSH_AGENT_PID=3195
tarray[  9] : KDE_MULTIHEAD=false
tarray[ 10] : HOSTNAME=wizard
tarray[ 11] : DM_CONTROL=/var/run/xdmctl
&lt;snip&gt;
==16243==
==16243== HEAP SUMMARY:
==16243==     in use at exit: 0 bytes in 0 blocks
==16243==   total heap usage: 292 allocs, 292 frees, 11,723 bytes allocated
==16243==
==16243== All heap blocks were freed -- no leaks are possible
==16243==
==16243== For counts of detected and suppressed errors, rerun with: -v
==16243== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>

<p>Always confirm that you have freed all memory you have allocated and that there are no memory errors.</p>
",0
58882356,58881363,1,"<p>Assuming the CSV data doesn't contain quotes that protect commas, we can remove the extra spaces around commas using a program that doesn't do any buffering of the data or any sort of processing with null-terminated character arrays. We just read one character at a time using <code>getchar</code>, and maintain some state in the form of counters that measure how many spaces and commas we have seen:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
  int nspc = 0;
  int ncomma = 0;
  int ch;

  while ((ch = getchar()) != EOF) {
    switch (ch) {
    case ' ': nspc++; break;
    case ',': ncomma++; break;
    default:
      if (ncomma &gt; 0)
        while (ncomma-- &gt; 0)
          putchar(',');
      else
        while (nspc-- &gt; 0)
          putchar(' ');
      putchar(ch);
      nspc = 0;
      ncomma = 0;
      break;
    }
  }

  return 0;
}
</code></pre>

<p>Test data:</p>

<pre><code>$ cat clean-comma-test 

a
aa
a,
,a
a a,
,a a
a , b
, a , b c , d
,  a , b   c d   ef,  g h
   ,
   ,a
,  ,
, ,, , ,    ,
</code></pre>

<p>Output:</p>

<pre><code>a
aa
a,
,a
a a,
,a a
a,b
,a,b c,d
,a,b   c d   ef,g h
,
,a
,,
,,,,,,
</code></pre>

<p>The basic idea is:</p>

<ul>
<li><p>if we see a field of N spaces that doesn't contain any commas, followed by a character C which isn't a space or comma, then we just reproduce N spaces and character C. </p></li>
<li><p>if we see a field of N spaces (possibly 0) containing one or more commas M, followed by a character C that isn't a space or comma, we reproduce the M commas, followed by C.</p></li>
<li><p>lines in C streams are terminated by the newline character <code>'\n'</code>, which serves as C in the case when the comma-space field is the last item in the line.</p></li>
</ul>

<p>A C program that doesn't manipulate any pointers cannot have a buffer overflow or memory leak. However, I haven't protected the counters against integer overflow. If you have a field of more than <code>INT_MAX</code> spaces and/or commas, the behavior is undefined. On modern systems, that's well over two billion, so there is a fair amount of justification for not caring about it.</p>

<p>The code also doesn't recognize other whitespace such as tabs.</p>
",1
59148768,59148481,2,"<p>You need to check the return value of <code>scanf</code> and flush the input:</p>

<pre><code>#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    bool done = false;
    while (!done) {
        printf(""\n\tWelcome\n"");
        printf(""1. Login\n"");
        printf(""2. Register\n"");
        printf(""3. Account\n"");
        printf(""4. Exit\n\n"");
        printf(""Enter a number:"");
        int selection;
        int result = scanf(""%d"", &amp;selection);
        if (EOF == result) {
            done = true;
        }
        else if (1 != result) {
            printf(""You did not enter a valid number\n"");
            int c;
            while ((c = getchar()) != '\n' &amp;&amp; c != EOF) {}
            done = (c == EOF);
        }
        else if (1 == selection) {
            printf(""You chose login\n"");
        }
        else if (2 == selection) {
            printf(""You chose register\n"");
        }
        else if (3 == selection) {
            printf(""You chose account\n"");
        }
        else if (4 == selection) {
            done = true;
        }
        else {
            printf(""Please pick a number between 1 and 4\n"");
        }
    }
}
</code></pre>

<p>The format string in <code>scanf(""%d"",&amp;slct);</code> is <code>%d</code> which means you want to read a number.</p>

<p>When you enter something else than a number, <code>scanf</code> returns 0 to indicate that zero numbers were read.</p>

<p>If the scanf encounters and end-of-file when attempting to read the input (enter control-D) then it returns the special value EOF.</p>

<p>Also, scanf does not consume the incorrect input, so you need to explicitly flush it.</p>
",2
58659583,58659349,-1,"<p>For a Unix type terminal, Ctrl-D is usually the termios VEOF character, and is not passed through to standard input when the terminal is in canonical input mode. In that case, typing the Ctrl-D character at the beginning of a line will make <code>scanf</code> see an end-of-file condition, but it needs to be at the beginning of a line, not partway through a line as in your example. So you may need to type a Carriage Return before the Ctrl-D in order to return from <code>scanf</code> early.</p>

<p>You can check the return value of <code>scanf</code> to see if it read the required number of input values, and end the program if the return value is incorrect.</p>
",0
58657038,58656579,1,"<p>To solve the task described you don't need arrays and you don't need to convert anything into binary. Numbers are already binary so you can simply operate directly on the numbers.</p>

<p>The program be shows how it can be done.</p>

<pre><code>uint32_t findMSB(uint32_t i)
{
  uint32_t n = 31;
  while(n)
  {
    if ((1 &lt;&lt; n) &amp; i) return n;
    --n;
  }
  return 0;
}

int main()
{
  uint32_t low = 0;
  uint32_t high = 20;
  for (uint32_t i = low; i&lt;=high; ++i)
  {
    uint32_t msb = findMSB(i);  // Find the highest bit number where the bit == 1
    uint32_t lsb = 0;
    int sym = 1;                // Assume the number is symmetrical 
    while(lsb &lt; msb)            // Check whether bits are equal, i.e. both 0 or both 1
    {
      int msb_val = ((1 &lt;&lt; msb) &amp; i) ? 1 : 0;
      int lsb_val = ((1 &lt;&lt; lsb) &amp; i) ? 1 : 0;
      if (msb_val != lsb_val)
      {
        sym = 0;                // Not symmetrical so clear the flag
        break;                  // No reason to continue the loop so break out
      }
      --msb;   // Move to next bits
      ++lsb;
    }
    if (sym) printf(""sym: %u\n"", i);
  }
  return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>sym: 0
sym: 1
sym: 3
sym: 5
sym: 7
sym: 9
sym: 15
sym: 17
</code></pre>

<p>What is left for you:</p>

<ol>
<li><p>The program prints decimal values so you need to add a binary print</p></li>
<li><p>The program only handles unsigned values so you need to add support for signed values</p></li>
<li><p>The program has fixed limits so you need read limits as user input</p></li>
</ol>
",0
58900323,58900169,1,"<p>Your <code>person_constructor()</code> is seriously confused.  You set <code>pptr</code> to point to <code>p</code>, only to overwrite it with the pointer to an uninitialised dynamic memory block (with incorrectly determined size).</p>

<pre><code>    // Allocate the structure memory
    Person* pptr = malloc( sizeof(Person) ) ;

    // Assign the structure members
    strcpy( pptr-&gt;name, name ) ;
    pptr-&gt;year_of_birth = year_of_birth;
    strcpy( pptr-&gt;sex, sex ) ;

    // Return a pointer to the allocation
    return pptr ;


</code></pre>
",1
58738266,58737960,0,"<p>Addressing the first issue, pass in how many items the user actually entered so you're not running up to <code>MAX</code> (which would include all the unused cells). The key is <code>nitems</code>.</p>

<pre><code>void frequencyAnalysis(int array[], int nitems, int *number, int *freq)
{
    for (int i = 0; i &lt; nitems; i++) {
        ...
        for (int j = 0; j &lt; nitems; j++)
        {
           // do stuff
        }
    }
}

int main(void)
{
int array[MAX],i, j, number = 0, freq = 0;

    ...
    frequencyAnalysis(array, i, &amp;number,&amp;freq);
    ///
}
</code></pre>
",3
59012537,59011358,0,"<p>The reason you're getting these errors:</p>

<blockquote>
  <p>warning: cast to pointer from integer of different size </p>
</blockquote>

<p>Is because your main file doesn't know how <code>MyMalloc</code> is defined, so it defaults to a function returning an <code>int</code>.  You can fix this by putting <code>#include ""mymalloc.h""</code> at the top of your main file.</p>

<p>If you do this, you'll see another error, specifically that <code>buffer</code> and <code>memory</code> are defined twice.  This is because you're defining these two variables in your header file.  It is for this reason that variables shouldn't be defined in a header file.</p>

<p>Since you only use <code>buffer</code> and <code>memory</code> in mymalloc.c, you should move them into that file.  That way you avoid the multiple definition error.  You should also move <code>struct node</code> for the same reason.</p>
",2
58830438,58829703,1,"<p>You should get into the habit of putting a newline (<code>\n</code>) at the end of your printf formats. That will usually make the data easier to read, and it will mostly save you from having to think about <code>stdout</code> buffering. (q.v.)</p>

<p>Also, I've heard that some IDEs swallow the last line of output if it's not terminated with a newline.</p>

<p>Sometimes, of course, you will want to use more than one <code>printf</code> call to print a single line; in that case, you only put the <code>\n</code> for the last printf in the line. But the normal case is that every format string ends with <code>\n</code>.</p>
",0
58985890,58985868,3,"<p>The question is not very clear but I think you are asking for:</p>

<pre><code>int func(int x, int y)
{
     int retval = 0;

     if ( x == 0 &amp;&amp; y == 0 )
          retval = 10;

     // ...other stuff...

     return retval;
}
</code></pre>

<p>Some languages have an implicit variable for the return value that you can modify but C does not .</p>

<p>There is no such thing as ""initialize the return value before calling the function"" , the return value is part of the function execution .</p>
",0
59130794,59130417,1,"<p>Your problem is that the <code>printf()</code> format string has 6 <code>%d</code> conversion specifications, but you only pass 4 values (<code>a</code>, <code>b</code>, <code>c</code> and the expression).  You either need to use the POSIX <em><code>n$</code></em> notation (see <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html"" rel=""nofollow noreferrer""><code>printf()</code></a>), like this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int a, b, c;
    printf(""a: \n"");
    scanf(""%d"", &amp;a);
    printf(""b: \n"");
    scanf(""%d"", &amp;b);
    printf(""c: \n"");
    scanf(""%d"", &amp;c);

    if ((a == 1 || a == 0) &amp;&amp; (b == 1 || b == 0) &amp;&amp; (c == 0 || c == 1))
        printf(""a = %1$d, b = %2$d, c = %3$d:  (%2$d &amp;&amp; (%1$d || %3$d)) || (%1$d &amp;&amp; %3$d) = %4$d\n"",
               a, b, c, (b &amp;&amp; (a || c)) || (a &amp;&amp; c));
    else
        printf(""Numbers are not correct!\n"");
    return 0;
}
</code></pre>

<p>or you need to repeat the arguments as required:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int a, b, c;
    printf(""a: \n"");
    scanf(""%d"", &amp;a);
    printf(""b: \n"");
    scanf(""%d"", &amp;b);
    printf(""c: \n"");
    scanf(""%d"", &amp;c);

    if ((a == 1 || a == 0) &amp;&amp; (b == 1 || b == 0) &amp;&amp; (c == 0 || c == 1))
        printf(""a = %d, b = %d, c = %d:  (%d &amp;&amp; (%d || %d)) || (%d &amp;&amp; %d) = %d\n"",
               a, b, c, b, a, c, a, c, (b &amp;&amp; (a || c)) || (a &amp;&amp; c));
    else
        printf(""Numbers are not correct!\n"");
    return 0;
}
</code></pre>

<p>The output from both programs is the same.  I used a shell script to test <code>b41</code> (created from <code>b41.c</code>) like this:</p>

<pre><code>for a in 0 1
do
    for b in 0 1
    do
        for c in 0 1
        do
            echo $a $b $c | b41
        done
    done
done | grep -v '^[abc]:'
</code></pre>

<p>The <code>grep</code> removes the prompt lines (they're boring!) and the output is:</p>

<pre><code>a = 0, b = 0, c = 0:  (0 &amp;&amp; (0 || 0)) || (0 &amp;&amp; 0) = 0
a = 0, b = 0, c = 1:  (0 &amp;&amp; (0 || 1)) || (0 &amp;&amp; 1) = 0
a = 0, b = 1, c = 0:  (1 &amp;&amp; (0 || 0)) || (0 &amp;&amp; 0) = 0
a = 0, b = 1, c = 1:  (1 &amp;&amp; (0 || 1)) || (0 &amp;&amp; 1) = 1
a = 1, b = 0, c = 0:  (0 &amp;&amp; (1 || 0)) || (1 &amp;&amp; 0) = 0
a = 1, b = 0, c = 1:  (0 &amp;&amp; (1 || 1)) || (1 &amp;&amp; 1) = 1
a = 1, b = 1, c = 0:  (1 &amp;&amp; (1 || 0)) || (1 &amp;&amp; 0) = 1
a = 1, b = 1, c = 1:  (1 &amp;&amp; (1 || 1)) || (1 &amp;&amp; 1) = 1
</code></pre>

<p>Note that GCC set fussy recommended extra parentheses in the expression mixing <code>&amp;&amp;</code> and <code>||</code> operators.  It's good to know the precedence rules; it's better to write code to avoid making those reading the code have to remember the rules.</p>

<p>The original expression (<code>(!a)&amp;b&amp;c + a&amp;(!b)&amp;c + a&amp;b&amp;(!c) + a&amp;b&amp;c</code>) is symmetric in <code>a</code>, <code>b</code>, <code>c</code>, yet the revision is not, and I suggested that the simplification was wrong, but it isn't. The original expression is true if any two of <code>a</code>, <code>b</code>, <code>c</code> are true, or if all three are true. On further scrutiny, the alternative (<code>b(a+c) + a*c</code>) does the same ¡ª but it could equivalently be written <code>c(a+b) + a*b</code> or <code>a(b+c) + b*c</code>; all three should produce the same output.</p>
",0
59567908,59567869,3,"<p>Since <code>difficulty</code> is a <code>typedef</code>, you shouldn't put <code>enum</code> before it when declaring a variable using that type. It should just be</p>

<pre><code>difficulty mode = NOT_SELECTED;
</code></pre>

<p>A <code>typedef</code> is used in declarations just like built-in types, you don't need to put anything before it.</p>
",0
59463548,59463407,2,"<p>Assuming you want <strong>every</strong> call to <code>printf</code> to be covered by the debug flag, you can do this:</p>

<pre><code>#ifdef DEBUG_PRINT
#define printf(...) printf(__VA_ARGS__)
#else
#define printf(...) 0
#endif
</code></pre>

<p>With this macro, if the flag is defined then the call to <code>printf</code> is unchanged.  If it is not, the call is replaced with the value 0.  The value is needed in case the return value of <code>printf</code> is used anyplace.</p>
",2
59218434,59218345,2,"<p>After calculating the value of <code>fiftyP</code>, you're  using <code>change</code> to calculate each successive remainder while using <code>remainder</code> to calculate each coin count.  You should instead be using <code>change</code> in all places:</p>

<pre><code>change = money - cost;
fiftyP = change / 50;
change= change % 50;
twentyP = change/ 20;
change= change% 20;
tenP = change/ 10;
change= change% 10;
fiveP = change/ 5;
change= change% 5;
twoP = change/ 2;
change= change% 2;
oneP = change/ 1;
</code></pre>
",0
59521887,59520832,0,"<p>This makes a pretty even distribution of 2s and 4s with the expression <code>int a = 2 * ((rand() % 2) + 1);</code></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main() {
    int twos = 0;
    int fours = 0;

    srand(time(0));
    for(int i=0; i&lt;2000; ++i)
    {
        int a = 2 * ((rand() % 2) + 1);
        (a == 2)? twos++ : fours++;
    }

    printf(""2s: %d\n"", twos);
    printf(""4s: %d"", fours);

    return 0;
}
</code></pre>

<h2>Output:</h2>

<pre><code>Success #stdin #stdout 0s 4548KB
2s: 1005
4s: 995


Success #stdin #stdout 0s 4412KB
2s: 1022
4s: 978
</code></pre>
",0
59520899,59520832,2,"<p><code>a != 2 || a != 4</code> is always <code>1</code> since <code>a</code> cannot be 2 or 4 at the same time. Hence the loop is infinite.</p>

<p>From a statistical perspective this needs thought. Sampling and rejecting out of range values can tie you to a particular class of generators, so is best avoided if at all possible.</p>

<p>In the search for an alternative note that <code>rand()</code> typically alternates between odd and even numbers due to how it works internally! So doing something with the least significant bit (which is often mooted as an answer) is a bad idea indeed.</p>

<p>One approach is to remove the loop entirely and use</p>

<pre><code>a = rand() &lt; RAND_MAX / 2 ? 2 : 4;
</code></pre>

<p>which might introduce a slight statistical bias, but probably no worse than <code>rand</code> itself.</p>
",3
58300155,58299867,7,"<p>Surely, what you have:</p>

<pre><code>while(checker = fread(&amp;y, sizeof(int), 1, fp) != 0 &amp;&amp; y != num){
</code></pre>

<p>should be:</p>

<pre><code>while ((checker = fread(&amp;y, sizeof(int), 1, fp)) != 0 &amp;&amp; y != num){
</code></pre>

<p>As it stands, you're evaluating <code>fread(&amp;y, sizeof(int), 1, fp) != 0 &amp;&amp; y != num</code> and assigning that boolean (0, 1) value to <code>checker</code>, and then testing whether it was 0 or 1.</p>
",0
59391481,59391321,1,"<p>C doesn't have a way to make a variable only writable from certain places, but <code>static</code> is limited to that source file. So instead what you might do is have a ""getter"" function only, to keep the variable ""hidden"" in just the desired file.</p>

<pre><code>// Header
int get_a();


// Source file1
static int a;
int get_a()
{
    return a;
}

void foo()
{
    a = 42; //OK
}

// Source file2
void bar()
{
    int x = get_a(); // OK, function in header
    a = x + 1; // Error, a was never declared in the header
}
</code></pre>
",0
59474882,59474809,2,"<blockquote>
  <p>Does 'all values' mean whole identifiers in same scope?</p>
</blockquote>

<p>I'm not sure why you think all identifiers in a scope matter. The integer promotion applies to a <em>single</em> item, be it an object (e.g., variable) or expression.</p>

<p>What it's saying is that, if every possible value of this item (already one of the types guaranteed to fit into an <code>int</code> or <code>unsigned int</code> as per the paragraphs before your quote<sup>(a)</sup>) can be represented by the <code>int</code> type, it gets promoted to an <code>int</code>. Otherwise it gets promoted to an <code>unsigned int</code>.</p>

<hr>

<p><sup>(a)</sup> The text states, in full:</p>

<blockquote>
  <p>The following may be used in an expression wherever an <code>int</code> or <code>unsigned int</code> may be used:</p>
  
  <ul>
  <li><p>An object or expression with an integer type (other than <code>int</code> or <code>unsigned int</code>) whose integer conversion rank is less than or equal to the rank of <code>int</code> and
  <code>unsigned int</code>.</p></li>
  <li><p>A bit-field of type <code>_Bool</code>, <code>int</code>, <code>signed int</code>, or <code>unsigned int</code>.</p></li>
  </ul>
  
  <p>If an <code>int</code> can represent all values of the original type (as restricted by the width, for a bit-field), the value is converted to an <code>int</code>; otherwise, it is converted to an <code>unsigned int</code>. These are called the integer promotions. All other types are unchanged by the integer promotions.</p>
</blockquote>
",1
59415582,59415514,3,"<pre><code>    if (strstr(st, &quot;{&quot;) != NULL)
        br2++;
</code></pre>
<p>What if you enter a line with more than one '{' on it?  This increments if <em>any</em> brace was found, and does not consider <em>how many</em> there were.</p>
<h1>some advice</h1>
<p>Go through the string one <em>character</em> at a time.</p>
<pre><code>int count_braces (const char* s)
{
int n= 0;
while (*s) {
   if (*s == '{')  ++n;
   else if (*s == '}') --n;
}
return n;
}
</code></pre>
",0
59415757,59415514,0,"<p>You aren't actually counting the blocks entered. And as JD?ugosz mentioned, you aren't considering if more than one block begins on a line.</p>

<p>Valid code:</p>

<pre><code>{
  {
    //something
  }
}
</code></pre>

<p>Also valid code:</p>

<pre><code>{{ /*something*/ }}
</code></pre>

<p>Consider this:</p>

<pre class=""lang-c prettyprint-override""><code>int countAllBraces(const char * h, const char * n)
{
    int count = 0;
    const char *tmp = h;
    while( tmp = strstr( tmp, n)){
        //printf( ""Position: %d\n"", (int)(tmp-h)); //debugging
        ++count;
    }
    return count;
}

void KeyboardToScreen()
{
    char st[80];int br1 = 0, br2 = 0, j = 0, k = 0, t;
    puts(""Enter the code:"");
    while (fgets(st, 80, stdin) != NULL)
    {
        j = 0;
        while (st[j] != '\0')
        {
            if (st[j] == '*') br1++;
            j++;
        }
        k += t = countAllBraces(st, ""{"");
        br2 += t;
        br2 -= countAllBraces(st, ""}"");
    }
    if (br2 &gt; 0)
        printf(""ERROR: Block is not closed \n"");
    printf(""%d %d \n"", br1, k);
    exit(0);
};
</code></pre>
",0
59430796,59430779,6,"<pre><code>strcpy(ch,""int"");
</code></pre>

<p>is equivalent to</p>

<pre><code>ch[0] = 'i';
ch[1] = 'n';
ch[2] = 't';
ch[3] = 0;
</code></pre>

<p>Seeing as <code>ch</code> only has three elements (<code>ch[0]..ch[2]</code>), this invokes undefined behaviour.</p>
",1
59431329,59430779,0,"<p>I used <a href=""https://www.onlinegdb.com/online_c_compiler#"" rel=""nofollow noreferrer"">online compiler</a> and selected ""C++"" and the error is not happening.
but when I selected C++17 I  got this warning <strong><em>""
input
main.cpp:9:12: warning: ¡®void</em> __builtin_memcpy(void*, const void*, long unsigned int)¡¯ writing 4 bytes into a region of size 3 ov
w=] ""*</strong></p>

<p>as @PaulMcKenzie mentioned this is buffer overflow case.</p>
",2
58145777,58145282,1,"<p><code>man pow</code> says:</p>

<blockquote>
  <p>double
  pow(double x, double y);</p>
  
  <p>...
  The pow() functions compute x raised to the power y.</p>
</blockquote>

<p>You need to include math.h. 
In code it would look like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;

int main() {
    int a, b;

    if(scanf(""%d"", &amp;a) != 1) {
        fprintf(stderr, ""wrong input for a"");
        exit(1);
    }

    if(scanf(""%d"", &amp;b) != 1) {
        fprintf(stderr, ""wrong input for b"");
        exit(1);
    }
    double result = pow(a, b);
    printf(""result of %d^%d=%g\n"", a, b, result);

    return 0;
}
</code></pre>

<p>Please note that <code>scanf</code> returns the number of input items assigned. So it makes sense to check for invalid input there.</p>
",0
59515102,59514075,0,"<p>You are forgetting to return the result and are attempting to pass the <code>result</code> parameter by value instead of by pointer reference.</p>

<p>Instead of this:</p>

<pre><code>int dotpro(int v1[], int v2[], int result, int n) {
    int i;

    for (i = 0; i &lt; n; i++) {
        result += (v1[i] * v2[i]);
    }
    printf(""%d"", result);
}
</code></pre>

<p>Do this:</p>

<pre><code>int dotpro(int v1[], int v2[], int n) {
    int i;
    int result = 0;

    for (i = 0; i &lt; n; i++) {
        result += (v1[i] * v2[i]);
    }
    return result;
}
</code></pre>

<p>And adjust the declaration at the top of the file to match:</p>

<pre><code>int dotpro(int v1[], int v2[], int n);
</code></pre>

<p>Then in main, invoke as follows:</p>

<pre><code>result = dotpro(v1, v2, n);
printf(""result = %d\n"", result);
</code></pre>
",1
59505297,59505238,3,"<p>First, you need to declare your array properly:</p>

<pre><code>char nums[3][10] =   // There are 3 rows, not 2
{
    {1,  2,  3,  4,  5,  6,  7},  // Use { } for each row
    {2,  1,  1,  2,  3,  5,  7},  // Separate values with commas
    {5,  2,  6,  7,  3,  5,  2}
};
</code></pre>

<hr>

<p>Then its:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    char nums[3][10] = 
    {
        {1,  2,  3,  4,  5,  6,  7},
        {2,  1,  1,  2,  3,  5,  7},
        {5,  2,  6,  7,  3,  5,  2}
    };


   for(int i=0; i&lt;3; ++i)
   {
       printf(""%d\n"", nums[i][2]); // Print the 3rd value (index 2), from each row (i)
   }

    return 0;
}
</code></pre>

<h3>Output</h3>

<pre><code>Success #stdin #stdout 0s 4288KB
3
1
6
</code></pre>
",0
59505394,59505238,0,"<pre><code>char nums[2][10] = 
{
1  2  3  4  5  6  7
2  1  1  2  3  5  7
5  2  6  7  3  5  2
};
</code></pre>

<p>is not correct. You cannot declare an array of two 10-element arrays and then try to put three 7-element arrays in it. First there are too many elements, and second, the 3rd array will overflow the bounds of the construct. Also you are populating a <code>char</code> array with integers. Make sure your data types match your input. Your declaration should look like this:</p>

<pre class=""lang-c prettyprint-override""><code>int nums[3][7] = 
{
 {1, 2, 3, 4, 5, 6, 7},
 {2, 1, 1, 2, 3, 5, 7},
 {5, 2, 6, 7, 3, 5, 2}
}
</code></pre>

<p>Now that we've covered that, you can consider this tidbit of code that will print out just the 3rd column, but you can modify it to read in the column to print into a variable and compare that to the value of <code>i</code> instead of hard-coding it to be the 3rd column (use 2 for zero-indexing).</p>

<pre class=""lang-c prettyprint-override""><code>for (int i = 0; i &lt; 7; i++)    //for each ""column""
{
  if(i == 2)                    //if we're at the 3rd 0-indexed column
  {
    for(int j = 0; j &lt; 3; j++)   //cycle through the rows
    {
      printf(""%d\n"", nums[j][i]); //print the number in that position
    }
  }
}
</code></pre>
",0
58310720,58310045,1,"<blockquote>
  <p>Is there a way to determine a position within a const array at compile-time in c?</p>
</blockquote>

<p>Yes. Remember that <strong><em>C</em> source files can be generated</strong>, and improve your <a href=""https://en.wikipedia.org/wiki/Build_automation"" rel=""nofollow noreferrer"">build automation</a> accordingly (e.g. edit your <a href=""https://en.wikipedia.org/wiki/Makefile"" rel=""nofollow noreferrer""><code>Makefile</code></a>).</p>

<p>So just generate the second part (e.g. with some <code>awk</code> or <a href=""https://www.gnu.org/software/guile/"" rel=""nofollow noreferrer"">Guile</a> script on Linux, or your own simple <a href=""https://en.wikipedia.org/wiki/Metaprogramming"" rel=""nofollow noreferrer"">meta-program</a> coded in C -or some scripting language- that output portions of generated C code). Play with <a href=""https://gcc.gnu.org/onlinedocs/cpp/"" rel=""nofollow noreferrer"">preprocessor tricks</a>. See <a href=""https://stackoverflow.com/a/26843374/841108"">this</a> answer for inspiration.</p>

<p>You could, assuming you use <a href=""https://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a> as your C compiler, also consider writing your ad-hoc <a href=""https://gcc.gnu.org/onlinedocs/gccint/Plugins.html"" rel=""nofollow noreferrer"">GCC plugin</a>, but in your particular case it is not worth the effort.</p>

<p>BTW, my <a href=""https://github.com/bstarynk/bismon/"" rel=""nofollow noreferrer"">Bismon</a> program uses such meta-programming tricks. And GCC itself has dozens of ad-hoc code generators.</p>

<p>If you generate some complex enough C code, I recommend keeping internally some kind of <a href=""https://en.wikipedia.org/wiki/Abstract_syntax_tree"" rel=""nofollow noreferrer"">AST</a> of it.</p>
",0
58332175,58332027,0,"<p>everything you read is on string format, so it's up to you how to convert it to int or whatever you want. In this case, you need to split the string ""20 31"" to two strings ""20"" and ""31"" using function strtok and then use function atoi to convert strings to int 20 and 31.</p>
",0
58295857,58295729,1,"<p>Not sure if this is the idea (I didn't check on the math aspect of this, and the ""180/3.1415"" after the atan() call is missing an operand), but I think this is your code with the pointers adjusted:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

void cal_mag_phase(double z1real, double z1imag, double* magnitude, double* phase)
{
  //magnitude is square root of components squared
  *magnitude = sqrt(pow(z1real,2)+pow(z1imag,2));
  //phase is calculated then converted to degrees
  *phase = atan(z1imag/z1real);// what's this?--&gt;180/3.1415;
}

int main(void) {
  double magnitude, phase;
  double z1real, z1imag;

  z1real = 1;
  z1imag = 1;

  cal_mag_phase(z1real, z1imag, &amp;magnitude, &amp;phase);
  printf(""magnitude and phase (in degrees) of (%.2lf + %.2lfi) are %lf and %lf\n"", z1real, z1imag, magnitude, phase);
}
</code></pre>

<p>I also added the variables and values for the complex Z1.</p>

<p>A note on your use of pointers, you were missing an '*' before one the parameters.</p>

<p>Other than that, I just reformatted your code. I know you're new here, but always try to clearly format code so that it's easier to read, and also test (in this case, including the declaration for Z1, which was needed to run the code).</p>
",0
59363259,59362421,3,"<p>This does not answer the question, because using <code>continue</code> isn't a good idea. It increases the amount of branches and can lead to spaghetti programming. It is not a good idea to practice bad habits while studying, or you'll end up using them in real programs later on.</p>

<p>A better idea is to use the built-in functions from ctype.h and only in case of a positive result, check for ""B"". Example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main (void)
{
  char ch = 0;
  int upper = 0;
  int lower = 0;

  for(int i=0; i&lt;15 &amp;&amp; ch != '.'; i++)
  {
    printf(""Input character %d:\n"", i+1);
    ch = getchar();

    if(isupper(ch) &amp;&amp; ch != 'B')
    {
      upper++;
    }
    else if(islower(ch) &amp;&amp; ch != 'b')
    {
      lower++;
    }
  }

  printf(""\nUPPERCASE: %d -- LOWERCASE: %d"", upper, lower);
  return 0;
}
</code></pre>

<p>Improvements:</p>

<ul>
<li>Reduced the number of branches</li>
<li>Doesn't make non-portable assumptions about underlying symbol table (EBCDIC-compatible, yay!)</li>
<li>Uses <code>for</code> since the (maximum) number of iterations is known in advance.</li>
<li>Intuitive variable names where it matters, instead of 1 letter names (<code>i</code> is fine since it stands for iterator).</li>
<li>Got rid of non-standard antique headers and functions for MS DOS.</li>
</ul>

<p>You may have to add code that rids stdin of the superfluous line feed <code>\n</code> characters.</p>
",1
59363116,59362421,1,"<p>If you really need to use <code>continue</code> you need to reverse asking and checking for the next character in your for loop.</p>

<pre><code>while(ch != '.' &amp;&amp; i &lt; 15){
    i++;
    printf(""\ninput the %d character\n"", i);
    ch = getche();
    if(ch == 'B' || ch == 'b')
        continue;
    if(isupper(ch)) {
        k++;
    }
    if(islower(ch)) {
        m++;
    }
}
</code></pre>

<p>And you don't need the lines:</p>

<pre><code>printf(""Input the %d character\n"", i+1);
ch = getche();
</code></pre>

<p>before the while loop</p>
",0
58355600,58355575,2,"<p>Here's your problem:</p>

<pre><code>printf(""height: %d\n"",&amp;height);
</code></pre>

<p>You're not printing the value of <code>height</code>.  You're printing its <strong>address</strong>.  Remove the address-of operator:</p>

<pre><code>printf(""height: %d\n"",height);
</code></pre>
",4
59025165,59025128,5,"<p>The likely candidate is this line:</p>

<pre><code>struct node* temp = malloc (sizeof(struct node*));
</code></pre>

<p>Which creates enough space to store a <em>pointer to a node</em>, not to a node itself. Remove the <code>*</code> from the <code>sizeof</code> expression. Alternatively (and the way I would write this code), just don't use types in <code>sizeof</code> expressions if you can avoid it:</p>

<pre><code>struct node *temp= malloc(sizeof *temp);
</code></pre>

<p>Other notes:</p>

<ol>
<li><p>As mentioned by @VladFeinstein, use <code>strdup</code> instead of your <code>malloc</code>/<code>strlen</code>/<code>strncpy</code>/<code>\0</code> dance.</p>

<pre><code>temp-&gt;word = strdup(word);
temp-&gt;id = strdup(id);
</code></pre></li>
<li><p>If you choose to not do that, notice that your order of operations seems confused in the <code>malloc</code> size expressions:</p>

<pre><code>temp-&gt;word = malloc(sizeof(char) * strlen(word) + 1);
</code></pre>

<p>It's still correct, but only because <code>sizeof(char)</code> is <code>1</code>. I'd simply write:</p>

<pre><code>temp-&gt;word = malloc(strlen(word) + 1);
</code></pre>

<p>But if you're really set on leaving <code>sizeof(char)</code> in there, make sure you parenthesize the addition in the expression correctly.</p></li>
</ol>
",2
58568746,58568667,1,"<p><code>sel</code> is treated as a selector if given, when it returns 0 the directory is skipped.</p>

<pre><code>   if (sel &amp;&amp; !sel(de)) {
</code></pre>

<p><code>cmp</code> is passed to quick sort as the comparison function to compare two entries and determine which one should go first.</p>

<pre><code>if (cmp) {
    qsort(names, cnt, sizeof *names, 
        (int (*)(const void *, const void *))cmp);
}
</code></pre>

<p>Both are function pointers, <code>sel</code> is passed the parameter as I noted above while <code>cmp</code> is passed along to <code>qsort()</code> which will internally invoke it with appropriate parameters.</p>

<p><strong>Update</strong>: Comparison functions, <code>cmp</code> above, are generally defined to return an integer with the following meaning:</p>

<ul>
<li>negative means <code>a &lt; b</code>, generally <code>-1</code> but do not rely on the magnitude just the sign.</li>
<li><code>0</code> means <code>a == b</code></li>
<li>positive means <code>a &gt; b</code>, generally <code>-1</code> but do not rely on the magnitude just the sign.</li>
</ul>

<p>The selector function, <code>sel</code> above, returns an integer - really a Boolean <code>true</code>/<code>false</code> - but this looks like old C which did not have <code>bool</code> type. So, <code>false</code> becomes <code>0</code> while any other integer becomes <code>true</code>.</p>
",2
58775416,58775148,-1,"<p>First of all: for what you're doing, you probably want to look carefully at the function <code>strtok</code> and the <code>atoi</code> macro. But given the code you posted, that's perhaps still a bit too advanced, so I'm taking a longer way here.</p>

<p>Supposing that the line is something like</p>

<p>172,924,1182</p>

<p>then you need to <em>parse</em> those numbers. The number 172 is actually represented by two or four bytes in memory, in a very different format, and the byte ""0"" is nothing like the number 0. What you'll read is the ASCII code, which is 48 in decimal, or 0x30 in hex.</p>

<p>If you take the ASCII value of a single digit and subtract 48, you will get a number, because fortunately the numbers are stored in digit order, so ""0"" is 48, ""1"" is 49 and so on.</p>

<p>But you still have the problem of converting the three digits 1 7 2 into 172.</p>

<p>So once you have 'data':
(I have added commented code to deal with a unquoted, unescaped text field inside the CSV, since in your question you mention an AGE field, but then you seem to want to use a NAME field. The case when the text field is quoted or escaped is another can of worms entirely)</p>

<pre><code>size_t i   = 0;
int number = 0;
int c;
int field = 0; // Fields start at 0 (ID).
// size_t x = 0;

// A for loop that never ends until we issue a ""break""
for(;;) {
    c = data[i++];
    // What character did we just read?
    if ((',' == c) || (0x0c == c) || (0x0a == c) || (0x00 == c)) {
        // We have completed read of a number field. Which field was it?
        switch(field) {
            case 0: ID[j] = number; break;
            case 1: AGE[j] = number; break;
            // case 1: NAME[j][x] = 0; break; // we have already read in NAME, but we need the ASCIIZ string terminator.
            case 2: GPA[j] = number; break;
        }
        // Are we at the end of line?
        if ((0x0a == c) || (0x0c == c)) {
            // Yes, break the cycle and read the next line
            break;
        }
        // Read the next field. Reinitialize number.
        field++;
        number = 0;
        // x = 0; // if we had another text field
        continue;
    }
    // Each time we get a digit, the old value of number is shifted one order of magnitude, and c gets added. This is called Horner's algorithm:
    // Number   Read    You get
    // 0        ""1""     0*10+1 = 1
    // 1        ""7""     1*10+7 = 17
    // 17       ""2""     17*10+2 = 172
    // 172      "",""     Finished. Store 172 in the appropriate place.
    if (c &gt;= '0' &amp;&amp; c &lt;= '9') {
        number = number * 10 + (c - '0');
    }
    /*
       switch (field) {
           case 1:
               NAME[j][x++] = c; 
               break;
       }
    */
}
</code></pre>
",2
58660501,58660440,5,"<pre><code>   struct vptree *tree;
   printf(""That 's ok! 1\n"");
   tree-&gt;vp.coordinates=(double *)malloc(d*sizeof(double));
</code></pre>

<p><code>tree</code> is not pointing to valid memory that is the reason you have undefined behavior when you dereference it.</p>

<p>Maybe you first need to allocate memory to it and <code>free</code> it later.</p>

<pre><code>   struct vptree *tree = malloc(sizeof *tree);
     ¡­
   free(tree);
</code></pre>

<p>or declare it as normal variable.</p>

<pre><code>   struct vptree tree;
   // access it using (.) operator
   tree.vp.coordinates=(double *)malloc(d*sizeof(double));
</code></pre>
",0
58729333,58724049,0,"<p>As you're learning C code I think that you should start off by taking on board a few standard working practices.
It's very evident that either your teacher hasn't really coded in a working environment or they are expecting you to spot the mistakes.
I realise that there may be issues or restrictions due to your compiler, but here are some pointers that will help in future.</p>

<p>Here are some pointers based on your code.</p>

<ol>
<li>Always initialise variables before use. If a variable can be null and that is not a valid value, check for null before use e.g. `char[] or pointer types. </li>
<li>Use <code>typedef</code> for structure declarations, this will allow the compiler to determine incorrect use through type checking during compilation.  </li>
<li>Use long, meaningful variable and function names as an aid to understand the code. </li>
<li>Indentation with brackets e.g. <code>{</code> <code>}</code>, to make code easy to understand. </li>
<li>Refrain from using literal values in code as this can lead to introduction of bugs at a later stage if a value is not changed in all cases through the code.</li>
<li>Function parameters should be definitive in type - this makes code portable between compilers, environments and easier to understand.</li>
<li>In for loops try to only use less than <code>&lt;</code> and greater than <code>&gt;</code> comparisons. </li>
<li>In 'if' statements try to place non-assignable values on the left side as this will raise a compiler warning if you type <code>=</code> instead of <code>==</code>.</li>
<li>Try and make functions re-entrant i.e. not reliant on global variables to determine their behaviour if possible, <code>void func(void)</code> should ring alarm bells. </li>
<li>Be careful when using signed values such as <code>int</code> use <code>unsigned int</code> in preference UNLESS you know that a variable will be assigned values of less than 0. </li>
<li>Declaring function parameters as <code>const</code> and then using local function variables as copies (if you wish to change their value) will make code easier to debug. </li>
<li>Switch statements should always include a <code>default:</code> to handle undetermined values.</li>
</ol>

<p></p>

<pre><code>struct stdnt /* REVIEW COMMENT: use typedef */
{
    char stName[100]; /* REVIEW COMMENT: non-literal value for 100 */
    char stRNo[100]; /* REVIEW COMMENT: Based upon later usage should this be unsigned int rather than char[] type */
    char Dept[50];
    char crse[50];
    int YoJ[4]; /* REVIEW COMMENT: this is an array of int. Either use int or char[4] */
}s[2];          /* REVIEW COMMENT: separate out declaration for clarity and use a meaningful name */
</code></pre>

<p>I'd suggest that you change it to this</p>

<pre><code>#define TEXT_LENGTH_LONG 100
#define TEXT_LENGTH_SHORT 50
#define NUMBER_OF_STUDENTS 2

typedef struct
{
    char Name[NAME_LENGTH];
    unsigned int RollNumber;
    char Department[TEXT_LENGTH_SHORT];
    char Course[TEXT_LENGTH_SHORT];
    unsigned int YearOfJoining;
}student_t;

student_t students[NUMBER_OF_STUDENTS];
</code></pre>

<p>This function code has some issues.</p>

<pre><code>void stRNm(q)/* REVIEW COMMENT: non-definitive declaration can cause confusion. Unclear function name and parameter */
{
  int i;

    for(i=0;i&lt;=1;i++)       /* REVIEW COMMENT: use of literal value  makes maintenance more difficult and can introduce bugs if the array size is changed but this is missed */
    {if(q == s[i].stRNo)    /* REVIEW COMMENT: possible type mismatch in comparison - comparing int or char[] ?*/
        {
        printf(""Student Name = %s\t"",s[i].stName); 
        printf(""Student Year of Joining = %d\t"",s[i].YoJ);
        printf(""Student Department = %s\t"",s[i].Dept);
        printf(""Student Course = %s\n"",s[i].crse);
        }
    }
}
</code></pre>

<p>becomes </p>

<pre><code>void PrintStudentInfo(const unsigned int rollNumOfStudent)/* Declaring rollNumOfStudent as const will give it compiler protection against being assigned to */
{
    int i;

    for(i=0;i&lt;NUMBER_OF_STUDENTS;i++)
    {
        if(rollNumOfStudent == students[i].RollNumber) 
        {
            printf(""Student Name = %s\t"",students[i].Name);
            printf(""Student Year of Joining = %d\t"",students[i].YearOfJoining);
            printf(""Student Department = %s\t"",students[i].Department);
            printf(""Student Course = %s\n"",students[i].Course);
        }
    }
}
</code></pre>

<p>Okay this is just a start.
There are issues in your main function relating to what I've mentioned already that are causing the odd behaviour.</p>

<p>C is a language that is so loosely defined that it is very easy to introduce bugs due to shortcuts taken in coding. 
Be pedantic.
Don't let the compiler make the decisions.
Be sure that the data types of variables are what you want rather than what the compiler determines. </p>

<p><strong>Edit</strong>
Taking into account my comments about data types. 
This line <code>if(year == s[i].YoJ)</code> is performing the following <code>if(int == int[4])</code></p>
",8
58697646,58697202,1,"<blockquote>
  <p>I am trying to concatenate/append a char * and char.</p>
</blockquote>

<p>There are several options.</p>

<ol>
<li><p>Assuming your string is changeable and the underlying array has enough space:</p>

<pre><code>char array[100] = ""abracadabra"";
char suffix = '$';

size_t alen = strlen(array);
array[alen] = suffix;
array[alen+1] = '\0';
</code></pre></li>
<li><p>Assuming your string is malloc'd and needs to grow:</p>

<pre><code>char *array = malloc(12);
strcpy(array, ""abracadabra"");
char suffix = '$';

size_t alen = strlen(array);
char *tmp = realloc(array, alen + 2); // space for suffix and '\0'
if (tmp) { array = tmp; }
else { fprintf(stderr, ""No memory.\n""); exit(EXIT_FAILURE); }

array[alen] = suffix;
array[alen+1] = '\0';

// remember to free(array) later
</code></pre></li>
<li><p>Assuming the original string is read-only and needs to be copied somewhere</p>

<pre><code>char *text = ""abracadabra"":
char suffix = '$';

char *tmp = malloc(strlen(text) + 2); // add space for suffix and '\0'
sprintf(tmp, ""%s%c"", text, suffix);

// remember to free(tmp) later
</code></pre></li>
</ol>
",3
58751868,58751830,1,"<p>Replace</p>

<pre><code>printf(""|%6D|"", d);
</code></pre>

<p>with</p>

<pre><code>printf(""|%d|"", d);
</code></pre>

<p><code>%d</code> is correct format for signed integers. Local PC and online IDE answers differ because you invoked undefined behavior.</p>
",6
58763259,58763200,3,"<p>The most common mentioned method is:</p>

<pre><code>y ^= x;
x ^= y;
y ^= x;
</code></pre>

<p>An alternative is to use addition and subtraction instead of XOR; but that's messy due to the risk of overflows.</p>

<p><em>Note: To be precise; XOR causes undefined behavior for negative values (but that can be prevented with simple casts to unsigned and back to signed); and addition/subtraction can cause overflow which is also undefined behavior, but there's no easy fix for that.</em></p>

<p>Of course no sane person would ever do this in real code (it's faster and cheaper to  use a temporary variable).</p>
",2
59036084,59035973,1,"<pre><code>num_count == 0 || up_count == 0 || down_count = 0
</code></pre>

<p>should be</p>

<pre><code>num_count == 0 || up_count == 0 || down_count == 0
</code></pre>

<hr>

<p>To explain the error, the statement you have is equivalent to the following:</p>

<pre><code>( num_count == 0 || up_count == 0 || down_count ) = 0
</code></pre>

<p>An expression that can be found on the left-hand side of an assignment is called an lvalue, and the expression in parens is not a valid lvalue.</p>
",0
59015815,59015711,0,"<blockquote>
  <p>So i just think that if i handle the seg. fault signal in os level may
  be i can fix this bug.</p>
</blockquote>

<p>It does not seem like a good idea at all, a <code>SIGSEGV</code> handler ??is not intended to ignore or try to fix the error, they are used to consistently exit your process, e.g. remove the used heap so that there are no memory leaks, to write in a log reporting the error ...</p>

<p>In addition, in the POSIX standard:</p>

<blockquote>
  <p>The behavior of a process is undefined after it returns normally from
  a signal-catching function for a [XSI] SIGBUS, SIGFPE, SIGILL, or
  SIGSEGV signal that was not generated by kill(), [RTS] sigqueue(), or
  raise().</p>
</blockquote>
",0
59145915,59144970,0,"<p>Here you go Alireza.
The problems are several, but the main one was the missing ""else"" in your check to see which calculator sequencing to use.</p>

<pre><code>int calc(int x, char op, int y) {

    if (op == '+') {
        return (x+y);
    }
    if (op == '-') {

        return (x-y);
    }
    if (op == 't') {

        return (x*y);
    }
    if (op == '/') {
        return (x/y);
    }

    printf(""Unknown operator!""); // added error check
}

int main(int argc, char *argv[]) {

    int a,b,c,result,doOp;
    char op1, op2;

    if (argc == 4 || argc == 6) {

        a = atoi(argv[1]);
        b = atoi(argv[3]);
        op1 = *argv[2];

    } else {
        printf(""Wrong number of arguments!"");
        return 0;
    }

    if (argc == 6) {
        c = atoi(argv[5]);
        op2 = *argv[4];

        if ((op1 == '+' || op1 == '-') &amp;&amp; (op2 == '/' || op2 == 't')) {

            result = calc(a, op1, calc(b, op2, c));
            printf(""%d"", result);
        }
        // added else if
        else if ((op2 == '+' || op2 == '-') &amp;&amp; (op1 == '/' || op1 == 't')) {

            result = calc((calc(a, op1, b)), op2, c);
            printf(""%d"", result);
        }
        else {
            result = calc((calc(a, op1, b)), op2, c);
            printf(""%d"", result);
        }
    }

    if (argc == 4) {

        result = calc(a, op1, b);
        printf(""%d"", result);
    }

    return 0;
}
</code></pre>
",0
58416411,58415571,1,"<blockquote>
  <p>I was expecting that the <code>f(z)</code> function would go to the would go to the <code>f</code> and increment increment <code>w</code> by 5, <code>x</code> by 6, <code>y</code> by 7 and <code>z</code> would stay 1 since all global variables are overwritten in the <code>main</code> function. </p>
</blockquote>

<p>Yes, this is <em>exactly</em> what is happening. You just need to find out <em>what is <code>w</code> and <code>y</code></em>. </p>

<p>This is not called <strong>overriding</strong> but <strong>shadowing</strong>. You can make it visible with e.g. using GCC with <code>-Wshadow</code> argument (<a href=""https://godbolt.org/z/NNMj8a"" rel=""nofollow noreferrer"">Godbolt</a>):</p>

<pre><code>&lt;source&gt;: In function 'f':

&lt;source&gt;:4:12: warning: declaration of 'y' shadows a global declaration [-Wshadow]

    4 | void f(int y){
      |        ~~~~^

&lt;source&gt;:2:11: note: shadowed declaration is here

    2 | int w, x, y, z = 10;
      |           ^

&lt;source&gt;: In function 'main':

&lt;source&gt;:11:9: warning: declaration of 'w' shadows a global declaration [-Wshadow]

   11 |     int w;
      |         ^

&lt;source&gt;:2:5: note: shadowed declaration is here

    2 | int w, x, y, z = 10;
      |     ^

Compiler returned: 0
</code></pre>

<p>The shadowing variable is present <em>only</em> in the scope where it is declared and after its declaration within that <em>scope</em> you can use that name refer to only that object, not the shadowed one.</p>
",0
58416071,58415571,1,"<p>For W : since you defined a local variable int w the actions outside main doesn't affect its value</p>

<p>For X : the variable is global and value is modified in main (1) then f(+6 => 7)</p>

<p>For Y : since you defined a parameter named y in f() the global variable with the same name won't be used</p>

<p>For Z : since your parameter is a int (and not a pointer) the modification on the parameter won't be kept once the treatment leaves f() (the parameter act as a copy z).</p>

<p>The behavior is clearer if you write it like this : </p>

<pre><code>#include &lt;stdio.h&gt;
int global_w, global_x, global_y, global_z = 10;

void f(int param_y) {
    global_w += 5;
    global_x += 6;
    param_y += 7;
}

int main(void) {
    int local_w;

    local_w = global_x = global_y = global_z = 1;
    f(global_z);
    printf (""%d %d %d %d\n"", local_w, global_x, global_y, global_z);
    return 0; 
}
</code></pre>
",0
58415707,58415571,3,"<p>In main there is declared only one local variable <code>w</code>.</p>

<p>The global variables <code>x, y, z</code> are reinitialized in this statement</p>

<pre><code>w = x = y = z = 1;
</code></pre>

<p>that is they are set to 1.</p>

<p>Within the function</p>

<pre><code>void f(int y){
w += 5;
x += 6;
y + = 7;
}
</code></pre>

<p>there are used all global variables including <code>w</code> and <code>x</code> and the parameter (local variable of the function) y.</p>

<p>So w is set to 5, x is set to 7 ( 1 + 6 ) and the parameter y is set to 8 ( 1 + 7 ).</p>

<p>Changing the parameter does not influence on the value of the global variable y.</p>

<p>In this call in main</p>

<pre><code>printf (""%d %d %d %d\n"", w, x, y, z);
</code></pre>

<p>there is used the local variable w that was early set to 1.</p>

<p>SO the output will be</p>

<pre><code>1 7 1 1
</code></pre>
",2
59010095,59009899,7,"<p>Here's the part where you calculate the sum of even numbers, which works:</p>

<pre><code>    if(count[n]%2==0)
    {
        even_lister[i]=count[n];
        sumEven+=even_lister[i];
    }
</code></pre>

<p>Now here's the part where you calculate the sum of odd numbers, which doesn't:</p>

<pre><code>    else //OddSummation      
    {
        int odd_lister[i], sumOdd, i=0;

        odd_lister[i]=count[n];
        sumOdd+=odd_lister[i];

    }
</code></pre>

<p>Do you see the difference? There's an extra line in the second one. In the version that doesn't work, you re-declared some local variables and assigned your values to those local variables. That's <em>why</em> it doesn't work. You didn't do anything with the ""original"" variables in a higher-up scope that you later print to the screen.</p>

<p>Furthermore, both parts are actually broken because you never initialised either <code>sumEven</code> or <code>sumOdd</code> to <code>0</code>, so their values are unspecified, and you're adding to unspecified values to create other unspecified values. Whether this bug creates an observable symptom or not is undefined.</p>

<p>Another problem is that you declare your arrays like this:</p>

<pre><code>int even_lister[i];
</code></pre>

<p>but <code>i</code> is a variable that you set to <code>0</code> and never changed. So those arrays have <em>zero length</em> and every single access to them is illegal. Perhaps you meant to use <code>n</code> instead?</p>

<p>You really need to turn on your compiler warnings and read your code more carefully.</p>
",2
58478355,58478180,1,"<p>You need to use a different name for the parameter array and the local array in the function.</p>

<p>Also, the function should take another parameter, the digit that you're trying to display.</p>

<p>You should then declare a 2-dimensional array, and you can use the digit as an index into it.</p>

<pre><code>void SegmentWrite (int SegmentDigits[7], int digit){
    int allSegmentDigits[][7] = {
        {1,1,1,1,1,1,0},//0
        {0,1,1,0,0,0,0},//1
        {1,1,0,1,1,0,1},//2
        {1,1,1,1,0,0,1},//3
        {0,1,1,0,0,1,1},//4
        {1,0,1,1,0,1,1},//5
        {1,0,1,1,1,1,1},//6
        {1,1,1,0,0,0,0},//7
        {1,1,1,1,1,1,1},//8
        {1,1,1,1,0,1,1}} //9
    memcpy(SegmentDigits, allSegmentDigits[digit], sizeof allSegmentDigits[0]);
}
</code></pre>
",3
59003736,59003618,4,"<p>You are accessing data outside its allocated buffer whenever lowerBound doesn't start with 0.</p>

<pre><code>info[i].lineNumber = i;
</code></pre>

<p>Ideally, you should become...</p>

<pre><code>info[i - lowerBound].lineNumber = i;
</code></pre>

<p>To ensure that the indexing starts at 0. Further, your window between <code>lowerBound</code> and <code>upperBound</code> is <em>inclusive</em>. That means it includes <em>both</em> ending boundaries. Therefore, <code>totalData</code> is undersized by one element. Even if you fix the indexing problem, your code will <em>still</em> be wrong with this:</p>

<pre><code>int totalData = (upperBound - lowerBound) + 1;
</code></pre>

<p>Failing to do both of the above causes your code to invoke <em>undefined behavior</em> (UB), and thus unpredictable results thereafter. It may even <em>appear</em> to work. That, however, is a red herring when your code has UB. Don't confuse <em>defined</em> behavior with <em>observed</em> behavior. You can trust the latter only once you have the former; the two are not synonymous.</p>
",0
58576616,58573334,0,"<p>You should put your return 0 statement after checking if count == maxguesses.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#define boolean

int main()
{

    int enternumber = -1;
    int count = 0;
    int maxguesses = 10;
    int guessing;
    int i;
    bool currentguesses = false;


    while (1) {
        count += 1;
        printf(""Player 1, enter a number between 1 and 1000\n"");
        scanf(""%d"", &amp;enternumber);

        if (enternumber &gt; 1000) {
            printf(""That number is out of range\n"");
        }

        else {
            printf(""That number is in the range\n"");
            break;
        }
    }

    printf(""Player 2, you have %d tries remaining\n"", maxguesses);

    for (i = 0; i &lt; maxguesses; i++) {
        printf(""Enter your guess\n"");
        scanf(""%d"", &amp;guessing);

        if (enternumber == guessing) {
            printf(""Player 2 wins.\n"");
            break;
        }
        else {
            printf(""Too %s.\n"", enternumber &lt; guessing ? ""high"" : ""low"");
        }
    }


    if (count == maxguesses) {
        printf(""Player 1 wins"");
    }
    return 0;
}
</code></pre>
",0
59235484,59235038,2,"<p>This solution works for all your test cases (positive and negative numbers), for numbers greater than 100000 and for zero as well:</p>

<pre class=""lang-c prettyprint-override""><code>#include ""stdio.h""
#include ""stdlib.h""

const int SHIFT = 3;

int main() {
    int number, abs_number, is_negative, operation, result, decimal_place;

    do {
        result = 0;
        decimal_place = 1;

        printf(""Enter the number: "");
        scanf(""%d"", &amp;number);

        // remove the sign before entering the cipher logic...
        abs_number = abs(number);
        // ...but do remember it so we can add it back later
        is_negative = number &lt; 0;

        // from least to most significant decimal place
        do {
            // cipher the digit and accumulate it in the result
            result += (((abs_number % 10) + SHIFT) % 10) * decimal_place;
            // remove the consumed digit from the input variable
            abs_number /= 10;
            // move to the next decimal place
            decimal_place *= 10;
        } while (abs_number &gt; 0);

        printf(""Result is: %s%d\n"", is_negative ? ""-"" : """", result);

        printf(""Press 1 to continue or 2 for exit."");
        scanf(""%d"", &amp;operation);

    } while (operation == 1);  // repeat if user requested another cipher

    return 0;
}
</code></pre>

<p>Some things to note in your original code:</p>

<ul>
<li>your code doesn't loop. A <code>switch</code> case won't help you repeat the operation. You need a <code>while</code> loop for that;</li>
<li>it doesn't  work for larger numbers: you would have to add an extra line of code to handle numbers greater than 100000... which leads to my next point:</li>
<li>you have repeated code: your logic is duplicated in two different ways. The first one is the iteration body. Even if you replaced the <code>switch</code> statement with a <code>while</code> loop, your first iteration is unnecessarily unrolled outside of the loop. The second one is the way you handle each decimal place of the input number. Wouldn't it be better if you had a same code snippet to handle any of the decimal places? Duplicating code is considered bad practice. It makes the code bigger, it's harder to maintain and easy for duplicated code to get changed in only one place and not in the other. You always want to avoid duplicating code.</li>
</ul>
",0
59240258,59235038,1,"<p>Unless the length of user input is not recorded, ""Caesar's cipher for numbers"" is not reversalable.  With input like <code>""777""</code>, <code>""7""</code>, <code>""000""</code>, <code>""0""</code>, the output needs to be 4 distinctive answers in order to convert back.</p>

<p>To maintain something of a numeric internal representation, consider using <code>""%n""</code> to keep track of the length of user input.</p>

<pre><code>static void print_digits(int a, int length, int offset) {
  if (length &gt; 1) {
    print_digits(a/10, length-1);
  }
  putchar((a+offset)%10 + '0');
}
</code></pre>

<p>...</p>

<pre><code>#define OFFSET 3

int number;
int n1, n2;
int offset = OFFSET % 10;
if (offset &lt; 10) offset += 10; // Handle negative OFFSET

printf(""Enter the number: "");
if (scanf("" %n%d%n"", &amp;n1, &amp;number, &amp;n2) == 1) {
  int length = n2 - n1;
  if (number &lt; 0) {
    putchar('-');
    number = -number;
    length--;
  }
  print_digits(number, length, offset);
}
</code></pre>

<p>Above code has trouble with select input magnitudes above <code>INT_MAX/10</code> or so.  To handle large integers, consider moving to string processing.</p>
",0
59235265,59235120,3,"<p>First of all, let's rewrite your code a little bit, for the sake of removing some confusion (because to the uninitiated there are few things going on here, that might seem similar, but are not).</p>

<blockquote>
<pre><code>#include &lt;string.h&gt;

void print_as_according_to_strlen(char *n) {
    for (int i=0; i &lt; strlen(newstring); i++) {
        printf(""a"");
    }
}
</code></pre>
</blockquote>

<p>There, this is the relevant part. If you look at the definition of <code>strlen</code> you'll see, that it returns a value of type <code>size_t</code></p>

<blockquote>
<pre><code>size_t strlen(const char *s);
</code></pre>
  
  <p>Return the length of the string s.</p>
</blockquote>

<p><code>size_t</code> is an <em>unsigned</em> type. C and C++ have certain rules by which integer values are implicited converted to a ""common"" type when used together in an operation. These are the so called <em>""integer promotion rules""</em> ¨C those are important to know, and you absolutely must learn them.</p>

<p>One of those rules is, that if you make a <em>signed</em> integer ""interact"" with an <em>unsigned</em> integer, the promoted type will be <em>unsigned</em> as well. And of course if you attempt to promote a negative value to an unsigned type, the result will be something different.</p>

<p>Now with C things become tricky here, because there are some (actually the majority of cases) where attempting to do that invokes <em>undefined behavior</em>, i.e. anything may happen. There are however a few exceptions, where it's actually well behaved (for example if you have two <em>unsigned</em> variables <code>unsigned a = 3</code> and <code>unsigned b = 5</code> the result of the operation <code>a-b</code> is actually a well defined value, because unsigned overflow is well defined, and the result is <code>UINT_MAX - (b-a)</code>).</p>

<p>The bottom line for you is: You must rewrite your code so that the comparison promotes to either a signed comparison, or instead of starting from <code>-1</code>, go to <code>strlen(¡­)+1</code>. Instead of using an <code>int</code> I suggest you use a <code>ptrdiff_t</code> instead, because the size of an int may, or may not, be sufficient to hold the result of <code>strlen</code>. And by happenstance (not of C, but how modern OSs manage memory) <code>strlen</code> will never return a value that could overflow <code>ptrdiff_t</code></p>

<pre><code>ptrdiff_t len = strlen(newstring);
for(ptrdiff_t i=-1; i &lt; len ; i++){
</code></pre>
",0
59306740,59306595,0,"<p><strong><em>Question 1:</em></strong><br>
<em>Why there are no worries about bounds violation? As I understand it, array index = 0, 1, ..., MAXCOL-1 and the value of line[pos] (pos = MAXCOL) is undefined.</em></p>

<p>Yes, there are concerns about bounds violation, but this note is accurate.  You need to make the distinction between the value used to <em>define</em> an array, such as <code>MAXCOL</code>, and the values used to <em>access</em> array elements: <code>0</code> through <code>(MAXCOL-1)</code>.  As you probably know, C uses zero based indexing for accessing elements of an array.  This is reflected in the above statement.  The phrase <em>pos == MAXCOL</em> is synonymous in this context with <em>count == MAXCOL</em>:</p>

<pre><code>Array index -&gt;  |0|1|2|3|4|5|6|7|...|MAXCOL-1|

pos or count -&gt; |1|2|3|4|5|6|7|8|...|MAXCOL|  
</code></pre>

<p>Or in other words, the zeroth <em>index</em> is the first <em>position</em>, and the first <em>index</em> is the second <em>position</em>, and so on.  Its just semantics.</p>

<p><strong><em>Question 2:</em></strong><br>
When code uses a series of <code>if-then-else</code> constructs (or similar) as is done here, it is always a good idea to explicitly handle the case where the value being tested (i.e. <code>pos</code>) is advanced beyond the limit (i.e. <code>MAXCOL</code>) in one of the other cases.  If that were ever true,  then in this case <code>(++pos == MAXCOL)</code> could result in an infinite loop, where <code>(++pos &gt;= MAXCOL)</code> would catch it.</p>

<p><strong><em>Question 3:</em></strong><br>
<code>if (pos &lt;= 0 || pos &gt;= MAXCOL)</code>  is a condition that looks for the value being tested to be outside the bounds of the working region, while <code>if (pos == MAXCOL)</code> is simply checking that <code>pos</code> is out of bounds on the upper end.  Again, including a test for the lower bound is prudent, and would be considered by most a good programming practice.<br>
Note that it might be acceptable to use <code>if (pos == MAXCOL)</code> iff it were not possible for the value <code>pos</code> to be negative.  i.e. perhaps it is defined as an <code>unsigned char</code>.</p>
",0
59366346,59366283,11,"<p>This is <a href=""https://en.wikipedia.org/wiki/Cargo_cult_programming"" rel=""noreferrer"">cargo cult programming</a>. <code>#define</code> does not ""make things go faster"", it inlines code, and <em>sometimes</em> inline code is the faster way of doing things.</p>

<p>Your variable names are utterly opaque, you're doing things like using a ternary for no real reason other than to look cool. This code is ""minimal"" as in maybe it works (there's no tests) and in terms of character count, but is otherwise <strong>completely unmaintanable</strong>.</p>

<p>I say this as someone who's written a lot of (sometimes deliberately) opaque Perl code: <strong>DON'T</strong>.</p>

<p>When writing code keep these points in mind:</p>

<ul>
<li>Declare <strong>functions and variables</strong> with <em>meaningful names</em>. Observe the <em>Principle of Least Surprise</em>, that is a function called <code>is_alive</code> should not format the hard drive, send an angry drunk email to your boss, etc., it should tell you if something's alive, and <strong>that's it</strong>. What does a function called <code>rst</code> do? It's a <em>surprise!</em></li>
<li>Do it the <em>standard way first</em>. Fight the tug of <em>Premature Optimization</em>. You call these functions <em>once</em> and even if you called them a million times, C on modern hardware is so ridiculously fast that you would be hard pressed to even benchmark how long this takes by hand with a stopwatch. It'd be instantaneous. <strong>Don't optimize what you can't measure as being slow</strong>.</li>
<li>Macros need to be defined <em>carefully</em>, not just slapdash. They get <em>interpolated</em> which means different rules apply. <code>while(i--&gt;0)</code> breaks completely if <code>i</code> is <code>x+2</code> for whatever reason. Learn how they work, then write them properly <em>if and when</em> you actually need a macro. <strong>Be aware of syntax complications</strong>.</li>
</ul>

<p>Writing code that's simple yet effective, that's boring in that it contains no surprises, is not always easy, but it's always <em>necessary</em>. When you mature as a developer you'll write code that's increasingly boring, increasingly ordinary, because you'll be able to visualize simple solutions to complex problems in a way that avoids all the unnecessary fanfare and bravado of solutions like this.</p>

<p>All the fancy tricks here have saved <em>nothing</em>. When this code is compiled with optimizations the compiler will decide which functions to inline, and because there's IO involved, any time savings that <em>could</em> have resulted from the <code>#define</code> trickery are completely lost because of the amount of time the kernel will have to spend shunting data back and forth from kernel to userspace. Your changes will be significantly less than statistical noise.</p>

<p>If you want your program to be fast you need to know what sorts of things will make it slow. For example, <code>getch()</code> is actually really <em>slow</em> as each call requires a fairly painful excursion through the kernel. No amount of optimizing or macro magic can get around that. Instead, read it in all at once into a buffer and parse that using simple pointer comparisons:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
  // Maximum size of file is:
  // + N to NNNNN (1-5 byte + newline = 6 bytes)
  // + 10,000 entries (letter + newline = 2 bytes each)
  // + Don't care about NUL terminator
  size_t max_size = 10000 * 2 + 6;
  char* raw = malloc(max_size);

  fread(raw, 1, max_size, stdin);

  char* p = raw;

  size_t count = atoi(p);
  while (*(p++) != '\n');

  int score = 0;

  for (int i = 0; i &lt; count; ++i) {
    score += p[i * 2] == p[count * 2 + i * 2];
  }

  printf(""%d\n"", score);

  free(raw);

  return 0;
}
</code></pre>

<p>On Windows you'll need to adjust this to handle CRLF instead of just LF, but the same idea works.</p>

<p><code>getch()</code> is brutal when reading lots of data. If you don't believe me, write a test program where you copy a large (~1GB) file using that approach, then compare to a more reasonable strategy of reading data in ~64KB chunks.</p>

<p>In a program where you're only reading a trivial amount of data, and 10K entries is inconsequential these days, the difference in performance here is academic, but the approach of dumping it into a buffer and manipulating it there saves a ton of fuss with decoding things that don't need to be decoded, stripping this problem down to the essentials: Comparing different parts of the string to other parts and counting the matches.</p>
",4
58378650,58378593,3,"<p>You need to pass the address of the variable, otherwise how is <code>scanf()</code> supposed to write to it?</p>

<p>You need:</p>

<pre><code>scanf(""%lf"", &amp;temp);
</code></pre>

<p>Also check the return value, I/O can fail.</p>
",0
58335808,58335456,0,"<p>The code works fine looks fine to me. About your question regarding <code>malloc()</code> and <code>free()</code> you are freeing all the memory you allocate, so, that is what you have to do.
My only further comment would be, you do not need to cast the return value from <code>malloc()</code>. You can then replace </p>

<pre><code>num_ptr[i] = (int*)malloc(sizeof(int)*num);
</code></pre>

<p>by </p>

<pre><code>num_ptr[i] = malloc(sizeof(int)*num);
</code></pre>
",3
58334449,58334006,2,"<p>For such a simple problem, you can make the function iterative.</p>

<pre><code>#include &lt;stdint.h&gt;

uint64_t foo (int n)
{
    if (n == 0)
        return 0;
    else if (n == 1)
        return 1;
    else if (n == 2)
        return 2;
    else
    {
        uint64_t a = 0, b = 1, c = 2;
        uint64_t ret;
        for (int i = 2; i&lt;n; i++)
        {
            ret = a + 2*b + c - 2;
            a = b;
            b = c;
            c = ret;
        }
        return (ret);
    }
}
</code></pre>

<p>If you have to use recursion, you can significantly improve runtime with memoisation. In this case, you need an extra array to store the results of already calculated values.</p>

<pre><code>uint64_t memo[101];  // size this array to the maximum value of n needed to be calculated.

uint64_t foo(int n) {
  uint64_t a;
  if (n==0)
  {
    return 0;
  }
  else if(n==1)
  {
    return 1;
  }
  else if(n==2)
  {
    return 2;
  }

  else
  {
    if (memo[n] == 0)
    {
        a = foo(n-1)-2*foo(n-2)+foo(n-3)-2;
        memo[n] = a;
    }
    else
    {
        a = memo[n];
    }
    return a;    
  }
}
</code></pre>
",1
58741403,58741334,1,"<p>Nope. Best you can do is some way to map an id to a particular struct instance. An array is the simple approach for small amounts of data. A hashmap is a more general way to do it.</p>
",0
58598626,58597992,1,"<blockquote>
<strong>5.1.2.2.1 Program startup</strong><br><br>
1 The function called at program startup is named <code><strong>main</strong></code>. The implementation declares no
prototype for this function. It shall be defined with a return type of int and with no
parameters:<br><br>
<pre><code>    int main(void) { /* ... */ }</code></pre>
or with two parameters (referred to here as <code><strong>argc</strong></code> and <code><strong>argv</strong></code>, though any names may be
used, as they are local to the function in which they are declared):<br><br>
<pre><code>    int main(int argc, char *argv[]) { /* ... */ }</code></pre>
or equivalent;<sup>10)</sup> or in some other implementation-defined manner.
<hr>
<sup>10) Thus, <code><strong>int</strong></code> can be replaced by a typedef name defined as <code><strong>int</strong></code>, or the type of <strong><code>argv</code></strong> can be written as
<strong><code>char ** argv</code></strong>, and so on.</sup>
</blockquote>

<p><sup><em><a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C 2011 Online Draft</a></em></sup></p>

<p><code>main()</code> is equivalent to <code>int main(void)</code>.  Under earlier versions of the language, if you defined a function without an explicit return type, the compiler assumed it returned <code>int</code>.  Also, if you define a function without any parameters, that means the function takes <em>no</em> parameters.  Implicit typing is no longer allowed, and using prototype syntax allows you to catch errors in the number and types of arguments at compile time, so this form should no longer be used.</p>

<p><code>void main()</code> is not standard, and should not be used unless your implementation <em>explicitly</em> documents it as a valid signature for <code>main</code> (""or in some other implementation-defined manner"")<sup>1</sup>.  Otherwise, using it results in <em>undefined behavior</em>, which may result in your code misbehaving on startup or exit.  There are platforms where it runs with no <em>apparent</em> issues, but you shouldn't rely on that being true.  </p>

<blockquote>
<strong>5.1.2.2.3 Program termination</strong><br><br>
1 If the return type of the <code><strong>main</strong></code> function is a type compatible with <strong><code>int</code></strong>, a return from the
initial call to the <strong><code>main</code></strong> function is equivalent to calling the <strong><code>exit</code></strong> function with the value
returned by the <strong><code>main</code></strong> function as its argument;<sup>11)</sup> reaching the <strong><code>}</code></strong> that terminates the
<strong><code>main</code></strong> function returns a value of 0. If the return type is not compatible with <strong><code>int</code></strong>, the
termination status returned to the host environment is unspecified.
<hr>
<sup>11) In accordance with 6.2.4, the lifetimes of objects with automatic storage duration declared in <code><strong>main</strong></code>
will have ended in the former case, even where they would not have in the latter.</sup>
</blockquote>

<p>C programs return a status code to the runtime environment - on *nix and similar platforms, a return code of 0 indicates successful, normal program termination.  <code>stdlib.h</code> defines the macros <code>EXIT_SUCCESS</code> and <code>EXIT_FAILURE</code>, which should be used instead of literal numeric values:</p>

<pre><code>#include &lt;stdlib.h&gt;
...
int main( void )
{
  ...
  if ( something_bad_happens )
    return EXIT_FAILURE;
  ...
  return EXIT_SUCCESS;
}
</code></pre>

<p><hr>
<sup></p>

<ol>
<li>Even then, I wouldn't use it, because it's guaranteed to be non-portable.
</ol>

<p></sup></p>
",0
58593765,58593016,0,"<p>Just print some spaces before the first number in each row</p>

<pre><code>    // ...
    for (r = 0; r &lt; rows; r++) {
        printsomespaces(r, rows); // prints some spaces depending on current row and total rows
        for (c = 0; c &lt; r; +c++) {
            printf(""%d "", number++);
        }
        printf(""\n"");
    }
    // ...
</code></pre>

<p>If you can't write your own function (no <code>printsomespaces</code>) use a loop instead:</p>

<pre><code>        //...
        //printsomespaces(r, rows);
        for (int space = 0; space &lt; XXXXXXXX; space++) putchar(' ');
        //...
</code></pre>

<p>where <code>XXXXXXXX</code> is some calculation using <code>r</code> and <code>rows</code>.<br>
Try (untested) <code>2 * (rows - r)</code> (2 is the width of each number: 1 for the number + 1 for the space).</p>
",3
58602602,58593016,0,"<blockquote>
  <p>i haven't learnt how to make my own functions yet. isnt there a way to accomplish this only by using loops?</p>
</blockquote>

<p>There is. A main problem of this exercise is to compute the needed width of each column, which of course depends on the number in the bottom row. The count of digits of a number can be determined in various ways; perhaps the easiest is via the <code>snprintf(char *s, size_t n, const char *format, ...)</code> function, which</p>

<blockquote>
  <p>¡­ returns the number of characters that would have been written
  had <code>n</code> been sufficiently large¡­</p>
  
  <p>If <code>n</code> is zero, nothing is written,
  and <code>s</code> may be a null pointer.</p>
</blockquote>

<pre><code>    // we need to compute the width the of widest number of each column
    int width[rows];
    const int max = rows*(rows+1)/2;    // the greatest number
    for (c=1; c&lt;=rows; ++c) // see how many characters will be written
        width[c-1] = snprintf(NULL, 0, ""%d "", max-rows+c);
    for (r=1; r&lt;=rows; ++r, puts(""""))
        for (c=1; c&lt;=rows; ++c)
            if (c &lt;= rows-r)    // here comes an empty cell in this row
                printf(""%-*c"", width[c-1], ' ');
            else
                printf(""%-*d"", width[c-1], number++);
</code></pre>
",0
58768458,58768375,3,"<p><code>rand() % 6</code> is a number in the interval 0-5.<br>
If you add one to any number in that interval, you get a number in the interval 1-6.</p>

<p>On the other hand, <code>rand() % 7</code> is a number in the interval 0-6.</p>
",0
58776917,58776758,0,"<p>Look at the way you call your function:</p>

<pre><code>prints(5);
</code></pre>

<p>You tell the function you're going to provide 5 integers as arguments, but omit all those integers. It's no surprise that you get funny results. Use something like this, which provides 5 integer arguments:</p>

<pre><code>prints(5, 0, -37, 248, 1239121, -91124887);
</code></pre>

<p>For example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

static
void prints(int n, ...)
{
    va_list args;
    va_start(args, n);
    for (int i = 0; i &lt; n; i++)
    {
        printf(""%d\n"", va_arg(args, int));
    }
    va_end(args);
}

int main(void)
{
    prints(5, 0, -37, 248, 1239121, -91124887);
    putchar('\n');
    prints(3, 99, 100, 101);
    putchar('\n');
    prints(1, 3141592);
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>0
-37
248
1239121
-91124887

99
100
101

3141592
</code></pre>
",1
58785274,58784935,3,"<p>The API complications may be hidden with friendly functions:</p>

<pre><code>typedef enum { Median, Average } CentralTendencyMeasure;

find_median(parameters)
{
    find_general(parameters, Median);
}

find_average(parameters)
{
     find_general(parameters, Average);
}

find_general(parameters, CentralTendencyMeasure Measure)
{
    Some code...
    switch (Measure)
    {
        case Median:  best_windows_median (parameters); break;
        case Average: best_windows_average(parameters); break;
        default:      Report error.
    }
    Some code...
}
</code></pre>

<p>Expose only <code>find_median</code> and <code>find_average</code> to the client, so they do not see <code>CentralTendencyMeasure</code> or <code>find_general</code>.</p>
",0
58784981,58784935,3,"<p>There are several ways to achieve this, including passing a value to switch which calculation is used, and passing a function pointer (this second one is the essence of dependency-inversion, if that's of interest).</p>

<p>So either:</p>

<pre><code>find_average(data parameters, avg_type) {
    same code
    switch (avg_type) {
    case AVG_MEAN:
        best_windows_mean(data parameters);
        break;
    case AVG_MEDIAN:
        best_windows_median(data parameters);
        break;
    case AVG_MODE:
        ...
    default:
        report unrecognised option;
    }
    same code;
}
</code></pre>

<p>or</p>

<pre><code>find_average(data parameters, best_windows_function) {
    same code;
    best_windows_function(data parameters);
    same code;
}
</code></pre>

<p>Which one to use depends on whether you're comfortable with function pointers and whichever one you like best, really.</p>
",2
59128043,59128002,7,"<p>Change <code>c[i]=='x'</code> to <code>c[i]==x</code></p>
<p>You want to compare with the variable x, not the character constant 'x'</p>
",2
59016948,59016502,-1,"<p>Considering that you will never be certain that a arbitrary number is an integer (unless you check the input and treat it as a string).</p>

<p>The best approximation would be to check that the value compare to supposed the integer value would be lower than the <a href=""https://en.wikipedia.org/wiki/Machine_epsilon"" rel=""nofollow noreferrer"">machine epsilon</a></p>

<pre><code>bool doubleMaybeInteger(double input) {
    return ((input - floor(input)) &lt; DBL_EPSILON)
}

</code></pre>
",0
59016762,59016502,-1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int i, n, ch, done;

    n = scanf(""%d"", &amp;i);
    if (n == 1) {
        ch = getchar();
        done = ch != '.';
        ungetc(ch, stdin);
    } else {
        done = 0;
    }
    if (done) {
        puts(""this is an int"");
    } else {
        puts(""this is not an int"");
    }
    return 0;
}
</code></pre>
",5
59023098,59023000,1,"<p>Hints only since it's classwork and you'll become a better developer if you nut it out yourself :-)</p>

<p>The idea is to scan all the numbers and remember which was the largest and smallest. For the average, you also need to accumulate a sum of all those number along with the count.</p>

<p>For example, consider the following pseudo-code:</p>

<pre><code>def getMinMaxAvg(inputFile):
    set sum, count, smallest, largest all to zero
    set value to inputFile.getNumber()
    if none available, return error indication
    while true
        if count is zero or value is less than smallest:
            set smallest to value
        if count is zero or value is greater than largest:
            set largest to value
        add value to sum
        add one to count
        set value to inputFile.getNumber()
        if none available, return (smallest, largest, sum / count)
</code></pre>

<p>That's basically the flow you need. The first important thing here is the <code>inputFile.getNumber()</code>, the thing that gets your numbers. Your use of <code>fgetc</code> will input single characters, you'll probably want to use <code>fscanf</code> with the <code>""%d""</code> specifier, so you can input integers.</p>

<p>Just make sure you check the return value to ensure it worked okay:</p>

<pre><code>int myInt; FILE *fileHandle = fopen(...);
if (fscanf(fileHandle, ""%d"", &amp;myInt) != 1)
    // Did not scan properly, needs to be handled.
// Now, myInt contains your value.
</code></pre>
",1
59448144,59448119,7,"<p><code>printnumber(5)</code> means to call <code>printnumber</code> immediately and pass it 5.  You want to pass <code>printnumber</code> and <code>5</code> separately as two arguments</p>

<pre><code>void printNumber(int nbr)
{
    printf(""%d\n"", nbr);
}

// void (*f)(int) is a pointer to a function that takes an int
// arg is the int to pass in
void myFunction(void (*f)(int), int arg)
{
    for(int i = 0; i &lt; 5; i++)
    {
        // call f and pass in arg
        (*f)(arg);
    }
}

int main(void)
{
    // pass the function and the arg to use
    myFunction(printNumber, 5);
    return (0);
}
</code></pre>
",1
59448152,59448119,3,"<p>You need another argument.</p>

<pre><code>void printNumber(int nbr)
{
    printf(""%d\n"", nbr);
}

void myFunction(void (*f)(int), int Arg)
{
    for(int i = 0; i &lt; 5; i++)
    {
        (*f)(Arg);
    }
}

int main(void)
{
    myFunction(printNumber, 42);
    return (0);
}
</code></pre>

<p>The parameter declaration <code>void (*f)(int)</code> only says that the function pointed to by <code>f</code> expects an <code>int</code>. It doesn't mean that an <code>int</code> is also packed into the function pointer somehow.</p>
",0
59224978,59224880,0,"<p>Since you are passing <code>MSG_DONTWAIT</code> to your <code>recv</code> call, if there is nothing to receive from the client yet, the call will return an error to indicate that fact.</p>

<p>If you are using polling mechanism, like <a href=""https://stackoverflow.com/q/27247/315052""><code>epoll</code></a>, then you would typically wait for a readable notification. Once the notification is received, you can retry the <code>recv</code> call. I don't see any use of a polling mechanism in your code.</p>

<p>Alternatively, you can spawn a thread for each new connection, and use blocking calls to <code>recv</code> (omit the <code>MSG_DONTWAIT</code> flag).</p>
",0
59114646,59114275,0,"<p>The algorithm for <code>numberOfArea</code> is the following. </p>

<p>Scan the area row by row, from top left to bottom right. If the cell we visit has value 0, we found a new area. We then increment the area counter and set the value of all cells of this area to the value 2. We call this process tagging an area. When the scan is finished, we have the count of distinct areas. We then do a last scan to restore the values to 0. </p>

<p>For tagging we use a recursive function. It does nothing if the cell coordinates are invalid or the cell value is not 0. Otherwise it sets the cell value to 2, and tags the four neighbor cells. </p>

<pre class=""lang-c prettyprint-override""><code>void tagArea(int area[20][20],int height, int width, int i, int j) {
    if(i &lt; 0 || j &lt; 0 || i &gt;= height || j &gt;= width || area[i][j] != 0)
        return;
    area[i][j] = 2;
    tagArea(area, height, width, i-1, j);
    tagArea(area, height, width, i+1, j);
    tagArea(area, height, width, i, j-1);
    tagArea(area, height, width, i, j+1);
}

int numberOfArea(int area[20][20],int height, int width, int *result) {
    // verify validity of arguments
    if(width &gt; 20 || height &gt; 20)
        return 1;
    for(int i = 0; i &lt; height; i++)
        for(int j = 0; j &lt; width; j++)
            if(area[i][j] &lt; 0 || area[i][j] &gt; 1)
                return 1;
    *result = 0;
    // count and tag every untagged area
    for(int i = 0; i &lt; height; i++) {
        for(int j = 0; j &lt; width; j++) {
            if(area[i][j] == 0) {
                (*result)++;
                tagArea(area, height, width, i, j);
            }
        }
    }
    // clear tags
    for(int i = 0; i &lt; height; i++)
        for(int j = 0; j &lt; width; j++)
            if(area[i][j] == 2)
                area[i][j] = 0;
    return 0;
}
</code></pre>

<p>Here is the code of the other function:</p>

<pre class=""lang-c prettyprint-override""><code>int numberOfRect(int area[20][20],int height, int width, int *result) {
    // verify validity of arguments
    if(width &gt; 20 || height &gt; 20)
        return 1;
    for(int i = 0; i &lt; height; i++)
        for(int j = 0; j &lt; width; j++)
            if(area[i][j] &lt; 0 || area[i][j] &gt; 1)
                return 1;
    *result = 0;
    // for every untagged cell...
    for(int i = 0; i &lt; height; i++) {
        for(int j = 0; j &lt; width; j++) {
            if(area[i][j] != 0)
                continue;
            // measure width and height of rectangle
            int w = 0, h = 0;
            for(int k = j; k &lt; width &amp;&amp; area[i][k] == 0; k++)
                w++;
            for(int k = i; k &lt; height &amp;&amp; area[k][j] == 0; k++)
                h++;            
            // assert top is border or all wall, otherwise the area would have been tagged
            // if left is not border and not all wall, it¡¯s not a rectangle
            if(j &gt; 0)
                for(int k = i; k &lt; i+h; k++)
                    if(area[k][j-1] != 1)
                        goto tagging; 
            // if right is not border and not all wall, it¡¯s not a rectangle
            if(j + w &lt; width)
                for(int k = i; k &lt; i+h; k++)
                    if(area[k][j+w] != 1)
                        goto tagging;
            // if bottom is not border and not all wall, it¡¯s not a rectangle
            if(i + h &lt; height)
                for(int k = j; k &lt; j+w; k++)
                    if(area[i+h][k] != 1)
                        goto tagging;
            // make sure no wall is inside the rectangle
            for(int k = i; k &lt; i+h; k++)
                for(int l = j; l &lt; j+w; l++)
                    if(area[k][l] != 0)
                        goto tagging;
            // all conditions are met, area is a rectangle
            (*result)++;
    tagging:
            tagArea(area, width, height, i, j);
        }            
    }
    // clear tags
    for(int i = 0; i &lt; height; i++)
        for(int j = 0; j &lt; width; j++)
            if(area[i][j] == 2)
                area[i][j] = 0;
    return 0;
}
</code></pre>

<p>Here is the code of the main function to test the other functions:</p>

<pre class=""lang-c prettyprint-override""><code>int main() {
    int height = 5, width = 5, result;
    int area[20][20] = {
        {0, 0, 1, 0, 0},
        {1, 0, 1, 1, 1},
        {0, 1, 1, 0, 0},
        {0, 1, 1, 0, 0},
        {0, 0, 1, 0, 0}
    };

    /*
    printf(""The size of the width: "");
    scanf(""%d"", &amp;width);
    printf(""The size of the height: "");
    scanf(""%d"", &amp;height);
    printf(""Please enter your array\n"");
    for(int i = 0; i &lt; width; i++) {
        for(int j = 0; j &lt; height; ++j) {
            printf(""[%d,%d]: "", i, j);
            scanf(""%d"", &amp;area[i][j]);
        }
    }
    */
    // print area
    printf(""\n"");
    for(int i = 0; i &lt; width; i++) {
        for(int j = 0; j &lt; height; ++j) {
            printf(""%d "", area[i][j]);
        }
        printf(""\n"");
    }

    if(numberOfArea(area, height, width, &amp;result) == 0) {
        printf(""Number of closed spaces: %d\n"", result);
    } else {
        printf(""Number of closed spaces: invalid width, height or grid value\n"");
    }
    if(numberOfRect(area, height, width, &amp;result) == 0) {
        printf(""Number of rectangular spaces: %d\n"", result);
    } else {
        printf(""Number of rectangular spaces: invalid width, height or grid value\n"");
    }
}
</code></pre>
",5
59125649,59125570,5,"<p>A NUL is only added when initializing from a string literal.</p>

<pre><code>char a1[] = ""abc"";               // 4 elements: 0x61, 0x62, 0x63, 0x00.
char a2[] = { 'a', 'b', 'c' };   // 3 elements: 0x61, 0x62, 0x63.
char a3[] = { 97, 98, 99 };      // 3 elements: 0x61, 0x62, 0x63.
</code></pre>

<p>Since your array doesn't contain <code>'\0'</code> (<code>0</code>), you read past its end until you happen to hit a <code>0</code>. This is undefined behaviour.</p>

<p>You could add a zero:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    int x[] = { 22, 8, 87, 76, 45, 43, 34, 13, 51, 15, 0 };
    size_t count = 0;
    while (x[count]) {
        count++;
    }

    printf(""%zu\n"", count);
}
</code></pre>

<p>That said, using a <a href=""https://en.wikipedia.org/wiki/Sentinel_value"" rel=""nofollow noreferrer"">sentinel value</a> here looks odd. One normally uses the size of the array.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    int x[] = { 22, 8, 87, 76, 45, 43, 34, 13, 51, 15 };
    size_t count = sizeof(x) / sizeof(x[0]);
    printf(""%zu\n"", count);
}
</code></pre>
",3
59127870,59127793,2,"<p>Bug #1.  Instead of this:</p>

<pre><code>char *res = malloc(end-begin);
for (int i=begin; i&lt;end; i++)
{
    res[i-begin] = str[i];
}
</code></pre>

<p>This:</p>

<pre><code>char *res = malloc(end-begin+1);  //+1 for null char
for (int i=begin; i&lt;end; i++)
{
    res[i-begin] = str[i];
}
res[end-begin] = '\0'; // null terminate the string that gets returned
</code></pre>

<p>I don't see <code>substr</code> getting invoked, but I see other variations of this string copy pattern missing the null char in your limits function.</p>

<p>More to come as I keep looking at the code....</p>
",0
59544109,59542393,0,"<p>Your function declaration <code>bool haveSameElems(arr1, arr2, size)</code> is implicitly the same as <code>bool haveSameElems(int arr1, int arr2, int size)</code>, per <a href=""https://stackoverflow.com/questions/59542393/error-expression-must-have-a-pointer-to-object-type-in-c#comment105256216_59542393"">Frankie_C</a>. To use <code>arr1</code> and <code>arr2</code> as arrays, they must be declared as pointers: <code>bool haveSameElems(int *arr1, int *arr2, int size)</code>. So you need to add those two asterisks in both the function declaration at the top of your code and in the function definition it corresponds to. It¡¯s good practice <em>always explicitly</em> to write types and not rely on the old K&amp;R style implicit <code>int</code> types Frankie_C wrote about in his comment. You can read more about it in the bottom box <a href=""https://en.cppreference.com/w/c/language/function_definition"" rel=""nofollow noreferrer"">here</a> and in the ¡°subscript¡± section <a href=""https://en.cppreference.com/w/c/language/operator_member_access"" rel=""nofollow noreferrer"">here</a>.</p>

<p>You also <a href=""https://en.cppreference.com/w/c/language/return"" rel=""nofollow noreferrer"">need</a> a <code>return false</code> at the end of <code>haveSameElems</code>, and <code>main</code> must return type <code>int</code> if you¡¯re using an older C complier. See <a href=""https://en.cppreference.com/w/c/language/main_function"" rel=""nofollow noreferrer"">here</a>.</p>
",0
59213336,59213288,7,"<p>You declared that the <code>SUM</code> function will return an integer value (<code>int</code>).</p>

<p>Then you added two <code>float</code>s together, and returned the <strong><em>address</em></strong> of the result.</p>

<p>The address of a <code>float</code> is nothing like the value of an <code>int</code>.</p>

<p>You have invoked <strong>Undefined Behavior</strong>.</p>

<hr>

<pre><code>float SUM (float n1, float n2);   // SUM should return a float.


float SUM (float n1, float n2) {
    float sum = n1+n2;
    return sum;                   // Return the sum (without any addresses)
}
</code></pre>

<h3>P.S.</h3>

<p>You have a function named <code>SUM</code> (with capital letters), and a variable named <code>sum</code> with lowercase letters.   While this is technically OK, it may be a point of confusion if another programmer reads your code.
Can you <em>always</em> be sure of the difference between <code>Sum</code>, <code>sum</code>, <code>SUM</code>?  What about <code>Sine</code>, <code>sine</code>, <code>sin</code>, <code>Sin</code>, <code>SINE</code>, etc.?  </p>

<p>You should put in extra effort to name your functions, variables, constants, etc clearly and unambiguously so that understanding and using the proper one in the proper context is easy for all programmers.</p>
",5
58345293,58344998,1,"<p>The problem is with the loop where you look for <code>empIDcheck</code>:</p>

<pre><code>for (i = 0; i &lt; SIZE; i++)
{
     if (empIDcheck == emp[i].IDNo) {
         found = 0;
         printf(""The current salary is %.2lf\n"", emp[i].salary);
     }
}
</code></pre>

<p>When you find the correct element in the array, you don't end the loop but continue iterating. That means the value of <code>i</code> after the loop will be equal to <code>SIZE</code>, which is out of bounds for the array.</p>

<p>You need to stop looping once you find the correct element. This can be done either with the <code>break</code> statement:</p>

<pre><code>for (i = 0; i &lt; SIZE; i++)
{
     if (empIDcheck == emp[i].IDNo) {
         found = 0;
         printf(""The current salary is %.2lf\n"", emp[i].salary);
         break;  // Done with the loop
     }
}
</code></pre>

<p>Or by updating the loop condition to check <code>found</code>:</p>

<pre><code>for (i = 0; i &lt; SIZE &amp;&amp; found != 0; i++)
{
     if (empIDcheck == emp[i].IDNo) {
         found = 0;
         printf(""The current salary is %.2lf\n"", emp[i].salary);
     }
}
</code></pre>
",1
59288232,59288231,0,"<p>Yes, you can do that, e.g. by using a function to change the digit.</p>

<p>Use the following steps:</p>

<ol>
<li>What you do, is first shifting the digit right until it is the most right digit and remember the part removed</li>
<li>Clear the last digit.</li>
<li>Add the new digit</li>
<li>Shift left</li>
<li>Add the remembered part</li>
</ol>

<p>Example (same steps as above) to change 321 to 351:</p>

<ol>
<li>Shift right gives 32. Remember 1</li>
<li>Use the modulo operator and remove it: 32 - (32 % 10) = 32 - 2 = 30</li>
<li>30 + 5 = 35</li>
<li>35 -> after shift gives 350 </li>
<li>350 + 1 = 351</li>
</ol>

<p>I will leave the implementation up to you.</p>
",2
59381911,59381702,1,"<p>One apparent problem is that this code seems to be more liberal in its array indexing than the C language allows for.<br>
C uses <a href=""https://developerinsider.co/why-does-the-indexing-of-array-start-with-zero-in-c/"" rel=""nofollow noreferrer"">zero based indexing for arrays</a>.  For example, an array such as this:</p>

<pre><code>int array[10]; //has room for 10 integer values, accessed like this:

for(int i=0;i&lt;10;i++)
{
    array[i] = i;  //populates array[0] through array[9]
}
</code></pre>

<p>eg. For:</p>

<pre><code>#define ROWS 6
#define COLS 7
char board[ROWS][COLS];

 ...

    for (i = 1; i &lt;= 4; i++)
    {
        if (getCell(row, i) == 'X' &amp;&amp; getCell(row, i + 1) == 'X' &amp;&amp; getCell(row, i + 2) == 'X' &amp;&amp; getCell(row, i + 3) == 'X')
</code></pre>

<p>Array indexing should really be:</p>

<pre><code>    for (i = 0; i &lt; 7; i++)
    {     
        if (getCell(row, i) == 'X' &amp;&amp; getCell(row, i + 1) == 'X' &amp;&amp; getCell(row, i + 2) == 'X' &amp;&amp; getCell(row, i + 3) == 'X')
</code></pre>

<p>In this section <code>row - 3</code> will at some point be a negative value, resulting in a negative array index, which might be the problem you were seeing:</p>

<pre><code>   if (getCell(row, col) == 'X' &amp;&amp; getCell(row - 1, col + 1) == 'X' &amp;&amp; getCell(row - 2, col + 2) == 'X' &amp;&amp; getCell(row - 3, col + 3) == 'X')
    {
        return 1;
    }
</code></pre>
",0
58494863,58491773,1,"<p>You need a condition expression to check whether you are filling a boundary or the interior. You need to check if it is the first row or last row, or first column or last column (those are your boundaries where you output <code>'*'</code>), otherwise you output out fille (<code>'-'</code>). Similar to:</p>

<pre><code>#include &lt;stdio.h&gt;

#define ROWS 5
#define COLS ROWS

int main (void) {

    int r, c;
    for (r = 0; r &lt; ROWS; r++)
    {
        for (c = 0; c &lt; COLS; c++)
        {
            if (!r || r == ROWS-1 || !c || c == COLS-1)
                putchar('*');
            else
                putchar('-');
        }
        putchar('\n');
    }

    return 0;
}
</code></pre>

<p><strong>Example Use/Output</strong></p>

<pre><code>$ ./bin/hboxfilledex
*****
*---*
*---*
*---*
*****
</code></pre>

<p>Look things over and let me know if you have further questions.</p>
",0
59573346,59573246,2,"<p>You must a format specifier that matches the type of the value you are printing.</p>

<p><code>%p</code> expects a <code>void *</code>.</p>

<p><code>%x</code> expects an <code>unsigned int</code>.</p>

<p><code>%lx</code> expects an <code>unsigned long</code>.</p>

<p>This is documented in <code>man 3 printf</code>.</p>

<pre><code>#include &lt;inttypes.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

int main(void) {
   const char *s = ""foo"";
   printf(""%p\n"", s);
   printf(""%s\n"", PRIxPTR);
   printf(""%#"" PRIxPTR ""\n"", (uintptr_t)s);
}
</code></pre>

<p>Output:</p>

<pre><code>$ gcc -Wall -Wextra -pedantic -std=c99 a.c -o a &amp;&amp; a
0x5b72da1774
lx
0x5b72da1774
</code></pre>

<p><code>PRIxPTR</code> will be something like <code>x</code>. In my case, it's <code>lx</code> because a pointer is the same size as an <code>unsigned long</code>.</p>
",2
59489121,59488643,0,"<p>One loop, 3 variables (<code>l</code>, <code>ll</code>, and <code>i</code>.  <code>n</code> specifies the size of the triangle)</p>
<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    const int n = 10;
    int l = 1;
    int ll = 1;
    
    for(int i=1; i&lt;=n; ++i)
    {
        printf(&quot;%d %s&quot;, 3*i, --l? &quot;&quot; : (l=++ll,&quot;\n&quot;));
    }
    
    return 0;
}
</code></pre>
<p><a href=""https://ideone.com/MtBTIY"" rel=""nofollow noreferrer"">Link to IDEOne</a></p>
<h2>Output</h2>
<pre><code>Success #stdin #stdout 0s 4212KB
3 
6 9 
12 15 18 
21 24 27 30 
</code></pre>
",0
59525235,59525207,0,"<p>That is not an error, it's just a warning. Your code does compile, trying running the resulting binary with <code>./a.out</code></p>

<p>GCC is just warning you that you didn't specify a return type for main, and that it will automatically return an integer.</p>
",2
58683679,58683535,0,"<p>Because its an enum definition, it doesn't make sense to make it <code>static</code>. You probably meant to do this instead:</p>

<pre><code>typedef enum 
{
  SET_SUCCESS   =  0,
  SET_ET_ERROR  = -1,
  SET_CBL_ERROR = -2,
  SET_SEN_ERROR = -3,
  SET_TAR_ERROR = -4,
  SET_ENG_ERROR = -5,
  SET_IO_ERROR  = -6,
} RetType;

...

static RetType ret = SET_SUCCESS;
</code></pre>
",0
58683679,58683535,0,"<p>Because its an enum definition, it doesn't make sense to make it <code>static</code>. You probably meant to do this instead:</p>

<pre><code>typedef enum 
{
  SET_SUCCESS   =  0,
  SET_ET_ERROR  = -1,
  SET_CBL_ERROR = -2,
  SET_SEN_ERROR = -3,
  SET_TAR_ERROR = -4,
  SET_ENG_ERROR = -5,
  SET_IO_ERROR  = -6,
} RetType;

...

static RetType ret = SET_SUCCESS;
</code></pre>
",0
58582728,58582216,0,"<p>Suggest:</p>

<p>1) create a struct that holds all the info for an individual student
2) create a file, perhaps in the local directory or in <code>/tmp</code>
3) for each student, after collecting the information, write the struct to the file</p>

<p>--or--</p>

<p>given the MAX number of courses that a student can take, then code similar to:</p>

<pre><code>int   course1day;
int   course1time;
int   course1code;
(repeat for MAX number of courses, increment the digit for each course)
</code></pre>

<p>a consideration is: what will the code be doing with this information after it is collected?</p>
",2
58589641,58582216,0,"<p>Assuming that <code>courseCode</code> is a single digit number representing the course you could do something like this:</p>

<pre><code>printf(""Please enter the number of courses you'd like to take: "");
int numOfCourses;
scanf_s(""%d"", &amp;numOfCourses);
int courseCode;
int courseDay;
int courseTime;

// unsigned long to have the most possible space
unsigned long courseCodeArray = 0;
unsigned long courseDayArray = 0;
unsigned long courseTimeArray = 0;

int i = 0;
while (i &lt; numOfCourses) {
  // single digit code
  printf(""Please enter the code of the course: ""); 
  scanf_s(""%d"", &amp;courseCode);

  // 1 = Monday, 2 = Tuesday, 3 = Wednesday , etc.
  printf(""Please enter the day of the course: "");
  scanf_s(""%d"", &amp;courseDay);

  // 1 = 8:00, 2 = 10:00, 3 = 12:00, etc.
  printf(""Please enter the time of the course: "");
  scanf_s(""%d"", &amp;courseTime);

  courseCodeArray += courseCode;
  courseDayArray += courseDay;
  courseTimeArray += courseTime;

  courseCodeArray = courseCodeArray * 10;
  courseDayArray =  courseDayArray * 10;
  courseTimeArray = courseTimeArray * 10;

  i++;
}
</code></pre>

<p>This way you would have an ""array"" made with a single int that could work as long as the code of the course is an integer between 1 and 9.</p>

<p>E.G. the numbers: <code>435</code> , <code>132</code> and <code>431</code>
Would mean: <code>4-1-4</code> <code>Course 4 Monday at 14:00</code> , <code>3-3-3</code> <code>Course 3 Wednesday at 12:00</code> and <code>5-2-1</code> <code>Course 5 Tuesday at 8:00</code> respectively.</p>

<p>Of course you then need to write some checks to ensure that the user will enter only valid numbers, that you don't go past the maximum <code>unsigned long</code> value and  make better design choices but i think this is what your professor meant by </p>

<blockquote>
  <p>Make your code robust and easy to read</p>
</blockquote>

<p>So I won't do absolutely everything for you ;)</p>

<p>With this you essentially store multiple values in a single <code>unsigned long</code> or <code>int</code> as long as you know how to ""decode"" the single digits to their representation. Just divide the arrays by 10 to remove the last 0 and then read digit by digit of the resulting ""array"" numbers and convert them back.</p>
",0
58575619,58575550,3,"<p>You're not always initializing <code>i</code>. You initialize <code>i = num1</code> if the first number is odd, and you initialize <code>i = num1 - 2</code> in the incrementing branch, but in the decrementing branch you don't initialize it. Since you ran the incrementing branch first, <code>i</code> was left as so:</p>

<pre><code>i = num1 - 2; // i = 0
while (i &lt;= num2 - 2) // i &lt;= 20
  printf(""%d, "", i += 2); // i is left as 22
</code></pre>

<p>So when you then run the decrementing loop, <code>i</code> is set correctly completely on accident:</p>

<pre><code>if (i &gt;= num2) // true, i = 22 from before, num2 = 2
{
    while (i &gt;= num2 + 2) // i &gt;= 4
        printf(""%d, "", i -= 2); // i = 2
}
</code></pre>

<p>But then when you try to run the decrementing loop again right after, <code>i</code> is 2, not 22. So you get</p>

<pre><code>if (i &gt;= num2) // true, i = 2, num2 = 2
{
    while (i &gt;= num2 + 2) // i &gt;= 4, immediately false
        printf(""%d, "", i -= 2); // never runs
}
</code></pre>

<p>What I would suggest is re-architecting your code into two functions. <code>main()</code> should handle the user input and the state of the program (num1, num2) which then get passed to a helper function <code>printSequence</code> (or two, <code>printForward</code> and <code>printReverse</code>) that has a local variable <code>i</code>. This will help with this kind of bug, because all the long-lived state will be confined to <code>main()</code>.</p>
",1
58626687,58624920,2,"<p>There are several items in your code that are problematic, including such things as your prompt for user input:  <code>scanf(""%d %d"",&amp;n,&amp;m);</code>.  This will not handle the white space that comes with the user input.</p>

<p>These are not hard rules, just some suggestions:<br>
(followed by example code with alternative methods of user input and temporary data storage.)</p>

<ul>
<li>When asking for user input, use simple clear directions that allow no ambiguity.   </li>
<li>Allow for 1 entry at a time.  </li>
<li>Use variable values that describe what you are doing. (<code>rows</code> <code>cols</code> are more descriptive than
<code>m</code> <code>n</code>)  </li>
<li>Create an appropriate container for holding user data as it is entered.</li>
</ul>

<p>For example:  </p>

<pre><code>int main(void)
{
    char str[4];
    int chr;
    int rows, cols;
    int i, j;

    char sDataConv[][2] = { ""W"", ""B"" };

    printf(""Enter number of rows: "");
    if(fgets(str, 4, stdin)) 
    {
        rows = atoi(str);   
    }
    printf(""Enter number of columns: "");
    if(fgets(str, 4, stdin)) 
    {
        cols = atoi(str);   
    }
    int array[rows][cols];//read data in as char values such as 'W' and 'B'
    memset(array, 0, sizeof(array));

    //Now a loop can be used prompting user
    //to enter  values, and placing values
    //into array as they are entered, eg using
    // array[i][j] = getc(stdin);
    // if((array[i][j] == 'W') || (array[i][j] == 'B'))

    for(i = 0; i&lt;rows; i++)
    {
        for(j = 0;j&lt;cols;j++)
        {
            printf(""Enter either W or B one at a time"");
            if(fgets(str, 4, stdin))
            {
                array[i][j] = str[0];
                //test - limit to allow only W or B
                while(!((array[i][j] == 'W') || (array[i][j] == 'B')))
                {
                    printf(""Wrong entry, enter either W or B."");
                    if(fgets(str, 4, stdin))
                    {
                        array[i][j] = str[0];
                    }
                }
            }
        }
    }
    //display data entered
    for(i = 0; i&lt;rows; i++)
    {
        for(j = 0;j&lt;cols;j++)
        {
            printf(""%c "", array[i][j]);
        }
        printf(""\n"");
    }



    return 0;
}
</code></pre>

<p>This should provide a start. The rest is up to you, but the array should help to make the comparisons, and present results.</p>
",1
58628883,58628804,3,"<p>Command line arguments are passed to the program as <em>strings</em> - you'll need to use <code>atof</code> or <code>strtod</code> to convert the string representation of a value to its numeric equivalent.  </p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main( int argc, char **argv )
{
  // All kinds of error checking ommitted
  double input = strtod( argv[1], NULL );
  double v = 4.0 / 3.0 * 3.14 * input * input * input;
  ...
}
</code></pre>

<p>Unless you're really constrained on space, use <code>double</code> instead of <code>float</code>.  </p>
",0
58628940,58628804,1,"<p>You don't have a variable <code>i</code>. You can think of <code>argv</code> as a string array if you want, <code>argv[0]</code> is the name of your executable so in this case <code>./radius</code>,  <code>argv[1]</code> in your case will be 2 and so on.</p>

<p>One thing you should keep in mind is that it's good practice to check <code>argc</code> to ensure you have the parameters you want, <code>argc</code> will tell you the length of <code>argv</code> so in your case it will be 2.</p>

<p>you can then use the number you passed like:</p>

<pre><code>double arg = atof(argv[1]);
double v = 4.0 / 3.0 * 3.14 * arg * arg * arg;
</code></pre>

<p>or:</p>

<pre><code>int i = 1;
double arg = atof(argv[i]);
double v = 4.0 / 3.0 * 3.14 * arg * arg * arg;
</code></pre>

<p>or again (the worst method):</p>

<pre><code>double v = 4.0 / 3.0 * 3.14 * atof(argv[1]) * atof(argv[1]) * atof(argv[1]);
</code></pre>

<p>If for some reason you <strong>REALLY</strong> don't want to have separate variables</p>

<p>but like i said, you should first check that you have enough arguments with <code>argc</code> and that the argument is what you actually want (E.G. a number and not a string)</p>
",0
58716654,58715775,0,"<p>The ""%s"" format character of fscanf expects that </p>

<blockquote>
  <p>the next pointer must be a pointer to character array that is long
  enough to hold the input sequence and the terminating null byte
  ('\0'), which is added automatically. The input string stops at white
  space or at the maximum field width, whichever occurs first.</p>
</blockquote>

<p>This means that instead of <code>actualAnswer1</code> which is of type char, you need to provide a character array for example <code>output</code></p>

<p><code>fscanf(filePointer, ""%s"", output);</code></p>

<p>The above line can read upto 255 character long string from the file and put a '0' in the 256th spot. If the first string in your file happened to be longer than 255 characters then the program will crash. You can provide a field width specifier to guard against this.</p>

<p><code>fscanf(filePointer, ""%255s"", output);</code></p>
",0
58699307,58699071,1,"<p>You are assuming that <code>OutputF(InputF(), InputF())</code> is calling InputF() in the order declared in the function call parameters.  That is undefined behavior in C. 
From the C specification:</p>

<blockquote>
  <p>The order of evaluation of the function designator, the actual
  arguments, and subexpressions within the actual arguments is
  unspecified, but there is a sequence point before the actual call.</p>
</blockquote>

<p>The compiler can do whatever it wants. Try this instead:</p>

<pre><code>int main(void)
{
    char in1 = InputF();
    char in2 = InputF();

    printf(""%d\n"", OutputF(in1,in2));
    printf(""%d\n"", OutputF('Y', 'N'));
    return 0;
}
</code></pre>

<p>See this <a href=""https://stackoverflow.com/questions/376278/parameter-evaluation-order-before-a-function-calling-in-c"">link</a> for more details on undefined behaviors</p>
",0
58820933,58820421,1,"<p>As I see it, your code has a few issues.</p>

<p>First, the <code>%*[\t]</code> specifiers are interfering and should not be necessary. A space between specifiers in <code>sscanf</code> will cause all whitespace to be consumed.</p>

<p>Second, the ID value you have may overflow a <code>long int</code>, so you may need to use <code>long long</code> instead with a <code>%lld</code> specifier.</p>

<p>Finally, there seems to be some confusion about whether spaces or tabs separate fields. Spaces are valid values for all your string fields, but also given between field. Your comments mention tabs, but I don't see any in your <code>line</code> string. If you use tabs to separate your fields things work much better, as the tab character is not part of your specifier sets.</p>

<p>Here is my update of your code correcting all the above:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {

  long long id;
  float grade,age;
  char name[40],city[40],country[40],line[100]=""3888914775\tItzel Gardner\t21\t26\tIran\tTehran"";

  int read_items = sscanf(line,""%lld %[a-zA-Z -] %f %f %[a-zA-Z -] %[a-zA-Z -]"",
        &amp;id,name,&amp;age,&amp;grade,country,city);

  printf(""readed line is: %lld %s %f %f %s %s. sscanf() read %d items\n"",id,name,grade,age,country,city,read_items);

}
</code></pre>

<p>Output:</p>

<pre><code>readed line is: 3888914775 Itzel Gardner 26.000000 21.000000 Iran Tehran. sscanf() read 6 items
</code></pre>
",2
59296826,59296685,2,"<p>There are two issues with this code, both fatal.</p>

<p>@IlyaBursov has pointed out that the test conditions are wrong:</p>

<blockquote>
  <p>if(salary == 0 &amp;&amp; salary >= 9325)</p>
</blockquote>

<p>There is no circumstance that this test will ever be true; likewise with all the others save for the last. Surely you mean <code>&gt;</code> or <code>&gt;=</code> instead of <code>==</code>.</p>

<p>But the <code>scanf()</code> using the token <code>%lf</code> is attempting to read a <code>double</code> (often 64-bit) instead of the actual 32-bit <code>float</code> variables provided. This will produce crazy numerical errors.</p>

<p>Many compilers support higher levels of warnings that will point out this second error, the mismatch between the <code>%lf</code> and the pointer associated with it; always enable these when you can.</p>

<p>Example:</p>

<pre><code>$ gcc -W -Wall test.c
test.c:20:9: warning: format ¡®%lf¡¯ expects argument of type ¡®double *¡¯, but argument 2 has type ¡®float *¡¯ [-Wformat=]
         scanf(""%lf"", &amp;salary);
</code></pre>

<p><strong>EDIT</strong>
Also change <code>scanf(""%s"", &amp;name);</code> to <code>scanf(""%s"", name);</code></p>
",7
58995936,58995811,0,"<blockquote>
  <p>This is my code, I couldn't figure out why memset function won't work in here.</p>
</blockquote>

<p>You have an array of <code>BLOCK_SIZE</code> bytes and you are trying to set all <code>BLOCK_SIZE*DISK_BLOCKS</code> bytes in that array to 0. I assume that <code>DISK_BLOCKS</code> is more than 1, so <code>memset</code> gets to the end of the array and then keeps going because you told it to.</p>
",1
59052796,59052680,0,"<p>Depending on how the 2D array <code>board</code> is defined, one potential problem is here:    </p>

<pre><code>if(board[r][c]==board[r][c+n]&amp;&amp; board[r][c]!='_')  
                          ^^    
</code></pre>

<p>For example, if board is defined somewhere as:</p>

<pre><code>int board[size][size] = {0};  
</code></pre>

<p>Then:  </p>

<p>If <code>c</code> can grow to <code>size-1</code><br>
And if <code>r</code> can grow to <code>size-1</code><br>
Then if <code>n</code> is greater than <code>0</code><br>
<code>board[r][c+n]</code> will exceed the 2nd index array bounds.  This will cause <em><a href=""https://www.google.com/search?client=firefox-b-1-d&amp;q=undefined+behavior+in+c"" rel=""nofollow noreferrer"">undefined behavior</a></em>.</p>

<p>Also, the phrase:</p>

<pre><code>if(board[r][c]==board[r][c+n]&amp;&amp; board[r][c]!='_')
  win=1;
  break;
</code></pre>

<p>will break even if <code>win</code> does not equal <code>1</code>.  </p>

<p>It should probably be written:</p>

<pre><code>if(board[r][c]==board[r][c+n]&amp;&amp; board[r][c]!='_')
{
    win=1;
    break;
}
</code></pre>
",0
59157769,59157707,2,"<p>If <code>scanf</code> fails to parse the input, it will leave it in the input buffer. The next iteration <code>scanf</code> will read the exact same input and again fail.</p>

<p>A common way to handle invalid input is to read a whole line into a buffer using e.g. <a href=""https://en.cppreference.com/w/c/io/fgets"" rel=""nofollow noreferrer""><code>fgets</code></a> and then attempt to parse it using <code>sscanf</code>, remembering to check what it <a href=""https://en.cppreference.com/w/cpp/io/c/fscanf#Return_value"" rel=""nofollow noreferrer""><em>returns</em></a>.</p>
",0
59364532,59364185,0,"<p>Fix the following problems:</p>

<ol>
<li>You're not closing the file after you write it, so the buffer isn't being flushed.</li>
<li>You're writing an extra newline before each number, but you don't skip it when reading.</li>
<li><code>replirtab()</code> expects an array of pointers, but the array contains integers, not pointers. There's no need to indirect through the references. When you pass an array to a function, a pointer to the first element is passed.</li>
</ol>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
void genererN ( int n){
    int i=0;
    FILE* fichier = NULL;
    fichier=fopen(""valeurs.txt"",""w"");
    if (!fichier) {
        printf(""Unable to write file\n"");
        exit(1);
    }
    while (i&lt;n){
        fprintf(fichier,""%d\n"",rand());
        i++;
    }
    fclose(fichier);
}

void replirtab (int *t,int n){
    int i=0;int m;
    FILE* fichier = NULL;
    fichier=fopen(""valeurs.txt"",""r"");
    if (!fichier) {
        printf(""Unable to read file\n"");
        exit(1);
    }
    char stre[999999] = """";
    while(i&lt;n){
        fgets(stre, 999999, fichier);
        m = atoi(stre);
        t[i]=m;
        i++;
    }
    fclose(fichier);
}

void affichertab (int *t,int n){
    int i=0;
    while(i&lt;n){
        printf(""%d\n"",t[i]);
        i++;
    }
}
</code></pre>
",1
59433556,59433239,5,"<p>Whitespace between tokens is unneeded in general, and completely irrelevant in your scenario.</p>

<p>Exception #1: Whitespace is sometimes needed to denote the end of a token. For example, <code>int foo(int)</code> can't be written <code>intfoo(int)</code>, and <code>a+++b</code> is equivalent to <code>a++ + b</code> rather than <code>a + ++b</code>.</p>

<p>Exception #2: Line feeds are sometimes significant. For example, it marks the end of a <code>//</code> command and of a <code>#</code> directive.</p>
",0
59500793,59500724,5,"<p>I think the problem is most likely that you don't think the <kbd>Enter</kbd> key will give you a character, but it will result in a newline <code>'\n'</code> character.</p>

<p>If you want to skip the newlines (or really <em>any</em> white-space) then use a leading space in the <code>scanf</code> format string:</p>

<pre><code>scanf("" %c"",&amp;a[i]);
//     ^
// Note space here
</code></pre>

<p>If you want to read other space characters (like ""normal"" space or tab) then you need to use one of the character-reading functions like <a href=""https://en.cppreference.com/w/c/io/fgetc"" rel=""noreferrer""><code>fgetc</code></a> or <a href=""https://en.cppreference.com/w/c/io/getchar"" rel=""noreferrer""><code>getchar</code></a>. For example as</p>

<pre><code>for (size_t i = 0; i &lt; 10; ++i)
{
    int c = getchar();
    if (c == '\n')
        continue;  // Skip newline
    if (c == EOF)
        break;  // Error or ""end of file""

    // Use the character...
}
</code></pre>
",4
58994255,58994024,4,"<p>The C pre-processor uses whitespace as the way to distinguish between pre-processor tokens. So just as in any C code, the amount of spaces in macros doesn't matter. When you use the pre-processor token concatenator <code>##</code> you merge two tokens together though, regardless of how much whitespace there is between them. And this is not what you want to do.</p>

<p>Assuming that you actually use the macro as <code>ADD_API(Whatever);</code> (with semicolon) and not as a string literal, then the correct macro should be</p>

<pre><code>#define ADD_API(NAME) func_##NAME NAME
</code></pre>

<p>with no semicolon in the end.</p>

<p>This expands <code>ADD_API(Whatever);</code> into <code>func_Whatever Whatever;</code></p>
",1
59389473,5528389,0,"<p>Based on @Whitham Reeve II answer given above, here is a better version:</p>

<p>No need for the 'a' int variable to hold 'num' ; Since each recursive call will have a separate copy of 'num' value (i.e. call by value).
Also it seems some compilers require you to pass also ""stdout"" as 2nd parameter to dump chars on screen.</p>

<pre><code>void print_int(int num){
    if (num &lt; 0)
    {
       putc('-', stdout);
       num = -num;
    }

    if (num &gt; 9) print_int(num/10);

    putc('0'+ (num%10), stdout);
 }
</code></pre>
",0
59101767,59101617,3,"<p><code>tu_printflike</code> is very likely a <em>macro</em> that expands to an <a href=""https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-format-function-attribute"" rel=""nofollow noreferrer"">attribute like</a>:</p>

<pre><code>__attribute__ ((format (printf, 3, 4)))
</code></pre>

<p>The above is GCC specific, so the use of a macro is there to enable portability across compilers, it can be defined as something akin to</p>

<pre><code>#ifdef __GNUC__
#  define tu_printflike(i, j) __attribute__ ((format (printf, i, j)))
#else
#  define tu_printflike(i, j) 
#endif
</code></pre>

<p>Your bonus point can be explained just the same with</p>

<pre><code>#define bar()
</code></pre>

<p>Where the definition is just an empty token sequence, the function like macro expands to nothing.</p>
",1
58092080,58092022,5,"<p>You pass a pointer to the location you want to write to. Compare with:</p>

<pre><code>#include &lt;stdio.h&gt;
char hello[18] = ""Hello cruel world"";
char* myfunc2() {
        return hello;
}
void myfunc(char **mypointer) {
        *mypointer = myfunc2();
}
int main(){
        char *testPointer;
        printf(""hello: %p\n"", &amp;hello);
        printf(""test: %p\n"", &amp;testPointer);
        myfunc(&amp;testPointer);
        printf(""test: %p\n"", &amp;testPointer);
        printf(""test value: %s\n"", testPointer);
        return 0;
}
</code></pre>
",0
48738886,48738829,2,"<p>You need to <code>#include &lt;sys/ioctl.h&gt;</code>.  Otherwise the definition of <code>TUNSETIFF</code> is not expanded fully into an integer.</p>
",0
57928719,57928549,1,"<p><code>printf("" 0x%x *ptr\n"",);</code></p>

<p>should be</p>

<p><code>printf("" 0x%x\n"", *ptr);</code></p>

<p>but the reason it prints out as <code>0xffffffef</code> instead of <code>0xef</code> is because <code>%x</code> interprets the input value as an <code>unsigned int</code> and so the char value is first <strong>sign extended</strong> to match the size of an <code>int</code>. <code>0xef</code> is binary <code>11101111</code>, notice the high bit is set. When extended as a signed value, that high bit gets repeated in the added bits:</p>

<p><code>11111111 11111111 11111111 11101111</code></p>

<p>aka <code>0xffffffef</code>.</p>

<p>To avoid <em>sign</em> extending, cast the char value to an <strong>unsigned</strong> value first so it then gets <em>zero</em> extended instead:</p>

<p><code>00000000 00000000 00000000 11101111</code></p>

<p>aka <code>0x000000ef</code>, or just <code>0xef</code> when leading zeros are omitted:</p>

<p><code>printf("" 0x%x\n"", (unsigned char) *ptr);</code></p>

<p>Alternatively, in C++11 and later, you can use <code>%hhx</code> instead, which interprets the input value as an <code>unsigned char</code>, so you can avoid the explicit typecast:</p>

<p><code>printf("" 0x%hhx\n"", *ptr);</code></p>
",2
55839672,55839573,0,"<p>A general print array function is prone to <em>undefined behavior</em> (UB) unless the data reference is aligned properly and of a valid value.</p>

<p>Having said that, try </p>

<pre><code>//printf(""Integer %d  %d\n"", (int*)(arr+i));
//              vv-------- print a `%`
printf(""Integer %%d  %d\n"", ((int*)arr)[i]);
//                          ^---------^ form a `int *` and then use [i]
</code></pre>

<p>Adding <code>i</code> to a <code>void*</code> is UB.  Cast the <code>void *</code> pointer <em>first</em> to the desired pointer type, then use the index <code>[i]</code>.</p>
",3
50957794,50957104,2,"<p><code>main</code> calls the function returned by <code>h</code> and returns that result.  <code>h</code> compares the output of <code>f</code> and <code>g</code> and returns the function which returns the larger value (else it returns 0).  Since the output of <code>g</code> is greater than <code>f</code>, <code>h</code> returns <code>g</code>.  Hence <code>main</code> returns 2.</p>
",0
55301255,55301153,5,"<p>Null terminate your strings.</p>

<pre><code>char tStr[9]
tStr[8]=0;
</code></pre>

<p>Your code works by accident otherwise.</p>

<p>The reason the code works has to do with the unused array growing the stack and putting <code>tStr</code> on the newly allocated page, thus initializing it to zeros, but there's something else here too. In any case, lots of undefined behavior to go around.</p>
",3
53118285,53114057,3,"<p>The C standard does not define ordering for assignment of members within a structure when assigning a structure.</p>
<p>About assignment, C 2018 6.5.16.1 says only:</p>
<blockquote>
<p>2 In <em>simple assignment</em> (<code>=</code>), the value of the right operand is converted to the type of the assignment expression and replaces the value stored in the object designated by the left operand.</p>
<p>3 If the value being stored in an object is read from another object that overlaps in any way the storage of the first object, then the overlap shall be exact and the two objects shall have qualified or unqualified versions of a compatible type; otherwise, the behavior is undefined.</p>
</blockquote>
<p>Examining the standard for all mentions of ¡°member¡±, ¡°struct¡±, or ¡°structure¡± does not reveal anything that would impose any chronological ordering on the members within the assignment. (There is not even an explicit definition of what the value of a structure is; we are left to presume it is effectively an ordered tuple of the value of its members, or perhaps, from ¡°a structure is a type consisting of a sequence of members¡± in 6.7.2.1 6, that its value is a sequence of values of its members.)</p>
",1
55697041,55696680,7,"<p>In C89/C90, you can't interleave declarations and statements, such as putting the <code>int x[size];</code> declaration (definition) after the <code>scanf()</code> ¡ª even if you change the dimension to a compile time constant.</p>

<p>In C89/C90, you cannot use a variable length array ¡ª so the <code>int x[size];</code> definition is not legal because <code>size</code> is not a compile time constant.</p>

<p>C99 compilers are required to support both declarations at (almost) arbitrary points in a function (they still can't be preceded by a label) and variable length array (VLA) definitions.</p>

<p>C11 compilers are required to support variable definitions (almost) anywhere in a function.  C11 compilers may optionally support VLAs (<a href=""http://port70.net/~nsz/c/c11/n1570.html#6.10.8.3"" rel=""nofollow noreferrer"">¡ì6.10.8.3 Conditional feature macros</a> and <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.7.6.2"" rel=""nofollow noreferrer"">¡ì6.7.6.2 Array declarators</a>), and should define <code>__STDC_NO_VLA__</code> if they do not support them.</p>

<p>C18 is equivalent to C11 in all aspects of this discussion.</p>

<p>Just for the record:</p>

<ul>
<li>C89 is ANSI X3.159-1989</li>
<li>C90 is ISO 9899-1990 ¡ª the ANSI version of which was marked with ""revision and redesignation of ANSI X3.159-1989"".  The primary difference was in the section numbers for the language and the library.</li>
<li>C99 is ISO/IEC 9899:1999</li>
<li>C11 is ISO/IEC 9899:2011</li>
<li>C18 is ISO/IEC 9899:2018</li>
</ul>

<p>Of course, the only unusual thing about X3.159-1989 was that it was published by ANSI before there was an ISO standard.  However, ANSI has adopted each subsequent ISO standard too, as have other national standards bodies such as BSI (British Standards Institute) and DIN (Deutsches Institut f¨¹r Normung or German Institute for Standardization).</p>

<p>There was also an Amendment 1 (to ISO 9899:1990) finalized in 1994 and published in 1995.  That added headers and introduced digraphs and made sundry other changes.  It is almost never considered separately, especially not now, 25 years later.</p>

<p>Note that GCC treats the <a href=""https://gcc.gnu.org/onlinedocs/gcc-8.3.0/gcc/Standards.html#C-Language"" rel=""nofollow noreferrer""><code>-ansi</code></a> option as equivalent to <code>-std=c90</code>, which can lead to confusion over terminology.  ANSI originally published 'the ANSI C standard' a year or so before ISO did, but the intent was always to have a common standard, and ANSI endorsed the ISO 9899:1990 standard when it was published.</p>
",6
55696730,55696680,0,"<p>ANSI-C (C89) <strong>does not allow</strong> initialize an array using a variable.</p>

<p>For example:</p>

<pre><code>  int x = 5;
  int ia[x];
</code></pre>

<p>This above example is illegal. ANSI-C restricts the array intialization size to be constant. However you can use macros to define the length of an array.</p>

<p>Example: </p>

<pre><code>    #define MAX_ARRAY_SIZE 5
    int ia[MAX_ARRAY_SIZE];
</code></pre>
",7
55973931,55973903,2,"<p>All variables must first be initialized to a valid value before you can use them in an expression like <code>*p</code>. For pointers, this means assigning an address to point to. You can do this either by taking the address of another variable or by dynamically allocating memory with <code>malloc()</code>.</p>

<p>When you try to dereference an uninitialized pointer with <code>*p</code>, it will use whatever memory address happens to be stored in <code>p</code> at that time. Most likely this address is invalid for you to use and so you get a segfault.</p>
",0
59242225,12786053,0,"<p><strong>Obvious</strong>     Solution: Don't assign results of function returning void.</p>

<p><strong>Non-Obvious</strong> Solution: Don't nest function calls, and you are less likely
to be looking in all of the wrong spots, thinking the compiler is broken.</p>

<pre><code>#include &lt;stdio.h&gt; //:for: printf(...)

void YOUR_MISTAKE_ACTUALLY_HERE();
void  MyFunc( void );
void* WRAPPED_MyFunc( int, int, int );


int main( void ){
    printf(""[BEG:main]\n"");


    void* HW = NULL;
    HW = WRAPPED_MyFunc(  //:&lt;---So you check this, but it looks fine.
        1
    ,   YOUR_MISTAKE_ACTUALLY_HERE()
    ,   3
    );; //:&lt;--- compiler says ""Invalid Use Of Void Expression"" Here.

    if( HW ){ /** NOOP **/ };


    printf(""[END:main]\n"");
} 

    void YOUR_MISTAKE_ACTUALLY_HERE(){ }

    //:Pretend this function is fetched from DLL.
    //:Casting all DLL functions initially to void(*pfn)void
    //:in a lookup table, then re-casting later.
    void MyFunc( void ){

        return;

    }//[;]//

    typedef  
        void* 
        (* MyFunc_TYPEDEF)(            

            int a
        ,   int b
        ,   int c

        );

    void*
    WRAPPED_MyFunc(

        int a
    ,   int b
    ,   int c

    ){


               MyFunc_TYPEDEF
        fun =( MyFunc_TYPEDEF)
               MyFunc;

        void* ret=( fun(

            a
        ,   b
        ,   c

        ));

        return( 
            (void*)
            ret 
        );;

    }//:Func
</code></pre>
",0
51972282,51971660,0,"<p>Well... thanks for negative votes (someone shall review that more carefully).</p>

<p>Seems that in C you just cannot extend enums.
Thanks to this post, I found a trick that works perfect for me
<a href=""https://stackoverflow.com/questions/11076941/warning-case-not-evaluated-in-enumerated-type"">Warning : case not evaluated in enumerated type?</a></p>

<p>Cast switch to int, than cast old enum to new one so:
- compiler will not complain about missing sw entry
- compiler will not complain about unused xxx_t</p>

<p>Here is my solution in case anyone needs to ""extend enums"" in C </p>

<pre><code>   typedef enum {
        GPS_MCU_UART_DEFAULT = 10,
    }xxx_t;


    switch((int)(xxx_t)(me-&gt;State))
    {
    case STATE_RUN:

        break;

    case GPS_MCU_UART_DEFAULT:

        break;


    }
</code></pre>

<p>I will give my vote to Tim, thanks!</p>
",0
55166883,55166623,1,"<p>When <code>group3d</code> is defined with <code>int (*group3d)[GROUPCOUNT][SENSORCOUNT][SENSORDIM]</code>, then <code>*group3d</code> is a three-dimensional array. That would let you use it with <code>(*group3d)[1][5][1]</code>.</p>

<p>To use it with <code>group3d[1][5][1]</code>, you need <code>group3d</code> to be a pointer to a two-dimensional array:</p>

<pre><code>int (*group3d)[SENSORCOUNT][SENSORDIM] = (int (*)[SENSORCOUNT][SENSORDIM]) groupdata;
</code></pre>

<p>(There are some technical concerns about C semantics in aliasing an array of <code>int</code> as an array of array of array of <code>int</code>, but this is not a problem in common compilers with default settings. However, it would be preferable to always use the memory as an array of array of array of <code>int</code>, not as an array of <code>int</code>.)</p>
",1
55988803,55988643,4,"<p>C strings are null-terminated by <strong>convention</strong>. That means that <code>printf</code>, or any other function receiving a C string, will read the pointed memory till it encounters a null character.</p>

<p>In your case there's no null terminator in <code>str</code>, so <code>printf</code> will keep reading from whatever memory comes next. This is undefined behavior. When you tried it yourself, you were lucky to have null following right after <code>str</code>, so <code>printf</code> stopped right ahead. If you are less lucky you can get garbage or a segfault. That's probably what happened when the code was executed by the judge.</p>

<p>Note that <code>str[5] = '\0'</code> is undefined behavior too, because <code>str[5]</code> is beyond the size of the array.</p>

<p>Alternative solutions that work: </p>

<p>Include the null terminator:</p>

<pre><code>char str[6]={r1,r2,r3,r4,r5,0};
</code></pre>

<p>Or pass the size of the buffer to <code>printf</code>:</p>

<pre><code>printf(""%.5s\n"", str);
</code></pre>

<p>Or:</p>

<pre><code>printf(""%.*s\n"", (int)sizeof(str), str);
</code></pre>

<p>Or use <code>fwrite</code>:</p>

<pre><code>fwrite(str, 1, sizeof(str), stdout);
fputc('\n', stdout);
</code></pre>
",5
53904319,16370363,1,"<p>Here's a short version:</p>

<pre><code>#include &lt;stdio.h&gt;

#define HEIGHT 6

int main(void) {
    char* f = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    char* b = ""ZYXWVUTSRQPONMLKJIHGFEDCBA"";
    int c = 0;

    for(int i=0; i&lt;HEIGHT; ++i)
    {
        printf(""%*.*s%.*s\n"", 10, i+1, f+i+c, i, b+strlen(b)-(c+2*i));
        c+=i;
    }
    return 0;
}
</code></pre>

<p><a href=""https://ideone.com/d90eRD"" rel=""nofollow noreferrer"">IDEOne Link</a></p>

<h1>Output:</h1>

<pre><code>Success #stdin #stdout 0s 9424KB
         A
        BCB
       DEFED
      GHIJIHG
     KLMNONMLK
    PQRSTUTSRQP
</code></pre>
",0
49616034,49615312,1,"<p>1) If you know the size of of your array you may want to be more precise with the allocation. </p>

<p>2) Remember to check if your allocation was successful.</p>

<p>3) When you do not needs your array <code>free</code> the allocated memory </p>

<p>The program may look like:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void read(double (*data)[6], int size, double *array)
{
 //do something and generate size and array[size*6]
 int i,j;
  for(i=0;i&lt;size;i++){
    for(j=0;j&lt;6;j++) 
        data[i][j]=array[i*6+j];
    }
}

int main(void) {

    int size = 6;
    int i,j;

    double arr[] = {
        1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 0.1, 0.1, 0.2,
        1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 0.1, 0.1, 0.2,
        1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 0.1, 0.1, 0.2,
        1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 0.1, 0.1, 0.2,
    };

    double (*data)[size] = malloc(sizeof(double[size][size]));
    if (data==NULL)
        return -1;

    read(data, size, arr);

    for (i = 0; i &lt; size; ++i){
        for(j=0;j&lt;6;j++) 
            printf(""%lf "", data[i][j]);
        printf(""\n"");
    }

    free(data);
    return 0;
}
</code></pre>

<p>Test:</p>

<pre><code>1.000000 2.000000 3.000000 4.000000 5.000000 6.000000                                                                                     
7.000000 8.000000 9.000000 0.100000 0.100000 0.200000                                                                                     
1.000000 2.000000 3.000000 4.000000 5.000000 6.000000                                                                                     
7.000000 8.000000 9.000000 0.100000 0.100000 0.200000                                                                                     
1.000000 2.000000 3.000000 4.000000 5.000000 6.000000                                                                                     
7.000000 8.000000 9.000000 0.100000 0.100000 0.200000 
</code></pre>
",6
54504460,54504366,1,"<p>The negation in <code>~0</code> will happen with type <code>int</code>.
But even if you do <code>~(unsigned char)0</code>, it'll still happen with type int because of implicit promotions.
Consequently, you'll get extra more 1-bits on the left (int is usually 32 bits large (must be at least 16)).
You can strip them by casting the bitnegation result to <code>uint8_t</code>.</p>

<p>I'd also recommend doing bit ops on <code>unsigned</code>s (<code>0</code>u rather than <code>0</code>) as the semantics are better standardized for those.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

void printfbits(int x) {
    for (int i=7; i&gt;=0;i--) {
        printf(""%d"", x&gt;&gt;i &amp; 1);
    }
    printf(""\n"");
}

int main() {
    printfbits( (uint8_t)~0u &gt;&gt;1 );  //prints 01111111
}
</code></pre>
",0
54504432,54504366,4,"<p>Right shift of negative signed values is <strong>implementation defined</strong>.  For gcc, a 1 is shifted in, otherwise a 0 is shifted in.</p>

<p>You were on the right track with the cast, but it doesn't help since the function still expects an <code>int</code>.  You need to change the function to take an <code>unsigned char</code> and you have to mask out all but the lowest byte before performing the shift in the function call.</p>

<pre><code>#include &lt;stdio.h&gt;

void printfbits(unsigned char x) {
    for (int i=7; i&gt;=0;i--) {
        printf(""%d"", x&gt;&gt;i &amp; 1);
    }
    printf(""\n"");
}

int main() {
    printfbits((~0u &amp; 0xff)&gt;&gt;1);
}
</code></pre>

<p>Also, note the use of the <code>U</code> suffix on the constant 0.  That gives the constant a type of <code>unsigned int</code>.</p>
",3
54504460,54504366,1,"<p>The negation in <code>~0</code> will happen with type <code>int</code>.
But even if you do <code>~(unsigned char)0</code>, it'll still happen with type int because of implicit promotions.
Consequently, you'll get extra more 1-bits on the left (int is usually 32 bits large (must be at least 16)).
You can strip them by casting the bitnegation result to <code>uint8_t</code>.</p>

<p>I'd also recommend doing bit ops on <code>unsigned</code>s (<code>0</code>u rather than <code>0</code>) as the semantics are better standardized for those.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

void printfbits(int x) {
    for (int i=7; i&gt;=0;i--) {
        printf(""%d"", x&gt;&gt;i &amp; 1);
    }
    printf(""\n"");
}

int main() {
    printfbits( (uint8_t)~0u &gt;&gt;1 );  //prints 01111111
}
</code></pre>
",0
54504432,54504366,4,"<p>Right shift of negative signed values is <strong>implementation defined</strong>.  For gcc, a 1 is shifted in, otherwise a 0 is shifted in.</p>

<p>You were on the right track with the cast, but it doesn't help since the function still expects an <code>int</code>.  You need to change the function to take an <code>unsigned char</code> and you have to mask out all but the lowest byte before performing the shift in the function call.</p>

<pre><code>#include &lt;stdio.h&gt;

void printfbits(unsigned char x) {
    for (int i=7; i&gt;=0;i--) {
        printf(""%d"", x&gt;&gt;i &amp; 1);
    }
    printf(""\n"");
}

int main() {
    printfbits((~0u &amp; 0xff)&gt;&gt;1);
}
</code></pre>

<p>Also, note the use of the <code>U</code> suffix on the constant 0.  That gives the constant a type of <code>unsigned int</code>.</p>
",3
59196171,59195812,0,"<p>I'm not sure what <em>""(with their own arguments)""</em> in your question is suppsed to mean exactly.</p>

<p>Are you looking for something like this?</p>

<pre><code>#include &lt;stdio.h&gt;

char* howdy(int arg) { printf(""&gt;howdy: arg = %d\n"", arg); return ""howdy""; }
char* goodbye(int arg) { printf(""&gt;goodbye: arg = %d\n"", arg);  return ""goodbye""; }

typedef char* (*Charpfunc)(int arg);

void print(Charpfunc* p, int arg)
{
  while (*p) {
    puts((*p)(arg));
    p++;
  }
}

int main()
{
  Charpfunc funcs[] = {
      howdy, goodbye, NULL
  };

  print(funcs, 111);
  print(funcs, 222);
  return 0;
}
</code></pre>

<p>or maybe something like this:</p>

<pre><code>#include &lt;stdio.h&gt;

char* howdy(int arg) { printf(""&gt;howdy: arg = %d\n"", arg); return ""howdy""; }
char* goodbye(int arg) { printf(""&gt;goodbye: arg = %d\n"", arg);  return ""goodbye""; }

typedef char* (*Charpfunc)(int arg);

void print(Charpfunc* p, int *arg)
{
  while (*p) {
    puts((*p)(*arg));
    p++;
    arg++;
  }
}

int main()
{
  Charpfunc funcs[] = {
      howdy, goodbye, NULL
  };

  int arg111[] = { 1, 11 };
  int arg222[] = { 2, 22 };
  print(funcs, arg111);
  print(funcs, arg222);
  return 0;
}
</code></pre>
",1
56690711,56690644,8,"<p>When you declare a variable of a given type, it refers to an underlying object of that type, so the object's effective type is the type of the associated variable.</p>

<p>Where things get a little fuzzy is when <code>malloc</code> comes into play.  Memory returned from <code>malloc</code> has no effective type.  For example:</p>

<pre><code>int *x = malloc(sizeof(int));
</code></pre>

<p>Assuming an <code>int</code> is 4 bytes in size, <code>x</code> now points to 4 bytes of memory with no effective type.  This memory gets an effective type when assigned to:</p>

<pre><code>*x = 123;
</code></pre>

<p>Now those bytes have an effective type of <code>int</code>.</p>

<p>In the case of your example, you allocate 1000 bytes, and initially these bytes have no effective type.</p>

<pre><code>*x = 10;
</code></pre>

<p>This makes the first <code>sizeof(int)</code> bytes an object of type <code>int</code>.</p>

<pre><code>struct point *p = x;
</code></pre>

<p>This <em>should</em> have a cast, but in the end it's OK because the first member of <code>struct point</code> has type <code>int</code>, and a pointer to a struct points to its first member.</p>

<pre><code>p-&gt;x = 5;
</code></pre>

<p>This is therefore safe, because <code>&amp;p-&gt;x</code> points to an object of type <code>int</code>, which matches the type of the lvalue <code>p-&gt;x</code>.</p>

<pre><code>p-&gt;y = 10;
</code></pre>

<p>This is also safe, because the bytes pointed to by <code>&amp;p-&gt;y</code> do not yet have an effective type, and the assignment causes the next <code>sizeof(int)</code> bytes to be an object of type <code>int</code>.</p>
",14
49289239,49288600,2,"<p>Maybe this is what you're after.  The code uses the pointers <code>p1</code> and <code>p2</code> to point alternatively at <code>array1</code>/<code>array2</code> or <code>array2</code>/<code>array1</code> respectively.</p>

<pre><code>#include &lt;stdio.h&gt;

static void dump_array(const char *tag, int num, double *data)
{
    printf(""%8s"", tag);
    for (int i = 0; i &lt; num; i++)
        printf("" %4.0f"", data[i]);
    putchar('\n');
}

int main(void)
{
    int dim = 10;
    double array1[dim];
    double array2[dim];

    for (int i = 0; i &lt; dim; i++)
        array1[i] = i;

    double *p1 = array1;
    double *p2 = array2;

    dump_array(""p1:"", dim, p1);
    for (int i = 0; i &lt; 5; i++)
    {
        for (int j = 0; j &lt; dim; j++)
            p2[j] = 2 * (p1[j] + 2) + j;
        dump_array(""p2:"", dim, p2);
        dump_array(""array1:"", dim, array1);
        dump_array(""array2:"", dim, array2);
        double *tp = p1;
        p1 = p2;
        p2 = tp;
        putchar('\n');
    }
}
</code></pre>

<p>Sample output:</p>

<pre><code>     p1:    0    1    2    3    4    5    6    7    8    9
     p2:    4    7   10   13   16   19   22   25   28   31
 array1:    0    1    2    3    4    5    6    7    8    9
 array2:    4    7   10   13   16   19   22   25   28   31

     p2:   12   19   26   33   40   47   54   61   68   75
 array1:   12   19   26   33   40   47   54   61   68   75
 array2:    4    7   10   13   16   19   22   25   28   31

     p2:   28   43   58   73   88  103  118  133  148  163
 array1:   12   19   26   33   40   47   54   61   68   75
 array2:   28   43   58   73   88  103  118  133  148  163

     p2:   60   91  122  153  184  215  246  277  308  339
 array1:   60   91  122  153  184  215  246  277  308  339
 array2:   28   43   58   73   88  103  118  133  148  163

     p2:  124  187  250  313  376  439  502  565  628  691
 array1:   60   91  122  153  184  215  246  277  308  339
 array2:  124  187  250  313  376  439  502  565  628  691
</code></pre>
",2
49289110,49288600,-1,"<p>The compiler is right, you cannot assign an array directly. You can initiate it directly and then loop through it to change it:</p>

<pre><code>#include &lt;stdio.h&gt;

double array[5] = {1, 2, 3, 4, 5};
double temparray[5] = {0, 0, 0, 0, 0};

void printArrays() {
    for (int i = 0; i &lt; 5; i++) {
        printf(""%f\n"", array[i]);
    }
    for (int i = 0; i &lt; 5; i++) {
        printf(""%f\n"", temparray[i]);
    }
}

void arrayCopy() {
    for (int i = 0; i &lt; 5; i++) {
        array[i] = temparray[i];
    }
}

int main() {
    printf(""Hello, Arrays!\n"");
    printArrays();
    arrayCopy();
    printf(""Hello, Arrays!\n"");
    printArrays();
    return 0;
}
</code></pre>

<p>There are many ways to illustrate it but I've tried to keep it simple above. It just replaces the elements of one array with another. </p>
",0
55583260,55582571,1,"<p>You can find relevant code on SO.  For example, the <code>rand_int()</code> code below is based on code for integers in an answer to
<a href=""https://stackoverflow.com/q/3343797"">Is this C implementation of the Fisher-Yates shuffle correct?</a> (and specifically the <a href=""https://stackoverflow.com/a/3348142"">answer</a> by <a href=""https://stackoverflow.com/users/225757/roland-illig"">Roland Illig</a>):</p>

<pre><code>static size_t rand_int(size_t n)
{
    size_t limit = RAND_MAX - RAND_MAX % n;
    size_t rnd;

    while ((rnd = rand()) &gt;= limit)
        ;
    return rnd % n;
}
</code></pre>

<p>The idea is that you calculate and ignore the large values returned by <code>rand()</code> which would lead to biassed results.  When one of the large values is returned, you ignore it and try the next value.  This will seldom need more than two calls to <code>rand()</code>.</p>

<p>You might find some of the external references in <a href=""https://stackoverflow.com/questions/6127503/shuffle-array-in-c"">Shuffle array in C</a> useful too.</p>
",0
50571379,50571330,6,"<p><code>-2147483648</code> is <code>2147483648</code>, a <code>long</code> number on your platform (because it's a decimal* greater than <code>INT_MAX</code> that fits in a <code>long</code>), negated.
Numbers in C (and the C preprocessor) are parsed separately from the <code>-</code> unary operator. That is why e.g., the glibc implementation of the standard C library implements the <code>INT_MIN</code> macro as <code>(-INT_MAX - 1)</code>.</p>

<hr>

<p>*The <a href=""https://stackoverflow.com/a/47206691/1084774"">rules determining what type to use for an integer literal with or without a suffix</a> differ depending on the radix of the literal.  </p>
",0
51263931,51263894,0,"<p>Use <code>scanf(""%c"", &amp;opr)</code> to read a single <code>char</code>.</p>

<p>Using <code>%s</code> will read a NUL terminated string, but you have only one byte which is insufficient, leading to undefined behavior.</p>

<p>What's actually happening is that the NUL terminator is being written on top one byte of the <code>int</code> variable next to <code>opr</code>.</p>
",0
53878017,53877953,3,"<p><code>x++</code> and <code>++x</code> both add <code>1</code> to <code>x</code>. The only difference between them is the value of the expression itself, e.g. if you do:</p>

<pre><code>y1 = x++;
</code></pre>

<p>or</p>

<pre><code>y2 = ++x;
</code></pre>

<p><code>y1</code> will get the <em>old</em> value of <code>x</code>, while <code>y2</code> will get the <em>new</em> value of <code>x</code>. See <a href=""https://stackoverflow.com/questions/3346450/what-is-the-difference-between-i-and-i?noredirect=1&amp;lq=1"">What is the difference between i++ and ++i?</a>.</p>

<p>Since you don't assign the result of the expression to anything, the difference is irrelevant in your program. If you had written:</p>

<pre><code>sum = sum + ++x;
</code></pre>

<p>you would get a different result than</p>

<pre><code>sum = sum + x++;
</code></pre>

<p>since now you're using the value of the expression, and the result matters.</p>

<p>Regarding your second question, statements are executed in order. So if you put <code>++x;</code> before the assignment, then you'll be adding the incremented values of <code>x</code> to <code>sum</code> instead of the original values. Instead of adding <code>1</code>, <code>2</code>, <code>3</code>, ... <code>10</code>, you'll add <code>2</code>, <code>3</code>, <code>4</code>, ..., <code>11</code>. You can see this difference if you put:</p>

<pre><code>printf(""Adding %d + %d\n"", sum, x);
</code></pre>

<p>before the assignment.</p>

<p>Putting the increment statement before or after the assignment is similar to using the increment expression in the assignment itself, and choosing between pre-increment and post-increment. I.e.</p>

<pre><code>++x; // or x++;
sum = sum + x;
</code></pre>

<p>is the same as</p>

<pre><code>sum = sum + ++x;
</code></pre>

<p>Conversely,</p>

<pre><code>sum = sum + x;
++x; // or x++;
</code></pre>

<p>is the same as</p>

<pre><code>sum = sum + x++;
</code></pre>
",0
54690258,54690059,4,"<p>The first structure has one element of size 2 (assuming <code>short</code> has size 2 on your system). It is as good as directly having an array of short directly.</p>

<p>The second structure is a special thing: access to <code>short</code> variables is best done on even addresses. If we hadn't padding, we had the following:</p>

<pre><code>struct s arr[5]; // an array
void * a = arr; // needed to reference it
</code></pre>

<p>Then,</p>

<ul>
<li><code>arr[0].c</code> is at <code>a</code>.</li>
<li><code>arr[0].a</code> is at <code>a</code> + 2 bytes.</li>
<li><code>arr[1].c</code> is at <code>a</code> + 3 bytes (!).</li>
<li><code>arr[1].a</code> is at <code>a</code> + 5 bytes (!).</li>
</ul>

<p>As it is preferrable to have <code>arr[1].c</code> at an even address, we add padding. Then,</p>

<ul>
<li><code>arr[1].c</code> is at <code>a</code> + 4 bytes.</li>
<li><code>arr[1].a</code> is at <code>a</code> + 6 bytes.</li>
</ul>
",0
54690333,54690059,5,"<p>The predominant use of padding is to align structure members as required by the hardware (or other aspects of the C implementation). An algorithm for laying out data in a struct is in <a href=""https://stackoverflow.com/a/11906915/298225"">this answer</a>.</p>

<p>To answer the question in your title, when do structures not have padding: A structure does not require padding for alignment if each member¡¯s alignment requirement is a divisor of the total size of all preceding members and of the total size of all members. (A C implementation may still add padding for reasons other than alignment, but that is a bit unusual.)</p>

<p>For your examples, let¡¯s suppose, in a C implementation, <code>short</code> is two bytes in size and requires two-byte alignment. By definition, <code>char</code> is one byte and requires one-byte alignment.</p>

<p>Then, in <code>struct s {short c;}</code>:</p>

<ul>
<li><code>c</code> is put at the beginning of the <code>struct</code>. There is never any padding at the beginning.</li>
<li>If we make an array of these <code>struct</code>, the next <code>struct s</code> will begin two bytes beyond the first, and its member <code>c</code> will still be at a multiple of two bytes, so it is aligned correctly.</li>
<li>Therefore, we do not need any padding to make this work.</li>
</ul>

<p>In contrast, in <code>struct s {short c; char a;}</code>:</p>

<ul>
<li><code>c</code> is put at the beginning.</li>
<li><code>a</code> is put two bytes after <code>c</code>. This is fine, since <code>a</code> only requires one-byte alignment.</li>
<li>If we do not add any padding, the size of the <code>struct</code> is three bytes. Then, if we make an array of these <code>struct</code>, the next <code>struct s</code> will begin three bytes from the start.</li>
<li>In that second <code>struct s</code>, the <code>c</code> member will be at an offset of three bytes. That violates the alignment requirement for <code>short</code>.</li>
<li>Therefore, to make this <code>struct</code> work, we must add one byte of padding. This makes the total size four bytes. Then, in an array of these <code>struct</code>, all the members will be at boundaries required by their alignment.</li>
</ul>

<p>Even if you declare just a single object of a structure, as in <code>struct s {short c; char a;} x;</code>, a structure is always laid out so it can be used in an array.</p>
",0
53922125,53922059,4,"<p>The expression <code>(p++, ++p)</code> has a <a href=""https://en.wikipedia.org/wiki/Comma_operator"" rel=""nofollow noreferrer""><em>comma operator</em></a>. The comma operator evaluates its operand left-to-right and yields the result of the right most operand. Thus <code>i</code> gets the value <code>-6</code> (after <code>p++</code> and <code>++p</code> operations).</p>
",0
52853220,52853017,3,"<p>Lets take a closer look at these two lines:</p>

<pre><code>char *q=NULL;
Sasprintf(q,""select * from tab"");
</code></pre>

<p>If we expand the macro it will become (roughly):</p>

<pre><code>char *q=NULL;
{
    char *tmp_string_for_extend = (q);
    asprintf(&amp;(q), ""select * from tab"");
    free(tmp_string_for_extend);
}
</code></pre>

<p>It should be quite clear that the initialization of <code>tmp_string_for_extend</code> will be equivalent to initialize it to <code>NULL</code>, since <code>q</code> at that point is <code>NULL</code>.</p>

<p>So when you call <code>free(tmp_string_for_extend)</code> you're effectively doing <code>free(NULL)</code>. Calling <code>free</code> with a null pointer does <em>nothing</em>.</p>

<p>If you instead do <code>free((write_to))</code> in the macro then it will be expanded to <code>free((q))</code> which will free the memory you just allocated with <code>asprintf</code>. Dereferencing <code>q</code> after that (which happens when you print the contents) will lead to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>.</p>

<p>You should call <code>free(q)</code> <em>after</em> you're fully done with <code>q</code>.</p>

<hr>

<p>Also note that for most <code>sprintf</code> variants, probably including the GNU libc-specific <code>asprintf</code> function, using the same argument for both source (as an argument) and as destination usually is <em>undefined behavior</em> as well. Which makes your second macro invocation invalid. And even if it was defined, then it could be a memory leak if <code>asprintf</code> doesn't free any non-null pointer.</p>
",6
48629217,48629089,0,"<p>The standard formatters are <a href=""http://en.cppreference.com/w/cpp/io/c/fprintf"" rel=""nofollow noreferrer"">well documented</a>. The <code>%d</code> one in particular is for integer, ""decimal"" values. This means the <code>.</code> separator is meaningless here since those don't have any particular precision like floating point values require.</p>

<p>That notation is reserved for situations like:</p>

<pre><code>printf(""%04.1f"", 3.9);
</code></pre>

<p>Which would give you <code>03.9</code>, four characters for the field, one decimal place, one point of precision.</p>

<p>In the case of <code>%d</code> the precision value is interpreted differently:</p>

<blockquote>Precision specifies the minimum number of digits to appear. The default precision is 1.</blockquote>

<p>It has an entirely different meaning, but it's rare to see that particular aspect of it used.</p>
",2
48629218,48629089,5,"<p>For <code>%d</code> if a precision (which specifies the minimum number of characters) is specified then the <code>0</code> flag is ignored, since it is performing a similar function.</p>

<p>The man page states the following regarding the <code>0</code> flag:</p>

<blockquote>
  <p>The  value  should  be  zero padded.  For d, i, o, u, x, X, a, A, e,
  E, f, F, g, and G conversions, the converted value is padded on the
                left with zeros rather than blanks.  If the 0 and - flags both appear, the 0 flag is ignored.  <strong>If a precision is given 
  with  a  numeric
                conversion (d, i, o, u, x, and X), the 0 flag is ignored.</strong>  For other conversions, the behavior is undefined.</p>
</blockquote>

<p>And the following regarding precision:</p>

<blockquote>
  <p>An  optional precision, in the form of a period ('.')  followed by an
  optional decimal digit string.  Instead of a decimal digit string one
  may
         write ""*"" or ""*m$"" (for some decimal integer m) to specify that the precision is given in the next argument, or in the m-th  argument,
  respectively, which must be of type int.  If the precision is given as just '.', the precision is taken to be zero.  A negative precision
  is taken as
         if the precision were omitted.  <strong>This gives the minimum number of digits to appear for d, i, o, u, x, and X conversions</strong>, the number
  of digits to
         appear after the radix character for a, A, e, E, f, and F conversions, the maximum number of significant digits for g and G
  conversions, or the
         maximum number of characters to be printed from a string for s and S conversions.</p>
</blockquote>

<p>In your case, since you specified 1 for the precision, then 1 character minimum needs to be printed.  Had you used 4 for the precision, you would have gotten a single leading zero.</p>
",0
54774149,54774028,7,"<p>You cannot initialize a flexible array member. Per C 2018 6.7.2.1 18, in most situations, a flexible array member is ignored. This is one of those situations: In initialization, it is as if the member does not exist.</p>

<p>Creating a structure with a flexible array member in a declaration statement can only create a structure with zero members in the array. To create a structure with more members in the array, you should dynamically allocate space with <code>malloc</code> or a similar routine. Once you have allocated sufficient space, you may convert the pointer to a pointer to a <code>Category</code> and then assign (rather than initialize) values to its members, including elements of its flexible array member.</p>

<p>(Conceivably, there might be a horrible way to define a union containing a structure with a flexible array member in such a way that sufficient space is provided for elements of the array, by stuffing the union with a <code>char</code> array of the necessary size. You still could not initialize those elements, but you could assign to them. Do not do this.)</p>

<p>To set up some prototype <code>Category</code> objects, you could use:</p>

<pre><code>static const Category category1 = {""Academic Registrar""};
static const Category category2 = {""Financial Services""};
static const Category category3 = {""IT Support"", ""IT""};
static const Category category4 = {""Parking Police"", ""PP""};
static const Category category5 = {""Coop Placement"", ""CP""};
</code></pre>

<p>Later, to create a <code>Category</code> with several <code>Ticket</code> elements, you could do:</p>

<pre><code>Category *C = malloc(sizeof *C + nTickets * sizeof(Ticket));
// Test C for NULL in case malloc failed.

// Copy initial data into new Category.
*C = category3;

// Assign values to Ticket elements.
for (int i = 0; i &lt; nTickets; ++i)
{
    C-&gt;ticket[i] = rand();
    C-&gt;timestamp = 0;
}
</code></pre>

<p>Note that you cannot create an array of <code>Category</code> objects, because they have flexible size, and objects in an array can only have a fixed size. So you can only work with one <code>Category</code> at a time. The <code>C</code> pointer above can only point to one <code>Category</code>, not an array of them. But the <code>C-&gt;ticket</code> member is an array of <code>Ticket</code>.</p>

<p>Note that I do not necessarily recommend copying data into a <code>Category</code> from prototypes that way. If the data is short, it could just be assigned in code. If the data is long, it might be better to use pointers to data instead of copying all the data into each one. Good solutions depend on circumstances. The above code is given just as an example.</p>
",7
54774328,54774028,3,"<p>For <code>const</code> structures of static duration, a workable approach in most cases is to declare a structure which has the same members as the FAM version, but with the flexible array member replaced by a suitably-sized array, and then construct a union which contains that type as well as the one with the Flexible Array Member.  The Common Initial Sequence guarantees imply that either type may be used to inspect the common members, and if an implementation gives any heed whatsoever to footnote 88 of the C11 draft (N1570) which says the purpose of 6.5p7 is to specify the circumstance when things may alias, it will refrain from using the rule as an excuse to break such code, since references to storage that is never modified never alias (aliasing involves situations where re-ordering accesses to an object would affect the semantics thereof; if an object is never modified, the order of accesses will never have any observable effect).</p>

<p>In theory, an implementation would be allowed to place a flexible array member at a different offset from a fixed-sized array, but code could, if desired, use a static assertion to ensure that does not happen.  A deliberately-obtuse interpretation might break things, but since the One Program Rule would allow deliberately-obtuse implementations to break just about any program, that's not really saying much.</p>
",0
49313017,49312949,4,"<p>You have declared <code>funcaddr</code> as an object pointer. To declare a function pointer it looks like this:</p>

<pre><code>struct callout {
   uint32 time;
   void (*funcaddr)();  // &lt;-------- function pointer
</code></pre>

<p>Then the rest of your code should work.</p>

<hr>

<p>If you didn't see an error message for the line <code>coptr-&gt;funcaddr = &amp;test;</code> then I would recommend adjusting your compiler settings, it's important to have the information available that the compiler can tell you.</p>
",2
54237901,54237004,5,"<blockquote>
  <p>I had suggested that proposed approach does not follow strict aliasing rule</p>
</blockquote>

<p>Correct. <code>ptrMsg = (Message *)buffer</code> means that you cannot access the data of <code>ptrMsg</code> without invoking undefined behavior.</p>

<p>You can prove your point with C17 6.5 ¡ì7 (<a href=""https://stackoverflow.com/a/7005988/584518"">cited here - What is the strict aliasing rule?</a>). An lvalue expression such as <code>ptrMsg-&gt;var1 = value</code> does not access the stored value through a type compatible with the effective type of what's stored there, nor through any of the allowed expressions.</p>

<p>You can however go from <code>Message</code> to an array of <code>uint8_t</code> (assuming <code>uint8_t</code> is a character type) without violating strict aliasing.</p>

<hr>

<p>The larger problem is however the presence of the bit-field in the first place, which is non-standard and non-portable. For example, you cannot know which part of the bit-field that is the MSB and LSB. You cannot know how the bits are aligned in the 64 bit type. Using a 64 bit type for a bit-field is a non-standard extension. It is endianess-dependent. And so on.</p>

<hr>

<p>Assuming the 24 bits refer to bit 31 to 8 (we can't know by reading your code), then proper code without strict aliasing violations, bit-field madness and non-standard ""struct padding killers"" would look like this:</p>

<pre><code>typedef union
{
   uint32_t var;
   uint8_t  bytes[4];
} Message;


uint8_t buffer[4];
Message* ptrMsg = (Message*)buffer;
uint32_t var1 = (ptrMsg-&gt;var &gt;&gt; 8);
uint8_t  var2 = (ptrMsg-&gt;var &gt;&gt; 4) &amp; 0x0F;
uint8_t  var3 = (ptrMsg-&gt;var) &amp; 0x0F;
</code></pre>

<p><code>Message</code> being ""a union type that includes one of the aforementioned types among its
members"". Meaning it contains a type compatible with <code>uint8_t [4]</code>.</p>

<p>This code also contains no copying and the shifts will get translated to the relevant bit access in the machine code.</p>
",0
54237874,54237004,4,"<p>You are right.</p>

<p>C17 draft ¡ì 6.5:</p>

<blockquote>
  <ol start=""7"">
  <li><p>An object shall have its stored value accessed only by an lvalue expression that has one of the
  following types: <sup>89)</sup></p>
  
  <ul>
  <li><p>a type compatible with the effective type of the object,</p></li>
  <li><p>a qualified version of a type compatible with the effective type of the object,</p></li>
  <li><p>a type that is the signed or unsigned type corresponding to the effective type of the object,</p></li>
  <li><p>a type that is the signed or unsigned type corresponding to a qualified version of the effective
  type of the object,</p></li>
  <li>an aggregate or union type that includes one of the aforementioned types among its members
  (including, recursively, a member of a subaggregate or contained union), or</li>
  <li>a character type.</li>
  </ul></li>
  </ol>
</blockquote>

<p>In this case the object is of type <code>uint8_t[]</code> and type of the lvalue expression is <code>Message</code>. None of the exceptions above apply.</p>

<p>Using <code>memcpy</code> over dereferences fixes this issue, or alternatively you can disable the strict aliasing in your compiler if you want to write in non-C language.</p>

<p>But even after this the code has a lot of problems and is not portable: Bitfields are extremely poorly defined in standard and overall structures are very clumsy way to handle serialization. You should take the option of deserializing each member manually.</p>
",3
49803264,49803044,1,"<p>You want <code>records</code> to be an array of strings, so it should be:</p>

<pre><code>char **records = NULL;
int num_records = 0;
</code></pre>

<p>Then, when you add a string to the records array:</p>

<pre><code>records = realloc(records, sizeof(*records) * (num_records + 1));
if (NULL == records) { // Handle failure }
records[num_records] = malloc(strlen(name) + 1);
if (NULL == records[num_records]) { // Handle failure }
strcpy(records[num_records], name);
num_records += 1;
</code></pre>

<p>And don't forget to <code>free()</code> all that data.</p>
",0
56986095,56985548,3,"<p>When you declare <code>struct room *rooms[max_entries];</code> you will have in the data segment an array of <code>max_entries</code> pointers that are initialized to <code>NULL</code>. </p>

<p>As you do not allocate memory for your room, it means that when you write <code>rooms[i]-&gt;room_name</code> you will have essentially done the same as <code>NULL-&gt;room_name</code>. The memory protection mechanism of you system detects that you want to access a memory portion that is not allowed and signals it to you with a segmentation fault.</p>

<p>you have to add:</p>

<pre><code> rooms[i] = malloc(sizeof (struct room));
 if(!rooms[i]) exit(EXIT_FAILURE);  // example error handling, can be different
</code></pre>

<p>to your loop.</p>

<p>BTW: it is usage in C to define macros in all caps so that it is immediately visible that it is a macro. You should therefore use</p>

<pre><code>#define MAX_ENTRIES 5
</code></pre>

<p>instead.</p>
",0
54973397,54973288,4,"<pre><code>void    rush(x &gt; 0 &amp;&amp; y &gt; 0)
</code></pre>

<p>That is not a valid C declaration of a function. (Are <code>x &gt; 0</code> and <code>y &gt; 0</code> supposed to be prerequisites to the function call?) A proper function call shows the types of the parameters, as in:</p>

<pre><code>void    rush(int x, int y)
</code></pre>

<p>Neither the <code>rush</code> function nor the <code>main</code> routine has any loop. Some sort of loop is necessary in order to iterate through the rows and columns of the image and prepare characters to output to generate the image.</p>

<pre><code>if (w == 1 || w == x) &amp;&amp; (h == 1 || h == y)
</code></pre>

<p>An <code>if</code> statement must have one expression enclosed in parentheses. You can combine two expressions with <code>&amp;&amp;</code>, but the entire resulting expression must be enclosed in parentheses:</p>

<pre><code>if ((w == 1 || w == x) &amp;&amp; (h == 1 || h == y))
</code></pre>

<p>Fix the function declaration, fix the <code>if</code> statements, and write two <code>for</code> loops to iterate <code>h</code> and <code>w</code>, and then you will have made substantial progress toward the goal.</p>
",0
54973397,54973288,4,"<pre><code>void    rush(x &gt; 0 &amp;&amp; y &gt; 0)
</code></pre>

<p>That is not a valid C declaration of a function. (Are <code>x &gt; 0</code> and <code>y &gt; 0</code> supposed to be prerequisites to the function call?) A proper function call shows the types of the parameters, as in:</p>

<pre><code>void    rush(int x, int y)
</code></pre>

<p>Neither the <code>rush</code> function nor the <code>main</code> routine has any loop. Some sort of loop is necessary in order to iterate through the rows and columns of the image and prepare characters to output to generate the image.</p>

<pre><code>if (w == 1 || w == x) &amp;&amp; (h == 1 || h == y)
</code></pre>

<p>An <code>if</code> statement must have one expression enclosed in parentheses. You can combine two expressions with <code>&amp;&amp;</code>, but the entire resulting expression must be enclosed in parentheses:</p>

<pre><code>if ((w == 1 || w == x) &amp;&amp; (h == 1 || h == y))
</code></pre>

<p>Fix the function declaration, fix the <code>if</code> statements, and write two <code>for</code> loops to iterate <code>h</code> and <code>w</code>, and then you will have made substantial progress toward the goal.</p>
",0
48114032,48113970,2,"<p>You cannot do this directly. With atof you e.g. change ""2.034"" to 2.034 (f), but not an expression (with a division in your case).</p>

<p>Instead, if you know there will be always a divider symbol, search for the divider symbol, than extract the left and right part, use atoi (string to integer), and divide the two integers (after casting to float).</p>
",5
55465695,55465170,0,"<p>I'm not a fan of using <code>scanf()</code> et.al. to parse data, as a simple <code>scanf(""%d,%d"")</code> tends to be error prone with differing user input.</p>

<p>My general approach when dealing with known formatting characters (like <code>(</code>, <code>,</code>, <code>)</code>), is to find them first with <code>strchr()</code>, validate they're somewhat sensible, and only then try to extract the value.</p>

<p>In the code below, I locate the parentheses and comma, then copy out the <em>possibly numeric</em> data in between, before handing it off to <code>strtol()</code> for converting the integer string to a numeric representation.  </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_NUMBER_LEN 32

/*
** Given a string which contains (somewhere) a pair
** of numbers in the form ""... (x, y) ..."", parse the pair
** into val1 and val2 respectively.
**
** Returns the point at which the input ended successfully
** or NULL on error
*/
const char *parseTuple(const char *input, int *val1, int *val2)
{
    char *result = NULL;
    char  val1_str[ MAX_NUMBER_LEN+1 ] = { '\0' }; 
    char  val2_str[ MAX_NUMBER_LEN+1 ] = { '\0' };

    // Find the first '('
    char *left_paren  = strchr( input, '(' );
    char *right_paren = strchr( input, ')' );
    char *comma       = strchr( input, ',' );

    // validate the things we found exist, and are in valid positions
    if ( left_paren != NULL &amp;&amp; right_paren != NULL &amp;&amp; comma != NULL &amp;&amp;   // needed parts exist
         left_paren &lt; comma &amp;&amp; comma &lt; right_paren )                     // in the correct order

    {
        // val1 source string exists between left_paren+1 and comma-1
        int val1_len = comma-1 - left_paren+1 - 1;
        if ( val1_len &gt; 0 &amp;&amp; val1_len &lt; MAX_NUMBER_LEN )
        { 
            strncpy( val1_str, left_paren+1, val1_len );
            val1_str[ val1_len ] = '\0';
        }

        // val2 source string exists between comma+1 and right_paren-1
        int val2_len = right_paren-1 - comma+1 - 1;
        if ( val2_len &gt; 0 &amp;&amp; val2_len &lt; MAX_NUMBER_LEN )
        { 
            strncpy( val2_str, comma+1, val2_len );
            val2_str[ val2_len ] = '\0';
        }

        // If we extracted some reasonable numbers, try to parse them
        if ( val1_str[0] != '\0' &amp;&amp; val2_str[0] != '\0' )
        {
            *val1 = strtol( val1_str, NULL, 10 );
            *val2 = strtol( val2_str, NULL, 10 );
            // TODO handle errno when string is not a number

            // if errono did not indicate a strol() failure
            result = right_paren+1;  // point to the next input location, so we can call again 
        }
    }

    return result;
}



int main(int argc, char **argv)
{
    const char *input;
    int val1;
    int val2;

    for (int i=1; i&lt;argc; i++)
    {
        input = argv[i];

        do
        {
            printf( ""From input of: [%s]\n"" , input );
            input = parseTuple( input, &amp;val1, &amp;val2 );
            if ( input != NULL )
                printf( ""    Parsed out: (%3d,%3d)\n"", val1, val2 );

        } while ( input != NULL &amp;&amp; strlen( input ) );
    }

    return 0;
}
</code></pre>

<p>Giving the test-run:</p>

<pre><code>$ ./parse_tuple '(-3, 2)' '(1,1)(11111111111111111111111111111111111111111111111111111111111111111111,0) () (,)' '(' '()' ')' '(,)' '(-12,)' '(123,456)'
From input of: [(-3, 2)]
    Parsed out: ( -3,  2)
From input of: [(1,1)(11111111111111111111111111111111111111111111111111111111111111111111,0) () (,)]
    Parsed out: (  1,  1)
From input of: [(11111111111111111111111111111111111111111111111111111111111111111111,0) () (,)]
From input of: [(]
From input of: [()]
From input of: [)]
From input of: [(,)]
From input of: [(-12,)]
From input of: [(123,456)]
    Parsed out: (123,456)
</code></pre>
",2
56609405,56609370,0,"<p>With your macro</p>

<pre><code>#define ADDR_TO_SETTING(ADDR) { #ADDR, setting_ ## ADDR}
</code></pre>

<p>the line</p>

<pre><code>settings.ADDR_TO_SETTING(ADDR_LOG_ACTIVE) = false;
</code></pre>

<p>expands to</p>

<pre><code>settings.{ ""ADDR_LOG_ACTIVE"", setting_ADDR_LOG_ACTIVE} = false;
</code></pre>

<p>which is a syntax error (particularly the <code>.{</code> part).</p>

<p>What did you expect to happen?</p>
",1
53630297,53630035,1,"<p>Both cases are incorrect. You can't use a <code>box_t**</code> to point at any array. Nor can it point to an array of type <code>box_t boxarray[10]</code>, because they are incompatible types. There is no need for several levels of indirection anywhere in your code.</p>

<p>You can however use a <code>box_t*</code> to point at the first element in an array, and that's what your code does here: <code>*box_bundle = boxarray;</code>. But in an obfuscated way.</p>

<p>Correct code should be: <code>box_t* box_bundle;</code>. If it should point at the original array, there is no need for malloc. If it should hold a copy of the original array, you need to alloc and copy the data: </p>

<pre><code>box_t* box_bundle = malloc (sizeof(*box_bundle)*10);
memcpy(box_bundle, boxarray, sizeof boxarray);
</code></pre>
",2
51968485,51967386,0,"<p>Given 3 functions and shift values (1, 2, 3).</p>

<p>If you apply this rule upon function invocation:</p>

<ul>
<li>set the most significant bit, then shift right by the respective value.</li>
</ul>

<p>For the given (order), you will get [these bits]:</p>

<pre><code>(1, 2, 3) [0, 0, 0, 1, 0, 1, 1, 0]
(1, 3, 2) [0, 0, 1, 0, 0, 1, 1, 0]
(2, 1, 3) [0, 0, 0, 1, 1, 0, 1, 0]
(2, 3, 1) [0, 1, 0, 0, 1, 0, 1, 0]
(3, 1, 2) [0, 0, 1, 1, 0, 0, 1, 0]
(3, 2, 1) [0, 1, 0, 1, 0, 0, 1, 0]
</code></pre>

<p>The python script that generated the bits for example purposes:</p>

<pre><code>import itertools                             

def mark(v, x):                              
  v[0] = 1                                   
  v = [0] * x + v[:-x]                       
  return v                                   

for x in itertools.permutations([1,2,3]):    
  v = [0] * 8                                
  for xx in x:                               
    v = mark(v, xx)                          
  print x, v                                 
</code></pre>
",1
55967824,55967705,3,"<p>The type <code>void *</code> is a generic pointer that can point to anything. But the compiler doesn't actually <em>know</em> what it points to, so you have to tell it by using casting.</p>

<p>So for <code>p-&gt;third</code> to work, you need to cast the pointer <code>p</code> to the correct pointer type. </p>

<p>Unfortunately this is not possible with your current code, as the inner structure is an anonymous structure without a known <em>tag</em> (structure name). You need to create a structure tag that you can use for the casting. For example</p>

<pre><code>typedef struct
{
    uint8_t first;
    struct inner_struct
    {
        uint8_t second;
        uint8_t third[8];
    } inner_struct;
} outer_struct;
</code></pre>

<p>Now you can cast the pointer <code>p</code>, like <code>((struct inner_struct *) p)-&gt;third</code>.</p>

<p>Or define <code>p</code> to be the correct type immediately:</p>

<pre><code>struct inner_struct *p = &amp;foo.inner_struct;
</code></pre>
",0
55967824,55967705,3,"<p>The type <code>void *</code> is a generic pointer that can point to anything. But the compiler doesn't actually <em>know</em> what it points to, so you have to tell it by using casting.</p>

<p>So for <code>p-&gt;third</code> to work, you need to cast the pointer <code>p</code> to the correct pointer type. </p>

<p>Unfortunately this is not possible with your current code, as the inner structure is an anonymous structure without a known <em>tag</em> (structure name). You need to create a structure tag that you can use for the casting. For example</p>

<pre><code>typedef struct
{
    uint8_t first;
    struct inner_struct
    {
        uint8_t second;
        uint8_t third[8];
    } inner_struct;
} outer_struct;
</code></pre>

<p>Now you can cast the pointer <code>p</code>, like <code>((struct inner_struct *) p)-&gt;third</code>.</p>

<p>Or define <code>p</code> to be the correct type immediately:</p>

<pre><code>struct inner_struct *p = &amp;foo.inner_struct;
</code></pre>
",0
52371308,52371180,0,"<p>In C, an array is often automatically converted to a pointer to its first element. C 2018 6.3.2.1 3 says:</p>

<blockquote>
  <p>Except when it is the operand of the <strong>sizeof</strong> operator, or the unary <strong>&amp;</strong> operator, or is a string literal used to initialize an array, an expression that has type ""<em>array of type</em>"" is converted to an expression with type ""<em>pointer to type</em>"" that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined.</p>
</blockquote>

<p>Thus, when the type <code>foo_t</code> is an array of three <code>uint8_t</code>, and <code>x</code> is an object of type <code>foo_t</code>, then, in a function call such as <code>function(x)</code>, <code>x</code> is automatically converted so that the function call is equivalent to <code>function(&amp;x[0])</code>.</p>

<p>However, in this case, the result is that <code>x</code> becomes a pointer to <code>uint8_t</code>. The argument must still satisfy the rules about matching argument types in the call to parameter types in the function declaration. If the function¡¯s parameter were declared to have type pointer to <code>foo_t</code> (so it is a pointer to an array of three <code>uint8_t</code>), then the compiler should give a warning or error that <code>function(x)</code> is passing a pointer to <code>uint8_t</code>.</p>

<p>No such call appears in the code you included in the question, so it is unclear what you are asking about. The <code>memcpy</code> calls do contain arguments that are arrays, which are converted to pointers. These are permitted as arguments to <code>memcpy</code> because its parameters are declared to be <code>void *</code> or <code>const void *</code>, and pointers to any types of objects may be converted to <code>void *</code>.</p>

<p>(Additionally, a parameter declaration that is an array is automatically adjusted to be a pointer to an array element.)</p>
",0
56463763,56460697,0,"<blockquote>
  <p>is there a way in C to use the function's return value, without defining a new variable, or calling the function twice[...]?</p>
</blockquote>

<p>Yes, with <code>switch</code></p>

<pre><code>switch (id_data_valid(data)) {
    default: return 0;
    case 1: /* ... */ return 1;
    case -1: /* ... */ return -1;
    case 2: /* ... */ return 2;
    // ...
}
</code></pre>
",1
48622277,48622145,1,"<p>You need to initialize c.  In your current code, it will just contain random data.  Add this line before you insert any data into c:</p>

<pre><code>memset(&amp;c, 0, sizeof(contato));
</code></pre>
",3
56614502,56614471,3,"<p>By definition, <code>&amp;st[3]</code> is the same as <code>st+3</code>. <code>st+3-st</code> is <code>3</code>. (<code>st</code> in that expression decays from array to a pointer. For portability, the printf format string should technically have <code>%td</code> instead of <code>%ld</code>.)</p>
",1
56614500,56614471,5,"<p>When you use an array in an expression, unless it is the argument of <code>&amp;</code> or <code>sizeof</code>, it evaluates to the address of its first element.</p>

<p>Thus <code>&amp;st[3] - st</code> evaluates as <code>&amp;st[3] - &amp;st[0]</code>, which is just pointer arithmetic: The difference between the addresses of two array elements is just the difference between their indices, i.e. <code>3 - 0</code>, which gives <code>3</code>.</p>

<p>The only problem is that the result is of type <code>ptrdiff_t</code>, but <code>printf</code> <code>%ld</code> expects a <code>long int</code>. If those types are different on your machine, it won't work. In a <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21.6"" rel=""nofollow noreferrer""><code>printf()</code></a> format string, the correct length modifier for <code>ptrdiff_t</code> is <code>t</code> ¡ª use <code>""\n%td\n""</code>.</p>
",0
49044543,49044336,4,"<p>In the specific case of <code>unsigned char foo</code>, there isn't a difference.  If you tried:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
      signed char bar = '\xFF';
    unsigned char foo = '\xFF';
    printf(""%hhx %x\n"", bar, bar);
    printf(""%hhx %x\n"", foo, foo);
    return 0;
}
</code></pre>

<p>You'd typically get the output:</p>

<pre><code>ff ffffffff
ff ff
</code></pre>

<p>The reason is that in both cases, the character is converted to an <code>int</code> when it is passed to <code>printf()</code>, but the signed character is converted to a negative <code>int</code>, which is then processed by conversion to <code>unsigned char</code> when the length modifier is <code>hh</code> and is left at full size (4 bytes, I'm assuming) when the length modifier is omitted.</p>
",2
57966608,57964994,3,"<p>Your bug is this:</p>

<pre><code>    /* check for non-divisable amount of processors */       
    int remainder = curr_proc &lt; (N % total_proc) ? 1 : 0;
    lower_limit = curr_proc * chunk_size + curr_proc;
    upper_limit = (curr_proc + 1) * chunk_size + remainder;
</code></pre>

<p>For example, if the remainder is zero, then the lower limit should be <code>curr_proc * chunk_size</code> but you're doing <code>curr_proc * chunk_size + curr_proc</code> and skipping numbers (not adding them to the sum).</p>

<p>It needs to be something more like:</p>

<pre><code>    int remainder = N % total_proc;
    if(curr_proc &lt; remainder) {
        lower_limit = curr_proc * chunk_size + curr_proc;
    } else {
        lower_limit = curr_proc * chunk_size + remainder;
    }
    if(curr_proc + 1 &lt; remainder) {
        upper_limit= (curr_proc + 1) * chunk_size + (curr_proc + 1);
    } else {
        upper_limit= (curr_proc + 1) * chunk_size + remainder;
    }
</code></pre>

<p>Also note that with <code>N+1</code> CPUs (e.g. 101 CPUs) the processes all do a single useless addition (<code>0 + lower_limit</code>), and the main process does all of the useful additions. To get any benefit you need to limit the number of CPUs to a fraction of N (e.g. so that each CPU does at least 10 useful additions you have to limit it to no more than N/10 CPUs).</p>

<p>Of course ""smarter"" is to use pairing - e.g. ""<code>0+100 = 1+99 = 2+98 = 3+97 = ... = 100</code>"", which means that (by calculating the number of pairs, the sum of all pairs, and finding the ""lone middle value"" if there is one) you end up with something like <code>sum = 100/2 * 100 + 100/2</code>.</p>
",0
49138542,49138322,1,"<p>As was mentioned in the comments, attempting to convert a pointer to one type into a pointer of another type breaks the strict aliasing rule.  You can get around this by using <code>memcpy</code> to copy bytes from one type to another:</p>

<pre><code>uint64_t x;
memcpy(&amp;x, &amp;f, sizeof(f));
</code></pre>

<p>Note that what <code>x</code> contains depends on the implementation, i.e. what is the representation of <code>double</code>, is the system big-endian or little-endian, is a <code>double</code> 64 bits, etc.</p>
",0
49139020,49138322,1,"<blockquote>
  <p>Don't know where I am going wrong.</p>
</blockquote>

<p><code>*(uint64_t *)&amp;f</code> breaks the strict-aliasing rules.  See <a href=""https://stackoverflow.com/a/8825257/2410359"">Fix for dereferencing type-punned pointer will break strict-aliasing
</a></p>

<p>To fix, use a <code>memcpy()</code> as well answered by <a href=""https://stackoverflow.com/a/49138542/2410359"">@dbush</a>  or a <code>union</code>.  A <code>union</code> copes with the strict-aliasing rules.  </p>

<pre><code>void insert2(Buffer *buf, double f, size_t index) {
  union { 
    double d; 
    uint64_t u64;
  } u = { f };
  insert_64(buf, u.u64, index);
}
</code></pre>

<p>or also use a <em>compound literal</em> (available since C99)</p>

<pre><code>void insert3(Buffer *buf, double f, size_t index) {
  //             v-----------------------------------------v   compound literal        
  insert_64(buf, (union { double d; uint64_t u64; }){.d = f}.u64, index);
}
</code></pre>

<hr>

<p>With C11, I would add the below for future assessment of correctness.</p>

<pre><code>_Static_assert(sizeof (double) == sizeof (uint64_t), ""Unexpected sizes"");
</code></pre>

<hr>

<p>Note: rare platforms have differing <em>endian</em> per integer and FP types.</p>
",0
56764400,56764392,1,"<p><code>x ^= 3</code> changes 1 to 2 and changes 2 to 1. <code>^</code> performs an exclusive or (XOR) operation.</p>
",0
56765452,56764392,0,"<p>The most elegant way is to define a structure that uses bit fields. Sadly this is rarely appropriate when dealing with hardware registers (e.g. order of bits in a bit-field isn't well defined, etc).</p>

<p>Without bitfields; use ""and with compliment"" (e.g. <code>x = x &amp; ~ 2;</code> or <code>x &amp;= ~2;</code>) to clear bits and ""or"" (e.g. <code>x = x | 1;</code> or <code>x |= 1;</code>) to set bits.</p>

<p>If you know the previous value you can optimize further. For example, if you know the previous value is 0x02 then you can just set a new value (e.g. <code>x = 0x01;   // It was 0x02</code> or maybe <code>x = (0x02 &amp; ~2) | 1;</code> so compiler will work out the constant for you but the source code still reflects how the constant was determined).</p>

<p>Note that it's not possible to do it in a single operation unless you do know something about the previous value. For example, if you know that the previous value will have bit 0 clear and bit 1 set but don't know anything about the other bits (and need to preserve the other bits), then you can decrement (<code>x--;   // Clear bit 2, set bit 1</code>) or use exclusive OR.</p>
",0
49163304,49163198,0,"<p><code>ntohll</code> is not a standard function AFAICT. It exists on modern Solaris UNIX (as your link in the comments mentions), and <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/jj710202(v=vs.85).aspx"" rel=""nofollow noreferrer"">Windows provides it</a> (from the WinSock2.h header), but it's not part of any common standard (e.g. POSIX) and not found on many (most/all?) ""UNIX-like""  systems, e.g Linux and the BSDs.</p>

<p>Many of the systems that lack it do provide <a href=""https://linux.die.net/man/3/be64toh"" rel=""nofollow noreferrer""><code>be64toh</code></a> instead with identical meaning (though the headers it comes from aren't consistent, varying even within the BSD community); they're just saying ""be"" to mean big-endian explicitly and 64 to make the bit size explicit, as opposed to ""n"" for ""network"" which assumes all network protocols are big endian (Windows protocols often aren't, not sure on others), and <code>ll</code> which is a less clear way of spelling out that it works on 64 bit values.</p>

<p>If you need portable code, <a href=""https://stackoverflow.com/a/4410728/364696"">you'll need to do a bunch of OS detection</a> to determine which headers to include, and use macros (or inline functions or the like) to provide a common name for the functionality based on whatever your OS actually provides.</p>
",0
50300649,50299072,1,"<p>The problem is that you're writing past the end of your arrays.</p>

<p>You allocate:</p>

<pre><code>double mat[n + n - 1][n];
</code></pre>

<p>Since <code>n=2</code>, that means each row has two columns, <code>[0]</code> and <code>[1]</code>.</p>

<p>So when you write to <code>mat[1][2]</code>, that's past the end of <code>mat[1]</code>. Which is undefined behavior, so it could do anything from segfaulting to spending your entire savings on a fly-by-night scam cryptocurrency. But, because of the way the arrays are allocated on your system, <code>mat[2]</code> ends up right after <code>mat[1]</code> in memory, with no gap, so a write to <code>mat[1][2]</code> goes into <code>mat[2][0]</code>.</p>

<p>Your code can also write to <code>[3]</code>, and in fact does so at <code>mat[2][3]</code>, because you're looping over <code>i &lt;= n</code> and writing to <code>mat[t][i+1]</code>.</p>

<p>You haven't explained what any of these values are supposed to mean, and I'm having a very hard time guessing (e.g., what is the <code>j</code> loop for, when you never even use <code>j</code> in it?), so I can't tell you for sure how to fix your code to do whatever it is you wanted to do.</p>

<p>But I can guess, based on the fact that you called the thing <code>mat</code>, that maybe you wanted a square matrix. In which case, the fix is probably as simple as this:</p>

<pre><code>double mat[n + n - 1][n + n - 1];
</code></pre>

<p>But even that isn't correct, because <code>n + n - 1</code> is 3, and <code>mat[2][3]</code> will still write past the end. So maybe you actually wanted this:</p>

<pre><code>double mat[n + n][n + n];
</code></pre>
",0
48219290,48218200,1,"<p>Your code causes undefined behaviour by using the wrong format specifier for the argument type in printf.</p>

<p>Here is some correct code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int s = -3;
    uint16_t u = s;          // u now has the value 65533

    printf(""%u\n"", (unsigned int)u);
    printf(""%x\n"", (unsigned int)u);
}
</code></pre>

<p>The code to printf a <code>uint16_t</code> is slightly complicated, it's simpler to cast to <code>unsigned int</code> and use <code>%u</code> or <code>%x</code> which are specifiers for <code>unsigned int</code>.</p>
",0
59508308,59508268,1,"<p><code>itoa()</code> converts a number to a string, so each digit has to be converted from a value in the range <code>0-9</code> to a character in the range <code>¡¯0¡¯-¡®9¡¯</code>. Because the characters happen to appear in order in ASCII, you can do that by adding the value of the digit to the value of the lowest character, <code>¡¯0¡¯</code>.</p>

<p>I¡¯m not sure about the segmentation fault, but one problem you might run into without the `+¡¯0¡¯ is that your string will have a zero byte wherever a zero appears in the number you¡¯re converting, making the string look shorter than it really is.</p>
",1
59508321,59508268,0,"<p>The <code>'0'</code> is the base value of the numbers in the ASCII table. The ASCII character ""0"" has a decimal value of 48. In order to compute the correct ASCII character for the integers 0-9, you can add <code>'0' + n</code>, where <code>n</code> is the decimal value. To see this in action, replace <code>'0'</code> in the code with <code>48</code>. The resulting string will be the same.</p>

<p>This works because the <code>char</code> data type in C is just a small integer (a single byte) and the <code>'0'</code> is syntactic sugar for the <code>char</code> value 48.</p>
",2
59508333,59508268,0,"<p>The ascii char <code>'0'</code> code is <code>48</code> in decimal.
Whenever <code>n % 10</code> returns <code>0</code> (that will happen for any digit that is <code>0</code>), then you're actually injecting a null byte into s.</p>

<p>My guess is that the segmentation fault actually occurs within the call of <code>reverse(s)</code>.</p>
",1
54050575,54050512,0,"<pre><code>for(i=0; string[i]; i++){
    if(string[i]!=' ')
        out[i]=string[i];
}
</code></pre>

<p>Because <em>out</em> can be smaller than <em>string</em> you need to have a separate index for each, the index in <em>out</em> must progress only when you put a new character in it</p>

<p>So currently you print non initialized characters, that explains the '+' and probably a null character just after stopping the print.</p>

<p><em>Replace a string of one or more blanks with a single blank</em> : your program <em>try</em> to remove all the spaces, not to replace consecutive spaces by only one</p>

<p>Do not forget to put the ending null char in <em>out</em> at the end</p>
",6
53269445,53269343,1,"<p>You can use a loop that iterates columns by rows:</p>

<pre><code>// mx is array of maximum by column
for (j=0;j&lt;n;j++) {
    mx[j]= a[0][j];
    for (i=1;i&lt;n;i++) {
        mx[j] = max(mx[j],a[i][j]);
    }
}
</code></pre>

<p>and <code>max(a,b)</code> is a function that returns the maximum of the 2 arguments.</p>
",1
53587446,53586937,0,"<pre><code> while((text_buff = fgetc(source)) != EOF)
</code></pre>

<p>The <code>fgetc</code> function returns an <code>int</code>. But you chop it to a <code>char</code>, assign that to <code>text_buff</code>, and then compare <em>that</em> to <code>EOF</code>. That won't work. You are supposed to compare the return value of <code>fgetc</code> to <code>EOF</code>, not any other value.</p>

<p>There are two possibilities. Either some value of <code>char</code> maps to <code>EOF</code> or no value of <code>char</code> maps to <code>EOF</code>. If some value of <code>char</code> maps to <code>EOF</code>, then when you read that character in the middle of the file, you'll treat at as the end of the file. If no value of <code>char</code> maps to <code>EOF</code>, then you'll never detect the end of the file.</p>

<p>So this can't possibly work right.</p>
",1
53587446,53586937,0,"<pre><code> while((text_buff = fgetc(source)) != EOF)
</code></pre>

<p>The <code>fgetc</code> function returns an <code>int</code>. But you chop it to a <code>char</code>, assign that to <code>text_buff</code>, and then compare <em>that</em> to <code>EOF</code>. That won't work. You are supposed to compare the return value of <code>fgetc</code> to <code>EOF</code>, not any other value.</p>

<p>There are two possibilities. Either some value of <code>char</code> maps to <code>EOF</code> or no value of <code>char</code> maps to <code>EOF</code>. If some value of <code>char</code> maps to <code>EOF</code>, then when you read that character in the middle of the file, you'll treat at as the end of the file. If no value of <code>char</code> maps to <code>EOF</code>, then you'll never detect the end of the file.</p>

<p>So this can't possibly work right.</p>
",1
52127028,52127012,4,"<p>One of the way would be to use Ternary operator like:</p>

<pre><code>printf(""%d%c"", a[i], i==n-1? '\n': ' ');
</code></pre>

<p>Which means you print your array element and after that you print either a space if i is not equal to (array size - 1)* or a new line character when you get last element of the array to print.</p>

<p>* Since array index starts from 0.</p>
",0
58556289,58556142,2,"<p>Remove the loops and simply</p>

<pre><code>free(sub_diag);
free(sup_diag);
free(diag);
free(d);
</code></pre>

<p>Each <code>free()</code> must correspond with each <code>calloc()</code>.</p>
",0
48243372,48243161,1,"<p>Your code stores pointers to local arrays <code>Data1</code> and <code>Data2</code> declared in <code>Func1</code>. It stores these pointers in <code>PutData1[0]</code> and <code>PutData2[0]</code>. When <code>Func1</code> completes, these local arrays <code>Data1</code> and <code>Data2</code> are destroyed. The <code>PutData1[0]</code> and <code>PutData2[0]</code> pointers become dangling. Any attempts to access anything through these dangling pointers will lead to undefined behavior.</p>

<p>In call to <code>call_func1</code> made from <code>Func2</code> you attempt to access data through those dangling <code>PutData1[0]</code> and <code>PutData2[0]</code> pointers. The behavior is undefined. That's all there is to it.</p>
",4
52030546,52025896,0,"<p>As an example of how I'd avoid conversion: 
(also added some error checking and an actual return value for <code>main</code> which I like to have, as do Unix-like OS'es...)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

static size_t count_char_in_line(const char *l, size_t len, char c){
    size_t res=0;
    while(len&gt;0){ 
        if (*(l++) == c) res++; 
        len--;
    }
    return res;
}

int main(void){

size_t nr_of_expected_lines=0;
ssize_t nr_read;
size_t line_length;
char *line = NULL;
int ret=0;

if (-1 != ( nr_read = getline(&amp;line, &amp;line_length, stdin))){
    if (1 != sscanf(line, ""%zu"", &amp;nr_of_expected_lines)){
        fprintf(stderr, ""not a number on the first line..\n"");
        ret=1;
        goto cleanup;
    }
} else {
    fprintf(stderr, ""premature end of stdin..\n"");
    ret=2;
    goto cleanup;
}
while (nr_of_expected_lines &gt; 0 &amp;&amp; (-1 != (nr_read = getline(&amp;line, &amp;line_length,stdin)))){
    if (nr_read &gt; 1){
        size_t count=count_char_in_line(line, nr_read-1, '4');
        fprintf(stdout, ""%zu\n"", count);
        nr_of_expected_lines--;
    } else {
        fprintf(stderr, ""empty line error\n"");
        ret= 3;
        break;
    }
}  

cleanup:
free(line);
return ret;
</code></pre>

<p>}</p>
",0
54056329,54056266,2,"<p><code>u</code> is not initialized in the original code or your additions. Presuming it had a proper value, then, if <code>*u</code> is not negative:</p>

<pre><code>""| "" + (*u / 4) % 2
</code></pre>

<p>is a pointer to the character <code>'|'</code> or <code>' '</code> according to whether <code>*u</code> is 0-3 or 4-7 modulo 8. In effect, <code>printf</code> is passed either <code>""| ""</code> or <code>"" ""</code>. Thus, the <code>printf</code> will print either ¡°| ¡± or ¡° ¡±.</p>

<p>And:</p>

<pre><code>""_"" + (*u++ / 8) % 2
</code></pre>

<p>is a pointer to either the <code>'_'</code> or the null character that terminates the string according to whether <code>*u</code> is 0-7 or 8-15 modulo 8, before the increment. Thus, the <code>printf</code> will print either ¡°_¡± or nothing.</p>
",3
54056315,54056266,1,"<pre><code>printf(""| "" + (*u / 4) % 2)
</code></pre>

<p>it will write (""| "" + 0) = ""| "", or (""| "" + 1) = "" "", depending on the value of <code>(*u / 4) % 2</code> being 0 or 1</p>

<p>the expression just return the address of ""| "" or that address more 1</p>

<p>it is similar for the other print</p>
",0
49360286,49359343,0,"<p>Given that it is all in upper case, it is probably a <code>#define</code> macro. </p>

<p>Given it's location - it is where you would expect to see the type in a variable declaration - it is probably a macro that defines a type. </p>

<p>Given that it is used as the return type for <code>msgQSend()</code>, it is probably an integer type, in fact, it is probably <code>int</code>. </p>

<p>Somewhere in your code (probably in a header) there will be a line like</p>

<pre><code>#define STATUS int
</code></pre>

<p>or possibly </p>

<pre><code>typedef int STATUS;
</code></pre>

<p>or possibly even an enum</p>

<pre><code>typedef enum { OK = 0, ERROR = -1 } STATUS;
</code></pre>
",0
53456067,53455675,0,"<p>When you declare an array like this</p>

<pre><code>char* keywords[keyno];
</code></pre>

<p>You are declaring an array of pointers to strings. However the pointers need to point somewhere
and each pointer needs to point to a different location.</p>

<pre><code>keywors[i-1]=var;
</code></pre>

<p>makes each pointer point to the same address, the address of the array <code>var</code></p>

<p>to fix this, allocate memory when you get something from the file.</p>

<p>e.g.</p>

<pre><code>keywords[i-1] = malloc(strlen(var)+1); /* allocate memory */
strcpy(keywords[i-1], var);  /* copy to the newly allocated memory */
</code></pre>

<p>later you need to free that memory</p>

<pre><code>for (int i = 0; i &lt; keyno; ++i)    
  free(keywords[i[);
</code></pre>

<p>as a precaution make sure all pointers are set to NULL at the beginning in your program since free on an uninitialized pointer is undefined behavior but freeing a NULL pointer is fine.</p>

<pre><code>char* keywords[key];
for (int i = 0; i &lt; keyno; ++i)
  keywords[i] = NULL;
...
while(fgets(var, sizeof(var), k)!=NULL){  ... }
...
for (int i = 0; i &lt; keyno; ++i)    
  free(keywords[i[);
</code></pre>
",0
49869794,49869532,1,"<p>The characters in the <code>""%c\n""</code> to <code>read_scan()</code> mean read and capture one character, and read and discard another character.  You could have an <code>X</code> or <code>@</code> instead of the <code>\n</code> and it would work the same.  When you delete the newline from the format, the newline after the character is left in the input.  Then the next call to <code>read_scan()</code> with <code>""%s""</code> invokes <code>fgets()</code>, which reads up to the next newline, but the next newline is the already in the input stream, so it returns immediately.</p>

<p>Note that if you typed a word instead of an initial, or if you have no middle initial (me!), things go wrong in different ways.</p>
",0
53877244,53877142,7,"<p>Parsers check syntax first.
The syntax for function definitions is (<a href=""http://port70.net/%7Ensz/c/c11/n1570.html#6.9.1"" rel=""noreferrer"">6.9.1</a>)</p>
<blockquote>
<p>function-definition:</p>
<pre><code>   declaration-specifiers declarator declaration-listopt compound-statement
</code></pre>
</blockquote>
<p>In your case <code>declaration-specifiers</code> is <code>int</code>, <code>declarator</code> is <code>main(void)</code> and now
you're in <code>declaration-list_opt</code>, which is there to support K&amp;R definitions such as <code>int main(argc, argv) int argc; char **argv { }</code>.</p>
<p>A commented K&amp;R function definition:</p>
<pre><code>/*the old declarator mirrors usage
  -- it takes an identifier list rather than a param-declarator list
  (http://port70.net/~nsz/c/c11/n1570.html#6.7.6)
*/

int main(argc, argv)

/*the types of the identifiers are then declared*/

int argc;
char **argv;

/*and only then comes the function body
  which is technically a compound statement
*/
{
}
</code></pre>
<p>In your case, <code>declaration-list_opt</code> is matched with:</p>
<pre><code>int i, j, m[5][5];
</code></pre>
<p>which semantically doesn't make sense with <code>main(void)</code> (the array declaration wouldn't make sense with any function declarator, really, since arrays are passed as pointers), but checking that would be part of a semantic check, which usually comes <em>after</em> syntax verification.</p>
<p>After <code>declaration-list_opt</code>, a <code>compound-statement</code> (i.e., <code>{}</code>-braced function body) is syntactically expected.<code>for</code> fails that syntactic expectation.</p>
",2
49577434,49574414,0,"<p>The <code>lookuptable</code> has typos, it should like:</p>

<pre><code>static t_symstruct lookuptable[] = {
    {""b"",b}, {""s"",s}, {""r"",r},  {""p"",p}
};
</code></pre>

<p>Your original version will not even compile. The testing program is presented below:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define BADKEY -1
#define b 1
#define s 2
#define r 3
#define p 4

typedef struct {
    char *key;
    int val;
} t_symstruct;

static t_symstruct lookuptable[] = {
    {""b"",b}, {""s"",s}, {""r"",r},  {""p"",p}
};

#define NKEYS (sizeof(lookuptable)/sizeof(t_symstruct))

int keyfromstring(char *key)
{
    int i;
    for (i=0; i &lt; NKEYS; i++) {
        if (strcmp(lookuptable[i].key, key) == 0)
            return lookuptable[i].val;
    }
    return BADKEY;
}

int main (void) {

    char * arr[] = { ""b"",""s"",""r"", ""p"", ""!"", NULL} ;
    int i;

    for (i =0; arr[i] !=NULL; i++)
    {   
        switch (keyfromstring(arr[i]))
        {
        case b :
            printf(""%s is b\n"", arr[i] );
            break;

        case s :
            printf(""%s is s\n"", arr[i] );
            break;

        case r :
            printf(""%s is r\n"", arr[i] );
            break;

        case p:
            printf(""%s is p\n"", arr[i] );
            break;

        case BADKEY:
            printf(""Case: BADKEY: %s \n"",  arr[i] );
            break;

        default://case if nothing
            printf(""Case: nothing happen\n"");
            break;
        }

    }

    return 0;
}
</code></pre>

<p>Test:</p>

<pre><code>b is b                                                                                                                                           
s is s                                                                                                                                           
r is r                                                                                                                                           
p is p                                                                                                                                           
Case: BADKEY: ! 
</code></pre>
",0
48414714,48413430,3,"<p>Your implementation is pretty fragile. Parsers really ought to verify syntax and return errors when they see something unexpected. For example, yours should detect missing fields and multiply defined ones. </p>

<p>Fortunately this parsing problem is simple enough for <code>sscanf</code> to handle everything:</p>

<ul>
<li>skip blank lines, </li>
<li>skip comments</li>
<li>ignore any amount of whitespace</li>
<li>extract the key/value pairs</li>
</ul>

<p>Here's code:</p>

<pre><code>#include &lt;stdio.h&gt;

#define CONFIG_SIZE (256)
#define HOST_SET (1)
#define PORT_SET (2)

typedef struct config {
  unsigned set;
  char host[CONFIG_SIZE];
  unsigned long port;
} CONFIG;

// Parse the buffer for config info. Return an error code or 0 for no error.
int parse_config(char *buf, CONFIG *config) {
  char dummy[CONFIG_SIZE];
  if (sscanf(buf, "" %s"", dummy) == EOF) return 0; // blank line
  if (sscanf(buf, "" %[#]"", dummy) == 1) return 0; // comment
  if (sscanf(buf, "" host = %s"", config-&gt;host) == 1) {
    if (config-&gt;set &amp; HOST_SET) return HOST_SET; // error; host already set
    config-&gt;set |= HOST_SET;
    return 0;
  }
  if (sscanf(buf, "" port = %lu"", &amp;config-&gt;port) == 1) {
    if (config-&gt;set &amp; PORT_SET) return PORT_SET; // error; port already set
    config-&gt;set |= PORT_SET;
    return 0;
  }
  return 3; // syntax error
}

void init_config(CONFIG *config) {
  config-&gt;set = 0u;
}

void print_config(CONFIG *config) {
  printf(""[host=%s,port="", config-&gt;set &amp; HOST_SET ? config-&gt;host : ""&lt;unset&gt;"");
  if (config-&gt;set &amp; PORT_SET) printf(""%lu]"", config-&gt;port); else printf(""&lt;unset&gt;]"");
}

int main(int argc, char *argv[]) {
  if (argc != 2) {
    fprintf(stderr, ""Usage: %s CONFIG_FILE\n"", argv[0]);
    return 1;
  }
  FILE *f = fopen(argv[1], ""r"");
  char buf[CONFIG_SIZE];
  CONFIG config[1];
  init_config(config);
  int line_number = 0;
  while (fgets(buf, sizeof buf, f)) {
    ++line_number;
    int err = parse_config(buf, config);
    if (err) fprintf(stderr, ""error line %d: %d\n"", line_number, err);
  }
  print_config(config);
  return 0;
}
</code></pre>

<p>With this input:</p>

<pre><code># This is a comment

This isn't
   # Non-leading comment
host = 123.456.789.10

 ###
port =42

port=    1
host=fruit.foo.bar
</code></pre>

<p>the output is</p>

<pre><code>error line 3: 3
error line 10: 2
error line 11: 1
[host=fruit.foo.bar,port=1]
</code></pre>

<p>Note that when the parser discovers a field has already been set, it still uses the latest value in the config. It's easy enough to keep the original instead. I'll let you have that fun.</p>
",0
48413634,48413430,1,"<p>I think <code>parse_line</code> is a little bit rigid for my taste, I would use <code>strtok</code>
instead. Then you don't have to worry too much about spaces, like you do if you
have a space before the <code>=</code> sign.</p>

<p>Your <code>struct</code> is also wrong, <code>host</code> and <code>port</code> would only hold a character.
Besides <code>port</code> should be an integer. And you need a semicolon <code>;</code> after the
struct definition.</p>

<pre><code>struct config
{
  char host[100];
  int port;
};

int parse_line(struct config *config, char *buf)
{
    if(config == NULL || buf == NULL)
        return 0;

    char varname[100];
    char value[100];
    const char* sep = ""=\n""; // get also rid of newlines
    char *token;

    token = strtok(buf, sep);

    strncpy(varname, token, sizeof varname);
    varname[sizeof(varname) - 1] = 0; // making sure that varname is C-String

    trim(varname);

    token = strtok(NULL, sep);

    if(token == NULL)
    {
        // line not in format var=val
        return 0;
    }

    strncpy(value, token, sizeof value);
    value[sizeof(varname) - 1] = 0

    trim(value);

    if(strcmp(varname, ""port"") == 0)
    {
        config-&gt;port = atoi(value);
        return 1;
    }


    if(strcmp(varname, ""host"") == 0)
    {
        strncpy(config-&gt;host, value, siezof config-&gt;host);
        config-&gt;host[(sizeof config-&gt;host) - 1] = 0;
        return 1;
    }


    // var=val not recognized
    return 0;
}
</code></pre>

<p>Note that I used a function called <code>trim</code>. This function is not part of the
standard library. Below I posted a possible implementation of such a function.</p>

<p>I like using <code>trim</code> because it gets rid of white spaces. Now you can do this in
<code>main</code>:</p>

<pre><code>struct config config;
// initializing
config.port = 0;
config.host[0] = 0;

int linecnt = 0;

while(fgets(buffer, sizeof(buffer), file) != NULL) {
    linecnt++;
    trim(buffer);
    if(buffer[0] == '#')
        continue;

    if(!parse_line(&amp;config, buffer))
    {
        fprintf(stderr, ""Error on line %d, ignoring.\n"", linecnt);
        continue;
    }
}
</code></pre>

<hr>

<p>A possible implementation of <code>trim</code></p>

<pre><code>void rtrim(char *src)
{
    size_t i, len;
    volatile int isblank = 1;

    if(src == NULL) return;

    len = strlen(src);
    if(len == 0) return;
    for(i = len - 1; i &gt; 0; i--)
    {   
        isblank = isspace(src[i]);
        if(isblank)
            src[i] = 0;
        else
            break;
    }   
    if(isspace(src[i]))
        src[i] = 0;
}

void ltrim(char *src)
{
    size_t i, len;

    if(src == NULL) return;

    i = 0;
    len = strlen(src);
    if(len == 0) return;
    while(src[i] &amp;&amp; isspace(src[i]))
                i++;

    memmove(src, src + i, len - i + 1); 
    return;
}

void trim(char *src)
{
    rtrim(src);
    ltrim(src);
}
</code></pre>
",0
49099960,49099879,2,"<p>It is illegal to write to <code>inputCopy</code>. It points to random memory:</p>

<pre><code>char *inputCopy;
char compressedString[100];
snprintf(inputCopy, size, ""%s"", input); // !? memory not allocated for the inputCopy
</code></pre>
",0
49099919,49099879,5,"<p>You're not allocating data for <code>snprintf</code>.  <code>inputCopy</code> is uninitialized, so it's probably writing over the memory used by <code>counter</code>.  Make sure you allocate the necessary memory.</p>

<p>Unrelated to this crash, but you have a potential for invalid reads (<code>inputCopy[j + 1]</code>).  Switch <code>j &lt; size</code> to <code>(j + 1) &lt; size</code> and move it to the beginning of the <code>while</code> so you'll short circuit.</p>

<p><code>valgrind</code> (or Clang's address sanitizer) can help catch both of these issues if you're on a Linux system.</p>
",2
51867211,51866536,2,"<p>The closest thing to an official &quot;why&quot; answer you're likely to find is the C89 Rationale. <em>4.10.4.5 The system function</em> reads:</p>
<blockquote>
<p>The system function allows a program to suspend its execution temporarily in order to run another program to completion.</p>
<p>Information may be passed to the called program in three ways: through command-line argument strings, through the environment, and (most portably) through data files.  Before calling the system function, the calling program should close all such data files.</p>
<p>Information may be returned from the called program in two ways: through the implementation-defined return value (in many implementations, the termination status code which is the argument to the exit function is returned by the implementation to the caller as the value returned by the system function), and (most portably) through data files.</p>
<p>If the environment is interactive, information may also be exchanged with users of interactive devices.</p>
<p>Some implementations offer built-in programs called <em>&quot;commands&quot;</em>  (for example, <code>date</code>)  which may provide useful information to an application program via the system function.  The Standard does not attempt to characterize such commands, and their use is not portable.</p>
<p>On the other hand, the use of the system function is portable, provided the implementation supports the capability.  The Standard permits the application to ascertain this by calling the system function with a null pointer argument.  Whether more levels of nesting are supported can also be ascertained this way; assuming more than one such level is obviously dangerous.</p>
</blockquote>
<p>Aside from that, I would say mainly for historical reasons. In the early days of Unix and C, <code>system</code> was a convenient library function that fulfilled a need that several interactive programs needed: as mentioned above, &quot;suspend[ing] its execution temporarily in order to run another program&quot;. It's not well-designed or suitable for any serious tasks (the POSIX requirements for it make it fundamentally non-thread-safe, it doesn't admit asynchronous events to be handled by the calling program while the other program is running, etc.) and its use is error-prone (safe construction of command string is difficult) and non-portable (because the particular form of command strings is implementation-defined, though POSIX defines this for POSIX-conforming implementations).</p>
<p>If C were being designed today, it almost certainly would not include <code>system</code>, and would either leave this type of functionality entirely to the implementation and its library extensions, or would specify something more akin to <code>posix_spawn</code> and related interfaces.</p>
",0
51867025,51866536,2,"<p>Many interactive applications offer a way for users to execute shell commands. For instance, in <code>vi</code> you can do:</p>

<pre><code>:!ls
</code></pre>

<p>and it will execute the <code>ls</code> command. <code>system()</code> is a function they can use to do this, rather than having to write their own <code>fork()</code> and <code>exec()</code> code. </p>

<p>Also, <code>fork()</code> and <code>exec()</code> aren't portable between operating systems; using <code>system()</code> makes code that executes shell commands more portable.</p>
",0
54325481,54325322,2,"<p>You should pass pointers to pointers as arguments to the <code>fill</code> function so you can effectively modify the pointers <code>a</code> and <code>b</code>.</p>

<pre><code>void fill(int** a, int** b){
    *a = malloc(LENGTH * sizeof(int));
    (*a)[i]=i;

fill(&amp;a,&amp;b);
</code></pre>
",0
52544953,52544818,2,"<p>This is allowed, with later initializers overriding any that came before.</p>

<p>This is specified in section 6.7.9p19 of the C standard:</p>

<blockquote>
  <p>The  initialization  shall  occur  in  initializer  list  order,  each
  initializer  provided  for  a particular subobject overriding any
  previously listed initializer for the same subobject; <sup>151)</sup> all
  subobjects that are not initialized explicitly shall be initialized
  implicitly the same as objects that have static storage duration.</p>
  
  <p>151) Any initializer for the subobject which is overridden and so not
  used to initialize that subobject might not be evaluated at all.</p>
</blockquote>
",1
54566700,54566622,1,"<p>Well, this is wrong, for a start:</p>

<pre><code>void swap()
{
    int *x, *y;
    int temp = *x;
    *x = *y;
    *y = temp;
}
</code></pre>

<p>This creates two brand <em>new</em> pointers within the function, with arbitrary values, and then attempts to dereference them, something that's undefined behaviour.</p>

<p>Since you're passing two pointers to the <code>swap</code> function with <code>swap(&amp;A[min], &amp;A[i])</code>, you should <em>receive</em> those in the parameter list so that you can operate on them:</p>

<pre><code>void swap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}
</code></pre>

<hr>

<p>And, though it's not a bug, you <em>may</em> want to consider using more descriptive names than <code>A</code> or <code>ss</code> (e.g., <code>dataArray</code> and <code>SelectionSort</code>).</p>

<p>This will tend to make your code much more readable and therefore maintainable if you have to, for example, come back and modify it twelve months in the future.</p>

<hr>

<p>You will also need a <em>loop</em> in your <code>main</code> function to get the four values. At the moment, you get only one and with an arbitrary index <code>i</code> which may cause you undefined behaviour again.</p>

<p>Since you've already done similar loops in the <em>other</em> two functions, I'll assume you can handle this task without me giving you the code.</p>
",0
53902376,53902032,1,"<p><code>scanf(""%d\n"",&amp;year);</code> means: read optional whitespace (any amount) followed by an integer (<code>%d</code>) followed by any amount of whitespace (<code>\n</code>).  </p>

<p>So after you type <code>[SPACE][TAB][ENTER]</code> the function consumes those 3 characters and is still ""stuck"" in the first whitespace reading.  </p>

<p>You then type <code>[SPACE][TAB]2000[ENTER]</code> and the function consumes those 7 characters, assignes 2000 to <code>year</code> and gets ""stuck"" in the second whitespace reading.<br>
Type a few more <code>[SPACE][TAB][ENTER]</code> and it is still ""stuck"". </p>

<p>Finally, type <code>[SPACE]""Z""[ENTER]</code> to have the function consume this last space until it gets to the ""Z"" which (along with <code>[ENTER]</code>) remains unconsumed in the input buffer.</p>
",0
54491680,54491474,2,"<p>All values are positive, so we can exploit the bit sign for our purposes.</p>

<p>Iterate over the array; for each element, check if it's negative, if so negate it and subtract 1. If it's outside the valid range [0, N-1] of course the input array is not valid, although you say we don't have to worry about this. </p>

<p>If it's in the range, use it as an index in the array itself; if the value you find is positive make it negative and subtract 1. If it's negative, it means that there's a duplicate element (you already sign-swapped it).</p>

<p>(the ""subtract 1"" thing is to account for the 0, which remains the same when negated) </p>

<p>Due to the pigeonhole principle, if you get to the last element without duplicates and without out of ranges, the input array contains all and only the elements in the range [0, N-1]. If you feel bad about leaving the array all negative, you can do a last pass to flip the sign of every number.</p>

<pre><code>bool check(int *arr, int N) {
    bool ret = true;
    for(int i = 0; i &lt; N &amp;&amp; ret; ++i) {
        int v = arr[i];
        if(v &lt; 0) v = -v - 1;
        if(v &gt;= N || arr[v] &lt; 0) ret = false;
        else arr[v] = -arr[v] - 1;
    }
    for(int i = 0; i &lt; N; ++i) { 
        if(arr[i] &lt; 0) arr[i] = -arr[i] - 1;
    } 
    return ret;
} 
</code></pre>
",10
54491705,54491474,3,"<p>This is my version. It runs in O(n).</p>

<p>The idea is to manipulate the original array and add N to it in order to mark all values that have been encountered. Then we do a sweep and check that all values are greater or equal than N and change the value back to the original one.</p>

<p>The only caveat is that the array must be mutable.</p>

<pre><code>#include &lt;stdio.h&gt;

int check(unsigned* a, size_t size) {
  for (size_t i = 0; i &lt; size; ++i) {
    if (a[i] &gt;= size) {
      return 0;
    }   
  }
  for (size_t i = 0; i &lt; size; ++i) {
    size_t const x = a[i] % size;
    a[x] = x + size;
  }
  int result = 1;
  for (size_t i = 0; i &lt; size; ++i) {
    if (a[i] &lt; size) {
      result = 0;
    } else {
      a[i] = a[i] - size;
    }   
  }
  return result;
}


int main() {
  unsigned a1[] = {0,5,1,3,2,4};
  unsigned a2[] = {0,5,1,3,0,0};
  printf(""a1: %d\n"",check(a1,sizeof(a1)/sizeof(*a1)));
  printf(""a2: %d\n"",check(a2,sizeof(a2)/sizeof(*a2)));
}
</code></pre>
",2
54491897,54491474,4,"<p>If you're allowed to modify the input array, the problem can be solved in O(N).</p>

<p>Observations:</p>

<ol>
<li><p>If the array was sorted, the problem would be trivial.</p></li>
<li><p>Sorting an array 0...N-1 where values are also 0...N-1 is also trivial, since each element's position is its value, you can iterate once, swapping elements into their final position.</p></li>
</ol>

<p>Just need an additional check during swapping that the element at position <em>i</em> doesn't already have the value <em>i</em>, which would mean <em>i</em> appears twice in the array.</p>

<pre><code>int check(unsigned* a, unsigned size) {
    for (unsigned i = 0; i &lt; size; ++i) {
        unsigned b = a[i];
        if (b != i) {
            do {
                if (b &lt; 0 || b &gt;= size)
                    return false; // value out of range
                unsigned c = a[b];
                if (b == c)
                    return false; // duplicate value
                a[b] = b;
                b = c;
            } while (b != i);
            a[i] = i;
        }
    }
    return true;
}
</code></pre>

<p>Note that the the inner loop makes the solution look O(N<sup>2</sup>), but it's not - each element is visited at most twice. The inner loop is needed to resolve cycles as in <code>{1,2,3,0}</code>.</p>
",7
52888009,52887963,4,"<p><code>&amp;x</code>  is a non-lvalue expression. It does not have a location. <code>&amp;</code> requires an <a href=""https://stackoverflow.com/questions/579421/often-used-seldom-defined-terms-lvalue/52840265#52840265"">lvalue</a> as its operand (or a function).</p>

<p><code>&amp;&amp;x</code> is not a valid construct at all in standard C. The address is not necessarily <em>stored anywhere at all</em> - in your program as <code>x</code> is a global variable, it is a compile/link-time constant!</p>

<hr>

<p>Instead GCC uses unary <code>&amp;&amp;x</code> as an extension to get the <em>address of jump label x</em> for <a href=""https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html"" rel=""nofollow noreferrer"">computed goto</a>. This does not break C conformance by itself as <code>&amp;&amp;</code> is parsed as a <em>single token</em> and <code>&amp;&amp;</code> is not allowed as an unary operator in standard C.</p>

<p>I.e. you can write</p>

<pre><code>    static void *array[] = { &amp;&amp;foo, &amp;&amp;bar, &amp;&amp;hack };

    int i = 1;
    goto *array[i]; // jump to label bar

    ...

foo: ...
bar: ...
baz: ...
</code></pre>
",15
52888028,52887963,1,"<p>To do what you want, you need to store <code>&amp;x</code> in a variable:</p>

<pre><code>int* y = &amp;x;
printf(""%p"", &amp;y);
</code></pre>
",0
52888017,52887963,5,"<p><code>&amp;x</code> is a temporary value. It is not stored in memory and does not have an address.</p>

<p>Similarly <code>&amp;42</code> is invalid because <code>42</code> is not stored in memory (it's also a temporary value).</p>

<p>The slightly weird error message you get is because gcc implements a unary <code>&amp;&amp;</code> operator, which can be used to get the address of a label. This is a non-standard extension of the C language.</p>

<p>To get a better error message, use <code>&amp; &amp;x</code> (with a space) or <code>&amp;(&amp;x)</code>.</p>

<p>But what you want simply doesn't exist.</p>
",1
52920937,52920577,1,"<p>When you use <code>&amp;y</code> in source code, the compiler does not need to create a new object to store the address of <code>y</code>.</p>

<p>The entries in the symbol table are actually the locations of <code>x</code> and <code>y</code>. (An entry is generally not a complete address but is usually an offset relative to whatever section the symbol is in.)</p>

<p>So, when <code>&amp;y</code> is used, the compiler inserts a reference to <code>y</code> in the assembly code it generates. The linker and/or loader fills in this reference with the address of <code>y</code>.</p>

<p>[The above of course is not part of the C standard. It is only compilers, linkers, and loaders generally work.]</p>
",0
48735097,48734808,2,"<p>I think the best way to do the splits with an ordered sequence of delimeters is
to replicate <code>strtok_r</code> behaviour using <code>strstr</code>, like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char *substrtok_r(char *str, const char *substrdelim, char **saveptr)
{
    char *haystack;

    if(str)
        haystack = str;
    else
        haystack = *saveptr;

    char *found = strstr(haystack, substrdelim);

    if(found == NULL)
    {
        *saveptr = haystack + strlen(haystack);
        return *haystack ? haystack : NULL;
    }

    *found = 0;
    *saveptr = found + strlen(substrdelim);

    return haystack;
}


int main(void)
{
    char line[] = ""a -&gt; b -&gt; c -&gt; d; Test - Number -&gt; &lt;10.0&gt; -&gt;No-&gt;split-&gt;here"";

    char *input = line;
    char *token;
    char *save;

    while(token = substrtok_r(input, "" -&gt;"", &amp;save))
    {
        input = NULL;
        printf(""token: '%s'\n"", token);
    }

    return 0;
}
</code></pre>

<p>This behaves like <code>strtok_r</code> but only splits when the substring is found. The
output of this is:</p>

<pre class=""lang-none prettyprint-override""><code>$ ./a 
token: 'a'
token: ' b'
token: ' c'
token: ' d; Test - Number'
token: ' &lt;10.0&gt;'
token: 'No-&gt;split-&gt;here'
</code></pre>

<p>And like <code>strtok</code> and <code>strtok_r</code>, it requires that the source string is
modifiable, as it writes the <code>'\0'</code>-terminating byte for creating and returning
the tokens.</p>

<hr>

<p><strong>EDIT</strong></p>

<blockquote>
  <p>Hi, would you mind explaining why <code>'*found = 0'</code> means the return value is only the string in-between delimiters. I don't really understand what is going on here or why it works. Thanks </p>
</blockquote>

<p>The first thing you've got to understand is how strings work in C. A string is
just a sequence of bytes (characters) that ends with the <code>'\0'</code>-terminating
byte. I wrote bytes and characters in parenthesis, because a character in C is
just a 1-byte value (on most systems a byte is 8 bit long) and the integer
values representing the characters are those defined in the <a href=""http://www.asciitable.com/"" rel=""nofollow noreferrer"">ASSCI</a> code
table, which are 7-bit long values. As you can see from the table the
value 97 represents the character <code>'a'</code>, 98 represents <code>'b'</code>, etc. Writing</p>

<pre><code>char x = 'a';
</code></pre>

<p>is the same as doing</p>

<pre><code>char x = 97;
</code></pre>

<p>The value 0 is an special value for strings, it is called <code>NUL</code> (null character)
or <code>'\0'</code>-terminating byte. This value is used to tell the functions where a
string ends. A function like <code>strlen</code> that returns the length of a string, does
it by counting how many bytes it encounters <strong>until</strong> it encounters a byte with
the value 0.</p>

<p>That's why strings are stored using <code>char</code> arrays, because a pointer to an array
gives to the start of the memory block where the sequence of <code>char</code>s is stored.</p>

<p>Let's look at this:</p>

<pre><code>char string[] = { 'H', 'e', 'l', 'l', 'o', 0, 48, 49, 50, 0 };
</code></pre>

<p>The memory layout for this array would be</p>

<pre class=""lang-none prettyprint-override""><code>0     1     2     3     4     5    6     7     8     9
+-----+-----+-----+-----+-----+----+-----+-----+-----+----+
| 'H' | 'e' | 'l' | 'l' | 'o' | \0 | '0' | '1' | '2' | \0 |
+-----+-----+-----+-----+-----+----+-----+-----+-----+----+
</code></pre>

<p>or to be more precise with the integer values</p>

<pre class=""lang-none prettyprint-override""><code>0    1     2     3     4     5   6    7     8   9   10
+----+-----+-----+-----+-----+---+----+----+----+---+
| 72 | 101 | 108 | 108 | 111 | 0 | 48 | 49 | 50 | 0 |
+----+-----+-----+-----+-----+---+----+----+----+---+
</code></pre>

<p>Note that the value 0 represents <code>'\0'</code>, 48 represents <code>'0'</code>, 49 represents
<code>'1'</code> and 50 represents <code>'2'</code>. If you do</p>

<pre><code>printf(""%lu\n"", strlen(string));
</code></pre>

<p>the output will be 5. <code>strlen</code> will find the value 0 at the 5th position and
stop counting, however <code>string</code> stores two strings, because from the 6th
position on, a new sequence of characters starts that also terminates with 0, thus making it a
second valid string in the array. To access it, you would need to have pointer
that points past the first 0 value.</p>

<pre><code>printf(""1. %s\n"", string);
printf(""2. %s\n"", string + strlen(string) + 1);
</code></pre>

<p>The output would be</p>

<pre class=""lang-none prettyprint-override""><code>Hello
012
</code></pre>

<p>This property is used in functions like <code>strtok</code> (and mine above) to return you
a substring from a larger string, without the need of creating a copy (that would be
creating a new array, dynamically allocating memory, using <code>strcpy</code> to create
the copy).</p>

<p>Assume you have this string:</p>

<pre><code>char line[] = ""This is a sentence;This is another one"";
</code></pre>

<p>Here you have one string only, because the <code>'\0'</code>-terminating byte comes after
the last <code>'e'</code> in the string. If I however do:</p>

<pre><code>line[18] = 0;  // same as line[18] = '\0';
</code></pre>

<p>then I created two strings in the same array:</p>

<pre><code>""This is a sentence\0This is another one""
</code></pre>

<p>because I replaced the semicolon <code>';'</code> with <code>'\0'</code>, thus creating a new string
from position 0 to 18 and a second one from position 19 to 38. If I do now</p>

<pre><code>printf(""string: %s\n"", line);
</code></pre>

<p>the output will be</p>

<pre class=""lang-none prettyprint-override""><code>string: This is a sentence
</code></pre>

<p>Now let's us take look at the function itself:</p>

<pre><code>char *substrtok_r(char *str, const char *substrdelim, char **saveptr);
</code></pre>

<p>The first argument is the source string, the second argument is the delimiters
strings and the third one is doule pointer of <code>char</code>. You have to pass a pointer
to a pointer of <code>char</code>. This will be used to remember where the function should
resume scanning next, more on that later.</p>

<p>This is the algorithm:</p>

<pre class=""lang-none prettyprint-override""><code>if str is not NULL:
    start a new scan sequence from str
otherwise
    resume scanning from string pointed to by *saveptr

found position of substring_d pointed to by 'substrdelim'

if no such substring_d is found
    if the current character of the scanned text is \0
        no more substrings to return --&gt; return NULL
    otherwise
        return the scanned text and set *saveptr to
        point to the \0 character of the scanned text,
        so that the next iteration ends the scanning
        by returning NULL

otherwise (a substring_d was found)

    create a new substring_a until the found one
    by setting the first character of the found
    substring_d to 0.

    update *saveptr to the start of the found substring_d
    plus it's previous length so that *saveptr
    points to the past the delimiter sequence found in substring_d.

    return new created substring_a
</code></pre>

<p>This first part is easy to understand:</p>

<pre><code>if(str)
    haystack = str;
else
    haystack = *saveptr;
</code></pre>

<p>Here if <code>str</code> is not <code>NULL</code>, you want to start a new scan sequence. That's why
in <code>main</code> the <code>input</code> pointer is set to point to the start of the string saved
in <code>line</code>. Every other iteration <strong>must</strong> be called with <code>str == NULL</code>, that's
why the first thing is done in the <code>while</code> loop is to set <code>input = NULL;</code> so
that <code>substrtok_r</code> resumes scanning using <code>*saveptr</code>. This is the standard
behaviour of <a href=""https://linux.die.net/man/3/strtok"" rel=""nofollow noreferrer""><code>strtok</code></a>.</p>

<p>The next step is to look for a delimiting substring:</p>

<pre><code>char *found = strstr(haystack, substrdelim);
</code></pre>

<p>The next part handles the case where no delimiting substring is
found<sup>2</sup>:</p>

<pre><code>if(found == NULL)
{
    *saveptr = haystack + strlen(haystack);
    return *haystack ? haystack : NULL;
}
</code></pre>

<p><code>*saveptr</code> is updated to point past the whole source, so that it points to the
<code>'\0'</code>-terminating byte. The return line can be rewritten as</p>

<pre><code>if(*haystack == '\0')
    return NULL
else
    return haystack;
</code></pre>

<p>which says if the source already is an empy string<sup>1</sup>, then return
<code>NULL</code>. This means no more substring are found, end calling the function. This
is also standard behaviour of <a href=""https://linux.die.net/man/3/strtok"" rel=""nofollow noreferrer""><code>strtok</code></a>.</p>

<p>The last part</p>

<pre><code>*found = 0;
*saveptr = found + strlen(substrdelim);

return haystack;
</code></pre>

<p>is handles the case when a delimiting substring is found. Here</p>

<pre><code>*found = 0;
</code></pre>

<p>is basically doing</p>

<pre><code>found[0] = '\0';
</code></pre>

<p>which creates substrings as explained above. To make it clear once again, before</p>

<p>Before</p>

<pre><code>*found = 0;
*saveptr = found + strlen(substrdelim);

return haystack;
</code></pre>

<p>the memory looks like this:</p>

<pre class=""lang-none prettyprint-override""><code>       +-----+-----+-----+-----+-----+-----+
       | 'a' | ' ' | '-' | '&gt;' | ' ' | 'b' | ...
       +-----+-----+-----+-----+-----+-----+
       ^     ^
       |     |
haystack     found
*saveptr
</code></pre>

<p>After</p>

<pre><code>*found = 0;
*saveptr = found + strlen(substrdelim);
</code></pre>

<p>the memory looks like this:</p>

<pre class=""lang-none prettyprint-override""><code>       +-----+------+-----+-----+-----+-----+
       | 'a' | '\0' | '-' | '&gt;' | ' ' | 'b' | ...
       +-----+------+-----+-----+-----+-----+
       ^     ^                  ^
       |     |                  |
haystack     found              *saveptr
                                because strlen(substrdelim)
                                is 3
</code></pre>

<p>Remember if I do <code>printf(""%s\n"", haystack);</code> at this point, because the <code>'-'</code> in
found has been set to 0, it will print <code>a</code>. <code>*found = 0</code> created two strings out
of one like exaplained above. <a href=""https://linux.die.net/man/3/strtok"" rel=""nofollow noreferrer""><code>strtok</code></a> (and my function which is based on
<code>strtok</code>) uses the same technique. So when the function does</p>

<pre><code>return haystack;
</code></pre>

<p>the first string in <code>token</code> will be the token before the split. Eventually
<code>substrtok_r</code> returns <code>NULL</code> and the loop exists, because <code>substrtok_r</code> returns
<code>NULL</code> when no more split can be created, just like <a href=""https://linux.die.net/man/3/strtok"" rel=""nofollow noreferrer""><code>strtok</code></a>.</p>

<hr>

<p><strong>Fotenotes</strong></p>

<p><sup>1</sup>An empty string is a string where the first character is already the
<code>'\0'</code>-terminating byte.</p>

<p><sup>2</sup>This is very important part. Most of the standard functions in the C
library like <code>strstr</code> will <strong>not</strong> return you a new string in memory, will
<strong>not</strong> create a copy and return a copy (unless the documentation says so). The
will return you a pointer pointing to the original plus an offset.</p>

<p>On success <code>strstr</code> will return you a pointer to the start of the substring,
this pointer will be at an offset to the source.</p>

<pre><code>const char *txt = ""abcdef"";
char *p = strstr(txt, ""cd"");
</code></pre>

<p>Here <code>strstr</code> will return a pointer to the start of the substring <code>""cd""</code> in
<code>""abcdef""</code>. To get the offset you do <code>p - txt</code> which returns how many bytes
there are appart</p>

<pre class=""lang-none prettyprint-override""><code>b = base address where txt is pointing to

b     b+1   b+2   b+3   b+4   b+5   b+6
+-----+-----+-----+-----+-----+-----+------+
| 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | '\0' |
+-----+-----+-----+-----+-----+-----+------+
^           ^
|           |
txt         p
</code></pre>

<p>So <code>txt</code> points to address <code>b</code>, <code>p</code> points to address <code>b+2</code>. That's why you get
the offset by doing <code>p-txt</code> which would be <code>(b+2) - b =&gt; 2</code>. So <code>p</code> points to
the original address plus the offset of 2 bytes. Because of this bahaviour
things like <code>*found = 0;</code> work in the first place.</p>

<p>Note that doing things like <code>txt + 2</code> will return you a new pointer pointing to
the where <code>txt</code> points plus the offset of 2. This is called pointer arithmetic.
It's like regualr arithmetic but here the compiler takes the size of an object
into consideration. <code>char</code> is a type that is defined to have the size of 1,
hence <code>sizeof(char)</code> returns 1. But let's say you have an array of integers:</p>

<pre><code>int arr[] = { 7, 2, 1, 5 };
</code></pre>

<p>On my system an <code>int</code> has size of 4, so an <code>int</code> object needs 4 bytes in memory.
This array looks like this in memory:</p>

<pre class=""lang-none prettyprint-override""><code>b = base address where arr is stored

address       base        base + 4    base + 8    base + 12
in bytes      +-----------+-----------+-----------+-----------+
              |    7      |    2      |    1      |    5      |
              +-----------+-----------+-----------+-----------+
pointer       arr         arr + 1     arr + 2     arr + 3
arithmetic
</code></pre>

<p>Here <code>arr + 1</code> returns you a pointer pointing to where <code>arr</code> is stored plus an
offset of 4 bytes.</p>
",5
53578963,53578497,0,"<p>My personal variant:</p>

<pre><code>char const* data = input; // if input is NOT a pointer or you yet need it unchanged
for(;;)
{
    int offset = 0;
    if(sscanf(data, ""%d,%n"", digit_arr + i, &amp;offset) == 1)
    {
        ++i;
        if(offset != 0)
        {
            data += offset;
            continue;
        }
    }
    break;
}
</code></pre>

<p>You might finally ckeck if all characters in the text are consumed:</p>

<pre><code>if(*data)
{
    // not all characters consumed, input most likely invalid
}
else
{
    // we reached terminating null character -&gt; fine
}
</code></pre>

<p>Note that my code as is does not cover trailing whitespace, you could do so by changing the format string to <code>""%d, %n</code> (note the added space character).</p>
",0
54228635,54228447,0,"<p>I'm not sure if this makes sense in the context you're seeing it, but the only use of ""tearing"" in computing I'm familiar with is when data from different frames is displayed on screen simultaneously.</p>

<p>Wikipedia has <a href=""https://en.wikipedia.org/wiki/Screen_tearing"" rel=""nofollow noreferrer"">an article on it</a> if you'd like more data.</p>

<p>If that's not the ""tearing"" you're encountering, perhaps you could provide a bit more context?  If the code is open source, linking to it would be great.</p>
",0
48407185,48407104,6,"<pre><code>int enabled = val == 0;
</code></pre>

<p>read as </p>

<pre><code>int enabled = (val == 0);
</code></pre>

<p>and</p>

<pre><code>(val == 0)
</code></pre>

<p>will be either 0 or non zero if val is 0 or not. <code>enabled</code> will then be initialized with that value</p>

<p>Equivalent to:</p>

<pre><code>int enabled;
if(val == 0)
{
    enabled = 1;
}
else
{
    enabled = 0;
}
</code></pre>

<p>now you do that same analysis on the second one</p>
",0
53165394,53165004,1,"<p>Working under the assumption that <code>struct b</code> is larger than <code>struct a_header</code> (otherwise <code>sizeof(struct b) - sizeof(struct a_header)</code> would be zero or very large since <code>size_t</code> cannot be negative), this statement clears any bytes in <code>union a</code> that are used by <code>b_hdr</code> but <em>not</em> <code>a_hdr</code>.</p>

<p>Breaking down the expression:</p>

<pre><code>&amp;a-&gt;a_hdr
</code></pre>

<p>Given than <code>a</code> is a pointer to <code>union a</code>, this gets the address of the <code>a_hdr</code> field</p>

<pre><code>(&amp;a-&gt;a_hdr)[1]
</code></pre>

<p>This treats the above address as an array and gets the element at offset 1.  There is none, so this <em>would</em> be undefined behavior, but then we have:</p>

<pre><code>&amp;(&amp;a-&gt;a_hdr)[1]
</code></pre>

<p>Since <code>a[b]</code> is exactly equivalent to <code>*(a + b)</code>, the above is the same as:</p>

<pre><code>&amp;(*(&amp;a-&gt;a_hdr + 1))
</code></pre>

<p>The <code>&amp;</code> and <code>*</code> adjacent to each other cancel each other out, so now you have:</p>

<pre><code>&amp;a-&gt;a_hdr + 1
</code></pre>

<p>So this points one element past the array of length 1 that is <code>a-&gt;a_hdr</code>.  It is this address that is passed to <code>bzero</code>.  The cast to <code>char *</code> is unnecessary since <code>bzero</code> takes a <code>void *</code> as its first parameter.</p>

<p>The second parameter:</p>

<pre><code>sizeof(struct b) - sizeof(struct a_header)
</code></pre>

<p>Again, assuming <code>struct b</code> is bigger than <code>struct a_header</code>, this gives us the number of bytes that <code>struct b</code> is bigger by.  So the bytes used by <code>b_hdr</code> but <em>not</em> <code>a_hdr</code> are cleared.</p>

<p>To illustrate, suppose the <code>struct b</code> is 8 bytes and <code>struct a_header</code> is 4 bytes.  Then a <code>union a</code> would look like this:</p>

<pre><code>---------------------------------
| X | X | X | X | X | X | X | X |
---------------------------------
|           struct b            |
---------------------------------
|struct a_header|
-----------------
</code></pre>

<p>Where <code>X</code> is some unknown byte value.  After the above call to <code>bzero</code>, it looks like this:</p>

<pre><code>---------------------------------
| X | X | X | X | 0 | 0 | 0 | 0 |
---------------------------------
|           struct b            |
---------------------------------
|struct a_header|
-----------------
</code></pre>
",2
53382154,53382014,2,"<p>When the lifetime of an object with automatic storage duration ends, that just means the memory is released (so that it may be used for other purposes). It does not guarantee that the memory is erased or that it is used for other purposes.</p>

<p>When the lifetime of another instance of the same object begins, memory is allocated for it again. It may happen to be the same memory that was used for it before. There is no guarantee that it was erased or used for other purposes.</p>
",0
53382415,53382014,2,"<p>Your program has what is scientifically known as <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behaviour</a>. In your case it results from using (printing) a bunch of <code>int</code> objects before initialising them.</p>

<p>Since the behaviour is undefined, program output can be anything at all, including a stream of characters that could possibly in theory lead someone into believing in an obvious nonsense (like <code>a</code> having static storage duration). </p>

<p>In practical terms, this is what happens if you ignore the high-brow world of language standards and look at the <em>iron</em>:</p>

<ul>
<li>At round 1 <code>a</code> contains garbage values, remnants of whatever has been stored at that memory location previously. </li>
<li>At round 2 <code>a</code> still contains garbage values, remnants of whatever has been stored at that memory location previously. </li>
</ul>

<p>The only difference is that the garbage looks familiar to you, because it happens to be <em>your</em> garbage. You can see it because the garbage people did not have a chance to collect it yet. It is still garbage however ¡ª the garbage people <strong>will</strong> remove it at some point.</p>
",0
53382145,53382014,3,"<p>The array <code>a</code> is an <strong>automatic</strong> variable because it is defined in a block scope, the block in this case being the body of the <code>for</code> loop.  The fact that you see the values you set the last time doesn't mean the variable is static.</p>

<p>Automatic variables are <strong>uninitialized</strong> if not explicitly initialized.  This basically means they'll contain whatever happened to be in those memory locations the last time they were used.  </p>

<p>On the first iteration of the loop, you see seemingly random values in the array.  The variable then goes out of scope at the end of the loop, and on the next iteration a new instance is created, but in this case it happened to be created at the same memory location it was created at last time, and nothing else happened to write to that memory location, so you end up seeing the same values.  There's no guarantee that you'll see the same behavior if you for example make an unrelated code change or compile with different optimization settings.</p>
",0
59223619,59223532,2,"<p>That would be a spectacularly <em>bad</em> implementation of memory allocation functions and, in fact, the standard (referencing C11, the current standard in force) appears to disallow it (I'm activating ""language lawyer"" mode here):</p>

<blockquote>
  <p>The <code>free</code> function causes the <strong><em>space pointed to</em></strong> by <code>ptr</code> to be deallocated, that is, <strong><em>made available for further allocation.</em></strong></p>
</blockquote>

<p>The space pointed to is the <em>whole</em> space so, if you can only use part of it, that's not really following the standard. Now you may <em>think</em> you could argue that it only has to free the space taken by the size you specified but I don't believe that's the case. In <code>malloc</code>, it states:</p>

<blockquote>
  <p>The <code>malloc</code> function allocates space for an object whose size is specified by <code>size</code> and whose value is indeterminate. The <code>malloc</code> function returns either a null pointer or a pointer <strong><em>to the allocated space.</em></strong></p>
</blockquote>

<p>Note that phrase ""allocated space"" mirroring the ""space pointed to by"" phrase in <code>free</code> - I believe that refers to the <em>entire</em> allocated chunk even though, if it's bigger than what you asked for, you should not use the excess (in fact, you don't even <em>know</em> there is excess).</p>

<p>Reading those two quotes in conjunction seems to indicate it must free the lot.</p>

<p>But, as stated earlier, and language lawyering aside, any implementation that actually <em>did</em> what you posit would be very short-lived as it consistently crashed from lack of memory caused by memory leaks.</p>

<p>Or, in a less nerdy context, when I ask to borrow your lawnmower and you also give me your hedge-trimmer out of the kindness of your heart, I suspect you wouldn't be happy to find out I've listed the latter on eBay because I assumed that, since I hadn't asked for it, you didn't need it back :-)</p>

<hr>

<p>Also, as an aside re your ""malloc takes memory in x8 bytes"" comment, that is by no means a given.</p>

<p>For example, I have in the past implemented allocation functions in embedded systems where <code>x</code> bytes was given regardless of what value not greater than that was asked for (obviously, if you asked for more, it just failed).</p>

<p>This allowed for optimisations in situations where you knew allocations should never be larger than that.</p>

<p>So, while you'll frequently find implementations that impose a certain resolution (be it eight bytes, sixteen or some other size), that's by no means mandated.</p>
",1
56607164,56607135,2,"<p>There are no ""unwanted braces"" in this code.  There is an anonymous block, which is not an error.  In fact, it is allowed by the spec.</p>

<p>Your variable <code>k</code> is defined in the main scope, but then shadowed in the anonymous block.</p>

<pre><code>int main() {
  int k = 0;
    {
    int k = 1;
    // do more stuff with k
    }
  // k is still 0 here.
}
</code></pre>

<p>When I was programming C, something like 1000 years ago, I would have had stern words for a dev on my team who tried using this trick.</p>
",0
54972215,54972156,1,"<p>Firstly, you are comparing <code>username</code> against itself. Obviously that will always be a ""true"" result.<sup>&dagger;</sup></p>

<p>You should read the username from the file into <em>one</em> variable, then the user input into <em>another</em> variable, and compare those two <em>different</em> variables.</p>

<p>Secondly, you need to understand <a href=""https://stackoverflow.com/q/8004237/560648"">how to properly compare character arrays</a>.</p>

<p><sub><sup>&dagger;</sup> There are times that this isn't true, like comparing <em>NaN</em> values, but this isn't one of them!</sub></p>
",0
54972215,54972156,1,"<p>Firstly, you are comparing <code>username</code> against itself. Obviously that will always be a ""true"" result.<sup>&dagger;</sup></p>

<p>You should read the username from the file into <em>one</em> variable, then the user input into <em>another</em> variable, and compare those two <em>different</em> variables.</p>

<p>Secondly, you need to understand <a href=""https://stackoverflow.com/q/8004237/560648"">how to properly compare character arrays</a>.</p>

<p><sub><sup>&dagger;</sup> There are times that this isn't true, like comparing <em>NaN</em> values, but this isn't one of them!</sub></p>
",0
49659697,44097610,1,"<p>I think that a better approach to address this issue is the use the <code>on_exit</code> function instead of the <code>atexit</code> function.</p>

<p>Please refer to the relevant man page - <a href=""http://man7.org/linux/man-pages/man3/on_exit.3.html"" rel=""nofollow noreferrer"">http://man7.org/linux/man-pages/man3/on_exit.3.html</a></p>
",1
52309400,52309235,7,"<p>In <code>strlen(line) - 1</code>, the type of <code>strlen(line)</code> is <code>size_t</code>, an unsigned integer type. With the definition of <code>size_t</code> on your compilation platform, <a href=""https://port70.net/~nsz/c/c11/n1570.html#6.3.1.1p2"" rel=""nofollow noreferrer"">C's promotion rules</a> make the subtraction a <code>size_t</code> (unsigned) subtraction, giving a <code>size_t</code>(unsigned) result. The result is <code>(size_t)-1</code>, which is typically <code>0xffffffff</code> or <code>0xffffffffffffffff</code>.</p>

<p>While not providing the above explanation, <a href=""https://taas.trust-in-soft.com/tsnippet/t/b0072c8f"" rel=""nofollow noreferrer"">this online C interpreter</a> hints at the problem by indicating that you are passing the wrong type for the format <code>%ld</code> in <code>printf</code>. On the selected compilation platform, the above applies and the <code>printf</code> argument <code>strlen(line) - 1</code> has type <code>size_t</code>, which should be printed with <code>%zu</code>.</p>

<p>This unsigned arithmetic causes your program to <a href=""https://taas.trust-in-soft.com/tsnippet/t/38356ca4"" rel=""nofollow noreferrer"">use</a> <code>line[j]</code> while this memory location is uninitialized. If you change all occurrences of <code>strlen(line) - 1</code> to <code>(int)strlen(line) - 1</code>, to force an <code>int</code> subtraction computing a signed result, then <a href=""https://taas.trust-in-soft.com/tsnippet/t/6147cb31"" rel=""nofollow noreferrer"">the program does not have undefined behavior</a>.</p>

<p>As noted in the comments, changing <code>strlen(line)</code> to <code>(int)strlen(line)</code> is only a quick-and-dirty fix, and limits the scope of inputs the program can be applied to if <code>int</code> is narrower than <code>size_t</code>. The proper fix is to examine each larger expression involving the result of <code>strlen</code> and to rewrite it so that it does what the programmer intends using <code>size_t</code> arithmetic. As an example, the condition <code>j == (strlen(line) - 1)</code> can be written <code>(size_t)j + 1 == strlen(line)</code>. This in turn suggests that a number of variables, including <code>j</code>, should be directly declared as <code>size_t</code> instead of <code>int</code>.</p>
",6
49785746,49785710,3,"<p>This is nothing to do with c. Its your shell processing its line before running your program. You don't specify your os, but you will need to escape the arguments whatever</p>
",1
54750975,54750876,6,"<p><code>ITIMER_REAL</code> sends <code>SIGALRM</code> not <code>SIGVTALRM</code>. 
Change the signal and it'll work.</p>

<pre><code>#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/time.h&gt;

void timer_handler (int signum)
{
 static int count = 0;
 printf (""timer expired %d times\n"", ++count);
}

int main ()
{
 struct sigaction sa;
 struct itimerval timer;

 /* Install timer_handler as the signal handler for SIGVTALRM. */
 memset (&amp;sa, 0, sizeof (sa));
 sa.sa_handler = &amp;timer_handler;
 sigaction (SIGALRM, &amp;sa, NULL);

 /* Configure the timer to expire after 250 msec... */
 timer.it_value.tv_sec = 0;
 timer.it_value.tv_usec = 250000;
 /* ... and every 250 msec after that. */
 timer.it_interval.tv_sec = 0;
 timer.it_interval.tv_usec = 250000;
 /* Start a virtual timer. It counts down whenever this process is
   executing. */
 setitimer (ITIMER_REAL, &amp;timer, NULL);

 /* Do busy work. */
 while (1);
}
</code></pre>

<p>(Generally, it's a bad idea to <code>printf</code> in a signal handler since <code>printf</code> isn't async-signal safe, but in your case it shouldn't be dangerous, because you're interrupting regular-context code that <em>is</em> async-signal safe (namely the busy loop). POSIX doesn't appear to guarantee this special exception, though, so to be perfectly safe, you should refrain from making <em>any</em> async-signal unsafe calls in signal handlers and replace the <code>printf</code> with a <code>write(1, ...)</code>.)</p>
",0
59036409,59036295,1,"<p>A backslash can be used to escape a newline in source code so that two lines are treated as a single line.</p>

<p>In your particular case it has no effect on the code, however it's more commonly used in macros which end at the time a newline is reached, i.e.:</p>

<pre><code>#define MY_MACRO(x) \
    do {\
        int y;\
        y = foo();\
        x = y;\
    } while (0)
</code></pre>

<p>Here the backslashes are required, otherwise only the first line would be part of the macro.</p>
",0
53151046,53150979,3,"<p>To answer the actual main question, exactly one, If you wish to return more you need to pass in a pointer, or return one to a struct, ie:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

bool test(int * data)
{
    *data = printf(""it is test\n"");
    return false;
}

int main()
{
    int data;
    if (false == test(&amp;data))
        printf(""return result is false, data = %d\n"", data);
}
</code></pre>

<p>As for why it works, please see: <a href=""https://stackoverflow.com/questions/32094189/comma-separated-return-arguments-in-c-function"">Comma-Separated return arguments in C function</a></p>
",2
53007928,53007738,2,"<p>Your <code>write_file</code> function already adds a <code>'\n'</code> :</p>

<pre><code>fprintf(fp, ""%s\n"", result[i]);
</code></pre>

<p>So, when you fill the array that you pass to that function you should not add additional newlines.</p>

<p>Ie. instead of building <code>a</code> as a single string with all lines concatenated, build it as an array of strings, with an item in the array for each line (without the <code>'\n'</code>).</p>

<p>To achieve that, you'll want to <a href=""https://stackoverflow.com/questions/5935933/dynamically-create-an-array-of-strings-with-malloc"">allocate memory for this array</a>, and then replace your current <code>snprintf</code> call with one that writes to the next item in that array, instead of to <code>a + OFFSET</code> :</p>

<pre><code>char **a = malloc(MAX_LAENGE_ARR * sizeof(char*));
</code></pre>

<p>and then for each line :</p>

<pre><code>a[count] = malloc(MAX_LAENGE_STR * sizeof(char));
snprintf(a[count], MAX_LAENGE_STR, ...);
</code></pre>

<p>Don't forget to <a href=""https://stackoverflow.com/questions/4733649/freeing-memory-which-has-been-allocated-to-an-array-of-char-pointers-strings"">free the allocated memory</a> once you no longer need it.</p>
",6
55599456,55598922,1,"<p>I was able to reproduce your issue locally.  Having done so, I modified the program to be more informative about the nature of the problem: instead of printing a hand-rolled yet minimally-expressive error message, I used the <code>perror()</code> function to print a message that explains the specific nature of the error:</p>

<pre><code>    if (retsize &lt; 0) {
        perror(""read"");
        exit(-1);
    }
</code></pre>

<p>Running the resulting program produced this message:</p>

<blockquote>
  <p>read: Bad address</p>
</blockquote>

<p>This seems to be reporting on the problem that @MichaelBurr noted in his comment: you have declared <code>buf</code> as a pointer to <code>unsigned</code>, but you have not assigned it to point to anything.  As a result, it is a dangling pointer, and you should consider yourself lucky that the <code>read</code> function was able to recognize that, instead of (probably) clobbering random memory somewhere in your program's address space.  It seems likely that you instead want to declare <code>buf</code> as an <em>array</em>, maybe something like this:</p>

<pre><code>    unsigned buf[16];
</code></pre>

<p>With that additional correction, the program no longer reported an error from <code>read()</code>.  That means it probably didn't have an error in <code>open()</code>, either, or in <code>lseek()</code>, but you ought to be testing each of those results individually.</p>
",1
52922361,52920591,0,"<p>You currently have:</p>

<pre><code>int parent = wait(NULL); //Wait on children
</code></pre>

<p>This waits on one child, not all children.  The shell <code>wait</code> command is different from the <code>wait()</code> system call in this respect.</p>

<p>You need, therefore, something like:</p>

<pre><code>int corpse;
int status;
while ((corpse = wait(&amp;status)) &gt; 0)
    printf(""PID %d exited with status 0x%.4X\n"", corpse, status);
</code></pre>

<p>This loops until there are no more children.  A possible alternative would be to use <code>waitpid()</code> to wait for each child in turn, but you'd ¡­ well, to be sensible, you'd need to store the pids of the children in an array instead of three numbered variables, but you could do it with three variables.</p>

<p>Your code needs to use far more functions and have far less repetition of everything three times with the names of the variables changing.  Handling 2 or 4 or 5 children should be as simple as handling 3 ¡ª with the current code structure, that is anything but trivial.</p>

<p>For example, if you created a function:</p>

<pre><code>static void wait_for_pid(int pid)
{
    int corpse;
    int status;
    if ((corpse = waitpid(pid, &amp;status, 0)) &gt; 0)
        printf(""PID %d exited with status 0x%.4X\n"", corpse, status);
    else
    {
        fprintf(stderr, ""failed to wait for PID %d\n"", pid);
        exit(EXIT_FAILURE);
    }
}
</code></pre>

<p>You could then use:</p>

<pre><code>wait_for_pid(res.pid1);
wait_for_pid(res.pid2);
wait_for_pid(res.pid3);
</code></pre>

<p>That's not great, but it is better than writing out the <code>waitpid()</code> code with error checking 3 times.</p>

<p>Your timing code is suspect too.  It is pretty much guaranteed not to be giving the correct results.  You stop the clock on process 2 before you've even launched process 3, but that doesn't mean that process 2 has even got going, much less finished.</p>
",0
49713412,49713376,3,"<p>First of all, use <code>%p</code> for printing addresses, not <code>%d</code>.</p>

<p>And your problem is that <code>malloc</code> just allocates memory, it <strong>does not initialize it</strong>. And you <code>malloc</code> call only initialized the memory for a <code>struct stc_free_lk</code> object, it does not allocate memory the members that are pointers, you need to allocate memory for them as well.</p>

<p>So <code>lk_header-&gt;buf_header</code> is pointing to nowhere, you cannot dereference it, it's undefined behaviour.
What you are seeing is a classic case of undefined behaviour.</p>

<p>Like I said, you have to initialize the member of the struct before you can access them.
You could use <code>calloc</code> instead of <code>malloc</code> because <code>calloc</code> sets the allocated
memory to 0, this helps when initializing pointers in structs.</p>

<pre><code>stc_free_lk *link = calloc(1, sizeof *link);
if(link == NULL)
{
    fprintf(stderr, ""Not enough memory\n"");
    return 1;
}

link-&gt;header = calloc(1, sizeof *link-&gt;header);
if(link-&gt;header == NULL)
{
    fprintf(stderr, ""Not enough memory\n"");
    free(link);
    return 1;
}

init(link-&gt;lk_header, (unsigned)0, (unsigned)0);
...
</code></pre>

<p>Then in <code>init</code> you should also allocate memory for <code>lk_header-&gt;buf_header</code> and
<code>lk_header-&gt;data_area</code> and so on.</p>

<p>I suggest that you write a function that allocates all the memory for all the
pointers so that you don't have to allocate memory at different places. That
makes the code hard to follow and hard to find bugs. Also I'd write a <code>destroy</code>
function that <code>free</code>s all allocated memory, again all in one place.</p>
",3
56731742,56730367,1,"<p>As others said, the <code>pipe()</code> function returns two descriptors that are already ready-to-use. That means, the <code>pipe()</code> already opens them for you. Otherwise it could not guarantee that these are conected to each other.</p>

<p>Remember that you are responsible for closing both of them!</p>

<p>Your whole solution should like something close to this pseudocode below:</p>

<pre><code>main
   variable: fileDescriptor

   detect if command line contains a filename, or file content
   if it was a filename
      fileDecriptor = openFile(some arguments...)
   if it was a filecontent
      fileDecriptor = openAndFillPipe(some other arguments...)

   doWhetever(fileDescriptor) // here's the 'operations' on the 'file'

   close(fileDescriptor) // whatever we got, we need to clean it up


openFile(filename)
    // simply: any file-opening will do
    descriptor = open(filename, ...)


openAndFillPipe(filecontent)
    // first, make a pipe: two connected descriptors
    int pairOfDescriptors[2];
    pipe(pairOfDescriptors);

    // [0] is for reading, [1] is for writing
    write(pairOfDescriptors[1], filecontent, ...) // write as if to a file

    close(pairOfDescriptors[1])  // we DONT need the 'write' side anymore

    descriptor = pairOfDescriptors[0] // return the 'read' as if it was a file
</code></pre>
",0
51337205,51330586,3,"<p>There is exactly one use case where</p>

<pre><code>struct somestruct  foo = { 0 };
</code></pre>

<p>is not sufficient, and</p>

<pre><code>struct somestruct  foo;
memset(&amp;foo, 0, sizeof foo);
</code></pre>

<p>needs to be used instead: when the padding in the structure may be important.</p>

<p>You see, the only difference between the two is that the latter is quaranteed to clear structure padding to zero too, whereas the former is only quaranteed to clear structure members to zero.</p>

<p>The reason one might care about padding, is based on upwards/future compatibility. If padding is quaranteed to be zero in current programs, a future version of a library can ""reuse"" the padding for new data fields, and still work with older binaries.</p>

<p>Since C99, new C libraries do, and should, reserve some members for just that purpose explicitly. That's usually why you see ""reserved"" fields in structures defined by many libraries, and even in the Linux kernel-userspace interface.  So, the padding issue is really only relevant to structures developed before C99 support became widespread; in other words, in old libraries only.</p>

<p>The one structure I know should always be cleared using <code>memset()</code>, is <code>struct sigaction</code>, defined in POSIX.1. In most POSIXy systems it is a perfectly normal structure (and so code that just clears the members of the structure will work absolutely fine on those systems), but because of the various different implementations at different times (especially how the signal mask is implemented), I believe there are still systems with C libraries that have a version of the structure where clearing the padding is still important.</p>

<p>(This is because of how the <code>sa_handler</code> and <code>sa_sigaction</code> members are usually in an union, and/or because the definition of <code>sigset_t</code> may have changed.)</p>

<p>It is possible there are others in some other older libraries, so I would recommend using the <code>memset()</code> idiom when working with libraries with pre-1999 roots, whose example code also uses it.</p>
",0
51379337,51379237,3,"<p>In C you can only pass arguments <em>by value</em>. That means as you pass an argument to a function, the value is <em>copied</em>.</p>

<p>C doesn't have pass by reference, but it can be emulated using pointers.</p>

<p>For example</p>

<pre><code>#include &lt;stdio.h&gt;

void f1(int a)
{
    a = 123;  // Modify local copy
}

void f2(int *a)
{
    *a = 234;  // Modify value where a is pointing
}

int main(void)
{
    int a1 = 0, a2 = 0;

    f1(a1);
    f2(&amp;a2);

    printf(""a1 = %d, a2 = %d\n"", a1, a2);
}
</code></pre>

<p>The above program would print</p>

<pre>
a1 = 0, a2 = 234
</pre>

<p>That's because when <code>f1</code> modifies the value of its argument, it only modifies its local copy. The original (the variable <code>a1</code> in the <code>main</code> function) is not modified.</p>

<p>The function <code>f2</code> on the other hand emulates pass by reference. When calling <code>f2</code> we pass a pointer to the variable <code>a2</code> by using the address-of operator <code>&amp;</code>. Then the function can dereference that pointer to get where it is pointing (the variable <code>a2</code> in the <code>main</code> function) and modify it.</p>

<p>Because the <code>scanf</code> function needs to modify variables, you can not pass copies of their current values, you need to pass pointers to the variables like when calling <code>f2</code> in the above example.</p>
",0
58205804,58205742,2,"<p>Consider using these small improvements:  </p>

<p>The prototype:</p>

<pre><code>List newList(void);
</code></pre>

<p>Should be changed to:</p>

<pre><code>List  *newList(void);
</code></pre>

<p>Then the return statement in that function call should be:</p>

<pre><code>return pL; //(remove *)
</code></pre>

<p>This suggestion is the same for the other functions attempting similar usage, such as:  <code>ListObj newListObj(void)</code> etc.</p>

<p>Do not forget to free this memory when done using it in the calling function.</p>

<p>The following is basically your code <em>with no other improvements</em> <strong><em>other than</em></strong> addition of a <code>main()</code> function with one example call, the suggestions regarding using pointers, and follow-on side-affects of using pointers.  eg, struct pointer notation, freeing, etc.:  ( It builds and runs, but I am not sure these improvements will address other problems the code may have.)  </p>

<pre><code>List * newList(void)
{
    List* pL = malloc(sizeof(List));

    if (pL == NULL)
    {
        fprintf(stderr, ""malloc failed\n"");
        exit(EXIT_FAILURE);
    }

    pL-&gt;front = pL-&gt;back = pL-&gt;cursor = NULL;

    return pL;
}

ListObj * newListObj(void)
{
    ListObj* pLO = malloc(sizeof(ListObj));

    if (pLO == NULL)
    {
        fprintf(stderr, ""malloc failed\n"");
        exit(EXIT_FAILURE);
    }

    pLO-&gt;next = pLO-&gt;prev = NULL;

    return pLO;
}

int length(List *L)
{
    L-&gt;cursor = L-&gt;front;
    int n = 0;

    while (L-&gt;cursor != NULL)
    {
        n++;
        L-&gt;cursor = L-&gt;cursor-&gt;next;
    }

    return n;
}

void append(List *L, int data)
{
    ListObj *LO = newListObj();
    LO-&gt;data = data;

    if (L-&gt;back != NULL)
    {
        LO-&gt;prev = L-&gt;back;
        L-&gt;back-&gt;next = LO;
    }

    L-&gt;back = LO;
    if (L-&gt;front == NULL)
    {
        L-&gt;front = LO;
    }

    if (L-&gt;front == NULL)
    {
        printf(""append null\n"");
    }
}

int main(void)
{
    List *L = newList();
    for (int i = 0; i &lt; 5; i++)
    {
        if (length(L) == 0)
        {
            append(L, i);
        }
    }
    free(L);
    return 0;
}
</code></pre>
",0
52283878,52283831,10,"<p>Unfortunately, you thought wrong.</p>

<p>On a typical implementation with 32-bit ints and 32-bit floats, it is obvious that a float cannot contain all ints exactly, as some of its bits must be used for the exponent, to make it floating point.</p>

<p>If your platform is IEEE-754 compatible, and your float is single-precision, specifically it breaks up like this:</p>

<ul>
<li>1 bit - sign</li>
<li>8 bits - exponent</li>
<li>24 bits<sup>1</sup> - significand</li>
</ul>

<p>This means that all integers up to 24 bits can be exactly represented, after that, some precision must necessarily be lost for some numbers.</p>

<p>With the same assumptions, a double will hold all 32-bit integers, as a double has 53 bits of precision.</p>

<p>References:</p>

<ul>
<li><a href=""https://en.wikipedia.org/wiki/Single-precision_floating-point_format"" rel=""nofollow noreferrer"">Single Precision Format</a></li>
<li><a href=""https://en.wikipedia.org/wiki/Double-precision_floating-point_format"" rel=""nofollow noreferrer"">Double Precision Format</a></li>
<li><a href=""https://en.wikipedia.org/wiki/IEEE_754"" rel=""nofollow noreferrer"">IEEE-754</a></li>
</ul>

<p><sup>1</sup>: Only 23 bits are stored, but the top bit is always considered to be 1, for regular numbers.  This means if the top bit needs to be zero, the whole thing is shifted left, and the exponent decreased.  This gets us an extra bit of precision that doesn't need to be stored.</p>
",6
52501361,52500868,3,"<p>You want something like this:</p>

<pre><code>struct Node{
   int value; 
   struct Node* next; 
}

int main(int argc, char** argv){

    struct Node* mylist;  // declare the mylist pointer, it points nowhere right now

    mylist = malloc(1 * sizeof *mylist);   // roughly the same as ""1 * sizeof(struct Node)""
                                           // now mylist points to a memory region of 
                                           // size (1 * sizeof(struct Node))
    // do something
    mylist-&gt;value = 1234;
    .....

    // once you're done 
    free(mylist); 
    // now mylist points nowhere again
}
</code></pre>

<p>I suggest you read the chapter dealing with pointers and dynamic memory allocation in your C text book.</p>
",0
55659380,55658154,0,"<p><sup><em>Transferring relevant comments into an answer.</em></sup></p>

<p>You have to remove the redirection text from the command line. Commands don¡¯t get to see any of the redirection done by the shell. The chances are you¡¯re asking to list the file into the file.</p>

<blockquote>
  <p>What do you mean I ""have to remove the redirection text from the command line""?</p>
</blockquote>

<p>You must make sure that when your shell executes <code>ls &gt; out.txt</code>, neither the <code>&gt;</code> nor the <code>out.txt</code> are passed to <code>ls</code>. I suspect that you¡¯re passing the file name. At least, it is an explanation for why you see (only) the file name in the output file.</p>

<p>And as <a href=""https://stackoverflow.com/users/2858773/ajay-brahmakshatriya"">Ajay Brahmakshatriya</a> <a href=""https://stackoverflow.com/questions/55658154/implementing-a-shell-in-c-output-redirection-is-writing-output-file-name-to-out/55659380#comment98005538_55658154"">said</a>:</p>

<blockquote>
  <p>I think the command you are finally executing is <code>ls out.txt</code>. Like Jonathan said, you are not removing the second argument. This causes <code>ls</code> to just print <code>out.txt</code> (since it is in the directory) and that is all that goes into the output. </p>
</blockquote>

<hr>

<blockquote>
  <p>Thank you both! That ended up being my issue.</p>
</blockquote>
",0
52228280,52228240,1,"<p>Redirecting input and output with pipes does not populate <code>argv</code>; it simply points <code>stdin</code> and <code>stdout</code> elsewhere, from within the execution environment. This is transparent to your program.</p>

<p><code>argv</code> contains command-line arguments that are passed to the program itself, not the execution environment.</p>
",3
50218198,50218083,3,"<p>This segmentation fault is caused by allocating too much automatic memory through VLA (variable-length arrays).</p>

<blockquote>
  <p>I made sure my code stays within the allowed limit of 50000 bytes</p>
</blockquote>

<p>Large VLAs may cause undefined behavior even if your program has plenty of memory available for dynamic allocation, because they take memory from the automatic storage (commonly referred to as ""stack""). The amount of automatic storage available to your program is usually a fraction of the total memory available to your process.</p>

<p>You can fix this problem by switching to dynamic allocation:</p>

<pre><code>long int *a = malloc(sizeof(long int)*size);
long int *b = malloc(sizeof(long int)*size2);
...
free(a);
free(b);
</code></pre>
",4
49846564,49844415,0,"<blockquote>
  <p><strong>Are structs guaranteed to be aligned to sizeof(size_t) in C?</strong></p>
</blockquote>

<p>No.</p>

<p>You've misunderstood the use of <code>size_t</code> in the quoted paragraph. The alignment of a type is a value <em>of type</em> <code>size_t</code>. For example, the alignment of type <code>char</code> is <code>(size_t)1</code>, and a structure containing only a single <code>char</code> member might itself have an alignment of <code>(size_t)1</code>. (Or it might have a larger alignment.)</p>

<p><code>size_t</code> is just the type used to represent an alignment value. The size or alignment of the type <code>size_t</code> has nothing to do with the size or alignment of a structure -- unless the structure happens to have a member of type <code>size_t</code>.</p>
",0
52649373,52649302,1,"<p>When checking for equality in <code>C</code> you should use double equals <code>==</code> otherwise this is interpreted as assignment. Thus on this line:</p>

<pre><code>if(strcmp(array[i].value, string) = 0){
</code></pre>

<p>You try to assign a result to function return value which is non-modifiable lvalue.</p>
",0
49942628,49942418,1,"<p>If you don't use the hard-to-read pointer arithmetic syntax <code>*(pArr + i)</code> but instead use indexing <code>pArr[i]</code>, then the bug is much easier to spot.</p>

<p>scanf expects an address but you pass a value. Change the code to this:</p>

<pre><code>scanf(""%d"", &amp;pArr[i]);
</code></pre>

<p>Also never cast the result of malloc, since this hides away bugs. In your case, it created a new bug since you accidentally cast to <code>int</code>. Your compiler must give a diagnostic message there.</p>
",0
49942674,49942418,1,"<p>There are two problems here:</p>

<p>The one that triggers the error you mention is here:</p>

<pre><code>scanf(""%d"",*(pArr + i));
</code></pre>

<p>For <code>scanf</code> you need to provide the <em>pointer</em> to the variable you want the input to go, but you provided the <em>value</em> of the variable.</p>

<p>You need</p>

<pre><code>scanf(""%d"", pArr + i);
</code></pre>

<p>or</p>

<pre><code>scanf(""%d"", &amp;pArr[i]);
</code></pre>

<p>The second problem is more subtle:</p>

<p>In this line you cast the result of <code>malloc</code> to <code>int</code>, but you probably wanted to cast it to <code>int*</code> (<code>malloc</code> returns a <em>pointer</em>).</p>

<pre><code>int * pArr = (int)malloc(sizeof(int) * size);
</code></pre>

<p>But anyway, in C you don't cast the return value from <code>malloc</code>, just write:</p>

<pre><code>int * pArr = malloc(sizeof(int) * size);
</code></pre>

<p>But best practice is writing:</p>

<pre><code>int * pArr = malloc(sizeof *pArr * size);
</code></pre>

<p>That way the argument of <code>sizeof</code> always matches the size of the type (<code>int</code> here).</p>
",0
58263340,58263191,2,"<p>The conversion you are doing is explicitly allowed by the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C standard</a>.  Section 6.3.2.3p1 regarding pointer conversions states:</p>

<blockquote>
  <p>A pointer to <code>void</code> may be converted to or from a pointer to any
  object type.  A pointer toa ny object  type  may  be  converted  to  a
  pointer  to <code>void</code> and  back  again;  the  result  shall compare equal
  to the original pointer.</p>
</blockquote>

<p>It's also not necessary to explictily cast to or from a <code>void *</code>.  So you can do something like this:</p>

<pre><code>void someFunc(void *newSizePtr){
    int *actualValuePtr = newSizePtr;
}

int main(){
    int newSize = size;
    pthread_t tid;
    pthread_create(&amp;tid, NULL, someFunc, &amp;newSize);
}
</code></pre>
",4
48412014,48411840,2,"<p>There are a couple of methods you could use to get the data into the program associated with a name, depending on how your program is structured.</p>

<p>If your program doesn't contain <em>variables</em> with those names already, then there's not a way to generate variables from a file. You could create a dictionary mapping the names to the values and use that as your ""variable"".</p>

<p>I suppose you could also have a dictionary mapping the names to the addresses of existing variables... so that you look up the name and then deref the variable to set if its in the dictionary.</p>

<p>As a really far-out solution... if you can recompile each time there is a new file (ie. the file is really compile-time input, not run-time input) then you might be able to use some kind of preprocessing to <code>#include</code> the  (possibly itself preprocessed into c-code) file of data.</p>
",0
53073023,53072885,2,"<p>As I said in comment , C array indexes go from 0 to len -1 . So change</p>

<pre><code>for (int i = 1; i &lt;= 4; i++) {
</code></pre>

<p>to </p>

<pre><code>for (int i = 0; i &lt;4; i++) {
</code></pre>

<p>BTW it should be</p>

<pre><code>for (int i = 0; i &lt; ARRAY_SIZE; i++) {
</code></pre>
",0
48177204,48177104,2,"<p>According to the documentation for <code>recvfrom</code> this is expected if you're using a non-blocking call:</p>

<blockquote>
If no messages are available at the socket, the receive call waits for a message to arrive, unless the socket is nonblocking (see <code>fcntl(2)</code>) in which case the value -1 is returned and the external vari-
     able errno set to <code>EAGAIN</code>.  The receive calls normally return any data available, up to the requested amount, rather than waiting for receipt of the full amount requested; this behavior is affected by the
     socket-level options <code>SO_RCVLOWAT</code> and <code>SO_RCVTIMEO</code> described in <code>getsockopt(2)</code>.
</blockquote>

<p>You can look up <code>errno</code> values in <code>/usr/include/sys/errno.h</code> if you're curious as to what values map to what errors.</p>

<p>If you want this function to block you may need to set the <code>MSG_WAITALL</code> flag which ""requests that the operation block until the full request is satisfied"".</p>

<p>Normally in low-level UNIX socket code you'd do a <code>select</code> on that socket to wait for a read signal, then call <code>recvfrom</code> to receive the data if and only if that signal triggered. You can also do a non-blocking receive and on an <code>EAGAIN</code> just wait a short period of time before trying again, though that is less efficient.</p>
",4
48246568,48246558,0,"<blockquote>
  <p>So, 3-5 = -2</p>
</blockquote>

<p>Thats for signed ints, for size_t which <code>strlen()</code> returns and is unsigned, that's a pretty big number. </p>
",0
48246711,48246558,0,"<p>Your problem is with subtracting greater unsigned value from the smaller one.</p>

<pre><code> `(unsigned) 3 - (unsigned) 5` =  (unsigned) 4294967294 which is &gt; 0.
</code></pre>

<p>Use proper types for your calculations and proper logic. Remember that <code>strlen</code> returns value of type <code>size_t</code>.
No need to repeat <code>strlen</code> operation for the same string.</p>

<p>The improved version of your program could look like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void printlength(char *s, char *t){

    size_t len; 

    size_t sLen = strlen(s);
    size_t tLen = strlen(t);        

    if(sLen &gt; tLen)
        len = sLen - tLen;
    else
        len = tLen - sLen;       

    printf(""len = %u\n\n"",len);

    printf(""NOTE: (unsigned) 3 - (unsigned) 5 =  %u"", -2);
}

int main()
{
    char *x =""abc"";
    char *y =""defgh"";

    printlength(x,y);

    return 0;
}
</code></pre>

<p>OUTPUT:</p>

<pre><code>len = 2

NOTE: (unsigned) 3 - (unsigned) 5 =  4294967294
</code></pre>
",0
51254044,51253957,3,"<p>The <code>switch</code> statement doesn't have numbered clauses like ""clause #1"" and ""clause #2"" but instead it tests <code>year</code> against the literal values <code>1</code> and <code>2</code>. What you mean is probably:</p>

<pre><code>int is_leap_year(year) {
  return year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0);
}
</code></pre>

<p>Then you can use that function in your main body of code:</p>

<pre><code>if (is_leap_year(year)) {
  printf(""Is leap year\n"");
}
else {
  printf(""Is not leap year\n"");
}
</code></pre>

<p>By putting it into a function you can quickly test against a number of cases. You want to be sure that 1900 is <em>not</em> a leap year, that 2000 and 2004 are, and that 2100 is not.</p>
",2
51254046,51253957,1,"<p>Right now, your code is checking for the user having entered 1 or 2 as the year. For any other year (e.g., 2018) it's going to jump directly to the <code>default</code> label.</p>

<p>I'd guess (but I'll admit I'm uncertain) that you wanted something more like:</p>

<pre><code>switch ( year % 4 ) { 
    case 0:
        if (year % 100 == 0 &amp;&amp; year % 400 != 0) {
            printf(""Not a leap year"");
            break;
        }
    default:
        printf(""leap year"");
}
</code></pre>

<p>We're not getting a whole lot out of using a <code>switch</code> though--it could just as well be an <code>if</code>.  </p>
",1
50695715,50695635,2,"<p>I believe your confusion is because C allows you to leave the braces off an <code>if</code> statement, but only the immediately following statement counts as inside the <code>if</code> block.</p>

<pre><code>if (!i)
    i++;
    i++;
</code></pre>

<p>That is the same as this.</p>

<pre><code>if (!i) {
    i++;
}
i++;
</code></pre>

<p>This can be very confusing if you come from Ruby or Python where indentation is syntax.</p>

<p>While leaving the braces off can be convenient, it's also a great way to introduce bugs. Never use this feature.</p>
",0
53347382,53347314,0,"<p>I'm surprised that compiles, just looking at it. The dynamic array dims are an extension, which you should probably avoid -- just do <code>char read[1024]</code> or something. (Really you should use a <code>#define</code> for that.) But in any case, <code>token2</code> is not even defined on the first line, so I don't see how the dynamic array dim can be evaluated.</p>

<p>Once you get over that, use a debugger. Step through line by line examining variables until you see where it's gone wrong.</p>
",4
53347395,53347314,0,"<p>Don't return when <code>r == 0</code>. Wait until you reach <code>count</code> and return only then.</p>
",0
53621786,53621722,2,"<p>When you apply the <code>sizeof</code> operator to an array, it gives you the size of the <em>whole array in bytes</em>, not the size of one element.  Because you're multiplying this value by the number of array elements, you're writing far past the end of the array.  This invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>You can properly clear each array as follows:</p>

<pre><code>out_t *out[c-1];
memset(out, 0, sizeof(out));

int Ilosc[c-1];
memset(Ilosc, 0, sizeof(Ilosc));
</code></pre>

<p>Or better still:</p>

<pre><code>out_t *out[c-1] = { NULL };
int Ilosc[c-1] = { 0 };
</code></pre>

<p>This will initialize all array elements to NULL or 0 without having to call <code>memset</code>.</p>
",3
54390067,54389443,2,"<p>I think in this case, the static analyzer is wrong. I tried it with clang 9.0 and got a different set of results, but they also look wrong. If you follow the list of steps, you'll see there's something missing:</p>

<blockquote>
  <p>/Users/realdarrin/Development/CodeReviewTester/CodeReviewTester/main.c:202:13: warning: 1st function call argument is an uninitialized value</p>

<pre><code>       putchar(tab[i][p]);
        ^~~~~~~~~~~~~~~~~~
</code></pre>
  
  <p>1 warning generated.</p>
</blockquote>

<p>If you follow the steps, it gives this:</p>

<pre><code>main.c:213:20: Entering loop body
main.c:217:12: Assuming 'x' is equal to 1
main.c:217:22: Assuming the condition is false
main.c:217:35: Assuming the condition is false
main.c:222:12: Assuming the condition is false
main.c:213:5: Looping back to the head of the loop
main.c:213:20: Entering loop body
main.c:217:12: Assuming 'x' is equal to 1
main.c:217:22: Assuming the condition is false
main.c:217:35: Assuming the condition is false
main.c:222:12: Assuming the condition is false
main.c:213:5: Looping back to the head of the loop
main.c:213:20: Entering loop body
main.c:217:12: Assuming 'x' is equal to 1
main.c:217:22: Assuming the condition is false
main.c:217:35: Assuming the condition is false
main.c:222:12: Assuming the condition is false
main.c:213:5: Looping back to the head of the loop
main.c:213:20: Entering loop body
main.c:217:12: Assuming 'x' is equal to 1
main.c:217:22: Assuming the condition is false
main.c:217:35: Assuming the condition is false
main.c:222:12: Assuming the condition is true
main.c:226:20: Entering loop body
main.c:228:9: Calling 'rysuj_glowny'
main.c:187:1: Entered call from 'main'
main.c:192:8: Assuming 'size' is &gt; 0
main.c:196:5: Calling 'rysowando'
main.c:20:1: Entered call from 'rysuj_glowny'
main.c:23:8: Assuming 'n' is not equal to 1
main.c:36:5: Calling 'rysowando'
main.c:20:1: Entered call from 'rysowando'
main.c:23:8: Assuming 'n' is not equal to 1
main.c:36:5: Calling 'rysowando'
main.c:20:1: Entered call from 'rysowando'
*main.c:23:8: Assuming 'n' is not equal to 1
main.c:45:8: Assuming 'startn' is &lt;= 0
main.c:116:8: Assuming 'startn' is &gt;= 0
main.c:36:5: Returning from 'rysowando'
main.c:36:5: Returning from 'rysowando'
main.c:196:5: Returning from 'rysowando'
main.c:198:20: Entering loop body
main.c:200:24: Entering loop body
main.c:200:9: Looping back to the head of the loop
main.c:200:24: Assuming 'p' is &gt;= 'size'
main.c:198:5: Looping back to the head of the loop
main.c:206:1: Storing uninitialized value
main.c:228:9: Returning from 'rysuj_glowny'
main.c:226:5: Looping back to the head of the loop
main.c:226:20: Entering loop body
main.c:228:9: Calling 'rysuj_glowny'
main.c:187:1: Entered call from 'main'
main.c:192:8: Assuming 'size' is &gt; 0
main.c:196:5: Calling 'rysowando'
main.c:20:1: Entered call from 'rysuj_glowny'
main.c:23:8: Assuming 'n' is not equal to 1
main.c:36:5: Calling 'rysowando'
main.c:20:1: Entered call from 'rysowando'
main.c:23:8: Assuming 'n' is not equal to 1
main.c:36:5: Calling 'rysowando'
main.c:20:1: Entered call from 'rysowando'
main.c:23:8: Assuming 'n' is equal to 1
main.c:26:29: Loop body executed 0 times
main.c:36:5: Returning from 'rysowando'
main.c:45:8: Assuming 'startn' is &lt;= 0
main.c:116:8: Assuming 'startn' is &gt;= 0
main.c:36:5: Returning from 'rysowando'
main.c:196:5: Returning from 'rysowando'
main.c:198:20: Entering loop body
main.c:200:24: Entering loop body
main.c:202:13: 1st function call argument is an uninitialized value
</code></pre>

<p>I've marked one line with an asterisk. To me, it looks like it's missing that <code>rysowando</code> is recursive that time. It says that it assumes <code>n</code> is not 1, but then doesn't show the recursion. It immediately goes on to the next line. </p>

<p>There are other problems with the analysis, such as when <code>n</code> does finally equal 1, the loop inside the <code>if (n == 1)</code> section executes 0 times,  even though <code>offset2</code> is always equal to <code>offset + 1</code>. So something is definitely off with the static analyzer here.</p>
",0
54719371,54719346,2,"<p><code>str2</code> is pointing to a <strong>string literal</strong>.  These are is read only, and in fact are typically placed in a read-only section of memory.   That's why you get a bus error when you try to modify it.</p>

<p>If you define <code>str2</code> as an array you'll be able to modify it.</p>

<pre><code>char str2[] = ""testing"";
</code></pre>

<p>Here, we have an array which is <em>initialized</em> with a string literal.  It is not a string literal itself.</p>
",0
48172918,48172290,4,"<p>Your code is incorrect because you cannot declare a function with <code>extern</code> (which is default) and afterwards provide a <code>static</code> definition. The fact that it compiles at all does not indicate anything useful.</p>

<p>From n1548 ¡ì6.2.2:</p>

<blockquote>
  <p>If, within a translation unit, the same identifier appears with both internal and external linkage, the behavior is undefined.</p>
</blockquote>

<p>So, you get something like this in <code>file1.c</code>:</p>

<pre><code>// Has external linkage (which is the default!)
extern inline void fun1(void);

// This would also have external linkage.
inline void fun1(void);

// This has static linkage.
static inline void fun1(void) {
    ...
}
</code></pre>

<p>(Note: ""external linkage"" is the default but <code>extern inline</code> actually means something special, it's different from <code>inline</code>.)</p>

<p>Bam! Undefined behavior. The compiler may not even give you an error message, although some compilers appear to give error messages for this.</p>

<pre>
error: static declaration of 'func' follows non-static declaration
</pre>

<p>This error actually has <em>nothing</em> to do with the fact that the function is <code>inline</code>. It is an error with or without <code>inline</code>.</p>

<h2>What about those questions?</h2>

<blockquote>
  <p>static inline functions are visible only to translation unit where it is defined.</p>
</blockquote>

<p>This is true of all <code>static</code> functions. They have ""internal linkage"" so you can have <code>static void func(void);</code> in one file and a completely different <code>static int func(char *p);</code> in a different file. The <code>inline</code> makes no difference here.</p>

<blockquote>
  <p>extern inline functions can be access in more than one translation units.</p>
</blockquote>

<p>Yes, which is why you shouldn't put them in header files. If you put them in header files, you will get multiple different definitions of the same function, which can all be accessed from different translation units. This is an error. Instead, put the <code>extern inline</code> in source files, but it only needs to be a declaration, not a definition.</p>

<blockquote>
  <p>Better to define inline functions in header files</p>
</blockquote>

<p>There is no real point to defining an inline function anywhere else. If your function is only used in one file just mark it <code>static</code> and the compiler will decide how to call the function.</p>

<blockquote>
  <p>There is no difference between static and static inline function definitions.</p>
</blockquote>

<p>Yes, there is no difference.</p>

<p>Well, technically, no, there is a difference because the compiler is allowed to treat <code>static inline</code> functions differently from just <code>static</code> functions. However, modern compilers tend to decide to inline functions using their own set of rules, and whether a function is <code>inline</code> doesn't affect that process very much.</p>

<p>Well, practically there is one other difference. A <code>static inline</code> function definition won't generate a warning in GCC if it's not used, but a <code>static</code> function will. This is so you can put a <code>static inline</code> function in a header file. This is an alternative to putting <code>inline</code> in the header file, which requires you to have an <code>extern inline</code> for that function somewhere in your program. However, if the compiler decides that it would rather not inline your <code>static inline</code> function, either because it think's that inlining is worse or because inlining is impossible, then it will have to make a separate copy of that function in each file it's used in.</p>

<h2>So, how do you do it correctly?</h2>

<p>Never declare a function <code>static</code> if it has a previous, non-static declaration. This is an error, even if it compiles.</p>

<p>Don't declare an <code>inline extern</code> function in a header file. This creates an ""external definition"" for the function, and you can only have one of those in your entire program.</p>

<p>Don't declare <code>inline</code> functions in header files without defining them. There is no point.</p>

<p>Here is how you would want to do this:</p>

<p>In <code>mylib.h</code>:</p>

<pre><code>// Provide ""inline definition"" of the function.
inline int times_two(int x) {
    return x * 2;
}
</code></pre>

<p>In <code>mylib.c</code>:</p>

<pre><code>#include ""mylib.h""

// Provide ""external definition"" of the function.
extern inline int times_two(int x);
</code></pre>

<p>This is the standard way to do things since C99. The compiler should be free to use the internal definition or the external definition, whichever one it thinks is better. If you don't have an external definition or you have more than one, you may get a linking error, just like with regular functions.</p>

<p>C++ has its own completely different rules for inline functions.</p>
",2
48921043,48917575,0,"<p>Rather than <code>long parentNodeID</code>, use a pointer to the parent node:</p>

<pre><code>typedef struct node
{
    struct node *parent;
    struct node *next;
    struct node *child;
    char        *name;
    long         id;
} node;
</code></pre>

<p>The root level nodes (<code>File</code>, for example) have <code>NULL</code> parents.</p>

<p>This lets you use a simple recursive function to print the IDs. The only trick is that you need to recurse before printing:</p>

<pre><code>void print_path(FILE *out, node *to)
{
    if (to-&gt;parent) {
        /* Non-root nodes */
        print_path(out, to-&gt;parent);
        fprintf(out, "".%ld"", to-&gt;id);
    } else
        /* Root nodes */
        fprintf(out, ""%ld"", to-&gt;id);
}
</code></pre>

<p>With this, printing the menu recursively is easy:</p>

<pre><code>void print_menu(FILE *out, node *menu, int indent)
{
    while (menu != NULL) {

        /* Print indent first */
        fprintf(out, ""%*s"", indent, """");

        /* Current menu entry */
        print_path(out, menu);
        fprintf(out, "" %s\n"", menu-&gt;name);

        /* Submenu? */
        if (menu-&gt;child)
            print_menu(out, menu-&gt;child, 3 + indent);

        menu = menu-&gt;next;
    }
}
</code></pre>

<p>If you have say <code>node *all;</code> that contains your menu tree, and you wanted to print it to standard output, just call <code>print_menu(stdout, all, 0);</code>.</p>

<p>Note that I like to explicitly specify the file handle used for output, rather than just assume it is always <code>stdout</code>. (<code>fprintf(stdout, ..FOOBAR..)</code> is equivalent to <code>printf(..FOOBAR..)</code>.) This approach lets me use the exact same functions when printing to a file, you see.</p>

<p>Printing the indent via <code>%*s</code> is not magic. The <code>*</code> in the width field for the <code>s</code> conversion just means that <code>printf()</code> will take the width from an <code>int</code> parameter, before the actual string to be printed. Thus, <code>printf(""%*s"", n, """")</code> will print <code>n</code> spaces. It is often called a ""trick"", but really, it is just well-documented <a href=""http://man7.org/linux/man-pages/man3/printf.3.html"" rel=""nofollow noreferrer""><code>printf()</code></a> behaviour.</p>
",0
49466467,49466435,3,"<p><code>printf</code> <code>%s</code> takes a string. You're passing it <code>arr</code>, which is not a string. A string needs a <code>'\0'</code> terminator to mark the end.</p>
",0
50778700,50778128,3,"<p>The <code>a</code> and <code>b</code> objects you show have static storage duration, meaning they exist during the entire execution of the program. The 2011 version of the C standard (draft N1570), clause 6.7.9, paragraph 4, says ¡°All the expressions in an initializer for an object that has static or thread storage duration shall be constant expressions or string literals.¡±</p>

<p>C does not have any provisions for calculating the initial values of static objects. Their values need to be determined at compile time or be <em>relocatable addresses</em> that can be calculated by the linker or loader. Relocatable address are calculated as simple expressions  that are functions of where the portions of a program are loaded in memory.</p>

<p>Objects declared inside functions (technically, inside blocks, which are inside function definitions) without <code>extern</code> or <code>static</code> have automatic storage duration. The C standard allows these to be be initialized with expressions that are computed at run time. It is relatively easy for compilers to implement this, because they simply put code to calculate the values at the start of the function.</p>

<p>Theoretically, the C standard could allow you to initialize static objects with values calculated at run-time, and implementations could implement this by including code that executes before <code>main</code>. Other programming languages have such features. However, it introduces complications. For example, if you write <code>extern int b; int a = 3*b;</code> in one source file and <code>extern int a; int b = a+4;</code> in another, which one should get executed first? How do you write language rules to prohibit this? There may be solutions to this and other problems, but C began when language development was still young, and it avoids complications like this.</p>
",1
54503219,54503134,4,"<p>the ""-"" sign negative the value of the short parameter in a <a href=""https://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow noreferrer"">two's complement</a> way. (in short, turn all 0 to 1, 1 to 0 and then add 1)</p>

<p>so 0xA55A in binary is 1010 0101 0101 1010<br>
then -(0xA55A) in binary is 0101 1010 1010 0110<br>
run <code>&amp;</code> between them will give you 0000 0000 0000 0010</p>
",0
54503484,54503134,0,"<p>Basically, what COMP does is AND the two operands of which one is in its original form and one of which is a negation of it's form.</p>

<p>How CPUs typically handle signed numbers is using <a href=""https://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow noreferrer"">2's Complement</a>, 2's complement splits the range of a numeric data type to 2, of which (2^n-1) -1 is positive and (2^n-1) is negative.</p>

<p>The MSB (right-most bit) represents the sign of the numeric data</p>

<p>e.g.</p>

<pre><code>0111 -&gt; +7
0110 -&gt; +6
0000 -&gt; +0
1111 -&gt; -1
1110 -&gt; -2
1100 -&gt; -6
</code></pre>

<p>So what COMP does by doing an AND on positive and negative version of the numeric data is to get the LSB (Left-most bit) of the first 1.</p>

<p>I wrote some sample code that can help you understand here:
<a href=""http://coliru.stacked-crooked.com/a/935c3452b31ba76c"" rel=""nofollow noreferrer"">http://coliru.stacked-crooked.com/a/935c3452b31ba76c</a></p>
",0
54503433,54503134,0,"<p><code>-(x)</code> negates <code>x</code>. Negation in two's complement is the same as <code>~x+1</code> (bitflip+1)
as the code below shows:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
int prbits(uintmax_t X, int N /*how many bits to print (from the low end)*/)
{
    int n=0;
    uintmax_t shift=(uintmax_t)1&lt;&lt;(N-1);
    for(;shift;n++,shift&gt;&gt;=1) putchar( (X&amp;shift)?'1':'0');
    return n;
}
int main()
{
    prbits(0xA55A,16),puts("""");
    //1010010101011010

    prbits(~0xA55A,16),puts("""");
    //0101101010100101

    prbits(~0xA55A+1,16),puts("""");
    //0101101010100110
    prbits(-0xA55A,16),puts("""");
    //0101101010100110 (same)

}
</code></pre>

<p>When you bitand a value with its bitfliped value, you get 0. When you bitand a value with its bitfliped value + 1 (=its negated value) you get the first nonzero bit from the right.</p>

<p>Why? If the rightmost bit of <code>~x</code> is 1, adding 1 to it will yield <code>0</code> with <code>carry=1</code>.  You repeat this while the rightmost bits are 1 and, zeroing those bits.  Once you hit zero (which would be <code>1</code> in <code>x</code>, since you're adding 1 to <code>~x</code>), it gets turned into 1 with carry==0, so the addition ends.  To the right you have zeros, to the left you have bitflips. You bitand this with the original and you get the first nonzero bit from the right.</p>
",0
53133441,53133411,1,"<p>The <code>%x</code> format specifier is expecting an integer type to be printed in hex.  Passing in a floating point type for this invokes undefined behavior.</p>

<p>You can print floating point numbers in hex with the <code>%a</code> format specifier:</p>

<pre><code>printf(""\nLong double: %La"", value.ld);
</code></pre>
",2
48908464,48908303,4,"<p>One way to do it is:</p>

<pre><code>#include &lt;inttypes.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    uint64_t x = 99999;
    printf(""%"" PRIu64 ""\n"", x*x*x);
}
</code></pre>

<p>You may also be able to do this with <code>unsigned long</code> or <code>unsigned long long</code> types, but these depend on your C implementation (the compiler you are using).</p>

<p>The arithmetic you attempted overflowed the supported range of the <code>int</code> type you were using. When programming, it is important to ensure that the calculations you do will not overflow the range of the types you use.</p>

<p>Additionally, you must be careful about types in C code:</p>

<ul>
<li><p>When using <code>scanf</code>, match the conversion specifier to the type. For example, when scanning a decimal numeral for an <code>int</code> object, you should use <code>%d</code>, not <code>%ld</code>. <code>%ld</code> is for <code>long int</code>.</p></li>
<li><p>In <code>unsigned long long int total = num*num*num;</code>, the <code>unsigned long long int</code> affects the type of <code>total</code>. It does not affect the type used in the calculation <code>num*num*num</code>. In that expression, the type of <code>num</code> is used. To use <code>unsigned long long int</code> in the calculation, you would have to convert one or all of the operands to <code>unsigned long long int</code>, as by using a cast: <code>(unsigned long long int) num * num * num</code>.</p></li>
<li><p>By assigning 99999 to a <code>uint64_t</code> object, which I named <code>x</code>, I ensured that <code>x*x*x</code> was calculated with <code>uint64_t</code> arithmetic. (<code>uint64_t</code> is a 64-bit unsigned integer.) Another way to do this would be with <code>UINT64_C(99999) * UINT64_C(99999) * UINT64_C(99999)</code>. <code>UINT64_C</code> is a macro defined in <code>stdint.h</code> that essentially means ¡°treat this constant as having type <code>uint64_t</code> or wider (actually <code>uint_least64_t</code>).¡± This could also be done with <code>UINT64_C(99999) * 99999 * 99999</code> because C will automatically convert the narrower-type integer operands to the wider-type integer operand. It could also be done with <code>(uint64_t) 99999 * 99999 * 99999</code>.</p></li>
<li><p><code>PRIu64</code> is a macro that provides the right <code>printf</code> conversion specifier for <code>uint64_t</code>. It is defined in <code>inttypes.h</code>.</p></li>
</ul>
",2
48908960,48908303,3,"<p>Bugs:</p>

<ul>
<li><code>%ld</code> on an <code>int</code> invokes undefined behavior.</li>
<li><code>fflush(stdin)</code> invokes undefined behavior since stdin is an input stream.</li>
<li><code>num*num*num</code> is carried out on operands that have type <code>int</code>, so you get overflow if you attempt <code>99999 * 99999 * 99999</code> since this is a larger number than 2<sup>31</sup>-1 (assuming 32 bit <code>int</code>). </li>
</ul>

<p>Fixed code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int num;
    printf(""Insert number : "");
    scanf(""%d"",&amp;num); getchar();
    long long int total = (long long)num*num*num;
    printf(""Result : %llu"",total);
    getchar();
    return 0;
}
</code></pre>
",0
55875540,55875516,3,"<p>You are closing the file after reading the first record. Move <code>fclose()</code> out of the loop. </p>

<p>You should also check that the file was opened successfully, by checking that <code>fptr</code> is not <code>NULL</code> before looping through the file. </p>
",1
55401179,55401073,6,"<p>In C, pass by reference is emulated by passing a pointer to the desired type.  That means if you have an <code>int *</code> that you want to pass to a function that can be modified (i.e. a change to the <code>int *</code> is visible in the caller), then the function should accept an <code>int **</code>.</p>

<p>In your specific case however, this isn't what you want.  You only need to pass an <code>int *</code> to your function which it can then dereference implicitly via the <code>[]</code> operator and change the elements of the array.</p>

<pre><code>void sort(int *arr, int s, int e)
{
  int temp = 0, i, j;
  for (i=0;i&lt;e;i++)
  {
    for (j=i+1;j&lt;e;j++)
    {
        if (arr[i]&gt;arr[j])
        {
            temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
  } 
}
</code></pre>
",0
57917402,57917265,1,"<p>Based on your examples you want:</p>

<pre><code>bits = 8:
    8-1, 16-9, 24-17, 32-25
bits = 16:
    16-1, 32-17
bits = 32:
    32-1, 64-33
bits = 64:
    64-1
</code></pre>

<p>This looks like you'll need two loops. The outer loop for each group of bits and the inner loop to reverse them:</p>

<pre><code>void swap(char *str, int i, int j) {
    char tmp = str[i];
    str[i] = str[j];
    str[j] = tmp;
}

char *transform(char *str, int bits) {
    int n = strlen(str);
    for (int i = 0; i &lt; n; i += bits) {
        for (int j = 0; j &lt; bits / 2; j++) {
            swap(str, i + j, i + bits - 1 - j);
        }
    }
    return str;
}
</code></pre>
",8
49703918,49703626,2,"<blockquote>
  <p>can any one tell me if it's proper to use swap method to perform
  strcpy() function?</p>
</blockquote>

<p>No, it's not proper, because that it not was <code>strcpy()</code> does.  I think you'd better read the <a href=""http://man7.org/linux/man-pages/man3/strcpy.3.html"" rel=""nofollow noreferrer"">strcpy() man page</a> again -- there's a reason it is named <code>strcpy()</code> (which is an abbreviation of ""string copy"") and not <code>swap_char_pointers()</code>.</p>

<blockquote>
  <p>if not, how can I write this code using ponters notation only?</p>
</blockquote>

<p>The first <code>strcpy()</code> implementation that you posted uses pointer notation only, and it works fine.</p>
",0
49511803,49511597,0,"<p>The issue is your equality check: <code>if(p-&gt;student_id==search_id)</code></p>

<p>Because both <code>student_id</code> and <code>search_id</code> are <code>char</code> arrays, the types will decay to pointers (<code>char *</code>) and this will never work as you expect.  Instead, you need to use <code>strcmp</code> (or better, <code>strncmp</code>).</p>

<pre><code>if(strncmp(p-&gt;student_id, search_id, 10) == 0) { /* equality */ }
</code></pre>
",0
49511717,49511597,1,"<pre><code>if(p-&gt;student_id==search_id){
            printf(""found"");
</code></pre>

<p>Now, that's <strong>not</strong> how you compare strings in C. Use the <code>strcmp()</code> function for string comparison. You may read about <code>strcmp()</code> <a href=""http://man7.org/linux/man-pages/man3/strcmp.3p.html"" rel=""nofollow noreferrer"">here</a>.</p>
",0
50862415,50862217,0,"<p>You have several problems.</p>

<p>The warning about <code>return</code> is because you have the function declared with an incorrect return type. It should be:</p>

<pre><code>char *lel(char var[]) {
    ...
}
</code></pre>

<p>The <code>while</code> loop is wrong because you're calling a nonexistent <code>length()</code> function. The function to get the length of a string is <code>strlen()</code>. But that loop is unnecessary. <code>strlen()</code> works by searching for the first null byte in the string, so after you do <code>var[j] = '\0';</code>, the next <code>strlen()</code> will return the position of the byte you just added. So just write:</p>

<pre><code>var[j] = '\0';
</code></pre>

<p>without the loop.</p>

<p>There's no need to call <code>strcpy()</code> in <code>main()</code>. <code>lel()</code> modifies the string in place, and returns a pointer to that same string. Copying the string back to itself has no effect, and violates the constraint that the arguments to <code>strcpy()</code> must not overlap.</p>
",0
48231649,48231213,1,"<p><em>variable not assigned</em> doesn't mean that it has no value, it just means that the value is not defined (or known if your prefer). But be careful, reading a variable that has never been initialised is undefined behaviour.</p>
",0
48645702,48645167,4,"<p>The C standard only requires integer types to have a minimum size. For the type <code>long</code>, the only requirement (C11 5.2.4.2.1) is that <code>long</code> can at least fit an integer of size 2<sup>31</sup>-1. This means that <code>long</code> <em>is at least</em> 4 bytes, but that a compiler is free to make it larger, such as for example 8 bytes.</p>

<p>Similarly, <code>long long</code> is only guaranteed to fit at least the value 2<sup>63</sup>-1.</p>

<p>The format specifier <code>%ld</code> assumes a parameter of type <code>long</code>. <code>%lld</code> assumes a parameter of type <code>long long</code>. If you use the wrong format specifiers compared to the types passed, then strictly speaking your program has undefined behavior (C11 7.21.6.1/7).</p>

<hr>

<p>As for your book, it makes the following silent assumptions:</p>

<ul>
<li><code>long long</code> is 8 bytes</li>
<li><code>long</code> is 4 bytes</li>
<li>Printing a <code>long long</code> with <code>%ld</code> gives some manner of deterministic output.</li>
<li>The system is using 2's complement, little endian, no trap representations.</li>
</ul>

<p>None of these assumptions are guaranteed by the standard and the book should mention this. Your particular system most likely has <code>long</code> as 8 bytes and therefore you get the mentioned result.</p>

<hr>

<p>As for how to do professional programming, the types <code>long</code> and <code>long long</code> are mostly useless in production-quality code, for these very reasons. Professional programmes instead use the types from <code>stdint.h</code>, such as <code>int32_t</code> and <code>int64_t</code>, which are <em>guaranteed</em> to be 32 and 64 bit respectively, with 2's complement representation. This makes it possible to write portable C code.</p>
",2
52774328,52774302,1,"<p>No, 0 is substitued for <code>number</code> by the <em>preprocessor</em> before the <em>compiler</em> gets to work.</p>

<p>The compiler issues a diagnostic when it sees <code>0++;</code></p>
",0
50438067,50438021,0,"<p>Here's a major problem, especially on 64-bit systems where <code>sizeof(int) != sizeof(int *)</code>:</p>

<pre><code>int **data = (int**) malloc(x * sizeof(int));
</code></pre>

<p>You allocate <code>x</code> times the size of <code>int</code>, not the size of pointer to <code>int</code>.</p>

<p>There is a good ""trick"" to always get the correct size, use <code>sizeof *variable_youre_allocating_for</code>. In your case it would be</p>

<pre><code>int **data = malloc(x * sizeof *data);
</code></pre>

<p>This works because <code>sizeof *data</code> is done at compile-time, and the compiler knows that <code>*data</code> is of type <code>int *</code> and will use the correct size.</p>

<p>Also notice that I removed the cast, <a href=""http://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">it's not needed in C</a>.</p>

<p>Besides that, your use of the data is correct. Using <code>data[i][j]</code> is perfectly fine, if <code>i</code> and <code>j</code> are valid indexes, and <code>data</code> and <code>data[i]</code> have been properly initialized.</p>

<p>The important part is to remember that for any pointer or array <code>a</code> and index <code>i</code>, the expression <code>a[i]</code> is <em>exactly</em> equal to <code>*(a + i)</code>. In fact, the compiler will translate <code>a[i]</code> to <code>*(a + i)</code>. So for your pointer <code>data</code>, the expression <code>*(data + i)</code> is exactly equal to <code>data[i]</code>. And the latter is usually easier to read and understand, as well as less to write.</p>
",6
48392330,48392272,0,"<blockquote>
  <p><em>My question is am I using strcmp statement correctly?</em></p>
</blockquote>

<p>No your are not, <code>strcmp</code> takes only two arguments. <code>strncmp</code><sup>1</sup> however takes a third argument which is the maximal length to be compared.</p>

<pre><code>if ( strncmp( argv[i], ""Candy"", 5)==0)
    ...
</code></pre>

<p>would be correct though.</p>

<p>Also your the <code>printf</code> is kind of wrong, though.</p>

<p>You are passing an argument, but your format doesn't have the <code>%s</code> conversion specifier, so the argument <code>argv[i+1]</code> is simply ignored and not printed.</p>

<p>Be careful with <code>argv[i+1]</code>, though. If <code>i</code> is equal to <code>argc-1</code>, meaning it's the last argument, <code>argv[i+1]</code> is <code>NULL</code> and doing this</p>

<pre><code>printf(""something %s\n"", NULL);
</code></pre>

<p>is undefined behaviour.</p>

<hr>

<p><strong>Footnotes</strong></p>

<p><sup>1</sup>Quote from the man page:</p>

<blockquote>
  <p><em>man strcmp</em></p>

<pre><code>#include &lt;string.h&gt;

int strcmp(const char *s1, const char *s2);
int strncmp(const char *s1, const char *s2, size_t n);
</code></pre>
  
  <p><strong>DESCRIPTION</strong></p>
  
  <p>The <code>strcmp()</code> function compares the two strings <code>s1</code> and <code>s2</code>.
  It returns an integer less than, equal to, or greater than zero if <code>s1</code> is
  found, respectively, to be less than, to match, or be greater than <code>s2</code>.</p>
  
  <p>The <code>strncmp()</code> function is similar, <strong>except it compares only the first (at most) <code>n</code> bytes</strong> of <code>s1</code> and <code>s2</code>.</p>
</blockquote>
",0
53290201,53289791,1,"<p>Your a victim of failing to understand <a href=""https://en.cppreference.com/w/c/language/operator_precedence"" rel=""nofollow noreferrer""><em>operator precedence</em></a>. In C, <code>[]</code> has higher precedence than <code>*</code>, so this:</p>

<pre><code>*seqList[curSeqListSize] = ...
</code></pre>

<p>says ""find the <code>curSeqListSize</code>  slotted <code>char**</code> in the sequence of <code>char**</code> pointed to by <code>seqList</code>, then dereference <em>that</em>. That's wrong. You need to shove higher precedence in to your <code>seqList</code> expression, and <code>()</code> will do that:</p>

<pre><code>(*seqList)[curSeqListSize] = ...
</code></pre>

<p>says ""Get the <code>char**</code> pointed to by <code>seqList</code>, then get the <code>curSeqListSize</code> slotted <code>char*</code> from that.</p>

<p>I'd change a number of other things, but that's where your wheels fell off the wagon.</p>
",0
48604400,48604331,10,"<p>If the variable has automatic storage ¡ª a local variable ¡ª and is not explicitly initialized, its state is indefinite.  That applies regardless of whether it is a simple variable (e.g. an <code>int</code>) or complex (e.g. a structure or union).</p>

<p>The fields will not reliably be zeroed.</p>

<p><a href=""https://port70.net/~nsz/c/c11/n1570.html#6.7.9p10"" rel=""nofollow noreferrer"">C11 ¡ì6.7.9 Initialization ?10</a>:</p>

<blockquote>
  <p>If an object that has automatic storage duration is not initialized explicitly, its value is
  indeterminate.</p>
</blockquote>
",0
48615036,48614944,1,"<p>You are missing the semicolons in the structures:</p>

<p>Correct would be</p>

<pre><code>struct first_name
{
    char *word;
    int number;
};

struct last_name{
    struct first_name *hello;
    int num2;
};
</code></pre>

<p>You can access the members like any other members of the structure.</p>

<pre><code>struct first_name fn = { .word = ""Hello"", .number = 23 };

printf(""word: %s, number = %d\n"", fn.word, fn.number);


struct last_name ln = { .hello = &amp;fn, .num2 = 11 };

printf(""name: %s, number: %d, num2: %d\n"", ln.hello-&gt;word, ln.hello-&gt;number, ln.num2);
</code></pre>

<p>The output would be:</p>

<pre class=""lang-none prettyprint-override""><code>word: Hello, number = 23
name: Hello , number: 23, num2: 11
</code></pre>
",0
48623035,48622935,-1,"<p>The second is true because you are using an optimizing compiler. Since <code>str1</code> and <code>str2</code> are pointers, it makes them point to the same string, thus saving a little memory.</p>
",0
48738269,48725587,0,"<p>This isn't an answer to the question, but I want to address (pun intended) the increased memory usage of an <code>int</code> vs. a <code>char</code> variable as discussed in other comments and answers, and a bit of code formatting will help with this.</p>

<p>When you're talking about memory use, the best policy is to be prepared for surprises.</p>

<p>A local variable like the one in the question will often occupy <em>zero</em> bytes of memory regardless of its size, if it is stored in a register instead of memory. However, it may take more <em>code</em> to convert the data width, as is the case here.</p>

<p>For comparison, here is the compiled code from VS2017 in x86 release mode, first with an <code>int</code> variable:</p>

<pre><code>                     int c;
                     c = getchar();
FF 15 B0 20 40 00    call        dword ptr [__imp__getchar (04020B0h)]  
                     printf(""%d"",c);
50                   push        eax  
68 F8 20 40 00       push        offset string ""%d"" (04020F8h)  
E8 1F 00 00 00       call        printf (0401030h)  
83 C4 08             add         esp,8  
</code></pre>

<p>And with a <code>char</code>:</p>

<pre><code>                     char c;
                     c = getchar();
FF 15 B0 20 40 00    call        dword ptr [__imp__getchar (04020B0h)]  
                     printf(""%d"",c);
0F BE C0             movsx       eax,al  ;; Widen 'char' to 'int'
50                   push        eax  
68 F8 20 40 00       push        offset string ""%d"" (04020F8h)  
E8 1C 00 00 00       call        printf (0401030h)  
83 C4 08             add         esp,8  
</code></pre>

<p>The generated code is identical, except that the <code>char</code> version has an extra three-byte instruction, the <code>movsx eax, al</code> to widen the <code>char</code> to an <code>int</code> before pushing it. So instead of saving memory, the <code>char</code> used three more bytes of code.</p>

<p>Of course in a simple test like this, you don't care how much code or data memory is used - in fact you may not ever do an optimized build at all, only a debug build.</p>

<p>And things may well change in a more complex piece of code. For example, if you have an <em>array</em> of <code>char</code> vs. <code>int</code>, obviously the array will take more memory for the <code>int</code> values, assuming it isn't a very small array that ends up in registers.</p>

<p>Even for data that does end up in registers, a shorter data type may help because it lets more data get packed into the registers (e.g. by using things like the <code>bl</code> and <code>bh</code> registers for byte values), so less data spills out into actual memory.</p>

<p>But you really don't know until you look at the size of the generated code and how it uses memory.</p>

<p>In any case, this is all a moot point for the code in the question, since it just isn't correct to use a <code>char</code> or <code>unsigned char</code> as the return value for <code>getchar()</code>. But it is interesting to look at what kind of code gets generated for the different data types.</p>
",0
53679697,53679475,1,"<p>The problem is that the parameter to your function:</p>

<pre><code>int deckValue(typeCard *deck[])
</code></pre>

<p>Doesn't match how you're using it:</p>

<pre><code>sum += deck[i].value.intValue;
</code></pre>

<p>The function definition says that <code>desk</code> is an array of <strong>pointers</strong> to <code>typeCard</code>.  So when you do <code>deck[i].value</code> it thinks that you have an array of <code>typeCard</code>.   </p>

<p>You instead want:</p>

<pre><code>sum += deck[i]-&gt;value.intValue;
</code></pre>

<p>This will dereference the pointer for the array element.</p>

<p>Also in <code>main</code>, you're not passing an array of pointers to <code>typeCard</code>:</p>

<pre><code>typeCard deck[] = {card1,card2,NULL};

sum = deckValue(deck);
</code></pre>

<p>You're passing an array of <code>typeCard</code>.  Since you want an array of pointers so you can use a NULL pointer as a sentinel, you need to change the definition to an array of pointers, and initialize the array elements accordingly:</p>

<pre><code>typeCard *deck[] = {&amp;card1, &amp;card2, NULL};
</code></pre>
",4
55924578,55924497,4,"<blockquote>
  <p>1) Are there different versions of C?</p>
</blockquote>

<p>Yes, and the specific reason that the validity of this code differs across C standards is that you are using the function <code>gets</code>, which has been deprecated and later fully removed by modern C standards.  There is practically no way to use <code>gets</code> in production code without risking a buffer overflow, so it's recommended to use functions that check the length of the buffer. <code>fgets</code> is the most common with:</p>

<pre><code>fgets(buffer, BUFFER_SIZE, stdin);
</code></pre>

<blockquote>
  <p>2) Is this code still correct, or would it be better to use char * for the function parameter</p>
</blockquote>

<p>There is no difference between the function parameters: <code>char *foo</code> and <code>char foo[]</code>, since when an array is passed as an argument to a function, it decays to a pointer to its first element.  Both syntaxes are acceptable.</p>
",1
48762302,48762197,2,"<blockquote>
  <p>Can anyone please explain both the outputs?</p>
</blockquote>

<p>In C, a union is really just a value that can be interpreted in several different ways. If you put <code>float</code> data into a union and then try to read it as <code>int</code>, you'll most likely get something that doesn't make much sense because the format of <code>int</code> is very different from that of <code>float</code>. The reverse is also true: since <code>float</code> is stored in a very different format than <code>int</code>, trying to interpret <code>int</code> data as a <code>float</code> is going to give nonsense. You might get <code>nan</code>, but you might also get some value that looks valid but isn't really.</p>

<p>Here you're storing <code>int</code> data:</p>

<blockquote>
  <p>k.s=2147483640;</p>
</blockquote>

<p>And here you're trying to reinterpret that data as a <code>float</code>:</p>

<blockquote>
  <p>printf(""%f\n"",k.a);</p>
</blockquote>

<p><strong>Don't do that.</strong> If you want to convert the value you stored in <code>k</code> from <code>int</code> to <code>float</code>, convert it explicitly with a cast:</p>

<pre><code>printf(""%f\n"",(float)k.s);
</code></pre>

<p>Here's an example that might prove more intuitive:</p>

<pre><code>union {
    int num;
    char[4] string;
} u;
</code></pre>

<p>Now, if we set <code>u.num = 1234</code>, then the value in <code>u</code> is going to be the <em>number</em> 1234, or <code>0x000004D2</code> in hex. You wouldn't expect that <code>u.string</code> would give you the characters <code>'1'</code>,<code>'2'</code>,<code>'3'</code>,<code>'4'</code>, right? <code>0x000004D2</code> is the characters <code>0x00</code>, <code>0x00</code>, <code>0x04</code>, <code>0xD2</code>. Going the other way, if you store the four characters <code>'1'</code>, <code>'2'</code>, <code>'3'</code> and <code>'4'</code> in <code>u.string</code>, then the value in <code>u</code> will be <code>0x31323334</code>, which is 825373492 decimal, not 1234.</p>

<p>A union stores whatever bits you put into it, but you have to keep track of how those bits should be interpreted.</p>
",12
48800286,48800265,7,"<pre><code>for (loopControl = 0; loopControl &lt;= 6, loopControl+=2;) 
</code></pre>

<p>so you are using the comma here it is just a typo,
coma evaluates both then returns the second, so loopControl+=2 is basically always true, you mean:</p>

<pre><code>for (loopControl = 0; loopControl &lt;= 6; loopControl+=2) 
</code></pre>
",6
48821569,48821342,3,"<pre><code>scanf(""%d"",&amp;a);
</code></pre>

<p>needs to be</p>

<pre><code>scanf(""%f"",&amp;a);
</code></pre>

<p><code>%d</code> is meant for reading <code>int</code>s while <code>%f</code> is meant for reading <code>float</code>s. </p>

<p>If you increase the warning level on your compiler you might be able to detect that as a problem at compile time. For example, using <code>gcc -Wall</code>, I get the following output:</p>

<pre class=""lang-none prettyprint-override""><code>soc.c:5:1: warning: return type defaults to ¡®int¡¯ [-Wimplicit-int]
 main()
 ^
soc.c: In function ¡®main¡¯:
soc.c:9:11: warning: format ¡®%d¡¯ expects argument of type ¡®int *¡¯, but argument 2 has type ¡®float *¡¯ [-Wformat=]
     scanf(""%d"",&amp;a);
           ^
soc.c:11:12: warning: format ¡®%d¡¯ expects argument of type ¡®int¡¯, but argument 2 has type ¡®double¡¯ [-Wformat=]
     printf(""the square is=%d"",b);
</code></pre>
",0
48957349,48957248,1,"<p>You need to alter your prototype for your <code>main</code> function and then parse the arguments provided:</p>

<pre><code>#include &lt;wiringPi.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;

#define MAX_TIMINGS 85
int data[5] = { 0, 0, 0, 0, 0 };

void read_dht_data(long dhtPin)
{
    uint8_t laststate    = HIGH;
    uint8_t counter        = 0;
    uint8_t j            = 0, i;

    data[0] = data[1] = data[2] = data[3] = data[4] = 0;

    /* pull pin down for 18 milliseconds */
    pinMode( dhtPin, OUTPUT );
    digitalWrite( dhtPin, LOW );
    delay( 18 );

    /* prepare to read the pin */
    pinMode( dhtPin, INPUT );

    /* detect change and read data */
    for ( i = 0; i &lt; MAX_TIMINGS; i++ )
    {
        counter = 0;
        while ( digitalRead( dhtPin ) == laststate )
        {
            counter++;
            delayMicroseconds( 1 );
            if ( counter == 255 )
            {
                break;
            }
        }
        laststate = digitalRead( dhtPin );

        if ( counter == 255 )
            break;

        /* ignore first 3 transitions */
        if ( (i &gt;= 4) &amp;&amp; (i % 2 == 0) )
        {
            /* shove each bit into the storage bytes */
            data[j / 8] &lt;&lt;= 1;
            if ( counter &gt; 16 )
                data[j / 8] |= 1;
            j++;
        }
    }
}

int main(int argc, char * argv[])
{
  if (argc != 2)
  {
    printf(""You must specify the DHT pin\n"");
    return 1;
  }

  char *end;
  long dhtPin = strtol(argv[1], &amp;end, 10);
  if (end == argv[1])
  {
    printf(""Invalid number\n"");
    return 1;
  }

  if ( wiringPiSetup() == -1 )
    return 1;

  read_dht_data(dhtPin);
  return 0;
}
</code></pre>

<p>If you need more complex argument parsing see the <a href=""https://linux.die.net/man/3/getopt"" rel=""nofollow noreferrer""><code>getopt</code></a> function.</p>
",1
48974729,48974694,1,"<p>The <code>if</code> condition tests</p>

<pre><code>is coldest &gt;= 80
AND
is coldest &gt;= 0
</code></pre>

<p>Can you spot the error now?</p>

<p>In addition, not testing the return value from <code>scanf</code> is <strong>always a bug</strong>.</p>
",2
59149108,59149038,2,"<p>You can use <code>sprintf()</code>:</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdio.h&gt;

int main (int argc, char** argv)
{
   if (argc &gt; 1)
   {
      char arr[20];
      sprintf(arr, ""%%55u%%%.12s$n"", argv[1]);
      ...
   }
   return 0;
}
</code></pre>

<p>Alternatively, use <code>strcpy()</code> and <code>strcat()</code> (use with care!):</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;string.h&gt;

int main (int argc, char** argv)
{
   if (argc &gt; 1)
   {
      char arr[20];
      strcpy(arr, ""%55u%"");
      strcat(arr, argv[1]);
      // or: strcat_s(arr, sizeof(arr)-3, argv[1]);
      strcat(arr, ""$n"");
      ...
   }
   return 0;
}
</code></pre>
",0
49497551,49497461,7,"<p>The format specifier for a character is <code>%c</code>.
You can get the first character from <code>str</code> by just dereferencing it: <code>str[0]</code></p>

<p>So in summary you can just do this:</p>

<pre><code>void first(char *str)
{
    printf(""Its first character is %c\n"", str[0]);
}
</code></pre>

<blockquote>
  <p>Why is it removing the first letter and printing the rest instead of the other way around?</p>
</blockquote>

<p><code>str[1]</code> gives you the second character in <code>str</code>. In your code you defined <code>initial</code> as a pointer set to the address of that second character. You then treated <code>initial</code> as a string (by printing it with the <code>%s</code> specifier) so you got the second character and everything after it, up to the <code>\0</code> character at the end of the string.</p>
",3
49069748,49069237,0,"<p>You probably want this. All comments are mine. The code is still extremely poor (for example there is no error checking at all, <code>fopen</code> can fail, unnecessary usage of global variables, fixed size <code>static PERSON p2</code> in <code>FileToArray</code> instead of dynamic memory allocation etc., etc.)</p>

<pre><code>#include &lt;stdio.h&gt;

typedef struct PersonRecords {
  char name[20];
  int age;
  char school[15];
}PERSON;

PERSON p1;

void UpdateRecords();
PERSON* FileToArray(int *nbofentries);

int main() {
  UpdateRecords();

  PERSON* p3;
  int nbofentries;
  p3 = FileToArray(&amp;nbofentries);  // nbofentries will contain the number of entries read

  for (int i = 0; i &lt; nbofentries; i++) {
    printf(""%s\t%i\t%s\n\n"", p3-&gt;name, p3-&gt;age, p3-&gt;school);  // instead of (*x).y write x-&gt;y
    p3 += 1;
  }
}


void UpdateRecords() {
  printf(""Enter  person name: \n"");
  fgets(p1.name, sizeof(p1.name), stdin);
  printf(""Enter person age: \n"");
  scanf(""%d"", &amp;p1.age);
  fgetc(stdin);                   // you need to add this (scanf is quite a special function)
  printf(""Enter person school: \n"");
  fgets(p1.school, sizeof(p1.school), stdin);

  FILE* ptr;
  ptr = fopen(""PersonRecords.dat"", ""ab"");
  fwrite(&amp;p1, 1, sizeof(p1), ptr);      // actually writes something to the file
  fclose(ptr);
}

PERSON* FileToArray(int *nbofentries) {
  FILE* pt;
  int i = 0;
  pt = fopen(""PersonRecords.dat"", ""rb"");
  static PERSON p2[250];
  while (fread(&amp;p2[i], sizeof(PERSON), 1, pt) != 0) {
    i++;
  }
  fclose(pt);

  *nbofentries = i;   // return the number of entries read to the caller
  return p2;
}
</code></pre>
",0
54414273,54413976,1,"<p><code>strncat()</code> works on a memory buffer containing a <code>NUL</code>-terminated (aka ""C"") string:</p>

<pre><code>char buf[10] = {'a', 'b', 'c', '\0'};
strncat(buf, ""def"", sizeof(buf) - strlen(buf) - 1);
assert(strcmp(buf, ""abcdef"") == 0);  // buf now equals to ""abcdef""
</code></pre>

<ul>
<li><a href=""https://ideone.com/fWXk8C"" rel=""nofollow noreferrer"">https://ideone.com/fWXk8C</a></li>
</ul>

<p>(Well, the use of <code>strlen()</code> kinda killed the benefit of <code>strncat()</code> over good ol' <code>strcat()</code> but that's another story...)</p>

<p>So it's very different from what you want to do in your exercise. You actually don't need either of <code>strncat()</code> or <code>strncpy()</code>.</p>
",0
53030615,53030381,0,"<p>Your main function should always be either <code>int main(void)</code> or <code>int main(int argc, char *argv[])</code>, depending on whether you are interested in command-line arguments or not. Always <code>#include &lt;stdlib&gt;</code>, so you can return from your main function using <code>return EXIT_SUCCESS;</code> or <code>return EXIT_FAILURE;</code>, or exit the program anywhere using <code>exit(EXIT_SUCCESS);</code> or <code>exit(EXIT_FAILURE);</code>.</p>

<p>The recommended simplest ""Hello, world!"" program is</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    printf(""Hello, world!\n"");
    return EXIT_SUCCESS;
}
</code></pre>

<p>Use it as the basis of your own programs.</p>

<blockquote>
  <ol>
  <li>Handle errors</li>
  </ol>
</blockquote>

<p>The <a href=""http://man7.org/linux/man-pages/man3/scanf.3.html"" rel=""nofollow noreferrer""><code>scanf()</code></a> family of functions returns the number of successful conversions. So, you really should have something like</p>

<pre><code>    if (scanf(""%d"", &amp;x) &lt; 1) {
        printf(""That's not a number. Goodbye, you sneaky human.\n"");
        return EXIT_FAILURE;
    }
</code></pre>

<p>to check if the input was an integer or not.</p>

<p>Hint: Try</p>

<pre><code>    printf(""Please input a positive integer:\n"");
    while ( (scanf(""%d"", &amp;x) &lt; 1) || (x &lt; 1) ) {
        printf(""No, a positive integer, please.\n"");
    }
</code></pre>

<p>and see how it behaves.  The <code>||</code> is a logical OR operator in C. It is short-circuiting, meaning that the left side is evaluated first, and if it is true, the right side won't be examined at all.</p>

<blockquote>
  <ol start=""2"">
  <li>Do a simple print task</li>
  </ol>
</blockquote>

<p>Learn to doodle the logic on paper first. You'll soon learn how to do it in your head, although doodling is useful for many, due to how the hand-eye coordination affects the thought model involved. Some use the Rubber Duck method instead, i.e. talk it aloud, as if describing it to some other person (but talk to eg. a rubber duck instead); putting the thoughts into words and linear speech helps organize your thoughts as well.</p>

<p><a href=""https://en.wikipedia.org/wiki/Pseudocode"" rel=""nofollow noreferrer"">Pseudocode</a> is often a useful method of doodling it out. In this case, we could describe the input part as</p>

<pre><code>Let  n  be some integer
Prompt user to input a positive integer
Scan n from input
While scan failed, or n is less than 1:
    Prompt user to input a positive integer
End While
</code></pre>

<p>The print-out part we could write as</p>

<pre><code>Let  sum  be some double-precision floating-point number
Let  i  be some integer

Let  sum = 1.0
Print ""1/1""
For i from 2 to n, inclusive:
    Print "" + 1 / %d"", i
    Let  sum = sum + 1.0 / i
End For

Print "" = %.3f\n"", sum
</code></pre>

<p>When adding each fraction to the sum, we use <code>1.0 / i</code>, because we want to evaluate it as a floating-point division. (We could use <code>1/(double)i</code>, or <code>1.0 / (double)i</code>, instead; but as long as one (either dividend or divisor) is a floating-point number, then the compiler will do a floating-point division.)  If we only use <code>1/i</code>, the compiler does <em>integer division</em>, which yields 0 for all <code>i</code> greater than one. That's not what we want.</p>

<p>When printing out the result, <code>%f</code> is the pattern to use with a floating-point number. The <code>%.3f</code> form tells the C library to use three decimals after the decimal point, so for example <code>printf(""%.3f\n"", 1.0)</code> prints <code>1.000</code>. The <code>\n</code>, as you well know by now, is a newline: any following output will go to a new line.</p>

<p>You've got ample help now to complete the assignment. Don't be a nasty human and try and <kbd>copy</kbd>+<kbd>paste</kbd> the answer from somewhere; take the effort to learn this stuff, and you'll find you have a powerful set of tools at your fingertips to solve many different types of problems, and have fun while at it. Good luck!</p>
",0
50957802,50957470,1,"<p><code>const</code> only applies to the portion of the declaration it is modifying.</p>

<p>So:</p>

<pre><code>int d;
int * const q = &amp;d;
*q = 3;             /* OK, *q is not const */
q = NULL;           /* ERROR, q is const */
const int * p;
p = &amp;d;             /* OK, p is not const */
*p = 3;             /* ERROR, *p is const */
</code></pre>

<p><code>const</code>ness does not traverse beyond the immediate object to which it is applied.
For your example, a <code>const tContainerStruct</code> would mean that each member of <code>tContainerStruct</code> would be <code>const</code>. Suppose we defined:</p>

<pre><code>typedef struct {
    tInnerStruct * const struct1;
    tInnerStruct * const struct2;
    tInnerStruct * const struct3;
}constant_tContainerStruct;
</code></pre>

<p>Then <code>constant_tContainerStruct</code> would behave like your <code>const tContainerStruct</code>. But, since the <code>const</code> is applied to the pointer member, it has no affect on the <code>tInnerStruct</code> being pointed to, so those objects remain modifiable.</p>
",0
52780471,52780378,0,"<p>the <code>+1</code>, i.e. 65 instead of 64, is needed only if you want to store a C-string, i.e. if you want to pass the string to, for example, a <code>printf</code> or <code>strlen</code> or other string functions. These functions need a terminating character <code>\0</code>, such that you need one more byte than required for the actual content. If you just want to store and retrieve the bytes you may go ahead with <code>64</code>. And if it is about storing 8 bit values, I'd use <code>unsigned char</code>.</p>
",7
50382134,50381876,2,"<p><em>Only because I'm bored tonight:</em></p>
<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    char str[1024];
    int count[26] = {};
    
    fgets( str, sizeof str, stdin );
    for(int i=0; str[i]; ++i)
    {
        count[tolower(str[i])-'a'] += !!isalpha(str[i]);
    }
    
    for(int i=0; i&lt;sizeof count / sizeof *count; ++i)
    {
        printf(&quot;%c: %.*s\n&quot;, i+'a', count[i], &quot;*************************************************&quot;);
    }
    
    return 0;
}
</code></pre>
<hr>
<h1>Example run:</h1>
<p><strong>Input:</strong></p>
<blockquote>
<p>The swimmer set a new world record in the 1,500-meter freestyle race Wednesday, taking first place at the 2018 TYR Pro Swim Series in Indianapolis. She posted a time of 15:20.48, which was five seconds better than her previous record set in 2015, per Nick Zaccardi of NBC Sports.</p>
</blockquote>
<p><strong>Output:</strong></p>
<pre><code>Success #stdin #stdout 0s 4456KB
a: *************
b: **
c: **********
d: *********
e: ******************************
f: *****
g: *
h: ********
i: *****************
j: 
k: **
l: ****
m: *****
n: ************
o: ***********
p: *******
q: 
r: *******************
s: ******************
t: *****************
u: *
v: **
w: *******
x: 
y: ***
z: *
</code></pre>
<p>The output shows that the letter <code>e</code> is the most common, and letters <code>j</code>, <code>q</code>, and <code>x</code> do not appear at all in the sample text.</p>
",0
50459233,50459057,2,"<p>Looking at the <a href=""https://godbolt.org/g/fZnugV"" rel=""nofollow noreferrer"">compilation result</a> of the first program </p>

<p>It look like <code>int input</code> is using the same memory location when it is passed to your thread, instead of using a new memory location, like you would expect, causing a <a href=""https://en.wikipedia.org/wiki/Race_condition"" rel=""nofollow noreferrer"">race condition</a>.</p>

<p>One way of solving your issue would be to use an <code>array</code> of <code>input</code></p>

<pre><code>...
pthread_t span[argc];
int input[argc];
for (int i=1; i&lt; argc; i++){
     input[i] = atoi(argv[i]);
     ...
     int rc = pthread_create(&amp;span[i], NULL, thread_fn, &amp;input[i]);
     ...
</code></pre>

<p>Other way would be to allocate memory for the input</p>

<pre><code> ...
 pthread_t span[argc];
 for (int i=1; i&lt; argc; i++){
     int *input=malloc(sizeof(int));
     *input = atoi(argv[i]);
     ...
     int rc = pthread_create(&amp;span[i], NULL, thread_fn, input);
     ...
</code></pre>

<p>Of course using this solution to avoid memory leak you would leave it to the thread procedure to free the memory allocated for the <code>input</code>.</p>
",2
49283436,49283411,13,"<p>You're referencing <code>argv</code> without checking that <code>argc</code> is high enough to permit those references. What if <code>argc</code> is only <code>1</code>?</p>

<p>The real problem is using <code>%s</code> to display a single character. That needs to be <code>%c</code>. Using <code>%s</code> is going to treat that as a character <em>pointer</em>, which it isn't, and then your program is deep into <em>undefined behaviour</em>.</p>
",0
49342617,49342268,0,"<p>Move global declarations: </p>

<pre><code>float currentMilage = 0.0, pricePerGallon = 0.0, MPG = 0.0, totalCost = 0.0;
</code></pre>

<p>to <code>main</code>.</p>

<p>Change: </p>

<pre><code>void calculateTotalCost() { 

        totalCost=(currentMilage/MPG)*pricePerGallon; 
}
</code></pre>

<p>to </p>

<pre><code>float calculateTotalCost(float currentMilage, float MPG, float pricePerGallon) { 

      float totalCost = (currentMilage/MPG)*pricePerGallon; 
      return totalCost;
}
</code></pre>

<p>Modify functions which do calculations to take more parameters and return the value: </p>

<pre><code> void updateCurrentMilage(float miles) { 

       currentMilage = currentMilage + miles; 
 }
</code></pre>

<p>like:</p>

<pre><code>  float updateCurrentMilage(float miles, float currentMilage) { 

       float current = currentMilage + miles;
       return current; 
 }
</code></pre>

<p>Use the returned value to update the appropriate variable;</p>

<pre><code>    currentMilage = updateCurrentMilage(miles,currentMilage); 
</code></pre>

<p>Repeat the process for all relevant data which you want to calculate.</p>
",0
49460921,49460791,-1,"<p>You have two errors:</p>

<pre><code>else if (num == 1)
</code></pre>

<p>You are using <code>%c</code> in <code>scanf</code>, so you are reading the value as a character. So
you have to check <code>num == '1'</code>, because <code>1 != '1'</code>. See the <a href=""https://www.asciitable.com/"" rel=""nofollow noreferrer"">ASCII table</a> for more information about the numeric values of characters.</p>

<p>The second error is</p>

<pre><code>printf(""That is %i in decimal"", &amp;result);
</code></pre>

<p>Here you have to pass <code>result</code>, but you are passing <code>&amp;result</code> which is a pointer
to <code>int</code>. <code>&amp;result</code> is the address of the variable <code>result</code>. Also add a newline
to the <code>printf</code>:</p>

<pre><code>printf(""That is %i in decimal\n"", result);
</code></pre>

<p>Also there is no reason for declaring <code>result</code>, <code>power</code> and <code>num</code> as global
variables, why are you doing that? Just declare them inside the <code>main</code>
function.</p>

<p>It is also a good idea to check the return value of <code>scanf</code> to see whether it
succeed in reading and converting the value from the user, this makes the
program more robust. You should also check if the user entered something
different from <code>'1'</code> and <code>'0'</code>.</p>

<p>So the corrected code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(){
    int result = 0;
    int power2 = 8;
    char num;

    printf(""Enter FOUR 1's and/or 0's followed by a '*'.\n"");
    int ret = scanf(""%c"", &amp;num);

    if(ret != 1)
    {
        fprintf(stderr, ""Could not read from user\n"");
        return 1;
    }

    while (num != '*') {
        if (num == ' '){
            printf(""\n"");
        } else if(num == '1' || num == '0') {
            // num - '0'  would give you either 1 or 0
            result = result + (num - '0') * power2;
            power2 = power2 / 2;
        } else {
            fprintf(stderr, ""Invalid input '%c', ignoring\n"", num);
        }

        ret = scanf(""%c"", &amp;num);
        if(ret != 1)
        {
            fprintf(stderr, ""Could not read from user\n"");
            return 1;
        }
    }

    printf(""That is %i in decimal\n"", result);
    return 0;
}
</code></pre>
",1
51806411,51806340,5,"<p>Your fundamental problem is that you are passing the function pointer to <code>printf</code> rather than the function return value:</p>

<p>You have:</p>

<pre><code>get_max(array,0,2),

printf(""MAX: %d"", get_max);
</code></pre>

<p>when you need something like:</p>

<pre><code>int max = get_max(array, 0, 2 );

printf( ""MAX: %d"", max ) ;
</code></pre>

<p>Use of the comma operator rather then the semi-colon statement terminator in your <code>get_max()</code> call was presumably a typo too?</p>

<p>To explain the diagnostic:</p>

<pre><code>format specifies type 'int' but the argument has type 'int (*)(int *, int, int)'.
                        ^                               ^
                       (1)                             (2)
</code></pre>

<ul>
<li><sup>(1)</sup> The <code>%d</code> format specifier expects an int argument.</li>
<li><sup>(2)</sup> You passed an pointer to a function returning <code>int</code> and taking arguments of type <code>int *, int, int</code></li>
</ul>

<p>Even then your <code>get_max()</code> function is seriously flawed:</p>

<ul>
<li>It inspects elements from <code>0</code> to <code>b - a</code> rather then from <code>a</code> to <code>b</code>,</li>
<li>it modifies the array; if <code>a</code> is greater than zero, it is not a harmless self-assignment.  </li>
<li>if <code>a</code> is zero and <code>array[a]</code> is the largest value, <code>max</code> is unassigned.</li>
</ul>

<p>Consider:</p>

<pre><code>int get_max( const int* array, int a, int b )
{
    int max = array[a] ;

    for( int i = a + 1; i &lt; b; i++ ) 
    {
        if( array[i] &gt; max )
        {
            max = array[i] ;
        } 
    }   

    return max;
}
</code></pre>
",5
49500655,49500409,0,"<p>An alternate solution, using a bit of a different technique:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    char str[128] = ""Some Text"";
    int i = strlen(str) + 1 ;

    while( i --&gt; 1 ) {
        printf(""value =&gt; %.*s \n"", i, str );
    }

    return 0;
}
</code></pre>
",2
49500470,49500409,0,"<p>The question's code changes the string's beginning by adjusting where the string starts (<code>p++</code> in the for loop). To change the ending of the string we instead adjust where the string ends by overwriting the last character with a NUL (0) byte. We achieve this by moving an index (<code>i</code>) from the end of the string (<code>strlen(str)</code>) towards the beginning.</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    char str[128] = ""Some Text"";
    char *p;
    int i;

    for (i = strlen(str); i&gt;0; i--) {
        str[i] = 0;
        printf("" value =&gt; %s \n "",str);
    }

    return 0;
}
</code></pre>
",3
49500548,49500409,1,"<p>First thing you need to do is remove the space character after the newline character in the format string.</p>

<pre><code>    printf("" value =&gt; %s \n"",p);
</code></pre>

<p>The next thing you need to do is keep moving the terminating null character. For that, you need to store a pointer that points to the terminating null character.</p>

<p>Here's an updated version of your program:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char str[128] = ""Some Text"";
    char *p = str;
    char *end = str + strlen(str);

    // The *(--end) = '\0' is the crucial part.
    // It decrements end so it points to the previous character
    // and changes its value to the null character.
    for ( ; end &gt; p; *(--end) = '\0')
    {
       printf("" value =&gt; %s \n"",p);
    }

    return 0;
}
</code></pre>

<hr>

<blockquote>
  <p>Can you put any example with the typical ""for"" with index? </p>
</blockquote>

<p>Sure.</p>

<p>Here's one that a little bit more simplified than the first one.</p>

<pre><code>for ( ; end &gt; p; --end)
{
   *end = '\0';
   printf("" value =&gt; %s \n"",p);
}
</code></pre>

<p>Here's one that uses a ""typical"" <code>for</code> loop.</p>

<pre><code>for ( int i = 0; i &lt; len; ++i)
{
   p[len-i] = '\0';
   printf("" value =&gt; %s \n"",p);
}
</code></pre>
",1
49590144,49589373,0,"<blockquote>
  <p>How would I go about saving and reading an integer then a struct array in the same .dat file?</p>
</blockquote>

<p>I  suggest an architecture change.  Rather than </p>

<pre><code>// void write(InventoryItemType *writefile[], int count)
// InventoryItemType *read(InventoryItemType *readfile[])
</code></pre>

<p>Consider </p>

<pre><code>// return 0 on success
int iwrite(const char *fname, const InventoryItemType *inventory, size_t count)
int iread(const char *fname, InventoryItemType **inventory, size_t *count)
</code></pre>

<hr>

<p>I found OP's approach too tangled.</p>

<p>To write, open the file, write the count and data.  Recall the inventory is still allocated and eventually needs to be freed.</p>

<pre><code>int iwrite(const char *fname, const InventoryItemType *inventory, size_t count) {
  FILE *ptr = fopen(fname, ""wb"");
  if(ptr == NULL) {
    // printf(""Unable to Open File\n"");
    return 1;
  }

  if (fwrite(&amp;count, sizeof count, 1, ptr)!= 1) {
    fclose(ptr);
    // printf(""Write count failed\n"");
    return 2;
  }

  if (fwrite(inventory, sizeof *inventory, count, ptr)!= count) {
    fclose(ptr);
    // printf(""Write inventory failed\n"");
    return 3;
  }

  fclose(ptr);
  return 0;
}
</code></pre>

<p>To write, open the file, read the count, allocate memory for the inventory and then read the inventory.</p>

<pre><code>int iread(const char *fname, InventoryItemType **inventory_ptr, size_t *count_ptr) {
  FILE *ptr = fopen(fname, ""rb""); // read mode
  if(ptr == NULL) {
    // printf(""Unable to Open File\n"");
    return 1;
  }

  size_t count;
  if (fread(&amp;count, sizeof count, 1, ptr)!= 1) {
    fclose(ptr);
    // printf(""Read count failed\n"");
    return 2;
  }

  InventoryItemType *inventory = malloc(sizeof *inventory * count);
  if (inventory == NULL &amp;&amp; count &gt; 0) {
    fclose(ptr);
    // printf(""allocation failed\n"");
    return 3;
  }

  if (fread(inventory, sizeof *inventory, count, ptr)!= count) {
    fclose(ptr);
    free(inventory);
    // printf(""Read inventory failed\n"");
    return 3;
  }

  fclose(ptr);
  *inventory_ptr = inventory;
  *count_ptr = count;
  return 0;
}
</code></pre>
",3
49578443,49578288,1,"<p>The elements of <code>inventoryItems</code> aren't dynamically-allocated, so you can't free them. They're directly contained in the array. When you do:</p>

<pre><code>inventoryItems[item_count] = *add_item();
</code></pre>

<p>you're dereferencing the pointer, not storing the pointer in the array. This makes a copy of the dynamically-allocated structure, and discards its pointer (so you get a memory leak).</p>

<p>You should change the type of this array to contain pointers:</p>

<pre><code>InventoryItemType * inventoryItems[MAX_INVENTORY_SIZE];
</code></pre>

<p>Then you shouldn't dereference the pointer returned by <code>addItem</code>, you should just assign it directly:</p>

<pre><code>inventoryItems[item_count] = add_item();
</code></pre>

<p>and you free it with:</p>

<pre><code>free(inventoryItems[item_count]);
</code></pre>

<p>And in <code>displayInventory()</code> you change all <code>display[i].xxx</code> to <code>display[i]-&gt;xxx</code>.</p>
",7
49578676,49578288,1,"<p>The reason you're having trouble freeing is because you didn't actually allocate what you're trying to free.</p>

<p>In your <code>addItem</code> function, you dynamically allocate an object, populate it, and return it.  In the calling function however, you never save the pointer you got back.  You instead dereference it directly and copy the contents via assignment to an instance in the array.  This results in a memory leak.</p>

<p>Later, when you go do delete an element, you return a pointer to an array element, which was <em>not</em> dynamically allocated, so you can't free it.  Actually, you're not even returning a pointer to the element you deleted but to the first element of the array instead, so you're not even attempting to free what you expected to.</p>

<p>Rather than dynamically allocating memory in <code>addItem</code>, just pass in the address of the current array element and populate that instead.  Also, no need to return anything in <code>deleteItem</code>.</p>

<p>So <code>addItem</code> should now look like this:</p>

<pre><code>void addItem(InventoryItemType *current)
{
    system(""cls"");
    if(current == NULL)
        return NULL;
    ...
    return;
}
</code></pre>

<p>And you would call it like this:</p>

<pre><code>addItem(&amp;inventoryItems[item_count]);
</code></pre>

<p>For <code>deleteItem</code>, change the return type to <code>void</code>, then get rid of the call to <code>free</code> after calling it.</p>
",1
49623165,49622718,3,"<p>I would say you went wrong from the very first line. This is your code, heavily edited to remove the obvious bugs.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char* argv[])
{
    if( argc &lt; 3 )
    {
          printf(""Insufficient number of arguments provided. \n Usage: \""program.exe &lt;height&gt; &lt;width&gt;\"""");
          return 1;
    }
    double height = strtod(argv[1], null);

    if (errno)
    {
         printf(""height is not a valid floating point number.""); 
         return 1; 
    }

    double width = strtod(argv[2], null);

    if (errno)
    {
         printf(""width is not a valid floating point number.""); 
         return 1; 
    }

    double perimeter = (height+width)*2;
    double area = height*width;

    printf(""( Height %f + width %f )* 2 = Perimeter %f\n"", height, width,
    perimeter);
    printf(""Height %f * width %f = Area %f\n"", height, width, area);

    return 0;
}
</code></pre>

<p>A brief explanation of changes:</p>

<ol>
<li>You are not checking argc for provided number of arguments. Hence the if() I added. Program name is the first argument passed at index 0, so you need to check if at least 3 arguments are provided. I also print program usage.</li>
<li>char* are not convertible to doubles by default. Use strtod() for that.</li>
<li>perimeter calculation was incorrect since it was doing height + (width * 2) instead of (height + width) * 2.</li>
<li>Prototype for main is what I wrote, yours was completely wrong. </li>
<li>As a commenter (can't tag while editing for some reason) mentions, it is a very good idea to checking whether string to double conversion succeeded or not.</li>
</ol>
",8
49623165,49622718,3,"<p>I would say you went wrong from the very first line. This is your code, heavily edited to remove the obvious bugs.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char* argv[])
{
    if( argc &lt; 3 )
    {
          printf(""Insufficient number of arguments provided. \n Usage: \""program.exe &lt;height&gt; &lt;width&gt;\"""");
          return 1;
    }
    double height = strtod(argv[1], null);

    if (errno)
    {
         printf(""height is not a valid floating point number.""); 
         return 1; 
    }

    double width = strtod(argv[2], null);

    if (errno)
    {
         printf(""width is not a valid floating point number.""); 
         return 1; 
    }

    double perimeter = (height+width)*2;
    double area = height*width;

    printf(""( Height %f + width %f )* 2 = Perimeter %f\n"", height, width,
    perimeter);
    printf(""Height %f * width %f = Area %f\n"", height, width, area);

    return 0;
}
</code></pre>

<p>A brief explanation of changes:</p>

<ol>
<li>You are not checking argc for provided number of arguments. Hence the if() I added. Program name is the first argument passed at index 0, so you need to check if at least 3 arguments are provided. I also print program usage.</li>
<li>char* are not convertible to doubles by default. Use strtod() for that.</li>
<li>perimeter calculation was incorrect since it was doing height + (width * 2) instead of (height + width) * 2.</li>
<li>Prototype for main is what I wrote, yours was completely wrong. </li>
<li>As a commenter (can't tag while editing for some reason) mentions, it is a very good idea to checking whether string to double conversion succeeded or not.</li>
</ol>
",8
56304591,56304455,2,"<p>There are lots of possibilities. Here is one. You can use a structure that defines your interface </p>

<pre><code>typedef struct {
  void* method1(void);
  void* method2(void);
  void* method3(void);
} interface;
</code></pre>

<p>In function of your options that you pass from command line to main() you initialize this interface with different methods</p>

<pre><code>  interface *i;
  switch (option) {
  case VERBOSE: i-&gt;method1=verbose_m1; i-&gt;method2=verbose_m2; ...a.s.o.
  break;
  case DEBUG: i-&gt;method1=debug_m1; i-&gt;method2=debug_m2; ...a.s.o.
  break;
  default: i-&gt;method1=m1; i-&gt;method2=m2; i-&gt;method3=m3;
  }
</code></pre>

<p>and you write a single code in which you call <code>i-&gt;method1</code> .</p>

<p>There are more elegant methods for this, to use uml or type classes , etc.  These elegant methods will generate low level code and on your side you define in a simple language the interface, etc.  To see how such a language looks like you can look over <a href=""http://asdl.sourceforge.net/"" rel=""nofollow noreferrer"">asdl</a>, which is a very simple language in this spirit.</p>
",0
55848181,55847963,3,"<p>Among several other issues with your code - you're trying to interpret the string ""11111111111"" (11 times '1') as an integer. However, the integer type on your machine uses 4 bytes, and the highest number it can represent is 2^31 - 1. The number 11,111,111,111 is higher than 2^33. So - you get <a href=""https://stackoverflow.com/questions/46789702/what-is-signed-integer-overflow"">signed integer overflow</a> behavior.</p>

<p>Try parsing your input as a string, not as a huge number...</p>

<p>But - next time, please:</p>

<ol>
<li>Use proper indentation.</li>
<li>Use meaningful variable names (e.g. <code>number_of_conversions</code>, not <code>t</code>).</li>
<li>Use a <em>minimal</em> example. For example, we didn't need to have the external loop over <code>t</code> - you could have demonstrated your issue with just a single conversion.</li>
<li>Check the results of your library calls! <code>scanf()</code> can fail, you know.</li>
</ol>
",0
49832669,49832585,0,"<p>Here's the calls that would be made:</p>

<pre><code>fun_1(n=6)//from main
    fun_1(n=3)//since 6 &gt; 0 {
        fun_1(n=0){//now n is not greater than zero, so don't recurse
            execute if n == 0, yes it is, so output Q
            print ++x, x was A now after ++x, x would be 'B'
        }
        since n &lt;&gt; 0, don't output Q
        print ++x, x was B, so print C which is after pre-incrementing x
    }
    since n &lt;&gt; 0, don't output Q
    print ++x, x was C, so print D which is after pre-incrementing x
}
</code></pre>
",0
49832734,49832585,1,"<p>You have a recursive function, recursive means that at some point it calls
itself. The terminal case (when the function stops calling itself) is when <code>n == 0</code>.</p>

<p>When dealing with recursive functions, you have to think this way:</p>

<p><em>Recursion level 0</em> (the first call)</p>

<pre><code>n == 6 ==&gt; if(n&gt;0) fun_1(n-3); is executed
</code></pre>

<ul>
<li><p><em>Recursion level 1</em></p>

<pre><code>n == 3 ==&gt; if(n&gt;0) fun_1(n-3); is executed
</code></pre>

<ul>
<li><p><em>Recursion level 2</em></p>

<pre><code>n == 0 ==&gt;
    if(n == 0 ) printf(""Q\n"");  is executed, output is ""Q\n""

    printf(""%c "", ++x);         is executed, x is now B, output is B
</code></pre>

<p>this is terminal case, therefore</p></li>
</ul>

<p>(back to)</p>

<p><em>Recursion level 1</em></p>

<pre><code>printf(""%c "", ++x);  is executed, x is now C, output is C
</code></pre></li>
</ul>

<p>(back to)</p>

<p><em>Recursion level 0</em></p>

<pre><code>printf(""%c "", ++x);  is executed, x is now D, output is D
</code></pre>

<p>Now the recursive calls have ended and you are back in <code>main</code>. As you can see
from the analysis of the recursion levels, the generated output is</p>

<pre><code>Q
B C D
</code></pre>
",0
58009035,58007623,1,"<p>Read the C11 standard <a href=""http://www.iso-9899.info/n1570.html"" rel=""nofollow noreferrer"">n1570</a> (also <a href=""https://web.cs.dal.ca/~vlado/pl/C_Standard_2011-n1570.pdf"" rel=""nofollow noreferrer"">here</a> in PDF). Use functions from <code>&lt;time.h&gt;</code> documented in its ¡ì7.27</p>

<p>On Linux, the <a href=""http://man7.org/linux/man-pages/man7/time.7.html"" rel=""nofollow noreferrer"">time(7)</a> page is very informative too.</p>

<p>You might want to use <code>time</code>, ?<code>localtime</code>, <code>strptime</code></p>

<p>And details are much more complex than what you believe. What about <a href=""https://en.wikipedia.org/wiki/Leap_second"" rel=""nofollow noreferrer"">leap seconds</a>, for example! Or <a href=""https://en.wikipedia.org/wiki/Daylight_saving_time"" rel=""nofollow noreferrer"">daylight saving time</a>!</p>

<p>Better use timing facilities provided by your <a href=""https://en.wikipedia.org/wiki/Operating_system"" rel=""nofollow noreferrer"">operating system</a>.</p>
",0
49937543,49937493,4,"<p>That code does not work, in fact it has undefined behavior.</p>

<p>This:</p>

<pre><code>s = (char *) malloc(sizeof(char));
</code></pre>

<p>allocates 1 byte of storage, into which you then scan a string, thus very likely leading to buffer overflow. The buffer can only hold a single string, i.e. string of 0 characters before the terminator character at the end.</p>

<p>You meant:</p>

<pre><code>s = malloc(128);
</code></pre>

<p>or something like that.</p>

<p>There's no need to cast, and <code>sizeof (char)</code> is always 1 so that doesn't add anything.</p>

<p>Also, as more of a code review, magic numbers in code is generally considered a bad idea, instead write:</p>

<pre><code>if (*s &gt;= 'A' &amp;&amp; *s &lt;= 'Z')
</code></pre>

<p>or even better</p>

<pre><code>if (isupper((unsigned int) *s))
</code></pre>

<p>to not hard-code a depdency on ASCII.</p>

<p><strong>UPDATE</strong> Oh, and as pointed out in a comment, you can't <em>change</em> the value of <code>s</code> and then pass the changed value to <code>free()</code>, that is undefined behavior also. The address passed to <code>free()</code> must be the same as the one you got back from <code>malloc()</code>.</p>

<p>Use a separate variable for the iteration:</p>

<pre><code>char *p = s;
</code></pre>

<p>and only <code>free()</code> the original <code>s</code>.</p>
",4
50359922,50359894,5,"<p>If the new element becomes the head, you have to modify the head.  Just displaying the list, there is no chance the head will change.</p>
",0
54443225,54443105,1,"<pre><code>strcpy( x, (a == MACRO1)? ""S"" :
           (a == MACRO2)? ""K"" : ""error"" );
</code></pre>

<p>Like your original code, this will copy either <code>""S""</code> or <code>""K""</code> to variable <code>x</code>.</p>

<p>If <code>a</code> is <strong><em>neither</em></strong> <code>MACRO1</code> nor <code>MACRO2</code>, it will copy <code>""error""</code> to buffer <code>x</code> with an assumption that <code>x</code> is large enough to hold <code>""error""</code> string.<br>
<em>(You should figure out a better way to handle the case where <code>a</code> is neither of the two macros)</em></p>
",0
54443661,54443105,4,"<p>Formally, it can be rewritten as equivalent</p>

<pre><code>a == MACRO1 ? strcpy(x, ""S"") : 
a == MACRO2 ? strcpy(x, ""K"") : 0;
</code></pre>

<p>but there's no meaningful reason to do so, unless it is just a puzzle (or unless there's a credible reason to <a href=""https://stackoverflow.com/questions/1613230/uses-of-c-comma-operator/1618867#1618867"">maintain expression semantics</a>). </p>
",0
54443458,54443105,3,"<p>Setting aside this <a href=""https://stackoverflow.com/questions/54443105/how-this-if-else-condition-can-be-replaced-by-ternary-operator/54443661#54443661"">beautiful answer</a>, this cannot be written as a two ""nested"" ternary conditional operators since there is nothing to do for any value of <code>a</code> other than <code>MACRO1</code> and <code>MACRO2</code>, and it's not possible to trick <code>strcpy</code> into a no-op. (The behaviour of copying <code>x</code> to itself is <em>undefined</em>.)</p>

<p>So you are best off leaving the code as it is. Note that in terms of programming history, the ternary conditional operator was invented before the <code>if</code> <code>else</code> control block due perhaps to the deficiencies in the former, as epitomised in the case you present.</p>

<p>You could submit</p>

<pre><code>strnpcy(x, a == MACRO1 ? ""S"" : ""K"", 2 * (a == MACRO1 + a == MACRO2));
</code></pre>

<p>to the next obfuscation contest though.</p>
",0
54443256,54443105,4,"<pre><code>if(a == MACRO1)
 strcpy(x,""S"")
else 
 strcpy(x,""K"");
</code></pre>

<p>can be :</p>

<pre><code>strcpy(x, (a == MACRO1) ? ""S"" : ""K"");
</code></pre>

<p>but</p>

<pre><code>if(a == MACRO1)
 strcpy(x,""S"")
else if (a == MACRO2)
 strcpy(x,""K"");
</code></pre>

<p>has a missing else and to do</p>

<pre><code>strcpy(x, (a == MACRO1) ? ""S"" : ((a == MACRO2) ? ""K"" : x));
</code></pre>

<p>is <strong>not</strong> correct because the argument of <em>strcpy</em>  must  not overlap but in that specific case not sure it is a true problem (even undefined behavior) , but also <em>x</em> is may be not yet initialized, and what about the performances ...</p>
",1
50054545,50054262,4,"<p>You need to initialize <code>r</code> and <code>l</code>. I <em>think</em> you want this:</p>

<pre><code>printf(""LEFT:"");
// Copy chars bitMessage 0-5 to l 0-5
for(i = 0; i &lt; 6; i++){
    l[i] = bitMessage[i];
    printf(""%c"", l[i]);
}
printf(""\n"");
printf(""RIGHT:"");
// Copy chars bitMessage 6-11 to r 0-5
for(i = 6; i &lt; 12; i++){
    r[i - 6] = bitMessage[i];
    printf(""%c"", r[i - 6]);
}
</code></pre>
",1
51693407,51693369,1,"<p>Your function <code>LoadEmployeeFromKey</code> is declared to return a <em>value</em>, and most of your <code>return</code> statements do return a value.</p>

<p>The problem is two-fold: First is that the function (except in one case) always return the <em>same</em> value, making it impossible to distinguish between the cases; The second problem is that you don't <em>check</em> what the function return, so it's not possible to add conditions based on that.</p>

<p>First of all make sure all return statements actually return a value (otherwise you will have <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>). Then return <em>one</em> value if the input was <code>""-1""</code>, and some <em>other</em> value if you fully initialized the structure. Lastly, use the returned value to check if you should increase the counter or not.</p>

<hr>

<p>First of all, you must (and probably already) have a proper function prototype:</p>

<pre><code>int LoadEmployeeFromKey(data *d);
</code></pre>

<p>Secondly, you <em>have</em> used function which returns a value before?</p>

<p>Lets say that the function return <code>1</code> on success, when all fields have been properly entered and initialized, and <code>0</code> otherwise, then you could use it directly in a condition:</p>

<pre><code>if (LoadEmployeeFromKey(&amp;employee[count]) == 1)
{
    // All data valid
    Calculation(&amp;employee[count]);
    count++;
}
</code></pre>

<p>If the function doesn't return <code>1</code> then just don't do anything special.</p>
",2
53030943,53030373,0,"<p>Consider this:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

char *create_filename(const char      *prefix,
                      const struct tm *timestamp,
                      const char      *suffix)
{
    /* YYYYMMDD-HHMMSS is 15 characters. */
    const size_t  timestamp_len = 15;
    const size_t  prefix_len = (prefix) ? strlen(prefix) : 0;
    const size_t  suffix_len = (suffix) ? strlen(suffix) : 0;
    char         *buffer;
    size_t        len;

    /* Abort if no timestamp provided. */
    if (!timestamp) {
        fprintf(stderr, ""create_filename(): No timestamp! (timestamp == NULL)\n"");
        exit(EXIT_FAILURE);
    }

    /* Allocate enough memory for prefix, timestamp, suffix,
       and the end-of-string nul byte, '\0'. */
    buffer = malloc(prefix_len + timestamp_len + suffix_len + 1);
    if (!buffer) {
         fprintf(stderr, ""create_filename(): Out of memory.\n"");
         exit(EXIT_FAILURE);
    }

    /* Copy the prefix part, if any. */
    if (prefix_len &gt; 0)
         memcpy(buffer, prefix, prefix_len);

    /* Copy the timestamp part. */
    len = strftime(buffer + prefix_len, timestamp_len + 1, ""%Y%m%d-%H%M%s"", timestamp);
    if (len &lt; 1 || len &gt; timestamp_len) {
         free(buffer);
         fprintf(stderr, ""BUG in create_filename(): timestamp_len is too small for strftime() pattern.\n"");
         exit(EXIT_FAILURE);
    }

    /* Copy the suffix part, if any. */
    if (suffix_len &gt; 0)
         memcpy(buffer + prefix_len + len, suffix, suffix_len);

    /* Add the terminating nul byte. */
    buffer[prefix_len + len + suffix_len] = '\0';

    return buffer;
}
</code></pre>

<p>Hopefully the comments are clear enough to follow along for new programmers.</p>

<p>Note that the expression <code>const size_t  prefix_len = (prefix) ? strlen(prefix) : 0;</code> uses a ternary operator, <code>(expression) ? (if-true) : (if-false)</code>. <code>strlen(NULL)</code> is not safe, and therefore we need to check that separately; <code>(prefix)</code> does that check. (It is equivalent to <code>(prefix != NULL)</code>, and can be read as <em>""if prefix is non-NULL""</em>.) Simply put, if <code>prefix</code> is NULL, it evaluates to zero, otherwise to the length of the string:</p>

<pre><code>    size_t  prefix_len;
    if (prefix != NULL) {
        prefix_len = strlen(prefix);
    } else {
        prefix_len = 0;
    }
</code></pre>

<p>In your main function, you can use the <code>create_filename()</code> function thus:</p>

<pre><code>int main(void)
{
    time_t     now;
    struct tm *nowtm;
    char      *path;

    now = time(NULL);
    nowtm = localtime(&amp;now);
    path = create_filename(NULL, &amp;nowtm, "".txt"");

    printf(""The path is '%s'.\n"", path);

    free(path); path = NULL;
    return EXIT_SUCCESS;
}
</code></pre>

<p>You can use <code>path</code> as if it was a character array, after the <code>create_filename()</code> call (where it is assigned).  When you no longer need it, call <code>free(path)</code>. This is how simple dynamic memory management really is.</p>

<p>When the program exits (using either <code>return</code> from main function, or the <code>exit()</code> or <code>_Exit()</code> functions), the operating system will free all dynamically allocated memory automatically.  So, technically, there is no need to <code>free()</code> just before a <code>return</code> from main function, or before an <code>exit()</code>.  Still, for learning purposes, it is a good idea to get in a habit of tracking <code>free()</code>s.</p>

<p>Most common bugs are off-by-one, and use-after-free. In <code>create_filename()</code>, off-by-one errors are not possible, because the length of the prefix and suffix are calculated, and the length of the pattern generated by <code>strftime()</code> is explicitly checked.</p>

<p>To avoid use-after-free, I usually set the pointer to NULL explicitly after freeing it. (This is often called <em>""poisoning""</em> in programming: setting the value to a recognizable, usually invalid value, so that use-after-free is easier to detect.)  Many programmers do not bother, but they're just being silly. It's not like it slows down the program, or causes any harm; but it does make debugging easier. In this case, if you tried to use <code>path</code> after it is freed and set to NULL, your program should crash (due to Segment violation, NULL pointer dereference, or similar error; it depends on the operating system you use). In short, it just makes finding bugs much easier.</p>

<p>If you didn't set <code>path = NULL;</code> after the <code>free(path);</code>, and accidentally added a <code>printf(""path is now '%s'\n"", path);</code> after it, <em>it might work, or it might not</em>, depending on the system, the phase of the moon, and the mood of the nasal imps that may one day fly out of your nose due to Undefined Behaviour. (It's a joke: Undefined Behaviour is really undefined behaviour, and although anything could happen, it's not going to break your computer, or wreck your nose, we believe. It's just that it's really difficult to get the program to behave in a reliable manner if you have any Undefined Behaviour in it.  Accessing a freed pointer, or a NULL pointer, is Undefined Behaviour.)</p>
",0
53030416,53030373,2,"<p>the array buffer's memory is only valid during your generateName function.
Even though you retain the pointer to the buffer using the filenam [sic] variable,
the pointer is no longer valid by the time you're back in the main function because the variable buffer is a local variable of the generateName function.</p>

<p>You should declare and allocate a character array as an static array instead
of just allocating a pointer, and pass that pointer as an argument into the generateName function, and write the generated filename there.</p>

<p>I hope this helps!</p>
",2
51192475,51192413,2,"<p>The loop:</p>

<pre><code>for (k=0 ; k&lt;1 ; k++)
</code></pre>

<p>goes until <code>k &lt; 1</code>, so just for <code>k = 0</code>, and similarly it goes for <code>l = 0</code>, so you get just one iteration to display the element at <code>tab_para_automate[0][0]</code>.</p>

<p>You should make both loops condition <code>&lt; 2</code> if you wnat to show all elements.</p>
",0
50304158,50303001,2,"<blockquote>
  <p>i need to check whether the file has previous data stored in it</p>
</blockquote>

<p>There might be <strong>no portable and robust way to do that</strong> (that file might change during the check, because other processes are using it). For example, on Unix or Linux, that file might be opened by <em>another</em> <a href=""https://en.wikipedia.org/wiki/Process_(computing)"" rel=""nofollow noreferrer"">process</a> writing into it while your own program is running (and that might even happen between your <code>ftell</code> and your <code>rewind</code>). And your program might be running in <em>several</em> processes.</p>

<p>You could use <a href=""https://en.wikipedia.org/wiki/Operating_system"" rel=""nofollow noreferrer"">operating system</a> specific functions. For POSIX (including Linux and many Unixes like MacOSX or Android), you might use <a href=""http://man7.org/linux/man-pages/man2/stat.2.html"" rel=""nofollow noreferrer"">stat(2)</a> to query the file status (including its size with <code>st_size</code>). But after that, some <em>other</em> process  might still write data into that file.</p>

<p>You might consider advisory <a href=""https://en.wikipedia.org/wiki/Lock_(computer_science)"" rel=""nofollow noreferrer"">locking</a>, e.g. with <a href=""http://man7.org/linux/man-pages/man2/flock.2.html"" rel=""nofollow noreferrer"">flock(2)</a>, but then you adopt the system-wide convention that every program using that file would lock it.</p>

<p>You could use some <a href=""https://en.wikipedia.org/wiki/Database"" rel=""nofollow noreferrer"">database</a> with <a href=""https://en.wikipedia.org/wiki/ACID"" rel=""nofollow noreferrer"">ACID</a> properties. Look into <a href=""http://sqlite.org/"" rel=""nofollow noreferrer"">sqlite</a> or into <a href=""https://en.wikipedia.org/wiki/Relational_database_management_system"" rel=""nofollow noreferrer"">RDBMS</a> systems like <a href=""http://postgresql.org/"" rel=""nofollow noreferrer"">PostGreSQL</a> or <a href=""https://mariadb.org/"" rel=""nofollow noreferrer"">MariaDB</a>. Or indexed file library like <a href=""https://www.gnu.org.ua/software/gdbm/"" rel=""nofollow noreferrer"">gdbm</a>.</p>

<p>You can continue coding with the implicit assumption (but be aware of it) that only your program is using that file, and that your program has at most one process running it.</p>

<blockquote>
  <p>if the file is empty [...] how can the file pointer not be <code>NULL</code> ? </p>
</blockquote>

<p>As <a href=""https://stackoverflow.com/a/50304122/841108"">Increasingly Idiotic answered</a>, <code>fopen</code> can fail, but usually don't fail on empty files. Of course, you need to <a href=""https://stackoverflow.com/a/18193383/841108"">handle <code>fopen</code> failure</a> (see also <a href=""https://stackoverflow.com/a/50286774/841108"">this</a>). So most of the time, your <code>fp</code> would be valid, and your code chunk (assuming no other process is changing that file simulateously) using <code>ftell</code> and <code>rewind</code> is an approximate way to check that the file is empty. BTW, if you read (e.g. with <code>fread</code> or <code>fgetc</code>) something from that file, that read would fail if your file was empty, so you probably don't need to check its emptiness before.</p>

<p>A POSIX specific way to query the status (including size) of some <code>fopen</code>-ed file is to use <a href=""http://man7.org/linux/man-pages/man3/fileno.3.html"" rel=""nofollow noreferrer"">fileno(3)</a> and <a href=""http://man7.org/linux/man-pages/man2/fstat.2.html"" rel=""nofollow noreferrer"">fstat(2)</a> together like <code>fstat(fileno(fp), &amp;mystat)</code> after having declared <code>struct stat mystat;</code></p>
",0
50306325,50306166,0,"<p>Your fopen line should read (look at the difference: first assignment, then the check for its result).</p>

<pre><code>if (NULL == (fp = fopen(""init.csv"",""r""))){
</code></pre>
",0
50389869,50388139,2,"<p>These statements do not generally have the same behavior as defined by the C standard. Consider when <code>s16X</code> has the least value of its type (e.g., perhaps <code>INT_MIN</code> in an implementation where the <code>int</code> type is 16 bits, so it could be ?32767) and <code>s16Y</code> is 2. Then, in:</p>

<pre><code>s16Result = (T_S16) (s16X - s16Y)
</code></pre>

<p>the expression <code>s16X - s16Y</code> overflows¡ªthe mathematical result of ?32769 is not representable in the <code>int</code> type, and the C standard does not define the result.</p>

<p>However, in:</p>

<pre><code>s16Result = (T_S16) ((T_U16) s16X - (T_U16) s16Y)
</code></pre>

<p>the <code>T_U16</code> type is presumably an unsigned 16-bit type. In this case, <code>s16X</code> is converted to the 16-bit type by adding or subtracting 65536, yielding 32769. <code>s16Y</code> retains its value of 2. Then the subtraction yields 32767. finally, this result is converted to the <code>T_S16</code> type, which keeps the value 32767.</p>

<p>Thus, the statement with unsigned arithmetic may have a defined value in some situations where the statement with signed arithmetic does not have a value defined by the C standard.</p>

<p>(The statement with unsigned arithmetic still has undefined behavior if the final result is not representable in the <code>T_S16</code> type, as when the final result is a number from 32768 to 65535 rather than from 0 to 32767.)</p>
",0
50635733,50635693,1,"<blockquote>
  <p>Am I doing anything illegal here:</p>
</blockquote>

<p>Yes: two things</p>

<ol>
<li>Valid indices for <code>highest1</code> are 0 through 49.</li>
<li>You want <code>strcpy(highest1, l-&gt;name)</code> because <code>highest1[0]</code> is a character, <em>not</em> a pointer to one.</li>
</ol>
",1
55549571,55549362,2,"<p>This is a common mistake when implementing pipelines.</p>

<p>When you pass <code>-l</code> to <code>ls</code>, it produces more output than when you don't pass that option.  That makes it completely fill up the pipe's internal buffer.  The kernel ""blocks"" it from continuing to execute until something reads from the other end of the pipe.  But nothing is reading from the other end of the pipe yet, because your parent program is waiting for <code>ls</code> to finish execution before it starts the <code>grep</code> process.  But <code>ls</code> will not finish execution until it can write more data to the pipe, so the overall program is deadlocked.</p>

<p>To fix this bug you must start <em>all</em> of the processes in the pipeline before you wait for <em>any</em> of them.  You can't do that with a single recursive call to <code>multiple_pipe_handle</code>.  You need two loops, one calling <code>fork</code> and one calling <code>waitpid</code>, and an array of subprocess PIDs.  If you intend to read from the final pipeline process's output in your parent process, you must read all of the data produced (until <code>read</code> signals EOF by returning zero bytes of data) <em>before</em> you start calling <code>waitpid</code>.</p>
",3
50755959,50755879,1,"<p>You probably are not running your program in the environment (notably check the current <a href=""https://en.wikipedia.org/wiki/Working_directory"" rel=""nofollow noreferrer"">working directory</a>) you want.</p>

<p>Of course your <code>fread</code>-s smell bad. Read again the documentation of <a href=""http://en.cppreference.com/w/c/io"" rel=""nofollow noreferrer"">standard C input/output</a> functions, in particular of <a href=""http://en.cppreference.com/w/c/io/fread"" rel=""nofollow noreferrer"">fread</a>. The <code>sizeof(artikl)</code> argument is surely wrong (but since your question don't explain what an <code>ARTIKL</code> really is, we cannot help more).</p>

<p>The notion of <a href=""https://en.wikipedia.org/wiki/Directory_(computing)"" rel=""nofollow noreferrer"">directory</a> is unknown by the C11 standard <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">n1570</a>. See also <a href=""https://stackoverflow.com/a/18193383/841108"">this</a>. But if you are on a POSIX system, you could query it with <a href=""http://man7.org/linux/man-pages/man3/getcwd.3.html"" rel=""nofollow noreferrer"">getcwd(3)</a>. Other operating systems have different ways of querying it (e.g. <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa364934(v=vs.85).aspx"" rel=""nofollow noreferrer"">GetCurrentDirectory</a> on Windows). Read <a href=""http://pages.cs.wisc.edu/~remzi/OSTEP/"" rel=""nofollow noreferrer""><em>Operating Systems: Three Easy Pieces</em></a> to understand more about operating systems, and read also a good C programming book.</p>

<p>So you could perhaps improve the error handling:</p>

<pre><code>if (fp == NULL) {
    fprintf(stderr, ""Pogreska: %s\n"", strerror(errno));
    char wdbuf[128];
    memset(wdbuf, 0, sizeof(cwdbuf));
    fprintf(stderr, ""working directory: %s\n"", 
            getcwd(wdbuf, sizeof(wdbuf));
}
</code></pre>

<p>(the above code don't handle failure of <code>getcwd</code>; a robust program should handle that)</p>

<p>BTW, I am not sure that handling binary files like you do is worthwhile (a binary format is <em>very</em> brittle, and you need to document its format very precisely; remember that most of the time, data is more valuable than the application processing it). You might consider instead storing the data in some textual format (like <a href=""http://json.org/"" rel=""nofollow noreferrer"">JSON</a>, <a href=""http://yaml.org/"" rel=""nofollow noreferrer"">YAML</a>, ....) or in some <a href=""http://sqlite.org/"" rel=""nofollow noreferrer"">sqlite</a> database. Consider using appropriate libraries (e.g. <a href=""http://www.digip.org/jansson/"" rel=""nofollow noreferrer"">jansson</a> for JSON, <code>libsqlite</code> <a href=""https://www.sqlite.org/whentouse.html"" rel=""nofollow noreferrer"">for</a> sqlite)</p>

<p>Don't forget to compile your code with all warnings and debug info (so <code>gcc -Wall -Wextra -g</code> with <a href=""http://gcc.gnu.org/"" rel=""nofollow noreferrer"">GCC</a>). Read the documentation of your compiler (e.g. how to <a href=""https://gcc.gnu.org/onlinedocs/gcc/Invoking-GCC.html"" rel=""nofollow noreferrer"">invoke it</a>) and of your <a href=""https://sourceware.org/gdb/current/onlinedocs/gdb/"" rel=""nofollow noreferrer"">debugger</a>. Use the debugger to understand the behavior of your program.</p>
",5
59169385,59167869,0,"<p>Please note, this algo does not handle hyphenated words or contractions. (That's your job!)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;

int WordCount(char *input, int size)
{
    int inword=0;
    int count=0;
    for (;*input; input++)
        if (isalpha((int) *input))
        {   // does not handle hyphenated words or contractions
            inword=1;
        }
        else
        {
            if (inword)
            {
                inword=0;
                count++;
            }
        }

    return count;
}

int PunctuationCount(char *input, int size)
{
    int count=0;
    for (;*input; input++)
        if (ispunct((int) *input))
        {   // does not handle hyphenated words or contractions
            count++;
        }

    return count;
}

int main(void)
{
    char test1[] = ""Hello, World!"";
    char test2[] = ""She sell sea shell on a sea shore. The shells she sells are sea-shells. I'm sure? For if she sells sea-shells on the sea-shore, then I'm sure she sells sea-shore shells!"";
    char test3[] = ""VISION 2020 embodies every SKKU student's dream, will, and destiny to make SKKU a global leading university. To successfully establish VISION 2020, SKKU will pursue 'The 5 Core Strategies' and '5 Divisional Strategies'. The Strategic Tasks for 5 Major Areas are the general tasks that influence SKKU's competitiveness."";

    printf(""test1 has %d punctuations, %d words.\n"", PunctuationCount(test1,sizeof(test1)/sizeof(char)), WordCount(test1,sizeof(test2)/sizeof(char)));
    printf(""test2 has %d punctuations, %d words.\n"", PunctuationCount(test2,sizeof(test2)/sizeof(char)), WordCount(test2,sizeof(test2)/sizeof(char)));
    printf(""test3 has %d punctuations, %d words.\n"", PunctuationCount(test3,sizeof(test3)/sizeof(char)), WordCount(test3,sizeof(test2)/sizeof(char)));

    return 0;
}
</code></pre>
",1
54638735,54638482,3,"<p>Code is reading some lines from a file then append new lines to the same file (yes, it appends, see below).</p>

<p>Calling <code>truncate()</code> set the file size to 0 on the filesystem. But it doesn't reset the current file offset for the opened file.</p>

<p>So when writing the new lines, they're appended at the end of the previous content, while previous content is replaced by 0: it's creating a sparse file, a file with hole, hole filled with 0.</p>
",0
54749217,54749095,2,"<p>The <code>&lt;</code> operator has left-to-right associativity.  So your expression is parsed as follows:</p>

<pre><code>(a&lt;b)&lt;c
</code></pre>

<p>So <code>a&lt;b</code> is first evaluated.  Since <code>a</code> is less that <code>b</code> it evaluates to true, i.e. 1.  So now you have:</p>

<pre><code>1&lt;c
</code></pre>

<p>Since <code>c</code> is 4 this is also true, so the final result is 1.</p>
",0
50886020,50885978,0,"<p><code>abcd</code> is expanded to blank.</p>

<p>so <code>char abcd c[] = ""AJITH""</code> is expanded to <code>char c[] = ""AJITH""</code>, which is perfectly fine.</p>

<p>Below is the output of your program only after preprocessing (gcc -E)</p>

<pre><code> char c[] = ""AJITH"";                                                            
 int i;                                                                         
 for(i=0;i&lt;5;i++){                                                              
 printf(""%c"",c[i]);                                                             
 }  
</code></pre>
",0
50997563,50997531,10,"<p>This is a silly trick that relies on <code>EOF</code> having all its bits set. <a href=""https://stackoverflow.com/q/4705968/335858"">Since the standard does not guarantee the exact value of EOF</a>, the behavior of this program is platform-dependent.</p>

<p>When <code>scanf</code> detects end-of-input, it returns <code>EOF</code>. Standard requires <code>EOF</code> to be negative. Very often <code>EOF</code> is set to <code>-1</code>. When <code>~</code> is applied to <code>-1</code>, you get back a zero, so the loop stops. On platforms with <code>EOF</code> defined as some other negative number the loop will never stop. Code's behavior also depends on the implementation-defined behavior of <code>~</code> with signed values.</p>

<p>You should rewrite the loop as follows:</p>

<pre><code>while (scanf(""%d"", &amp;a) != EOF) {
    ...
}
</code></pre>
",6
51014023,51013789,0,"<p>Your program is crashing inside <code>insFinal</code> because the <code>ent</code> parameter passed in from <code>main</code> has uninitialized data.  Hence, undefined behavior. Ammend these two lines at the beginning of <code>main</code>:</p>

<pre><code>fila exp;
celula aux;
</code></pre>

<p>With this:</p>

<pre><code>fila exp = {0};
celula aux = {0};
</code></pre>

<p>That will zero-init both.</p>

<p>The thing I don't get is what all these data structures are used for.  Nor do I understand the double-nested for loop for checking the balance.  Checking for a balanced set of parentheses in an expression should be as simple as this:</p>

<pre><code>int areParenthesesBalanced(const char* str) 
{
    int balance = 0;
    int len = str ? strlen(str) : 0;
    for (int i = 0; i &lt; len; i++)
    {
        if (str[i] == '(')
        {
            balance++;
        }
        else if (str[i] == ')')
        {
            balance--;
            if (balance &lt; 0)
            {
                return 0;
            }
        }
    }
    return (balance == 0) ? 1 : 0;
}

int main() {
    char str[1000];
    scanf(""%s"", str);
    if (areParenthesesBalanced(str))
    {
        printf(""Incorreta\n"");
    }
    else
    {
        printf(""Correta\n"");
    }


    return 0;
}
</code></pre>
",5
51132695,51131726,1,"<p>Your comparison function makes no sense.</p>

<p>For it to work, the data type being sorted must be known, so you can't hide the structure declaration from it.</p>

<p>Assuming you move that to the top, you can then re-write the comparison function:</p>

<pre><code>static int compare_crickets(const void *va, const void *vb)
{
  // Convert the generic arguments to actual structure pointers.
  const struct cricket * const ca = va, * const cb = vb;
  // Compare on the 'avrun' member, return -1/0/1 for LT/EQ/GT.
  return ca-&gt;avrun &lt; cb-&gt;avrun ? -1 : ca-&gt;avrun &gt; cb-&gt;avrun;
}
</code></pre>
",0
51143783,51143339,2,"<p>A good idea would be to wrap the part which should be repeated multiple times in <code>do {} while ()</code> <a href=""https://www.tutorialspoint.com/cprogramming/c_do_while_loop.htm"" rel=""nofollow noreferrer"">loop</a>. 
Something like this:</p>

<pre><code>do {
    printf(""You are a prisoner in a room with 2 doors and 2 guards.\n"");
    printf(""One of the doors will guide you to freedom and behind the other is a hangman --you don't know which is which.\n"");
    printf(""One of the guards always tells the truth and the other always lies. You don't know which one is the truth-teller or the liar either.\n"");
    printf(""You have to choose and open one of these doors, but you can only ask a single question to one of the guards.\n"");
    printf(""What do you ask so you can pick the door to freedom?\n\n"");
    printf(""\t1. Ask the truth-guard to point to the door of doom.\n"");
    printf(""\t2. Ask the liar-guard to point to the door of doom.\n"");
    printf(""\t3. Doesn't matter which one you pick.\n"");
    printf (""Enter a number between 1 and 3: "");
    scanf(""%i"" , &amp;choice);

    char *answer = ""No matter which one you choose the guards both tell you which door leads to death, and therefore you can pick the other door.\n"";

    switch (choice) {
        case 1:
            printf(answer);
            break;
        case 2:
            printf(answer);
            break;
        case 3:
            printf(answer);
            break;
        default:
            break;
    }

    printf(""Would you like to play again? (y/n): "");
    int result = getchar();
    while (result == '\n' || result == EOF) 
       result = getchar();
    }
    if (result == EOF) break;
    play = (char)result;
while (play == 'y')
</code></pre>

<p>UPD: As <a href=""https://stackoverflow.com/users/3629249/user3629249"">user3629249</a> pointed out, the input reading in the sample from the question is incorrect. So I fixed it.</p>
",2
51145012,51144902,3,"<p>If possible, I would build this as a single process running two threads, one listening for input from the Windows machine, the other running the simulation itself.</p>

<p>This would make it fairly easy for the listening thread to simply update the data in-place, where the simulation thread will use it.</p>

<p>The one tricky part is coordinating the two--if the simulation thread tries to read data while the listening thread is trying to write it, you're liable to get corrupted data.</p>

<p>To avoid this, you could (for one example) have two separate data areas, one for the current data, and one for the next generation of data, as it's being updated by the listening thread.</p>

<p>The listening thread and the simulation thread then have an atomic flag (or maybe two) to indicate which data area each should use at a given time.</p>
",1
55179004,55178864,3,"<p>Initialise <code>i</code></p>

<pre><code>int i = 0;
int n;
</code></pre>

<p>[edit: I see now that you have edited your code as I suggested]</p>
",0
52980322,52980311,0,"<p><code>remainder</code> takes a double (two, actually).  Use <code>remainderf</code>, not <code>remainder</code>.</p>
",2
51228992,51228657,1,"<p>Since rand() returns an integer this statement</p>

<pre><code>if (rand () % 1 &lt; 0.5)
</code></pre>

<p>makes no sense</p>

<p>try </p>

<pre><code>if (rand() % 2 == 1) 
</code></pre>

<p>for a 50:50 chance.</p>
",2
51426678,51426227,6,"<p>This is probably what you want, just implement your <code>ft_putchar</code> with <code>write</code></p>

<pre><code>#include &lt;unistd.h&gt;

void ft_putchar(char c) { write(STDOUT_FILENO, &amp;c, 1); }

void ft_print_alphabet(void) {
  char letter;

  letter = 'a';
  while (letter &lt;= 'z') {
    ft_putchar(letter);
    letter++;
  }
}

int main(void) {
  ft_print_alphabet();
  return 0;
}
</code></pre>
",3
51426973,51426227,2,"<p>The standard function for printing a character is <a href=""https://en.cppreference.com/w/c/io/putchar"" rel=""nofollow noreferrer""><code>putchar</code></a>. You need to do <code>#include &lt;stdio.h&gt;</code> to use it.</p>

<pre><code>#include &lt;stdio.h&gt;

void    ft_print_alphabet(void)
{
    char    letter;

    letter = 'a';
    while (letter &lt;= 'z')
    {
        putchar(letter);
        letter++;
    }
}

int main(void)
{
    ft_print_alphabet();
    return 0;
}
</code></pre>
",0
51256460,51256337,0,"<p>There's actually no need to use <code>isdigit</code> <em>at all</em> here since <code>scanf</code> with the <code>%d</code> format specifier already guarantees that the characters will be digits with an optional leading sign. And there's a <em>separate</em> specifier to get rid of the leading sign, <code>%u</code>.</p>

<p>If what you input <em>isn't</em> of the correct format, <code>scanf</code> will tell you (since it returns the number of items successfully scanned).</p>

<p>So, for a simple solution, you can just use something like:</p>

<pre><code>unsigned int age;
if (scanf(""%u"", &amp;age) == 1) {
    puts(""Not a valid age"");
    return 1;
}
// Now it's a valid uint, though you may want to catch large values.
</code></pre>

<hr>

<p>If you want <em>robust</em> code, you may have to put in a little more effort than a one-liner <code>scanf(""%d"")</code> - it's fine for one-time or throw-away programs but it has serious shortcomings for code intended to be used in real systems.</p>

<p>First, I would use the excellent string input routine in <a href=""https://stackoverflow.com/questions/2430303/disadvantages-of-scanf/2430310#2430310"">this answer</a><sup>(a)</sup> - it pretty much provides everything you need for prompted and checked user input.</p>

<p>Once you have the input as a string, <code>strtoul</code> allows you to do the same type of conversion as <code>scanf</code> but with the ability to also ensure there's no trailing rubbish on the line as well. <a href=""https://stackoverflow.com/questions/13154275/how-to-get-unsigned-int-as-console-argument/13154368#13154368"">This answer</a> (from the same author) provides the means for doing that.</p>

<p>Tying that all together, you can use something like:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// Code to robustly get input from user.

#define OK       0      // Return codes - okay.
#define NO_INPUT 1      //              - no input given.
#define TOO_LONG 2      //              - input was too long.

static int getLine (
    char *prmpt,        // The prompt to use (NULL means no prompt).
    char *buff,         // The buffer to populate.
    size_t sz           // The size of the buffer.
) {
    int ch, extra;

    // Get line with buffer overrun protection.

    if (prmpt != NULL) {
        printf (""%s"", prmpt);
        fflush (stdout);
    }
    if (fgets (buff, sz, stdin) == NULL)
        return NO_INPUT;

    // If it was too long, there'll be no newline. In that case, we flush
    // to end of line so that excess doesn't affect the next call.

    if (buff[strlen(buff)-1] != '\n') {
        extra = 0;
        while (((ch = getchar()) != '\n') &amp;&amp; (ch != EOF))
            extra = 1;
        return (extra == 1) ? TOO_LONG : OK;
    }

    // Otherwise remove newline and give string back to caller.

    buff[strlen(buff)-1] = '\0';
    return OK;
}

// Code to check string is valid unsigned integer and within range.
// Returns true if it passed all checks, false otherwise.

static int validateStrAsUInt(
    char *str,                   // String to evaluate.
    unsigned int minVal,         // Minimum allowed value.
    unsigned int maxVal,         // Maximum allowed value.
    unsigned int *pResult        // Address of item to take value.
) {
    char *nextChar;
    unsigned long retVal = strtoul (str, &amp;nextChar, 10);

    // Ensure we used the *whole* string and that it wasn't empty.

    if ((nextChar == str) || (*nextChar != '\0'))
        return 0;

    // Ensure it's within range.

    if ((retVal &lt; minVal) || (retVal &gt; maxVal))
        return 0;

    // It's okay, send it back to caller.

    *pResult = retVal;
    return 1;
}

// Code for testing above functions.

int main(void) {
    int retCode;
    unsigned int age;
    char buff[20];

    // Get it as string, detecting input errors.

    retCode = getLine (""Enter your age&gt; "", buff, sizeof(buff));

    if (retCode == NO_INPUT) {
        printf (""\nError, no input given.\n"");
        return 1;
    }

    if (retCode == TOO_LONG) {
        printf (""Error, input too long [%s]\n"", buff);
        return 1;
    }

    // Check string is valid age.

    if (! validateStrAsUInt(buff, 0, 150, &amp;age)) {
        printf(""Not a valid age (0-150)\n"");
        return 1;
    }

    // It's okay, print and exit.

    printf(""Age is valid: %u\n"", age);
    return 0;
}
</code></pre>

<hr>

<p><sup>(a)</sup> I'm reliably informed the author is actually quite clever, and very good looking :-)</p>
",0
51913422,51913352,1,"<p>You should create a header for your module that declares the functions in the module ¨C and any other information that a consumer of the module needs.  You might call that header <code>weekly.h</code>, a pun on your name, but you can choose any name you like within reason.</p>

<p>You should create a library (shared or static ¡ª that's up to you) that contains the functions (and any global variables, if you're so gauche as to have any) defined by your module.  You might call it <code>libweekly.so</code> or <code>libweekly.a</code> ¡ª or using the extensions appropriate to your machine (<code>.dylib</code> and <code>.a</code> on macOS, for example).  The source files might or might not be <code>weekly.c</code> ¡ª if there's more than one function, you'll probably have multiple source files, so they won't all be <code>weekly.c</code>.  You should put this code (the header and the source files and their makefile) into a separate source directory.</p>

<p>You should install the header(s) and the library in a well-known location (e.g. <code>$HOME/include</code> for headers and <code>$HOME/lib</code> for the library ¡ª or maybe in the corresponding directories under <code>/usr/local</code>), and then ensure that the right options are used when compiling (<code>-I$HOME/include</code> for the headers) or linking (<code>-L$HOME/lib</code> and <code>-lweekly</code>).</p>

<p>Your source code using the module would contain:</p>

<pre><code>#include ""weekly.h""
</code></pre>

<p>and your code would be available.  With shared libraries in <code>$HOME/lib</code>, you would have to ensure that the runtime system knows where to find the library.  If you install it in <code>/usr/local</code>, that is done for you already.  If you install it in <code>$HOME/lib</code>, you have to investigate things like <code>/etc/ld.so.conf</code> or the <code>LD_LIBRARY_PATH</code> or <code>DYLIB_LIBRARY_PATH</code> environment variables, etc.</p>
",2
55691476,55691287,3,"<p>The error is on this line</p>

<pre><code> +i*sizeof(struct Address)
</code></pre>

<p>The compiler already multiplies by the size when adding to pointers so don't do it again.  You want only</p>

<pre><code>+i
</code></pre>
",4
52100187,52100048,0,"<p>In your middle loop, you only print a single vertical bar before going to the next line.</p>

<p>You need to print the bar once, then add another loop to print the spaces, then print one more bar:</p>

<pre><code>  for(j=1;j&lt;=width;j++)
  {
     printf(""\n"");
     printf(""%c"",179);
     for (i=1;i&lt;=length;i++) {
       printf("" "");
     }
     printf(""%c"",179);
  }
</code></pre>
",5
56603086,56603037,3,"<p>The <code>random</code> function returns the result of the condition <code>a[0] == 'y'</code>.  Since you define <code>a</code> as <code>char a[3] =""yak""</code> this is always true.</p>

<p>Because of this, the condition of <code>if (random(""random char""))</code> is true so the <code>if</code> section is entered.  Then <code>if(x)</code> is evaluated.  <code>x</code> points to the string constant <code>""Tup""</code>, meaning it has a non-zero value, causing the condition to be true.  So `""True"" is then printed.</p>
",0
51438664,51438280,2,"<p>The problem is here:</p>

<pre><code>long* N;          // N points nowhere
*N = 0;           // you deferecence a pointer that points nowhere
                  // which most likely will result in a segfault
scanf(""%li\n"", N);
</code></pre>

<p>This is correct:</p>

<pre><code>long N;
N = 0;            // this line is somewhat useless BTW, because
                  // N will be modified in the line below anyway
scanf(""%li\n"", &amp;N);
...
su = summation(&amp;N);
</code></pre>

<p>Or even better:</p>

<pre><code>su = summation(N);
...

double summation(long N)   // no need to pass the pointer to N
{                          // just pass N
  double S = 0;
  int i;

  for (i = 1; i &lt;= N; i++)
    S = S + pow(i, 2);
  return S;
}
</code></pre>

<p>You need to read the chapter dealing with pointers in your C text book.</p>
",5
51480922,51479705,1,"<p>I think the most reliable way of checking the OS name is to use the <code>uname</code> utility.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int match_OS(const char* name) {
    FILE *p;
    int result;
    char *s = malloc(1024);
    p = popen(""uname -v"", ""r"");
    s = fgets(s, 1024, p);
    result = (strstr(s, name) != NULL);
    pclose(p);
    free(s);
    return result;
}

int main() {
    if (match_OS(""Ubuntu"")) {
        puts(""This is Ubuntu"");
    }
    else {
        puts(""This isn't Ubuntu"");
    }
    return 0;
}
</code></pre>
",0
51534293,51534209,1,"<p><code>&amp;MES</code> is a pointer to an array of <code>unsigned char</code>.</p>

<p><code>in</code> is an array of pointers to <code>unsigned char</code>.</p>

<p>Try instead :</p>

<pre><code>unsigned char (*in)[] = &amp;MES;
</code></pre>

<p>which makes <code>in</code> also a pointer to an array of <code>unsigned char</code>.</p>
",0
55583668,55583586,7,"<p>If you are compiling to object files, ala:</p>

<pre><code>gcc -O3 -o main.o main.c
gcc -O3 -o func.o func.c
gcc -O3 -o a.out main.o func.o
</code></pre>

<p>Then the compiler will optimize each object file (main and func), but cannot optimize the files when they're pieced together.</p>

<p>There's a reason for this: some projects have hundreds of object files and doing global optimization would greatly increase compile times. This, in turn, would make iterative testing difficult.</p>

<p>You can, however, force what's called ""<a href=""https://en.wikipedia.org/wiki/Interprocedural_optimization"" rel=""noreferrer"">link-time"" or ""interprocedural"" optimization</a>:</p>

<pre><code>gcc -O3 -flto -o main.o main.c
gcc -O3 -flto -o func.o func.c
gcc -O3 -flto -o a.out main.o func.o
</code></pre>

<p>The compiler should now behave as if all the code had been in one source file to begin with. (<code>-flto</code> stands for ""link-time optimization"")</p>
",9
56963875,56963738,4,"<p>In both <code>str[strlen(str) + 1] = '\0';</code> and <code>s = strlen(var.temp) - var.j;</code>, you call <code>strlen</code> on things that are <em>not</em> strings. Only a valid string may be passed to <code>strlen</code>. Look at this code:</p>

<pre><code>str = (char *)malloc(size + 1);
if (!str)
    return (NULL);
str[strlen(str) + 1] = '\0';
</code></pre>

<p>You pass <code>str</code> to <code>strlen</code> even though you just allocated it and it points to a buffer that contains random garbage. You cannot do that. The interface contract for <code>strlen</code> says that you must pass it a pointer to memory that contains a string. Random garbage may or may not be a valid string.</p>

<p>The same is true of <code>var.temp</code> when you pass it to <code>strlen</code>. It doesn't contain a valid string because you haven't placed a valid string in it yet.</p>
",4
51949695,51949466,1,"<p>There is only one <code>char</code> type, just like there is only one <code>int</code> type.</p>

<p>But like with <code>int</code> you can add a modifier to tell the compiler if it's an unsigned or a signed <code>char</code> (or <code>int</code>):</p>

<pre><code>signed char   x1;  // x1 can hold values from -128 to +127 (typically)
unsigned char x2;  // x2 can hold values from 0 to +255 (typically)
signed int    y1;  // y1 can hold values from -2147483648 to +2147483647 (typically)
unsigned int  y2;  // y2 can hold values from 0 to +4294967295 (typically)
</code></pre>

<p>The big difference between plain unmodified <code>char</code> and <code>int</code> is that <code>int</code> without a modifier will <em>always</em> be signed, but it's implementation defined (i.e. it's up to the compiler) if <code>char</code> without a modifier is signed or unsigned:</p>

<pre><code>char x3;  // Could be signed, could be unsigned
int  y3;  // Will always be signed
</code></pre>
",9
51950097,51949466,1,"<p>Plain <code>char</code> is the type spelled <code>char</code> without <code>signed</code> or <code>unsigned</code> prefix.</p>

<p>Plain <code>char</code>, <code>signed char</code> and <code>unsigned char</code> are three distinct <em>integral</em> types (yes, character values are (small) integers), even though plain <code>char</code> is represented identically to one of the other two. Which one is implementation defined. This is distinct from say <code>int</code> : plain <code>int</code> is always the same as <code>signed int</code>.</p>

<p>There's a subtle point here: if plain <code>char</code> is for example signed, then it is a signed type, and we say ""plain char is signed on this system"", but it's still <em>not</em> the same type as <code>signed char</code>. </p>

<p>The difference between these two lines</p>

<pre><code>signed char mySignChar = 'A';
unsigned char myUnsignChar = 'A';
</code></pre>

<p>is exactly the same as the difference between these two lines:</p>

<pre><code>signed int mySignInt = 42;
unsigned int myUnsignInt = 42;
</code></pre>

<p>The statement ""Printable char's are always positive"" means exactly what it says. On some systems some plain char values are negative. On all systems some signed char values are negative. On all systems there is a character of each kind that is exactly zero. But none of those are printable. Unfortunately the statement <em>is not necessarily correct</em> (it is correct about all characters in the <em>basic execution character set</em>, but not about the <em>extended execution character set</em>).</p>
",8
56707937,56707900,6,"<p>The syntax <code>""string_literal"" + N</code> will result in a pointer <code>N</code> bytes up from the start of the literal. <code>""test""+1</code> points to the string <code>""est""</code>, which has length 3.</p>
",0
53900835,53899106,2,"<p>Normally (ignoring bitfields) C can't store anything smaller than a <code>char</code>. To work around that you can read the whole <code>char</code>, modify a portion of it, then store the whole (modified) <code>char</code>.</p>

<p>Note that in C <code>char</code> may be signed (e.g. maybe a signed octet with range -128 to +127); and this makes it messy to modify due to uncertainty (e.g. behaviour of ""right shift of signed integer"" isn't defined). For that reason I'd strongly recommend using <code>unsigned char</code> or <code>uint8_t</code>.</p>

<p>To write the lowest nibble you'd want to do something like:</p>

<pre><code>    dest = dest &amp; 0xF0;        // Clear all bits in the low nibble
    dest = dest | new_nibble;  // Set new bits in the low nibble
</code></pre>

<p>To write the highest nibble you'd want to do something like:</p>

<pre><code>    dest = dest &amp; 0x0F;               // Clear all bits in the high nibble
    dest = dest | (new_nibble &lt;&lt; 4);  // Set new bits in the high nibble
</code></pre>

<p>To read nibbles you'd do something like:</p>

<pre><code>    low_nibble = src &amp; 0x0F;
    high_nibble = (src &amp; 0xF0) &gt;&gt; 4;
</code></pre>

<p>Copying is just reading and then writing. For example, to copy the lowest nibble from <code>src</code> to the highest nibble in <code>dest</code> you could:</p>

<pre><code>    nibble = src &amp; 0x0F;
    dest = dest &amp; 0x0F;             // Clear all bits in the high nibble
    dest = dest | (nibble &lt;&lt; 4);    // Set new bits in the high nibble
</code></pre>

<p>With elements of arrays it might look like this:</p>

<pre><code>    nibble1 = input[loop] &amp; 0x0F;
    nibble2 = (input[loop] &amp; 0xF0) &gt;&gt; 4;
    gen_message[loop + 1] = gen_message[loop + 1] &amp; 0xF0;
    gen_message[loop + 1] = gen_message[loop + 1] | nibble1;
    gen_message[loop] = gen_message[loop] &amp; 0x0F;
    gen_message[loop] = gen_message[loop] | (nibble2 &lt;&lt; 4);
</code></pre>

<p>This can also be done more concisely:</p>

<pre><code>    gen_message[loop + 1] &amp;= 0xF0;
    gen_message[loop + 1] |= input[loop] &amp; 0x0F;
    gen_message[loop] &amp;= 0x0F;
    gen_message[loop] |= ((input[loop] &amp; 0xF0) &gt;&gt; 4) &lt;&lt; 4;
</code></pre>

<p>Of course if know that the destination contains zeros already (e.g. due to <code>memset()</code> or <code>calloc()</code>), you can skip the ""clear nibble"" parts:</p>

<pre><code>    gen_message[loop + 1] |= input[loop] &amp; 0x0F;
    gen_message[loop] |= ((input[loop] &amp; 0xF0) &gt;&gt; 4) &lt;&lt; 4;
</code></pre>

<p><strong>EDIT</strong></p>

<p>The other commentors are right - due to the number of problems it's hard to guess what you're actually trying to do. I think that you might (but might not) be trying to do something like this:</p>

<pre><code>unsigned char *shiftArray4Bits( unsigned char *srcArray ) {
    int srcLen = strlen(srcArray);
    unsigned char temp = 0;
    unsigned char *destArray;

    destArray = malloc(srcLen + 1);
    if(destArray == NULL) {
        return NULL;     // Failed to allocate memory
    }

    for(int i = 0; i &lt; srcLen; i++) {
        dest[i] = temp | ((srcArray[i] &amp; 0xF0) &gt;&gt; 4);
        temp = (srcArray[i] &amp; 0x0F) &lt;&lt; 4;
    }
    dest[i] = temp;
    return dest;
}
</code></pre>
",0
51785469,51785425,18,"<p>The <a href=""https://en.cppreference.com/w/cpp/language/operator_precedence"" rel=""noreferrer"">order of operations</a> is different than what you think.</p>

<p>Your expression is equivalent to</p>

<pre><code>x &amp;&amp; (y==1)
</code></pre>

<p>which is <code>false</code> in your case.</p>
",6
52026026,52025845,1,"<p>It appears that your compilation succeeded successfully.</p>

<p>See if there is an <code>a.out</code> or <code>a.exe</code> file present, as you didn't indicate a non-default executable name.</p>

<p>Note that running <code>a</code> alone typically won't do anything, because it is highly unlikely that your executable is on the bash <code>PATH</code>.  This means you need to run <code>./a.out</code> or <code>./a</code> (depending on base operating system).</p>
",0
51811080,51811017,1,"<p>You forgot some brackets. Here's what your code does currently:</p>

<pre><code>int main(){

    int c, nl = 0;
    while ((c = getchar()) != EOF){
        if (c == '\n'){
            ++nl;
        }
    }
    printf(""%d\n"", nl);
}
</code></pre>

<p>Here's what you probably wanted to do based of indentation:</p>

<pre><code>int main(){

    int c, nl = 0;
    while ((c = getchar()) != EOF){
        if (c == '\n'){
            ++nl;
            printf(""%d\n"", nl);
        }
    }
}
</code></pre>

<p>In C, whitespace is mostly ignored. If you want to run multiple statements together in a block, you need to surround that code with brackets <code>{}</code></p>
",4
51960375,51935893,1,"<p>The purpose of <code>srand</code> and the seed passed to it is to give you <strong>control</strong> over the sequence generated by <code>rand</code>.</p>

<p><code>srand</code> initializes the data used by <code>rand</code>, so it determines what the sequence of numbers generated by <code>rand</code> is. You can use this to choose whether to generate a <strong>new</strong> sequence (one you have not generated previously) or to repeat an <strong>old</strong> sequence (one you generated previously).</p>

<p>For example, suppose you have a simulation of some sort, and random numbers are desired to select some inputs to this simulation, such as when customers arrive or what particles enter the system. For this, you can simply use <code>rand</code> repeatedly to generate numbers. When the simulation is done, you might want to run it again to see how the simulation varies due to effectively random changes in its input. However, if you run the simulation program again, it will behave exactly the same way, because, if <code>srand</code> is not called, <code>rand</code> always produces exactly the same sequence.</p>

<p>So, to generate a different sequence each time, a program may call <code>srand</code> and pass it a different seed. Often, the current time, as returned by the standard <code>time</code> routine, is used as a seed. However, any method of choosing a different value in different runs of the program will serve this purpose. (Note that <code>time(NULL)</code> commonly returns a number of seconds, so executing a program that uses <code>srand(time(NULL))</code> twice in quick succession will result in the same sequence of numbers being used if both executions of the program start within the same second.)</p>

<p>It does not matter which value is passed for the seed, just that it is different from other instances. The reason it does not matter is that a good random number generator uses complicated and well-designed functions to convert the seed into the state of the random number generator and to calculate the generated numbers, and this design makes it difficult for a choice of seed to have any deliberate effect on the generated numbers.</p>

<p>On the other hand, sometimes you want to repeat a sequence. Perhaps one run of the simulation did something interesting, and you want to study it in more detail. Or you want to provide the program to colleagues along with all the data needed to reproduce your results. Or a program has a bug that only manifests sometimes, so you need to exactly repeat execution while debugging. In these cases, you would pass the same seed to <code>srand</code> in each execution in order to reproduce the same sequence of generated numbers.</p>

<p>In programs where I use a varying seed, as with <code>time(NULL)</code>, I have the program write the seed it is using to output, so that, if the user later desires to run with the same sequence, they can pass that seed to the program with a command-line switch (also built into the program) specifying to use that seed.</p>
",1
51936362,51935893,0,"<p>The <code>rand()</code> function returns the next number in a sequence of number defined by some function (the random number generator), and the <code>srand()</code> function defines what the first number in the sequence is.</p>

<p>If you pass a value to <code>srand</code>, call <code>rand</code> (for example) 5 times, then call <code>srand</code> again with the same value and call <code>rand</code> 5 more times, the first set of 5 numbers will be exactly the same as the next set of 5 numbers.</p>

<p>If you don't call <code>srand</code>, the effect is the same as calling <code>srand(0)</code>, so that's why calling <code>rand</code> in a program without calling <code>srand</code> results in the same sequence of numbers.  If you instead pass some varying value to <code>srand</code>, such as the process ID, the current time, or some mathematical combination of them, you get a fairly unique starting point for your sequence of random numbers, leading to a fairly unique sequence.</p>
",1
54446088,54446050,3,"<p>Three things:</p>

<ol>
<li><p><code>Elasticity</code> is of type <code>int</code>. It cannot contain fractional parts. You need to make it a <code>float</code>, <code>double</code> or <code>long double</code> for it to be able to contain a fractional part.</p></li>
<li><p>You are using the <code>%d</code> format specifier in your <code>printf</code> call, which is intended to print out a signed integer in base-10. Use <code>%f</code> to print out a <code>float</code> or <code>double</code>.</p></li>
<li><p>As commenter @user58697 pointed out, you are performing an out of bounds access on <code>y[i + 1]</code> on the last iteration of your <code>for</code> loop. I'm not sure what your intent is with your calculation, so I cannot offer a solution for it.</p></li>
</ol>
",0
53485294,53485231,2,"<p>On platforms where <code>wchar_t</code> is 2 bytes (ie, Windows), you can use <a href=""https://en.cppreference.com/w/c/string/multibyte/wcstombs"" rel=""nofollow noreferrer""><code>wcstombs()</code></a>. </p>
",4
52084422,52082850,0,"<p>The reason is suspected <code>conio.h</code> and other outdated headers is this.</p>

<pre><code>#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
// #include&lt;conio.h&gt;
#include&lt;string.h&gt;

char* strrev(char *str)
{
      char *p1;
      int i, j;
      //puts(""Reversing"");
      //puts(str);
      p1 = (char*)malloc(strlen(str) * sizeof(char));
      for( i = strlen(str)-1, j =0; i &gt;=0; i--, j++) {
        p1[j] = str[i];
      }
      p1[j] = '\0';
      puts(p1);
      //puts(""Done"");
      return p1;
}

void main()
{
    char *arr[1][3]= {{""aABb"",""c"",""d""}};
    char input[15]= {'\0'};
    char temp[15]= {'\0'};
    char stack[15]= {'$','S'};
    int ip=0;
    int ct=0;
    int top,i;
    char x;

    printf(""\t\t\t Predictive parser\t\t\t\n"");
    printf(""___________________________________________________\n\n"");
    printf(""The grammar is :\n"");
    printf(""\t\tS--&gt;aABb\n"");
    printf(""\t\tA--&gt;c\n"");
    printf(""\t\tB--&gt;d\n\n"");
    printf(""You have follow some rules\n"");
    printf(""The string must end with $\n"");
    printf(""Enter  the String  : "");
    gets(input);
    top=(strlen(stack))-1;
    x=stack[top];
    printf(""_______________________________________________________\n"");
    printf(""stack\t\t\t input\t\t\t production\n"");
    printf(""________________________________________________________\n"");
    while(x!='\0')
    {
        if(x=='S'&amp;&amp;input[ct]=='a')
        {
            printf(""\n"");
            for(i=0; i&lt;=strlen(stack); i++)
                printf(""%c"",stack[i]);
            printf(""\t\t\t"");
            for(i=ip; i&lt;6; i++)
                printf(""%c"",input[i]);
            printf(""\t\tderivation using S--&gt;aABb\n"");
            stack[top]='\0';
            strcpy(temp,strrev(arr[0][0]));
            strcat(stack,temp);
            top=strlen(stack)-1;
        }
        else if(x=='A'&amp;&amp;input[ct]=='c')
        {
            printf(""\n"");
            for (i=0; i&lt;=strlen(stack); i++)
                printf(""%c"",stack[i]);
            printf(""\t\t\t "");
            for (i=ip; i&lt;6; i++)
                printf(""%c"",input[i]);
            stack[top]='\0';
            strcpy(temp,strrev(arr[0][1]));
            strcat(stack,temp);
            top=strlen(stack)-1;
            printf(""\t\t derivation usingA--&gt;c\n"");
        }
        else if(x=='B'&amp;&amp;input[ct]=='d')
        {
            printf(""\n"");
            for (i=0; i&lt;=strlen(stack); i++)
                printf(""%c"",stack[i]);
            printf(""\t\t\t "");
            for (i=ip; i&lt;6; i++)
                printf(""%c"",input[i]);
            stack[top]='\0';
            strcpy(temp,strrev(arr[0][2]));
            strcat(stack,temp);
            top=strlen(stack)-1;
            printf(""\t\t derivation using B--&gt;d\n"");
        }
        else if(x=='a'&amp;&amp;input[ct]=='a')
        {
            printf(""\n"");
            for (i=0; i&lt;=strlen(stack); i++)
                printf(""%c"",stack[i]);
            printf(""\t\t\t "");
            for (i=ip; i&lt;6; i++)
                printf(""%c"",input[i]);
            printf(""\t\t popping a from the stack"");
            input[ct]=' ';
            ct++;
            stack[top]='\0';
            top--;
        }
        else if(x=='c'&amp;&amp;input[ct]=='c')
        {
            printf(""\n"");
            for (i=0; i&lt;=strlen(stack); i++)
                printf(""%c"",stack[i]);
            printf(""\t\t\t "");
            for (i=ip; i&lt;6; i++)
                printf(""%c"",input[i]);
            printf(""\t\t popping c from the stack"");
            input[ct]=' ';
            ct++;
            stack[top]='\0';
            top--;
        }
        else if(x=='d'&amp;&amp;input[ct]=='d')
        {
            printf(""\n"");
            for (i=0; i&lt;=strlen(stack); i++)
                printf(""%c"",stack[i]);
            printf(""\t\t\t "");
            for (i=ip; i&lt;6; i++)
                printf(""%c"",input[i]);
            printf(""\t\t popping d from the stack"");
            input[ct]=' ';
            ct++;
            stack[top]='\0';
            top--;
        }
        else if(x=='b'&amp;&amp;input[ct]=='b')
        {
            printf(""\n"");
            for (i=0; i&lt;=strlen(stack); i++)
                printf(""%c"",stack[i]);
            printf(""\t\t\t "");
            for (i=ip; i&lt;6; i++)
                printf(""%c"",input[i]);
            printf(""\t\t popping b from the stack"");
            input[ct]=' ';
            ct++;
            stack[top]='\0';
            top--;
        }
        else if(x=='$'&amp;&amp;input[ct]=='$')
        {
            printf(""\n"");
            for (i=0; i&lt;=strlen(stack); i++)
                printf(""%c"",stack[i]);
            printf(""\t\t\t "");
            for (i=ip; i&lt;6; i++)
                printf(""%c"",input[i]);
            stack[top]='\0';
            printf(""\t\tSuccessfull\n"");
        }
        else
        {
            printf(""\n"");
            for (i=0; i&lt;=strlen(stack); i++)
                printf(""%c"",stack[i]);
            printf(""\t\t\t "");
            for (i=ip; i&lt;6; i++)
                printf(""%c"",input[i]);
            stack[top]='\0';
            printf(""\t\tUnsuccessfull\n"");
            getchar();
            exit(1);
        }
        x=stack[top];
    }
    printf(""\n____________________ Exit program__________________"");
    getchar();
}
</code></pre>

<p><strong>The above is your code with some tiny modifications</strong></p>

<ol>
<li>Used a custom <code>strrev</code> , very naive implementation with bad memory practices, but it works.</li>
<li>got rid of <code>conio</code></li>
<li>Added <code>stdlib.h</code> for <code>malloc</code> </li>
<li>got rid of <code>getch</code> in favor of <code>getchar</code></li>
<li>got rid of <code>clrscr()</code></li>
</ol>

<p>Nobody knows what bugs <code>conio</code> and the old Borland headers have. They might erroneously redescribe some std functions.</p>

<p>When I run the above with input <code>acdb$</code> I get</p>

<pre><code>                        Predictive parser
___________________________________________________

The grammar is :
                S--&gt;aABb
                A--&gt;c
                B--&gt;d

You have follow some rules
The string must end with $
Enter  the String  : acdb$
_______________________________________________________
stack                    input                   production
________________________________________________________

$S                      acdb$           derivation using S--&gt;aABb
bBAa

$bBAa                    acdb$           popping a from the stack
$bBA                      cdb$c
                 derivation usingA--&gt;c

$bBc                      cdb$           popping c from the stack
$bB                        db$d
                 derivation using B--&gt;d

$bd                        db$           popping d from the stack
$b                          b$           popping b from the stack
$                            $          Successfull

____________________ Exit program__________________
</code></pre>

<p>Start using either gcc/clang and use gdb/lldb to debug these programs. </p>

<p><a href=""https://www.cs.umd.edu/~srhuang/teaching/cmsc212/gdb-tutorial-handout.pdf"" rel=""nofollow noreferrer"">here</a>'s a nice guide.</p>

<p>If you compile with these options you can see your program is rife with bad programming patterns</p>

<pre><code>gcc -Werror -Wall -Wextra -pedantic parser.c -o parser
parser.c: In function ¡®strrev¡¯:
parser.c:9:4: error: C++ style comments are not allowed in ISO C90 [-Werror]
parser.c:9:4: error: (this will be reported only once per input file) [-Werror]
parser.c:11:4: error: implicit declaration of function ¡®malloc¡¯ [-Werror=implicit-function-declaration]
parser.c:11:16: error: incompatible implicit declaration of built-in function ¡®malloc¡¯ [-Werror]
parser.c: At top level:
parser.c:21:6: error: return type of ¡®main¡¯ is not ¡®int¡¯ [-Werror=main]
parser.c: In function ¡®main¡¯:
parser.c:52:23: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
parser.c:66:24: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
parser.c:80:24: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
parser.c:94:24: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
parser.c:108:24: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
parser.c:122:24: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
parser.c:136:24: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
parser.c:150:24: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
parser.c:161:24: error: comparison between signed and unsigned integer expressions [-Werror=sign-compare]
parser.c:169:13: error: implicit declaration of function ¡®exit¡¯ [-Werror=implicit-function-declaration]
parser.c:169:13: error: incompatible implicit declaration of built-in function ¡®exit¡¯ [-Werror]
cc1: all warnings being treated as errors
</code></pre>
",0
57778497,57778437,-1,"<p>There's a big difference between using <code>malloc()</code> and not doing so. For instance <code>A_ptr</code> if was returned from a function would be invalid in the scope where the function has already finished excuting, which means that the <code>A_ptr</code> is now pointing to ""<em>invalid</em>"" memory.</p>

<p>You also cannot <code>free()</code> that pointer. And as explained above it can only be used anywhere before the function where the actual object was allocated exits.</p>

<p>It was done like this to have a pointer to a local variable probably just inside a function, it's hard to say what the motivation was without seeing the actual use case.</p>

<p>Also note that the member of type <code>structA</code> is not a pointer so you can't assign to it a pointer. You can create a pointer to it like they did in <code>A_ptr = ...</code>.</p>
",2
53896105,53895785,1,"<p>Only you can know what length is sufficient for your needs.</p>

<p>If there is a limited set or range of valid inputs, you can use the length of the maximum valid input + 1.</p>

<p>If there isn't a limit to the maximum valid input, either you need to decide that your program doesn't support input longer than X and set that as the limit, or implement reading in a loop into a dynamically growing buffer (e.g., using <code>realloc</code> as needed).</p>

<p>And always remember to limit the maximum allowed input length when reading, so that it's not possible to overflow your buffer with excessive input. (Using <code>fgets</code> is often the simplest to get right.)</p>
",0
52348270,52348186,-1,"<p>Recursion involves finding an inductive case and a base case. The inductive case takes you one step closer to the solution, while the base case solves a small version of the problem.</p>

<p>In this case, your <strong>base case</strong> is ""find all permutations of a list with one element."" There is only one value in this set, the string itself.</p>

<p>A great candidate for your <strong>inductive case</strong> would be ""for each string in the set, return the concatenation of that string with each of the permutations of the set without that string"".</p>
",0
53860078,53860008,1,"<p><code>scanf</code> requires an address to place the scanned input into.  You are providing a value, not an address to the value.</p>

<p>To understand this better, to print the number, you would reference it as <code>num[i]</code>, but to get the address of that same number, you would use <code>&amp;num[i]</code>.</p>
",0
52411104,52411033,0,"<p>If you've got an <code>int</code> value, internally it's always represented as a certain number of bits (or whatever your CPU uses <a href=""https://en.wikipedia.org/wiki/Ternary_form"" rel=""nofollow noreferrer"">to store numbers</a>) so you have no control over this.</p>

<p>There's always ""leading zeroes"" in terms of the internal format, because, for example, because 2099 is actually <code>0b00000000000000000000100000110011</code> in 32-bit form. This gets more complicated due to <a href=""https://en.wikipedia.org/wiki/Endianness"" rel=""nofollow noreferrer"">endian issues</a>, but the principle still holds.</p>

<p>The only time leading zeroes makes sense is if you're using <a href=""https://en.wikipedia.org/wiki/Binary-coded_decimal"" rel=""nofollow noreferrer"">binary coded decimal</a>, which has fallen out of style, or string notation such as produced by <code>sprintf</code> type functions.</p>

<p>It's only humans that care about digits. As far as a computer's concerned it's equally difficult to add 1+1 as it is 6916863870493370158+6471945999301299985 because they're both 64-bit operations.</p>
",0
52411147,52411033,1,"<p>If you store the number as an integer (e.g., <code>int</code>) or floating point type, any formatting information is inevitably lost: only the binary representation of the number is stored. (It may help to consider it as saving the <em>idea</em> of the number, e.g., ""two"", not how it looks when written.)</p>

<p>You need to store any additional information elsewhere, such as by saving the original string and using that for output, or by saving the number of digits and applying that to the <code>printf</code> format. There are also decimal number libraries that can internally save the decimal representation of the number, but that is considerably heavier than using the native types.</p>

<p>(Alternatively, just settle on a canonical output format and use that regardless of input. Is the goal really to preserve <em>any</em> input formatting as is, or would it suffice to always add the leading zeroes to the output?)</p>
",0
52411173,52411033,4,"<p>The result of using <code>scanf</code> specifiers <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, <code>a</code>, <code>e</code>, <code>f</code>, <code>g</code> is a mathematical number. There are no leading zeros. Conceptually, there are no digits in a number; it is a pure mathematical entity. (As <a href=""https://stackoverflow.com/users/15168/jonathan-leffler"">Jonathan Leffler</a> notes, leading zeros in the input matter the <code>i</code> specifier; a leading zero changes the base to octal while interpreting the numeral. This is for input only; the result is still a number with no associated digits or base.)</p>

<p>To preserve the leading zeros of a numeral, you must treat it as a string. <code>scanf</code> can be used to read strings or individual characters with the <code>s</code>, <code>c</code>, and <code>[</code> specifiers, although you might wish to use a simple get-character function such as <code>getchar</code>. You would have to count the leading zeros yourself. The remaining digits could also be handled as a string, or you could convert them to a number.</p>
",1
52595789,52595756,2,"<p>The side effect of incrementing using either the prefix <code>++</code> or the postfix <code>++</code> occurs before the statement <code>i++;</code> completes.  The fact that the statement is in a loop doesn't change that.</p>

<p>Your professor is correct.  The first time <code>printf</code> is called in the loop, <code>i</code> will have the value 1 because the previous statement incremented the value.</p>

<p>Had you instead had the following code:</p>

<pre><code>while(i &lt; 10)
{
  printf(""%d\n"",i++);
}
</code></pre>

<p>Then 0 <em>would</em> be printed on the first iteration.  In this case, the value of <code>i</code> is incremented, but the postfix <code>++</code> operator means that the old value of <code>i</code> is passed to the <code>printf</code> call.</p>
",0
56193461,56192534,0,"<p>the following proposed code may be what your looking for:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// to avoid using 'magic' numbers
#define NUM_STRUCTS  10
#define MAX_USERS    20
#define MAX_USER_LEN 20
#define MAX_PASSS    20
#define MAX_PASS_LEN 20

struct Register
{
     char user[ MAX_USERS ][ MAX_USER_LEN ];
     char pass[ MAX_PASSS ][ MAX_PASS_LEN ];
}; 

int main( void )
{
    struct Register x[ NUM_STRUCTS ];

    // initialize structs here, then

    FILE *fp = fopen( ""fileContainingStructs"", ""w"" );
    if( !fp )
    {
        perror( ""fopen failed"" );
        exit( EXIT_FAILURE );
    }

    // implied else, fopen successful

    size_t numStructs =
        fwrite( x, sizeof( struct Register ), NUM_STRUCTS, fp );
    if( numStructs != NUM_STRUCTS )
    {
        perror( ""fwrite failed"" );
        fclose( fp );
        exit( EXIT_FAILURE );
    }

    // implied else, fwrite successful

    fclose( fp );
}
</code></pre>
",2
52516073,52515951,0,"<p>When the function call happens, all your local variables will be in stack. During function call, the stack variables can be modified. When the function call returns, <strong>the stack pointer is decremented</strong>¡¯</p>

<p>Hence, you will be accessing something which is not guaranteed in any way. <strong>In programming languages, this is addressed as a case of undefined behaviour</strong>, since you are overriding the rules of programming language.</p>

<p>In this case of function, given that you stack frame is still active and not modified by any other code, you might get the same value that you wrote to that address.</p>

<p>But is not guaranteed in anyway and <strong>dont assume anything not guaranteed</strong>.</p>
",0
56644885,56644606,13,"<p>If you require this behaviour, use floating point numbers, which can represent infinity, and provide the desired behaviour. Note that technically this is <em>undefined behaviour</em> but in practice most compilers (<em>all</em> mainstream compilers for standard architectures) implement IEEE 754 semantics, e.g. <a href=""https://gcc.gnu.org/wiki/FloatingPointMath"" rel=""noreferrer"">GCC</a>.</p>

<pre><code>int main() {
    float f = 42;
    float g = f / 0.0f;
    printf(""%f\n"", g);
}
</code></pre>

<p>Output:</p>

<pre><code>inf
</code></pre>

<p>This is behaviour that <em>can</em> be relied on since it¡¯s clearly documented by the compilers. However, when writing portable code make sure that you test these assumptions inside your code (e.g. by testing whether the preprocessor macro <code>__STDC_IEC_559__</code>, <a href=""https://stackoverflow.com/q/31181897/1968""><em>as well as</em> compiler-specific macros</a> are defined).</p>

<p>If, for some reason, you need this behaviour for integer values, the only recourse is to make your own type. Something like this:</p>

<pre><code>typedef struct {
    int value;
    bool is_inf;
    bool is_nan;
} ext_int;

ext_int make_ext_int(int i) {
    return (ext_int) {i, false, false};
}

ext_int make_nan() {
    return (ext_int) {0, false, true};
}

ext_int make_inf(int sign) {
    return (ext_int) {(sign &gt; 0) - (sign &lt; 0), true, false};
}

ext_int ext_div(ext_int a, ext_int b) {
    if (a.is_nan || b.is_nan) {
        return  make_nan();
    }
    if (b.value == 0) {
        return make_inf(a.value);
    }
    // TODO: insert other cases.
    return (ext_int) {a.value / b.value, false, false};
}
</code></pre>

<p>¡­ in a real implementation you¡¯d pack the different flags rather than having a separate <code>bool</code> for each, of course.</p>
",6
53740185,53740151,2,"<pre><code>  while((c = fgetc(orginalFile))!=EOF)
  {
     fputc(c,newFile);
     c = fgetc(orginalFile);
   }
</code></pre>

<p>Two mistakes here:</p>

<ol>
<li><p>You call <code>fgetc</code> twice in the loop, which throws every other character away.</p></li>
<li><p>You compare <code>c</code> to <code>EOF</code>. You're suppose to compare the return value of <code>fgetc</code> to <code>EOF</code>. If you think they're the same, remember that <code>c</code> is of type <code>char</code> and <code>fgetc</code> returns an <code>int</code>.</p></li>
</ol>

<p>Also:</p>

<pre><code>    if (orginalFile == NULL | newFile == NULL)
</code></pre>

<p>One mistake here. You have <code>|</code> which is bitwise OR, but you want <code>||</code>, which is a logical OR.</p>
",1
53082631,53082561,3,"<p>You need to convert <code>ag[3]</code> (of type <code>char *</code> / string) to an integer.</p>

<p>Have a look at <a href=""https://en.cppreference.com/w/c/string/byte/strtol"" rel=""nofollow noreferrer""><code>strtol()</code></a> and its brethren. With <a href=""https://en.cppreference.com/w/c/string/byte/atoi"" rel=""nofollow noreferrer""><code>atoi()</code></a> exists a simpler function, which however is not as robust and versatile. That is why I would recommend getting into the habit of using <code>strtol()</code> et al., always.</p>

<p>Sidenote, ""<code>n</code>"" parameters are usually made <code>size_t</code> (unsigned) instead of <code>int</code>. (Compare <a href=""https://en.cppreference.com/w/c/string/byte/strncmp"" rel=""nofollow noreferrer""><code>strncmp()</code></a>). You'd use <code>strtoul()</code> then.</p>
",0
53013722,53013652,0,"<p>You're storing entire strings in memory where you've only allocated a single character. This is a ""buffer overflow"" and causes undefined behavior. </p>

<p>Instead of allocating these as single characters (type <code>char</code>), try allocating them as arrays of characters (e.g., <code>unsigned char cont[128];</code>). I also recommend using <code>fgets()</code> for string input, instead of using <code>scanf()</code> with the <code>%s</code> specifier. </p>

<p>Additionally, don't use <code>cont == America</code> to compare strings. The <code>strcmp()</code> function is the right tool for this job. </p>

<p>Lastly, you never define the variables you're using here as constants (like <code>America</code>). You need to either define <code>America</code> (the variable) (perhaps as <code>""America""</code>) or compare <code>cont</code> directly to the string you're testing for (again, perhaps <code>""America""</code>)</p>

<pre><code>int main(void) {
  const unsigned char *America=""America"";
  unsigned char cont[128];
  ...
  fgets(cont, 128, stdin);
  ...
  if (strcmp(cont, America) == 0) {
    ...
  }
  ...
}
</code></pre>
",0
53327531,53327505,2,"<p>The code simply defines an array that contains several instances of <code>option</code> structures. In this case, the <code>{ 0, 0, 0, 0 }</code> is probably used to signify that it is the last item in the array (since C arrays don't have a length property).</p>

<p>As far as the name, it is unnamed. You can reference this structure from code using <code>options[3]</code>.</p>
",0
54741910,54741715,3,"<p>There are several problems. Presumably <code>chunk</code> is the size of the buffer. Now, if <code>recv</code> is successful it will return the number of bytes received. You should use <em>this</em> count instead of <code>chunk</code> for limiting the loop. Otherwise you'd run the loop for even a failed <code>recv</code> operation and it would count whatever garbage existed in the buffer.</p>

<p>The second problem of course is that the <code>&lt;p&gt;</code> tag might actually be located on the border of 2 chunks.</p>

<p>The third one is that you're probably reading the buffer out of bounds - even if <code>buf[i]</code> is valid doesn't mean that <code>buf[i + 2]</code> is.</p>

<hr>

<p>The <em>simplest</em>, but perhaps not the most correct solution would be to use <code>fdopen</code> on the socket, and then <code>fgetc()</code>, or reading the <em>entire body</em> into a buffer. Let's use <code>fdopen</code> though:</p>

<pre><code>FILE *f = fdopen(s, ""r+b"");
size_t pcount = 0;

int c = 0;
while (c != EOF)
{
    if ((c = fgetc(f)) == '&lt;' 
         &amp;&amp; (c = fgetc(f)) == 'p'
         &amp;&amp; (c = fgetc(f)) == '&gt;') 
    {
        pcount += 1;
    }
}
</code></pre>

<p>Here we're wrapping the socket into a <code>&lt;stdio.h&gt;</code> <code>FILE</code>; <code>fgetc</code> returns the next character from the file and the <code>&amp;&amp;</code> short-circuits; the return value of last <code>fgetc</code> is captured in <code>c</code> as well; and if the return value was <code>EOF</code> the loop is broken and <code>pcount</code> will contain the correct tag count.</p>

<p>If you cannot use <code>fdopen</code>, then you can write your own buffering logic for the socket, or even make a simulated function that calls <code>recv</code> for one byte at a time... </p>

<hr>

<p>Or you can use a state machine:</p>

<pre><code>int pstate = 0;

ssize_t count = recv(s, buf, sizeof buf, 0);
// TODO: add error checking...

for (ssize_t i = 0; i &lt; count; i++)
{
    if (buf[i] == '&lt;') {
        pstate = 1;
    }
    else if (pstate == 1 &amp;&amp; buf[i] == 'p') {
        pstate = 2;
    }
    else if (pstate == 2 &amp;&amp; buf[i] == '&gt;') {
        pcount += 1;
        pstate = 0;
    }
    else {
        // if any other character is found,
        // or any of these characters was in wrong position
        // then reset the state
        pstate = 0;
    }
}
</code></pre>

<p>This will work correctly across different chunk sizes and does not address the buffer out of bounds. As a complication though, it does look much more complicated compared to the <code>fdopen</code> one, even though it is still missing the outer loop!</p>
",1
53176685,53176237,1,"<p>If you're using a native array of arrays of <code>int</code>, you can't force-feed it to a function expecting a pointer to a sequence of pointers. All of those hard casts are a clear-and-present indicator you're doing something wrong. Whoever told you <code>int[N][M]</code> is synonymous with <code>int**</code> was lying; they're not.</p>

<p>Most toolchain vendors support VLAs (variable length arrays) in C in automatic variable locations, including function arguments. The only requirement is the size must precede the array in the argument list:</p>

<pre><code>#include &lt;stdio.h&gt;

void transpose(size_t siz, int mat[][siz])
{
    for(size_t i= 0; i&lt; siz; ++i)
    {
        for(size_t j = i ; j&lt; siz; ++j)
        {
            int temp = mat[i][j];
            mat[i][j] = mat[j][i];
            mat[j][i] = temp;
        }
    }
}

void printMat(size_t siz, int const arr[][siz])
{
    for(size_t i=0; i&lt;siz; ++i)
    {
        for (size_t j=0; j&lt;siz; ++j)
            printf(""%d| "", arr[i][j]);
        fputc('\n',stdout);
    }
}

int main()
{
    int arr[][3] = {{1,2,3},{4,5,6},{7,8,9}};
    printMat(3, arr);
    transpose(3, arr);
    printMat(3,arr);

    return 0;
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>1| 2| 3| 
4| 5| 6| 
7| 8| 9| 
1| 4| 7| 
2| 5| 8| 
3| 6| 9| 
</code></pre>

<p><a href=""https://ideone.com/BCqmpa"" rel=""nofollow noreferrer"">See it live</a>.</p>
",4
57943496,57942829,1,"<p>The standard C features for <code>printf</code> do not provide any means of controlling the number of digits in the exponent. If you want a different format, you will have to write your own code or obtain code from somewhere else.</p>

<p>(The <code>%a</code> conversion does use only as many digits in the exponent as needed, but it prints the value with hexadecimal.)</p>
",1
52908390,52908346,-1,"<p>Try resetting your static variables before second call to multiply or do without them</p>

<pre><code>int multiply(int a, int b) {
      If (a==0)
           return 1;
      else if (a&gt;0)
           return b+multiply(a-1, b);
        else
          return - 1*multiply(-1*a, b); }
</code></pre>
",2
52908366,52908239,1,"<p>You need to turn on compiler warnings:  You have some significant problems in your code.</p>

<p>The lines of the form: </p>

<pre><code>else if (game == Draw &amp;&amp; input == Paper) printf (""i chose paper, its a draw\n"");
</code></pre>

<p>are comparing input (which is a function pointer) to an integer.  The compiler will warn you about this problem if you let it.  Do that, try again, and ask for help if you need it. </p>

<p>Also, you are not using scanf properly.  Look for questions on Stack Overflow about scanf, and print the value you get back from scanf in order to debug your program.  </p>

<p>Best of luck, and don't hesitate to ask another question when you get stuck.</p>
",0
54955547,54955516,4,"<p>You're inserting every element at the head of the list, so they're ordered in the reverse order you read them.  That's not what an insertion sort is.</p>

<p>When you insert into the list, you need to put the new element in the correct order.  When you find a node such that the new value is greater than the current node's value but less than the next node's value, you insert the new node between the current node and the next node.  </p>

<p>If it's less than the head node, make it the new head.  If it's greater than the end node, put it at the end.</p>
",4
55029500,55026252,2,"<p>You've got two main problems, both in the <code>readWords</code>:</p>

<pre><code>while ( true ) {
    ...
    Node *n = (Node *) malloc( sizeof( Node ) );
    ...

    if ( len == 0 ) {
       return list;
    }

    n-&gt;next = list;

    list = n;

    free(n);
}

fclose(fp);
</code></pre>

<p>You populate a node, add that node to the list, then you immediately free that node making invalid.  Later, when you attempt to read the list, you invoked <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a> by dereferencing a pointer to memory that has already been freed.  You're already freeing the list at the end of <code>main</code> so no need to do it here.  </p>

<p>That leaves you with a couple of dangling memory leaks.  When you reach the end of the file,  the <code>len == 0</code> check is true so you immediately return from the function.  This leaves the most recent node you allocated (which contains nothing) as a leak, and you don't close <code>fp</code>.  You can fix this by freeing <code>n</code> inside of the <code>if</code> block and using  <code>break</code> to get out of the loop, and moving the <code>return</code> statement after <code>fclose</code>.</p>

<pre><code>while ( true ) {
    ...
    Node *n = (Node *) malloc( sizeof( Node ) );
    ...

    if ( len == 0 ) {
        free(n);
        break;
    }

    n-&gt;next = list;
    list = n;
}

fclose(fp);
return list;
</code></pre>
",0
53020179,53019948,2,"<p><code>realloc()</code> is the same as <code>malloc()</code>, <code>memcpy()</code>, <code>free()</code> all in one function <em>(*)</em>.</p>

<p>The loop in your code effectively replaces <code>memcpy()</code></p>

<pre><code>        // memcpy(newarr, numbers, cnt * sizeof *newarr);
        for (int i = 0; i &lt; cnt; ++i)
            newarr[i] = numbers[i]; 
</code></pre>

<hr>

<p><sup><em>(*)</em> <code>realloc()</code> may be smart enough to avoid the <code>memcpy()</code> and <code>free()</code> and reuse memory.</sup></p>

<hr>

<blockquote>
  <p>How can I implement this in my code?</p>
</blockquote>

<p>It helps to encapsulate the pointer and the total/used elements in a structure.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct DynArray {
    double *data;
    size_t m; // total
    size_t n; // used
};

void growarray(struct DynArray *x) {
    size_t newsize = x-&gt;m * 13 / 8 + 1; // use phi aproximation 13/8
    double *newarr = realloc(x-&gt;data, newsize * sizeof *x-&gt;data);
    if (!newarr) exit(EXIT_FAILURE);
    fprintf(stderr, ""INFO: realloc'ed with %d elements.\n"", (int)newsize);
    x-&gt;data = newarr;
    x-&gt;m = newsize;
}

int main(void) {
    struct DynArray numbers = { 0 };
    double newnum;
    while (scanf(""%lf"", &amp;newnum) == 1 &amp;&amp; newnum != -1) {
        if (numbers.n == numbers.m) growarray(&amp;numbers);
        numbers.data[numbers.n] = newnum;
        numbers.n++;
    }

    for (int i = numbers.n - 1; i &gt;= 0; --i) {
        printf(""%f\n"", numbers.data[i]);
    }

    free(numbers.data);

    return 0;
}
</code></pre>

<p><a href=""https://ideone.com/1NkLmi"" rel=""nofollow noreferrer"">See code running on ideone</a> or <a href=""https://ideone.com/y22Hso"" rel=""nofollow noreferrer"">previous version without growarray function</a> or <a href=""https://ideone.com/rybKlo"" rel=""nofollow noreferrer"">previous version with cnt</a></p>
",5
53103716,53103571,0,"<p><code>==</code> isn't defined for string (or any other array) comparisons - you need to use the standard library function <code>strcmp</code> to compare strings:</p>

<pre><code>if ( strcmp( name, ""yes"" ) == 0 )
</code></pre>

<p>or</p>

<pre><code>if ( !strcmp( name, ""yes"") )
</code></pre>

<p><code>strcmp</code> is a little non-intuitive in that it returns 0 if the string contents are equal, so the sense of the test will feel wrong.  It will return a negative value if the first string is lexicographically less than the second, and a positive value if the first string is lexicographically greater than the second.</p>

<p>You'll need to <code>#include &lt;string.h&gt;</code> in order to use <code>strcmp</code>.  </p>

<p>For comparing arrays that aren't strings, use <code>memcmp</code>.  </p>
",0
53137557,53136838,-1,"<pre><code>#include &lt;stdio.h&gt;

int main() {
  char input[] = ""101E34"";
  char output[100];
  int i = 0, j = 0, k = 0;
  for(i = 0; i &lt; 6;) {
    if(input[i] &gt;= '0' &amp;&amp; input[i] &lt;= '9')
      j = (input[i] - '0')&lt;&lt; 4;
    else if(input[i] &gt;= 'A' &amp;&amp; input[i] &lt;= 'Z')
      j = (input[i] - 'A' + 10)&lt;&lt; 4;
    else if(input[i] &gt;= 'a' &amp;&amp; input[i] &lt;= 'z')
      j = (input[i] - 'a' + 10)&lt;&lt; 4;


    if(input[i + 1] &gt;= '0' &amp;&amp; input[i + 1] &lt;= '9')
      j = j + (input[i + 1] - '0');
    else if(input[i + 1] &gt;= 'A' &amp;&amp; input[i + 1] &lt;= 'Z')
      j = j + (input[i + 1] - 'A' + 10);
    else if(input[i + 1] &gt;= 'a' &amp;&amp; input[i + 1] &lt;= 'z')
      j = j + (input[i + 1] - 'a' + 10);

    k += snprintf((output + k), (100 - k), ""%d"", j);
    i = i + 2;
  }
  puts(output);
  return 0;
}
</code></pre>

<p>The only restriction is on the size of <code>output</code>. You may need to dynamically allocate it if the <code>input</code> is big or changes in every run.</p>
",3
54056441,54054423,2,"<p><sup> <em>I wrote the accompanying code in March 2018 to satisfy myself about what goes on with <code>strncat()</code> for another question that got deleted before I submitted an answer.  This is just retargeting that code.</em></sup></p>
<p>The <code>strncat()</code> function is (as I said in a <a href=""https://stackoverflow.com/questions/54054423/how-to-avoid-abort-trap-6-error-at-runtime-using-strncat#comment94943480_54054423"">comment</a>) evil and vile.  It is inconsistent with the <code>strncpy()</code> interface, too ¡ª and different from anything you'll encounter anywhere else.  After reading this, you will decide (with luck) that you should never use <code>strncat()</code>.</p>
<h1>TL;DR ¡ª Never use <code>strncat()</code></h1>
<p>The C standard defines <a href=""https://port70.net/%7Ensz/c/c11/n1570.html#7.24.3.2"" rel=""nofollow noreferrer""><code>strncat()</code></a> (and POSIX agrees ¡ª <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strncat.html"" rel=""nofollow noreferrer""><code>strncat()</code></a>)</p>
<blockquote>
<h3>C11 ¡ì7.24.3.2 The <code>strncat</code> function</h3>
<p><strong>Synopsis</strong></p>
<pre><code>#include &lt;string.h&gt;
char *strncat(char * restrict s1, const char * restrict s2, size_t n);
</code></pre>
<p><strong>Description</strong></p>
<p>The <code>strncat</code> function appends not more than <code>n</code> characters (a null character and characters that follow it are not appended) from the array pointed to by <code>s2</code> to the end of the string pointed to by <code>s1</code>. The initial character of <code>s2</code> overwrites the null character at the end of <code>s1</code>. A terminating null character is always appended to the result.<sup>309)</sup> If copying takes place between objects that overlap, the behavior is undefined.</p>
<p><strong>Returns</strong></p>
<p>The <code>strncat</code> function returns the value of <code>s1</code>.</p>
<p><sup>309)</sup> Thus, the maximum number of characters that can end up in the array pointed to by <code>s1</code> is <code>strlen(s1)+n+1</code>.</p>
</blockquote>
<p>The footnote identifies the biggest trap with <code>strncat()</code> ¡ª you can't safely use:</p>
<pre><code>char *source = ¡­;

char target[100] = &quot;&quot;;

strncat(target, source, sizeof(target));
</code></pre>
<p>This is contrary to what occurs with most other functions that take an array size argument <strong><sup>1</sup></strong> in C code.</p>
<p>To safely use <code>strncat()</code>, you should know:</p>
<ul>
<li><code>target</code></li>
<li><code>sizeof(target)</code> ¡ª or, for dynamically allocated space, the allocated length</li>
<li><code>strlen(target)</code> ¡ª you must know the length of what is already in the target string</li>
<li><code>source</code></li>
<li><code>strlen(source)</code> ¡ª if you are concerned about whether the source string was truncated; not needed if you don't care</li>
</ul>
<p>With that information, you could use:</p>
<pre><code>strncat(target, source, sizeof(target) - strlen(target) - 1);
</code></pre>
<p>However, doing that would be a little silly; if you know <code>strlen(target)</code>, you can avoid making <code>strncat()</code> find it out again by using:</p>
<pre><code>strncat(target + strlen(target), source, sizeof(target) - strlen(target) - 1);
</code></pre>
<p>Note that <code>strncat()</code> guarantees null termination, unlike <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strncpy.html"" rel=""nofollow noreferrer""><code>strncpy()</code></a>.  That means that you could use:</p>
<pre><code>size_t t_size = sizeof(target);
size_t t_length = strlen(target);
strncpy(target + t_length, source, t_size - t_length - 1);
target[t_size - 1] = '\0';
</code></pre>
<p>and you would be guaranteed the same result if the source string is too long to be appended to the target.</p>
<h2>Demo Code</h2>
<p>Multiple programs that illustrate aspects of <code>strncat()</code>.  Note that on macOS, there is a macro definition of <code>strncat()</code> in <code>&lt;string.h&gt;</code> which invokes a different function ¡ª?<code>__builtin___strncat_chk</code> ¡ª which validates the uses of <code>strncat()</code>.  For compactness of the command lines, I've dropped two warning compiler options that I normally use ¡ª <code>-Wmissing-prototypes -Wstrict-prototypes</code> ¡ª?but that doesn't affect any of the compilations.</p>
<h3><code>strncat19.c</code></h3>
<p>This demonstrates one safe use of <code>strncat()</code>:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    char spare1[16] = &quot;abc&quot;;
    char buffer[16] = &quot;&quot;;
    char spare2[16] = &quot;xyz&quot;;
    strncat(buffer, &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;, sizeof(buffer) - 1);
    printf(&quot;%zu: [%s]\n&quot;, strlen(buffer), buffer);
    printf(&quot;spare1 [%s]\n&quot;, spare1);
    printf(&quot;spare2 [%s]\n&quot;, spare2);
    return 0;
}
</code></pre>
<p>It compiles cleanly (with Apple's <code>clang</code> from XCode 10.1 (<code>Apple LLVM version 10.0.0 (clang-1000.11.45.5)</code>) and GCC 8.2.0, even with stringent warnings set:</p>
<pre><code>$ gcc -O3 -g -std=c11 -Wall -Wextra -Werror strncat19.c -o strncat19
$ ./strncat19
15: [ABCDEFGHIJKLMNO]
spare1 [abc]
spare2 [xyz]
$
</code></pre>
<h3><code>strncat29.c</code></h3>
<p>This is similar to <code>strncat19.c</code> but (a) allows you to specify a string to be copied on the command line, and (b) incorrectly uses <code>sizeof(buffer)</code> instead of <code>sizeof(buffer) - 1</code> for the length.</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv)
{
    const char *data = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
    if (argc == 2)
        data = argv[1];
    char spare1[16] = &quot;abc&quot;;
    char buffer[16] = &quot;&quot;;
    char spare2[16] = &quot;xyz&quot;;
    strncat(buffer, data, sizeof(buffer));
    printf(&quot;%zu: [%s]\n&quot;, strlen(buffer), buffer);
    printf(&quot;spare1 [%s]\n&quot;, spare1);
    printf(&quot;spare2 [%s]\n&quot;, spare2);
    return 0;
}
</code></pre>
<p>This code doesn't compile with the stringent warning options:</p>
<pre><code>$ clang -O3 -g -std=c11 -Wall -Wextra -Werror strncat29.c -o strncat29  
strncat29.c:12:27: error: the value of the size argument in 'strncat' is too large, might lead to a buffer
      overflow [-Werror,-Wstrncat-size]
    strncat(buffer, data, sizeof(buffer));
                          ^~~~~~~~~~~~~~
strncat29.c:12:27: note: change the argument to be the free space in the destination buffer minus the terminating null byte
    strncat(buffer, data, sizeof(buffer));
                          ^~~~~~~~~~~~~~
                          sizeof(buffer) - strlen(buffer) - 1
1 error generated.
$ gcc -O3 -g -std=c11 -Wall -Wextra -Werror strncat29.c -o strncat29  
In file included from /usr/include/string.h:190,
                 from strncat29.c:2:
strncat29.c: In function ¡®main¡¯:
strncat29.c:12:5: error: ¡®__builtin___strncat_chk¡¯ specified bound 16 equals destination size [-Werror=stringop-overflow=]
     strncat(buffer, data, sizeof(buffer));
     ^~~~~~~
cc1: all warnings being treated as errors
$
</code></pre>
<p>Even with no warnings requested, the warning is given by GCC, but because the <code>-Werror</code> option is absent, it produces an executable:</p>
<pre><code>$ gcc -o strncat29 strncat29.c
In file included from /usr/include/string.h:190,
                 from strncat29.c:2:
strncat29.c: In function ¡®main¡¯:
strncat29.c:12:5: warning: ¡®__builtin___strncat_chk¡¯ specified bound 16 equals destination size [-Wstringop-overflow=]
     strncat(buffer, data, sizeof(buffer));
     ^~~~~~~
$ ./strncat29
Abort trap: 6
$ ./strncat29 ZYXWVUTSRQPONMK
15: [ZYXWVUTSRQPONMK]
spare1 [abc]
spare2 [xyz]
$ ./strncat29 ZYXWVUTSRQPONMKL
Abort trap: 6
$
</code></pre>
<p>That is the <code>__builtin__strncat_chk</code> function at work.</p>
<h3><code>strncat97.c</code></h3>
<p>This code also takes an optional string argument; it also pays attention to whether there is another argument on the command line, and if so, it invokes the <code>strncat()</code> function directly, rather than letting the macro check it first:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

/*
** Demonstrating that strncat() should not be given sizeof(buffer) as
** the size, even if the string is empty to start with.  The use of
** (strncat) inhibits the macro expansion on macOS; the code behaves
** differently when the __strncat_chk function (on High Sierra or
** earlier - it's __builtin__strncat_chk on Mojave) is called instead.
** You get an abort 6 (but no other useful message) when the buffer
** length is too long.
*/

int main(int argc, char **argv)
{
    const char *data = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
    if (argc &gt;= 2)
        data = argv[1];
    char spare1[16] = &quot;abc&quot;;
    char buffer[16] = &quot;&quot;;
    char spare2[16] = &quot;xyz&quot;;
    size_t len = (argc == 2) ? sizeof(buffer) : sizeof(buffer) - 1;
    if (argc &lt; 3)
        strncat(buffer, data, len);
    else
        (strncat)(buffer, data, len);
    printf(&quot;buffer %2zu: [%s]\n&quot;, strlen(buffer), buffer);
    printf(&quot;spare1 %2zu: [%s]\n&quot;, strlen(spare1), spare1);
    printf(&quot;spare2 %2zu: [%s]\n&quot;, strlen(spare2), spare2);
    return 0;
}
</code></pre>
<p>Now the compilers produce different results:</p>
<pre><code>$ gcc -O3 -g -std=c11 -Wall -Wextra -Werror strncat97.c -o strncat97  
strncat97.c: In function ¡®main¡¯:
strncat97.c:26:9: error: ¡®strncat¡¯ output truncated copying 15 bytes from a string of length 26 [-Werror=stringop-truncation]
         (strncat)(buffer, data, len);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
cc1: all warnings being treated as errors
$ clang -O3 -g -std=c11 -Wall -Wextra -Werror strncat97.c -o strncat97  
$
</code></pre>
<p>This demonstrates an advantage of using more than one compiler ¡ª different compilers detect different problems on occasion.  This code is messy trying to used different numbers of options to do multiple things.  It suffices to show:</p>
<pre><code>$ ./strncat97
0x7ffee7506420: buffer 15: [ABCDEFGHIJKLMNO]
0x7ffee7506430: spare1  3: [abc]
0x7ffee7506410: spare2  3: [xyz]
$ ./strncat97 ABCDEFGHIJKLMNOP
Abort trap: 6
$ ./strncat97 ABCDEFGHIJKLMNO
0x7ffeea141410: buffer 15: [ABCDEFGHIJKLMNO]
0x7ffeea141420: spare1  3: [abc]
0x7ffeea141400: spare2  3: [xyz]
$
</code></pre>
<h3><code>strncat37.c</code></h3>
<p>This is the all-singing, all-dancing version of the programs above, with option handling via <code>getopt()</code>.  It also uses my error reporting routines; the code for them is available in my <a href=""https://github.com/jleffler/soq"" rel=""nofollow noreferrer"">SOQ</a> (Stack Overflow Questions) repository on GitHub as files <code>stderr.c</code> and <code>stderr.h</code> in the <a href=""https://github.com/jleffler/soq/tree/master/src/libsoq"" rel=""nofollow noreferrer"">src/libsoq</a> sub-directory.</p>
<pre><code>#include &quot;stderr.h&quot;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

/*
** Demonstrating that strncat() should not be given sizeof(buffer) as
** the size, even if the string is empty to start with.  The use of
** (strncat) inhibits the macro expansion on macOS; the code behaves
** differently when the __strncat_chk function (on High Sierra or
** earlier - it's __builtin__strncat_chk on Mojave) is called instead.
** You get an abort 6 (but no other useful message) when the buffer
** length is too long.
*/

static const char optstr[] = &quot;fhlmsV&quot;;
static const char usestr[] = &quot;[-fhlmsV] [string]&quot;;
static const char hlpstr[] =
    &quot;  -f  Function is called directly\n&quot;
    &quot;  -h  Print this help message and exit\n&quot;
    &quot;  -l  Long buffer length -- sizeof(buffer)\n&quot;
    &quot;  -m  Macro cover for the function is used (default)\n&quot;
    &quot;  -s  Short buffer length -- sizeof(buffer)-1 (default)\n&quot;
    &quot;  -V  Print version information and exit\n&quot;
    ;

int main(int argc, char **argv)
{
    err_setarg0(argv[0]);

    int f_flag = 0;
    int l_flag = 0;
    int opt;

    while ((opt = getopt(argc, argv, optstr)) != -1)
    {
        switch (opt)
        {
        case 'f':
            f_flag = 1;
            break;
        case 'h':
            err_help(usestr, hlpstr);
            /*NOTREACHED*/
        case 'l':
            l_flag = 1;
            break;
        case 'm':
            f_flag = 0;
            break;
        case 's':
            l_flag = 0;
            break;
        case 'V':
            err_version(err_getarg0(), &amp;&quot;@(#)$Revision$ ($Date$)&quot;[4]);
            /*NOTREACHED*/
        default:
            err_usage(usestr);
            /*NOTREACHED*/
        }
    }

    if (optind &lt; argc - 1)
        err_usage(usestr);

    const char *data = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;
    if (optind != argc)
        data = argv[optind];
    char spare1[16] = &quot;abc&quot;;
    char buffer[16] = &quot;&quot;;
    char spare2[16] = &quot;xyz&quot;;
    size_t len = l_flag ? sizeof(buffer) : sizeof(buffer) - 1;

    printf(&quot;Specified length: %zu\n&quot;, len);
    printf(&quot;Copied string: [%s]\n&quot;, data);
    printf(&quot;Copied %s\n&quot;, f_flag ? &quot;using strncat() function directly&quot;
                                 : &quot;using strncat() macro&quot;);

    if (f_flag)
        (strncat)(buffer, data, len);
    else
        strncat(buffer, data, len);

    printf(&quot;%p: buffer %2zu: [%s]\n&quot;, (void *)buffer, strlen(buffer), buffer);
    printf(&quot;%p: spare1 %2zu: [%s]\n&quot;, (void *)spare1, strlen(spare1), spare1);
    printf(&quot;%p: spare2 %2zu: [%s]\n&quot;, (void *)spare2, strlen(spare2), spare2);
    return 0;
}
</code></pre>
<p>As before, Clang and GCC have different views on the acceptability of the code (and <code>-Werror</code> means the warning from GCC is treated as an error):</p>
<pre><code>$ clang -O3 -g -I./inc -std=c11 -Wall -Wextra -Werror strncat37.c -o strncat37 -L./lib  -lsoq 
$ gcc -O3 -g -I./inc -std=c11 -Wall -Wextra -Werror strncat37.c -o strncat37 -L./lib  -lsoq 
strncat37.c: In function ¡®main¡¯:
strncat37.c:80:9: error: ¡®strncat¡¯ output may be truncated copying between 15 and 16 bytes from a string of length 26 [-Werror=stringop-truncation]
         (strncat)(buffer, data, len);
         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
cc1: all warnings being treated as errors
$
</code></pre>
<p>When run:</p>
<pre><code>$ ./strncat37 -h
Usage: strncat37 [-fhlmsV] [string]
  -f  Function is called directly
  -h  Print this help message and exit
  -l  Long buffer length -- sizeof(buffer)
  -m  Macro cover for the function is used (default)
  -s  Short buffer length -- sizeof(buffer)-1 (default)
  -V  Print version information and exit

$ ./strncat37
Specified length: 15
Copied string: [ABCDEFGHIJKLMNOPQRSTUVWXYZ]
Copied using strncat() macro
0x7ffedff4e400: buffer 15: [ABCDEFGHIJKLMNO]
0x7ffedff4e410: spare1  3: [abc]
0x7ffedff4e3f0: spare2  3: [xyz]
$ ./strncat37 -m -s
Specified length: 15
Copied string: [ABCDEFGHIJKLMNOPQRSTUVWXYZ]
Copied using strncat() macro
0x7ffeeaf043f0: buffer 15: [ABCDEFGHIJKLMNO]
0x7ffeeaf04400: spare1  3: [abc]
0x7ffeeaf043e0: spare2  3: [xyz]
$ ./strncat37 -m -l
Specified length: 16
Copied string: [ABCDEFGHIJKLMNOPQRSTUVWXYZ]
Copied using strncat() macro
Abort trap: 6
$ ./strncat37 -f -s
Specified length: 15
Copied string: [ABCDEFGHIJKLMNOPQRSTUVWXYZ]
Copied using strncat() function directly
0x7ffeef0913f0: buffer 15: [ABCDEFGHIJKLMNO]
0x7ffeef091400: spare1  3: [abc]
0x7ffeef0913e0: spare2  3: [xyz]
$ ./strncat37 -f -l
Specified length: 16
Copied string: [ABCDEFGHIJKLMNOPQRSTUVWXYZ]
Copied using strncat() function directly
0x7ffeed8d33f0: buffer 16: [ABCDEFGHIJKLMNOP]
0x7ffeed8d3400: spare1  0: []
0x7ffeed8d33e0: spare2  3: [xyz]
$
</code></pre>
<p>The default behaviour is also the correct behaviour; the program doesn't crash and doesn't produce unexpected side-effects.  When run using the macro and with too long a length specified (<code>-m -l</code>), the program crashes.  When run using the function and too long a length (<code>-f -l</code>), the program overwrites the first byte of array <code>spare1</code> with the null added after the end of <code>buffer</code>, and shows 16 bytes of data instead of 15.</p>
<hr>
<p><strong><sup>1</sup></strong> One exception is in <code>scanf()</code> when you use <code>%31s</code> or similar; the number specified is the number of non-null characters that can be stored in the string; it will add a null byte after reading 31 other characters.  So again, the maximum size that can be used safely is <code>sizeof(string) - 1</code>.</p>
<p>You can find the code for <code>strncatXX.c</code> in my <a href=""https://github.com/jleffler/soq"" rel=""nofollow noreferrer"">SOQ</a> (Stack Overflow Questions) repository on GitHub in the <a href=""https://github.com/jleffler/soq/tree/master/src/so-5405-4423"" rel=""nofollow noreferrer"">src/so-5405-4423</a> sub-directory.</p>
<hr>
<h1>Analysis of Code from Question</h1>
<p>Taking the code from the question and changing <code>int main(){</code> to <code>int main(void){</code> because my default compilation options generate an error (it would be a warning if I didn't use <code>-Werror</code>) for the non-prototype <code>main()</code>, and adding <code>return 0;</code> at the end of <code>main()</code>, what's left gives me these errors compiling with GCC 8.2.0 on a Mac running macOS 10.14.2 Mojave:</p>
<pre><code>$ gcc -O3 -g -std=c11 -Wall -Wextra -Werror -Wmissing-prototypes -Wstrict-prototypes so-5405-4423-v1.c -o so-5405-4423-v1 
In file included from /opt/gcc/v8.2.0/lib/gcc/x86_64-apple-darwin17.7.0/8.2.0/include-fixed/stdio.h:425,
                 from so-5405-4423-v1.c:1:
so-5405-4423-v1.c: In function ¡®main¡¯:
so-5405-4423-v1.c:32:29: error: ¡®%d¡¯ directive writing between 1 and 2 bytes into a region of size between 1 and 100 [-Werror=format-overflow=]
             sprintf(result, &quot;%s%d, &quot;, text, i); // Format the text and store it in result
                             ^~~~~~~~
so-5405-4423-v1.c:32:29: note: directive argument in the range [0, 10]
so-5405-4423-v1.c:32:13: note: ¡®__builtin___sprintf_chk¡¯ output between 4 and 104 bytes into a destination of size 100
             sprintf(result, &quot;%s%d, &quot;, text, i); // Format the text and store it in result
             ^~~~~~~
so-5405-4423-v1.c:37:29: error: ¡® ¡¯ directive writing 1 byte into a region of size between 0 and 99 [-Werror=format-overflow=]
             sprintf(result, &quot;%s%d &quot;, text, i); // Format the text and store it in result
                             ^~~~~~~
so-5405-4423-v1.c:37:13: note: ¡®__builtin___sprintf_chk¡¯ output between 3 and 102 bytes into a destination of size 100
             sprintf(result, &quot;%s%d &quot;, text, i); // Format the text and store it in result
             ^~~~~~~
cc1: all warnings being treated as errors
$
</code></pre>
<p>The compiler notes that <code>text</code> is a string that can contain 0 to 99 characters, so it could in theory cause an overflow when concatenated with a number and the <code>&quot;, &quot;</code> (or the <code>&quot; &quot;</code> for one iteration).  The fact that it is initialized to <code>&quot;String No.&quot;</code> means that there isn't an overflow risk, but you can mitigate that by using a shorter length for <code>text</code> ¡ª say <code>20</code> instead of <code>100</code>.</p>
<p>I admit that this warning, which is relatively new in GCC, is not always as helpful as all that (and this is a case where the code is OK, but the warning still appears).  I usually <em>do</em> fix the problem, if only because it currently shows up with my default options and code doesn't compile with any warnings with <code>-Werror</code> and I'm not ready to do without that level of protection.  I don't use <code>clang</code>'s <code>-Weverything</code> option raw; it produces warnings which are definitely counter-productive (at least AFAIAC).  However, I countermand the 'everything' options that don't work for me.  If a <code>-Wall</code> or <code>-Wextra</code> option was too painful, for some reason, I'd countermand it, but cautiously.  I'd review the pain level, and aim to deal with whatever the symptom is.</p>
<p>You also have the loop:</p>
<pre><code>for(j = 0; j &lt; 10; j++){ // Now loop to change the line

    strcpy(lines[i], line); // Copy the line of text into each line of the array

    fputs(lines[i], file); // Put each line into the file        

}   
</code></pre>
<p>Unfortunately, when this loop runs, <code>i</code> is equal to <code>10</code>, which is out of bounds of the array <code>lines</code>.  This can lead to a crash.  Presumably, the index should be <code>j</code> instead of <code>i</code>.</p>
<p>Here's an instrumented version of your code (<code>so-5405-4423-v2.c</code>):</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

char line[1001];
char lines[11][1001];
char info[100];

char *extra_info(char string_1[], char string_2[], char string_3[],
                 char string_4[], char string_5[]);

int main(void)
{
    char result[100], text[20];
    const char filename[] = &quot;test.txt&quot;;
    FILE *file;

    strcpy(text, &quot;String No.&quot;);

    file = fopen(filename, &quot;w+&quot;);
    if (file == NULL)
    {
        fprintf(stderr, &quot;Failed to open file '%s' for writing/update\n&quot;, filename);
        return 1;
    }

    for (int i = 0; i &lt; 10; i++)
    {
        if (i != 9)
            sprintf(result, &quot;%s%d, &quot;, text, i);
        else
            sprintf(result, &quot;%s%d &quot;, text, i);

        fprintf(stderr, &quot;Iteration %d:\n&quot;, i);
        fprintf(stderr, &quot;1 result (%4zu): [%s]\n&quot;, strlen(result), result);
        fprintf(stderr, &quot;1 line   (%4zu): [%s]\n&quot;, strlen(line), line);
        extra_info(&quot;st&quot;, &quot;nd&quot;, &quot;rd&quot;, &quot;th&quot;, &quot;th&quot;);
        fprintf(stderr, &quot;2 line   (%4zu): [%s]\n&quot;, strlen(line), line);
        fprintf(stderr, &quot;1 info   (%4zu): [%s]\n&quot;, strlen(info), info);
        strncat(line, info, 100);
        fprintf(stderr, &quot;3 line   (%4zu): [%s]\n&quot;, strlen(line), line);
        printf(&quot;%s&quot;, result);
        strncat(line, result, 15);
        fprintf(stderr, &quot;3 line   (%4zu): [%s]\n&quot;, strlen(line), line);
    }

    fprintf(stderr, &quot;4 line   (%4zu): [%s]\n&quot;, strlen(line), line);
    strncat(line, &quot;\n\n&quot;, 2);

    for (int j = 0; j &lt; 10; j++)
    {
        strcpy(lines[j], line);
        fputs(lines[j], file);
    }

    fclose(file);

    return 0;
}

char *extra_info(char string_1[], char string_2[], char string_3[],
                 char string_4[], char string_5[])
{
    char text[100];

    sprintf(text, &quot; 1%s&quot;, string_1);
    fprintf(stderr, &quot;EI 1: add (%zu) [%s] to (%zu) [%s]\n&quot;, strlen(string_1), string_1, strlen(line), line);
    strncat(line, text, 100);

    sprintf(text, &quot;, 2%s&quot;, string_2);
    fprintf(stderr, &quot;EI 2: add (%zu) [%s] to (%zu) [%s]\n&quot;, strlen(string_2), string_2, strlen(line), line);
    strncat(line, text, 100);

    sprintf(text, &quot;, 3%s&quot;, string_3);
    fprintf(stderr, &quot;EI 3: add (%zu) [%s] to (%zu) [%s]\n&quot;, strlen(string_3), string_3, strlen(line), line);
    strncat(line, text, 100);

    sprintf(text, &quot;, 4%s&quot;, string_4);
    fprintf(stderr, &quot;EI 4: add (%zu) [%s] to (%zu) [%s]\n&quot;, strlen(string_4), string_4, strlen(line), line);
    strncat(line, text, 100);

    sprintf(text, &quot;, 5%s.&quot;, string_5);
    fprintf(stderr, &quot;EI 5: add (%zu) [%s] to (%zu) [%s]\n&quot;, strlen(string_5), string_5, strlen(line), line);
    strncat(line, text, 100);

    fprintf(stderr, &quot;EI 6: copy (%zu) [%s] to info\n&quot;, strlen(line), line);
    strcpy(info, line);

    return line;
}
</code></pre>
<p>When run, it produces output similar to:</p>
<pre><code>Iteration 0:
1 result (  13): [String No.0, ]
1 line   (   0): []
EI 1: add (2) [st] to (0) []
EI 2: add (2) [nd] to (4) [ 1st]
EI 3: add (2) [rd] to (9) [ 1st, 2nd]
EI 4: add (2) [th] to (14) [ 1st, 2nd, 3rd]
EI 5: add (2) [th] to (19) [ 1st, 2nd, 3rd, 4th]
EI 6: copy (25) [ 1st, 2nd, 3rd, 4th, 5th.] to info
2 line   (  25): [ 1st, 2nd, 3rd, 4th, 5th.]
1 info   (  25): [ 1st, 2nd, 3rd, 4th, 5th.]
3 line   (  50): [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.]
3 line   (  63): [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0, ]
Iteration 1:
1 result (  13): [String No.1, ]
1 line   (  63): [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0, ]
EI 1: add (2) [st] to (63) [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0, ]
EI 2: add (2) [nd] to (67) [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st]
EI 3: add (2) [rd] to (72) [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd]
EI 4: add (2) [th] to (77) [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd]
EI 5: add (2) [th] to (82) [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th]
EI 6: copy (88) [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th.] to info
2 line   (  88): [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th.]
1 info   (  88): [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th.]
3 line   ( 176): [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th.]
3 line   ( 189): [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th.String No.1, ]
Iteration 2:
1 result (  13): [String No.2, ]
1 line   ( 189): [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th.String No.1, ]
EI 1: add (2) [st] to (189) [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th.String No.1, ]
EI 2: add (2) [nd] to (193) [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th.String No.1,  1st]
EI 3: add (2) [rd] to (198) [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th.String No.1,  1st, 2nd]
EI 4: add (2) [th] to (203) [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th.String No.1,  1st, 2nd, 3rd]
EI 5: add (2) [th] to (208) [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th.String No.1,  1st, 2nd, 3rd, 4th]
EI 6: copy (214) [ 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th. 1st, 2nd, 3rd, 4th, 5th.String No.0,  1st, 2nd, 3rd, 4th, 5th.String No.1,  1st, 2nd, 3rd, 4th, 5th.] to info
String No.0, String No.1, Abort trap: 6
</code></pre>
<p>When you observe that 214 bytes are copied from <code>line</code> (which is big enough to hold that string) to <code>info</code> (which is not ¡ª it is but 100 bytes long), the ensuing crash is not very surprising.  It isn't entirely clear what the desired behaviour is.</p>
<p>On my Mac, the <code>lldb</code> debugger reports the crash in <code>__strcpy_chk</code>; AFAICT, it's in the line highlighted at the end of <code>extra_info()</code>:</p>
<pre><code>frame #6: 0x00007fff681bbe84 libsystem_c.dylib`__strcpy_chk + 83
frame #7: 0x00000001000017cc so-5405-4423-v2`extra_info(string_1=&lt;unavailable&gt;, string_2=&lt;unavailable&gt;, string_3=&quot;rd&quot;, string_4=&quot;th&quot;, string_5=&quot;th&quot;) at so-5405-4423-v2.c:86
</code></pre>
<p>So, while it apparently isn't <code>strncat()</code> that causes the crash here, the way that <code>strncat()</code> <em>is</em> used is not obviously correct ¡ª IMO, it is incorrect, but views may differ.  And I still stand by my basic conclusion: <strong>Do not use <code>strncat()</code></strong>.</p>
",8
55497727,55497526,1,"<p>Perhaps your intent was to use a variable sized array, initializing it after reading <code>n</code>:</p>

<pre><code>// read 'n'
int n;
scanf(""%d"",&amp;n);

// create an automatic (temporary) array of size 'n'
// which will be deallocated once it leaves scope
int intArr[n];

// this part is just making it harder for compiler to 
// do static analysis - why not simply use `intArr`?
int * p = intArr;
</code></pre>

<p>But since you are using <code>malloc</code>, you don't need the temporary array at all and could have just used:</p>

<pre><code>// read 'n'
int n;
scanf(""%d"",&amp;n);

// allocate an array of size 'n'
int * p = malloc(n * sizeof *p);

...

// release the memory 
free(p);
</code></pre>
",0
55497668,55497526,0,"<p>The problem comes from :</p>

<pre><code>p = intArr;
p = malloc(...);
</code></pre>

<p>Doing this, the value of <code>p</code> is lost on the second line.</p>

<p>You should have written </p>

<pre><code>p = malloc(...);
intArr = p;
</code></pre>

<p>or </p>

<pre><code>intArr = malloc(...);
p = intArr;
</code></pre>

<p>Note:</p>

<ol>
<li>Writting <code>int intArr[];</code> does not compile (at least on gcc 8.3) I assume you wrote <code>int *intArr;</code> </li>
<li>A compiler should have warn you about the problem : with option <strong><code>-Wall</code></strong>, gcc says: 

<blockquote>
  <p>warning: ¡®intArr¡¯ is used uninitialized in this function [-Wuninitialized]</p>
</blockquote></li>
</ol>
",1
55497727,55497526,1,"<p>Perhaps your intent was to use a variable sized array, initializing it after reading <code>n</code>:</p>

<pre><code>// read 'n'
int n;
scanf(""%d"",&amp;n);

// create an automatic (temporary) array of size 'n'
// which will be deallocated once it leaves scope
int intArr[n];

// this part is just making it harder for compiler to 
// do static analysis - why not simply use `intArr`?
int * p = intArr;
</code></pre>

<p>But since you are using <code>malloc</code>, you don't need the temporary array at all and could have just used:</p>

<pre><code>// read 'n'
int n;
scanf(""%d"",&amp;n);

// allocate an array of size 'n'
int * p = malloc(n * sizeof *p);

...

// release the memory 
free(p);
</code></pre>
",0
55497668,55497526,0,"<p>The problem comes from :</p>

<pre><code>p = intArr;
p = malloc(...);
</code></pre>

<p>Doing this, the value of <code>p</code> is lost on the second line.</p>

<p>You should have written </p>

<pre><code>p = malloc(...);
intArr = p;
</code></pre>

<p>or </p>

<pre><code>intArr = malloc(...);
p = intArr;
</code></pre>

<p>Note:</p>

<ol>
<li>Writting <code>int intArr[];</code> does not compile (at least on gcc 8.3) I assume you wrote <code>int *intArr;</code> </li>
<li>A compiler should have warn you about the problem : with option <strong><code>-Wall</code></strong>, gcc says: 

<blockquote>
  <p>warning: ¡®intArr¡¯ is used uninitialized in this function [-Wuninitialized]</p>
</blockquote></li>
</ol>
",1
56417201,56412211,-1,"<p>malloc return void * pointer to a place in the memory in size you sent it that you can cast to any - <a href=""https://www.tutorialspoint.com/cprogramming/c_type_casting.htm"" rel=""nofollow noreferrer"">https://www.tutorialspoint.com/cprogramming/c_type_casting.htm</a> type you want see malloc definition :
<a href=""https://www.tutorialspoint.com/c_standard_library/c_function_malloc.htm"" rel=""nofollow noreferrer"">https://www.tutorialspoint.com/c_standard_library/c_function_malloc.htm</a></p>
",0
58989791,58989725,0,"<p>In your sample <code>bytesRead</code> contains the number of bytes read in the last call to <code>read</code> and each iteration of the <code>while</code> loop overwrites the existing value.</p>

<p>Add another variable <code>totalBytesRead</code>, initialize it to 0, and perform <code>totalBytesRead += bytesRead;</code> inside the loop. Then <code>totalBytesRead</code> will hold the total number of bytes read.</p>

<p>That being said, you are not checking any errors from <code>write</code>, thus the variable will contain the bytes read not written (currently for example your code will continue reading even if writing fails. You can add another variable <code>totalBytesWritten</code> as well, perform the same logic as for <code>totalBytesRead</code> in each iteration and compare if you wrote everything you read.</p>
",1
58508337,58508296,1,"<p>I'm not familiar with Zinjai, but with most IDEs you need to create a project in order to compile and link multiple source files into your executable.</p>
",0
55400592,55400132,3,"<blockquote>
  <p>In this case why people don't add ; behind of i++?</p>
</blockquote>

<p>Because the language syntax doesn't allow it:</p>

<p><pre><code>for ( <em>expression<sub>opt</sub></em> ; <em>expression<sub>opt</sub></em> ; <em>expression<sub>opt</sub></em> ) <em>statement</em></pre></code></p>

<p>In the control section of a <code>for</code> loop, the <code>;</code> acts as a <em>separator</em> between the three (optional) expressions, not as a statement terminator.  </p>
",0
55400261,55400132,12,"<p>If you wrote <code>i++</code> as an independent statement you <em>would</em> need to put <code>;</code> after it.</p>

<pre><code>void foo(int i)
{
    i++   // syntax error, missing ';'
}
</code></pre>

<p>But you don't need to put a semicolon after the third expression in a <code>for</code> loop header, because there is a close parenthesis to end it instead.   That's a rule about <code>for</code>, not a rule about <code>++</code>.  No matter what you put in a <code>for</code> loop header, you put a close parenthesis after the third expression, and not a semicolon.</p>

<pre><code>for (listnode *p = list_head; *p; p = p-&gt;next) // correct
</code></pre>
",0
53460970,53460711,0,"<p>You could use:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

static int get_set(int size, int arr[])
{
    int i;
    int n;
    printf(""Enter number of values to the array: "");
    fflush(stdout);      // Usually not strictly necessary, but ensures the prompt appears
    if (scanf(""%d"", &amp;n) != 1)
    {
        fprintf(stderr, ""Invalid number entered\n"");
        exit(EXIT_FAILURE);
    }
    if (n &gt; size)
        n = size;
    printf(""\n"");
    for (i = 0; i &lt; n; i++)
    {
        printf(""Value %d is: "", i + 1);
        fflush(stdout);
        if (scanf(""%d"", &amp;arr[i]) != 1)
        {
            break;
        }
    }
    return i;
}

static void print_set(const char *tag, int size, int arr[])
{
    int i;
    printf(""\n%s: "", tag);
    for (i = 0; i &lt; size; i++)
    {
        printf(""%d,"", arr[i]);
    }
    printf(""\n"");
}

static int RemoveDuplicates(int size, int arr[])
{
    int i, j, k;
    for (i = 0; i &lt; size; i++) 
    {
        for (j = 0; j &lt; i; j++) 
        {
            if (arr[i] == arr[j]) 
            {
                size--;
                for (k = i; k &lt; size; k++) 
                {
                    arr[k] = arr[k + 1];
                }
                i--;
            }
        }
    }
    return size;
}

int main(void)
{
    int arr[64] = {0};
    int size = get_set(64, arr);  // 64 is the maximum; size contains the actual
    print_set(""Original array"", size, arr);
    size = RemoveDuplicates(size, arr);
    print_set(""Duplicates removed"", size, arr);
    return 0;
}
</code></pre>

<p>None of the functions except <code>main()</code> are called from outside this file; the functions can all be static, therefore.</p>

<p>Example run:</p>

<pre><code>Enter number of values to the array: 12

Value 1 is: 1
Value 2 is: 1
Value 3 is: 1
Value 4 is: 2
Value 5 is: 2
Value 6 is: 3
Value 7 is: 4
Value 8 is: 5
Value 9 is: 99
Value 10 is: 999
Value 11 is: 1
Value 12 is: 1

Original array: 1,1,1,2,2,3,4,5,99,999,1,1,

Duplicates removed: 1,2,3,4,5,99,999,
</code></pre>

<p>An alternative redesign of the <code>print_set()</code> function would make the <code>flag</code> in the original code into a <code>static int</code>.  However, that is a far less flexible solution than passing the tag string argument to the function.  Static variables inside functions are occasionally useful, but they should be regarded with a jaundiced eye and avoided when possible, just as global variables should be avoided when possible.</p>
",1
53460787,53460711,1,"<p>The <code>size</code> variable in <code>main</code> is passed by value to <code>get_set</code>, so it will still be <code>0</code> in <code>main</code>.  You should have <code>get_set</code> return the size and assign the result to the <code>size</code> variable (or pass <code>size</code> by reference) so that you can pass it to <code>print_set</code> and <code>RemoveDuplicates</code>.</p>

<p><code>get_set</code> doesn't really need <code>size</code> as a parameter, unless you change it's meaning to indicate the capacity of the array and add error checking to make sure that you don't overflow it.</p>

<p>The <code>arr</code> variable is passed by reference because it is an array which decays into a pointer, so <code>get_set</code> will modify the variable in <code>main</code>.</p>
",1
56608253,56608231,0,"<pre><code>char i=240
</code></pre>

<p>Overflow. <code>char</code> = 8 bits. When signed, it ranges from -128 to 127.
So this converts it to negative.</p>

<p>Suggestion: read your compiler's warnings carefully.</p>
",4
53481821,53481743,2,"<p><code>M</code> is a multiple of <code>N</code> if and only if <code>M % N</code> is zero.<br>
I'm sure you can work out the rest on your own.</p>
",0
53504226,53504022,1,"<p>Because you initialize <code>leastRating</code> to zero you won't have a least favorite unless the rating is negative.  Not sure that's what you want.  </p>

<p>The best suggestion is from @xing, add a include </p>

<pre><code>#include &lt;limits.h&gt;
</code></pre>

<p>and initialize you best and worst like this;</p>

<pre><code>favRating = INT_MIN;
leastRating = INT_MAX;
</code></pre>
",1
54048273,54048054,0,"<p>Code does not allocate enough memory with <code>malloc(sizeof(char))</code> as that is only 1 byte.</p>

<p>When code tries to save a 2nd <code>char</code> into <code>s</code>, bad things can happen: <em>undefined behavior</em> (UB).</p>

<p>In any case, the allocation is not needed.</p>

<hr>

<p>Instead form a reasonable fixed sized buffer and store characters/digits there.</p>

<pre><code>// The max digits in a `long` is about log10(LONG_MAX) + a few
// The number of [bits in an `long`]/3 is about log10(INT_MAX)
#define LONG_DEC_SZ (CHAR_BIT*sizeof(long)/3 + 3)

int main(void)  {
  char a[LONG_DEC_SZ * 2]; // lets go for 2x to allow some leading zeros

  int i = 0;
  int ch; // `getchar()` typically returns 257 different values, use `int`

  // As long as there is room and code is reading digits ...
  while (i &lt; sizeof a &amp;&amp; isdigit((ch = getchar())) ) {
    a[i++] = ch;
  }
  a[i++] = '\0';
  long n = conversion(a);
  printf(""\n%ld\n"", n);
}
</code></pre>

<hr>

<p>To Do: This code does not allow a leading sign character like <code>'-'</code> or <code>'+'</code></p>
",0
54585169,54585062,2,"<p><code>&amp;</code> in C is the inverse of <code>*</code>.</p>

<p>Take <code>char ch;</code> declaration as an example. It declares <code>ch</code> as a one-byte integral variable. Let's say that this variable happens to be stored at <code>0x80000000</code>.</p>

<p>When you say <code>ch = 65</code>, you are changing the value at location <code>0x80000000</code> to <code>65</code>.</p>

<p><code>&amp;</code> gives you the address where the variable is stored. <code>&amp;ch</code> is therefore the pointer <code>0x80000000</code>. <code>char *pointerToCh; pointerToCh = &amp;ch</code> will thus result in <code>pointerToCh</code> being <code>0x80000000</code></p>

<p><code>*</code> refers to the value at the pointer address. Thus, <code>*pointerToCh</code> is the same as <code>ch</code>. <code>*pointerToCh = *pointerToCh + 7</code> will change <code>ch</code> to <code>72</code>, since it is the same as <code>ch = ch + 7</code>. It also follows that <code>*(&amp;ch)</code> is the same thing as <code>ch</code>.</p>

<p>There is a bit of a problem because <code>*</code> is also used in type declarations, to say that something is a pointer - as you've seen above in <code>char *pointerToCh</code>. The <code>*</code> here is not the same <code>*</code> as the one in <code>*pointerToCh = *pointerToCh + 7</code>: the first one makes pointer types; the second one dereferences a pointer.</p>

<p>Why do we do this? Because functions in C just copy parameters passed to them, so they can't change their parameters and have this change be propagated to the calling code. For example:</p>

<pre><code>void uselesslyChange(char copyOfCh) {
  // copyOfCh is 65
  copyOfCh = 80;
  // copyOfCh is 80
}

char ch = 65;
uselesslyChange(ch);
// ch is still 65
</code></pre>

<p>However, if we know the address, we can change what's there (even if the address is just a copy).</p>

<pre><code>void change(char* copyOfChPointer) {
  // copyOfChPointer is 0x80000000, and there's a 65 there
  *copyOfChPointer = 80;
  // copyOfChPointer is 0x80000000, and there's a 80 there
}

char ch = 65;
change(&amp;ch);
// ch is now 80
</code></pre>

<p>So, your code. The important bit is to understand that <code>getline</code> is supposed to be able to change both the buffer (pointer to the first character of an allocated memory area) and the buffer size (integer) to reflect the size of the line being read (e.g. if the buffer is too small, <code>getline</code> will reallocate it somewhere else). In order to be able to change them, it needs to know their locations in memory, just like above. Thus, <code>getline</code> accepts a pointer to a pointer to character (<code>char **buffer</code>) and a pointer to a size (<code>size_t *bufsize</code>). Remember, <code>**</code> and <code>*</code> here is a <em>type</em>, not dereferencing operation.</p>
",0
55664858,55664577,0,"<p>The statement <code>a=&quot;OneExample&quot;;</code> does not mean ¡°Copy the string <code>&quot;OneExample&quot;</code> into <code>a</code>.¡±</p>
<p>In C, a string literal like <code>&quot;OneExample&quot;</code> is an array of <code>char</code> that the compiler allocates for you. When used in an expression, the array automatically becomes a pointer to its first element.<sup>1</sup></p>
<p>So <code>a=&quot;OneExample&quot;</code> means ¡°Set the pointer <code>a</code> to point to the first <code>char</code> in <code>&quot;OneExample&quot;</code>.¡±</p>
<p>Now, <code>a</code> is pointing to the string, and <code>printf</code> of course prints it.</p>
<p>Then <code>free(a)</code> is wrong because it attempts to free the memory of <code>&quot;OneExample&quot;</code> instead of the memory provided <code>malloc</code>.</p>
<h2>Footnote</h2>
<p><sup>1</sup> This automatic conversion does not occur when a string literal is the operand of <code>sizeof</code>, is the operand of unary <code>&amp;</code>, or is used to initialize an array.</p>
",0
55664616,55664577,4,"<p>You aren't using the memory you've allocated. After allocating the memory, you override the pointer <code>a</code> with a pointer to a string literal, causing a memory leak. The subsequent call to <code>free</code> may also crash your application since you're calling <code>free</code> on a pointer that was not allocated with <code>malloc</code>.</p>

<p>If you want to use the space you allocated, you could copy in to it (e..g, by using <code>strncpy</code>).</p>
",0
54287625,54287545,5,"<p>replace</p>

<pre><code>if( (fp=fopen(""/User/don/Vim/code.c"", ""at+"")) == NULL ){
    printf(""Cannot open file\n"");
}
</code></pre>

<p>by</p>

<pre><code>if( (fp=fopen(""/User/don/Vim/code.c"", ""at+"")) == NULL ){
    printf(""Cannot open file\n"");
    return 0;
}
</code></pre>

<p>else you will use a null pointer after in <code>fputs(str, fp);</code></p>

<p>as Jabberwocky says <em>gets</em> is dangerous because you can overflow the buffer, it is more secure to use <em>fgets</em></p>

<p>of course you can also do your work in an <code>else</code> branch :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(){
  FILE *fp;
  char str[120] = {0}, strTemp[100];
  if( (fp=fopen(""/User/don/Vim/code.c"", ""at+"")) == NULL ){
    printf(""Cannot open file\n"");
  }
  else {
    printf(""Input a string:"");
    fgets(strTemp, sizeof(strTemp), stdin);
    strcat(str, ""\n"");
    strcat(str, strTemp);
    fputs(str, fp);
    fclose(fp);
  }

  return 0;
}
</code></pre>
",4
53841044,53840605,2,"<p>Perhaps you mean 220, as in this case:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
  char s = 35;
  unsigned char u = 35;

  char is = ~s;
  unsigned char iu = ~u;

  printf(""~35 (signed) = %d\n"", is);
  printf(""~35 (unsigned) = %d\n"", iu);

  return 0;
}
</code></pre>

<p>Where that prints:</p>

<pre><code>~35 (signed) = -36
~35 (unsigned) = 220
</code></pre>

<p>Remember that <code>int</code> is often 32 bits or more, not 8 as you expected.</p>
",2
53840725,53840605,4,"<p>The bitwise compliment operator <code>~</code> inverts <strong>all</strong> bits of its operand.  So assuming an <code>int</code> is 32 bits, the binary value:</p>

<pre><code>00000000 00000000 00000000 00100011
</code></pre>

<p>Becomes this after applying <code>~</code>:</p>

<pre><code>11111111 11111111 11111111 11011100
</code></pre>

<p>Assuming negative numbers are represented in two's complement representation, this value is -36.</p>

<p>The value 222 you were expecting looks like this in binary as an <code>int</code>:</p>

<pre><code>00000000 00000000 00000000 11011110
</code></pre>

<p>So it seems you were expecting that only the least significant byte gets inverted, but instead the bits in all bytes get inverted.</p>
",3
53841257,53840605,1,"<p>220 is the unsigned value representing the negation of 35 when stored with an 8-bit data type.</p>

<p><code>int</code> is guaranteed by the C standard to be <em>at least</em> 16 bits, so you will <em>never</em> produce the value of 220 by negating an <code>int</code> containing 35. Use <code>uint8_t</code> in <code>&lt;stdint.h&gt;</code> to store the value of 35 and its negation.</p>

<p>Also note that <code>printf</code>-family functions promote <code>%u</code> and <code>%d</code> arguments to <code>unsigned int</code> and <code>int</code> respectively, so you may want to chop off the higher bits with a bitwise AND when printing.</p>
",0
54167488,54167360,4,"<p>C arrays express under evaluation contexts (such as your argument passing to <code>scanf</code>) as a pointer-to-type, where the type is the underlying element type of the array. Therefore <code>word</code> expresses as <code>char*</code>. The address result is that of the first element. </p>

<p>Whereas, <code>&amp;word1</code> evaluates as the <em>same</em> address, but typed to <code>char (*)[100]</code> (because that's exactly what you asked for). It's the same address, and therefore <code>scanf</code> against a <code>%s</code> specifier will still ""work"" (term used loosely). </p>

<p>Your compiler should have puked a warning telling you the expected argument type was <code>char*</code> and you're giving <code>char(*)[100]</code>. If it didn't, turn up your warnings. </p>

<p>Summary; The proper syntax for <code>%s</code> is to pass a <code>char*</code>. In this case, that is obtained by <code>word1</code> (rinse/repeat for <code>word2</code>). It <em>can</em> work using the address-of operator, but there is no reason to use it in this context, and every reason not to.</p>
",0
54167489,54167360,1,"<p>Specifically when using <code>scanf</code> to read a string into <code>char [N]</code> (or <code>char *</code>), you must not use <code>&amp;</code>.</p>

<p>Thus the correct way is:</p>

<pre><code>char word1[100]
scanf(""%s"", word1);
</code></pre>

<p>If you teacher says you need <code>&amp;</code> in this case, they're wrong.</p>

<hr>

<p><code>%s</code> <a href=""https://en.cppreference.com/w/cpp/io/c/fscanf"" rel=""nofollow noreferrer"">expects</a> an argument of type <code>char *</code>.</p>

<p>When you pass a <code>char</code> array (<code>char [N]</code>) to it without using <code>&amp;</code>, it's implicitly converted to a pointer to its' first element - <code>char *</code>.</p>

<p>But if you use <code>&amp;</code>, you end up passing <code>char (*)[N]</code> (a pointer to a <code>char</code> array of size <code>N</code>) instead.<br>
This changes the type of a pointer, but not its' <em>numerical value</em>. Because of that, adding <code>&amp;</code> usually has no effect in this case.
But formally, since the type of the argumentis is incorrect, the behavior is undefiend.</p>
",0
54167471,54167360,2,"<p><code>scanf</code> needs to know the memory location where to place the read and possibly converted value.</p>

<p>For an elementary type, such as <code>int</code>, <code>double</code>, <code>char</code> it means to pass it the <em>address</em> of the variable.</p>

<p>That is also true for an array of characters, however, the compiler by default uses the address of the first element of an array when you pass the name of the array. So:</p>

<pre><code>int i;
char word[100];

scanf(""%d"", &amp;i);
scanf(""%s"", word);
</code></pre>
",2
53872547,53872311,1,"<blockquote>
  <p>When I'm implementing mathematical formulas that carry various constant like this, should I always put .0 at the end to make sure its internally used as a double ?</p>
</blockquote>

<p>Only if you need to make sure the result is a <code>double</code>.  If you want an integer result, then don't append a <code>.0</code>.  If you want a <code>float</code> result, append <code>.0f</code>.  </p>
",0
53872396,53872311,5,"<p>Constants have a type at compile time, just as variables do.  If a numeric constant contains a decimal point and no type suffix then its type is <code>double</code>.  If it does not contain a decimal point and no suffix it will be one of the integer types (which one depends on the value of the constant and the range of the relevant types).  So there's no speedup or slowdown associated solely with the type of the constant. </p>

<p>When it comes to performing calculations, integer arithmetic tends to be faster than floating point, so as a rule don't use floating point values unless you need to.</p>
",2
55940131,55939740,2,"<blockquote>
  <p><strong>Q1</strong>. I want to know if there is any way to check how much stack memory my code is going to use, performance check of the code(optimization), memory leakage.</p>
</blockquote>

<p>You may be able to estimate how much stack space your program will require by analyzing the call graph and the variables declared in each function, but this is not easy for a complex program.  It is much more difficult if any recursion is involved, but one should at least be able to place a rough upper bound.  But the easy way is to <em>measure</em> the usage when running on characteristic inputs.</p>

<p>Absolute performance is <em>extremely</em> hard for humans to predict.  The best we can usually do reliably is to characterize how performance will scale with problem size.  Comparative performance should always be measured.</p>

<p>As for memory leakage, careful code analysis by humans can usually detect memory leaks, but it is wise to complement that with usage of a runtime memory-usage analysis tool such as Valgrind.  Such tools turn up leaks even in well-analyzed code with distressing frequency.</p>

<blockquote>
  <p><strong>Q2</strong>. if the structure of my code is like,nested functions,
  [...]
  because of the function2 call inside a for loop is it going to use
  more stack memory than using once only?</p>
</blockquote>

<p>No.  A function's automatically-allocated resources are released when control leaves that function.  Calling the same function multiple times, whether in a loop or otherwise, does not use more automatic (stack) resources than the most demanding individual call does.</p>

<p>However, when a function <em>recurses</em> by directly or indirectly calling itself, it probably does use additional resources proportional to the recursion depth.  I say ""probably"" because in some cases the compiler may be able to convert the recursion into an iteration within a single function call.</p>
",0
56418676,56418567,1,"<p>Instead of using a pointer, use an array</p>

<pre><code>char str[] = ""bananas';
</code></pre>

<p>You can't modify a string literal but you can modify an array.</p>
",3
54813616,54813338,2,"<p>Supposing you're sorting with function <code>fx()</code></p>

<pre><code>qsort(..., fx);
</code></pre>

<p>just tweak <code>fx()</code></p>

<pre><code>// global var to count comparisons
unsigned long ncomp = 0;

int fx(const void *a, const void *b) {
    ncomp++;
    /* return ...; */
}
</code></pre>
",0
59040638,59040555,4,"<p>You can look at the <code>__STDC_VERSION__</code> macro, which hast the format YYYYMM and from that deduce whether you run C89, C99, C11 or C18.</p>

<p>See also <a href=""https://stackoverflow.com/questions/9294207/what-is-the-stdc-version-value-for-c11"">What is the __STDC_VERSION__ value for C11?</a></p>
",0
54027234,54027168,1,"<p>The variable <code>output_file</code> is local to the <code>if</code> block it is defined in and goes out of scope when you leave the block.  So anyplace after that where you use <code>output_file</code> complain that the variable is not defined.</p>

<p>Define <code>output_file</code> outside of the <code>if</code> block.</p>

<pre><code>FILE *output_file = NULL;
if (LOG_ENABLED == TRUE)
{
    output_file = fopen(filename, ""a"");
}
</code></pre>

<p>Be sure to either check if <code>output_file</code> is set to NULL anyplace you use it later, or set to something like <code>stdout</code> so output goes to the console.</p>
",0
54027234,54027168,1,"<p>The variable <code>output_file</code> is local to the <code>if</code> block it is defined in and goes out of scope when you leave the block.  So anyplace after that where you use <code>output_file</code> complain that the variable is not defined.</p>

<p>Define <code>output_file</code> outside of the <code>if</code> block.</p>

<pre><code>FILE *output_file = NULL;
if (LOG_ENABLED == TRUE)
{
    output_file = fopen(filename, ""a"");
}
</code></pre>

<p>Be sure to either check if <code>output_file</code> is set to NULL anyplace you use it later, or set to something like <code>stdout</code> so output goes to the console.</p>
",0
54036318,54035134,0,"<p>To begin with: you use <em>signed</em> int for indices and num. Input could be negative then(!), so you would have to check for. You avoid this problem if you use <em>unsigned</em> types (especially, as negative indices and array lengths are meaningless anyway). I personally would use <code>size_t</code> for.</p>

<p>Shortened your code a bit:</p>

<pre><code>free(mens[index]-&gt;userName);
// ...
for (f = index; f &lt; *numMens - 1; f++)
{
    mens[f]-&gt;age = mens[f + 1]-&gt;age;
    // ...
}

// these are wrong: you moved them to preceeding list element already
// (unless it was the last element itself, but then you freed them directly
// before entering the loop)
free(mens[*numMens - 1]-&gt;description);

// but I assume you instead want to delete the last element instead:

free(mens[*numMens - 1]);
</code></pre>

<p>You can have this part easier, though:</p>

<pre><code>free(mens[index]-&gt;userName);
// ...

free(mens[index]);

for (f = index; f &lt; *numMens - 1; f++)
{
    mens[f] = mens[f + 1];
}
</code></pre>

<p>The re-alloc part is questionable, though:</p>

<ol>
<li>result of passing zero size is <a href=""https://en.cppreference.com/w/c/memory/realloc"" rel=""nofollow noreferrer""><em>implementation defined</em></a> &ndash; you might or not get a null pointer, memory might or not be freed.</li>
<li>Since C11, support for zero size is deprecated.</li>
</ol>

<p>Reducing memory in size might force the user of the function into a new <code>realloc</code> as soon as she or he adds another element to the array, which might not be to her/his favour...</p>

<p>My personal recommendation:</p>

<pre><code>typedef struct
{
    size_t size;
    size_t capacity;
    user_** data; // maybe even better: user_* data??? - depends on use case, though
} List;
</code></pre>

<p>This struct holds all relevant data together at one place, if you use it for your insertion/deletion functions, you are better off. You'd increase memory, if running out of capacity, but leave reduction to the user (maybe have a separate function for convenience, though).</p>

<p>If you feel reminded to C++: Yes, the basic idea is stolen from there (<code>std::vector</code>)...</p>
",0
54063555,54063529,0,"<p>You could use <code>snprintf</code> for that.</p>

<pre><code>int a = -20;
char string[MAXLEN+1];
snprintf(string, MAXLEN, ""%d"", a)
</code></pre>

<p>The only difference is that you will get a <code>\0</code> value at the end of <code>string</code> array.</p>
",3
55066973,55066847,0,"<p>You have accidentally interchanged the order of the arguments.   The manual page says:</p>

<pre><code>struct servent *getservbyname(const char *name, const char *proto);
</code></pre>

<p>But you swapped the service name and proto in your code:</p>

<pre><code>struct servent *sptr = getservbyname(""tcp"", ""exonet"");
</code></pre>
",4
54184019,54182132,1,"<blockquote>
  <p>Is this c program null safe?</p>
</blockquote>

<p>No.</p>

<hr>

<p>The below fails when <code>argc &lt; 3</code> (e.g. 2,1,0) as it calls <code>atoi()</code> with <code>NULL</code> or unknown. <a href=""https://stackoverflow.com/questions/54182132/is-this-c-program-null-safe/54184019#comment95193203_54182132"">@Ian Abbott</a></p>

<pre><code>int a=atoi(argv[1]),b=atoi(argv[2]),n,status;
</code></pre>

<p>Instead change prior test from only testing against 1 to the below.  Note that <code>argc == 0</code> is possible on select platforms and with certain function calls.</p>

<pre><code>// if(argc==1)
if(argc &lt; 3)
</code></pre>

<hr>

<p>As a stand-alone function, <code>check_negative()</code> does not check if a <em>null pointer</em> argument is passed before de-referencing.  Add checks</p>

<pre><code>int check_negative(int *x, int *y){
  if (x == NULL || y == NULL) return 0;  /// or handle in some way
</code></pre>

<hr>

<p>Aside: </p>

<p><code>isprime(Any_int_less_than_2)</code> errantly returns <code>1</code>.</p>

<p><code>for(i=2; i &lt;= n/2; ++i)</code> is very slow for large <code>n</code>. Suggest speedier <code>for(i=2; i &lt;= n/i; ++i)</code>.  <a href=""https://stackoverflow.com/a/54160322/2410359"">Sample</a></p>
",2
54219348,54202271,0,"<p>How about this (comments explain the code):</p>

<pre><code>void coluna(int size, int board[size][size]){
    int not_zeros[size]; // Use to save the index of columns that contain at 
                         // least one number different than zero.
    int i, j;
    for(i=0; i&lt;size; i++){
        not_zeros[i] = -1; //initialize the array.

    for (i=0; i&lt;size; i++){
        int foundNotZero = 0;
        for (j=0; j&lt;size; j++){
            if(board[j][i] != 0){ //line j, column i.
                foundNotZero = 1;
                break;
            }
        }
        if (foundNotZero == 1){ //at least one element of the column i is not zero.
            not_zeros[i] = i;
        }
    }
    int start = 0;
    for(i=0; i&lt;size; i++){
        if (not_zeros[i] &gt;= 0){ //copy column i to column start.
            for(j = 0; j&lt;size; j++){
                board[j][start] = board[j][not_zeros[i]];
            }
            start++; //increment start.
        }
    }
    for(i=start; i&lt;size; i++){
        for(j=0; j&lt;size; j++){
            board[j][i] = 0; //fill the remaining columns with zeros.
        }
    }
}
</code></pre>
",2
54260879,54260802,2,"<p>Pointers should be printed with <code>%p</code> not <code>%d</code>: the number might be too big and so it is overflowing. </p>

<hr>

<p><strong>EDIT</strong>
Let me be clearer on this: types such as <code>int</code> <code>char</code> etc. have a fixed number of bits/bytes. Even if two types have the same number of bits the difference is how the computer interprets them. For integers, including characters,  with <code>n</code> bits can represent <code>2^n</code> values. Signed integer use some of this to represent negative numbers: particularly you can represent the number in the range <code>-2^(n/2)</code> to <code>2^(n/2) - 1</code>. On the contrary unsigned int represents numbers from <code>0</code> to <code>2^n - 1</code>. The biggest integer has all bits set to 1 except the msb. To get the correspondent positive number the steps are exactly the same</p>

<p>Negative numbers are calculated using <a href=""https://en.wikipedia.org/wiki/Two%27s_complement"" rel=""nofollow noreferrer"">Two's complement</a>: you take the bit-representation of the positive number, do a bit-per-bit negation and then sum 1 to the result. Negative numbers have the most significant bit set to 1.</p>

<p>Let's consider 2 bits: you can represent 4 values with it. If you use an unsigned representation the binary number <code>10</code> corresponds obviously to <code>1</code>. On the contrary if you interpret it as a signed number its value is <code>-2</code>.</p>

<p>Another example is the following consider for example an integer with 8 bits: <code>00001011</code>. This is a positive number. Suppose you cast it to an integer type of smaller size, for example 4 bits. According to <a href=""https://stackoverflow.com/a/34886065/1714692"">this answer</a>, the most common behaviour, which is actually implementation dependent, is to discard the most significant bits. So your number will become <code>1011</code> but using an <code>int</code> representation it is now considered a negative number.</p>

<hr>

<p>You might try to print is as an unsigned <code>%u</code>:</p>

<pre><code>printf(""%u %u %u"",(unsigned int)(p),(unsigned int)(q),(unsigned int)(r));
</code></pre>

<p>Also note that I am getting the warning: <code>warning: incompatible pointer types initializing 'int *' with an expression of type 'int (*)[2]' [-Wincompatible-pointer-types]</code></p>

<p>for </p>

<pre><code>int *q  = &amp;a;
</code></pre>

<p><strong>EDIT</strong></p>

<p>For example in this program run on my computer returns a size of 8 byte for pointers (of type <code>int</code>) and 4 bytes for <code>int</code>:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main(void)
{
    printf(""size of int*: %lu\n"", sizeof(int*));
    printf(""size of int: %lu\n"", sizeof(int));
    return 0;


}
</code></pre>

<p>From this it seems you are following in the second case of the examples I gave.</p>

<p><strong>PLEASE NOTE</strong> Being the pointer size bigger, also the cast to <code>unsigned int</code> might not be enough.</p>
",4
56307500,56307371,1,"<p>If you change the <code>printf()</code> statement to the following, it's easier to see what's going on:</p>

<pre><code>printf(""%d\n%d\n%d\n%d\n"",sizeof(a),sizeof(p),strlen(a),strlen(p));
</code></pre>

<p>On my system, this results in the output:</p>

<pre><code>12
8
11
11
</code></pre>

<p>In other words:</p>

<ul>
<li>The size of the array is 12 bytes. (11 for the string, plus one for the <code>\0</code> character.)</li>
<li>The size of the pointer is 8 bytes (because I'm using a computer with 64-bit memory addresses, as opposed to a 32-bit computer which would likely output <code>4</code>).</li>
<li>When used as strings (<code>char*</code> pointers), <code>a</code> and <code>p</code> are equivalent. (because <code>p</code> points to <code>a</code>.) The length of the string <code>Hello World</code> is <code>11</code> (since <code>strlen()</code> doesn't include the <code>\0</code> byte at the end of the string).</li>
</ul>

<p>Hope this helps.</p>
",3
54327287,54327109,2,"<p>You can use a while or do-while statement.</p>

<p>Also make a 3x3 twodimensional array that keeps track of the spots: 0 = unfilled, 1 = Human, 2 = AI (better is to use an enum).</p>

<p>In pseudo code:</p>

<p>Global variable:</p>

<pre><code>int spots[3][3]; // 3x3 array
</code></pre>

<p>Code:</p>

<pre><code>Setup(); // Setup of board, sets 0's to spots.

while (!endOfGame())
{
    Player(); // Handle player, assuming it plays first, sets a 1 in one spot

    if (!endOfGame())
    {
         AI();
    }
}


void AI() 
{
    do
    {
       square = AIChoice();
    } while (spots[square] == 0);

    // Now we know spots[square] == 0, thus unfilled
    spots[square] = 2; // AI
}
</code></pre>
",2
55576638,55576587,0,"<p>You obviously understand how to put a number of same characters next to each other.</p>

<p>The only thing left to do for you is to notice that the only difference between the first half-tree and the second is some spaces in front of the stars.</p>

<p>Also notice that the number of spaces is quite predictable, given the number of stars: the total width of spaces and stars is constant.</p>
",2
54456650,54456398,3,"<p>In the <code>leggi_file</code> function, <code>array</code> is a pointer to a pointer of structures. Think of it as a pointer to an array of structures. It is most definitely not an array of pointers to structures (as the use <code>array[i]-&gt;nome</code> would indicate).</p>

<p>The correct way is to dereference the pointer to get the array (of <strong><em>structures</em></strong>), as in <code>(*array)[i].nome</code>.</p>

<p>With <code>array[i]-&gt;nome</code> you treat <code>array</code> as an array of pointers, which it is not. It's (effectively, but not semantically) a pointer to an array.</p>

<p>By using <code>array[i]-&gt;nome</code> you will go out of bounds of the memory for <code>array</code>, leading to <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>. You're lucky (or unlucky depending on point of view) that the code don't crash.</p>

<p>The only line you need to change is this one:</p>

<pre><code>fscanf(input, ""%s %s %s"", array[i]-&gt;nome, array[i]-&gt;cognome, array[i]-&gt;cf);
</code></pre>

<p>Which you should change into</p>

<pre><code>fscanf(input, ""%s %s %s"", (*array)[i].nome, (*array)[i].cognome, (*array)[i].cf);
</code></pre>
",8
54707749,54707502,1,"<p>Your solution is not quite what the algorithm states. You might consider not using
two nested for-loops:</p>

<pre><code>void insertionsort(int a[], int n){
   int i, key, j; 
   for (i = 1; i &lt; n; i++) 
   { 
       key = a[i]; 
       j = i-1; 

       /* 
          Move all elements in the array at index 0 to i-1, that are 
          greater than the key element, one position to the right 
          of their current position 
       */
       while (j &gt;= 0 &amp;&amp; a[j] &gt; key) 
       { 
           a[j+1] = a[j]; 
           j = j-1; 
       } 
       a[j+1] = key; 
   } 
}
</code></pre>
",0
54707560,54707502,0,"<p>You need to swap <code>i-1</code> index value too and also the second for loop condition should be <code>&gt;</code>.</p>

<pre><code>void insertionsort(int a[], int n){
    int next, i, j;
    for(i=1; i&lt;n; i++){
        if(a[i]&lt;a[i-1]){
            for(j=i; j&gt;0; j--){
                if(a[j - 1]&gt;a[ j ]){
                    next = a[ j - 1];
                    a[j - 1] = a[j];
                    a[j] = next;
                }
            }
        }
    }
}
</code></pre>
",0
54497645,54497582,1,"<p>Looks like a small mistake:</p>

<p>You initialize <code>minimum</code> with <code>NMAX</code>, which I assume is 8 (the size of the array). 99.9% of the random numbers will be bigger. So 8 is chosen as the minimum.</p>

<p>What you really want is to initialize it with <code>RAND_MAX</code> ¨C the maximum value <code>rand()</code> can return.</p>
",0
55466087,55466053,2,"<pre><code>int result2(int base, int exponent)
{
    int i;

    for(i=1; i&lt;=exponent; i++)
    {
        result2 = result2 * base;
    }
    return;
}
</code></pre>

<p><code>result2</code> is the name of your function. Rather than using it like a variable that can accumulate the results of the loop, you should create a variable to do that job. Then return the value of the variable at the end.</p>

<pre><code>int result2(int base, int exponent)
{
    int i;
    int result = 1;

    for(i=1; i&lt;=exponent; i++)
    {
        result = result * base;
    }
    return result;
}
</code></pre>

<p>Better yet, give the function a different name. <code>result2</code> sounds like the name of a variable. The function should be named something that indicates what it does. Since <code>pow</code> is taken, how about <code>power</code>?</p>

<pre><code>int power(int base, int exponent)
{
    int result = 1;

    for (int i=1; i&lt;=exponent; i++)
    {
        result *= base;
    }

    return result;
}
</code></pre>

<p>Some other small improvements are declaring <code>int i</code> inside the <code>for</code> loop, and using <code>result *= base</code> as shorthand for <code>result = result * base</code>.</p>
",0
55737109,55737063,0,"<p>When you wrote <code>&amp;i</code> you accidentally created a pointer to <code>i</code>.  Your pointer will have type <code>int *</code>, because it is a pointer to an int.  The <code>%d</code> format specifier expects an int, not a pointer to an int, so that is why the compiler is giving you that error.  (You should re-reread that error and make sure every word of it makes complete sense to you now.)</p>

<p>The solution is to remove the erroneous <code>&amp;</code> operator:</p>

<pre><code>printf(""Enter value %d.\n"", i + 1);
</code></pre>
",1
54527886,54527854,1,"<p>You are calling <code>strlen</code> on an uninitialized buffer, which is undefined behaviour. </p>

<p><code>strlen</code> finds the length of a string by incrementing a pointer from the start of the string to the null-terminator. If your buffer is uninitialized, it may well go out of bounds in search of one.</p>

<p>Replace <code>strlen</code> with <code>sizeof</code> in your <code>snprintf</code> call.  Also replace <code>snprintf()</code> with <code>vsnprintf()</code>.</p>
",0
54672539,54672014,3,"<p>You probably want something like this:</p>

<pre><code>void excmd(const char* cmd, ...) {
  char *buf = NULL;
  va_list args;

  va_start(args, cmd);
  int sizeneeded = vsnprintf(buf, 0, cmd, args) + 1;
  va_end(args);

  buf = malloc(sizeneeded);

  va_start(args, cmd);
  vsnprintf(buf, sizeneeded, cmd, args);
  va_end(args);

  system(buf);    
  free(buf);
}
</code></pre>

<p>or</p>

<pre><code>void excmd(const char* cmd, ...) {
  va_list args;

  va_start(args, cmd);
  int sizeneeded = vsnprintf(NULL, 0, cmd, args) + 1;
  va_end(args);

  char buf[sizeneeded];

  va_start(args, cmd);
  vsnprintf(buf, sizeneeded, cmd, args);
  va_end(args);

  system(buf);    
}
</code></pre>
",3
55388512,55388414,0,"<p>This is an infinite loop:</p>

<pre><code>        while (name != ""."" || name != NULL) {
            name++;
        }
</code></pre>

<p><code>name</code> is a <code>char*</code>. Unless the interned string literal <code>"".""</code> is stored at the <code>NULL</code> address (it isn't), then you're saying the loop should continue forever, because <code>name</code> will always be either not pointing to the storage for <code>"".""</code> or not pointing to <code>NULL</code>. While I believe it's officially undefined behavior to compare unrelated pointers like <code>"".""</code> and <code>name</code>, in practice most (all flat memory model?) compilers just allow arbitrary pointer comparisons, and since you never dereference the pointer, you never actually try to read the unallocated addresses you're traversing (you'd eventually segfault if you did), so it just goes on forever.</p>

<p>I'm unclear on what the goal of that loop is (maybe stripping leading <code>.</code>s from ""hidden"" file names?), so I can't really suggest a fix other than removing it.</p>
",0
54680632,54680580,4,"<p><code>argv[0]</code> points to the program name, not the first argument. <code>argv[1]</code> points to that, if the argument is present.</p>

<p>C Standard, <a href=""https://port70.net/~nsz/c/c11/n1570.html#5.1.2.2.1"" rel=""noreferrer"">&sect; 5.1.2.2.1, Program Startup</a>:</p>

<blockquote>
  <p>If the value of argc is greater than zero, the string pointed to by <strong>argv[0] represents the program name</strong>; argv[0][0] shall be the null character if the program name is not available from the host environment. If the value of argc is greater than one, the strings pointed to by argv[1] through argv[argc-1] represent the program parameters.</p>
</blockquote>

<p>Emphasis mine.</p>
",0
55857637,55857460,1,"<p>That's just what you programmed.
In the case <code>if(x&lt;l-&gt;value)</code>, which means the list's value is greater than <code>x</code>, then you put it to <code>aux1</code>, which is <code>mx</code>. Therefore, big values end up in <code>mx</code> and smaller values end up in <code>Mx</code>.</p>

<p>To spot mistakes like these more easily, I recommend to use longer and more expressive names, e.g. <code>smallerValues</code> and <code>biggerValues</code> instead of <code>mx</code> and <code>Mx</code>. Also, I don't see the point why you're copying the pointers <code>mx</code> and <code>Mx</code> to <code>aux1</code> and <code>aux2</code>. You could just use <code>mx</code> and <code>Mx</code> directly.</p>

<p>Besides, I guess your code does not compile. You use <code>if(x&gt;=l-&gt;valor)</code>, but <code>LInt</code> does not have a member <code>valor</code> ;)</p>

<p><strike>Also, This will probably not run for more than one element per output list. You set <code>aux1=&amp;((*aux1)-&gt;next);</code> without having <code>next</code> initialized. Therefore, after that instruction, <code>aux1</code> just points ""somewhere"".</strike></p>

<p><strong>Edit</strong>: Indeed, I was confused by the typedefed pointer as @David C. Rankin said :)</p>

<p>Here is a refactored but entirely untested version:</p>

<pre class=""lang-cpp prettyprint-override""><code>typedef struct {
  int value;
  ListItem* next;
} ListItem;

void splitList(ListItem *inputList, int threshold, ListItem **smallerItems, ListItem **biggerItems) {
  while(inputList) {
    if(inputList-&gt;value &lt; threshold) {
      *smallerItems = (ListItem*)malloc(sizeof(ListItem));
      (*smallerItems)-&gt;value = value;
      smallerItems = &amp;((*smallerItems)-&gt;next);
    }
    else {
      *biggerItems = (ListItem*)malloc(sizeof(ListItem));
      (*biggerItems)-&gt;value = value;
      biggerItems = &amp;((*biggerItems)-&gt;next);
    }
    inputList = inputList-&gt;next;
  }
}
</code></pre>
",2
54717045,54715516,2,"<h2>Code fix</h2>
<p>Using you own code, you should fix <code>tail_insertion(...)</code> to be like the code below. There are comments to help understand the changes.</p>
<pre><code>Node *pNew; /* Declaring pNew *without* assignment. */

for(int i = 0; i &lt; 3; i++){
    
    pNew = (Node*) malloc(sizeof(Node)); /* Allocation of new memory address. */
    
    pNew-&gt;info  = i; /* pNew-&gt;info works like an ID in you current code. */

    pNew-&gt;pNext = NULL; /* It is proper to assign NULL */
    
    if(pFirst == NULL){
        
        pNew-&gt;info++;
        
        pFirst       = pNew;
        pLast        = pNew;
        
        printf(&quot;The list was empty.\n&quot;);
        
    } else {
        
        pNew-&gt;info++;
        
        pLast-&gt;pNext = pNew;
        pLast        = pNew;
        
        printf(&quot;The list wasn't empty.\n&quot;);
        
    }
}

print_list(pFirst);
</code></pre>
<p>Note that I have removed the <code>return(...)</code> function since it wasn't necessary. It is not necessary because <code>tail_insertion(...)</code> has the type <code>void</code>.</p>
<p>Also, <code>pNew-&gt;info</code> is storing the ID of the node as of my reading. So it shouldn't be a problem assigning <code>i</code> to it. If necessary, make the proper changes.</p>
<p>Now.. Let's begin explaining things from the beginning!</p>
<h2>General Code Analysis</h2>
<p>Let's <strong>consider</strong> <code>tail_insertion(...)</code> and what you want it to do:</p>
<ul>
<li>You create a new node;</li>
<li>You give it the right values;</li>
<li>You start a <code>for</code> loop with the intention of creating more nodes based on certain conditions;</li>
<li>You print the whole list to check if it worked;</li>
</ul>
<p>Now, look at your <strong>code for</strong> <code>tail_insertion(...)</code> <strong>function</strong> (<em>comments removed</em>):</p>
<pre><code>Node *pNew = (Node*) malloc(sizeof(Node));

pNew-&gt;info=0;
pNew-&gt;pNext= NULL;

for(int i=0; i&lt;3;i++){
    
    if(pFirst == NULL){
        
        pNew-&gt;info++;

        pFirst = pNew;
        pLast = pNew;
        
        printf(&quot;Ok, the list was empty.\n&quot;);
        
    } else {
        
        pNew-&gt;info++;

        pLast-&gt; pNext= pNew;
        pLast= pNew;
        
        printf(&quot;Ok, the list wasn't empty.\n&quot;);
        
    }
    
}

print_list(pFirst);
</code></pre>
<p>Seeing any problem yet? No? Well, let's proceed.</p>
<h2>Debugging</h2>
<p>We are going to <strong>debug this function step-by-step</strong>. Aside from program fixes, it is important for the learning process as well:</p>
<ul>
<li><strong>Creating a node</strong>:
<ul>
<li>You create <code>pNEW</code>. It is empty;</li>
<li>Let's give it the address <code>0x01</code> (fictious);</li>
<li>A <code>0</code> is assigned to <code>pNew-&gt;info</code>;</li>
<li>A <code>NULL</code> is assigned to <code>pNew-&gt;pNext</code>;</li>
</ul>
</li>
<li><strong>Beginning of the</strong> <code>for</code> <strong>loop</strong> - an attempt to create 3 nodes for a list:
<ul>
<li><code>i = 0</code>:
<ul>
<li>You check to see if the list is empty. It is:
<ul>
<li>You add <code>1</code> to <code>pNew-&gt;info</code> value. The address of <code>pNew</code> is <code>0x01</code>;</li>
<li><code>pFirst</code> is assigned to point at the address <code>0x01</code>;</li>
<li><code>pLast</code> is assigned to point at the address <code>0x01</code> since the list was empty;</li>
<li>You print a message saying the list was empty;</li>
</ul>
</li>
</ul>
</li>
<li>At the end of <code>i = 0</code>, the list is as follows:
<ul>
<li><code>pFirst</code> points at the address <code>0x01</code>;</li>
<li><code>pLast</code> points at the address <code>0x01</code>;</li>
<li><code>0x01-&gt;info</code> is <code>1</code>;</li>
</ul>
</li>
<li><code>i = 1</code>
<ul>
<li>You check to see if the list is empty. It is not:
<ul>
<li>You add <code>1</code> to <code>pNew-&gt;info</code> value. The address of <code>pNew</code> is <code>0x01</code>. There was never a creation of another node;</li>
<li><code>pLast-&gt;pNext</code> is assigned to point at the address <code>0x01</code>;</li>
<li><code>pLast</code> is assigned to point at the address <code>0x01</code>;</li>
<li>You print a message saying the list wasn't empty;</li>
</ul>
</li>
</ul>
</li>
<li>At the end of <code>i = 1</code>, the list is as follows:
<ul>
<li><code>pFirst</code> points at the address <code>0x01</code>;</li>
<li><code>pLast</code> points at the address <code>0x01</code>;</li>
<li><code>pLast-&gt;pNext</code> points at the address <code>0x01</code>;</li>
<li><code>0x01-&gt;info</code> is <code>2</code>;</li>
</ul>
</li>
<li><code>i = 2</code>
<ul>
<li>You check to see if the list is empty. It is not:
<ul>
<li>You add <code>1</code> to <code>pNew-&gt;info</code> value. The address of <code>pNew</code> is <code>0x01</code>. There was never a creation of another node;</li>
<li><code>pLast-&gt;pNext</code> is assigned to point at the address <code>0x01</code>;</li>
<li><code>pLast</code> is assigned to point at the address <code>0x01</code>;</li>
<li>You print a message saying the list wasn't empty;</li>
</ul>
</li>
</ul>
</li>
<li>At the end of <code>i = 2</code>, the list is as follows:
<ul>
<li><code>pFirst</code> points at the address <code>0x01</code>;</li>
<li><code>pLast</code> points at the address <code>0x01</code>;</li>
<li><code>pLast-&gt;pNext</code> points at the address <code>0x01</code>;</li>
<li><code>pLast-&gt;pNext-&gt;pNext</code> points at the address <code>0x01</code>;</li>
<li><code>0x01-&gt;info</code> is <code>3</code>;</li>
</ul>
</li>
<li>End of the <code>for</code> loop;</li>
</ul>
</li>
<li><strong>Printing the resulting list</strong>:
<ul>
<li>A call for <code>print_list(...)</code></li>
</ul>
</li>
</ul>
<h2>Conclusion</h2>
<p>As of now, you probably saw <strong>what's wrong</strong>: you haven't created a new node inside the <code>for</code> loop. You created it outside of the loop. This makes a repetitive process of <strong>adding the very same node with the same address to the list</strong>.</p>
<p>Also, you are having problems with the value of <code>info</code>. But that is thanks to using the same node as stated above. It will need just some adjusting in this incremental logic that sets <code>info</code> value to accommodate the modifications need to fix the usage of the same node and make everything work.</p>
<h2>Final Notes</h2>
<p>There are comments saying you don't need <code>pLast</code>. While that is true, you need to consider:</p>
<ul>
<li>If you only use <code>pFirst</code>, you need to make sure that after inserting the new node in <code>pFirst-&gt;pNext</code>, you do a <code>pFirst-&gt;pNext-&gt;pNext = NULL</code>. This way you can know whenever you have reached the end of the list by comparing to <code>NULL</code>;</li>
<li>If you continue to use <code>pLast</code>, you can compare to <code>pLast</code> to know if the address is the last address inside the list. Obviously, you can also compare to NULL after my fix;</li>
<li><strong>Considering tail insertions</strong>, having <code>pLast</code> facilitates things quite a bit and reduces CPU usage in the long run;</li>
</ul>
<p>You probably know but you should put <code>print_list(pFirst);</code> inside the <code>main(...)</code> function to makes things more organized. Also, it makes my &quot;code OCD&quot; reach new levels of desperation! ;-)</p>
",2
56409291,56409212,3,"<p>When you print a <code>char</code> using <code>printf</code>, it's <a href=""https://en.wikipedia.org/wiki/ASCII"" rel=""nofollow noreferrer"">ASCII</a> value is used. In this specific case, you could use</p>

<pre><code>string[0] = (char) (start + '0');
string[1] = '/';
string[2] = (char) (finish + '0');
</code></pre>

<p>Or you could use <code>string[0] = (char) start + 48;</code>. The ASCII value of '0' is 48.</p>

<p>Or better initialize <code>start</code> and <code>finish</code> as <code>char start = '0'</code>, <code>char finish = '5'</code>, etc.</p>

<p>In addition, make sure that <code>start</code> and <code>finish</code> are between <code>0</code> and <code>9</code>. Other values, will give you unexpected results.</p>

<p>Also, the last line should be <code>string[3] = '\0'</code>. <code>strlen</code> works by iterating till it encounters a <code>\0</code> and thus is useless in this case.</p>

<p><a href=""https://ideone.com/1TUYID"" rel=""nofollow noreferrer"">Demo</a></p>
",1
56381737,56380992,1,"<p>Highly recommend you just malloc/memset your structure instead of doing the hacky pointer thing.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define EDGE        ( 10 )
#define TOTAL_CELLS ( EDGE * EDGE )

int main()
{
    int i;
    char * fabric = malloc(TOTAL_CELLS);
    memset(fabric,'x',TOTAL_CELLS);


    for(i=0; i&lt;TOTAL_CELLS; i++){
        printf(""%c"",fabric[i]);
    }

    return 0;
}
</code></pre>

<p>If you still want to reference the 2D array-like structure (<code>fabric[i][j]</code>), you can do it in a 1D array just as easily (<code>fabric[i*EDGE+j]</code>), and its easier to manipulate that linear memory block.</p>
",0
54840532,54840496,3,"<p>The line</p>

<pre><code>int ifPrime=1;
</code></pre>

<p>must be inside the outer <code>for</code> loop. There it will be initialized for every <code>i</code>. This corresponds to the natural language words ""to check whether a number i is prime, first assume it is. Then check if it is divisible"". The code you had before said ""to check whether the numbers 2 to 1000 are prime, first assume they are"", and this wording was too broad.</p>

<p>The code should be:</p>

<pre><code>int main()
{
    for (int i = 2; i &lt; 1000; i++)
    {
        int ifPrime = 1;
        for (int j = 2; j &lt; i; j++)
</code></pre>

<p>I replaced <code>main</code> with <code>int main</code> since that is required since 20 years. (You should not learn programming from such old books.)</p>

<p>I moved the <code>int i</code> and the <code>int j</code> into the <code>for</code> loops so that you cannot accidentally use these variables outside the scope where they have defined values.</p>

<p>To avoid this bug in the future, it's a good idea to extract the <code>is_prime</code> calculation into a separate function. Then you would have been forced to initialize the <code>ifPrime</code> in the correct place.</p>

<p>Another way of finding the cause of this bug is to step through the code using a debugger and ask yourself at every step: does it still make sense what the program is doing?</p>
",0
54887105,54886742,2,"<p>Your code is wrong. You were trying to make a staet machine which basically is the correct approach, but you failed because there are two problems in these lines:</p>

<pre><code>while(c=' ')
  state=0;
</code></pre>

<p>First you certainly wanted to write <code>while(c == ' ')</code>, and your compiler probably warned you about this.</p>

<p>But even this is wrong:</p>

<pre><code>while(c == ' ')
  state=0;
</code></pre>

<p>This loop will never finish if the condition <code>c == ' '</code> is true.</p>

<p>What you need is this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
  int c;
  int spaceread = 1;

  while ((c = getchar()) != EOF) {
    if (c != ' ')
      spaceread = 0;   // something else than space =&gt; process normally
    else
    {
      // space char has been read

      if (spaceread)   // if a space has been read previously =&gt; do nothing,
        continue;      // just continue to read the next character.

      spaceread = 1;   // remember we've read a space
    }

    putchar(c);        // print character
  }
}
</code></pre>
",1
55330223,55330189,1,"<p>functions in parameters to <code>printf</code> are called before the <code>printf</code> itself. Since both calls return address to the same buffer, the last call creates its contents. (there is no defined order in which functions in parameters are called). </p>

<p>As a result you call printf with 3 args, where the last 2 have the same pointer to the same buffer with the same content.</p>
",1
59276779,59276687,0,"<p>You can use <code>sprintf</code> to write formatted output to a string (or better <code>snprintf</code> to avoid buffer overflows):</p>

<pre><code>int main() {
    int valeur=5;
    int score=10;
    char array[100];
    snprintf(array, sizeof(array), ""Bravo vous avez gagn¨¦ %d points (total: %d)"",valeur,score);
    printf(""%s\n"",array);

    //output :
    //Bravo vous avez gagn¨¦ 5 points (total: 10)
}
</code></pre>
",0
54954214,54953892,0,"<p>The <code>strlen</code> function is only for strings. In your code, <code>choice</code> is an array of one character, not a string. And <code>sendChoice</code> is a pointer to that single character.</p>

<p>The data length is one. You can just pass <code>1</code> as the size or you can use <code>sizeof(choice)</code>. Do not use <code>sizeof(sendChoice)</code> as that would be the size of the pointer! You cannot use <code>strlen</code> because you do not have a string.</p>

<p>If you think about it, there is no way <code>strlen</code> could tell just from the pointer you passed to it that it only pointed to a single character. So <code>strlen</code> could only work by some kind of magic.</p>

<p>Also, check the documentation for <code>send</code>. It will tell you how to get a useful error code when <code>send</code> fails that will help you troubleshoot in the future.</p>
",0
56621285,56621253,4,"<p>It is a standard feature, but it has nothing to do with constant arrays. It only works for string literals.</p>

<p>The C standard defines a number of ""translation phases"". Phase 6 is:</p>

<blockquote>
  <ol start=""6"">
  <li>Adjacent string literal tokens are concatenated.</li>
  </ol>
</blockquote>

<p>See e.g. <strong>5.1.1.2 Translation phases</strong> in <a href=""https://web.archive.org/web/20181230041359if_/http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf"" rel=""nofollow noreferrer"">this draft standard</a>.</p>
",2
55061708,55060443,1,"<p>You have to write (and to read) in two steps: first the struct, and then the array the struct points to. 
Code fragment for writing (a.o. without error checking, that is however needed):</p>

<pre><code>#include &lt;stdio.h&gt;
// ...
employees emp;
const char* filename=""your_filename"";
// populate emp;
FILE* file = fopen(filename,""w"");
fwrite(&amp;emp,sizeof(employees),1,file);
fwrite(emp.pic,sizeof(int),emp.imageCount,file);
fclose(file);
</code></pre>

<p>Now you have the array after the struct in your file. Read it in the same way:</p>

<pre><code>FILE* file = fopen(filename,""r"");
fread(&amp;emp,sizeof(employees),1,file);
emp.pic=calloc(sizeof(int), emp.imageCount); 
fread(emp.pic,sizeof(int),emp.imageCount,file);
</code></pre>

<p>Please don't forget to check for errors (see <code>man fopen|fread|fwrite|calloc</code>). In case you have several structs, you must repeat the two steps for any element.</p>
",2
55113265,55113199,2,"<p>With respect to your current code:</p>

<pre><code>void pushBack(List *list, int *data)
{
    Node *node = createNode(data);
    while ( list -&gt; head )
        list -&gt; head = list -&gt; head -&gt; next;
    list -&gt; head = node;
    list -&gt; size ++;
}
</code></pre>

<p>Pushing something on to the back of a list should only ever change the head <strong><em>if the list was previously empty.</em></strong> What you're doing is actually corrupting the list by moving its head where it should not be.</p>

<p>You <em>may</em> have meant to use <code>current</code> rather than <code>head</code> (after first setting it to <code>head</code> of course) but it's unusual to dedicate a field for that within the list itself - you usually just use a temporary variable.</p>

<p>You would be far better off storing the tail as well so that you don't have to search for it each time<sup>(a)</sup>. But, assuming that's not an option, the following pseudo-code should help you out:</p>

<pre><code>def push_back(list, item):
    # Force tail constraints, new tail must be end of list.

    item.next = null

    # If list empty, simply set head.

    if list.head == null:
        list.head = item
        return

    # Find last element in list:

    curr = list.head
    while curr.next != null:
        curr = curr.next

    # Now have last, just attach new item to it.

    curr.next = item
</code></pre>

<p>Turning that into C, I'll leave as an exercise for the reader. You should be doing at least <em>some</em> of your homework :-)</p>

<hr>

<p><sup>(a)</sup> If you're interested in how to do that, see below:</p>

<pre><code>def push_back(list, item):
    # Force tail constraints, new tail must be end of list.

    item.next = null

    # If list empty, simply set head/tail.

    if list.head == null:
        list.head = item
        list.tail = item
        return

    # In non-empty list, tail will always be last element.

    curr.tail.next = item   # Point current tail to new tail.
    curr.tail = item        # Update tail
</code></pre>
",0
55346582,55346536,2,"<p>You are instructing <code>printf</code> to output the value as an integer.  To output a character, you need to use <code>%c</code> format specifier.</p>

<p>It is also preferable to use character constants instead of hard-coded numbers, for clarity.  And, while not strictly necessary for <code>printf</code>, your <code>lucky</code> type should probably be <code>char</code> since you intend it to represent a character:</p>

<pre><code>char lucky = (rand() % 26) + 'A';
printf(""&gt; %c"", lucky);
</code></pre>
",5
55538229,55537849,0,"<pre class=""lang-c prettyprint-override""><code>void print_nth_word (const char *sentence, int n) {
    int word_no = 0;
    char ch, lch = ' ';

    while (ch = *sentence++) {
        if (ch == ' ' || word_no != n) printf (""%c"", '.');
        else printf (""%c"", ch);

        if (ch == ' ' &amp;&amp; lch != ' ') word_no++;
        lch = ch;
    }
}
</code></pre>

<p>I replaced <code>'\0'</code> with <code>'.'</code> to make results visible.</p>

<p>Invocation:</p>

<pre><code>print_nth_word (""e il cie                       enta traspare   e"", i)
</code></pre>

<p>Output:</p>

<pre><code>.....cie........................................
</code></pre>
",3
56339954,56339482,0,"<p>AT-command manual describes ""URL"" in the following way:</p>

<pre><code>""http://'server'/'path':'tcpPort'"" 
</code></pre>

<p>In your command, the 'path' is missing:</p>

<pre><code>AT+HTTPPARA=""URL"",""http://procedure.xxxxtech.com:1234""
</code></pre>

<p>Could you try to add path of your default page to the url. For example:</p>

<pre><code>AT+HTTPPARA=""URL"",""http://procedure.xxxxtech.com/index.html:1234""
</code></pre>
",1
55566583,55566505,4,"<p>The issue is that the code is finding the number of bytes in the file with <code>ftell()</code>, and then allocating whatever <code>size</code> amount that data is.</p>

<p>However, when then reading from the file, it's trying to read four times as much data, because of the <em>count-of-elements</em>, and <em>size-of-elements</em> passed to <code>fread()</code>.  </p>

<p>If the input file was a big block of binary longs (in the same format as the local hardware), it's possible to just <code>fread()</code> the lot in a single go.  This means your size is the <code>ftell()</code> result, but the count-of-elements is <strong>one</strong>.</p>

<pre><code>fseek( fp, 0, SEEK_END );
size = ftell( fp );
arr = ( long * ) malloc( size );
count = fread( arr, size, 1, fp );  // read the whole block in a single go
</code></pre>
",0
55566580,55566505,3,"<p>There are a lot of issues here and I think this isn¡¯t the actual code even. The ones immediately noticeable:</p>

<ul>
<li><p>you¡¯re trying to open a file called <code>argv[1]</code>, not the filename given in command line. Drop the quotes. </p></li>
<li><p>you allocate memory for <code>size</code> bytes, then try to read <code>size * 4</code> bytes and don¡¯t check how many were read</p></li>
<li><p>don¡¯t cast the return value of <code>malloc</code></p></li>
<li><p><code>sizeof arr</code> only gives you the size of a pointer, not the data you have. You have <code>size</code>, use it. </p></li>
<li><p>your while loop has a new variable with the same name as outside, neither is ever changed so the loop is eternal </p></li>
<li><p>if you can¡¯t open a file you free an unassigned pointer</p></li>
</ul>

<p>So check your compiler¡¯s warnings. Think about what you¡¯re doing, what the parameters you give to functions mean. Check return values. Use a debugger to step through the code line by line. </p>

<p>The exact cause can only be determined after you fix the other problems, and might even get fixed by that. If this is the exact code then the last one is probably the reason. A debugger will tell you. </p>
",0
55566797,55566505,3,"<p>There are a bunch of things that needs attention in no particular order of severity</p>

<ul>
<li><em>always validate arguments</em></li>
</ul>

<p>your program doesn't seem to validate arguments which is kind of bad, a quick statement at the start will do the job</p>

<pre><code> /* Always do some argument checking, Assuming in your case command line is 2 */
    if ( argc != 2 ) 
    {
        printf(""Invalid arguments "");
        printf(""Usage %s &lt;filename&gt;\n"", argv[0]);
        exit(0);
    }
</code></pre>

<ul>
<li><em>always check return values</em></li>
</ul>

<p>Almost always its a good Idea to check for return values and validate them, there are of course some exceptions <code>printf</code> for example but cases like <code>fopen</code>, <code>malloc</code> its a crime to not check for return values</p>

<pre><code>/* Return Type Validations are mandatory */
    fp  = fopen( argv[1], ""r"" );
    if( fp == NULL )
    {
        printf(""Error Opening file %s\n"", argv[1]);
        exit(0);
    }
</code></pre>

<ul>
<li><em>Do not cast malloc result</em></li>
</ul>

<p>This is a popular one <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">Do I cast the result of malloc</a> the answer is no</p>

<ul>
<li><em><code>fread</code></em></li>
</ul>

<p>This probably down to misunderstanding function behavior, from <a href=""http://man7.org/linux/man-pages/man3/fread.3.html"" rel=""nofollow noreferrer"">man fread</a></p>

<pre><code>The function fread() reads nmemb items of data, each size bytes long,
       from the stream pointed to by stream, storing them at the location
       given by ptr.
</code></pre>

<p>you are essentially reading 4 times the data your need by writing statement like</p>

<pre><code>count = fread( arr, size, 4, fp );
</code></pre>

<ul>
<li><p><em>mixing <code>local</code> and <code>global</code> scopes</em></p>

<p>There are multiple declarations of variable <code>i</code> in local ( inside <code>for loop</code>) and global scope do not do that. </p></li>
<li><p><em>Careful while using <code>sizeof()</code> for poniters</em></p></li>
</ul>

<p>this statement <code>sizeof( arr )</code> always gives the size of pointer and not the sizeof data pointed by the pointer, the below statement </p>

<pre><code>Quicksort( arr, 0, sizeof( arr ) / sizeof( int ) - 1 );
</code></pre>

<p>did not make much sense to me, and there is no way I can evaluate if that is really a valid in context of your program.</p>
",0
55665472,55665297,2,"<p>With the assignment</p>

<pre><code>buffer = tmp
</code></pre>

<p>you have two pointer pointing to the very same memory. It could be looked at something like this:</p>

<pre>
   +-----+
   | tmp | --\ 
   +-----+    \     +--------------------------------+
               >--> | memory allocated by realloc... |
+--------+    /     +--------------------------------+
| buffer | --/
+--------+
</pre>

<p>Since you only have a single allocation, the call</p>

<pre><code>free(tmp);
</code></pre>

<p>will free that single allocation. After that call to <code>free</code> you have something like</p>

<pre>
   +-----+
   | tmp | --\ 
   +-----+    \     +-----------------------+
               >--> | unallocated memory... |
+--------+    /     +-----------------------+
| buffer | --/
+--------+
</pre>

<p>That means any dereference of <code>buffer</code> will be invalid since it <em>also</em> points to that unallocated memory. And of course any further call to <code>realloc</code> is invalid as well, since there's nothing to reallocate.</p>

<p>The solution is simple: Don't call <code>free</code> in the loop.</p>
",0
55771921,55771847,1,"<p>This loop:</p>

<pre><code>while((c = getc(f))){
    ...
}
</code></pre>

<p>will terminate only when <code>getc()</code> returns zero, i.e., when it reads a null character <code>'\0'</code>. And when it returns <code>EOF</code> you'll store that value (converted to <code>char</code>) in <code>s[i]</code> and continue looping.</p>

<p>The test for <code>EOF</code> <em>after</em> the loop will never match.</p>

<p>You need to end the loop when it returns <code>EOF</code>. The usual idiom is:</p>

<pre><code>while ((c = getc(f)) != EOF) {
    ...
}
</code></pre>
",4
57121464,57117111,1,"<p>Don't write to string constants. Write to string arrays. Yes I know they're of type <code>char*</code> for legacy reasons so the compiler won't catch you if you do this.</p>

<p>Do not write:</p>

<pre><code>void main(){
    return invertir(""parlante"");
}
</code></pre>

<p>write:</p>

<pre><code>void main(){
    char string[] = ""parlante""
    invertir(string);
    puts(string);
}
</code></pre>

<p>Also, your program clearly doesn't compile because <code>return void</code>;</p>
",3
55972285,55972054,0,"<p>There are many issues:</p>

<pre><code>    FILE *fptr;   // here fptr points nowhere
    return ex3(fptr);
</code></pre>

<p>You pass an invalid pointer to <code>ex3</code> and you dereference ith there. But declaring your <code>fptr</code> outside <code>ex3</code> is pointless anyway.</p>

<hr>

<p><code>singlePerson</code> is never initialized, it points nowhere. You probably want this:</p>

<pre><code>Person singlePerson;
</code></pre>

<p>instead of</p>

<pre><code>Person *singlePerson;
</code></pre>

<p>and call <code>fwrite</code> like this:</p>

<pre><code>fread(&amp;singlePerson, sizeof(Person), 1, fptr);
</code></pre>

<hr>
",0
55972209,55972054,2,"<p><code>singlePerson</code> doesn't point anywhere:</p>

<pre><code>Person *singlePerson;
...
fread(singlePerson, sizeof(Person), 1, fptr);
</code></pre>

<p>So <code>fread</code> is attempting to read and dereference an uninitialized pointer.  This invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>, which in your case manifests as crashing sometimes but not others.</p>

<p>You don't need a pointer here.  Just declare <code>singlePerson</code> as an instance of <code>Person</code> and pass its address.</p>

<pre><code>Person singlePerson;
...
fread(&amp;singlePerson, sizeof(Person), 1, fptr);
</code></pre>
",2
56307166,56307004,1,"<p><code>enter code here</code>    void change(int*);</p>

<pre><code>int main(void){
    int array[1] = {2};

    printf(""%d\n"", array[0]);
    change(array);
    printf(""%d\n"", array[0]);
}

void change(int* array)
{
    array[0] = 4;
    *(array + 0) = 4;
}
</code></pre>

<p>don't put '&amp;' in array. it is pointer. so you must change your function ""change(int ...) to change(int* )""</p>

<p>and to change array[0] you don't need to put * on array. it's an array!. or to use * . then you must add n-th element number.</p>
",0
58603509,58603256,3,"<p>The <code>cont:</code> is a label, which would be used by <code>goto</code>. 
I believe it appears in this snippet to explain the difference between <code>for</code> and <code>while</code>: when you use <code>continue</code> in a <code>for</code> loop, it is equivalent to using <code>goto cont</code> in a <code>while</code> loop, not <code>continue</code>.</p>

<p>Please check the next paragraph, <strong>Jump statements</strong>. The label <code>cont:</code> was put to use there.</p>

<blockquote>
  <p>A <code>continue</code> statement may appear only within an iteration statement and
  causes control to pass to the loop-continuation portion of the
  innermost enclosing iteration statement. That is, within each of the
  statements</p>
</blockquote>

<pre><code> while (expression) {
     /* ... */
     cont: ; }

 do {
     /* ... */
     cont: ; } while (expression);

 for (expr1; expr2; expr3) {
      /* ... */
      cont: ; } 
</code></pre>

<blockquote>
  <p>a <code>continue</code> not contained within a nested iteration statement is the same as <code>goto cont</code>.</p>
</blockquote>
",1
56150122,56150093,2,"<p>The problem is a misplaced semi colon here <code>if ( hours &gt; 40 );</code> just remove the semi colon.  It's good practice to indent the code properly to help detect these kind of errors.</p>
",5
56498229,56497436,0,"<p>Stopping at end of file with scanf is easy.</p>

<pre><code>a=fscanf(fp,""%s | %s | %d"",(p+i)-&gt;name,(p+i)-&gt;last_name,&amp;(p+i)-&gt;number);

if (a != 3) {
     /* handle eof; */
     break;
}
</code></pre>

<p>There's a lot of stuff yet to do involving malformed files and reading the file once while growing your array, but hey baby steps man. You will reach that eof block on any IO or format error as well.</p>
",0
56483915,56483866,0,"<p>The <code>execve</code> function expects three arguments but you're passing two arguments.  Hence the error message.</p>

<p>You seem to be under the impression that passing an array to a function means that each element of the array becomes an argument to the function, but that is not the case.</p>

<p>The function is declared as follows:</p>

<pre><code>int execve(const char *filename, char *const argv[], char *const envp[]);
</code></pre>

<p>The first argument is the command to run, the second is an array of arguments, and the third is an array of environment variables.  If you're not interested in passing environment variables, use <code>execv</code> instead which doesn't have the third argument.</p>
",1
56300885,56300778,2,"<p>When you pass an array to a function (or use it in a myriad of other ways), it decays into a pointer to the first element of that array<sup>(a)</sup>.</p>

<p>That means it will be a pointer, with the <em>size</em> of a pointer, <em>not</em> the size of the original array.</p>

<p>If you want to know the size, you'll have to work that out while it's still an array and pass that as well, something like:</p>

<pre><code>void print_arry (int *nums, size_t sz) {
    printf (""%z:"", sz);
    for (size_t i = 0; i &lt; sz; ++i) {
        printf ("" %d"", nums[i]);
    }
    putchar ('\n');
}
:
print_arry (nums, sizeof(nums) / sizeof(*nums));
</code></pre>

<hr>

<p><sup>(a)</sup> See, for example, <code>C11 6.3.2.1 Lvalues, arrays, and function designators /3</code>:</p>

<blockquote>
  <p>Except when it is the operand of the <code>sizeof</code> operator, the <code>_Alignof</code> operator, or the unary <code>&amp;</code> operator, or is a string literal used to initialize an array, an expression that has type ""array of type"" is <strong><em>converted to an expression with type ""pointer to type"" that points to the initial element of the array object</em></strong> and is not an lvalue. If the array object has register storage class, the behavior is undefined.</p>
</blockquote>
",0
56307233,56307037,2,"<p>Presuming your board is declared as follows:</p>

<pre><code>char tttarray[3][3];
</code></pre>

<p>Then to print out any single row, like the first row would be as follows:</p>

<pre><code>printf(""%c %c %c\n"", tttarray[0][0], tttarray[0][1], tttarray[0][2]);
</code></pre>

<p>Printing out the second and third row:</p>

<pre><code>printf(""%c %c %c\n"", tttarray[1][0], tttarray[1][1], tttarray[1][2]);
printf(""%c %c %c\n"", tttarray[2][0], tttarray[2][1], tttarray[2][2]);
</code></pre>
",0
56307672,56307345,1,"<p>Error is in this line in <code>main</code>:- </p>

<pre><code>sutuntopla(a[5][6],6);
</code></pre>

<p>You just need to pass <code>a</code> to your function. <code>a[5][6]</code> tries to access the element at that particular location which is of type <code>int</code> to function expecting <code>int[][]</code> and also causes index out of bounds. </p>
",2
56587959,56587883,4,"<p>I think what you're stumbling on is the distinction between the return value and <code>errno</code>.  <code>errno</code> is a global variable, declared in <code>errno.h</code>.  What you want is something like:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

int main(void)
{
    char directory[100];
    scanf(""%[^\n]"", directory);

    if (chdir(directory) != 0) {
        switch (errno) {
          case EACCES:
            perror(""\nError "");
            break;
          /*  ... */
        }
    }
}
</code></pre>

<p>It's also a bit weird that you have a bunch of cases in your switch that do the exact same thing¡­ I'm assuming that's because they're just stubs and you really want to handle different errors differently in your code, but if not you can drop the switch and just do something like</p>

<pre><code>if (chdir(directory) != 0) {
    perror(""\nError "");
    exit(EXIT_FAILURE);
}
</code></pre>
",0
57797240,57797019,1,"<p>you shouldn't read a character at a time, use <code>fscanf()</code> to read whole integers from the file. It will parse the numbers and skip over whitespace between them.</p>

<pre><code>int i = 0;
while(fscanf(matrixA, ""%d"", &amp;a[i]) == 1) {
  printf(""%d "", a[i]);
  i++;
}
printf(""\n"");
</code></pre>
",0
56416372,56415149,2,"<p>You declared a char but you're treating it like a string. In C, strings are actually one-dimensional arrays of chars, with a null character '\0' at the end.</p>

<p>The following:</p>

<pre><code>""my fun string""
</code></pre>

<p>equates to this in C:</p>

<pre><code>{'m', 'y', ' ', 'f', 'u', 'n', ' ', 's', 't', 'r', 'i', 'n', 'g', '\0'}
</code></pre>

<p>You need to allocate a char array large enough for the name. Something like the following: </p>

<p><code>int max_size=120; char name[max_size];</code></p>

<p>so your code should look like this:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int age;

    int max_size=120;
    char name[max_size];
    printf(""Enter your age here: "");
    scanf(""%d"", &amp;age);
    printf(""Your age is %d.\n"", age);

    printf(""enter your name here: \n"");
    scanf(""%s"", &amp;name);

    printf(""Your name is %s and your age is %d.\n"", name, age);

    return 0;
}
</code></pre>

<p>Additionally, you probably shouldn't use <code>scanf()</code>. <code>fgets()</code> is preferable.</p>
",3
58280227,58280197,4,"<p>You have unnecessary code, which resulted in more places to make a mistake.</p>

<p>After <code>sprintf_s(str, ""%x"", i)</code>, <code>str</code> contains the hex representation of <code>i</code>. Then <code>printf_s(""%x"", str);</code> prints out the <code>str</code> <em>pointer</em> as a hex number.</p>

<p>The minimal fix is to change the latter line to <code>printf_s(""%s"", str)</code> to output the <em>content</em> of the string <code>str</code>.</p>

<p>The better way would be to just directly print out the hex value, without going through <code>str</code> at all. Replace both lines with just <code>printf_s(""%x"", i)</code>.</p>
",0
56422643,56422548,2,"<p>If I understand you correctly, you want to only call <code>showCnt</code> as</p>

<pre><code>showCnt(function);
</code></pre>

<p>and it should print both <code>teams.female</code> and <code>teams.male</code>?</p>

<p>Then to begin with remove the (<em>erroneous</em>) <code>count</code> argument from the function <code>showCnt</code>. Then inside the loop of <code>showCnt</code> call <code>function</code> <em>twice</em> with <code>teams[n].female</code> and <code>teams[n].male</code>.</p>
",2
56422643,56422548,2,"<p>If I understand you correctly, you want to only call <code>showCnt</code> as</p>

<pre><code>showCnt(function);
</code></pre>

<p>and it should print both <code>teams.female</code> and <code>teams.male</code>?</p>

<p>Then to begin with remove the (<em>erroneous</em>) <code>count</code> argument from the function <code>showCnt</code>. Then inside the loop of <code>showCnt</code> call <code>function</code> <em>twice</em> with <code>teams[n].female</code> and <code>teams[n].male</code>.</p>
",2
59179068,59179029,0,"<p>The mistake you did here is doing:</p>

<pre><code>*ptr1=a;
*ptr2=b;
</code></pre>

<p>you're trying to dereference unitialized pointers, pointing to indeterminate memory location, which are invalid. This invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behaviour</a>.</p>

<p>You need to ensure that the pointers are pointing to valid memory location before you can dereference them.</p>

<p>In your case, it looks like you want the pointers to point to the variables, so changing the code to be</p>

<pre><code>ptr1 = &amp;a;
ptr2 = &amp;b;
</code></pre>

<p>should do.</p>
",0
59179053,59179029,3,"<p><code>*ptr1 = a;</code> and <code>*ptr2 = b;</code> are your errors, and really you should check that the return value of <code>scanf</code> is 2 to indicate that both variables were set to something.</p>

<p>Neither <code>ptr1</code> nor <code>ptr2</code> point to anything when the deferences are attempted, so the behaviour on dereferencing them is undefined. A core dump is a manifestation of that undefined behaviour.</p>

<p>Did you want <code>ptr1 = &amp;a;</code> and <code>ptr2 = &amp;b;</code>? Or call more simply with</p>

<pre><code>swap(&amp;a, &amp;b);
</code></pre>
",0
56510312,56507800,0,"<p>A pointer points to a memory address. When declared and initialized as <code>int *ptr=x;</code>, <code>ptr</code> is assigned the memory address where the first element of <code>x</code> starts in memory. So if <code>x</code> consists of three 4-byte integers which contain the decimal values 10, 20, 30 and the lowest byte address of the first integer begins at address 0x1010, <code>ptr</code> would be assigned the value 0x1010, and the memory addresses occupied by <code>x</code> would look like</p>

<pre><code>Addr |1010|1011|1012|1013|1014|1015|1016|1017|1018|1019|101A|101B|
     +====+====+====+====+====+====+====+====+====+====+====+====+
Val  | 0A | 00 | 00 | 00 | 14 | 00 | 00 | 00 | 1E | 00 | 00 | 00 |
     +====+====+====+====+====+====+====+====+====+====+====+====+
</code></pre>

<p>(All addresses and values above are shown in hexadecimal)</p>

<p>The above assumes a ""little-endian"" architecture, such as the Intel x86, where the low-order byte of a multibyte integer is stored in the low-order address. (Other orderings of multibyte integers in memory are used on other architectures but I won't address them here).</p>

<p>I hope this helps.</p>
",0
56508067,56507800,-1,"<p>A pointer points to <em>an address</em>. To convince yourself, you could print the different addresses of the different element of the array by using the <code>%p</code> flag in printf.</p>

<pre><code>printf(""%p\n"", ptr[0]);
printf(""%p\n"", ptr[1]);
printf(""%p\n"", ptr[2]);
</code></pre>
",5
56522294,56522223,0,"<p>The <code>pow</code> function operates on doubles. Doubles use finite precision. Conversion back to integer chops rather than rounding.</p>

<p>Finite precision is like representing 1/3 as <code>0.333333</code>. If you do <code>9 * 1/3</code> and chop to an integer, you'll get 2 instead of 3 because <code>9 * 1/3</code> will give <code>2.999997</code> which chops to two.</p>

<p>This same kind of rounding and chopping is causing you to be off by one. You could also round by adding 0.5 before chopping to an integer, but I wouldn't suggest it.</p>

<p>Don't pass integers through doubles and back if you expect exact answers.</p>
",3
58821039,58820913,2,"<p>The reason is that the <code>static</code> functions cannot be seen from other translation units. Remove the <code>static</code> declaration, and it will link.</p>

<p>The name of your question also mentions shared variables. If you want to share a variable between translation units, make sure to declare it as <code>extern</code> in your header file, and to define it exactly once in one of your source code files.</p>
",8
56603109,56603083,1,"<p>It causes the function (not the program, just that function) to terminate w/o doing anything further.</p>
",0
56603118,56603083,2,"<p>The <code>return</code> statement when encountered causes the function to return immediately instead of continuing to run any code that comes after it.</p>

<p>If the function returns a value, the <code>return</code> statement must specify a value to return.  For a function with a <code>void</code> return type, no value is needed.</p>
",2
56683909,56668557,1,"<p>The answer to the question of where arrays, or indeed any variables, are stored depends on whether you are considering the abstract machine or the real hardware. The C standard specifies how things work on the abstract machine, but a conforming compiler is free to do something else on the real hardware (e.g., due to optimization) if the <em>observable effects</em> are the same.</p>

<p>(On the abstract machine, arrays are generally stored in the same place as other variables declared in the same scope would be.)</p>

<p>For example, a variable might be placed in a register instead of the stack, or it might be optimized away completely. As a programmer you generally shouldn't care about this, since you can also just consider the abstract machine. (Admittedly there may be some cases where you do care about it, and on microcontrollers with very limited RAM one reason might be that you have to be very frugal about using the stack, etc.)</p>

<p>As for your code for reading the memory: it cannot possibly work. If <code>size</code> is the size of the memory available to variables, you cannot fit the array <code>bufferf[size]</code> in that memory <em>together with everything else</em>.</p>

<p>Fortunately, copying the contents of the memory to a separate buffer is not needed. Consider your line <code>bufferf[e] = *(mem_start + e)</code> ¨C since you can already read an arbitrary index <code>e</code> from memory at <code>mem_start</code>, you can use <code>*(mem_start + e)</code> (or, better, <code>mem_start[e]</code>, which is exactly equivalent) directly everywhere you would use <code>bufferf[e]</code>! Just treat <code>mem_start</code> as pointing to the first element of an array of <code>size</code> bytes.</p>

<p>Also note that if you are programmatically searching for the contents of the array <code>tab</code>, its elements are <code>int</code>s, so they are more than one byte each ¨C you won't simply find five adjacent bytes with those values.</p>

<p>(Then again, you can also just take the address of <code>tab[0]</code> and find out where it is stored, i.e., <code>((unsigned char *) tab) - mem_start</code> is the index of <code>tab</code> in <code>mem_start</code>. However, here observing it may change things due to the aforementioned optimization.)</p>
",1
56668890,56668557,1,"<pre><code>global variable is stored in memory, and the local variable is saved in the stack
</code></pre>

<p>This is false.  </p>

<p>Global variables are sometimes kept in registers, not only in static memory.</p>

<p>If the function is recursive the compiler may choose to use the stack or not.  If the function is tail recursive it is no need to use the stack as there is no continuation after the function returns and one can use the current frame for the next call.</p>

<p>There are mechanical methods to convert the code in continuation passing style and in this equivalent form <a href=""http://matt.might.net/articles/cps-conversion/"" rel=""nofollow noreferrer"">it is evaluated stackless</a>.</p>

<p>There are lots of mathematical models of computation and not all use the stack.  The code can be <a href=""https://en.wikipedia.org/wiki/Turing_machine_equivalents"" rel=""nofollow noreferrer"">converted from one model to other</a> keeping the same result after evaluation.</p>

<p>You got these informations from books written in the 70s, 80s and in the meantime the process of evaluation of code was much improved (using methods that were theoretical in the 30s but nowadays are implemented in systems).</p>
",2
56704623,56704518,2,"<p>Take your <code>return 0;</code> outside the <code>for</code> loop.</p>
",0
56856913,56855176,1,"<p>In a <em>declaration</em>, the unary <code>*</code> indicates that the thing being declared has pointer type:</p>

<pre><code>T *p;       // p has type ""pointer to T""
T *p[N];    // p has type ""array of pointer to T""
T (*p)[N];  // p has type ""pointer to array of T""
T *p();     // p has type ""function returning pointer to T""
T (*p)();   // p has type ""pointer to function returning T""
</code></pre>

<p>The subscript <code>[]</code> and function call <code>()</code> operators have higher precedence than unary <code>*</code>, so an expression like <code>*p[i]</code> will be parsed as <code>*(p[i])</code>; you're dereferencing the result of <code>p[i]</code>.  If <code>p</code> is a pointer to an array of something, then you have to write <code>(*p)[i]</code> - you need to dereference <code>p</code> and than subscript into the result.</p>

<p>You can have multiple levels of indirection:</p>

<pre><code>T **p;           // p has type ""pointer to pointer to T""
T ***p;          // p has type ""pointer to pointer to pointer to T""
T *(*p)[N];      // p has type ""pointer to array of pointer to T""
T *(*(*p)())[N]; // p is a pointer to a function returning a pointer
                 // to an N-element array of pointer to T
</code></pre>

<p>In an <em>expression</em>, the unary <code>*</code> operator dereferences the pointer to access the pointed-to object, as in your example.  Again, you can have multiple levels of indirection:</p>

<pre><code>int x = 10;    
int *p = &amp;x;    // p stores the address of x
int **pp = &amp;p;  // pp stores the address of p
</code></pre>

<p>After those declarations, the following are true:</p>

<pre><code>**pp == *p ==  x == 10 // all of these expressions have type int
 *pp ==  p == &amp;x       // all of these expressions have type int *
  pp == &amp;p             // all of these expressions have type int **
 &amp;pp                   // this expression has type int ***
</code></pre>

<p>C declaration syntax is built off the type of <em>expressions</em>.  Suppose you had a pointer to an <code>int</code> named <code>p</code> and you wanted to access that integer value.  You'd write an expression like</p>

<pre><code>x = *p;
</code></pre>

<p>The type of the <em>expression</em> <code>*p</code> is <code>int</code>, so the <em>declaration</em> is written as</p>

<pre><code>int *p;
</code></pre>

<p>If you had an array of pointers to <code>int</code> named <code>p</code> and you wanted to access the integer value pointed to by the <code>i</code>'th element, you'd write</p>

<pre><code>x = *p[i];
</code></pre>

<p>Again, the type of the <em>expression</em> <code>*p[i]</code> is <code>int</code>, so the declaration is written as</p>

<pre><code>int *p[N];
</code></pre>

<p>Multiple indirection shows up in two main places:</p>

<p><strong>You want a function to write to a parameter of pointer type</strong></p>

<p>Remember that C passes all function arguments by value, so if you want a function to write to a parameter, you must pass a pointer to that parameter:</p>

<pre><code>void foo( T *ptr )
{
  *ptr = new_value();  // writes a new value to the thing ptr points to
}

void bar( void )
{
  T value;
  foo ( &amp;value );     // writes a new value to value
}
</code></pre>

<p>Let's replace <code>T</code> with a pointer type <code>P *</code>:</p>

<pre><code>void foo( P **ptr )
{
  *ptr = new_value();  // writes a new value to the thing ptr points to
}

void bar( void )
{
  P *value;
  foo ( &amp;value );     // writes a new value to value
}
</code></pre>

<p>As you can see, it works the same way.  We want to update the contents of <code>value</code>, so we must pass a pointer to it.  Yes, <code>value</code> already has a pointer type, but we need a pointer to <code>value</code> <em>itself</em> in order to update it.  </p>

<p>Remember, if an lvalue expression <code>x</code> has type <code>T</code>, then the expression <code>&amp;x</code> has type <code>T *</code>.  Again, replace <code>T</code> with a pointer type <code>P *</code>, and you'll see that the expression <code>&amp;x</code> has type <code>P **</code>.  </p>

<p><strong>You want to allocate a jagged array</strong></p>

<p>Sometimes you want a 2D (or 3D, or higher) array-like structure, but you don't want the rows to be the same size.  The usual way to do that is like so:</p>

<pre><code>T **arr = malloc( N * sizeof *arr ); // allocate an array to hold N objects of type T *

if ( arr )
{
  for ( size_t i = 0; i &lt; N; i++ )
  {
    arr[i] = malloc( M * sizeof *arr[i] ); // allocate an array to hold M objects of type T, where M can vary from row to row
  }
}
</code></pre>

<p><code>arr</code> points to the first in a sequence of pointers to <code>T</code>.  </p>
",0
56855510,56855176,0,"<p>As far as I'm aware of there are three 'uses' for the asterisk in the C language.</p>

<p>There's multiplication:</p>

<pre><code>int result = 3 * 3; /* result == 9 */
</code></pre>

<p>There's definition:</p>

<pre><code>int *pointer_to_result = &amp;result; /* define a pointer to an int, and initialize it with the address of the result variable */
</code></pre>

<p>And finally for dereferencing:</p>

<pre><code>int copy_of_result = *pointer_to_result /* copy_of_result == 9 */
</code></pre>

<p>What you are seeing with the double asterisk is <a href=""https://www.tutorialspoint.com/cprogramming/c_pointer_to_pointer.htm"" rel=""nofollow noreferrer"">a pointer to a pointer</a>. Read up on these. They are a lot of fun.</p>
",2
56813738,56812604,0,"<p>Several things:</p>

<ol>
<li><code>'abcd'</code> is not a <em>string</em> - it is a multi-byte character constant, and the behavior of that is <em>entirely</em> implementation-specific.  Note that in C, character constants like <code>'A'</code> and <code>'\n'</code> have type <code><em>int</em></code>, not <code>char</code>.

<li>The declaration <code>char a[0]</code> is invalid - if a constant expression is used for the array size (as it is here), it <em>must</em> be greater than 0.  This is a constraint violation and the compiler is <em>required</em> to issue a diagnostic (although it doesn't have to halt translation).  

<li>A <em>string</em> is a sequence of character values including a 0-valued terminator.  Strings are stored in arrays of character type (<code>char</code> or <code>wchar_t</code> for ""wide"" strings), and the array must be large enough to accommodate the 0 terminator - IOW, an N-character string requires an array that's <em>at least</em> N+1 characters wide to store it in.  

<li>C does not mandate any bounds checking on array writes or accesses. If you try to store a 100 character string to an array that's only 10 elements wide, those additional 90 characters are going to be written to the memory immediately following the end of the array, potentially clobbering something important.  You will not get an ArrayOutOfBounds exception.  Depending on what gets overwritten, you may get a runtime error.  

<li>String literals like <code>""Hello""</code> have storage set aside for them at program startup and are held until the program terminates.  String literals are <em>supposed</em> to be immutable (like strings in Java), but there are platforms where the storage for string literals is writable.  The behavior on attempting to modify the contents of a string literal is <em>undefined</em> - it's erroneous, but the compiler is not required to handle it in any particular way.  It may work as expected, it may leave the string unmodified, it may crash, you may get a diagnostic, the compiler may halt translation, etc.  
</ol>

<p>So, in summary, you cannot store anything but an empty string (i.e., the 0 terminator) in a character array that's 1 element wide.  </p>

<p>From your comment:</p>

<blockquote>
  <p>In java, if i need to store array of string, I will do. <code>String[] a = new String[1]; a[0] = ""text"";</code> Now, I need to do this exact thing in C, with array size 1.</p>
</blockquote>

<p>The equivalent in C would be:</p>

<pre><code>char *a[1];                             // a is a 1-element array of *pointer* to char
a[0] = malloc( strlen( ""text"" ) + 1 );  // malloc allocates memory from the heap and returns its address
if ( a[0] )
  strcpy( a[0], ""text"" );               // copy the contents of the literal to the heap memory
</code></pre>

<p>Here, you allocate some memory from the heap, store the address of that newly-allocated memory to <code>a[0]</code>, then copy the string literal <code>""text""</code> into that new buffer.  Since C doesn't do automatic garbage collection, you'll need to manually free that memory when you're done with it:</p>

<pre><code>free( a[0] );
</code></pre>
",3
58882565,58882341,0,"<p>Homework is an exploration.</p>

<p>You are trying to print an object that will have a number of decisions.  You need to code for each one.  Simple code for this might try the approach of 'print all the characters in a square, deciding what each should be.'  That's your approach 
so far.   Next you need to write if statements and correctly answer do I print '+', '-', '|', '\', '/', 'X', or ' '?</p>

<p>You need to think about each character in order.  For example, your first test, <code>if (i == 0 &amp;&amp; (j == 0 || j == size * 2))</code>, but you need to expand it to get the '+' on the last line as well.</p>

<p>One base idea is to first get something working.  I suggest you start with your code and add items as you go.  Here is an outline with '+' working:</p>

<pre><code>for (int i = 0;i &lt; ((size * 2) + 1);i++){
    for (int j = 0; j &lt; ((size * 2) + 1);j++){
        if ((i == 0 || i == size * 2) &amp;&amp; (j == 0 || j == size * 2)){
            printf(""+"");
        }
        // more else if for '-', etc.
        else {
            printf("" "");
        }
    }
}
</code></pre>

<p>Once you have it printing the '+' at the four corners of a square, add the logic for each other charcter, checking that you get a square with the '-', '_', etc., correct.  </p>

<p>One other point is that there are other ways to do the problem, and you should explore how some seem less error prone than others.  For example, if you change your outline to:</p>

<pre><code>int last = size * 2
for (int i = 0; i &lt; last + 1; i++){
    for (int j = 0; j &lt; last + 1; j++){
        if ((i == 0 || i == last) &amp;&amp; (j == 0 || j == last) {
           ...
</code></pre>

<p>you may find that eliminating repetition and parenthesis makes it less error prone.  Notice or keep track of the errors you make.</p>
",0
58882434,58882341,2,"<p>To elaborate a bit on @EugeneSh.'s idea: Think of it this way. You have two loops in which you're iterating over (2n+1) x (2n+1) characters in the output. Each of these has to be one of the following: <code>+</code>, <code>-</code>, <code>|</code>, <code>\</code>, <code>/</code>, <code>X</code> or it has to have a <code></code>  (a space character).</p>

<p>You can't avoid printing all those (2n+1)^2 characters. So - don't try to. Just decide, for each of them, which one it needs to be. Form the appropriate conditions and check for them. You've already done it for 3 of the possible characters - just do the rest.</p>

<p>The ""trick"" is that if none of the conditions for the non-space characters is satisfied - you print a space (<code></code>).</p>

<p>PS - You might want to consider the <code>switch() { ... }</code> statement for doing this, with <code>default:</code> used for printing the space.</p>
",0
56896273,56896198,2,"<p>The <a href=""https://stackoverflow.com/a/24140394/918959"">operator precedence</a> tells that brackets <code>[]</code> are applied first, followed then by the increment operator <code>++</code> used as a prefix, i.e. <code>++cc[c]</code> is parsed as <code>++(cc[c])</code>.</p>

<p>Indeed in this context I would have preferred the use of <code>cc[c]++;</code> as it will be easy to parse without ambiguity even without knowing the precedence.</p>

<p>What <code>cc[c]++</code> or <code>++cc[c]</code> do is to increment the <code>c</code>th item in the array pointed to by <code>cc</code> by one. The two forms differ in the <em>value of the expression</em>, the former evaluating to the value <em>before</em> increment, and the latter to the value <em>after</em> increment. The value of the expression is <em>ignored</em> here as it is evaluated as a <code>void</code> expression in the expression statement, and so you can use either form.</p>

<hr>

<p>The first <code>for</code> loop using <code>i</code> zeroes each element in the array of character counts (<code>cc</code>). That loop is not actually needed if the array is zero-initialized: just writing</p>

<pre><code>int cc[MAXCHAR] = {0};
</code></pre>

<p>will set to zero each and every element in the <code>cc</code> array.</p>
",3
56926689,56926294,1,"<p>When you declare variable outside of a function, its initialiser expression must be one that can be evaluated at compile time.  That excludes any initialiser that invokes a function.</p>

<p>It seems likely that you intended the variables <code>l1</code> and <code>l2</code> to be <em>inside</em> a function. Little else about the header roots.h makes much sense in the context of the code in <code>main()</code>.</p>

<p>While you need a function <em>definition</em>, such a definition should not normally be placed in a header file (unless it is declared <code>inline</code> or <code>static</code> but that would be unusual and in non trivial applications can result in ""code bloat"" so it is not a habit you want to get into even for trivial code.<br>
Header files are normally <em>declarative</em>; i.e. they declare symbols that are <em>defined</em> elsewhere.  You then use separate compilation and linking of individual translation units. </p>

<p>In this case you might have:</p>

<p><em>roots.h</em></p>

<pre><code>#ifndef roots_h
#define roots_h

// Find the roots of the second order nontrivial solution
void roots( float a1, float a2, float* l1, float* l2 ) ;

#endif /* roots_h */
</code></pre>

<p><em>roots.c</em></p>

<pre><code>#include &lt;math.h&gt;
#include ""roots.h""

void roots( float a1, float a2, float* l1, float* l2 )
{
    float r = sqrt( a1*a1 - 4*a1*a2) ;
    *l1 = (-a1 + r) / 2 ;
    *l2 = (-a1 - r) / 2 ;
}
</code></pre>

<p><em>main.c</em></p>

<pre><code>#include &lt;stdio.h&gt;
#include ""roots.h""  //header file

int main()
{
    printf(""Enter a1 and a2 separated by a space: "");
    float a1, a2;
    scanf(""%f %f"", &amp;a1, &amp;a2);

    float l1, l2;
    roots( a1, a2, &amp;l1, &amp;l2) ;

    printf( ""l1 = %f, l2 = %f\n"", l1, l2 ) ;

    return 0;
}
</code></pre>

<p>The you must <em>separately</em> compile both roots.c and main.c, then link the resulting object files. Most often you would manage separate compilation and linking via a makefile or an IDE project management - otherwise it becomes very tedious and error prone with even a small number of translation units.</p>

<p>For trivial code (I appreciate that this is part of a larger project), you might simply avoid that and place the code in a single file:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

void roots( float a1, float a2, float* l1, float* l2 )
{
    float r = sqrt( a1*a1 - 4*a1*a2) ;
    *l1 = (-a1 + r) / 2 ;
    *l2 = (-a1 - r) / 2 ;
}

int main()
{
    printf(""Enter a1 and a2 separated by a space: "");
    float a1, a2;
    scanf(""%f %f"", &amp;a1, &amp;a2);

    float l1, l2;
    roots( a1, a2, &amp;l1, &amp;l2) ;

    printf( ""l1 = %f, l2 = %f\n"", l1, l2 ) ;

    return 0;
}
</code></pre>
",3
56938146,56937914,1,"<p>The problem is not with termination of strings. [Note 1]</p>
<p>Your problem is that arrays in C start at index 0, not index 1. So the elements in <code>p</code> are <code>p[0]</code> through <code>p[4]</code> and so <code>p[5]</code> references random memory. C does not check that array indexes are valid, and using invalid ones leads to odd bugs like this one.</p>
<p><code>scanf</code> certainly NUL-terminates strings, which is why I said that termination is not a problem. However, it doesn't know how much memory you've reserved for the string, so it could well overwrite random memory if the string entered by the user is too long. Better to use the format <code>&quot;%d%49s%d&quot;</code> (in this case) to limit the string read to 49 characters. (You can't fit a 50-character string in a 50-element array precisely because you need to leave space for the terminating NUL.)</p>
<p>However, you also need to check the return value of <code>scanf</code>. That function returns the number of successful conversions, which in this case must be three. If it returns a smaller number, that means one of the conversions failed, and if a numeric conversion fails, the offending character (perhaps a letter) will still be the next input character, so the next <code>%d</code> conversion will also fail.</p>
<hr />
<h3>Notes:</h3>
<ol>
<li><p>If you want to store a NUL in a string, you would do something like;this, assuming you know where the string ends:</p>
<pre><code> p[i].name[len] = `\0`;
</code></pre>
<p>You can declare and initialise a character array so that all its elements are 0:</p>
<pre><code> char name[50] = { '\0' };
</code></pre>
<p>But you can't put an initialiser inside the definition of a <code>struct</code>. The <code>struct</code> declaration only defines the general form of a composite object; it doesn't declare any instances of that object so there is nothing to initialise.</p>
</li>
</ol>
",1
58104470,58104410,0,"<p>What about something like this (in the loop)</p>

<pre><code>if (c[i] == '+' )
{
// do the plus operation.
}
else if ( c[i] == '-') 
{
// do the minus operation.
}
/// ... same thing for the other operations.
</code></pre>
",1
57126854,57126755,1,"<p>You can't have a value without a type.</p>

<p><code>123456789</code> just like that is nothing; you need to know if it's an integer, a double, a pointer, ...</p>

<p>So, I like to think of it as the pair <code>(value, type)</code>.<br>
And that <em>value</em> could be <code>(123456789, int)</code>, or <code>(123456789, double)</code>, or <code>(123456789, char*)</code>, ... which are all different pairs (with the same value).</p>

<p>In your case you have <code>(&lt;address&gt;, char(*)[7])</code> <strong>not the same as</strong> <code>(&lt;address&gt;, char*)</code></p>
",0
57139999,57139998,2,"<p>The first problem that I spotted in that you have not allocated any memory for the inputted password. Next your first <code>if</code> compares two pointers, not two strings. </p>

<p>I recommend a different language:</p>

<p><code>python3</code> will be good for this, or <code>go</code> (if you need to compile to native code).</p>

<p>Other problems: </p>

<ul>
<li>I can get your password by running <code>strings ?program name?</code>.</li>
<li>I can circumvent the the security by directly running the external programs (batch files). I can find the external programs by running <code>strings ?program name?</code>.</li>
</ul>
",2
57941250,57941178,1,"<p>The short answer would be: C has pointers.</p>

<p>A medium length answer is: you have relatively easy/free access to memory trough pointers.</p>

<p>A longer answer with an example:</p>

<pre><code>int i = 42; // i is an integer (usually 4 bytes)
int *p;  // p is a pointer to an integer (it's not pointing to anything now)
p = &amp;i;  // make p point to the integer x, so now x and *p are ""the same""
// and you can do crazy stuff like this
char *p1; // p1 is a pointer to an char (char is 1 byte)
p1 = ((char*)p) + 1; // now p1 points to the address one above p (i.e. the second byte of x)
*p1 = *p1 + 1; // this will effectively add 32 to x (if my in head math is correct)
</code></pre>

<p>This example is quite contrived, and you shouldn't do stuff like this. You shouldn't worry about not knowing what ""low level access to memory"" means, and try to learn C. Eventually, when you understand C and it's pointer mechanism, you'll probably understand what the book meant by ""low level access to memory"".</p>
",0
57207612,57207583,0,"<p>You're specifying <code>%d</code> for your <code>feet</code> variable which is quite clearly a <code>float</code>, though oddly it's a <code>float</code> based on a rounded value, so you could use <code>int</code> if you wanted.</p>

<p>Turn on warnings like <code>-Wall</code> to be alerted to simple mistakes like this.</p>

<p>You'll also want to check for <em>uninitialized variables</em> as these are the primary source of crashes.</p>

<p>You can't use <code>while</code> on a variable that isn't defined. You must define it first.</p>

<p>Consider restructuring:</p>

<pre><code>float height_cm;

while (true)
{
    printf(""Enter a height in centimeters(&lt;=0 to quit): "");
    scanf(""%.2f"", &amp;height_cm);

    if (height_cm &gt; 0) {
      int feet = (height_cm/2.54)/12;
      float inch = (height_cm/2.54) % 12; // Don't forget to modulo

      printf(""%.2f = %d feet, %.2f inches"", height_cm,feet,inch);
    }
    else {
      break;
    }
}
</code></pre>

<p>Due to how you're asking for input and looping around it you'll want to conditionally <code>break</code> rather than express the break condition in the <code>while</code> itself.</p>
",3
57341239,57341099,4,"<p>A Little translation from C.</p>

<pre><code>""%[^\n]%[^\n]%s%s%d""

%[^\n]        // reads everything up to the new line
              // But does not read the new line character.
              // So there is still a new  line character on the stream.

%[^\n]%[^\n]  // So the first one reads up to the new line.
              // The second one will immediately fail as there is a new line
              // still on the stream and thus not read anything. 
</code></pre>

<p>So:</p>

<pre><code>int count = scanf(CompanyFile,""%[^\n]%[^\n]%s%s%d"", /*Variables*/ );
printf(""Count = %d\n"", count);
</code></pre>

<p>Will print 1 as only one variable has been filled.</p>

<p>I know it is tempting to use the following to read a line.</p>

<pre><code> fscanf(""%[^\n]\n"", /* Variables*/ );
</code></pre>

<p>But that is a bad idea as it is hard to spot empty lines. An empty line will not read anything into the variable and thus fail before reading the new line so it effectively will not read the empty line. So best to break this into multiple statements.</p>

<pre><code> int count;
 do {
     count = fscanf(""%[^\n]"", /* Variables*/ );
     fscanf(""\n"");
 } while (count == 0);
 // successfully read the company name and moved on to next line
 // while skipping completely empty lines.
</code></pre>

<p>Now that seems logical extension of the above.<br>
But that would not be the best way to do it. If you assume that a line may start with the '\n' from the previous line (and you want to ignore any leading white space on the data line) then you can use a space before.</p>

<pre><code> int count = fscanf("" %[^\n]"", /* Variables*/ );
                  // ^ The leading space will drop all white space characters.
                  // this includes new lines so if you expect the last read may
                  // have left the new line on the stream this will drop it.
</code></pre>

<p>Another thing to note is that you should always check the return value of a <code>fscanf()</code> to make sure the number of variables you expect to have scanned was actually scanned.</p>
",2
57342663,57342489,1,"<p>This is not something a function pointer can do.</p>

<p>Instead of function pointers, you probably want some kind of object-orientation so you can have several objects each with its own private <code>test</code> field, but sharing the same <em>code</em>.</p>

<p>For this, you need to go to C++ instead of plain C.</p>

<p>(If for some reason this is not available to you and you <em>have</em> to do your stuff in C, there's no real way around giving the function an extra context pointer as a parameter. Or, if you need only finitely many instances of the function, write it several times. They can share a helper function that does the real stuff, but each instance needs to declare their own memory for the helper function to operate on).</p>
",2
58818064,58817884,0,"<p>This is designed for array out of bounds bugs:</p>

<pre><code>int counter = 1;
...
++counter;
...
[counter-1]
</code></pre>

<p>Instead do</p>

<pre><code>for(int i=0; more_data; i++)
{
  sensor_arr[i] = ...;
  sensor_arr = realloc(sensor_arr,(i+2)*sizeof(Sensor));
}
</code></pre>

<p>Please note <a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong"">Why is ¡°while ( !feof (file) )¡± always wrong?</a>.</p>

<p>And your use of <code>realloc</code> is wrong, use a tmp pointer for storing the result and check it against NULL before assigning it back to the <code>sensor_arr</code> pointer.</p>
",1
57779852,57778493,0,"<p>When the input is ¡°123456789¡± followed by a newline character:</p>

<ul>
<li>The loop <code>while (j&lt;lim-1 &amp;&amp; (c=getchar())!=EOF &amp;&amp; c!='\n')</code> iterates nine times. In the last iteration, <code>c=getchar()</code> has put <code>'9'</code> in <code>c</code>, and <code>j</code> is 9.</li>
<li>Then <code>j&lt;lim-1</code> is false because <code>j</code> is 9 and <code>lim-1</code> is 10?1, so the loop exits.</li>
<li>Then <code>if (c=='\n' &amp;&amp; i&gt;0)</code> does nothing because <code>c</code> contains <code>'9'</code>.</li>
<li>Then <code>s[i] = '\0';</code> appends a null character, and <code>getline</code> returns to <code>main</code>.</li>
<li><code>main</code> prints the buffer (<code>line</code>), resulting in output of ¡°123456789¡±.</li>
<li>Then <code>main</code> calls <code>getline</code> again.</li>
<li>This time, in the first iteration of <code>while (j&lt;lim-1 &amp;&amp; (c=getchar())!=EOF &amp;&amp; c!='\n')</code>, <code>getchar()</code> returns <code>'\n'</code>, and this is put into <code>c</code>. Then the loop terminates since <code>c!='\n'</code> is false.</li>
<li>Since the loop terminated without executing any iterations, <code>i</code> is 0.</li>
<li>Then <code>if (c=='\n' &amp;&amp; i&gt;0)</code> does nothing because <code>i&gt;0</code> is false.</li>
<li>Then <code>s[i] = '\0';</code> appends a null character, and <code>getline</code> returns to <code>main</code>.</li>
<li>At this point, <code>line</code> contains a null character at its start. When <code>main</code> prints this, nothing is printed.</li>
</ul>

<p>Conclusion: The design is defective. <code>getline</code> is designed to suppress completely blank lines by not appending a newline if the line is empty (<code>i</code> is zero during the test <code>if (c=='\n' &amp;&amp; i&gt;0)</code>), but it is called both for the start of a line and the continuation of a line that was not completely processed due to buffer size. When it is called for the continuation of a line and the line continues exactly at a newline character, it treats it as a completely blank line and suppresses the append of a newline.</p>

<p>One remedy would be to add a parameter to <code>getline</code> to inform it whether it is being called for the start of a new line or the continuation of a line, and then modifying the test <code>if (c=='\n' &amp;&amp; i&gt;0)</code> appropriately.</p>

<p>Another defect in the design is that, if a line contains blanks and/or tabs just before where <code>getline</code> stops processing due to the buffer being full, they will be lost, because <code>getline</code> writes a null character to mark the end of the non-blank portion of the partial line and returns to <code>main</code>, thus forgetting about the pending blanks and/or tabs, which might be needed because the later continuation of the line contains non-blank characters.</p>
",3
59451128,59451087,0,"<p>Try this instead:</p>

<pre><code>#include &lt;stdio.h&gt;

int main() {
    char str1[1000];   // &lt;-- here are the changes
    printf(""What is your name? "");
    scanf(""%s."", str1);
    printf(""Hi there %s."", str1);
    return 0;
}
</code></pre>
",0
58558646,58556838,1,"<p>There are two reasons that calculating the sum of the squares of the sine and the cosine of an angle using floating-point arithmetic may not produce exactly 1:</p>

<ul>
<li>Floating-point arithmetic only approximates real arithmetic. Since a floating-point format can only represent certain values, the real-number result of any mathematical operation is rounded to the nearest value representable in the floating-point format.</li>
<li>Calculating sine, cosine, and exponentiation is somewhat hard, and the implementations of the <code>sin</code>, <code>cos</code>, and <code>pow</code> routines may have errors (greater than those necessitated by the floating-point format).</li>
</ul>

<p>Those issues cause errors in the arithmetic. Those errors might or might not cancel out, so the final result might or might not be 1.</p>

<p>When formatting a floating-point number using <code>%f</code>, the default precision is six digits after the decimal point. To see the difference between 1 and the representable values closest to 1 in the <code>double</code> format, you need 16 digits after the decimal place. (This assumes the IEEE-754 basic 64-bit binary format is being used for <code>double</code>, which is very common.) In general, you need 17 significant digits to uniquely distinguish the specific value. (This number is given by <code>DBL_DECIMAL_DIG</code>, defined in <code>&lt;float.h&gt;</code>.)</p>

<p>If you format the numbers with <code>printf(""%.16f"", sum);</code>, you will see the differences.</p>

<p>Although the variations due to rounding can be analyzed, they often behave similarly to random fluctuations. So slight changes in the arithmetic used can cause different results. In this case, the difference between <code>0.0174533</code> and <code>3.14/180</code> caused the angle to be slightly different, which resulted in slightly different calculations.</p>
",0
57943286,57942849,-1,"<p>Local non-static variables without an explicit initialiser have <em>undefined</em> value.  So initialisation is required when the value will be read before it is otherwise explicitly assigned.</p>

<p>It is possible to declare without initialisation, and then explicitly <em>assign</em> a value before the value needs to be read. For example:</p>

<pre><code>int duplicates ;
duplicates = 0 ;
</code></pre>

<p>But using explicit initialisation (i.e. assigning a value on creation of teh variable) closes the window during which the variable has undefined value. This can avoid bugs where you might read a variable before it has ever been assigned a value.  In that sense it is generally considered <em>good practice</em> to initialise all non-static local variables.</p>

<p>The first thing the code does is <em>assign</em> <code>firstNumber</code> (via <code>scanf()</code>)  so initialisation is not required, but would do no harm, and is often advised to avoid undefined behaviour.</p>

<p><code>secondNumber</code> is tested for value <em>before</em> it is assigned, so must have a value.  The test <code>secondNumber == -8</code> will be true on the first iteration.  The use of -8 seems arbitrary any negative value could be used, -1 would be more idiomatic.</p>

<p>Again <code>duplicates</code> is modified before it is assigned a value, and is a count of consecutive duplicates so must be initialised to zero.</p>

<p>The question says nothing about how the sequence is presented and can be generalised:</p>

<pre><code>int dupCount( int* seq )
{
    int duplicates = 0 ;
    for( int i = 1; seq[i] &gt;= 0; i++ )
    {
        if( seq[i] == seq[i-1] )
        {
            duplicates++ ;
        }
    }

    return duplicates ;
}
</code></pre>

<p>Example usage:</p>

<pre><code>int main()
{
    int seq[] = {3, 11, 5, 5, 5, 2, 4, 6, 6, 7, 3, -1} ;
    printf( ""%d\n"", dupCount( seq ) ) ;

    return 0;
}
</code></pre>

<p>If arbitrary length user input is specified and simply omitted from your question, then:</p>

<pre><code>#include &lt;stdio.h&gt;

int inputDupCount()
{
    int inp = 0 ;
    scanf( ""%d"", &amp;inp ) ;

    int duplicates = 0 ;
    while( inp &gt; 0 )
    {
        int prev_inp = inp ;
        scanf( ""%d"", &amp;inp ) ;

        if( inp == prev_inp )
        {
            duplicates++ ;
        }
    }

    return duplicates ;
}
</code></pre>

<p>Usage example:</p>

<pre><code>int main()
{
    printf( ""%d\n"", inputDupCount() ) ;
    return 0;
}
</code></pre>
",0
58145162,58143564,-1,"<p>This should do:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;


int main(void)
{
  long double ld, ldi;
  long long int lli;

  {
    int n;

    do
    {
      n = scanf(""%Lf"", &amp;ld);
    } while (1 != n);
  }

  while (LDBL_EPSILON &lt; fabsl(modfl(ld, &amp;ldi))) {
    ld *= 10.;
    fprintf(stderr, ""%.30Lf\n"", ld);
  }

  lli = (long long int) ldi;
  printf(""%lld\n"", lli);
}
</code></pre>

<p><sup><em>if <code>LDBL_EPSILON</code> is missing try <code>__LDBL_EPSILON __</code> or alike ...</em> </sup></p>
",2
58001093,58001066,0,"<p><code>char</code> is generally 8 bits, so to increment by 32 bits you need to increment by <code>32/8</code>.</p>

<pre><code>d += 4;
</code></pre>

<p>It would be better to parametrize this in terms of the size of a datatype.</p>

<pre><code>d += sizeof(int);
</code></pre>

<p>You could also just convert the pointer to <code>int*</code> and incremented it normally.</p>

<pre><code>intd = (int*)d;
while (get_data((char *)intd)) {
    callAnotherMethod(*intd);
    intd++;
}
</code></pre>
",6
58886385,58886074,1,"<p><code>num</code> is only zero the first time through the loop.</p>

<p>Suppose you enter <code>6521</code>. The first time through the loop, it does</p>

<pre><code>num = (0 * 10) + (6521 % 10);
</code></pre>

<p>which sets <code>num = 1</code>. Then it divides <code>n</code> by 10. So the next time through the loop it does:</p>

<pre><code>num = (1 * 10) + (652 % 10);
</code></pre>

<p>which sets <code>num = 12</code>. The next iteration does:</p>

<pre><code>num = (12 * 10) + (65 % 10);
</code></pre>

<p>which sets <code>num = 125</code>. The next iteration does:</p>

<pre><code>num = (125 * 10) + (6 % 10);
</code></pre>

<p>which sets <code>num = 1256</code>.</p>

<p>Then the loop ends because dividing <code>n</code> by <code>10</code> results in <code>0</code>.</p>

<p>The result of this is to reverse the digits of the number that was entered.</p>
",1
58041704,58041657,1,"<p>You can allocate the entire thing at once. A <code>typedef</code> makes it easier to specify the array declaration.</p>

<pre><code>typedef int[128] row;
row *twoD_array = calloc(num_rows, sizeof(row));
</code></pre>
",2
58083571,58083489,0,"<p>The instructions say that <code>twice</code> is ""given a number"", but you've defined it as taking two numbers. It only needs one parameter.</p>

<p>And you're supposed to use your <code>sum()</code> function. There's no need to multiply <code>x*x</code> (that's the square of the number, not twice the number), nor is there any point in assigning a variable in the <code>return</code> statement.</p>

<p>You only need to read one number as input to test this.</p>

<pre><code>#include &lt;stdio.h&gt;

int sum(int x, int y)
{
    return y == 0 ? x : sum(x+1, y-1);
}

int twice(int x)
{
    return sum(x, x);
}

int main(void)
{
    int x;
    int w;
    scanf(""%d"", &amp;x);
    int w = twice(x);
    printf(""%d\n"", w);
    return 0;
} 
</code></pre>
",8
58194622,58194407,0,"<p>I don't know what language you're using but it seems to use 0-based array indexing.
However, you are indexing <code>arr</code> from <code>arr[1]</code> to <code>arr[8]</code>.</p>
",1
58194429,58194308,0,"<p>Please, use <code>strptime()</code> to parse date and / or time (or both):</p>

<pre><code>struct tm ltm = {0};

char buf1[] = ""2011-02-31"";
char buf2[] = ""10:15"";

strptime(buf1, ""%Y-%m-%d"", &amp;ltm);
strptime(buf2, ""%H:%M"", &amp;ltm);
</code></pre>
",0
58194487,58194305,-2,"<p>What you've found online is right, you can't detect it.</p>

<p>The audio jacks are simple connectors that either send analog signals out or receive them in. They function the same if something is connected to them as when something isn't. They don't have a method for detecting if the hardware is attached or not.</p>

<p>A microphone isn't too bad to detect through software, just listen on the port and if there is no signal at all (no noise) then you can assume that there is nothing connected. The speaker jack is different since you can send sound out all you want and it just won't be heard if there are no speakers attached.</p>

<p><strong>There's just no way to detect if speakers are there or not</strong></p>

<p>It would be different if there were a method for measuring continuity through the speaker jack, but there isn't.</p>

<p>To give you some more read... Take a look here <a href=""http://stackoverflow.com/questions/33872895/detect-if-headphones-are-plugged-in-or-not-via-c-sharp"">http://stackoverflow.com/questions/33872895/detect-if-headphones-are-plugged-in-or-not-via-c-sharp</a></p>

<p>I hope it helps.</p>
",1
58438311,58438227,0,"<p>Output to <code>stdout</code> (which is the <code>FILE *</code> that <code>printf</code> writes to) is <em>buffered</em>. More specifically line-buffered (when connected to a terminal).</p>

<p>That means the output won't actually be written to the terminal unless the buffer is flushed, which happens on four conditions: The <code>FILE *</code> is closed, the buffer is full, there is a newline, or you explicitly flush it with the <a href=""https://en.cppreference.com/w/c/io/fflush"" rel=""nofollow noreferrer""><code>fflush</code></a> function.</p>

<p>For your use-case the best solution would be to call <code>fflush</code> in the loop before sleeping:</p>

<pre><code>for(const Node *current = local_head; current != NULL; current = current-&gt;next) {
    printf(""%d -&gt; "", current-&gt;value);
    fflush(stdout);  // Make sure the buffer is flushed and written to the terminal
    sleep(1);
}
</code></pre>
",1
59433467,59433423,3,"<p>The <code>double</code> you're trying to print has <a href=""https://en.wikipedia.org/wiki/Double-precision_floating-point_format"" rel=""nofollow noreferrer"">53 bits of precision and 11 bits of exponent</a>. <code>1e20</code> (base 10) is <code>101 0110 1011 1100 0111 0101 1110 0010 1101 0110 0011 0001 0000 0000 0000 0000 0000</code> in binary (<code>56BC75E2D63100000</code> in hex). Your <code>3.14</code> is too small to be represented once added to a number of that magnitude. Change the order of operations if you want to work around that. This code:</p>

<pre><code>    printf(""%f\n"", -1e20 + 1e20 + 3.14);
</code></pre>

<p>Prints <code>3.140000</code>.</p>
",5
58236784,58236721,1,"<p>Remove <code>\n</code> from <code>scanf(""%d\n"", &amp;quantity);</code> so it looks like this:</p>

<pre><code>scanf(""%d"", &amp;quantity);
</code></pre>
",0
58236770,58236721,3,"<p>There's a problem with your format specifiers:</p>

<pre><code>scanf(""%d\n"", &amp;quantity);
</code></pre>

<p>The <code>\n</code> in the format string causes <code>scanf</code> to wait until a newline is entered <strong>and</strong> some other character after that.  That's why you have to enter some other key.  Remove the newline and you'll be able to input values without having to enter something extra:</p>

<pre><code>scanf(""%d"", &amp;quantity);
</code></pre>

<p>Also, this isn't doing what you think:</p>

<pre><code>if (choice = 'a') {
    ...
} else if (choice = 'b') {
    ...
} else if (choice = 'c') {
</code></pre>

<p>In C <code>=</code> is the assignment operator, not the comparison operator.  When you do an assignment, the value of the expression is assigned value.  So the first <code>if</code> assigns <code>'a'</code> to <code>choice</code>, then that value is evaluated in a boolean context.  Because the value is not 0, it will always be true and so you'll never enter either of the other two cases.</p>

<p>For comparisons, you want the <code>==</code> operator:</p>

<pre><code>if (choice == 'a') {
    ...
} else if (choice == 'b') {
    ...
} else if (choice == 'c') {
</code></pre>
",0
58306913,58306405,1,"<p><code>main</code> doesn't magically return the result of another function, you need to return the value also from <code>main</code></p>

<pre><code>int main(void)
{
    return cb(10, 1);
}
</code></pre>

<p>or you can exit the program from your function with a value:</p>

<pre><code>bool cb(int N,int i){ //`called function`
    exit(((N&gt;&gt;i)&amp;1)==1 ? EXIT_FAILURE : EXIT_SUCCESS);
}
</code></pre>

<p>and check the return in the console:</p>

<pre><code>./yourprogram
echo $?
</code></pre>

<p>But notice that this is considered bad practice, we usualy return <code>EXIT_FAILURE</code> only when something went wrong, instead, you can print the result:</p>

<pre><code>int main(void)
{
    printf(""%d\n"", cb(10, 1));
    return 0;
}
</code></pre>

<p>Finaly, you can use a debugger</p>

<p>Change your code to</p>

<pre><code>Line 6   int res = cb(10, 1);
Line 7   return 0;
</code></pre>

<p>and start the debugger</p>

<pre><code>gdb yourprogram
breakpoint 7 (after the line you want to inspect)
run
print res
</code></pre>
",1
58306805,58306405,0,"<p>So Here's your program:</p>

<pre><code>#include&lt;stdbool.h&gt;

//`called function`
bool cb(int N,int i)
{ 
     return ((N &gt;&gt; i) &amp; 1) ==1;
}

//`main function` 
int main(void) 
{                 
    cb(10,1);    
    return 0;
}
</code></pre>

<p>Your program is executing - which means that the main() function is returning successfully (a Value of 0).  You also invoke <code>cb(10,1);</code> which calls your function declaration above (and returns a boolean: True/False).  But you don't store the value of that function call, nor display the value with a <code>printf()</code> or <code>cout</code> statement.</p>

<p>You'll need to add more for your program to give you more noticable output.</p>
",0
58655018,58654304,0,"<p>Because you are overwriting the main string, the <code>e</code> becomes <code>r</code> and then you can't read <code>e</code> to compare to anymore. That's why you are getting <code>uryyb</code> instead of <code>urzyb</code>. This is a modified code with an alternative vowel check method and another buffer for the modified string, keeping the original intact:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main()
{
    unsigned char message[100], original[100], ch;
    int i, key, len;

    memset(message, 0, 100);
    memset(original, 0, 100);

    printf(""Enter a message to encrypt: "");
    scanf(""%s"", original);

    printf(""Enter key: "");
    scanf(""%d"", &amp;key);

    for(i = 0, len = strlen(original); i &lt; len; i++){
        if(original[i] &gt;= 'a' &amp;&amp; original[i] &lt;= 'z'){
            if(i &gt; 0 &amp;&amp; memchr(""aeiou"", original[i-1], 5)){
                message[i] = original[i] + 14;
            }else{
                message[i] = original[i] + 13;
            }            
        }
    }

    for(i = 0, len = strlen(message); i &lt; len; i++){
        if(message[i] &gt; 'z'){
            message[i] = message[i] - 'z' + 'a' - 1;
        }
    }

    printf(""Encrypted message: %s"", message);

    return 0;   
}
</code></pre>

<p><strong>Edit</strong>: moved the overflow fix outside another loop.</p>

<p><strong>Edit</strong>: forgot an crucial part, chars need to be <code>unsigned</code>.</p>

<p><a href=""https://onlinegdb.com/ryo2dKR5H"" rel=""nofollow noreferrer"">https://onlinegdb.com/ryo2dKR5H</a></p>
",5
58655748,58654304,1,"<p>I have three advises for you.</p>

<ol>
<li>Don't use gets, it is deprecated and for good reason, use fgets instead.</li>
<li>Since you are modifying the message character by character. You cannot look back at the previous character using message[i-1] to see if that was a wovel, because it was already shifted in the previous iteration of the loop. store the previous character in a separate variable instead.</li>
<li>Since you are wrapping back to 'a' when you reach 'z', consider using the modulus arithmetic, which is used to cycle the numbers in a given range.</li>
</ol>

<p>see the code below with these ideas applied to your code.</p>

<pre><code>int main()
{
    // ...
    printf(""Enter a message to encrypt: "");
    fgets(message,100,stdin);
    printf(""Enter key: "");
    scanf(""%d"", &amp;key);

    char p = 1; // some initial value that is not a vowel.
    for(i = 0; message[i] != '\0'; ++i){
        if(message[i] &gt;= 'a' &amp;&amp; message[i] &lt;= 'z'){
            char ch = (message[i]-'a' + key) % 26 + 'a'; // using modular math
            if (strchr(""aeiou"",p)){
                ch++; // increment by 1 if previous character was a vowel
            }   
            p = message[i]; // save previous character
            message[i]=ch;  // update message.
        }   
    }   
    printf(""Encrypted message: %s"", message);
    return 0;
}
</code></pre>
",2
58332244,58332196,3,"<p>The type signature of</p>

<pre><code>void create_magic_square(int n, int magic_square[N][N]);
</code></pre>

<p>is actually:</p>

<pre><code>void create_magic_square(int n, int (*magic_square)[N]);
</code></pre>

<p>It takes a pointer to the first element of an array whose elements are arrays of N integers.</p>

<p>This declaration:</p>

<pre><code>int magic_square[n][n];
</code></pre>

<p>produces a C99 variable-length ARRAY (VLA): an 5-element array of 5-element arrays of int. This is not compatible with what the function expects. But, never mind that, this is not even passed to the function in any manner that resembles correct:</p>

<pre><code>create_magic_square(n, magic_square[N][N]);
</code></pre>

<p>Here, the expression <code>magic_square[N][N]</code> accesses the <code>magic_square</code> out-of-bounds (undefined behavior) to retrieve an <code>int</code> value, which is then passed as a pointer argument. That is a constraint violation; the compiler should produce a diagnostic here (likely to be worded as being about an integer to pointer conversion without a cast).</p>

<p>The expression we want looks like:</p>

<pre><code>create_magic_square(n, magic_square);
</code></pre>

<p>but for that to be correct, the function has to receive the VLA in the correct way.</p>

<p>Here is a diff between your program and a working one:</p>

<pre><code>--- magicsquare-ORIG.c  2019-10-10 16:14:50.437827772 -0700
+++ magicsquare.c   2019-10-10 16:17:17.896145951 -0700
@@ -1,8 +1,7 @@
 #include &lt;stdio.h&gt;
-#define N 100

-void create_magic_square(int n, int magic_square[N][N]);
-void print_magic_square(int n, int magic_square[N][N]);
+void create_magic_square(int n, int magic_square[n][n]);
+void print_magic_square(int n, int magic_square[n][n]);


 int main(void) {
@@ -13,17 +12,28 @@

     int magic_square[n][n];

-    create_magic_square(n, magic_square[N][N]);
-    print_magic_square(n, magic_square[N][N]);
+    create_magic_square(n, magic_square);
+    print_magic_square(n, magic_square);
     return 0;
 }

-void create_magic_square(int n, int magic_square[N][N]) {
+void create_magic_square(int n, int magic_square[n][n]) {

-    int i, row, col, next_row, next_col;
+    int row, col;
     for (row = 0; row &lt; n; row++) {
         for (col = 0; col &lt; n; col++) {
             magic_square[row][col] = 0;
         }
     }
 }
+
+void print_magic_square(int n, int magic_square[n][n]) {
+
+    int row, col;
+    for (row = 0; row &lt; n; row++) {
+        for (col = 0; col &lt; n; col++) {
+            printf(""%d,"", magic_square[row][col]);
+        }
+        putchar('\n');
+    }
+}
</code></pre>

<p>We lose the <code>N</code> macro, add a <code>print_magic_square</code> function, call the functions properly, and drop some unused local variables.</p>
",0
59020249,59020131,1,"<p>You need to link the new entry allocated at the end of <code>findUpdate</code> into the list. I suggest rewriting <code>findUpdate</code> as:</p>

<pre><code>void findUpdate(int account, float amount)
  {
  struct ACCOUNT *current;

  for(current = head ; current != NULL ; current = current-&gt;next)
    {
    if(current-&gt;accountNumber == account)
      {
      current-&gt;balance += amount;
      break;
      }
    }

  if(current == NULL)
    {
    current = malloc(sizeof(struct ACCOUNT));
    current-&gt;accountNumber = account;
    current-&gt;balance = amount;
    current-&gt;next = head;
    head = current;
    }
  }
</code></pre>
",2
59149065,59148829,0,"<p>This my not be the answer you desire, but 2 way communication via environment variable is near impossible because as pointed out in the comment a child process could not affect its parent process environment.</p>

<p>I would suggest you look at <a href=""https://www.geeksforgeeks.org/inter-process-communication-ipc/"" rel=""nofollow noreferrer"">inter process communication</a> :</p>

<ul>
<li>Shared memory</li>
<li>Pipe</li>
<li>Socket</li>
<li>RPC</li>
</ul>
",0
59325646,59325551,3,"<p>Few things:</p>

<ol>
<li><p>Your loop condition <code>for (int i = 0; arr[i] != '\0'; i++)</code> requires that the array is terminated with zero. This is not the case unless you explicitly terminate the array with zero. Also, if any of the values in <code>numbers</code> is zero, it will stop there.</p></li>
<li><p>You are always dereferencing the first element in the array. Print <code>arr[i]</code> or <code>*(arr + i)</code> to print the actual array values one by one.</p></li>
<li><p>Not code related, but it's grammatically correct to say ""number too small"", not ""number to small"". :-)</p></li>
</ol>
",0
58574427,58574153,0,"<p>Since there is no information about your other code yet, let me speculate: the calling code does something like:</p>

<pre><code>int main(void) {
    char* Pointer = series_sum(999);
    free(Pointer);
    return 0;
}
</code></pre>

<p>That free-call tries to free a static. You can call free on pointers that you got from malloc. You should not try to call it on a static buffer.</p>
",1
58671436,58670828,1,"<p>If stdin is a seekable file, then <code>rewind(stdin)</code> ought to work just fine.  If you need to rewind on a non-seekable file, then you either need to buffer all the data (either in memory or in a temporary file) or abort.  That is, just do:</p>

<pre><code>if( fseek(stdin, 0L, SEEK_SET) ) {
    perror(""stdin"");
    exit(EXIT_FAILURE);
}
</code></pre>
",3
58671330,58670828,5,"<p><a href=""https://linux.die.net/man/3/rewind"" rel=""noreferrer"">The <code>rewind()</code> and <code>fseek()</code> functions</a> are the conventional ways to reposition a stream <strong>that supports doing so</strong>.  Not all streams do support it, and whether yours does is a function not only of your C implementation but also of your operating environment and the specific circumstances of program launch.</p>

<p>I would generally be inclined to expect a stream associated with redirected input <em>not</em> to support repositioning, so even if it worked in your particular circumstances, you would be wise to consider a more reliable alternative.</p>

<p>In particular, you could create a temporary file, copy the standard input to it, and then use that file.  You can perform the copying either ahead of time or as you perform the first ordinary run-through.  If you need to re-read the data specifically from <code>stdin</code>, as opposed to from some other stream you open, then you can use <a href=""https://linux.die.net/man/3/freopen"" rel=""noreferrer""><code>freopen()</code></a> to attach <code>stdin</code> to your temp file.</p>
",2
59413220,59412997,0,"<p>In C++17 you can use std::optional for this sort of thing.</p>

<pre><code>#include &lt;optional&gt;

struct optional_params {
    int color;
    float frobication_level;
} params;

struct options {
    const char* type;
    const char* action;
    std::optional&lt;optional_params&gt; extra;
};

void useOptions(const options&amp; opts) {
    // ...
    if (opts.extra.has_value()) {
        auto [color, frob_lvl] = opts.extra.value();
        // ...
    }
}

options opts = { ""foo"",""bar"", optional_params{1, 42.0} };
useOptions(opts);
</code></pre>
",0
59413066,59412997,2,"<h1>C++ Way</h1>

<p>Depending on the type(s) of the optional parameters, you might want to consider <code>std::map</code> or <code>std::unordered_map</code> with an appropriate template type (e.g., some sort of polymorphic base reference).</p>

<h1>C Way</h1>

<p>This gets a little tricky, but there are some design options. In short, you're going to have to default the optional parameters to some common type (e.g., char-strings), and have a struct pairing them appropriately. For example,</p>

<pre><code>typedef struct{
  char  param[32];
  char* val;
} ParameterPair;
</code></pre>
",0
58779992,58779710,3,"<blockquote>
  <p>Why do we need a return function in main in C? </p>
</blockquote>

<p>The return value from <code>main()</code> is returned to the ""system"" and interpreted as a process <em>exit code</em> which can be used in shell scripts and batch files for example.  In Windows for example:</p>

<pre><code>&gt; myprogram
Hello World
&gt; echo myprogram returned %errorlevel%
myprogram returned 0
</code></pre>

<blockquote>
  <p>[...] it should execute the statement after the return statement till a closing bracket is encountered?</p>
</blockquote>

<p>No. A function returns when a <code>return</code> is encountered (clue is in the name!) or at the closing brace - whichever occurs first.  A return statement can appear anywhere in a function and a function may have more than one return statement. If the closing brace is encountered before a <code>return</code>, then that is an <em>implicit return</em> which for a non-void function is undefined behaviour if the caller attempts to use the return value.</p>

<p>When you return from <code>main()</code> control is returned to the system, and in a hosted environment that terminates the process and the OS recovers resources, closes files etc.</p>
",0
58798224,58792627,0,"<p>There are 2 acceptable ways to declare this struct:</p>

<pre><code>typedef struct cellule
{
    int numero;
    int poids;
    struct cellule *suivant;
}Celulle;

// usage:
Celulle c;
</code></pre>

<p>or</p>

<pre><code>struct cellule
{
    int numero;
    int poids;
    struct cellule *suivant;
};

// usage:
struct celulle c;
</code></pre>

<p>Which one to pick is a matter of coding style. The former is by far most common. The latter is used in Linux style programs. Either is fine.</p>

<p>What is never ok however, is to hide a pointer behind a <code>typedef</code>. Your originally code does this, defining a type <code>LISTE</code> which is actually a <code>Celulle*</code> pointer. Hiding pointers like this create confusion and is known to cause bugs because of it. Your original program should instead be rewritten to something like this:</p>

<pre><code>typedef struct cellule
{
    int numero;
    int poids;
    struct cellule* suivant;
}Celulle;

Celulle* graphe[TAILLE];
</code></pre>
",0
58847821,58847754,1,"<p>Kudos for asking--unfortunately this is unsafe. The line, <code>newarr = &amp; arr[1];</code> discards the array you allocated in the line above, and makes <code>newarr</code> point into the existing array (which is too small to hold the new value for certain value of <code>size</code>). Additionally, you leak memory since you don't pair mallocs with frees.</p>

<p>In your case, you probably got lucky since you didn't run into off-limits memory or overwrite something important. With larger arrays or more calls, you could end up crashing (and bugs of this type can also lead to security flaws).</p>

<p>Assuming that you can clobber the input rather than copying, you can <a href=""https://en.cppreference.com/w/c/memory/realloc"" rel=""nofollow noreferrer""><code>realloc</code></a> the array and shift the elements around; alternatively you can construct the new array and copy into it. Note that I assume that <code>size</code> is at most the size of the old array plus one:</p>

<pre><code>int * cycle_and_append(int *arr, int size, int newvalue) {

    int * newarr = (int *) malloc(size*sizeof(int));

    for(size_t i = 0; i &lt; (size-1); i++) {
        newarr[i] = arr[i+1]
    }
    newarr[size-1] = newvalue;
    // either free(arr) or put that responsibility onto the caller
    return newarr;
}
</code></pre>

<p>To improve this further you could tweak the meaning of <code>size</code> to better reflect that it's the size of the old array:</p>

<pre><code>int * cycle_and_append(int *arr, int oldsize, int newvalue) {

    int * newarr = (int *) malloc((oldsize+1)*sizeof(int));

    for(size_t i = 0; i &lt; oldsize; i++) {
        newarr[i] = arr[i+1]
    }
    newarr[oldsize] = newvalue;

    // either free(arr) or put that responsibility onto the caller
    return newarr;
}
</code></pre>
",2
58915314,58912460,1,"<p>This C analyzer can tell you that there is something wrong when your function is misused:</p>

<p><a href=""https://taas.trust-in-soft.com/tsnippet/t/cf1e64df"" rel=""nofollow noreferrer"">https://taas.trust-in-soft.com/tsnippet/t/cf1e64df</a></p>

<p>It tells you, when applied to <code>dest</code> and <code>src</code>, that an invalid write happens inside your function at <code>str1[i] = 0;</code>.</p>

<p><a href=""https://i.stack.imgur.com/9gzsD.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9gzsD.png"" alt=""screenshot of Tsnippet finding a bug""></a></p>
",0
58915572,58912460,1,"<p>Valgrind's Memcheck has <a href=""https://stackoverflow.com/questions/29842747/valgrind-wont-detect-buffer-overflow"">some limitations</a> regarding arrays allocated on the stack. Since it works with normally compiled binaries, it can't know the exact array sizes under certain circumstances.</p>

<p>clang's <a href=""https://clang.llvm.org/docs/AddressSanitizer.html"" rel=""nofollow noreferrer"">AddressSanitizer</a> is better in this regard. If you <a href=""https://tio.run/##VY7NDoIwEITvfYqRExVIwGvD3TfwQIhpyo9NSjFtPSDh1a0UosY97cw32R2RCcV17724cYPjMF2tM@I@xbteRZHiu58omQnWkdpBokTOyKa70SBmCJFK1jgEApkkdKNhwqWAyk@IkX873w3TuofRiAOgjCyEhF8DlzqmmPEruDWsiqKm85IiOrdKjbiMRjURZVi8f4lO8d76rLNcSyefbcmbxrTWvgE"" rel=""nofollow noreferrer"">compile with <code>-fsanitize=address</code></a>, you'll get the following error:</p>

<pre><code>=================================================================
==15908==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffdb7e06beb at pc 0x0000005286d2 bp 0x7ffdb7e06b40 sp 0x7ffdb7e06b38
WRITE of size 1 at 0x7ffdb7e06beb thread T0
    #0 0x5286d1 in my_strcpy (/home/runner/.bin.tio+0x5286d1)
    #1 0x52883d in main (/home/runner/.bin.tio+0x52883d)
    #2 0x7ff3e3fae412 in __libc_start_main (/lib64/libc.so.6+0x24412)
    #3 0x41b33d in _start (/home/runner/.bin.tio+0x41b33d)

Address 0x7ffdb7e06beb is located in stack of thread T0 at offset 43 in frame
    #0 0x5286ff in main (/home/runner/.bin.tio+0x5286ff)

  This frame has 1 object(s):
    [32, 43) '.compoundliteral' &lt;== Memory access at offset 43 overflows this variable
HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork
      (longjmp and C++ exceptions *are* supported)
SUMMARY: AddressSanitizer: stack-buffer-overflow (/home/runner/.bin.tio+0x5286d1) in my_strcpy
Shadow bytes around the buggy address:
  0x100036fb8d20: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100036fb8d30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100036fb8d40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100036fb8d50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100036fb8d60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=&gt;0x100036fb8d70: 00 00 00 00 00 00 00 00 f1 f1 f1 f1 00[03]f3 f3
  0x100036fb8d80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100036fb8d90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100036fb8da0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100036fb8db0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x100036fb8dc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==15908==ABORTING
</code></pre>
",0
59004248,59004225,2,"<p>You need to coerce the <code>1</code> before shifting, otherwise is it treated as an <code>int</code> constant:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    long long int from, to;
    printf(""signed long long int: "");

    int bytes = sizeof(long long int);
    int bits = 8 * bytes;

    from = -(((long long)1) &lt;&lt; (bits-1));
    to =  (((long long)1) &lt;&lt; (bits-1)) - 1;

    printf("" %d bytes from %lld to %lld\n"", bytes, from, to);
}
</code></pre>

<p>Or use the more readable <code>1LL</code> as @phuclv pointed out.</p>

<p>Output:</p>

<pre><code>signed long long int:  8 bytes from -9223372036854775808 to 9223372036854775807
</code></pre>
",0
59004250,59004225,0,"<p><code>1</code> is an int literal, therefore <code>1 &lt;&lt; (bits-1)</code> is done in <code>int</code> type, which invokes undefined behavior since you're shifting more than the type's width. Use <code>1LL</code> instead for a <code>long long</code> value</p>
",0
59001300,59000498,2,"<p>If you have a handful of commands, a simple if/elsif will do.</p>

<pre><code>enum commands cmd_num = UNKNOWN_COMMAND;

if( strcmp(cmd_string, ""this"") ) {
    cmd_num = THIS_COMMAND;
}
else if( strcmp(cmd_string, ""that"") ) {
    cmd_num = THAT_COMMAND;
}
else {
    fprintf(stderr, ""Unknown command: %s"", cmd_string);
}

switch(cmd_num) {
  case THIS_COMMAND:
    this();
    break;
  case THAT_COMMAND:
    that();
    break;
  default:
    fprintf(stderr, ""Unknown command #%d"", cmd_num);
}
</code></pre>

<p>But why not cut out the middle man?</p>

<pre><code>if( strcmp(cmd_string, ""this"") ) {
    this();
elsif( strcmp(cmd_string, ""that"") ) {
    that();
}
else {
    fprintf(""Unknown command: %s"", cmd_string);
}
</code></pre>

<p>If you plan on having a lot of commands you can put them into a <a href=""https://developer.gnome.org/glib/2.62/glib-Hash-Tables.html#g-hash-table-lookup"" rel=""nofollow noreferrer"">hash table</a> for ease of addition and lookup. The key is the command string. The value could be an integer with a separate switch statement (or another hash table) to run the command.</p>

<p>Or, once again, we can cut out the middle man and make it a function pointer.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;gmodule.h&gt;

void this() {
    puts(""this"");
}

void that() {
    puts(""that"");
}

GHashTable *init_commands() {
    return g_hash_table_new( g_str_hash, g_str_equal );
}

void add_command(GHashTable *commands, const char *command, void(*func_ptr)(void)) {
    g_hash_table_insert(commands, g_strdup(command), (void *)func_ptr);
}

void run_command(GHashTable *commands, const char *command) {
    void(*func_ptr)(void) = g_hash_table_lookup(commands, command);
    if( func_ptr ) {
        (*func_ptr)();
    }
    else {
        fprintf(stderr, ""Unknown command: %s"", command);
    }
}

int main() {    
    GHashTable *commands = init_commands();
    add_command(commands, ""this"", this);
    add_command(commands, ""that"", that);

    run_command(commands, ""this"");
}
</code></pre>

<p>The trade-off is that all commands must now have the same signature. This is common for remote command handlers, but it takes some getting used to. Which way you choose depends on how your project works.</p>
",3
59086420,59086364,4,"<p>You declare this:</p>

<pre><code>int scan_fraction(int* nump, int* denomp);
</code></pre>

<p>And your implementation is this:</p>

<pre><code>void scan_fraction(int* nump, int* denomp)
</code></pre>

<p>Declaration and implementation don't match.</p>

<hr>

<p>Also, you have:</p>

<pre><code>status = scanf(""%d %c%d"", &amp;nump, &amp;slash, denomp);
</code></pre>

<p>You should use this, because <code>nump</code> is already a pointer to <code>int</code>:</p>

<pre><code>status = scanf(""%d %c%d"", nump, &amp;slash, denomp);
</code></pre>

<p>Your compiler should be telling you about this, too.</p>
",0
59055960,59055378,2,"<p>You are looking for numbers with a decimal representation that ends with <code>1</code> (<code>count % 10 == 1</code>), except those with a decimal representation that ends with 11 (<code>count % 100 != 11</code>), so</p>

<pre><code>if (count % 10 == 1 &amp;&amp; count % 100 != 11)
   return ""§â§å§Ò§Ý§î"";
</code></pre>

<hr>

<p>Put differently, </p>

<pre><code>if ((count % 100 == 1) || (count % 100 == 21) || (count % 100 == 31)) return ""§â§å§Ò§Ý§î"";
else if ((count % 100 == 41) || (count % 100 == 51) || (count % 100 == 61)) return ""§â§å§Ò§Ý§î"";
else if ((count % 100 == 71) || (count % 100 == 81) || (count % 100 == 91)) return ""§â§å§Ò§Ý§î"";
</code></pre>

<p>is equivalent to </p>

<pre><code>if (
   count % 100 ==  1 ||
// count % 100 == 11 ||   // Intentionally omitted.
   count % 100 == 21 ||
   count % 100 == 31 ||
   count % 100 == 41 ||
   count % 100 == 51 ||
   count % 100 == 61 ||
   count % 100 == 71 ||
   count % 100 == 81 ||
   count % 100 == 91
) {
   return ""§â§å§Ò§Ý§î"";
}
</code></pre>

<p>This is already more readable, but we can do better.</p>

<p>If we could add <code>count % 100 == 11</code>, the condition would be more uniform, and that might open up avenues for simplification. So let's try that.</p>

<pre><code>if (count % 100 != 11) {
   if (
      count % 100 ==  1 ||
      count % 100 == 11 ||
      count % 100 == 21 ||
      count % 100 == 31 ||
      count % 100 == 41 ||
      count % 100 == 51 ||
      count % 100 == 61 ||
      count % 100 == 71 ||
      count % 100 == 81 ||
      count % 100 == 91
   ) {
      return ""§â§å§Ò§Ý§î"";
   }
}
</code></pre>

<p>Indeed, we can now simplify the large condition as follows:</p>

<pre><code>if (count % 100 != 11) {
   if (count % 10 == 1) {
      return ""§â§å§Ò§Ý§î"";
   }
}
</code></pre>

<p>Finally, you can collapse nested <code>if</code> statements by AND-ing their conditions.</p>

<pre><code>if (count % 100 != 11 &amp;&amp; count % 10 == 1)
   return ""§â§å§Ò§Ý§î"";
</code></pre>

<p>More readable:</p>

<pre><code>if (count % 10 == 1 &amp;&amp; count % 100 != 11)
   return ""§â§å§Ò§Ý§î"";
</code></pre>
",0
59233101,59233061,2,"<p><code>i</code> is the starting column, <code>j</code> is the starting row, and you're checking 4 adjacent rows/columns. If you didn't subtract 3 from the width/height respectively you would overflow into non-existent rows/columns.</p>

<p>Edit:
In fact the left diagonal code is bugged and will overflow the board. Should be like this:</p>

<pre><code>//checks left diagonal win
for(i=0;i&lt;sizeWidth-3;i++)
    for(j=3;j&lt;sizeHeight;j++)
        if(board[i][j] != 0 &amp;&amp; board[i][j]==board[i+1][j-1] &amp;&amp; board[i][j]==board[i+2][j-2] &amp;&amp; board[i][j]==board[i+3][j-3])
            printf(""\n4"");
</code></pre>
",0
59340838,59340680,1,"<p>Your code is fine, but your output statements are messed up. Use:</p>

<pre><code>  #include &lt;stdio.h&gt;
  int main(){
      int num1;
      int total;

      printf(""Enter a Number: "");
      scanf("" %d"", &amp;num1);

      total = num1 * num1;

      printf(""The value of your number is %d\n"", num1);
      printf(""%d multiplied by %d is %d\n"", num1, num1, total);
  }
</code></pre>
",0
59456805,59456790,2,"<p>The problem you are facing is because of the existence of another function <a href=""https://linux.die.net/man/3/getline"" rel=""nofollow noreferrer""><code>getline()</code></a>, which is most likely present in your version of the standard library. It creates the conflict with your function definition. It is prototyped in <code>stdio.h</code> (which is included in your program) and present in the standard library (which is linked by default) which you're using.</p>

<p>Easiest way out: Use a different name for your function, like <code>my_getline()</code> or something.</p>
",0
59472610,59471587,1,"<p>Rather than</p>

<pre><code>int left(int matrix[][], int sz);
</code></pre>

<p>Pass the size information first.  This uses a <em>variable length array</em>, available in C99, optional in C11, C17.</p>

<pre><code>int left(int sz, int matrix[sz][sz])
</code></pre>

<p>Or better yet, pass both dimensions and use <code>size_t</code></p>

<pre><code>int left(size_t rows, size_t cols, int matrix[rows][cols]);

int play(size_t sz, int matrix[sz][sz], char play_user[1]) {
  if (play_user[0] == 'a') {
    return left(sz, sz, matrix);
  }
  return 0;
}

int left(size_t rows, size_t cols, int matrix[rows][cols]) {
  for (size_t r = 0; r &lt; rows; ++r) {
    for (size_t c = 0; c &lt; cols; ++c) {
      printf(""%d\t"", matrix[r][c]);
    }
    printf(""\n"");
  }
  return 0;
}
</code></pre>

<hr>

<p>See also <a href=""https://stackoverflow.com/q/14548753/2410359"">Passing a multidimensional variable length array to a function</a></p>
",0
59583853,59583202,2,"<p>When <code>leNumeros()</code> is called you attempt to allocate a zero length block - that has <em>implementation defined behaviour</em>.  </p>

<p>Then when you enter a number > 0, you attempt to <code>realloc()</code> a zero length block - that behaviour is <em>well defined</em> it frees the original block then returns a null pointer, then at <code>*lista[*nElem] = op;</code> you deference that null pointer rather than aborting the loop.</p>

<p>In any event <code>*lista[*nElem] = op;</code> should be <code>(*lista)[*nElem] = op;</code></p>

<p>Even if  <code>*nElem</code> was non-zero, the line:</p>

<pre><code>*lista = (int*)realloc(*lista, *nElem * sizeof(int));
</code></pre>

<p>is bad-practice, because if the reallocation fails the original block will leak because *lista will be come NULL without releasing whatever it previously pointed to.  Instead you should (for example):</p>

<pre><code>int* new_block = realloc(*lista, *nElem * sizeof(int));
if( new_block == NULL )
{
    printf( ""memory fail\n"" ) ;
    break ;
}

*lista = new_block ;
</code></pre>

<p>To work at all in main <code>tam</code> must be > 0, and to avoid possible failure due to implementation defined behaviour <code>nElem</code> should also be grater than zero. </p>
",1
59583944,59583202,1,"<p>I think the <code>tam</code> parameter is probably the block size to allocate. So for example, if tam = 10, allocate space for 10 ints. Then after taking 10 ints, realloc for 10 more.</p>

<p>Also, note that because of operator precedence, <code>*lista[*nElem] = op;</code> is the same as <code>*(lista[*nElem]) = op;</code>. You want to deference the pointer first, then use the brackets: <code>(*lista)[*nElem] = op;</code></p>

<pre><code>void leNumeros(int **lista, int *nElem, int *tam)
{
    if (*tam &lt;= 0) {
        puts(""Error: tam must be &gt; 0"");
        return;
    }

    int op;

    // Keep track of how many ints the array can hold
    int items_allocated = *tam;
    *lista = malloc(*tam * sizeof(int));

    if (*lista == NULL)
    {
        printf(""memory fail\n"");
    }
    else
    {
        do
        {
            printf(""number:\n"");
            if (1 != scanf(""%d"", &amp;op)) break;

            if (op &gt;= 0) {
                // Realloc a new block of tam bytes if out of space
                if (*nElem &gt;= items_allocated) {
                    items_allocated += *tam;
                    int *temp = realloc(*lista, items_allocated * sizeof(int));

                    if (temp == NULL) {
                        printf(""memory fail"");
                        break;
                    }
                    else {
                        *lista = temp;
                        printf(""added: %zu bytes total: %zu bytes\n"", *tam * sizeof(int), items_allocated * sizeof(int));
                    }
                }
                (*lista)[*nElem] = op;
                (*nElem)++;
            }
        } while (op &gt;= 0);
    }
}


int main(int argc, char** argv) {

    int *lista = NULL, nElem = 0, tam = 5;
    leNumeros(&amp;lista, &amp;nElem, &amp;tam);

    for (int i = 0; i &lt; nElem; i++) {
        printf(""%d "", lista[i]);
    }

    return (EXIT_SUCCESS);
}
</code></pre>
",0
53127480,53127433,2,"<p>To match the size of the anonymous struct, it would have to be not anonymous but then within standard C, you couldn't address its members transparently.</p>

<pre><code>typedef int T1,T2,T3; //example types
struct name{ //originally anonymous struct given a name
     T1 f1;
     T2 f2;
     T3 f3;
};
struct A{
    union {
        struct name embedded;
        char bytes[sizeof(struct name)];
        //^can size it now that is has a name
    } ;
}u;
</code></pre>

<p>Under extended C (<code>-fms-extensions</code>/<code>-fplan9-extensions</code> with gcc) you can do:</p>

<pre><code>typedef int T1,T2,T3;
struct name{
     T1 f1;
     T2 f2;
     T3 f3;
};
struct A{
    union {
        struct name; //embed struct name transparently
        char bytes[sizeof(struct name)];
    } ;
}u;
</code></pre>

<p>but in any case, none of this is necessary as the C standard explicitly allows you to reinterpret any object as a char array without causing any undefined behavior (Simply cast the pointer to the object to <code>char*</code> and pretend you're reading a <code>char</code> array).</p>

<p>Edit: if you need reinterpreting via a type other than char, you could use a macro as in:</p>

<pre><code>typedef int T1,T2,T3;
#define ANON_STRUCT \
    struct { \
         T1 f1; \
         T2 f2; \
         T3 f3; \
    }
struct A{
    union {
        ANON_STRUCT;
        ANON_STRUCT named_anon;
        #if __cplusplus
        char bytes[sizeof(named_anon)];
        #else
        char bytes[sizeof(ANON_STRUCT)];
        #endif
    } ;
}u;
</code></pre>

<p>but last time I checked you couldn't use unions for reinterpreting in C++ (only in C) -- you had to stick to using the currently active member.</p>
",5
52176117,52175111,0,"<p>There are several ways to do this:</p>

<p>If you know how big the dimensions need to be at compile time, and you want the rows to be contiguous in memory, do the following:</p>

<pre><code>#define ROWS 2
#define COLUMNS 5
...
int (*student)[COLUMNS] = malloc( sizeof *student * ROWS );
...
student[i][j] = some_value;
</code></pre>

<p>If you don't know how big the dimensions need to be at compile time, and you want the rows to be contiguous in memory, and your version of C supports variable-length array syntax (C99 or later):</p>

<pre><code>size_t rows;
size_t columns;

// get rows and columns somehow

int (*student)[columns] = malloc( sizeof *student * rows ); 
...
student[i][j] = some_value;
</code></pre>

<p>Strictly speaking, this will invoke undefined behavior since <code>sizeof</code> on a VLA is evaluated at runtime, and <code>student</code> hasn't been initialized to point anywhere meaningful yet.  However, I and others argue that this is a weakness in the wording of the language standard, and I've never had this not work as expected.  But, be aware, this isn't <em>guaranteed</em> to work everywhere all the time.  </p>

<p>If you don't know how big the dimensions need to be at compile time, and you need the rows to be contiguous in memory, and you don't have variable-length arrays available:</p>

<pre><code>size_t rows; 
size_t columns;

// get rows and columns;

int *student = malloc( sizeof *student * rows * columns );
</code></pre>

<p>Yeah, this is a 1D array; you'll have to map ""rows"" and ""columns"" onto this 1D structure:</p>

<pre><code>student[i * ROWS + j] = some_value;
</code></pre>

<p>If you don't know how big your dimensions need to be at compile time, and you don't care whether rows are contiguous or not, you can do this:</p>

<pre><code>size_t rows;
size_t columns;

// get rows and columns;

int **student = malloc( sizeof *student * rows );
if ( student )
{
  for ( size_t i = 0; i &lt; rows; i++ )
  {
    student[i] = malloc( sizeof *student[i] * columns );
  }
}
...
student[i][j] = some_value;
</code></pre>

<p>For the first three methods, cleanup is easy:</p>

<pre><code>free( student );
</code></pre>

<p>For the last method, you'll have to deallocate each ""row"" individually:</p>

<pre><code>for ( size_t i = 0; i &lt; rows; i++ )
  free( student[i] );
free( student );
</code></pre>
",0
54875308,54875214,7,"<p>Change <code>char *buffer</code> to <code>unsigned char *buffer</code>. Also change <code>%02x</code> to <code>%02hhx</code>.</p>

<p>In your C implementation, <code>char</code> is signed. When you read data into a buffer of <code>char</code>, you have signed values. When you use them in an expression (including arguments to <code>printf</code>), some of them have negative values. Additionally, values narrower than <code>int</code> are generally promoted to <code>int</code>. At that point, the <code>char</code> value ?92 (which is represented with bits 0xA4) becomes the <code>int</code> value ?92 (which is represented with bits 0xFFFFFFA4, in your C implementation).</p>

<p>So you have negative values that are converted to <code>int</code> and then printed with <code>%02x</code>, and <code>%02x</code> shows all the bits of the <code>int</code>. (In <code>%02x</code>, <code>2</code> specifies the minimum width; it does not restrict the result to two digits.)</p>

<p><code>%hhx</code> is a proper conversion specifier for an <code>unsigned char</code>. <code>%x</code> is for <code>unsigned int</code>.</p>
",3
54875340,54875214,0,"<p>The format specifier <code>%02x</code> specifies the <em>minimum</em> number of digits to be printed out, not the maximum.  The values <code>a4</code>, <code>8b</code> and <code>ef</code> are all negative when interpreted as signed bytes, so what you're seeing is the two's complement representation of these values as 32-bit <code>int</code>s, which is what they're promoted to when passed to <code>printf</code>.</p>

<p>Explicitly name buffer as <code>unsigned char</code> or <code>uint8_t</code> to avoid this unintended sign-extension, and use the correct format specifier (<code>%hhx</code> for lowercase <code>a</code>-<code>f</code> hex digits, <code>%hhX</code> for uppercase).</p>
",0
48670554,48647638,0,"<p>As Bathsheba's answer correctly points out, signed integer overflow has undefined behavior.</p>

<p>Having said that, the result of evaluating <code>LONG_MAX + 1</code> is likely to be <code>LONG_MIN</code> on most implementations. The reason you're not seeing a negative value when you print it is that you're printing it incorrectly.</p>

<pre><code>long int max = LONG_MAX;
long int max_plus_one = max + 1;

printf("" max \t\t %lx\n LONG_MAX \t %lx\n"", max, LONG_MAX);
printf("" max_plus_one \t %lx\n max + 1 \t %lx\n LONG_MIN \t %lx\n\n"",\
       max_plus_one, max + 1, LONG_MIN);
</code></pre>

<p>The <code>%lx</code> specifier requires an argument of type <code>unsigned long int</code>. You're giving it an argument of type (signed) <code>long int</code>. In particular, you're giving it a negative value.</p>

<p>Usually if you pass a numeric argument to a function expecting a different numeric type, the value will be converted. That's possible because the compiler knows what type the function expects. For <code>printf</code>, however, the expected type is determined by the format string, which isn't (necessarily) processed until run time. It's likely to interpret the contents of the <code>long int</code> object <em>as if</em>
it were an object of type <code>unsigned long int</code>, but strictly speaking the behavior is undefined.</p>

<p>Here's a simpler example where the number being printed was set to <code>LONG_MIN</code> without any overflow:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;
int main(void) {
    unsigned long num = LONG_MIN;
    printf(""num = %ld\n"", num);
    printf(""num = 0x%lx (undefined behavior)\n"", num);
}
</code></pre>

<p>The output on my system is:</p>

<pre><code>num = -9223372036854775808
num = 0x8000000000000000 (undefined behavior)
</code></pre>

<p>The positive value printed by the second <code>printf</code> does not indicate that <code>num</code> has a positive value, just that it's being printed incorrectly.</p>

<p>You <em>can</em> use <code>%lx</code> to print a signed value <em>if</em> it's within the range of both <code>long</code> and <code>unsigned long</code>. There is no format specifier that will print an arbitrary signed value in hexadecimal.</p>
",0
53639906,53639747,1,"<p>I guess you just got the middle section wrong. Try this to print the spaces:</p>

<pre><code>    for(z=0 ;z &lt; height - x; ++z)
        printf(""  ""); // &lt;- Notice there are 2 spaces being printed here.
</code></pre>
",2
55959952,55958327,-2,"<p>A better way would be to use portable library functions! </p>

<p>It will:</p>

<ul>
<li>Make your code future proof by adding support for IPv6</li>
<li>Make your code compatible with many other functions that use IP Addresses. </li>
</ul>

<p>For example:</p>

<pre><code>#include &lt;stdio.h&gt; 
#include &lt;string.h&gt;
#include &lt;arpa/inet.h&gt; 

void main(){
  // IP addresses might be longer on this system eg. see https://stackoverflow.com/questions/55958327/how-to-convert-an-int-array-to-an-ip-address-string-in-c
  char str[INET_ADDRSTRLEN];

  // this ""socket address"" is a very portable address format which you will use when dealing with sockets
  struct sockaddr_in sa;

  // this format is not portable or usable when dealing with other libaries, unless you convert it
  // note that technically 'unsigned char' is more accurate, but it will be processed slower than int on modern PC's
  unsigned char a_ipv4addr[4] = {192,168,1,60};

  // Don't do this! This will only work on little-endian machines, when compiled without certain optimizations - so it's not portable. That's why you should rather use the functions - some day soon you might want your code to run on a RISC V processor...
  memcpy(&amp;sa.sin_addr.s_addr,&amp;a_ipv4addr,4);
  inet_ntop(AF_INET, &amp;sa.sin_addr, str, INET_ADDRSTRLEN);
  printf(""Bad example with memcpy: %s\n"", str); 

  // sprintf your address, and then convert it - if you absolutely have to use your format
  sprintf(str,""%i.%i.%i.%i"",a_ipv4addr[0],a_ipv4addr[1],a_ipv4addr[2],a_ipv4addr[3]);
  inet_pton(AF_INET, str, &amp;(sa.sin_addr)); // now you can use it in other functions
  inet_ntop(AF_INET, &amp;sa.sin_addr, str, INET_ADDRSTRLEN); // just to show that it's correct
  printf(""Better example from generated string: %s\n"", str); 

  // you can also represent it as an unsigned int
  unsigned int ipv4addr=0x3c01a8c0; // c0.a8.01.3c = 192.168.1.60 backwards aka little-endian
  sa.sin_addr.s_addr=ipv4addr;
  inet_ntop(AF_INET, &amp;sa.sin_addr, str, INET_ADDRSTRLEN);
  printf(""Example from unsigned int: %s\n"", str);

  // you can also represent it as an unsigned int, in decimal
  ipv4addr=192+(168&lt;&lt;8)+(1&lt;&lt;16)+(60&lt;&lt;24);
  sa.sin_addr.s_addr=ipv4addr;
  inet_ntop(AF_INET, &amp;sa.sin_addr, str, INET_ADDRSTRLEN);
  printf(""Example from unsigned int decimal example: %s\n"", str);

  // Or just store it as a string to begin with...
  inet_pton(AF_INET, ""9.9.9.9"", &amp;(sa.sin_addr));
  // or if you read it from another function, you can convert it back and print it
  inet_ntop(AF_INET, &amp;(sa.sin_addr), str, INET_ADDRSTRLEN);
  printf(""Example from string: %s\n"", str); // prints ""9.9.9.9""

}
</code></pre>

<p>If you're on Linux, try:</p>

<pre><code>man inet_addr
</code></pre>

<p>To learn more!</p>
",2
59523783,59523730,1,"<p>You store pointers to variables with block scope, i.e. they go out of scope and must not be accessed once the block (in the <code>for</code>-loop) has finished; accessing these pointers later is undefined behaviour.</p>

<p>In your case, the input is probably written to the same memory space, such that the second input overrides the first one; And all your pointers probably point to the same memory address.</p>
",4
52699760,52699673,4,"<p>Literal string like e.g. <code>"" ""</code> is actually an <em>array</em> of (read-only) characters. As other arrays, it decays to a pointer to its first element. That means <code>c == "" ""</code> will compare the character in <code>c</code> with the <em>pointer</em> to the first character of <code>"" ""</code>.</p>

<p>To get a literal character, use single quotes instead, as in <code>' '</code>:</p>

<pre><code>if (c== ' ' ||  c== '\n' || c== '\t')
</code></pre>

<p>Now when you know how to use literal characters, you can use them inside a <code>switch</code> for your <code>case</code> labels.</p>

<p>But of course, don't reinvent the wheel, use the standard <a href=""https://en.cppreference.com/w/c/string/byte/isspace"" rel=""nofollow noreferrer""><code>isspace</code></a> function instead:</p>

<pre><code>if (isspace(c))
</code></pre>
",0
52699754,52699673,5,"<p>To begin with, there is no way the original code you posted works, it is not valid C.</p>

<p><code>switch</code> statements only work on integers, so you have to use the proper character constants such as <code>' '</code>. And not string literals <code>"" ""</code>. Example:</p>

<pre><code>switch(ch)
{
  case ' ':
  case '\n':
  case '\t':
    puts(""whitespace"");
  break;

  default:
    puts(""not whitespace"");
}
</code></pre>

<p>That being said, there is no need to roll out stuff like this manually. <code>#include &lt;ctype.h&gt;</code> then call the function <code>isspace</code> instead.</p>
",0
54628696,54628615,3,"<p><code>x[y]</code> is equivalent to <code>*(x + y)</code> which is equivalent to <code>*(y + x)</code> which is equivalent to <code>y[x]</code>.</p>
",0
54975797,54975623,8,"<p>The linked article explores a small artificial situation, and the difference demonstrated vanishes if you insert <code>const</code> after <code>*</code> in <code>const char *ptr = ""Lorum ipsum"";</code> (tested in Apple LLVM 10.0.0 with clang-1000.11.45.5).</p>

<p>The fact the compiler had to load <code>ptr</code> arose entirely from the fact it could be changed in some other module not visible to the compiler. Making the pointer <code>const</code> eliminates that, and the compiler can prepare the address of the string directly, without loading the pointer.</p>

<p>If you are going to declare a pointer to a string and never change the pointer, then declare it as <code>static const char * const ptr = ""string"";</code>, and the compiler can happily provide the address of the string whenever the value of <code>ptr</code> is used. It does not need to actually load the contents of <code>ptr</code> from memory, since it can never change and will be known to point to wherever the compiler chooses to store the string. This is then the same as <code>static const char array[] = ""string"";</code>¡ªwhenever the address of the array is needed, the compiler can provide it from its knowledge of where it chose to store the array.</p>

<p>Furthermore, with the <code>static</code> specifier, <code>ptr</code> cannot be known outside the translation unit (the file being compiled), so the compiler can remove it during optimization (as long as you have not taken its address, perhaps when passing it to another routine outside the translation unit). The result should be no differences between the pointer method and the array method.</p>

<p>Rule of thumb: Tell the compiler as much as you know about stuff: If it will never change, mark it <code>const</code>. If it is local to the current module, mark it <code>static</code>. The more information the compiler has, the more it can optimize.</p>
",8
54975710,54975623,2,"<p>From the performance perspective, this is a fairly small optimization which makes sense for low-level code that needs to run with the lowest possible latency.</p>

<p>However, I would argue that <code>const char s3[] = ""bux"";</code> is better from the semantic perspective, because the type of the right hand side is closer to type of the left hand side. For that reason, I think it makes sense to declare string constants with the array syntax.</p>
",2
54225859,54225723,0,"<p>On a Linux environment, you'll want to look at a tool like <a href=""https://www.systutorials.com/docs/linux/man/1-objdump/"" rel=""nofollow noreferrer""><code>objdump</code></a>, that will show you a bunch of information about the compiled output.</p>

<p>There are pages that explain some of its complicated output, such as <a href=""https://www.howtoforge.com/linux-objdump-command/"" rel=""nofollow noreferrer"">this</a>.
But perhaps one of the simplest is <code>objdump -T</code>.</p>
",0
54226347,54225723,1,"<p>It sounds like you are in need of perusing your source code.  <em><a href=""http://www.doxygen.nl/download.html"" rel=""nofollow noreferrer"">Doxygen</a></em> is an excellent tool for summarizing just about every aspect of a C project.  (and many other languages).  It is OpenSource, and easily downloaded.  Additionally, the <em><a href=""http://mcs.une.edu.au/doc/doxygen/html/features.html"" rel=""nofollow noreferrer"">list of features</a></em> is extensive.</p>
",0
58446229,58445914,1,"<p>The way you allocate memory for <code>Btenders</code> is incorrect.</p>

<pre><code>Btenders = (CUOfS **)malloc(sizeof (**Btenders) * numOfBCtenders)   // WRONG
</code></pre>

<p><code>sizeof (**Btenders)</code> is the same as <code>sizeof(CUOfS)</code>, but you need <code>sizeof(CUOfS*)</code> :</p>

<pre><code>Btenders = (CUOfS **)malloc(sizeof (*Btenders) * numOfBCtenders)    // FIXED
</code></pre>

<p>Similarly for :</p>

<pre><code>Btenders[counter] = (CUOfS *)malloc(sizeof (Btenders[counter]));    // WRONG
</code></pre>

<p><code>sizeof (Btenders[counter])</code> is the same as <code>sizeof(CUOfS*)</code>, but you need <code>sizeof(CUOfS)</code> :</p>

<pre><code>Btenders[counter] = (CUOfS *)malloc(sizeof (*(Btenders[counter]))); // FIXED
</code></pre>
",0
58391430,58391379,3,"<p>It happens because 
<code>ape</code> is still left in the input stream and your second <code>scanf</code> tries to read it but fails as it was expecting <code>integer</code> but found <code>chars</code>. </p>

<p>You can clear the input buffer after your first <code>scanf</code> as below.</p>

<pre><code>//first scanf

int c;
while ((c = getchar()) != '\n' &amp;&amp; c != EOF) { }


//second scanf
</code></pre>
",2
57227886,57227849,1,"<p>A cast operator has the same precedence as a unary <code>+</code> operator, but the <code>+</code> operator in <code>(int32_t) addr_base + offset</code> is a binary <code>+</code> operator, which has lower precedence.</p>

<p>A <em>unary</em> operator is one with only one operand. In <code>x = -y;</code>, the <code>-</code> is a unary operator. We can also write <code>x = +y;</code>, where the <code>+</code> is a unary operator, but this is rarely done since it is largely superfluous.</p>

<p>A <em>binary</em> operator is one with two operands. In <code>x = y + z</code>, the <code>+</code> is a binary operator.</p>
",0
50767329,50767276,0,"<p>Yes, the <code>continue</code> is redundant in this case because it is at the end of the loop.  In fact, you can just put a <code>;</code> at the end of the <code>while</code>.</p>
",1
54412556,54411081,0,"<p>See <a href=""http://c-faq.com/varargs/varargs1.html"" rel=""nofollow noreferrer"">http://c-faq.com/varargs/varargs1.html</a>.</p>

<pre><code>#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;  /* printf */

struct my_struct {
    int i;
};

struct other_struct {
    char a;
};

struct third_struct {
    float f;
};

struct fourth_struct {
    double d;
};

static int do_one_thing(struct my_struct *s, struct other_struct *os) {
    printf(""do one thing %d %c.\n"", s-&gt;i, os-&gt;a);
    return s-&gt;i;
}

static int do_another_thing(struct third_struct *ts, struct fourth_struct *s,
    int i) {
    printf(""do another thing %f %f %d.\n"", ts-&gt;f, s-&gt;d, i);
    return i;
}

static int do_even_more_stuff(float *f, struct fourth_struct *s, int i) {
    printf(""do even more stuff %f %f %d.\n"", *f, s-&gt;d, i);
    return i;
}

enum Fn { ONE, ANOTHER, STUFF };

static int wrapper_function(const enum Fn fn, ... ) {
    va_list argp;
    int fun_ret = 0;
    struct my_struct *s;
    struct other_struct *os;
    struct third_struct *ts;
    struct fourth_struct *fs;
    int i;
    float *f;

    va_start(argp, fn);

    switch(fn) {
        case ONE:
            s = va_arg(argp, struct my_struct *);
            os = va_arg(argp, struct other_struct *);
            fun_ret = do_one_thing(s, os);
            break;
        case ANOTHER:
            ts = va_arg(argp, struct third_struct *);
            fs = va_arg(argp, struct fourth_struct *);
            i = va_arg(argp, int);
            fun_ret = do_another_thing(ts, fs, i);
            break;
        case STUFF:
            f = va_arg(argp, float *);
            fs = va_arg(argp, struct fourth_struct *);
            i = va_arg(argp, int);
            fun_ret = do_even_more_stuff(f, fs, i);
            break;
    }

    va_end(argp);

    return fun_ret;
}

int main(void) {
    struct my_struct s = { 42 };
    struct other_struct os = { 'z' };
    struct third_struct ts = { 3.14f };
    struct fourth_struct fs = { 0.9999 };
    float f = 2.001;
    int r0, r1, r2;
    printf(""Function one returned %d.\n""
        ""Function another returned %d.\n""
        ""Function stuff returned %d.\n"",
        r0 = wrapper_function(ONE, &amp;s, &amp;os),
        r1 = wrapper_function(ANOTHER, &amp;ts, &amp;fs, 99),
        r2 = wrapper_function(STUFF, &amp;f, &amp;fs, -3));
    return 0;
}
</code></pre>

<p>However, I don't really see what the advantage is; one is increasing overhead and basically turning off type-checking.</p>
",0
49691058,49690804,5,"<p>I would use an array of structures:</p>

<pre><code>static bool do_abc(void)
{
  // ...
}

bool dispatch(const char *str)
{
  static const struct {
    const char *key;
    bool (*func)(void);
  } funcs[] = {
    { ""abc"", do_abc },
    { ""def"", do_def },
    { ""ghi"", do_ghi },
  };
  for (size_t i = 0; i &lt; sizeof funcs / sizeof *funcs; ++i)
  {
    if(strcmp(funcs[i].text, str) == 0)
      return funcs[i].func();
  }
  return false;
}
</code></pre>

<p>This assumes that all the functions have the same signature, otherwise it's hard to generalize.</p>

<p>By the way, this can be called an example of ""data-driven code"", which is often nice.</p>
",1
49691116,49690804,1,"<p>depends on your needs there are several other way you can use. </p>

<p>For example, you an initially create a sorted array of strings which you compare against and use binary search: <a href=""https://linux.die.net/man/3/bsearch"" rel=""nofollow noreferrer"">https://linux.die.net/man/3/bsearch</a>. </p>

<p>You can use hash tables or trees as well, just a bit more complicated.</p>

<p>In some cases you might even create a combined string of all your strings like ""abcdefdhi"" and use <code>strstr</code> to find the string in a singe operation.</p>
",0
49313727,49313593,7,"<p>Structure tags are in the 'tag' name space, shared with unions and enumerations.  This is wholly separate from the 'ordinary identifier' name space (holding typedef names and variable names and function names), and also from the per-structure member names namespace.</p>

<p>That means you could have:</p>

<pre><code>struct sth       // DO
{                // NOT
    int sth;     // DO
} sth;           // THIS!
</code></pre>

<p>This declares a structure variable <code>sth</code> of type <code>struct sth</code> with one member named <code>sth</code>.</p>

<p>The compiler can keep all that straight; you probably can't and probably shouldn't.  In other words, although you can write code like that, it would be an incredibly bad idea to actually do so.</p>
",0
48332725,48332693,4,"<p>C99 introduces <a href=""https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html#Designated-Inits"" rel=""noreferrer"">Designated Initializers</a>, with which you can initialize an array
in any order by using the index.</p>

<blockquote>
  <p><em><a href=""https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html#Designated-Inits"" rel=""noreferrer"">6.27 Designated Initializers</a></em></p>
  
  <p>Standard C90 requires the elements of an initializer to appear in a fixed order, the same as the order of the elements in the array or structure being initialized.</p>
  
  <p>In ISO C99 you can give the elements in any order, specifying the array indices or structure field names they apply to, and GNU C allows this as an extension in C90 mode as well. This extension is not implemented in GNU C++.</p>
  
  <p>To specify an array index, write <code>[index] =</code> before the element value. For example,</p>

<pre><code>int a[6] = { [4] = 29, [2] = 15 };
</code></pre>
  
  <p>is equivalent to</p>

<pre><code>int a[6] = { 0, 0, 15, 0, 29, 0 };
</code></pre>
</blockquote>
",0
57822137,57821911,2,"<p>The token <code>S</code> will be replaced with <code>113</code> everyplace it appears.  You have a few options to fix this:</p>

<ul>
<li><p>Rename the parameter to <code>some_funcN</code>:</p>

<pre><code>double some_funcN( float n )
{
   return n/0.1;
}
</code></pre></li>
<li><p>Undefine the constant before the function and redefine it after.  This has the disadvantage that <code>S</code> is defined in multiple places, so I wouldn't recommend it:</p>

<pre><code>#undef S
double some_funcN( float S )
{
   return S/0.1;
}
#define S 113
</code></pre></li>
<li><p>Change <code>S</code> from a macro to a variable.  This allows variable scoping rules to take effect so that the function parameter <code>S</code> masks the definition of the variable <code>S</code> declared at file scope.</p>

<pre><code>const int S = 113;
</code></pre></li>
</ul>
",1
56434219,15316455,0,"<p>This code will work on Win32 applications (regardless of the subsystem used: WINDOWS or CONSOLE):</p>

<pre><code>inline void setFontSize(int a, int b) 

{

    HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

    PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx = new CONSOLE_FONT_INFOEX();

    lpConsoleCurrentFontEx-&gt;cbSize = sizeof(CONSOLE_FONT_INFOEX);

    GetCurrentConsoleFontEx(hStdOut, 0, lpConsoleCurrentFontEx);

    lpConsoleCurrentFontEx-&gt;dwFontSize.X = a;

    lpConsoleCurrentFontEx-&gt;dwFontSize.Y = b;

    SetCurrentConsoleFontEx(hStdOut, 0, lpConsoleCurrentFontEx);

}
</code></pre>

<p>Then just call (for example):</p>

<pre><code>setFontSize(20,20);
</code></pre>
",0
55986227,55986196,6,"<p>The string literals have <em>static storage duration</em>. For such an object, <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.2.4p3"" rel=""noreferrer"">C11 6.2.4p3</a> says that:</p>

<blockquote>
  <p>Its lifetime is the entire execution of the program and its stored value is initialized only once, prior to program startup.</p>
</blockquote>

<p>And  of lifetime <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.2.4p2"" rel=""noreferrer"">C11 6.2.4p2</a></p>

<blockquote>
  <ol start=""2"">
  <li>The lifetime of an object is the portion of program execution during which storage is guaranteed to be reserved for it. An object exists, has a constant address,33) and retains its last-stored value throughout its lifetime.34) If an object is referred to outside of its lifetime, the behavior is undefined. The value of a pointer becomes indeterminate when the object it points to (or just past) reaches the end of its lifetime. </li>
  </ol>
</blockquote>

<p>I.e. you can safely store a pointer to a string literal for the remainder of program execution.</p>

<hr>

<p>However, attempts to <code>free</code> a string literal will have undefined behaviour, so if you sometimes use a string literal and sometimes a <code>malloc</code>ated string, you need to either keep track of it, or use your 2nd alternative for all cases. </p>

<p>And since string literals are immutable, you must copy them if you intend to modify the string. </p>

<hr>

<p>Finally, <code>malloc(sizeof(input_string))</code> is wrong, it <strong>must be</strong> <code>malloc(strlen(input_string) + 1)</code>. For duplicating a string, POSIX  has the <a href=""https://stackoverflow.com/a/252802/918959""><code>strdup</code> function</a>.</p>
",2
51358336,51358141,5,"<pre><code>if (--i)
</code></pre>

<p>This will evaluate true the first time (<code>--i == 4</code>). The code recurses into <code>main()</code>. (<a href=""https://en.wikipedia.org/wiki/Recursion_(computer_science)"" rel=""nofollow noreferrer""><em>Recursion</em></a>: A function calling itself.)</p>

<p>As <code>i</code> is <a href=""https://en.cppreference.com/w/c/language/static_storage_duration"" rel=""nofollow noreferrer""><em>static</em></a>, it will retain its value of <code>4</code> (as opposed to an automatic variable, which would be initialized to <code>5</code> again). The <code>if (--i)</code> in this <em>second</em> execution of <code>main()</code> will again be true (evaluating to <code>3</code>), and will again call <code>main()</code> (for a third execution of the function).</p>

<p>The same for <code>--i == 2</code> and <code>--i == 1</code>, for four executions of <code>main()</code> (including the first, non-recursive one) total that are evaluating the <code>if</code> condition to true.</p>

<p>The next recursion will evaluate the <code>if</code> condition to <code>--i == 0</code>, and thus false. Skipping the <code>if</code> clause, the function call will just return. <em><code>i</code> is zero at this point, and -- being <code>static</code>, i.e. only one persistent <code>i</code> for all instances of <code>main()</code> -- will remain at that value.</em></p>

<p>The <code>main()</code> call one level up the stack -- the one that evaluated <code>--i == 1</code>, then called <code>main()</code> and was waiting for it to return -- will now continue with the statement after the call to <code>main()</code>, and <code>printf()</code> the <em>current</em> value of <code>i</code>... which is <code>0</code>.</p>

<p>The same happens three more times (for a total of four) until the top-most <code>main()</code> returns. You get four times the current value of <code>i</code>, which is <code>0</code>.</p>

<hr>

<p>Note that calling <code>main()</code> from your program is allowed in C, but not in C++. This is specifically for calling <strong><code>main()</code></strong> recursively; for other functions, it is allowed in either language.</p>
",0
50804580,50804558,5,"<p>What you're looking for is called a <strong>compound literal</strong>:</p>

<pre><code>arraysomething((double []){1.,2.});
</code></pre>

<p>The syntax looks like an initializer for an array or struct preceeded by what looks like a cast to the type in question.  </p>

<p>Because you want to pass in array, the typename given should be <code>double []</code>, which means an array of unspecified size.  The actual size isn't needed because it is inferred from the number of elements in the literal.</p>
",3
54494376,54494308,2,"<p>The most likely culprit of your problem is that you sort the <em>whole</em> array, even when maybe not all elements are initialized.</p>

<p>If the file contains less than the 30 elements you have for the array, parts of the array will be <em>uninitialized</em> with <em>indeterminate</em> contents (which may sometimes seem random or like ""garbage""). You should not use those when sorting, only sort the data you actually have read from the file.</p>

<p>You have the number of valid and initialized elements in the array in the variable <code>i</code> which you should use instead:</p>

<pre><code>qsort(staff, i, sizeof(employee), struct_cmp_by_name);
</code></pre>

<p>You have the same problem when printing the data: You print the whole array, including the uninitialized parts.</p>

<p>I suggest you create a new variable for the number of valid elements, suitable named, instead of the generic <code>i</code> that you now use.</p>
",2
48639713,48638821,0,"<p>The only way to really understand this kind of stuff (memory management, pointer behaviour, etc.) is to experiment yourself. Anyway, I smell someone is trying to seem clever fooling students, so I will try to clarify a few things.</p>

<pre><code>int a[NUM]={20,-90,450,-37,87};
int *p;
</code></pre>

<p>This structure in memory would be something like:</p>

<p><a href=""https://i.stack.imgur.com/yfrKu.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/yfrKu.png"" alt=""A pointer &lt;code&gt;p&lt;/code&gt; pointing to the first element in &lt;code&gt;a&lt;/code&gt;.""></a></p>

<p>This creates a vector of five <code>int</code>, so far, so good. The obvious move, given that data, is to run over the elements of a using <code>p</code>. You would do the following:</p>

<pre><code>for(p = a; p &lt; (a + NUM); ++p) {
    printf(""%d "", *p);
}
</code></pre>

<p>However, the first change to notice is that both loops convert the pointers to <code>char</code>. So, they would be:</p>

<pre><code>for (p=a;(char *)p&lt;((char *)a+sizeof(int)*NUM); ++p) {
    printf(""%d "", *p);
}
</code></pre>

<p>Instead of pointing to <code>a</code> with a pointer to <code>int</code> the code converts <code>p</code>to a pointer to <code>char</code>. Say your machine is a 32bit one. Then an <code>int</code> will probably occupy four bytes. With <code>p</code> being a pointer to <code>int</code>, when you do <code>++p</code> then you effectively go to the next element in <code>a</code>, since transparently your compiler will jump four bytes. If you convert the <code>int</code> pointer to a <code>char</code> instead, then you cannot add <code>NUM</code> and assume that you are the end of the array anymore: a <code>char</code> is stored in one byte, so <code>((char *)p) + 5</code> will point to the second byte in the second element of <code>a</code>, provided it was pointing at the beginning of <code>a</code> before. That is way you have to call <code>sizeof(int)</code> and multiply it by <code>NUM</code>, in order to get the end of the array.</p>

<p>And finally, the infamous <code>*p++ = ++*p&lt;60 ? *p : 0;</code>. This is something unfair to face students with, since as others have already pointed out, the behaviour of that code is undefined. Lets go expression by expression.</p>

<p><code>++*p</code> means ""access <code>p</code> and add 1 to the result. If <code>p</code> is pointing to the first position of <code>a</code>, then the result would be 21. <code>++*p</code>not only returns 21, but also stored 21 in memory in the place where you had 20. If you were only to return 21, you would write; <code>*p + 1</code>.</p>

<p><code>++*p&lt;60 ? *p : 0</code> means ""if the result of permanently adding 1 to the value pointed by <code>p</code> is less than <code>60</code>, then return that result, otherwise return 0.</p>

<p><code>*p++ = x</code> means ""store the value of <code>x</code> in the memory address pointed by <code>p</code>, and then increment <code>p</code>. That's why you don't find <code>++p</code> or <code>p++</code> in the increment part of the <code>for</code> loop.</p>

<p>Now about the whole instruction (<code>*p++ = ++*p&lt;60 ? *p : 0;</code>), it is undefined behaviour (check @Lundin's answer for more details). In summary, the most obvious problem is that you don't know which part (the left or the right one), around the assignment operator, is going to be evaluated first. You don't even know how the subexpressions in the expression at the right of the assignment operator are going to be evaluated (which order).</p>

<p>How could you fix this? It would be actually be very simple:</p>

<pre><code>for (p=a;(char *)p&lt;((char *)a+sizeof(int)*NUM); ++p) {
    *p = (*p + 1) &lt;60 ? (*p + 1) : 0;
}
</code></pre>

<p>And much more readable. Even better:</p>

<pre><code>for (p = a; p &lt; (a + NUM); ++p) {
    *p = (*p + 1) &lt;60 ? (*p + 1) : 0;
}
</code></pre>

<p>Hope this helps.</p>
",5
48640067,48638821,4,"<p>The question is similar to <a href=""https://stackoverflow.com/questions/949433/why-are-these-constructs-using-undefined-behavior-in-c"">Why are these constructs (using ++) undefined behavior in C?</a> although not an exact duplicate due to the (subtle) sequence point inside the <code>?:</code> operator.</p>

<p><strong>There is no predictable output since the program contains undefined behavior.</strong></p>

<p>While the sub-expression <code>++*p</code> is sequenced in a well-defined way compared to <code>*p</code> because of the internal sequence point of the <code>?:</code> operator, this is not true for the other combinations of sub-expressions. Most notably, the order of evaluation of the operands to <code>=</code> is not specified:</p>

<p>C11 6.5.15/3: </p>

<blockquote>
  <p>The evaluations of the operands are unsequenced.</p>
</blockquote>

<p><code>*p++</code> is not sequenced in relation to <code>++*p</code>. The order of evaluation of the sub-expressions is unspecified, and since there are multiple unsequenced side-effects on the same variable, the behavior is undefined.</p>

<p>Similarly, <code>*p++</code> is not sequenced in relation to <code>*p</code>. This also leads to undefined behavior.</p>

<p>Summary: the code is broken and full of bugs. Anything can happen. Whoever gave you the assignment is incompetent.</p>
",0
48639375,48638821,3,"<blockquote>
  <p>at the beginning i want to understand what the first for statement doing</p>
</blockquote>

<p>This is what one would call code obfuscation... The difficult part is obviously this one:</p>

<pre><code>(char *)p &lt; ((char *)a+sizeof(int)*NUM);
</code></pre>

<p>OK, we convert p to a pointer to char, then compare it to another pointer retrieved from array a that points to the first element past a: <code>sizeof(int)*NUM</code> is the size of the array - which we could have gotten much more easily by just having <code>sizeof(a)</code>, so <code>(char*)p &lt; (char*)a + sizeof(a)</code></p>

<p>Be aware that comparing pointers other than with (in-)equality is undefined behaviour if the pointers do not point into the same array or one past the end of the latter (they do, in this example, though).</p>

<p>Typically, one would have this comparison as <code>p &lt; a + sizeof(a)/sizeof(*a)</code> (or <code>sizeof(a)/sizeof(a[0])</code>, if you prefer).</p>

<p><code>*p++</code> increments the pointer and dereferences it afterwards, it is short for <code>p = p + 1; *p = ...</code>. <code>++*p</code>, on the other hand first dereferences the pointer and increments the value it is pointing to (note the difference to <code>*++p</code>, yet another variant - can you get it yourself?), i. e. it is equivalent to <code>*p = *p + 1</code>.</p>

<p>The entire line <code>*p++ = ++*p&lt;60 ? *p : 0;</code> then <em>shall</em> do the following:</p>

<ul>
<li>increment the value of <code>*p</code></li>
<li>if the result is less than 60, use it, otherwise use 0</li>
<li>assign this to <code>*p</code></li>
<li>increment <code>p</code></li>
</ul>

<p>However, this is <strong>undefined behaviour</strong> as there is no sequence point in between read and write access of <code>p</code>; you do not know if the left or the right side of the assignment is evaluated first, in the former case we would assign <code>a[i] = ++a[i + 1]</code>, in the latter case, <code>a[i] = ++a[i]</code>! You might have gotten different output with another compiler!!!</p>

<p>However, these are only the two most likely outputs &ndash; actually, if falling into undefined behaviour, <em>anything</em> might happen, the compiler might just to ignore the piece of code in question, decide not to do anything at all (just exit from main right as the first instruction), the program might crash or it could even switch off the sun...</p>

<p>Be aware that one single location with undefined behaviour results in the whole program itself having undefined behaviour!</p>
",0
52733777,52733459,3,"<p>Why you are getting error is explained in John Zwinck's links, but how to solve it for you, it depends. You could create constructor function which does initialisation for you e.g.</p>

<pre><code>static stack_t* entry_times;
__attribute__((constructor))
void my_init(){
    entry_times=create_stack(500);
}
</code></pre>

<p>or you could create a wrapper function around it </p>

<pre><code>stack_t* my_entry_times(){
    static stack_t* entry_times;
    if (!entry_times) {
        entry_times=create_stack(500);
    }
    return entry_times;
}
</code></pre>

<p>and use <code>my_entry_times()</code> instead of <code>entry_times</code> in code</p>
",1
58520326,58520107,0,"<p>Well, you don't needed it. Some compilers however will give you a warning which you would suppress with a pragma, or suppress by having an extra return. And then that might also get you a warning on a different compiler, because the statement is unreachable.</p>

<p>For that piece of code, I'd try to move the if test into the while, so you have</p>

<pre><code>int is_thing_five() 
{
    while (not thing_is_ready)
    {
         update_thing();
    }
    return thing == 5;
}
</code></pre>

<p>which is somewhat clearer as it doesn't have an infinite loop with a test to break out of it in the middle.</p>
",0
58520200,58520107,3,"<p>In C, the behaviour of <em>using</em> a return value from a non-void function that does not have an explicit return value is <em>undefined</em>.</p>
<p>So, no you don't need the <code>return</code> statement, and you wouldn't need it even if the end of the function was reachable, so long as a caller of the function doesn't use the return value.</p>
<p><code>int main</code> is an exception to this rule: you are allowed to call <code>main</code> from itself (indirectly or otherwise), and you are allowed to assume an implicit <code>return 0;</code> on any branch that doesn't have an explicit return value.</p>
<hr>
<p>Interesting, before C11 the behaviour of a function with an infinite loop that &quot;did nothing&quot; was <em>undefined</em>. But C11 defines the behaviour by way of a footnote in the standard:</p>
<p>C11, 6.8.5 ad 6:</p>
<blockquote>
<p>An iteration statement whose controlling expression is not a constant expression,<sup>156)</sup> that performs no input/output operations, does not access volatile objects, and performs no synchronization or atomic operations in its body, controlling expression, or (in the case of a for statement) its expression-3, may be assumed by the implementation to terminate.<sup>157)</sup></p>
<hr />
<p><sup>157)</sup><sub>This is intended to allow compiler transformations such as removal of empty loops even when termination cannot be proven.</sub></p>
</blockquote>
",2
51461948,51461732,-2,"<p>No, there's no way to distinguish between <code>list[a] == NULL</code> and <code>list[a] == 0</code>. <code>list</code> is nothing more than a block of memory where every 4 bytes are considered be an integer.</p>

<p>The basic problem is you want to distinguish between elements which are empty and those which have a value. There's a few ways to handle this.</p>

<h1>Use a special integer.</h1>

<p>You could define all negative numbers as ""empty"". Or, if you need negative values, perhaps just one value. <code>INT_MIN</code> is a good choice.</p>

<p>But special values lead to bugs, and there's no type checking to save you, and you need to specially initialize each list. There are better ways.</p>

<h1>Use integer pointers.</h1>

<p>Instead of storing integers, store pointers to integers. Now <code>NULL</code> works.</p>

<pre><code>int main() {
    int **list = calloc(10, sizeof(int*));
    int num = 42;
    list[5] = &amp;num;

    for( size_t i = 0; i &lt; 10; i++ ) {
        int *entry = list[i];
        if( entry == NULL ) {
            continue;
        }
        printf(""%d\n"", *entry);
    }
}
</code></pre>

<p>The downside if you're storing pointers, so you have to remember to copy lest you alter the original memory. Also now <code>NULL</code> can't be used as a sentry to indicate the end of the array.</p>

<h1>Use a hash or tree</h1>

<p>The real solution is to change your data structure to better match the job. An array is great if you have a complete, ordered list of things easily indexed with integers. If you have an incomplete list with gaps, a hash might be a better fit. Here's an example using <a href=""https://developer.gnome.org/glib/stable/glib-Hash-Tables.html"" rel=""nofollow noreferrer"">GLib's hash table</a>.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;glib.h&gt;

// A little convenience function for inserting integers into a hash
// that normally wants pointers.
gboolean hash_table_insert_int(
    GHashTable *table, int key, int value
) {
    return g_hash_table_insert( table, GINT_TO_POINTER(key), GINT_TO_POINTER(value) );
}

int main() {    
    GHashTable *numbers = g_hash_table_new(g_direct_hash, g_direct_equal);

    // Add 5 -&gt; 42 and 9 -&gt; 23
    hash_table_insert_int( numbers, 5, 42 );
    hash_table_insert_int( numbers, 9, 23 );

    // Iterate through the entries in the table.
    GHashTableIter iter;
    gpointer key, value;
    g_hash_table_iter_init(&amp;iter, numbers);
    while( g_hash_table_iter_next(&amp;iter, &amp;key, &amp;value) ) {
        printf(""%d -&gt; %d\n"", (int)key, (int)value);
    }
}
</code></pre>

<p>GLib's data structures take some getting used to because it's designed to be type generic, but it's worth it for the robust flexibility they bring. Now you have a data structure which you can explicitly insert and delete entries without messing with special values, it knows its memory boundaries, and is memory and performance efficient.</p>
",0
50826940,50826908,2,"<p>The array <code>cipher</code> is <em>uninitialized</em>. It's contents is <em>indeterminate</em> (and will seem almost random). It might not contain the string-terminator at all, which means <code>strlen</code> will go out of bounds in its search for it. In your specific case you seem to be ""lucky"" that the second element in your array just happens to be the terminator.</p>

<p>And you seem to forget that <code>char</code> strings are really called <strong><em>null-terminated</strong> byte strings</em>. That <em>null-terminator</em> also needs space. And exist of course.</p>

<p>All in all plenty of chances for <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>.</p>
",18
49213033,49212814,1,"<p>If want variable <code>cache_t s;</code> to be allocated on the stack then you cannot have flexible size array member <code>char data[];</code> since there is no way to allocate memory for it. </p>

<p><strong>It is not possible to modify the array base address, array base address is a constant pointer.</strong></p>

<pre><code> my_static_cache.data = malloc(100); // it would fail for char data[]
</code></pre>

<p>You would have to use a 'classical' approach with <code>char *data;</code> which you  surely know already:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct cache_s
{
    int length;  
    char *data;
} cache_t;

int main(void)
{
    cache_t my_static_cache;
    char  *str  = ""123456789"";

    my_static_cache.data = malloc(100);
    strcpy(my_static_cache.data,str);

    printf(""%s"",my_static_cache.data);
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>123456789
</code></pre>
",4
56582648,56582169,1,"<p>You can't. Hard links also exist on Windows and the C standard library has no methods for operating on them.</p>

<p>Plausible solutions to the larger problem: link against cygwin1.dll and use the st_ino method. You omitted st_dev from your sample code and need to put it back.</p>

<p>While there is an actual way to accomplish this on Windows, it involves ntdll methods and I had to read Cygwin's code to find out how to do it.</p>

<p>The methods are NtGetFileInformationByHandle and NtFsGetVolumeInformationNyHandle. There are documented kernel32 calls that claim to do the same thing. See the cygwin source code for why they don't work right (buggy fs drivers).</p>
",0
51541426,51540688,1,"<p>Since <code>test</code> is an <code>int</code>, <code>&amp;test</code> is a pointer to an <code>int</code>. The function you are calling expects a pointer to a <code>char</code> in its second argument.</p>

<p>The C operator for converting a thing of one type to a thing of another type is a cast operator. It has the form <code>(</code> <em>type-name</em> <code>)</code> <em>expression</em>.</p>

<p>The type name of a pointer to <code>char</code> is <code>char *</code>. To take the address of <code>test</code> and convert it to a pointer to <code>char</code>, you write:</p>

<pre><code>(char *) &amp;test
</code></pre>

<p>This particular conversion is supported in C, subject to various caveats that the software you are working with has presumably accounted for. (It is not unusual for system functions to treat arbitrary objects as sequences of bytes.) However, you should be aware that not all pointer conversions are proper C. Before converting to types that are pointers other than pointers to character objects, you should learn C¡¯s rules about pointer conversions.</p>
",0
52322859,52322825,5,"<p><code>int getc ( FILE * stream );</code> gets a character from the stream.</p>

<p>It returns the character currently pointed by the internal file position indicator of the specified stream. The internal file position indicator is then advanced to the next character. (The increment.)
Which is this line specfically:</p>

<blockquote>
  <p><code>ch = getc(fp);</code></p>
</blockquote>
",0
58125921,58125846,3,"<p>It's probably your index formula in <code>p[i*noOfDays+j]</code> is not correct.</p>

<p>Change it from <code>p[i*noOfDays+j]</code> to <code>p[i*transcount+j]</code>.</p>

<p>The reason is the <code>i</code> is the index of the current transaction group.
The <code>j</code> is the index of specific transaction in a day.</p>
",0
49343392,49343308,0,"<p>You could introduce a state variable to tell the program that you are on comment
mode. Like this:</p>

<pre><code>// mode == 0 --&gt; normal
// mode == 1 --&gt; comment, remove/ignore comments
int mode = 0;
char line[100];
while(fgets(line, sizeof line, myFile))
{
    char *newline = strchr(line, '\n');

    if(mode == 1)
    {
        if(newline)
            mode = 0; // restore normal mode

        continue; // ignore read characters
    }

    char *comment = strchr(line, '#');

    if(comment)
    {
        *comment = '\0';

        if(newline == NULL)
            mode = 1; // set comment mode
    }

    // process your line without the comment
}
</code></pre>

<p>If a comment is found, <code>strchr</code> returns a pointer to that location. Setting it
to <code>'\0'</code> allows you to process the line without a comment. If the comment is
larger than <code>line</code> can hold, then the newline character is not found. In that case
you have to skip the next read bytes of <code>fgets</code>, until you find a newline.
That's when the <code>mode</code> variable comes in handy, you set it to 1 so the next
iterations can ignore the line if a newline is not found.</p>
",0
57843410,57843266,1,"<p>If you use this for the input:</p>

<pre><code>scanf("" %c"", &amp;checkbit);
</code></pre>

<p>you have to input characters with the code 0x01 ... 0x16, which is quite difficult, because these are special codes and you won't be able to easily type most of them on your keyboard.</p>

<p>For example, f you try to input <code>1</code> -- this will come as ASCII code 49 -- and the number of bit you'll be checking is way above what you're expecting to.</p>

<p>This is why getting your input as an integer is the preferred way in situations like yours.</p>
",0
55373798,55373268,0,"<p>Add space also in loop</p>

<pre><code>int m,n;
FILE* file = fopen(""file1.txt"", ""r""); // open a file
while(fscanf (file, ""(%d, %d)"", &amp;m, &amp;n)==2 || fscanf (file, ""(%d, %d) "", &amp;m, &amp;n)==2 ||fscanf (file, "" (%d, %d)"", &amp;m, &amp;n)==2)
{
    printf(""m is %d:\n"", m);
    printf(""n is %d:\n"", n);
}
//close the file after opening
fclose (file);
</code></pre>

<p>Alternatively </p>

<pre><code>int m,n;
char ch;
FILE* file = fopen(""file1.txt"", ""r""); // open a file
while (!feof (file))
{
     fscanf (file, ""(%d, %d)"", &amp;m, &amp;n);
     printf(""m is %d:\n"", m);
     printf(""n is %d:\n\n"", n);
     while((ch = fgetc(file)) != EOF)
         if(ch == ' ')
             break;
}
//close the file after opening
fclose (file);
</code></pre>

<p><strong>EDIT:</strong> To answer the comment. </p>

<p><strong>EDIT2:</strong> Modified the regular expression to avoid space and line end </p>

<blockquote>
  <p><strong>%*c</strong> 
  this escape sequence can be added to avoid multiple characters. This is similar to using <strong>regular expression</strong> during scanf. </p>
</blockquote>

<pre><code>while(fscanf (file, ""(%d%*c%d%*[) \n]"", &amp;m, &amp;n)==2)
{
    printf(""m is %d:\n"", m);
    printf(""n is %d:\n"", n);
}
</code></pre>
",2
55137559,55137301,-2,"<p>The simplest way is to just read integers and stop when there is no more integers to read. <code>scanf</code> works fine:</p>

<pre><code>int n;
while (scanf(""%d"", &amp;n) == 1) {
    // do something with integer n
}
// last scanf call failed to find an integer, so that's probably the end of input
</code></pre>

<p>This will not work if the input is in form ""integers, empty line, more integers that should be ignored"". In that case the code should be a bit more complex.</p>
",2
56588815,56588419,2,"<p>It looks like <a href=""https://github.com/vurtun/nuklear/blob/master/nuklear.h#L220"" rel=""nofollow noreferrer"">it does include header guards</a> now.  Try updating the library.  If that doesn't work file a bug or, even better, a pull request.</p>

<p>It's open source software, if you find something wrong you can fix it instead of trying to work around the problem.</p>
",0
53630096,53629973,4,"<p>See <a href=""https://stackoverflow.com/questions/52550/what-does-the-comma-operator-do"">What does the comma operator , do?</a></p>

<p>After understanding how the comma operator works, we can tell that this code is equivalent to:</p>

<pre><code>int a,b=5;
b++;
++b;
b*4; // nonsense, the result isn't stored anywhere
a=b-3;
printf(""%d"",a);
</code></pre>

<p>5 + 1 + 1 - 3 = 4. The <code>b*4</code> part does nothing and is just obfuscation.</p>
",0
52208084,52207839,5,"<p>As I think you mean it, for any array or pointer 'a' and index <code>i</code> the expression <code>a[i]</code> is exactly equal to <code>*(a + i)</code>.</p>

<p>That means e.g. <code>a[0]</code> is equal to <code>*(a + 0)</code>. And <code>*(a + 0)</code> is equal to <code>*(a)</code> which is equal to <code>*a</code>.</p>

<p>If <code>a</code> is an array of characters, as shown in your example, then <code>*a</code> is indeed the value of the first element. But if <code>a</code> is an array of arrays, like</p>

<pre><code>char a[2][4] = { ""Foo"", ""Bar"" };
</code></pre>

<p>then <code>*a</code> is is <em>still</em> the first element of <code>a</code>, and in this case it's <em>another array</em> (the one containing the string <code>""Foo""</code>). And using the same logic as above, since <code>*a</code> is another array then <code>**a</code> is the first element of that nested array, which in my example is the letter <code>'F'</code>.</p>

<p>That's why you need ""two indirection"" to reach the first letter of the first array.</p>

<p>Oh, and going backward, <code>**a</code> (with my arrays of arrays) becomes equal to <code>a[0][0]</code>.</p>

<hr>

<p>If we take our array of arrays</p>

<pre><code>char a[2][4] = { ""Foo"", ""Bar"" };
</code></pre>

<p>and show how it would be laid out in memory, it would be like this (with pointers added):</p>

<pre>
+-----+-----+-----+-----+-----+-----+-----+-----+
| 'F' | 'o' | 'o' |  0  | 'B' | 'a' | 'r' |  0  |
+-----+-----+-----+-----+-----+-----+-----+-----+
^                       ^
|                       |
&a[0][0]                &a[1][0]
|                       |
&a[0]                   &a[1]
|
&a
</pre>

<p>If we take the pointers <code>&amp;a</code>, <code>&amp;a[0]</code> and <code>&amp;a[0][0]</code> they all point to the same location. <strong><em>But</em></strong> they are not the same type!</p>

<ul>
<li>The expression <code>&amp;a</code> is a pointer to the whole array <code>a</code>, its type is <code>char (*)[2][4]</code></li>
<li>The expression <code>&amp;a[0]</code> is a pointer to the first sub-array, and its type is <code>char (*)[4]</code></li>
<li>And the expression <code>&amp;a[0][0]</code> is a pointer to the first character in the first array, and its type is <code>char *</code></li>
</ul>

<p>The ""dereferencing"" made means different things for the different pointers.</p>
",10
51887127,51812437,0,"<p>Here's an adaptation of your code that does what you need.  Note that the file name is specified in the <code>main()</code> program (without an absolute path) and passed to the initialization function.  Also note the discussion in <a href=""http://stackoverflow.com/questions/750178/is-it-a-good-idea-to-typedef-pointers"">Is it a good idea to typedef pointers?</a> ¡ª the short answer is ""No"".</p>

<p>The code adds two fields to the structure to record the maximum number of entries that could be stored in the <code>fichas_perdidas</code> array, and the actual number of entries that are stored.  The allocation code exploits the zero-initialization in <code>main()</code> and the fact that when passed a null pointer, <code>realloc()</code> behaves like <code>malloc()</code>.  The allocation code reports the error to standard error; the name <code>stderr</code> indicates that is intended for error messages.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

struct JugadorStruct_t
{
    int fichas, manos_ganadas, manos_perdidas;
    char *nombre;
    int *fichas_partidas;
    int max_fichas;
    int num_fichas;
};

typedef struct JugadorStruct_t *JugadorPtr_t;   // Don't do this!

static
int initJugador(JugadorPtr_t jugador, const char *file)
{
    FILE *fp = fopen(file, ""r"");

    if (fp == NULL)
    {
        printf(""El archivo del jugador no existe\n"");
        fclose(fp);
        return 1;
    }

    char *line = NULL;
    size_t len = 0;

    getline(&amp;line, &amp;len, fp);
    jugador-&gt;nombre = strdup(line);

    getline(&amp;line, &amp;len, fp);
    jugador-&gt;fichas = atoi(line);

    getline(&amp;line, &amp;len, fp);
    jugador-&gt;manos_ganadas = atoi(line);

    getline(&amp;line, &amp;len, fp);
    jugador-&gt;manos_perdidas = atoi(line);

    while (getline(&amp;line, &amp;len, fp) != -1)
    {
        int x = strtol(line, 0, 0); /* Extremely sloppy */
        if (jugador-&gt;num_fichas &gt;= jugador-&gt;max_fichas)
        {
            size_t new_number = 2 * jugador-&gt;max_fichas + 2;
            size_t new_buflen = new_number * sizeof(*jugador);
            void *new_buffer = realloc(jugador-&gt;fichas_partidas, new_buflen);
            if (new_buffer == NULL)
            {
                fprintf(stderr, ""Out of memory (requesting %zu bytes)\n"",
                        new_buflen);
                free(jugador-&gt;nombre);
                free(jugador-&gt;fichas_partidas);
                fclose(fp);
                return -1;
            }
            jugador-&gt;fichas_partidas = new_buffer;
            jugador-&gt;max_fichas = new_number;
        }
        jugador-&gt;fichas_partidas[jugador-&gt;num_fichas++] = x;
    }

    fclose(fp);
    return 0;
}

static void printJugador(const char *tag, struct JugadorStruct_t *jp)
{
    printf(""%s (%p):\n"", tag, (void *)jp);
    printf(""Nombre:        [%s]\n"", jp-&gt;nombre);
    printf(""Fichas:         %d\n"", jp-&gt;fichas);
    printf(""Manos Ganadas:  %d\n"", jp-&gt;manos_ganadas);
    printf(""Manos Perdidas: %d\n"", jp-&gt;manos_perdidas);
    printf(""Num Fichas:     %d\n"", jp-&gt;num_fichas);
    printf(""Max Fichas:     %d\n"", jp-&gt;max_fichas);
    for (int i = 0; i &lt; jp-&gt;num_fichas; i++)
        printf(""%2d: %d\n"", i + 1, jp-&gt;fichas_partidas[i]);
}

int main(void)
{
    struct JugadorStruct_t j = { 0 };
    initJugador(&amp;j, ""jugador.txt"");
    printJugador(""After reading"", &amp;j);
    return 0;
}
</code></pre>

<p>Sample data file:</p>

<pre><code>Line for nombre
32
27
19
12345
23456
34567
45678
56789
67890
99999999
</code></pre>

<p>Output from program:</p>

<pre><code>After reading (0x7ffee84ee400):
Nombre:        [Line for nombre
]
Fichas:         32
Manos Ganadas:  27
Manos Perdidas: 19
Num Fichas:     7
Max Fichas:     14
 1: 12345
 2: 23456
 3: 34567
 4: 45678
 5: 56789
 6: 67890
 7: 99999999
</code></pre>
",0
58208223,58207908,-3,"<p>So take 3 as your number of bits: 0b1000.  Subtract 1.  That yields the pattern: 0b0111.   </p>

<p>Now test 5: 0b101.  0b111 xor 0b101 yields 0b010.  negate the result: 0b101.  if that result matches the number you are testing so the answer is yes.</p>

<p>Now test 9: 0b1001.  0b0111 xor 0b1001 yields 0b1110.  That does not match, so the answer is no.</p>

<p>So I think the answer is along that line.  Do some bit operations to turn your question into a equality compare form, and yield you a result.</p>
",4
48918705,48918672,-1,"<pre><code>int a = 0b0111111;
int b = 0b0000110;

int combined = (a &lt;&lt; 7) | b;
</code></pre>
",2
48918754,48918672,0,"<pre><code>unsigned int X = 0b00111111;
unsigned int Y = 0b00000110;

unsigned int Z = ((X &lt;&lt; 7) &amp; 0xFF00) | Y;
</code></pre>
",3
56881866,56881484,1,"<p>These kind of dirty ""burn-away"" loops were common long time ago, and still exist at some extent in embedded systems. They aren't professional since they are very inaccurate and also tightly coupled to a certain compiler build on a certain system. You cannot get accurate timing out of it for a PC, that's for sure.</p>

<p>First of all, programmers always tend to write them wrong. In the 1980s you could write loops like this because compilers were crap, but nowadays any half-decent compiler will simply remove that whole loop from the executable. This is because it doesn't contain any side-effects. So in order to make the code work at all, you must declare <code>i</code> as <code>volatile</code> to prevent that optimization.</p>

<p>Once that severe bug is fixed, you'll have to figure out how long time the loop actually takes. It is a sum of all CPU instructions needed to run it: a compare, some calculation and then increasing the iterator by 1. If you disassemble the program you can calculate this by adding together the number of cycles needed by all instructions, then multiply that with the time it takes to execute one cycle, which is normally 1/CPU frequency (ignoring pipelining, potential RAM access time losses, multicore etc etc).</p>

<p>In the end you'll come up with the conclusion that whoever wrote this code just pulled a number out of their... hat, then at best benchmarked the loop execution time with all optimizations enabled. But far more likely, I'd say this code was written by someone who didn't know what they were doing, which we can already tell from the missing <code>volatile</code>.</p>
",0
48624036,48617378,1,"<p>Yes, different implementations may have <code>double</code> types with different characteristics, but that is not actually the cause of the behavior you are seeing here. In this case, the cause is that the Windows routines for converting floating-point values to decimal do not produce the correctly rounded result as defined in IEEE 754 (they ¡°give up¡± after a limited number of digits), whereas the macOS routines do produce the correctly rounded result (and in fact produce the exact result if allowed to produce enough digits for that).</p>
",0
48619467,48617378,4,"<p>According to the C standard, the following behaviour is <a href=""http://port70.net/~nsz/c/c11/n1570.html#5.2.4.2.2p6"" rel=""nofollow noreferrer""><strong>implementation-defined</strong></a>:</p>

<blockquote>
  <ol start=""6"">
  <li>The accuracy of the floating-point operations (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) and of the library functions in <code>&lt;math.h&gt;</code> and <code>&lt;complex.h&gt;</code> that return floating-point results is implementation- defined, <em>as is the accuracy of the conversion between floating-point internal representations and string representations performed by the library functions in <code>&lt;stdio.h&gt;</code>, <code>&lt;stdlib.h&gt;</code>, and <code>&lt;wchar.h&gt;</code>. The implementation may state that the accuracy is unknown.</em></li>
  </ol>
</blockquote>
",0
48619804,48617378,0,"<p>The short answer is: yes, different platforms behave differently.</p>

<hr>

<p>From <a href=""https://software.intel.com/en-us/articles/intel-xeon-processor-e5-2600-v2-product-family-technical-overview"" rel=""nofollow noreferrer"">Intel</a>:</p>

<blockquote>
  <p>Intel Xeon processor E5-2600 V2 product family supports half-precision (16-bit) floating- point data types. Half-precision floating-point data types provide 2x more compact data representation than single-precision (32-bit) floating-point data format, but sacrifice data range and accuracy. In particular, half-floats may provide better performance than 32-bit floats when the 32-bit float data does not fit into the L1 cache.</p>
</blockquote>

<p>I don't have access to a Xeon machine to test this but I'd expect that you are ending up with a <code>double</code> that is not really a <code>double</code> due to the use of a ""faster floating-point, but less precision"" CPU instructions.</p>

<p>The ""i"" line of Intel Core processors doesn't have that half-width fast floating point precision so it doesn't truncate the result.</p>

<p>Here's more on the <a href=""https://software.intel.com/en-us/blogs/2013/09/30/intel-half-precision-floating-point-format-conversion-instructions"" rel=""nofollow noreferrer"">half-precision format in Xeon</a> on Intel website.</p>
",0
55659168,55658837,1,"<p><code>int *ret = (int *) malloc(sizeof (int));</code> allocates space for just one integer.</p>

<p><code>*ret = i;</code> does not increment the pointer, it just changes the value to which it it pointing. </p>

<p>So ret's value is some address, where you first write 0, then 1, etc.</p>

<p><code>*(p + i)</code> When you do this, you are dereferencing a memory, which wasn't allocated by your <code>malloc</code> call, it could be used for something else, or even worse could be read-only or outside process's address space, causing a crash.</p>

<p>I think what you want is:</p>

<p><code>int *ret = (int *) malloc(sizeof(int) * nproc);// allocating for nproc integers</code></p>

<p>And then:</p>

<p><code>ret[i] = i;</code></p>
",1
51956905,51956857,1,"<p>Just add it to the argument list of <code>executor</code>.</p>

<pre><code>void executor(FUNC_PTR func, uint8_t* b)
{ 
   uint64_t opts = 0x0000010;
   res = func(opts, b);
}
</code></pre>

<p>You can allocate the memory on the stack or heap in main.</p>

<pre><code>void main()
{
   uint8_t mem1, mem2;
   executor(func1, &amp;mem1);
   executor(func2, &amp;mem2);
}
</code></pre>
",3
52194567,52194539,4,"<p>The problem with <code>fscanf</code>'s <code>%s</code> format specifier is that it stops as soon as it reaches a space. Given your format, this is incorrect: you are looking for a read of data up to a semicolon.</p>

<p>This can be achieved with <code>%[^;]</code> format. The complete format string would also use semicolons as separators between <code>%d</code> specifiers to match your file's format, like this:</p>

<pre><code>fscanf(fp, ""%32[^;];%d;%d%%;%d"", name, id, score, number);
</code></pre>

<p>Note <code>32</code> above. This limit should correspond to the longest name that you would like to read. If <code>name</code> is an array of <code>N</code> characters, use <code>N-1</code> for the value between <code>%</code> and <code>[^;]</code> to avoid buffer overruns. Also note the <code>%%</code> after the second <code>%d</code>. That is required to match the percentage sign (second <code>%</code> is required by <code>fscanf</code>'s rules).</p>
",0
48985651,48985522,5,"<p>Since your range has both a negative and a positive side, going from <code>-s</code> to <code>+s</code>, you can shorten the positive part of the range by 1, then add 1 in case when the generated value is non-negative:</p>

<pre><code>N2_1 = -S/10;
N2_2 = S/10-1; // Shrink by one    
N2 = rand() % (N2_2 + 1 - N2_1) + N2_1;
if (N2 &gt;= 0) { // Correct for zero
    N2++;
}
</code></pre>

<p>Alternatively you could check the result for zero, and generate a new number if necessary:</p>

<pre><code>int nepresnostNoZero(int S) {
    int res;
    do {
        res = nepresnost_N2(S);
    } while (res == 0);
    return res;
}
</code></pre>
",1
55979945,55979822,2,"<p>After the typedef in the external library, the name of the type is <code>wifi_ap_record_t</code>, not <code>struct wifi_ap_record_t</code>.</p>

<p>Names that start with <code>struct</code> is a separate space, but typedef-ed names are not in it, even if they refer to a struct type.</p>

<p>There should be no <code>struct</code> keyword in your own code. A pointer to this struct will have the type <code>wifi_ap_record_t*</code>, not <code>struct wifi_ap_record_t*</code>. You don't need your own typedef.</p>
",2
59314159,59313739,0,"<p>You could read the input as a string and then scan the string for a dot. </p>

<pre><code>#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main (void) {
    int i;
    float f;
    char input[256];
    char dummy[256];
    fgets(input, 256, stdin);
    if(strchr(input, '.') != NULL) {
        if(sscanf(input, ""%f%s"", &amp;f, dummy) == 1) {
            printf(""%f is a float\n"", f);
        } else {
            //error case
        }
    } else {
        if(sscanf(input, ""%d%s"", &amp;i, dummy) == 1) {
            printf(""%d is an integer\n"", i);
        } else {
            // error case
        }
    }

  return 0;
}
</code></pre>
",0
58718464,58718244,0,"<p>¡°Alias¡± simply means an alternative name. In C, what we mean by ¡°name¡± in the meaning of ¡°alias¡± is an lvalue. According to C 2018 6.3.2.1 1, ¡°An lvalue is an expression¡­ that potentially designates an object¡­¡± If you have two lvalues for same thing, you have two aliases for the that thing (or you might designate one as the primary name and the other as an alias).</p>

<p>Most simply, after <code>int b;</code>, <code>b</code> is an lvalue for the object named by <code>b</code>. And, after <code>int *p = &amp;b;</code>, <code>*p</code> is an lvalue for the same object. Then <code>b</code> and <code>*p</code> are aliases of the same object.</p>

<p>The meanings of the diagrams you show are unclear. Part of it shows <code>a</code> and <code>b</code> as simple scalar objects. Another part shows them as arrays. Without more context and explanation, it is not possible to interpret it reliably.</p>

<p>If we have an <code>int a[1]</code> and an <code>int b[1]</code>, and the compiler happens to put <code>b</code> in memory immediately after <code>a</code>, then <code>a[1]</code> is in some sense an alias for <code>b[0]</code>, but it is improper to use it, because the rules in the C standard do not define the behavior of accessing an array out of bounds, even if we somehow know what follows it in memory.</p>
",0
48607273,48607216,2,"<p>Your search for characters of one string existing in another string is incorrect. Here is how you fix it:</p>

<ol>
<li>Flip loop's order. The loop on <code>alphabet</code> should be on the outside</li>
<li>Invert the nested loop. Currently, you stop as soon as you find a non-equal character. Instead, you should look through all characters currently in <code>alphabet2</code> before deciding if the next character should be kept or discarded.</li>
<li>Null-terminate <code>alphabet</code> once you are done processing. This can be done by setting <code>alphabet[k]</code> to zero after both loops have finished.</li>
</ol>

<p><a href=""https://ideone.com/NQUZbJ"" rel=""nofollow noreferrer"">Demo.</a></p>

<p><strong>Note:</strong> Since you are using string function <code>strlen</code>, you might use another string function <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/strchr.html"" rel=""nofollow noreferrer""><code>strchr</code></a> to eliminate the nested loop. Consider doing this as an exercise.</p>
",0
48963260,48963133,4,"<p>As sad in comment, your format specifier is wrong in <code>printf</code> function. It should be like:</p>

<pre><code>printf(""X^y = %lli\n"", result);
</code></pre>

<p><code>lli</code> is the correct format specifier. Result:</p>

<pre><code>X^y = 10000000000
</code></pre>

<p>Integer values in <code>C</code> programming language are <code>32 bits</code> and it can hold values that contains 10 digits but 10^10 is 11 digit so it overflows.</p>

<p>You can learn about more from this question:</p>

<p><a href=""https://stackoverflow.com/questions/94591/what-is-the-maximum-value-for-an-int32"">What is the maximum value for an int32?</a></p>
",2
54876391,54858673,2,"<p><strong>fscanf</strong>(3) is almost unusable unless the input is strictly controlled.  It's hard to distinguish between I/O errors and parsing errors.  That's why it's much more common to read each line with <strong>fgets</strong>(3), and then scan it with <strong>sscanf</strong>(3).  </p>

<p>Because <strong>sscanf</strong> returns the number of elements parsed, you can use that to determine if a scan works as expected.  No need to peek at the input: if you got what you expected, you're done, else try scanning some other way.  Here's a working example:</p>

<pre><code>#include &lt;assert.h&gt;
#include &lt;err.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int
main( int argc, char *argv[] ) {
  if( argc &lt; 2 ) {
    errx(EXIT_FAILURE, ""syntax: %s filename"", argv[0]);
  }

  FILE *input = fopen(argv[1], ""r"");
  if( !input ) {
    err(EXIT_FAILURE, ""could not open '%s'"", argv[0]);
  }

  static char line[128];
  int n;

  while( fgets(line, sizeof(line), input) != NULL ) {
    double d1, d2;
    int quantum;

    if( 2 == sscanf(line, ""%d(%lf)"", &amp;quantum, &amp;d1) ) {
      printf( ""ok: %d\t%7.2f\n"", 100 * quantum, d1 );
    } else if( 2 == sscanf(line, ""(%lf %lf)"", &amp;d1, &amp;d2) ) {
      printf( ""ok: %7.2f\t%7.2f\n"", d1, d2 );
    } else {
      printf( ""&gt;&gt;&gt; %s\n"", line );
    }

  }

  if( !feof(input) ) {
    err(EXIT_FAILURE, ""error reading %s"", argv[1]);
  }

  return EXIT_SUCCESS;
}
</code></pre>

<p>If you discover other patterns, it's easy to add them.  Note that when <strong>fgets</strong> fails, the program returns success only if we reached end of file.  </p>
",1
54871994,54858673,0,"<p>As mentioned in the comments, you can read a full line and then determine the format of the line and parse the line accordingly. The following code does what you want. However, production worthy code would probably more robustly interpret the format of each line.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

char *GetStringNoBeginWhitespace( char *str )
{
    static const char whitespace[] = "" \f\n\r\t\v"";

    return(str + strspn(str, whitespace));
}

int main(int argc, char *argv[])
{
    char *line = NULL;
    FILE *fp;
    char buffer[255];

    int i;
    double d,d1;

    fp = fopen(""data.txt"", ""r"");

    while(fgets(buffer, 255, fp))
    {
        buffer[strlen(buffer)-1] = 0x00;
        line = GetStringNoBeginWhitespace( buffer );
        if( line )
        {
            fputs(line, stdout);
            if( isdigit((int)line[0] ))
            {
                printf(""\tFormat is x(.......)\n"");
                if( sscanf(line,""%d(%le)\n"", &amp;i, &amp;d) == 2 )
                {
                    printf(""      %d %le\n"", i, d);
                }
                else
                {
                    printf(""\tUnknown format....\n"");
                }
            }
            else if( line[0] == '(' )
            {
                printf(""\tFormat is ( ...... ....... )\n"");
                if( sscanf(line, ""(%le %le)\n"", &amp;d, &amp;d1) == 2 )
                {
                    printf(""      %le %le\n"", d, d1);
                }
                else
                {
                    printf(""\tUnknown format....\n"");
                }
            }
            else
            {
                printf(""\tUnknown format....\n"");
            }
        }
    }

    fclose(fp); 
    return(0);
}
</code></pre>

<p>Output:</p>

<pre>jnorton@ubuntu:~/source$ ./a.out 
1(1.230000e+00) Format is x(.......)
      1 1.230000e+00
2(1.230000e+00) Format is x(.......)
      2 1.230000e+00
(1.230000e+00 1.230000e+00) Format is ( ...... ....... )
      1.230000e+00 1.230000e+00
3(1.230000e+00) Format is x(.......)
      3 1.230000e+00
(1.230000e+00 1.230000e+00) Format is ( ...... ....... )
      1.230000e+00 1.230000e+00</pre>

<p>data.txt file:</p>

<pre>1(1.230000e+00)
2(1.230000e+00)
(1.230000e+00 1.230000e+00)
3(1.230000e+00)
(1.230000e+00 1.230000e+00)</pre>
",0
52887818,41171863,0,"<p>While almost all of what CristiFati wrote is right, there's a small error in:</p>

<blockquote>
  <p>The last change is: replace <code>if (index &lt; threshold) {</code> by <code>if (index &lt; read) {</code> ¡­</p>
</blockquote>

<p>Since the previous loop runs <code>while (((index &lt;= read) ¡­</code> and <code>scanner[<i>read</i>]</code> is a valid data point, it's</p>

<pre><code>    if (index &lt;= read)
    {
</code></pre>

<p>One more thing:</p>

<pre><code>        printf(""Threshold not reached after %d readings."", scanner[255]);
</code></pre>

<p>has to be</p>

<pre><code>        printf(""Threshold not reached after %d readings."", scanner[0]);
</code></pre>

<p>- after all, <code>scanner[255]</code> would be out of the array bounds.</p>
",0
48978950,48978875,4,"<p>There is no standard-compliant way to return a string from an <code>int</code> function. Returning <code>-1</code> wouldn't work either, because <code>-1</code> could be a legitimate majority element in an array of <code>int</code>.</p>

<p>One approach to do this is to return the value by setting the result by pointer, and returning a flag indicating a success:</p>

<pre><code>bool find_majority(int data[], size_t length, int* resPtr) {
    ...
}
</code></pre>

<p>The caller would invoke your function as follows:</p>

<pre><code>int res;
if (find_majority(array, array_length, &amp;res)) {
    printf(""Found: %d\n"", res);
} else {
    printf(""Not found\n"");
}
</code></pre>
",2
54410935,54410551,2,"<p>You may simply <strong>abstract away the type of the elements</strong>. All your array needs to know is how big those elements are. You can go the full way of allowing the user to supply a copy constructor and destructor via function pointers, or you can limit the scope of your array to <code>memcpy()</code> movable types.</p>

<h3>Providing an array for plain data elements</h3>

<p>You simply add the size of the elements as a parameter to your array <code>struct</code>:</p>

<pre><code>typedef struct {
  char *array;
  size_t elementSize;
  size_t used;
  size_t size;
} Array;

void Array_init(Array *a, size_t elementSize, size_t initialSize);
void Array_insert(Array *a, const void* element);
const void* Array_at(Array *a, size_t index);
void Array_destruct(Array *a);
</code></pre>

<p>All indexing into the array simply multiplies the index with the given element size to index the internal <code>char</code> array. The internal <code>char</code> pointers are implicitly converted to the <code>void</code> pointers of the interface, which in turn are implicitly converted to <code>double</code> pointers, or whatever other type you plug into this array.</p>

<p>This works great <em>as long as the elements are trivially copyable</em>. If you elements need to manage memory themselves, you need the following approach:</p>

<h3>Providing an array for complex data elements</h3>

<p>If you objects need to do custom stuff when they are copied, you need to provide a means for the user to supply the necessary behavior. That is done via function pointers:</p>

<pre><code>typedef void (*Array_callback_copy_construct)(void* this, const void* original);
typedef void (*Array_callback_destruct)(void* this);
typedef struct {
  char *array;
  size_t elementSize;
  size_t used;
  size_t size;
  Array_callback_copy_construct copy_construct;
  Array_callback_destruct destruct;
} Array;

void Array_init(Array *a, size_t elementSize, size_t initialSize, Array_callback_copy_construct copy_construct, Array_callback_destruct destruct);
void Array_insert(Array *a, const void* element);
const void* Array_at(Array *a, size_t index);
void Array_destruct(Array *a);
</code></pre>

<p>The <code>Array_insert()</code> and <code>Array_destruct()</code> methods now simply use the user provided callback functions to copy and destroy the elements of the array.</p>

<p>More advanced versions might also use a move constructor callback, and/or a (move) assignment callback. Copy construction + destruction is the minimal set you need, better performance may be achieved with the more advanced callbacks.</p>

<hr>

<p>The first method is simple enough to be useful in a wide variety of applications, and I would not hesitate to use it. However, <strong>the catch of the use of <code>memcpy()</code> must be clearly documented</strong>.</p>

<p>The second method works where the first method fails, but it's generally much more hassle than it's worth. Avoid it unless you figure that it's really the only solution.</p>
",1
54499208,54499136,0,"<p>The <code>cont</code> in <code>main</code> (which is not the same as the <code>cont</code> in <code>perfectNumber</code>) is never changed inside the loop, and the loop guard is only dependent on that <code>cont</code>.  Similar thing w/ the two <code>userInput</code>s.</p>
",0
52089575,52089080,0,"<p>The direct answer as follows:</p>

<pre><code>int num = 1234, digit = 0;
do {
    digit = num % 10;           // Assigns the extracted digit to a variable named digit (ex: 4).
    if (digit % 2 != 0)         // Applies the formula to get the odd number.
        printf(""%d\n"", digit);  // Prints the odd number.
    num /= 10;                  // Extracts one digit each time (ex: 1234 / 10 = 123).
} while (num &gt; 0);              // Has reached the end of the number 'num'.
</code></pre>

<p>The Result:</p>

<p>3<br>
1</p>
",0
52930189,52929785,1,"<p>You defined <code>dest_mac</code> and <code>src_mac</code> as arrays and then tried to use them as a pointer which doesn't make sense. I'm guessing you want those variables to point to the data from the buffer. If that's the case, use a pointer instead of an array.</p>

<pre><code>void print_ethernet_data(const u_char *Buffer , int Size){

unsigned char *dest_mac; unsigned char *src_mac;
struct ether_header *eth = (struct ether_header *)Buffer;

    printf( ""\n"");
    printf( ""Ethernet Header\n"");
    printf( ""   |-Destination Address : %.2X:%.2X:%.2X:%.2X:%.2X:%.2X \n"", eth-&gt;dhost[0] , eth-&gt;dhost[1] , eth-&gt;dhost[2] , eth-&gt;dhost[3] , eth-&gt;dhost[4] , eth-&gt;dhost[5] );
    printf( ""   |-Source Address      : %.2X:%.2X:%.2X:%.2X:%.2X:%.2X \n"", eth-&gt;shost[0] , eth-&gt;shost[1] , eth-&gt;shost[2] , eth-&gt;shost[3] , eth-&gt;shost[4] , eth-&gt;shost[5] );
    printf( ""   |-Protocol            : %u \n"",(unsigned short)eth-&gt;type);
    dest_mac = eth-&gt;dhost;
    src_mac = eth-&gt;shost;
    handledata(Buffer + header_size , Size - header_size, &amp;dest_mac, &amp;src_mac);  //This is the function called
}
</code></pre>

<p>And your other function also needs a fix for the <code>src_mac</code> variable since you defined it as a pointer to a pointer instead of just being a plain pointer to <code>char</code>.</p>

<pre><code>void handledata(struct sniff_dns* dns, int size, unsigned char* dest_mac, unsigned char* src_mac)
{

    //RECEIVEING DATA HERE-------------------------------
    printf(""DST_MAC = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n"",dest_mac[0], dest_mac[1], dest_mac[2], dest_mac[3], dest_mac[4], dest_mac[5]);
    printf(""SRC_MAC = %.2X:%.2X:%.2X:%.2X:%.2X:%.2X\n"",src_mac[0], src_mac[1], src_mac[2], src_mac[3], src_mac[4], src_mac[5]);

    insert_in_db(dst_mac, src_mac);    //How should I handle this function and its call?
}
</code></pre>

<p>And finally, on the call to the <code>insert_in_db</code> function, you can just pass the pointer instead of passing the address of the pointer. I think you should read about pointers.</p>
",0
48117723,48117139,4,"<p>to have precise control of the character i suggest</p>

<pre><code>tabuleiro[0][j] = ""123456789T""[j];
</code></pre>

<p>This will pick the jth character from that string</p>

<p>BTW the reason you got ':' is becasue ':' is the next ascii character after '9' - see <a href=""http://www.asciitable.com/"" rel=""nofollow noreferrer"">http://www.asciitable.com/</a></p>
",2
48117760,48117139,3,"<p>The issue is the char code for <code>10 + '0' = 58</code> which is the char code for ':'. You might consider removing the column and row names out of the game array. They are just labels and not part of the game (I assume).</p>

<pre><code>#define board_size 10
</code></pre>

<p>And </p>

<pre><code>// Create game board and initialize grid to '~', in main() possibly
// Game is 10x10 grid
char tabuleiro[board_size][board_size];
for (int row = 0; row &lt; board_size; row++) {
    for (int col = 0; col &lt; board_size; col++) {
        tabuleiro[row][col] = '~';
    }
}
</code></pre>

<p>Have a function that draws the game board:</p>

<pre><code>void drawBoard(char tabuleiro[board_size][board_size]) {
    // Print top line
    printf(""  "");
    for (int col = 0; col &lt; board_size; col++) {
        printf("" %-2d"", col+1);
    }
    printf(""\n"");

    // Print grid
    for (int row = 0; row &lt; board_size; row++) {
        // Print letter
        printf(""%c "", 'A' + row);
        // Print board
        for (int col = 0; col &lt; board_size; col++) {
            printf("" %c "", tabuleiro[row][col]);
        }
        printf(""\n"");
    }
}
</code></pre>
",2
54290945,54290835,2,"<p>All numbers are larger by one in the second loop, not just the last.</p>

<p>Your for-loop is equivalent to</p>

<pre><code>nc = 0;
while (getchar() != EOF)
{
    printf(""%ld\n"", nc);
    ++nc;
}
</code></pre>

<p>As you can see, it increments after printing, and your while increments before printing.</p>
",0
55356581,55356531,2,"<p>The subsequent errors give you the relevant hint: <code>struct dirent</code> was only declared, not defined. You need to include the relevant header (<code>dirent.h</code>).</p>

<p>In addition, you probably failed to include <code>stdbool.h</code> in your header (and included it in your implementation file instead, maybe indirectly).</p>
",7
49459143,49458917,9,"<ol>
<li><p>In current C standards (C99, C11), one should <a href=""https://en.wikipedia.org/wiki/Type_punning"" rel=""noreferrer"">type-pun</a> via an union, rather than dereferencing a type-cast pointer:</p>

<pre><code>#include &lt;stdint.h&gt;

uint32_t  float_bits(const float  f)
{
    union {
        uint32_t  u;
        float     f;
    } temp;

    temp.f = f;
    return temp.u;
}
</code></pre></li>
<li><p>Most current architectures use IEEE-754 <a href=""https://en.wikipedia.org/wiki/Single-precision_floating-point_format#IEEE_754_single-precision_binary_floating-point_format:_binary32"" rel=""noreferrer"">binary32</a> format for <code>float</code> type, but not all. If your program assumes this, it should say so in the documentation.
<br>I personally like to check it at compile time, and fail the compilation if my code cannot cope. </p></li>
<li><p>Most current architectures use the same byte order (<a href=""https://en.wikipedia.org/wiki/Endianness"" rel=""noreferrer"">endianness</a>) for integer and float types, but not all. Again, if your program assumes this, it should say so in the documentation, or check it at compile time (using a separate test program in the same project, for example).</p></li>
<li><p>In C, the expression <code>(type)variable</code> casts the <strong>value</strong> of variable <code>variable</code> to type <code>type</code>. For example:</p>

<pre><code>int32_t my_truncate(float value)
{
    return (int32_t)value;
}
</code></pre>

<p>If for example <code>value == 2.125</code>, then <code>my_truncate(value) == 2</code>.</p>

<p>Similarly, casting an integer value to a floating-point type, evaluates to a floating-point value that best represents the original integer value. For example, <code>(float)425 == 425.0f</code>. (The final <code>f</code> just tells the value is of <code>float</code> type. If there is no <code>f</code> at the end of a floating-point value, its type in C is <code>double</code>.)</p></li>
<li><p>""Storage representation"" refers to how values are actually stored in memory.</p></li>
<li><p>The difference between <em>casting</em> and <em>type-punning</em> is that <em>casting</em> reinterprets the value itself, but <em>type-punning</em> reinterprets how the storage representation of the value is interpreted.</p>

<p>Thus, casting an integer value to a float type just yields a float that best represents the original integer value; but type-punning an integer value (of the same size as a <code>float</code>) to <code>float</code> means the storage representation of that integer value is treated as the storage representation of a float value, yielding the float value that has the same storage representation as the original integer value has.</p>

<p>Similarly in the other direction. Type-punning a float to an unsigned integer type, will yield the unsigned integer (and thus bits) that has the same storage representation as the original float had. This is exactly what the <code>float_bits()</code> example function above does.</p></li>
<li><p>In C99 and later versions of the C standard, as well as in POSIXy C implementations, you can use the <a href=""http://man7.org/linux/man-pages/man3/frexp.3.html"" rel=""noreferrer""><code>frexpf()</code></a> function to split a <code>float</code> into a normalized fraction: <i>x</i> ¡Á 2<sup>n</sup>, where either -1.0 &lt; <i>x</i> &lt;= -0.5f or 0.5 &lt;= <i>x</i> &lt; 1; and <code>n</code> is an integer exponent.
<br>If need be, one can use this to construct the representation of the closest value binary32 can represent, in an <code>uint32_t</code>. This can be useful on architectures that does not use IEEE 754 binary32 for <code>float</code>s. </p></li>
</ol>
",2
51198411,51198325,4,"<p>The leading <code>0</code> in octal literals should not be counted, that's just part of the syntax (not that leading zeroes should count, anyway). <code>0177700</code> fits in 16 bits since the most significant octal digit is 1. The value is equal to <code>0xffc0</code> which is obviously a 16-bit value.</p>

<p>Yes, using an inverted small literal is slightly more flexible since it encodes less information in the literal.</p>

<p>If you want to clear the lowest bit of an integer, doing</p>

<pre><code>x &amp;= ~1u;
</code></pre>

<p>is more flexible since it will work just the same on platforms with 16-bit integers as on 32-bit platforms, but the more explicit</p>

<pre><code>x &amp;= 0xfffeu;
</code></pre>

<p>will not, since it assumes 16 bits and doesn't provide masking bits for bits 16 through 31, should they be present.</p>
",0
51198491,51198325,5,"<p>It should be easier to visualize if you convert those octals to binary:</p>

<pre class=""lang-none prettyprint-override""><code>077:
0011 1111

~077:
1100 0000

0177700:
1111 1111 1100 0000
</code></pre>

<blockquote>
  <p>why the authors consider the x as 16 bit quantity whereas 0177700 is total of 21 bit?</p>
</blockquote>

<p>It is not, as you can see above. 0177700 takes 16 bit in fact.</p>

<blockquote>
  <p>is the passage saying that using ~077 is more flexible and useful as it can be applied to any x values regardless of its size?</p>
</blockquote>

<p>Exactly. If you consider a byte being the smallest possible unit for handling, the bitwise NOT of 077 (<code>~077</code>) represents the smallest possible number containing the last six bits set to 0 and the remaining ones (only two) set to one. If you want to set the last 6 bit of an arbitrary word to 0, you need to AND it with something that fits this description (last 6 set to 0 and others to 1). And <code>~077</code> is the most adequate fit being the smallest possible containing these requirements.</p>

<p>If you would AND it to 0177700, you are assuming the word is at least 16 bit long.</p>

<p>This is heavily based on the fact that you can't AND two different sizes. With <code>~077</code>, and considering this:</p>

<pre><code>x &amp; ~077
</code></pre>

<p>If <code>x</code> is of a type bigger than 077, let's say 16bit, 077 will first be ""promoted"" by being padded with zeros:</p>

<pre><code>0000 0000 0011 1111
</code></pre>

<p>And then inverted generating the desired</p>

<pre><code>1111 1111 1100 0000
</code></pre>

<p>Had you used 0177700, if <code>x</code> was 8bit long, you have a problem. That's why they say you'd be assuming <code>x</code> is 16bit long. In other words, <code>~077</code> is the smallest and most adequate fit for that job of setting the last six bits to 0.</p>

<p>Similarly, using 0300 (which is <code>~077</code> resolved) you would be assuming that <code>x</code> is 8bit. Losing the flexibility that type promotion provides in <code>~077</code>.</p>
",2
50896573,50896459,0,"<p>Static in a global scope means it is only visible in that file. You're confusing it with static in a function I suspect. See this answer for details:</p>

<p><a href=""https://stackoverflow.com/questions/572547/what-does-static-mean-in-c#572550"">What does &quot;static&quot; mean in C?</a></p>

<p>A global variable is implicitly the same as a static variable in a function, you don't need the static at the global scope in your code. You will then also want to define the variable using the extern keyword in your header file, as per:</p>

<p><a href=""https://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files#1433387"">How do I use extern to share variables between source files?</a></p>
",1
50898792,50896459,1,"<p>To make <code>npTxQueue</code> an ugly global:</p>

<ul>
<li><p>Put into <code>znp_app.h</code> </p>

<pre><code>extern osal_msg_q_t npTxQueue; 
</code></pre></li>
<li><p>and into <code>znp_app.c</code> put (without any <code>static</code>)</p>

<pre><code>osal_msg_q_t npTxQueue; 
</code></pre></li>
<li><p>and include into <code>znp_app.c</code> <code>znp_app.h</code> as well (before the definition of <code>npTxQueue</code>).</p></li>
<li><p>Finally include <code>znp_app.h</code> into where you need <code>npTxQueue</code>.</p></li>
</ul>

<hr>

<p>Alternativly use a getter by</p>

<ul>
<li><p>moving the definition of  <code>osal_msg_q_t</code> to <code>znp_app.h</code> (if not in there already).</p></li>
<li><p>and add (below the definition of  <code>osal_msg_q_t</code>) the prototype of the getter to <code>znp_app.h</code> as well:</p>

<pre><code>osal_msg_q_t GetIt(void);
</code></pre></li>
<li><p>and add the getter's implementation to <code>znp_app.c</code>:</p>

<pre><code>osal_msg_q_t GetIt(void)
{
  return npTxQueue; 
}
</code></pre></li>
<li><p>Finally include <code>znp_app.h</code> into where you need <code>npTxQueue</code>.</p></li>
</ul>
",0
52730336,52729371,1,"<p>To properly handle <code>-0.0</code> and <code>NAN</code>, extract the sign with <code>signbit()</code> and use the string trick as in <a href=""https://stackoverflow.com/a/52729509/2410359"">@pm100</a>.</p>

<blockquote>
  <p>The <code>signbit</code> macro determines whether the sign of its argument value is negative. (footnote)<br>
  The <code>signbit</code> macro returns a nonzero value if and only if the sign of its argument value
  is negative.<br>
  The <code>signbit</code> macro reports the sign of all values, including infinities, zeros, and NaNs.</p>
</blockquote>

<pre><code>#include &lt;math.h&gt;

// 9999.999(+/-)i9999.999
printf(""%.3f%ci%.3f"", z.re, ""-+""[!signbit(z.im)], fabs(z.im));
</code></pre>
",0
52729509,52729371,2,"<p>without if or ternary</p>

<pre><code>void show(struct z z) {
    printf(""%.3f%ci%.3f"", z.re, ""+-""[z.im&lt;0], fabs(z.im));
}
</code></pre>
",2
48716913,48716882,1,"<p>If <code>execvp</code> is successful, the process starts executing the specified program.</p>

<pre class=""lang-none prettyprint-override""><code>Parent Process          Child Process
-------------------     -------------------
fork()
pid_t pid = ...;        pid_t pid = ...;
pid &lt; 0                 pid &lt; 0
pid &gt; 0                 pid &gt; 0
/* do something */      execvp(*args, args)
return 0;               [main of new program]
</code></pre>

<p>Your program could have been written</p>

<pre><code>int execCmd(char** args) {
    pid_t pid = fork();
    if (pid &lt; 0) {
        perror(""fork"");
        exit(1);
    }

    if (pid == 0) {
        execvp(*args, args);
        perror(""execvp"");
        _exit(1);
    }

    /* ... Do something in parent ... */
    return 0;
}
</code></pre>

<p>Also, you probably want to wait for the child to finish, return the <code>pid</code> or have the child auto-reap (by making SIGCHILD ignored).</p>
",1
55056583,55056214,4,"<p>Coding tip: Don't put a space before/after the dot <code>.</code> or arrow <code>-&gt;</code> operators.</p>

<p>Instead of this:</p>

<pre><code>table -&gt; bins
</code></pre>

<p>This:</p>

<pre><code>table-&gt;bins
</code></pre>

<p>Your actual issue is this.  <code>create_table</code> isn't propertly allocating memory for bins.  Even worse, it's using an array on the stack.  That memory is undefined behavior as soon as create_table returns.  Better:</p>

<pre><code>hash_t create_table(int bins){
        hash_t table = malloc(sizeof(hash_t));
        table-&gt;table = calloc(sizeof(struct node_s*) * bins); //malloc and zero-init
        table-&gt;bins = bins
        table-&gt;size = 0;
        return table;
}
</code></pre>

<p>Also, instead of this:</p>

<pre><code>        if(node == NULL){
                printf(""Filled bucket!\n"");
                table -&gt; table[index] = newNode;
                table -&gt; size = table -&gt; size + 1;
        }else{
                printf(""Chained!\n"");
                while(node -&gt; link != NULL){
                        node = node -&gt; link;
                }
                node -&gt; link  = newNode;
        }
</code></pre>

<p>Just do this:</p>

<pre><code>printf(""%s\n"", (table-&gt;table[index] ? ""Filled bucked!"" : ""Chained!""));
newNode-&gt;link = table-&gt;table[index];
table-&gt;table[index] = newNode;
</code></pre>

<p>Each time a new node gets added to a bin, it becomes the head item in the bin's linked list.  The chaining happens at the front of the each bin's list instead of the back.</p>
",0
54842754,54842596,1,"<p>My recommendation is to convert your <code>create()</code> function to an <code>init()</code> function; this will allow the user to create <code>PrQueue</code> objects inside other objects and/or on the stack, rather than only on the heap:</p>

<pre><code>void init(PrQueue * Meta)
{   
   Meta-&gt;NrOfItems = 0;
   Meta-&gt;Head = NULL;
}
</code></pre>

<p>It also means there is no possibility of the function failing, so the user won't have to do any error-checking.</p>

<p>The user could use it like this:</p>

<pre><code>int main(int argc, char ** argv)
{
   PrQueue q;
   init(&amp;q);
   [...]
}
</code></pre>
",0
48250177,48250079,0,"<p>Use <code>ds_list</code> as structure not a pointer</p>

<pre><code>typedef struct ds_list_element {
    char value[MAX];
    struct ds_list_element *next;
}ds_list;
</code></pre>

<p>and allocate memory for the structure not a pointer.</p>

<p>Working program:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#define MAX 100

typedef struct ds_list_element {
    char value[MAX];
    struct ds_list_element *next;
}ds_list;


int ds_list_empty(ds_list *id) { // id listy
    if (id == NULL) return 1;
    else return 0;
}

ds_list * ds_list_add(ds_list *id, char add[MAX]) {
    ds_list *temp;

    temp = (malloc(sizeof(ds_list)));
    strcpy(temp-&gt;value,add);
    temp-&gt;next = id;
    return temp;
}

void ds_list_print(ds_list *id) {

    if (ds_list_empty(id) == 0) {
        printf(""%s\n"",id-&gt;value);
        ds_list_print(id-&gt;next);
    }
}

int main () {
    ds_list *my_list = NULL;

    my_list = ds_list_add(my_list,""one"");
    my_list = ds_list_add(my_list,""two"");
    my_list = ds_list_add(my_list,""three"");
    my_list = ds_list_add(my_list,""four"");

    ds_list_print(my_list);
    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>four
three
two
one
</code></pre>
",0
54464911,54464790,0,"<p>If you have, as you claim, an <em>array</em> of input (not just a <em>pointer</em> to the first element of the array), you don't need a null terminator. The array will also have length information:</p>

<pre><code>size_t len = sizeof myarray;
// To write a single char:
fputc(myarray[0], fp);
// To write the entire array:
fwrite(myarray, 1, len, fp);
</code></pre>

<p>If you do want to output the entire array</p>
",0
54464990,54464790,2,"<p>I'd suggest to use function <code>fwrite</code> to write binary data to a file; obviously the solution works for arrays of <code>SIZE==1</code> as well:</p>

<pre><code>int main() {
#define SIZE 10

    unsigned char a[SIZE] = {1, 2, 3, 4, 5, 0, 1, 2, 3, 4 };
    FILE *f1 = fopen(""file.bin"", ""wb"");
    if (f1) {
        size_t r1 = fwrite(a, sizeof a[0], SIZE, f1);
        printf(""wrote %zu elements out of %d requested\n"", r1,  SIZE);
        fclose(f1);
    }
}
</code></pre>
",0
54468094,54464790,0,"<blockquote>
  <p>I've got an array of unsigned chars that I'd like to output<br>
  How to output unsigned char to a text file in c?</p>
</blockquote>

<p>The tricky part is ""to a <strong>text</strong> file"".  This usually means to save something human readable.</p>

<p>If that is the goal, then save printable characters as text and non-printable ones as escaped text - also special handling of <code>'\n'</code> and <code>'\\'</code>.</p>

<pre><code>#include &lt;ctype.h&gt;
#include &lt;stdio.h&gt;

void print_1_uchar(FILE *stream, unsigned char uch) {
  if ((isprint(uch)) &amp;&amp; ch != '\\') || ch == '\n') {
    fputc(uch,  stream);
  } else {
    fprintf(stream, ""\\x03o"", uch);
  }
}

void print_1_array(FILE *stream, const void *a, size_t sz) {
  const unsigned char *s = a;
  while (sz-- &gt; 0) {
    print_1_uchar(stream, *s++);
  }
}
</code></pre>

<p>Usage</p>

<pre><code>unsigned char foo[] = { 1,2,3,4,5 };
print_1_array(stdout, foo, sizeof foo);
</code></pre>
",0
52851320,52850650,1,"<p>There is quite a bit of explanation here so</p>

<p>let me <strong>just answer</strong> your question straight ""<em>How could I make it output?</em>""</p>

<pre><code>while (x++ &lt; 33) //original x
{
    //int x = 100;
    static int x = 100;
    x++;
    printf(""x in while loop: %d at %p\n"", x, &amp;x);
}
</code></pre>

<p>I'd say read something on <code>static</code> variables and in general <code>storage classes</code></p>
",0
49208804,49208593,1,"<p>Your problems with printout comes from overwriting the first member of the structure.</p>

<p>The byte sequence <code>{'y', '\0'}</code> is being written to the single-byte <code>prompt</code> <em>and</em> what follows, which is almost certainly the first byte of <code>numbers</code>. This is therefore setting the first character of the <code>cell</code> field to <code>'\0'</code>, making it an empty string.</p>

<p>If you want to use string formatting <code>""%s""</code> in <code>scanf(""%s"", &amp;prompt);</code> the <code>prompt</code> has to be as string type. Char variable is unable to hold character plus null string terminator read by your <code>scanf</code>.</p>

<p>The more natural and typical approach is to use <code>"" %c""</code> for the character read. Both ways are presented.</p>

<p>Note 1:
The <code>%c</code> conversion specifier won't automatically skip any leading whitespace, so if there's a stray newline in the input stream (from a previous entry, for example) the scanf call will consume it immediately.</p>

<p>One way around the problem is to put a blank space before the conversion specifier in the format string:</p>

<pre><code>scanf("" %c"", &amp;c);
</code></pre>

<p>Note 2: Typically we declare structures before <code>main</code> to give them global scope in the file.</p>

<p>Note 3:  Also, if you declare <code>numbers</code> as a local struct variable then all of the struct members are undefined. In case of user skipping filling the number you may get a garbage printout for that field. You are obligated to initialize those members yourself.</p>

<pre><code>#define _CRT_SECURE_NO_WARNINGS

#include &lt;stdio.h&gt;

struct Numbers
{
    char cell[21];
    char home[21];
    char business[21];
};

int main (void)
{
    // Declare variables here:

    char prompt[10];
    char prompt1;

    struct Numbers numbers;

    numbers.cell[0] = '\0';
    numbers.home[0] = '\0';
    numbers.business[0] = '\0';

    printf(""Do you want to enter a cell phone number? (y or n):\n"");
    scanf("" %c"", &amp;prompt1);

    if (prompt1 == 'y' || prompt1 == 'Y')
    {
        printf(""Please enter the contact's cell phone number:\n"");
        scanf(""%s"", numbers.cell);
    }

    printf(""Do you want to enter a home phone number? (y or n):\n"");
    scanf("" %c"", &amp;prompt1);
    if (prompt1 == 'y' || prompt1 == 'Y')
    {
        printf(""Please enter the contact's home phone number:\n"");
        scanf(""%s"", numbers.home);
    }

    printf(""Do you want to enter a business phone number? (y or n):\n"");
    scanf(""%s"", &amp;prompt);
    if (*prompt == 'y' || *prompt == 'Y')
    {
        printf(""Please enter the contact's business phone number:\n"");
        scanf(""%s"", numbers.business);
    }

    printf(""\n"");

    printf(""Phone Numbers:"");
    printf(""\n"");
    printf(""Cell phone number: %s"", numbers.cell);
    printf(""\n"");
    printf(""Home phone number: %s"", numbers.home);
    printf(""\n"");
    printf(""Business phone number: %s"", numbers.business);
    printf(""\n"");

    printf(""Structure test for Name, Address, and Numbers Done!"");

   return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>Do you want to enter a cell phone number? (y or n):                                                                                           
y                                                                                                                                             
Please enter the contact's cell phone number:                                                                                                 
123                                                                                                                                           
Do you want to enter a home phone number? (y or n):                                                                                           
y                                                                                                                                             
Please enter the contact's home phone number:                                                                                                 
456                                                                                                                                           
Do you want to enter a business phone number? (y or n):                                                                                       
y                                                                                                                                             
Please enter the contact's business phone number:                                                                                             
789                                                                                                                                           

Phone Numbers:                                                                                                                                
Cell phone number: 123                                                                                                                        
Home phone number: 456                                                                                                                        
Business phone number: 789                                                                                                                    
Structure test for Name, Address, and Numbers Done!
</code></pre>
",4
51894252,51893959,0,"<p>This is perfectly fine, as others have said.</p>

<p>However, you might be able to avoid this if  you use meaningful variable names.</p>

<p>I also find myself declaring a lot of differently named enums, which are basically just Boolean.</p>

<p>Which is clearer?</p>

<p>1)  </p>

<pre><code>processData(1);  // you might add acomemnt to explain what 1 means.
                 // Many won't bother (especially those @~¡ê%$!! who write  
                 // code that I have to main years later !!)
</code></pre>

<p>2)</p>

<pre><code>#define TRUE 1
#define FALSE 0
...

processData(TRUE);
</code></pre>

<p>3)  </p>

<pre><code>typedef enum {deleteDuplicates, retainDuplicates} howTohandleDuplicates_t;

processData(deleteDuplicates);
</code></pre>

<p>Always try your best to write maintainable, easy to read, code. Comments are fine, but well chosen variable names can obviate the need for most of them</p>
",4
51899451,51899413,4,"<p>This code would not be undefined behavior, in the sense that the pointer to storage of <code>x</code> returned by your function would remain valid even after your function exits. In other words, this does not create the problem that you get when you return a pointer to locally-allocated automatic storage.</p>

<p>A problem you may get by returning this pointer directly is that the callers may not respect the boundaries of <code>x</code>'s storage, and access memory past <code>my_function()+sizeof(x)</code>. This could be fixed by providing functions to read and write <code>x</code> without returning a pointer to it.</p>

<p><strong>Note:</strong> Using <code>static</code> makes the name of the variable <code>x</code> inaccessible, not its storage. The idea is to let other modules define their own variables <code>x</code> without creating a name collision.</p>
",0
51899449,51899413,5,"<p>The variable <code>x</code> is not <em>visible</em> by that name outside of myfile.c, however because it resides at file scope, i.e. it has static storage duration, its lifetime is still the lifetime of the whole program.</p>

<p>So it is valid to return a pointer to static data between source files.</p>
",0
59129320,59129287,2,"<p>You need to give the type-alias a name:</p>

<pre><code>// structure name
//             v
typedef struct x x;
//               ^
// type-alias name
</code></pre>

<p>And you can define that name only once (i.e. only <em>one</em> <code>typedef</code>), so drop the type-aliasing when defining the structure:</p>

<pre><code>struct x
{
    int a;
    int b;
};
</code></pre>
",2
48514968,48514819,5,"<p>One problem is that access to the misaligned members is slower ¡ª alignment is used to ensure speedy access.</p>

<p>People tend to use packing when they think they need to send the structure over the wire (a network connection) and don't want to spend time serializing and deserializing their data, not always realizing that there's a cost to avoiding that overhead that may be comparable to the cost of serialization/deserialization.  If the receiving CPU is big-endian while the sending end is little-endian, the work has to be done properly anyway by at least one of the computers.  The cost does vary with platform ¡ª RISC chips tend to be more stringent about misaligned access than CISC chips.  (On a DEC Alpha, for example, unaligned access resulted in a system call.)</p>
",4
57300624,57297434,1,"<p>Eight lines suffice:</p>

<pre><code>#include &lt;unistd.h&gt;

int main(void)
{
    int i;
    i = 0;
    while (++i &lt; 1000)
        if (i/100 &lt; i/10%10 &amp;&amp; i/10%10 &lt; i%10)
            write(1, (char []) { '0' + i/100, '0' + i/10%10, '0' + i%10, '\n'}, 4);
}
</code></pre>

<p>One could make it seven by changing <code>int i;</code> and <code>i = 0;</code> to <code>static int i;</code>, relying on static initialization to initialize <code>i</code> to zero.</p>
",1
57297937,57297434,2,"<p>Something like this?</p>

<pre><code>#include &lt;unistd.h&gt;

void pnum(int num)
{
    char digs[4];
    digs[0] = (num/100) + '0';
    digs[1] = (num % 100)/10 + '0';
    digs[2] = (num % 10) + '0';
    digs[3] = '\n';
    if ((digs[0] &lt; digs[1]) &amp;&amp; (digs[1] &lt; digs[2]))
        write(1, digs, 4);
}

int main()
{
    int a;
    a=0;
    while (a++ &lt; 1000)
    {
        pnum(a);
    }
}
</code></pre>

<p>Note: learn to break requirements down and implement them in pieces.  The breakdown that I saw was: 1) generate all combinations in ascending order. 2) display the ones that have the digits in ascending order.  That's why I wrote this in two parts.</p>
",2
50263833,50263769,2,"<p>If your array of line numbers is sorted in ascending order, you could do it by modifying your code as follows:</p>

<pre><code>int lineNumbers[] = {1, 3, 5, 7, 9};
size_t numElements = sizeof(lineNumbers)/sizeof(lineNumbers[0]);
size_t currentIndex = 0;
...
while ( fgets ( line, sizeof line, file ) != NULL ) {/* read a line */
    i++;
    if (i  == lineNumbers[currentIndex]) {
        fputs ( line, stdout ); /* write the line */
        if (++currentIndex == numElements) {
            break;
        }
    }
}
</code></pre>

<p>This lets you determine if <code>i</code> is equal to the next desired line without walking through the array repeatedly.</p>
",1
53737264,53734825,2,"<p>You need to make a number of changes to the code.  The parent shouldn't really wait on its children until after they're all launched.  Since you create a new pipe for each of the first three children, you need to keep track of which file descriptors are in use.  You should use arrays for that, and for the strings to be sent.  Neither the <code>read()</code> nor the <code>write()</code> system calls  null-terminates strings, and you don't tell it to write a null byte at the end, so you need to tell <code>printf()</code> to print the correct information.</p>

<p>Those changes and sundry others lead to:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

#define MAX_CHILDREN 3

int main(void)
{
    pid_t pid;
    int fd[MAX_CHILDREN][2];
    char buffer[100];
    const char *str[MAX_CHILDREN] = { ""Hello 1"", ""Hello 2"", ""Hello 3"" };

    for (int i = 0; i &lt; MAX_CHILDREN; i++)
    {
        if (pipe(fd[i]) == -1)
        {
            perror(""pipe Failed"");
            exit(1);
        }
        pid = fork();
        if (pid &lt; 0)
        {
            perror(""fork failed"");
            exit(1);
        }
        if (pid == 0)
        {
            printf(""Child %i (pid= %i) send string %s\n"", i + 1, getpid(), str[i]);
            write(fd[i][1], str[i], strlen(str[i]));
            exit(i + 1);
        }
    }

    pid = fork();

    if (pid &lt; 0)
    {
        perror(""fork failed"");
        exit(1);
    }
    if (pid == 0)
    {
        printf(""The new process %i read fd pipe\n"", getpid());
        for (int i = MAX_CHILDREN; i-- &gt; 0; )
        {
            int nbytes;
            if ((nbytes = read(fd[i][0], buffer, sizeof(buffer))) &lt;= 0)
            {
                perror(""error read"");
                exit(EXIT_FAILURE);
            }
            printf(""String read: %.*s\n"", nbytes, buffer);
        }
        exit(4);
    }

    int corpse;
    int status;
    while ((corpse = wait(&amp;status)) &gt;= 0)
        printf(""child %d exited with status 0x%.4X\n"", corpse, status);
    return 0;
}
</code></pre>

<p>When run, the output might be:</p>

<pre><code>Child 1 (pid= 91027) send string Hello 1
Child 2 (pid= 91028) send string Hello 2
Child 3 (pid= 91029) send string Hello 3
The new process 91030 read fd pipe
String read: Hello 3
String read: Hello 2
String read: Hello 1
child 91027 exited with status 0x0100
child 91028 exited with status 0x0200
child 91029 exited with status 0x0300
child 91030 exited with status 0x0400
</code></pre>

<p>I reversed the order of the elements in the reading loop, mainly just for fun.  You can use a conventional <code>for (int i = 0; i &lt; MAX_CHILDREN; i++)</code> loop instead if you prefer.</p>

<p>Although it isn't crucial in this program, you aren't closing enough file descriptors in the children or the parent.  The parent should close the write ends of the pipes; it isn't going to be using them.  The children should close the read ends of the pipes; they aren't going to be using them.  Further, the second and third children should close the pipes opened for the first, and the third should close the pipe for the second, as they aren't going to use those, either.  If you don't do this and the fourth child looped waiting for EOF (0 bytes returned), it would hang.</p>

<p><strong>Rule of thumb</strong>: If you
<a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/dup2.html"" rel=""nofollow noreferrer""><code>dup2()</code></a>
one end of a pipe to standard input or standard output, close both of the
original file descriptors returned by
<a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html"" rel=""nofollow noreferrer""><code>pipe()</code></a>
as soon as possible.
In particular, you should close them before using any of the
<a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/execvp.html"" rel=""nofollow noreferrer""><code>exec*()</code></a>
family of functions.</p>

<p>The rule also applies if you duplicate the descriptors with either
<a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/dup.html"" rel=""nofollow noreferrer""><code>dup()</code></a>
or
<a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/fcntl.html"" rel=""nofollow noreferrer""><code>fcntl()</code></a>
with <code>F_DUPFD</code></p>

<hr>

<p>Note that an alternative design for the program would create a single pipe outside the loop and the children would all write to the same pipe.  You'd probably want to add a newline to the message strings so that the results are separate.  You'd definitely want to think about looping the read in the fourth child, and you'd need to worry about the pipe being closed properly, and so on.  It'd be a worthwhile sub-exercise to code that.</p>
",0
51344736,46717958,2,"<p>Using a diverse approach</p>

<pre><code>int main()
{
    char string[4];
    int reverse = 0;

    printf(""Enter the number to reverse:\n"");
    scanf_s(""%d"", &amp;reverse);

    if (reverse &gt; 999)
        return 0;

    sprintf_s(string, ""%d"", reverse);

    char c1 = string[0];
    string[0] = string[2];
    string[2] = c1;

    reverse = atoi(string);

    printf("" The reverse is %d"", reverse);
    return 0;
}
</code></pre>

<p>or if you don't want to use atoi</p>

<pre><code>int main()
{
    char string[4];
    int reverse = 0;

    printf(""Enter the number to reverse:\n"");
    scanf_s(""%d"", &amp;reverse);

    if (reverse &gt; 999)
        return 0;

    sprintf_s(string, ""%d"", reverse);

    printf("" The reverse is %c%c%c"", string[2], string[1], string[0]);

    return 0;
}
</code></pre>
",0
48554701,48550232,0,"<p>Your condition for the while loop should be the <code>fscanf()</code> statement itself. <code>EOF</code> is always an integer. See the <a href=""https://www.ibm.com/support/knowledgecenter/en/ssw_ibm_i_71/rtref/fscanf.htm"" rel=""nofollow noreferrer"">manual page for <code>fscanf()</code></a>:</p>

<blockquote>
  <p><strong>Return Value</strong></p>
  
  <p>The fscanf() function returns the number of fields that it successfully converted and assigned. The return value does not include fields that the fscanf() function read but did not assign.</p>
  
  <p>The return value is EOF if an input failure occurs before any conversion, or the number of input items assigned if successful.</p>
</blockquote>

<p>And, like everyone else I will refer you to <strong><a href=""https://stackoverflow.com/questions/5431941/why-is-while-feof-file-always-wrong?rq=1"">Why is <code>while ( !feof (file) )</code> always wrong?</a></strong>. This is essential reading on Stack Overflow for new C programmers.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
    FILE *fp1, *fp2, *fp3;
    int n, i, num, flag = 0, ret;

    /* fopen files */

    while ((ret = fscanf(fp1, ""%d"", &amp;num)) != EOF) {
        if (ret == 0) {
            getc(fp1);
            continue;
        }
        if (num % 2 == 0) {
            fprintf(fp2, ""%d "", num);
        }
        /* rest of the loop here */
    }

    /* fclose files */
}
</code></pre>

<p>If <code>fscanf()</code> fails to read a character, but does not return EOF, it can often solve things to <code>getc()</code>, to advance the buffer by one character. This method also works when using <code>getchar()</code> to advance stdin, after getting user input from <code>scanf()</code>.</p>
",0
48550461,48550232,3,"<p><code>fscanf</code> returns <code>EOF</code> when the end-of-file is reached:</p>

<blockquote>
  <p><em>man fscanf</em></p>

<pre><code>#include &lt;stdio.h&gt;

int scanf(const char *format, ...);
int fscanf(FILE *stream, const char *format, ...);
int sscanf(const char *str, const char *format, ...);
</code></pre>
  
  <p>[...]</p>
  
  <p>The <code>scanf()</code> function reads input from the standard input stream <code>stdin</code>, <code>fscanf()</code> reads input from the stream pointer <code>stream</code>, and
  <code>sscanf()</code> reads its input from the character string pointed to by <code>str</code>.</p>
  
  <p>[...]</p>
  
  <p><strong>RETURN VALUE</strong></p>
  
  <p>On success, these functions return the number of input items successfully matched and assigned; this can be fewer than provided for, or
  even zero, in the event of an early matching failure.</p>
  
  <p><strong>The value <code>EOF</code> is returned if the end of input is reached before either the first successful conversion or a matching failure occurs.
  <code>EOF</code> is also returned if a read error occurs, in which case the error indicator for the stream (see ferror(3)) is set, and <code>errno</code> is set
  to indicate the error.</strong></p>
</blockquote>

<p>A solution would be to read save the return value of <code>fscanf</code> in a <code>int</code>
variable and check it agains 0 and <code>EOF</code>, like this:</p>

<p>If you want to keep using <code>fscanf</code>:</p>

<pre><code>int ret;
while((ret = fscanf(fp1, ""%d, &amp;num)) != EOF)
{
    if(ret == 0)
    {
        // fscanf failed to convert the input
        // let it consume a charatcer and try again.
        getc(fp1);
        continue;
    }

    if(num % 2 == 0)
        ...
}
</code></pre>

<p><strong>edit</strong></p>

<p>Avoid using <code>feof</code> to control looping on a file like this <code>while(!feof(fp)</code>, see <a href=""https://stackoverflow.com/questions/5431941/"">Why is ¡°while ( !feof (file) )¡± always wrong?</a> for more
information about that.</p>

<hr>

<p><strong>edit 2</strong></p>

<p>This was my original idea, but as Jonathan Leffler pointed out in the comments:</p>

<blockquote>
  <p><em>Jonathan Leffler wrote:</em></p>
  
  <p>Your first solution demands a single number per line, which the code in the question does not</p>
</blockquote>

<p>He's right, I didn't see that.</p>

<blockquote>
  <p><em>me from the past</em></p>
  
  <p>One option would be to read the input line by line using <code>fgets</code> and then use
  <code>sscanf</code> to parse the line:</p>

<pre><code>char buffer[1024];

while(fgets(buffer, sizeof buffer, fp1))
{
    if(sscanf(buffer, ""%d"", &amp;num) != 1)
    {
        fprintf(stderr, ""Could not read an integer, ignoring line\n"");
        continue;
    }

    if (num % 2 == 0)
        ...
}
</code></pre>
</blockquote>
",0
48290932,48290855,4,"<p>You need to <code>NUL</code> terminate your C-style strings, and that includes allocating enough memory to hold the <code>NUL</code>.</p>

<p>Your array is a byte short (must be <code>char command[strlen(argv[1])+4+1];</code> to leave space for <code>NUL</code>), and you should probably just use something like <code>sprintf</code> to fill it in, e.g.:</p>

<pre><code> sprintf(command, ""vim %s"", argv[1]);`
</code></pre>

<p>That's simpler than manual loops, and it also fills in the <code>NUL</code> for you.</p>

<p>The garbage you see is caused by the search for the <code>NUL</code> byte (which terminates the string) wandering off into unrelated (and undefined for that matter) memory that happens to occur after the buffer.</p>
",1
48291257,48290855,0,"<p>I know that there are already good answers here, but I'd like to expand them a little bit.</p>

<p>I often see this kind of code</p>

<pre><code>system(""vim %s"",argv[1]); //Error:
</code></pre>

<p>and beginners often wonder, why that is not working.</p>

<p>The reason for that is that <code>""%s"", some_string</code> is <strong>not</strong> a feature of the C
language, the sequence of characters <code>%s</code> has no special meaning, in fact it is
as meaningful as the sequence <code>mickey mouse</code>.</p>

<p>The reason why that works with <code>printf</code> (and the other members of the
<code>printf</code>-family) is because <code>printf</code> <strong>was designed</strong> to replace sequences like
<code>%s</code> with a value passed as an argument. It's <code>printf</code> which make <code>%s</code> special,
not the C language.</p>

<p>As you may have noticed, doing <code>""hallo"" + "" world""</code> doesn't do string
concatenation. C doesn't have a native string type that behaves like C++'s
<code>std::string</code> or Python's <code>String</code>. In C a string is just a sequence of
characters that happen to have a byte with value of 0 at the end (also called
the <code>'\0'</code>-terminating byte).</p>

<p>That's why you pass to <code>printf</code> a format as the first argument. It tells
<code>printf</code> that it should print character by character unless it finds a <code>%</code>,
which tells <code>printf</code> that the next character(s)<sup>1</sup> is/are special and
must substitute them with the value passed as subsequent arguments to <code>printf</code>.</p>

<p>The <code>%x</code> are called conversion specifiers and the <a href=""https://linux.die.net/man/3/printf"" rel=""nofollow noreferrer"">documentation of <code>printf</code></a>
will list all of them and how to use them.</p>

<p>Other functions like the <code>scanf</code> family use a similar strategy, but that doesn't
mean that all functions in C that expect strings, will work the same way. In
fact the vast majority of C functions that expect strings, do not work in that
way.</p>

<blockquote>
  <p><em>man system</em></p>

<pre><code>#include &lt;stdlib.h&gt;

int system(const char *command);
</code></pre>
</blockquote>

<p>Here you see that <code>system</code> is a function that expects <strong>one</strong> argument only.
That's why your compiler complains with a line like this: <code>system(""vim %s"",argv[1]);</code>.
That's where functions like <code>sprintf</code> or <code>snprintf</code> come in handy.</p>

<hr>

<p><sup>1</sup>If you take a look at the <code>printf</code> documentation you will see that
the conversion specifier together with length modifiers can be longer than 1
character.</p>
",2
58692131,58692009,0,"<p><code>int16_t</code> has the range <code>[?32768, +32767]</code> - you are overflowing that range immediately with the first multiplication.</p>

<p>What does the first printf print out? That should have been an indication. You also mention it in your question.</p>

<p>Google <code>int16_t range</code> and it will show you the range above. Try using an int32_t and see what difference that makes.</p>
",2
58695419,58692009,0,"<p>Given <code>y = y * z;</code> where all operands are type <code>int16_t</code> and the values are 1024 * 65 = 66560, 
then there are two possibilities:</p>

<ul>
<li>If your system is 8 or 16 bit, you will have 16 bit <code>int</code> type. There will be no type promotion of the operands since they are already 16 bits and you get a signed integer overflow, invoking undefined behavior. Since 16 bit signed integers can only store values up to 32767.</li>
<li><p>If your system is 32 bit, then both <code>y</code> and <code>z</code> are implicitly promoted (see <a href=""https://stackoverflow.com/questions/46073295/implicit-type-promotion-rules"">Implicit type promotion rules</a>) to type <code>int</code> which is then 32 bits. The result of the multiplication is of type <code>int</code>. The value 66560 will fit just fine.</p>

<p>You then convert this 32 bit <code>int</code> to <code>int16_t</code> upon assignment. The value will no longer fit - what will happen is an implementation-defined conversion from signed 32 to signed 16. (In theory your system may raise a signal here.) </p>

<p>In practice most systems will simply take the 66560 = 10400h and cut off the MS bytes, leaving you with 1024 = 400h.</p></li>
</ul>

<p>In either case, the equation <code>y = y * z;</code> is highly questionable given the size of the input values! This is to be regarded as a bug. You should use <code>uint16_t</code> or <code>int32_t</code> instead.</p>

<hr>

<p>As for <code>y / 3 * 3 - 3 * y / 3</code>, it will be <code>1024 / 3 * 3 - 3 * 1024 / 3</code>. All operands are integers and the operator associativity of multiplicative operators <code>*</code> and <code>/</code> is left-to-right. </p>

<p>So you get <code>341 * 3 - 3072 / 3</code> -> <code>1023 - 1024</code> = <code>-1</code>. </p>

<hr>

<p>As a side-note, you are using the wrong <code>printf</code> conversion specifier. The most correct one for <code>int16_t</code> is this:</p>

<pre><code>#include &lt;inttypes.h&gt;

printf(""1. Ausgabe: %""PRIi16 ""\n"", y);
</code></pre>
",0
52536050,52534940,-1,"<p>You probably want something like this:</p>

<ul>
<li>no more obscure copying into a global variable (avoid global variables whenever possible)</li>
<li>no more cast for malloc</li>
<li><code>free</code> called once we're done with the created human and not before</li>
</ul>

<hr>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Human
{
    int age;
    char sex;
    float height;
    float weight;
};

struct Human *create_human(int age, char sex, float height, float weight)
{
    struct Human *A = malloc(sizeof(struct Human));  // no need to cast
    A-&gt;age = age;
    A-&gt;sex = sex;
    A-&gt;height = height;
    A-&gt;weight = weight;
    return A;
}

int main()
{
    struct Human *human = create_human(22, 'M', 1.90, 100.0);
    printf(""Age: %d\tSex: %c\tHeight %.2f\tWeight %.2f\n"", human-&gt;age, human-&gt;sex, human-&gt;height, human-&gt;weight);
    free(human);
}
</code></pre>

<p>If you absolutely want to copy your human into a global variable, you can still do it:</p>

<pre><code>...
struct human *globalhuman;
...
int main()
{
    globalhuman = create_human(22, 'M', 1.90, 100.0);
    printf(""Age: %d\tSex: %c\tHeight %.2f\tWeight %.2f\n"", globalhuman -&gt;age, globalhuman -&gt;sex, globalhuman -&gt;height, globalhuman -&gt;weight);
    free(globalhuman );
}
</code></pre>
",1
53698725,53698677,2,"<p>In C, a string is just an array of type <code>char</code> that contains printable characters followed by a terminating null character (<code>'\0'</code>). </p>

<p>With this knowledge, you can eschew the standard functions <code>strcpy</code> and <code>strcat</code> and assign a string manually: </p>

<pre><code>A[0] = '1';
A[1] = '2';
A[2] = '\0';
</code></pre>

<p>If there were characters in the string <code>A</code> beyond index <code>2</code>, they don't matter since string processing functions will stop reading the string once they encounter the null terminator at <code>A[2]</code>.</p>
",0
49353458,49352762,0,"<p>To ""delete"" an element from a stack-allocated array is really just to overwrite it and shift future elements back by one. To do this, you will need <code>memmove</code></p>

<pre><code>/* delelem: Removes element at zero-based index at from array array of 
   size size */
void delelem(int *array, size_t size, int at)
{
    if (at &lt; size-1)
        memmove(&amp;array[at], &amp;array[at+1], 
                ((size - 1) - at) * sizeof(array[0]));
    array[size - 1] = 0; /* use 0 to denote an empty element. In order for
                            this to work, use memset to zero out the array 
                            when it is first created */
}
</code></pre>

<p>Rewriting this code to use client objects is trivial.</p>
",0
53398618,53398526,0,"<p>You're not actually calling the functions:</p>

<pre><code>if(number&lt;0)
{
    void Calculate_neg_power(number,expo);
}
else{
    void Calculate_pos_power(number,expo);
}
</code></pre>

<p>These are function <em>declarations</em>, and invalid ones at that.</p>

<p>When calling a function, don't prefix it with the return type.</p>

<pre><code>if(number&lt;0)
{
    Calculate_neg_power(number,expo);
}
else{
    Calculate_pos_power(number,expo);
}
</code></pre>

<p>You also have a similar declaration inside one of your functions that isn't doing anything:</p>

<pre><code>int Driver(NUMBER,EXPO, ans);
</code></pre>

<p>This can be removed.</p>
",1
55340346,55339592,0,"<p>Try this:</p>

<pre><code>const int length = 9;
int counter = 0;
int wait_loop_cnt = 0;

while (
  wait_loop_cnt++ &lt;= MAX_WAIT_LOOP &amp;&amp; 
  counter &lt; length) /* NO semicolon here! */
{
  if (read_byte_successfully(...))
  {
    ++counter;
  }
}

if (counter &lt; length) 
{
  /* Handle case of to few bytes received here. */
}
</code></pre>
",0
54602692,54602258,0,"<p>You're going to want to figure out how you want to store the pixel data in RAM. Specifically, do you want:</p>

<ul>
<li>a 1 dimensional array of ""pointers to 1 dimensional array of pixels"" for each row</li>
<li>a 2 dimensional array of pixels</li>
<li>something else</li>
</ul>

<p>Your code looks like it's trying to do the first option (and looks like it's doing it wrong - e.g. <code>malloc(height * sizeof(struct pixel));</code> when it should be <code>malloc(height * sizeof(struct pixel *));</code>. However your code also looks like it's trying to do the second option (e.g. <code>ptrs[i][j]-&gt;blue</code> and not <code>row = ptrs[i];</code> and <code>row[j]-&gt;blue</code>).</p>

<p>For the first option (1 dimensional array of pointers) it'd be like:</p>

<pre><code>struct pixel **read_pixel_array(FILE *image, int pixel_array_offset, int width, int height) {

    struct pixel **ptrs;
    struct pixel *row;

    ptrs = malloc(height * sizeof(struct pixel *));
    if(ptrs == NULL) {
        // Failed to allocate memory for array of pointers
        return NULL;
    }

    fseek(image, pixel_array_offset, SEEK_SET);

    for (int i=0, i&lt;height, i++) {
        row = malloc(width * sizeof(struct pixel));
        if(row == NULL) {
            // Failed to allocate memory for row. Need to free everything
            //   that was previously allocated to avoid memory leaks
            while(i &gt; 0) {
                i--;
                free(ptrs[i]);
            }
            free(ptrs);
            return NULL;
        }
        ptrs[i] = row;
        for (int j=0, j&lt;width, j++) {
            fread(row[j]-&gt;blue, 1, 1, image);
            fread(row[j]-&gt;green, 1, 1, image);
            fread(row[j]-&gt;red, 1, 1, image);
        }
    }
    return ptrs;
}
</code></pre>

<p>Myself, I'd use the second option (one 2D array) because it's easier and faster. The problem is that C doesn't know the dimensions at compile time, so you need to cheat and use ""2D array implemented as 1D array"". In that case it'd be like:</p>

<pre><code>struct pixel *read_pixel_array(FILE *image, int pixel_array_offset, int width, int height) {
    struct pixel *myArray;

    myArray = malloc(height * width * sizeof(struct pixel));
    if(myArray == NULL) {
        // Failed to allocate memory
        return NULL;
    }

    fseek(image, pixel_array_offset, SEEK_SET);

    for (int i=0, i&lt;height, i++) {
        for (int j=0, j&lt;width, j++) {
            fread(myArray [i*width + j]-&gt;blue, 1, 1, image);
            fread(myArray [i*width + j]-&gt;green, 1, 1, image);
            fread(myArray [i*width + j]-&gt;red, 1, 1, image);
        }
    }
    return myArray;
}
</code></pre>

<p>NOTE: Neither of these examples were tested and neither can be assumed ""correct"" without testing.</p>
",0
51341150,51338558,0,"<p>You can define <code>F_CPU</code> in a common header (i.e., both foo.c and bar.c include qux.h, and qux.h contains a <code>#define F_CPU ...</code>), or pass have your build system pass <code>-DF_CPU=...</code> in the C flags.</p>
",1
53535423,53534544,1,"<p>Yes, you can associate data with graph edges, and it's not related to the way you are representing the graph. Think of how you would solve the <a href=""https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/"" rel=""nofollow noreferrer"">shortest path problem</a>; you obviously need to know the distance between two nodes in your graph, and this information is a property of the edge connecting them, not the individual nodes.</p>

<p>In your example, you could have:</p>

<pre><code>// create reciprocal links between nodes 'src' and 'dst',
// containing the 'distance' information
void graph_link_two_cities(struct Graph* graph, int src, int dst, int distance)
{
    {
        struct Edge* head = graph-&gt;array[src].head; 
        struct Edge* node = { .id = dst, .distance = length, .next = head });
        graph-&gt;edges[src].head = node;
    }

    {
        struct Edge* head = graph-&gt;array[dst].head; 
        struct Edge* node = { .id = src, .distance = length, .next = head });
        graph-&gt;edges[dst].head = node;
    }
}
</code></pre>

<p>Using an adjacency matrix, you would simply store the distance between <code>src</code> and <code>dst</code> into <code>matrix[src][dst]</code>.</p>
",3
55224613,55224304,1,"<p>With some prints I have seen there are some problems in this line:</p>

<pre><code>printf (""%s   %s   %s\n\n%s   %s   %s\n\n%s   %s   %s\n\n"",input[0][0],input[0][1],input[0][2],input[1][0],input[1][1],input[1][2],input[2][0],input[2][1],input[2][2]);
</code></pre>

<p>You defined <code>char input[3][3]</code> so <code>input[0][0]</code> is a single char (and the others with different indexes too) just like if I define <code>char my_str[10];</code>, <code>my_str[0]</code> is a single char.</p>

<p>I don't know if this is what you want but changing to:</p>

<pre><code>printf (""%c   %c   %c\n\n%c   %c   %c\n\n%c   %c   %c\n\n"",input[0][0],input[0][1],input[0][2],input[1][0],input[1][1],input[1][2],input[2][0],input[2][1],input[2][2]);
</code></pre>

<p>should not generate the error.</p>
",1
53672965,53672849,3,"<p><code>ptr</code> points to an array of <code>int *</code>.  On your system, it appears that pointers are 8 bytes in size, so each member of the array is 8 bytes.   </p>

<p>When you then print the address of each member as <code>ptr + i</code>, you see that they each differ by 8.</p>

<p>Also, you should be using <code>%p</code> to print pointers instead of <code>%d</code>.  Using the wrong format specifier invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>Regarding the specific memory addresses returned by <code>malloc</code>, those are an implementation detail of the library.  There is no requirement that successive allocations should be adjacent in memory.  In fact, it makes sense that they are not adjacent because there is likely some metadata being stored in those in-between addresses which is being used internally by <code>malloc</code>.</p>
",5
49523026,49522820,1,"<p>The <a href=""http://man7.org/linux/man-pages/man3/printf.3.html"" rel=""nofollow noreferrer"">documentation for <code>sprintf</code></a> reads like:</p>

<blockquote>
  <p><code>int sprintf(char *str, const char *format, ...);</code></p>
  
  <p><code>sprintf()</code> [et al.] ... write to the character string
         <em><code>str</code></em>.</p>
</blockquote>

<p>You suffered undefined behavior due to <code>sprintf</code> attempting to read uninitialized memory to use as the format string, and attempting to write to a string literal.</p>

<p>However, you should prefer <code>snprintf</code> to <code>sprintf</code> to help you avoid buffer overflow issues.</p>

<pre><code>int r = snprintf(graduationText, 1024, ""%.*f"", decimalsToShow, graduation);
</code></pre>
",0
53049546,53049391,3,"<p>Your understanding is correct till 3.</p>

<p>4 - <code>p</code> points to the first element of <code>a</code>.</p>

<p>5 - You are using the post increment operator. So <code>p</code>'s old value will be used and <code>p</code> will be incremented (meaning <code>p</code> will now point to the second element in <code>a</code>). So this is equivalent to <code>p[0] = i + 1; p = p + 1; i = i + 1;</code>
At this point <code>p</code> is pointing to the second element of <code>a</code> and the first element of <code>a</code> is changed to <code>3</code>. <code>i</code> is also <code>3</code> at this point. </p>

<ol start=""6"">
<li><code>a[0] = 3</code>, <code>a[i++] = a[3] = 11</code>, <code>*p = a[1] = 7</code>, <code>*(p+2) = a[3] = 11</code>. </li>
</ol>

<p>This is exactly the output you get - See <a href=""https://ideone.com/pdi00T"" rel=""nofollow noreferrer"">here</a>.</p>
",1
48094500,48094250,2,"<p>There are a couple of issues with your code:
  It doesn't handle a single digit of 9 (which cause a stack overflow).
  Adding 1 to 9 makes 10 not 0.</p>

<p>I've run it through the sample data you supplied and it seems to work (in C#) and it has a hard core recursive line at the end.</p>

<pre><code>    int newNumber(int n)
    {
        if (n == 9)
            return 0;
        if (n &lt; 9)
            return n + 1;
        return (newNumber(n / 10) * 10) + newNumber(n % 10);
    }
</code></pre>
",4
50697532,50697406,1,"<p>The reason is because of the last line in the function, which prints the value of <code>k</code> after the recursive call has returned/finished. This will print the value as it was <em>before</em> the <code>+1</code>, i.e. the original value before the call. </p>

<p>However, it only does that part after all the recursive calls are complete.</p>

<p>Basically, when <code>k&lt;n</code> is no longer true, then it will start to do the last <code>printf</code> call, then return to the previous function call and do that ones last <code>printf</code> (which will be the value of <code>k</code> before it was incremented) and it will repeat until all previous calls are complete.</p>

<p>It's quite hard to explain, you just need to step through it more carefully. Using a debugger would help greatly.</p>

<p>Maybe this helps explain it better:</p>

<pre><code>// call 1 (k = 2)
// call 1 print 2
    // call 2 (k = 3)
    // call 2 print 3
        // call 3 (k = 4)
        // call 3 print 4
            // call 4 (k = 5)
            // call 4 print 5
                // call 5 (k = 6)
                // call 5 print 6
                    // k&lt;n is false, so no more recursive calls.
                // call 5 print 6
            // call 4 print 5
        // call 3 print 4
    // call 2 print 3
// call 1 print 2
</code></pre>
",0
49018337,49018271,0,"<p>take a look at the command <a href=""http://www.cplusplus.com/reference/cstdio/fseek/"" rel=""nofollow noreferrer"">fseek reference</a></p>

<p>it jumps to an offset from Start/End/Current-position of File</p>

<p>to jump to start use <code>fseek(f, 0, SEEK_SET)</code> which is equivalent to <code>rewind(f)</code></p>
",0
55944371,55944160,0,"<p>As Ry mentioned, problem is with the cursor you are using in while loop, it's never initialized. Instead you are creating a new variable with the same name when *q is null. I see one more problem in your code, when list is empty you are adding new node twice. First in null check condition and then after while loop.</p>

<p>To fix move this line
""node *cursor = *q""
outside if condition and add a return instead. Also remove this line 
""node *cursor""</p>

<p>Note:: I am assuming your create method has no issue. </p>
",2
59311335,59311180,2,"<p>Let's pretend for a second you want to print the following for n=4:</p>

<pre><code>0 1 2 3
1 2 3 4
2 3 4 5
3 4 5 6
</code></pre>

<p>Pretty easy, eh? At any position, we simply print <code>row+col</code>.</p>

<p>But we want the numbers to wrap around when they become too large. The key is the modulus aka remainder (<code>%</code>) operator. <code>(row+col) % n</code> gives us the following:</p>

<pre><code>0 1 2 3
1 2 3 0
2 3 0 1
3 0 1 2
</code></pre>

<p>Finally, we just add one (<code>(row+col) % n + 1</code>) to get the desired result:</p>

<pre><code>1 2 3 4
2 3 4 1
3 4 1 2
4 1 2 3
</code></pre>
",2
49122287,48450421,0,"<blockquote>
  <p>A lot of times, I will get a ""wrong answer"" message when clearly my code answers the questions properly. </p>
</blockquote>

<p>This is <em>not</em> one of those cases as evidenced by the fact that, despite the contrary, your code seems to think that <code>9</code> is a prime. The line:</p>

<pre><code>if(j % 2 == 1 || j == 2)
</code></pre>

<p>combined with the fact that you appear to be printing all odd numbers (and two), is an indication that your prime check is incorrect.</p>

<hr>

<p>Where you should probably <em>start</em> is with a simple prime check function such as:</p>

<pre><code>int isPrime(int num) {
    int chk = 2;
    while (chk * chk &lt;= num)
        if ((num % chk) == 0)
            return 0;
        ++chk;
    }
    return 1;
}
</code></pre>

<p>Once you have it working, <em>then</em> worry about performance (two of my favourite mantras are ""Wrong is the <em>least</em> optimised state"" and ""Get it working first, <em>then</em> get it working fast"").</p>

<p>The things you can look into for optimisations include, but are not limited to:</p>

<ul>
<li>Eratosthenes sieve where, provided the range of primes isn't too large, it can greatly improve speed by not having to do a lot of calculations for each prime test; and</li>
<li>Using the fact that all primes other than two and three are of the form <code>6n¡À1</code>, effectively tripling the speed of the <code>isPrime</code> function (see <a href=""https://stackoverflow.com/questions/32431067/how-to-improve-the-efficiency-of-c-code-find-the-largest-prime-factor/32431097#32431097"">here</a> for an explanation).</li>
</ul>

<p>For that second bullet point, you can use:</p>

<pre><code>int isPrime(unsigned int num) {
    // Special cases for 0-3.

    if (num &lt; 2) return 0;
    if (num &lt; 4) return 1;

    int chk = 5, add = 2;         // prime generator, 6n +/- 1.
    while (chk * chk &lt;= num)      // check every candidate.
        if ((num % chk) == 0)     // check if composite.
            return 0;
        chk += add;               // next candidate.
        add = 6 - add;            // alternate +2, +4.
    }
    return 1;                     // no factors, must be prime.
}
</code></pre>
",0
57790742,57789507,1,"<p><code>(int)(float)(char) i;</code> is <strong>not</strong> a definition of <code>i</code>. It merely is using the value for nothing.</p>

<pre><code>#include &lt;stdio.h&gt;
double i;
int main(void) {
    i; // use i for nothing
    (int)i; // convert the value of i to integer, than use that value for nothing
    (int)(float)i; // convert to float, then to int, then use for nothing
    (int)(float)(char)i; // convert char, then to float, then to int, then use for nothing
    printf(""sizeof i is %d\n"", (int)sizeof i);
    char i; // define a new i (and hide the previous one) of type char
    printf(""sizeof i is %d\n"", (int)sizeof i);
}
</code></pre>
",3
50426457,50426296,2,"<p>I tried your code and I do get non-zero results -- depending on the input, of course, so maybe you are only testing on strings that produce zero.</p>

<p>However, the results are not always correct.  There are two problems I found in the code:</p>

<p>1) As pointed out in a comment, you should initialize <code>upper</code> and <code>chars</code> to 0.</p>

<p>2) You are starting the loop at index 1, not index 0.  I think you did this so you could look at <code>text[i-1]</code> inside the loop, but it is causing you to exclude the first character from your totals.  You should start the loop index and 0 and figure out a different way to handle it within the loop.  (Hint - note that the first <code>if</code> within the loop and the one following the loop have similar conditions and the same body.)</p>
",1
50223841,50223815,0,"<p>After the first <code>fread()</code> add an</p>

<pre><code>if (feof(fp))
{
    break;
}
</code></pre>

<p>What happens is that the first <code>fread</code> will trigger the end of file, so <code>pn</code> won't be changed. Then the second <code>fread</code> triggers end of file again, <code>q</code> also doesn't get changed. Then the 3rd <code>fread</code> yet again triggers eof, and <code>p</code> remains unchanged. <code>printf</code> will show the old values one more time.</p>
",0
51942948,51942867,8,"<p>The best way is probably type punning over <code>union</code>. It allows you to use the same memory area with different variable representations, for example by giving each struct member individual names, while at the same time remaining able to loop through them.</p>

<pre><code>#include &lt;stdio.h&gt;

typedef union {
  struct  // anonymous struct, requires standard C compiler
  {
    int a;
    int b;
    int c;
  };
  int array[3];
} Example;


int main (void)
{
  Example ex = { .a=1, .b=2, .c=3 };

  for(size_t i=0; i&lt;3; i++)
  {
    printf(""%d\n"", ex.array[i]);
  }
}
</code></pre>

<hr>

<p>If you can't change the struct definition, then the second best is some pointer arithmetic through a character type. This takes much more care though, so that you don't end up writing code with poorly-defined behavior - you need to be aware of things like alignment and strict aliasing. Character types are preferred to work with in case the struct turns more complex with different types of members, because character types are safe from aliasing issues.</p>

<p>Assuming <code>uint8_t</code> is a character type, then:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

typedef union {
  struct
  {
    int a;
    int b;
    int c;
  };
} Example;


int main (void)
{
  Example ex = { .a=1, .b=2, .c=3 };
  uint8_t* begin = (uint8_t*)&amp;ex;
  uint8_t* end   = begin + sizeof ex;


  for(uint8_t* i=begin; i!=end; i+=sizeof(int))
  {
    printf(""%d\n"", *(int*)i);
  }
}
</code></pre>
",3
54776920,54776872,4,"<p>The difference is in returning a value as opposed to returning a pointer.</p>

<p>When you do this:</p>

<pre><code>int f()
{
    int x = 9;
    return x;
}

int main()
{
    int a = f();
    printf(""a=%d\n"", a);
    return;
}
</code></pre>

<p>This is valid because even though <code>x</code> is out of scope when <code>f</code> returns, it is the <em>value</em> stored in <code>x</code> (9 in this case) that is returned.  That value is then assigned to <code>a</code> and subsequently printed.</p>

<p>In your example you're returning an array.  In most contexts, an array used in an expression decays into a pointer to its first element.  So <code>return str</code> is the same as <code>return &amp;str[0]</code>.  That pointer value is returned and passed to <code>printf</code>.  Then <code>printf</code> tried to dereference that pointer, but the memory it points to (the array <code>str</code>) is no longer valid.</p>

<p>So you can return values from a function, but if that value is a pointer to a local variable it will not be valid.</p>
",0
53977649,53977336,5,"<p>I'll try to help you by being as concise as I can.
The following statements are simply <strong>not</strong> true in C:</p>

<ul>
<li>""all global variables were implicitly static""</li>
<li>""there is only one place in memory for a static variable""</li>
</ul>

<p>Global variables can be static or non-static (regular). The difference is that regular global variables can be used by other translation units (briefly, C files), while the static variables cannot. </p>

<p>Let me give you an example. Let's say you have two C files, a.c and b.c.
In a.c:</p>

<pre><code>int my_global_var;
static int a_static_var;
</code></pre>

<p>In b.c:</p>

<pre><code>extern int my_global_var;
static int a_static_var;

int main() { /* ... */ }
</code></pre>

<p>You can build a program using both the C files, this way [assuming you're using Linux]:</p>

<pre><code>gcc -c a.c
gcc -c b.c
gcc -o prog a.o b.o
</code></pre>

<p>Now, the variable <code>my_global_var</code> is the <em>same</em> in both the files, but it is <em>instantiated</em> in the <code>a.o</code> translation unit (b.c sees it as an <em>extern</em> variable). While the variable <code>a_static_var</code> is <strong>not</strong> unique. Each translation unit has its own <code>a_static_var</code> variable: they are completely unrelated.</p>

<p>Returning back to your example, static variables can also have <em>function scope</em>: in that case, static variables defined inside different functions are completely <em>unrelated</em>, the same way as global static variables inside separate translation units are unrelated. In your case you can think about the two static <code>a</code> variables AS IF they were called <code>__main_a</code> and <code>__prtFun_b</code>. That's actually pretty close to what happens <em>under the hood</em>, when you compile your program. </p>

<p>Now, to complete the picture there is a rule allowing you to define local (static or not) variables, even when that will <em>hide</em> global variables defined with the same name. Therefore, in <code>prtFun()</code> for example, when you access <code>b</code>, you're accessing your local non-static variable and when you access <code>a</code>, you're accessing your local static <code>a</code> variable. The same is true for <code>main()</code>. In no case your code touches the global <code>a, b, c</code> variables.</p>

<p>I hope I've been helpful.</p>
",0
52063914,52063712,7,"<p>Implicit <code>int</code> and implicit function declarations are <strong>removed</strong> from the C language. They are no more. The program is <strong>ill-formed</strong>. If your compiler accepts it, then you are dealing with a vendor extension ¡ª or a compiler for an outdated version of C.</p>

<p>Before these things were removed, the program had <strong>undefined behaviour</strong>. All editions of the standard require that all declarations of an entity in a program must be compatible, regardless of whether anything in them is implicit or not. Violations of this rule lead to undefined behaviour, with no diagnostic required. </p>
",8
50357147,50356801,2,"<p>The preprocessor simply does a ""search and replace"".</p>

<p><code>#define foreach(a, b, c) for (int a = b; a &lt; c; a++)</code> literally means something like <code>foreach(x, y, z)</code> will be replaced with <code>for (int x = y; x &lt; z; x++)</code>. And so forth. 
It does so for each <code>#define</code>'s literal until there are no more replacements left.</p>

<p>You can simply run your program through the preprocessor and see what remains:</p>

<p><code>cpp myfile.c &gt; myfile_preprocessed.c</code></p>

<pre><code>// #include's omitted

typedef double **mat;

void mat_zero(mat x, int n) {
    for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++)
            x[i][j] = 0;
}

mat mat_new(int n) {
    mat x = malloc(sizeof(double*) * n);
    x[0] = malloc(sizeof(double) * n * n);

    for (int i = 0; i &lt; n; i++)
        x[i] = x[0] + n * i;
    mat_zero(x, n);

    return x;
}

mat mat_copy(void *s, int n) {
    mat x = mat_new(n);
    for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++)
            x[i][j] = ((double(*)[n]) s)[i][j];
    return x;
}

void mat_del(mat x) {
    free(x[0]);
    free(x);
}

void mat_show(mat x, char *fmt, int n) {
    if (!fmt)
        fmt = ""%8.4g"";
    for (int i = 0; i &lt; n; i++) {
        printf(i ? ""      "" : "" [ "");
        for (int j = 0; j &lt; n; j++) {
            printf(fmt, x[i][j]);
            printf(j &lt; n - 1 ? ""  "" : i == n - 1 ? "" ]\n"" : ""\n"");
        }
    }
}


mat mat_mul(mat a, mat b, int n) {
    mat c = c = mat_new(n);
    for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) for (int k = 0; k &lt; n; k++)
                c[i][j] += a[i][k] * b[k][j];
    return c;
}


void mat_pivot(mat a, mat p, int n) {
    for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++)
        {
            p[i][j] = (i == j);
        }
    for (int i = 0; i &lt; n; i++) {
        int max_j = i;
        for (int j = i; j &lt; n; j++)
            if (fabs(a[j][i]) &gt; fabs(a[max_j][i]))
                max_j = j;

        if (max_j != i)
            for (int k = 0; k &lt; n; k++) {
                { typeof(p[i][k]) tmp = p[i][k]; p[i][k] = p[max_j][k]; p[max_j][k] = tmp; };
            }
    }
}


void mat_LU(mat A, mat L, mat U, mat P, int n) {
    mat_zero(L, n);
    mat_zero(U, n);
    mat_pivot(A, P, n);

    mat Aprime = mat_mul(P, A, n);

    for (int i = 0; i &lt; n; i++) {
        L[i][i] = 1;
    }
    for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++)
        {
            double s;
            if (j &lt;= i) {
                { s = 0; for (int k = 0; k &lt; j; k++) s+= L[j][k] * U[k][i]; }
                U[j][i] = Aprime[j][i] - s;
            }
            if (j &gt;= i) {
                { s = 0; for (int k = 0; k &lt; i; k++) s+= L[j][k] * U[k][i]; };
                L[j][i] = (Aprime[j][i] - s) / U[i][i];
            }
        }

    mat_del(Aprime);
}

double A3[][3] = { { 1, 3, 5 }, { 2, 4, 7 }, { 1, 1, 0 } };
double A4[][4] = { { 11, 9, 24, 2 }, { 1, 5, 2, 6 }, { 3, 17, 18, 1 }, { 2, 5,
        7, 1 } };

int main() {
    int n = 3;
    mat A, L, P, U;

    L = mat_new(n);
    P = mat_new(n);
    U = mat_new(n);
    A = mat_copy(A3, n);
    mat_LU(A, L, U, P, n);
    printf(""A"""" ="");mat_show(A, 0, n);
    printf(""L"""" ="");mat_show(L, 0, n);
    printf(""U"""" ="");mat_show(U, 0, n);
    printf(""P"""" ="");mat_show(P, 0, n);
    mat_del(A);
    mat_del(L);
    mat_del(U);
    mat_del(P);

    printf(""\n"");

    n = 4;

    L = mat_new(n);
    P = mat_new(n);
    U = mat_new(n);
    A = mat_copy(A4, n);
    mat_LU(A, L, U, P, n);
    printf(""A"""" ="");mat_show(A, 0, n);
    printf(""L"""" ="");mat_show(L, 0, n);
    printf(""U"""" ="");mat_show(U, 0, n);
    printf(""P"""" ="");mat_show(P, 0, n);
    mat_del(A);
    mat_del(L);
    mat_del(U);
    mat_del(P);

    return 0;
}
</code></pre>

<p>Beware of replacing the bodies of for-loops with function calls though, the resulting code <em>may</em> become slower, that will depend on the quality and the settings of the optimizer.</p>
",1
48210215,48210039,1,"<p>The second argument of an <code>fscanf</code> is the format of what is being scanned. This type of format is present in many similar functions like <code>printf</code>, <code>scanf</code>, and so on.</p>

<p>To know more about this format check the manual pages (man pages) in Linux by typing:</p>

<pre><code>man fscanf
</code></pre>

<p>on the terminal. If in Windows, check their <a href=""https://www.google.de/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjj0NnVl9DYAhWEWSwKHWfeAQYQFggpMAA&amp;url=https%3A%2F%2Fmsdn.microsoft.com%2Fen-us%2Flibrary%2Fcb5kac8b.aspx&amp;usg=AOvVaw0J3fQrVdt7loRwLQaxpdT1"" rel=""nofollow noreferrer"">manual pages</a>.</p>

<p>About the particular <code>%[A-Za-z \' -]</code> would mean to recognize anything from A to Z, a to z, blank space, ', or -.</p>
",0
59232751,59232737,0,"<p>To terminate your program, change</p>

<pre><code>printf(""success\n"");
            break;
</code></pre>

<p>To</p>

<pre><code>printf(""success\n"");
            return 0;
</code></pre>

<p>The <code>return 0</code> will stop the program.</p>
",0
59233249,59232737,0,"<p>Exit function is used to terminate the execution of program in C Language</p>

<p>Syntax:</p>

<blockquote>
  <p>exit(0);</p>
</blockquote>

<p>Find the link <a href=""https://www.tutorialspoint.com/c_standard_library/c_function_exit.htm"" rel=""nofollow noreferrer"">here</a></p>
",0
49141163,49141061,3,"<p>You wrote:</p>

<pre><code>#define SIDE_1_LABEL 'A'
#define SIDE_2_LABEL 'B'

float getUserValue(char SIDE_1_LABEL, char SIDE_2_LABEL);
</code></pre>

<p>That is exactly the same as writing:</p>

<pre><code>float getUserValue(char 'A', char 'B');
</code></pre>

<p>which is obviously invalid because 'A' and 'B' are not variable names.</p>

<p>If you weren't aware - macro expansion works as if you literally copy-pasted the macro definition everywhere the macro appears.</p>
",5
51109897,51109863,-1,"<p>As in <a href=""https://en.cppreference.com/w/cpp/io/c/fprintf"" rel=""nofollow noreferrer"">the documentation</a> you can always have the width itself a specifier:</p>

<pre><code>printf(""%*s"", j, star);
</code></pre>

<p>Where that's taking <code>j</code> as the width argument, <code>star</code> as the value to be formatted.</p>
",2
51109895,51109863,0,"<p>If you read e.g. <a href=""http://en.cppreference.com/w/c/io/fprintf"" rel=""nofollow noreferrer"">this <code>printf</code> (and family) reference</a> you will see that it is (kind of funny thinking about what you want to print)... The <em>star</em>.</p>

<p>That means an <code>int</code> argument will be read for the field width.</p>

<p>As in</p>

<pre><code>printf(""%*s\n"", j, star);
</code></pre>
",0
53902000,53901967,4,"<p>You expect <code>(x == 2) ? f : i</code> to have a type based on the value of <code>x</code>. But that is not how the C type system operates. The conditional operator is an expression, and all* expressions in C have a fixed type at compile time. It is this type that <code>sizeof</code> operates on. The value of the expression will depend on the value of <code>x</code>, but the type depends on <code>f</code> and <code>i</code> alone.</p>

<p>In this case, the type is the determined by the usual arithmetic conversions, which nominate <code>float</code> as the type of the result, same as if you had written <code>f + i</code>, where the result would unsurprisingly be a <code>float</code> too.</p>

<hr>

<p><sub>
(*) - VLA's produce exemptions to this rule, but your question is not about one, so it's irrelevant.
</sub></p>
",0
53901998,53901967,0,"<p>You are asking the compiler to compute the size of <code>(x == 2) ? f : i</code>  and that expression is a <code>float</code>.</p>

<p>Remember that <code>sizeof</code> is a <em>compile-time</em> operator, and that the <a href=""https://en.wikipedia.org/wiki/%3F:"" rel=""nofollow noreferrer""><code>?:</code> ternary conditional operator</a> will have as type something which is convertible from both the ""then"" and the ""else"" case.</p>

<p>For details, refer to some <a href=""https://en.cppreference.com/w/c"" rel=""nofollow noreferrer"">C reference</a> and to the C11 standard <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">n1570</a></p>
",0
48589900,48587202,0,"<p><strong>Syntax</strong> (or grammar) describes the <em>structure</em> of the program - what functions, statements, and expressions are supposed to look like.  For example, the syntax of a <code>for</code> loop<sup>1</sup> is</p>

<pre><code><strong>for ( </strong><em>expression<sub>opt</sub></em> <strong>;</strong> <em>expression<sub>opt</sub></em> <strong>;</strong> <em>expression<sub>opt</sub></em> <strong>)</strong> <em>statement</em>
</code></pre>

<p>Thus, a <em>syntax error</em> is an error in the structure of the program - you're missing a semicolon, or curly braces or parentheses are mismatched, you've misspelled a keyword, something like that.  A compiler is <em>required</em> to issue a diagnostic<sup>2</sup> for syntax errors.  </p>

<p>However, syntax alone cannot specify rules like ""a variable must be declared before use"", or ""the target of an assignment must be a modifiable lvalue"", or ""the source and target of an assignment must be compatible types"", etc.  <strong>Semantic rules</strong> (the C standard calls them <em>constraints</em>) describe what program constructs are <em>meaningful</em> - just because a statement is syntactically valid doesn't mean it's semantically meaningful.  For example, here's part of the syntax for a declaration:</p>

<pre><code><em>declaration</em>:
    <em>declaration-specifiers init-declarator-list<sub>opt</sub></em> <strong>;</strong>
    <em>static_assert-declaration</em>

<em>declaration-specifiers</em>:
    <em>storage-class-specifier declaration-specifiers<sub>opt</sub>
    type-specifier declaration-specifiers<sub>opt</sub>
    type-qualifier declaration-specifiers<sub>opt</sub>
    function-specifier declaration-specifiers<sub>opt</sub>
    alignment-specifier declaration-specifiers<sub>opt</sub></em>
</code></pre>

<p>Now, based on syntax alone, we could come up with any arbitrary combination of type specifiers, type qualifiers, etc.  The <em>syntax</em> allows something like</p>

<pre><code>int char long short unsigned double float foo;
</code></pre>

<p>but there are additional <em>constraints</em> that specify which combinations of type specifiers are meaningful.  <code>long long</code> and <code>long double</code> and <code>unsigned short int</code> are meaningful.  <code>double char</code> and <code>float long int</code> are not.  </p>

<p>Thus, a <em>semantic error</em> (or a <em>constraint violation</em>) is an error in the <em>meaning</em> of the program - you're missing a declaration somewhere, or you're trying to assign to something that should not be written to, stuff like that.  Like with syntax errors, the compiler is <em>required</em> to issue a diagnostic for constraint violations.  </p>

<p>So, is <code>a + b = c;</code> a syntax error or a semantic error?  Here's the syntax for assignment:</p>

<pre><code><em>assignment-expression</em>:
    <em>conditional-expression</em>
    <em>unary-expression assignment-operator assignment-expression</em>

<em>assignment-operator</em>: one of
    <strong>= *= /= %= += -= >= &= ^= |=</strong>
</code></pre>

<p>Does <code>a + b</code> reduce to a <em>unary-expression</em>? Based on my reading of the syntax, it does:</p>

<pre><code><em>additive-expression</em>:
    <em>multiplicative-expression</em>
    <em>additive-expression</em> <strong>+</strong> <em>multiplicative-expression</em>
    <em>additive-expression</em> <strong>-</strong> <em>multiplicative-expression</em>

<em>multiplicative-expression</em>:
    <em>cast-expression</em>
    <em>multiplicative-expression</em> <strong>*</strong> <em>cast-expression</em>
    <em>multiplicative-expression</em> <strong>/</strong> <em>cast-expression</em>
    <em>multiplicative-expression</em> <strong>%</strong> <em>cast-expression</em>

<em>cast-expression</em>:
    <em>unary-expression</em>
    <strong>(</strong> <em>type-name</em> <strong>)</strong> <em>cast-expression</em>
</code></pre>

<p>Here's how I see it reducing:</p>

<pre><code>a + b =>
    <em>additive-expression</em> <strong>+</strong> <em>multiplicative-expression</em> =>
    <em>additive-expression</em> =>
    <em>multiplicative-expression</em> =>
    <em>cast-expression</em> =>
    <em>unary-expression</em>
</code></pre>

<p>So, at first blush, this doesn't appear to be a syntax error.  If it's not, it's <em>definitely</em> a semantic error (a.k.a. constraint violation), and that's how gcc reports it:</p>

<pre><code>error: invalid lvalue in assignment
</code></pre>

<p><em>lvalues</em> only come in to play at the semantic level, not the syntax level.  The result of <code>a + b</code> is not an lvalue - it doesn't correspond to a location that you can write a new value to, thus it cannot be the target of an assignment.  </p>

<p>A <strong>logic error</strong> (a.k.a. bug) is an error in the <em>implementation</em> of the program.  For example, your function to calculate the area of a rectangle is implemented incorrectly.  <em>Sometimes</em>, logic errors trigger a constraint violation, but not always.  This is why you test.</p>

<p><hr>
<sup></p>

<ol>
<li><a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C 2011 Online Draft</a>
<li>The C language standard does not distinguish between ""warnings"" and ""errors""; it only mandates that a diagnostic of some sort be issued for syntax errors and constraint violations.
</ol>

<p></sup>
</p>
",0
51528286,51528204,4,"<p>Escape sequences aren't processed in data that's read from a stream, so the user should type <code>c:\file.txt</code>, not <code>c:\\file.txt</code>.</p>
",0
49130356,49128897,1,"<p>The bug in your code is here:</p>

<pre><code>if (ptd=NULL)
</code></pre>

<p>Instead of testing for the success of the preceding call to <code>malloc</code> you are instead setting <code>ptd</code> to <code>NULL</code>, which then later results in a crash when you try to dereference the pointer. Either your book has a mistake or you made a mistake when copying out the code - this line should of course be:</p>

<pre><code>if (ptd == NULL)
</code></pre>

<p>NOTE: if you had enabled compiler warnings (e.g. <code>gcc -Wall ...</code>) then the compiler would have pointed this out to you and saved you a lot of grief. ALWAYS enable compiler warnings, and ALWAYS pay attention to them.</p>
",5
48495249,48495218,4,"<p>In C language strings are just arrays of characters. One can say that the core language itself is not even aware of the existence of strings - it is a library-level concept. (With the exception of string literals, perhaps, which are core language feature and which are strings.). In all respects strings are just arrays.</p>

<p>In C language naked arrays are generally not copyable, neither in assignment contexts nor in initialization contexts. Instead, arrays in C instantly decay to pointers with the exception of a few special contexts:</p>

<ol>
<li>Unary <code>&amp;</code> operator</li>
<li><code>sizeof</code> operator</li>
<li><code>_Alignof</code> operator</li>
<li>Initialization of a <code>char[]</code> array with a string literal (in which case array copying actually takes place)</li>
</ol>

<p>Your example with <em>initialization</em> belongs to the above list, which is why it works. But your example with <em>assignment</em> is not an exception. In the latter case the general rule for array is applied: you can't assign arrays in C. In you want to copy a naked array, you have to use user-level or library-level code.</p>
",2
54893184,54892951,3,"<p>In your <code>printf</code> call:</p>

<pre><code>printf(""%f"", result);
</code></pre>

<p>The <code>%f</code> format specifier expects a <code>double</code> (or a <code>float</code> which gets automatically converted), but you're passing it a <strong>pointer</strong> to a float.  You need to dereference the pointer to get the <code>float</code> value:</p>

<pre><code>printf(""%f"", *result);
</code></pre>

<p><strong>However</strong>, you have another problem.</p>

<p>Inside of <code>Calculate</code> you define <code>result</code>, which is what you return from the function, as a pointer to a <code>float</code>, but you never set it to point anywhere.  So anytime you try do dereference this pointer you're reading an uninitialized value and using it as a valid pointer.  Doing so invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>There's no reason to use a pointer to a <code>float</code> in your code, so change both <code>result</code> in <code>main</code> and <code>result</code> in <code>Calculate</code> from <code>float *</code> to <code>float</code>, and change <code>Calculate</code> to return a <code>float</code>.</p>

<p>Also, the <code>strncpy</code> function doesn't always null terminate the destination string, and <code>malloc</code> returns uninitialized memory, so <code>atoi</code> will can read past the end of allocated memory when it reads the strings.  You can fix this by using <code>calloc</code> instead of <code>malloc</code> which returns memory initialized to all 0's.  Also, be sure to <code>free</code> those buffers when you're done with them.</p>

<pre><code>float Calculate(char* buffer)
{
    int number1, number2;

    char *firstPart = calloc(strlen(buffer), 1);
    char *secondPart = calloc(strlen(buffer), 1);

    strncpy(firstPart, buffer+1, 4);
    strncpy(secondPart, buffer+5, 8);

    number1 = atoi(firstPart);
    number2 = atoi(secondPart);

    free(firstPart);
    free(secondPart);

    float result;

    if( buffer[0] == '0')
    {
        result = (float)number1 + (float)number2;
    }
    else if(buffer[0] == '1')
    {
        result = (float)number1 - (float)number2;
    }
    else if(buffer[0] == '2')
    {
        result = (float)number1 * (float)number2;
    }
    else if(buffer[0] == '3')
    {
        result = (float)number1 / (float)number2;
    }

    return result;
}

int main()
{
    char buffer[20];
    printf(""Insert code word: "");
    scanf(""%s"", buffer);

    float result = Calculate(buffer);
    printf(""%f"", result);

    return 1;
}
</code></pre>
",7
48584413,48584300,1,"<p>Look at this line:</p>

<pre><code>} while (myString[size - 1] != 13 || myString[size - 1] != '\n');
</code></pre>

<p>The condition is ""while A is true or B is true"" where <strong>either</strong> A or B is always going to be true since they complement each other! Because that condition is ""I have an X, if X is not equal to two things simultaneously...""</p>

<p>Solution:</p>

<pre><code>} while (myString[size - 1] != 13 &amp;&amp; myString[size - 1] != '\n');
</code></pre>
",2
53587347,53586845,1,"<p>You seem to be confusing strings and numbers and long/int.  Strings are sequences of characters in memory.  Numbers are an abstract concept that can be represented in many ways.  <code>long</code> and <code>int</code> are numeric data types in C that represent numbers.</p>

<p>So the function <code>strtol</code> converts a number represented as a string of digits in some base (""hex"" or ""decimal"" or ""octal"" are all possible) into the <code>long</code> representation of that number.  It does not convert hex to decimal (or do any kind of ""base"" conversion), though it can be used as half of a function that does.</p>

<p>When you use <code>printf(""%ld""</code> it converts a number in the <code>long</code> representation into a decimal string representation and prints that on stdout (usually your terminal window).  This is necessary to display anything related to a number, as terminals cannot display numbers, only characters.</p>

<p>Now all the above distinctions between numbers and representations of numbers may seem obscure, but it is very important -- crucially important in understanding how to write and understand programs written in C. </p>
",0
53587347,53586845,1,"<p>You seem to be confusing strings and numbers and long/int.  Strings are sequences of characters in memory.  Numbers are an abstract concept that can be represented in many ways.  <code>long</code> and <code>int</code> are numeric data types in C that represent numbers.</p>

<p>So the function <code>strtol</code> converts a number represented as a string of digits in some base (""hex"" or ""decimal"" or ""octal"" are all possible) into the <code>long</code> representation of that number.  It does not convert hex to decimal (or do any kind of ""base"" conversion), though it can be used as half of a function that does.</p>

<p>When you use <code>printf(""%ld""</code> it converts a number in the <code>long</code> representation into a decimal string representation and prints that on stdout (usually your terminal window).  This is necessary to display anything related to a number, as terminals cannot display numbers, only characters.</p>

<p>Now all the above distinctions between numbers and representations of numbers may seem obscure, but it is very important -- crucially important in understanding how to write and understand programs written in C. </p>
",0
48876451,48876393,2,"<p>You have some errors in your code:</p>

<ol>
<li><p><strong>Do not use <code>gets</code></strong>. This function is dangerous because it doesn't take the
size of the buffer into account. Use <code>fgets</code> instead.</p></li>
<li><p>Your <code>append</code> function does not write the <code>'\0'</code>-terminating byte. It should
be</p>

<pre><code>char* append (char s1[], char s2[]) {
    int s1len = strlen (s1);
    int s2len = strlen (s2);
    int k;
    for (k=0; k&lt;s2len; k++) {
        s1[k+s1len] = s2[k];
    }
    s1[k+s1len] = 0; // writing the 0-terminating byte
    return s1;
}
</code></pre></li>
<li><p><code>str1</code> may be to short for holding both strings. If <code>str2</code> contains <code>""Hello""</code>
and <code>str2</code> contains <code>""World!""</code>, you are going to overflow the buffer. Make the
buffer larger.</p></li>
</ol>

<p>If you writing your own <code>strcat</code>, I would pass the size of the destination
buffer as well, so that you don't overflow the buffers:</p>

<pre><code>char *mystrcat(char *t1, const char *t2, size_t maxsize)
{
    if(t1 == NULL || t2 == NULL)
        return NULL;

    size_t s1 = strlen(t1);
    size_t s2 = strlen(t2);

    size_t i;
    for(i = 0; i &lt; s2 &amp;&amp; (s1 + i) &lt; maxsize - 1 ; ++i)
        t1[i + s1] = t2[i];

    t1[i + s1] = 0; // terminating the

    return t1;
}


int main(void)
{
    char str1[30] = ""Hello "";
    char str2[30] = ""World!"";

    printf(""mystrcat(\""%s\"", \""%s\"") = %s\n"", str1, str2,
            mystrcat(str1, str2, sizeof str1));

    char str3[100] = ""This is a long sentence"";

    printf(""mystrcat(\""%s\"", \""%s\"") = %s\n"", str1, str3,
            mystrcat(str1, str3, sizeof str1));

    char line[100];
    printf(""Enter some text: "");
    fflush(stdout);

    fgets(line, sizeof line, stdin);
    line[strcspn(line, ""\n"")] = 0; // removing possible newline

    strcpy(str3, ""User input was: "");

    printf(""mystrcat: %s\n"", mystrcat(str3, line, sizeof str3));

    return 0;
}
</code></pre>

<p>That would return</p>

<pre class=""lang-none prettyprint-override""><code>mystrcat(""Hello World!"", ""World!"") = Hello World!
mystrcat(""Hello World!This is a long se"", ""This is a long sentence"") = Hello World!This is a long se
Enter some text: ABC DEF user input is great
mystrcat: User input was: ABC DEF user input is great
</code></pre>
",0
53450536,53450390,2,"<p>Because (<a href=""http://port70.net/~nsz/c/c99/n1256.html#7.19.6.2p10"" rel=""nofollow noreferrer"">C99 7.19.6.2p10</a>, the emphasis is mine) <code>""i""</code> and <code>""%d""</code> cause a ""matching failure"".</p>

<blockquote>
  <p>[...] the input item [...] is converted to a type appropriate to the conversion specifier. <strong>If the input item is not a matching sequence, the execution of the directive fails: this condition is a matching failure</strong>. [...]</p>
</blockquote>

<p>You should always test the return value of most functions with prototype in <code>&lt;stdio.h&gt;</code></p>

<pre><code>if (scanf(""%%"", ...) != EXPECTED) /* error */;
</code></pre>
",2
53450443,53450390,3,"<p>Format <code>%d</code> in <code>scanf</code> accepts (consumes) character sequences that represent integers in decimal notation. If the characters you input do not match the required format, <code>scanf</code> fails and returns <em>without modifying the recipient variable</em>. This is what happened in your case. <code>i</code> is not valid input for format <code>%d</code>. <code>scanf</code> failed immediately and <code>choice</code> kept its old value. </p>
",4
48256326,48256304,1,"<p>You need to reinitialize the variable <code>i</code> more often.<br>
Instead of having a for loop that looks like <code>for (i; i&lt;=N; i++)</code>, initialize <code>i</code> and do <code>for (i=0; i&lt;=N; i++)</code></p>
",0
48270616,48270513,1,"<p>This code:</p>

<pre><code>char *str = ""Test"";
</code></pre>

<p>means:</p>

<ul>
<li><p>Create an array of five characters containing T, e, s, t, and a null character. Storage for this array is ¡°static¡±; it is allocated for the entire lifetime of your program.</p></li>
<li><p>Create a pointer to <code>char</code> named <code>str</code> and set its initial value to the address of the first character in that array created above.</p></li>
</ul>

<p>In this case, the storage for <code>""Test""</code> is automatically allocated for you as part of compiling, loading, and executing your program.</p>

<p>In contrast, in the <code>strdup</code> code, the function is passed a pointer to a string. (A string is an array of characters that has a null character to mark the end of the string.) In this case, the function does not know in advance how long the string is. So it does not know how much memory it needs until the function is called and it uses <code>strlen</code> to measure the length of the string.</p>

<p>When you do not know in advance how much memory is needed, you generally need to use <code>malloc</code> or one of the related memory-allocation routines to allocate storage. (Another method is to use variable-length arrays. Not all C implementations support variable-length arrays, and they should be used only for small, or perhaps moderate size, arrays that are needed only within one function.)</p>
",0
48373956,48373917,0,"<p>You get this error because of:</p>

<pre><code>if(MilitaryTime &lt;= 1159)
    StandardTime = MilitaryTime/100;
    printf(""The regular time is: %2f AM\n"", StandardTime);
else
...
</code></pre>

<p>Note that indentions in C have no meaning (like for example in Python).</p>

<p>You code is is equivalent to:</p>

<pre><code>if(MilitaryTime &lt;= 1159)
{
    StandardTime = MilitaryTime/100;
}
    printf(""The regular time is: %2f AM\n"", StandardTime);
else
...
</code></pre>

<p>And as you can see, the <code>printf</code> comes after the <code>if</code> block, for the compiler
that is the end of the whole <code>if</code> block, then it sees an <code>else</code> without a
previous <code>if</code>, which is syntax error.</p>

<p>The correct code would be:</p>

<pre><code>if(MilitaryTime &lt;= 1159)
{
    StandardTime = MilitaryTime/100;
    printf(""The regular time is: %2f AM\n"", StandardTime);
} else {
    StandardTime = (MilitaryTime - 1200)/100;
    printf(""The regular time is: %2f PM\n"", StandardTime);
}
</code></pre>

<p><strong>edit</strong></p>

<p>Note that in C, the correct syntax for <code>if</code> and <code>while</code> block is</p>

<pre><code>// very simplified version of the grammer

if(condition)
    statement-block;

while(condition)
    statement-block;

statement-block can be one of this:

 - ;

 - { statement1; statement2; ... }

 - statement
</code></pre>

<p>Generally speaking after an <code>if</code> and <code>while</code> you can have one statement only. If
you need more, then you have to wrap them in curly braces
<code>{ statement1; statement2; .. }</code></p>

<p>There are cases where you only see a colon <code>;</code>:</p>

<pre><code>// these are the same
if(condition);

if(condition)
{
}
</code></pre>

<p>Note that the identation of code doesn't matter to C. The semicolon <code>;</code> is what
tells the statements appart. This two programms are equivalent.</p>

<pre><code>int main(void)
{
    printf(""Hello, "");
    printf(""world!\n"");
    return 0;
}

int main(void){printf(""Hello, "");printf(""world!\n"");return 0;}
</code></pre>
",0
48433942,48433427,0,"<p>you need an array of students</p>

<pre><code>struct student{
    int LogID;
    char firstname[20];
    char lastname[20];
    int mark;
    char *subjects[100];
};



struct student students[100];
</code></pre>

<p>you now have space for 100 students. They are students[0], students[1],...students[99]</p>

<p>Now you can do</p>

<pre><code>int studno = 0;
While(something)
{
  printf(""\Enter Student Details:\n\nStudent ID: "");
        scanf(""%d"",&amp;(students[studno].LogID));

....
  studno++;
}
</code></pre>
",0
49472273,49472247,0,"<p>In lines like:</p>

<pre><code>cA = ((b^2)+(c^2)-(a^2))/(2*b*c);
</code></pre>

<p>You do the calculations on <code>int</code>s and save the result to <code>double</code>. This means you could end up with an intermediate result like <code>8 / 10</code> which is just <code>0</code> rather than a fraction.</p>

<p>But the bigger issue is that <code>^</code> is an <code>XOR</code> operation rather than what you think. Either use <code>b*b</code>, or <code>pow(b, 2)</code>.</p>
",3
51318300,51318192,5,"<p>Your copying loop doesn't attempt to detect EOF.  It should read:</p>

<pre><code>int ch;
while ((ch = fgetc(fp)) != EOF)
    fputc(ch, fp);
</code></pre>

<p>Note that the value is read into an <code>int</code>, not a <code>char</code>.  The <code>getchar()</code>, <code>getc()</code> and <code>fgetc()</code> functions return an <code>int</code>, which either contains a positive number representing the character (byte) treated as an <code>unsigned char</code>, or it returns the negative value <code>EOF</code> (which is customarily, but not necessarily, <code>-1</code>).  You can't store all those values in a <code>char</code>; you must use an <code>int</code>.</p>

<p>It's also a little peculiar to ask your user to enter a file name and then ignore what they enter.  In most ways, it is just as well you do; you need more than a single <code>char filename1</code> or <code>char filename2</code> to hold a file name, and you need to use <code>%s</code> rather than <code>%c</code> to read the names.  Fortunately, you use fixed string literals for the file names in the <code>fopen()</code> calls.</p>

<p>The reason that the second input doesn't seem to wait is that your first call to <code>scanf()</code> reads a single character, so even if you type <code>a</code> as the file name, there is also a newline in the input.  The second <code>scanf()</code> reads the newline.  There are only 3 formats that don't skip leading white space (such as newlines).  They are <code>%c</code>, <code>%[¡­]</code> (scan sets) and <code>%n</code>.</p>
",1
48491517,48491348,0,"<p>No no, declare <code>ch</code> as <code>char[]</code>:</p>

<pre><code>char ch[MAXLENGTH];
</code></pre>

<p>While possible, it's definitely possible to store strings in an <code>int</code> array,
you shouldn't do that at all.</p>

<p>I also would write your <code>get_input</code> like this:</p>

<pre><code>int get_input(char *ch, size_t lim)
{
    if(!fgets(ch, lim, stdin))
        return 0;

    // removing possible \n
    ch[strcspn(ch, ""\n"")] = 0;
    return 1;
}
</code></pre>

<p>The logic behind the algorithm seems to be OK, however your <code>while</code> and <code>for</code>
conditions are a little bit strange and it caused problems when stepping through
the debugger.</p>

<pre><code>while(ch[arrayindex] != EOF &amp;&amp; arrayindex &lt; lim-1)
</code></pre>

<p>Don't check for <code>EOF</code>, you shouldn't write an <code>EOF</code> in
a string, because <code>EOF</code> is an <code>signed int</code> and doesn't fit in a <code>char</code>. If you
read a line with <code>fgets</code>, there is never going to be a <code>EOF</code> in the string. Also
because you did <code>while((i = getchar()) !=  EOF &amp;&amp; z &lt; lim-1 &amp;&amp; i != '\n')</code> in
the read function, you are not going to have an <code>EOF</code> in the string. You should
check for <code>'\0'</code> which is the only correct way to terminate a string.</p>

<p>The correct condition would be:</p>

<pre><code>while(ch[arrayindex] != '\0' &amp;&amp; arrayindex &lt; lim-1)
</code></pre>

<p>If you are checking for the bounds, then it would be better to have that first
and then check for the end of string.</p>

<pre><code>while(arrayindex &lt; lim-1 &amp;&amp; ch[arrayindex])
</code></pre>

<p>Here I omitted the <code>!= '\0'</code> because <code>'\0' == 0</code>.</p>

<p>After the loop you should do</p>

<pre><code>ch_copy[copy_counter] = '\0';
</code></pre>

<p>Use <code>copy_counter</code>, not <code>arrayindex</code>, because <code>arrayindex</code> is the index for the
original, where multiple blanks are stored. <code>copy_counter</code> is the index for the
copy.</p>

<p>But if prior of the <code>while</code> loop you did:</p>

<pre><code>memset(ch_copy, 0, lim);
</code></pre>

<p>then the whole buffer would be initalized with 0 and you won't need to worry
about the 0 terminating because the copy will never be larger than the original.</p>

<p>Lastly, the condition in the <code>for</code> loop should be corrected with the same logic
as for the <code>while</code> loop. Here you don't need to check for the boundaries,
because you know that the copy is never be larger than the original:</p>

<pre><code>for(arrayindex = 0; ch_copy[arrayindex]; arrayindex++){
    ch[arrayindex] = ch_copy[arrayindex];
}

ch[arrayindex] = 0;
</code></pre>

<p>Or you could just use <code>strcpy</code>:</p>

<pre><code>strcpy(ch, ch_copy);
</code></pre>

<p>So the function should look like this:</p>

<pre><code>void replace_blanks(char ch[], int lim)
{
  char ch_copy[lim];
  int i, arrayindex, copy_counter;

  memset(ch_copy, 0, lim);

  copy_counter = 0;
  arrayindex = 0;
  i = arrayindex;

  while(arrayindex &lt; lim -1  &amp;&amp; ch[arrayindex]){
    if(ch[arrayindex] != ' '){
      ch_copy[copy_counter] = ch[arrayindex];
      i = arrayindex;
      arrayindex++;
      copy_counter++;
    }
    else if(ch[arrayindex] == ' ' &amp;&amp; ch[i] != ' '){
      ch_copy[copy_counter] = ch[arrayindex];
      i = arrayindex;
      arrayindex++;
      copy_counter++;
    } else {
      i = arrayindex;
      arrayindex++;
    }   
 }

  strcpy(ch, ch_copy);
}
</code></pre>
",8
50278369,50277762,3,"<p>The C Standard Library I/O functions are designed around using streams of bytes that are sent or received. Those streams of bytes are sent to some device such as a terminal or a printer or a file or a network device.  The Standard Library I/O is really oriented for text terminals, text printers, and files in which a stream of bytes or text characters is written to a device handle or read from a device handle.</p>

<p>About the only kind of device specific positioning of the Standard Library is for files using functions such as <code>ftell()</code> and <code>fseek()</code> as well as <code>rewind()</code> and <code>fgetpos()</code> and <code>fsetpos()</code> (see <a href=""https://stackoverflow.com/questions/3348637/fgetpos-fsetpos-and-ftell-fseek"">what is difference between fgetpos/fsetpos and ftell/fseek</a> an explanation as to the differences).</p>

<p>The C Standard Library I/O functions do not have any terminal or printer device specific functionality such as positioning a cursor, setting text colors or text font, positioning windows, changing windows, or any of the other functionality common to Graphical User Interfaces or graphical printers (laser or inkjet).</p>

<p>A common work around is to use special characters, <a href=""https://en.wikipedia.org/wiki/Escape_sequence"" rel=""nofollow noreferrer"">escape codes</a>, to indicate that the text following is a command to the device itself and to then specify a command such as setting a cursor position or setting a text color. There are a number of defacto standards for these command sequences which depend on the target device.</p>

<p>In the old days with 80 column, 25 line terminals, most terminals supported a defacto standard with some elements of cursor positioning modeled on what was provided by the <a href=""https://en.wikipedia.org/wiki/VT100"" rel=""nofollow noreferrer"">VT-100 video terminal from Digital Equipment Corporation</a>.</p>

<p>In order to access that cursor positioning functionality, the first C compatible libraries were developed so that a programmer could specify a cursor position and the library function would create the proper escape code sequence for the position and send it to the terminal.</p>

<p><a href=""https://en.wikipedia.org/wiki/Ncurses"" rel=""nofollow noreferrer"">ncurses</a> is a modern version of those early libraries and is probably the most commonly used for text terminal emulation when a full blown GUI is not needed.</p>

<p>You might find this <a href=""https://en.wikipedia.org/wiki/List_of_platform-independent_GUI_libraries"" rel=""nofollow noreferrer"">List of platform-independent GUI libraries</a> helpful though a GUI library may be overkill for what you actually need.</p>

<p>See also the various answers to <a href=""https://stackoverflow.com/questions/2018850/cross-platform-c-library-for-gui-apps"">Cross Platform C library for GUI Apps?</a></p>
",0
48492655,48492597,0,"<p>If you have collected the name, you can proceed as follows:</p>

<pre><code>if (name[0] &gt;= 'a' &amp;&amp; name[0] &lt;= 'z')
{
    name[0] -= 0x20;
}
printf(""Hello %s. Could you tell us a bit about yourself?"", name);
</code></pre>

<p>The assumptions are:</p>

<p>1 - you have the name<br>
2 - it begins in first character of the character array<br>
3 - the name is in ASCII / English 7-bit characters</p>

<p>Aside from that, see the other answer by Pablo - you've made several errors.</p>
",7
50688676,50688580,2,"<p>You need to understand the subtle difference between these 2 lines</p>

<pre><code>char temp1[4] = ""abc"";
char *temp2 = ""123"";
</code></pre>

<p>The first one creates a 4 character variable and copies ""abc\0"" to it.<br>
You can overwrite that if you want to. You can do e.g. <code>temp1[0] = 'x'</code> if you want.</p>

<p>The second one creates a pointer that points to the constant literal ""123\0"".<br>
You cannot overwrite that, its typically in memory that is declared read only to the OS.</p>
",1
59418730,59418690,3,"<p>This is trying to loop on reading characters until a newline is read, and it's just doing it in an odd way: normally I'd expect to see just one <code>getchar()</code> as part of the loop itself.</p>

<p>This would be a more customary way to write the same thing:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{   
    int ch;            // note: not char!
    int len = 0;

    printf(""Enter a message: "");

    while ( (ch = getchar()) != EOF  &amp;&amp;  ch != '\n')
       len++;

    printf(""Your message was %d characters long\n"", len);

    return 0;
}
</code></pre>

<p>We see a few changes here.</p>

<p>First, we see the <code>ch = getchar()</code> assignment <em>in the loop condition itself</em>: fetch a character, and as long as we're not done (however defined), keep going and keep counting.</p>

<p>But we also have to check for <code>EOF</code> - end of file - which signifies the end of input, so that test is done here as well. If you fail this test, the code will loop and loop and loop and loop because it will <em>never</em> get EOF. Always check for end of file!</p>

<p><strong>IMPORTANT</strong>: You really must use an <code>int</code> variable to receive the return from <code>getchar()</code>, not a <code>char</code>. Surprise! The reason is that <code>EOF</code> is typically -1 (<a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21.1p3"" rel=""nofollow noreferrer"">EOF must be negative</a>), and <a href=""http://port70.net/~nsz/c/c11/n1570.html#7.21.7.1p2"" rel=""nofollow noreferrer""><code>getchar()</code></a> returns either EOF or the next 'character as an <code>unsigned char</code> converted to an <code>int</code>' (normally, a value 0..255).  That is more values than can be stored in a plain <code>char</code>, so it is crucial to use an <code>int</code> instead of a <code>char</code> variable so you can be sure to detect EOF properly.</p>

<p>Also a trivial simplification of <code>len++</code> for <code>len = len + 1</code>.</p>

<p>The original loop is doing more or less the same thing, but without combining the get + check parts into one.</p>
",1
48995409,48995369,1,"<p>You should define your <code>struct</code> before you <em>ever</em> use it (say, in a function prototype).</p>
",0
52601361,52601342,1,"<p>You are missing <code>break</code>s for a start. (so if you pick option 1 it will also perform options 2 3 4 and 5)</p>

<p><code>conversionValue</code> is a <code>double</code> but you scan it in with <code>%d</code>. This means you aren't converting the value you think you are. Basic debug (printing your input values) would highlight that.</p>

<p>All your prints are trying to print a double with <code>%d</code> (should be <code>%lf</code> for doubles)</p>

<p>Combining output with calculations is bad. i.e. Your <code>convert</code> routines should return the converted value and the print should be outside the convert function.</p>
",2
56045756,56045436,4,"<p>You have two serious problems.</p>

<p>First, you're not initializing the contents of the <code>result</code> array to an empty string. After you call <code>malloc()</code>, add:</p>

<pre><code>result[0] = '\0';
</code></pre>

<p><code>malloc()</code> doesn't initialize the memory it allocates. There's another function <code>calloc()</code> that takes slightly different arguments and initializes the memory to zeroes. But you only need the first character to be zero, so there's no need for that.</p>

<p>Second, the <code>for</code> loop is not processing the last character of <code>text</code>. It should be:</p>

<pre><code>for (i = 0; i &lt; size; i++)
</code></pre>

<p>Similarly, the test for whether to add a space should be <code>if (i != size-1)</code>. Did you think <code>strlen()</code> counts the null character at the end?</p>

<p>The amount of space you specify in <code>malloc()</code> is not correct, but in practice it won't cause a problem. <code>sizeof(int)</code> has nothing to do with the number of characters it takes to show the value of an integer. Since you're just printing the alphabetical position, it will be at most <code>26</code>, so you need 3 characters for every input character. Therefore, it should be:</p>

<pre><code>char *result = malloc(3 * size + 1);
</code></pre>

<p>Your allocation works because <code>sizeof(int)</code> is generally at least 4, so you're allocating more than enough space.</p>

<p>There are other minor problems that don't affect the correctness of the result:</p>

<p>You don't need the <code>if</code> statement that treats <code>'a'</code> specially, the code you have in <code>else</code> will work for all letters.</p>

<p>You don't need <code>strcat(result, ""\0"")</code> at the end. <code>result</code> has to already be null-terminated in order for you to use it as an argument to <code>strcat()</code>, so there's no point in using <code>strcat()</code> to add a null terminator.</p>
",6
48742560,48742428,2,"<p>There are two problem in the above code snippet.</p>

<ol>
<li>Syntax regarding function arguments is wrong. You cannot pass argument type inside square braces.</li>
<li>There must be constant column size to be passed with the array in the argument list.</li>
</ol>

<p>You can do something like this.</p>

<pre><code>#define R 10
#define C 100
void transpose(int arr[][C]); // prototype declaration line 2
void transpose(int arr[][C]) { // line 3
    int i, j;
    int matB[C][R];
    for (i = 0; i&lt;C; i++) {
        for (j = 0; j&lt;R; j++) {
            matB[i][j] = arr[j][i];
        }
    }
    for (i = 0; i&lt;R; i++) {
        for (j = 0; j&lt;C; j++) {
            arr[i][j] = matB[i][j];
        }
    }
}
</code></pre>
",2
51936016,51935996,2,"<p>Order of operations:</p>

<p><code>30 / 30 * 30</code> is <code>1 * 30</code>. <code>30 / 900</code> is <code>0</code>.</p>

<p>You need to parenthesize in your macro to get the right behaviour:</p>

<pre><code>#define N2 (L * L)
</code></pre>
",5
51936043,51935996,0,"<pre><code>#define N2 (L * L)
</code></pre>

<p>or</p>

<pre><code>printf(""k = %d\n"", id/(N2));
</code></pre>

<p>would do the trick.</p>
",2
48844985,48843492,1,"<h1>The larger solution</h1>

<p><strong>Always compile with all warnings enabled.</strong></p>

<p>If you had done so, you would have caught things like these:</p>

<pre><code>In function ¡®read_meteo¡¯:
test.c:51:16: warning: return from incompatible pointer type [-Wincompatible-pointer-types]
         return arr;
                ^~~

 error: ¡®meteo_t {aka struct meteo_t}¡¯ has no member named ¡®preassure¡¯;
     did you mean ¡®pressure¡¯?
 sscanf(line, ""%[^,],%[^,],%[^,],%[^,],%[^,],%[^,],%s"",
(arr[*len].meteo_id), (arr[*len].meteo_city_id), (arr[*len].tempt_max),
(arr[*len].tempt_min), (arr[*len].humidity), (arr[*len].preassure),
(arr[*len].date));

warning: comparison between pointer and integer
 if (strcasecmp(date, meteo[i].date) == 0 &amp;&amp; id == meteo[i].meteo_city_id) {
                                                ^~
warning: initialization from incompatible pointer type [-Wincompatible-pointer-types]
meteo_t *meteo = read_meteo(""meteo.csv"", &amp;meteo_len);
              ^~~~~~~~~~
warning: passing argument 2 of ¡®search_meteo_by_city_by_date¡¯ 
makes integer from pointer without a cast [-Wint-conversion]
search_meteo_by_city_by_date(meteo, &amp;meteo_len, local, id, date);
                                    ^~~~~~~~~~
note: expected ¡®size_t {aka long unsigned int}¡¯ but argument 
    is of type ¡®size_t * {aka long unsigned int *}¡¯
void search_meteo_by_city_by_date(meteo_t *meteo, size_t len, 
                                                  ^~~~~~~~~~~
    const char *city, const int id, const char *date){
</code></pre>

<h1>The <em>not-so-right-after-all</em> solution</h1>

<p>Simply replace <code>152</code> with <code>len</code>. Apparently you already have an array index counter in there:</p>

<pre><code>meteo_t *meteo = read_meteo(""meteo.csv"", &amp;meteo_len);
if (meteo == NULL) {
    printf(""ERROR"");
    // YOU SHOULD ALSO EXIT IF YOU EVER ENTER HERE.
}
search_meteo_by_city_by_date(meteo, &amp;meteo_len, cidade, id, date);
</code></pre>

<p>The above, as @user3629249 pointed out, is logically correct <strong>but formally incorrect</strong> because the parameter being passed is <strong>not</strong> the value (which is probably 152, so correct) but <strong>its address</strong>, which is almost surely NOT 152, and therefore wildly incorrect. And that's why when you apply this solution you  get a crash.</p>

<p>If you had activated compiler warnings, this error wouldn't have been there, and if <em>I</em> had, I believe I would have given the right (<em>but still not complete! Look at those problems above!</em>) answer. Since neither of us used warnings, <strong>you and I both ended up being wrong</strong>. So: <em>use compiler warnings</em>.</p>
",4
50325266,50322304,3,"<p>If you want your code to be portable, use wide character output. The following code is standard C (C99 or later):</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;
#include &lt;wchar.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    if (!setlocale(LC_ALL, """"))
        fprintf(stderr, ""Warning: Current locale is not supported by the C library.\n"");
    if (fwide(stdin, 1) &lt; 1)
        fprintf(stderr, ""Warning: Standard input does not support wide characters.\n"");
    if (fwide(stdout, 1) &lt; 1)
        fprintf(stderr, ""Warning: Standard output does not support wide characters.\n"");

    wprintf(L""Here are ¡Ü and ¡Ý.\n"");

    return EXIT_SUCCESS;
}
</code></pre>

<p>On Linux systems (and on Macs, too, I believe), if you have a locale that can display ¡Ü and ¡Ý, that is what you will get.  In other locales, you'll see <code>Here are &lt;= and &gt;=.</code> instead.</p>

<p>If you need to be able to use narrow standard input and output functions (for example, because you use other code using those), use</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;
#include &lt;wchar.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    if (!setlocale(LC_ALL, """"))
        fprintf(stderr, ""Warning: Current locale is not supported by the C library.\n"");

    printf(""Here are %lc and %lc.\n"", L'¡Ü', L'¡Ý');

    return EXIT_SUCCESS;
}
</code></pre>

<p>instead. Unfortunately, this tends to have issues with locales that cannot support the ¡Ü and ¡Ý characters (on my system, the output is then just <code>Here are</code> without a newline). I personally would use the first approach instead.</p>
",6
48939916,48939460,0,"<p>I would create a function that converts the integers to the characters.</p>

<pre><code>char int_to_char(int val)
{

    if(val == 21)
        return 'A';

    if(val == 22)
        return 'B';

    if(val == 42)
        return 'H';

    if(val == 32)
        return 'E';

    if(val == 53)
        return 'L';

    if(val == 63)
        return 'O';


    // I don't see you pattern, so I don't know which value
    // is which character
    return '?';
}
</code></pre>

<p>I don't see your pattern here.</p>

<p>Then your loop would look like:</p>

<pre><code>// i is the number of entered values
// making sure that the end condition is even
for(int j = 0; j &lt; i&amp;1 ? i - 1 : i; j += 2)
{
    printf(""%c"", int_to_char(array[j] * 10 + array[j+1]));
}
</code></pre>

<p>This would print <code>HELLO</code> with the input <code>4 2 3 2 5 3 5 3 6 3</code>.</p>
",0
48997683,48997348,1,"<p>Use of <code>struct PAYRECORD</code> is wrong since there is no such type. You only have a <code>typedef</code> named <code>PAYRECORD</code>.</p>

<p>If you want to be able to use <code>struct PAYRECORD</code> as well as just <code>PAYRECORD</code>, change the definition of the <code>struct</code> to:</p>

<pre><code>typedef struct PAYRECORD {
   char name[100];
   int age;
   float hrlyWage;
   float hrsWorked;
   float regPay;
   float otPay;
   float totalPay;
   DATE payDate;
} PAYRECORD;
</code></pre>

<p>If that's not your goal, change the use of <code>struct PAYRECORD</code> by just <code>PAYRECORD</code>.</p>

<p>Also, the line:</p>

<pre><code>record[index].name = {'\0'};
</code></pre>

<p>in <code>newRecord</code> is not correct. You cannot assign to an array like that. Change it to:</p>

<pre><code>record[index].name[0] = '\0';
</code></pre>
",1
48997730,48997348,1,"<p>The <code>struct PAYRECORD</code> does not exist, the compiler has no idea how big that is.
Note that <code>PAYRECORD</code> is a typedef to an anonymous struct. So your function
should look like this:</p>

<pre><code>int newRecord(PAYRECORD record[], int index){
    //set name to \0 so it can work as string
    record[index].name[0] = 0;
    index++;
    return index;
}
</code></pre>

<p>Also note that <code>{'\0'};</code> works only when initializing a array when you declare
it:</p>

<pre><code>char arr1[10] = { '\0' }; // OK

char arr2[10];
arr2 = { '\0' }; // NOT OK
// error: expected expression before ¡®{¡¯ token
//  a = { '\0' };
//      ^
</code></pre>

<p>And when writing functions that take arrays as an argument, you should also pass
the size of the array.</p>

<pre><code>int newRecord(PAYRECORD record[], int index, size_t len){
    if(record == NULL)
        return -1; // error, NULL passed

    if(index &gt;= len)
        return -1; // error, cannot access array

    record[index].name[0] = 0;
    index++;
    return index;
}
</code></pre>

<p>And then you can call it from <code>main</code> like this:</p>

<pre><code>PAYRECORD record[SIZE];
...

int index = 0;

if(newRecord(record, index, sizeof record / sizeof *record) != index)
{
    // error handling
}
</code></pre>

<p>This makes the code more robust. You always have to check the array boundaries,
otherwise you might read/write out of bounds. And also check that <code>NULL</code> has not
been passed as well, if you dereference <code>NULL</code>, your program will crash with
segfault.</p>
",0
54733364,54733134,0,"<pre><code>#include &lt;inttypes.h&gt;
#include &lt;math.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


/*  Interpret a string containing a numeral for an integer value as an encoding
    of an IEEE-754 basic 32-bit binary floating-point value.
*/
static float Interpret(const char *s)
{
    //  Interpret the string as an integer numeral.  Errors are not handled.
    uint32_t x = strtoumax(s, NULL, 16);

    //  Separate the sign (1 bit), exponent (8), and significand (23) fields.
    uint32_t sign        = x&gt;&gt;31;
    uint32_t exponent    = (x&gt;&gt;23) &amp; 0xff;
    uint32_t significand = x &amp; 0x7fffff;

    //  Interpret the sign field.
    float Sign = sign ? -1 : +1;

    //  Create an object to hold the magnitude (or NaN).
    float Magnitude;

    //  How we form the magnitude depends on the exponent field.
    switch (exponent)
    {
        //  If the exponent field is zero, the number is zero or subnormal.
        case 0:
        {
            //  In a zero or subnormal number, the significand starts with 0.
            float Significand = 0 + significand * 0x1p-23f;

            //  In a zero or subnormal number, the exponent has its minimum value.
            int Exponent = 1 - 127;

            //  Form the magnitude from the significand and exponent.
            Magnitude = ldexpf(Significand, Exponent);

            break;
        }

        //  If the exponent field is all ones, the datum is infinity or a NaN.
        case 0x7fffff:
        {
            /*  If the significand field is zero, the datum is infinity.
                Otherwise it is a NaN.  Note that different NaN payloads and
                types (quiet or signaling) are not supported here.  Standard C
                does not provide good support for these.
            */
            Magnitude = significand == 0 ? INFINITY : NAN;
            break;
        }

        //  Otherwise, the number is normal.
        default:
        {
            //  In a normal number, the significand starts with 1.
            float Significand = 1 + significand * 0x1p-23f;

            //  In a normal number, the exponent is biased by 127.
            int Exponent = (int) exponent - 127;

            //  Form the magnitude from the significand and exponent.
            Magnitude = ldexpf(Significand, Exponent);
        }
    }

    //  Combine the sign and magnitude and return the result.
    return copysignf(Magnitude, Sign);
}


int main(void)
{
    printf(""%.99g\n"", Interpret(""0x466F9100""));
}
</code></pre>
",1
49933844,49933687,1,"<p>Passing values to a function has two points of view:</p>

<p>A function itself has a parameter (or formal parameter), when it is compiled. I. e. ¡­</p>

<pre><code>void f( int a )
{
  ¡­
}
</code></pre>

<p>¡­ has the (formal) parameter <code>a</code>.</p>

<p>When the function is called at run-time, there is a value that <code>a</code> represents. This is the argument (actual parameter):</p>

<pre><code>f( 5 )
</code></pre>

<p>Here <code>5</code> is the argument (actual parameter).</p>

<p>So the call maps the argument/actual parameter to the formal parameter.</p>

<p>In C in some situations you can pass a variable number of arguments to a function. This is, if the function has an open parameter list:</p>

<pre><code>f( int a, ... )
</code></pre>

<p>In many cases the first parameter is a format string that needs additional arguments. I. e.:</p>

<pre><code>printf( ""%d items"", 5 );
</code></pre>

<p>In this case <code>""%d items""</code> is a format string (format argument) that tells the function to insert a string representation of the second argument ahead of <code>"" items""</code>. </p>

<p>But a variable number of arguments does not limit to format strings. I. e. the following examples are all (formally) valid calls:</p>

<pre><code>f( int a, ... ) {?¡­?}

f( 5 );
f( 6, 2, 3 )
</code></pre>

<p>I think, dummy arguments/parameters has different meanings. It can be an parameter (and therefore an argument in a call) that isn't used inside the function. It can be an optional parameter, that gets a default value, if there is no argument for it in the call. (This concept does not exist in C, but in other programming languages.)</p>
",2
49014771,49014422,1,"<p>C uses storage classes to let you control a variable's scope and lifetime. ""Variable scope"" and ""variable lifetime"" are concepts that almost all languages have. ""Scope"" is basically ""what code can see/use this variable"" and ""lifetime"" is ""when is this variable created and destroyed"".</p>

<p>""extern"" doesn't create a variable or function, it just <em>declares</em> that somewhere else in the program that variable or function exists. </p>

<p>Hopefully this will give you enough information to find the rest of the answers you want.</p>
",0
52740256,52726001,0,"<p><code>fgets</code> could be used to read each line from the file. Then use <code>sscanf</code> to get the value from the line.</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    char line[100];
    int v[30],s,i;
    FILE *f;

    f=fopen(""dizionario.txt"",""r"");
    if (f==NULL) {
        printf(""Error.\n"");
        return -1;
    }

    if ( fgets ( line, sizeof line, f))
    {
        if ( sscanf ( line, ""%d"", &amp;s) != 1)
        {
            printf ( ""first line should have integer\n"");
            fclose ( f);
            return 0;
        }
    }
    if ( s &gt; 30)
    {
        s = 30;
    }
    i=0;
    while ( fgets ( line, sizeof line, f))
    {
        if ( sscanf ( line, ""$%d"", &amp;v[i]) == 1)
        {
            i++;
            if ( i &gt;= s)
            {
                break;
            }
        }
    }
    if ( i &lt; s)
    {
        s = i;
    }
    for ( i = 0; i &lt; s; i++) {
        printf ( ""%d\n"", v[i]);
    }

    return 0;
}
</code></pre>
",0
49463493,49463436,0,"<p>Actually, C language itself is not fully aware of <em>strings</em>. It only handles characters and pointers to them. What makes a C string is a convention by which an array of characters (an array is just a pointer to an allocated blob of memory) terminated by a null character <code>'\0'</code> can be handled as a string.</p>

<p>The only place where C is aware of strings is literal constants in code, like <code>""Hello""</code> in your example, which allocate memory containing those characters and followed by <code>'\0'</code>.</p>

<p><code>char *</code> does not declare a string variable. It declares a pointer to a character.</p>
",1
51203328,51202755,1,"<p>A character constant is written with single quotes: <code>'q'</code>.<code>""q""</code> is a string literal - an array of characters that decays to a pointer to a first character. Hence the warning given by the compiler</p>

<pre><code>test.c: In function ¡®main¡¯:
test.c:5:14: warning: comparison between pointer and integer
    while ( x != ""q"") {
              ^~
</code></pre>

<p>Here is the correct code</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void) {
    // loop forever. Easier to make the condition to exit with if + break

    while (1) {
        printf(""Enter the interger: "");

        // declare where it is used, to avoid it being used uninitialized
        int x = getchar();

        // if an error occurs or there are no more input, x equals to EOF.
        // to be correct, the program will need to handle the EOF condition
        // as well. Notice the single quotes around 'q'
        if (x == EOF || x == 'q') {
            break;
        } 
    }
    return 0; // main defaults to return 0 in standard C ever since 1999,
              // so this could have been omitted.
}
</code></pre>

<p>or the <code>do {?} while</code> loop could work too:</p>

<pre><code>    int x;
    do {
        printf(""Enter the integer: "");
        x = getchar();
    } while (x != EOF &amp;&amp; x != 'q');
</code></pre>

<p>however that might not be as nice because since the condition is now inverted and therefore harder to read, <code>x</code> needs to be declared outside the loop and you probably <em>do</em> need to do some processing for values other than <code>EOF</code>/<code>q</code> so you'd need an <code>if</code> anyway.</p>

<hr>

<p>As for the double prompt - that will happen because the newline <code>'\n'</code> is a read character too.</p>
",0
55617131,55558836,0,"<p>Short version (I'll try to expand later). </p>

<p>The library you're using SDL2_ttf's TTF_OpenFont requires an absolute path, not a relative one. This odd, because just about everywhere else an open will take a relative path (""../assests/fonts/DejeVuSans.ttf"") not an absolute (""/home/me/Project/SDL2_thing/assets/fonts/DejeVuSans.ttf""). </p>

<p>Assuming your program is running in a directory like ""/home/me/Project/SDL2_thing/source/my_program"". To get the parent directory (SDL2_thing) and build the absolute path, this snippet should work (based on POSIX functions and a bit sloppy with buffer sizes):</p>

<pre><code>#include &lt;stdio.h&gt;   //printf
#include &lt;unistd.h&gt;  //getcwd
#include &lt;libgen.h&gt;  //dirname

int main() {

        char buffer[1024];
        char target[2048];

        //get the full path to the current working directory
        getcwd(buffer, 1024);
        printf(""cwd\t: %s \n"", buffer);
        // This will chop off the directory at the end of the path (doing ../source) effectively)
        dirname(buffer);
        printf(""parent\t: %s \n"", buffer);

        //Take the path we have "".../SDL2_thing"" and build a string appending the rest
        sprintf(target, ""%s/assets/fonts/DejeVuSans.ttf"", buffer);
        printf(""target\t: %s \n"", target);

        return 0;
}
</code></pre>

<p>This is a complete program you can easily compile and run to see the outputs of intermediate value. Again, I'm just tossing around a couple big buffers which is sloppy and should be avoid. Use the proper MAX_PATH constants and such. You should be able to adapt this to get the absolute path to your font and give to TTF_OpenFont().</p>

<p>Check the result of the TTF_OpenFont() call. If null, print the string that TTF_GetError() gives you. This should help determine where the error is.</p>

<p>If you try this solution and have issues respond by commenting on this answer.</p>

<p>When I get a chance I'm going to look into why this function doesn't take an absolute and at least try to get it documented as such if not fixed. </p>
",0
53119620,53119519,2,"<pre><code>#ifdef _WIN32
printf(""Windows\n"");
#else
printf(""Not Windows\n"");
#endif
</code></pre>
",2
50145930,50145882,3,"<p>You never sort your arrays, but it looks like the <code>compute_union()</code> routine is assuming sorted arrays.</p>
",5
52049615,52049488,4,"<p>There's no difference in how <code>bzero</code> works whether the memory is allocated on the stack or on the heap.  The real problem is with how you're printing the contents:</p>

<pre><code>int i = 0;
while (i++ &lt; 4048)
  printf(""%x"", ptr[i]);
</code></pre>

<p>On the first iteration of the loop, the value of <code>i</code> (0) is compared against 4048.  It is less, so the loop is entered, but not before <code>i</code> is incremented.  Then the value of <code>ptr[i]</code>, i.e. <code>ptr[1]</code> is printed.  So you skip printing the first value.</p>

<p>Jumping ahead to the end, <code>i</code> is 4047 which is less than 4048 so the loop is entered, and again <code>i</code> is incremented before entering the loop body.  Then the value of <code>ptr[4048]</code> is printed, however this value is past the end of the array / allocated memory, so reading it invokes undefined behavior.  In this particular case, UB manifests as different garbage values being printed for each of the two cases.</p>

<p>You need to fix the loop to perform the increment inside the loop body:</p>

<pre><code>int i = 0;
while (i &lt; 4048)
  printf(""%x"", ptr[i++]);
</code></pre>
",2
49311847,49311820,3,"<p>If you are only reading, then you can simply copy the address of <code>argv[1]</code> like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, const char **argv) {
    const unsigned char *myvar = NULL;

    // Be sure to check argc first
    if (argc &lt; 2) {
        fprintf(stderr, ""Not enough arguments.\n"");

        return EXIT_FAILURE;
    }

    myvar = (const unsigned char *)argv[1];

    printf(""myvar = %s\n"", myvar);
}
</code></pre>

<p>If you want to change <code>myvar</code> then you should copy the string with <code>strncpy</code> or alike.</p>
",1
49312105,49311820,0,"<p>An array cannot be initialized by a pointer or by another array.  You can only initialize it with an initializer list or (in the char of a <code>char</code> array) a string constant.</p>

<p>What you can do it copy the contents of another string with <code>strcpy</code>.  And since you'll be using this array as a parameter to an encryption function, it will probably need to be a fixed size.</p>

<pre><code>char myvar[8] = { 0 };        // initialize all values to 0
strncpy(myvar, argv[1], 8);   // copy the first 8 bytes
</code></pre>
",0
49319753,49319615,2,"<p>You have made one of the classic mistakes: you used <code>scanf</code>.  There are a whole bunch of reasons not to use <code>scanf</code> <em>ever</em>, but right now the important reason is that <code>scanf(""%d\n"")</code> is going to <em>keep trying to read input</em> after the number, until it receives either EOF or something that isn't whitespace.</p>

<p>What you want to do instead is use <code>fgets</code>, which will read one entire line of input no matter what its contents are, and then <code>sscanf</code> to parse the number.  When you start writing more sophisticated programs you'll discover that even <code>sscanf</code> is troublesome and it's better to use lower-level functions like <code>strtol</code> and <code>strsep</code>, but for a classroom exercise like this <code>sscanf</code> is fine.</p>
",1
49328244,49328141,0,"<p>That happens because data types on any  programming language have limits, so you cannot simply put any number into an integer data type. Probably for your test the limit is 2.147.483.647 for integer data type, if you want to receive a bigger number you will have to switch to long or maybe unsigned long, it all depends of your needs, and when it comes to handle really really big numbers probably you will need to read it as string and then parse it to a special structure or class than can handle that really big number.</p>
",0
49338764,49338268,0,"<p>You can read how to use <code>printf</code> <a href=""http://www.cplusplus.com/reference/cstdio/printf/"" rel=""nofollow noreferrer"">here</a>.</p>

<p>In short <code>printf</code> does not require address of the variable but value of it - which is
opposite to <code>scanf</code>.</p>

<p>Remove the <code>&amp;</code> operator to use <code>printf</code> like:</p>

<pre><code>printf(""%d\n"",i);
</code></pre>

<p>and</p>

<pre><code>printf(""sum is:%d\n"",s);
</code></pre>

<p>See:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;

int main(void)
{
    int i,s=0;
    clrscr();

    for(i=1; i&lt;=5; i++)
    {
        if((i%3==0)||(i%5==0))
        {
            printf(""%d\n"",i);
            s=s+i;
        }
    }

    printf(""sum is:%d\n"",s);

    getch();

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>3                                                                                                                                            
5                                                                                                                                            
sum is:8  
</code></pre>

<p>Other improvement  would be to comply with <code>C</code> standard and declare <code>main</code> as <code>int main(void)</code> instead of <code>void main()</code> and return a value from the program.</p>
",0
49338357,49338268,1,"<p>Correct your code from:</p>

<pre><code>printf(""%d\n"", &amp;i);
</code></pre>

<p>to:</p>

<pre><code>printf(""%d\n"", i);
</code></pre>

<p>You do not need to use the <code>&amp;</code> address operator.</p>
",0
49468695,49468519,4,"<p>As @rafix07 commented, you just have to call <code>printHistogram(results, 10)</code> instead of <code>printHistogram(hist, 10)</code>.</p>

<p>Already compiled and tested... works</p>
",1
53355190,53355117,3,"<pre><code>for (l1 = 0; s1[l1] != '\0'; l1++)
//           ^^^^^^^^^^^^^^
</code></pre>

<p>Here's a problem: You're checking for <code>'\0'</code> in <code>s1</code>, but you never set any element of <code>s1</code> to <code>'\0'</code>, so this will access uninitialized memory and potentially go out of bounds of the array.</p>

<p>You have the same problem with <code>s2</code>.</p>

<p>There may be other problems, but this is where I stopped reading.</p>

<hr>

<p>General comments:</p>

<ul>
<li>Never use <code>scanf</code>.</li>
<li>If you do, always check its return value to make sure it was successful.</li>
<li>Never use <code>%s</code> with <code>scanf</code>. It's a buffer overflow waiting to happen.</li>
<li>Your code makes very stringent assumption about what the input looks like. If the user doesn't type exactly what your code is expecting, fun things will happen (e.g. the first <code>for (z = 0; in[z] != '+'; z++)</code> loop will go out of bounds if there is no <code>+</code> in the string). You should probably verify your assumptions and not blindly assume everything is OK.</li>
</ul>
",0
49555252,49554984,1,"<p>I think the problem lies in your for loops:</p>
<p><strong>First iteration:</strong></p>
<p><code>a = 0;</code></p>
<pre><code>for(b=0;b&lt;=a-1;b++) 
</code></pre>
<p>will not be true</p>
<p>as <code>b&lt;=a-1</code> equates to <code>b&lt;=-1</code> which is not true. Hence it will not enter the for loop for b. It will go to break and exit</p>
<p>Same process will repeat until <code>a&gt;=2</code>,</p>
<p>When you don't have break , b waits for <code>b&gt;=2</code> and starts comparing. That's why you see result of comparison.</p>
<p>A simple check would be to print out values of a and b at every iteration.</p>
",1
49742096,49741894,0,"<p>You can update the buffer before write function call as below:</p>

<pre><code>char *p = buffer;
for ( ; *p; ++p) *p = toupper(*p);
</code></pre>

<p>Make sure the buffer read is a proper string in C.</p>
",0
50356813,50356468,2,"<p>So many errors:</p>

<pre><code>void PrintDisplay(void);   // Do not put a semi-colon when defining a function.
{   
printf(""Enter an amount to calculate change: \n "");
return;
}

int CalculateChange(int change)
{
int FiftyCentAmount = 0;
int TwentyCentAmount = 0;
int TenCentAmount = 0;
int FiveCentAmount = 0;

[ .... ]

// C cannot return multiple variables at once.  A function can have ONE and ONLY ONE return value.
return(int FiftyCentAmount, int TwentyCentAmount, int TenCentAmount, int FiveCentAmount); 
}

void PrintResult(int FiftyCentAmount, int TwentyCentAmount, int TenCentAmount, int FiveCentAmount)
{
[...]
return;  // An empty return statement is not needed.  When a void-function reaches the end, it automatically returns.
}

int main(void)
{
    // Declare your variables before using them!
    int change;
    int FiftyCentAmount;
    int TwentyCentAmount;
    int TenCentAmountCentAmount;
    int FiveCentAmountCentAmount;

    PrintDisplay();

    // Do not write the type when calling a function
    // GetChange(change);
    GetChange(int change);

    // Do not write the type when calling a function.
    // CalculateChange(FiftyCentAmount, TwentyCentAmount, TenCentAmountCentAmount, FiveCentAmountCentAmount);

    CalculateChange(int FiftyCentAmount, int TwentyCentAmount, int TenCentAmountCentAmount, int FiveCentAmountCentAmount);
    PrintResult(int FiftyCentAmount, int TwentyCentAmount, int TenCentAmount, int FiveCentAmount);
return(0);
}
</code></pre>

<p>There are more errors, but that is enough to at least get the program to compile!</p>

<hr>

<p>You asked about a function modifying its parameters as a substitute for returning multiple values.</p>

<p>Here is the really short answer:<br>
(<em>deep understanding only comes with time</em>)</p>

<ul>
<li>Call the function with <code>&amp;</code> in front of each variable you wish to modify.</li>
<li>The function receives each parameter with <code>*</code></li>
<li>The function refers to each parameter as <code>*name</code></li>
</ul>

<p><strong>Example</strong></p>

<pre><code>// Declare the function:
void GetLightning(int* day, int* month, int* year, int *hour, int *minute);

// Define the function:
void GetLightning(int* day, int* month, int* year, int *hour, int *minute)
{
*day    = 12;
*month  = 11; // November
*year   = 1955;
*hour   = 10;
*minute = 4;
}


int main(void)
{
int day;
int month;
int year;
int hour;
int minute;

// Call the function
GetLightning(&amp;day, &amp;month, &amp;year, &amp;hour, &amp;minute);

// Show the results:
printf(""Lightning will strike the clocktower at precisely %02d:%02d on %d/%d/%d!\n"", hour, minute, month, day, year);
return 0;
}
</code></pre>
",3
50356615,50356468,1,"<p>Alvits already answered in comment.  Looks like you have an unintended semicolon on the first line.</p>
",0
49788912,49788639,2,"<pre><code>int x=-3, y=0, k,j;
for( k=j=-3 ; x= x+(k&lt;j),++j ; y+=2);
</code></pre>

<hr>

<pre><code>int x=-3, y=0, k=-3, j=-3;
while(x = x+(k&lt;j), ++j) {
    y += 2;
}
</code></pre>

<hr>

<pre><code>int x=-3, y=0, k=-3, j=-3;
x += k&lt;j;
while(++j) {
    y += 2;
    x += k&lt;j;
}
</code></pre>

<hr>

<pre><code>int x=-3, y=0, k=-3, j=-3;
x += 0;
while(++j) {
    y += 2;
    x += k&lt;j;
}
</code></pre>

<hr>

<pre><code>int x=-3, y=0, k=-3, j=-3;
while(++j) {
    y += 2;
    x += k&lt;j;
}
</code></pre>

<p>Now, this is way easier to understand:</p>

<ul>
<li>at the end, <code>j</code> will be zero, as it's the exit condition of the loop;</li>
<li>the loop will run twice, as the third time <code>++j</code> is evaluated it will evaluate to zero;</li>
<li><code>y</code> will end as 4, as it starts at zero, the loop runs twice and each time it's incremented by 2;</li>
<li><code>k</code> is never touched, so it stays at -3;</li>
<li>in the loop body, <code>k&lt;j</code> always, as they start equal but <code>j</code> has already been incremented once the control flow reach <code>x+=k&lt;j</code>, so this statement becomes <code>++x</code>. As it runs twice, <code>x</code> becomes -1.</li>
</ul>
",1
50426864,50426839,2,"<p>1) start your loops consistently at 0</p>

<p>2) use &lt;<code>nnr</code></p>
",0
49826796,49826502,1,"<p>The question ""what does the stack frame look like?"" doesn't have a single answer.  The answer depends on at what point we look at the stack frame.</p>

<p>The sequence of calls looks like this:</p>

<pre><code>f(4)
  f(2)
    f(0)
    f(0)
  f(2)
    f(0)
    f(0)
</code></pre>

<p>If we set a breakpoint at the return for when <code>n &lt;= 1</code> and called <code>f(4)</code>, we'd hit the breakpoint inside the first call to <code>f(0)</code> in the sequence above.  The stack frame would look something like this (assuming stack grows from top of allocated frame downward, and we're dumping memory from the SP to sequentially higher memory, both of which are typical):</p>

<pre><code>0
PC of f(0) call
2
PC of f(2) call
4
PC of f(4) call
</code></pre>

<p>For this function, bigO is the same as big theta, and I believe Mike P got it right: 2^(n/2).  To see why, try writing the call sequence for <code>f(6)</code> and <code>f(8)</code> and hopefully you'll see the pattern: every time you add two to the parameter, the number of calls doubles.</p>

<p>For a more complete answer, see <a href=""https://stackoverflow.com/questions/360748/computational-complexity-of-fibonacci-sequence"">Computational complexity of Fibonacci Sequence</a> .  This is not the Fibonacci series, but the algorithm has the same complexity.</p>
",2
49828926,49828877,2,"<p>With width and high you mean the number of rows and columns of the file?</p>

<p>In this case you can check the newline character:</p>

<pre><code>int rows = 0;
int cols = 0;
int rowcols = 0;
while ((dat = fgetc(fs)) != EOF) {
    if (dat == '\n') {
        if (rowcols &gt; cols) {
            cols = rowcols;
        }
        rowcols = 0;
        rows++;
    } else {
        if (dat != '\r') { /* Do not count the carriage return */
            rowcols++;
        }
    }
    printf(""%c"",dat); 
}
/* If the file does not end with a newline */
if (rowcols != 0) {
    if (rowcols &gt; cols) {
        cols = rowcols;
    }
    rows++;
}
printf(""Rows = %d, Cols = %d\n"", rows, cols); 
</code></pre>

<p>On the other hand, always check the number of arguments passed to <code>main</code> and the result of <code>fopen</code>:</p>

<pre><code>if (argc &lt; 2) {
    fprintf(stderr, ""Usage = %s file\n"", argv[0]);
    exit(EXIT_FAILURE);
}
...
fs = fopen(argv[1], ""r"");
if (fs == NULL) {
    perror(""fopen"");
    exit(EXIT_FAILURE);
}
</code></pre>
",0
51810025,51809381,2,"<p>If you want to see <em>how it works</em>, you are up a creek with Winsock; the source code is not available.  You can disassemble <code>ws2_32.dll</code> but that's tedious and makes it very hard to tell what behavior is contractual and what is accidental.</p>

<p>Instead, I recommend you read through the equivalent functions in an open-source C library; for instance, here is <a href=""https://svnweb.freebsd.org/base/head/lib/libc/inet/inet_addr.c?view=markup"" rel=""nofollow noreferrer""><code>inet_addr</code> in FreeBSD libc</a> and <a href=""https://sourceware.org/git/?p=glibc.git;a=blob;f=resolv/inet_addr.c;hb=HEAD"" rel=""nofollow noreferrer""><code>inet_addr</code> in GNU libc</a>.  This will not educate you about Windows-specific quirks; the best sources for those are <a href=""https://msdn.microsoft.com/de-de/library/windows/desktop/ms738563(v=vs.85).aspx"" rel=""nofollow noreferrer"">MSDN</a> and paper books like <em>Windows Internals</em>.</p>
",0
49940990,49940788,0,"<p>Change this lines.</p>

<pre><code>14: InternetAddress *ExactInternetAddress(char *filename);
18: char filename [] = ""internetaddress.txt"";
24: InternetAddress *ExactInternetAddress(char *filename) {
</code></pre>
",0
49962928,49962860,3,"<p>In C, the <code>main</code> function should return 0 upon a successful exit and some error code otherwise. This way you can distinguish between success and different errors. One way to do it is mentioned in the comment by @Stargateur:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define pi 3.141593

int main(void)
{
    float inner_d, outer_d, surface_area, radius;

    printf(""Enter the outer diameter:\n"");
    scanf(""%f"", &amp;outer_d);

    printf(""Enter the inner diameter:\n"");
    scanf(""%f"", &amp;inner_d);
    if (inner_d &lt; 0 || outer_d &lt; 0 || inner_d &gt;= outer_d) { return EXIT_FAILURE;}
    float inner_a = (inner_d / 2) * (inner_d / 2) * pi;
    float outer_a = (outer_d / 2) * (outer_d / 2) * pi;  

    surface_area = outer_a - inner_a;

    printf(""Your surface area is: %f\n"", surface_area);
    return 0;
} 
</code></pre>
",2
52980724,52980480,1,"<p>This answer serves purely to challenge your thinking about your current approach.</p>

<p>Personally, unless there's some special logic involved, I would just ditch the loops completely and initialize your struct like this.</p>

<pre><code>const struct deviations devs[8] = {
    { 1, -1, -1 },  // top-left
    { 1,  0, -1 },  // top
    { 1,  1, -1 },  // top-right
    { 1, -1,  0 },  // left
    { 1,  1,  0 },  // right
    { 1, -1,  1 },  // bottom-left
    { 1,  0,  1 },  // bottom
    { 1,  1,  1 }   // bottom-right
};
</code></pre>

<p>If you then decide that you really need to allocate that dynamically then you could just copy it:</p>

<pre><code>struct deviations *pdevs = malloc(sizeof(devs));
if (pdevs) memcpy(pdevs, devs, sizeof(devs));
</code></pre>

<p>But if you really wanted to generate this stuff in a loop, why not something like this?</p>

<pre><code>int ii = 0;
for(int y = -1; y &lt;= 1; ++y) {
    for(int x = -1; x &lt;= 1; ++x) {
        if (x == 0 &amp;&amp; y == 0) continue;
        pdevs[ii].switch = 1;
        pdevs[ii].x = x;
        pdevs[ii].y = y;
        ++ii;
    }
}
</code></pre>
",3
52838428,52838020,2,"<p>The obscure but probably quite effective version would be this:</p>

<pre><code>#include &lt;limits.h&gt;

return !((a &amp; INT_MIN) ^ (b &amp; INT_MIN));
</code></pre>

<p>Explanation:</p>

<p>No matter signed representation on the given system, the MSB of the variable will always hold a sign bit. By checking if the sign bit is set on each variable, we can see if it is signed or not.</p>

<p>This is done by bitwise masking, for example <code>a &amp; 0x80000000</code> on a 32 bit system. This returns <code>0x80000000</code> if the number is signed, otherwise <code>0</code>.</p>

<p>The portable version of the 0x80... mask is <code>INT_MIN</code> from limits.h.<br>
(Or if you will, you can use <code>1u &lt;&lt; (CHAR_BIT*sizeof(int))</code>).</p>

<p>You want to return 1 if the variables have the same sign, otherwise 0. That is logical XNOR. C does not have that operator but we can create it through <code>!(a ^ b)</code>, read as ""NOT (a XOR b)"".</p>

<p>And so we end up with the above expression. For those who doesn't know the difference in operator precedence between bitwise AND and bitwise XOR (<em>gasp</em>, shame on you!), I added the inner parenthesis, although you can also drop them if you wish to pose with your C operator precedence knowledge:</p>

<pre><code>return !( a &amp; INT_MIN ^ b &amp; INT_MIN );
</code></pre>
",2
50360420,50360175,0,"<p><code>printf</code> format codes of the form <code>%M.Nf</code>, where M and N are integers, mean to round the number to N decimal places, and left-pad it with spaces until it takes up at least M screen columns.</p>

<pre><code>&gt;&gt;&gt; printf('%10.2f', 12345.6789);
  12345.68
^^ Note the 2 spaces here to produce 10 chars of output.
</code></pre>

<p>Key word here being ¡°at least¡±.  If the number ¡°naturally¡± takes up more than M columns, then it won't be truncated.</p>

<p><code>%0.f</code> (with the <code>0</code> on the <em>left</em> side of the <code>.</code>) literally means to pad the number with spaces until it's at least 0 columns wide.  But since there's no such thing as a negative-width numeric string, it could never actually write any space-padding, so it's equivalent to just <code>%.f</code>.</p>
",0
50360405,50360175,3,"<p>Yes, they are the same.</p>

<p>The number to the left of the decimal is the minimum number of digits to print before padding with white space.  </p>

<p>If that number begins with a zero, it also indicates that the number should be padded with zeros instead of spaces.  For a length of zero, no padding will be applied.  It's impossible to print a number of length less than zero, so the additional padding indicator will never be used.</p>

<p>In either case, one must print some number, which means that even though you indicated you want a minimally zero length float, it will print more than the minimum length to show the number's value.  For your test cases, the output of <code>printf(""%0.f"", 0.0f)</code> will show <code>0</code>, having decided to print more than the minimum number of characters to show the number.</p>

<p>For those confusing <code>%0.f</code> with <code>%.0f</code> note that one specifies minimum number of digits, and the other is a precision modifier.</p>

<p>For floats, the presence of the <code>.</code> character indicates a specified precision, and the absence of a number to the right is interpreted as <code>0</code>.  So <code>%3.0f</code> and <code>%3.f</code> are equivalent.  In the event you do not supply a <code>.</code> in your float, then it is assumed that your float is effectively formatted with <code>.6</code></p>
",3
50452167,50450297,0,"<p><del>Your comparison function will be passed (as <code>void *</code>) pointers to 2 elements of the array. Your comparison function must treat both of these pointers equivalently - the normal way is to define 2 local variables of type ""pointer-to-array-element"", and assign (without casts) the two arguments to those local variables; then compare the 2 elements by dereferencing those local, appropriate-type pointers.</del></p>

<p><del>Your sample comparison function converts the two arguments into pointers-to 2 diferent types. You're going to have a bad time.</del></p>

<p>Ignore the above.</p>

<p>(While <code>bsearch()</code> <em>can</em> use a comparison function that is also usable by <code>qsort()</code>, it isn't necessary to write the function that way.)</p>
",2
50451017,50450297,3,"<p><code>bsearch()</code> needs to know the size of each element in the array. It gets passed as a pointer, so <code>bsearch()</code> needs to know how to calculate the offset of each element. </p>

<p>When <code>bsearch()</code> tries to find the <code>nth</code> element of the array it will do something like:</p>

<pre><code>ptr + size * n;
</code></pre>

<p>(Where <code>ptr</code> is the 2nd param to <code>bsearch()</code> and <code>size</code> is the 4th).</p>

<p>So if you provide the wrong <code>size</code> value (which you are doing), <code>bsearch()</code> won't be able to calculate the correct addresses.</p>

<p>Fix - pass the correct size of the elements of the array:</p>

<pre><code>result = bsearch(key, dictionary, *num_dict, sizeof(word_dict_t), cmp_func);
</code></pre>

<p>or:</p>

<pre><code>result = bsearch(key, dictionary, *num_dict, sizeof(dictionary[0]), cmp_func);
</code></pre>
",0
50563000,50557000,3,"<blockquote>
  <p>a value of type void* cannot be used to initialize an entity of type Item*</p>
</blockquote>

<p>The malloc code is fine. You either get this warning because VS is non-conforming compiler, or because you are compiling the code as C++. If the problem persists after setting VS to compile in C mode, get a better compiler. </p>

<blockquote>
  <p>const char* cannot be assigned to an entity of type char* </p>
</blockquote>

<p>Pretty self-explaining. Either you allow the pointer to be changed and then drop const correctness in <code>const char* _color</code>. Or you don't allow the pointer to be changed, then make the struct member <code>const char* color;</code>.</p>

<blockquote>
  <p>const void* cannot be used to initialize entity of type const Item**</p>
</blockquote>

<p><code>const Item**</code> is a pointer-to-pointer to <code>const Item</code>. This is a different pointer type than <code>const void*</code> since they have different qualifiers. You can probably solve the compiler error with something obscure such as <code>const Item*const* pfirst</code>, but that isn't the actual root of the problem.</p>

<p>I take it you are writing a function to pass to bsearch/qsort etc, and what you have is an array of pointers. In which case you should only convert <code>a</code> and <code>b</code> to <code>const Item*</code>. I'm not sure why you bring in the <code>Item**</code> in the first place.</p>
",0
55374873,55373307,1,"<p>In practice, a variable will be initialized <em>before use</em>, regardless if it is placed in an inner scope or not. This code:</p>

<pre><code>void func1 (int i){
  if(i) {
    int arr[2048] = {0};
    printf(""%d"", arr[666]);
  } else {
    //Doing something
  }
}
</code></pre>

<p>gives exactly the same machine code as this code:</p>

<pre><code>void func2 (int i){
  int arr[2048] = {0};
  if(i) {
    printf(""%d"", arr[666]);
  } else {
    //Doing something
  }
}
</code></pre>

<p>gcc -O3 on x86 gives:</p>

<pre><code>.LC0:
        .string ""%d""
func1:
        test    edi, edi
        jne     .L4
        ret
.L4:
        xor     esi, esi
        mov     edi, OFFSET FLAT:.LC0
        xor     eax, eax
        jmp     printf
</code></pre>

<p>and</p>

<pre><code>.LC0:
        .string ""%d""
func2:
        test    edi, edi
        jne     .L7
        ret
.L7:
        xor     esi, esi
        mov     edi, OFFSET FLAT:.LC0
        xor     eax, eax
        jmp     printf
</code></pre>

<p>As you can see they are identical. </p>

<p>It is good design practice to limit the scope of variables as much as possible though, but that has nothing to do with performance.</p>
",0
51358646,51358150,2,"<p>The line:</p>

<pre><code>*(char*) data = mac;
</code></pre>

<p>attempts to assign a <code>char*</code> to a <code>char</code> - in GCC it yields the following warning:</p>

<pre><code>    warning: assignment makes integer from pointer without a cast [-Wint-conversion]
</code></pre>

<p>You should have something similar and should never ignore the warnings.</p>

<p>What you need to do here is copy the string generated in <code>mac</code> to the buffer provided by the caller <code>data</code> :</p>

<pre><code>static void on_get_mac_result_line( void* data, const char* line, int length )
{
    if( wifi_state != STATE_IDLE ) 
    {
        char mac[length] ;

        if( sscanf_s( line, ""%17s"", mac, length ) == 1 ) 
        {
            strcpy( data, mac) ;
        }
    }
}
</code></pre>

<p>You should take measures also to ensure that <code>length</code> is sufficient to prevent an overrun, for example you could either check that <code>length</code> is at least 18, or use <code>sscanf_s</code> as I have above.  </p>

<p>Note that <code>p</code> in your original implementation is unused and serves no purpose.</p>
",2
51358601,51358150,3,"<p><code>char mac[length];</code> is local to the <code>on_get_mac_result_line</code> function. Attempts to access it outside of that function should not be made.</p>

<p>You'll have to copy the entire <code>char</code> array into the <code>data</code> destination to make the result available to the calling function (<code>wifi_get_mac</code>). Eg. by using <a href=""https://en.cppreference.com/w/c/string/byte/strncpy"" rel=""nofollow noreferrer""><code>strncpy</code></a> :</p>

<pre><code>strncpy((char*) data, mac, 17);
</code></pre>
",2
54619616,54619290,1,"<p>Linear interpolation is fairly straight forward.</p>

<ul>
<li>At <code>percentage</code> 0, the speed should be <code>speed_max</code>.</li>
<li>At <code>percentage</code> 85, the speed should be <code>speed_min</code>.</li>
<li>At <code>percentage</code> values greater than 85, the speed should still be <code>speed_min</code>.</li>
<li>Between 0 and 85, the speed should be linearly interpolated between <code>speed_max</code> and <code>speed_min</code>, so <code>percentage</code> is a 'amount of drop from maximum speed'.</li>
</ul>

<p>Assuming <code>percentage</code> is of type <code>float</code>:</p>

<pre><code>float speed_from_percentage(float percent)
{
    if (percent &lt;= 0.0)
        return speed_max;
    if (percent &gt;= 85.0)
        return speed_min;
    return speed_min + (speed_max - speed_min) * (85.0 - percentage) / 85.0;
}
</code></pre>

<p>You can also replace the final return with the equivalent:</p>

<pre><code>return speed_max - (speed_max - speed_min) * percentage / 85.0;
</code></pre>

<p>If you're truly pedantic, all the constants should be suffixed with <code>F</code> to indicate <code>float</code> and hence use <code>float</code> arithmetic instead of <code>double</code> arithmetic.  And hence you should probably also use <code>float</code> for <code>speed_min</code> and <code>speed_max</code>.  If everything is meant to be integer arithmetic, you can change <code>float</code> to <code>int</code> and drop the <code>.0</code> from the expressions.</p>
",0
54619611,54619290,2,"<p>Assuming speed is linearly calculated based on percentages from 0 to 85 (and stays at speed_min with percentage is gt 85), then this is your formula for calculating speed:</p>

<pre><code>if (percentage &gt;= 85)
{
    speed = speed_min;
}
else
{
     speed = speed_max - (((speed_max - speed_min)*percentage)/85);
}
</code></pre>
",0
50727000,50726387,0,"<p>After reading the Wikipedia article about the Luhn algorithm, the application int the program is clear.</p>

<p>Every credit card number has a ""check digit"" as its last digit.  That digit makes it so that when the Luhn algorithm is applied, the result is an even multiple of 10.  If someone mistypes the card number, chances are good that it will not add up to a multiple of 10, catching the error before bothering to check the credit card with the CC company.</p>

<p>That's what the program does: it checks that the credit card number ""looks"" legitimate.  Try it on your own CC, and then try it on the same CC number but with a mistake.</p>

<p>The Luhn function you posted returns a true value if the result is evenly divisible by 10.</p>
",0
50789012,50788970,4,"<p>Do not call <code>srand</code> every time you want to generate a number. <code>srand</code> initializes the pseudo-random number generator and is intended to be called just once at the start of your program, or when you want to reset the generator. By resetting it every time, you are forcing <code>rand</code> to generate the same numbers every time you call it within each second on the clock.</p>

<p>Do not use <code>x % n</code> to reduce the number to a desired range. Old implementations of <code>rand</code> are notoriously bad and have patterns in the low bits. Instead, use <code>x / ((RAND_MAX+1u) / n)</code>.</p>

<p>The code <code>int range = RAND_MAX - (RAND_MAX % n);</code> is flawed. Suppose <code>n</code> is 4 and <code>RAND_MAX</code> is 7, meaning <code>rand</code> returns 0 to 7. This code sets <code>range</code> to 4, and then <code>while (x &gt; range) x = rand();</code> discards 5, 6, and 7, while it retains 4. There are two bugs here: The code keeps the five values 0, 1, 2, 3, and 4, which is a mismatch to (not a multiple of) the desired range of 4, and it unnecessarily discards values. If we had kept 4, 5, 6, and 7, we would have a match. You could use:</p>

<pre><code>unsigned range = (RAND_MAX + 1u) - ((RAND_MAX + 1u) % n);
</code></pre>

<p>and:</p>

<pre><code>while (x &gt;= range) x = rand();
</code></pre>

<p>If you are using C++, switch to using <a href=""http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution"" rel=""nofollow noreferrer""><code>std::uniform_int_distribution</code></a>. If you are using C, check the quality of <code>rand</code> in your implementation or switch to another generator such as the POSIX <code>srandom</code> and <code>random</code>.</p>
",1
50789055,50788970,0,"<p>As noted elsewhere, the fix to the repeated numbers is to move the call to <code>srand(time(NULL))</code> outside this function and call it only once per program at the beginning.</p>

<p>As for why you're getting repeated numbers: The function is being called several times per second.  Each time the function executes in a given second, <code>time(NULL)</code> returns the same number, which this code uses to seed the random number generator.  </p>

<p>The sequence of random numbers generated from a particular seed will always be the same.  This code takes the first number from that sequence, which is always the same for one second, until <code>time(NULL)</code> returns a new value.</p>
",0
50813002,50811739,0,"<p>Regarding what the declaration you came up with does, that's a pretty icky declaration. You can unwind it with the <a href=""http://c-faq.com/decl/spiral.anderson.html"" rel=""nofollow noreferrer"">clockwise/spiral rule</a>.</p>

<p>Basically the <code>table()</code> part means there's a a function. The <code>()</code> is obsolete C, meaning a function taking any parameter. You should be using <code>(void)</code> instead.</p>

<p>The <code>int* (* ... ) [10]</code> part means that you have a function returning an array pointer to an array <code>int* [10]</code>. Such an array pointer is normally declared as  <code>int* (*name)[10]</code> when written outside a function return value.</p>

<p>So you have a function declaration, of a function returning an array pointer, to an array of 10 int*, the function is taking an obsolete style parameter list.</p>

<p>You can understand it better with this example:</p>

<pre><code>typedef int* (*arrptr)[10]; // to illustrate, typedef an array pointer int* (*)[10]

typedef arrptr func_t (void); // typedef a function type returning said array pointer

void func (func_t* x){}
// dummy function to demonstrate type compatibility, funct_t* is a function pointer 


int *(*table(void))[10]; // function declaration

int main (void)
{

  func(table); // table is of same type as the function pointer func_t*

  return 0;
}

int *(*table(void))[10]
{
  return 0;
}
</code></pre>

<p>Please note that hiding arrays and pointers behind typedefs is normally bad practice.</p>

<hr>

<p>Regarding how to get an array of function pointers, it is way more straight-forward than interpreting the above gibberish.</p>

<ul>
<li><code>int* func (void)</code> This is a function.</li>
<li><code>int* (*func) (void)</code> This is a function pointer to such a function.</li>
<li><code>int* (*func[10][10]) (void)</code> This is a 2D array of function pointers.</li>
</ul>

<p>Or preferably:</p>

<ul>
<li><code>typedef int* func_t (void)</code> This is a function type.</li>
<li><code>func_t* fptr</code> This is a function pointer to such a function.</li>
<li><code>func_t* fptr[10][10]</code> This is a 2D array of function pointers.</li>
</ul>
",13
50843302,50843188,3,"<p>You have several problems.</p>

<p>First, you didn't allocate memory for <code>my_record</code> to point to. The warning about using an uninitialized variable is because you didn't do:</p>

<pre><code>abc my_record = malloc(sizeof(struct rec));
</code></pre>

<p>Second, the first argument to <code>fwrite()</code> should be the pointer to the structure you want to write, but you're using a pointer to the pointer.</p>

<p>Third, the second argument to <code>fwrite()</code> should be the size of the structure, but you're giving the size of the pointer.</p>

<p>There doesn't seem to be any good reason to define <code>abc</code> as a pointer in the first place. You should just declare a variable containing the structure itself.</p>

<pre><code>#include&lt;stdio.h&gt;

typedef struct rec
{
    int x, y, z;
} abc;

int main()
{
    int counter;
    FILE *ptr_myfile;
    //struct rec my_record;
    abc my_record;

    ptr_myfile = fopen(""test.bin"", ""wb"");
    if (!ptr_myfile)
    {
        printf(""Unable to open file!"");
        return 1;
    }
    for (counter = 1; counter &lt;= 10; counter++)
    {
        my_record.x = counter;
        fwrite(&amp;my_record, sizeof my_record, 1, ptr_myfile);
    }
    fclose(ptr_myfile);
    system(""pause"");
    return 0;
}
</code></pre>
",0
54629805,54626096,1,"<p>This relates to a well-known shortcoming in the C language, which I will discuss below. Presuming we want <code>find_char</code> to return a <code>char *</code> even though its inputs are <code>const char *</code>, you should use an explicit cast in the <code>return</code> statement:</p>

<pre><code>return (char *) result;
</code></pre>

<p>With <code>return result;</code>, there is an implicit conversion from <code>char *</code> to the incompatible type <code>const char *</code>. The compiler warns because this could be a mistake. With the explicit cast, you show the compiler the conversion is intentional, and it is not likely to warn. (If it does, you can turn off that particular warning category.)</p>

<p>Regarding the shortcoming in C, consider the nature of <code>find_char</code>. It is similar to the C library routine <code>strstr</code>, which suffers from the same issue:</p>

<ul>
<li>The caller may have a <code>char *</code> and want a <code>char *</code> as a result.</li>
<li>We would like the function parameters to be <code>const char *</code> to inform the compiler that the function does not alter the strings it is passed, because this may create some optimization opportunities.</li>
<li>The function returns a pointer into one of its input strings. So it internally has a <code>const char *</code> but must return a <code>char *</code>, so it must convert it.</li>
</ul>

<p>In other words, we have a <code>char *</code>, and we want to tell the compiler ¡°Ths function will accept a <code>char *</code>, and it will not change the content, but it will return a <code>char *</code> result.¡± To do this in C, it is necessary to declare the parameter to be <code>const char *</code> but to convert the result pointer to <code>char *</code> before returning it.</p>
",1
52534937,52534840,3,"<p>You actually have <em>two</em> problems:</p>

<p>The first is that you break <a href=""https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule"">strict aliasing</a> and have <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a>.</p>

<p>The second problem is that on most modern platforms the size of an <code>int</code> is <em>four</em> bytes, and the pointer <code>pp</code> is pointing only to a <em>single</em> byte. The assignment you make to <code>*pp</code> will therefore write out of bounds and <em>also</em> lead to undefined behavior.</p>
",0
52534998,52534840,0,"<p>Cast or no cast, you are essentially try to use incompatible types, leading to violating strict aliasing rules.</p>

<p>According to <code>C11</code>, chapter ¡ì6.5,</p>

<blockquote>
  <p>An object shall have its stored value accessed only by an lvalue expression that has one of
  the following types:88)</p>
  
  <p>¡ª a type compatible with the effective type of the object,</p>
  
  <p>¡ª a qualified version of a type compatible with the effective type of the object,</p>
  
  <p>¡ª a type that is the signed or unsigned type corresponding to the effective type of the
  object,</p>
  
  <p>¡ª a type that is the signed or unsigned type corresponding to a qualified version of the
  effective type of the object,</p>
  
  <p>¡ª an aggregate or union type that includes one of the aforementioned types among its
  members (including, recursively, a member of a subaggregate or contained union), or</p>
  
  <p>¡ª a character type.</p>
</blockquote>

<p>But, you try to access the memory allocated for a <code>char</code> via an <code>int</code> type. This violates strict aliasing.</p>

<p>That said, the standard guarantees that size of a <code>char</code> is 1 byte, size of an <code>int</code> is <code>&gt;=</code> <code>char</code>. So, the access would be out of bound and lead to undefined behavior.</p>
",0
58001682,58001432,0,"<p>I'd write a general function for replacing a char with another char.... then use it to replace 'e' with 'E'.</p>

<p>for example :-</p>

<pre><code>char* replace_all(char* str, char target, char replacement) {
    char* s = str;
    while(*s != 0)  {
        if(*s == target) *s = replacement;
        s++;
    }
    return str;
}

int main() {
    char example[] = ""The elephant in the room."";
    printf(""%s"", replace_all(example,'e', 'E'));
}
</code></pre>

<p>you mentioned 'random_letter' but didn't explicitly talk about it in your question.   I'm assuming for that, you can then build something like the following.</p>

<pre><code>char* replace_all(char* str, char target, char replacement) {
    char* s = str;
    while(*s != 0)  {
        if(*s == target) *s = replacement;
        s++;
    }
    return str;
}

char capitalize(char c) {
    if(c &gt;= 'a' &amp;&amp; c &lt;= 'z') return 'A' + (c -'a');
    return c;
}


int main() {
    char example[] = ""The elephant in the room."";
    char letter = random_letter();
    printf(""%s"", replace_all(example,letter, capitalize(letter)));
}
</code></pre>

<p>Now you have built two useful functions that can be reused for other things, rather than one very explicit function called capitalize_e</p>
",1
51077705,51074432,0,"<p>Here is an implementation.
The magic here is carried out by the <code>change_file_name(org, dest, size, ext)</code>, that checks whether the name <em>org</em> ends with <em>ext</em>, and in that case copies the name up to that point.</p>

<p>Hope this helps.</p>

<pre><code> /* Changes the name of the sys input file. */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdbool.h&gt;


bool change_file_name(const char * org, char * dest, size_t max_length, const char * file_ext)
{
    bool toret = false;
    const size_t name_length = strlen( org );
    const size_t ext_length = strlen( file_ext );
    const size_t new_name_size = name_length - ext_length;

    if ( name_length &gt; ext_length
      &amp;&amp; name_length &lt; max_length
      &amp;&amp; strcmp( org + new_name_size, file_ext ) == 0 )
    {
        strncpy( dest, org, name_length - ext_length );
        *( dest + new_name_size ) = 0;
        toret = true;
    }

    return toret;
}

void convert_file(const char * org, const char * dest)
{
    printf( ""Processing file '%s' into '%s'\n"", org, dest );
}

int main(int argc, char *argv[])
{
    const int NAME_SIZE = 1024;
    const char * rle_ext = "".rle"";
    char new_name[NAME_SIZE];
    int toret = EXIT_SUCCESS;

    if ( argc == 2 ) {
        if ( change_file_name( argv[ 1 ], new_name, NAME_SIZE, rle_ext ) ) {
            printf( ""The new name is: '%s'\n"", new_name );
            convert_file( argv[ 1 ], new_name );
        } else {
            toret = EXIT_FAILURE;
            fprintf( stderr,
                     ""Name results empty, is not ending in '%s' or is too large: '%s'\n"",
                     rle_ext,
                     argv[ 1 ] );
        }
    } else {
        toret = EXIT_FAILURE;
        fprintf( stderr, ""Usage: %s &lt;file name&gt;.txt.rle\n"", argv[ 0 ] );
    }

    return toret;
}
</code></pre>
",2
51076933,51074432,0,"<p>You can simply do this with:</p>

<ul>
<li><a href=""http://man7.org/linux/man-pages/man3/strchr.3.html"" rel=""nofollow noreferrer""><code>strrchr</code></a> to find where is the last period in string,</li>
<li><code>strlen</code> / <code>malloc</code> to allocate memory to store the new name,</li>
<li><a href=""http://man7.org/linux/man-pages/man3/sprintf.3p.html"" rel=""nofollow noreferrer""><code>sprintf</code></a> to create the new name.</li>
</ul>

<hr>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

/* this function will create a new name, replacing the existing extension
   by the given one.
   returned value should be `free()` after usage

   /!\ warning: 
        * validity of parameters is not tested
        * return of strdup and malloc are not tested.
   */
char *replace_ext(const char *org, const char *new_ext)
{
    char *ext;

    /* copy the original file */
    char *tmp = strdup(org);

    /* find last period in name */
    ext = strrchr(tmp , '.');

    /* if found, replace period with '\0', thus, we have a shorter string */
    if (ext) { *ext = '\0'; }

    /* compute the new name size: size of name w/o ext + size of ext + 1 
       for the final '\0' */
    size_t new_size = strlen(tmp) + strlen(new_ext) + 1;

    /* allocate memory for new name*/
    char *new_name = malloc(new_size);

    /* concatenate the two string */
    sprintf(new_name, ""%s%s"", tmp, new_ext);

    /* free tmp memory */
    free(tmp);

    /* return the new name */
    return new_name;
}

int main(void)
{
    int i;
    char *tests[] = { ""test.ext"", ""test.two.ext"", ""test_no_ext"", NULL};

    for (i = 0; tests[i]; ++i)
    {
        char *new_name = replace_ext(tests[i], "".foo"");
        printf(""%s --&gt; %s\n"", tests[i], new_name);
        free(new_name);
    }

    return 0;
}
</code></pre>
",2
55356677,55356559,1,"<p>Your condition is <code>1&lt;=num&lt;=100</code>, not <code>1&gt;=num</code> and <code>100&gt;=num</code>, so the solution would be to change the <code>if</code> condition, like this:</p>

<pre><code>if (
  (num1 &gt;= 1 &amp;&amp; num2 &gt;= 1 &amp;&amp; num3 &gt;= 1 &amp;&amp; num4 &gt;= 1 &amp;&amp; num5 &gt;= 1 &amp;&amp; num6 &gt;= 1 &amp;&amp; num7 &gt;= 1 &amp;&amp; num8 &gt;= 1 &amp;&amp; num9 &gt;= 1 &amp;&amp; num10 &gt;= 1) &amp;&amp;
  (num1 &lt;= 100 &amp;&amp; num2 &lt;= 100 &amp;&amp; num3 &lt;= 100 &amp;&amp; num4 &lt;= 100 &amp;&amp; num5 &lt;= 100 &amp;&amp; num6 &lt;= 100 &amp;&amp; num7 &lt;= 100 &amp;&amp; num8 &lt;= 100 &amp;&amp; num9 &lt;= 100 &amp;&amp; num10 &lt;= 100)
) {
  printf(""Numbers are good"");
} else {
  printf(""All numbers must be between 1 to 100"");
}
</code></pre>
",0
51117994,51115555,1,"<p>Here's my suggestion to simplify your code, and hopefully make it easier to debug.</p>

<ol>
<li>Define a function that returns the number of digits.</li>
<li>Define a function that divides the square into to numbers, given the number of digits in the original number.</li>
<li>Compute the sum of the divided parts of the square and compare it with the original number.</li>
</ol>

<hr>

<pre><code>int getNumberOfDigits(int n)
{
   if ( n == 0 )
   {
      return 1;
   }

   int count = 0;
   while ( n / 10 &gt; 0 )
   {
      n /= 10;
      ++count;
   }

   return count;
}

void divideSquare(int square, int originalDigitCount, int out[2])
{
    int left = square;
    int right = 0;
    for ( int = 0; i &lt; originalDigitCount; ++i )
    {
       right  = right*10 + left%10;
       left /= 10;
    }
    out[0] = left;
    out[1] = right;
}

int main()
{
    for (int n = 0; n &lt; 10000; ++n )
    {
       int square = n * n;
       int out[2];
       int count = getNumberOfDigits(n);
       divideSquare(square, count, out);
       if ( out[0] + out[1] == n )
       {
          printf(""%d is a Kaprekar number\n"", n);
       }
    }
 }
</code></pre>
",0
57177643,57175939,1,"<p>In contrast to empty string literal (<code>""""</code>), character literals always need to contain a character (exactly one)<sup>*</sup>. Replace <code>''</code> with <code>' '</code> and you code should compile at least.</p>

<p>However, the code as is will count the number of spaces. What will happen if a string contains more than one subsequent space? Additionally, you might want to consider tabs as well? And how would you want to interpret punctuation marks? Part of words or separator? And what about numbers?</p>

<p>Depending on how you answer all these questions, you might need to vary the condition in code below. In any case, I propose a stateful iteration over your input:</p>

<pre><code>int isSeparator = 1; // so you will count the first word occuring, too, even if starting
                     // at first character of the string
for(char const* s = str; *s; ++s)
{
    if(isalnum((unsigned char)*s)) // requires &lt;ctype.h&gt; header; modify condition
                                   // appropriately if you want different
                                   // characters to count as word parts
    {
        wordCount += isSeparator;
        isSeparator = 0;
    }
    else
    {
        isSeparator = 1;
    }
}
</code></pre>

<p><sub><sup>*</sup>Actually, the standard <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.4.4.4p2"" rel=""nofollow noreferrer"">does</a> allow multi-byte characters, so to be precise, we'd need to state <em>'at least one character'</em>, but these multi-byte characters have implementation defined meaning and usually aren't useful anyway, so for practical reasons, we might stay with the technically less correct <em>'exactly one character'</em>...</sub></p>
",0
51542253,51542146,2,"<p>From <code>man 3 strcat</code>:</p>

<blockquote>
  <p>The strings may not overlap, and the dest string must have enough space for the result. If dest is not large enough, program behavior is unpredictable; <em>buffer overruns are a favorite avenue for attacking secure programs</em>.</p>
</blockquote>

<p>You need to ensure your <code>header</code> array is allocated large enough to ensure that you can write <code>strlen(strDeviceName) + 5</code> bytes into it in addition to the initial size; otherwise you have a (probably remotely exploitable) buffer overrun vulnerability.</p>

<p>Presumably <code>header</code> is allocated locally to the function? In that case you should consider using <code>alloca</code> or <code>malloc</code> to get a properly-sized block of memory rather than relying on a static size. You'll also need to handle errors from those functions.</p>

<p>Additionally, you should always prefer the safe alternative <code>strncat</code> over plain <code>strcat</code>, as <code>strncat</code> takes an additional argument for the number of bytes to append, and ensures that the buffer is always null-terminated even if an overflow would otherwise have happened.</p>
",0
51542973,51542146,0,"<p>The problem is that you are [str]concatenating to an array (<code>header</code>) which doesn't extra space (C arrays can't be changed in size).</p>

<p><a href=""http://man7.org/linux/man-pages/man3/printf.3.html"" rel=""nofollow noreferrer""><code>snprintf</code></a> could be a better fit here.</p>

<p>If you know the maximum possible length of <code>strDevicename</code>, you could use a fixed size buffer:</p>

<pre><code>const char header[] = ""POST /api/add HTTP/1.1\r\nHost: xxxxxxx:3000\r\nContent-Type: application/octet-stream; charset=utf-8\r\nContent-Length: 500\r\nName: "";
const char tail[] = ""\r\n\r\n"";
char buf[(sizeof header - 1) + MAX_DEV_LENGTH + (sizeof tail - 1) + 1];
/* sizeof would count the null byte in header &amp; tail arrays. */
snprintf(buf, sizeof buf, ""%s%s%s"", header, strDevicename, tail);
</code></pre>

<p>If <code>strDevicename</code> is of unknown length, you could use <a href=""http://man7.org/linux/man-pages/man3/asprintf.3.html"" rel=""nofollow noreferrer""><code>asprintf</code></a>(GNU function):</p>

<pre><code>char *buf = NULL;
if (asprintf(&amp;buf, ""%s%s%s"", header, strDevicename, tail) == -1) {
   /* handle memory allocation failure */
}

...

free(buf);
</code></pre>

<p>If you <code>asprintf</code> isn't available, then you could allocate sufficient memory (just as above) yourself using <a href=""http://man7.org/linux/man-pages/man3/realloc.3.html"" rel=""nofollow noreferrer""><code>malloc</code></a> and then use <code>snprintf</code>.</p>
",7
51542237,51542146,4,"<p>In your code, the size of the array <code>header</code> is decided by the size of the supplied initializer string, and it does not have any additional space to store (or <em>append</em>) any further characters.</p>

<p>Quoting <code>C11</code>, chapter ¡ì6.7.9</p>

<blockquote>
  <p>If an array of unknown size is initialized, its size is determined by the largest indexed
  element with an explicit initializer. The array type is completed at the end of its
  initializer list.</p>
</blockquote>

<p>Next, for <code>strcat()</code>, from chapter ¡ì7.24.3.1</p>

<blockquote>
  <p>The <code>strcat</code> function appends a copy of the string pointed to by <code>s2</code> (including the
  terminating null character) to the end of the string pointed to by <code>s1</code>. [...]</p>
</blockquote>

<p>which indicates, the target <code>s1</code> (here, <code>header</code>) should have sufficient storage to hold the concatenated string.</p>

<p>Thus, the attempt to <code>strcat()</code> with <code>header</code> as source, invokes undefined behaviour here, as you run past allocated memory.</p>

<p>You need to make <code>header</code> have enough space left after you fill it with the initializer string. Use a fixed size for the array, which has much excess after filling it with the initialize string, something like</p>

<pre><code>#define STRSIZ 512

char header[STRSIZ] = ""POST /api/add HTT.........
</code></pre>
",0
51542232,51542146,0,"<p>You need to allocate sufficient space for the entire string. 
Man page:</p>

<pre><code>char * strcat(char *restrict s1, const char *restrict s2);
The string s1 must have sufficient space to hold the result.
</code></pre>

<p>You could do it the ""right"" way and allocate exactly what you need:</p>

<pre><code>char *buf;
char header[] = ""POST /api/add HTTP/1.1\r\nHost: xxxxxxx:3000\r\nContent-Type: application/octet-stream; charset=utf-8\r\nContent-Length: 500\r\nName: ""

buf = malloc(strlen(header)+strlen(strDeviceName)+strlen(""\r\n\r\n"")+1);
if(buf==NULL) abort();
strcpy(buf, header);
strcat(buf, strDevicename); \\
strcat(buf, ""\r\n\r\n"");
</code></pre>

<p>Or do it the lazy way and overallocate:</p>

<pre><code>char header[1024] = ""POST /api/add HTTP/1.1\r\nHost: xxxxxxx:3000\r\nContent-Type: application/octet-stream; charset=utf-8\r\nContent-Length: 500\r\nName: ""

strcat(header, strDevicename); \\
strcat(header, ""\r\n\r\n"");
</code></pre>
",1
51220466,51220429,4,"<p>C have a very limited amount of <a href=""https://en.cppreference.com/w/c/numeric/random"" rel=""nofollow noreferrer"">pseudo-random number generators</a>, but it's still usable for your use-case.</p>

<p>Simply loop over the string, and generate a random <code>0</code> or <code>1</code>. If <code>0</code> do nothing to the current character; If <code>1</code> then check if the current character is upper or lower case (using e.g. <a href=""https://en.cppreference.com/w/c/string/byte/isupper"" rel=""nofollow noreferrer""><code>isupper</code></a> or <a href=""https://en.cppreference.com/w/c/string/byte/islower"" rel=""nofollow noreferrer""><code>islower</code></a>) and change the character case accordingly (using <a href=""https://en.cppreference.com/w/c/string/byte/toupper"" rel=""nofollow noreferrer""><code>toupper</code></a> or <a href=""https://en.cppreference.com/w/c/string/byte/tolower"" rel=""nofollow noreferrer""><code>tolower</code></a>).</p>

<p>If you want to random select another letter or digit, then use the first number as a selector to see if the character should be changed, and generate a <em>second</em> number between <code>0</code> and <code>36</code>. If <code>0</code> then change case, if <code>1</code> to <code>10</code> then change into the corresponding digit, or if <code>11</code> to <code>36</code> then subtract <code>10</code> and change to the corresponding letter.</p>

<p>You can easily change the probabilities of the chances of changing a character by changing the range of the first number. For example you can generate a number between <code>0</code> and <code>3</code> (inclusive) and modify the character if the value is equal to <code>0</code>. Then you have a one-in-four chance of modifying a character, instead of a one-in-two.</p>

<p>As for getting a number in a specific range, there are a <em>lot</em> of examples all over the Internet, if you serch a little.</p>

<hr>

<p>If you want to modify some (or all) characters to similar <em>looking</em> characters (like <code>'o'</code> or <code>'O'</code> to <code>'0'</code>), similar to ""leet code"", then a possible solution is to keep a lookup-table for all characters which you want to possibly translate. Then if you decide to ""change"" the character then randomly select a look-alike in the lookup-table for the current character.</p>

<p>This lookup-table could be an array of structures, like</p>

<pre><code>struct
{
    int original;
    int leet;
} character_change_table[] = {
    { 'o', '0' },
    { 'e', '3' },
    // Etc.
};
</code></pre>
",1
51452407,51452366,2,"<p>If you look at the memory layout of a 3x3 array, it looks like:</p>

<pre class=""lang-none prettyprint-override""><code>[0][0]          [1][0]        [2][0]         
+----+----+----+----+----+----+----+----+----+
|    |    |    |    |    |    |    |    |    |
+----+----+----+----+----+----+----+----+----+
</code></pre>

<p>Where is the element <code>[3][3]</code>?</p>

<pre><code>[0][0]          [1][0]        [2][0]         [3][0]         [3][3] 
+----+----+----+----+----+----+----+----+----+----+----+----+----+
|    |    |    |    |    |    |    |    |    |    |    |    |    |
+----+----+----+----+----+----+----+----+----+----+----+----+----+
</code></pre>

<p>That explains why you end up accessing 12 elements.</p>

<p>Your code is subject to undefined behavior for accessing the beyond valid indices but that's another issue.</p>

<p>You could use:</p>

<pre><code>for (int *ip = &amp;abc[0][0]; ip &lt;= &amp;abc[2][2]; ip++)
{
  printf(""%d   \n"",*ip);
}
</code></pre>

<p>However, it is  better to access a 2D array as a 2D array.</p>

<pre><code>for (size_t i = 0; i &lt; 3; ++i )
{
  for (size_t j = 0; j &lt; 3; ++j )
  {
    printf(""%d   \n"", abc[i][j]);
  }
}
</code></pre>
",2
53071756,53071070,2,"<p>You have a few issues in your algorithm.</p>

<ol>
<li><p>the <code>for</code> loop calls the <code>numbers</code> program multiple times, starting the recursion multiple times. You need to start it only once, right?</p></li>
<li><p>you calling recursion with <code>n+1</code>, actually making every next invocation with an incremental value, which could be incremented indefinitely. Your recursion has no exit and will die with some out of memory or a crash.</p></li>
</ol>

<p>To solve the first issue, just instantiate it once. </p>

<p>To print it correctly, you need to have the print statement withing the recursion.</p>

<p>For the second issue, you can do different approaches. The following is the easiest to understand and it passes <code>max</code> as a second argument.</p>

<pre><code> void numbers(int n, int max) {
     printf(%d "", n);
     if (n &gt;= max)
        return;
     numbers (n + 1, max);
  }

  int main() {
    ...
    numbers(1, number);
  }
</code></pre>

<p>a more efficient way is having a single argument and count it down to 0. But you have to be careful on when you want to print. In your case, if you need increment order of values, you have to make sure that the print happens <strong>after</strong> you return from recursion. </p>

<p>Here is the program which implements the second method:</p>

<pre><code>#include &lt;stdio.h&gt;

void numbers(int n);
int main(int argc, char const *argv[]) {
  int number;
  int i;
  printf(""Put a number and the program will do everything for ya.\n"");
  printf(""Number: "");
  scanf(""%d"", &amp;number);

  // start recursion.
  numbers(number);
  printf(""\n"");
}

void numbers(int n){
    if (n == 0)
        return;
    numbers(n-1);

    // after return from recursion
    printf(""%d "", n);
}
</code></pre>
",0
58883190,58882897,3,"<p>As mentioned in the comments, you have 2 issues. First, since you iterate over the entire row, you end up swapping each item 2x. And that leaves just the original array.</p>

<p>Second, you access one past the end of the array with <code>image[i][width - j]</code> when <code>j == 0</code>. Valid indexes for an array are <code>0...(length-1)</code>.</p>

<p>Another, minor issue is that you don't need an array for the temp value.</p>

<pre><code>// Reflect image horizontally
void reflect(int height, int width, int image[height][width])
{
    int temp;

    for (int i = 0; i &lt; height; i++)
    {
        for (int j = 0; j &lt; width / 2; j++)
        {
            temp = image[i][j];
            image[i][j] = image[i][width - j - 1];
            image[i][width - j - 1] = temp;
        }
    }
    return;
}
</code></pre>

<p>Tested: <a href=""https://ideone.com/EAALtI"" rel=""nofollow noreferrer"">https://ideone.com/EAALtI</a></p>
",1
53715004,53714928,0,"<p>dont ignore compiler warnings, it must be complaining at you about this</p>

<pre><code>char scan_year2() {
  char year_number;
  scanf(""%s"", year_number);
  return year_number;
  return 0;
}
</code></pre>

<p>you try to return twice.</p>

<p>Also</p>

<pre><code> part_size = str_size / 2;
  for (i = 0; i &lt; str_size; i++) {
    if (i % part_size == 0)
      printf(""\n"");
    printf(""%s"", str[i]);
  }
</code></pre>

<p>is not going to give you the correct output. YOu are outputing the string each time. IE if str = ""1923"" then you will get</p>

<pre><code>1923923
232
</code></pre>

<p>You should do</p>

<pre><code> part_size = str_size / 2;
  for (i = 0; i &lt; str_size; i++) {
    if (i % part_size == 0)
      printf(""\n"");
    printf(""%c"", str[i]);
  }
</code></pre>

<p>to only output one char at a time</p>
",0
51597853,51596516,1,"<h3>Simple code solution</h3>

<p>Here's a (not worse than) linear-time answer based on the hint first <a href=""https://stackoverflow.com/questions/51596516/if-input-is-abcdexyzbwqpoolj-the-output-should-be-b-find-first-repeating-charact?noredirect=1#comment90159081_51596516"">commented</a> on by <a href=""https://stackoverflow.com/users/4253229/eugene-sh"">Eugene Sh.</a>:</p>

<pre><code>#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    char str[1000];
    char map[UCHAR_MAX + 1] = { 0 };

    if (scanf(""%999s"", str) == 1)
    {
        for (int i = 0; str[i] != '\0'; i++)
        {
            int n = (unsigned char)str[i];
            if (map[n]++ != 0)
            {
                printf(""first duplicate: %c\n"", str[i]);
                break;
            }
        }
    }
    return 0;
}
</code></pre>

<p>This keeps a record of each byte already seen in the <code>map</code> array, and simply breaks the loop when a duplicate character (not just letter) is found.  This has various merits, including:</p>

<ul>
<li>linear (O(N)) execution time</li>
<li>not breaking nested loops (because there's no nesting)</li>
<li>not scanning the whole input if there are duplicates at the start</li>
<li>not using <code>strlen()</code> in the loop condition (that could make the original code more complex than O(N2) if the optimizer doesn't detect that <code>strlen()</code> could be called just once)</li>
</ul>

<p>Its main demerit is that it says nothing if no duplicate is found.  If that's not acceptable, add a flag that is initially false, is set to true when the <code>break</code> is executed, and is tested after the loop.  Alternatively, instead of a <code>break</code>, the code could use <code>return 0;</code> to exit the program after printing the duplicate, and could print a 'no duplicates' message and exit with failure at the end.</p>

<h3>O(N) linear vs O(1) constant search time</h3>

<p>Since the total search space is 255 bytes (because a null byte isn't counted as a duplicatable character), there is room to argue that rather than being O(N) linear time, it is O(1) constant time.  If the input is only lower-case non-alphabetic, then there must be a duplicate if there are 27 characters in the input.  If the input is not so constrained, then there will be a duplicate within the first 256 bytes (it is less than that since <code>scanf()</code> and <code>%s</code> stop reading at the first white space, so there can't be any white space characters to repeat).  The Big-O notation is for the asymptotic run time, and neither 27 nor 256 is very large, so it can be argued that the run time is O(1).</p>
",6
51488876,51488853,2,"<p>What you are doing wrong is simply not realising that C is not Pascal :-) Pascal has the concept of functions within functions where the ""visibility"" of the former is limited to the latter. In other words, you can't see the inner function from anywhere else.</p>

<p>There is no facility in C to have functions within functions. The closest equivalent to what you have is:</p>

<pre><code>#include &lt;stdio.h&gt;

static void echoNumber()
{
    int num;
    printf(""Enter a number:"");
    scanf(""%d"", &amp;num);
    printf(""You entered %d"", num);
}

int main()
{
    echoNumber();
    return 0;
}
</code></pre>

<p>The <code>static</code> in front of <code>echoNumber</code> limits it's ""visibility"" to that of the rest of the file. That's not <em>quite</em> as restrictive as the Pascal model but, provided you organise your code nicely, will be equally efficient.</p>

<hr>

<p>You'll note I've quoted the word visibility above. I'm using the the common English term (for ""where you can see it from"") rather than the preoper ISO standards ones, since I find that's more understandable to those who aren't intimately immersed in the standard.</p>
",0
51488874,51488853,2,"<p>C doesn't have nested functions. Move <code>echoNumber</code> outside of <code>main</code>, e.g.</p>

<pre><code>#include &lt;stdio.h&gt;

void echoNumber()
{
    int num;
    printf(""Enter a number:"");
    scanf(""%d"", &amp;num);
    printf(""You entered %d"", num);
}

int main()
{
    echoNumber();
    return 0;
}
</code></pre>
",0
54048601,54048209,0,"<p>As long as the string of <code>#</code> marks is long enough (at least <code>n</code> of them), you can use:</p>

<pre><code>for (i = 0; i &lt; n; i++)
    printf(""%*.*s\n"", n, i+1, ""##########"");
</code></pre>

<p>The <code>*</code> markers in the format string mean 'read an <code>int</code> from the parameter list' ¡ª see the POSIX specification of <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html"" rel=""nofollow noreferrer""><code>printf()</code></a>, for example, or the C11 specification of <a href=""https://port70.net/~nsz/c/c11/n1570.html#7.21.6.1"" rel=""nofollow noreferrer""><code>fprintf()</code></a>.  The notation <code>""%10.6s\n""</code>, for example, would mean ""print a field 10 characters wide, right justified, blank filled on the left, with no more than 6 characters coming from the string argument"".  So, if <code>n</code> is <code>10</code>, the loop works as:</p>

<pre><code>printf(""%10.1s\n"", ""##########"");    // 9 blanks, 1 hash
printf(""%10.2s\n"", ""##########"");    // 8 blanks, 2 hashes
¡­
printf(""%10.9s\n"", ""##########"");    // 1 blank, 9 hashes
printf(""%10.10s\n"", ""##########"");   // 0 blanks, 10 hashes
</code></pre>

<p>You can try the following code:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{
    int n = 10;

    for (int i = 0; i &lt; n; i++)
        printf(""%*.*s\n"", n, i + 1, ""##########"");

    return 0;
}
</code></pre>

<p>Or:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    int n = 10;
    char data[n + 1];
    memset(data, '#', n);
    data[n] = '\0';

    for (int i = 0; i &lt; n; i++)
        printf(""%*.*s\n"", n, i + 1, data);

    return 0;
}
</code></pre>

<p>Or:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void)
{
    int n = 10;
    char *data = malloc(n + 1);
    memset(data, '#', n);
    data[n] = '\0';

    for (int i = 0; i &lt; n; i++)
        printf(""%*.*s\n"", n, i + 1, data);

    free(data);
    return 0;
}
</code></pre>

<p>The latter two will handle values of <code>n</code> larger than <code>10</code> without any problem. As shown, the first won't (but it can be adapted to handle moderate values of <code>n</code> fairly easily, of course).  Note that the middle one uses a VLA (variable length array); that's a mandatory feature of C99 and an optional feature of C11 and C18.  The last one should check that <code>malloc()</code> succeeds. For plausible values of <code>n</code>, it is unlikely to fail in this context, but in a bigger program, the check is always advisable.</p>
",0
51596312,51596185,2,"<p>Aside from a small formatting error at the bottom, it prints out just fine. 
<br><a href=""http://codepad.org/EKatQ2AH"" rel=""nofollow noreferrer"">See here.</a></p>

<p>Note however that for writing such a kind of game, using standard C printing is not suitable as it doesn't allow you to move the cursor around freely or clear what you've printed before, so you cannot update what you already printed to screen. Not sure if Windows offers an easy way to do so but on most other systems it's a bit complicated and very system dependent, that's why people use libraries for that like <a href=""https://en.wikipedia.org/wiki/Ncurses"" rel=""nofollow noreferrer"">Ncurses</a>. It's not available for Windows but a library named <a href=""https://www.projectpluto.com/win32a.htm"" rel=""nofollow noreferrer"">PDCurses</a> is. It's code is public domain (you may use it in any way you like) and <a href=""https://github.com/Bill-Gray/PDCurses"" rel=""nofollow noreferrer"">can be found on GitHub</a>.</p>

<h2>Update</h2>

<p>Maybe I spoke too soon. Of course, if you know the exact screen size (number of lines and number of columns per line), you can always print the entire screen which will cause the entire screen to be refreshed. Check out this demonstration code I wrote: </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdint.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;math.h&gt;
#include &lt;float.h&gt;
#include &lt;time.h&gt;

#if defined (__WIN32__)
#   include &lt;windows.h&gt;
#else
#   include &lt;unistd.h&gt;
#endif

#define TERM_WIDTH    80
#define TERM_HEIGHT   25
#define STAR_COUNT  1000

static const float STAR_SPEED = 1.5;
static const unsigned SPACE_DEPTH = 70;
static const unsigned FRAME_DURATION = 24;
static const char BANNER_TEXT[] = ""This is awesome!!!"";

struct Star {
    float x;
    float y;
    float z;
};

static unsigned gBannerPosition;
static struct Star gStars[STAR_COUNT];
static char gBanner[2 * TERM_WIDTH];
static char gScreen[TERM_HEIGHT][TERM_WIDTH];

static
void sleepForMS ( unsigned milliseconds ) {
#if defined (__WIN32__)
    Sleep(milliseconds);
#else
    usleep(milliseconds * 1000);
#endif
}

static
void clearScreen ( ) {
    memset(gScreen, ' ', sizeof(gScreen));
}

static
void printScreen ( ) {
    printf(""%.*s"", (int)sizeof(gScreen), (char *)gScreen);
    fflush(stdout);
}

static
void animateBanner ( ) {
    const int line = (TERM_HEIGHT / 2);
    memcpy(gScreen[line], &amp;gBanner[gBannerPosition], sizeof(gScreen[line]));
    gBannerPosition--;
    if (gBannerPosition == 0) {
        gBannerPosition = sizeof(gScreen[12]);
    }
}

static
struct Star spawnNewStar ( bool randomZ )  {
    return (struct Star){
        .x = (float)random() / INT_MAX * 50 - 25,
        .y = (float)random() / INT_MAX * 50 - 25,
        .z = randomZ ?
                ((float)random() / INT_MAX * SPACE_DEPTH - 1) + 1
                : SPACE_DEPTH
    };
}

static
void animateStars ( ) {
    for (unsigned s = 0; s &lt; STAR_COUNT; s++) {
        gStars[s].z -= STAR_SPEED;
        if (gStars[s].z &lt;= 0) {
            gStars[s] = spawnNewStar(false);
        }
        float zFactor = 128.f / (gStars[s].z + FLT_MIN);
        int x = round(gStars[s].x * zFactor + (TERM_WIDTH / 2));
        int y = round(gStars[s].y * zFactor + (TERM_HEIGHT / 2));
        if (x &gt;= 0 &amp;&amp; x &lt; TERM_WIDTH &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; TERM_HEIGHT) {
            float starSize = (SPACE_DEPTH - gStars[s].z) / SPACE_DEPTH;
            char starSign = '#';
            if (starSize &lt; 0.25) {
                starSign = '.';
            } else if (starSize &lt; 0.5) {
                starSign = '+';
            } else if (starSize &lt; 0.75) {
                starSign = '*';
            }
            gScreen[y][x] = starSign;
        }
    }
}

static
void initStars ( ) {
    srandom(time(NULL));
    for (unsigned s = 0; s &lt; STAR_COUNT; s++) {
        gStars[s] = spawnNewStar(true);
    }
}

static
size_t minsize ( size_t a, size_t b ) { return a &lt; b ? a : b; }

static
void initBanner ( ) {
    memset(gBanner, ' ', sizeof(gBanner));
    memcpy(gBanner, BANNER_TEXT,
        minsize(sizeof(BANNER_TEXT) - 1, TERM_WIDTH)
    );
    memcpy(&amp;gBanner[TERM_WIDTH], BANNER_TEXT,
        minsize(sizeof(BANNER_TEXT) - 1, TERM_WIDTH)
    );
    gBannerPosition = TERM_WIDTH;
}

int main ( int argc, const char * const * const argv ) {
    initStars();
    initBanner();
    while (1) {
        clearScreen();
        animateStars();
        animateBanner();
        printScreen();
        sleepForMS(FRAME_DURATION);
    }
}
</code></pre>

<p>By default it expects your terminal to be 80x25 characters but just change the defines on top and you can make it fit to any terminal size. These values must be correct, otherwise it will not display correctly. Whether it looks good or horrible depends on how fast your terminal is able to refresh its content. You might be able to tweak results a bit by tweaking the <code>FRAME_DURATION</code> constant. Code builds on macOS using <code>clang -o demo demo.c</code> and on Linux using <code>gcc -lm -o demo demo.c</code>. I tried to make it compatible to Windows as well but didn't test it on Windows.</p>
",0
51576594,51576477,0,"<p>This line is wrong in two ways:</p>

<pre><code>if (strcmp(argv[5], ""-c"") == 0);
</code></pre>

<p>First, you¡¯re ending the <code>if</code> with a semicolon, so it tests whether the
fifth argument is <code>""-c""</code>, but then it runs the next block either way.</p>

<p>If you¡¯re not typing <code>-c</code> as the fifth argument, you probably only have
four arguments, in which case the fifth argument would be <code>NULL</code>. (Or
you might have fewer than four, in which case there is no fifth argument
at all.) Passing <code>NULL</code> to <code>strcmp</code> is undefined behavior. So, you need
to check that <code>argv &gt;= 5</code> before testing <code>argv[5]</code>.</p>
",0
51835400,51835218,4,"<p>It's sloppily written code. What it does is to create an array of 4 structs and initialize the member <code>l</code> only in each struct. Good compilers will warn here (for gcc use <code>-Wextra</code>), since the struct is partially initialized.</p>

<p>Since <code>q</code> isn't initialized explicitly, it will get set to zero. This is a special rule for partially initialized structs.</p>

<p>Properly written, the equivalent code looks like this:</p>

<pre><code>typedef struct 
{
  int l;
  int q;
} id_gpios_t;

id_gpios_t id_gpios[] = 
{ 
  {1,0},
  {2,0},
  {3,0},
  {4,0},
};
</code></pre>

<p>(Using <code>l</code> as an identifier is well-known bad practice, since it looks like <code>1</code> on a lot of editor fonts.)</p>
",3
51718958,51718925,0,"<p><code>scanf()</code> does not discard input not matching the format specifier. You should read it in a char[] with <code>%s</code> and then do a <code>atoi()</code> for trying to convert it to string. If it fails, <code>ERRNO</code> will be set to some error code. That way, you'll not leave any unprocessed input behind if something other than a digit is entered.</p>
",2
51719109,51718925,2,"<p><code>scanf</code> is weird. It has an internal buffer, and will only read from the stream if that buffer is empty. At the start of your code, there is nothing, so a line is read from standard input. Then <code>scanf</code> tries to find an integer there. If an integer is found, it will report it successfully read one item (by returning <code>1</code>) and puts the read value into the supplied pointer location. However, if an integer is not found, it will return <code>0</code> for ""zero items successfully read"", and it <em>will not consume anything from the buffer</em>. This means, next time <code>scanf</code> is invoked, the buffer will not be empty, consequently the user will not be prompted again for a new line, and <code>scanf</code> will try again to read an integer at exactly the same place it tried last time (and will fail for exactly the same reason). Thus, infinite loop.</p>

<p>To illustrate this ""buffer"" thing, try this:</p>

<pre><code>scanf(""%d"", &amp;a);
scanf(""%d"", &amp;b);
printf(""a: %d, b: %d\n"", a, b);
</code></pre>

<p>and enter <code>12 53</code> <em>in one line</em>, as the input to the first <code>scanf</code>. Magically, <code>a</code> ends up as <code>12</code> and <code>b</code> ends up as <code>53</code>. The explanation for the magic is - the first <code>scanf</code> found the buffer empty, read the line from the user, and found one integer, as it was told to; the second <code>scanf</code> found the buffer with some stuff still there, and continued reading where it left off last without having to ask the user for a new line.</p>

<p>As others commented already, it is usually better to read a line yourself (<code>fgets</code>) and parse it yourself (<code>strtol</code>), or if you absolutely need to use <code>scanf</code>, make sure to check if <code>scanf</code> read what you expected it to by inspecting its return code. See <a href=""https://stackoverflow.com/questions/7898215/how-to-clear-input-buffer-in-c"">here</a> on how to clear the input buffer if <code>scanf</code> fails.</p>
",1
51916074,51915133,2,"<p>Your program contains a buffer overflow. <code>str2</code> is a buffer, its size is 14bytes (the length of ""stackoverflow"" + the terminating NULL character). When you execute <code>strcpy(str2, str1)</code> you are overflowing that buffer since <code>str1</code> is longer than 14bytes. <code>strcpy</code> has no way of knowing the size of the buffer, so (by its definition) it blindly copies from one buffer to the other.</p>

<h3> Buffer overflow on the stack </h3>

<p>Now, why does this alter <code>str1</code>? Well, because when <code>strcpy</code> copies more chars than the destination buffer's size, these chars must go somewhere.
Since both <code>str2</code> and <code>str1</code> are allocated on the stack, they are placed right next to each other. So, when <code>strcpy</code> copies onto <code>str2</code> and overflows its size, it will move on to whatever's next to it in the memory - in your case that's <code>str1</code>.</p>

<p>So, the last characters <code>strcpy</code> is copying - the last few characters in <code>str1</code> - are copied back onto the beginning of <code>str1</code>.</p>
",0
51916316,51915133,2,"<p>First of all, the destination <code>str2</code> is shorter than string length <code>str1</code> therefore this is an undefined behaviour.</p>

<p>But to understand why this happens, consider the following.</p>

<p>When I print out the memory addresses of the string, before any modification of your code in my system it is like this.</p>

<pre><code>printf(""str1: %p (%d)  \nstr2: %p (%d)\n"", str1, strlen (str1),  str2, strlen (str2));

str1: 0x7ffd394e85d0 (19)  
str2: 0x7ffd394e85c2 (13)
str1: wwwww
str2: stackoverflowwwwwww
str3:successful
str4:asdfgh
</code></pre>

<p>Note the address of <code>str1</code> and <code>str2</code>. <code>str2</code> starts first (lower address) and <code>0x7ffd394e85d0 - 0x7ffd394e85c2 = e</code>, which is 13 in decimal, the exact length of the string.</p>

<p>Therefore the initial layout is</p>

<pre><code>Initial layout
0x7ffd394e85c2               0x7ffd394e85d0
str2                         str1
|                            | 
|                            |
V                            V
s t a c k o v e r f l o w \0 s t a c k o v e r f l o w w w w w w w \0
</code></pre>

<p>When the string is being copied from <code>str1</code> to <code>str2</code>, <code>strcpy</code> will align and copy strings as follows. Here the end of <code>str2</code> buffer gets violated.</p>

<pre><code>When being copied
0x7ffd394e85c2               0x7ffd394e85d0
str2                         str1
|                            | 
|                            |
V                            V
s t a c k o v e r f l o w \0 s t a c k o v e r f l o w w w w w w w \0
s t a c k o v e r f l o w w  w w w w w \0
</code></pre>

<p>After copy the state is as follows</p>

<pre><code>After copy
0x7ffd394e85c2              0x7ffd394e85d0
str2                        str1
|                           | 
|                           |
V                           V
s t a c k o v e r f l o w w w w w w w \0 v e r f l o w w w w w w w \0
</code></pre>

<p>Now <code>str1</code> points to the beginning of the buffer starting with a 'w' and it has five consecutive 'w's until it reaches '\0'. Therefore the C string pointed by <code>str1</code> now is ""wwwww"", as you see in your output.</p>

<p><strong>Note</strong> that this is for my system where I get five consecutive 'w's. In other systems, the compiler may generate code which has a few blank bytes between the end of <code>str2</code> and the beginning of <code>str1</code>, therefore they can have a varying number of 'w's. Also, note that, as this is an undefined behaviour, and the storage layout of the two strings are not defined, the output can be anything.</p>
",0
51993847,51993736,3,"<p>Strings in C are null-terminated it means that you need one more byte at the end of the character array to mark it's termination. otherwise you cannot find where the string actually ends.</p>

<p>For example,
If I have string <code>""aba""</code> it would be like that at the memory:</p>

<p><code>'a','b','a','\0'</code></p>

<p>So you should define you're array as:</p>

<pre><code>char ls[5][4]={""aba"",""bab"",""dad"",""cac"",""lal""};
</code></pre>
",0
52323313,52323002,1,"<p>The logic for your borrow code is broken. When <code>x[i]</code> is greater than <code>y[i]</code> and <code>i</code> is not <code>n-1</code>, you go into this code that looks for a non-zero <code>x[j]</code> to borrow from. But the higher-indexed <code>x[j]</code> were already operated on (because <code>i</code> runs from 15 to 0). You should not be borrowing from them.</p>

<p>Usually subtraction proceeds from the low digits to the high digits (<code>i</code> from 0 to 15). Then, if we need to borrow, we calculate the current digit as if we borrowed, set a counter or flag to remember that we borrowed, and go on to the next digit, incorporating the borrow into the calculations for it.</p>

<p>Alternately, if working from high to low, then, when a borrow is needed, we need to take it from the previously calculated digits (in <code>difference</code>), not from the minuend (<code>x</code>). (And the code for that would have to be alert for running off the high end.)</p>
",1
52773111,52772739,1,"<p>One option is to use a variable like <code>pad</code> in this code:</p>

<pre><code>const char *pad = """";
printf(""Open lockers:"");
for (int i = 0; i &lt; sizeof(lockers); i++)
{
    if (lockers[i])
    {
        printf(""%s %d"", pad, i + 1);
        pad = "","";
    }
}
putchar('.');
</code></pre>

<p>Another variant is:</p>

<pre><code>const char *pad = "":"";
printf(""Open lockers"");
for (int i = 0; i &lt; sizeof(lockers); i++)
{
    if (lockers[i])
    {
        printf(""%s %d"", pad, i + 1);
        pad = "","";
    }
}
putchar('.');
</code></pre>

<p>Note that <code>sizeof(lockers)</code> only works if <code>sizeof(lockers[0]) == 1</code>.  I left it because that's what you used, but I'd normally have a variable set to the maximum value and use that in the loop.</p>
",0
59262673,59262591,2,"<p>You probably want something like this:</p>

<pre><code>char request = message[0];
...
char username[12 + 1];             // + 1 for the string terminator
...
memcpy(username, message + 1, 12);
username[12] = 0;                  // put the string terminator
</code></pre>

<p>or even simply:</p>

<pre><code>strcpy(username, message + 1);
</code></pre>

<p>provided the username is NUL terminated. The latter aproach is dangerous though because if the message is incorrect, yoo might get a buffer overflow. This kind of weakness has been exploited in real world in the past.</p>
",2
54375066,54374711,1,"<p>I suspect this is homework to teach how to approach problems with <a href=""https://www.khanacademy.org/computing/computer-science/algorithms/merge-sort/a/divide-and-conquer-algorithms"" rel=""nofollow noreferrer"">Divide and Conquer</a>. This splits a problem up into two simpler subproblems which are then solved recursively. It's usually useful for sorting and searching.</p>

<p>Simply finding the smallest element in a list is overkill, it's O(nlogn) where a simple loop would be O(n), but it's teaching the technique. I hope.</p>

<p>In this case you find the smallest element of an array by splitting it in two halves, finding the smallest element of those halves, and then taking minimum of those. You keep splitting until you have just one element, that terminates the recursion.</p>

<p><a href=""https://stackoverflow.com/a/54375015/14660"">@chux already wrote the code</a>, there's no need for me to repeat that.</p>

<p>Why they want you to do it starting from a certain index doesn't make a lot of sense. I suspect what you're really supposed to do is use the midpoint to split the array in half and recurse like so...</p>

<pre><code>int findMin(int arr[], int start, int len) {
  assert(len &gt; 0);
  if(len == 1 ) {
    return arr[start];
  }
  int mid = len/2;
  int left_min = findMin(arr, start, mid);
  int right_min = findMin(arr, mid, len - mid);
  return left_min &lt; right_min ? left_min : right_min;
}

int main(void) {
  int array[7]= {23,17,8,7,9,32,56};
  printf(""%d\n"", findMin(array, 0, 7));
}
</code></pre>

<p>This avoids having to do pointer arithmetic. Pointer arithmetic is generally faster and simpler, but often it doesn't get taught until later.</p>
",1
54375015,54374711,2,"<p><code>mid</code> is never updated.</p>

<p>Code ""works"" with the test case by luck.</p>

<hr>

<blockquote>
  <p>This needs to be done recursively without using loops.</p>
</blockquote>

<p>Of course recursion is not required, nor advisable, to find the min <code>int</code>.</p>

<hr>

<p>Although called <code>mid</code>, the <code>findMinpos(arr, mid, len-1)</code> implies code will call <code>findMinpos()</code> N times (N is the original array element count) <strong>and</strong> makes for a recursion depth O(N).</p>

<p>Such linear use of recursion, give recursions a bad name.</p>

<p>Instead, halve the problem each <code>findMinpos</code> call.</p>

<pre><code>int findMinpos_alt(int arr[], int len){
  assert(len &gt; 0);
  if(len == 1 ) {
    return arr[0];
  }
  int left_len = len/2
  int left_min =  findMinpos_alt(arr, left_len);
  int right_min =  findMinpos_alt(arr + left_len, len - left_len);
  return left_min &lt; right_min ? left_min : right_min;
}
</code></pre>

<p>This calls the function N times, yet the recursion depth is O(log(N)).</p>

<hr>

<p>More advanced code would use</p>

<pre><code>int findMinpos_alt2(const int arr[], size_t len);
</code></pre>
",0
52570023,52569955,1,"<p>The string literal <code>""  1 2 Hello    ""</code> is stored in read-only memory. Copy it first before attempting to write '\0' into it, and the problem will go away. So e.g., just replace this:</p>

<pre><code>char* final = string;
</code></pre>

<p>with this:</p>

<pre><code>char* final = strdup(string);
</code></pre>

<p>Edit 1: Upon considering this in more detail, I realized you also do a leading trim before trailing trim. Since you are moving the pointer, the allocation needs to happen <strong>after</strong> the leading trim, or the caller will not be able to free the memory. Here's a complete solution that shouldn't have any errors:</p>

<pre><code>char *removeSpaces(const char *string) {

    while(isspace((unsigned char)string[0]))
        string++;
    char *final = strdup(string);
    int length = strlen(final);
    while(length &gt; 0 &amp;&amp; isspace((unsigned char)final[length-1]))
        length--;
    final[length-1] = '\0';
    return final;
}
</code></pre>

<p>Edit 2: While I would not recommend it in this case, it might be useful to be aware that if the variable was declared like this:</p>

<pre><code>char word[] = ""  1 2 Hello    "";
</code></pre>

<p>It would have been in writable memory, and the problem would also not exist. Thanks to <a href=""https://stackoverflow.com/users/25324/pmg"">pmg</a> for the idea.</p>

<p>The reason why it is not a good approach is that you are expecting the callers to the function to always provide writable strings, and that you will modify them. A function that returns a duplicate is a much better approach in general.</p>

<p>(Don't forget to free() the result afterwards!)</p>
",7
52586865,52586781,0,"<p>You are printing:</p>

<pre><code>printf(""%d"",distance);
</code></pre>

<p>instead I think you mean:</p>

<pre><code>printf(""%d"",total_distance);
</code></pre>

<p>before this you should also initialize <code>total_distance</code> to 0.</p>
",3
53765230,53762156,0,"<p>Consider the following example:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;

typedef struct {
    size_t  num;    /* Number of ints in array */
    size_t  max;    /* Number of ints allocated for */
    int    *array;
} intarray;
#define  INTARRAY_INIT  { 0, 0, NULL }

/* Discard an intarray. */
void intarray_free(intarray *iarr)
{
    if (iarr) {
        free(iarr-&gt;array); /* Note: free(NULL) is safe to do. */
        iarr-&gt;num = 0;
        iarr-&gt;max = 0;
        iarr-&gt;array = NULL;
    }
}

/* Ensure there is room for at least 'more' additional ints in the intarray. */
void intarray_need(intarray *iarr, const size_t  more)
{
    int    *array;
    size_t  max;

    /* No intarray specified? */
    if (!iarr) {
        fprintf(stderr, ""intarray_need(): iarr == NULL!\n"");
        exit(EXIT_FAILURE);
    }

    /* Calculate size needed. */
    max = iarr-&gt;num + more;

    /* Array already large enough? */
    if (iarr-&gt;max &gt;= max)
        return;

    /* Growth policy: increase allocated size,
       to avoid reallocating in too small chunks. */
    if (max &lt; 8) {
        /* Always at least 8 ints. */
        max = 8;  
    } else
    if (max &lt; 524288) {
        /* Grow by 50% up to 524288. */
        max = (3 * max) / 2;
    } else {
        /* Round up to next multiple of 262144, less 32. */
        max = (max | 262143) + 262145 - 32;
    }

    /* Allocate. */
    array = realloc(iarr-&gt;array, max * sizeof iarr-&gt;array[0]);
    if (!array) {
        fprintf(stderr, ""intarray_need(): Out of memory; num == %zu, more == %zu, new max == %zu.\n"",
                        iarr-&gt;num, more, max);
        exit(EXIT_FAILURE);
    }

    iarr-&gt;max   = max;
    iarr-&gt;array = array;
}

/* Add one int to the intarray. */
void intarray_add(intarray *iarr, const int val)
{
    /* We need room for at least one more int. */
    intarray_need(iarr, 1);

    /* Append. */
    iarr-&gt;array[iarr-&gt;num++] = val;
}

int main(void)
{
    intarray  data = INTARRAY_INIT;
    size_t    i;
    int       val;

    /* Parse ints from standard input. */
    while (scanf(""%d"", &amp;val) == 1) {
        intarray_add(&amp;data, val);
    }

    /* Why did the scan fail? */
    if (ferror(stdin)) {
        fprintf(stderr, ""Error reading from standard input.\n"");
        exit(EXIT_FAILURE);
    } else
    if (feof(stdin)) {
        printf(""All input converted successfully.\n"");
        /* Fall through */
    } else {
        fprintf(stderr, ""Warning: Could not parse all standard input.\n"");
        /* Fall through */
    }

    printf(""Read %zu ints:\n"", data.num);
    for (i = 0; i &lt; data.num; i++)
        printf(""%12d\n"", data.array[i]);

    intarray_free(&amp;data);

    return EXIT_SUCCESS;
}
</code></pre>

<p>The <code>intarray</code> type is a structure type, which contains members <code>max</code>, <code>num</code>, and <code>array</code>. It is initialized to known values using <code>INTARRAY_INIT</code>.</p>

<p>The <code>intarray_free()</code> function discards an intarray.</p>

<p>The <code>intarray_more()</code> function is the interesting one. It ensures there is enough memory allocated for the specified number of additional ints.  Note that <code>realloc(NULL, SIZE)</code> is equivalent to <code>malloc(SIZE)</code>; because the structure was properly initialized (<code>INTARRAY_INIT</code>), we can just reallocate it to whatever size we might need.</p>

<p>The resize policy shown here is only an example, and is roughly typical of what I myself might use. It has three parts: a minimum allocation size, an exponential growth part, and linear growth part.  The intent is that the growth works for both small and very large arrays without huge drawbacks.  The really large linear growth part (<code>max = (max | 262143) + 262145 - 8;</code>) is a curiosity, as it rounds up to the next multiple of 2<sup>18</sup> = 262144 less 8 ints using simple binary operations: the idea is to allow the C library to allocate a chunk that is a multiple of 2<sup>18</sup>, including its own overhead. The underlying hope is that the OS can do that (allocation in multiples of a large power of two, specifically) more efficiently than other sizes. Think of it as an example of what you might see in real life; not what you should do.</p>

<p>While <code>intarray_add()</code> adds just one int at a time, you can easily write another function that adds several at the time; just remember to call <code>intarray_need()</code> first to ensure there is enough memory allocated for the new integers.</p>

<p>If you compile and run the program, it will read integers from standard input until you supply non-integer input, or end of input is encountered (if you e.g. redirect input from a file).</p>

<p>For example, if you run the program as <code>program.exe &lt; file.txt</code> or <code>./program &lt; file.txt</code> with <code>file</code> containing</p>

<pre><code>1 2
3 4 5
-6 -7
-8
9
</code></pre>

<p>then the output is</p>

<pre><code>All input converted successfully.
Read 9 ints:
       1
       2
       3
       4
       5
      -6
      -7
      -8
       9
</code></pre>

<p>The only limitation is the amount of memory available for the program.</p>

<p>There is also one bug left in the program: Possible overflow when calculating <code>max</code> in <code>intarray_need()</code>, and the number of bytes to be reallocated (the second parameter to <code>realloc()</code>). These can be checked, because all parameters are of type <code>size_t</code>, which is some unsigned integer type; and in C, unsigned integer types use modulo arithmetic (that is, as if all computations were made <em>modulo</em> <code>UINT_MAX + 1</code>).</p>
",0
52650549,52649982,2,"<p>You have:</p>

<pre><code>/* function to obtain hours worked for employees */
void getHours (long int clock_number[]);
float hours_worked[]; /* array for hours worked */
{
    printf(""Enter the number of hours worked for employee #%d: "", d + 1);
    scanf(""%f"", &amp;hours_worked[d]);
    return (getHours);
}
</code></pre>

<p>The <code>void getHours(¡­)</code> line ends with a semicolon; that is a function declaration.</p>

<p>The <code>float hours_worked[];</code> line is an array definition, but it doesn't specify the array size and is not prefixed with <code>extern</code> so it is invalid.</p>

<p>The <code>{</code> therefore has no business in the code; it isn't part of a function definition.</p>

<p>As a function definition, there's no <code>d</code> in scope, and returning a pointer to the function isn't going to work (wrong type, amongst other things ¡ª the function isn't supposed to return a value at all!), and there's no way to make the data available to the calling code.</p>

<p>You probably need:</p>

<pre><code>/* function to obtain hours worked for one employee */
float getHours (long clock_number)
{
    float hours_worked;
    printf(""Enter the number of hours worked for employee #%ld: "", clock_number);
    scanf(""%f"", &amp;hours_worked);
    return (hours_worked);
}
</code></pre>

<p>There will then be changes required to how you use this function.  I've not even looked at the code beyond it.</p>
",1
52818218,52817390,1,"<p>This</p>

<pre><code>     scanf(..., name);
</code></pre>

<p>scans input to where <code>name</code> points to. <code>name</code> is not initialised to point anywhere, so the scanner scans into invalid memory, and by doing so invokes undefined behaviour. Anything can happen from then on. The program might crash or not, immediately or later.</p>

<p>The same applies to this statement</p>

<pre><code>    scanf(..., name2);
</code></pre>

<p><a href=""https://stackoverflow.com/q/37549594/694576"">More about this unfortunately seemingly common mistake here.</a></p>

<hr>

<p>Aside of the above issue this <code>"" %[^\n]s""</code> does not what you expect. As it reads a string and then waits for an <code>s</code>.</p>

<p>It should just be <code>"" %[^\n]""</code>.</p>
",0
52796334,52794924,0,"<p>This won't be what your instructor had in mind, but it (more or less) meets the letter of the requirements.  It waits for the user to type <code>R</code> or <code>S</code> (more accurately, <code>R</code> or something else) and compiles some code using conditional preprocessing based on what the user typed.</p>

<h3><code>square_circle.h</code></h3>

<pre><code>#define RADIUS 'R'
#define PI (355.0 / 113.0)
#define CIRCLE(X) (PI*(X)*(X))
#define SIDE 'S'
#define SQ(X) ((X)*(X)) 
</code></pre>

<p>That's a much better approximation to ¦Ð than you might think ¡ª it is accurate to 7 decimal digits and only erroneous by 3 counts in the 7th decimal place ¡ª?<code>bc -l</code> reports the value is <code>3.14159292035398230088</code> compared with  <code>3.14159265358979323844</code> (result of <code>4*a(1)</code>).</p>

<h3><code>area.c</code></h3>

<p>This code is compiled with either <code>-DAREA_CIRCLE</code> or without, and depending on that, will calculate the area of a circle or of a square when it is compiled and run.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include ""square_circle.h""

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        fprintf(stderr, ""Usage: %s length\n"", argv[0]);
        return 1;
    }

    double d;
    if ((d = strtod(argv[1], 0)) == 0.0)
    {
        fprintf(stderr, ""Invalid argument given to %s\n"", argv[0]);
        return 1;
    }
#ifdef AREA_CIRCLE
    printf(""Your shape is a circle with radius %g and area %g\n"", d, CIRCLE(d));
#else
    printf(""Your shape is a square with sides %g and area %g\n"", d, SQ(d));
#endif
    return 0;
}
</code></pre>

<h3><code>chooser.c</code></h3>

<p>This is the program the user runs directly and enters the data into.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include ""square_circle.h""

int main(void)
{
    double number;
    char choice;    

    printf(""Please type a number: "");
    if (scanf(""%lf"", &amp;number) != 1)
    {
        fprintf(stderr, ""That wasn't a number!\n"");
        return 1;
    }

    printf(""What kind of shape do you want type R or S: "");
    if (scanf("" %c"", &amp;choice) != 1)
    {
        fprintf(stderr, ""That wasn't recognized\n"");
        return 1;
    }

    char cmd[1000];
    if (choice == RADIUS)
        snprintf(cmd, sizeof(cmd), ""gcc -o area area.c -DAREA_CIRCLE"");
    else
        snprintf(cmd, sizeof(cmd), ""gcc -o area area.c -DAREA_SQUARE"");
    system(cmd);
    snprintf(cmd, sizeof(cmd), ""./area %g"", number);
    system(cmd);
    return 0;
}
</code></pre>

<p>Note that using <code>%g</code> for the formats works well here; it doesn't print superfluous trailing zeros and does format both really big and really small numbers sanely too.</p>

<p>The code does assume you're using GCC as the compiler; you can change <code>gcc</code> to your preferred compiler name (twice).</p>

<p>Example runs:</p>

<pre><code>$ ./chooser
Please type a number: 2.34
What kind of shape do you want type R or S: R
Your shape is a circle with radius 2.34 and area 17.2021
$ ./chooser
Please type a number: 2.34
What kind of shape do you want type R or S: S
Your shape is a square with sides 2.34 and area 5.4756
$ ./chooser
Please type a number: 9999 
What kind of shape do you want type R or S: R
Your shape is a circle with radius 9999 and area 3.14096e+08
$ ./chooser
Please type a number: 0.00007654
What kind of shape do you want type R or S: S
Your shape is a square with sides 7.654e-05 and area 5.85837e-09
$
</code></pre>
",0
52722646,52722322,1,"<p>Assuming you have the datatype of the array matched with what the functions expect, you have two issues here.</p>

<p>The first is in your printing function:</p>

<pre><code>void print_statistics(float mean, int maximum, int minimum){
  printf( ""The average is: %f\n"", mean );
  printf( ""The maximum is: %f\n"", maximum  );
  printf( ""The minimum is: %f\n"", minimum  );
}
</code></pre>

<p><code>minimum</code> and <code>maximum</code> have type <code>int</code>, but you're using the <code>%f</code> format specifier, which expects a <code>double</code>.  Using the wrong format specifier invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>Use <code>%d</code> to print = an <code>int</code>:</p>

<pre><code>  printf( ""The maximum is: %d\n"", maximum  );
  printf( ""The minimum is: %d\n"", minimum  );
</code></pre>

<p>The second problem is in <code>find_minimum</code> and <code>find_maximum</code>.  Both functions enter a while loop with <code>while ( i &lt; length )</code> without initializing <code>i</code>.  This means its value is indeterminate.  Using this value to index an array will likely read past the end of the array, again invoking undefined behavior.</p>

<p>Initialize <code>i</code> to 0 in both functions.</p>

<p>Once you do that, you'll get the following results:</p>

<pre class=""lang-none prettyprint-override""><code>The average is: 93.000000
The maximum is: 250
The minimum is: 2
</code></pre>
",0
52722407,52722322,4,"<ol>
<li><p>All automatic storage duration variables need to be initialised in C.</p></li>
<li><p>Your divisions are <em>all</em> in <em>integer arithmetic</em>, which explains the whole-number results. Use the <code>1.f * sum / count</code> idiom to force evaluation in floating point.</p></li>
<li><p>The <em>format specifier</em> for an <code>int</code> in <code>printf</code> is <code>%d</code>. <code>%f</code> is for a <code>float</code> or <code>double</code>.</p></li>
<li><p>Whilst being potentially valid in principle, fashioning an <code>int</code> array from a array of <code>unsigned char</code> values opens you up to a lot of potential bugs and undefined behaviour. In particular, the alignment of the <code>unsigned char</code> array might not be appropriate for an <code>int</code> on your platform, and you need to calculate the number of elements carefully. You don't appear to do that.</p></li>
<li><p>(Don't use leading double underscores for any symbol. They are reserved.)</p></li>
</ol>
",6
52732933,52731535,2,"<p>Quite apart from the <a href=""https://stackoverflow.com/a/52731584/15168"">memory allocation</a> issue identified by <a href=""https://stackoverflow.com/users/68587/john-kugelman"">John Kugelman</a>, you have at least one more major problem¡­</p>

<h3>Another problem</h3>

<p>Note that the lines like these two:</p>

<pre><code>game-&gt;players[0] = (Player*)malloc(sizeof(Player));
game-&gt;players[0] = &amp;(Player){0, NULL};
</code></pre>

<p>carefully leak the allocated memory.  You replace the just allocated pointer with a pointer to the compound literal, which leaves you no way to free the allocated memory.  It is perfectly legitimate to modify the compound literal as long as it doesn't go out of scope ¡ª but it does go out of scope when the function returns, so you not only leak memory but you also modify data you no longer own if you ever change the player information.</p>

<p>You probably want this instead, which copies the compound literal to the allocated memory:</p>

<pre><code>game-&gt;players[0] = (Player*)malloc(sizeof(Player));
*game-&gt;players[0] = (Player){0, NULL};
</code></pre>

<p>I wouldn't be surprised to find there are other issues lurking, but the code is not an MCVE (<a href=""https://stackoverflow.com/help/mcve"">Minimal, Complete, Verifiable Example</a>) so it is hard to be sure.</p>
",0
52731584,52731535,3,"<pre><code>typedef struct _game {
    ...
} *Game;
</code></pre>

<p><code>Game</code> is defined as an alias for <code>struct _game *</code>, a pointer.</p>

<pre><code>Game game = (Game)malloc(sizeof(Game));
</code></pre>

<p>That means that <code>sizeof(Game)</code> is the size of a pointer and not the entire struct. A pointer is smaller than the entire struct, so it's not enough memory. Writing to <code>-&gt;players</code> accesses memory outside of the malloc'ed area which causes the illegal operation error.</p>

<p>A correct allocation would be:</p>

<pre><code>Game game = malloc(sizeof *game);
</code></pre>

<p>Lesson learned: use <code>p = malloc(sizeof *p)</code> rather than <code>p = malloc(sizeof(Type))</code> to avoid this kind of mistake. The compiler won't catch a size mismatch. <code>sizeof *p</code> will always be the right size, even if <code>p</code> changes type.</p>

<p>And if possible, get rid of the <code>*</code> in the definition of <code>Game</code>! It's quite out of place.</p>
",2
52785008,52784022,0,"<p>Since the value is <em>below</em> 999, 999 <em>not</em> included, just read the integer, and print it with <code>0.%03d...</code>:</p>

<pre><code>int num;

scanf(""%d"", &amp;num);
printf(""0.%03d...\n"", num);
</code></pre>

<p>The conversion specification <code>%03d</code> will print the given integer in base-10, with <em>leading zeroes prepended</em> so that it is at least 3 characters wide. For 3, it will print <code>003</code>, for <code>10</code> it will print <code>010</code> and for <code>976</code> it will print <code>976</code>.</p>

<p>What you specifically <em>cannot do this with</em> are <em>floats</em>. Floats in your computer are <em>binary numbers</em> and they cannot precisely produce decimal fractions... nor can they do infinite precision.</p>
",1
52807343,52805318,0,"<p>The code in the question should not compile without at least a diagnostic about 'too many initializers' for the union variable.  You might also get a warning about a <code>useless storage class specifier in empty declaration</code> because the <code>typedef</code> doesn't actually define an alias for <code>union x</code>.</p>

<p>Suppose you revised the code to use designated initializers, like this:</p>

<pre><code>#include &lt;stdio.h&gt;

union x
{
    int y;
    char x[6];
};

int main(void)
{
    union x  first = { .y = 4, .x = ""AAAAA"" };
    printf(""%d\n"", first.y);
    printf(""%s\n"", first.x);
    return 0;
}
</code></pre>

<p>This would compile and run, but with the compiler set to fussy, you might get warnings like <code>warning: initialized field overwritten [-Woverride-init]</code>.</p>

<p>Note that there is one less <code>A</code> in the initializer for <code>.x</code> shown above than in the original. That ensures that the value is a (null-terminated) string, not just an array of bytes.  In this context, the designated initializer for <code>.x</code> overrides the designated initializer for <code>.y</code>, and therefore the value in <code>.x</code> is fully valid.  The output I got, for example, was:</p>

<pre><code>1094795585
AAAAA
</code></pre>

<p>The decimal number corresponds to hex <code>0x41414141</code> as might be expected.</p>

<p>Note that I removed the pointless <code>typedef</code>.  My default compilation rules wouldn't accept the code; I had to cancel <code>-Werror</code> and <code>-Wextra</code> options to get it to compile.  The original code compiled with warnings without the <code>-Werror</code> to convert the warnings into error.  Even adding <code>-pedantic</code> didn't trigger an error for the extra initializer (though the warning was always given, as required by the standard).</p>
",0
55563067,55562768,1,"<p>There is no such thing as type-generic function pointers in C.</p>

<p>However, you could have a struct of pointers for different relevant types, e.g.</p>

<pre><code>
typedef enum  { 
    USE_FLOAT = 0,
    USE_DOUBLE = 1, 
    // USE_LONG_DOUBLE = 2   // maybe you have this one as well
} complex_component_type_selector;

typedef struct {
    union {
        float complex (*float_)(float complex);
        double complex(*double_)(double complex);
    } function_ptr;
    complex_component_type_selector component_type;
} variant_function;

typedef union {
   union {
       float complex float_;
       double complex double_
   } datum;
   complex_component_type_selector component_type;
} variant_complex_datum;

</code></pre>

<p>and with that you can pass <code>variant_complex_function</code> along with a <code>variant_complex_datum</code> to sort-of-kind-of get what you wanted.</p>

<p>... Now, my suggestion is a bit crass and half-assed implementation of some <a href=""https://en.wikipedia.org/wiki/Variant_type"" rel=""nofollow noreferrer"">variants</a>. I'm sure there are libraries for C which are more sophisticated and comprehensive... oh yeah, here you go:</p>

<p><a href=""https://stackoverflow.com/questions/2734808/variant-datatype-library-for-c"">Variant datatype library for C</a></p>
",0
55564257,55562768,0,"<blockquote>
  <p>I believe the code behaves this way because the tgmath functions are implemented as functional macros and those only expand if the name is followed by ().</p>
</blockquote>

<p>Yes</p>

<blockquote>
  <p>Is there any way to get around that ... ?</p>
</blockquote>

<p>No direct way around it. </p>

<p>Using <code>&lt;tgmath.h&gt;</code>, code cannot extract the function that would be called with an object of some type.</p>

<p>You could write your own function set using <code>_Generic</code>, yet I think you know that and are trying to avoid it.</p>
",0
58352401,58352034,2,"<p>In this line</p>

<pre><code> for (i=1; progress_num[i]&gt;0; i++) {
</code></pre>

<p>the code does not compare to the previous value, but to the current, which isn't even set. </p>

<p>Change it to be</p>

<pre><code> for (i=1; progress_num[i-1]&gt;0; i++) {
</code></pre>

<p>Also adjust the array <code>progress_num</code>'s size, or add a test to not write beyond its bounds.</p>

<p>As well take care <code>i * 1000000</code> does not overflow <code>int</code>.</p>

<p>BTW: In C it has to be <code>int main(void)</code> at least.</p>
",1
53419279,53419230,1,"<p>This is just printing the address of the array age as a decimal integer (actually it introduces undefined behavior);</p>

<pre><code>printf(""Age: %d\n"", age);
</code></pre>

<p>Try this</p>

<pre><code>printf(""Age: %d\n"", age[0]);
</code></pre>
",3
53028205,53028177,0,"<pre><code>while (!eof(filePtr))
    fscanf(filePtr, ""%d %d %d %d"", &amp;option, &amp;mainMemSize, &amp;cacheSize, &amp;blockSize);
</code></pre>

<p>There are two things wrong here:</p>

<ol>
<li><p>The <code>eof</code> function doesn't predict the future. You can't use it to predict that a future read will fail and thereby avoid that read. Instead, check if the read actually succeeded or failed and, if it failed, stop.</p></li>
<li><p>This repeats the <code>fscanf</code> operation over and over, each time overwriting the previous results. You don't want to call <code>fscanf</code> again after it returns, so the loop should not be here.</p></li>
</ol>
",1
55834147,55834068,3,"<p>You can use <code>sprintf</code> to build the filename:</p>

<pre><code>sprintf(filename, ""book%03d.txt"", num);
</code></pre>

<p>This will create files named booknnn.txt, where <em>nnn</em> is the number in question padded with 0's, ex. book001.txt, book002.txt.</p>
",0
53184335,53184088,0,"<p>This code doesn't work.</p>

<p>If it is compiled with warnings, there's <em>lots</em> of warnings letting the user know.</p>

<p>The reason it can actually compile is that mostly the manipulation involves pointers. Pointers are just numbers, so it's possible to put a char** pointer into the space for a char*.  This doesn't help the program actually work of course.</p>

<p>The C Standard doesn't define these operations as errors, so the compiler lets them pass.</p>

<pre><code>$ gcc -g -Wall  example.c -o example
m.c: In function ¡®main¡¯:
m.c:7:12: warning: initialization from incompatible pointer type [-Wincompatible-pointer-types]
  char **x= (char *)malloc(1000);
            ^
m.c:11:10: warning: format ¡®%s¡¯ expects argument of type ¡®char *¡¯, but argument 2 has type ¡®char **¡¯ [-Wformat=]
 printf(""%s"",x); //random bits in memory
         ~^
m.c:13:10: warning: format ¡®%c¡¯ expects argument of type ¡®int¡¯, but argument 2 has type ¡®char **¡¯ [-Wformat=]
 printf(""%c"",x); //random bits in memory
         ~^
m.c:15:5: warning: assignment makes pointer from integer without a cast [-Wint-conversion]
 x[0]='w';
     ^
m.c:17:5: warning: assignment makes pointer from integer without a cast [-Wint-conversion]
 x[1]='t';
     ^
m.c:19:5: warning: assignment makes pointer from integer without a cast [-Wint-conversion]
 x[2]='f';
     ^
m.c:23:10: warning: format ¡®%c¡¯ expects argument of type ¡®int¡¯, but argument 2 has type ¡®char **¡¯ [-Wformat=]
 printf(""%c"",x); //random bits in memory
         ~^
m.c:25:10: warning: format ¡®%s¡¯ expects argument of type ¡®char *¡¯, but argument 2 has type ¡®char **¡¯ [-Wformat=]
 printf(""%s"",x); //w
</code></pre>
",0
53248673,53248523,1,"<p>I didn't test the code, but the main idea is something like this:</p>

<pre><code>while(ch != '\n')    // terminates if user hit enter
{
    ch = getchar();
    // if this is a backspace character, 
    // lower the index and delete the last char
    if(ch == 0x08){
       name[--i] = 0x00;
    }else{
       // other chars will increment the index and fill the current char buffer
       name[i++] = ch;
    }
}
</code></pre>

<p><strong>Late Edit:</strong></p>

<p>Sorry I understood the question wrong I guess. The correct answer would be this:</p>

<p>Suppose you entered this: <code>1235[0x08]4</code> into the terminal. </p>

<p>Your char array would be: </p>

<pre><code>[0x31, 0x02, 0x33, 0x35, 0x08, 0x34] 
</code></pre>

<p>And when you print it, it'll execute like this order and it'll print char by char. Likewise, <code>5</code> would be printed and backspaced so fast you wouldn't notice. </p>

<p>And here's another question that may give you some other idea that how backspace works in some environments:</p>

<p><a href=""https://stackoverflow.com/questions/6792812/the-backspace-escape-character-b-unexpected-behavior"">The &quot;backspace&quot; escape character &#39;\b&#39;: unexpected behavior?</a></p>
",1
53248676,53248523,2,"<p>Userspace C's stdio won't talk directly with the hardware. It'll talk with the OS. And the OS will usually do quite a bit of preprocessing on the keystrokes it receives before it sends them to an application. On a UNIX-like OS much of the preprocessing will be done by your terminal driver, which can be set to reset to raw mode in which case you will actually receive the backspace too. Playing with the terminal driver is not standardized by the C standard, though.</p>

<p>On Linux, I can do:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    char name[30], ch;
    int i = 0;
    printf(""Enter name: "");
    system(""stty raw"");
    while(ch != '\n' &amp;&amp; i &lt; sizeof(name))    // terminates if user hit enter
    {
        ch = getchar();
        name[i] = ch;
        i++;
    }
    name[i] = '\0';       // inserting null character at end
    printf(""Name: %s"", name);
    system(""stty sane""); //set some sane settings to the terminal
    return 0;
}
</code></pre>

<p>and then I get the raw characters (I need to type <code>shift+Enter</code> to send the <code>\n</code>).</p>
",1
56759481,56759412,2,"<pre><code>struct node *new1;
</code></pre>

<p>This allocates a local variable, probably on the stack, of type ""pointer to struct node"".</p>

<pre><code>new1 = (struct node*)malloc(sizeof(struct node));
</code></pre>

<p>This allocates a suitably-aligned chunk of memory large enough to hold a <code>struct node</code>, probably from the heap, and sets <code>new1</code> to point to that newly-allocated chunk. The chunk will remain allocated until the process terminates or the block is freed. The cast is not necessary.</p>
",4
56759496,56759412,0,"<p>Memory returned by <code>malloc</code> initially has no type.  When a pointer is then used to write to that memory, the memory (up to the size of the given type) becomes an object whose type is the type of the dereferenced pointer.</p>
",0
53186665,53183987,1,"<p>Try RAW sockets and <code>recvfrom()</code>. It should be pretty fast. Example:</p>

<pre><code>int fd = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
if (fd != -1)
{
    char buf[2345];
    struct sockaddr_in addr;

    for (int i = 0; i &lt; 10; i++)
    {
        socklen_t addrlen = sizeof(addr);
        int len = recvfrom(fd, buf, sizeof(buf), 0, (struct sockaddr*)&amp;addr, &amp;addrlen);
        printf(""len = %d\n"", len);
    }
    close(fd);
}
</code></pre>

<p>Example code receives all incoming TCP packets with IP headers. 
You can bind it to loopback-interface, if needed.
You must implement other filtering by yourself.</p>

<p>For binding to loopback-interface:</p>

<pre><code>struct ifreq ifr;

memset(&amp;ifr, 0, sizeof(ifr));
strncpy(ifr.ifr_name, ""lo"", sizeof(ifr.ifr_name));
setsockopt(fd, SOL_SOCKET, SO_BINDTODEVICE, &amp;ifr, sizeof(ifr));
</code></pre>
",1
56569243,56569205,2,"<p>Inside <code>clearField()</code>, you are indeed re-declaring the array with the same name as the argument, which makes no sense.</p>

<p>If you intended to assign to the argument, which makes sense, you can't repeat it's type like that.</p>

<p>Also, you cannot assign to arrays like that, most normal code would use either nested loops or a <code>memset()</code> call, I think.</p>

<p>Other strangenesses include the non-quoted <code>N</code> and <code>n</code> that you compare <code>start</code> against, and the repeated pointless function declarations inside the <code>if</code>.</p>

<p>It seems you really need to read up on basic C syntax and structure, you seem to want to repeat declarations when you actually need statements that do something (like calling a function).</p>
",0
53289549,53289515,3,"<p>You don't have any functions in your code, and Instructions can only appear in functions.</p>

<p>The following lines are Instructions, which must be in a function:</p>

<pre><code>LAMBDA-&gt;label='A';
LAMBDA-&gt;leftchild=NULL;
LAMBDA-&gt;rightchild=NULL;
</code></pre>

<hr>

<p>I recommend putting these instructions into a main function:</p>

<pre><code>typedef char labeltype;

typedef struct celltag{
labeltype label;
struct celltag* leftchild;
struct celltag* rightchild;
}celltype;

typedef celltype* BiTree;
typedef celltype* node;

int main(void)   /* This is where a function starts */
{
    node LAMBDA;

    printf(""Program Start\n"");
    LAMBDA-&gt;label='A';
    LAMBDA-&gt;leftchild=NULL;
    LAMBDA-&gt;rightchild=NULL;
    printf(""Program End\n"");
    return 0;
}    /* This is the end of the function */
</code></pre>
",1
53289559,53289515,1,"<p>In C language all executable code is written <em>inside functions</em>. You can't just write statements in the middle of the file. </p>

<p>At file level in C you can only write declarations. Everything in your code are declarations, until you get to the last three lines. The last three lines are not declarations. You can't write them at file level.</p>
",2
53400436,53398551,0,"<p>You've got an awful lot going on in one giant <code>main()</code> function. The instructions are pretty complicated: there are a number of things you need to do, each of which requires several steps. Doesn't trying to keep all the steps and sub-steps in your head at the same time make your head spin? There must be a better way, right?</p>

<p>The better way is: <strong>Break it down.</strong> That is, go through the instructions and make a list of the different tasks you need to accomplish to be able to process the files. For example, you need to be able to:</p>

<ul>
<li>read a line from a file</li>
<li>find the next word on a line</li>
<li>capitalize the first letter of a word</li>
<li>capitalize the last letter of a word</li>
<li>merge two lines</li>
</ul>

<p>...and so on. Wouldn't it be a whole lot easier to think about this problem if you didn't try to think about it all at once? It'd be nice if all the details were taken care of and you could just write a very high-level program that looks like this:</p>

<pre><code>while there are lines in both file1 and file2, do {
    read a line from file1 into line1
    read a line from file2 into line2
    merge line1 and line2 and save the result in line_out
    write line_out into file3
}
copy any remaining lines from file1 into file3
copy any remaining lines from file2 into file3
</code></pre>

<p>That seems pretty straightforward, doesn't it? It's clear that it does the fundamental behavior that's asked for: reading one line from each of two files, merging them, and writing them to the output. What you need to do is to write that program. Forget about the capitalization or mixing the words from the two lines together or any of that, <strong>but:</strong> when you write the program above, <strong>each of those steps should be a function call</strong>. So you'll write a function like:</p>

<pre><code>void readOneLine(FILE inputFile, char *line, int maxChars)
</code></pre>

<p>that reads a line from <code>inputFile</code> into <code>line</code>, making sure not to read more than <code>maxChars</code>. You can similarly create a <code>writeOneLine(FILE outputFile char *line)</code> function that writes a line into a file, and between those two functions you've already got most of what you need to write the program above.</p>

<p>Merging the lines in the way the requirements describe seems kinda complicated, so don't worry about that at first. Just write a placeholder function that takes two lines and gives you back a third line:</p>

<pre><code>void mergeLines(char *line1, char *line2, char *line_out)
</code></pre>

<p>Don't worry about the requirements right away. You could just concatenate the two lines to start, or even just set <code>line_out</code> to some constant string and ignore the two input lines at first. Once you <em>have</em> the <code>mergeLines()</code> function, you've got something you can use to write the program, and you can worry about merging the two input lines the right way later.</p>

<p>So, now you've got the tools you need to write the program outlined above. Do it. Your <code>main()</code> function will be very short -- just a bit of code to open the files and create some buffers for the lines you're going to read and write, and then about eight lines of code to do the actual work.</p>

<p>Once you've got that working, you can get to improving it. The main problem is that <code>mergeLines()</code> doesn't do the right thing at all, because we basically ignored it. And it's still pretty daunting -- how do you merge two lines and make sure the right words are capitalized in the right places? How do you even capitalize some words at the beginning and others at the end? Once again, you're going to <strong>break it down</strong> into smaller steps, and write a function for each one of those steps. So you might write a function to get the next word in a line, for example. And you might write one function that capitalizes the first letter of a word, and another one that capitalizes the last letter of a word. Or you might just write one function that capitalizes any letter you tell it to. There are no wrong answers here ¡ª it's just a matter of how you want to do it. The main thing is that whenever something seems even a little complicated, you break it down into smaller steps that are easier to manage, and then write the larger process in terms of those steps.</p>
",0
53861298,53859856,0,"<p>One thing I've realized is that it is often not worth the trouble to percolate fatal errors up the stack.  If something fails in a way that makes forward progress impossible, just end the program there.   I usually deal with it by creating an <code>error_exit</code> function that I can call from anywhere:</p>

<pre><code>void error_exit(int code, const char* message) {
  printf(""Error %d: %s\nExiting!\n"", code, message);
  cleanup();
  exit(code);
}

float* nested_function(int input, ...) {
  if (causes_hopeless_failure(input)) {
    error_exit(err_HOPELESS, ""invalid input to nested_function"");
  }
  //normal processing proceeds ...
  return valid_pointer;
}

int main() {
   float* vector = function_which_eventually_calls_nested_function();
   cleanup();
   return 0;
}
</code></pre>

<p>The <code>cleanup</code> function is used to deal with resources that don't get cleaned up correctly on program exit.  File handles and allocated buffers don't usually fall into this category. I generally use it for system configuration changes that need to be undone.</p>
",0
53904977,53859856,0,"<p>C has out-of-band error code handling, it's been in there since forever.</p>

<pre><code>#include &lt;errno.h&gt;

int do_something(char* data) {
   if ( data == 0 ) {
      errno = ENODATA;
      return 0;
   }
   ... do stuff ...
}
</code></pre>

<p>... in the caller ...</p>

<pre><code>int value = do_something( ""one"" );
if ( int errornum = errno ) {
   fprintf(""error (%d) could not do something: %s"", strerror( errornum ) );
   return; // or exit;
} 
</code></pre>

<p>if wishing to chain errors</p>

<pre><code>int value = do_something( ""one"" );
if ( int errornum = errno ) {
   fprintf(""error (%d) could not do something: %s"", strerror( errornum ) );
   errno = errornum;
   return; // or exit;
} 
</code></pre>

<p>Keep in mind that errno is reset by nearly every standard function call, so you need to capture it and then optionally set it again after you do whatever you want.</p>

<p>The reason errno is typically not used as heavily as it should be is probably becasue too many people are taught in-band error reporting (through special sentinels / values) first.  In addition, it takes more lines of code to properly check error codes.  That said, it is a far better solution, as you don't overload a return value with data and control information in the same variable.</p>

<p>There are already many error codes set, odd are you can reuse one for your needs, or pick one that's close enough</p>

<pre><code>1  EPERM Operation not permitted
2   ENOENT  No such file or directory
3   ESRCH   No such process
4   EINTR   Interrupted system call
5   EIO     I/O error
6   ENXIO   No such device or address
7   E2BIG   Argument list too long
8   ENOEXEC     Exec format error
9   EBADF   Bad file number
10  ECHILD  No child processes
11  EAGAIN  Try again
12  ENOMEM  Out of memory
13  EACCES  Permission denied
14  EFAULT  Bad address
15  ENOTBLK     Block device required
16  EBUSY   Device or resource busy
17  EEXIST  File exists
18  EXDEV   Cross-device link
19  ENODEV  No such device
20  ENOTDIR     Not a directory
21  EISDIR  Is a directory
22  EINVAL  Invalid argument
23  ENFILE  File table overflow
24  EMFILE  Too many open files
25  ENOTTY  Not a typewriter
26  ETXTBSY     Text file busy
27  EFBIG   File too large
28  ENOSPC  No space left on device
29  ESPIPE  Illegal seek
30  EROFS   Read-only file system
31  EMLINK  Too many links
32  EPIPE   Broken pipe
33  EDOM    Math argument out of domain of func
34  ERANGE  Math result not representable
35  EDEADLK     Resource deadlock would occur
36  ENAMETOOLONG    File name too long
37  ENOLCK  No record locks available
38  ENOSYS  Function not implemented
39  ENOTEMPTY   Directory not empty
40  ELOOP   Too many symbolic links encountered
42  ENOMSG  No message of desired type
43  EIDRM   Identifier removed
44  ECHRNG  Channel number out of range
45  EL2NSYNC    Level 2 not synchronized
46  EL3HLT  Level 3 halted
47  EL3RST  Level 3 reset
48  ELNRNG  Link number out of range
49  EUNATCH     Protocol driver not attached
50  ENOCSI  No CSI structure available
51  EL2HLT  Level 2 halted
52  EBADE   Invalid exchange
53  EBADR   Invalid request descriptor
54  EXFULL  Exchange full
55  ENOANO  No anode
56  EBADRQC     Invalid request code
57  EBADSLT     Invalid slot
59  EBFONT  Bad font file format
60  ENOSTR  Device not a stream
61  ENODATA     No data available
62  ETIME   Timer expired
63  ENOSR   Out of streams resources
64  ENONET  Machine is not on the network
65  ENOPKG  Package not installed
66  EREMOTE     Object is remote
67  ENOLINK     Link has been severed
68  EADV    Advertise error
69  ESRMNT  Srmount error
70  ECOMM   Communication error on send
71  EPROTO  Protocol error
72  EMULTIHOP   Multihop attempted
73  EDOTDOT     RFS specific error
74  EBADMSG     Not a data message
75  EOVERFLOW   Value too large for defined data type
76  ENOTUNIQ    Name not unique on network
77  EBADFD  File descriptor in bad state
78  EREMCHG     Remote address changed
79  ELIBACC     Can not access a needed shared library
80  ELIBBAD     Accessing a corrupted shared library
81  ELIBSCN     .lib section in a.out corrupted
82  ELIBMAX     Attempting to link in too many shared libraries
83  ELIBEXEC    Cannot exec a shared library directly
84  EILSEQ  Illegal byte sequence
85  ERESTART    Interrupted system call should be restarted
86  ESTRPIPE    Streams pipe error
87  EUSERS  Too many users
88  ENOTSOCK    Socket operation on non-socket
89  EDESTADDRREQ    Destination address required
90  EMSGSIZE    Message too long
91  EPROTOTYPE  Protocol wrong type for socket
92  ENOPROTOOPT     Protocol not available
93  EPROTONOSUPPORT     Protocol not supported
94  ESOCKTNOSUPPORT     Socket type not supported
95  EOPNOTSUPP  Operation not supported on transport endpoint
96  EPFNOSUPPORT    Protocol family not supported
97  EAFNOSUPPORT    Address family not supported by protocol
98  EADDRINUSE  Address already in use
99  EADDRNOTAVAIL   Cannot assign requested address
100     ENETDOWN    Network is down
101     ENETUNREACH     Network is unreachable
102     ENETRESET   Network dropped connection because of reset
103     ECONNABORTED    Software caused connection abort
104     ECONNRESET  Connection reset by peer
105     ENOBUFS     No buffer space available
106     EISCONN     Transport endpoint is already connected
107     ENOTCONN    Transport endpoint is not connected
108     ESHUTDOWN   Cannot send after transport endpoint shutdown
109     ETOOMANYREFS    Too many references: cannot splice
110     ETIMEDOUT   Connection timed out
111     ECONNREFUSED    Connection refused
112     EHOSTDOWN   Host is down
113     EHOSTUNREACH    No route to host
114     EALREADY    Operation already in progress
115     EINPROGRESS     Operation now in progress
116     ESTALE  Stale NFS file handle
117     EUCLEAN     Structure needs cleaning
118     ENOTNAM     Not a XENIX named type file
119     ENAVAIL     No XENIX semaphores available
120     EISNAM  Is a named type file
121     EREMOTEIO   Remote I/O error
122     EDQUOT  Quota exceeded
123     ENOMEDIUM   No medium found
124     EMEDIUMTYPE     Wrong medium type
125     ECANCELED   Operation Canceled
126     ENOKEY  Required key not available
127     EKEYEXPIRED     Key has expired
128     EKEYREVOKED     Key has been revoked
129     EKEYREJECTED    Key was rejected by service
130     EOWNERDEAD  Owner died
131     ENOTRECOVERABLE     State not recoverable
</code></pre>
",1
53860952,53859856,4,"<p>There are three common patterns of returning an error from a function:</p>

<ol>
<li><p>Have the function return an <code>int</code>, with specific values indicating success and failure</p>

<p>For example, returning <code>EXIT_SUCCESS</code> or <code>EXIT_FAILURE</code> from <code>main()</code> is the way the C standards recommend reporting success or failure of the entire process. (BSD variants have attempted to standardize some other codes; if your system has a <code>&lt;sysexits.h&gt;</code> header, you could use those. But do note that they are not ""standard"", just the closest thing we have to an agreement how a process can report error codes.)<br>&nbsp;</p></li>
<li><p>Reserve a specific return value for errors, and use a global or thread-local variable (usually <code>errno</code>) to describe the error</p>

<p>Most standard C library functions do this, with functions returning <code>int</code> using <code>-1</code> for the error, and functions returning a pointer using <code>NULL</code> to indicate the error.<br>&nbsp;</p></li>
<li><p>Use an extra parameter to point to an error indicator.</p>

<p>This approach is common with code and interfaces deriving from Fortran. Often, the error indicator is optional, and may be left <code>NULL</code> if the caller is not interested in whether the result is valid or not.<br>&nbsp;</p></li>
</ol>

<p>My own rules are simple:</p>

<ul>
<li><p>Prefer the second approach when writing a low-level library. It is familiar approach to those familiar with the standard C library.</p></li>
<li><p>Use the first approach for recoverable errors.</p>

<p>Often, I combine it with the second one, using <code>return 0;</code> for success, and <code>return errno;</code> or <code>return errno = EINVAL;</code> etc. for errors. (The last one first assigns <code>EINVAL</code> to <code>errno</code>, and then returns <code>EINVAL</code>.)</p></li>
<li><p>Use the third approach when error state should be retained over a number of operations, or there is a structure whose state errors affect.</p></li>
</ul>

<hr>

<p>Let's look how these methods differ in practice.</p>

<p>A very common thing to do is to parse command-line arguments as numbers. Let's look at a case where the arguments are to be used as <code>double</code>s, for some kind of calculation:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int     arg;
    double  val;    

    for (arg = 1; arg &lt; argc; arg++) {
        if (sscanf(argv[arg], ""%lf"", &amp;val) == 1) {
            printf(""argv[%d] = %.6f\n"", arg, val);
        } else {
            printf(""%s: Not a number.\n"", argv[arg]);
            exit(EXIT_FAILURE);
        }
    }

    return EXIT_SUCCESS;
}
</code></pre>

<p>The above uses <code>sscanf()</code> to convert a string. Unfortunately, it does not check for any trailing garbage, so it accepts for example <code>1.5k</code> as <code>1.5</code>. To avoid that, we can use a dummy character to detect trailing garbage:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    int     arg;
    double  val;
    char    dummy;

    for (arg = 1; arg &lt; argc; arg++) {
        if (sscanf(argv[arg], ""%lf %c"", &amp;val, &amp;dummy) == 1) {
            printf(""argv[%d] = %.6f\n"", arg, val);
        } else {
            printf(""%s: Not a number.\n"", argv[arg]);
            exit(EXIT_FAILURE);
        }
    }

    return EXIT_SUCCESS;
}
</code></pre>

<p>That works, because <code>sscanf()</code> returns the number of successful conversions, and we expect only the double conversion (<code>%lf</code>) to work, and the char conversion (<code>%c</code>) to fail.</p>

<p>Unfortunately, scanf family of functions does not check for overflow. If you supply a large enough number, it gets silently mangled. Not good.  To avoid that, we can use <code>strtod()</code>. To make use simpler, we can put it in a separate function, <code>parse_double()</code>. But, how should that return the value, and the possible error? Which one of the following to implement?</p>

<pre><code>/* Convert the initial double, returning the pointer to the rest of the
   string; or NULL if an error occurs. */
const char *parse_double(const char *src, double *to);

/* If the string contains exactly one double, convert it and return 0.
   Otherwise return a nonzero error code. */
int parse_double(const char *src, double *to);

/* Convert the string to a double as best as you can. If an error occurs, return 'errval'. */
double parse_double(const char *src, const double errval);
</code></pre>

<p>So, which one of these is the best?</p>

<p>The answer is, of course, <strong>it depends on the use case</strong>.</p>

<p>I've actually implemented all three (in separate programs), depending on which one has been the most appropriate one.</p>

<p>The first one is especially useful when the same function is used to parse input files, and/or we allow any number of doubles per parameter/line. It is very easy to use in a loop.</p>

<p>The second one is what I most often use in programs. Very often, I use</p>

<pre><code>typedef struct {
    double  x;
    double  y;
    double  z;
} vec3d;

int parse_vector(const char *src, vec3d *to)
{
    vec3d  temp;
    char   dummy;

    if (!src || !*src)
        return -1; /* NULL or empty string */

    if (sscanf(src, "" %lf %lf %lf %c"", &amp;temp.x, &amp;temp.y, &amp;temp.z, &amp;dummy) == 3 ||
        sscanf(src, "" %lf %*[.,:/] %lf %*[.,:/] %lf %c"", &amp;temp.x, &amp;temp.y, &amp;temp.z, &amp;dummy) == 3) {
        if (to)
            *to = temp;
        return 0;
    }

    return -1;
}
</code></pre>

<p>which allows one to specify a 3D vector on the command line using <code>1+2+3</code>, <code>1/2/3</code>, <code>1:2:3</code>, or even <code>'1 2 3'</code> or <code>""1 2 3""</code> (the quotes are needed to stop the shell from splitting it to three separate arguments).  It does not check for <code>double</code> overflow, so it is important to show the parsed vector in the output, so that the user can detect if their input was misparsed.</p>

<p>(The asterisk <code>*</code> in <code>%*[.,:/]</code> means the result of the conversion is not stored anywhere, and the conversion is not counted in the return value. <code>[</code> is a conversion specifier, ""converting"" any and all of the characters in the list, terminated with a <code>]</code> character. <code>[^</code> is the inverse, ""converting"" any and all characters <em>not</em> in the list.)</p>
",0
56089854,56089580,2,"<p>The code <code>top new_node=(top)malloc(sizeof(top));</code> allocates enough space for a <code>top</code>, which is a pointer to <code>struct person</code>. However, the space is going to be used to hold <code>struct person</code>, and therefore it must allocate enough space for <code>struct person</code>. Therefore, correct code for this is:</p>

<pre><code> top new_node=(top)malloc(sizeof(struct person));
</code></pre>

<p>Additionally:</p>

<ul>
<li>Using <code>sizeof *new_node</code> automatically allocates enough space for whatever new_node points to, even if the type of <code>new_node</code> is changed as the code is edited.</li>
<li>In C, there is no need to cast the type of <code>malloc</code>. This code can be <code>top new_node = malloc(sizeof *new_node);</code>.</li>
<li>Consider using a different name for a pointer to <code>struct person</code>, instead of <code>top</code>. It is not always the top of the stack.</li>
</ul>
",0
53422366,53422329,1,"<pre><code>#define mypi1 3.14
float mypi2 = 3.14;
</code></pre>

<p>The first of those is a <code>double</code> type, the second is a <code>double</code> coerced into a <code>float</code>.</p>

<p>The expression <code>mypi1==mypi2</code> will first convert the <code>float</code> <em>back</em> to a <code>double</code> before comparing (the idea is that, if one type is of lesser range/precision than the other, it's converted so that both types are identical).</p>

<p>Hence, if the <code>if</code> statement is failing, it's likely that you lose information in the <code>double -&gt; float -&gt; double</code> round-trip<sup>(a)</sup>.</p>

<p>To be honest, unless you're using a great <em>many</em> floating point values (and storage space is a concern), you should probably just use <code>double</code> everywhere. If you <em>do</em> need <code>float</code> types, use that for both values:</p>

<pre><code>#define mypi1 3.14f
float mypi2 = 3.14f;
</code></pre>

<p>Comparing two <code>float</code> variables will not involve any conversions.</p>

<hr>

<p><sup>(a)</sup> See, for example, the following complete program:</p>

<pre><code>#include &lt;stdio.h&gt;
#define x 3.14
int main(void) {
    float y = 3.14;  // double -&gt; float
    double z = y;    //        -&gt; double
    printf(""%.50f\n"", x);
    printf(""%.50f\n"", z);
}
</code></pre>

<p>In this, <code>x</code> is a <code>double</code> and <code>z</code> is a <code>double</code> that's gone through the round-trip conversion discussed above. The output shows the difference that can happen:</p>

<pre><code>3.14000000000000012434497875801753252744674682617188
3.14000010490417480468750000000000000000000000000000
</code></pre>
",4
53495624,53494757,1,"<p>There is at least a problem here:</p>

<pre><code>void object_ctor(Object *o, int id, char *name)
{
  o-&gt;id = id;
  o-&gt;name = malloc(sizeof(name));
  if (sizeof(o-&gt;name) != sizeof(name))
  {
    o-&gt;name = NULL;
  }
  else
  {
    strcpy(o-&gt;name, name);
  }
}
</code></pre>

<p><code>sizeof(name)</code> is not the length of the string pointed by <code>name</code>. You need <code>strlen(name) + 1</code> (+1 for the NUL terminator).</p>

<p>And your test <code>if (sizeof(o-&gt;name) != sizeof(name))</code> is pointless, and I'm not sure what you're trying to achieve here.</p>

<p>You probably want this:</p>

<pre><code>void object_ctor(Object *o, int id, char *name)
{
  o-&gt;id = id;
  o-&gt;name = malloc(strlen(name) + 1);

  if (o-&gt;name != NULL)
    strcpy(o-&gt;name, name);
}
</code></pre>

<p>There are similar problems in <code>object_cpy</code>:</p>

<ul>
<li>pointless use of <code>strncpy</code></li>
<li>pointless allocation of a 10Mb buffer</li>
<li>pointless test <code>strcmp(dst-&gt;name, src-&gt;name)</code></li>
</ul>

<p>You probably want this:</p>

<pre><code>Object *object_cpy(Object *dst, Object *src)
{
  if (src != NULL)
  {
    const size_t len_str = strlen(src-&gt;name) + 1;
    dst-&gt;name = malloc(len_str);

    if (dst-&gt;name != NULL)
    {
      dst-&gt;id = src-&gt;id;
      strcpy(dst-&gt;name, src-&gt;name);
    }
  }

  return dst;
}
</code></pre>

<p>With these corrections following code works fine:</p>

<pre><code>int main()
{
  char tmp_name[] = ""Hello 1"";
  Object o1, copy;
  object_ctor(&amp;o1, 1, tmp_name);
  object_cpy(&amp;copy, &amp;o1);

  print_object(&amp;copy);
  print_object(&amp;o1);  

  object_dtor(&amp;o1);
  object_dtor(&amp;copy);
}
</code></pre>
",0
53547027,53546945,1,"<p>Your loop will stop as soon as it finds a price that is not within range.  And if it doesn't find a price out of range, it will read past the end of the array, invoking <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p>What you want is to loop over all elements of the array, then inside the loop use an <code>if</code> to determine whether or not to print.</p>

<pre><code>for (i=0; i&lt;5; i++) {
    if (phone[i].price &gt;= min &amp;&amp; phone[i].price &lt;= max) {
        printf(""\n%-20s %-15s %6.2f\n"", phone[i].manu, phone[i].model, phone[i].price);
    }
}
</code></pre>
",2
53548164,53548013,0,"<p>Your array is passed by value (i.e. you don't pass a pointer to your matrix). Yet you change it. </p>

<blockquote>
<pre><code>array = realloc(array, cols * sizeof(int *));
</code></pre>
</blockquote>

<p>This is just a local change. Also,</p>

<blockquote>
<pre><code>for (i = 0; i &lt; cols; i++) {
       array[i] = realloc(array[i], rows * sizeof(int));
}
</code></pre>
</blockquote>

<p>If <code>rows &lt; col</code> this piece of code will try to reallocate memory for <code>array[i]</code> where <code>i&gt;rows-1</code>. That implies deallocating the memory pointed to by <code>array[i]</code> has never been allocated and you have no idea where it points to. </p>
",0
53548124,53548013,4,"<p>When you modify <code>array</code> in <code>matrixTranspose</code>, you're changing a local variable.  That change isn't visible in the calling function, so <code>mat</code> in <code>main</code> no longer points to valid memory.</p>

<p>You need to change the function to accept address of a <code>int **</code> and dereference it as needed.</p>

<pre><code>void matrixTranspose(int rows, int cols, int ***array) {
    int temp[rows][cols];
    int i, j;

    for (i = 0; i &lt; rows; i++) {
        for(j = 0; j &lt; cols; j++) {
            temp[i][j] = (*array)[i][j];
        }
    }

    *array = realloc(*array, cols * sizeof(int *));
    if (!*array) {
        perror(""realloc failed"");
        exit(1);
    }

    int min = rows &lt; cols ? rows : cols;
    for (i = 0; i &lt; min; i++) {
        (*array)[i] = realloc((*array)[i], rows * sizeof(int));
        if (!(*array)[i]) {
            perror(""realloc failed"");
            exit(1);
        }
    }
    if (rows &gt; cols) {
        for (i = min; i &lt; rows; i++) {
            free((*array)[i]);
        }
    } else if (cols &gt; rows) {
        for (i = min; i &lt; cols; i++) {
            (*array)[i] = malloc(rows * sizeof(int));
            if (!(*array)[i]) {
                perror(""malloc failed"");
                exit(1);
            }
        }
    }

    for (i = 0; i &lt; cols; i++) {
        for(j = 0; j &lt; rows; j++) {
            (*array)[i][j] = temp[j][i];
        }
    }
 }
</code></pre>

<p>Note that if the number of rows and columns are not the same, you'll need to either <code>free</code> the extra rows you no longer have or use <code>malloc</code> to allocate new rows.</p>

<p>Note also that you should be checking the return value of <code>malloc</code> and <code>realloc</code> for failure.</p>

<p>Then pass the address of <code>mat</code> to this function:</p>

<pre><code>matrixTranspose(rows, cols, &amp;mat);
</code></pre>
",0
53570368,53570324,-2,"<pre><code>Int I*[2];
</code></pre>

<p>Should do the trick as a now has some memory for those pointers</p>
",1
53693036,53692972,0,"<p>You <strong>are</strong> using ""only pointers"". <code>a[i]</code> is defined <strong>only</strong> when either <strong><code>a</code></strong> or <strong><code>i</code></strong> is a pointer or is converted to one. <code>*(a + i)</code> is <strong>exactly</strong> equivalent to <code>a[i]</code> and <code>*(i + a)</code> and <code>i[a]</code>.</p>

<p>It can be written as <code>*(*(*(*(a + i)+j)+k)+l)</code> or for example <code>*(l + *(k + *(*(a + i) + j)))</code> for example, but this is not ""using pointers"" any more than <code>a[i][j][k][l]</code>.</p>

<hr>

<p>I'd avoid such a quiz like plague and redirect the entire <a href=""https://helpdeskgeek.com/how-to/block-websites-using-hosts-file/"" rel=""nofollow noreferrer"">host that serves such garbage to localhost</a>.</p>
",0
54241909,54240997,0,"<p>Have you considered adding a header to the file?</p>

<p>That is, place a special structure at the start of the file that tells you some information about the file.  Something like ...</p>

<pre><code>struct file_header {
    char      id[32];        /* Let this contain a special identifying string */
    uint32_t  version;       /* version number in case the file structure changes */
    uint32_t  num_material;  /* number of material structures in file */
};
</code></pre>

<p>Not only does this give you a relatively quick way to determine how many material structures you have in your file, it is also extensible. Perhaps you will want to store other structures in this file, and you want to know how many of each are in there--just add a new field and update the version.</p>

<p>If you want, you can even throw in some error checking.</p>
",0
58592434,58592149,0,"<p>The code in the question exhibits several deviations and potential deviations from the problem specification:</p>

<ul>
<li>The program does not correctly test whether a transaction can be completed, because it tests whether the requested amount is less than the account balance instead of whether the requested amount <strong>plus the withdrawal fee</strong> is less than <strong>or equal to</strong> the balance.</li>
<li>It is not known that <code>float</code> has sufficient precision to represent the bank balance.</li>
<li>The program fails to end output lines with a newline character. (Although the problem statement does not state this explicitly, it may be expected implicitly.)</li>
<li>The program fails to include <code>&lt;stdio.h&gt;</code>.</li>
</ul>
",0
58592425,58592149,1,"<p>Besides the function-in-function stuff and a missing return value (which isn't used btw), the problem is that you never check if the account goes negative.</p>

<p>Check what happens if you call your code with <code>transaction(100,100.45);</code></p>

<p>Instead try like:</p>

<pre><code>#define count 0.5

void transaction(int x, float acc_bal)
{
    float z = acc_bal - count - x;  // z will be new balance if the transaction is made
    if (z &gt;= 0 &amp;&amp; x % 5 == 0)       // check if the transaction can be made
    {
        acc_bal = z;                // it could... so update balance
    }
    printf(""%0.2f\n"",acc_bal);      // print current balance
}   

int main(void) 
{
    transaction(100,100.45);  // not ok - can't pay bank charges
    transaction(99, 100.45);  // not ok - x is not a multiple of 5
    transaction(95, 100.55);  // ok
}
</code></pre>

<p>Output:</p>

<pre><code>100.45
100.45
5.05
</code></pre>
",0
59216614,59216253,1,"<p>Interesting problem.</p>

<p>Here's what I came up with.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;limits.h&gt;

int main()
{
    int counter = 0;
    int i=1;
    while(counter &lt; 10)
    {
        if (i*i % (int)pow(10,(int)log10(i)+1) == i)
        {
            counter++;
            printf(""%d) %d is automorphic because %d * %d == %d\n"", counter, i, i, i, i*i);
        }
        ++i;
    }
    return 0;
}
</code></pre>

<h2>Sample Output</h2>

<pre><code>Success #stdin #stdout 0s 4516KB
1) 1 is automorphic because 1 * 1 == 1
2) 5 is automorphic because 5 * 5 == 25
3) 6 is automorphic because 6 * 6 == 36
4) 25 is automorphic because 25 * 25 == 625
5) 76 is automorphic because 76 * 76 == 5776
6) 376 is automorphic because 376 * 376 == 141376
7) 625 is automorphic because 625 * 625 == 390625
8) 9376 is automorphic because 9376 * 9376 == 87909376
</code></pre>

<p>(I stopped after finding 8 values due to time-constraints)</p>
",1
54865382,54862296,0,"<p>Not nice but possible would be to define a <code>Node</code> with sort of a ""Invalid-Node"" value and in case there is no node to return just return the ""Invalid-Node""-node.</p>

<pre><code>const Node InvalidNode = {(void*)-1, 
  (struct node*)-1, (struct node*)-1, (struct node*)-1, (struct node*)-1
};

#define NODE_IS_INVALID(n) ( \
  ((n).data == InvalidNode.data) &amp;&amp; \
  ((n).next == InvalidNode.next) &amp;&amp; \
  ((n).prev == InvalidNode.prev) &amp;&amp; \
  ((n).head == InvalidNode.head) &amp;&amp; \
  ((n).tail == InvalidNode.tail) \
)
</code></pre>

<p>Then change your function to look like this:</p>

<pre><code>Node pop_node(List plist,long index){
  Node *pnode;
  pnode=direct_to_head(plist)-&gt;next;
  if(index&gt;list_count(plist)){
    fprintf(stderr, ""index out of link list scope."");
    return InvalidNode;

    ...
</code></pre>

<p>And call it like this:</p>

<pre><code>Node n = pop_node(...);
if (NODE_IS_INVALID(n))
{
   /* handle error */
}
else
{
   /* use n here */
}
</code></pre>
",1
54863909,54862296,0,"<p>If a function is declared to return <code>void</code> (that is, nothing), it can only return nothing. If a function is declared to return some other type <code>T</code>, that's all it can return.</p>

<p>Consider:</p>

<ol>
<li>returning a pointer to type <code>Node</code> (which can be <code>NULL</code>)</li>
<li>returning multiple values (as a struct containing them), one being a flag or error code</li>
<li>returning a 2nd value through an additional pointer given to the function (again, one being a flag/code)</li>
<li>using <a href=""https://en.cppreference.com/w/c/program/longjmp"" rel=""nofollow noreferrer"">longjmp()</a></li>
</ol>

<p>Another variant of option 1 is to define a special global variable of type <code>Node</code> with a suitable/recognizable name, e.g. <code>ErrorNode</code>, and return a pointer to it. The caller can then compare the returned pointer with <code>&amp;ErrorNode</code> to detect the error condition. It doesn't seem special at first sight, but if you end up needing to recognize several distinct error conditions (not too many, though), you may define several such variables (not too many because you'll need to use <code>if/else</code> instead of <code>switch</code> in order to distinguish them).</p>
",7
54149553,54148293,5,"<p><code>strlen</code> already includes spaces, since it counts the length of the string up to the terminating NUL character (zero, <code>'\0'</code>).</p>

<p>Your problem is that that the <code>%s</code> conversion of <code>scanf</code> stops reading when it encounters whitespace, so your string never included it in the first place (you can verify this easily by printing out the string). (You could fix it by using different <code>scanf</code> conversions, but in general it's easier to get things right by reading with <code>fgets</code> ¨C it also forces you to specify the buffer size, fixing the potential buffer overflow in your current code.)</p>
",0
53781916,53781469,1,"<p>Comments in line, explaining each error.</p>

<pre><code>int main(int argc, string argv[]); // You ended this prototype with a semi-colon (;) here.
{                                  // You cannot define the function after a semi-colon (;)
    bool yes = false;              // false is not a valid keyword in C. (it is valid in C++, or with special header files)
    int l = 0                      // You did not use a semi-colon here.
    int length = 0;                // This is the ONLY line you got right.
    string text = """"               // string is not a valid type in C (C++? defined in header file?) You did not use semi-colon
</code></pre>
",0
54598134,54598093,11,"<p>The C standard says this about the <code>%p</code> format specifier for <code>printf</code> family functions (&sect; 7.21.6.2, paragraph 12)</p>

<blockquote>
  <p>The corresponding argument shall be a pointer to a pointer to void. </p>
</blockquote>

<p>Pointers to different types may differ in their internal representation, except for <code>void *</code> and <code>char *</code> pointers, which are guaranteed to be the same size. However, any object pointer type is convertible to <code>void *</code>. So, to be sure that all <code>%p</code> variables are processed correctly by <code>printf</code>, they are required to be <code>void *</code>.</p>
",1
54229152,54229055,1,"<h2>Update for response</h2>

<p>I hope this will work. Where A is sorted array and we are looking value K. </p>

<pre><code>int UpperBound(int A[],int N,int K){
    int low , high , mid ;
    low = 1 ;
    high = N ;
    while(low &lt;= high){
        mid = ( low + high ) / 2 ; // finding middle element 
        if(A[mid] &gt; K &amp;&amp; ( mid == 1 || A[mid-1] &lt;= K )) // checking conditions for upperbound
            return mid ;
        else if(A[mid] &gt; K) // answer should be in left part 
            high = mid - 1 ;
        else                // answer should in right part if it exists
            low = mid + 1 ;
    }
    return mid ; // this will execute when there is no element in the given array which &gt; K
}


int LowerBound(int A[],int N,int K){
    int low , high , mid ;
    low = 1 ;
    high = N ;
    while(low &lt;= high){
        mid = ( low + high ) / 2 ; // finding middle element 
        if(A[mid] &gt;= K &amp;&amp; ( mid == 1 || A[mid-1] &lt; K )) // checking conditions for lowerbound
            return mid ;
        else if(A[mid] &gt;= K) // answer should be in left part 
            high = mid - 1 ;
        else                // answer should in right part if it exists
            low = mid + 1 ;
    }
    return mid ; // this will execute when there is no element in the given array which &gt;= K
}
</code></pre>
",9
53982660,53982596,3,"<p>Practically you'd probably use the minimal field width option to the printf formatter along with the 
left justification flag (-), e.g., <code>printf("" %-5d"", 1);</code>, but if you want to use this as an opportunity to
play with the ternary, note that <a href=""http://port70.net/~nsz/c/c11/n1570.html#6.5.15p1"" rel=""nofollow noreferrer"">its syntax</a> is:</p>

<pre><code>conditional-expression:
                 logical-OR-expression
                 logical-OR-expression ? expression : conditional-expression
</code></pre>

<p>In English this means that you can nest it:</p>

<pre><code>#define PR(X) printf("" %d %s"", X,  \
            (X)&lt;10 ? ""   "" :  \
            (X)&lt;100 ? ""  "" :  \
            (X)&lt;1000 ? "" "" : """" \
            )

#include &lt;stdio.h&gt;
int main(){
    printf("" %-5d"", 1);
    printf("" %-5d"", 22);
    printf("" %-5d"", 333);
    printf("" %-5d\n"", 4444);

    //PRINTS:
    //1     22    333   4444 

    //The same thing with the ternary:
    PR(1);
    PR(22);
    PR(333);
    PR(4444);
    puts("""");

}
</code></pre>
",0
56296988,56296838,1,"<p>This:</p>

<blockquote>
<pre><code>    char *nume[50];
</code></pre>
</blockquote>

<p>... is an array of 50 <em>pointers</em>.  That does not appear to be what you want semantically, and it is certainly not what <code>strcmp()</code> expects as an argument.</p>

<p>Probably what you want instead is</p>

<pre><code>    char nume[50];
</code></pre>

<p>... an array of 50 <code>char</code>s.  That will work fine as an argument to <code>strcmp()</code>, because expressions of array type <em>decay</em> to pointers to thge first array element.  It's one of the standard forms of an argument to <code>strcmp</code>, in fact.</p>

<p>You probably want the same change to the other, similar declarations.</p>
",0
56099690,56099539,1,"<blockquote>
  <p>The value for x was 12 so the printf would print 12 and then x should be assigned 2 and while ++ was there x should be later changed with 2+1 and on line 6 pre-increment is done so output shouldn't be 124.</p>
</blockquote>

<p>no, the assignment is done after all concerning <code>printf(""%d"", ++x);</code>, your code is equivalent to that :</p>

<pre><code>#include &lt;stdio.h&gt;

int main(){
  int x = 12;

  int y = printf(""%d"", x++);

  x = y;

  printf(""%d"", ++x);

  return 0;
}
</code></pre>

<p>so <code>x = printf(""%d"", ++x);</code> does :</p>

<ul>
<li><em>printf</em> writes 12</li>
<li>then <em>x</em> is incremented to value 13</li>
<li>then <em>x</em> is assigned to the result of <em>printf</em> valuing 2</li>
</ul>

<p>then you execute <code>printf(""%d"", ++x);</code> while <em>x</em> values 2 before, so <em>x</em> is incremented before to be given in argument, so 3 is written</p>

<p>and the final print result is 123</p>

<p>PS. As said by @H.S.  in an other remark :There is a sequence point after the evaluation of all function arguments (x++ is an argument to printf()) and the pre/post increment/decrement operation complete at or before the next sequence point. </p>
",0
56099574,56099539,-1,"<p>This will work for you:</p>

<p><strong>++x</strong> is prefix increment and the <strong>x++</strong> is postfix increment, and here is the difference on both of them:</p>

<p>The prefix increment returns the value of a variable after it has been incremented.</p>

<p>On the other hand, the more commonly used postfix increment returns the value of a variable before it has been incremented.</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int x = 12;

    x = printf(""%d"", ++x);

    printf(""%d"", ++x);

    return 0;
}
</code></pre>
",1
54052998,54052956,2,"<p>Regarding the comment ""when file is the same folder of the .exe"", that is incorrect.</p>

<p>Instead relative paths (like your <code>professor.txt</code>) is relative from the process current working directory. Which might be very different from the location of the <code>.exe</code> file.</p>

<p>My <em>guess</em> is that you're running inside Visual Studio (or other IDE) which places the executable files in a sub-directory. The working directory when running, though, is usually the project root directory.</p>

<p>So either go into the project settings and change the working directory when running the program into the directory where the file is located, or move the file to the actual working directory.</p>

<hr>

<p>You can use the <a href=""https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/getcwd-wgetcwd?view=vs-2017"" rel=""nofollow noreferrer""><code>_getcwd</code></a> function to get the process working directory, to verify that it is what you believe it is.</p>
",1
57833581,57832146,2,"<p>In each of the operations AND, OR, NOT, and XOR, each bit in the result is solely a function of the one (OT) or two (AND, OR, XOR) bits in the same position in the operands. In a shift by any amount other than zero, each bit in the result is a function of a bit in a different position in the operand being shifted. Therefore, it is not possible to compute a shift solely from AND, OR, NOT, and XOR.</p>
",0
54098501,54098398,1,"<blockquote>
  <p>Passing Any Type As A ... Parameter</p>
</blockquote>

<pre><code>void f(/* no signature here */);

int main() {
  f(1);
  f(1.2);
  f(""Hello"");
  f(f);
}

void f(/* TBD signature */) {
  ;
}
</code></pre>

<p>Calling a function with any type is easy.  Doing something useful with that is the tricky part.</p>

<p>An <a href=""https://codereview.stackexchange.com/q/115143/29485"">example of printing</a> with out directly specifying the type using <code>_Generic()</code> to steer code.</p>

<pre><code>GPrintf(""The answer to everything "", GP(42), "" or "", GP(42.0), GP_eol);
</code></pre>

<p>The central idea it to make a function-like macro that uses <code>_Generic</code> to selectivity form code.  Below is a square root example.</p>

<pre><code>#define xsqrt(X) _Generic((X), \
  long double: sqrtl, \
  default: sqrt, \
  float: sqrtf \
  )(X)


xsqrt(42.0f); // calls  sqrtf
xsqrt(42.0);  // calls  sqrt
xsqrt(42);    // calls  sqrt
</code></pre>
",2
56122399,56122266,1,"<p>You aren't casting a char to an int, you are casting a pointer to a char to an int.</p>

<pre><code>int main(){
    // define as an actual char, not a char*
    char letter;
    int ascii;

    printf(""Please input a character:"");
    // scan a character, not a string.  Pass in the address of the char
    scanf(""%c"", &amp;letter);
    ascii = (int)letter;
    printf(""\n The ASCII value of %c is %d.\n"", letter, ascii);
}
</code></pre>
",0
55570107,55569929,2,"<p>Your issue is not related to printf, it's due to a bug in your code where you try to use memory you're not supposed to.</p>

<p>In this line in your <code>invertTable</code> function:</p>

<pre><code> tableau[0]=temp;
</code></pre>

<p>You are pointing the <code>table</code> pointer in your main() function to the local <code>temp</code> variable.</p>

<p>Your <code>temp</code> array goes out of scope when the <code>invertTable</code> function ends, so you end up with a dangling pointer and you can't use that memory anymore- doing so is undefined behavior.</p>

<p>You could instead dynamically allocate memory, which will stay valid after <code>invertTable</code> ends:</p>

<pre><code>int *temp = malloc(sizeof(int) * size);
for(int i = 0; i &lt; size; i++)
{
    temp[i]=-1*tableau[0][i];
}
//deallocate previous allocation
free(tableau[0]);
tableau[0]=temp;
</code></pre>
",0
55570506,55569929,0,"<pre><code>tableau[0]=temp;
</code></pre>

<p>This is not valid.  It means to return a pointer to a local array.  This is undefined behavior.</p>

<p>You can do so:</p>

<pre><code>for(int i = 0; i &lt; size; i++)
    (*tableau)[i]*=-1;
</code></pre>
",0
54519472,54517789,2,"<blockquote>
  <p>0x23 0x69 0x6E 0x63 0x6C 0x75 0x64 0x65 0x20 0x3C 0x73 0x74 0x64 0x69 0x6F 0x2E </p>
</blockquote>

<p>If you interpret those bytes as ASCII, you get <code>#include &lt;stdio.</code></p>

<p>In other words, you're passing a C source file to your linker, which tries to interpret it as an object file, but fails, obviously.</p>

<p>To solve this, make sure that your source files aren't passed as inputs to <code>ld</code>.</p>
",0
55340169,55338221,0,"<p>Remember that C strings include a 0-valued terminator, so to store an N-character string, you need a character array that's at least N+1 elements wide.</p>
<p>String management functions like <code>strcmp</code> rely on that terminator to tell them where the end of the string is.  The likely reason you're getting weird output is that the string constant <code>&quot;Mar&quot;</code> is 0-terminated, while the string stored in your <code>month</code> array is not, so <code>strcmp</code> is reading past the end of the <code>month</code> array until it sees a 0-valued byte and is returning the difference between <code>&quot;Mar&quot;</code> and <code>&quot;Mar<em>x</em>&quot;</code>, where <em><code>x</code></em> represents some unknown sequence of bytes.</p>
<p>Accessing memory past the end of an array results in <em>undefined behavior</em>, and any result is possible.</p>
<p>To fix this particular issue, declare <code>month</code> as a 4-element array of <code>char</code> and limit the input to 3 characters on the <code>scanf</code> call:</p>
<pre><code>char month[4];
...
scanf( &quot;%3s&quot;, month );
</code></pre>
<p>The standard signature of <code>main</code> is either</p>
<pre><code>int main( void )
</code></pre>
<p>or</p>
<pre><code>int main( int argc, char *argv[] ); // NOT const
</code></pre>
<p>The <code>argv</code> array is supposed to be modifiable:</p>
<blockquote>
<strong>5.1.2.2.1 Program startup</strong><br>
...<br>
¡ª The parameters <strong><code>argc</code></strong> and <strong><code>argv</code></strong> and the strings pointed to by the <strong><code>argv</code></strong> array shall
be modifiable by the program, and retain their last-stored values between program
startup and program termination.
</blockquote>
<p><sup><em><a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C 2011 Online Draft</a></em></sup></p>
",0
54278787,54278687,1,"<pre><code>const char * FindItem(int id)
</code></pre>

<p>returns a pointer to <code>char</code>.</p>

<pre><code>  return s1; 
</code></pre>

<p>returns from the function to the caller the address of the 1st element of <code>s1</code>. </p>

<p>Still, the moment the function <code>FindItem()</code> has return <code>s1</code> is gone, as it only lived on the function's local stack, existed for the live time of <code>FindItem()</code> only.</p>

<p>So</p>

<pre><code>  printf(""%s"", FindItem( ...
</code></pre>

<p>tries to print data pointed to by what <code>FindItem()</code> returned, although the data is gone, as the function returned already.</p>

<p>To fix this, defined the buffer to read into on the caller side and pass the address of its 1st element to the function:</p>

<pre><code>char * FindItem(char * s1, int id)
{
    FILE *f1;
    f1 = fopen(""Items.txt"", ""r"");
    int i = 0;

    while(1)
    {
      ...


int main(void)
{
  char s1[256];
  printf(""%s"", FindItem(s1, 2));
}
</code></pre>
",0
54299540,54299488,1,"<p>The problem is that you defined <code>Name</code> as a <code>char</code> - a single character - but you are trying to use it as a string (multiple characters).</p>

<p>To fix this you must either (a) define <code>Name</code> as an <em>array</em> of characters (which would be a string) - such as <code>char Name[100];</code> or (b) as a pointer (such as <code>char *Name;</code>) - which would require you to <code>malloc()</code> the string before use and <code>free()</code> it after use.</p>

<p>Strings can be tricky, as they are basically just arrays of <code>char</code>s, but that requires you to either know, or find a way to know, how many characters will be in the string.  You can read more about how to do that <a href=""https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/scanf-s-scanf-s-l-wscanf-s-wscanf-s-l?view=vs-2017"" rel=""nofollow noreferrer"">here, in the documentation for scanf_s</a>, which gives this example:</p>

<pre><code>char c[4];
scanf_s(""%4c"", &amp;c, (unsigned)_countof(c)); // not null terminated
</code></pre>
",0
54299509,54299488,2,"<p>Your problem is that <code>char Name;</code> can only store a single character. Your code is allowing the user to type in multiple characters which are being stored into <code>Name</code> causing a memory error.</p>

<p>Change <code>char Name;</code> to something like <code>char Name[50]</code> so that you can store up-to 49 characters plus the <code>null</code> byte.</p>

<p>Also you should use <code>scanf_s()</code> properly to avoid the error if the buffer (char array) ends up being too small.</p>

<p><strong>Note, you should always check the return from <code>scanf_s()</code> so you know if the user entered valid data or not.</strong></p>

<p>This code works correctly in Visual Studio:</p>

<pre><code>#include ""stdafx.h""
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;


int main()
{
    int Age;
    char Name[50];

    printf(""Type your age: "");
    if(scanf_s(""%d"", &amp;Age))
    {
        printf(""Your age is %d\n"", Age);

        printf(""Type your Name: "");
        if (scanf_s(""%s"", Name, (unsigned)_countof(Name)))
        {
            printf(""Your name is %s\n"", Name);
        }
        else
        {
            printf(""Name:: Invalid Input\n"");
        }
    }
    else
    {
        printf(""Age:: Invalid Input\n"");
    }

    return 0;
}
</code></pre>
",3
55113714,55113654,0,"<p>Your indention doesn't match your braces. Before:</p>

<pre><code>while((*listPtr)-&gt;next !=NULL){
  if((*listPtr)-&gt;value ==findValue){
  }
if((*listPtr)-&gt;next ==NULL){
   }
}
</code></pre>

<p>after:</p>

<pre><code>while((*listPtr)-&gt;next !=NULL){
  if((*listPtr)-&gt;value ==findValue){
  }
}
if((*listPtr)-&gt;next ==NULL){
}
</code></pre>

<p>We generally don't like code with messed-up indentation. It's hard to see what's wrong. But that code still won't work because more errors. Let's try this:</p>

<pre><code>while((*listPtr)-&gt;next !=NULL){
  if((*listPtr)-&gt;value ==findValue) {
    listNode *newNodePtr=(listNode *)malloc(sizeof(listNode));
    newNodePtr-&gt;value = value;
    newNodePtr-&gt;next = (*listPtr)-&gt;next;
    (*listPtr)-&gt;next =newNodePtr;
    return;
  }
  listPtr = &amp;((*listPtr)-&gt;next); /* advancer was really messed up */
}
if((*listPtr)-&gt;next ==NULL){
  listNode *newNodePtr = (listNode *)malloc(sizeof(listNode));
  newNodePtr-&gt;value = value;
  newNodePtr-&gt;next = NULL;
  (*listPtr)-&gt;next=newNodePtr;
}
</code></pre>

<p>But we can remove a lot of duplication:</p>

<pre><code>while((*listPtr) != NULL){
  if((*listPtr)-&gt;value ==findValue) {
    break;
  }
  listPtr = &amp;((*listPtr)-&gt;next);
}
listNode *newNodePtr = (listNode *)malloc(sizeof(listNode));
newNodePtr-&gt;value = value;
newNodePtr-&gt;next = (*listPtr)-&gt;next;
(*listPtr)-&gt;next=newNodePtr;
</code></pre>

<p>Or even more succinctly:</p>

<pre><code>for(;*listPtr &amp;&amp; (*listPtr)-&gt;value != findValue;
    listPtr = &amp;((*listPtr)-&gt;next)) { }
struct listNode *newNodePtr = malloc(sizeof(struct listNode));
newNodePtr-&gt;value = value;
newNodePtr-&gt;next = (*listPtr)-&gt;next;
(*listPtr)-&gt;next=newNodePtr;
</code></pre>

<p>At this point, the rest of the bugs in the original code are addressable:</p>

<pre><code>for(;*listPtr &amp;&amp; (*listPtr)-&gt;value != findValue;
    listPtr = &amp;((*listPtr)-&gt;next)) { }
struct listNode *newNodePtr = malloc(sizeof(struct listNode));
if (*listPtr) { /* it's insert after, not insert before, but we have to handle not finding anything and putting it on the end */
    newNodePtr-&gt;value = *listPtr-&gt;value;
    *listPtr-&gt;value = value;
} else {
    newNodePtr-&gt;value = value;
}
newNodePtr-&gt;next = *listPtr; /* Don't try to follow next off the end */
*listPtr = newNodePtr;
</code></pre>
",2
54365560,54365482,1,"<p><code>s</code> is an uninitialized pointer. It points nowhere.</p>

<p>You want this:</p>

<pre><code>char s[100];
</code></pre>

<p>Instead of:</p>

<pre><code>char *s;
</code></pre>

<p>I suggest you read the chapter dealing with pointers in your C text book.</p>

<p>You also need to check if <code>fopen</code> was successful:</p>

<pre><code>in = fopen(""input"", ""r"");
if (in == NULL)
{
  printf(""Can't open file\n"");
  exit(1);
}
</code></pre>
",0
54507062,54507034,0,"<p>this:</p>

<pre><code>if(f(x1)*f(x2)&lt;0);  /* **&lt;--- if statement line 16** */
</code></pre>

<p>should be:</p>

<pre><code>while (f(x1)*f(x2)&lt;0);  /* **&lt;--- if statement line 16** */
</code></pre>
",0
54507083,54507034,1,"<p>Right before the <code>if</code>, you have this:</p>

<pre><code>  do
  {
       printf(""Enter a number for x1 and x2"");
       scanf(""%lf  %lf"", &amp;x1, &amp;x2);
  }
  if(f(x1)*f(x2)&lt;0);
</code></pre>

<p>You have the start of a <code>do...while</code> loop, but there's no <code>while</code> condition.  You also have an <code>if</code> with no statement that follows.  You probably wanted to use <code>while</code> here instead of <code>if</code>:</p>

<pre><code>  do
  {
       printf(""Enter a number for x1 and x2"");
       scanf(""%lf  %lf"", &amp;x1, &amp;x2);
  }
  while (f(x1)*f(x2)&lt;0);
</code></pre>
",1
54507062,54507034,0,"<p>this:</p>

<pre><code>if(f(x1)*f(x2)&lt;0);  /* **&lt;--- if statement line 16** */
</code></pre>

<p>should be:</p>

<pre><code>while (f(x1)*f(x2)&lt;0);  /* **&lt;--- if statement line 16** */
</code></pre>
",0
54507083,54507034,1,"<p>Right before the <code>if</code>, you have this:</p>

<pre><code>  do
  {
       printf(""Enter a number for x1 and x2"");
       scanf(""%lf  %lf"", &amp;x1, &amp;x2);
  }
  if(f(x1)*f(x2)&lt;0);
</code></pre>

<p>You have the start of a <code>do...while</code> loop, but there's no <code>while</code> condition.  You also have an <code>if</code> with no statement that follows.  You probably wanted to use <code>while</code> here instead of <code>if</code>:</p>

<pre><code>  do
  {
       printf(""Enter a number for x1 and x2"");
       scanf(""%lf  %lf"", &amp;x1, &amp;x2);
  }
  while (f(x1)*f(x2)&lt;0);
</code></pre>
",1
56065180,56065070,1,"<p>The <code>&amp;array</code> in <code>fread(&amp;array,8,npts,fo);</code> is wrong; that is the address of the pointer. You should pass the pointer: <code>fread(array,8,npts,fo);</code>.</p>
",3
54443750,54443678,1,"<p><code>printf(""something"");</code> is the equivalent of <code>fprintf(stdout, ""something"");</code> so it prints on the <em>standard output</em>, whatever where finally the output will be done (screen, file, pipe, ...)</p>

<p>because ""something"" doesn't content special formating (using %) if is printed unchanged, and probably your question moves to be <em>how putchar() / fputc() works</em></p>

<p><em>printf</em> doesn't know what a screen / file / pipe / ... is, in the same way <em>scanf</em> doesn't know what a keyboard is, this is not their responsibility</p>
",8
55641666,55641271,0,"<p>The address of the first member of a structure is also the address of the structure, so you can exploit that fact by using a common header structure containing the <code>next</code> member and writing a function that will free generic nodes.</p>

<p>Given:</p>

<pre><code>typedef struct node 
{
    struct node* next ;
} Node ;
</code></pre>

<p>Then :</p>

<pre><code>typedef struct bnode 
{
    Node node ;
    ...
    some variables
    ...
} Book;
</code></pre>

<p>and</p>

<pre><code>typedef struct bnode 
{
    Node node ;
    ...
    some variables
    ...
} Student ;
</code></pre>

<p>Then:</p>

<pre><code>void free_all_nodes( Node* table, int max  )
{
    for( int i = 0; i &lt; max; i++ ) 
    {
        Node* head = table[i] ;
        while ( head != NULL ) 
        {
            Node* temp = head ;
            head = head-&gt;next;
            free(temp);
        }

        table[i] = NULL ;
    }
}
</code></pre>

<p>and:</p>

<pre><code>void free_all_books()
{
    free_all_nodes( (Node*)book_table, MAX_LEN ) ;
}

void free_all_students()
{
    free_all_nodes( (Node*)student_table, MAX_LEN ) ;
}
</code></pre>
",0
54453358,54453110,0,"<p><strong>Mis-match arguments</strong></p>

<p>In many places, the following type of error.  Readily findable will all warnings enabled.</p>

<blockquote>
  <p>warning: passing argument 1 of 'pop_back' from incompatible pointer type [-Wincompatible-pointer-types]</p>
</blockquote>

<pre><code>int push_back(deque* d, int item){ 
    // if (full(&amp;d))
    if (full(d))
</code></pre>

<p><code>main()</code></p>

<pre><code>  // deque* d;
  deque d;
  initialize(&amp;d, tamdeque);
</code></pre>

<p><strong>mixing <code>int/unsigned</code> math.</strong></p>

<p>Recommend a design change to use just one.</p>

<p><strong>Missing return value</strong></p>

<p>Minor: <code>int push_back(), push_front()</code></p>

<hr>

<p>Other problems exist.  (About 30 total warnings)</p>
",4
54492992,54492875,2,"<p>You're printing pointer addresses, instead of what the pointer is pointing to. Also arrayD is the address, you don't need &amp;arrayD. Here is a complete working sample:</p>

<pre><code>#include &lt;stdio.h&gt;
int main()
{
    char arrayD[] = ""asdf"";
    char *arraypointer = arrayD;
    while(*arraypointer != '\0'){
        printf(""%c \n"", *(arraypointer+1));
        arraypointer++;
    }
    return 0;
}
</code></pre>
",11
58348584,58348557,3,"<p>You need to skip over the string at the beginning of each line.</p>

<pre><code>for(i = 0; i &lt; 26; i++){
     fscanf(letFloats, ""%*s %f"", &amp;floats[i]);
}
</code></pre>

<p>The <code>*</code> means to parse the string, but not store it anywhere.</p>

<p>Your code isn't storing anything, because <code>fscanf()</code> always fails to find a float to parse.</p>
",1
54588376,54588314,2,"<pre><code>if ( fgetc(""/n"")) {
</code></pre>

<p>You are using <code>fgetc</code> with a wrong parameter, the parameter should be a pointer to a <code>FILE</code> object that identifies an input stream (in your case it seems to be <code>files</code>)</p>
",1
54671513,54671428,3,"<p>A string constant like <code>""YES""</code> or <code>""NO""</code> is an array of characters, not a single character, so you can't store them in a <code>char</code>.  </p>

<p>You need to declare <code>y</code> and <code>n</code> as <code>char *</code> so they can point to the string constant and change the return type of the function accordingly.</p>

<pre><code>const char *findNumber(int arr_count, int arr[], int k) 
{
    const char *y=""YES"";
    const char *N=""NO"";
    ...
</code></pre>
",0
54690526,54688889,0,"<p>Your code is perfectly correct. It is simply terribly inefficient and therefore takes very, very long time just to find out if a single large number is prime.</p>

<p>Here is better version of <code>is_prime</code>:</p>

<ul>
<li>It tests divisors only up to the square root of the number to be tested.</li>
<li>It only tests odd divisors, if the number is not divisible by two, it's pointless to test if it's divisible by 4, 6, 8 etc.</li>
</ul>

<hr>

<pre><code>// long long integer square root found somewhere on the internet
unsigned long long isqrt(unsigned long long x)
{
  unsigned long long op, res, one;

  op = x;
  res = 0;

  /* ""one"" starts at the highest power of four &lt;= than the argument. */
  one = 1LL &lt;&lt; 62;  /* second-to-top bit set */
  while (one &gt; op) one &gt;&gt;= 2;

  while (one != 0) {
    if (op &gt;= res + one) {
      op -= res + one;
      res += one &lt;&lt; 1;  // &lt;-- faster than 2 * one  
    }
    res &gt;&gt;= 1;
    one &gt;&gt;= 2;
  }
  return res;
}


int is_prime(unsigned long long a)
{
  if (a &lt;= 1 || a == 2 || a % 2 == 0)
    return 0;

  unsigned long long count = 0;
  unsigned long long limit = isqrt(a) + 1;

  for (unsigned long long p = 3; p &lt; limit; p += 2)
  {
    if (a % p == 0)
      return 0;
  }
  return 1;
}
</code></pre>

<p>Further optimisations are of course possible. E.g. it is also pointless to test for multiples of 3 if the number was not divisible by 3 etc. Also if you want to find a range of prime numbers there are probably other approaches to be taken into account.</p>
",2
54896233,54896094,1,"<pre><code>            else
            {
                system(""cls"");
                printf(""\t\t\t\t\tZack's Miraculus MiniGames\n\n\n"");
                printf(""Computer Chose scissors\n"");
                char computerString[30] = ""Scissors"";
            }
            }while (thing != 0);


            if(strcmp(choice, computerString) == 0)
            {
                printf(""It Is A Draw!\n"");
                printf(""Type Anything To Continue: "");
                scanf(""%s"", placeHolder);
            }
</code></pre>

<p>The <code>char computerString[30] = ""Scissors"";</code> creates a variable whose scope is the block in which it was created. The following <code>}</code> ends that block, so the variable no longer exists. Further down in the code, when you pass <code>computerString</code> to <code>strcmp</code>, there is no variable with that name in scope.</p>

<p>To fix it, create <code>computerString</code> earlier in the code, in a scope that includes all the code that needs to access it. Use <code>strcpy</code> to set values for <code>computerString</code>.</p>

<p>Your compiler was warning you that you assigned <code>computerString</code> a value and then let it go out of scope without using that value.</p>
",1
54896253,54896094,0,"<p>I went ahead and created a small sample that fixes a few things for you. It doesn't do everything, but it does show you how to properly compare strings etc.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

int main(int argc, char *argv[])
{
    char choice[10];
    char *computerChoices[] = {""Rock"", ""Paper"", ""Scissors""};
    char *computerChoice = NULL;

    /* Use current time as seed for random generator */
    srand(time(0));     

    do
    {
        printf(""\t\t\t\t\tZack's Miraculus MiniGames\n\n\n"");
        printf(""What Is Your Choice? Rock, Paper or Scissors\n"");
        printf(""Enter Your Answer Here: "");
        scanf(""%s"", choice);
    }while (strcmp(choice, computerChoices[0]) != 0 &amp;&amp; strcmp(choice, computerChoices[1]) != 0 &amp;&amp; strcmp(choice, computerChoices[2]) != 0);

    computerChoice = computerChoices[rand()%3];
    printf(""Computer Chose %s\n"", computerChoice);

    if(strcmp(choice, computerChoice) == 0)
    {
        printf(""It Is A Draw!\n"");
    }
    return(0);
}
</code></pre>

<p>Hope this helps.</p>
",2
55536892,55536799,1,"<p>Create a private header file somewhere in your source tree, such as directly alongside your library's source files. Declare the utility function(s) in this header file. Then add a source file with its implementation, and make this source file part of your library's sources.</p>

<p>In effect, the only difference between a ""client-visible"" function and ""internal-only"" function in the library is whether you make the declaration header public or not.</p>
",1
55537100,55536799,0,"<blockquote>
  <p>How to save utils when creating a C library?</p>
</blockquote>

<p>This is tricky when the util function is a same name replacement as a standard library as various other <code>.c</code> files may need the original standard function - especially for test code to compare functions.</p>

<hr>

<p>Rename function and save in ""TP.c""</p>

<pre><code>// int strlen(char *s){
int TP_strlen(char *s){
</code></pre>

<p>Form header ""TP.h""</p>

<pre><code>int TP_strlen(char *s);
// and inline or define
inline int strlen(char *s) { return TP_strlen(s); }
</code></pre>

<p>Do <strong>not</strong> include both <code>""TP.h""</code> and <code>&lt;string.h&gt;</code></p>

<hr>

<p>Strongly recommend to use the <em>same</em> function signature as standard functions.</p>

<pre><code>// int TP_strlen(char *s)
size_t TP_strlen(const char *s)
</code></pre>
",0
55031538,55030606,1,"<p><code>tokens</code> is an array of pointers.</p>

<p>The distinction between strings and pointers if often fuzzy. In some situations strings are better thought out as arrays, in other situations as pointers.</p>

<p>Anyway... in your example <code>input</code> is an array and <code>tokens</code> is an array of pointers to a place within <code>input</code>.</p>

<p>The data inside <code>input</code> is changed with each call to <code>strtok()</code></p>

<p>So, step by step</p>

<pre><code>// input[] = ""foo bar baz"";
tokens[0] = strtok(input, "" "");
// input[] = ""foo\0bar baz"";
//            ^-- tokens[0] points here
tokens[1] = strtok(NULL, "" "");
// input[] = ""foo\0bar\0baz"";
//                 ^-- tokens[1] points here
tokens[2] = strtok(NULL, "" "");
// input[] = ""foo\0bar\0baz"";
//                      ^-- tokens[2] points here
// next strtok returns NULL
</code></pre>
",0
55030855,55030606,2,"<p><code>strtok</code> is a bad citizen. </p>

<p>For one thing, it retains state, as you've implicitly used when you call <code>strtok(NULL,...)</code> -- this state is stored in the private memory of the Standard C Library, which means only single threaded programs can use <code>strtok</code>. Note that there is a reentrant version called <code>strtok_r</code> in some libraries.</p>

<p>For another, and to answer your question, <code>strtok</code> modifies its input. It doesn't allocate space for the strings; it writes NUL characters in place of your delimiter in the input string, and returns a pointer into the input string.</p>

<p>You are correct that <code>strtok</code> can return more than 10 results. You should check for that in your code so you don't write beyond the end of <code>tokens</code>. A reliable program would either set an upper limit, like your <code>10</code>, and check for it, reporting an error if it's exceeded, or dynamically allocate the <code>tokens</code> array with <code>malloc</code>, and <code>realloc</code> it if it gets too big. Then the error occurs when you fun out of memory.</p>

<p>Note that you can also work around the problem of <code>strtok</code> modifying your input string by <code>strdup</code>ing before passing it to <code>strtok</code>. Then you'll have to free the new string after both it and <code>tokens</code>, which points to it, are going out of scope.</p>
",2
55128511,55128115,0,"<p>In C, a string is a sequence of consecutive <code>char</code> variables that is terminated by the representation of zero as a character, <code>'\0'</code>.</p>

<p>This value acts as a sentinel for the end of the string and allows the idiomatic ""string processing"" loop below:</p>

<pre><code>char *p = &lt;some string&gt;;
while(*p)
{
    dosomething(*p);
    p++;
}
</code></pre>

<p>Library functions that process strings (i.e. <code>strlen</code>, <code>strcpy</code>, <code>strcat</code>, etc.) use a construct similar to the code above, and when you write your own code that processes arbitrary strings, you will find the null character check useful; even if a string is stored in a <code>char []</code> array of known length, it decays to a pointer to its first element when passed to a function, losing information about its length.</p>

<p>So, if you want to blank the string, all that is needed is to set the first element of the string to <code>'\0'</code>. If the first value in the string is the null terminator, the condition <code>*p</code> is false and the loop is never entered:</p>

<pre><code>char *p = ""\0someotherstuff"";
printf(""%zu\n"", strlen(p));
// Output: 0
</code></pre>
",0
55156613,55154098,1,"<p>To solve tasks using recursion, you can use this pattern:</p>

<ul>
<li>to solve the task:

<ul>
<li>check if you've reached a trivial case. If so:

<ul>
<li>do the trivial thing</li>
</ul></li>
<li>otherwise:

<ul>
<li>split the task into smaller parts that look similar to the whole task</li>
<li>solve each of the smaller tasks by calling the function recursively</li>
</ul></li>
</ul></li>
</ul>

<p>In your case the task is <code>print_diagonals(width_of_the_square, current_line_number)</code>.</p>

<p>Defining this task by giving it a proper name and by finding out the parameters and their names is the most important part of solving this kind of problems. It's much easier to think about <code>print_diagonals</code> than about <code>recursiveProblem</code> since the names I've given carry lots of meaning and exactly describe their purpose.</p>

<p>The ""trivial case"" in this task can be either ""print the line in the middle of the square"" or ""print the bottom line of the square"". Both will work, and the programs will look similar. Try them both and then compare the resulting programs. The part these programs have in common is typical for recursive programs.</p>

<p>Using this information, you should be able to do your homework by yourself.</p>
",0
55156464,55154098,-1,"<p>I don't understand why anyone would want to make this recursive.  But this works.</p>

<pre><code>#include &lt;stdio.h&gt;

void recurse(int i, int j, int n){
    printf(i==j || i+j+1==n ? ""X"" : "" "");
    if (++j == n) {
        printf(""\n"");
        if (++i == n)
            return;
        j=0;
    }
    recurse(i, j, n);
}

int main(){
    int n;
    printf(""Enter width: "");
    scanf(""%d"",&amp;n);
    recurse(0, 0, n);
    return 0;
}
</code></pre>

<p>If you'll notice, I move one <code>if</code> block right inside the <code>printf</code> statement using the <code>? :</code> operator.</p>

<p>Also, notice that every single <code>printf</code> is called from it's own <code>recurse</code> function call, which is on top of every other function call on the stack.  So if your stack is limited and <code>n</code> is large, you could run out of stack and crash.  This is one reason recursive functions should only be used with caution.</p>

<p>Alternately, you could put the loop that increments <code>j</code> in the recursive function and only recurse to increment <code>i</code>.  That would use a lot less stack.</p>
",3
55197738,55197688,0,"<p>First, read why <em><a href=""https://stackoverflow.com/questions/5431941/why-is-while-feoffile-always-wrong"">(!feof(fp)) is always wrong</a></em>.  </p>

<p>This can be replaced by using <em><a href=""https://www.tutorialspoint.com/c_standard_library/c_function_fgets.htm"" rel=""nofollow noreferrer"">fgets()</a></em> in conjunction with a <code>while()</code> loop:  </p>

<pre><code>fp = fopen("".\\somefilename.txt"", ""r"");
if(fp)
{
    while(fgets(line, sizeof(line, fp))
    {
        // parse line to ignore first two words using strtok() or strchr()
    }
    fclose(fp);
}fclose(fp)
</code></pre>
",2
55814925,55814023,0,"<p>You should test the return of <code>scanf</code>.</p>

<p>Indeed, if you don't enter anything, the value of <code>input</code> stay uninitialized and that could explain the infinite loop.</p>

<pre><code>int getInput ()
{
    int input;
    printf (""Enter salary: "");
    if (2 == scanf (""%d%*c"", &amp;input))
        return input;

    else 
        /* if scanf was not able to read one integer and one char, return a negative value */
        return -1;
}
</code></pre>
",0
55814934,55814023,0,"<p>your problem probably comes because you declare <em>getInput</em> as returning a <em>float</em> but its definition returns an <em>int</em></p>

<p>when you do <code>salaries[i] = getInput();</code> the code make a <em>float</em> from an <em>int</em> but because it is already a <em>float</em> the conversion is wrong, and after the test of the sign is wrong too</p>

<p>Out of that I strongly encourage you to test the result of <em>scanf</em> to be sure a valid input was done, else you definitively not get a value value because the invalid value is never bypassed</p>
",0
55334842,55334524,3,"<p><code>match6(&amp;numbers[i], matchArray, &amp;m6[100]);</code>. You pass the address of the item beyond the last allocated item. After which match6 writes out of bounds. Instead of doing strange things, simply pass the array:</p>

<pre><code>char m6[100] = """";
match6(&amp;numbers[i], matchArray, m6);  
</code></pre>
",0
55285054,55284731,1,"<pre><code>int n = atoi(string);
printf(""Sum of digits is %d\n"", (!(n%9) &amp;&amp; n) ? 9 : n%9);
</code></pre>

<p>See <a href=""https://stackoverflow.com/questions/13985796/sum-of-all-digits-for-a-given-positive-number"">Sum of all digits for a given Positive Number</a>  for complete details.</p>

<p><a href=""https://ideone.com/Obl9re"" rel=""nofollow noreferrer"">IDEOne Link</a></p>
",0
55340924,55340700,1,"<p><code>sizeof anElement-&gt;id</code> yields the size of a pointer!</p>

<pre><code>fgets(anElement-&gt;id,sizeof anElement-&gt;id,stdin);
//                  ^^^^^^^^^^^^^^^^^^^^
//                  size of a pointer
//                  probably 4 or 8
</code></pre>

<p>You should allocate enough space and read that many bytes</p>

<pre><code>anElement-&gt;id = malloc(100);      // error checking omitted for brevity
fgets(anElement-&gt;id, 100, stdin); // error checking omitted for brevity
// use anElement-&gt;id
free(anElement-&gt;id);
</code></pre>

<p>Don't forget to <code>free()</code> the memory when you no longer need it.</p>
",3
55347527,55347478,1,"<p>This sets <code>enBuyuk</code> to a value that is undefined!</p>

<pre><code>int enBuyuk = dizi[0]; //first biggest element 
</code></pre>

<p>Instead, move this line to just above your for-loop.</p>

<hr>

<pre><code>for (j = 0; j &lt;= elemansayisi; j++) {  
</code></pre>

<p>This should be strictly less than (remove the <code>=</code> sign)</p>

<pre><code>int enBuyuk = dizi[0]; // Move line here
for (j = 0; j &lt; elemansayisi; j++) {
</code></pre>
",0
55366528,55366483,1,"<p>You should put the <code>struct</code> declaration in your <code>.h</code> file instead of the <code>.c</code> file.</p>
",5
55687122,55686996,2,"<p>You have two immediate problems in your code, first you miss to add a null character to end each sub string, second you never reset the index to 0 when you read a /</p>

<p>Other problems are you do not check if you will write out of the arrays, and you do not not manages the EOF</p>

<p>You also test the value of <em>slashcounter</em> all the time, this is quite expensive for nothing, you can have 3 loops or use a pointer to point to the array to fill etc</p>

<p>There is also no reason to use global variables, all of them can be local in <em>main</em></p>

<p>Example with minimal changes :</p>

<pre><code>#include &lt;stdio.h&gt;

int main(){
  int c;
  char replace[80], toBeReplaced[80], input[80];
  int i = 0;
  int slashcounter = 0;

  puts(""Enter a line of text: "");

  while (( c = getchar()) != '\n') {
    if (c == EOF) {
      fprintf(stderr, ""unexpected EOF"");
      return -1;
    }

    if (c == '/') {
      if (slashcounter == 0) {
        replace[i] = 0;
      }
      else if (slashcounter == 1) {
        toBeReplaced[i] = 0;
      }
      else if (slashcounter == 2) {
        input[i] = c;
      }
      i = 0;
      slashcounter++;
    }
    else if (slashcounter == 0) {
      if (i != (sizeof(replace) - 2))
        replace[i++] = c;
    }
    else if (slashcounter == 1) {
      if (i != (sizeof(toBeReplaced) - 2))
        toBeReplaced[i++] = c;
    }
    else if (slashcounter == 2) {
      if (i != (sizeof(input) - 2))
        input[i++] = c;
    }
  }

  if (slashcounter == 0) {
    replace[i] = 0;
    toBeReplaced[0] = 0;
    input[0] = 0;
  }
  else if (slashcounter == 1) {
    toBeReplaced[i] = 0;
    input[0] = 0;
  }
  else if (slashcounter == 2) {
    input[i] = 0;
  }

  //debug purpose
  puts(""The arrays have the following content\n"");
  puts(""replace[]:\n"");
  puts(replace);
  puts(""\n"");
  puts(""toBeReplaced[]:\n"");
  puts(toBeReplaced);
  puts(""\n"");
  puts(""input[]:\n"");
  puts(input);
  printf(""Slashcounter = %d\n"",slashcounter);

  return 0;
}
</code></pre>

<p>Note I use an <em>int</em> for <em>c</em> to handle <em>EOF</em> and I removed the useless array <em>testInput</em></p>

<p>Compilation and execution :</p>

<pre><code>pi@raspberrypi:/tmp $ gcc -pedantic -Wall -Wextra s.c
pi@raspberrypi:/tmp $ ./a.out
Enter a line of text: 
this/test/fails
The arrays have the following content

replace[]:

this


toBeReplaced[]:

test


input[]:

fails
Slashcounter = 2
</code></pre>
",0
55500336,55499452,1,"<p><code>==</code> binds more tightly than <code>=</code>. Try putting parentheses around the assignment of <code>queue_id</code>, or put it on its own line:</p>

<pre><code>queue_id = msgget(IPC_PRIVATE, IPC_CREAT | IPC_EXCL | 0600);
if(queue_id == -1) {
         perror(""queue"");
         return -1;
}
</code></pre>

<p>Running your compiler with <code>-Wall -Wextra -Werror</code> will help with this kind of thing.</p>
",0
55500336,55499452,1,"<p><code>==</code> binds more tightly than <code>=</code>. Try putting parentheses around the assignment of <code>queue_id</code>, or put it on its own line:</p>

<pre><code>queue_id = msgget(IPC_PRIVATE, IPC_CREAT | IPC_EXCL | 0600);
if(queue_id == -1) {
         perror(""queue"");
         return -1;
}
</code></pre>

<p>Running your compiler with <code>-Wall -Wextra -Werror</code> will help with this kind of thing.</p>
",0
55567396,55567291,2,"<p>While it's clearest to just use the variable, you can get what you're looking for with a <a href=""https://gcc.gnu.org/onlinedocs/gcc/Compound-Literals.html"" rel=""nofollow noreferrer"">compound literal</a>:</p>

<pre><code>test_func(&amp;(int){1});
</code></pre>
",1
55561312,55561251,2,"<p>Strings represented as character arrays, need to be null terminated. This includes your <code>abc</code> and <code>pass</code> arrays.  <code>printf</code> doesn't know anything about the size of your array when <code>abc</code> is passed to it. It just prints characters starting at that address until it hits a <code>\0</code> char.  Ditto for <code>pass</code></p>

<p>If  <code>abc</code> was printing correctly without a null char appended to it, that that's probably just you getting lucky.  It's technically undefined behavior.</p>

<p>Let's fix your code up....</p>

<pre><code>int main(void)
{
    char abc[52+1]; // 53
    for (int i = 0; i &lt; 52; i++)
    {
        if (i &lt; 26)
        {
            abc[i] = 'a' + i;
        }
        else
        {
            abc[i] = 'A' + i - 26;
        }
    }
    abc[52] = '\0';
    printf(""%s\n"", abc);

    char pass[2+1]; //3
    pass[0] = abc[3];
    pass[1] = '\0'; // null terminate pass before printing
    printf(""%s\n"", pass);

    pass[1] = abc[1];
    pass[2] = '\0'; // null terminate pass again before printing
    printf(""%s\n"", pass);
}
</code></pre>
",3
56182437,56176624,0,"<blockquote>
  <p>it seems not to be RIP as well.</p>
</blockquote>

<p>Though it doesn't seem so to you, it may well be that there are code addresses far away from each other. Example:</p>

<pre><code>(gdb) bt
#0  0x0000000000000000 in ?? ()
#1  0x00007f2b9480dd52 in __libc_start_main () from /lib64/libc.so.6
#2  0x0000000000400479 in _start ()
</code></pre>

<p>The value <code>0x00007ffff7a47c37</code> is definitely the instruction pointer where the signal was raised. You can even use the <code>gdb</code> command <code>disas __GI_raise</code> to verify.</p>
",0
55606784,55606699,0,"<p>If <code>List</code> should be pointing to <code>e</code>, then you should not call <code>malloc()</code> again. You should do:</p>

<pre><code>struct ELEMENT **List = &amp;e;
</code></pre>
",0
55657855,55657794,0,"<p>This is your program with minimal changes:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void main(void)

{

      int n = 1, i = 0;
      char a = 0;
      char *str = NULL;
      str = malloc(sizeof(char) * (n+1)); // reserve space for a zero byte
      printf(""Enter string : "");
      while (a != '\n')
      {
         a = getchar();
         str = realloc(str, sizeof(char) * (n+1)); // reserve space for a zero byte
         str[i++] = a;
         str[i+1] = 0; // add a zero byte
         n++;
      }
      puts(str); // puts instead of printf
      free(str);
}    
</code></pre>
",0
56716866,56715099,1,"<p>There are some good suggestions in the comments, but it seems most likely that the problem you are reporting is not a programming issue so much as a problem with your data file. The superposition of <code>Banana</code> and <code>Pera</code> over the line which prints <code>Mera</code> strongly suggests that the first two lines in your file are not correctly terminated with a newline character, but rather with a carriage return.</p>

<p>I honestly don't know how this might occur these days. Twenty years ago, Apple's operating system used CR line endings, but that changed when Apple rebased their OS on FreeBSD. Windows still uses a two-character CR-LF sequence to indicate newline, but since that includes a <code>\n</code>, it should not lead to this particular problem.</p>

<p>So all I can suggest is that you examine your input file with a hex editor (or just look at it with <code>hd</code>) and see what the character code(s) at the end of the lines are. </p>
",2
55695611,55691946,0,"<p>You're close, but not quite there. The global variable must also be <em>defined</em> in the global scope, and you're running into the difference between <em>declaration</em> and <em>definition</em> (which are easy to get the wrong way round but the words don't matter as much as the idea). Normally, your statements that introduce a variable will both declare and define simultaneously, but not so with globals that are shared between modules like this:</p>

<p>In your <code>file1.h</code>, you are correctly <em>declaring</em> the <code>char*</code> variable in the global scope. Anyone who includes this file (e.g. <code>file2.c</code>) will ""see"" that the variable with that name should exist and all modules will compile cleanly, and the <code>extern</code> keyword makes explicit that you are only declaring this to exist, not creating storage for it yet. That is what you want, because you don't want to accidentally create multiple conflicting global variables with this name. When the compiled modules are eventually linked together, the linker will look for the actual memory storage space set aside for the global and connect all the references up correctly.</p>

<p>But in your case, that won't happen correctly, because although you have declared to the world that this global exists, you haven't yet actually created storage for the variable! </p>

<p>You still need to do this in the global scope (outside the functions) in <code>file1.h</code>:</p>

<pre><code>char * global; 
</code></pre>

<p>That creates the actual variable with the matching name to the extern declaration, and so the linker will be able to assemble your modules correctly. </p>

<p>So </p>

<pre><code>#include ""file1.h""

// Define global:
char * global;

int main() {
     // Assign a value to the global variable:
     global = some_struct-&gt;data;

     //more code
}
</code></pre>

<p>Note that you don't redeclare the extern or anything in this file, and you don't redefine the type of <code>global</code> inside <code>main</code>, because it already exists, and you can assign to it or look at its value. You also don't use the keyword <code>extern</code> here-- it is the ""home"" module for this variable.</p>

<p>Declaration and definition are generally just accomplished simultaneously, for example when you declare local variables within a function. Globals that are accessible from different modules rely on splitting the work into the two separate ideas so that both coworkers and the compiler and linker toolchain are not confused by your intentions. </p>
",1
55692058,55691946,2,"<p>in <em>main</em></p>

<blockquote>
<pre><code>     extern char *global = some_struct-&gt;data;
</code></pre>
</blockquote>

<p>is wrong, if you want to assign <em>global</em> do :</p>

<pre><code>     global = some_struct-&gt;data;
</code></pre>

<p>and some where at global scope you need to define <em>global</em> :</p>

<pre><code>char *global;
</code></pre>

<p>So for instance <em>main</em> become :</p>

<pre><code>#include ""file1.h""

char *global;

int main() {
     //some code
     global = some_struct-&gt;data;
     //more code
}
</code></pre>
",3
55716736,55716162,2,"<p>The proper format operator for reading a single character is <code>%c</code>, not <code>%1s</code>. The latter reads a single character, but writes it into a null-terminated string, so it will write a null byte outside the <code>userLetter</code> variable, which causes undefined behavior.</p>

<p>You should put a space before the operator to make <code>scanf</code> skip over whitespace before reading the character. This is needed to make it ignore the newline after each response.</p>

<p>You should also turn off output buffering or flush the buffer after each prompt, since they don't end with a newline.</p>

<p>There's no need for the <code>while</code> loop at the end, since you don't get out of the first loop until the characters match.</p>

<p>This is a working version:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{

    char myLetter = 'a';

    setbuf(stdout, NULL);
    printf(""insert a char:"");

    char userLetter;
    scanf("" %c"", &amp;userLetter);

    while (userLetter !=  myLetter)
    {
        printf(""%c does not match mine, try again:"", userLetter);
        scanf("" %c"", &amp;userLetter);
    }

    printf(""char matches! program will terminate now.\n"");
}
</code></pre>
",0
55832064,55832010,8,"<p>The <code>%s</code> format specifier to <code>printf</code> is used to print a string and expects a <code>char *</code> argument which points to the first element of a null-terminated character array.  The <code>%d</code> format specifier is used to print an integer in decimal format and expects an <code>int</code>.</p>

<p>Since <code>str</code> is an array, when used in an expression it <em>decays</em> into a pointer to its first element.  So <code>str</code> in an expression has type <code>char *</code>, which matches what <code>%s</code> expects.</p>

<p><code>*str</code> is not valid for <code>%s</code> because that has type <code>char</code> and has a value of the first character in an array.  Using the wrong format specifier for a given argument to <code>printf</code> invokes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">undefined behavior</a>.</p>

<p><code>*p</code> is valid for <code>%d</code> because <code>p</code> has type <code>int *</code>, meaning that <code>*p</code> has type <code>int</code>, which matches what <code>%d</code> expects.</p>
",8
55733047,55732975,2,"<p><code>scanf</code> stops processing input as soon as any conversion fails, going from left to right, it doesn't try to process the remaining inputs. </p>

<p>So when you enter</p>

<pre><code>b b 2.8
</code></pre>

<p>it fails when trying to do the first <code>%lf</code> conversion. Since no conversions have been done, it returns <code>0</code>.</p>

<p>When you enter</p>

<pre><code>2 x 2.1
</code></pre>

<p>it successfully converts <code>2</code> to a <code>double</code>, but fails on <code>x</code>, so it doesn't process <code>2.1</code> and returns <code>1</code>.</p>
",0
55736317,55736187,0,"<p>First of all, instead of declaring <code>float height;</code>, you need to declare <code>struct HealthProfile H;</code>. Better yet, declare <code>struct HealthProfile profile;</code> and replace <code>H</code> everywhere with <code>profile</code>.</p>

<p>Next, fix your <code>scanf()</code> statements. For example</p>

<pre><code>scanf(""%s"", &amp;H.name);
</code></pre>

<p>should be</p>

<pre><code>scanf(""%s"", profile.name);
</code></pre>

<p>Similarly change</p>

<pre><code>scanf(""%f"", &amp;H.height);
</code></pre>

<p>to</p>

<pre><code>scanf(""%f"", profile.height);
</code></pre>

<p>Now your syntax for <code>printf()</code> will be correct.</p>

<p><strong>However, you will still have problems because non of your pointers have been allocated memory.</strong> Declaring the <code>name</code> and <code>last</code> fields as pointers makes sense. However, I think you should declare <code>float height;</code> and <code>float weight;</code> instead of using pointers for these values. If you do so, then your original <code>scanf()</code> statements with the <code>&amp;</code> operator will be correct.</p>
",1
55738550,55738412,1,"<p><code>""123456789""</code> is a <em>string literal</em>. It is an object of type <code>char [10]</code> in C. It is an object of array type.</p>

<p>When an object of array type is used with binary <code>+</code> operator, it gets implicitly converted (decays) to pointer type. The resultant pointer value points to the beginning of the array. So, the original <code>char [10]</code> array decays to <code>char *</code> pointing to character <code>'1'</code> in <code>""123456789""</code>.</p>

<p>Binary operator <code>+</code>, when applied to a pointer, performs <em>pointer arithmetic</em>. Adding <code>3</code> to a <code>char *</code> pointer produces a pointer that points 3 bytes to the right of the original pointer. So, you get a pointer that points to character <code>'4'</code> in <code>""123456789""</code>.</p>

<p>After that you use format <code>%s</code> to ask ask <code>printf</code> to print a string that begins from that <code>'4'</code>. And that is the output you get.</p>

<hr>

<p>The same thing happens in C++, except that in C++ this string literal has <code>const char [10]</code> type and decays to <code>const char *</code> pointer,</p>
",0
55876921,55876648,1,"<p>Add a <code>printf</code> statement to the top of your <code>bq</code> function:</p>

<pre><code>void bq(int* v, int s, int e) {
    printf(""e=%d, s=%d,  e+s+1=%d\n"", e, s, e + s + 1);
    if (e + s + 1 &gt; 2) {
</code></pre>

<p>When you run your program, you'll see this is the output;</p>

<pre><code>e=9, s=0,  e+s+1=10
e=9, s=6,  e+s+1=16
e=9, s=9,  e+s+1=19
e=9, s=10,  e+s+1=20
e=9, s=11,  e+s+1=21
e=9, s=11,  e+s+1=21
e=9, s=11,  e+s+1=21
e=9, s=11,  e+s+1=21
e=9, s=11,  e+s+1=21
e=9, s=11,  e+s+1=21
e=9, s=11,  e+s+1=21
e=9, s=11,  e+s+1=21
e=9, s=11,  e+s+1=21
e=9, s=11,  e+s+1=21
...
</code></pre>

<p>In other words, the <code>bq</code> function converges to just invoking itself recursively with the same parameters: <code>bq(v, 9, 11)</code>.  But since <code>9+11+1</code> is always greater than <code>2</code>, it's in an infinite recursive loop. Otherwise known as Stack Overflow. The end result is you run out of stack memory and the program crashes.</p>

<p>My psychic powers suggest this line:</p>

<pre><code>if (e+s+1 &gt; 2){
</code></pre>

<p>Was intended to express, ""if I have at least two elements in the range of v[s..e]"".  In which case, it should read:</p>

<pre><code>if (e-s+1 &gt; 2){
</code></pre>

<p>Not sure about the rest of your program being correct, but that's a start.</p>
",2
56467849,56467763,3,"<p><code>ftell</code> reports the current position in the file. For a file that has just been opened, the position is the start, and <code>ftell</code> returns zero. Then, since <code>size</code> is zero, the loop in <code>findnum_lines</code> processes zero characters and reports no lines were found.</p>

<p>Generally, you do not want to get the file size and then loop on that. One reason is that the file can change while you read it¡ªother processes may write more data to it or may truncate it. Another reason is that it is unnecessary. Just read characters until you get <code>EOF</code>, using a <code>while</code> loop (or a <code>do ¡­ while</code> loop).</p>

<p>Additionally, <code>char line;</code> should be <code>int line;</code> because it is used to hold the result of <code>getc</code>, which may be either a character or <code>EOF</code>, and a <code>char</code> is inadequate to hold <code>EOF</code>. (Also, <code>getc</code> returns the character¡¯s value as an <code>unsigned char</code> converted to an <code>int</code>, so, in an implementation where <code>char</code> is signed, <code>char</code> cannot even properly represent all characters.)</p>
",0
57150257,57150137,1,"<p>On a typical x86 platform an <code>int</code> is four bytes wide and is stored little endian. Little endian means the bytes are stored in reverse, least significant to most significant. The number 512 is represented in memory as 2 ¡Á 2<sup>8</sup>, or:</p>

<pre><code>{ 0x00, 0x02, 0x00, 0x00 }
// LSB              MSB
// 2^0  2^8   2^16  2^24
</code></pre>

<p>After the two assignments you have:</p>

<pre><code>{ 0x01, 0x02, 0x00, 0x00 }
// LSB              MSB
// 2^0  2^8   2^16  2^24
</code></pre>

<p>Converting these four bytes back to decimal you have 1 ¡Á 2<sup>0</sup> + 2 ¡Á 2<sup>8</sup> = 1 + 512 = 513.</p>
",1
55925994,55925728,0,"<p>A digit character has a character code value <code>'0'</code> to <code>'9'</code> (in the ASCII character set 0x30 to 0x39 or 48 to 57 decimal), while <code>rand() % 10</code> has integer value 0 to 9.</p>

<p>By adding the character code <code>'0'</code> (48) to the random number you will generate a random character code <code>'0'</code> to <code>'9'</code>.</p>

<pre><code>int main()
{
    char temp1 = rand() % 10 + '0' ;
    char temp = getch() ;

    if( temp == temp1 )
    {
        printf(""ok"");
    }

    return 0 ;
}
</code></pre>

<p>Alternatively if you subtract <code>'0'</code> from the  input <em>character</em> you will transform digit characters to their corresponding 0 to 9 integer values (and other characters to some other value).</p>
",1
56066412,56066067,4,"<blockquote>
  <p>I thought all symbolic links pointed to folders</p>
</blockquote>

<p>Nope.  A symbolic link is an indirect reference to another path.  That other path can refer to any kind of file that can be represented in any mounted file system, or to no file at all (i.e. it can be a broken link).</p>

<blockquote>
  <p>How to check that it points to a directory?</p>
</blockquote>

<p>You mention the <code>stat()</code> function, but for reimplementing <code>ls</code> you should mostly be using <code>lstat()</code>, instead.  The difference is that when the specified path refers to a symbolic link, <code>stat</code> returns information about the link's target path, whereas <code>lstat</code> returns information about the link itself (including information about the file type, from which you can tell that it <em>is</em> a link).</p>

<p>In the event that you encounter a symbolic link, you can simply check the same path again with <code>stat()</code> to find out what kind of file it points to.  <code>stat()</code> will recursively resolve symbolic links to discover the information for the ultimate target, which will be a symbolic link only if it is a broken one.  Any way around, you don't need to distinguish between a broken link and any other form of non-directory for your particular purpose.</p>
",2
56026213,56026096,4,"<p>This is the result of an out of range conversion.  In this case, an attempt is made to store a value out of the range of an <code>int</code> in an <code>int</code>.  Because <code>int</code> is signed, the conversion happens in an implementation defined way.  </p>

<p>On a system using two's complement representation of negative numbers, this typically means that the value wraps around which is what you're seeing here.</p>

<p>Compilers aren't required to warn when something like this happens, but they can if they chose to.  For example, gcc will not warn with <code>-Wall -Wextra</code> but will warn with <code>-Wconversion</code>.</p>

<p>This behavior is documentated in section 6.3.1.8 of the <a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf"" rel=""nofollow noreferrer"">C standard</a> regarding integer conversions:</p>

<blockquote>
  <p><em>1</em> When a value with integer type is converted to another integer type
  other than
  _Bool ,if the value can be represented by the new type, it is unchanged.</p>
  
  <p><em>2</em> Otherwise,  if  the  new  type  is  unsigned,  the  value  is 
  converted  by  repeatedly  adding  or subtracting  one  more  than 
  the  maximum  value  that  can  be  represented  in  the  new type
  until the value is in the range of the new type.</p>
  
  <p><em>3</em> <strong>Otherwise,  the  new  type  is  signed  and  the  value  cannot  be 
  represented  in  it;  either  the result is implementation-defined or
  an implementation-defined signal is raised.</strong></p>
</blockquote>
",4
56036552,56026096,0,"<p>For historical reasons, C compilers are very lenient by default and accept silly errors without blinking.</p>

<p>It is quite advisable to ask the compiler for extra warnings and make these errors with <code>-Wall -Werror</code> or even stricter settings such as <code>gcc -Wextra</code> or <code>clang -Weverything</code>.</p>

<p>Here is my trace:</p>

<pre><code>chqrlie$ clang -Wall -Werror overf.c
overf.c:4:15: error: implicit conversion from 'long' to 'int' changes value from 2147483700 to -2147483596 [-Werror,-Wconstant-conversion]
    int num = 2147483700;
        ~~~   ^~~~~~~~~~
1 error generated.
</code></pre>
",3
57814900,57814833,0,"<p>So what we want to do is run Q1 and Q2 in a pipeline, almost as though the starting command was <code>./Q1 | ./Q2</code>, but have Q1 do it. While the exec family of functions is necessary, it is not quite sufficient. Setting up the whole of the pipe is easy.</p>

<p>At the top of Q1:</p>

<pre><code>int main()
{
    int pipefd[2];
    pid_t pid;
    pipe(&amp;pipefd);
    if (0 == (pid = fork()) {
        close(pipefd[1]);
        dup2(pipefd[0], 0);
        close(pipefd[0]);
        execl(""Q2"", ""Q2"", ...);
        _exit(3);
    }
    dup2(pipefd[1], 1);
    close(pipefd[1]);
    close(pipefd[0]);

    /* any output with `printf()` is now input to Q2; anything with `fprintf(stderr)` still displays on screen */
}
</code></pre>

<p>Error handling mostly omitted for brevity. <code>pipe()</code>, <code>fork()</code>, and <code>execl()</code> can fail. With the first two, they return -1 for failure; if <code>execl()</code> returns at all you know it failed. I prefer <code>perror()</code> for error messages.</p>
",0
58717740,58717638,3,"<p>From <a href=""https://linux.die.net/man/3/memcmp"" rel=""nofollow noreferrer"">memcmp(3)</a>:</p>

<blockquote>
  <p>The memcmp() function returns an integer <strong>less than</strong>, <strong>equal to</strong>, or <strong>greater than</strong> zero if the first n bytes of s1 is found, respectively, to be less than, to match, or be greater than the first n bytes of s2.</p>
</blockquote>

<p>The only thing that matters about the return value are is it less than zero, equalt to zero, or greater than zero.</p>
",0
59559076,59559043,4,"<p>Suppose you try to write:</p>

<pre><code>int foo = B * 10;
</code></pre>

<p>You probably expect this to set <code>B</code> to <code>1010</code>. But it will actually set it to <code>110</code> because it expands to</p>

<pre><code>int foo = 100+1 * 10;
</code></pre>

<p>Because of operator precedence, the multiplication is done first, so it's <code>100 + 10</code>, not <code>101 * 10</code>.</p>

<p>To prevent problems like this, you should put parentheses around the macro expansion.</p>

<pre><code>#define B (A+1)
</code></pre>

<p>Then it will expand to</p>

<pre><code>int foo = (100+1) * 10;
</code></pre>

<p>and you'll get the expected result.</p>
",0
56315823,56314824,-1,"<p>Taking a clue from your heading that this is networking code, what you are likely looking at is a packet decoder.   In this case, it has noticed that the ethernet frame (wikipedia) has had a vlan header pre-pended to it.  The code is skipping past this header to inspect the encapsulated packet.</p>

<p>Somebody pointed out that this is the dreaded Undefined Behaviour.  I am not certain whether the observation that virtually all systems code, including the internet, relies on what is now Undefined Behaviour speak more about the integrity of the worlds computers and networks or the delusional belief that standards bodies are somehow beyond reproach.   I have been on standards working groups; and am living evidence that they aren't that bright.</p>
",0
59333194,59333184,2,"<p>Your helper variables are <strong>uninitialized</strong> and therefore untrustworthy (besides causing UB)</p>

<pre><code>// int hasupper, haslower, hasdigit;
int hasupper = 0, haslower = 0, hasdigit = 0;
</code></pre>
",0
58224985,58224638,23,"<p>I don't completely like either your version or your teacher's. Your teacher's version does the extra tests that you correctly point out are unnecessary. C's mod operator is not a proper mathematical mod: a negative number mod 10 will produce a negative result (proper mathematical modulus is always non-negative). But since you're squaring it anyway, no difference.</p>

<p>But this is far from obvious, so I would add to your code not the checks of your teacher, but a big comment that explains why it works. E.g.:</p>

<p>/* NOTE: This works for negative values, because the modulus gets squared */</p>
",5
58404320,58224638,6,"<h1>This reminds me of an assignment that I failed</h1>
<p>Way back in the 90's. The lecturer had been sprouting on about loops and, long story short, our assignment was to write a function that would return the number of digits for any given integer &gt; 0.</p>
<p>So, for example, the number of digits in <code>321</code> would be <code>3</code>.</p>
<p>Although the assignment simply said to write a function that returned the number of digits, the expectation was that we would use a loop that divides by 10 until... <em>you get it, as covered by the lecture</em>.</p>
<p>But using loops was not explicitly stated so I: <code>took the log, stripped away the decimals, added 1</code> and was subsequently lambasted in front of the whole class.</p>
<p><strong>Point is, the purpose of the assignment was to test our understanding of what we had learned during lectures</strong>. From the lecture I received I learned the computer teacher was a bit of a jerk (but perhaps a jerk with a plan?)</p>
<hr />
<h1>In your situation:</h1>
<blockquote>
<p>write a function in C/C++ that returns the sum of the digits of the number squared</p>
</blockquote>
<p>I would definitely have provided two answers:</p>
<ul>
<li>the correct answer (squaring the number first), and</li>
<li>the incorrect answer in keeping with the example, just to keep him happy ;-)</li>
</ul>
",3
56629864,56629378,2,"<p>It is an unnamed bit-field, basically used-defined bit padding. From C17 6.7.2.1:</p>

<blockquote>
  <p>A bit-field declaration with no declarator, but only a colon and a width, indicates an
  unnamed bit-field. As a special case, a bit-field structure member with a width of 0 indicates that no further bit-field is to be packed into the unit in which the previous bitfield, if any, was placed.</p>
</blockquote>

<p>So I would guess it is used to get a certain memory layout, perhaps to correspond with a certain pre-defined hardware register or communication protocol.</p>

<p>But also please note that it isn't well-defined which bit that's the MSB, and that the compiler if free to add padding of its own, so this bit-field isn't portable between compilers or systems. It is best to avoid bit-fields entirely, for any purpose.</p>
",0
56916266,56915607,1,"<p><code>-&gt;</code> is an (implicit) indirection operator -- <code>a-&gt;b</code> is the same as <code>(*a).b</code>.  So when you write</p>

<pre><code>*(students+i)-&gt;studentID
</code></pre>

<p>that's the same as</p>

<pre><code>*(*(students+i)).studentID
</code></pre>

<p>with TWO indirection operations.</p>
",0
56915657,56915607,-1,"<p>You <strong>can</strong> use the indirection operator here, but then you use the member operator <code>.</code> instead of <code>-&gt;</code>:</p>

<pre><code>printf(""%d\n"", (*(students+i)).studentID);
</code></pre>

<p>This is semantically the same as</p>

<pre><code>printf(""%d\n"", (students+i)-&gt;studentID);
</code></pre>
",0
56755479,56755269,3,"<p>In the general case it's not doable at compile time, since there is no way to convey such requirements, and even if there were, it might not be possible for the compiler to prove in every case that all code paths leading to <code>get_something</code> have first called <code>init</code>.</p>

<p>In some special cases you might be able to get a compile-time warning through some questionable hacks, e.g., have your <code>something.h</code> contain <code>static void init(void) { real_init(); }</code> ¨C then some compilers with enough warnings enabled will warn of an unused <code>static</code> function <code>init</code> unless you call it (from anywhere ¨C there might still be code paths that don't call it).</p>

<p>At runtime, you could keep track of whether <code>init</code> has been called and <code>assert</code> that it has been called in everything that depends on it. (The <code>assert</code> macro can then be compiled to nothingness in production code, see documentation.)</p>
",0
56755612,56755269,1,"<p>AFAIK there is no way to do that, a very very ugly trick if you can use static asserts (C11) and the <code>__COUNTER__</code> predefined macro is check if <code>init()</code> is called at some point in the program, something like:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

#define init() do {__COUNTER__; init();} while(0);

void (init)(void) // parenthesis prevents the expansion and allows you 
                  // to call a macro with the same name
{
    /* ... */
}

int get_something(void)
{
    /* ... */
    return 0;
}

int main(void)
{
    static_assert(__COUNTER__ == 1, ""init() is never used"");
    return 0;
}
</code></pre>
",7
56851520,56849082,1,"<p>You need to go back to the basics (this means: reading a good C book before diving in). You are confusing <em>declaration</em> and <em>calling</em> of functions.</p>

<pre><code>int main()
{
  void Num();

  return 0;
}
</code></pre>

<p><code>main</code> contains two statements:</p>

<ol>
<li>A local (re)declaration of <code>Num</code> as a function without return value.</li>
<li>A <code>return</code> statement.</li>
</ol>

<p>Since you want to <em>call</em> <code>Num</code> rather than redeclaring it, you need to use the function call syntax:</p>

<pre><code>int main()
{
  Num();
  return 0;
}
</code></pre>

<p>This is just the first step, however. Your <code>Num</code> function does not perform the correct actions to determine primality.</p>
",0
56838260,56832438,5,"<p>How memory for variables is allocated is entirely a function of the implementation - the answer will vary from platform to platform.  Variables don't have to be laid out in the order they were declared, and depending on alignment requirements, there may be ""holes"" (unused bytes) between the end of one variable and the beginning of another.  </p>

<p>Here's what's likely happening on your system (all byte values in hex format):</p>

<pre><code>   +----+
y: | 41 | 0x7fffcc33e10b    
   +----+
x: | 0a | 0x7fffcc33e10c    // assuming little-endian representation
   +----+
   | 00 | 0x7fffcc33e10d
   +----+
   | 00 | 0x7fffcc33e10e
   +----+
   | 00 | 0x7fffcc33e10f
   +----+
</code></pre>

<p>On x86 and similar platforms, the stack grows ""downward"" towards decreasing addresses (x86 is also little-endian, so the addressed byte is the least significant byte of a multi-byte object).  So <code>x</code> is allocated ""first"" at address <code>0x7fffcc33e10c</code>, and then <code>y</code> is allocated at the next available object address.  Since <code>y</code> is a <code>char</code> and only a single byte wide, that next available address is <code>0x7fffcc33e10b</code>.  If <code>y</code> were also a 4-byte <code>int</code>, then the next available address would be <code>0x7fffcc33e108</code>, and the layout would be something like this:</p>

<pre><code>   +----+
y: | 41 | 0x7fffcc33e108
   +----+
   | 00 | 0x7fffcc33e109
   +----+
   | 00 | 0x7fffcc33e10a
   +----+
   | 00 | 0x7fffcc33e10b
   +----+
x: | 0a | 0x7fffcc33e10c    
   +----+
   | 00 | 0x7fffcc33e10d
   +----+
   | 00 | 0x7fffcc33e10e
   +----+
   | 00 | 0x7fffcc33e10f
   +----+
</code></pre>

<p><strong>EDIT</strong> </p>

<p>An interesting exercise would be to declare</p>

<pre><code>int x = 10;
char y = 'A';
int z = 20;
</code></pre>

<p>and see how they're laid out.  If they were laid out in the order declared, then you will likely see one or more unused bytes between <code>y</code> and <code>z</code>, since most platforms require multi-byte objects to start at an even address.  I wouldn't be surprised if a compiler decided to lay them out as <code>x</code>, <code>z</code>, <code>y</code>, since that would minimize any such ""holes"".  </p>

<p><strong>EDIT OF THE EDIT</strong></p>

<p>Tried it myself, got the following result:</p>

<pre><code>       Item         Address   00   01   02   03
       ----         -------   --   --   --   --
          x  0x7ffee73b8a78   0a   00   00   00    ....

          y  0x7ffee73b8a77   41   0a   00   00    A...

          z  0x7ffee73b8a70   14   00   00   00    ....
</code></pre>

<p>Three unused bytes between <code>y</code> and <code>z</code>, so 4-byte objects clearly must be aligned to addresses that are multiples of 4.  Graphically, we have</p>

<pre><code>    +----+
z : | 14 | 0x7ffee73b8a70
    +----+ 
    | 00 | 0x7ffee73b8a71
    +----+
    | 00 | 0x7ffee73b8a72
    +----+
    | 00 | 0x7ffee73b8a73
    +----+
    | ?? | 0x7ffee73b8a74
    +----+
    | ?? | 0x7ffee73b8a75
    +----+
    | ?? | 0x7ffee73b8a76
    +----+
 y: | 41 | 0x7ffee73b8a77
    +----+
 x: | 0a | 0x7ffee73b8a78
    +----+
    | 00 | 0x7ffee73b8a79
    +----+
    | 00 | 0x7ffee73b8a7a
    +----+
    | 00 | 0x7ffee73b8a7b
    +----+
</code></pre>
",0
58258040,58257938,1,"<p>It is because you compile and run your code on little-endian architecture machine (x86 for example)</p>

<p>At first you put 4 bytes in memory in order: <code>01 02 03 04</code>. Than convert pointer to this array to pointer to int. On little-endian machine memory block <code>01 02 03 04</code> represents integer value 0x04030201 which is printed on next step.</p>

<p>See <a href=""https://en.m.wikipedia.org/wiki/Endianness"" rel=""nofollow noreferrer"">https://en.m.wikipedia.org/wiki/Endianness</a> for more information</p>
",0
57932316,57932295,6,"<p>The comma operator <code>,</code> evaluates its left operand, discards the value, and uses the right operand as the result of the operator.  However it also has the lowest precedence, lower even than the assignment operator <code>=</code>.  So this:</p>

<pre><code>z=x,y;
</code></pre>

<p>Parses as:</p>

<pre><code>(z=x),y;
</code></pre>

<p>So in this expression, <code>z</code> gets assigned the value of <code>x</code> which is 7.  That value, being the left operand of the comma operator, gets discarded and the value of <code>y</code> is evaluated.  The final value of the expression, 8, then gets discarded as well as it is the final value of an expression statement.</p>

<p>Had you done this:</p>

<pre><code>z=(x,y);
</code></pre>

<p>Then the comma operator would evaluate to the value of <code>y</code> which is 8, then that value would get assigned to <code>z</code>.</p>
",0
59332094,59332056,1,"<p>Friday night, and I'm bored, so here's the answer.</p>

<p>But you also get a Down Vote and a VTC</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;limits.h&gt;
int main(void)
{
    for(uint8_t c = 0; c &lt; UCHAR_MAX; ++c)
    {
        uint8_t out[2] = {c};
        printf(""%d (%s)\n"", c, isprint(c)? out : ""*unprintable*"");
    }

    return 0;
}
</code></pre>

<h3>Output</h3>

<pre><code>Success #stdin #stdout 0s 4288KB
0 (*unprintable*)
1 (*unprintable*)
2 (*unprintable*)
3 (*unprintable*)
4 (*unprintable*)
5 (*unprintable*)
[....]
29 (*unprintable*)
30 (*unprintable*)
31 (*unprintable*)
32 ( )
33 (!)
34 ("")
35 (#)
36 ($)
37 (%)
38 (&amp;)
39 (')
40 (()
41 ())
42 (*)
43 (+)
[...]
65 (A)
66 (B)
67 (C)
68 (D)
69 (E)
70 (F)
71 (G)
</code></pre>
",1
58398880,58397937,0,"<p>If printing is all you want to do, you can do this with the same long division you were taught in elementary school:</p>

<pre><code>#include &lt;stdio.h&gt;


/*  Print the decimal representation of N/D with up to
    P digits after the decimal point.
*/
#define P   60
static void PrintDecimal(unsigned N, unsigned D)
{
    //  Print the integer portion.
    printf(""%u."", N/D);

    //  Take the remainder.
    N %= D;

    for (int i = 0; i &lt; P &amp;&amp; N; ++i)
    {
        //  Move to next digit position and print next digit.
        N *= 10;
        printf(""%u"", N/D);

        //  Take the remainder.
        N %= D;
    }
}


int main(void)
{
    PrintDecimal(1562, 4995);
    putchar('\n');
}
</code></pre>
",1
57128778,57128746,1,"<p>You've declared <code>Point.x</code> as type <code>int *</code>, i.e. a pointer to an <code>int</code>, but you assign an <code>int</code> to it and print it as an <code>int</code>.</p>

<p>Change the type to <code>int</code>.</p>

<pre><code>struct Point { 
    int x; 
};
</code></pre>
",1
57302936,57302654,1,"<p>Ternary operator has higher precedence than assignment, that's why your code is equal to <code>(k &lt; m ? k++ : m) = k;</code>. Your compiler says that the value in brackets is not assignable.</p>

<p>What you want to do is:</p>

<pre><code>#include &lt;stdio.h&gt;

void main()
{
    int k = 8;
    int m = 7;
    k &lt; m ? k++ : (m = k);
    printf(""%d"", k);
}
</code></pre>
",0
57839159,57839064,1,"<p>This will get you most of the way there if you are trying to do what I think you are trying to do.  Your example doesn't seem to indicate you want to create integers like</p>

<p>['0', '0', '0'] going to [0, 0, 0], so I didn't do any subtraction.  Your example indicates a direct ascii conversion.</p>

<p>Here is the answer that gives me [113, 113, 113, 0, 0, 0, 0..0] by using the code you provided:</p>

<pre><code>char input[50] = { 0 }, ch;
int intinput[50] = { '\0' };
int j = 0, l = 0;



printf(""Enter Cleartext: "");
while ((ch = getchar()) != '\n') {
    input[j] = ch;
    j++;
}

for (l = 0; input[l] != '\0'; l++) {
    intinput[l] = (int)input[l];
}
</code></pre>
",1
57340317,57340253,4,"<p><code>unsigned</code>s are usually 4-8 bytes. You're reading just 1 byte into them, leaving the rest indeterminate. </p>

<p>If you want to read just one byte, you should read it into an <code>unsigned char</code>.</p>

<p>If you want to keep using <code>unsigned int</code>s, you could pre-zero them, and then you'd get the result you want provided you're on a two's complement machine.</p>

<p>In real code, you should also be checking your return values (at least for <code>fopen</code> and <code>fread</code>).</p>
",1
58739434,58739009,1,"<p>How about there, it appears there's a way: the IP Helper library.</p>

<p>Ref: <a href=""https://docs.microsoft.com/en-us/windows/win32/iphlp/ip-helper-start-page"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/windows/win32/iphlp/ip-helper-start-page</a></p>

<p>I haven't used it for this, but it's clearly going down the right road by providing everything you need to basically roll your own <code>netstat.exe</code>.</p>

<p>The low-level object that contains all the info is <code>MIB_TCPROW2</code>, which has the local and remote address + port, plus <code>dwOwningPid</code>. So we know there's a way.</p>

<p>Drilling down we ultimately need the <code>GetTcpTable2()</code> call, and Microsoft's web page helpfully has what appears to be fully-functional C code to do all this yourself.</p>

<p><a href=""https://docs.microsoft.com/en-us/windows/win32/api/iphlpapi/nf-iphlpapi-gettcptable2"" rel=""nofollow noreferrer"">https://docs.microsoft.com/en-us/windows/win32/api/iphlpapi/nf-iphlpapi-gettcptable2</a></p>

<p>Finding this was the best surprise of my day!</p>
",3
59116826,59116752,2,"<p>You have to put a <code>&amp;&amp;</code> (and) instead of <code>||</code> (or) in the test of while. </p>

<p>The input is invalid if it¡¯s not an r <strong>and</strong> not a p <strong>and</strong> not a s.  </p>
",0
59011106,59010673,2,"<p>Your problem is not actually on the code but on the maths behind it. In your sine function,</p>

<pre><code>double sinTrig(double angle) 
{
   double imgSet = 0;
   double sum = 0;
   int n = 0;
   double x;
   x = angle * pi/180;
   do
   {
       imgSet = power(-1,n) * power(x,2*n+1) / (double)factorial(2*n+1);
       sum = sum + imgSet;
       n++;
   }while(abs(imgSet) &gt;= 0.00001);
   printf(""\n The sine of %.3lf is :: sin(%.2lf) --&gt; %.3lf"", angle, angle, sum);
   return sum;
}
</code></pre>

<p>you compute, as you well said, the MacLaurin series (also known as the Taylor series centered in 0). This means that your function approximates well the sine  function for angles close enough to 0, but the error becomes bigger when the angle is farther from 0.</p>
",3
58641354,58641170,0,"<p>Try this logic. Not tested</p>

<pre><code>        #include &lt;stdio.h&gt;

    int main()
    {
        int num, i, flag = 0;
        printf(""Enter a positive integer: "");
        scanf(""%d"", &amp;num);
        int isPrime=IsPrime(num)
        if(isPrime==0){
        numNext=num+1;
        int nextPrimeNum=checkNextPrime(numNext);
        }
    }

    int IsPrime(int num){
        for(i = 2; i &lt;= num/2; ++i)
        {
            // condition for nonprime number
            if(num%i == 0)
            {
                flag = 1;
                break;
            }
        }
        if (num == 1) 
        {
            flag=1;//neither prime nor composite
        }   

        return flag;

    }
    int checkNextPrime(int numNext){

        int isNextPrime=IsPrime(numNext)
        if(isNextPrime==0){
            printf(""This is the required output :""numNext);
            return numNext;
        }
        else{
            numNext=numNext+1;
            checkNextPrime(int numNext)
        }   
    }

</code></pre>
",2
58736213,58736158,6,"<p>Strings require a null terminator.</p>

<pre><code>#include &lt;stdio.h&gt;

void main(){
    char ini[11]={'a','b','c','d','e','f','g','h','i','j', 0};
    char final[11];

    for (int i = 0; i &lt; 10 ; i++) {
        final[i]=ini[10-1-i];
    }
    final[10] = 0;
    printf(""%s\n\n"",ini);
    printf(""%s"",final);
}
</code></pre>

<p>If you use a string literal as the initializer, it includes the terminator automatically. The following is equivalent:</p>

<pre><code>char ini[] = ""abcdefghij"";
</code></pre>
",0
58807075,58806983,4,"<p>You have <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer""><em>undefined behavior</em></a> as you use the <code>%d</code> format for <a href=""https://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow noreferrer""><code>scanf</code></a>. This format specifier expects the argument to be a pointer to <code>int</code>.</p>

<p>Mismatching format specifier and argument type leads to UB.</p>

<p>For <code>uint16_t</code> use the macro <code>SCNu16</code> (as documented in e.g. <a href=""https://en.cppreference.com/w/c/types/integer#Format_macro_constants"" rel=""nofollow noreferrer"">this reference</a>):</p>

<pre><code>scanf(""%"" SCNu16, &amp;a);
</code></pre>
",1
58926016,58925525,0,"<pre><code>    if(score &gt;=0  || score &lt;= 100)
</code></pre>

<p>Every number is either greater than or equal to zero or less than or equal to 100. There is no number that is excluded by this test.</p>

<p>To prevent the -1 from counting, you can add <code>if (score == -1) break;</code> before the other <code>if</code> tests. Also, you probably don't want a score of 120 to cause <code>passing</code> to be incremented.</p>
",0
58823180,58811751,0,"<blockquote>
  <p>Is there a different function like sscanf to find specific format input fields and save them?</p>
</blockquote>

<p>There are plenty of scanning/parsing functions, yes. There are more standard ones in C++ than there are in C, but you can always use external libraries.</p>

<blockquote>
  <p>My problem is i specified the right regex with sscanf</p>
</blockquote>

<p>But as I said already, <a href=""https://en.cppreference.com/w/c/io/fscanf"" rel=""nofollow noreferrer""><code>sscanf</code></a> <strong>does not use regular expressions</strong>.</p>

<p>I know that the <code>[character class]</code> syntax looks <em>similar to</em> regular expression syntax. It is, nevertheless, not a regex. I encourage you to read the documentation I linked which describes the syntax the <code>scanf</code> family <em>actually</em> uses.</p>

<blockquote>
  <p>If it doesn't use regular expressions it would've not worked on what I want to do by parts</p>
</blockquote>

<p>You're not checking your assumptions. Your assumptions are <em>wrong</em>, and you are failing to check carefully what is actually happening. This is entirely normal, and perfectly understandable, and can be a hard lesson to learn.</p>

<p>But you do need to learn it instead of telling the people giving you free help that you know better than them, especially when you're the one whose code doesn't work.</p>

<blockquote>
  <p>... you can test doing %[0-9]* or %[a-zA-Z]* and you'll see</p>
</blockquote>

<p>Here's an experiment. Try it yourself, and refer to that documentation as you go.</p>

<ul>
<li><p>step 1: the simplest thing that could possibly work.</p>

<p>Let's start by converting only the first field. We'll worry about all the rest later, and just write this according to the linked documentation.</p>

<pre><code>char tmp[100] = {};
int rv = sscanf(""a    oday    adsa    4"", ""%[a-zA-Z -]"", tmp);
printf(""sscanf returned %d, tmp is '%s'\n"", rv, tmp);
</code></pre>

<p>tells me that <code>sscanf returned 1</code>, because one field was successfully scanned. That field was <code>%[a-zA-Z -]</code>, defined in the documentation and further discussed below. To confirm, the value of tmp is indeed shown as <code>""a    oday    adsa    ""</code>.</p>

<blockquote>
  <p>[set] matches a non-empty sequence of character from set of characters</p>
</blockquote>

<p>Note there is no trailing <code>*</code>. The documentation suggests this is not needed, and we've confirmed that. We'll add it back in next to see what happens.</p></li>
<li><p>step 2: what the <code>*</code> does</p>

<pre><code>char tmp[100] = {};
int rv = sscanf(""a    oday    adsa    4"", ""%[a-zA-Z -]*"", tmp);
printf(""sscanf returned %d, tmp is '%s'\n"", rv, tmp);
</code></pre>

<p>tells me that <code>sscanf returned 1</code>, because one field was successfully scanned. That field was <code>%[a-zA-Z -]</code>, as before. Appending <code>*</code> to our format string didn't change the contents of <code>tmp</code> at all.</p>

<p>This time we added back the <code>*</code> at the end of the format string. Reading the linked doc, you see that since it is <em>not</em> part of a <code>%</code> format specifier, and is a</p>

<blockquote>
  <p>non-whitespace multibyte characters except %: each such character in the format string consumes exactly one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.</p>
</blockquote>

<p>But so far this has <em>no observable effect</em>, because it already matched the only input field. Failure would only affect the <em>next</em> conversion, and there aren't any yet. So, let's add one in our next test.</p></li>
<li><p>step 3: the effect of failure</p>

<pre><code>int val = 0;
rv = sscanf(""a    oday    adsa    4"", ""%[a-zA-Z -]*%d"", tmp, &amp;val);
printf(""scanf returned %d, tmp is '%s', val=%d\n"", rv, tmp, val);
</code></pre>

<p>tells me that <code>sscanf returned 1</code> because it converted one field <em>successfully</em>. The string output value is correct. It never converted the integer value, because there was an error before it reached <code>%d</code>, because the <code>*</code> in the format string did not match any literal <code>*</code> in the input.</p></li>
<li><p>step 4: what would actually work</p>

<pre><code>int val = 0;
rv = sscanf(""a    oday    adsa    4"", ""%[a-zA-Z -]%d"", tmp, &amp;val);
printf(""scanf returned %d, tmp is '%s', val=%d\n"", rv, tmp, val);
</code></pre>

<p>tells me that <code>sscanf returned 2</code> because it converted two fields. The string and integer output values are correct.</p></li>
<li><p>step 5: confirmation</p>

<pre><code>int val = 0;
rv = sscanf(""a    oday    adsa    *4"", ""%[a-zA-Z -]*%d"", tmp, &amp;val);
printf(""scanf returned %d, tmp is '%s', val=%d\n"", rv, tmp, val);
</code></pre>

<p>tells me that <code>sscanf returned 2</code> because it converted two fields. The string and integer output values are correct. Now, the literal <code>*</code> character in the format string matches the literal <code>*</code> I added to the input. This just confirms the behaviour matches the documentation.</p></li>
</ul>
",0
59061797,59061774,2,"<p>The socket you listen on is only for accepting new connections, not reading/writing data.  The <code>accept</code> function returns a file descriptor for the accepted socket.  That is the one you should be calling <code>recv</code> and <code>send</code> on.</p>

<pre><code>int newsock;
if((newsock = accept(sock, (struct sockaddr *) &amp;clientAddr, &amp;clientAddrSize)) &lt; 0) {
    exitMessage(""Could not accept new connections"");
}

if(recv(newsock, buffer, DATA_SIZE - 1, 0) &lt; 0) {
    exitMessage(""Failed to receive data from client"");      
}

printf(""\nReceived: \'%s\' to client\n"", buffer);
printf(""input data for client: "");

int index = 0;
while((data[index++] = getchar()) != '\n');

if(send(newsock, data, strlen(data), 0) &lt; 0) {
    exitMessage(""Failed sending to client"");
}
</code></pre>
",0
58850497,58850422,5,"<p>With your code:</p>

<pre><code>typedef struct TreeNode{
    int weight;
    TreeNode *left_child;
    TreeNode *right_child;
} TreeNode;
</code></pre>

<p>the name <code>TreeNode</code> is not known until the line <code>} TreeNode;</code> is parsed.  When processing the line <code>TreeNode *left_child;</code>, the compiler knows that there is a type <code>struct TreeNode</code>, but it doesn't know anything about a type <code>TreeNode</code>.</p>

<p>You can also use:</p>

<pre><code>typedef struct TreeNode Treenode;

struct TreeNode
{
    int weight;
    TreeNode *left_child;
    TreeNode *right_child;
};
</code></pre>

<p>The first line says ""there is a a structure type <code>struct TreeNode</code>, and <code>TreeNode</code> is an alias for that type"".  The remaining lines of code define what it means to be a <code>struct TreeNode</code>.</p>

<p>Alternatively, as the other answers point out, you can use:</p>

<pre><code>typedef struct TreeNode
{
    int weight;
    struct TreeNode *left_child;
    struct TreeNode *right_child;
} TreeNode;
</code></pre>

<p>The compiler knows enough about the type <code>struct TreeNode</code> to be able to handle pointers to the type as it reads the definition. Note C11 <a href=""https://port70.net/~nsz/c/c11/n1570.html#6.7.2.1p3"" rel=""nofollow noreferrer"">¡ì6.7.2.1 Structure and union specifiers ?3</a>:</p>

<blockquote>
  <p>A structure or union shall not contain a member with incomplete or function type (hence, a structure shall not contain an instance of itself, but may contain a pointer to an instance of itself), ¡­</p>
</blockquote>
",1
58980591,58980147,1,"<p>This code:</p>

<pre><code>fread(person1,sizeof(struct Person),1,fp);
</code></pre>

<p>... reads a <code>Person</code> structure from the file.</p>

<p>And this code:</p>

<pre><code>printf(""%s\n"",person1-&gt;name );
</code></pre>

<p>.. attempts to access the memory that <code>Person.name</code> points to.</p>

<p>But what does it point to? <code>name</code> contains a memory address that you read from the file, but no memory has been allocated for the name. You are reading the memory at that address but that address is no longer a valid memory address. And you get a segmentation fault when you attempt to access invalid memory.</p>

<p>There are several ways to deal with this but the easiest is to store the name in the same block of memory. You can do that like this:</p>

<pre><code>#define MAX_NAME 80

struct Person{
  char name[MAX_NAME + 1];
  int numb;
  char *kind;
};
</code></pre>

<p>Now, reading the person also reads the name. You'll also need to do the same thing with <code>kind</code> or you'll have the same problem there.</p>
",0
58961347,58960920,2,"<p>You were pretty much there, except you never allocated any memory for the string you're trying to produce. Here's a version which (apparently) runs correctly:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char* anybase(int n, int b)
  {
  char *s;
  int len;

  if(n == 0)
    {
    s = malloc(200);
    s[0] = '\0';
    }
  else
    {
    s = anybase(n/b, b);

    len=strlen(s);
    s[len] = ""0123456789ABCEDFGHIGKLMNOPQRSTUVWXYZ""[n%b];
    s[len+1]='\0';
    }

  return s;
  }

int main()
  {
  char *result;

  result = anybase(900000, 18);
  printf(""%s\n"", result);

  free(result);
  }
</code></pre>

<p>Note that since the buffer returned by <code>anybase</code> is allocated dynamically (using the <code>malloc</code> library function) it must be free'd after use.</p>
",2
59458319,59458305,4,"<p>At this point - <code>if(!mask[sea])</code>, the variable <code>sea</code> is unassigned. You are using the value of  <code>sea</code> as an offset for <code>mask</code>. This causes <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow noreferrer"">UB</a>. </p>

<p>The <code>for</code> statement that you commented out starts by assigning the integer <code>0</code> to <code>sea</code> using the assignment operator <code>=</code>. Assuming <code>mask</code> is an array, you are using the value of <code>sea</code> to jump to a specific element of the array in the <code>if</code> statement.</p>

<p>Now, that <code>sea</code> is unassigned, it might be anything (even a negative number). Thus, you are trying to access some element in an array using an unknown index. It's like you know which street your friend lives on, but you do not know the house number.</p>

<p>HTH</p>
",3
59340012,59339991,1,"<p>A program will perform tasks in the order in which they are written.</p>

<p>You simply need to ask for the values of a and b before performing calculations using them.</p>

<pre><code>#include &lt;stdio.h&gt;

int main(void) {
  int a, b, c, d, f, h, g;

  printf(""Enter two numbers:"");
  scanf(""%d %d\n"",&amp;a,&amp;b);

  c = a + b;
  d = a - b;
  f = a * b;
  h = a / b;
  g = a % b;

  printf(""%d\n"",c);
  printf(""%d\n"",d);
  printf(""%d\n"",f);
  if (b != 0 ) {
  printf(""%d\n"",h);
  printf(""%d\n"",g);
  }
}
</code></pre>

<p>To answer your other question, &amp; and * are dealing with pointers - the location of the variable in memory.  It took me a lot of time and practise before I felt comfortable with the concept, so don't be surprised if you struggle with it at first - stick with it - you'll get there.</p>

<p>Basically</p>

<pre><code>int n;
</code></pre>

<p>creates an integer variable in memory with n being it's reference name.
You can find the memory address at which that integer is stored using <strong>&amp;n</strong>.</p>

<pre><code>int *n;
</code></pre>

<p>creates a pointer to a memory location, with the pointer name being n.  It does not create an integer variable.</p>

<p>So, you can:</p>

<pre><code>int a;
int *p;

p=&amp;a; /* Set pointer to be the address of the variable a in memory */

a = 5;  /* Set a value for a */

printf(""a = %d\n"", a);   /* show a */
printf(""a = %d\n"", *p);  /* Show the contents at address p */

printf(""p = %p\n"", p);   /* show p */
printf(""p = %p\n"", &amp;a);  /* show the memory address where a is stored */
</code></pre>
",3
59035589,59035321,0,"<p>You have several of things going on in your program.  Let's start with this:  Think of a pointer as an address in computer memory.  In you main(), you're saying ""p is an address of a place to store an integer"" ... in most implementations, that would be 4 bytes.  But p currently doesn't have a value.</p>

<p>In your myPtr() routine, you set that address to 142:  you're telling the program that address 0x000008e (the hex equivalent of 142) is 4 bytes of memory for an integer ... but you don't know what's stored at that address.</p>

<p>The printf() format specifier, ""%d"", says you're going to pass an integer ... but what you pass is a pointer to memory, which is why you're getting that warning.  If what you wanted to do was print the address, you could use the format ""%p"", which tells printf() you are, indeed, passing a pointer.</p>

<p>If, on the other hand, you want to print a number, you need to dereference the pointer:</p>

<pre><code>printf(""%d"", *nbr);
</code></pre>

<p>The problem you'll hit with that on most systems is that you'll get a memory access error:  address 0x0000008e (142) is in a protected memory page on most systems (""page 0""), and you can't normally read or write that memory.</p>

<p>I think you need to find a good on-line tutorial on C pointers, taking the address of a variable with &amp;, and accessing the pointer with *.</p>
",0
59097663,59097608,1,"<p>The <code>==</code> operator doesn't work for comparing strings.  What it actually does in this case is compare the starting address of the string <code>Name</code> with the starting address of the string literal <code>""abc""</code>.  This is what the warning is saying.</p>

<p>The solution, as the warning says, is to use the <code>strcmp</code> function.</p>

<pre><code>if (strcmp(Name, ""abc"") == 0) {
</code></pre>

<p>This function returns 0 if both strings are the same, a negative value if the left operand is ""greater"", and a positive value if the right operand is ""greater"".</p>
",0
59320837,59320687,4,"<p>whatever you do, this code will always output ""Not found"":</p>

<pre><code>int kst, zero = 0, lengs;

// a lot of irrelevant stuff skipped

if (zero == 0)
    puts(""Not found "");   
</code></pre>
",1
59401211,59401003,1,"<p>Eljay has it. </p>

<pre><code>prod_matrix[i] = (double *)malloc((dim_col2)*sizeof(int)); 
</code></pre>

<p>should be </p>

<pre><code>prod_matrix[i] = (double *)malloc((dim_col2)*sizeof(double));
</code></pre>
",3
59469736,59469489,1,"<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 struct node {
    int data;
    struct node *next;
};
</code></pre>

<p>created type <code>struct node</code></p>

<pre><code>struct node *root = (node*)malloc(sizeof(struct node));
</code></pre>

<p>You cannot have code outside a function. The above line does not belong here, hanging out of any function like that.<br>
Besides that, it tries to convert the return value of the <code>malloc()</code> function (of <code>void*</code> type) to a pointer to a type that does not exist (type <code>node</code> does not exist; type <code>struct node</code> exists).<br>
And also, it is, at best redundant and at worse an error, wrong to cast the return value of <code>malloc()</code> in C.</p>

<pre><code>*root-&gt;next = NULL;
</code></pre>

<p>Again, a statement hanging out of any function. Illegal in C.</p>

<pre><code>void print (node*abc)
</code></pre>

<p>Type <code>node</code> does not exist, you can't use pointers to types that do not exist.</p>

<pre><code>{
    while(abc!=NULL)
    {
        printf (""%d"",abc-&gt;data);
        abc = abc-&gt;next;
    }
}
void addTail (node*abc)
</code></pre>

<p>Type <code>node</code> does not exist, you can't use pointers to types that do not exist.</p>

<pre><code>{
    while (abc-&gt;next!=NULL);
    abc-&gt;next = ( node*)malloc(sizeof(struct node));
}
int main ()
{
printf (""dd"");
}
</code></pre>

<p>Have fun!</p>
",2
59553646,59553611,1,"<p>If <code>*v</code> is legal then <code>&amp;*v</code> is equivalent to <code>v</code>. <code>&amp;</code> is the inverse of <code>*</code>.</p>

<pre><code>int *v = &amp;x;

v;        // address of x
*v;       // x
&amp;*v;      // address of x
</code></pre>
",6
59503011,59502916,2,"<p>Arguments to functions in C are passed by value, which means that changes made to the value of the argument within the body of the function has no effect once the function returns. A simple example:</p>

<pre><code>void foo(int a)
{
    a += 10;
}

int main()
{
    int b = 0;
    printf(""before: %d\n"", b);
    foo(b);
    printf(""after: %d\n"", b);
    return 0;
}
</code></pre>

<p>This will print:</p>

<pre class=""lang-none prettyprint-override""><code>before: 0
after: 0
</code></pre>

<p>If you want the calling function (<code>main</code> in this case) to see the updated value, you have to pass a pointer to <code>int</code> (you could also return the updated value, but we'll ignore that here):</p>

<pre><code>void foo(int *a)
{
    *a += 10;
}

int main()
{
    int b = 0;
    printf(""before: %d\n"", b);
    foo(&amp;b); /* Note that we are taking the address of 'b' here */
    printf(""after: %d\n"", b);
    return 0;
}
</code></pre>

<p>In this case our output would be:</p>

<pre class=""lang-none prettyprint-override""><code>before: 0
after: 10
</code></pre>

<p>Passing a pointer is no different. Making changes to the pointer in your function is not going to change it in the calling function so you have to pass a pointer to the pointer. This is why your second code example works.</p>
",4
